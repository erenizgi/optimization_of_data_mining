{
    "author": "orrzohar",
    "message": "SmolVLM2 (#36126)\n\n* smolvlm init\n\n* updates\n\n* fixing bugs\n\n* minimal run, no checks\n\n* minimal run, no checks\n\n* passing first check + adding url support\n\n* updating video dataloading logic\n\n* fixing image logic\n\n* trying modular, but fails\n\n* modular is working, changing processor to match PR comments and general transformers logic\n\n* fixing kwargs\n\n* offloading video loading logic to  image_util\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* fixing circleci code formatting errors\n\n* update\n\n* add idefics3-based tests\n\n* add keyword to all\n\n* add PreTrainedModel\n\n* updateing video loading logic\n\n* working inference\n\n* updates for PR comments\n\n* updates for PR comments\n\n* moving SmolVLMPretrainedModel higher to fix import error\n\n* CI test pass\n\n* CI test pass\n\n* removing lambda\n\n* CI test pass\n\n* CI test pass\n\n* CI test pass\n\n* CI test pass\n\n* CI test pass\n\n* CI test pass\n\n* processor tests\n\n* add example in docs\n\n* typo\n\n* fix copies\n\n* skip compile tests - sdpa for VisionTransformer\n\n* fix init\n\n* raise import error for num2words\n\n* update doc for FA2\n\n* more doc fix\n\n* CI\n\n* updates for PR comments\n\n* Update docs/source/en/model_doc/smolvlm.md\n\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\n\n* Update docs/source/en/model_doc/smolvlm.md\n\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\n\n* Update docs/source/en/model_doc/smolvlm.md\n\nCo-authored-by: Joshua Lochner <admin@xenova.com>\n\n* Update docs/source/en/model_doc/smolvlm.md\n\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\n\n* Update docs/source/en/model_doc/smolvlm.md\n\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\n\n* fixing processor -- tokenizer not defined properly, (gpt2 tokenizer), and does not have the attributes of fake image token, etc\n\n* adding smolvlm to VQA models\n\n* removing vqa auto class\n\n* Update src/transformers/models/smolvlm/processing_smolvlm.py\n\nCo-authored-by: Joshua Lochner <admin@xenova.com>\n\n* removing smolvlmvisiontransformer from index.md\n\n* my bad, video processing had typos\n\n* fixing docs\n\n* renaming params in SmolVLMModel.inputs_merger\n\n* removing un-needed dtype/device in model forward\n\n* ruff for CI\n\n* update docs\n\n* Update docs/source/en/model_doc/smolvlm.md\n\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\n\n* return cache position\n\n* return cache position\n\n* return cache also in modular\n\n* needed to run modular again\n\n* fix training tests\n\n* push vectorized inputs merger\n\n* format\n\n* format\n\n* reduce number of mappings\n\n* addressing PR comments\n\n* happy CI, happy me :)\n\n* skip non-nested images\n\n* adjust integration test for smaller GPUs\n\n* format\n\n* fix kwargs in chat template apply\n\n* skip this for now\n\n---------\n\nCo-authored-by: raushan <raushan@huggingface.co>\nCo-authored-by: Pablo <pablo.montalvo.leroux@gmail.com>\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\nCo-authored-by: Joshua Lochner <admin@xenova.com>",
    "sha": "4397dfcb7107508ab1ff1a8f644f248b84a9e912",
    "files": [
        {
            "sha": "6a168e9905baa78788832c2236d80b8aaa4bf48e",
            "filename": "docs/source/en/index.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/docs%2Fsource%2Fen%2Findex.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/docs%2Fsource%2Fen%2Findex.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Findex.md?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -317,6 +317,7 @@ Flax), PyTorch, and/or TensorFlow.\n |                           [SEW](model_doc/sew)                           |       ‚úÖ        |         ‚ùå         |      ‚ùå      |\n |                         [SEW-D](model_doc/sew-d)                         |       ‚úÖ        |         ‚ùå         |      ‚ùå      |\n |                        [SigLIP](model_doc/siglip)                        |       ‚úÖ        |         ‚ùå         |      ‚ùå      |\n+|                       [SmolVLM](model_doc/smolvlm)                       |       ‚úÖ        |         ‚ùå         |      ‚ùå      |\n |        [Speech Encoder decoder](model_doc/speech-encoder-decoder)        |       ‚úÖ        |         ‚ùå         |      ‚úÖ      |\n |                 [Speech2Text](model_doc/speech_to_text)                  |       ‚úÖ        |         ‚úÖ         |      ‚ùå      |\n |                      [SpeechT5](model_doc/speecht5)                      |       ‚úÖ        |         ‚ùå         |      ‚ùå      |"
        },
        {
            "sha": "b883fd162b5a499441f99f82bee5ea9093a11a24",
            "filename": "docs/source/en/model_doc/smolvlm.md",
            "status": "added",
            "additions": 197,
            "deletions": 0,
            "changes": 197,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/docs%2Fsource%2Fen%2Fmodel_doc%2Fsmolvlm.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/docs%2Fsource%2Fen%2Fmodel_doc%2Fsmolvlm.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fsmolvlm.md?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -0,0 +1,197 @@\n+<!--Copyright 2025 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+‚ö†Ô∏è Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# SmolVLM\n+\n+## Overview\n+SmolVLM2 is an adaptation of the Idefics3 model with two main differences:\n+\n+- It uses SmolLM2 for the text model.\n+- It supports multi-image and video inputs\n+\n+## Usage tips\n+\n+Input images are processed either by upsampling (if resizing is enabled) or at their original resolution. The resizing behavior depends on two parameters: do_resize and size.\n+\n+Videos should not be upsampled. \n+\n+If `do_resize` is set to `True`, the model resizes images so that the longest edge is 4*512 pixels by default.\n+The default resizing behavior can be customized by passing a dictionary to the `size` parameter. For example, `{\"longest_edge\": 4 * 512}` is the default, but you can change it to a different value if needed.\n+\n+Here‚Äôs how to control resizing and set a custom size:\n+```python\n+image_processor = SmolVLMImageProcessor(do_resize=True, size={\"longest_edge\": 2 * 512}, max_image_size=512)\n+```\n+\n+Additionally, the `max_image_size` parameter, which controls the size of each square patch the image is decomposed into, is set to 512 by default but can be adjusted as needed. After resizing (if applicable), the image processor decomposes the images into square patches based on the `max_image_size` parameter.\n+\n+This model was contributed by [orrzohar](https://huggingface.co/orrzohar).\n+\n+\n+\n+## Usage example\n+\n+### Single Media inference\n+\n+The model can accept both images and videos as input, but you should use only one of the modalities at a time. Here's an example code for that.\n+\n+```python\n+import torch\n+from transformers import AutoProcessor, AutoModelForImageTextToText\n+\n+processor = AutoProcessor.from_pretrained(\"HuggingFaceTB/SmolVLM2-256M-Video-Instruct\")\n+model = AutoModelForImageTextToText.from_pretrained(\n+    \"HuggingFaceTB/SmolVLM2-256M-Video-Instruct\",\n+    torch_dtype=torch.bfloat16,\n+    device_map=\"cuda\"\n+)\n+\n+conversation = [\n+    {\n+        \"role\": \"user\",\n+        \"content\":[\n+            {\"type\": \"image\", \"url\": \"http://images.cocodataset.org/val2017/000000039769.jpg\"},\n+            {\"type\": \"text\", \"text\": \"Describe this image.\"}\n+        ]\n+    }\n+]\n+\n+inputs = processor.apply_chat_template(\n+    conversation,\n+    add_generation_prompt=True,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\",\n+).to(model.device, dtype=torch.bfloat16)\n+\n+output_ids = model.generate(**inputs, max_new_tokens=128)\n+generated_texts = processor.batch_decode(output_ids, skip_special_tokens=True)\n+print(generated_texts)\n+\n+\n+# Video\n+conversation = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"video\", \"path\": \"/path/to/video.mp4\"},\n+            {\"type\": \"text\", \"text\": \"Describe this video in detail\"}\n+        ]\n+    },\n+]\n+\n+inputs = processor.apply_chat_template(\n+    conversation,\n+    add_generation_prompt=True,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\",\n+).to(model.device, dtype=torch.bfloat16)\n+\n+generated_ids = model.generate(**inputs, do_sample=False, max_new_tokens=100)\n+generated_texts = processor.batch_decode(generated_ids, skip_special_tokens=True)\n+print(generated_texts[0])\n+```\n+\n+### Batch Mixed Media Inference\n+\n+The model can batch inputs composed of several images/videos and text. Here is an example.\n+\n+```python\n+import torch\n+from transformers import AutoProcessor, AutoModelForImageTextToText\n+\n+processor = AutoProcessor.from_pretrained(\"HuggingFaceTB/SmolVLM2-256M-Video-Instruct\")\n+model = AutoModelForImageTextToText.from_pretrained(\n+    \"HuggingFaceTB/SmolVLM2-256M-Video-Instruct\",\n+    torch_dtype=torch.bfloat16,\n+    device_map=\"cuda\"\n+)\n+\n+# Conversation for the first image\n+conversation1 = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\", \"path\": \"/path/to/image.jpg\"},\n+            {\"type\": \"text\", \"text\": \"Describe this image.\"}\n+        ]\n+    }\n+]\n+\n+# Conversation with two images\n+conversation2 = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\", \"path\": \"/path/to/image.jpg\"},\n+            {\"type\": \"image\", \"path\": \"/path/to/image.jpg\"},\n+            {\"type\": \"text\", \"text\": \"What is written in the pictures?\"}\n+        ]\n+    }\n+]\n+\n+# Conversation with pure text\n+conversation3 = [\n+    {\"role\": \"user\",\"content\": \"who are you?\"}\n+]\n+\n+\n+conversations = [conversation1, conversation2, conversation3]\n+inputs = processor.apply_chat_template(\n+    conversation,\n+    add_generation_prompt=True,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\",\n+).to(model.device, dtype=torch.bfloat16)\n+\n+generated_ids = model.generate(**inputs, do_sample=False, max_new_tokens=100)\n+generated_texts = processor.batch_decode(generated_ids, skip_special_tokens=True)\n+print(generated_texts[0])\n+```\n+\n+## SmolVLMConfig\n+\n+[[autodoc]] SmolVLMConfig\n+\n+## SmolVLMVisionConfig\n+\n+[[autodoc]] SmolVLMVisionConfig\n+\n+## Idefics3VisionTransformer\n+\n+[[autodoc]] SmolVLMVisionTransformer\n+\n+## SmolVLMModel\n+\n+[[autodoc]] SmolVLMModel\n+    - forward\n+\n+## SmolVLMForConditionalGeneration\n+\n+[[autodoc]] SmolVLMForConditionalGeneration\n+    - forward\n+\n+\n+## SmolVLMImageProcessor\n+[[autodoc]] SmolVLMImageProcessor\n+    - preprocess\n+\n+\n+## SmolVLMProcessor\n+[[autodoc]] SmolVLMProcessor\n+    - __call__"
        },
        {
            "sha": "b8896114eccb8be7788dbc936d46e3bc5ad87604",
            "filename": "docs/source/en/perf_infer_gpu_one.md",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -95,6 +95,7 @@ FlashAttention-2 is currently supported for the following architectures:\n * [PhiMoE](https://huggingface.co/docs/transformers/model_doc/phimoe#transformers.PhimoeModel)\n * [StableLm](https://huggingface.co/docs/transformers/model_doc/stablelm#transformers.StableLmModel)\n * [Starcoder2](https://huggingface.co/docs/transformers/model_doc/starcoder2#transformers.Starcoder2Model)\n+* [SmolVLM](https://huggingface.co/docs/transformers/model_doc/smolvlm#transformers.SmolVLMModel)\n * [Qwen2](https://huggingface.co/docs/transformers/model_doc/qwen2#transformers.Qwen2Model)\n * [Qwen2Audio](https://huggingface.co/docs/transformers/model_doc/qwen2_audio#transformers.Qwen2AudioEncoder)\n * [Qwen2MoE](https://huggingface.co/docs/transformers/model_doc/qwen2_moe#transformers.Qwen2MoeModel)\n@@ -301,6 +302,7 @@ For now, Transformers supports SDPA inference and training for the following arc\n * [Mixtral](https://huggingface.co/docs/transformers/model_doc/mixtral#transformers.MixtralModel)\n * [StableLm](https://huggingface.co/docs/transformers/model_doc/stablelm#transformers.StableLmModel)\n * [Starcoder2](https://huggingface.co/docs/transformers/model_doc/starcoder2#transformers.Starcoder2Model)\n+* [SmolVLM](https://huggingface.co/docs/transformers/model_doc/smolvlm#transformers.SmolVLMModel)\n * [Qwen2](https://huggingface.co/docs/transformers/model_doc/qwen2#transformers.Qwen2Model)\n * [Qwen2Audio](https://huggingface.co/docs/transformers/model_doc/qwen2_audio#transformers.Qwen2AudioEncoder)\n * [Qwen2MoE](https://huggingface.co/docs/transformers/model_doc/qwen2_moe#transformers.Qwen2MoeModel)"
        },
        {
            "sha": "0c9c6025def71458e3944d0f2e083f707819cc09",
            "filename": "scripts/deberta_scrtipt.py",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/scripts%2Fdeberta_scrtipt.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/scripts%2Fdeberta_scrtipt.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/scripts%2Fdeberta_scrtipt.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -1,7 +1,10 @@\n-import torch\n-from transformers import pipeline, AutoTokenizer, AutoModel, AutoModelForMaskedLM\n import time\n \n+import torch\n+\n+from transformers import AutoModel, AutoTokenizer, pipeline\n+\n+\n test_sentence = 'Do you [MASK] the muffin man?'\n \n # for comparison"
        },
        {
            "sha": "dc427aad5727cd0f68200442b90bcb01e3f6fd16",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -776,6 +776,7 @@\n         \"SiglipTextConfig\",\n         \"SiglipVisionConfig\",\n     ],\n+    \"models.smolvlm\": [\"SmolVLMConfig\"],\n     \"models.speech_encoder_decoder\": [\"SpeechEncoderDecoderConfig\"],\n     \"models.speech_to_text\": [\n         \"Speech2TextConfig\",\n@@ -1288,6 +1289,7 @@\n     _import_structure[\"models.segformer\"].extend([\"SegformerFeatureExtractor\", \"SegformerImageProcessor\"])\n     _import_structure[\"models.seggpt\"].extend([\"SegGptImageProcessor\"])\n     _import_structure[\"models.siglip\"].append(\"SiglipImageProcessor\")\n+    _import_structure[\"models.smolvlm\"].extend([\"SmolVLMImageProcessor\"])\n     _import_structure[\"models.superglue\"].extend([\"SuperGlueImageProcessor\"])\n     _import_structure[\"models.superpoint\"].extend([\"SuperPointImageProcessor\"])\n     _import_structure[\"models.swin2sr\"].append(\"Swin2SRImageProcessor\")\n@@ -3557,6 +3559,16 @@\n             \"SiglipVisionModel\",\n         ]\n     )\n+    _import_structure[\"models.smolvlm\"].extend(\n+        [\n+            \"SmolVLMForConditionalGeneration\",\n+            \"SmolVLMModel\",\n+            \"SmolVLMPreTrainedModel\",\n+            \"SmolVLMProcessor\",\n+            \"SmolVLMVisionConfig\",\n+            \"SmolVLMVisionTransformer\",\n+        ]\n+    )\n     _import_structure[\"models.speech_encoder_decoder\"].extend([\"SpeechEncoderDecoderModel\"])\n     _import_structure[\"models.speech_to_text\"].extend(\n         [\n@@ -5930,6 +5942,7 @@\n         SiglipTextConfig,\n         SiglipVisionConfig,\n     )\n+    from .models.smolvlm import SmolVLMConfig\n     from .models.speech_encoder_decoder import SpeechEncoderDecoderConfig\n     from .models.speech_to_text import (\n         Speech2TextConfig,\n@@ -6459,6 +6472,7 @@\n         from .models.segformer import SegformerFeatureExtractor, SegformerImageProcessor\n         from .models.seggpt import SegGptImageProcessor\n         from .models.siglip import SiglipImageProcessor\n+        from .models.smolvlm import SmolVLMImageProcessor\n         from .models.superglue import SuperGlueImageProcessor\n         from .models.superpoint import SuperPointImageProcessor\n         from .models.swin2sr import Swin2SRImageProcessor\n@@ -8274,6 +8288,14 @@\n             SiglipTextModel,\n             SiglipVisionModel,\n         )\n+        from .models.smolvlm import (\n+            SmolVLMForConditionalGeneration,\n+            SmolVLMModel,\n+            SmolVLMPreTrainedModel,\n+            SmolVLMProcessor,\n+            SmolVLMVisionConfig,\n+            SmolVLMVisionTransformer,\n+        )\n         from .models.speech_encoder_decoder import SpeechEncoderDecoderModel\n         from .models.speech_to_text import (\n             Speech2TextForConditionalGeneration,"
        },
        {
            "sha": "d08b138d9b6c5b35f2da6b86330110110e4f94c5",
            "filename": "src/transformers/image_utils.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fimage_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fimage_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fimage_utils.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -843,7 +843,7 @@ def sample_indices_fn_func(metadata, **fn_kwargs):\n         file_obj = BytesIO(requests.get(video).content)\n     elif os.path.isfile(video):\n         file_obj = video\n-    elif is_valid_image(video) or (isinstance(video, (list, tuple) and is_valid_image(video[0]))):\n+    elif is_valid_image(video) or (isinstance(video, (list, tuple)) and is_valid_image(video[0])):\n         file_obj = None\n     else:\n         raise TypeError(\"Incorrect format used for video. Should be an url linking to an video or a local path.\")"
        },
        {
            "sha": "220f5dfa59c60d9ba5562135c391cc32ff9b226a",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -245,6 +245,7 @@\n     sew,\n     sew_d,\n     siglip,\n+    smolvlm,\n     speech_encoder_decoder,\n     speech_to_text,\n     speecht5,"
        },
        {
            "sha": "7e81e41006a68829d2a087e3707c628b20defa1e",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -272,6 +272,8 @@\n         (\"sew-d\", \"SEWDConfig\"),\n         (\"siglip\", \"SiglipConfig\"),\n         (\"siglip_vision_model\", \"SiglipVisionConfig\"),\n+        (\"smolvlm\", \"SmolVLMConfig\"),\n+        (\"smolvlm_vision\", \"SmolVLMVisionConfig\"),\n         (\"speech-encoder-decoder\", \"SpeechEncoderDecoderConfig\"),\n         (\"speech_to_text\", \"Speech2TextConfig\"),\n         (\"speech_to_text_2\", \"Speech2Text2Config\"),\n@@ -616,6 +618,8 @@\n         (\"sew-d\", \"SEW-D\"),\n         (\"siglip\", \"SigLIP\"),\n         (\"siglip_vision_model\", \"SiglipVisionModel\"),\n+        (\"smolvlm\", \"SmolVLM\"),\n+        (\"smolvlm_vision\", \"SmolVLMVisionTransformer\"),\n         (\"speech-encoder-decoder\", \"Speech Encoder decoder\"),\n         (\"speech_to_text\", \"Speech2Text\"),\n         (\"speech_to_text_2\", \"Speech2Text2\"),\n@@ -741,6 +745,7 @@\n         (\"aria_text\", \"aria\"),\n         (\"idefics3_vision\", \"idefics3\"),\n         (\"siglip_vision_model\", \"siglip\"),\n+        (\"smolvlm_vision\", \"smolvlm\"),\n         (\"chinese_clip_vision_model\", \"chinese_clip\"),\n         (\"rt_detr_resnet\", \"rt_detr\"),\n         (\"granitevision\", \"llava_next\"),"
        },
        {
            "sha": "8fbe1b6c0d68cf8040aef93f7a061d8fc6d6309a",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -251,6 +251,8 @@\n         (\"sew-d\", \"SEWDModel\"),\n         (\"siglip\", \"SiglipModel\"),\n         (\"siglip_vision_model\", \"SiglipVisionModel\"),\n+        (\"smolvlm\", \"SmolVLMModel\"),\n+        (\"smolvlm_vision\", \"SmolVLMVisionTransformer\"),\n         (\"speech_to_text\", \"Speech2TextModel\"),\n         (\"speecht5\", \"SpeechT5Model\"),\n         (\"splinter\", \"SplinterModel\"),\n@@ -835,6 +837,7 @@\n         (\"pixtral\", \"LlavaForConditionalGeneration\"),\n         (\"qwen2_5_vl\", \"Qwen2_5_VLForConditionalGeneration\"),\n         (\"qwen2_vl\", \"Qwen2VLForConditionalGeneration\"),\n+        (\"smolvlm\", \"SmolVLMForConditionalGeneration\"),\n         (\"udop\", \"UdopForConditionalGeneration\"),\n         (\"vipllava\", \"VipLlavaForConditionalGeneration\"),\n         (\"vision-encoder-decoder\", \"VisionEncoderDecoderModel\"),"
        },
        {
            "sha": "31d97ffa70eccdeafaf00c27c3b04fe15152e4d4",
            "filename": "src/transformers/models/idefics3/modeling_idefics3.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fidefics3%2Fmodeling_idefics3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fidefics3%2Fmodeling_idefics3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fidefics3%2Fmodeling_idefics3.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -22,12 +22,12 @@\n from torch import nn\n from torch.nn import CrossEntropyLoss\n \n-from ... import PreTrainedModel\n from ...activations import ACT2FN\n from ...cache_utils import Cache, DynamicCache\n from ...generation import GenerationMixin\n from ...modeling_attn_mask_utils import _prepare_4d_attention_mask\n from ...modeling_outputs import BaseModelOutput, ModelOutput\n+from ...modeling_utils import PreTrainedModel\n from ...utils import (\n     add_start_docstrings,\n     add_start_docstrings_to_model_forward,"
        },
        {
            "sha": "706c9928300f408dbae61df4ccd17879d1f53fdf",
            "filename": "src/transformers/models/smolvlm/__init__.py",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fsmolvlm%2F__init__.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -0,0 +1,29 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_smolvlm import *\n+    from .image_processing_smolvlm import *\n+    from .modeling_smolvlm import *\n+    from .processing_smolvlm import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "f4a42f348de4f3f5ffc4043c0c11eb9c46cb8f7c",
            "filename": "src/transformers/models/smolvlm/configuration_smolvlm.py",
            "status": "added",
            "additions": 197,
            "deletions": 0,
            "changes": 197,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fconfiguration_smolvlm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fconfiguration_smolvlm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fconfiguration_smolvlm.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -0,0 +1,197 @@\n+#                üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®\n+#           This file was automatically generated from src/transformers/models/smolvlm/modular_smolvlm.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_smolvlm.py file directly. One of our CI enforces this.\n+#                üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Inc. team. All rights reserved.\n+# Written by Orr Zohar\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...utils import logging\n+from ..auto import CONFIG_MAPPING, AutoConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class SmolVLMVisionConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`SmolVLMVisionModel`]. It is used to instantiate a\n+    SmolVLM vision encoder according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the SigLIP checkpoint\n+    [google/siglip-so400m-patch14-384](https://huggingface.co/google/siglip-so400m-patch14-384) used in SmolVLM\n+    [HuggingFaceTB/SmolVLM2-2.2B-Instruct](https://huggingface.co/HuggingFaceTB/SmolVLM2-2.2B-Instruct).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 1152):\n+            Dimensionality of the encoder layers and the pooler layer.\n+        intermediate_size (`int`, *optional*, defaults to 3072):\n+            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+        num_hidden_layers (`int`, *optional*, defaults to 12):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_channels (`int`, *optional*, defaults to 3):\n+            Number of channels in the input images.\n+        image_size (`int`, *optional*, defaults to 224):\n+            The size (resolution) of each image.\n+        patch_size (`int`, *optional*, defaults to 32):\n+            The size (resolution) of each patch.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"gelu_pytorch_tanh\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+            `\"relu\"`, `\"selu\"` and `\"gelu_new\"` `\"quick_gelu\"` are supported.\n+        layer_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the layer normalization layers.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers.models.smolvlm.modeling_smolvlm import SmolVLMVisionTransformer\n+    >>> from transformers.models.smolvlm.configuration_smolvlm import SmolVLMVisionConfig\n+\n+    >>> # Initializing a SmolVLMVisionConfig with google/siglip-so400m-patch14-384 style configuration\n+    >>> configuration = SmolVLMVisionConfig()\n+\n+    >>> # Initializing a SmolVLMVisionTransformer (with random weights) from the google/siglip-so400m-patch14-384 style configuration\n+    >>> model = SmolVLMVisionTransformer(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"smolvlm_vision\"\n+    base_config_key = \"vision_config\"\n+\n+    def __init__(\n+        self,\n+        hidden_size=1152,\n+        intermediate_size=3072,\n+        num_hidden_layers=12,\n+        num_attention_heads=16,\n+        num_channels=3,\n+        image_size=224,\n+        patch_size=32,\n+        hidden_act=\"gelu_pytorch_tanh\",\n+        layer_norm_eps=1e-6,\n+        attention_dropout=0.0,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.num_channels = num_channels\n+        self.patch_size = patch_size\n+        self.image_size = image_size\n+        self.attention_dropout = attention_dropout\n+        self.layer_norm_eps = layer_norm_eps\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+\n+\n+class SmolVLMConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`SmolVLMModel`]. It is used to instantiate a\n+    SmolVLM model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the model of the SmolVLM\n+    [HuggingFaceTB/SmolVLM2-2.2B-Instruct](https://huggingface.co/HuggingFaceTB/SmolVLM2-2.2B-Instruct) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should cache the key/value pairs of the attention mechanism. Only\n+            relevant if `config.is_decoder=True`.\n+        image_token_id (`int`, *optional*, defaults to 128257):\n+            The id of the \"image\" token.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether or not to tie the word embeddings with the token embeddings.\n+        vision_config (`IdeficsVisionConfig` or `dict`, *optional*, defaults to `IdeficsVisionConfig`):\n+            Custom vision config or dict for the vision tower\n+        text_config (`PretrainedConfig` or `dict`, *optional*, defaults to `LlamaConfig`):\n+            Custom text config or dict for the text model\n+        scale_factor (`int`, *optional*, defaults to 2):\n+            The scale factor for the image encoder.\n+        pad_token_id (`int`, *optional*, defaults to 128002):\n+            The id of the padding token.\n+\n+    Example:\n+    ```python\n+    >>> from transformers import SmolVLMModel, SmolVLMConfig\n+    >>> # Initializing configuration\n+    >>> configuration = SmolVLMConfig()\n+    >>> # Initializing a model from the configuration\n+    >>> model = SmolVLMModel(configuration)\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"smolvlm\"\n+    sub_configs = {\"text_config\": AutoConfig, \"vision_config\": SmolVLMVisionConfig}\n+\n+    def __init__(\n+        self,\n+        use_cache=True,\n+        image_token_id=128257,\n+        tie_word_embeddings=False,\n+        vision_config=None,\n+        text_config=None,\n+        scale_factor=2,\n+        pad_token_id=128_002,\n+        **kwargs,\n+    ):\n+        self.image_token_id = image_token_id\n+        self.use_cache = use_cache\n+        self.tie_word_embeddings = tie_word_embeddings\n+\n+        if vision_config is None:\n+            self.vision_config = SmolVLMVisionConfig()\n+            logger.info(\"vision_config is None, using default vision config\")\n+        elif isinstance(vision_config, dict):\n+            self.vision_config = SmolVLMVisionConfig(**vision_config)\n+        elif isinstance(vision_config, SmolVLMVisionConfig):\n+            self.vision_config = vision_config\n+\n+        if isinstance(text_config, dict):\n+            text_config[\"model_type\"] = text_config[\"model_type\"] if \"model_type\" in text_config else \"llama\"\n+            text_config = CONFIG_MAPPING[text_config[\"model_type\"]](**text_config)\n+        elif text_config is None:\n+            logger.info(\"text_config is None, using default text config\")\n+            text_config = CONFIG_MAPPING[\"llama\"](\n+                rms_norm_eps=1e-5,\n+                pad_token_id=pad_token_id,\n+                tie_word_embeddings=False,\n+            )\n+\n+        self.text_config = text_config\n+        self.scale_factor = scale_factor\n+\n+        super().__init__(**kwargs, pad_token_id=pad_token_id, tie_word_embeddings=tie_word_embeddings)\n+\n+\n+__all__ = [\"SmolVLMVisionConfig\", \"SmolVLMConfig\"]"
        },
        {
            "sha": "93ed18d13449b519f5ef238340aacb166728cc0a",
            "filename": "src/transformers/models/smolvlm/image_processing_smolvlm.py",
            "status": "added",
            "additions": 851,
            "deletions": 0,
            "changes": 851,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fimage_processing_smolvlm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fimage_processing_smolvlm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fimage_processing_smolvlm.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -0,0 +1,851 @@\n+#                üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®\n+#           This file was automatically generated from src/transformers/models/smolvlm/modular_smolvlm.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_smolvlm.py file directly. One of our CI enforces this.\n+#                üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Inc. team. All rights reserved.\n+# Written by Orr Zohar\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import math\n+from typing import Dict, Iterable, List, Optional, Tuple, Union\n+\n+import numpy as np\n+\n+from ...image_processing_utils import BaseImageProcessor, BatchFeature\n+from ...image_transforms import PaddingMode, pad, to_channel_dimension_format, to_pil_image\n+from ...image_utils import (\n+    IMAGENET_STANDARD_MEAN,\n+    IMAGENET_STANDARD_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    is_scaled_image,\n+    make_nested_list_of_images,\n+    to_numpy_array,\n+    valid_images,\n+    validate_preprocess_arguments,\n+)\n+from ...utils import TensorType, is_vision_available, logging\n+\n+\n+if is_vision_available():\n+    import PIL\n+    from PIL import Image\n+\n+\n+logger = logging.get_logger(__name__)\n+MAX_IMAGE_SIZE = 4096  # 4k resolution as absolute maximum\n+\n+\n+def _resize_output_size_rescale_to_max_len(\n+    height: int, width: int, min_len: Optional[int] = 1, max_len: Optional[int] = None\n+) -> Tuple[int, int]:\n+    \"\"\"\n+    Get the output size of the image after resizing given a dictionary specifying the max and min sizes.\n+    Args:\n+        height (`int`):\n+            Height of the input image.\n+        width (`int`):\n+            Width of the input image.\n+        min_len (`int`, *optional*, defaults to 1):\n+            Minimum size of the output image.\n+        max_len (`int`, *optional*, defaults to the maximum size of the image):\n+            Maximum size of the output image.\n+    Returns:\n+        The output size of the image after resizing.\n+    \"\"\"\n+    max_len = max(height, width) if max_len is None else max_len\n+    aspect_ratio = width / height\n+\n+    if width >= height:\n+        width = max_len\n+        height = int(width / aspect_ratio)\n+        if height % 2 != 0:\n+            height += 1\n+    elif height > width:\n+        height = max_len\n+        width = int(height * aspect_ratio)\n+        if width % 2 != 0:\n+            width += 1\n+\n+    # Avoid resizing to a size smaller than min_len\n+    height = max(height, min_len)\n+    width = max(width, min_len)\n+    return height, width\n+\n+\n+def _resize_output_size_scale_below_upper_bound(\n+    height: int, width: int, max_len: Optional[Dict[str, int]] = None\n+) -> Tuple[int, int]:\n+    \"\"\"\n+    Get the output size of the image after resizing given a dictionary specifying the max and min sizes.\n+    Args:\n+        height (`int`):\n+            Height of the input image.\n+        width (`int`):\n+            Width of the input image.\n+        max_len (`Dict[str, int]`, *optional*, defaults to the maximum size of the image):\n+            Defines the maximum dimensions of the image.\n+    Returns:\n+        The output size of the image after resizing.\n+    \"\"\"\n+    max_len = max(height, width) if max_len is None else max_len\n+\n+    aspect_ratio = width / height\n+    if width >= height and width > max_len:\n+        width = max_len\n+        height = int(width / aspect_ratio)\n+    elif height > width and height > max_len:\n+        height = max_len\n+        width = int(height * aspect_ratio)\n+\n+    # Avoid resizing to a size smaller than 1\n+    height = max(height, 1)\n+    width = max(width, 1)\n+    return height, width\n+\n+\n+def get_resize_output_image_size(\n+    image,\n+    resolution_max_side: int,\n+    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+) -> Tuple[int, int]:\n+    \"\"\"\n+    Get the output size of the image after resizing given a dictionary specifying the max and min sizes.\n+    Args:\n+        image (`np.ndarray`):\n+            Image to resize.\n+        resolution_max_side (`int`):\n+            The longest edge of the image will be resized to this value. The shortest edge will be resized to keep the\n+            input aspect ratio.\n+        input_data_format (`ChannelDimension` or `str`):\n+            The channel dimension format of the input image.\n+    Returns:\n+        The output size of the image after resizing.\n+    \"\"\"\n+    height, width = get_image_size(image, channel_dim=input_data_format)\n+\n+    # Find the output size, when rescaling the longest edge to max_len and preserving the aspect ratio\n+    height, width = _resize_output_size_rescale_to_max_len(height, width, max_len=resolution_max_side)\n+    # Find the output size when scaling the image to be below the MAX_IMAGE_SIZE\n+    height, width = _resize_output_size_scale_below_upper_bound(height, width, max_len=MAX_IMAGE_SIZE)\n+    return height, width\n+\n+\n+def get_max_height_width(\n+    images_list: List[List[np.ndarray]], input_data_format: Optional[Union[str, ChannelDimension]] = None\n+) -> List[int]:\n+    \"\"\"\n+    Get the maximum height and width across all images in a batch.\n+    \"\"\"\n+    if input_data_format is None:\n+        input_data_format = infer_channel_dimension_format(images_list[0][0], num_channels=(1, 3, 4))\n+\n+    max_height = max_width = float(\"-inf\")\n+    for images in images_list:\n+        for image in images:\n+            height, width = get_image_size(image, channel_dim=input_data_format)\n+            max_height = max(height, max_height)\n+            max_width = max(width, max_width)\n+    return (max_height, max_width)\n+\n+\n+def make_pixel_mask(\n+    image: np.ndarray, output_size: Tuple[int, int], input_data_format: Optional[Union[str, ChannelDimension]] = None\n+) -> np.ndarray:\n+    \"\"\"\n+    Make a pixel mask for the image, where 1 indicates a valid pixel and 0 indicates padding.\n+    Args:\n+        image (`np.ndarray`):\n+            Image to make the pixel mask for.\n+        output_size (`Tuple[int, int]`):\n+            Output size of the mask.\n+    \"\"\"\n+    input_height, input_width = get_image_size(image, channel_dim=input_data_format)\n+    mask = np.zeros(output_size, dtype=np.int64)\n+    mask[:input_height, :input_width] = 1\n+    return mask\n+\n+\n+def convert_to_rgb(\n+    image: np.ndarray,\n+    palette: Optional[PIL.ImagePalette.ImagePalette] = None,\n+    data_format: Optional[Union[str, ChannelDimension]] = None,\n+    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+) -> ImageInput:\n+    \"\"\"\n+    Converts an image to RGB format.\n+    Args:\n+        image (`np.ndarray`):\n+            The image to convert.\n+        palette (List[int], *optional*):\n+            The palette to use if given.\n+        data_format (ChannelDimension or str, *optional*):\n+            The channel dimension format for the output image. If not provided, it will be the same as the input image.\n+        input_data_format (ChannelDimension or str, *optional*):\n+            The channel dimension format of the input image.\n+    \"\"\"\n+    if input_data_format is None:\n+        input_data_format = infer_channel_dimension_format(image, num_channels=(1, 3, 4))\n+\n+    # For all transformations, we want to keep the same data format as the input image unless otherwise specified.\n+    # The resized image from PIL will always have channels last, so find the input format first.\n+    data_format = input_data_format if data_format is None else data_format\n+\n+    mode = \"P\" if palette is not None else None\n+    image = to_pil_image(image, image_mode=mode, input_data_format=input_data_format)\n+    if image.mode == \"P\" and palette is not None:\n+        image.putpalette(palette)\n+\n+    image_rgba = image.convert(\"RGBA\")\n+    background = Image.new(\"RGBA\", image_rgba.size, (255, 255, 255))\n+    alpha_composite = Image.alpha_composite(background, image_rgba)\n+    alpha_composite = alpha_composite.convert(\"RGB\")\n+\n+    output_array = np.array(alpha_composite)\n+    # The image is always in channels last format after converting from a PIL image\n+    output_array = to_channel_dimension_format(output_array, data_format, input_channel_dim=ChannelDimension.LAST)\n+    return output_array\n+\n+\n+# FIXME Amy: make a more general crop function that isn't just centre crop\n+def _crop(\n+    image: np.ndarray,\n+    w1: int,\n+    h1: int,\n+    w2: int,\n+    h2: int,\n+    data_format: Optional[Union[str, ChannelDimension]] = None,\n+) -> np.ndarray:\n+    if data_format is None:\n+        data_format = infer_channel_dimension_format(image, num_channels=(1, 3, 4))\n+\n+    if data_format == ChannelDimension.FIRST:\n+        image = image[:, h1:h2, w1:w2]\n+    elif data_format == ChannelDimension.LAST:\n+        image = image[h1:h2, w1:w2, :]\n+    else:\n+        raise ValueError(\"Invalid channel dimension format.\")\n+\n+    return image\n+\n+\n+class SmolVLMImageProcessor(BaseImageProcessor):\n+    r\"\"\"\n+    Constructs a SmolVLM image processor.\n+    Args:\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB. This is useful if the input image is of a different format e.g. RGBA.\n+            Only has an effect if the input image is in the PIL format.\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image. The longest edge of the image is resized to  be <= `size[\"longest_edge\"]`, with the\n+            shortest edge resized to keep the input aspect ratio.\n+        size (`Dict`, *optional*, defaults to `{\"longest_edge\": 4 * 364}`):\n+            Controls the size of the output image. This is a dictionary containing the key \"longest_edge\".\n+            The image will be resized such that the longest edge is <= `size[\"longest_edge\"]` and the shortest edge is resized\n+            to keep the input aspect ratio.\n+        resample (`Resampling`, *optional*, defaults to `Resampling.LANCZOS`):\n+            Resampling filter to use when resizing the image.\n+        do_image_splitting (`bool`, *optional*, defaults to `True`):\n+            Whether to split the image into sub-images concatenated with the original image. They are split into patches\n+            such that each patch has a size of `max_image_size[\"height\"]` x `max_image_size[\"width\"]`.\n+        max_image_size (`Dict`, *optional*, defaults to `{\"longest_edge\": 364}`):\n+            Maximum resolution of the patches of images accepted by the model. This is a dictionary containing the key \"longest_edge\".\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image. If set to `True`, the image is rescaled to have pixel values between 0 and 1.\n+        rescale_factor (`float`, *optional*, defaults to `1/255`):\n+            Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image. If set to `True`, the image is normalized to have a mean of `image_mean` and\n+            a standard deviation of `image_std`.\n+        image_mean (`float` or `List[float]`, *optional*, defaults to `IDEFICS_STANDARD_MEAN`):\n+            Mean to use if normalizing the image. This is a float or list of floats the length of the number of\n+            channels in the image. Can be overridden by the `image_mean` parameter in the `preprocess` method. Can be\n+            overridden by the `image_mean` parameter in the `preprocess` method.\n+        image_std (`float` or `List[float]`, *optional*, defaults to `IDEFICS_STANDARD_STD`):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats the length of the\n+            number of channels in the image. Can be overridden by the `image_std` parameter in the `preprocess` method.\n+            Can be overridden by the `image_std` parameter in the `preprocess` method.\n+        do_pad (`bool`, *optional*, defaults to `True`):\n+            Whether or not to pad the images to the largest height and width in the batch and number of images per\n+            sample in the batch, such that the returned tensor is of shape (batch_size, max_num_images, num_channels, max_height, max_width).\n+    \"\"\"\n+\n+    model_input_names = [\"pixel_values\", \"pixel_attention_mask\"]\n+\n+    def __init__(\n+        self,\n+        do_convert_rgb: bool = True,\n+        do_resize: bool = True,\n+        size: Dict[str, int] = None,\n+        resample: PILImageResampling = PILImageResampling.LANCZOS,\n+        do_image_splitting: bool = True,\n+        max_image_size: Dict[str, int] = None,\n+        do_rescale: bool = True,\n+        rescale_factor: float = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_pad: bool = True,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        self.do_convert_rgb = do_convert_rgb\n+        self.do_resize = do_resize\n+        self.size = size if size is not None else {\"longest_edge\": 4 * 364}\n+        self.resample = resample\n+        self.do_image_splitting = do_image_splitting\n+        self.max_image_size = max_image_size if max_image_size is not None else {\"longest_edge\": 364}\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean if image_mean is not None else IMAGENET_STANDARD_MEAN\n+        self.image_std = image_std if image_std is not None else IMAGENET_STANDARD_STD\n+        self.do_pad = do_pad\n+\n+    def resize(\n+        self,\n+        image: np.ndarray,\n+        size: Dict[str, int],\n+        resample: PILImageResampling = PILImageResampling.LANCZOS,\n+        data_format: Optional[Union[str, ChannelDimension]] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+        **kwargs,\n+    ) -> np.ndarray:\n+        \"\"\"\n+        Resize an image. The longest edge of the image is resized to size[\"longest_edge\"], with the shortest edge\n+        resized to keep the input aspect ratio. Can also be used with size[\"height\"] and size[\"width\"].\n+        Args:\n+            image (`np.ndarray`):\n+                Image to resize.\n+            size (`Dict[str, int]`):\n+                Size of the output image.\n+            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.LANCZOS`):\n+                Resampling filter to use when resizing the image.\n+            data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the output image. If not provided, it will be the same as the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the input image. If not provided, it will be inferred.\n+        \"\"\"\n+        if input_data_format is None:\n+            input_data_format = infer_channel_dimension_format(image, num_channels=(1, 3, 4))\n+\n+        # For all transformations, we want to keep the same data format as the input image unless otherwise specified.\n+        # The resized image from PIL will always have channels last, so find the input format first.\n+        data_format = input_data_format if data_format is None else data_format\n+\n+        if \"longest_edge\" in size:\n+            size = get_resize_output_image_size(\n+                image, resolution_max_side=size[\"longest_edge\"], input_data_format=input_data_format\n+            )\n+        elif \"height\" in size and \"width\" in size:\n+            size = (size[\"height\"], size[\"width\"])\n+        else:\n+            raise ValueError(\"size must be a dictionary with key 'longest_edge' or 'height' and 'width'.\")\n+\n+        image_mode = None\n+        if image.ndim == 2 or image.shape[-1] == 1:\n+            image_mode = \"P\"\n+        image = to_pil_image(image, image_mode=image_mode, input_data_format=input_data_format)\n+\n+        resized_image = image.resize((size[1], size[0]), resample=resample)\n+        resized_image = np.array(resized_image)\n+\n+        # If the input image channel dimension was of size 1, then it is dropped when converting to a PIL image\n+        # so we need to add it back if necessary.\n+        resized_image = np.expand_dims(resized_image, axis=-1) if resized_image.ndim == 2 else resized_image\n+        # The image is always in channels last format after converting from a PIL image\n+        resized_image = to_channel_dimension_format(\n+            resized_image, data_format, input_channel_dim=ChannelDimension.LAST\n+        )\n+        return resized_image\n+\n+    def split_image(\n+        self,\n+        image,\n+        max_image_size: Dict[str, int],\n+        resample: PILImageResampling = PILImageResampling.LANCZOS,\n+        data_format: Optional[Union[str, ChannelDimension]] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Split an image into squares of side max_image_size and the original image resized to max_image_size.\n+        That means that a single image becomes a sequence of images.\n+        This is a \"trick\" to spend more compute on each image with no changes in the vision encoder.\n+        1) If one side of the original image is larger than `max_image_size`, resize it to `max_image_size` while preserving the aspect ratio.\n+        2) Divide the resulting image into `ceil(height / max_image_size)` x `ceil(width / max_image_size)`\n+        sub-images of the same size each (image_size, image_size). Typically, 364x364.\n+        3) Returns the list of the crops and the original image, in addition to the number of splits for the height and the width.\n+        Args:\n+            image (`np.ndarray`):\n+                Images to split.\n+            max_image_size (`Dict[str, int]`):\n+                Maximum size of the output image. If the image is larger than this size, it will be split into\n+                patches of this size, and the original image will be concatenated with the patches, resized to max_size.\n+            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.LANCZOS`):\n+                Resampling filter to use when resizing the image.\n+            data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the output image. If not provided, it will be the same as the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the input image. If not provided, it will be inferred.\n+        \"\"\"\n+        height, width = get_image_size(image, channel_dim=input_data_format)\n+        max_height = max_width = max_image_size[\"longest_edge\"]\n+\n+        frames = []\n+        if height > max_height or width > max_width:\n+            # Calculate the number of splits\n+            num_splits_h = math.ceil(height / max_height)\n+            num_splits_w = math.ceil(width / max_width)\n+            # Calculate the optimal width and height for the sub-images\n+            optimal_height = math.ceil(height / num_splits_h)\n+            optimal_width = math.ceil(width / num_splits_w)\n+\n+            # Iterate through each row and column\n+            for r in range(num_splits_h):\n+                for c in range(num_splits_w):\n+                    # Calculate the starting point of the crop\n+                    start_x = c * optimal_width\n+                    start_y = r * optimal_height\n+\n+                    # Calculate the ending point of the crop\n+                    end_x = min(start_x + optimal_width, width)\n+                    end_y = min(start_y + optimal_height, height)\n+\n+                    # Crop the image\n+                    cropped_image = _crop(\n+                        image,\n+                        start_x,\n+                        start_y,\n+                        end_x,\n+                        end_y,\n+                        data_format=data_format,\n+                    )\n+                    frames.append(cropped_image)\n+\n+            # For the global image at the end, we resize it to match the max_image_size, for cpu memory efficiency\n+            global_image_height, global_image_width = max_height, max_width\n+            if height != global_image_height or width != global_image_width:\n+                image = self.resize(\n+                    image,\n+                    {\"height\": global_image_height, \"width\": global_image_width},\n+                    resample=resample,\n+                    input_data_format=data_format,\n+                )\n+        else:\n+            num_splits_h, num_splits_w = 0, 0\n+\n+        frames.append(image)\n+\n+        return frames, num_splits_h, num_splits_w\n+\n+    def resize_for_vision_encoder(\n+        self,\n+        image: np.ndarray,\n+        vision_encoder_max_size: int,\n+        resample: PILImageResampling = PILImageResampling.LANCZOS,\n+        data_format: Optional[Union[str, ChannelDimension]] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Resize images to be multiples of `vision_encoder_max_size` while preserving the aspect ratio.\n+        Args:\n+            image (`np.ndarray`):\n+                Images to resize.\n+            vision_encoder_max_size (`int`):\n+                Maximum size of the output image. If the image is larger than this size, it will be split into\n+                patches of this size, and the original image will be concatenated with the patches, resized to max_size.\n+            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.LANCZOS`):\n+                Resampling filter to use when resizing the image.\n+            data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the output image. If not provided, it will be the same as the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the input image. If not provided, it will be inferred\n+        \"\"\"\n+        height, width = get_image_size(image, channel_dim=input_data_format)\n+\n+        aspect_ratio = width / height\n+        if width >= height:\n+            width = math.ceil(width / vision_encoder_max_size) * vision_encoder_max_size\n+            height = int(width / aspect_ratio)\n+            height = math.ceil(height / vision_encoder_max_size) * vision_encoder_max_size\n+        elif height > width:\n+            height = math.ceil(height / vision_encoder_max_size) * vision_encoder_max_size\n+            width = int(height * aspect_ratio)\n+            width = math.ceil(width / vision_encoder_max_size) * vision_encoder_max_size\n+        new_size = {\"height\": height, \"width\": width}\n+        return self.resize(\n+            image, size=new_size, resample=resample, input_data_format=input_data_format, data_format=data_format\n+        )\n+\n+    def _pad_image(\n+        self,\n+        image: np.ndarray,\n+        output_size: Tuple[int, int],\n+        constant_values: Union[float, Iterable[float]] = 0,\n+        data_format: Optional[ChannelDimension] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ) -> np.ndarray:\n+        \"\"\"\n+        Pad an image with zeros to the given size.\n+        \"\"\"\n+        input_height, input_width = get_image_size(image, channel_dim=input_data_format)\n+        output_height, output_width = output_size\n+\n+        pad_bottom = output_height - input_height\n+        pad_right = output_width - input_width\n+        padding = ((0, pad_bottom), (0, pad_right))\n+        padded_image = pad(\n+            image,\n+            padding,\n+            mode=PaddingMode.CONSTANT,\n+            constant_values=constant_values,\n+            data_format=data_format,\n+            input_data_format=input_data_format,\n+        )\n+        return padded_image\n+\n+    def pad(\n+        self,\n+        images: List[np.ndarray],\n+        constant_values: Union[float, Iterable[float]] = 0,\n+        return_pixel_mask: bool = True,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        data_format: Optional[ChannelDimension] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ) -> BatchFeature:\n+        \"\"\"\n+        For a list of images, for each images, pads a batch of images to the bottom and right of the image with zeros to the size of largest height and width.\n+        For each sample in the batch, pads the sample with empty images to the max_number of images per sample in the batch. Optionally returns a pixel mask.\n+        Args:\n+            images (`List[np.ndarray]`):\n+                List of list of images to pad. Pads to the largest height and width in the batch.\n+            constant_values (`float` or `Iterable[float]`, *optional*):\n+                The value to use for the padding if `mode` is `\"constant\"`.\n+            return_pixel_mask (`bool`, *optional*, defaults to `True`):\n+                Whether to return a pixel mask.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                    - Unset: Return a list of `np.ndarray`.\n+                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n+                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n+            data_format (`str` or `ChannelDimension`, *optional*):\n+                The channel dimension format of the image. If not provided, it will be the same as the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the input image. If not provided, it will be inferred.\n+        \"\"\"\n+        pad_size = get_max_height_width(images, input_data_format=input_data_format)\n+\n+        batch_size = len(images)\n+        max_num_images = max(len(images_) for images_ in images)\n+        input_data_format = (\n+            infer_channel_dimension_format(images[0][0], num_channels=(1, 3, 4))\n+            if input_data_format is None\n+            else input_data_format\n+        )\n+        data_format = input_data_format if data_format is None else data_format\n+\n+        if input_data_format == ChannelDimension.FIRST:\n+            n_channels = images[0][0].shape[0]\n+        elif input_data_format == ChannelDimension.LAST:\n+            n_channels = images[0][0].shape[-1]\n+        else:\n+            raise ValueError(\"Invalid channel dimension format.\")\n+\n+        def empty_image(size, input_data_format):\n+            if input_data_format == ChannelDimension.FIRST:\n+                return np.zeros((n_channels, *size), dtype=np.uint8)\n+            elif input_data_format == ChannelDimension.LAST:\n+                return np.zeros((*size, n_channels), dtype=np.uint8)\n+\n+        padded_images_list = [\n+            [empty_image(pad_size, data_format) for _ in range(max_num_images)] for _ in range(batch_size)\n+        ]\n+        padded_masks = [[np.zeros(pad_size) for _ in range(max_num_images)] for _ in range(batch_size)]\n+\n+        for batch_idx in range(batch_size):\n+            for sample_idx, image in enumerate(images[batch_idx]):\n+                padded_images_list[batch_idx][sample_idx] = self._pad_image(\n+                    image,\n+                    pad_size,\n+                    constant_values=constant_values,\n+                    data_format=data_format,\n+                    input_data_format=input_data_format,\n+                )\n+                padded_masks[batch_idx][sample_idx] = make_pixel_mask(\n+                    image, output_size=pad_size, input_data_format=input_data_format\n+                )\n+\n+        padded_masks = padded_masks if return_pixel_mask else None\n+        return padded_images_list, padded_masks\n+\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        do_convert_rgb: Optional[bool] = None,\n+        do_resize: Optional[bool] = None,\n+        size: Optional[Dict[str, int]] = None,\n+        resample: PILImageResampling = None,\n+        do_image_splitting: Optional[bool] = None,\n+        do_rescale: Optional[bool] = None,\n+        max_image_size: Optional[Dict[str, int]] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_pad: Optional[bool] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        return_row_col_info: bool = False,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Preprocess a batch of images.\n+        Args:\n+            images (`ImageInput`):\n+                A list of images to preprocess.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. With the longest edge resized to keep the input aspect ratio.\n+            resample (`int`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n+                has an effect if `do_resize` is set to `True`.\n+            do_image_splitting (`bool`, *optional*, defaults to `self.do_image_splitting`):\n+                Whether to split the image into sub-images concatenated with the original image. They are split into patches\n+                such that each patch has a size of `max_image_size[\"height\"]` x `max_image_size[\"width\"]`.\n+            max_image_size (`Dict`, *optional*, defaults to `self.max_image_size`):\n+                Maximum resolution of the images. If the image is larger than this size, the image is split into patches.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n+                `True`.\n+            do_pad (`bool`, *optional*, defaults to `self.do_pad`):\n+                Whether or not to pad the images to the largest height and width in the batch.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                - Unset: Return a list of `np.ndarray`.\n+                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n+                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n+            return_row_col_info (`bool`, *optional*, default to `False`):\n+                Whether to return the number of rows and columns of the split images. This is used for the\n+                `SmolVLMProcessor` to generate prompt strings based on the number of rows and columns.\n+            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n+                from the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+        do_resize = do_resize if do_resize is not None else self.do_resize\n+        size = size if size is not None else self.size\n+        resample = resample if resample is not None else self.resample\n+        do_rescale = do_rescale if do_rescale is not None else self.do_rescale\n+        rescale_factor = rescale_factor if rescale_factor is not None else self.rescale_factor\n+        do_image_splitting = do_image_splitting if do_image_splitting is not None else self.do_image_splitting\n+        max_image_size = max_image_size if max_image_size is not None else self.max_image_size\n+        do_normalize = do_normalize if do_normalize is not None else self.do_normalize\n+        image_mean = image_mean if image_mean is not None else self.image_mean\n+        image_std = image_std if image_std is not None else self.image_std\n+        do_convert_rgb = do_convert_rgb if do_convert_rgb is not None else self.do_convert_rgb\n+        do_pad = do_pad if do_pad is not None else self.do_pad\n+\n+        images_list = make_nested_list_of_images(images)\n+\n+        if not valid_images(images_list[0]):\n+            raise ValueError(\n+                \"Invalid image type. Must be of type PIL.Image.Image, numpy.ndarray, \"\n+                \"torch.Tensor, tf.Tensor or jax.ndarray.\"\n+            )\n+\n+        validate_preprocess_arguments(\n+            do_rescale=do_rescale,\n+            rescale_factor=rescale_factor,\n+            do_normalize=do_normalize,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            do_resize=do_resize,\n+            size=size,\n+            resample=resample,\n+        )\n+\n+        # save the palettes for conversion to RGB\n+        palettes_list = [\n+            [im.getpalette() if isinstance(im, Image.Image) and im.mode == \"P\" else None for im in images]\n+            for images in images_list\n+        ]\n+\n+        # All transformations expect numpy arrays.\n+        images_list = [[to_numpy_array(image) for image in images] for images in images_list]\n+\n+        # Extra channel dimension for grayscale images\n+        if input_data_format in [ChannelDimension.LAST, None]:\n+            images_list = [\n+                [np.expand_dims(img, axis=-1) if img.ndim == 2 else img for img in images] for images in images_list\n+            ]\n+        elif input_data_format == ChannelDimension.FIRST:\n+            images_list = [\n+                [np.expand_dims(img, axis=0) if img.ndim == 2 else img for img in images] for images in images_list\n+            ]\n+\n+        if do_rescale and is_scaled_image(images_list[0][0]):\n+            logger.warning_once(\n+                \"It looks like you are trying to rescale already rescaled images. If the input\"\n+                \" images have pixel values between 0 and 1, set `do_rescale=False` to avoid rescaling them again.\"\n+            )\n+\n+        # We assume that all images have the same channel dimension format.\n+        if input_data_format is None:\n+            input_data_format = infer_channel_dimension_format(images_list[0][0], num_channels=(1, 3, 4))\n+\n+        if do_resize:\n+            images_list = [\n+                [\n+                    self.resize(image=image, size=size, resample=resample, input_data_format=input_data_format)\n+                    for image in images\n+                ]\n+                for images in images_list\n+            ]\n+\n+        if do_image_splitting:\n+            # We first resize both height and width of each image to the nearest max_image_size multiple, disregarding the aspect ratio\n+            # for size=(10, max_image_size) -> rescaled_size=(max_image_size, max_image_size)\n+            # for size=(11, max_image_size+1) -> rescaled_size=(max_image_size, max_image_size*2)\n+            images_list = [\n+                [\n+                    self.resize_for_vision_encoder(\n+                        image, max_image_size[\"longest_edge\"], resample=resample, input_data_format=input_data_format\n+                    )\n+                    for image in images\n+                ]\n+                for images in images_list\n+            ]\n+            images_list_split_arrays = []\n+            palettes_list_split_arrays = []\n+            images_list_rows = []\n+            images_list_cols = []\n+            for images, palettes in zip(images_list, palettes_list):\n+                split_image_arrays = []\n+                split_palettes_arrays = []\n+                image_rows = []\n+                image_cols = []\n+                for image, palette in zip(images, palettes):\n+                    split_image_array, rows, cols = self.split_image(\n+                        image,\n+                        max_image_size=max_image_size,\n+                        input_data_format=input_data_format,\n+                    )\n+                    split_image_arrays.extend(split_image_array)\n+                    split_palettes_arrays.extend([palette] * len(split_image_array))\n+                    image_rows.append(rows)\n+                    image_cols.append(cols)\n+                images_list_split_arrays.append(split_image_arrays)\n+                palettes_list_split_arrays.append(split_palettes_arrays)\n+                images_list_rows.append(image_rows)\n+                images_list_cols.append(image_cols)\n+            images_list = images_list_split_arrays\n+            palettes_list = palettes_list_split_arrays\n+        else:\n+            # We square the images to max_image_size\n+            images_list = [\n+                [\n+                    self.resize(\n+                        image=image,\n+                        size={\"height\": max_image_size[\"longest_edge\"], \"width\": max_image_size[\"longest_edge\"]},\n+                        resample=resample,\n+                        input_data_format=input_data_format,\n+                    )\n+                    for image in images\n+                ]\n+                for images in images_list\n+            ]\n+            images_list_rows = [[0] * len(images) for images in images_list]\n+            images_list_cols = [[0] * len(images) for images in images_list]\n+\n+        if do_convert_rgb:\n+            images_list = [\n+                [convert_to_rgb(img, palette) for img, palette in zip(images, palettes)]\n+                for images, palettes in zip(images_list, palettes_list)\n+            ]\n+\n+        if do_rescale:\n+            images_list = [\n+                [self.rescale(image, rescale_factor, input_data_format=input_data_format) for image in images]\n+                for images in images_list\n+            ]\n+\n+        if do_normalize:\n+            images_list = [\n+                [\n+                    self.normalize(image=image, mean=image_mean, std=image_std, input_data_format=input_data_format)\n+                    for image in images\n+                ]\n+                for images in images_list\n+            ]\n+\n+        pixel_attention_mask = None\n+        if do_pad:\n+            images_list, pixel_attention_mask = self.pad(\n+                images_list, return_pixel_mask=True, return_tensors=return_tensors, input_data_format=input_data_format\n+            )\n+\n+        if data_format is not None:\n+            images_list = [\n+                [\n+                    to_channel_dimension_format(image, data_format, input_channel_dim=input_data_format)\n+                    for image in images\n+                ]\n+                for images in images_list\n+            ]\n+\n+        # Faster tensor conversion\n+        data = {\"pixel_values\": np.array(images_list) if do_pad and return_tensors is not None else images_list}\n+        if pixel_attention_mask is not None:\n+            data[\"pixel_attention_mask\"] = (\n+                np.array(pixel_attention_mask) if do_pad and return_tensors is not None else pixel_attention_mask\n+            )\n+\n+        encoding = BatchFeature(data=data, tensor_type=return_tensors)\n+\n+        # This is needed for generating correct text inputs in the processor - we don't pad to the max number of images\n+        if return_row_col_info:\n+            encoding[\"rows\"] = images_list_rows\n+            encoding[\"cols\"] = images_list_cols\n+\n+        return encoding\n+\n+\n+__all__ = [\"SmolVLMImageProcessor\"]"
        },
        {
            "sha": "53c0093c5c351234ab44a0b02773e41419558e88",
            "filename": "src/transformers/models/smolvlm/modeling_smolvlm.py",
            "status": "added",
            "additions": 1265,
            "deletions": 0,
            "changes": 1265,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fmodeling_smolvlm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fmodeling_smolvlm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fmodeling_smolvlm.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -0,0 +1,1265 @@\n+#                üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®\n+#           This file was automatically generated from src/transformers/models/smolvlm/modular_smolvlm.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_smolvlm.py file directly. One of our CI enforces this.\n+#                üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Inc. team. All rights reserved.\n+# Written by Orr Zohar\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from dataclasses import dataclass\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+from torch import nn\n+from torch.nn import CrossEntropyLoss\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...modeling_attn_mask_utils import _prepare_4d_attention_mask\n+from ...modeling_outputs import BaseModelOutput, ModelOutput\n+from ...modeling_utils import PreTrainedModel\n+from ...utils import (\n+    add_start_docstrings,\n+    add_start_docstrings_to_model_forward,\n+    is_flash_attn_2_available,\n+    is_flash_attn_greater_or_equal_2_10,\n+    logging,\n+    replace_return_docstrings,\n+)\n+from ..auto import AutoModel\n+from .configuration_smolvlm import SmolVLMConfig, SmolVLMVisionConfig\n+\n+\n+if is_flash_attn_2_available():\n+    from ...modeling_flash_attention_utils import _flash_attention_forward\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+_CONFIG_FOR_DOC = \"SmolVLMConfig\"\n+\n+\n+SMOLVLM_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`SmolVLMConfig`] or [`SmolVLMVisionConfig`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare SmolVLM Model outputting raw hidden-states without any specific head on top.\",\n+    SMOLVLM_START_DOCSTRING,\n+)\n+class SmolVLMPreTrainedModel(PreTrainedModel):\n+    config_class = SmolVLMConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"SmolVLMVisionAttention\", \"SmolVLMDecoderLayer\"]\n+    _skip_keys_device_placement = \"past_key_values\"\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = True\n+    _supports_cache_class = True\n+\n+    def _init_weights(self, module):\n+        std = (\n+            self.config.text_config.initializer_range\n+            if hasattr(self.config, \"initializer_range\")\n+            else self.config.text_config.initializer_range\n+        )\n+\n+        if hasattr(module, \"class_embedding\"):\n+            module.class_embedding.data.normal_(mean=0.0, std=std)\n+\n+        if isinstance(module, (nn.Linear, nn.Conv2d)):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+\n+\n+class SmolVLMVisionEmbeddings(nn.Module):\n+    \"\"\"\n+    This is a modified version of `siglip.modelign_siglip.SiglipVisionEmbeddings` to enable images of variable\n+    resolution.\n+\n+    The modifications are adapted from [Patch n' Pack: NaViT, a Vision Transformer for any Aspect Ratio and Resolution](https://arxiv.org/abs/2307.06304)\n+    which allows treating images in their native aspect ratio and without the need to resize them to the same\n+    fixed size. In particular, we start from the original pre-trained SigLIP model\n+    (which uses images of fixed-size square images) and adapt it by training on images of variable resolutions.\n+    \"\"\"\n+\n+    def __init__(self, config: SmolVLMVisionConfig):\n+        super().__init__()\n+        self.embed_dim = config.hidden_size\n+        self.image_size = config.image_size\n+        self.patch_size = config.patch_size\n+\n+        self.patch_embedding = nn.Conv2d(\n+            in_channels=config.num_channels,\n+            out_channels=self.embed_dim,\n+            kernel_size=self.patch_size,\n+            stride=self.patch_size,\n+            padding=\"valid\",\n+        )\n+\n+        self.num_patches_per_side = self.image_size // self.patch_size\n+        self.num_patches = self.num_patches_per_side**2\n+        self.num_positions = self.num_patches\n+        self.position_embedding = nn.Embedding(self.num_positions, self.embed_dim)\n+\n+    def forward(self, pixel_values: torch.FloatTensor, patch_attention_mask: torch.BoolTensor) -> torch.Tensor:\n+        batch_size, _, max_im_h, max_im_w = pixel_values.shape\n+\n+        patch_embeds = self.patch_embedding(pixel_values)\n+        embeddings = patch_embeds.flatten(2).transpose(1, 2)\n+\n+        max_nb_patches_h, max_nb_patches_w = max_im_h // self.patch_size, max_im_w // self.patch_size\n+        boundaries = torch.arange(1 / self.num_patches_per_side, 1.0, 1 / self.num_patches_per_side)\n+        position_ids = torch.full(size=(batch_size, max_nb_patches_h * max_nb_patches_w), fill_value=0)\n+\n+        for batch_idx, p_attn_mask in enumerate(patch_attention_mask):\n+            nb_patches_h = p_attn_mask[:, 0].sum()\n+            nb_patches_w = p_attn_mask[0].sum()\n+\n+            fractional_coords_h = torch.arange(0, 1 - 1e-6, 1 / nb_patches_h)\n+            fractional_coords_w = torch.arange(0, 1 - 1e-6, 1 / nb_patches_w)\n+\n+            bucket_coords_h = torch.bucketize(fractional_coords_h, boundaries, right=True)\n+            bucket_coords_w = torch.bucketize(fractional_coords_w, boundaries, right=True)\n+\n+            pos_ids = (bucket_coords_h[:, None] * self.num_patches_per_side + bucket_coords_w).flatten()\n+            position_ids[batch_idx][p_attn_mask.view(-1).cpu()] = pos_ids\n+\n+        position_ids = position_ids.to(self.position_embedding.weight.device)\n+        embeddings = embeddings + self.position_embedding(position_ids)\n+        return embeddings\n+\n+\n+class SmolVLMVisionAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+        self.config = config\n+        self.embed_dim = config.hidden_size\n+        self.num_heads = config.num_attention_heads\n+        self.head_dim = self.embed_dim // self.num_heads\n+        if self.head_dim * self.num_heads != self.embed_dim:\n+            raise ValueError(\n+                f\"embed_dim must be divisible by num_heads (got `embed_dim`: {self.embed_dim} and `num_heads`:\"\n+                f\" {self.num_heads}).\"\n+            )\n+        self.scale = self.head_dim**-0.5\n+        self.dropout = config.attention_dropout\n+\n+        self.k_proj = nn.Linear(self.embed_dim, self.embed_dim)\n+        self.v_proj = nn.Linear(self.embed_dim, self.embed_dim)\n+        self.q_proj = nn.Linear(self.embed_dim, self.embed_dim)\n+        self.out_proj = nn.Linear(self.embed_dim, self.embed_dim)\n+\n+        # Ignore copy\n+        self.is_causal = False\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        output_attentions: Optional[bool] = False,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor]]:\n+        \"\"\"Input shape: Batch x Time x Channel\"\"\"\n+\n+        batch_size, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(batch_size, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(batch_size, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(batch_size, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+\n+        k_v_seq_len = key_states.shape[-2]\n+        attn_weights = torch.matmul(query_states, key_states.transpose(2, 3)) * self.scale\n+\n+        if attn_weights.size() != (batch_size, self.num_heads, q_len, k_v_seq_len):\n+            raise ValueError(\n+                f\"Attention weights should be of size {(batch_size, self.num_heads, q_len, k_v_seq_len)}, but is\"\n+                f\" {attn_weights.size()}\"\n+            )\n+\n+        if attention_mask is not None:\n+            if attention_mask.size() != (batch_size, 1, q_len, k_v_seq_len):\n+                raise ValueError(\n+                    f\"Attention mask should be of size {(batch_size, 1, q_len, k_v_seq_len)}, but is {attention_mask.size()}\"\n+                )\n+            attn_weights = attn_weights + attention_mask\n+\n+        # upcast attention to fp32\n+        attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query_states.dtype)\n+        attn_weights = nn.functional.dropout(attn_weights, p=self.dropout, training=self.training)\n+        attn_output = torch.matmul(attn_weights, value_states)\n+\n+        if attn_output.size() != (batch_size, self.num_heads, q_len, self.head_dim):\n+            raise ValueError(\n+                f\"`attn_output` should be of size {(batch_size, self.num_heads, q_len, self.head_dim)}, but is\"\n+                f\" {attn_output.size()}\"\n+            )\n+\n+        attn_output = attn_output.transpose(1, 2).contiguous()\n+        attn_output = attn_output.reshape(batch_size, q_len, self.embed_dim)\n+\n+        attn_output = self.out_proj(attn_output)\n+\n+        return attn_output, attn_weights\n+\n+\n+class SmolVLMVisionFlashAttention2(SmolVLMVisionAttention):\n+    \"\"\"\n+    SmolVLMVision flash attention module. This module inherits from `SmolVLMVisionAttention` as the weights of the module stays\n+    untouched. The only required change would be on the forward pass where it needs to correctly call the public API of\n+    flash attention and deal with padding tokens in case the input contains any of them.\n+    \"\"\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        # TODO: Should be removed once Flash Attention for RoCm is bumped to 2.1.\n+        # flash_attn<2.1 generates top-left aligned causal mask, while what is needed here is bottom-right alignement, that was made default for flash_attn>=2.1. This attribute is used to handle this difference. Reference: https://github.com/Dao-AILab/flash-attention/releases/tag/v2.1.0.\n+        # Beware that with flash_attn<2.1, using q_seqlen != k_seqlen (except for the case q_seqlen == 1) produces a wrong mask (top-left).\n+        self._flash_attn_uses_top_left_mask = not is_flash_attn_greater_or_equal_2_10()\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.LongTensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        **kwargs,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        output_attentions = False\n+\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        # Flash attention requires the input to have the shape\n+        # batch_size x seq_length x head_dim x hidden_dim\n+        # therefore we just need to keep the original shape\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim)\n+        key_states = key_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+\n+        kv_seq_len = key_states.shape[-2]\n+        if past_key_value is not None:\n+            kv_seq_len += past_key_value.get_usable_length(kv_seq_len, self.layer_idx)\n+\n+        # TODO: These transpose are quite inefficient but Flash Attention requires the layout [batch_size, sequence_length, num_heads, head_dim]. We would need to refactor the KV cache\n+        # to be able to avoid many of these transpose/reshape/view.\n+        key_states = key_states.transpose(1, 2)\n+        value_states = value_states.transpose(1, 2)\n+\n+        dropout_rate = self.dropout if self.training else 0.0\n+\n+        # In PEFT, usually we cast the layer norms in float32 for training stability reasons\n+        # therefore the input hidden states gets silently casted in float32. Hence, we need\n+        # cast them back in the correct dtype just to be sure everything works as expected.\n+        # This might slowdown training & inference so it is recommended to not cast the LayerNorms\n+        # in fp32. (SmolVLMVisionRMSNorm handles it correctly)\n+\n+        input_dtype = query_states.dtype\n+        if input_dtype == torch.float32:\n+            if torch.is_autocast_enabled():\n+                target_dtype = torch.get_autocast_gpu_dtype()\n+            # Handle the case where the model is quantized\n+            elif hasattr(self.config, \"_pre_quantization_dtype\"):\n+                target_dtype = self.config._pre_quantization_dtype\n+            else:\n+                target_dtype = self.q_proj.weight.dtype\n+\n+            logger.warning_once(\n+                f\"The input hidden states seems to be silently casted in float32, this might be related to\"\n+                f\" the fact you have upcasted embedding or layer norm layers in float32. We will cast back the input in\"\n+                f\" {target_dtype}.\"\n+            )\n+\n+            query_states = query_states.to(target_dtype)\n+            key_states = key_states.to(target_dtype)\n+            value_states = value_states.to(target_dtype)\n+\n+        attn_output = _flash_attention_forward(\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            q_len,\n+            dropout=dropout_rate,\n+            is_causal=self.is_causal,\n+            use_top_left_mask=self._flash_attn_uses_top_left_mask,\n+        )\n+\n+        attn_output = attn_output.reshape(bsz, q_len, self.embed_dim).contiguous()\n+        attn_output = self.out_proj(attn_output)\n+\n+        if not output_attentions:\n+            attn_weights = None\n+\n+        return attn_output, attn_weights\n+\n+\n+class SmolVLMVisionMLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.config = config\n+        self.activation_fn = ACT2FN[config.hidden_act]\n+        self.fc1 = nn.Linear(config.hidden_size, config.intermediate_size)\n+        self.fc2 = nn.Linear(config.intermediate_size, config.hidden_size)\n+\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        hidden_states = self.fc1(hidden_states)\n+        hidden_states = self.activation_fn(hidden_states)\n+        hidden_states = self.fc2(hidden_states)\n+        return hidden_states\n+\n+\n+IDEFICS_VISION_ATTENTION_CLASSES = {\n+    \"eager\": SmolVLMVisionAttention,\n+    \"flash_attention_2\": SmolVLMVisionFlashAttention2,\n+}\n+\n+\n+class SmolVLMEncoderLayer(nn.Module):\n+    def __init__(self, config: SmolVLMVisionConfig):\n+        super().__init__()\n+        self.embed_dim = config.hidden_size\n+        self.self_attn = IDEFICS_VISION_ATTENTION_CLASSES[config._attn_implementation](config)\n+        self.layer_norm1 = nn.LayerNorm(self.embed_dim, eps=config.layer_norm_eps)\n+        self.mlp = SmolVLMVisionMLP(config)\n+        self.layer_norm2 = nn.LayerNorm(self.embed_dim, eps=config.layer_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: torch.Tensor,\n+        output_attentions: Optional[bool] = False,\n+    ) -> Tuple[torch.FloatTensor]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.FloatTensor`):\n+                Input to the layer of shape `(batch, seq_len, embed_dim)`.\n+            attention_mask (`torch.FloatTensor`):\n+                Attention mask of shape `(batch, 1, q_len, k_v_seq_len)` where padding elements are indicated by very large negative values.\n+            output_attentions (`bool`, *optional*, defaults to `False`):\n+                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n+                returned tensors for more detail.\n+        \"\"\"\n+        residual = hidden_states\n+\n+        hidden_states = self.layer_norm1(hidden_states)\n+        hidden_states, attn_weights = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            output_attentions=output_attentions,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        residual = hidden_states\n+        hidden_states = self.layer_norm2(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        outputs = (hidden_states,)\n+\n+        if output_attentions:\n+            outputs += (attn_weights,)\n+\n+        return outputs\n+\n+\n+class SmolVLMEncoder(nn.Module):\n+    \"\"\"\n+    Transformer encoder consisting of `config.num_hidden_layers` self attention layers. Each layer is a\n+    [`SmolVLMEncoderLayer`].\n+\n+    Args:\n+        config: SmolVLMConfig\n+    \"\"\"\n+\n+    def __init__(self, config: SmolVLMConfig):\n+        super().__init__()\n+        self.config = config\n+        self.layers = nn.ModuleList([SmolVLMEncoderLayer(config) for _ in range(config.num_hidden_layers)])\n+        self.gradient_checkpointing = False\n+\n+    # Ignore copy\n+    def forward(\n+        self,\n+        inputs_embeds,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Union[Tuple, BaseModelOutput]:\n+        r\"\"\"\n+        Args:\n+            inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`):\n+                Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation.\n+                This is useful if you want more control over how to convert `input_ids` indices into associated vectors\n+                than the model's internal embedding lookup matrix.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+\n+                [What are attention masks?](../glossary#attention-mask)\n+            output_attentions (`bool`, *optional*):\n+                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n+                returned tensors for more detail.\n+            output_hidden_states (`bool`, *optional*):\n+                Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors\n+                for more detail.\n+            return_dict (`bool`, *optional*):\n+                Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+        \"\"\"\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        encoder_states = () if output_hidden_states else None\n+        all_attentions = () if output_attentions else None\n+\n+        hidden_states = inputs_embeds\n+        for encoder_layer in self.layers:\n+            if output_hidden_states:\n+                encoder_states = encoder_states + (hidden_states,)\n+            if self.gradient_checkpointing and self.training:\n+                layer_outputs = self._gradient_checkpointing_func(\n+                    encoder_layer.__call__,\n+                    hidden_states,\n+                    attention_mask,\n+                    output_attentions,\n+                )\n+            else:\n+                layer_outputs = encoder_layer(\n+                    hidden_states,\n+                    attention_mask,\n+                    output_attentions=output_attentions,\n+                )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if output_attentions:\n+                all_attentions = all_attentions + (layer_outputs[1],)\n+\n+        if output_hidden_states:\n+            encoder_states = encoder_states + (hidden_states,)\n+\n+        if not return_dict:\n+            return tuple(v for v in [hidden_states, encoder_states, all_attentions] if v is not None)\n+        return BaseModelOutput(\n+            last_hidden_state=hidden_states, hidden_states=encoder_states, attentions=all_attentions\n+        )\n+\n+\n+SMOLVLM_VISION_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`SmolVLMVisionConfig`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The SmolVLM Vision Transformer Model outputting raw image embedding.\",\n+    SMOLVLM_VISION_START_DOCSTRING,\n+)\n+class SmolVLMVisionTransformer(SmolVLMPreTrainedModel):\n+    config_class = SmolVLMVisionConfig\n+    _supports_sdpa = False\n+\n+    def __init__(self, config: SmolVLMVisionConfig):\n+        super().__init__(config)\n+        embed_dim = config.hidden_size\n+\n+        self.embeddings = SmolVLMVisionEmbeddings(config)\n+        self.encoder = SmolVLMEncoder(config)\n+        self.patch_size = config.patch_size\n+        self.post_layernorm = nn.LayerNorm(embed_dim, eps=config.layer_norm_eps)\n+        self._use_flash_attention_2 = config._attn_implementation == \"flash_attention_2\"\n+\n+    def get_input_embeddings(self):\n+        return self.embeddings\n+\n+    def set_input_embeddings(self, value):\n+        self.embeddings = value\n+\n+    def forward(\n+        self,\n+        pixel_values,\n+        patch_attention_mask: Optional[torch.BoolTensor] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Union[Tuple, BaseModelOutput]:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        batch_size = pixel_values.size(0)\n+        if patch_attention_mask is None:\n+            patch_size = self.patch_size\n+            patch_attention_mask = torch.ones(\n+                (\n+                    batch_size,\n+                    pixel_values.size(2) // patch_size,\n+                    pixel_values.size(3) // patch_size,\n+                )\n+            )\n+            patch_attention_mask = patch_attention_mask.to(dtype=torch.bool, device=pixel_values.device)\n+\n+        hidden_states = self.embeddings(pixel_values=pixel_values, patch_attention_mask=patch_attention_mask)\n+\n+        patch_attention_mask = patch_attention_mask.view(batch_size, -1)\n+        # The call to `_upad_input` in `_flash_attention_forward` is expensive\n+        # So when the `patch_attention_mask` is full of 1s (i.e. attending to the whole sequence),\n+        # avoiding passing the attention_mask, which is equivalent to attending to the full sequence\n+        if not torch.any(~patch_attention_mask):\n+            patch_attention_mask = None\n+        elif not self._use_flash_attention_2:\n+            patch_attention_mask = _prepare_4d_attention_mask(patch_attention_mask, hidden_states.dtype)\n+\n+        encoder_outputs = self.encoder(\n+            inputs_embeds=hidden_states,\n+            attention_mask=patch_attention_mask,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+        )\n+\n+        last_hidden_state = encoder_outputs[0]\n+        last_hidden_state = self.post_layernorm(last_hidden_state)\n+\n+        if not return_dict:\n+            return (last_hidden_state,) + encoder_outputs[1:]\n+\n+        return BaseModelOutput(\n+            last_hidden_state=last_hidden_state,\n+            hidden_states=encoder_outputs.hidden_states,\n+            attentions=encoder_outputs.attentions,\n+        )\n+\n+\n+@dataclass\n+class SmolVLMBaseModelOutputWithPast(ModelOutput):\n+    \"\"\"\n+    Base class for SmolVLM model's outputs that may also contain a past key/values (to speed up sequential decoding).\n+    Args:\n+        last_hidden_state (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`):\n+            Sequence of hidden-states at the output of the last layer of the model.\n+            If `past_key_values` is used only the last hidden-state of the sequences of shape `(batch_size, 1,\n+            hidden_size)` is output.\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`) and optionally if\n+            `config.is_encoder_decoder=True` 2 additional tensors of shape `(batch_size, num_heads,\n+            encoder_sequence_length, embed_size_per_head)`.\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks and optionally if\n+            `config.is_encoder_decoder=True` in the cross-attention blocks) that can be used (see `past_key_values`\n+            input) to speed up sequential decoding.\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        image_hidden_states (`tuple(torch.FloatTensor)`, *optional*):\n+            Tuple of `torch.FloatTensor` (one for the output of the image embeddings, `(batch_size, num_images,\n+            sequence_length, hidden_size)`.\n+            image_hidden_states of the model produced by the vision encoder\n+    \"\"\"\n+\n+    last_hidden_state: torch.FloatTensor = None\n+    past_key_values: Optional[Tuple[Tuple[torch.FloatTensor]]] = None\n+    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+    attentions: Optional[Tuple[torch.FloatTensor]] = None\n+    image_hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+\n+\n+class SmolVLMSimpleMLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        input_size = config.vision_config.hidden_size * (config.scale_factor**2)\n+        output_size = config.text_config.hidden_size\n+        self.proj = nn.Linear(input_size, output_size, bias=False)\n+\n+    def forward(self, x):\n+        return self.proj(x)\n+\n+\n+class SmolVLMConnector(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.scale_factor = config.scale_factor\n+        self.modality_projection = SmolVLMSimpleMLP(config)\n+\n+    def pixel_shuffle(self, x, scale_factor=2):\n+        bsz, seq, embed_dim = x.size()\n+        height = width = int(seq**0.5)\n+        x = x.view(bsz, height, width, embed_dim)\n+        x = x.view(bsz, height, int(width / scale_factor), embed_dim * scale_factor)\n+        x = x.permute(0, 2, 1, 3)\n+        x = x.reshape(bsz, int(width / scale_factor), int(height / scale_factor), embed_dim * (scale_factor**2))\n+        x = x.permute(0, 2, 1, 3)\n+        x = x.reshape(bsz, int(seq / (scale_factor**2)), embed_dim * (scale_factor**2))\n+        return x\n+\n+    def forward(self, image_hidden_states):\n+        image_hidden_states = self.pixel_shuffle(image_hidden_states, self.scale_factor)\n+        image_hidden_states = self.modality_projection(image_hidden_states)\n+        return image_hidden_states\n+\n+\n+SMOLVLM_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+            it.\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            [What are input IDs?](../glossary#input-ids)\n+        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+            - 1 for tokens that are **not masked**,\n+            - 0 for tokens that are **masked**.\n+\n+            [What are attention masks?](../glossary#attention-mask)\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            If `past_key_values` is used, optionally only the last `decoder_input_ids` have to be input (see\n+            `past_key_values`).\n+\n+            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n+            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n+            information on the default strategy.\n+\n+            - 1 indicates the head is **not masked**,\n+            - 0 indicates the head is **masked**.\n+        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n+            config.n_positions - 1]`. [What are position IDs?](../glossary#position-ids)\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`) and 2 additional tensors of shape\n+            `(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`.\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n+            blocks) that can be used (see `past_key_values` input) to speed up sequential decoding.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n+            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n+            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n+        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n+            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n+            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n+            model's internal embedding lookup matrix.\n+        pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)):\n+            The tensors corresponding to the input images. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`CLIPImageProcessor.__call__`] for details ([]`LlavaProcessor`] uses\n+            [`CLIPImageProcessor`] for processing images).\n+        pixel_attention_mask (`torch.Tensor` of shape `(batch_size, image_size, image_size)`, *optional*):\n+            Mask to avoid performing attention on padding pixel indices.\n+        image_hidden_states (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+            The hidden states of the image encoder after modality projection.\n+        use_cache (`bool`, *optional*):\n+            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n+            `past_key_values`).\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"\"\"SmolVLM model consisting of a SIGLIP vision encoder and Llama3 language decoder\"\"\",\n+    SMOLVLM_START_DOCSTRING,\n+)\n+class SmolVLMModel(SmolVLMPreTrainedModel):\n+    \"\"\"\n+    A subclass of Idefics3Model. We do *not* remove or block the call to inputs_merger\n+    in forward. Instead, we override inputs_merger here with custom logic.\n+    \"\"\"\n+\n+    def __init__(self, config: SmolVLMConfig):\n+        super().__init__(config)\n+        self.padding_idx = self.config.text_config.pad_token_id\n+        self.vocab_size = self.config.text_config.vocab_size\n+\n+        self.vision_model = SmolVLMVisionTransformer._from_config(config.vision_config)\n+        self.connector = SmolVLMConnector(config)\n+        self.text_model = AutoModel.from_config(config.text_config)\n+\n+        self.image_seq_len = int(\n+            ((config.vision_config.image_size // config.vision_config.patch_size) ** 2) / (config.scale_factor**2)\n+        )\n+        self.image_token_id = self.config.image_token_id\n+\n+        self._use_flash_attention_2 = config.text_config._attn_implementation == \"flash_attention_2\"\n+\n+        self.post_init()\n+\n+    def enable_input_require_grads(self):\n+        \"\"\"\n+        Enables the gradients for the input embeddings.\n+\n+        This is useful for lora when using gradient checkpointing.\n+        c.f. https://github.com/huggingface/peft/issues/1402#issuecomment-1913675032\n+\n+        Override to set output.requires_grad = True for both the decoder's and vision model's embeddings.\n+        \"\"\"\n+\n+        def get_lowest_module(module):\n+            if len(list(module.children())) == 0:\n+                # If the module has no children, it is a leaf module (e.g., Linear, Conv2d, etc.)\n+                return module\n+            else:\n+                # Recursively call the function on each child module\n+                return get_lowest_module(list(module.children())[0])\n+\n+        def make_inputs_require_grads(module, input, output):\n+            output.requires_grad_(True)\n+\n+        self._text_require_grads_hook = self.get_input_embeddings().register_forward_hook(make_inputs_require_grads)\n+        self._vision_require_grads_hook = get_lowest_module(self.vision_model).register_forward_hook(\n+            make_inputs_require_grads\n+        )\n+\n+    def disable_input_require_grads(self):\n+        self._text_require_grads_hook.remove()\n+        self._vision_require_grads_hook.remove()\n+\n+    def get_input_embeddings(self):\n+        return self.text_model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.text_model.set_input_embeddings(value)\n+\n+    def inputs_merger(\n+        self, input_ids: torch.LongTensor, inputs_embeds: torch.Tensor, image_hidden_states: torch.Tensor\n+    ):\n+        \"\"\"\n+        This method aims at merging the token embeddings with the image hidden states into one single sequence of vectors that are fed to the transformer LM.\n+        The merging happens as follows:\n+        - The text token sequence is: `tok_1 tok_2 tok_3 <fake_token_around_image> <image> <image> ... <image> <fake_token_around_image> tok_4`.\n+        - We get the image hidden states for the image through the vision encoder and that hidden state, after a pixel shuffle operation, is then projected into the text embedding space.\n+        We thus have a sequence of image hidden states of size (1, image_seq_len, hidden_dim), where 1 is for batch_size of 1 image and hidden_dim is the hidden_dim of the LM transformer.\n+        - The merging happens so that we obtain the following sequence: `vector_tok_1 vector_tok_2 vector_tok_3 vector_fake_tok_around_image {sequence of image_seq_len image hidden states} vector_fake_toke_around_image vector_tok_4`. That sequence is fed to the LM.\n+        - To fit the format of that sequence, `input_ids`, `input_embeds`, `attention_mask` are all 3 adapted to insert the image hidden states.\n+        \"\"\"\n+        _, patch_size, _ = image_hidden_states.shape\n+\n+        image_mask = input_ids == self.image_token_id\n+        num_image_tokens = image_mask.sum(dim=1)\n+        if not torch.all(num_image_tokens % patch_size == 0):\n+            raise ValueError(\"At least one sample has <image> tokens not divisible by patch_size.\")\n+\n+        blocks_per_sample = num_image_tokens // patch_size\n+\n+        offsets = torch.nn.functional.pad(blocks_per_sample.cumsum(dim=0), (1, 0), value=0)\n+        block_offset = offsets[:-1]\n+        row_cum = image_mask.cumsum(dim=-1)\n+        chunk_idx = (row_cum - 1) // patch_size\n+        local_idx = (row_cum - 1) % patch_size\n+        block_idx = block_offset.unsqueeze(1) + chunk_idx\n+\n+        image_embeds = torch.zeros_like(inputs_embeds)\n+        image_embeds[image_mask] = image_hidden_states[block_idx[image_mask], local_idx[image_mask], :]\n+\n+        merged_embeds = torch.where(image_mask.unsqueeze(-1), image_embeds, inputs_embeds)\n+        return merged_embeds\n+\n+    @add_start_docstrings_to_model_forward(\n+        \"\"\"\n+        Inputs fed to the model can have an arbitrary number of images. To account for this, pixel_values fed to\n+        the model have image padding -> (batch_size, max_num_images, 3, max_heights, max_widths) where\n+        max_num_images is the maximum number of images among the batch_size samples in the batch.\n+        Padding images are not needed beyond padding the pixel_values at the entrance of the model.\n+        For efficiency, we only pass through the vision_model's forward the real images by\n+        discarding the padding images i.e. pixel_values of size (image_batch_size, 3, height, width) where\n+        image_batch_size would be 7 when num_images_per_sample=[1, 3, 1, 2] and max_num_images would be 3.\n+        \"\"\",\n+        SMOLVLM_INPUTS_DOCSTRING,\n+    )\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        pixel_values: Optional[torch.FloatTensor] = None,\n+        pixel_attention_mask: Optional[torch.BoolTensor] = None,\n+        image_hidden_states: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+    ) -> Union[Tuple, SmolVLMBaseModelOutputWithPast]:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        if self.training and self.text_model.gradient_checkpointing and use_cache:\n+            logger.warning_once(\n+                \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n+            )\n+            use_cache = False\n+\n+        # retrieve input_ids and inputs_embeds\n+        if input_ids is not None:\n+            batch_size, seq_length = input_ids.shape\n+        elif inputs_embeds is not None:\n+            batch_size, seq_length, _ = inputs_embeds.shape\n+        else:\n+            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n+\n+        past_seen_tokens = 0\n+        if use_cache:\n+            if past_key_values is None:\n+                past_key_values = DynamicCache()\n+            past_seen_tokens = past_key_values.get_seq_length()\n+\n+        if inputs_embeds is not None and input_ids is None and past_seen_tokens == 0:\n+            raise ValueError(\"When first calling the model, if input_embeds are passed, input_ids should not be None.\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.text_model.get_input_embeddings()(input_ids).to(input_ids.device)\n+\n+        # START VISUAL INPUTS INTEGRATION\n+        if pixel_values is not None and image_hidden_states is not None:\n+            raise ValueError(\"You cannot specify both pixel_values and image_hidden_states at the same time\")\n+        elif pixel_values is not None:\n+            batch_size, num_images, num_channels, height, width = pixel_values.shape\n+            pixel_values = pixel_values\n+            pixel_values = pixel_values.view(batch_size * num_images, *pixel_values.shape[2:])\n+\n+            # Remove padding images - padding images are full 0.\n+            nb_values_per_image = pixel_values.shape[1:].numel()\n+            real_images_inds = (pixel_values == 0.0).sum(dim=(-1, -2, -3)) != nb_values_per_image\n+\n+            if not any(real_images_inds):\n+                # no images, leave one empty image.\n+                real_images_inds[0] = True\n+\n+            pixel_values = pixel_values[real_images_inds].contiguous()\n+\n+            # Handle the vision attention mask\n+            if pixel_attention_mask is None:\n+                pixel_attention_mask = torch.ones(\n+                    size=[pixel_values.shape[i] for i in (0, 2, 3)],\n+                    dtype=torch.bool,\n+                    device=pixel_values.device,\n+                )\n+            else:\n+                # Remove padding images from the mask\n+                pixel_attention_mask = pixel_attention_mask.view(\n+                    batch_size * num_images, *pixel_attention_mask.shape[2:]\n+                )\n+                pixel_attention_mask = pixel_attention_mask[real_images_inds].contiguous()\n+\n+            patch_size = self.config.vision_config.patch_size\n+            patches_subgrid = pixel_attention_mask.unfold(dimension=1, size=patch_size, step=patch_size)\n+            patches_subgrid = patches_subgrid.unfold(dimension=2, size=patch_size, step=patch_size)\n+            patch_attention_mask = (patches_subgrid.sum(dim=(-1, -2)) > 0).bool()\n+\n+            # Get sequence from the vision encoder\n+            image_hidden_states = self.vision_model(\n+                pixel_values=pixel_values,\n+                patch_attention_mask=patch_attention_mask,\n+            ).last_hidden_state\n+\n+            # Modality projection & resampling\n+            image_hidden_states = self.connector(image_hidden_states)\n+\n+        elif image_hidden_states is not None:\n+            image_hidden_states = image_hidden_states.to(dtype=self.dtype, device=input_ids.device)\n+\n+        if inputs_embeds is not None and image_hidden_states is not None:\n+            # When we generate, we don't want to replace the potential image_token_id that we generated by images\n+            # that simply don't exist\n+            inputs_embeds = self.inputs_merger(\n+                input_ids=input_ids,\n+                inputs_embeds=inputs_embeds,\n+                image_hidden_states=image_hidden_states,\n+            )\n+\n+        outputs = self.text_model(\n+            inputs_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+            cache_position=cache_position,\n+        )\n+\n+        if not return_dict:\n+            return tuple(v for v in [*outputs, image_hidden_states] if v is not None)\n+\n+        return SmolVLMBaseModelOutputWithPast(\n+            last_hidden_state=outputs.last_hidden_state,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            image_hidden_states=image_hidden_states,\n+        )\n+\n+\n+@dataclass\n+class SmolVLMCausalLMOutputWithPast(ModelOutput):\n+    \"\"\"\n+    Base class for Idefics causal language model (or autoregressive) outputs.\n+\n+    Args:\n+        loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+            Language modeling loss (for next-token prediction).\n+        logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n+            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+            `past_key_values` input) to speed up sequential decoding.\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        image_hidden_states (`tuple(torch.FloatTensor)`, *optional*):\n+            Tuple of `torch.FloatTensor` (one for the output of the image embeddings, `(batch_size, num_images,\n+            sequence_length, hidden_size)`.\n+            image_hidden_states of the model produced by the vision encoder\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: torch.FloatTensor = None\n+    past_key_values: Optional[List[torch.FloatTensor]] = None\n+    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+    attentions: Optional[Tuple[torch.FloatTensor]] = None\n+    image_hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+\n+\n+@add_start_docstrings(\n+    \"\"\"The SmolVLM Model with a language modeling head. It is made up a SigLIP vision encoder, with a language modeling head on top. \"\"\",\n+    SMOLVLM_START_DOCSTRING,\n+)\n+class SmolVLMForConditionalGeneration(SmolVLMPreTrainedModel, GenerationMixin):\n+    \"\"\"\n+    A subclass of Idefics3ForConditionalGeneration that uses SmolVLMModel\n+    instead of the default Idefics3Model.\n+    \"\"\"\n+\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = SmolVLMModel(config)\n+        self.image_token_id = self.config.image_token_id\n+        self.lm_head = nn.Linear(config.text_config.hidden_size, config.text_config.vocab_size, bias=False)\n+        self.vocab_size = config.text_config.vocab_size\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def enable_input_require_grads(self):\n+        \"\"\"\n+        Enables the gradients for the input embeddings. This is useful for fine-tuning adapter weights while keeping\n+        the model weights fixed.\n+        \"\"\"\n+\n+        def make_inputs_require_grads(module, input, output):\n+            output.requires_grad_(True)\n+\n+        self._text_require_grads_hook = self.get_input_embeddings().register_forward_hook(make_inputs_require_grads)\n+        self._vision_require_grads_hook = self.model.vision_model.get_input_embeddings().register_forward_hook(\n+            make_inputs_require_grads\n+        )\n+\n+    def disable_input_require_grads(self):\n+        self._text_require_grads_hook.remove()\n+        self._vision_require_grads_hook.remove()\n+\n+    def get_input_embeddings(self):\n+        return self.model.text_model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.model.text_model.set_input_embeddings(value)\n+\n+    def get_output_embeddings(self):\n+        return self.lm_head\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.lm_head = new_embeddings\n+\n+    @add_start_docstrings_to_model_forward(SMOLVLM_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=SmolVLMCausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        pixel_values: Optional[torch.FloatTensor] = None,\n+        pixel_attention_mask: Optional[torch.BoolTensor] = None,\n+        image_hidden_states: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Union[Tuple, SmolVLMCausalLMOutputWithPast]:\n+        r\"\"\"\n+        Args:\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.vocab_size]` or `model.image_token_id` (where `model` is your instance of `SmolVLMForConditionalGeneration`).\n+                Tokens with indices set to `model.image_token_id` are ignored (masked), the loss is only\n+                computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> import requests\n+        >>> import torch\n+        >>> from PIL import Image\n+        >>> from io import BytesIO\n+\n+        >>> from transformers import AutoProcessor, AutoModelForImageTextToText\n+        >>> from transformers.image_utils import load_image\n+\n+        >>> # Note that passing the image urls (instead of the actual pil images) to the processor is also possible\n+        >>> image1 = load_image(\"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\")\n+        >>> image2 = load_image(\"https://cdn.britannica.com/59/94459-050-DBA42467/Skyline-Chicago.jpg\")\n+        >>> image3 = load_image(\"https://cdn.britannica.com/68/170868-050-8DDE8263/Golden-Gate-Bridge-San-Francisco.jpg\")\n+\n+        >>> processor = AutoProcessor.from_pretrained(\"HuggingFaceTB/SmolVLM2-2.2B-Instruct\")\n+        >>> model = AutoModelForImageTextToText.from_pretrained(\"HuggingFaceTB/SmolVLM2-2.2B-Instruct\", torch_dtype=torch.bfloat16, device_map=\"auto\")\n+\n+        >>> # Create inputs\n+        >>> messages = [\n+        ...     {\n+        ...         \"role\": \"user\",\n+        ...         \"content\": [\n+        ...             {\"type\": \"video\", \"path\": path/to/video},\n+        ...             {\"type\": \"text\", \"text\": \"What is happening in this video?\"},\n+        ...         ]\n+        ...     }\n+        ... ]\n+\n+        >>> inputs = processor.apply_chat_template([messages], add_generation_prompt=True)\n+\n+        >>> # Generate\n+        >>> generated_ids = model.generate(**inputs, max_new_tokens=256)\n+        >>> generated_texts = processor.batch_decode(generated_ids, skip_special_tokens=True)\n+\n+        >>> print(generated_texts)\n+        ```\"\"\"\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            pixel_values=pixel_values,\n+            pixel_attention_mask=pixel_attention_mask,\n+            image_hidden_states=image_hidden_states,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+        )\n+\n+        hidden_states = outputs[0]\n+        logits = self.lm_head(hidden_states)\n+\n+        loss = None\n+        if labels is not None:\n+            # Upcast to float if we need to compute the loss to avoid potential precision issues\n+            logits = logits.float()\n+            labels = labels.to(logits.device)\n+            # Shift so that tokens < n predict n\n+            if attention_mask is not None:\n+                # we use the input attention mask to shift the logits and labels, because it is 2D.\n+                # we also crop attn mask in case it is longer, which happens in PrefixTuning with peft\n+                shift_attention_mask = attention_mask[:, -(logits.shape[1] - 1) :].to(logits.device)\n+                shift_logits = logits[..., :-1, :][shift_attention_mask != 0].contiguous()\n+                shift_labels = labels[..., 1:][shift_attention_mask != 0].contiguous()\n+            else:\n+                shift_logits = logits[..., :-1, :].contiguous()\n+                shift_labels = labels[..., 1:].contiguous()\n+            # Flatten the tokens\n+            loss_fct = CrossEntropyLoss()\n+            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)), shift_labels.view(-1))\n+\n+        if not return_dict:\n+            output = (logits,) + outputs[1:]\n+            return (loss,) + output if loss is not None else output\n+\n+        return SmolVLMCausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            image_hidden_states=outputs.image_hidden_states,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        attention_mask=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        pixel_values=None,\n+        pixel_attention_mask=None,\n+        image_hidden_states=None,\n+        logits_to_keep=None,\n+        **kwargs,\n+    ):\n+        # Overwritten -- there are mutually exclusive inputs (if the logic to make `image_hidden_states` take\n+        # precedence is moved to the model, we can remove this fn)\n+\n+        # If we have cache: let's slice `input_ids` through `cache_position`, to keep only the unprocessed tokens\n+        if past_key_values is not None:\n+            if inputs_embeds is not None:  # Exception 1\n+                input_ids = input_ids[:, -cache_position.shape[0] :]\n+            elif input_ids.shape[1] != cache_position.shape[0]:\n+                input_ids = input_ids[:, cache_position]\n+\n+        position_ids = kwargs.get(\"position_ids\", None)\n+        if attention_mask is not None and position_ids is None:\n+            # create position_ids on the fly for batch generation\n+            position_ids = attention_mask.long().cumsum(-1) - 1\n+            position_ids.masked_fill_(attention_mask == 0, 1)\n+            if past_key_values:\n+                position_ids = position_ids[:, -input_ids.shape[1] :]\n+\n+        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n+        # but IDEFICS requires noth ids and embeds to be present\n+        if inputs_embeds is not None and cache_position[0] == 0:\n+            model_inputs = {\"inputs_embeds\": inputs_embeds, \"input_ids\": input_ids}\n+        else:\n+            # The clone here is for the same reason as for `position_ids`.\n+            model_inputs = {\"input_ids\": input_ids.clone(memory_format=torch.contiguous_format), \"inputs_embeds\": None}\n+\n+        if logits_to_keep is not None:\n+            model_inputs[\"logits_to_keep\"] = logits_to_keep\n+\n+        if image_hidden_states is not None:\n+            pixel_values = None\n+            pixel_attention_mask = None\n+        else:\n+            pixel_values = pixel_values\n+            pixel_attention_mask = pixel_attention_mask\n+        model_inputs.update(\n+            {\n+                \"position_ids\": position_ids,\n+                \"past_key_values\": past_key_values,\n+                \"use_cache\": kwargs.get(\"use_cache\"),\n+                \"attention_mask\": attention_mask,\n+                \"pixel_values\": pixel_values,\n+                \"pixel_attention_mask\": pixel_attention_mask,\n+                \"image_hidden_states\": image_hidden_states,\n+            }\n+        )\n+        return model_inputs\n+\n+    def _update_model_kwargs_for_generation(self, outputs, model_kwargs, is_encoder_decoder, **kwargs):\n+        model_kwargs = super()._update_model_kwargs_for_generation(\n+            outputs=outputs,\n+            model_kwargs=model_kwargs,\n+            is_encoder_decoder=is_encoder_decoder,\n+            **kwargs,\n+        )\n+        # Get the precomputed image_hidden_states\n+        model_kwargs[\"image_hidden_states\"] = outputs.image_hidden_states\n+        return model_kwargs\n+\n+\n+__all__ = [\"SmolVLMForConditionalGeneration\", \"SmolVLMPreTrainedModel\", \"SmolVLMModel\", \"SmolVLMVisionTransformer\"]"
        },
        {
            "sha": "e4df055442bcd474fcd2eadfac48454b11926dbf",
            "filename": "src/transformers/models/smolvlm/modular_smolvlm.py",
            "status": "added",
            "additions": 387,
            "deletions": 0,
            "changes": 387,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fmodular_smolvlm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fmodular_smolvlm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fmodular_smolvlm.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -0,0 +1,387 @@\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Inc. team. All rights reserved.\n+# Written by Orr Zohar\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+import torch.utils.checkpoint\n+from torch import nn\n+\n+from ...cache_utils import DynamicCache\n+from ...utils import (\n+    logging,\n+)\n+from ..idefics3.configuration_idefics3 import Idefics3Config, Idefics3VisionConfig\n+from ..idefics3.image_processing_idefics3 import Idefics3ImageProcessor\n+from ..idefics3.modeling_idefics3 import (\n+    Idefics3BaseModelOutputWithPast,\n+    Idefics3ForConditionalGeneration,\n+    Idefics3Model,\n+    Idefics3PreTrainedModel,\n+    Idefics3VisionTransformer,\n+)\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class SmolVLMVisionConfig(Idefics3VisionConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`SmolVLMVisionModel`]. It is used to instantiate a\n+    SmolVLM vision encoder according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the SigLIP checkpoint\n+    [google/siglip-so400m-patch14-384](https://huggingface.co/google/siglip-so400m-patch14-384) used in SmolVLM\n+    [HuggingFaceTB/SmolVLM2-2.2B-Instruct](https://huggingface.co/HuggingFaceTB/SmolVLM2-2.2B-Instruct).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 1152):\n+            Dimensionality of the encoder layers and the pooler layer.\n+        intermediate_size (`int`, *optional*, defaults to 3072):\n+            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+        num_hidden_layers (`int`, *optional*, defaults to 12):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_channels (`int`, *optional*, defaults to 3):\n+            Number of channels in the input images.\n+        image_size (`int`, *optional*, defaults to 224):\n+            The size (resolution) of each image.\n+        patch_size (`int`, *optional*, defaults to 32):\n+            The size (resolution) of each patch.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"gelu_pytorch_tanh\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+            `\"relu\"`, `\"selu\"` and `\"gelu_new\"` `\"quick_gelu\"` are supported.\n+        layer_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the layer normalization layers.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers.models.smolvlm.modeling_smolvlm import SmolVLMVisionTransformer\n+    >>> from transformers.models.smolvlm.configuration_smolvlm import SmolVLMVisionConfig\n+\n+    >>> # Initializing a SmolVLMVisionConfig with google/siglip-so400m-patch14-384 style configuration\n+    >>> configuration = SmolVLMVisionConfig()\n+\n+    >>> # Initializing a SmolVLMVisionTransformer (with random weights) from the google/siglip-so400m-patch14-384 style configuration\n+    >>> model = SmolVLMVisionTransformer(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"smolvlm_vision\"\n+    pass\n+\n+\n+class SmolVLMPreTrainedModel(Idefics3PreTrainedModel):\n+    pass\n+\n+\n+class SmolVLMVisionTransformer(Idefics3VisionTransformer):\n+    pass\n+\n+\n+class SmolVLMConfig(Idefics3Config):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`SmolVLMModel`]. It is used to instantiate a\n+    SmolVLM model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the model of the SmolVLM\n+    [HuggingFaceTB/SmolVLM2-2.2B-Instruct](https://huggingface.co/HuggingFaceTB/SmolVLM2-2.2B-Instruct) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should cache the key/value pairs of the attention mechanism. Only\n+            relevant if `config.is_decoder=True`.\n+        image_token_id (`int`, *optional*, defaults to 128257):\n+            The id of the \"image\" token.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether or not to tie the word embeddings with the token embeddings.\n+        vision_config (`IdeficsVisionConfig` or `dict`, *optional*, defaults to `IdeficsVisionConfig`):\n+            Custom vision config or dict for the vision tower\n+        text_config (`PretrainedConfig` or `dict`, *optional*, defaults to `LlamaConfig`):\n+            Custom text config or dict for the text model\n+        scale_factor (`int`, *optional*, defaults to 2):\n+            The scale factor for the image encoder.\n+        pad_token_id (`int`, *optional*, defaults to 128002):\n+            The id of the padding token.\n+\n+    Example:\n+    ```python\n+    >>> from transformers import SmolVLMModel, SmolVLMConfig\n+    >>> # Initializing configuration\n+    >>> configuration = SmolVLMConfig()\n+    >>> # Initializing a model from the configuration\n+    >>> model = SmolVLMModel(configuration)\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"smolvlm\"\n+    pass\n+\n+\n+class SmolVLMImageProcessor(Idefics3ImageProcessor):\n+    pass\n+\n+\n+class SmolVLMBaseModelOutputWithPast(Idefics3BaseModelOutputWithPast):\n+    pass\n+\n+\n+class SmolVLMModel(Idefics3Model):\n+    \"\"\"\n+    A subclass of Idefics3Model. We do *not* remove or block the call to inputs_merger\n+    in forward. Instead, we override inputs_merger here with custom logic.\n+    \"\"\"\n+\n+    def inputs_merger(\n+        self, input_ids: torch.LongTensor, inputs_embeds: torch.Tensor, image_hidden_states: torch.Tensor\n+    ):\n+        _, patch_size, _ = image_hidden_states.shape\n+\n+        image_mask = input_ids == self.image_token_id\n+        num_image_tokens = image_mask.sum(dim=1)\n+        if not torch.all(num_image_tokens % patch_size == 0):\n+            raise ValueError(\"At least one sample has <image> tokens not divisible by patch_size.\")\n+\n+        blocks_per_sample = num_image_tokens // patch_size\n+\n+        offsets = torch.nn.functional.pad(blocks_per_sample.cumsum(dim=0), (1, 0), value=0)\n+        block_offset = offsets[:-1]\n+        row_cum = image_mask.cumsum(dim=-1)\n+        chunk_idx = (row_cum - 1) // patch_size\n+        local_idx = (row_cum - 1) % patch_size\n+        block_idx = block_offset.unsqueeze(1) + chunk_idx\n+\n+        image_embeds = torch.zeros_like(inputs_embeds)\n+        image_embeds[image_mask] = image_hidden_states[block_idx[image_mask], local_idx[image_mask], :]\n+\n+        merged_embeds = torch.where(image_mask.unsqueeze(-1), image_embeds, inputs_embeds)\n+        return merged_embeds\n+\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        pixel_values: Optional[torch.FloatTensor] = None,\n+        pixel_attention_mask: Optional[torch.BoolTensor] = None,\n+        image_hidden_states: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+    ) -> Union[Tuple, SmolVLMBaseModelOutputWithPast]:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        if self.training and self.text_model.gradient_checkpointing and use_cache:\n+            logger.warning_once(\n+                \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n+            )\n+            use_cache = False\n+\n+        # retrieve input_ids and inputs_embeds\n+        if input_ids is not None:\n+            batch_size, seq_length = input_ids.shape\n+        elif inputs_embeds is not None:\n+            batch_size, seq_length, _ = inputs_embeds.shape\n+        else:\n+            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n+\n+        past_seen_tokens = 0\n+        if use_cache:\n+            if past_key_values is None:\n+                past_key_values = DynamicCache()\n+            past_seen_tokens = past_key_values.get_seq_length()\n+\n+        if inputs_embeds is not None and input_ids is None and past_seen_tokens == 0:\n+            raise ValueError(\"When first calling the model, if input_embeds are passed, input_ids should not be None.\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.text_model.get_input_embeddings()(input_ids).to(input_ids.device)\n+\n+        # START VISUAL INPUTS INTEGRATION\n+        if pixel_values is not None and image_hidden_states is not None:\n+            raise ValueError(\"You cannot specify both pixel_values and image_hidden_states at the same time\")\n+        elif pixel_values is not None:\n+            batch_size, num_images, num_channels, height, width = pixel_values.shape\n+            pixel_values = pixel_values\n+            pixel_values = pixel_values.view(batch_size * num_images, *pixel_values.shape[2:])\n+\n+            # Remove padding images - padding images are full 0.\n+            nb_values_per_image = pixel_values.shape[1:].numel()\n+            real_images_inds = (pixel_values == 0.0).sum(dim=(-1, -2, -3)) != nb_values_per_image\n+\n+            if not any(real_images_inds):\n+                # no images, leave one empty image.\n+                real_images_inds[0] = True\n+\n+            pixel_values = pixel_values[real_images_inds].contiguous()\n+\n+            # Handle the vision attention mask\n+            if pixel_attention_mask is None:\n+                pixel_attention_mask = torch.ones(\n+                    size=[pixel_values.shape[i] for i in (0, 2, 3)],\n+                    dtype=torch.bool,\n+                    device=pixel_values.device,\n+                )\n+            else:\n+                # Remove padding images from the mask\n+                pixel_attention_mask = pixel_attention_mask.view(\n+                    batch_size * num_images, *pixel_attention_mask.shape[2:]\n+                )\n+                pixel_attention_mask = pixel_attention_mask[real_images_inds].contiguous()\n+\n+            patch_size = self.config.vision_config.patch_size\n+            patches_subgrid = pixel_attention_mask.unfold(dimension=1, size=patch_size, step=patch_size)\n+            patches_subgrid = patches_subgrid.unfold(dimension=2, size=patch_size, step=patch_size)\n+            patch_attention_mask = (patches_subgrid.sum(dim=(-1, -2)) > 0).bool()\n+\n+            # Get sequence from the vision encoder\n+            image_hidden_states = self.vision_model(\n+                pixel_values=pixel_values,\n+                patch_attention_mask=patch_attention_mask,\n+            ).last_hidden_state\n+\n+            # Modality projection & resampling\n+            image_hidden_states = self.connector(image_hidden_states)\n+\n+        elif image_hidden_states is not None:\n+            image_hidden_states = image_hidden_states.to(dtype=self.dtype, device=input_ids.device)\n+\n+        if inputs_embeds is not None and image_hidden_states is not None:\n+            # When we generate, we don't want to replace the potential image_token_id that we generated by images\n+            # that simply don't exist\n+            inputs_embeds = self.inputs_merger(\n+                input_ids=input_ids,\n+                inputs_embeds=inputs_embeds,\n+                image_hidden_states=image_hidden_states,\n+            )\n+\n+        outputs = self.text_model(\n+            inputs_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+            cache_position=cache_position,\n+        )\n+\n+        if not return_dict:\n+            return tuple(v for v in [*outputs, image_hidden_states] if v is not None)\n+\n+        return SmolVLMBaseModelOutputWithPast(\n+            last_hidden_state=outputs.last_hidden_state,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            image_hidden_states=image_hidden_states,\n+        )\n+\n+\n+class SmolVLMForConditionalGeneration(Idefics3ForConditionalGeneration):\n+    \"\"\"\n+    A subclass of Idefics3ForConditionalGeneration that uses SmolVLMModel\n+    instead of the default Idefics3Model.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = SmolVLMModel(config)\n+        self.lm_head = nn.Linear(config.text_config.hidden_size, config.text_config.vocab_size, bias=False)\n+        self.post_init()\n+\n+    def forward(self, **super_kwargs):\n+        r\"\"\"\n+        Args:\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.vocab_size]` or `model.image_token_id` (where `model` is your instance of `SmolVLMForConditionalGeneration`).\n+                Tokens with indices set to `model.image_token_id` are ignored (masked), the loss is only\n+                computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> import requests\n+        >>> import torch\n+        >>> from PIL import Image\n+        >>> from io import BytesIO\n+\n+        >>> from transformers import AutoProcessor, AutoModelForImageTextToText\n+        >>> from transformers.image_utils import load_image\n+\n+        >>> # Note that passing the image urls (instead of the actual pil images) to the processor is also possible\n+        >>> image1 = load_image(\"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\")\n+        >>> image2 = load_image(\"https://cdn.britannica.com/59/94459-050-DBA42467/Skyline-Chicago.jpg\")\n+        >>> image3 = load_image(\"https://cdn.britannica.com/68/170868-050-8DDE8263/Golden-Gate-Bridge-San-Francisco.jpg\")\n+\n+        >>> processor = AutoProcessor.from_pretrained(\"HuggingFaceTB/SmolVLM2-2.2B-Instruct\")\n+        >>> model = AutoModelForImageTextToText.from_pretrained(\"HuggingFaceTB/SmolVLM2-2.2B-Instruct\", torch_dtype=torch.bfloat16, device_map=\"auto\")\n+\n+        >>> # Create inputs\n+        >>> messages = [\n+        ...     {\n+        ...         \"role\": \"user\",\n+        ...         \"content\": [\n+        ...             {\"type\": \"video\", \"path\": path/to/video},\n+        ...             {\"type\": \"text\", \"text\": \"What is happening in this video?\"},\n+        ...         ]\n+        ...     }\n+        ... ]\n+\n+        >>> inputs = processor.apply_chat_template([messages], add_generation_prompt=True)\n+\n+        >>> # Generate\n+        >>> generated_ids = model.generate(**inputs, max_new_tokens=256)\n+        >>> generated_texts = processor.batch_decode(generated_ids, skip_special_tokens=True)\n+\n+        >>> print(generated_texts)\n+        ```\"\"\"\n+        super().forward(**super_kwargs)\n+\n+\n+__all__ = [\n+    \"SmolVLMVisionConfig\",\n+    \"SmolVLMConfig\",\n+    \"SmolVLMImageProcessor\",\n+    \"SmolVLMForConditionalGeneration\",\n+    \"SmolVLMPreTrainedModel\",\n+    \"SmolVLMModel\",\n+    \"SmolVLMVisionTransformer\",\n+]"
        },
        {
            "sha": "f5a1ff57a9f74a8207beece64574dcd0f0090711",
            "filename": "src/transformers/models/smolvlm/processing_smolvlm.py",
            "status": "added",
            "additions": 454,
            "deletions": 0,
            "changes": 454,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fprocessing_smolvlm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fprocessing_smolvlm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fprocessing_smolvlm.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -0,0 +1,454 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"\n+Processor class for SmolVLM.\n+\"\"\"\n+\n+import copy\n+from datetime import timedelta\n+from typing import TYPE_CHECKING, Dict, List, Optional, Union\n+\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_utils import (\n+    ImageInput,\n+    VideoInput,\n+    make_batched_videos,\n+    make_nested_list_of_images,\n+)\n+from ...processing_utils import ImagesKwargs, ProcessingKwargs, ProcessorMixin, Unpack\n+from ...tokenization_utils_base import BatchEncoding, TextInput\n+from ...utils import is_num2words_available, logging\n+from .video_processing_smolvlm import (\n+    DEFAULT_MEDIA_OUTTRO,\n+    DEFAULT_VIDEO_INTRO,\n+    FRAME_TIMESTAMP_MESSAGE,\n+    smolvlm_sample_indices_fn,\n+)\n+\n+\n+if TYPE_CHECKING:\n+    from ...tokenization_utils_base import PreTokenizedInput\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+if is_num2words_available():\n+    from num2words import num2words\n+else:\n+    num2words = None\n+\n+\n+def _prompt_split_image(\n+    image_seq_len, image_rows, image_cols, fake_token_around_image, image_token, global_image_token\n+):\n+    \"\"\"Prompt with expanded image tokens for when the image is split into patches.\"\"\"\n+    text_split_images = \"\"\n+    for n_h in range(image_rows):\n+        for n_w in range(image_cols):\n+            text_split_images += (\n+                f\"{fake_token_around_image}\" + f\"<row_{n_h + 1}_col_{n_w + 1}>\" + f\"{image_token}\" * image_seq_len\n+            )\n+        text_split_images += \"\\n\"\n+\n+    text_split_images += (\n+        f\"\\n{fake_token_around_image}\"\n+        + f\"{global_image_token}\"\n+        + f\"{image_token}\" * image_seq_len\n+        + f\"{fake_token_around_image}\"\n+    )\n+    return text_split_images\n+\n+\n+def _prompt_single_image(image_seq_len, fake_token_around_image, image_token, global_image_token):\n+    \"\"\"Prompt with expanded image tokens for a single image.\"\"\"\n+    return (\n+        f\"{fake_token_around_image}\"\n+        + f\"{global_image_token}\"\n+        + f\"{image_token}\" * image_seq_len\n+        + f\"{fake_token_around_image}\"\n+    )\n+\n+\n+def get_image_prompt_string(\n+    image_rows, image_cols, image_seq_len, fake_token_around_image, image_token, global_image_token\n+):\n+    if image_rows == 0 and image_cols == 0:\n+        return _prompt_single_image(\n+            image_seq_len,\n+            fake_token_around_image=fake_token_around_image,\n+            image_token=image_token,\n+            global_image_token=global_image_token,\n+        )\n+    return _prompt_split_image(\n+        image_seq_len, image_rows, image_cols, fake_token_around_image, image_token, global_image_token\n+    )\n+\n+\n+class SmolVLMImagesKwargs(ImagesKwargs, total=False):\n+    return_row_col_info: Optional[bool]\n+    max_image_size: Optional[Dict[str, int]]\n+\n+\n+class SmolVLMProcessorKwargs(ProcessingKwargs, total=False):\n+    images_kwargs: SmolVLMImagesKwargs\n+\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"add_special_tokens\": True,\n+            \"padding\": False,\n+            \"is_split_into_words\": False,\n+        },\n+        \"images_kwargs\": {\n+            \"return_row_col_info\": True,\n+        },\n+    }\n+\n+\n+class SmolVLMProcessor(ProcessorMixin):\n+    r\"\"\"\n+    Constructs a SmolVLM processor which wraps a LLama tokenizer and SmolVLM image processor into a single processor.\n+\n+    [`SmolVLMProcessor`] offers all the functionalities of [`SmolVLMImageProcessor`] and [`SmolVLMTokenizerFast`]. See\n+    the docstring of [`~IdeficsProcessor.__call__`] and [`~IdeficsProcessor.decode`] for more information.\n+\n+    Args:\n+        image_processor (`SmolVLMImageProcessor`):\n+            An instance of [`SmolVLMImageProcessor`]. The image processor is a required input.\n+        tokenizer (`PreTrainedTokenizerBase`, *optional*):\n+            An instance of [`PreTrainedTokenizerBase`]. This should correspond with the model's text model. The tokenizer is a required input.\n+        image_seq_len (`int`, *optional*, defaults to 169):\n+            The length of the image sequence i.e. the number of <image> tokens per image in the input.\n+            This parameter is used to build the string from the input prompt and image tokens and should match the\n+            value the model used. It is computed as: image_seq_len = int(((image_size // patch_size) ** 2) / (scale_factor**2))\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    attributes = [\"image_processor\", \"tokenizer\"]\n+    valid_kwargs = [\"image_seq_len\", \"chat_template\"]\n+    image_processor_class = \"SmolVLMImageProcessor\"\n+    tokenizer_class = \"AutoTokenizer\"\n+\n+    def __init__(self, image_processor, tokenizer=None, image_seq_len: int = 169, chat_template: str = None, **kwargs):\n+        self.fake_image_token = getattr(tokenizer, \"fake_image_token\", \"<fake_token_around_image>\")\n+        self.image_token = getattr(tokenizer, \"image_token\", \"<image>\")\n+        self.end_of_utterance_token = getattr(tokenizer, \"end_of_utterance_token\", \"<end_of_utterance>\")\n+        self.global_image_token = getattr(tokenizer, \"global_image_token\", \"<global-img>\")\n+        self.image_seq_len = image_seq_len\n+\n+        self.video_size = image_processor.video_sampling[\"video_size\"]\n+        self.image_size = image_processor.size\n+\n+        self.do_image_splitting = image_processor.do_image_splitting\n+        self.do_video_splitting = image_processor.video_sampling.get(\"do_image_splitting\", False)\n+\n+        self.default_max_frames = image_processor.video_sampling[\"max_frames\"]\n+        self.default_fps = image_processor.video_sampling[\"fps\"]\n+        # Matches one or more occurrences of <row_x_col_y> tags (where x and y are digits, optionally surrounded by newline characters\n+        # self._regex_to_remove_extra_special_tokens = re.compile(r\"(<row_\\d+_col_\\d+>\\n?)+\")\n+\n+        if not num2words:\n+            raise ImportError(\n+                \"Package `num2words` is required to run SmolVLM processor. Install it with `pip install num2words`.\"\n+            )\n+\n+        super().__init__(image_processor, tokenizer, chat_template=chat_template, **kwargs)\n+\n+    def process_vision(self, text, images, output_kwargs, do_image_splitting=False, image_processor_size=None):\n+        if text is not None:\n+            n_images_in_text = [sample.count(self.image_token) for sample in text]\n+\n+        n_images_in_images = [len(sublist) for sublist in images]\n+        image_inputs = self.image_processor(\n+            images, do_image_splitting=do_image_splitting, size=image_processor_size, **output_kwargs[\"images_kwargs\"]\n+        )\n+\n+        if text is None:\n+            return None, image_inputs\n+\n+        if n_images_in_images != n_images_in_text:\n+            raise ValueError(\n+                f\"The number of images in the text {n_images_in_text} and images {n_images_in_images} should be the same.\"\n+            )\n+        image_rows = image_inputs.pop(\"rows\", [[0] * len(text)])\n+        image_cols = image_inputs.pop(\"cols\", [[0] * len(text)])\n+\n+        prompt_strings = []\n+        for sample, sample_rows, sample_cols in zip(text, image_rows, image_cols):\n+            # Replace the image token with fake tokens around the expanded image token sequence of length `image_seq_len`\n+            image_prompt_strings = []\n+            for n_rows, n_cols in zip(sample_rows, sample_cols):\n+                image_prompt_string = get_image_prompt_string(\n+                    n_rows,\n+                    n_cols,\n+                    self.image_seq_len,\n+                    image_token=self.image_token,\n+                    fake_token_around_image=self.fake_image_token,\n+                    global_image_token=self.global_image_token,\n+                )\n+                image_prompt_strings.append(image_prompt_string)\n+\n+            split_sample = sample.split(self.image_token)\n+            if len(split_sample) == 0:\n+                raise ValueError(\"The image token should be present in the text.\")\n+\n+            # Place in the image prompt strings where the image tokens are\n+            sample = split_sample[0]\n+            for i, image_prompt_string in enumerate(image_prompt_strings):\n+                sample += image_prompt_string + split_sample[i + 1]\n+            prompt_strings.append(sample)\n+\n+        return prompt_strings, image_inputs\n+\n+    def __call__(\n+        self,\n+        images: Union[ImageInput, List[ImageInput], List[List[ImageInput]]] = None,\n+        text: Union[TextInput, \"PreTokenizedInput\", List[TextInput], List[\"PreTokenizedInput\"]] = None,\n+        audio=None,\n+        videos: VideoInput = None,\n+        **kwargs: Unpack[SmolVLMProcessorKwargs],\n+    ) -> BatchEncoding:\n+        \"\"\"\n+        Processes the input prompts and returns a BatchEncoding.\n+\n+        Example:\n+\n+        ```python\n+        >>> import requests\n+        >>> from transformers import SmolVLMProcessor\n+        >>> from transformers.image_utils import load_image\n+\n+        >>> processor = SmolVLMProcessor.from_pretrained(\"HuggingFaceM4/SmolVLM2-256M-Video-Instruct\")\n+        >>> processor.image_processor.do_image_splitting = False  # Force as False to simplify the example\n+\n+        >>> url1 = \"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\"\n+        >>> url2 = \"https://cdn.britannica.com/59/94459-050-DBA42467/Skyline-Chicago.jpg\"\n+\n+        >>> image1, image2 = load_image(url1), load_image(url2)\n+        >>> images = [[image1], [image2]]\n+\n+        >>> text = [\n+        ...     \"<image>In this image, we see\",\n+        ...     \"bla bla bla<image>\",\n+        ... ]\n+        >>> outputs = processor(images=images, text=text, return_tensors=\"pt\", padding=True)\n+        >>> input_ids = outputs.input_ids\n+        >>> input_tokens = processor.tokenizer.batch_decode(input_ids)\n+        >>> print(input_tokens)\n+        ['<|begin_of_text|><fake_token_around_image><global-img>((<image>)*169)<fake_token_around_image> In this image, we see', '<|reserved_special_token_0|><|reserved_special_token_0|><|reserved_special_token_0|><|begin_of_text|>bla bla bla<fake_token_around_image><global-img>((<image>)*169)<fake_token_around_image>']\n+        ```\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`, *optional*):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. If is of type `List[ImageInput]`, it's assumed that this is for a single prompt i.e. of batch size 1.\n+            text (`Union[TextInput, PreTokenizedInput, List[TextInput], List[PreTokenizedInput]]`, *optional*):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+                Wherever an image token, `<image>` is encountered it is expanded to\n+                `<fake_token_around_image>` + `<row_x_col_y>` + `<image>` * `image_seq_len` * <fake_token_around_image>`.\n+            return_tensors (`Union[str, TensorType]`, *optional*):\n+                If set, will return tensors of a particular framework. See [`PreTrainedTokenizerFast.__call__`] for more\n+                information.\n+        \"\"\"\n+        if text is None and images is None and videos is None:\n+            raise ValueError(\"You must provide one of `text`, `images` or `videos'.\")\n+\n+        if text is None and ((images is None) ^ (videos is not None)):\n+            raise ValueError(\"You must specify exactly one of `images` or `videos`\")\n+\n+        output_kwargs = self._merge_kwargs(\n+            SmolVLMProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+\n+        if text is not None:\n+            if isinstance(text, str):\n+                text = [text]\n+            elif not isinstance(text, list) and not isinstance(text[0], str):\n+                raise ValueError(\"Invalid input text. Please provide a string, or a list of strings\")\n+            n_images_in_text = sum([sample.count(self.image_token) for sample in text])\n+            if n_images_in_text > 0 and (images is None and videos is None):\n+                raise ValueError(f\"We detected {n_images_in_text} tokens in the text but no images/videos were passed\")\n+\n+        inputs = BatchFeature()\n+        # Images and videos are mutually exclusive, so process one which is present\n+        if images is not None:\n+            images = make_nested_list_of_images(images)\n+            text, vision_inputs = self.process_vision(\n+                text,\n+                images,\n+                output_kwargs,\n+                do_image_splitting=self.do_image_splitting,\n+                image_processor_size=self.image_size,\n+            )\n+            inputs.update(vision_inputs)\n+        elif videos is not None:\n+            videos = make_batched_videos(videos)\n+            text, vision_inputs = self.process_vision(\n+                text,\n+                videos,\n+                output_kwargs,\n+                do_image_splitting=self.do_image_splitting,\n+                image_processor_size=self.video_size,\n+            )\n+            inputs.update(vision_inputs)\n+\n+        if text is not None:\n+            text_inputs = self.tokenizer(text=text, **output_kwargs[\"text_kwargs\"])\n+            inputs.update(text_inputs)\n+\n+        return inputs\n+\n+    def _process_messages_for_chat_template(\n+        self,\n+        conversations: List[List[Dict[str, str]]],\n+        batch_images: List[ImageInput],\n+        batch_videos: List[VideoInput],\n+        batch_video_metadata: List[List[Dict[str, any]]],\n+        **chat_template_kwargs,\n+    ):\n+        \"\"\"\n+        Used within `apply_chat_template` when a model has special way to process conversation history. For example,\n+        video models might want to specify in the prompt the duration of video or which frame indices at which timestamps\n+        were sampled. This information cannot be accessed before the video is loaded.\n+        For most models it is a no-op, must be overriden by model processors which require special processing.\n+        Args:\n+            conversation (`List[Dict, str, str]`):\n+                The conversation to process. Always comes in batched format.\n+            batch_images (`List[List[ImageInput]]`):\n+                Batch of images that were loaded from url/path defined in the conversation. The images\n+                are ordered in the same way as in the conversation. Comes in nested list format, one list of `PIL` images\n+                per batch.\n+            batch_videos (`List[List[ImageInput]]`):\n+                Batch of videos that were loaded from url/path defined in the conversation. The videos\n+                are ordered in the same way as in the conversation. Comes in nested list format, one list of 4D video arrays\n+                per batch.\n+            batch_video_metadata (`List[List[Dict[[str, any]]]]`):\n+                Batch of metadata returned from loading videos. That includes video fps, duration and total number of framer in original video.\n+                Metadata are ordered in the same way as `batch_videos`. Comes in nested list format, one list of 4D video arrays\n+                per batch.\n+        \"\"\"\n+        # We don't want to modify in-place the messages passed by user\n+        # The user might want to add new turn on conv and continue generation\n+        conversations = copy.deepcopy(conversations)\n+        batch_num_frames, batch_timestamps = [], []\n+        for metadata_list, video_list in zip(batch_video_metadata, batch_videos):\n+            for metadata, video in zip(metadata_list, video_list):\n+                duration_sec = getattr(metadata, \"duration\")\n+                frames_idx = getattr(metadata, \"frames_indices\")\n+                fps = getattr(metadata, \"fps\")\n+\n+                timestamps = []\n+                for idx, frame_np in zip(frames_idx, video):\n+                    sec = idx / fps\n+                    mm = int(sec // 60)\n+                    ss = int(sec % 60)\n+                    timestamps.append(f\"{mm:02d}:{ss:02d}\")\n+                batch_timestamps.append(timestamps)\n+                batch_num_frames.append(len(video))\n+\n+        for conversation in conversations:\n+            # For each message, scan content for {\"type\": \"video\"}\n+            for msg in conversation:\n+                if \"content\" not in msg:\n+                    continue\n+\n+                new_content = []\n+                for block in msg[\"content\"]:\n+                    if block.get(\"type\") == \"video\":\n+                        curr_timestamps = batch_timestamps.pop(0)\n+                        curr_num_frames = batch_num_frames.pop(0)\n+\n+                        # Build the video intro texts\n+                        td = timedelta(seconds=int(duration_sec))\n+                        new_content.append(\n+                            {\n+                                \"type\": \"text\",\n+                                \"text\": DEFAULT_VIDEO_INTRO.format(\n+                                    frame_count=num2words(curr_num_frames), video_duration=str(td)\n+                                ),\n+                            }\n+                        )\n+\n+                        # 2) Insert per-frame lines: \"Frame from {timestamp}:\", then an \"image\" block\n+                        for i, ts in enumerate(curr_timestamps):\n+                            new_content.append({\"type\": \"text\", \"text\": FRAME_TIMESTAMP_MESSAGE.format(timestamp=ts)})\n+                            new_content.append({\"type\": \"image\"})\n+\n+                        # 3) Optionally add an outro (e.g. \"Now answer the question:\")\n+                        new_content.append({\"type\": \"text\", \"text\": DEFAULT_MEDIA_OUTTRO})\n+                        # Do NOT add the original block => we skip it (since we've replaced it)\n+                    else:\n+                        # keep original block\n+                        new_content.append(block)\n+\n+                # update the content\n+                msg[\"content\"] = new_content\n+        return conversations\n+\n+    def batch_decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to SmolVLMTokenizerFast's [`~PreTrainedTokenizer.batch_decode`]. Please\n+        refer to the docstring of this method for more information.\n+        \"\"\"\n+        batched_decode_output = self.tokenizer.batch_decode(*args, **kwargs)\n+        return batched_decode_output\n+\n+    def decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to SmolVLMTokenizerFast's [`~PreTrainedTokenizer.decode`]. Please refer to\n+        the docstring of this method for more information.\n+        \"\"\"\n+        decode_output = self.tokenizer.decode(*args, **kwargs)\n+        return decode_output\n+\n+    @property\n+    def model_input_names(self):\n+        tokenizer_input_names = self.tokenizer.model_input_names\n+        image_processor_input_names = self.image_processor.model_input_names\n+        return list(dict.fromkeys(image_processor_input_names + tokenizer_input_names))\n+\n+    # Add model-specific video sampling method when applying the template\n+    def apply_chat_template(\n+        self,\n+        conversation,\n+        max_frames=None,\n+        target_fps=None,\n+        skip_secs=1,\n+        video_load_backend=\"pyav\",\n+        sample_indices_fn=None,\n+        **kwargs,\n+    ):\n+        max_frames = self.default_max_frames if max_frames is None else max_frames\n+        target_fps = self.default_fps if target_fps is None else target_fps\n+\n+        def sample_indices_fn_func(metadata, **fn_kwargs):\n+            return smolvlm_sample_indices_fn(\n+                metadata, max_frames=max_frames, target_fps=target_fps, skip_secs=skip_secs, **fn_kwargs\n+            )\n+\n+        # word of caution- we are blindly overriding a callable kwarg here.\n+        # typed kwargs would be a way to avoid that @molbap\n+        if not sample_indices_fn:\n+            sample_indices_fn = sample_indices_fn_func\n+        return super().apply_chat_template(\n+            conversation, video_load_backend=video_load_backend, sample_indices_fn=sample_indices_fn, **kwargs\n+        )\n+\n+\n+__all__ = [\"SmolVLMProcessor\"]"
        },
        {
            "sha": "4adde6be578b8b9a67c6b0ad3e4d9c95e667bfee",
            "filename": "src/transformers/models/smolvlm/video_processing_smolvlm.py",
            "status": "added",
            "additions": 90,
            "deletions": 0,
            "changes": 90,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fvideo_processing_smolvlm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fvideo_processing_smolvlm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fsmolvlm%2Fvideo_processing_smolvlm.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -0,0 +1,90 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+import numpy as np\n+\n+# Make sure these are imported from your library\n+from ...utils import logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+DEFAULT_SYSTEM_MESSAGE = \"You are a helpful language and vision assistant. You are able to understand the visual content that the user provides, and assist the user with a variety of tasks using natural language.\"\n+DEFAULT_VIDEO_INTRO = (\n+    \"You are provided the following series of {frame_count} frames from a {video_duration} [H:MM:SS] video.\\n\"\n+)\n+DEFAULT_MEDIA_OUTTRO = \"\\n\\n\"\n+FRAME_TIMESTAMP_MESSAGE = \"\\nFrame from {timestamp}:\"\n+\n+\n+def smolvlm_sample_indices_fn(metadata, max_frames, target_fps, skip_secs=0):\n+    \"\"\"\n+    Example sampling function which:\n+      - Uses `max_frames` (if provided) or calculates it from `fps` and metadata.\n+      - Applies a basic center-skip if fewer frames than available, otherwise\n+        optionally skips `skip_secs` from both the start and end.\n+      - Uniformly samples the desired number of frames between the start and end indices.\n+\n+    Args:\n+        max_frames (`int`):\n+            Maximum number of frames to sample.\n+        target_fps (`int`):\n+            Target frames to sample per second.\n+        metadata (`dict`):\n+            Contains video metadata such as \"n_frames\" and \"video_fps\".\n+        skip_secs (`float`, *optional*, defaults to 1.0):\n+            Number of seconds to skip from the start and end if the video is long enough.\n+\n+    Returns:\n+        numpy.ndarray:\n+            An array of unique frame indices to sample.\n+    \"\"\"\n+\n+    total_num_frames = getattr(metadata, \"total_num_frames\", 0)\n+    if total_num_frames <= 0:\n+        raise ValueError(f\"Invalid total_num_frames={total_num_frames} in metadata.\")\n+\n+    native_fps = getattr(metadata, \"fps\", 30.0)\n+    duration_seconds = getattr(metadata, \"duration\", 0)\n+\n+    if duration_seconds <= 0:\n+        raise ValueError(f\"Invalid duration_seconds={duration_seconds} in metadata.\")\n+\n+    # Step 1) Estimate how many frames we'd sample at `target_fps`, fallback if target_fps <= 0\n+    estimated_frames = int(round(target_fps * duration_seconds))\n+\n+    # Step 2) desired_frames\n+    desired_frames = min(estimated_frames, max_frames)\n+    if desired_frames < 1:\n+        desired_frames = 1\n+\n+    # Step 3) center skip logic\n+    start_idx = 0\n+    end_idx = total_num_frames - 1\n+\n+    if skip_secs > 0 and (duration_seconds - 2 * skip_secs) > (max_frames * target_fps):\n+        start_idx = int(skip_secs * native_fps)\n+        end_idx = int(total_num_frames - skip_secs * native_fps)\n+\n+    start_idx = max(0, start_idx)\n+    end_idx = min(end_idx, total_num_frames - 1)\n+    if start_idx >= end_idx:\n+        start_idx, end_idx = 0, total_num_frames - 1\n+\n+    indices = np.linspace(start_idx, end_idx, desired_frames, dtype=int)\n+    indices = np.unique(indices)\n+\n+    return indices"
        },
        {
            "sha": "079e575a5e3972d426829760ff3bd7ed2a36ab57",
            "filename": "src/transformers/utils/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Futils%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Futils%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2F__init__.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -165,6 +165,7 @@\n     is_natten_available,\n     is_ninja_available,\n     is_nltk_available,\n+    is_num2words_available,\n     is_onnx_available,\n     is_openai_available,\n     is_optimum_available,"
        },
        {
            "sha": "e04a785f2c9434c7c407b0ca155fefe720aa243d",
            "filename": "src/transformers/utils/dummy_pt_objects.py",
            "status": "modified",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -8849,6 +8849,48 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torch\"])\n \n \n+class SmolVLMForConditionalGeneration(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class SmolVLMModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class SmolVLMPreTrainedModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class SmolVLMProcessor(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class SmolVLMVisionConfig(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class SmolVLMVisionTransformer(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n class SpeechEncoderDecoderModel(metaclass=DummyObject):\n     _backends = [\"torch\"]\n "
        },
        {
            "sha": "d0e59a7d5c07394d96de2bb27e20fc23f271500b",
            "filename": "src/transformers/utils/dummy_vision_objects.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -639,6 +639,13 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"vision\"])\n \n \n+class SmolVLMImageProcessor(metaclass=DummyObject):\n+    _backends = [\"vision\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"vision\"])\n+\n+\n class SuperGlueImageProcessor(metaclass=DummyObject):\n     _backends = [\"vision\"]\n "
        },
        {
            "sha": "960079a9e388e788d703a28142dafd84c200584e",
            "filename": "src/transformers/utils/import_utils.py",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Futils%2Fimport_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/src%2Ftransformers%2Futils%2Fimport_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fimport_utils.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -196,6 +196,7 @@ def _is_package_available(pkg_name: str, return_version: bool = False) -> Union[\n _torchdistx_available = _is_package_available(\"torchdistx\")\n _torchvision_available, _torchvision_version = _is_package_available(\"torchvision\", return_version=True)\n _mlx_available = _is_package_available(\"mlx\")\n+_num2words_available = _is_package_available(\"num2words\")\n _hqq_available, _hqq_version = _is_package_available(\"hqq\", return_version=True)\n _tiktoken_available = _is_package_available(\"tiktoken\")\n _blobfile_available = _is_package_available(\"blobfile\")\n@@ -1280,6 +1281,10 @@ def is_mlx_available():\n     return _mlx_available\n \n \n+def is_num2words_available():\n+    return _num2words_available\n+\n+\n def is_tiktoken_available():\n     return _tiktoken_available and _blobfile_available\n "
        },
        {
            "sha": "9318f82d027926f82a00ac785d8f5e2432f1ae82",
            "filename": "tests/models/idefics3/test_modeling_idefics3.py",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/tests%2Fmodels%2Fidefics3%2Ftest_modeling_idefics3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/tests%2Fmodels%2Fidefics3%2Ftest_modeling_idefics3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fidefics3%2Ftest_modeling_idefics3.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -193,6 +193,10 @@ def test_inputs_embeds_matches_input_ids(self):\n     def test_flash_attn_2_inference_padding_right(self):\n         pass\n \n+    @unittest.skip(reason=\"Compile not yet supported in idefics3 models\")\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n     # We need to override as we need to prepare such that the image token is the last token\n     def test_resize_tokens_embeddings(self):\n         (original_config, inputs_dict) = self.model_tester.prepare_config_and_inputs_for_common()\n@@ -377,6 +381,10 @@ def test_flash_attn_2_fp32_ln(self):\n     def test_eager_matches_sdpa_generate(self):\n         pass\n \n+    @unittest.skip(reason=\"Compile not yet supported in Idefics3 models end-to-end\")\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n     # We need to override as we need to prepare such that the image token is the last token\n     def test_resize_tokens_embeddings(self):\n         (original_config, inputs_dict) = self.model_tester.prepare_config_and_inputs_for_common()"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/smolvlm/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/tests%2Fmodels%2Fsmolvlm%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/tests%2Fmodels%2Fsmolvlm%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fsmolvlm%2F__init__.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912"
        },
        {
            "sha": "273a4c0c3cd93838b7ad849dbd6c1cfbdf1ecbbd",
            "filename": "tests/models/smolvlm/test_image_processing_smolvlm.py",
            "status": "added",
            "additions": 284,
            "deletions": 0,
            "changes": 284,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/tests%2Fmodels%2Fsmolvlm%2Ftest_image_processing_smolvlm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/tests%2Fmodels%2Fsmolvlm%2Ftest_image_processing_smolvlm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fsmolvlm%2Ftest_image_processing_smolvlm.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -0,0 +1,284 @@\n+# coding=utf-8\n+# Copyright 2024 HuggingFace Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+import unittest\n+\n+import numpy as np\n+\n+from transformers.image_utils import PILImageResampling\n+from transformers.testing_utils import require_torch, require_vision\n+from transformers.utils import is_torch_available, is_vision_available\n+\n+from ...test_image_processing_common import ImageProcessingTestMixin\n+\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+    from transformers import SmolVLMImageProcessor\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+class SmolVLMImageProcessingTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=7,\n+        num_channels=3,\n+        num_images=1,\n+        image_size=18,\n+        min_resolution=30,\n+        max_resolution=40,\n+        do_resize=True,\n+        size=None,\n+        max_image_size=None,\n+        do_rescale=True,\n+        rescale_factor=1 / 255,\n+        do_normalize=True,\n+        image_mean=[0.5, 0.5, 0.5],\n+        image_std=[0.5, 0.5, 0.5],\n+        do_convert_rgb=True,\n+        do_pad=True,\n+        do_image_splitting=True,\n+        resample=PILImageResampling.LANCZOS,\n+    ):\n+        self.size = size if size is not None else {\"longest_edge\": max_resolution}\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.num_images = num_images\n+        self.image_size = image_size\n+        self.min_resolution = min_resolution\n+        self.max_resolution = max_resolution\n+        self.do_resize = do_resize\n+        self.resample = resample\n+        self.do_image_splitting = do_image_splitting\n+        self.max_image_size = max_image_size if max_image_size is not None else {\"longest_edge\": 20}\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean\n+        self.image_std = image_std\n+        self.do_convert_rgb = do_convert_rgb\n+        self.do_pad = do_pad\n+\n+    def prepare_image_processor_dict(self):\n+        return {\n+            \"do_convert_rgb\": self.do_convert_rgb,\n+            \"do_resize\": self.do_resize,\n+            \"size\": self.size,\n+            \"max_image_size\": self.max_image_size,\n+            \"do_rescale\": self.do_rescale,\n+            \"rescale_factor\": self.rescale_factor,\n+            \"do_normalize\": self.do_normalize,\n+            \"image_mean\": self.image_mean,\n+            \"image_std\": self.image_std,\n+            \"do_pad\": self.do_pad,\n+            \"do_image_splitting\": self.do_image_splitting,\n+        }\n+\n+    def get_expected_values(self, image_inputs, batched=False):\n+        \"\"\"\n+        This function computes the expected height and width when providing images to SmolVLMImageProcessor,\n+        assuming do_resize is set to True. The expected size in that case the max image size.\n+        \"\"\"\n+        return self.max_image_size[\"longest_edge\"], self.max_image_size[\"longest_edge\"]\n+\n+    def expected_output_image_shape(self, images):\n+        height, width = self.get_expected_values(images, batched=True)\n+        effective_nb_images = (\n+            self.num_images * 5 if self.do_image_splitting else 1\n+        )  # 5 is a squared image divided into 4 + global image resized\n+        return effective_nb_images, self.num_channels, height, width\n+\n+    def prepare_image_inputs(\n+        self,\n+        batch_size=None,\n+        min_resolution=None,\n+        max_resolution=None,\n+        num_channels=None,\n+        num_images=None,\n+        size_divisor=None,\n+        equal_resolution=False,\n+        numpify=False,\n+        torchify=False,\n+    ):\n+        \"\"\"This function prepares a list of PIL images, or a list of numpy arrays if one specifies numpify=True,\n+        or a list of PyTorch tensors if one specifies torchify=True.\n+\n+        One can specify whether the images are of the same resolution or not.\n+        \"\"\"\n+        assert not (numpify and torchify), \"You cannot specify both numpy and PyTorch tensors at the same time\"\n+\n+        batch_size = batch_size if batch_size is not None else self.batch_size\n+        min_resolution = min_resolution if min_resolution is not None else self.min_resolution\n+        max_resolution = max_resolution if max_resolution is not None else self.max_resolution\n+        num_channels = num_channels if num_channels is not None else self.num_channels\n+        num_images = num_images if num_images is not None else self.num_images\n+\n+        images_list = []\n+        for i in range(batch_size):\n+            images = []\n+            for j in range(num_images):\n+                if equal_resolution:\n+                    width = height = max_resolution\n+                else:\n+                    # To avoid getting image width/height 0\n+                    if size_divisor is not None:\n+                        # If `size_divisor` is defined, the image needs to have width/size >= `size_divisor`\n+                        min_resolution = max(size_divisor, min_resolution)\n+                    width, height = np.random.choice(np.arange(min_resolution, max_resolution), 2)\n+                images.append(np.random.randint(255, size=(num_channels, width, height), dtype=np.uint8))\n+            images_list.append(images)\n+\n+        if not numpify and not torchify:\n+            # PIL expects the channel dimension as last dimension\n+            images_list = [[Image.fromarray(np.moveaxis(image, 0, -1)) for image in images] for images in images_list]\n+\n+        if torchify:\n+            images_list = [[torch.from_numpy(image) for image in images] for images in images_list]\n+\n+        if numpify:\n+            # Numpy images are typically in channels last format\n+            images_list = [[image.transpose(1, 2, 0) for image in images] for images in images_list]\n+\n+        return images_list\n+\n+\n+@require_torch\n+@require_vision\n+class SmolVLMImageProcessingTest(ImageProcessingTestMixin, unittest.TestCase):\n+    image_processing_class = SmolVLMImageProcessor if is_vision_available() else None\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.image_processor_tester = SmolVLMImageProcessingTester(self)\n+\n+    @property\n+    def image_processor_dict(self):\n+        return self.image_processor_tester.prepare_image_processor_dict()\n+\n+    def test_image_processor_properties(self):\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        self.assertTrue(hasattr(image_processing, \"do_convert_rgb\"))\n+        self.assertTrue(hasattr(image_processing, \"do_resize\"))\n+        self.assertTrue(hasattr(image_processing, \"size\"))\n+        self.assertTrue(hasattr(image_processing, \"resample\"))\n+        self.assertTrue(hasattr(image_processing, \"do_image_splitting\"))\n+        self.assertTrue(hasattr(image_processing, \"max_image_size\"))\n+        self.assertTrue(hasattr(image_processing, \"do_rescale\"))\n+        self.assertTrue(hasattr(image_processing, \"rescale_factor\"))\n+        self.assertTrue(hasattr(image_processing, \"do_normalize\"))\n+        self.assertTrue(hasattr(image_processing, \"image_mean\"))\n+        self.assertTrue(hasattr(image_processing, \"image_std\"))\n+        self.assertTrue(hasattr(image_processing, \"do_pad\"))\n+        self.assertTrue(hasattr(image_processing, \"do_image_splitting\"))\n+\n+    def test_call_numpy(self):\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = self.image_processing_class(**self.image_processor_dict)\n+            # create random numpy tensors\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False, numpify=True)\n+            for sample_images in image_inputs:\n+                for image in sample_images:\n+                    self.assertIsInstance(image, np.ndarray)\n+\n+            # Test not batched input\n+            encoded_images = image_processing(image_inputs[0], return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape([image_inputs[0]])\n+            self.assertEqual(tuple(encoded_images.shape), (1, *expected_output_image_shape))\n+\n+            # Test batched\n+            encoded_images = image_processing(image_inputs, return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape(image_inputs)\n+            self.assertEqual(\n+                tuple(encoded_images.shape), (self.image_processor_tester.batch_size, *expected_output_image_shape)\n+            )\n+\n+    def test_call_numpy_4_channels(self):\n+        # SmolVLM always processes images as RGB, so it always returns images with 3 channels\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processor_dict = self.image_processor_dict\n+            image_processing = self.image_processing_class(**image_processor_dict)\n+            # create random numpy tensors\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False, numpify=True)\n+\n+            for sample_images in image_inputs:\n+                for image in sample_images:\n+                    self.assertIsInstance(image, np.ndarray)\n+\n+            # Test not batched input\n+            encoded_images = image_processing(image_inputs[0], return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape([image_inputs[0]])\n+            self.assertEqual(tuple(encoded_images.shape), (1, *expected_output_image_shape))\n+\n+            # Test batched\n+            encoded_images = image_processing(image_inputs, return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape(image_inputs)\n+            self.assertEqual(\n+                tuple(encoded_images.shape), (self.image_processor_tester.batch_size, *expected_output_image_shape)\n+            )\n+\n+    def test_call_pil(self):\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = self.image_processing_class(**self.image_processor_dict)\n+            # create random PIL images\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False)\n+            for images in image_inputs:\n+                for image in images:\n+                    self.assertIsInstance(image, Image.Image)\n+\n+            # Test not batched input\n+            encoded_images = image_processing(image_inputs[0], return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape([image_inputs[0]])\n+            self.assertEqual(tuple(encoded_images.shape), (1, *expected_output_image_shape))\n+\n+            # Test batched\n+            encoded_images = image_processing(image_inputs, return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape(image_inputs)\n+            self.assertEqual(\n+                tuple(encoded_images.shape), (self.image_processor_tester.batch_size, *expected_output_image_shape)\n+            )\n+\n+    def test_call_pytorch(self):\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = self.image_processing_class(**self.image_processor_dict)\n+            # create random PyTorch tensors\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False, torchify=True)\n+\n+            for images in image_inputs:\n+                for image in images:\n+                    self.assertIsInstance(image, torch.Tensor)\n+\n+            # Test not batched input\n+            encoded_images = image_processing(image_inputs[0], return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape([image_inputs[0]])\n+            self.assertEqual(tuple(encoded_images.shape), (1, *expected_output_image_shape))\n+\n+            # Test batched\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape(image_inputs)\n+            encoded_images = image_processing(image_inputs, return_tensors=\"pt\").pixel_values\n+            self.assertEqual(\n+                tuple(encoded_images.shape),\n+                (self.image_processor_tester.batch_size, *expected_output_image_shape),\n+            )"
        },
        {
            "sha": "a0cc898c2c611470420e3ac2c514486cde9a5e8b",
            "filename": "tests/models/smolvlm/test_modeling_smolvlm.py",
            "status": "added",
            "additions": 591,
            "deletions": 0,
            "changes": 591,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/tests%2Fmodels%2Fsmolvlm%2Ftest_modeling_smolvlm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/tests%2Fmodels%2Fsmolvlm%2Ftest_modeling_smolvlm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fsmolvlm%2Ftest_modeling_smolvlm.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -0,0 +1,591 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch SmolVLM model.\"\"\"\n+\n+import copy\n+import unittest\n+from io import BytesIO\n+\n+import pytest\n+import requests\n+from parameterized import parameterized\n+\n+from transformers import (\n+    AutoProcessor,\n+    is_torch_available,\n+    is_vision_available,\n+)\n+from transformers.testing_utils import (\n+    cleanup,\n+    require_torch,\n+    require_torch_sdpa,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import ModelTesterMixin, floats_tensor, ids_tensor\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import (\n+        SmolVLMConfig,\n+        SmolVLMForConditionalGeneration,\n+        SmolVLMModel,\n+    )\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+class SmolVLMVisionText2TextModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        is_training=True,\n+        batch_size=2,\n+        scale_factor=2,\n+        num_images=2,\n+        vision_config={\n+            \"image_size\": 16,\n+            \"patch_size\": 4,\n+            \"hidden_size\": 32,\n+            \"num_hidden_layers\": 2,\n+            \"num_attention_heads\": 4,\n+            \"intermediate_size\": 32,\n+            \"dropout\": 0.1,\n+            \"attention_dropout\": 0.1,\n+            \"initializer_range\": 0.02,\n+        },\n+        text_config={\n+            \"vocab_size\": 100,\n+            \"hidden_size\": 64,\n+            \"intermediate_size\": 56,\n+            \"num_hidden_layers\": 3,\n+            \"num_attention_heads\": 2,\n+            \"num_key_value_heads\": 2,\n+            \"hidden_act\": \"silu\",\n+            \"max_position_embeddings\": 256,\n+            \"initializer_range\": 0.02,\n+            \"rms_norm_eps\": 1e-6,\n+            \"pad_token_id\": 2,\n+            \"bos_token_id\": 0,\n+            \"eos_token_id\": 1,\n+            \"image_token_id\": 57,\n+            \"tie_word_embeddings\": False,\n+            \"rope_theta\": 10000.0,\n+            \"sliding_window\": 32,\n+            \"attention_dropout\": 0.0,\n+        },\n+        use_cache=False,\n+        tie_word_embeddings=False,\n+        image_token_id=57,\n+    ):\n+        self.parent = parent\n+        self.is_training = is_training\n+        self.batch_size = batch_size\n+        self.num_images = num_images\n+        self.scale_factor = scale_factor\n+        self.seq_length = (\n+            int(((vision_config[\"image_size\"] // vision_config[\"patch_size\"]) ** 2) / (self.scale_factor**2))\n+            * self.num_images\n+        )\n+        self.use_cache = use_cache\n+        self.image_token_id = image_token_id\n+        self.tie_word_embeddings = tie_word_embeddings\n+        # Hack - add properties here so use common tests\n+        self.vocab_size = text_config[\"vocab_size\"]\n+        self.num_hidden_layers = text_config[\"num_hidden_layers\"]\n+        self.num_attention_heads = text_config[\"num_attention_heads\"]\n+        self.hidden_size = text_config[\"hidden_size\"]\n+\n+        self.vision_config = vision_config\n+        self.text_config = text_config\n+\n+    def get_config(self):\n+        return SmolVLMConfig(\n+            use_cache=self.use_cache,\n+            image_token_id=self.image_token_id,\n+            tie_word_embeddings=self.tie_word_embeddings,\n+            vision_config=self.vision_config,\n+            text_config=self.text_config,\n+            vocab_size=self.vocab_size,\n+            scale_factor=self.scale_factor,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        pixel_values = floats_tensor(\n+            [\n+                self.batch_size,\n+                self.num_images,\n+                3,  # SmolVLMImageProcessor always generates RGB pixel values\n+                self.vision_config[\"image_size\"],\n+                self.vision_config[\"image_size\"],\n+            ]\n+        )\n+        config = self.get_config()\n+\n+        return config, pixel_values\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], config.text_config.vocab_size - 2) + 1\n+\n+        # For simplicity just set the last n tokens to the image token\n+        n_image_tokens_per_batch = self.seq_length\n+        input_ids[:, -n_image_tokens_per_batch:] = self.image_token_id\n+        attention_mask = input_ids.ne(1).to(torch_device)\n+        inputs_dict = {\n+            \"pixel_values\": pixel_values,\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+        }\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class SmolVLMModelTest(ModelTesterMixin, unittest.TestCase):\n+    \"\"\"\n+    Model tester for `SmolVLM`.\n+    \"\"\"\n+\n+    all_model_classes = (SmolVLMModel,) if is_torch_available() else ()\n+    fx_compatible = False\n+    test_torchscript = False\n+    test_pruning = False\n+    test_resize_embeddings = True\n+    test_head_masking = False\n+\n+    def setUp(self):\n+        self.model_tester = SmolVLMVisionText2TextModelTester(self)\n+        self.config_tester = ConfigTester(\n+            self, config_class=SmolVLMConfig, has_text_modality=False, common_properties=[\"image_token_id\"]\n+        )\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    @unittest.skip(reason=\"input_embeds cannot be passed in without input_ids\")\n+    def test_inputs_embeds():\n+        pass\n+\n+    @unittest.skip(reason=\"input_embeds cannot be passed in without input_ids\")\n+    def test_inputs_embeds_matches_input_ids(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Model does not support padding right\")\n+    def test_flash_attn_2_inference_padding_right(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Compile not yet supported in SmolVLM models\")\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Compile not yet supported in SmolVLM models\")\n+    def test_sdpa_can_dispatch_on_flash(self):\n+        pass\n+\n+    # We need to override as we need to prepare such that the image token is the last token\n+    def test_resize_tokens_embeddings(self):\n+        (original_config, inputs_dict) = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            config = copy.deepcopy(original_config)\n+            model = model_class(config)\n+            model.to(torch_device)\n+\n+            if self.model_tester.is_training is False:\n+                model.eval()\n+\n+            model_vocab_size = config.text_config.vocab_size\n+            # Retrieve the embeddings and clone theme\n+            model_embed = model.resize_token_embeddings(model_vocab_size)\n+            cloned_embeddings = model_embed.weight.clone()\n+\n+            # Check that resizing the token embeddings with a larger vocab size increases the model's vocab size\n+            model_embed = model.resize_token_embeddings(model_vocab_size + 10)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size + 10)\n+            # Check that it actually resizes the embeddings matrix\n+            self.assertEqual(model_embed.weight.shape[0], cloned_embeddings.shape[0] + 10)\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that resizing the token embeddings with a smaller vocab size decreases the model's vocab size\n+            model_embed = model.resize_token_embeddings(model_vocab_size - 15)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size - 15)\n+            # Check that it actually resizes the embeddings matrix\n+            self.assertEqual(model_embed.weight.shape[0], cloned_embeddings.shape[0] - 15)\n+\n+            # Ignore copy\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            # Input ids should be clamped to the maximum size of the vocabulary - 1 and the image token should be the last token\n+            inputs_dict[\"input_ids\"].clamp_(max=model_vocab_size - 15 - 2)\n+            n_images = self.model_tester.num_images * self.model_tester.seq_length\n+            model.image_token_id = model_vocab_size - 15 - 1\n+            inputs_dict[\"input_ids\"][:, -n_images:] = model.image_token_id\n+\n+            # make sure that decoder_input_ids are resized as well\n+            if \"decoder_input_ids\" in inputs_dict:\n+                inputs_dict[\"decoder_input_ids\"].clamp_(max=model_vocab_size - 15 - 1)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that adding and removing tokens has not modified the first part of the embedding matrix.\n+            models_equal = True\n+            for p1, p2 in zip(cloned_embeddings, model_embed.weight):\n+                if p1.data.ne(p2.data).sum() > 0:\n+                    models_equal = False\n+\n+            self.assertTrue(models_equal)\n+\n+            config = copy.deepcopy(original_config)\n+            model = model_class(config)\n+            model.to(torch_device)\n+\n+            model_vocab_size = config.text_config.vocab_size\n+            model.resize_token_embeddings(model_vocab_size + 10, pad_to_multiple_of=1)\n+            self.assertTrue(model.config.text_config.vocab_size + 10, model_vocab_size)\n+\n+            model_embed = model.resize_token_embeddings(model_vocab_size, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0] // 64, 0)\n+\n+            self.assertTrue(model_embed.weight.shape[0], model.config.text_config.vocab_size)\n+            self.assertTrue(model.config.text_config.vocab_size, model.vocab_size)\n+\n+            model_embed = model.resize_token_embeddings(model_vocab_size + 13, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0] // 64, 0)\n+\n+            # Check that resizing a model to a multiple of pad_to_multiple leads to a model of exactly that size\n+            target_dimension = 128\n+            model_embed = model.resize_token_embeddings(target_dimension, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0], target_dimension)\n+\n+            with self.assertRaisesRegex(\n+                ValueError,\n+                \"Asking to pad the embedding matrix to a multiple of `1.3`, which is not and integer. Please make sure to pass an integer\",\n+            ):\n+                model.resize_token_embeddings(model_vocab_size, pad_to_multiple_of=1.3)\n+\n+    # We need to override as we need to prepare such that the image token is the last token\n+    def test_resize_embeddings_untied(self):\n+        (original_config, inputs_dict) = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        original_config.tie_word_embeddings = False\n+\n+        for model_class in self.all_model_classes:\n+            config = copy.deepcopy(original_config)\n+            model = model_class(config).to(torch_device)\n+\n+            # if no output embeddings -> leave test\n+            if model.get_output_embeddings() is None:\n+                continue\n+\n+            # Check that resizing the token embeddings with a larger vocab size increases the model's vocab size\n+            model_vocab_size = config.text_config.vocab_size\n+            model.resize_token_embeddings(model_vocab_size + 10)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size + 10)\n+            output_embeds = model.get_output_embeddings()\n+            self.assertEqual(output_embeds.weight.shape[0], model_vocab_size + 10)\n+            # Check bias if present\n+            if output_embeds.bias is not None:\n+                self.assertEqual(output_embeds.bias.shape[0], model_vocab_size + 10)\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that resizing the token embeddings with a smaller vocab size decreases the model's vocab size\n+            model.resize_token_embeddings(model_vocab_size - 15)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size - 15)\n+            # Check that it actually resizes the embeddings matrix\n+            output_embeds = model.get_output_embeddings()\n+            self.assertEqual(output_embeds.weight.shape[0], model_vocab_size - 15)\n+            # Check bias if present\n+            if output_embeds.bias is not None:\n+                self.assertEqual(output_embeds.bias.shape[0], model_vocab_size - 15)\n+\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            # Input ids should be clamped to the maximum size of the vocabulary - 1 and the image token should be the last token\n+            inputs_dict[\"input_ids\"].clamp_(max=model_vocab_size - 15 - 2)\n+            n_images = self.model_tester.num_images * self.model_tester.seq_length\n+            model.image_token_id = model_vocab_size - 15 - 1\n+            inputs_dict[\"input_ids\"][:, -n_images:] = model.image_token_id\n+\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+\n+@require_torch\n+class SmolVLMForConditionalGenerationModelTest(GenerationTesterMixin, ModelTesterMixin, unittest.TestCase):\n+    \"\"\"\n+    Model tester for `SmolVLMForConditionalGeneration`.\n+    \"\"\"\n+\n+    all_model_classes = (SmolVLMForConditionalGeneration,) if is_torch_available() else ()\n+    all_generative_model_classes = (SmolVLMForConditionalGeneration,) if is_torch_available() else ()\n+    pipeline_model_mapping = {\"image-text-to-text\": SmolVLMForConditionalGeneration} if is_torch_available() else ()\n+    fx_compatible = False\n+    test_pruning = False\n+    test_resize_embeddings = True\n+    test_head_masking = False\n+    test_torchscript = False\n+\n+    def setUp(self):\n+        self.model_tester = SmolVLMVisionText2TextModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=SmolVLMConfig, has_text_modality=False)\n+\n+    @unittest.skip(reason=\"input_embeds cannot be passed in without input_ids\")\n+    def test_inputs_embeds():\n+        pass\n+\n+    @unittest.skip(reason=\"Model does not support padding right\")\n+    def test_flash_attn_2_inference_padding_right(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Contrastive search is not implemented for VLMs that do cross-attn\")\n+    def test_contrastive_generate(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Contrastive search is not implemented for VLMs that do cross-attn\")\n+    def test_contrastive_generate_dict_outputs_use_cache(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Contrastive search is not implemented for VLMs that do cross-attn\")\n+    def test_contrastive_generate_low_memory(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"Prompt lookup decoding needs a way to indicate `bad_word_ids` that should not be suggested as candidates\"\n+    )\n+    def test_prompt_lookup_decoding_matches_greedy_search(self):\n+        pass\n+\n+    @unittest.skip(reason=\" FlashAttention only support fp16 and bf16 data type\")\n+    def test_flash_attn_2_fp32_ln(self):\n+        pass\n+\n+    @unittest.skip\n+    def test_training_gradient_checkpointing(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"This architecure seem to not compute gradients properly when using GC, check: https://github.com/huggingface/transformers/pull/27124\"\n+    )\n+    def test_training_gradient_checkpointing_use_reentrant(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"This architecure seem to not compute gradients properly when using GC, check: https://github.com/huggingface/transformers/pull/27124\"\n+    )\n+    def test_training_gradient_checkpointing_use_reentrant_false(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Unsupported\")\n+    def test_generate_from_inputs_embeds_0_greedy(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Unsupported\")\n+    def test_generate_from_inputs_embeds_1_beam_search(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Unsupported\")\n+    def test_generate_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Compile not yet supported in SmolVLM models\")\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Compile not yet supported in SmolVLM models\")\n+    def test_sdpa_can_dispatch_on_flash(self):\n+        pass\n+\n+    @pytest.mark.generate\n+    @require_torch_sdpa\n+    @slow\n+    @unittest.skip(\n+        reason=\"SmolVLM doesn't support SDPA for all backbones, vision backbones has only eager/FA2 attention\"\n+    )\n+    def test_eager_matches_sdpa_generate(self):\n+        pass\n+\n+    @parameterized.expand([(\"random\",), (\"same\",)])\n+    @unittest.skip(reason=\"Cache position is off by one leaving out image tokens, FIXME raushan\")\n+    def test_assisted_decoding_matches_greedy_search(self, assistant_type):\n+        pass\n+\n+    # We need to override as we need to prepare such that the image token is the last token\n+    def test_resize_tokens_embeddings(self):\n+        (original_config, inputs_dict) = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            config = copy.deepcopy(original_config)\n+            model = model_class(config)\n+            model.to(torch_device)\n+\n+            model_vocab_size = config.text_config.vocab_size\n+            # Retrieve the embeddings and clone theme\n+            model_embed = model.resize_token_embeddings(model_vocab_size)\n+            cloned_embeddings = model_embed.weight.clone()\n+\n+            # Check that resizing the token embeddings with a larger vocab size increases the model's vocab size\n+            model_embed = model.resize_token_embeddings(model_vocab_size + 10)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size + 10)\n+            # Check that it actually resizes the embeddings matrix\n+            self.assertEqual(model_embed.weight.shape[0], cloned_embeddings.shape[0] + 10)\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that resizing the token embeddings with a smaller vocab size decreases the model's vocab size\n+            model_embed = model.resize_token_embeddings(model_vocab_size - 15)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size - 15)\n+            # Check that it actually resizes the embeddings matrix\n+            self.assertEqual(model_embed.weight.shape[0], cloned_embeddings.shape[0] - 15)\n+\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            # Input ids should be clamped to the maximum size of the vocabulary - 1 and the image token should be the last token\n+            inputs_dict[\"input_ids\"].clamp_(max=model_vocab_size - 15 - 2)\n+            n_images = self.model_tester.num_images * self.model_tester.seq_length\n+            model.model.image_token_id = model_vocab_size - 15 - 1\n+            inputs_dict[\"input_ids\"][:, -n_images:] = model.model.image_token_id\n+\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that adding and removing tokens has not modified the first part of the embedding matrix.\n+            models_equal = True\n+            for p1, p2 in zip(cloned_embeddings, model_embed.weight):\n+                if p1.data.ne(p2.data).sum() > 0:\n+                    models_equal = False\n+\n+            self.assertTrue(models_equal)\n+\n+            config = copy.deepcopy(original_config)\n+            model = model_class(config)\n+            model.to(torch_device)\n+\n+            model_vocab_size = config.text_config.vocab_size\n+            model.resize_token_embeddings(model_vocab_size + 10, pad_to_multiple_of=1)\n+            self.assertTrue(model.config.text_config.vocab_size + 10, model_vocab_size)\n+\n+            model_embed = model.resize_token_embeddings(model_vocab_size, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0] // 64, 0)\n+\n+            self.assertTrue(model_embed.weight.shape[0], model.config.text_config.vocab_size)\n+            self.assertTrue(model.config.text_config.vocab_size, model.vocab_size)\n+\n+            model_embed = model.resize_token_embeddings(model_vocab_size + 13, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0] // 64, 0)\n+\n+            # Check that resizing a model to a multiple of pad_to_multiple leads to a model of exactly that size\n+            target_dimension = 128\n+            model_embed = model.resize_token_embeddings(target_dimension, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0], target_dimension)\n+\n+            with self.assertRaisesRegex(\n+                ValueError,\n+                \"Asking to pad the embedding matrix to a multiple of `1.3`, which is not and integer. Please make sure to pass an integer\",\n+            ):\n+                model.resize_token_embeddings(model_vocab_size, pad_to_multiple_of=1.3)\n+\n+    # We need to override as we need to prepare such that the image token is the last token\n+    def test_resize_embeddings_untied(self):\n+        (original_config, inputs_dict) = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        original_config.tie_word_embeddings = False\n+\n+        for model_class in self.all_model_classes:\n+            config = copy.deepcopy(original_config)\n+            model = model_class(config).to(torch_device)\n+\n+            # Check that resizing the token embeddings with a larger vocab size increases the model's vocab size\n+            model_vocab_size = config.text_config.vocab_size\n+            model.resize_token_embeddings(model_vocab_size + 10)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size + 10)\n+            output_embeds = model.get_output_embeddings()\n+            self.assertEqual(output_embeds.weight.shape[0], model_vocab_size + 10)\n+            # Check bias if present\n+            if output_embeds.bias is not None:\n+                self.assertEqual(output_embeds.bias.shape[0], model_vocab_size + 10)\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that resizing the token embeddings with a smaller vocab size decreases the model's vocab size\n+            model.resize_token_embeddings(model_vocab_size - 15)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size - 15)\n+            # Check that it actually resizes the embeddings matrix\n+            output_embeds = model.get_output_embeddings()\n+            self.assertEqual(output_embeds.weight.shape[0], model_vocab_size - 15)\n+            # Check bias if present\n+            if output_embeds.bias is not None:\n+                self.assertEqual(output_embeds.bias.shape[0], model_vocab_size - 15)\n+\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            # Input ids should be clamped to the maximum size of the vocabulary - 1 and the image token should be the last token\n+            inputs_dict[\"input_ids\"].clamp_(max=model_vocab_size - 15 - 2)\n+            n_images = self.model_tester.num_images * self.model_tester.seq_length\n+            model.model.image_token_id = model_vocab_size - 15 - 1\n+            inputs_dict[\"input_ids\"][:, -n_images:] = model.model.image_token_id\n+\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+\n+@require_torch\n+class SmolVLMForConditionalGenerationIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = AutoProcessor.from_pretrained(\"HuggingFaceTB/SmolVLM2-256M-Video-Instruct\")\n+        self.image1 = Image.open(\n+            BytesIO(\n+                requests.get(\n+                    \"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\"\n+                ).content\n+            )\n+        )\n+        self.image2 = Image.open(\n+            BytesIO(requests.get(\"https://cdn.britannica.com/59/94459-050-DBA42467/Skyline-Chicago.jpg\").content)\n+        )\n+        self.image3 = Image.open(\n+            BytesIO(\n+                requests.get(\n+                    \"https://thumbs.dreamstime.com/b/golden-gate-bridge-san-francisco-purple-flowers-california-echium-candicans-36805947.jpg\"\n+                ).content\n+            )\n+        )\n+\n+    def tearDown(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    @slow\n+    # TODO (Orr?) this is a dummy test to check if the model generates things that make sense.\n+    # Needs to be expanded to a tiny video\n+    def test_integration_test(self):\n+        model = SmolVLMForConditionalGeneration.from_pretrained(\n+            \"HuggingFaceTB/SmolVLM2-256M-Video-Instruct\",\n+            torch_dtype=torch.bfloat16,\n+            device_map=\"auto\",\n+        )\n+\n+        # Create inputs\n+        text = \"<image>In this image, we see\"\n+        images = self.image1\n+        inputs = self.processor(text=text, images=images, return_tensors=\"pt\", padding=True)\n+        inputs.to(device=torch_device, dtype=torch.bfloat16)\n+\n+        generated_ids = model.generate(**inputs, max_new_tokens=9)\n+        generated_texts = self.processor.batch_decode(generated_ids, skip_special_tokens=True)\n+\n+        expected_generated_text = \"\\n\\n\\n\\nIn this image, we see a view of the Statue of Liberty and the\"\n+        self.assertEqual(generated_texts[0], expected_generated_text)"
        },
        {
            "sha": "d276d92a50111f464845abee3564f70d7fc06063",
            "filename": "tests/models/smolvlm/test_processor_smolvlm.py",
            "status": "added",
            "additions": 655,
            "deletions": 0,
            "changes": 655,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/tests%2Fmodels%2Fsmolvlm%2Ftest_processor_smolvlm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/tests%2Fmodels%2Fsmolvlm%2Ftest_processor_smolvlm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fsmolvlm%2Ftest_processor_smolvlm.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -0,0 +1,655 @@\n+# coding=utf-8\n+# Copyright 2024 HuggingFace Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import shutil\n+import tempfile\n+import unittest\n+from io import BytesIO\n+from typing import Optional\n+\n+import numpy as np\n+import requests\n+\n+from transformers import SmolVLMProcessor\n+from transformers.models.auto.processing_auto import AutoProcessor\n+from transformers.testing_utils import require_av, require_torch, require_vision\n+from transformers.utils import is_vision_available\n+\n+from ...test_processing_common import ProcessorTesterMixin\n+\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+@require_torch\n+@require_vision\n+class SmolVLMProcessorTest(ProcessorTesterMixin, unittest.TestCase):\n+    processor_class = SmolVLMProcessor\n+    videos_input_name = \"pixel_values\"\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.tmpdirname = tempfile.mkdtemp()\n+        processor = SmolVLMProcessor.from_pretrained(\"HuggingFaceTB/SmolVLM2-256M-Video-Instruct\", image_seq_len=2)\n+        processor.save_pretrained(cls.tmpdirname)\n+        cls.image1 = Image.open(\n+            BytesIO(\n+                requests.get(\n+                    \"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\"\n+                ).content\n+            )\n+        )\n+        cls.image2 = Image.open(\n+            BytesIO(requests.get(\"https://cdn.britannica.com/59/94459-050-DBA42467/Skyline-Chicago.jpg\").content)\n+        )\n+        cls.image3 = Image.open(\n+            BytesIO(\n+                requests.get(\n+                    \"https://thumbs.dreamstime.com/b/golden-gate-bridge-san-francisco-purple-flowers-california-echium-candicans-36805947.jpg\"\n+                ).content\n+            )\n+        )\n+        cls.bos_token = processor.tokenizer.bos_token\n+        cls.image_token = processor.image_token\n+        cls.fake_image_token = processor.fake_image_token\n+        cls.global_img_token = processor.global_image_token\n+\n+        cls.bos_token_id = processor.tokenizer.convert_tokens_to_ids(cls.bos_token)\n+        cls.image_token_id = processor.tokenizer.convert_tokens_to_ids(cls.image_token)\n+        cls.fake_image_token_id = processor.tokenizer.convert_tokens_to_ids(cls.fake_image_token)\n+        cls.global_img_tokens_id = processor.tokenizer(cls.global_img_token, add_special_tokens=False)[\"input_ids\"]\n+        cls.padding_token_id = processor.tokenizer.pad_token_id\n+        cls.image_seq_len = processor.image_seq_len\n+\n+    def get_tokenizer(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).tokenizer\n+\n+    def get_image_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).image_processor\n+\n+    def get_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs)\n+\n+    def prepare_processor_dict(self):\n+        return {\n+            \"image_seq_len\": self.image_seq_len,\n+            \"chat_template\": \"<|im_start|>{% for message in messages %}{{message['role'] | capitalize}}{% if message['content'][0]['type'] == 'image' %}{{':'}}{% else %}{{': '}}{% endif %}{% for line in message['content'] %}{% if line['type'] == 'text' %}{{line['text']}}{% elif line['type'] == 'image' %}{{ '<image>' }}{% endif %}{% endfor %}<end_of_utterance>\\n{% endfor %}{% if add_generation_prompt %}{{ 'Assistant:' }}{% endif %}\",\n+        }\n+\n+    def get_split_image_expected_tokens(self, processor, image_rows, image_cols):\n+        text_split_images = []\n+        for n_h in range(image_rows):\n+            for n_w in range(image_cols):\n+                text_split_images += (\n+                    [self.fake_image_token_id]\n+                    + processor.tokenizer(f\"<row_{n_h + 1}_col_{n_w + 1}>\", add_special_tokens=False)[\"input_ids\"]\n+                    + [self.image_token_id] * self.image_seq_len\n+                )\n+            text_split_images += processor.tokenizer(\"\\n\", add_special_tokens=False)[\"input_ids\"]\n+        text_split_images = text_split_images[:-1]  # remove last newline\n+        # add double newline, as it gets its own token\n+        text_split_images += processor.tokenizer(\"\\n\\n\", add_special_tokens=False)[\"input_ids\"]\n+        text_split_images += (\n+            [self.fake_image_token_id]\n+            + self.global_img_tokens_id\n+            + [self.image_token_id] * self.image_seq_len\n+            + [self.fake_image_token_id]\n+        )\n+        return text_split_images\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        shutil.rmtree(cls.tmpdirname)\n+\n+    def test_process_interleaved_images_prompts_no_image_splitting(self):\n+        processor_components = self.prepare_components()\n+        processor_components[\"tokenizer\"] = self.get_component(\"tokenizer\", padding_side=\"left\")\n+        processor_components[\"image_processor\"] = self.get_component(\"image_processor\", do_image_splitting=False)\n+        processor_kwargs = self.prepare_processor_dict()\n+\n+        processor = self.processor_class(**processor_components, **processor_kwargs)\n+\n+        # Test that a single image is processed correctly\n+        inputs = processor(images=self.image1)\n+        image1_expected_size = (512, 512)\n+        self.assertEqual(np.array(inputs[\"pixel_values\"]).shape, (1, 1, 3, *image1_expected_size))\n+        self.assertEqual(np.array(inputs[\"pixel_attention_mask\"]).shape, (1, 1, *image1_expected_size))\n+        # fmt: on\n+\n+        # Test a single sample with image and text\n+        image_str = \"<image>\"\n+        text_str = \"In this image, we see\"\n+        text = image_str + text_str\n+        inputs = processor(text=text, images=self.image1)\n+\n+        # fmt: off\n+        tokenized_sentence = processor.tokenizer(text_str, add_special_tokens=False)\n+        expected_input_ids = [[self.fake_image_token_id] + self.global_img_tokens_id + [self.image_token_id] * self.image_seq_len + [self.fake_image_token_id] + tokenized_sentence[\"input_ids\"]]\n+        self.assertEqual(inputs[\"input_ids\"], expected_input_ids)\n+        self.assertEqual(inputs[\"attention_mask\"], [[1] * len(expected_input_ids[0])])\n+        self.assertEqual(np.array(inputs[\"pixel_values\"]).shape, (1, 1, 3, *image1_expected_size))\n+        self.assertEqual(np.array(inputs[\"pixel_attention_mask\"]).shape, (1, 1, *image1_expected_size))\n+        # fmt: on\n+\n+        # Test that batch is correctly processed\n+        image_str = \"<image>\"\n+        text_str_1 = \"In this image, we see\"\n+        text_str_2 = \"In this image, we see\"\n+\n+        text = [\n+            image_str + text_str_1,\n+            image_str + image_str + text_str_2,\n+        ]\n+        images = [[self.image1], [self.image2, self.image3]]\n+\n+        inputs = processor(text=text, images=images, padding=True)\n+\n+        # fmt: off\n+        tokenized_sentence_1 = processor.tokenizer(text_str_1, add_special_tokens=False)\n+        tokenized_sentence_2 = processor.tokenizer(text_str_2, add_special_tokens=False)\n+        image_tokens = [self.fake_image_token_id] + self.global_img_tokens_id + [self.image_token_id] * self.image_seq_len + [self.fake_image_token_id]\n+        expected_input_ids_1 = image_tokens + tokenized_sentence_1[\"input_ids\"]\n+        expected_input_ids_2 = 2 * image_tokens + tokenized_sentence_2[\"input_ids\"]\n+        # Pad the first input to match the second input\n+        pad_len = len(expected_input_ids_2) - len(expected_input_ids_1)\n+        padded_expected_input_ids_1 = [self.padding_token_id] * pad_len + expected_input_ids_1\n+\n+        self.assertEqual(\n+            inputs[\"input_ids\"], [padded_expected_input_ids_1, expected_input_ids_2]\n+        )\n+        self.assertEqual(\n+            inputs[\"attention_mask\"],\n+            [[0] * pad_len + [1] * len(expected_input_ids_1), [1] * len(expected_input_ids_2)]\n+        )\n+        self.assertEqual(np.array(inputs['pixel_values']).shape, (2, 2, 3, 512, 512))\n+        self.assertEqual(np.array(inputs['pixel_attention_mask']).shape, (2, 2, 512, 512))\n+        # fmt: on\n+\n+    def test_process_interleaved_images_prompts_image_splitting(self):\n+        processor_components = self.prepare_components()\n+        processor_components[\"tokenizer\"] = self.get_component(\"tokenizer\", padding_side=\"left\")\n+        processor_components[\"image_processor\"] = self.get_component(\"image_processor\", do_image_splitting=True)\n+        processor_kwargs = self.prepare_processor_dict()\n+\n+        processor = self.processor_class(**processor_components, **processor_kwargs)\n+\n+        # Test that a single image is processed correctly\n+        inputs = processor(images=self.image1)\n+        self.assertEqual(np.array(inputs[\"pixel_values\"]).shape, (1, 13, 3, 512, 512))\n+        self.assertEqual(np.array(inputs[\"pixel_attention_mask\"]).shape, (1, 13, 512, 512))\n+        # fmt: on\n+        self.maxDiff = None\n+\n+        # Test a single sample with image and text\n+        image_str = \"<image>\"\n+        text_str = \"In this image, we see\"\n+        text = image_str + text_str\n+        inputs = processor(text=text, images=self.image1)\n+\n+        # fmt: off\n+        tokenized_sentence = processor.tokenizer(text_str, add_special_tokens=False)\n+        split_image1_tokens = self.get_split_image_expected_tokens(processor, 3, 4)\n+        expected_input_ids_1 = [split_image1_tokens + tokenized_sentence[\"input_ids\"]]\n+        self.assertEqual(inputs[\"input_ids\"], expected_input_ids_1)\n+        self.assertEqual(inputs[\"attention_mask\"], [[1] * len(expected_input_ids_1[0])])\n+        self.assertEqual(np.array(inputs[\"pixel_values\"]).shape, (1, 13, 3, 512, 512))\n+        self.assertEqual(np.array(inputs[\"pixel_attention_mask\"]).shape, (1, 13, 512, 512))\n+        # fmt: on\n+\n+        # Test that batch is correctly processed\n+        image_str = \"<image>\"\n+        text_str_1 = \"In this image, we see\"\n+        text_str_2 = \"bla, bla\"\n+\n+        text = [\n+            image_str + text_str_1,\n+            text_str_2 + image_str + image_str,\n+        ]\n+        images = [[self.image1], [self.image2, self.image3]]\n+\n+        inputs = processor(text=text, images=images, padding=True)\n+\n+        # fmt: off\n+        tokenized_sentence_1 = processor.tokenizer(text_str_1, add_special_tokens=False)\n+        tokenized_sentence_2 = processor.tokenizer(text_str_2, add_special_tokens=False)\n+\n+        split_image1_tokens = self.get_split_image_expected_tokens(processor, 3, 4)\n+        split_image2_tokens = self.get_split_image_expected_tokens(processor, 4, 4)\n+        split_image3_tokens = self.get_split_image_expected_tokens(processor, 3, 4)\n+        expected_input_ids_1 = split_image1_tokens + tokenized_sentence_1[\"input_ids\"]\n+        expected_input_ids_2 = tokenized_sentence_2[\"input_ids\"] + split_image2_tokens + split_image3_tokens\n+        # Pad the first input to match the second input\n+        pad_len = len(expected_input_ids_2) - len(expected_input_ids_1)\n+        padded_expected_input_ids_1 = [self.padding_token_id] * pad_len + expected_input_ids_1\n+\n+        self.assertEqual(\n+            inputs[\"input_ids\"], [padded_expected_input_ids_1, expected_input_ids_2]\n+        )\n+        self.assertEqual(\n+            inputs[\"attention_mask\"],\n+            [[0] * pad_len + [1] * len(expected_input_ids_1), [1] * len(expected_input_ids_2)]\n+        )\n+        self.assertEqual(np.array(inputs['pixel_values']).shape, (2, 30, 3, 512, 512))\n+        self.assertEqual(np.array(inputs['pixel_attention_mask']).shape, (2, 30, 512, 512))\n+        # fmt: on\n+\n+    def test_add_special_tokens_processor(self):\n+        processor = self.get_processor()\n+\n+        image_str = \"<image>\"\n+        text_str = \"In this image, we see\"\n+        text = text_str + image_str\n+\n+        # fmt: off\n+        inputs = processor(text=text, images=self.image1, add_special_tokens=False)\n+        tokenized_sentence = processor.tokenizer(text_str, add_special_tokens=False)\n+        split_image1_tokens = self.get_split_image_expected_tokens(processor, 3, 4)\n+        expected_input_ids = [tokenized_sentence[\"input_ids\"] + split_image1_tokens]\n+        self.assertEqual(inputs[\"input_ids\"], expected_input_ids)\n+\n+        inputs = processor(text=text, images=self.image1)\n+        expected_input_ids = [tokenized_sentence[\"input_ids\"] + split_image1_tokens]\n+        self.assertEqual(inputs[\"input_ids\"], expected_input_ids)\n+        # fmt: on\n+\n+    @unittest.skip(reason=\"from @molbap @zucchini-nlp, passing non-nested images is error-prone and not recommended\")\n+    def test_non_nested_images_with_batched_text(self):\n+        processor = self.get_processor()\n+        processor.image_processor.do_image_splitting = False\n+\n+        image_str = \"<image>\"\n+        text_str_1 = \"In this image, we see\"\n+        text_str_2 = \"In this image, we see\"\n+\n+        text = [\n+            image_str + text_str_1,\n+            image_str + image_str + text_str_2,\n+        ]\n+        images = [[self.image1], [self.image2, self.image3]]\n+\n+        inputs = processor(text=text, images=images, padding=True)\n+\n+        self.assertEqual(np.array(inputs[\"pixel_values\"]).shape, (2, 2, 3, 512, 512))\n+        self.assertEqual(np.array(inputs[\"pixel_attention_mask\"]).shape, (2, 2, 512, 512))\n+\n+    # Copied from tests.models.idefics2.test_processor_idefics2.Idefics2ProcessorTest.test_process_interleaved_images_prompts_image_error\n+    def test_process_interleaved_images_prompts_image_error(self):\n+        processor = self.get_processor()\n+\n+        text = [\n+            \"This is a test sentence.\",\n+            \"In this other sentence we try some good things\",\n+        ]\n+        images = [[self.image1], [self.image2]]\n+        with self.assertRaises(ValueError):\n+            processor(text=text, images=images, padding=True)\n+        images = [[self.image1], []]\n+        with self.assertRaises(ValueError):\n+            processor(text=text, images=images, padding=True)\n+\n+        text = [\n+            \"This is a test sentence.<image>\",\n+            \"In this other sentence we try some good things<image>\",\n+        ]\n+        images = [[self.image1], [self.image2, self.image3]]\n+        with self.assertRaises(ValueError):\n+            processor(text=text, images=images, padding=True)\n+        images = [[], [self.image2]]\n+        with self.assertRaises(ValueError):\n+            processor(text=text, images=images, padding=True)\n+        images = [self.image1, self.image2, self.image3]\n+        with self.assertRaises(ValueError):\n+            processor(text=text, images=images, padding=True)\n+        images = [self.image1]\n+        with self.assertRaises(ValueError):\n+            processor(text=text, images=images, padding=True)\n+\n+        text = [\n+            \"This is a test sentence.\",\n+            \"In this other sentence we try some good things<image>\",\n+        ]\n+        images = [[self.image1], []]\n+        with self.assertRaises(ValueError):\n+            processor(text=text, images=images, padding=True)\n+        images = [[], [self.image2]]\n+        with self.assertRaises(ValueError):\n+            processor(text=text, images=images, padding=True)\n+        images = [self.image1, self.image2]\n+        with self.assertRaises(ValueError):\n+            processor(text=text, images=images, padding=True)\n+        images = [self.image1]\n+        with self.assertRaises(ValueError):\n+            processor(text=text, images=images, padding=True)\n+\n+    def test_apply_chat_template(self):\n+        # Message contains content which a mix of lists with images and image urls and string\n+        messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"text\", \"text\": \"What do these images show?\"},\n+                    {\"type\": \"image\"},\n+                    {\"type\": \"image\"},\n+                    \"What do these images show?\",\n+                ],\n+            },\n+            {\n+                \"role\": \"assistant\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"text\",\n+                        \"text\": \"The first image shows the statue of Liberty in New York. The second image picture depicts Idefix, the dog of Obelix in Asterix and Obelix.\",\n+                    }\n+                ],\n+            },\n+            {\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"And who is that?\"}]},\n+        ]\n+        processor = self.get_processor()\n+        # Make short sequence length to test that the fake tokens are added correctly\n+        rendered = processor.apply_chat_template(messages, add_generation_prompt=True)\n+\n+        expected_rendered = (\n+            \"<|im_start|>User: What do these images show?<image><image><end_of_utterance>\\n\"\n+            \"Assistant: The first image shows the statue of Liberty in New York. The second image picture depicts Idefix, the dog of Obelix in Asterix and Obelix.<end_of_utterance>\\n\"\n+            \"User: And who is that?<end_of_utterance>\\n\"\n+            \"Assistant:\"\n+        )\n+        self.assertEqual(rendered, expected_rendered)\n+\n+    @unittest.skip(reason=\"Broken from common. Fixing TODO @zucchini-nlp @molbap\")\n+    def test_chat_template_video_special_processing(self):\n+        pass\n+\n+    @require_av\n+    def test_chat_template_video(self):\n+        # overriden because SmolVLM has special preprocessing for videos\n+        processor = self.get_processor()\n+        if processor.chat_template is None:\n+            self.skipTest(\"Processor has no chat template\")\n+\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\n+                            \"type\": \"video\",\n+                            \"url\": \"https://test-videos.co.uk/vids/bigbuckbunny/mp4/h264/720/Big_Buck_Bunny_720_10s_10MB.mp4\",\n+                        },\n+                        {\"type\": \"text\", \"text\": \"What is shown in this video?\"},\n+                    ],\n+                },\n+            ]\n+        ]\n+\n+        num_frames = 3\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            num_frames=num_frames,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 1)\n+        # SmolVLM doesn't sample `num_frames` exactly, by uses other sampling method\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name][0]), 10)\n+\n+        # Load with `video_fps` arg\n+        video_fps = 1\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            video_fps=video_fps,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 1)\n+        # SmolVLM doesn't sample 1 frame per second exactly, by uses other sampling method\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name][0]), video_fps * 10)\n+\n+        # NOTE: the last assert checks are removed\n+        # Loading video as a list of frames (i.e. images) is not supported in SmolVLM\n+\n+    # Override as SmolVLMProcessor needs image tokens in prompts\n+    def prepare_text_inputs(self, batch_size: Optional[int] = None):\n+        if batch_size is None:\n+            return \"lower newer <image>\"\n+\n+        if batch_size < 1:\n+            raise ValueError(\"batch_size must be greater than 0\")\n+\n+        if batch_size == 1:\n+            return [\"lower newer <image>\"]\n+        return [\"lower newer <image>\", \"<image> upper older longer string\"] + [\"<image> lower newer\"] * (\n+            batch_size - 2\n+        )\n+\n+    # Override tests as inputs_ids padded dimension is the second one but not the last one\n+    @require_vision\n+    @require_torch\n+    def test_kwargs_overrides_default_tokenizer_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\", max_length=30)\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+        input_str = self.prepare_text_inputs()\n+        image_input = self.prepare_image_inputs()\n+\n+        inputs = processor(text=input_str, images=image_input, return_tensors=\"pt\", max_length=30)\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 30)\n+\n+    @require_torch\n+    @require_vision\n+    def test_structured_kwargs_nested(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = self.prepare_text_inputs()\n+        image_input = self.prepare_image_inputs()\n+\n+        # Define the kwargs for each modality\n+        inputs = processor(\n+            text=input_str,\n+            images=image_input,\n+            common_kwargs={\"return_tensors\": \"pt\"},\n+            images_kwargs={\"max_image_size\": {\"longest_edge\": 32}},\n+            text_kwargs={\"padding\": \"max_length\", \"max_length\": 120, \"truncation\": \"longest_first\"},\n+        )\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        self.assertEqual(inputs[\"pixel_values\"].shape[3], 32)\n+\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 120)\n+\n+    @require_torch\n+    @require_vision\n+    def test_structured_kwargs_nested_from_dict(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+        input_str = self.prepare_text_inputs()\n+        image_input = self.prepare_image_inputs()\n+\n+        # Define the kwargs for each modality\n+        all_kwargs = {\n+            \"common_kwargs\": {\"return_tensors\": \"pt\"},\n+            \"images_kwargs\": {\"max_image_size\": {\"longest_edge\": 32}},\n+            \"text_kwargs\": {\"padding\": \"max_length\", \"max_length\": 120, \"truncation\": \"longest_first\"},\n+        }\n+\n+        inputs = processor(text=input_str, images=image_input, **all_kwargs)\n+        self.assertEqual(inputs[\"pixel_values\"].shape[3], 32)\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 120)\n+\n+    @require_vision\n+    @require_torch\n+    def test_tokenizer_defaults_preserved_by_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\", max_length=30)\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+        input_str = self.prepare_text_inputs()\n+        image_input = self.prepare_image_inputs()\n+\n+        inputs = processor(text=input_str, images=image_input, return_tensors=\"pt\")\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 30)\n+\n+    @require_torch\n+    @require_vision\n+    def test_unstructured_kwargs_batched(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = self.prepare_text_inputs(batch_size=2)\n+        image_input = self.prepare_image_inputs(batch_size=2)\n+        image_input = [[image_input[0]], [image_input[1]]]\n+        inputs = processor(\n+            text=input_str,\n+            images=image_input,\n+            return_tensors=\"pt\",\n+            padding=\"longest\",\n+            max_length=76,\n+            truncation=True,\n+            max_image_size={\"longest_edge\": 30},\n+        )\n+\n+        self.assertEqual(inputs[\"pixel_values\"].shape[2], 3)\n+        self.assertEqual(inputs[\"pixel_values\"].shape[3], 30)\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 76)\n+\n+    @require_torch\n+    @require_vision\n+    def test_unstructured_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = self.prepare_text_inputs()\n+        image_input = self.prepare_image_inputs()\n+        inputs = processor(\n+            text=input_str,\n+            images=image_input,\n+            return_tensors=\"pt\",\n+            max_image_size={\"longest_edge\": 32},\n+            padding=\"max_length\",\n+            max_length=120,\n+            truncation=\"longest_first\",\n+        )\n+\n+        self.assertEqual(inputs[\"pixel_values\"].shape[3], 32)\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 120)\n+\n+    @require_torch\n+    @require_vision\n+    def test_text_only_inference(self):\n+        \"\"\"Test that the processor works correctly with text-only input.\"\"\"\n+        processor_components = self.prepare_components()\n+        processor_components[\"tokenizer\"] = self.get_component(\"tokenizer\", padding_side=\"left\")\n+        processor_kwargs = self.prepare_processor_dict()\n+\n+        processor = self.processor_class(**processor_components, **processor_kwargs)\n+\n+        text = \"This is a simple text without images.\"\n+        inputs = processor(text=text)\n+\n+        tokenized_sentence = processor.tokenizer(text, add_special_tokens=False)\n+        expected_input_ids = [tokenized_sentence[\"input_ids\"]]\n+\n+        self.assertEqual(inputs[\"input_ids\"], expected_input_ids)\n+        self.assertEqual(inputs[\"attention_mask\"], [[1] * len(expected_input_ids[0])])\n+        self.assertTrue(\"pixel_values\" not in inputs)\n+        self.assertTrue(\"pixel_attention_mask\" not in inputs)\n+\n+        # Test batch of texts without image tokens\n+        texts = [\"First text.\", \"Second piece of text.\"]\n+        batch_inputs = processor(text=texts, padding=True)\n+\n+        tokenized_1 = processor.tokenizer(texts[0], add_special_tokens=False)\n+        tokenized_2 = processor.tokenizer(texts[1], add_special_tokens=False)\n+\n+        expected_1 = tokenized_1[\"input_ids\"]\n+        expected_2 = tokenized_2[\"input_ids\"]\n+\n+        # Pad the shorter sequence\n+        pad_len = len(expected_2) - len(expected_1)\n+        if pad_len > 0:\n+            padded_expected_1 = [self.padding_token_id] * pad_len + expected_1\n+            expected_attention_1 = [0] * pad_len + [1] * len(expected_1)\n+            self.assertEqual(batch_inputs[\"input_ids\"], [padded_expected_1, expected_2])\n+            self.assertEqual(batch_inputs[\"attention_mask\"], [expected_attention_1, [1] * len(expected_2)])\n+        else:\n+            pad_len = -pad_len\n+            padded_expected_2 = [self.padding_token_id] * pad_len + expected_2\n+            expected_attention_2 = [0] * pad_len + [1] * len(expected_2)\n+            self.assertEqual(batch_inputs[\"input_ids\"], [expected_1, padded_expected_2])\n+            self.assertEqual(batch_inputs[\"attention_mask\"], [[1] * len(expected_1), expected_attention_2])\n+\n+    @require_torch\n+    @require_vision\n+    def test_missing_images_error(self):\n+        \"\"\"Test that appropriate error is raised when images are referenced but not provided.\"\"\"\n+        processor = self.get_processor()\n+\n+        # Test single text with image token but no image\n+        text = \"Let me show you this image: <image> What do you think?\"\n+        with self.assertRaises(ValueError) as context:\n+            processor(text=text)\n+        self.assertTrue(\"tokens in the text but no images/videos were passed\" in str(context.exception))\n+\n+        # Test batch with image tokens but no images\n+        texts = [\n+            \"First text with <image> token.\",\n+            \"Second text <image> with token.\",\n+        ]\n+        with self.assertRaises(ValueError) as context:\n+            processor(text=texts)\n+        self.assertTrue(\"tokens in the text but no images/videos were passed\" in str(context.exception))\n+\n+        # Test with None as Images\n+        with self.assertRaises(ValueError) as context:\n+            processor(text=text, images=None)\n+        self.assertTrue(\"tokens in the text but no images/videos were passed\" in str(context.exception))\n+\n+        with self.assertRaises(ValueError) as context:\n+            processor(text=texts, images=None)\n+        self.assertTrue(\"tokens in the text but no images/videos were passed\" in str(context.exception))"
        },
        {
            "sha": "2cb48b7a3cae9b2c1a92fde618903ff4e654caa4",
            "filename": "tests/test_modeling_common.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/tests%2Ftest_modeling_common.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/tests%2Ftest_modeling_common.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Ftest_modeling_common.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -57,6 +57,7 @@\n     MODEL_FOR_CAUSAL_LM_MAPPING_NAMES,\n     MODEL_FOR_DOCUMENT_QUESTION_ANSWERING_MAPPING_NAMES,\n     MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES,\n+    MODEL_FOR_IMAGE_TEXT_TO_TEXT_MAPPING_NAMES,\n     MODEL_FOR_MASKED_IMAGE_MODELING_MAPPING_NAMES,\n     MODEL_FOR_MASKED_LM_MAPPING_NAMES,\n     MODEL_FOR_MULTIPLE_CHOICE_MAPPING_NAMES,\n@@ -262,6 +263,7 @@ def _prepare_for_class(self, inputs_dict, model_class, return_labels=False):\n                 *get_values(MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES),\n                 *get_values(MODEL_FOR_CAUSAL_LM_MAPPING_NAMES),\n                 *get_values(MODEL_FOR_CAUSAL_IMAGE_MODELING_MAPPING_NAMES),\n+                *get_values(MODEL_FOR_IMAGE_TEXT_TO_TEXT_MAPPING_NAMES),\n                 *get_values(MODEL_FOR_MASKED_LM_MAPPING_NAMES),\n                 *get_values(MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES),\n                 *get_values(MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES),"
        },
        {
            "sha": "f8769cbb1b1342b0b35949e3d718885359730bee",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -86,6 +86,7 @@\n     \"Idefics2PerceiverResampler\",\n     \"Idefics2VisionTransformer\",\n     \"Idefics3VisionTransformer\",\n+    \"SmolVLMVisionTransformer\",\n     \"AriaTextForCausalLM\",\n     \"AriaTextModel\",\n ]"
        },
        {
            "sha": "6e3096756b1fe6392058146079703cd14f3746f7",
            "filename": "utils/check_table.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/4397dfcb7107508ab1ff1a8f644f248b84a9e912/utils%2Fcheck_table.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4397dfcb7107508ab1ff1a8f644f248b84a9e912/utils%2Fcheck_table.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_table.py?ref=4397dfcb7107508ab1ff1a8f644f248b84a9e912",
            "patch": "@@ -180,6 +180,7 @@ def _center_text(text: str, width: int) -> str:\n     \"CLIPVisionModel\",\n     \"Qwen2AudioEncoder\",\n     \"SiglipVisionModel\",\n+    \"SmolVLMVisionTransformer\",\n ]\n \n "
        }
    ],
    "stats": {
        "total": 5112,
        "additions": 5108,
        "deletions": 4
    }
}