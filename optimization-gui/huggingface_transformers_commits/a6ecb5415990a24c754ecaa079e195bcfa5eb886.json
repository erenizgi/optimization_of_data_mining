{
    "author": "ethanknights",
    "message": "Update `trainer_pt_utils.py` docstrings for consistency (#36912)\n\n* Update trainer_pt_utils.py\n\n* update docstrings trainer_pt_utils.py for consistency\n\n* Update src/transformers/trainer_pt_utils.py\n\n---------\n\nCo-authored-by: Matt <Rocketknight1@users.noreply.github.com>",
    "sha": "a6ecb5415990a24c754ecaa079e195bcfa5eb886",
    "files": [
        {
            "sha": "ad77411802de7f32af5cd7eed9da9554182105b9",
            "filename": "src/transformers/trainer_pt_utils.py",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/huggingface/transformers/blob/a6ecb5415990a24c754ecaa079e195bcfa5eb886/src%2Ftransformers%2Ftrainer_pt_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a6ecb5415990a24c754ecaa079e195bcfa5eb886/src%2Ftransformers%2Ftrainer_pt_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Ftrainer_pt_utils.py?ref=a6ecb5415990a24c754ecaa079e195bcfa5eb886",
            "patch": "@@ -291,7 +291,7 @@ def __iter__(self):\n \n class EvalLoopContainer:\n     \"\"\"\n-    Container to store intermediate results of evaluation loop\n+    Container to store intermediate results of evaluation loop.\n \n     Args:\n         do_nested_concat (`bool`, *optional*, defaults to `True`):\n@@ -443,7 +443,7 @@ class DistributedTensorGatherer:\n         - P1: `[6, 7, 8, 9, 10, 11]`\n         - P2: `[12, 13, 14, 15, 0, 1]`\n \n-    The first batch treated on each process will be\n+    The first batch treated on each process will be:\n \n         - P0: `[0, 1]`\n         - P1: `[6, 7]`\n@@ -736,7 +736,7 @@ def __iter__(self) -> Iterator:\n             # add extra samples to make it evenly divisible\n             indices += indices[: (self.total_size - len(indices))]\n         else:\n-            # remove tail of data to make it evenly divisible.\n+            # remove tail of data to make it evenly divisible\n             indices = indices[: self.total_size]\n         assert len(indices) == self.total_size\n \n@@ -928,7 +928,7 @@ def _get_learning_rate(self):\n \n def _secs2timedelta(secs):\n     \"\"\"\n-    convert seconds to hh:mm:ss.msec, msecs rounded to 2 decimals\n+    Convert seconds to hh:mm:ss.msec, msecs rounded to 2 decimal places.\n     \"\"\"\n \n     msec = int(abs(secs - int(secs)) * 100)\n@@ -937,7 +937,7 @@ def _secs2timedelta(secs):\n \n def metrics_format(self, metrics: dict[str, float]) -> dict[str, float]:\n     \"\"\"\n-    Reformat Trainer metrics values to a human-readable format\n+    Reformat Trainer metrics values to a human-readable format.\n \n     Args:\n         metrics (`Dict[str, float]`):\n@@ -963,7 +963,7 @@ def metrics_format(self, metrics: dict[str, float]) -> dict[str, float]:\n \n def log_metrics(self, split, metrics):\n     \"\"\"\n-    Log metrics in a specially formatted way\n+    Log metrics in a specially formatted way.\n \n     Under distributed environment this is done only for a process with rank 0.\n \n@@ -977,7 +977,7 @@ def log_metrics(self, split, metrics):\n \n     In order to get memory usage report you need to install `psutil`. You can do that with `pip install psutil`.\n \n-    Now when this method is run, you will see a report that will include: :\n+    Now when this method is run, you will see a report that will include:\n \n     ```\n     init_mem_cpu_alloc_delta   =     1301MB\n@@ -1006,7 +1006,7 @@ def log_metrics(self, split, metrics):\n     The reporting happens only for process of rank 0 and gpu 0 (if there is a gpu). Typically this is enough since the\n     main process does the bulk of work, but it could be not quite so if model parallel is used and then other GPUs may\n     use a different amount of gpu memory. This is also not the same under DataParallel where gpu0 may require much more\n-    memory than the rest since it stores the gradient and optimizer states for all participating GPUS. Perhaps in the\n+    memory than the rest since it stores the gradient and optimizer states for all participating GPUs. Perhaps in the\n     future these reports will evolve to measure those too.\n \n     The CPU RAM metric measures RSS (Resident Set Size) includes both the memory which is unique to the process and the\n@@ -1091,7 +1091,7 @@ def save_metrics(self, split, metrics, combined=True):\n \n def save_state(self):\n     \"\"\"\n-    Saves the Trainer state, since Trainer.save_model saves only the tokenizer with the model\n+    Saves the Trainer state, since Trainer.save_model saves only the tokenizer with the model.\n \n     Under distributed environment this is done only for a process with rank 0.\n     \"\"\"\n@@ -1104,7 +1104,7 @@ def save_state(self):\n \n def get_model_param_count(model, trainable_only=False):\n     \"\"\"\n-    Calculate model's total param count. If trainable_only is True then count only those requiring grads\n+    Calculate model's total param count. If trainable_only is True then count only those requiring grads.\n     \"\"\"\n     if is_deepspeed_zero3_enabled():\n "
        }
    ],
    "stats": {
        "total": 20,
        "additions": 10,
        "deletions": 10
    }
}