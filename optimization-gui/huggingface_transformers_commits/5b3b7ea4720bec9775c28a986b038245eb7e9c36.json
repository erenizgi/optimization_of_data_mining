{
    "author": "tic-top",
    "message": "Add Kosmos-2.5 (#31711)\n\nAdd Microsoft Kosmos-2.5\n\n---------\n\nCo-authored-by: kirp@umich.edu <tic-top>\nCo-authored-by: ydshieh <ydshieh@users.noreply.github.com>\nCo-authored-by: Yih-Dar <2521628+ydshieh@users.noreply.github.com>\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>",
    "sha": "5b3b7ea4720bec9775c28a986b038245eb7e9c36",
    "files": [
        {
            "sha": "d4cfe1711a5eef9e1f6d1c0bcebfb508be76b56f",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -1039,6 +1039,8 @@\n         title: Janus\n       - local: model_doc/kosmos-2\n         title: KOSMOS-2\n+      - local: model_doc/kosmos2_5\n+        title: KOSMOS-2.5\n       - local: model_doc/layoutlm\n         title: LayoutLM\n       - local: model_doc/layoutlmv2"
        },
        {
            "sha": "d881bf61678c8350f4edf7926d5ccecaf64029a3",
            "filename": "docs/source/en/model_doc/kosmos2_5.md",
            "status": "added",
            "additions": 196,
            "deletions": 0,
            "changes": 196,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/docs%2Fsource%2Fen%2Fmodel_doc%2Fkosmos2_5.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/docs%2Fsource%2Fen%2Fmodel_doc%2Fkosmos2_5.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fkosmos2_5.md?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -0,0 +1,196 @@\n+<!--Copyright 2025 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+-->\n+\n+<div style=\"float: right;\">\n+    <div class=\"flex flex-wrap space-x-1\">\n+        <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+        <img alt=\"Flax\" src=\"https://img.shields.io/badge/Flax-29a79b.svg?style=flat&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAMAAAANxBKoAAAC7lBMVEUAAADg5vYHPVgAoJH+/v76+v39/f9JbLP///9+AIgAnY3///+mcqzt8fXy9fgkXa3Ax9709fr+///9/f8qXq49qp5AaLGMwrv8/P0eW60VWawxYq8yqJzG2dytt9Wyu9elzci519Lf3O3S2efY3OrY0+Xp7PT///////+dqNCexMc6Z7AGpJeGvbenstPZ5ejQ1OfJzOLa7ejh4+/r8fT29vpccbklWK8PVa0AS6ghW63O498vYa+lsdKz1NDRt9Kw1c672tbD3tnAxt7R6OHp5vDe7OrDyuDn6vLl6/EAQKak0MgATakkppo3ZK/Bz9y8w9yzu9jey97axdvHzeG21NHH4trTwthKZrVGZLSUSpuPQJiGAI+GAI8SWKydycLL4d7f2OTi1+S9xNzL0ePT6OLGzeEAo5U0qJw/aLEAo5JFa7JBabEAp5Y4qZ2QxLyKmsm3kL2xoMOehrRNb7RIbbOZgrGre68AUqwAqZqNN5aKJ5N/lMq+qsd8kMa4pcWzh7muhLMEV69juq2kbKqgUaOTR5uMMZWLLZSGAI5VAIdEAH+ovNDHuNCnxcy3qcaYx8K8msGplrx+wLahjbYdXrV6vbMvYK9DrZ8QrZ8tqJuFms+Sos6sw8ecy8RffsNVeMCvmb43aLltv7Q4Y7EZWK4QWa1gt6meZKUdr6GOAZVeA4xPAISyveLUwtivxtKTpNJ2jcqfvcltiMiwwcfAoMVxhL+Kx7xjdrqTe60tsaNQs6KaRKACrJ6UTZwkqpqTL5pkHY4AloSgsd2ptNXPvNOOncuxxsqFl8lmg8apt8FJcr9EbryGxLqlkrkrY7dRa7ZGZLQ5t6iXUZ6PPpgVpZeJCJFKAIGareTa0+KJod3H0deY2M+esM25usmYu8d2zsJOdcBVvrCLbqcAOaaHaKQAMaScWqKBXqCXMJ2RHpiLF5NmJZAdAHN2kta11dKu1M+DkcZLdb+Mcql3TppyRJdzQ5ZtNZNlIY+DF4+voCOQAAAAZ3RSTlMABAT+MEEJ/RH+/TP+Zlv+pUo6Ifz8+fco/fz6+evr39S9nJmOilQaF/7+/f38+smmoYp6b1T+/v7++vj189zU0tDJxsGzsrKSfv34+Pf27dDOysG9t6+n/vv6+vr59uzr1tG+tZ6Qg9Ym3QAABR5JREFUSMeNlVVUG1EQhpcuxEspXqS0SKEtxQp1d3d332STTRpIQhIISQgJhODu7lAoDoUCpe7u7u7+1puGpqnCPOyZvffbOXPm/PsP9JfQgyCC+tmTABTOcbxDz/heENS7/1F+9nhvkHePG0wNDLbGWwdXL+rbLWvpmZHXD8+gMfBjTh+aSe6Gnn7lwQIOTR0c8wfX3PWgv7avbdKwf/ZoBp1Gp/PvuvXW3vw5ib7emnTW4OR+3D4jB9vjNJ/7gNvfWWeH/TO/JyYrsiKCRjVEZA3UB+96kON+DxOQ/NLE8PE5iUYgIXjFnCOlxEQMaSGVxjg4gxOnEycGz8bptuNjVx08LscIgrzH3umcn+KKtiBIyvzOO2O99aAdR8cF19oZalnCtvREUw79tCd5sow1g1UKM6kXqUx4T8wsi3sTjJ3yzDmmhenLXLpo8u45eG5y4Vvbk6kkC4LLtJMowkSQxmk4ggVJEG+7c6QpHT8vvW9X7/o7+3ELmiJi2mEzZJiz8cT6TBlanBk70cB5GGIGC1gRDdZ00yADLW1FL6gqhtvNXNG5S9gdSrk4M1qu7JAsmYshzDS4peoMrU/gT7qQdqYGZaYhxZmVbGJAm/CS/HloWyhRUlknQ9KYcExTwS80d3VNOxUZJpITYyspl0LbhArhpZCD9cRWEQuhYkNGMHToQ/2Cs6swJlb39CsllxdXX6IUKh/H5jbnSsPKjgmoaFQ1f8wRLR0UnGE/RcDEjj2jXG1WVTwUs8+zxfcrVO+vSsuOpVKxCfYZiQ0/aPKuxQbQ8lIz+DClxC8u+snlcJ7Yr1z1JPqUH0V+GDXbOwAib931Y4Imaq0NTIXPXY+N5L18GJ37SVWu+hwXff8l72Ds9XuwYIBaXPq6Shm4l+Vl/5QiOlV+uTk6YR9PxKsI9xNJny31ygK1e+nIRC1N97EGkFPI+jCpiHe5PCEy7oWqWSwRrpOvhFzcbTWMbm3ZJAOn1rUKpYIt/lDhW/5RHHteeWFN60qo98YJuoq1nK3uW5AabyspC1BcIEpOhft+SZAShYoLSvnmSfnYADUERP5jJn2h5XtsgCRuhYQqAvwTwn33+YWEKUI72HX5AtfSAZDe8F2DtPPm77afhl0EkthzuCQU0BWApgQIH9+KB0JhopMM7bJrdTRoleM2JAVNMyPF+wdoaz+XJpGoVAQ7WXUkcV7gT3oUZyi/ISIJAVKhgNp+4b4veCFhYVJw4locdSjZCp9cPUhLF9EZ3KKzURepMEtCDPP3VcWFx4UIiZIklIpFNfHpdEafIF2aRmOcrUmjohbT2WUllbmRvgfbythbQO3222fpDJoufaQPncYYuqoGtUEsCJZL6/3PR5b4syeSjZMQG/T2maGANlXT2v8S4AULWaUkCxfLyW8iW4kdka+nEMjxpL2NCwsYNBp+Q61PF43zyDg9Bm9+3NNySn78jMZUUkumqE4Gp7JmFOdP1vc8PpRrzj9+wPinCy8K1PiJ4aYbnTYpCCbDkBSbzhu2QJ1Gd82t8jI8TH51+OzvXoWbnXUOBkNW+0mWFwGcGOUVpU81/n3TOHb5oMt2FgYGjzau0Nif0Ss7Q3XB33hjjQHjHA5E5aOyIQc8CBrLdQSs3j92VG+3nNEjbkbdbBr9zm04ruvw37vh0QKOdeGIkckc80fX3KH/h7PT4BOjgCty8VZ5ux1MoO5Cf5naca2LAsEgehI+drX8o/0Nu+W0m6K/I9gGPd/dfx/EN/wN62AhsBWuAAAAAElFTkSuQmCC\">\n+        <img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+        <img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+    </div>\n+</div>\n+\n+\n+# KOSMOS-2.5\n+\n+The Kosmos-2.5 model was proposed in [KOSMOS-2.5: A Multimodal Literate Model](https://arxiv.org/abs/2309.11419/) by Microsoft.\n+\n+The abstract from the paper is the following:\n+\n+*We present Kosmos-2.5, a multimodal literate model for machine reading of text-intensive images. Pre-trained on large-scale text-intensive images, Kosmos-2.5 excels in two distinct yet cooperative transcription tasks: (1) generating spatially-aware text blocks, where each block of text is assigned its spatial coordinates within the image, and (2) producing structured text output that captures styles and structures into the markdown format. This unified multimodal literate capability is achieved through a shared Transformer architecture, task-specific prompts, and flexible text representations. We evaluate Kosmos-2.5 on end-to-end document-level text recognition and image-to-markdown text generation. Furthermore, the model can be readily adapted for any text-intensive image understanding task with different prompts through supervised fine-tuning, making it a general-purpose tool for real-world applications involving text-rich images. This work also paves the way for the future scaling of multimodal large language models.*\n+\n+<img src=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/model_doc/kosmos2_5_ocr.png\"\n+alt=\"drawing\" width=\"600\"/>\n+\n+<img src=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/model_doc/kosmos2_5_md.png\"\n+alt=\"drawing\" width=\"600\"/>\n+\n+<small> Overview of tasks that KOSMOS-2.5 can handle. Taken from the <a href=\"https://arxiv.org/abs/2309.11419\">original paper</a>. </small>\n+\n+The examples below demonstrates how to generate with [`AutoModel`], for both Markdown and OCR tasks. \n+\n+<hfoptions id=\"usage\">\n+<hfoption id=\"AutoModel - Markdown Task\">\n+\n+```py\n+import re\n+import torch\n+import requests\n+from PIL import Image, ImageDraw\n+from transformers import AutoProcessor, Kosmos2_5ForConditionalGeneration\n+\n+repo = \"ydshieh/kosmos-2.5\"\n+device = \"cuda:0\"\n+dtype = torch.bfloat16\n+model = Kosmos2_5ForConditionalGeneration.from_pretrained(repo, device_map=device, torch_dtype=dtype)\n+processor = AutoProcessor.from_pretrained(repo)\n+\n+# sample image\n+url = \"https://huggingface.co/ydshieh/kosmos-2.5/resolve/main/receipt_00008.png\"\n+image = Image.open(requests.get(url, stream=True).raw)\n+\n+prompt = \"<md>\"\n+inputs = processor(text=prompt, images=image, return_tensors=\"pt\")\n+\n+height, width = inputs.pop(\"height\"), inputs.pop(\"width\")\n+raw_width, raw_height = image.size\n+scale_height = raw_height / height\n+scale_width = raw_width / width\n+\n+inputs = {k: v.to(device) if v is not None else None for k, v in inputs.items()}\n+inputs[\"flattened_patches\"] = inputs[\"flattened_patches\"].to(dtype)\n+generated_ids = model.generate(\n+    **inputs,\n+    max_new_tokens=1024,\n+)\n+\n+generated_text = processor.batch_decode(generated_ids, skip_special_tokens=True)\n+print(generated_text[0])\n+```\n+\n+</hfoption>\n+<hfoption id=\"AutoModel - OCR Task\">\n+\n+```py\n+import re\n+import torch\n+import requests\n+from PIL import Image, ImageDraw\n+from transformers import AutoProcessor, Kosmos2_5ForConditionalGeneration\n+\n+repo = \"ydshieh/kosmos-2.5\"\n+device = \"cuda:0\"\n+dtype = torch.bfloat16\n+model = Kosmos2_5ForConditionalGeneration.from_pretrained(repo, device_map=device, torch_dtype=dtype)\n+processor = AutoProcessor.from_pretrained(repo)\n+\n+# sample image\n+url = \"https://huggingface.co/ydshieh/kosmos-2.5/resolve/main/receipt_00008.png\"\n+image = Image.open(requests.get(url, stream=True).raw)\n+\n+# bs = 1\n+prompt = \"<ocr>\"\n+inputs = processor(text=prompt, images=image, return_tensors=\"pt\")\n+height, width = inputs.pop(\"height\"), inputs.pop(\"width\")\n+raw_width, raw_height = image.size\n+scale_height = raw_height / height\n+scale_width = raw_width / width\n+\n+# bs > 1, batch generation\n+# inputs = processor(text=[prompt, prompt], images=[image,image], return_tensors=\"pt\")\n+# height, width = inputs.pop(\"height\"), inputs.pop(\"width\")\n+# raw_width, raw_height = image.size\n+# scale_height = raw_height / height[0]\n+# scale_width = raw_width / width[0]\n+\n+inputs = {k: v.to(device) if v is not None else None for k, v in inputs.items()}\n+inputs[\"flattened_patches\"] = inputs[\"flattened_patches\"].to(dtype)\n+generated_ids = model.generate(\n+    **inputs,\n+    max_new_tokens=1024,\n+)\n+\n+generated_text = processor.batch_decode(generated_ids, skip_special_tokens=True)\n+def post_process(y, scale_height, scale_width):\n+    y = y.replace(prompt, \"\")\n+    if \"<md>\" in prompt:\n+        return y\n+    pattern = r\"<bbox><x_\\d+><y_\\d+><x_\\d+><y_\\d+></bbox>\"\n+    bboxs_raw = re.findall(pattern, y)\n+    lines = re.split(pattern, y)[1:]\n+    bboxs = [re.findall(r\"\\d+\", i) for i in bboxs_raw]\n+    bboxs = [[int(j) for j in i] for i in bboxs]\n+    info = \"\"\n+    for i in range(len(lines)):\n+        box = bboxs[i]\n+        x0, y0, x1, y1 = box\n+        if not (x0 >= x1 or y0 >= y1):\n+            x0 = int(x0 * scale_width)\n+            y0 = int(y0 * scale_height)\n+            x1 = int(x1 * scale_width)\n+            y1 = int(y1 * scale_height)\n+            info += f\"{x0},{y0},{x1},{y0},{x1},{y1},{x0},{y1},{lines[i]}\"\n+    return info\n+\n+output_text = post_process(generated_text[0], scale_height, scale_width)\n+print(output_text)\n+\n+draw = ImageDraw.Draw(image)\n+lines = output_text.split(\"\\n\")\n+for line in lines:\n+    # draw the bounding box\n+    line = list(line.split(\",\"))\n+    if len(line) < 8:\n+        continue\n+    line = list(map(int, line[:8]))\n+    draw.polygon(line, outline=\"red\")\n+image.save(\"output.png\")\n+```\n+\n+</hfoption>\n+</hfoptions>\n+\n+\n+## Example\n+**Markdown Task:** For usage instructions, please refer to [md.py](https://huggingface.co/ydshieh/kosmos-2.5/blob/main/md.py).\n+\n+**OCR Task:** For usage instructions, please refer to [ocr.py](https://huggingface.co/ydshieh/kosmos-2.5/blob/main/ocr.py).\n+\n+\n+\n+## Kosmos2_5Config\n+\n+[[autodoc]] Kosmos2_5Config\n+\n+## Kosmos2_5ImageProcessor\n+\n+[[autodoc]] Kosmos2_5ImageProcessor\n+    - preprocess\n+\n+## Kosmos2_5ImageProcessorFast\n+\n+[[autodoc]] Kosmos2_5ImageProcessorFast\n+    - preprocess\n+\n+## Kosmos2_5Processor\n+\n+[[autodoc]] Kosmos2_5Processor\n+\n+## Kosmos2_5Model\n+\n+[[autodoc]] Kosmos2_5Model\n+    - forward\n+\n+## Kosmos2_5ForConditionalGeneration\n+\n+[[autodoc]] Kosmos2_5ForConditionalGeneration\n+    - forward"
        },
        {
            "sha": null,
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36"
        },
        {
            "sha": "16d994f4004fbc64ebb2c2d31fa8faf77fafe642",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -209,6 +209,7 @@\n         (\"jetmoe\", \"JetMoeConfig\"),\n         (\"jukebox\", \"JukeboxConfig\"),\n         (\"kosmos-2\", \"Kosmos2Config\"),\n+        (\"kosmos-2.5\", \"Kosmos2_5Config\"),\n         (\"kyutai_speech_to_text\", \"KyutaiSpeechToTextConfig\"),\n         (\"layoutlm\", \"LayoutLMConfig\"),\n         (\"layoutlmv2\", \"LayoutLMv2Config\"),\n@@ -626,6 +627,7 @@\n         (\"jetmoe\", \"JetMoe\"),\n         (\"jukebox\", \"Jukebox\"),\n         (\"kosmos-2\", \"KOSMOS-2\"),\n+        (\"kosmos-2.5\", \"KOSMOS-2.5\"),\n         (\"kyutai_speech_to_text\", \"KyutaiSpeechToText\"),\n         (\"layoutlm\", \"LayoutLM\"),\n         (\"layoutlmv2\", \"LayoutLMv2\"),\n@@ -908,6 +910,7 @@\n         (\"data2vec-vision\", \"data2vec\"),\n         (\"donut-swin\", \"donut\"),\n         (\"kosmos-2\", \"kosmos2\"),\n+        (\"kosmos-2.5\", \"kosmos2_5\"),\n         (\"maskformer-swin\", \"maskformer\"),\n         (\"xclip\", \"x_clip\"),\n         (\"clip_vision_model\", \"clip\"),"
        },
        {
            "sha": "08c85e61f733212874a793c42f15bb049805ae25",
            "filename": "src/transformers/models/auto/image_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -116,6 +116,7 @@\n             (\"instructblipvideo\", (\"InstructBlipVideoImageProcessor\", None)),\n             (\"janus\", (\"JanusImageProcessor\", \"JanusImageProcessorFast\")),\n             (\"kosmos-2\", (\"CLIPImageProcessor\", \"CLIPImageProcessorFast\")),\n+            (\"kosmos-2.5\", (\"Kosmos2_5ImageProcessor\", \"Kosmos2_5ImageProcessorFast\")),\n             (\"layoutlmv2\", (\"LayoutLMv2ImageProcessor\", \"LayoutLMv2ImageProcessorFast\")),\n             (\"layoutlmv3\", (\"LayoutLMv3ImageProcessor\", \"LayoutLMv3ImageProcessorFast\")),\n             (\"levit\", (\"LevitImageProcessor\", \"LevitImageProcessorFast\")),"
        },
        {
            "sha": "8041d5db473b95a53d94889edfe1b7222dbed265",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -209,6 +209,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"jetmoe\", \"JetMoeModel\"),\n         (\"jukebox\", \"JukeboxModel\"),\n         (\"kosmos-2\", \"Kosmos2Model\"),\n+        (\"kosmos-2.5\", \"Kosmos2_5Model\"),\n         (\"kyutai_speech_to_text\", \"KyutaiSpeechToTextModel\"),\n         (\"layoutlm\", \"LayoutLMModel\"),\n         (\"layoutlmv2\", \"LayoutLMv2Model\"),\n@@ -943,6 +944,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"instructblip\", \"InstructBlipForConditionalGeneration\"),\n         (\"instructblipvideo\", \"InstructBlipVideoForConditionalGeneration\"),\n         (\"kosmos-2\", \"Kosmos2ForConditionalGeneration\"),\n+        (\"kosmos-2.5\", \"Kosmos2_5ForConditionalGeneration\"),\n         (\"llava\", \"LlavaForConditionalGeneration\"),\n         (\"llava_next\", \"LlavaNextForConditionalGeneration\"),\n         (\"llava_next_video\", \"LlavaNextVideoForConditionalGeneration\"),\n@@ -992,6 +994,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"internvl\", \"InternVLForConditionalGeneration\"),\n         (\"janus\", \"JanusForConditionalGeneration\"),\n         (\"kosmos-2\", \"Kosmos2ForConditionalGeneration\"),\n+        (\"kosmos-2.5\", \"Kosmos2_5ForConditionalGeneration\"),\n         (\"llama4\", \"Llama4ForConditionalGeneration\"),\n         (\"llava\", \"LlavaForConditionalGeneration\"),\n         (\"llava_next\", \"LlavaNextForConditionalGeneration\"),"
        },
        {
            "sha": "4b70acbbc4a8a5440f6795a40627c0604e8aeace",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -88,6 +88,7 @@\n         (\"internvl\", \"InternVLProcessor\"),\n         (\"janus\", \"JanusProcessor\"),\n         (\"kosmos-2\", \"Kosmos2Processor\"),\n+        (\"kosmos-2.5\", \"Kosmos2_5Processor\"),\n         (\"kyutai_speech_to_text\", \"KyutaiSpeechToTextProcessor\"),\n         (\"layoutlmv2\", \"LayoutLMv2Processor\"),\n         (\"layoutlmv3\", \"LayoutLMv3Processor\"),"
        },
        {
            "sha": "13b5acdb19581b2ff7df6d4cd8a1e4e7e20bdb30",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -343,6 +343,7 @@\n                 \"XLMRobertaTokenizerFast\" if is_tokenizers_available() else None,\n             ),\n         ),\n+        (\"kosmos-2.5\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"layoutlm\", (\"LayoutLMTokenizer\", \"LayoutLMTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"layoutlmv2\", (\"LayoutLMv2Tokenizer\", \"LayoutLMv2TokenizerFast\" if is_tokenizers_available() else None)),\n         (\"layoutlmv3\", (\"LayoutLMv3Tokenizer\", \"LayoutLMv3TokenizerFast\" if is_tokenizers_available() else None)),"
        },
        {
            "sha": "2aeaa21dff36ce018ca6b2479fe0f370fd1fa1f9",
            "filename": "src/transformers/models/kosmos2/modeling_kosmos2.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2%2Fmodeling_kosmos2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2%2Fmodeling_kosmos2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fkosmos2%2Fmodeling_kosmos2.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -1820,6 +1820,7 @@ def forward(\n             vision_model_output=vision_model_output,\n         )\n \n+    @torch.no_grad()\n     def generate(\n         self,\n         pixel_values: Optional[torch.Tensor] = None,"
        },
        {
            "sha": "69ff528783bc11b0f00df15eeee2bb474ffa5a49",
            "filename": "src/transformers/models/kosmos2_5/__init__.py",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2F__init__.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -0,0 +1,31 @@\n+# coding=utf-8\n+# Copyright 2024 Microsoft Research and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_kosmos2_5 import *\n+    from .image_processing_kosmos2_5 import *\n+    from .image_processing_kosmos2_5_fast import *\n+    from .modeling_kosmos2_5 import *\n+    from .processing_kosmos2_5 import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "7015c05de532fb060b67447af86b07c2ef100ed4",
            "filename": "src/transformers/models/kosmos2_5/configuration_kosmos2_5.py",
            "status": "added",
            "additions": 254,
            "deletions": 0,
            "changes": 254,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fconfiguration_kosmos2_5.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fconfiguration_kosmos2_5.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fconfiguration_kosmos2_5.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -0,0 +1,254 @@\n+# coding=utf-8\n+# Copyright 2024 Microsoft Research and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"KOSMOS-2.5 model configuration\"\"\"\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...utils import logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Kosmos2_5TextConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Kosmos2_5TextModel`]. It is used to instantiate a\n+    KOSMOS-2.5 text decoder according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the text decoder of the KOSMOS-2.5\n+    [microsoft/kosmos-2.5](https://huggingface.co/microsoft/kosmos-2.5) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 108481):\n+            Vocabulary size of the Kosmos2_5 model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Kosmos2_5Model`].\n+        max_position_embeddings (`int`, *optional*, defaults to 4096):\n+            The maximum sequence length that this model might ever be used with. Typically set this to something large\n+            just in case (e.g., 512 or 1024 or 2048).\n+        embed_dim (`int`, *optional*, defaults to 1536):\n+            Dimensionality of the layers and the pooler layer.\n+        layers (`int`, *optional*, defaults to 24):\n+            Number of hidden layers in the Transformer encoder.\n+        ffn_dim (`int`, *optional*, defaults to 6144):\n+            Dimensionality of the \"intermediate\" (often named feed-forward) layer in the Transformer encoder.\n+        attention_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        activation_function (`str` or `function`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+            `\"relu\"`, `\"silu\"` and `\"gelu_new\"` are supported.\n+        dropout (`float`, *optional*, defaults to 0.1):\n+            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        activation_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for activations inside the fully connected layer.\n+        layerdrop (`float`, *optional*, defaults to 0.0):\n+            The LayerDrop probability for the decoder. See the [LayerDrop paper](see https://arxiv.org/abs/1909.11556)\n+            for more details.\n+        layer_norm_eps (`float`, *optional*, defaults to 1e-5):\n+            The epsilon used by the layer normalization layers.\n+        init_std (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        scale_embedding (`bool`, *optional*, defaults to `True`):\n+            Scale embeddings by diving by sqrt(embed_dim).\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models).\n+    ```\"\"\"\n+\n+    model_type = \"kosmos_2_5_text_model\"\n+    base_config_key = \"text_config\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    attribute_map = {\n+        \"num_attention_heads\": \"attention_heads\",\n+        \"hidden_size\": \"embed_dim\",\n+        \"num_hidden_layers\": \"layers\",\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=108481,\n+        max_position_embeddings=4096,\n+        embed_dim=1536,\n+        layers=24,\n+        ffn_dim=6144,\n+        attention_heads=16,\n+        activation_function=\"gelu\",\n+        dropout=0.1,\n+        attention_dropout=0.0,\n+        activation_dropout=0.0,\n+        layerdrop=0.0,\n+        layer_norm_eps=1e-5,\n+        init_std=0.02,\n+        scale_embedding=True,\n+        use_cache=True,\n+        pad_token_id=1,\n+        bos_token_id=0,\n+        eos_token_id=2,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            **kwargs,\n+        )\n+\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.embed_dim = embed_dim\n+        self.layers = layers\n+        self.ffn_dim = ffn_dim\n+        self.attention_heads = attention_heads\n+        self.activation_function = activation_function\n+        self.dropout = dropout\n+        self.attention_dropout = attention_dropout\n+        self.activation_dropout = activation_dropout\n+        self.layerdrop = layerdrop\n+        self.layer_norm_eps = layer_norm_eps\n+        self.init_std = init_std\n+        self.scale_embedding = scale_embedding\n+        self.use_cache = use_cache\n+\n+\n+class Kosmos2_5VisionConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Kosmos2_5VisionModel`]. It is used to\n+    instantiate a KOSMOS-2.5 vision encoder according to the specified arguments, defining the model architecture.\n+    Instantiating a configuration defaults will yield a similar configuration to that of the vision encoder of the KOSMOS-2.5\n+    [microsoft/kosmos-2.5](https://huggingface.co/microsoft/kosmos-2.5) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 1536):\n+            Dimensionality of the encoder layers and the pooler layer.\n+        patch_embed_hidden_size (`int`, *optional*, defaults to 768):\n+            Dimensionality of the input patch_embedding layer in the Transformer encoder.\n+        intermediate_size (`int`, *optional*, defaults to 3968):\n+            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+        head_dim (`int`, *optional*, defaults to 64):\n+            Dimensionality of the key, query, value projections per attention head.\n+        num_hidden_layers (`int`, *optional*, defaults to 18):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 24):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        dense_act_fn (`str` or `function`, *optional*, defaults to `\"gelu_new\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+            `\"relu\"`, `\"selu\"` and `\"gelu_new\"` ``\"gelu\"` are supported.\n+        layer_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the layer normalization layers.\n+        dropout_rate (`float`, *optional*, defaults to 0.0):\n+            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        max_num_patches (`int`, *optional*, defaults to 4096):\n+            Maximum sequence length (here number of patches) supported by the model.\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Kosmos2_5VisionConfig, Kosmos2_5VisionModel\n+\n+    >>> # Initializing a Kosmos2_5VisionConfig with microsoft/kosmos-2.5 style configuration\n+    >>> configuration = Kosmos2_5VisionConfig()\n+\n+    >>> # Initializing a Kosmos2_5VisionModel (with random weights) from the microsoft/kosmos-2.5 style configuration\n+    >>> model = Kosmos2_5VisionModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"kosmos_2_5_vision_model\"\n+    base_config_key = \"vision_config\"\n+\n+    def __init__(\n+        self,\n+        hidden_size=1536,\n+        patch_embed_hidden_size=768,\n+        intermediate_size=3968,\n+        head_dim=64,\n+        num_hidden_layers=18,\n+        num_attention_heads=24,\n+        dense_act_fn=\"gelu_new\",\n+        layer_norm_eps=1e-6,\n+        dropout_rate=0.0,\n+        attention_dropout=0.0,\n+        max_num_patches=4096,\n+        initializer_factor=1.0,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.hidden_size = hidden_size\n+        self.patch_embed_hidden_size = patch_embed_hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.dropout_rate = dropout_rate\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.attention_dropout = attention_dropout\n+        self.layer_norm_eps = layer_norm_eps\n+        self.dense_act_fn = dense_act_fn\n+        self.max_num_patches = max_num_patches\n+        self.head_dim = head_dim\n+        self.initializer_factor = initializer_factor\n+        self.initializer_range = initializer_range\n+\n+\n+class Kosmos2_5Config(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Kosmos2_5Model`]. It is used to instantiate a\n+    KOSMOS-2.5 model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of the KOSMOS-2.5\n+    [microsoft/kosmos-2.5](https://huggingface.co/microsoft/kosmos-2.5) architecture.\n+\n+    Args:\n+        text_config (`dict`, *optional*):\n+            Dictionary of configuration options used to initialize [`Kosmos2_5TextConfig`].\n+        vision_config (`dict`, *optional*):\n+            Dictionary of configuration options used to initialize [`Kosmos2_5VisionConfig`].\n+        latent_query_num (`int`, *optional*, defaults to 2048):\n+            The number of latent query tokens that represent the image features used in the text decoder component.\n+        kwargs (*optional*):\n+            Dictionary of keyword arguments.\n+    \"\"\"\n+\n+    model_type = \"kosmos-2.5\"\n+    sub_configs = {\"text_config\": Kosmos2_5TextConfig, \"vision_config\": Kosmos2_5VisionConfig}\n+\n+    def __init__(\n+        self,\n+        text_config=None,\n+        vision_config=None,\n+        latent_query_num=2048,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        if text_config is None:\n+            text_config = {}\n+            logger.info(\"text_config is None. Initializing the Kosmos2_5TextConfig with default values.\")\n+        if vision_config is None:\n+            vision_config = {}\n+            logger.info(\"vision_config is None. Initializing the Kosmos2_5VisionConfig with default values.\")\n+\n+        self.text_config = Kosmos2_5TextConfig(**text_config)\n+        self.vision_config = Kosmos2_5VisionConfig(**vision_config)\n+\n+        self.latent_query_num = latent_query_num\n+\n+\n+__all__ = [\"Kosmos2_5Config\"]"
        },
        {
            "sha": "d490c95a6a68d257842d6534ea5c4ed953a1b994",
            "filename": "src/transformers/models/kosmos2_5/convert_kosmos2_5.py",
            "status": "added",
            "additions": 101,
            "deletions": 0,
            "changes": 101,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fconvert_kosmos2_5.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fconvert_kosmos2_5.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fconvert_kosmos2_5.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -0,0 +1,101 @@\n+# coding=utf-8\n+# Copyright 2024 Microsoft Research and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import argparse\n+\n+from fairseq.checkpoint_utils import load_checkpoint_to_cpu\n+\n+from transformers import Kosmos2_5Config, Kosmos2_5ForConditionalGeneration\n+\n+\n+KEYS_TO_MODIFY_MAPPING = {\n+    \"gpt_model.decoder.output_projection\": \"text_model.lm_head\",\n+    \"gpt_model.decoder\": \"text_model.model\",\n+    \"img_connector\": \"image_to_text_projection\",\n+    \"img_model.embeddings\": \"vision_model.embeddings\",\n+    \"img_model.encoder\": \"vision_model.encoder\",\n+    \"img_model.layernorm\": \"vision_model.layernorm\",\n+    \"img_model\": \"vision_model\",\n+    \"ln_pre\": \"pre_layrnorm\",\n+    \"ln_post\": \"post_layernorm\",\n+    \"transformer.resblocks\": \"encoder.layers\",\n+    \"ts_attn\": \"self_attn\",\n+    \"ln_1\": \"layer_norm1\",\n+    \"ln_2\": \"layer_norm2\",\n+    \"c_fc\": \"fc1\",\n+    \"c_proj\": \"fc2\",\n+}\n+\n+\n+KEYS_TO_IGNORE = [\n+    # this buffer in the original code is only used to send weights to the desired device\n+    \"gpt_model.decoder.embed_positions._float_tensor\",\n+    # this weight is never used in the forward in the original KOSMOS-2.5)\n+    \"gpt_model.decoder.self_attn_sope.scale\",\n+]\n+\n+\n+def rename_key(key):\n+    for key_to_modify, new_key in KEYS_TO_MODIFY_MAPPING.items():\n+        if key_to_modify in key:\n+            key = key.replace(key_to_modify, new_key)\n+\n+    return key\n+\n+\n+def convert_kosmos2_5_checkpoint_to_pytorch(checkpoint_path, pytorch_dump_folder_path):\n+    state = load_checkpoint_to_cpu(checkpoint_path)\n+    state_dict = state[\"model\"]\n+    state_dict_keys = list(state_dict.keys())\n+\n+    config = Kosmos2_5Config()\n+    # This is necessary to match the results given by the original demo\n+    config.text_config.no_repeat_ngram_size = 3\n+    model = Kosmos2_5ForConditionalGeneration(config)\n+\n+    # convert (by renaming keys)\n+    converted_state_dict = {}\n+    for key in state_dict_keys:\n+        if key in KEYS_TO_IGNORE:\n+            continue\n+        renamed_key = rename_key(key)\n+        converted_state_dict[renamed_key] = state_dict[key]\n+\n+    # set\n+    # check weight loading\n+    # check whether the state in converted_state_dict is the same as the state in the model\n+    model.load_state_dict(converted_state_dict, strict=True)\n+    # save the result\n+    model.save_pretrained(pytorch_dump_folder_path)\n+\n+\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser()\n+    # Required parameters\n+    parser.add_argument(\n+        \"--kosmos2_5_checkpoint_path\",\n+        default=\"ckpt.pt\",\n+        type=str,\n+        required=False,\n+        help=\"Path the official PyTorch dump.\",\n+    )\n+    parser.add_argument(\n+        \"--pytorch_dump_folder_path\",\n+        default=\"ckpt\",\n+        type=str,\n+        required=False,\n+        help=\"Path to the output PyTorch model.\",\n+    )\n+    args = parser.parse_args()\n+    convert_kosmos2_5_checkpoint_to_pytorch(args.kosmos2_5_checkpoint_path, args.pytorch_dump_folder_path)"
        },
        {
            "sha": "8ee6c482e0382e6cb94b87aeaefb7972b1958a4a",
            "filename": "src/transformers/models/kosmos2_5/image_processing_kosmos2_5.py",
            "status": "added",
            "additions": 353,
            "deletions": 0,
            "changes": 353,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fimage_processing_kosmos2_5.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fimage_processing_kosmos2_5.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fimage_processing_kosmos2_5.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -0,0 +1,353 @@\n+# coding=utf-8\n+# Copyright 2024 Microsoft Research and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Image processor class for Kosmos2_5.\"\"\"\n+\n+import math\n+from typing import Optional, Union\n+\n+import numpy as np\n+\n+from ...image_processing_utils import BaseImageProcessor, BatchFeature\n+from ...image_transforms import (\n+    convert_to_rgb,\n+    normalize,\n+    to_channel_dimension_format,\n+)\n+from ...image_utils import (\n+    ChannelDimension,\n+    ImageInput,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    make_list_of_images,\n+    to_numpy_array,\n+    valid_images,\n+)\n+from ...utils import TensorType, is_torch_available, logging\n+from ...utils.import_utils import requires_backends\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+logger = logging.get_logger(__name__)\n+DEFAULT_FONT_PATH = \"ybelkada/fonts\"\n+\n+\n+# Copied from transformers.models.pix2struct.image_processing_pix2struct.torch_extract_patches\n+def torch_extract_patches(image_tensor, patch_height, patch_width):\n+    \"\"\"\n+    Utiliy function to extract patches from a given image tensor. Returns a tensor of shape\n+    (1, `rows`, `columns`, `num_channels`x `patch_height` x `patch_width`).\n+\n+    Args:\n+        image_tensor (torch.Tensor):\n+            The image tensor to extract patches from.\n+        patch_height (int):\n+            The height of the patches to extract.\n+        patch_width (int):\n+            The width of the patches to extract.\n+    \"\"\"\n+    requires_backends(torch_extract_patches, [\"torch\"])\n+\n+    image_tensor = image_tensor.unsqueeze(0)\n+    patches = torch.nn.functional.unfold(image_tensor, (patch_height, patch_width), stride=(patch_height, patch_width))\n+    patches = patches.reshape(image_tensor.size(0), image_tensor.size(1), patch_height, patch_width, -1)\n+    patches = patches.permute(0, 4, 2, 3, 1).reshape(\n+        image_tensor.size(2) // patch_height,\n+        image_tensor.size(3) // patch_width,\n+        image_tensor.size(1) * patch_height * patch_width,\n+    )\n+    return patches.unsqueeze(0)\n+\n+\n+# similar to transformers.models.pix2struct.image_processing_pix2struct.Pix2StructImageProcessor, but delete is_vqa and additionaly return width and height after resizing\n+class Kosmos2_5ImageProcessor(BaseImageProcessor):\n+    r\"\"\"\n+    Constructs a Kosmos2_5 image processor.\n+\n+    Args:\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image. Can be overridden by the `do_normalize` parameter in the `preprocess`\n+            method. According to Kosmos2_5 paper and code, the image is normalized with its own mean and standard\n+            deviation.\n+        patch_size (`Dict[str, int]`, *optional*, defaults to `{\"height\": 16, \"width\": 16}`):\n+            The patch size to use for the image. According to Kosmos2_5 paper and code, the patch size is 16x16.\n+        max_patches (`int`, *optional*, defaults to 4096):\n+            The maximum number of patches to extract from the image as per the\n+            [KOSMOS 2.5 paper](https://arxiv.org/pdf/2309.11419).\n+    \"\"\"\n+\n+    model_input_names = [\"flattened_patches\"]\n+\n+    def __init__(\n+        self,\n+        do_convert_rgb: bool = True,\n+        do_normalize: bool = True,\n+        patch_size: Optional[dict[str, int]] = None,\n+        max_patches: int = 4096,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        self.patch_size = patch_size if patch_size is not None else {\"height\": 16, \"width\": 16}\n+        self.do_normalize = do_normalize\n+        self.do_convert_rgb = do_convert_rgb\n+        self.max_patches = max_patches\n+\n+    def extract_flattened_patches(\n+        self,\n+        image: np.ndarray,\n+        max_patches: int,\n+        patch_size: dict,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+        **kwargs,\n+    ) -> np.ndarray:\n+        \"\"\"\n+        Extract flattened patches from an image.\n+\n+        Args:\n+            image (`np.ndarray`):\n+                Image to extract flattened patches from.\n+            max_patches (`int`):\n+                Maximum number of patches to extract.\n+            patch_size (`dict`):\n+                Dictionary containing the patch height and width.\n+\n+        Returns:\n+            result (`np.ndarray`):\n+                A sequence of `max_patches` flattened patches.\n+        \"\"\"\n+        requires_backends(self.extract_flattened_patches, \"torch\")\n+\n+        # convert to torch\n+        image = to_channel_dimension_format(image, ChannelDimension.FIRST, input_data_format)\n+        image = torch.from_numpy(image)\n+\n+        patch_height, patch_width = patch_size[\"height\"], patch_size[\"width\"]\n+        image_height, image_width = get_image_size(image, ChannelDimension.FIRST)\n+\n+        # maximize scale s.t.\n+        scale = math.sqrt(max_patches * (patch_height / image_height) * (patch_width / image_width))\n+        num_feasible_rows = max(min(math.floor(scale * image_height / patch_height), max_patches), 1)\n+        num_feasible_cols = max(min(math.floor(scale * image_width / patch_width), max_patches), 1)\n+        resized_height = max(num_feasible_rows * patch_height, 1)\n+        resized_width = max(num_feasible_cols * patch_width, 1)\n+\n+        image = torch.nn.functional.interpolate(\n+            image.unsqueeze(0),\n+            size=(resized_height, resized_width),\n+            mode=\"bilinear\",\n+            align_corners=False,\n+            antialias=True,\n+        ).squeeze(0)\n+\n+        # [1, rows, columns, patch_height * patch_width * image_channels]\n+        patches = torch_extract_patches(image, patch_height, patch_width)\n+\n+        patches_shape = patches.shape\n+        rows = patches_shape[1]\n+        columns = patches_shape[2]\n+        depth = patches_shape[3]\n+\n+        # [rows * columns, patch_height * patch_width * image_channels]\n+        patches = patches.reshape([rows * columns, depth])\n+\n+        # [rows * columns, 1]\n+        row_ids = (\n+            torch.arange(rows, device=patches.device)\n+            .reshape([rows, 1])\n+            .repeat(1, columns)\n+            .reshape([rows * columns, 1])\n+        )\n+        col_ids = (\n+            torch.arange(columns, device=patches.device)\n+            .reshape([1, columns])\n+            .repeat(rows, 1)\n+            .reshape([rows * columns, 1])\n+        )\n+\n+        # Offset by 1 so the ids do not contain zeros, which represent padding.\n+        row_ids += 1\n+        col_ids += 1\n+\n+        # Prepare additional patch features.\n+        # [rows * columns, 1]\n+        row_ids = row_ids.to(torch.float32)\n+        col_ids = col_ids.to(torch.float32)\n+\n+        # [rows * columns, 2 + patch_height * patch_width * image_channels]\n+        result = torch.cat([row_ids, col_ids, patches], -1)\n+\n+        # [max_patches, 2 + patch_height * patch_width * image_channels]\n+        result = torch.nn.functional.pad(result, [0, 0, 0, max_patches - (rows * columns)]).float()\n+\n+        result = to_numpy_array(result)\n+\n+        return result, resized_width, resized_height, rows, columns\n+\n+    # Copied from transformers.models.pix2struct.image_processing_pix2struct.Pix2StructImageProcessor.normalize\n+    def normalize(\n+        self,\n+        image: np.ndarray,\n+        data_format: Optional[Union[str, ChannelDimension]] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+        **kwargs,\n+    ) -> np.ndarray:\n+        \"\"\"\n+        Normalize an image. image = (image - image_mean) / image_std.\n+\n+        The image std is to mimic the tensorflow implementation of the `per_image_standardization`:\n+        https://www.tensorflow.org/api_docs/python/tf/image/per_image_standardization\n+\n+        Args:\n+            image (`np.ndarray`):\n+                Image to normalize.\n+            data_format (`str` or `ChannelDimension`, *optional*):\n+                The channel dimension format for the output image. If unset, the channel dimension format of the input\n+                image is used.\n+            input_data_format (`str` or `ChannelDimension`, *optional*):\n+                The channel dimension format of the input image. If not provided, it will be inferred.\n+        \"\"\"\n+        if image.dtype == np.uint8:\n+            image = image.astype(np.float32)\n+\n+        # take mean across the whole `image`\n+        mean = np.mean(image)\n+        std = np.std(image)\n+        adjusted_stddev = max(std, 1.0 / math.sqrt(np.prod(image.shape)))\n+\n+        return normalize(\n+            image,\n+            mean=mean,\n+            std=adjusted_stddev,\n+            data_format=data_format,\n+            input_data_format=input_data_format,\n+            **kwargs,\n+        )\n+\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        do_convert_rgb: Optional[bool] = None,\n+        do_normalize: Optional[bool] = None,\n+        max_patches: Optional[int] = None,\n+        patch_size: Optional[dict[str, int]] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        data_format: ChannelDimension = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+        **kwargs,\n+    ) -> ImageInput:\n+        \"\"\"\n+        Preprocess an image or batch of images. The processor first computes the maximum possible number of\n+        aspect-ratio preserving patches of size `patch_size` that can be extracted from the image. It then pads the\n+        image with zeros to make the image respect the constraint of `max_patches`. Before extracting the patches the\n+        images are standardized following the tensorflow implementation of `per_image_standardization`\n+        (https://www.tensorflow.org/api_docs/python/tf/image/per_image_standardization).\n+\n+\n+        Args:\n+            images (`ImageInput`):\n+                Image to preprocess. Expects a single or batch of images.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            max_patches (`int`, *optional*, defaults to `self.max_patches`):\n+                Maximum number of patches to extract.\n+            patch_size (`dict`, *optional*, defaults to `self.patch_size`):\n+                Dictionary containing the patch height and width.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                    - Unset: Return a list of `np.ndarray`.\n+                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n+                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n+            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n+                from the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+        do_normalize = do_normalize if do_normalize is not None else self.do_normalize\n+        do_convert_rgb = do_convert_rgb if do_convert_rgb is not None else self.do_convert_rgb\n+        patch_size = patch_size if patch_size is not None else self.patch_size\n+        max_patches = max_patches if max_patches is not None else self.max_patches\n+\n+        if kwargs.get(\"data_format\") is not None:\n+            raise ValueError(\"data_format is not an accepted input as the outputs are \")\n+\n+        images = make_list_of_images(images)\n+\n+        if not valid_images(images):\n+            raise ValueError(\n+                \"Invalid image type. Must be of type PIL.Image.Image, numpy.ndarray, \"\n+                \"torch.Tensor, tf.Tensor or jax.ndarray.\"\n+            )\n+\n+        # PIL RGBA images are converted to RGB\n+        if do_convert_rgb:\n+            images = [convert_to_rgb(image) for image in images]\n+\n+        # All transformations expect numpy arrays.\n+        images = [to_numpy_array(image) for image in images]\n+\n+        if input_data_format is None:\n+            # We assume that all images have the same channel dimension format.\n+            input_data_format = infer_channel_dimension_format(images[0])\n+\n+        flattened_patches, width, height, rows, cols, attention_masks = [], [], [], [], [], []\n+        for image in images:\n+            if do_normalize:\n+                image = self.normalize(image=image, input_data_format=input_data_format)\n+\n+            # convert to torch tensor and permute\n+            patches, resized_width, resized_height, n_rows, n_columns = self.extract_flattened_patches(\n+                image=image,\n+                max_patches=max_patches,\n+                patch_size=patch_size,\n+                input_data_format=input_data_format,\n+            )\n+            flattened_patches.append(patches)\n+            width.append(resized_width)\n+            height.append(resized_height)\n+            rows.append(n_rows)\n+            cols.append(n_columns)\n+            # create attention mask in numpy\n+            attention_masks.append((patches.sum(axis=-1) != 0).astype(np.float32))\n+\n+        encoded_outputs = BatchFeature(\n+            data={\n+                \"flattened_patches\": flattened_patches,\n+                \"attention_mask\": attention_masks,\n+                \"width\": width,\n+                \"height\": height,\n+                \"rows\": rows,\n+                \"cols\": cols,\n+            },\n+            tensor_type=return_tensors,\n+        )\n+\n+        return encoded_outputs\n+\n+\n+__all__ = [\"Kosmos2_5ImageProcessor\"]"
        },
        {
            "sha": "e6962d65011a5a467c00163c91dec837e4635b40",
            "filename": "src/transformers/models/kosmos2_5/image_processing_kosmos2_5_fast.py",
            "status": "added",
            "additions": 299,
            "deletions": 0,
            "changes": 299,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fimage_processing_kosmos2_5_fast.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fimage_processing_kosmos2_5_fast.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fimage_processing_kosmos2_5_fast.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -0,0 +1,299 @@\n+# coding=utf-8\n+# Copyright 2025 Microsoft Research and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Fast Image processor class for Kosmos2_5.\"\"\"\n+\n+import math\n+from typing import Optional, Union\n+\n+from ...image_processing_utils import BatchFeature\n+from ...image_processing_utils_fast import (\n+    BaseImageProcessorFast,\n+    DefaultFastImageProcessorKwargs,\n+    group_images_by_shape,\n+    reorder_images,\n+)\n+from ...image_utils import ChannelDimension, ImageInput, get_image_size\n+from ...processing_utils import Unpack\n+from ...utils import TensorType, auto_docstring, is_torch_available\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+# Similar to transformers.models.pix2struct.image_processing_pix2struct.torch_extract_patches but dealing with a batch of images directly.\n+def torch_extract_patches(image_tensor, patch_height, patch_width):\n+    \"\"\"\n+    Utiliy function to extract patches from a given tensor representing a batch of images. Returns a tensor of shape\n+    (batch_size, `rows`, `columns`, `num_channels` x `patch_height` x `patch_width`).\n+\n+    Args:\n+        image_tensor (torch.Tensor):\n+            The image tensor to extract patches from.\n+        patch_height (int):\n+            The height of the patches to extract.\n+        patch_width (int):\n+            The width of the patches to extract.\n+    \"\"\"\n+    image_tensor = image_tensor\n+    patches = torch.nn.functional.unfold(image_tensor, (patch_height, patch_width), stride=(patch_height, patch_width))\n+    patches = patches.reshape(image_tensor.size(0), image_tensor.size(1), patch_height, patch_width, -1)\n+    patches = patches.permute(0, 4, 2, 3, 1).reshape(\n+        image_tensor.size(0),\n+        image_tensor.size(2) // patch_height,\n+        image_tensor.size(3) // patch_width,\n+        image_tensor.size(1) * patch_height * patch_width,\n+    )\n+    return patches\n+\n+\n+class Kosmos2_5FastImageProcessorKwargs(DefaultFastImageProcessorKwargs):\n+    r\"\"\"\n+    patch_size (`Dict[str, int]`, *optional*, defaults to `{\"height\": 16, \"width\": 16}`):\n+        The patch size to use for the image. According to Kosmos2_5 paper and code, the patch size is 16x16.\n+    max_patches (`int`, *optional*, defaults to 4096):\n+        The maximum number of patches to extract from the image as per the\n+        [KOSMOS 2.5 paper](https://arxiv.org/pdf/2309.11419).\n+    \"\"\"\n+\n+    patch_size: Optional[dict[str, int]]\n+    max_patches: Optional[int]\n+\n+\n+@auto_docstring\n+class Kosmos2_5ImageProcessorFast(BaseImageProcessorFast):\n+    # To be checked against the slow image processor\n+    # None values left after checking can be removed\n+    do_normalize = True\n+    do_convert_rgb = True\n+    patch_size = {\"height\": 16, \"width\": 16}\n+    max_patches = 4096\n+    rescale_factor = None\n+    valid_kwargs = Kosmos2_5FastImageProcessorKwargs\n+\n+    def __init__(self, **kwargs: Unpack[Kosmos2_5FastImageProcessorKwargs]):\n+        super().__init__(**kwargs)\n+\n+    @auto_docstring\n+    def preprocess(self, images: ImageInput, **kwargs: Unpack[Kosmos2_5FastImageProcessorKwargs]) -> BatchFeature:\n+        r\"\"\"\n+        patch_size (`Dict[str, int]`, *optional*, defaults to `{\"height\": 16, \"width\": 16}`):\n+            The patch size to use for the image. According to Kosmos2_5 paper and code, the patch size is 16x16.\n+        max_patches (`int`, *optional*, defaults to 4096):\n+            The maximum number of patches to extract from the image as per the\n+            [KOSMOS 2.5 paper](https://arxiv.org/pdf/2309.11419).\n+        \"\"\"\n+        # return super().preprocess(images, **kwargs)\n+        # TODO: revert once the issue is fixed: https://huggingface.slack.com/archives/C02TXKQQLE5/p1743411133979019\n+        return super().preprocess(images, image_mean=0.0, image_std=0.0, **kwargs)\n+\n+    def normalize(\n+        self,\n+        image: \"torch.Tensor\",\n+        **kwargs,\n+    ) -> \"torch.Tensor\":\n+        \"\"\"\n+        Normalize an image. image = (image - image_mean) / image_std.\n+\n+        The image std is to mimic the tensorflow implementation of the `per_image_standardization`:\n+        https://www.tensorflow.org/api_docs/python/tf/image/per_image_standardization\n+\n+        Args:\n+            image (`torch.Tensor`):\n+                Image to normalize.\n+        \"\"\"\n+        # Q: should we keep this?\n+        if image.dtype == torch.uint8:\n+            image = image.to(dtype=torch.float32)\n+\n+        # take mean across the whole `image` except the batch dim (= 0).\n+        dim = list(range(1, image.ndim))\n+        mean = torch.mean(image, dim=dim)\n+        std = torch.std(image, dim=dim)\n+        # num_elements in a single image\n+        num_elements = torch.tensor(torch.numel(image[0]))\n+        adjusted_stddev = torch.max(std, 1.0 / torch.sqrt(num_elements))\n+\n+        # change `image` from [batch_size, n_channels, width, height] to [n_channels, batch_size, width, height]\n+        image = torch.transpose(image, 0, 1)\n+\n+        # 'torchvision.transforms.Normalize` works on the usual channel dimension (dim=1) which is the batch\n+        # dimension before we use `transpose`.\n+        image = super().normalize(\n+            image,\n+            mean=mean,\n+            std=adjusted_stddev,\n+            **kwargs,\n+        )\n+        # back to [batch_size, n_channels, width, height]\n+        normalized_image = torch.transpose(image, 0, 1)\n+\n+        return normalized_image\n+\n+    def extract_flattened_patches(\n+        self,\n+        image: \"torch.Tensor\",\n+        max_patches: int,\n+        patch_size: dict,\n+        # TODO: correct this return type, and the docstring\n+    ) -> \"torch.Tensor\":\n+        \"\"\"\n+        Extract flattened patches from an image.\n+\n+        Args:\n+            image (`np.ndarray`):\n+                Image to extract flattened patches from.\n+            max_patches (`int`):\n+                Maximum number of patches to extract.\n+            patch_size (`dict`):\n+                Dictionary containing the patch height and width.\n+\n+        Returns:\n+            result (`np.ndarray`):\n+                A sequence of `max_patches` flattened patches.\n+        \"\"\"\n+        patch_height, patch_width = patch_size[\"height\"], patch_size[\"width\"]\n+        image_height, image_width = get_image_size(image, ChannelDimension.FIRST)\n+\n+        # maximize scale s.t.\n+        scale = math.sqrt(max_patches * (patch_height / image_height) * (patch_width / image_width))\n+        num_feasible_rows = max(min(math.floor(scale * image_height / patch_height), max_patches), 1)\n+        num_feasible_cols = max(min(math.floor(scale * image_width / patch_width), max_patches), 1)\n+        resized_height = max(num_feasible_rows * patch_height, 1)\n+        resized_width = max(num_feasible_cols * patch_width, 1)\n+\n+        image = torch.nn.functional.interpolate(\n+            image,\n+            size=(resized_height, resized_width),\n+            mode=\"bilinear\",\n+            align_corners=False,\n+            antialias=True,\n+        )\n+\n+        # [batch_size, rows, columns, patch_height * patch_width * image_channels]\n+        patches = torch_extract_patches(image, patch_height, patch_width)\n+\n+        patches_shape = patches.shape\n+        batch_size = patches_shape[0]\n+        rows = patches_shape[1]\n+        columns = patches_shape[2]\n+        depth = patches_shape[3]\n+\n+        # [batch_size, rows * columns, patch_height * patch_width * image_channels]\n+        patches = patches.reshape([batch_size, rows * columns, depth])\n+\n+        # [rows * columns, 1]\n+        row_ids = (\n+            torch.arange(rows, device=patches.device)\n+            .reshape([rows, 1])\n+            .repeat(1, columns)\n+            .reshape([rows * columns, 1])\n+        )\n+        col_ids = (\n+            torch.arange(columns, device=patches.device)\n+            .reshape([1, columns])\n+            .repeat(rows, 1)\n+            .reshape([rows * columns, 1])\n+        )\n+\n+        # Offset by 1 so the ids do not contain zeros, which represent padding.\n+        row_ids += 1\n+        col_ids += 1\n+\n+        # Prepare additional patch features.\n+        # [batch_size, rows * columns, 1]\n+        row_ids = row_ids.unsqueeze(0).repeat(batch_size, 1, 1).to(torch.float32)\n+        col_ids = col_ids.unsqueeze(0).repeat(batch_size, 1, 1).to(torch.float32)\n+\n+        # [rows * columns, 2 + patch_height * patch_width * image_channels]\n+        result = torch.cat([row_ids, col_ids, patches], -1)\n+\n+        # [batch_size, max_patches, 2 + patch_height * patch_width * image_channels]\n+        result = torch.nn.functional.pad(result, [0, 0, 0, max_patches - (rows * columns)]).float()\n+\n+        return result, resized_width, resized_height, rows, columns\n+\n+    def _preprocess(\n+        self,\n+        images: list[\"torch.Tensor\"],\n+        do_normalize: bool,\n+        max_patches: int,\n+        patch_size: dict[str, int],\n+        disable_grouping: Optional[bool],\n+        return_tensors: Optional[Union[str, TensorType]],\n+        **kwargs,\n+    ) -> BatchFeature:\n+        # Q: should we have this?\n+        if kwargs.get(\"data_format\") is not None:\n+            raise ValueError(\"data_format is not an accepted input as the outputs are \")\n+\n+        width, height, rows, cols, attention_masks = [], [], [], [], []\n+        obj_idx_to_new_index_map = {}\n+        current_index = -1\n+\n+        # Group images by size for batched resizing\n+        processed_image_patches_grouped = {}\n+        grouped_images, grouped_images_index = group_images_by_shape(images, disable_grouping=disable_grouping)\n+        for shape, stacked_images in grouped_images.items():\n+            # TODO: if it's possible to do in batch mode\n+            if do_normalize:\n+                stacked_images = self.normalize(stacked_images, **kwargs)\n+\n+            # TODO: we need this to be in batch from\n+            # convert to torch tensor and permute\n+            patches, resized_width, resized_height, n_rows, n_columns = self.extract_flattened_patches(\n+                image=stacked_images,\n+                max_patches=max_patches,\n+                patch_size=patch_size,\n+            )\n+            n_of_stacked_images = stacked_images.size()[0]\n+            width.extend([resized_width] * n_of_stacked_images)\n+            height.extend([resized_height] * n_of_stacked_images)\n+            rows.extend([n_rows] * n_of_stacked_images)\n+            cols.extend([n_columns] * n_of_stacked_images)\n+            # create attention mask in numpy\n+            attention_masks.extend(list((patches.sum(axis=-1) != 0).to(dtype=torch.float32)))\n+            processed_image_patches_grouped[shape] = list(patches)\n+            for x in processed_image_patches_grouped[shape]:\n+                current_index += 1\n+                obj_idx_to_new_index_map[id(x)] = current_index\n+\n+        processed_images = reorder_images(processed_image_patches_grouped, grouped_images_index)\n+        orig_idx_to_new_idx_map = {\n+            orig_idx: obj_idx_to_new_index_map[id(image)] for orig_idx, image in enumerate(processed_images)\n+        }\n+\n+        flattened_patches = processed_images\n+        width = [width[orig_idx_to_new_idx_map[orig_idx]] for orig_idx in orig_idx_to_new_idx_map]\n+        height = [height[orig_idx_to_new_idx_map[orig_idx]] for orig_idx in orig_idx_to_new_idx_map]\n+        rows = [rows[orig_idx_to_new_idx_map[orig_idx]] for orig_idx in orig_idx_to_new_idx_map]\n+        cols = [cols[orig_idx_to_new_idx_map[orig_idx]] for orig_idx in orig_idx_to_new_idx_map]\n+\n+        encoded_outputs = BatchFeature(\n+            data={\n+                \"flattened_patches\": torch.stack(flattened_patches, dim=0) if return_tensors else flattened_patches,\n+                \"attention_mask\": torch.stack(attention_masks, dim=0) if return_tensors else attention_masks,\n+                \"width\": width,\n+                \"height\": height,\n+                \"rows\": rows,\n+                \"cols\": cols,\n+            },\n+            tensor_type=return_tensors,\n+        )\n+\n+        return encoded_outputs\n+\n+\n+__all__ = [\"Kosmos2_5ImageProcessorFast\"]"
        },
        {
            "sha": "05fdfbf26c87466b2dc7df842d77b92c8fad14b7",
            "filename": "src/transformers/models/kosmos2_5/modeling_kosmos2_5.py",
            "status": "added",
            "additions": 1841,
            "deletions": 0,
            "changes": 1841,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fmodeling_kosmos2_5.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fmodeling_kosmos2_5.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fmodeling_kosmos2_5.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -0,0 +1,1841 @@\n+# coding=utf-8\n+# Copyright 2024 Microsoft Research and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch KOSMOS-2.5 model.\"\"\"\n+\n+import math\n+from dataclasses import dataclass\n+from typing import Any, Callable, Optional, Union\n+\n+import torch\n+import torch.utils.checkpoint\n+from torch import nn\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...modeling_attn_mask_utils import AttentionMaskConverter\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import (\n+    BaseModelOutput,\n+    BaseModelOutputWithPast,\n+    BaseModelOutputWithPastAndCrossAttentions,\n+    BaseModelOutputWithPooling,\n+    CausalLMOutputWithCrossAttentions,\n+)\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import (\n+    ModelOutput,\n+    TransformersKwargs,\n+    add_start_docstrings,\n+    add_start_docstrings_to_model_forward,\n+    can_return_tuple,\n+    is_torch_flex_attn_available,\n+    logging,\n+    replace_return_docstrings,\n+)\n+from .configuration_kosmos2_5 import (\n+    Kosmos2_5Config,\n+    Kosmos2_5TextConfig,\n+    Kosmos2_5VisionConfig,\n+)\n+\n+\n+if is_torch_flex_attn_available():\n+    from torch.nn.attention.flex_attention import BlockMask\n+\n+    from ...integrations.flex_attention import make_flex_block_causal_mask\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+_CONFIG_FOR_DOC = Kosmos2_5Config\n+\n+\n+# Copied from transformers.models.kosmos2.modeling_kosmos2._expand_mask\n+def _expand_mask(mask: torch.Tensor, dtype: torch.dtype, tgt_len: Optional[int] = None):\n+    \"\"\"\n+    Expands attention_mask from `[bsz, seq_len]` to `[bsz, 1, tgt_seq_len, src_seq_len]`.\n+    \"\"\"\n+    bsz, src_len = mask.size()\n+    tgt_len = tgt_len if tgt_len is not None else src_len\n+\n+    expanded_mask = mask[:, None, None, :].expand(bsz, 1, tgt_len, src_len).to(dtype)\n+\n+    inverted_mask = 1.0 - expanded_mask\n+\n+    return inverted_mask.masked_fill(inverted_mask.to(torch.bool), torch.finfo(dtype).min)\n+\n+\n+# Copied from transformers.models.roberta.modeling_roberta.create_position_ids_from_input_ids\n+def create_position_ids_from_input_ids(input_ids, padding_idx, past_key_values_length=0):\n+    \"\"\"\n+    Replace non-padding symbols with their position numbers. Position numbers begin at padding_idx+1. Padding symbols\n+    are ignored. This is modified from fairseq's `utils.make_positions`.\n+\n+    Args:\n+        x: torch.Tensor x:\n+\n+    Returns: torch.Tensor\n+    \"\"\"\n+    # The series of casts and type-conversions here are carefully balanced to both work with ONNX export and XLA.\n+    mask = input_ids.ne(padding_idx).int()\n+    incremental_indices = (torch.cumsum(mask, dim=1).type_as(mask) + past_key_values_length) * mask\n+    return incremental_indices.long() + padding_idx\n+\n+\n+KOSMOS2_5_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`Kosmos2_5Config`]): Model configuration class with all the parameters of the model.\n+            Initializing with a config file does not load the weights associated with the model, only the\n+            configuration. Check out the [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+KOSMOS2_5_VISION_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        flattened_patches (`torch.FloatTensor` of shape `(batch_size, max_patches, 2 + patch_height * patch_width * image_channels)`):\n+            Flattened patches of the images. `flattened_patches` can be obtained using [`AutoImageProcessor`]. See\n+            [`Kosmos2_5ImageProcessor.__call__`] for details.\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+\"\"\"\n+\n+KOSMOS2_5_TEXT_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+            it.\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            [What are input IDs?](../glossary#input-ids)\n+        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+            - 1 for tokens that are **not masked**,\n+            - 0 for tokens that are **masked**.\n+\n+            [What are attention masks?](../glossary#attention-mask)\n+        image_embeds: (`torch.FloatTensor` of shape `(batch_size, latent_query_num, hidden_size)`, *optional*):\n+            Sequence of hidden-states at the output of `Kosmos2ImageToTextProjection`.\n+        image_embeds_position_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to indicate the location in a sequence to insert the image features . Mask values selected in `[0,\n+            1]`:\n+\n+            - 1 for places where to put the image features,\n+            - 0 for places that are not for image features (i.e. for text tokens).\n+\n+        past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n+            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n+            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n+            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n+        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n+            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n+            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n+            model's internal embedding lookup matrix.\n+        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n+            config.max_position_embeddings - 1]`.\n+\n+            [What are position IDs?](../glossary#position-ids)\n+        use_cache (`bool`, *optional*):\n+            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n+            `past_key_values`).\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+\"\"\"\n+\n+KOSMOS2_5_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+            it.\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            [What are input IDs?](../glossary#input-ids)\n+        flattened_patches (`torch.FloatTensor` of shape `(batch_size, max_patches, 2 + patch_height * patch_width * image_channels)`):\n+            Flattened patches of the images. `flattened_patches` can be obtained using [`AutoImageProcessor`]. See\n+            [`Kosmos2_5ImageProcessor.__call__`] for details.\n+        width (`torch.FloatTensor` of shape `(batch_size,)`):\n+            The original width (before resizing) of each image in the batch. This can be obtained using\n+            [`AutoImageProcessor`]. See [`Kosmos2_5ImageProcessor.__call__`] for details.\n+        height (`torch.FloatTensor` of shape `(batch_size,)`):\n+            The original height (before resizing) of each image in the batch. This can be obtained using\n+            [`AutoImageProcessor`]. See [`Kosmos2_5ImageProcessor.__call__`] for details.\n+        image_embeds_position_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to indicate the location in a sequence to insert the image features . Mask values selected in `[0,\n+            1]`:\n+\n+            - 1 for places where to put the image features,\n+            - 0 for places that are not for image features (i.e. for text tokens).\n+\n+        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+            - 1 for tokens that are **not masked**,\n+            - 0 for tokens that are **masked**.\n+\n+            [What are attention masks?](../glossary#attention-mask)\n+\n+        past_key_values (`tuple(tuple(torch.FloatTensor))` of length `config.n_layers` with each tuple having 4 tensors of shape `(batch_size, num_heads, sequence_length - 1, embed_size_per_head)`):\n+            Contains precomputed key and value hidden states of the attention blocks. Can be used to speed up decoding.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n+            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n+            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n+        image_embeds: (`torch.FloatTensor` of shape `(batch_size, latent_query_num, hidden_size)`, *optional*):\n+            Sequence of hidden-states at the output of `Kosmos2ImageToTextProjection`.\n+        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n+            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n+            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n+            model's internal embedding lookup matrix.\n+        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n+            config.max_position_embeddings - 1]`.\n+\n+            [What are position IDs?](../glossary#position-ids)\n+        use_cache (`bool`, *optional*):\n+            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n+            `past_key_values`).\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+\"\"\"\n+\n+\n+@dataclass\n+class Kosmos2_5ModelOutput(ModelOutput):\n+    \"\"\"\n+    Base class for text model's outputs that also contains a pooling of the last hidden states.\n+\n+    Args:\n+        last_hidden_state (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`):\n+            Sequence of hidden-states at the output of the last layer of the model.\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        width (`torch.FloatTensor` of shape `(batch_size,)`):\n+            The original width (before resizing) of each image in the batch.\n+        height (`torch.FloatTensor` of shape `(batch_size,)`):\n+            The original height (before resizing) of each image in the batch.\n+        image_embeds (`torch.FloatTensor` of shape `(batch_size, latent_query_num, hidden_size)`, *optional*):\n+            Sequence of hidden-states at the output of `Kosmos2ImageToTextProjection`.\n+        projection_attentions (`tuple(torch.FloatTensor)`, *optional*):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+\n+            Attentions weights given by `Kosmos2ImageToTextProjection`, after the attention softmax, used to compute\n+            the weighted average in the self-attention heads.\n+        vision_model_output(`BaseModelOutputWithPooling`, *optional*):\n+            The output of the [`Kosmos2VisionModel`].\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`) and optionally if\n+            `config.is_encoder_decoder=True` 2 additional tensors of shape `(batch_size, num_heads,\n+            encoder_sequence_length, embed_size_per_head)`.\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks and optionally if\n+            `config.is_encoder_decoder=True` in the cross-attention blocks) that can be used (see `past_key_values`\n+            input) to speed up sequential decoding.\n+    \"\"\"\n+\n+    last_hidden_state: torch.FloatTensor = None\n+    past_key_values: Optional[tuple[tuple[torch.FloatTensor]]] = None\n+    hidden_states: Optional[tuple[torch.FloatTensor]] = None\n+    attentions: Optional[tuple[torch.FloatTensor]] = None\n+    width: Optional[torch.FloatTensor] = None\n+    height: Optional[torch.FloatTensor] = None\n+    image_embeds: Optional[torch.FloatTensor] = None\n+    projection_attentions: Optional[tuple[torch.FloatTensor]] = None\n+    vision_model_output: BaseModelOutputWithPooling = None\n+\n+    def to_tuple(self) -> tuple[Any]:\n+        return tuple(\n+            (self[k] if k not in [\"vision_model_output\"] else getattr(self, k).to_tuple()) for k in self.keys()\n+        )\n+\n+\n+@dataclass\n+class Kosmos2_5ForConditionalGenerationModelOutput(ModelOutput):\n+    \"\"\"\n+    Model output class for `Kosmos2_5ForConditionalGeneration`.\n+\n+    Args:\n+        loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+            Language modeling loss (for next-token prediction).\n+        logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n+            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        width (`torch.FloatTensor` of shape `(batch_size,)`):\n+            The original width (before resizing) of each image in the batch.\n+        height (`torch.FloatTensor` of shape `(batch_size,)`):\n+            The original height (before resizing) of each image in the batch.\n+        image_embeds (`torch.FloatTensor` of shape `(batch_size, latent_query_num, hidden_size)`, *optional*):\n+            Sequence of hidden-states at the output of `Kosmos2ImageToTextProjection`.\n+        projection_attentions (`tuple(torch.FloatTensor)`, *optional*):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+\n+            Attentions weights given by `Kosmos2ImageToTextProjection`, after the attention softmax, used to compute\n+            the weighted average in the self-attention heads.\n+        vision_model_output(`BaseModelOutputWithPooling`, *optional*):\n+            The output of the [`Kosmos2VisionModel`].\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`) and optionally if\n+            `config.is_encoder_decoder=True` 2 additional tensors of shape `(batch_size, num_heads,\n+            encoder_sequence_length, embed_size_per_head)`.\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks and optionally if\n+            `config.is_encoder_decoder=True` in the cross-attention blocks) that can be used (see `past_key_values`\n+            input) to speed up sequential decoding.\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: torch.FloatTensor = None\n+    past_key_values: Optional[Union[Cache, list[torch.FloatTensor]]] = None\n+    hidden_states: Optional[tuple[torch.FloatTensor]] = None\n+    attentions: Optional[tuple[torch.FloatTensor]] = None\n+    width: Optional[torch.FloatTensor] = None\n+    height: Optional[torch.FloatTensor] = None\n+    image_embeds: Optional[torch.FloatTensor] = None\n+    projection_attentions: Optional[tuple[torch.FloatTensor]] = None\n+    vision_model_output: BaseModelOutputWithPooling = None\n+\n+    def to_tuple(self) -> tuple[Any]:\n+        return tuple(\n+            (self[k] if k not in [\"vision_model_output\"] else getattr(self, k).to_tuple()) for k in self.keys()\n+        )\n+\n+\n+# Copied from transformers.models.pix2struct.modeling_pix2struct.Pix2StructLayerNorm with Pix2Struct->Kosmos2_5\n+class Kosmos2_5LayerNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        Construct a layernorm module in the T5 style. No bias and no subtraction of mean.\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        # T5 uses a layer_norm which only scales and doesn't shift, which is also known as Root Mean\n+        # Square Layer Normalization https://huggingface.co/papers/1910.07467 thus variance is calculated\n+        # w/o mean and there is no bias. Additionally we want to make sure that the accumulation for\n+        # half-precision inputs is done in fp32\n+\n+        variance = hidden_states.to(torch.float32).pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+\n+        # convert into half-precision if necessary\n+        if self.weight.dtype in [torch.float16, torch.bfloat16]:\n+            hidden_states = hidden_states.to(self.weight.dtype)\n+\n+        return self.weight * hidden_states\n+\n+\n+# similar to transformers.models.pix2struct.modeling_pix2struct.Pix2StructVisionEmbeddings but with `inplace=False`\n+# TODO: check with krip\n+class Kosmos2_5VisionEmbeddings(nn.Module):\n+    def __init__(self, config: Kosmos2_5VisionConfig) -> None:\n+        super().__init__()\n+        self.config = config\n+        self.patch_projection = nn.Linear(config.patch_embed_hidden_size, config.hidden_size)\n+\n+        self.row_embedder = nn.Embedding(config.max_num_patches, config.hidden_size)\n+        self.column_embedder = nn.Embedding(config.max_num_patches, config.hidden_size)\n+\n+        self.dropout = nn.Dropout(config.dropout_rate, inplace=False)\n+\n+    def forward(self, flattened_patches: torch.Tensor) -> torch.Tensor:\n+        # the row and column indices are stored in the first and second position of the flattened_patches\n+        # flattened_patches: `batch_size`, `seq_len`, `hidden_size` + 2\n+        row_indices = flattened_patches[:, :, 0].long()\n+        col_indices = flattened_patches[:, :, 1].long()\n+\n+        flattened_patches = flattened_patches[:, :, 2:]\n+\n+        embeddings = self.patch_projection(flattened_patches)\n+        row_embeddings = self.row_embedder(row_indices).to(embeddings.device)\n+        col_embeddings = self.column_embedder(col_indices).to(embeddings.device)\n+\n+        # sum all embeddings together\n+        embeddings = embeddings + row_embeddings + col_embeddings\n+\n+        embeddings = self.dropout(embeddings)\n+\n+        return embeddings\n+\n+\n+# Copied from transformers.models.t5.modeling_t5.T5DenseGatedActDense with T5DenseGatedActDense->Pix2StructVisionMlp,T5Config->Pix2StructVisionConfig,config.d_model->config.hidden_size,dropout_rate->dropout_rate\n+class Kosmos2_5VisionMlp(nn.Module):\n+    def __init__(self, config: Kosmos2_5VisionConfig):\n+        super().__init__()\n+        self.wi_0 = nn.Linear(config.hidden_size, config.intermediate_size, bias=False)\n+        self.wi_1 = nn.Linear(config.hidden_size, config.intermediate_size, bias=False)\n+        self.wo = nn.Linear(config.intermediate_size, config.hidden_size, bias=False)\n+        self.dropout = nn.Dropout(config.dropout_rate)\n+        self.act = ACT2FN[config.dense_act_fn]\n+\n+        # Ignore copy\n+        self.config = config\n+\n+    def forward(self, hidden_states):\n+        hidden_gelu = self.act(self.wi_0(hidden_states))\n+        hidden_linear = self.wi_1(hidden_states)\n+        hidden_states = hidden_gelu * hidden_linear\n+        hidden_states = self.dropout(hidden_states)\n+\n+        # To make 8bit quantization work for google/flan-t5-xxl, self.wo is kept in float32.\n+        # See https://github.com/huggingface/transformers/issues/20287\n+        # we also make sure the weights are not in `int8` in case users will force `_keep_in_fp32_modules` to be `None``\n+        if (\n+            isinstance(self.wo.weight, torch.Tensor)\n+            and hidden_states.dtype != self.wo.weight.dtype\n+            and self.wo.weight.dtype != torch.int8\n+        ):\n+            hidden_states = hidden_states.to(self.wo.weight.dtype)\n+\n+        hidden_states = self.wo(hidden_states)\n+        return hidden_states\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs,\n+):\n+    # this weight maybe overflow with fp16\n+    attn_weights = torch.matmul(query, key.transpose(2, 3)) * scaling\n+\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+class Kosmos2_5VisionAttention(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.head_dim = config.head_dim\n+        self.n_heads = config.num_attention_heads\n+        self.dropout = config.attention_dropout\n+        self.inner_dim = self.n_heads * self.head_dim\n+        self.is_causal = False\n+        self.scaling = self.head_dim**-0.5\n+\n+        # Mesh TensorFlow initialization to avoid scaling before softmax\n+        self.query = nn.Linear(self.hidden_size, self.inner_dim, bias=False)\n+        self.key = nn.Linear(self.hidden_size, self.inner_dim, bias=False)\n+        self.value = nn.Linear(self.hidden_size, self.inner_dim, bias=False)\n+        self.output = nn.Linear(self.inner_dim, self.hidden_size, bias=False)\n+\n+        self.gradient_checkpointing = False\n+\n+    def forward(\n+        self,\n+        hidden_states,\n+        attention_mask=None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ):\n+        \"\"\"\n+        Self-attention block\n+        \"\"\"\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.query(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.key(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.value(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            if self.config._attn_implementation == \"sdpa\" and kwargs.get(\"output_attentions\", False):\n+                logger.warning_once(\n+                    \"`torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. Falling back to \"\n+                    'eager attention. This warning can be removed using the argument `attn_implementation=\"eager\"` when loading the model.'\n+                )\n+            else:\n+                attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1)\n+        attn_output = self.output(attn_output)\n+\n+        return attn_output, attn_weights\n+\n+\n+class Kosmos2_5VisionLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: Kosmos2_5VisionConfig) -> None:\n+        super().__init__()\n+        self.config = config\n+\n+        self.attention = Kosmos2_5VisionAttention(config)\n+        self.mlp = Kosmos2_5VisionMlp(config)\n+        self.pre_mlp_layer_norm = Kosmos2_5LayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n+        self.pre_attention_layer_norm = Kosmos2_5LayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        output_attentions: bool = False,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple[torch.Tensor, torch.Tensor], tuple[torch.Tensor]]:\n+        residual = hidden_states\n+\n+        # in  Kosmos2_5Vision, layernorm is applied before self-attention\n+        hidden_states = self.pre_attention_layer_norm(hidden_states)\n+\n+        attention_output, self_attn_weights = self.attention(\n+            hidden_states,\n+            attention_mask=attention_mask,\n+            output_attentions=output_attentions,\n+            **kwargs,\n+        )\n+\n+        # first residual connection\n+        hidden_states = attention_output + residual\n+\n+        # in  Kosmos2_5Vision, layernorm is also applied after self-attention\n+        layer_output = self.pre_mlp_layer_norm(hidden_states)\n+        layer_output = self.mlp(layer_output) + hidden_states  # second residual connection\n+\n+        outputs = (layer_output,)\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        return outputs\n+\n+\n+# Adapted from transformers.models.pix2struct.modeling_pix2struct.Pix2StructVisionEncoder with Pix2Struct->Kosmos2_5\n+class Kosmos2_5VisionEncoder(nn.Module):\n+    def __init__(self, config: Kosmos2_5VisionConfig) -> None:\n+        super().__init__()\n+        self.config = config\n+        self.layer = nn.ModuleList([Kosmos2_5VisionLayer(config) for _ in range(config.num_hidden_layers)])\n+        self.gradient_checkpointing = False\n+\n+    def _prepare_attention_mask(self, attention_mask, input_shape, inputs_embeds):\n+        if self.config._attn_implementation == \"flash_attention_2\":\n+            if attention_mask is not None and 0.0 in attention_mask:\n+                return attention_mask\n+            return None\n+        if attention_mask is not None:\n+            # [bsz, seq_len] -> [bsz, 1, tgt_seq_len, src_seq_len]\n+            expanded_attn_mask = _expand_mask(attention_mask, inputs_embeds.dtype, tgt_len=input_shape[-1]).to(\n+                inputs_embeds.device\n+            )\n+        return expanded_attn_mask\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        output_attentions: bool = False,\n+        output_hidden_states: bool = False,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> BaseModelOutput:\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attentions = () if output_attentions else None\n+\n+        attention_mask = self._prepare_attention_mask(attention_mask, hidden_states.shape[:2], hidden_states)\n+\n+        for i, layer_module in enumerate(self.layer):\n+            if output_hidden_states:\n+                all_hidden_states = all_hidden_states + (hidden_states,)\n+\n+            layer_outputs = layer_module(hidden_states, attention_mask, output_attentions, **kwargs)\n+            hidden_states = layer_outputs[0]\n+\n+            if output_attentions:\n+                all_self_attentions = all_self_attentions + (layer_outputs[1],)\n+\n+        if output_hidden_states:\n+            all_hidden_states = all_hidden_states + (hidden_states,)\n+\n+        return BaseModelOutput(\n+            last_hidden_state=hidden_states,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attentions,\n+        )\n+\n+\n+# Copied from transformers.models.kosmos2.modeling_kosmos2.Kosmos2TextSinusoidalPositionalEmbedding with Kosmos2->Kosmos2_5\n+class Kosmos2_5TextSinusoidalPositionalEmbedding(nn.Module):\n+    \"\"\"This module produces sinusoidal positional embeddings of any length.\"\"\"\n+\n+    # Copied from transformers.models.m2m_100.modeling_m2m_100.M2M100SinusoidalPositionalEmbedding.__init__\n+    def __init__(self, num_positions: int, embedding_dim: int, padding_idx: Optional[int] = None):\n+        super().__init__()\n+        self.offset = 2\n+        self.embedding_dim = embedding_dim\n+        self.padding_idx = padding_idx\n+        self.make_weights(num_positions + self.offset, embedding_dim, padding_idx)\n+\n+    # Copied from transformers.models.m2m_100.modeling_m2m_100.M2M100SinusoidalPositionalEmbedding.make_weights\n+    def make_weights(self, num_embeddings: int, embedding_dim: int, padding_idx: Optional[int] = None):\n+        emb_weights = self.get_embedding(num_embeddings, embedding_dim, padding_idx)\n+        if hasattr(self, \"weights\"):\n+            # in forward put the weights on the correct dtype and device of the param\n+            emb_weights = emb_weights.to(dtype=self.weights.dtype, device=self.weights.device)\n+\n+        self.register_buffer(\"weights\", emb_weights, persistent=False)\n+\n+    @staticmethod\n+    # Copied from transformers.models.m2m_100.modeling_m2m_100.M2M100SinusoidalPositionalEmbedding.get_embedding\n+    def get_embedding(num_embeddings: int, embedding_dim: int, padding_idx: Optional[int] = None):\n+        \"\"\"\n+        Build sinusoidal embeddings.\n+\n+        This matches the implementation in tensor2tensor, but differs slightly from the description in Section 3.5 of\n+        \"Attention Is All You Need\".\n+        \"\"\"\n+        half_dim = embedding_dim // 2\n+        emb = math.log(10000) / (half_dim - 1)\n+        emb = torch.exp(torch.arange(half_dim, dtype=torch.int64).float() * -emb)\n+        emb = torch.arange(num_embeddings, dtype=torch.int64).float().unsqueeze(1) * emb.unsqueeze(0)\n+        emb = torch.cat([torch.sin(emb), torch.cos(emb)], dim=1).view(num_embeddings, -1)\n+        if embedding_dim % 2 == 1:\n+            # zero pad\n+            emb = torch.cat([emb, torch.zeros(num_embeddings, 1)], dim=1)\n+        if padding_idx is not None:\n+            emb[padding_idx, :] = 0\n+\n+        return emb.to(torch.get_default_dtype())\n+\n+    @torch.no_grad()\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.Tensor] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        past_key_values_length: int = 0,\n+        position_ids: Optional[torch.Tensor] = None,\n+    ):\n+        if input_ids is not None:\n+            bsz, seq_len = input_ids.size()\n+            if position_ids is None:\n+                # Create the position ids from the input token ids. Any padded tokens remain padded.\n+                position_ids = create_position_ids_from_input_ids(\n+                    input_ids, self.padding_idx, past_key_values_length\n+                ).to(input_ids.device)\n+        else:\n+            bsz, seq_len = inputs_embeds.size()[:-1]\n+            if position_ids is None:\n+                position_ids = self.create_position_ids_from_inputs_embeds(inputs_embeds, past_key_values_length)\n+\n+        # expand embeddings if needed\n+        max_pos = self.padding_idx + 1 + seq_len + past_key_values_length\n+        if max_pos > self.weights.size(0):\n+            self.make_weights(max_pos + self.offset, self.embedding_dim, self.padding_idx)\n+\n+        return self.weights.index_select(0, position_ids.view(-1)).view(bsz, seq_len, self.weights.shape[-1]).detach()\n+\n+    # Copied from transformers.models.m2m_100.modeling_m2m_100.M2M100SinusoidalPositionalEmbedding.create_position_ids_from_inputs_embeds\n+    def create_position_ids_from_inputs_embeds(self, inputs_embeds, past_key_values_length):\n+        \"\"\"\n+        We are provided embeddings directly. We cannot infer which are padded so just generate sequential position ids.\n+\n+        Args:\n+            inputs_embeds: torch.Tensor\n+\n+        Returns: torch.Tensor\n+        \"\"\"\n+        input_shape = inputs_embeds.size()[:-1]\n+        sequence_length = input_shape[1]\n+\n+        position_ids = torch.arange(\n+            self.padding_idx + 1, sequence_length + self.padding_idx + 1, dtype=torch.long, device=inputs_embeds.device\n+        )\n+        return position_ids.unsqueeze(0).expand(input_shape).contiguous() + past_key_values_length\n+\n+\n+# Copied from transformers.models.kosmos2.modeling_kosmos2.Kosmos2TextFFN with Kosmos2->Kosmos2_5\n+class Kosmos2_5TextFFN(nn.Module):\n+    def __init__(self, config: Kosmos2_5TextConfig):\n+        super().__init__()\n+\n+        self.dropout = config.dropout\n+        self.activation_fn = ACT2FN[config.activation_function]\n+        self.activation_dropout = config.activation_dropout\n+\n+        self.fc1 = nn.Linear(config.embed_dim, config.ffn_dim)\n+        self.fc2 = nn.Linear(config.ffn_dim, config.embed_dim)\n+\n+        self.ffn_layernorm = nn.LayerNorm(config.ffn_dim, eps=config.layer_norm_eps)\n+\n+    def forward(self, hidden_states):\n+        hidden_states = self.activation_fn(self.fc1(hidden_states))\n+        hidden_states = nn.functional.dropout(hidden_states, p=self.activation_dropout, training=self.training)\n+        hidden_states = self.ffn_layernorm(hidden_states)\n+        hidden_states = self.fc2(hidden_states)\n+        hidden_states = nn.functional.dropout(hidden_states, p=self.dropout, training=self.training)\n+\n+        return hidden_states\n+\n+\n+class Kosmos2_5TextAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(\n+        self,\n+        config,\n+        embed_dim: int,\n+        num_heads: int,\n+        dropout: float = 0.0,\n+        is_decoder: bool = False,\n+        bias: bool = True,\n+        is_causal=True,\n+        layer_idx: Optional[int] = None,\n+    ):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.embed_dim = embed_dim\n+        self.num_heads = num_heads\n+        self.dropout = dropout\n+        self.head_dim = embed_dim // num_heads\n+\n+        if (self.head_dim * num_heads) != self.embed_dim:\n+            raise ValueError(\n+                f\"embed_dim must be divisible by num_heads (got `embed_dim`: {self.embed_dim}\"\n+                f\" and `num_heads`: {num_heads}).\"\n+            )\n+        self.scaling = self.head_dim**-0.5\n+        self.is_decoder = is_decoder\n+\n+        self.k_proj = nn.Linear(embed_dim, embed_dim, bias=bias)\n+        self.v_proj = nn.Linear(embed_dim, embed_dim, bias=bias)\n+        self.q_proj = nn.Linear(embed_dim, embed_dim, bias=bias)\n+        self.out_proj = nn.Linear(embed_dim, embed_dim, bias=bias)\n+        self.is_causal = is_causal\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,  # text part\n+        encoder_hidden_states: Optional[torch.Tensor] = None,  # image part\n+        attention_mask: Optional[torch.Tensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor], Optional[tuple[torch.Tensor]]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        # use encoder_hidden_states if cross attention\n+        is_cross_attention = encoder_hidden_states is not None\n+        current_states = encoder_hidden_states if is_cross_attention else hidden_states\n+\n+        current_input_shape = current_states.shape[:-1]\n+        current_hidden_shape = (*current_input_shape, -1, self.head_dim)\n+\n+        key_states = self.k_proj(current_states).view(current_hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(current_states).view(current_hidden_shape).transpose(1, 2)\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        # Apply `self.scaling`\n+        query_states = self.scaling * query_states\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            if self.config._attn_implementation == \"sdpa\" and kwargs.get(\"output_attentions\", False):\n+                logger.warning_once(\n+                    \"`torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. Falling back to \"\n+                    'eager attention. This warning can be removed using the argument `attn_implementation=\"eager\"` when loading the model.'\n+                )\n+            else:\n+                attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.dropout,\n+            scaling=1.0,  # We don't use `self.scaling` as it's already applied to `query_states` above .\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.out_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class Kosmos2_5TextBlock(GradientCheckpointingLayer):\n+    def __init__(self, config: Kosmos2_5TextConfig, layer_idx: int):\n+        super().__init__()\n+        self.embed_dim = config.embed_dim\n+        self.layer_idx = layer_idx\n+        self.self_attn = Kosmos2_5TextAttention(\n+            config,\n+            embed_dim=self.embed_dim,\n+            num_heads=config.attention_heads,\n+            dropout=config.attention_dropout,\n+            is_decoder=True,\n+            is_causal=True,\n+            layer_idx=layer_idx,\n+        )\n+        self.dropout = config.dropout\n+        self.self_attn_layer_norm = nn.LayerNorm(self.embed_dim, eps=config.layer_norm_eps)\n+        self.ffn = Kosmos2_5TextFFN(config)\n+        self.final_layer_norm = nn.LayerNorm(self.embed_dim, eps=config.layer_norm_eps)\n+\n+    # Adapted from transformers.models.kosmos2.modeling_kosmos2.Kosmos2TextBlock.forward\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: Optional[bool] = False,\n+        use_cache: Optional[bool] = True,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.FloatTensor, Optional[tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        residual = hidden_states\n+\n+        hidden_states = self.self_attn_layer_norm(hidden_states)\n+\n+        # Self Attention\n+        hidden_states, self_attn_weights = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = nn.functional.dropout(hidden_states, p=self.dropout, training=self.training)\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.final_layer_norm(hidden_states)\n+        hidden_states = self.ffn(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        outputs = (hidden_states,)\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        return outputs\n+\n+\n+# Adapted from transformers.models.kosmos2.modeling_kosmos2.Kosmos2TextTransformer with Kosmos2->Kosmos2_5\n+class Kosmos2_5TextTransformer(nn.Module):\n+    \"\"\"\n+    Transformer decoder consisting of `config.layers` layers. Each layer is a [`Kosmos2_5TextBlock`].\n+    Here we doesn't have cross attention.\n+    Args:\n+        config: Kosmos2_5TextConfig\n+    \"\"\"\n+\n+    def __init__(self, config: Kosmos2_5TextConfig):\n+        super().__init__()\n+        self.config = config\n+        self.dropout = config.dropout\n+        self.layerdrop = config.layerdrop\n+\n+        self.embed_scale = math.sqrt(config.embed_dim) if config.scale_embedding else 1.0\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.embed_dim, padding_idx=config.pad_token_id)\n+\n+        self.embed_positions = Kosmos2_5TextSinusoidalPositionalEmbedding(\n+            num_positions=config.max_position_embeddings,\n+            embedding_dim=config.embed_dim,\n+            padding_idx=config.pad_token_id,\n+        )\n+\n+        # Ignore copy\n+        self.segment_emb = nn.Embedding(2, config.embed_dim)\n+        self.layers = nn.ModuleList([Kosmos2_5TextBlock(config, layer_idx) for layer_idx in range(config.layers)])\n+        self.layer_norm = nn.LayerNorm(config.embed_dim, config.layer_norm_eps)\n+        self.gradient_checkpointing = False\n+\n+    # TODO (ydshieh): Remove this (to match Llama's code)\n+    def _update_causal_mask(\n+        self,\n+        attention_mask: Union[torch.Tensor, \"BlockMask\"],\n+        input_tensor: torch.Tensor,\n+        cache_position: torch.Tensor,\n+        past_key_values: Cache,\n+        output_attentions: bool = False,\n+    ):\n+        if self.config._attn_implementation == \"flash_attention_2\":\n+            if attention_mask is not None and (attention_mask == 0.0).any():\n+                return attention_mask\n+            return None\n+        if self.config._attn_implementation == \"flex_attention\":\n+            if isinstance(attention_mask, torch.Tensor):\n+                attention_mask = make_flex_block_causal_mask(attention_mask)\n+            return attention_mask\n+\n+        # For SDPA, when possible, we will rely on its `is_causal` argument instead of its `attn_mask` argument, in\n+        # order to dispatch on Flash Attention 2. This feature is not compatible with static cache, as SDPA will fail\n+        # to infer the attention mask.\n+        past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+        using_compilable_cache = past_key_values.is_compileable if past_key_values is not None else False\n+\n+        # When output attentions is True, sdpa implementation's forward method calls the eager implementation's forward\n+        if self.config._attn_implementation == \"sdpa\" and not using_compilable_cache and not output_attentions:\n+            if AttentionMaskConverter._ignore_causal_mask_sdpa(\n+                attention_mask,\n+                inputs_embeds=input_tensor,\n+                past_key_values_length=past_seen_tokens,\n+                is_training=self.training,\n+            ):\n+                return None\n+\n+        dtype = input_tensor.dtype\n+        sequence_length = input_tensor.shape[1]\n+        if using_compilable_cache:\n+            target_length = past_key_values.get_max_cache_shape()\n+        else:\n+            target_length = (\n+                attention_mask.shape[-1]\n+                if isinstance(attention_mask, torch.Tensor)\n+                else past_seen_tokens + sequence_length + 1\n+            )\n+\n+        # In case the provided `attention` mask is 2D, we generate a causal mask here (4D).\n+        causal_mask = self._prepare_4d_causal_attention_mask_with_cache_position(\n+            attention_mask,\n+            sequence_length=sequence_length,\n+            target_length=target_length,\n+            dtype=dtype,\n+            cache_position=cache_position,\n+            batch_size=input_tensor.shape[0],\n+        )\n+\n+        if (\n+            self.config._attn_implementation == \"sdpa\"\n+            and attention_mask is not None\n+            and attention_mask.device.type in [\"cuda\", \"xpu\", \"npu\"]\n+            and not output_attentions\n+        ):\n+            # Attend to all tokens in fully masked rows in the causal_mask, for example the relevant first rows when\n+            # using left padding. This is required by F.scaled_dot_product_attention memory-efficient attention path.\n+            # Details: https://github.com/pytorch/pytorch/issues/110213\n+            min_dtype = torch.finfo(dtype).min\n+            causal_mask = AttentionMaskConverter._unmask_unattended(causal_mask, min_dtype)\n+\n+        return causal_mask\n+\n+    @staticmethod\n+    # TODO (ydshieh): Remove this (to match Llama's code)\n+    def _prepare_4d_causal_attention_mask_with_cache_position(\n+        attention_mask: torch.Tensor,\n+        sequence_length: int,\n+        target_length: int,\n+        dtype: torch.dtype,\n+        cache_position: torch.Tensor,\n+        batch_size: int,\n+        **kwargs,\n+    ):\n+        \"\"\"\n+        Creates a causal 4D mask of shape `(batch_size, 1, query_length, key_value_length)` from a 2D mask of shape\n+        `(batch_size, key_value_length)`, or if the input `attention_mask` is already 4D, do nothing.\n+\n+        Args:\n+            attention_mask (`torch.Tensor`):\n+                A 2D attention mask of shape `(batch_size, key_value_length)` or a 4D attention mask of shape\n+                `(batch_size, 1, query_length, key_value_length)`.\n+            sequence_length (`int`):\n+                The sequence length being processed.\n+            target_length (`int`):\n+                The target length: when generating with static cache, the mask should be as long as the static cache,\n+                to account for the 0 padding, the part of the cache that is not filled yet.\n+            dtype (`torch.dtype`):\n+                The dtype to use for the 4D attention mask.\n+            cache_position (`torch.Tensor`):\n+                Indices depicting the position of the input sequence tokens in the sequence.\n+            batch_size (`torch.Tensor`):\n+                Batch size.\n+        \"\"\"\n+        if attention_mask is not None and attention_mask.dim() == 4:\n+            # In this case we assume that the mask comes already in inverted form and requires no inversion or slicing.\n+            causal_mask = attention_mask\n+        else:\n+            min_dtype = torch.finfo(dtype).min\n+            causal_mask = torch.full(\n+                (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=cache_position.device\n+            )\n+            if sequence_length != 1:\n+                causal_mask = torch.triu(causal_mask, diagonal=1)\n+            causal_mask *= torch.arange(target_length, device=cache_position.device) > cache_position.reshape(-1, 1)\n+            causal_mask = causal_mask[None, None, :, :].expand(batch_size, 1, -1, -1)\n+            if attention_mask is not None:\n+                causal_mask = causal_mask.clone()  # copy to contiguous memory for in-place edit\n+                mask_length = attention_mask.shape[-1]\n+                padding_mask = causal_mask[:, :, :, :mask_length] + attention_mask[:, None, None, :].to(\n+                    causal_mask.device\n+                )\n+                padding_mask = padding_mask == 0\n+                causal_mask[:, :, :, :mask_length] = causal_mask[:, :, :, :mask_length].masked_fill(\n+                    padding_mask, min_dtype\n+                )\n+\n+        return causal_mask\n+\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        image_embeds: Optional[torch.Tensor] = None,\n+        image_embeds_position_mask: Optional[torch.Tensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> BaseModelOutputWithPastAndCrossAttentions:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\n+                \"You cannot specify both input_ids and inputs_embeds at the same time, and must specify either one\"\n+            )\n+\n+        if self.gradient_checkpointing and self.training and use_cache:\n+            logger.warning_once(\n+                \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`.\"\n+            )\n+            use_cache = False\n+\n+        # The argument `inputs_embeds` should be the one without being multiplied by `self.embed_scale`.\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        # Ignore copy\n+        if image_embeds is not None:\n+            inputs_embeds[image_embeds_position_mask == 1] = image_embeds.to(inputs_embeds.device).view(\n+                -1, image_embeds.size(-1)\n+            )\n+\n+        inputs_embeds = inputs_embeds * self.embed_scale\n+\n+        # embed positions\n+        positions = self.embed_positions(\n+            input_ids=input_ids,\n+            inputs_embeds=inputs_embeds,\n+            past_key_values_length=0,\n+            position_ids=position_ids,\n+        )\n+        positions = positions.to(inputs_embeds.device)\n+\n+        # Ignore copy\n+        if image_embeds_position_mask is not None:\n+            # make every not equal 0 be 1\n+            image_embeds_position_mask = image_embeds_position_mask.ne(0).long()\n+            segment_embeds = self.segment_emb(image_embeds_position_mask).to(positions.device)\n+            positions += segment_embeds\n+        else:\n+            # add zero embedding for padding tokens\n+            bsz, seq_len, dim = positions.size()\n+            zero_emb = self.segment_emb(\n+                torch.zeros((bsz, 1), dtype=torch.long, device=self.segment_emb.weight.device)\n+            ).to(positions.device)\n+            positions += zero_emb\n+\n+        hidden_states = inputs_embeds + positions\n+\n+        hidden_states = nn.functional.dropout(hidden_states, p=self.dropout, training=self.training)\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache()\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        causal_mask = self._update_causal_mask(\n+            attention_mask, inputs_embeds, cache_position, past_key_values, output_attentions\n+        )\n+\n+        hidden_states = nn.functional.dropout(hidden_states, p=self.dropout, training=self.training)\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+\n+        for decoder_layer in self.layers:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            layer_outputs = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask,\n+                past_key_value=past_key_values,\n+                output_attentions=output_attentions,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+            hidden_states = layer_outputs[0]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+        # add final layer norm\n+        hidden_states = self.layer_norm(hidden_states)\n+\n+        # add hidden states from the last decoder layer\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        output = BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values if use_cache else None,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+        )\n+        return output\n+\n+\n+class Kosmos2_5ImageToTextProjection(nn.Module):\n+    \"\"\"The layer that transforms the image model's output to part of the text model's input (namely, image features)\"\"\"\n+\n+    def __init__(self, config: Kosmos2_5Config):\n+        super().__init__()\n+        self.dense = nn.Linear(config.vision_config.hidden_size, config.text_config.embed_dim)\n+        self.latent_query = nn.Parameter(torch.randn(config.latent_query_num, config.text_config.embed_dim))\n+\n+        # Ignore copy\n+        self.x_attn = Kosmos2_5TextAttention(\n+            config.text_config,\n+            config.text_config.embed_dim,\n+            config.text_config.attention_heads,\n+            dropout=config.text_config.attention_dropout,\n+            is_decoder=False,\n+            is_causal=False,\n+        )\n+\n+    def forward(self, features):\n+        hidden_states = self.dense(features)\n+\n+        # shape = [batch, latent_query_num, h_dim]\n+        latent_query = self.latent_query.unsqueeze(0).expand(hidden_states.size(0), -1, -1)\n+        key_value_states = torch.cat([hidden_states, latent_query], dim=1)\n+\n+        hidden_states, attn_weights = self.x_attn(\n+            hidden_states=latent_query,\n+            encoder_hidden_states=key_value_states,\n+            past_key_value=None,\n+            attention_mask=None,\n+            output_attentions=None,\n+            is_causal=False,\n+        )\n+\n+        return hidden_states, attn_weights\n+\n+\n+class Kosmos2_5PreTrainedModel(PreTrainedModel):\n+    \"\"\"\n+    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n+    models.\n+    \"\"\"\n+\n+    config_class = Kosmos2_5Config\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"Kosmos2_5VisionLayer\", \"Kosmos2_5TextBlock\"]\n+    _supports_flash_attn_2 = True\n+    _supports_cache_class = True\n+    _supports_sdpa = True\n+    _supports_attention_backend = True\n+\n+    def _init_weights(self, module):\n+        \"\"\"Initialize the weights\"\"\"\n+        if isinstance(self, Kosmos2_5VisionModel):\n+            init_factor = self.config.initializer_factor\n+            std = self.config.initializer_range * init_factor\n+        elif isinstance(self, (Kosmos2_5TextModel, Kosmos2_5TextForCausalLM)):\n+            std = self.config.init_std\n+        elif isinstance(self, (Kosmos2_5Model, Kosmos2_5ForConditionalGeneration)):\n+            std = self.config.text_config.init_std\n+        if isinstance(module, nn.Linear):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+        elif isinstance(module, (nn.LayerNorm, Kosmos2_5LayerNorm)):\n+            module.weight.data.fill_(1.0)\n+            if getattr(module, \"bias\", None) is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, Kosmos2_5ImageToTextProjection):\n+            module.latent_query.data.normal_(mean=0.0, std=1.0)\n+\n+\n+class Kosmos2_5VisionModel(Kosmos2_5PreTrainedModel):\n+    config_class = Kosmos2_5VisionConfig\n+\n+    # Copied from transformers.models.pix2struct.modeling_pix2struct.Pix2StructVisionModel.__init__ with Pix2Struct->Kosmos2_5\n+    def __init__(self, config: Kosmos2_5VisionConfig):\n+        super().__init__(config)\n+        self.config = config\n+\n+        self.embeddings = Kosmos2_5VisionEmbeddings(config)\n+        self.encoder = Kosmos2_5VisionEncoder(config)\n+\n+        self.layernorm = Kosmos2_5LayerNorm(config.hidden_size, eps=config.layer_norm_eps)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    # Copied from transformers.models.pix2struct.modeling_pix2struct.Pix2StructVisionModel.get_input_embeddings\n+    def get_input_embeddings(self):\n+        return self.embeddings.patch_projection\n+\n+    # Copied from transformers.models.pix2struct.modeling_pix2struct.Pix2StructVisionModel._prune_heads\n+    def _prune_heads(self, heads_to_prune: dict[int, list[int]]) -> None:\n+        \"\"\"\n+        Prunes heads of the model. heads_to_prune: dict of {layer_num: list of heads to prune in this layer} See base\n+        class PreTrainedModel\n+        \"\"\"\n+        for layer, heads in heads_to_prune.items():\n+            self.encoder.layer[layer].attention.prune_heads(heads)\n+\n+    # Similar to transformers.models.pix2struct.modeling_pix2struct.Pix2StructVisionModel.forward without docstring\n+    def forward(\n+        self,\n+        flattened_patches: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> BaseModelOutputWithPooling:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+\n+        if flattened_patches is None:\n+            raise ValueError(\"You have to specify flattened_patches\")\n+\n+        if attention_mask is None:\n+            # check where `flattened_patches` is not 0\n+            attention_mask = (flattened_patches.sum(dim=-1) != 0).float()\n+\n+        embedding_output = self.embeddings(flattened_patches)\n+\n+        encoder_outputs = self.encoder(\n+            embedding_output,\n+            attention_mask=attention_mask,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            **kwargs,\n+        )\n+        sequence_output = encoder_outputs.last_hidden_state\n+        sequence_output = self.layernorm(sequence_output)\n+\n+        return BaseModelOutput(\n+            last_hidden_state=sequence_output,\n+            hidden_states=encoder_outputs.hidden_states,\n+            attentions=encoder_outputs.attentions,\n+        )\n+\n+\n+# Adapted from transformers.models.kosmos2.modeling_kosmos2.Kosmos2TextModel with KOSMOS2->KOSMOS2_5\n+class Kosmos2_5TextModel(Kosmos2_5PreTrainedModel):\n+    config_class = Kosmos2_5TextConfig\n+\n+    def __init__(self, config: Kosmos2_5TextConfig):\n+        super().__init__(config)\n+        self.model = Kosmos2_5TextTransformer(config)\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self) -> nn.Module:\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    @add_start_docstrings_to_model_forward(KOSMOS2_5_TEXT_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=BaseModelOutputWithPastAndCrossAttentions, config_class=Kosmos2_5TextConfig)\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        image_embeds: Optional[torch.Tensor] = None,\n+        image_embeds_position_mask: Optional[torch.Tensor] = None,\n+        past_key_values: Optional[Union[Cache, list[torch.FloatTensor]]] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> BaseModelOutputWithPastAndCrossAttentions:\n+        r\"\"\"\n+        Returns:\n+\n+        \"\"\"\n+        return self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            image_embeds=image_embeds,\n+            image_embeds_position_mask=image_embeds_position_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            position_ids=position_ids,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+\n+@add_start_docstrings(\n+    \"\"\"\n+    KOSMOS-2.5 Model for generating text and image features. The model consists of a vision encoder and a language model.\n+    \"\"\",\n+    KOSMOS2_5_START_DOCSTRING,\n+)\n+class Kosmos2_5Model(Kosmos2_5PreTrainedModel):\n+    config_class = Kosmos2_5Config\n+\n+    def __init__(self, config: Kosmos2_5Config):\n+        super().__init__(config)\n+\n+        self.text_model = Kosmos2_5TextModel._from_config(config.text_config)\n+        self.vision_model = Kosmos2_5VisionModel._from_config(config.vision_config)\n+        self.image_to_text_projection = Kosmos2_5ImageToTextProjection(config)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self) -> nn.Module:\n+        return self.text_model.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.text_model.model.embed_tokens = value\n+\n+    @can_return_tuple\n+    @add_start_docstrings_to_model_forward(KOSMOS2_5_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=Kosmos2_5ModelOutput, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.Tensor] = None,\n+        flattened_patches: Optional[torch.Tensor] = None,\n+        width: Optional[torch.Tensor] = None,\n+        height: Optional[torch.Tensor] = None,\n+        image_embeds_position_mask: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        past_key_values: Optional[Union[Cache, list[torch.FloatTensor]]] = None,\n+        image_embeds: Optional[torch.Tensor] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Kosmos2_5ModelOutput:\n+        r\"\"\"\n+        Returns:\n+\n+        Examples:\n+\n+        ```python\n+        >>> from PIL import Image\n+        >>> import requests\n+        >>> from transformers import AutoProcessor, Kosmos2_5Model\n+\n+        >>> model = Kosmos2_5Model.from_pretrained(\"microsoft/kosmos2.5\")\n+        >>> processor = AutoProcessor.from_pretrained(\"microsoft/kosmos2.5\")\n+\n+        >>> url = \"https://huggingface.co/microsoft/kosmos2.5/resolve/main/snowman.jpg\"\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> text = (\n+        ...     \"<grounding> An image of<phrase> a snowman</phrase><object><patch_index_0044><patch_index_0863>\"\n+        ...     \"</object> warming himself by<phrase> a fire</phrase><object><patch_index_0005><patch_index_0911>\"\n+        ...     \"</object>\"\n+        ... )\n+\n+        >>> inputs = processor(text=text, images=image, return_tensors=\"pt\", add_eos_token=True)\n+\n+        >>> last_hidden_state = model(\n+        ...     pixel_values=inputs[\"pixel_values\"],\n+        ...     input_ids=inputs[\"input_ids\"],\n+        ...     attention_mask=inputs[\"attention_mask\"],\n+        ...     image_embeds_position_mask=inputs[\"image_embeds_position_mask\"],\n+        ... ).last_hidden_state\n+        >>> list(last_hidden_state.shape)\n+        [1, 91, 2048]\n+        ```\"\"\"\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+\n+        vision_model_output = None\n+        projection_attentions = None\n+        if image_embeds is None:\n+            if flattened_patches is not None:\n+                vision_model_output = self.vision_model(\n+                    flattened_patches=flattened_patches,\n+                    output_attentions=output_attentions,\n+                    output_hidden_states=output_hidden_states,\n+                    **kwargs,\n+                )\n+                # normalized features\n+                image_embeds = nn.functional.normalize(vision_model_output.last_hidden_state, dim=-1)\n+                image_embeds, projection_attentions = self.image_to_text_projection(image_embeds)\n+\n+        outputs = self.text_model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            image_embeds=image_embeds,\n+            image_embeds_position_mask=image_embeds_position_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            position_ids=position_ids,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        return Kosmos2_5ModelOutput(\n+            last_hidden_state=outputs.last_hidden_state,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            width=width,\n+            height=height,\n+            image_embeds=image_embeds,\n+            projection_attentions=projection_attentions,\n+            vision_model_output=vision_model_output,\n+        )\n+\n+\n+@add_start_docstrings(\n+    \"\"\"\n+    The text model from KOSMOS-2.5 with a language modeling head on top (linear layer with weights tied to the input\n+    embeddings).\n+    \"\"\",\n+    KOSMOS2_5_START_DOCSTRING,\n+)\n+class Kosmos2_5TextForCausalLM(Kosmos2_5PreTrainedModel):\n+    config_class = Kosmos2_5TextConfig\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+\n+    def __init__(self, config: Kosmos2_5TextConfig):\n+        super().__init__(config)\n+\n+        self.model = Kosmos2_5TextTransformer(config)\n+        self.lm_head = nn.Linear(in_features=config.embed_dim, out_features=config.vocab_size, bias=False)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self) -> nn.Module:\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    def get_output_embeddings(self) -> nn.Module:\n+        return self.lm_head\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.lm_head = new_embeddings\n+\n+    @add_start_docstrings_to_model_forward(KOSMOS2_5_TEXT_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=CausalLMOutputWithCrossAttentions, config_class=Kosmos2_5TextConfig)\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        image_embeds: Optional[torch.Tensor] = None,\n+        image_embeds_position_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        past_key_values: Optional[Union[Cache, list[torch.FloatTensor]]] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> CausalLMOutputWithCrossAttentions:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the left-to-right language modeling loss (next word prediction). Indices should be in\n+            `[-100, 0, ..., config.vocab_size]` (see `input_ids` docstring) Tokens with indices set to `-100` are\n+            ignored (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`\n+\n+        Returns:\n+\n+        \"\"\"\n+        if labels is not None:\n+            if use_cache:\n+                logger.warning(\"The `use_cache` argument is changed to `False` since `labels` is provided.\")\n+            use_cache = False\n+\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            image_embeds=image_embeds,\n+            image_embeds_position_mask=image_embeds_position_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            position_ids=position_ids,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            **kwargs,\n+        )\n+        lm_logits = self.lm_head(outputs.last_hidden_state)\n+\n+        lm_loss = None\n+        if labels is not None:\n+            # move labels to correct device to enable model parallelism\n+            labels = labels.to(lm_logits.device)\n+            lm_loss = self.loss_function(\n+                lm_logits,\n+                labels,\n+                vocab_size=self.config.vocab_size,\n+                **kwargs,\n+            )\n+\n+        return CausalLMOutputWithCrossAttentions(\n+            loss=lm_loss,\n+            logits=lm_logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        image_embeds=None,\n+        image_embeds_position_mask=None,\n+        past_key_values=None,\n+        attention_mask=None,\n+        use_cache=None,\n+        cache_position=None,\n+        position_ids=None,\n+        **model_kwargs,\n+    ):\n+        input_shape = input_ids.shape\n+        # if model is used as a decoder in encoder-decoder model, the decoder attention mask is created on the fly\n+        if attention_mask is None:\n+            attention_mask = input_ids.new_ones(input_shape)\n+\n+        position_ids = None\n+\n+        # cut input_ids if past_key_values is used\n+        if past_key_values is not None:\n+            position_ids = create_position_ids_from_input_ids(\n+                input_ids,\n+                padding_idx=self.config.pad_token_id,\n+                past_key_values_length=0,\n+            )[:, -cache_position.shape[0] :]\n+\n+            input_ids = input_ids[:, -cache_position.shape[0] :]\n+            # the image info. is already encoded into the past keys/values\n+            if past_key_values.get_seq_length() > 0:\n+                image_embeds = None\n+                image_embeds_position_mask = None\n+        elif image_embeds_position_mask is not None:\n+            # appending `False` to `image_embeds_position_mask` (because `input_ids` grows during generation)\n+            batch_size, seq_len = input_ids.size()\n+            mask_len = image_embeds_position_mask.size()[-1]\n+            image_embeds_position_mask = torch.cat(\n+                (\n+                    image_embeds_position_mask,\n+                    torch.zeros(size=(batch_size, seq_len - mask_len), dtype=torch.bool, device=input_ids.device),\n+                ),\n+                dim=1,\n+            )\n+\n+        return {\n+            \"input_ids\": input_ids,\n+            \"image_embeds\": image_embeds,\n+            \"image_embeds_position_mask\": image_embeds_position_mask,\n+            \"past_key_values\": past_key_values,\n+            \"attention_mask\": attention_mask,\n+            \"position_ids\": position_ids,\n+            \"use_cache\": use_cache,\n+        }\n+\n+\n+@add_start_docstrings(\n+    \"\"\"\n+    KOSMOS-2.5 Model for generating text and bounding boxes given an image. The model consists of a vision encoder and a\n+    language model.\n+    \"\"\",\n+    KOSMOS2_5_START_DOCSTRING,\n+)\n+class Kosmos2_5ForConditionalGeneration(Kosmos2_5PreTrainedModel, GenerationMixin):\n+    config_class = Kosmos2_5Config\n+    _tied_weights_keys = [\"text_model.lm_head.weight\"]\n+\n+    def __init__(self, config: Kosmos2_5Config):\n+        super().__init__(config)\n+        self.text_model = Kosmos2_5TextForCausalLM(config.text_config)\n+        self.vision_model = Kosmos2_5VisionModel(config.vision_config)\n+        self.image_to_text_projection = Kosmos2_5ImageToTextProjection(config)\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self) -> nn.Module:\n+        return self.text_model.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.text_model.model.embed_tokens = value\n+\n+    def get_output_embeddings(self) -> nn.Module:\n+        return self.text_model.get_output_embeddings()\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.text_model.set_output_embeddings(new_embeddings)\n+\n+    @can_return_tuple\n+    @add_start_docstrings_to_model_forward(KOSMOS2_5_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(\n+        output_type=Kosmos2_5ForConditionalGenerationModelOutput,\n+        config_class=_CONFIG_FOR_DOC,\n+    )\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.Tensor] = None,\n+        flattened_patches: Optional[torch.Tensor] = None,\n+        width: Optional[torch.Tensor] = None,\n+        height: Optional[torch.Tensor] = None,\n+        image_embeds_position_mask: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        past_key_values: Optional[Union[Cache, list[torch.FloatTensor]]] = None,\n+        image_embeds: Optional[torch.Tensor] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Kosmos2_5ForConditionalGenerationModelOutput:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the left-to-right language modeling loss (next word prediction). Indices should be in\n+            `[-100, 0, ..., config.vocab_size]` (see `input_ids` docstring) Tokens with indices set to `-100` are\n+            ignored (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`\n+\n+        Returns:\n+\n+        Examples:\n+\n+        ```python\n+        >>> from PIL import Image\n+        >>> import requests\n+        >>> import torch\n+        >>> from transformers import AutoProcessor, Kosmos2_5ForConditionalGeneration\n+\n+        >>> repo = \"ydshieh/kosmos-2.5\"\n+        >>> device = \"cuda:0\"\n+        >>> dtype = torch.bfloat16 # torch.float16\n+        >>> model = Kosmos2_5ForConditionalGeneration.from_pretrained(repo, device_map=device, torch_dtype=dtype)\n+        >>> processor = AutoProcessor.from_pretrained(repo)\n+\n+        >>> url = \"https://huggingface.co/ydshieh/kosmos-2.5/resolve/main/receipt_00008.png\"\n+\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> prompt = \"<ocr>\" # <md>\n+\n+        >>> inputs = processor(text=prompt, images=image, return_tensors=\"pt\")\n+        >>> height, width = inputs.pop(\"height\"), inputs.pop(\"width\")\n+        >>> inputs = {k: v.to(device) if v is not None else None for k, v in inputs.items()}\n+        >>> inputs[\"flattened_patches\"] = inputs[\"flattened_patches\"].to(dtype)\n+\n+        >>> generated_ids = model.generate(**inputs,max_new_tokens=1024)\n+        >>> generated_text = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]\n+        >>> generated_text\n+        '<ocr><bbox><x_53><y_573><x_69><y_606></bbox>1\\n<bbox><x_79><y_573><x_464><y_612></bbox>[REG] BLACK SAKURA\\n<bbox><x_690><y_569><x_810><y_606></bbox>45,455\\n<bbox><x_53><y_614><x_69><y_648></bbox>1\\n<bbox><x_79><y_614><x_468><y_650></bbox>COOKIE DOH SAUCES\\n<bbox><x_788><y_609><x_812><y_644></bbox>0\\n<bbox><x_50><y_658><x_69><y_693></bbox>1\\n<bbox><x_79><y_658><x_358><y_693></bbox>NATA DE COCO\\n<bbox><x_790><y_652><x_814><y_687></bbox>0\\n<bbox><x_31><y_742><x_820><y_781></bbox>Sub Total 45,455\\n<bbox><x_27><y_781><x_822><y_827></bbox>PB1 (10%) 4,545\\n<bbox><x_27><y_826><x_824><y_872></bbox>Rounding 0\\n<bbox><x_24><y_872><x_827><y_921></bbox>Total 50,000\\n<bbox><x_17><y_1056><x_836><y_1108></bbox>Card Payment 50,000\\n'\n+        ```\"\"\"\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+\n+        vision_model_output = None\n+        projection_attentions = None\n+\n+        if image_embeds is None:\n+            if flattened_patches is not None:\n+                vision_model_output = self.vision_model(\n+                    flattened_patches=flattened_patches,\n+                    output_attentions=output_attentions,\n+                    output_hidden_states=output_hidden_states,\n+                    **kwargs,\n+                )\n+                image_embeds = nn.functional.normalize(vision_model_output.last_hidden_state, dim=-1)\n+                image_embeds, projection_attentions = self.image_to_text_projection(image_embeds)\n+\n+        lm_outputs = self.text_model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            image_embeds=image_embeds,\n+            image_embeds_position_mask=image_embeds_position_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            position_ids=position_ids,\n+            labels=labels,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            **kwargs,\n+        )\n+\n+        return Kosmos2_5ForConditionalGenerationModelOutput(\n+            loss=lm_outputs.loss,\n+            logits=lm_outputs.logits,\n+            past_key_values=lm_outputs.past_key_values,\n+            hidden_states=lm_outputs.hidden_states,\n+            attentions=lm_outputs.attentions,\n+            width=width,\n+            height=height,\n+            image_embeds=image_embeds,\n+            projection_attentions=projection_attentions,\n+            vision_model_output=vision_model_output,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        flattened_patches=None,\n+        image_embeds=None,\n+        image_embeds_position_mask=None,\n+        past_key_values=None,\n+        attention_mask=None,\n+        use_cache=None,\n+        cache_position=None,\n+        position_ids=None,\n+        **model_kwargs,\n+    ):\n+        # Overwritten -- in specific circumstances we don't want to forward image inputs to the model\n+\n+        model_inputs = self.text_model.prepare_inputs_for_generation(\n+            input_ids,\n+            image_embeds=image_embeds,\n+            image_embeds_position_mask=image_embeds_position_mask,\n+            past_key_values=past_key_values,\n+            attention_mask=attention_mask,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            position_ids=position_ids,\n+            **model_kwargs,\n+        )\n+\n+        if cache_position[0] == 0:\n+            # If we're in cached decoding stage, `flattened_patches` should be `None` because `input_ids` do not contain special image token anymore\n+            # Otherwise we need `flattened_patches` to be passed to model\n+            model_inputs[\"flattened_patches\"] = flattened_patches\n+\n+        return model_inputs\n+\n+\n+__all__ = [\n+    \"Kosmos2_5ForConditionalGeneration\",\n+    \"Kosmos2_5Model\",\n+    \"Kosmos2_5PreTrainedModel\",\n+]"
        },
        {
            "sha": "5e780ca2db9aeea301c164c47f3308100dd5a1fb",
            "filename": "src/transformers/models/kosmos2_5/processing_kosmos2_5.py",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fprocessing_kosmos2_5.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fprocessing_kosmos2_5.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fkosmos2_5%2Fprocessing_kosmos2_5.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -0,0 +1,164 @@\n+# coding=utf-8\n+# Copyright 2024 Microsoft Research and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"\n+Processor class for Kosmos2_5.\n+\"\"\"\n+\n+from typing import Optional, Union\n+\n+from ...image_processing_utils import BatchFeature\n+from ...image_utils import ImageInput\n+from ...processing_utils import ImagesKwargs, ProcessingKwargs, ProcessorMixin, TextKwargs, Unpack\n+from ...tokenization_utils_base import TextInput\n+from ...utils import is_torch_available\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+class Kosmos2_5ImagesKwargs(ImagesKwargs, total=False):\n+    max_patches: Optional[int]\n+    num_image_tokens: Optional[int]\n+\n+\n+class Kosmos2_5ProcessorKwargs(ProcessingKwargs, total=False):\n+    text_kwargs: TextKwargs\n+    images_kwargs: Kosmos2_5ImagesKwargs\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": True,\n+            \"return_token_type_ids\": False,\n+            \"stride\": 0,\n+            \"truncation\": True,\n+        },\n+        \"images_kwargs\": {\n+            \"max_patches\": 4096,\n+            \"num_image_tokens\": 2048,\n+        },\n+        \"common_kwargs\": {\"return_tensors\": \"pt\"},\n+    }\n+\n+\n+class Kosmos2_5Processor(ProcessorMixin):\n+    r\"\"\"\n+    Constructs a Kosmos2_5 processor which wraps a PreTrainedTokenizerFast and Kosmos2_5 image processor into a single\n+    processor.\n+\n+    [`Kosmos2_5Processor`] offers all the functionalities of [`Kosmos2_5ImageProcessor`] and [`PreTrainedTokenizerFast`]. See\n+    the docstring of [`~Kosmos2_5Processor.__call__`] and [`~Kosmos2_5Processor.decode`] for more information.\n+\n+    Args:\n+        image_processor (`Kosmos2_5ImageProcessor`):\n+            An instance of [`Kosmos2_5ImageProcessor`]. The image processor is a required input.\n+        tokenizer (Union[`T5TokenizerFast`, `T5Tokenizer`]):\n+            An instance of ['T5TokenizerFast`] or ['T5Tokenizer`]. The tokenizer is a required input.\n+    \"\"\"\n+\n+    attributes = [\"image_processor\", \"tokenizer\"]\n+    image_processor_class = \"AutoImageProcessor\"\n+    tokenizer_class = \"PreTrainedTokenizerFast\"\n+\n+    def __init__(self, image_processor, tokenizer):\n+        self.image_start_token = tokenizer.boi_token  # \"<image>\" : fixed token for the start of image\n+        self.image_end_token = tokenizer.eoi_token  # \"</image>\" : fixed token for the end of image\n+        self.image_token = tokenizer.image_token  # \"<s>\" : within a <image> ... </image> pair, these <s> tokens indicate they are positions reserved for an image\n+        super().__init__(image_processor, tokenizer)\n+\n+    def __call__(\n+        self,\n+        images: ImageInput = None,\n+        text: Union[TextInput, list[TextInput]] = None,\n+        audio=None,\n+        videos=None,\n+        **kwargs: Unpack[Kosmos2_5ProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        This method uses [`Kosmos2_5ImageProcessor.preprocess`] method to prepare image(s) for the model, and\n+        [`PreTrainedTokenizerFast.__call__`] to prepare text for the model.\n+\n+        Please refer to the docstring of the above two methods for more information.\n+\n+        The rest of this documentation shows the arguments specific to `Kosmos2_5Processor`.\n+        \"\"\"\n+        if images is None and text is None:\n+            raise ValueError(\"You have to specify either images or text.\")\n+\n+        if images is None:\n+            raise ValueError(\"Kosmos2_5Processor requires images to be passed.\")\n+\n+        output_kwargs = self._merge_kwargs(\n+            Kosmos2_5ProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+        num_image_tokens = output_kwargs[\"images_kwargs\"].setdefault(\"num_image_tokens\", None)\n+\n+        encoding = BatchFeature()\n+\n+        if images is not None:\n+            image_encoding = self.image_processor(images, **output_kwargs[\"images_kwargs\"])\n+            image_encoding.pop(\"rows\")\n+            image_encoding.pop(\"cols\")\n+            encoding.update(image_encoding)\n+\n+        prompt = f\"{self.tokenizer.bos_token}{self.image_start_token}{self.image_token * num_image_tokens}{self.image_end_token}\"\n+\n+        if text is not None:\n+            if isinstance(text, str):\n+                text = [prompt + text]\n+            else:\n+                text = [prompt + t for t in text]\n+            input = self.tokenizer(text, **output_kwargs[\"text_kwargs\"])\n+\n+            batch_size, seq_len = input.input_ids.shape\n+            image_embeds_position_mask = [0, -1] + [1] * num_image_tokens + [-1]\n+            image_embeds_position_mask += [0] * (seq_len - len(image_embeds_position_mask))\n+            image_embeds_position_mask = (\n+                torch.LongTensor(image_embeds_position_mask).unsqueeze(0).repeat(batch_size, 1)\n+            )\n+\n+            encoding.update(\n+                {\n+                    \"input_ids\": input.input_ids,\n+                    \"attention_mask\": input.attention_mask,\n+                    \"image_embeds_position_mask\": image_embeds_position_mask,\n+                }\n+            )\n+\n+        return encoding\n+\n+    def batch_decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to Kosmos2_5TokenizerFast's [`~PreTrainedTokenizer.batch_decode`].\n+        Please refer to the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.batch_decode(*args, **kwargs)\n+\n+    def decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to Kosmos2_5TokenizerFast's [`~PreTrainedTokenizer.decode`]. Please\n+        refer to the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.decode(*args, **kwargs)\n+\n+    @property\n+    def model_input_names(self):\n+        tokenizer_input_names = self.tokenizer.model_input_names\n+        image_processor_input_names = self.image_processor.model_input_names\n+        return list(dict.fromkeys(tokenizer_input_names + image_processor_input_names))\n+\n+\n+__all__ = [\"Kosmos2_5Processor\"]"
        },
        {
            "sha": "d9002cae4b38c3a214011a7971c4c01ab3fedf4e",
            "filename": "src/transformers/models/pix2struct/image_processing_pix2struct.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fpix2struct%2Fimage_processing_pix2struct.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fpix2struct%2Fimage_processing_pix2struct.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fpix2struct%2Fimage_processing_pix2struct.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -51,8 +51,8 @@\n # adapted from: https://discuss.pytorch.org/t/tf-image-extract-patches-in-pytorch/171409/2\n def torch_extract_patches(image_tensor, patch_height, patch_width):\n     \"\"\"\n-    Utiliy function to extract patches from a given image tensor. Returns a tensor of shape (1, `patch_height`,\n-    `patch_width`, `num_channels`x `patch_height` x `patch_width`)\n+    Utiliy function to extract patches from a given image tensor. Returns a tensor of shape\n+    (1, `rows`, `columns`, `num_channels`x `patch_height` x `patch_width`).\n \n     Args:\n         image_tensor (torch.Tensor):"
        },
        {
            "sha": "7a497e243f65712eedcb9e25df59c06f8c4d9ef9",
            "filename": "src/transformers/models/pix2struct/modeling_pix2struct.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fpix2struct%2Fmodeling_pix2struct.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Fmodels%2Fpix2struct%2Fmodeling_pix2struct.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fpix2struct%2Fmodeling_pix2struct.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -305,7 +305,7 @@ def forward(\n \n \n class Pix2StructVisionEncoder(nn.Module):\n-    def __init__(self, config: Pix2StructConfig) -> None:\n+    def __init__(self, config: Pix2StructVisionConfig) -> None:\n         super().__init__()\n         self.config = config\n         self.layer = nn.ModuleList([Pix2StructVisionLayer(config) for _ in range(config.num_hidden_layers)])\n@@ -480,7 +480,7 @@ class Pix2StructVisionModel(Pix2StructPreTrainedModel):\n     supports_gradient_checkpointing = True\n     _no_split_modules = [\"Pix2StructVisionLayer\"]\n \n-    def __init__(self, config: Pix2StructConfig):\n+    def __init__(self, config: Pix2StructVisionConfig):\n         super().__init__(config)\n         self.config = config\n "
        },
        {
            "sha": "c259d2035573e00bfcffea755a57e4879da5aee2",
            "filename": "src/transformers/utils/auto_docstring.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Futils%2Fauto_docstring.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/src%2Ftransformers%2Futils%2Fauto_docstring.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fauto_docstring.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -63,6 +63,7 @@\n     \"openai\": \"OpenAIGPTConfig\",\n     \"x-clip\": \"XCLIPConfig\",\n     \"kosmos2\": \"Kosmos2Config\",\n+    \"kosmos2-5\": \"Kosmos2_5Config\",\n     \"donut\": \"DonutSwinConfig\",\n     \"esmfold\": \"EsmConfig\",\n }"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/kosmos2_5/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/tests%2Fmodels%2Fkosmos2_5%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/tests%2Fmodels%2Fkosmos2_5%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fkosmos2_5%2F__init__.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36"
        },
        {
            "sha": "36cfcf979efc5e9e65efcaaf3e730a895b704249",
            "filename": "tests/models/kosmos2_5/test_image_processing_kosmos2_5.py",
            "status": "added",
            "additions": 436,
            "deletions": 0,
            "changes": 436,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/tests%2Fmodels%2Fkosmos2_5%2Ftest_image_processing_kosmos2_5.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/tests%2Fmodels%2Fkosmos2_5%2Ftest_image_processing_kosmos2_5.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fkosmos2_5%2Ftest_image_processing_kosmos2_5.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -0,0 +1,436 @@\n+# coding=utf-8\n+# Copyright 2024 HuggingFace Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+import unittest\n+\n+import numpy as np\n+import pytest\n+import requests\n+from packaging import version\n+\n+from transformers.testing_utils import require_torch, require_torch_accelerator, require_vision, slow, torch_device\n+from transformers.utils import is_torch_available, is_torchvision_available, is_vision_available\n+\n+from ...test_image_processing_common import ImageProcessingTestMixin, prepare_image_inputs\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+    from transformers import Kosmos2_5ImageProcessor\n+\n+    if is_torchvision_available():\n+        from transformers import Kosmos2_5ImageProcessorFast\n+\n+\n+class Kosmos2_5ImageProcessingTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=7,\n+        num_channels=3,\n+        image_size=18,\n+        min_resolution=30,\n+        max_resolution=400,\n+        size=None,\n+        do_normalize=True,\n+        do_convert_rgb=True,\n+        patch_size=None,\n+    ):\n+        size = size if size is not None else {\"height\": 20, \"width\": 20}\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.image_size = image_size\n+        self.min_resolution = min_resolution\n+        self.max_resolution = max_resolution\n+        self.size = size\n+        self.do_normalize = do_normalize\n+        self.do_convert_rgb = do_convert_rgb\n+        self.max_patches = [512, 1024, 2048, 4096]\n+        self.patch_size = patch_size if patch_size is not None else {\"height\": 16, \"width\": 16}\n+\n+    def prepare_image_processor_dict(self):\n+        return {\"do_normalize\": self.do_normalize, \"do_convert_rgb\": self.do_convert_rgb}\n+\n+    def prepare_dummy_image(self):\n+        img_url = \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/tasks/australia.jpg\"\n+        raw_image = Image.open(requests.get(img_url, stream=True).raw).convert(\"RGB\")\n+        return raw_image\n+\n+    def prepare_image_inputs(self, equal_resolution=False, numpify=False, torchify=False):\n+        return prepare_image_inputs(\n+            batch_size=self.batch_size,\n+            num_channels=self.num_channels,\n+            min_resolution=self.min_resolution,\n+            max_resolution=self.max_resolution,\n+            equal_resolution=equal_resolution,\n+            numpify=numpify,\n+            torchify=torchify,\n+        )\n+\n+\n+@require_torch\n+@require_vision\n+class Kosmos2_5ImageProcessingTest(ImageProcessingTestMixin, unittest.TestCase):\n+    image_processing_class = Kosmos2_5ImageProcessor if is_vision_available() else None\n+    fast_image_processing_class = Kosmos2_5ImageProcessorFast if is_torchvision_available() else None\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.image_processor_tester = Kosmos2_5ImageProcessingTester(self)\n+\n+    @property\n+    def image_processor_dict(self):\n+        return self.image_processor_tester.prepare_image_processor_dict()\n+\n+    # Overwrite from the common test to use `flattened_patches` instead of `pixel_values`.\n+    # TODO: enhance the common test to avoid overwriting\n+    @require_vision\n+    @require_torch\n+    def test_slow_fast_equivalence(self):\n+        if not self.test_slow_image_processor or not self.test_fast_image_processor:\n+            self.skipTest(reason=\"Skipping slow/fast equivalence test\")\n+\n+        if self.image_processing_class is None or self.fast_image_processing_class is None:\n+            self.skipTest(reason=\"Skipping slow/fast equivalence test as one of the image processors is not defined\")\n+\n+        dummy_image = Image.open(\n+            requests.get(\"http://images.cocodataset.org/val2017/000000039769.jpg\", stream=True).raw\n+        )\n+        image_processor_slow = self.image_processing_class(**self.image_processor_dict)\n+        image_processor_fast = self.fast_image_processing_class(**self.image_processor_dict)\n+\n+        encoding_slow = image_processor_slow(dummy_image, return_tensors=\"pt\")\n+        encoding_fast = image_processor_fast(dummy_image, return_tensors=\"pt\")\n+        self.assertTrue(torch.allclose(encoding_slow.flattened_patches, encoding_fast.flattened_patches, atol=1e-1))\n+        self.assertLessEqual(\n+            torch.mean(torch.abs(encoding_slow.flattened_patches - encoding_fast.flattened_patches)).item(), 1e-3\n+        )\n+\n+    # Overwrite from the common test to use `flattened_patches` instead of `pixel_values`.\n+    # TODO: enhance the common test to avoid overwriting\n+    @require_vision\n+    @require_torch\n+    def test_slow_fast_equivalence_batched(self):\n+        if not self.test_slow_image_processor or not self.test_fast_image_processor:\n+            self.skipTest(reason=\"Skipping slow/fast equivalence test\")\n+\n+        if self.image_processing_class is None or self.fast_image_processing_class is None:\n+            self.skipTest(reason=\"Skipping slow/fast equivalence test as one of the image processors is not defined\")\n+\n+        if hasattr(self.image_processor_tester, \"do_center_crop\") and self.image_processor_tester.do_center_crop:\n+            self.skipTest(\n+                reason=\"Skipping as do_center_crop is True and center_crop functions are not equivalent for fast and slow processors\"\n+            )\n+\n+        dummy_images = self.image_processor_tester.prepare_image_inputs(equal_resolution=False, torchify=True)\n+        image_processor_slow = self.image_processing_class(**self.image_processor_dict)\n+        image_processor_fast = self.fast_image_processing_class(**self.image_processor_dict)\n+\n+        encoding_slow = image_processor_slow(dummy_images, return_tensors=\"pt\")\n+        encoding_fast = image_processor_fast(dummy_images, return_tensors=\"pt\")\n+\n+        self.assertTrue(torch.allclose(encoding_slow.flattened_patches, encoding_fast.flattened_patches, atol=1e-1))\n+        self.assertLessEqual(\n+            torch.mean(torch.abs(encoding_slow.flattened_patches - encoding_fast.flattened_patches)).item(), 1e-3\n+        )\n+\n+    # Overwrite from the common test to use `flattened_patches` instead of `pixel_values`.\n+    # TODO: enhance the common test to avoid overwriting + fix this compile test.\n+    @unittest.skip(\"Failing with `AttributeError: 'StrictLessThan' object has no attribute 'diff'`.\")\n+    @slow\n+    @require_torch_accelerator\n+    @require_vision\n+    @pytest.mark.torch_compile_test\n+    def test_can_compile_fast_image_processor(self):\n+        if self.fast_image_processing_class is None:\n+            self.skipTest(\"Skipping compilation test as fast image processor is not defined\")\n+        if version.parse(torch.__version__) < version.parse(\"2.3\"):\n+            self.skipTest(reason=\"This test requires torch >= 2.3 to run.\")\n+\n+        torch.compiler.reset()\n+        input_image = torch.randint(0, 255, (3, 224, 224), dtype=torch.uint8)\n+        image_processor = self.fast_image_processing_class(**self.image_processor_dict)\n+        output_eager = image_processor(input_image, device=torch_device, return_tensors=\"pt\")\n+\n+        image_processor = torch.compile(image_processor, mode=\"reduce-overhead\")\n+        output_compiled = image_processor(input_image, device=torch_device, return_tensors=\"pt\")\n+        self._assert_slow_fast_tensors_equivalence(\n+            output_eager.pixel_values, output_compiled.pixel_values, atol=1e-4, rtol=1e-4, mean_atol=1e-5\n+        )\n+\n+    @unittest.skip(\n+        reason=\"Kosmos2_5ImageProcessor already uses many torch operations. Fast image processor only works faster with sufficiently large batch size on GPU.\"\n+    )\n+    def test_fast_is_faster_than_slow(self):\n+        super().test_fast_is_faster_than_slow()\n+\n+    def test_image_processor_properties(self):\n+        image_processor = self.image_processing_class(**self.image_processor_dict)\n+        self.assertTrue(hasattr(image_processor, \"do_normalize\"))\n+        self.assertTrue(hasattr(image_processor, \"do_convert_rgb\"))\n+\n+    def test_expected_patches(self):\n+        dummy_image = self.image_processor_tester.prepare_dummy_image()\n+\n+        image_processor = self.image_processing_class(**self.image_processor_dict)\n+        max_patch = 2048\n+\n+        inputs = image_processor(dummy_image, return_tensors=\"pt\", max_patches=max_patch)\n+        self.assertTrue(torch.allclose(inputs.flattened_patches.mean(), torch.tensor(0.0606), atol=1e-3, rtol=1e-3))\n+\n+    def test_call_pil(self):\n+        # Initialize image_processor\n+        image_processor = self.image_processing_class(**self.image_processor_dict)\n+        # create random PIL images\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False)\n+        for image in image_inputs:\n+            self.assertIsInstance(image, Image.Image)\n+\n+        # Test not batched input\n+        expected_hidden_dim = (\n+            (self.image_processor_tester.patch_size[\"height\"] * self.image_processor_tester.patch_size[\"width\"])\n+            * self.image_processor_tester.num_channels\n+        ) + 2\n+\n+        for max_patch in self.image_processor_tester.max_patches:\n+            # Test not batched input\n+            encoded_images = image_processor(\n+                image_inputs[0], return_tensors=\"pt\", max_patches=max_patch\n+            ).flattened_patches\n+            self.assertEqual(\n+                encoded_images.shape,\n+                (1, max_patch, expected_hidden_dim),\n+            )\n+\n+            # Test batched\n+            encoded_images = image_processor(\n+                image_inputs, return_tensors=\"pt\", max_patches=max_patch\n+            ).flattened_patches\n+            self.assertEqual(\n+                encoded_images.shape,\n+                (self.image_processor_tester.batch_size, max_patch, expected_hidden_dim),\n+            )\n+\n+    def test_call_numpy(self):\n+        # Initialize image_processor\n+        image_processor = self.image_processing_class(**self.image_processor_dict)\n+        # create random numpy tensors\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False, numpify=True)\n+        for image in image_inputs:\n+            self.assertIsInstance(image, np.ndarray)\n+\n+        expected_hidden_dim = (\n+            (self.image_processor_tester.patch_size[\"height\"] * self.image_processor_tester.patch_size[\"width\"])\n+            * self.image_processor_tester.num_channels\n+        ) + 2\n+\n+        for max_patch in self.image_processor_tester.max_patches:\n+            # Test not batched input\n+            encoded_images = image_processor(\n+                image_inputs[0], return_tensors=\"pt\", max_patches=max_patch\n+            ).flattened_patches\n+            self.assertEqual(\n+                encoded_images.shape,\n+                (1, max_patch, expected_hidden_dim),\n+            )\n+\n+            # Test batched\n+            encoded_images = image_processor(\n+                image_inputs, return_tensors=\"pt\", max_patches=max_patch\n+            ).flattened_patches\n+            self.assertEqual(\n+                encoded_images.shape,\n+                (self.image_processor_tester.batch_size, max_patch, expected_hidden_dim),\n+            )\n+\n+    def test_call_numpy_4_channels(self):\n+        # Initialize image_processor\n+        image_processor = self.image_processing_class(**self.image_processor_dict)\n+        # create random numpy tensors\n+        self.image_processor_tester.num_channels = 4\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False, numpify=True)\n+        for image in image_inputs:\n+            self.assertIsInstance(image, np.ndarray)\n+\n+        expected_hidden_dim = (\n+            (self.image_processor_tester.patch_size[\"height\"] * self.image_processor_tester.patch_size[\"width\"])\n+            * self.image_processor_tester.num_channels\n+        ) + 2\n+\n+        for max_patch in self.image_processor_tester.max_patches:\n+            # Test not batched input\n+            encoded_images = image_processor(\n+                image_inputs[0], return_tensors=\"pt\", max_patches=max_patch, input_data_format=\"channels_last\"\n+            ).flattened_patches\n+            self.assertEqual(\n+                encoded_images.shape,\n+                (1, max_patch, expected_hidden_dim),\n+            )\n+\n+            # Test batched\n+            encoded_images = image_processor(\n+                image_inputs, return_tensors=\"pt\", max_patches=max_patch, input_data_format=\"channels_last\"\n+            ).flattened_patches\n+            self.assertEqual(\n+                encoded_images.shape,\n+                (self.image_processor_tester.batch_size, max_patch, expected_hidden_dim),\n+            )\n+        self.image_processor_tester.num_channels = 3\n+\n+    def test_call_pytorch(self):\n+        # Initialize image_processor\n+        image_processor = self.image_processing_class(**self.image_processor_dict)\n+        # create random PyTorch tensors\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False, torchify=True)\n+        for image in image_inputs:\n+            self.assertIsInstance(image, torch.Tensor)\n+\n+        # Test not batched input\n+        expected_hidden_dim = (\n+            (self.image_processor_tester.patch_size[\"height\"] * self.image_processor_tester.patch_size[\"width\"])\n+            * self.image_processor_tester.num_channels\n+        ) + 2\n+\n+        for max_patch in self.image_processor_tester.max_patches:\n+            # Test not batched input\n+            encoded_images = image_processor(\n+                image_inputs[0], return_tensors=\"pt\", max_patches=max_patch\n+            ).flattened_patches\n+            self.assertEqual(\n+                encoded_images.shape,\n+                (1, max_patch, expected_hidden_dim),\n+            )\n+\n+            # Test batched\n+            encoded_images = image_processor(\n+                image_inputs, return_tensors=\"pt\", max_patches=max_patch\n+            ).flattened_patches\n+            self.assertEqual(\n+                encoded_images.shape,\n+                (self.image_processor_tester.batch_size, max_patch, expected_hidden_dim),\n+            )\n+\n+\n+@require_torch\n+@require_vision\n+class Kosmos2_5ImageProcessingTestFourChannels(ImageProcessingTestMixin, unittest.TestCase):\n+    image_processing_class = Kosmos2_5ImageProcessor if is_vision_available() else None\n+    fast_image_processing_class = Kosmos2_5ImageProcessorFast if is_torchvision_available() else None\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.image_processor_tester = Kosmos2_5ImageProcessingTester(self, num_channels=4)\n+        self.expected_encoded_image_num_channels = 3\n+\n+    @property\n+    def image_processor_dict(self):\n+        return self.image_processor_tester.prepare_image_processor_dict()\n+\n+    # Overwrite from the common test to use `flattened_patches` instead of `pixel_values`.\n+    # TODO: enhance the common test to avoid overwriting\n+    @unittest.skip(reason=\"Kosmos2_5ImageProcessor does not support 4 channels yet\")  # FIXME Amy\n+    @require_vision\n+    @require_torch\n+    def test_slow_fast_equivalence(self):\n+        if not self.test_slow_image_processor or not self.test_fast_image_processor:\n+            self.skipTest(reason=\"Skipping slow/fast equivalence test\")\n+\n+        if self.image_processing_class is None or self.fast_image_processing_class is None:\n+            self.skipTest(reason=\"Skipping slow/fast equivalence test as one of the image processors is not defined\")\n+\n+        dummy_image = Image.open(\n+            requests.get(\"http://images.cocodataset.org/val2017/000000039769.jpg\", stream=True).raw\n+        )\n+        image_processor_slow = self.image_processing_class(**self.image_processor_dict)\n+        image_processor_fast = self.fast_image_processing_class(**self.image_processor_dict)\n+\n+        encoding_slow = image_processor_slow(dummy_image, return_tensors=\"pt\")\n+        encoding_fast = image_processor_fast(dummy_image, return_tensors=\"pt\")\n+        self.assertTrue(torch.allclose(encoding_slow.flattened_patches, encoding_fast.flattened_patches, atol=1e-1))\n+        self.assertLessEqual(\n+            torch.mean(torch.abs(encoding_slow.flattened_patches - encoding_fast.flattened_patches)).item(), 1e-3\n+        )\n+\n+    @unittest.skip(reason=\"Kosmos2_5ImageProcessor does not support 4 channels yet\")\n+    def test_slow_fast_equivalence_batched(self):\n+        return super().test_slow_fast_equivalence_batched()\n+\n+    @unittest.skip(reason=\"Kosmos2_5ImageProcessor does not support 4 channels yet\")\n+    def test_can_compile_fast_image_processor(self):\n+        return super().test_can_compile_fast_image_processor()\n+\n+    @unittest.skip(\n+        reason=\"Kosmos2_5ImageProcessor already uses many torch operations. Fast image processor only works faster with sufficiently large batch size on GPU.\"\n+    )\n+    def test_fast_is_faster_than_slow(self):\n+        super().test_fast_is_faster_than_slow()\n+\n+    def test_image_processor_properties(self):\n+        image_processor = self.image_processing_class(**self.image_processor_dict)\n+        self.assertTrue(hasattr(image_processor, \"do_normalize\"))\n+        self.assertTrue(hasattr(image_processor, \"do_convert_rgb\"))\n+\n+    def test_call_pil(self):\n+        # Initialize image_processor\n+        image_processor = self.image_processing_class(**self.image_processor_dict)\n+        # create random PIL images\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False)\n+        for image in image_inputs:\n+            self.assertIsInstance(image, Image.Image)\n+\n+        # Test not batched input\n+        expected_hidden_dim = (\n+            (self.image_processor_tester.patch_size[\"height\"] * self.image_processor_tester.patch_size[\"width\"])\n+            * (self.image_processor_tester.num_channels - 1)\n+        ) + 2\n+\n+        for max_patch in self.image_processor_tester.max_patches:\n+            # Test not batched input\n+            encoded_images = image_processor(\n+                image_inputs[0], return_tensors=\"pt\", max_patches=max_patch\n+            ).flattened_patches\n+            self.assertEqual(\n+                encoded_images.shape,\n+                (1, max_patch, expected_hidden_dim),\n+            )\n+\n+            # Test batched\n+            encoded_images = image_processor(\n+                image_inputs, return_tensors=\"pt\", max_patches=max_patch\n+            ).flattened_patches\n+            self.assertEqual(\n+                encoded_images.shape,\n+                (self.image_processor_tester.batch_size, max_patch, expected_hidden_dim),\n+            )\n+\n+    @unittest.skip(reason=\"Kosmos2_5ImageProcessor does not support 4 channels yet\")  # FIXME Amy\n+    def test_call_numpy(self):\n+        return super().test_call_numpy()\n+\n+    @unittest.skip(reason=\"Kosmos2_5ImageProcessor does not support 4 channels yet\")  # FIXME Amy\n+    def test_call_pytorch(self):\n+        return super().test_call_pytorch()\n+\n+    @unittest.skip(\n+        reason=\"Kosmos2_5ImageProcessor does treat numpy and PIL 4 channel images consistently\"\n+    )  # FIXME Amy\n+    def test_call_numpy_4_channels(self):\n+        return super().test_call_pytorch()"
        },
        {
            "sha": "6d67e8611b0c35edc8dfb6d5eab8308e5bae3496",
            "filename": "tests/models/kosmos2_5/test_modeling_kosmos2_5.py",
            "status": "added",
            "additions": 786,
            "deletions": 0,
            "changes": 786,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/tests%2Fmodels%2Fkosmos2_5%2Ftest_modeling_kosmos2_5.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/tests%2Fmodels%2Fkosmos2_5%2Ftest_modeling_kosmos2_5.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fkosmos2_5%2Ftest_modeling_kosmos2_5.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -0,0 +1,786 @@\n+# coding=utf-8\n+# Copyright 2024 Microsoft Research and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch KOSMOS-2.5 model.\"\"\"\n+\n+import copy\n+import inspect\n+import tempfile\n+import unittest\n+\n+import numpy as np\n+import pytest\n+import requests\n+from parameterized import parameterized\n+\n+from transformers import AutoProcessor, Kosmos2_5Config\n+from transformers.models.kosmos2_5.configuration_kosmos2_5 import (\n+    Kosmos2_5TextConfig,\n+    Kosmos2_5VisionConfig,\n+)\n+from transformers.testing_utils import (\n+    require_flash_attn,\n+    require_torch,\n+    require_torch_gpu,\n+    require_torch_sdpa,\n+    require_vision,\n+    slow,\n+    torch_device,\n+)\n+from transformers.utils import is_torch_available, is_vision_available\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import (\n+    ModelTesterMixin,\n+    _config_zero_init,\n+    floats_tensor,\n+    ids_tensor,\n+    random_attention_mask,\n+)\n+from ...test_pipeline_mixin import PipelineTesterMixin\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import Kosmos2_5ForConditionalGeneration, Kosmos2_5Model\n+\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+class Kosmos2_5VisionModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=6,\n+        image_size=32,\n+        patch_size=4,\n+        num_channels=3,\n+        is_training=True,\n+        hidden_size=32,\n+        intermediate_size=64,\n+        num_hidden_layers=2,\n+        num_attention_heads=4,\n+        dropout=0,\n+        attention_dropout=0,\n+        scope=None,\n+    ):\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.image_size = image_size\n+        self.patch_size = patch_size\n+        self.num_channels = num_channels\n+        self.is_training = is_training\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.patch_embed_hidden_size = patch_size * patch_size * num_channels\n+        self.dropout = dropout\n+        self.attention_dropout = attention_dropout\n+        self.scope = scope\n+\n+        # in ViT, the seq length equals the number of patches + 1 (we add 1 for the [CLS] token)\n+        num_patches = (image_size // patch_size) ** 2\n+        self.seq_length = num_patches + 1\n+\n+    def prepare_config_and_inputs(self):\n+        flattened_patches = floats_tensor([self.batch_size, self.seq_length, self.patch_embed_hidden_size + 2])\n+        config = self.get_config()\n+\n+        return config, flattened_patches\n+\n+    def get_config(self):\n+        return Kosmos2_5VisionConfig(\n+            image_size=self.image_size,\n+            patch_size=self.patch_size,\n+            num_channels=self.num_channels,\n+            hidden_size=self.hidden_size,\n+            intermediate_size=self.intermediate_size,\n+            num_hidden_layers=self.num_hidden_layers,\n+            num_attention_heads=self.num_attention_heads,\n+            patch_embed_hidden_size=self.patch_embed_hidden_size,\n+            dropout=self.dropout,\n+            attention_dropout=self.attention_dropout,\n+        )\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, flattened_patches = config_and_inputs\n+        inputs_dict = {\"flattened_patches\": flattened_patches}\n+        return config, inputs_dict\n+\n+\n+class Kosmos2_5TextModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=6,\n+        seq_length=7,\n+        is_training=True,\n+        use_input_mask=True,\n+        use_labels=True,\n+        vocab_size=99,\n+        hidden_size=32,\n+        ffn_dim=64,\n+        num_hidden_layers=2,\n+        num_attention_heads=4,\n+        dropout=0,\n+        attention_dropout=0,\n+        max_position_embeddings=512,\n+        scope=None,\n+    ):\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.seq_length = seq_length\n+        self.is_training = is_training\n+        self.use_input_mask = use_input_mask\n+        self.use_labels = use_labels\n+        self.vocab_size = vocab_size\n+        self.hidden_size = hidden_size\n+        self.ffn_dim = ffn_dim\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.dropout = dropout\n+        self.attention_dropout = attention_dropout\n+        self.max_position_embeddings = max_position_embeddings\n+        self.scope = scope\n+\n+    def prepare_config_and_inputs(self):\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], self.vocab_size)\n+\n+        input_mask = None\n+        if self.use_input_mask:\n+            input_mask = random_attention_mask([self.batch_size, self.seq_length])\n+\n+        if input_mask is not None:\n+            batch_size, seq_length = input_mask.shape\n+            rnd_start_indices = np.random.randint(1, seq_length - 1, size=(batch_size,))\n+            for batch_idx, start_index in enumerate(rnd_start_indices):\n+                input_mask[batch_idx, :start_index] = 1\n+                input_mask[batch_idx, start_index:] = 0\n+\n+        config = self.get_config()\n+\n+        return config, input_ids, input_mask\n+\n+    def get_config(self):\n+        return Kosmos2_5TextConfig(\n+            vocab_size=self.vocab_size,\n+            embed_dim=self.hidden_size,\n+            ffn_dim=self.ffn_dim,\n+            layers=self.num_hidden_layers,\n+            attention_heads=self.num_attention_heads,\n+            dropout=self.dropout,\n+            attention_dropout=self.attention_dropout,\n+            max_position_embeddings=self.max_position_embeddings,\n+        )\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, input_ids, input_mask = config_and_inputs\n+        inputs_dict = {\"input_ids\": input_ids, \"attention_mask\": input_mask}\n+        return config, inputs_dict\n+\n+\n+class Kosmos2_5ModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        text_kwargs=None,\n+        vision_kwargs=None,\n+        latent_query_num=3,\n+        is_training=True,\n+    ):\n+        if text_kwargs is None:\n+            text_kwargs = {}\n+        if vision_kwargs is None:\n+            vision_kwargs = {}\n+\n+        self.parent = parent\n+        self.text_model_tester = Kosmos2_5TextModelTester(parent, **text_kwargs)\n+        self.vision_model_tester = Kosmos2_5VisionModelTester(parent, **vision_kwargs)\n+        self.batch_size = self.text_model_tester.batch_size  # need bs for batching_equivalence test\n+        self.seq_length = self.text_model_tester.seq_length\n+        self.latent_query_num = latent_query_num\n+        self.is_training = is_training\n+\n+    def prepare_config_and_inputs(self):\n+        text_config, input_ids, attention_mask = self.text_model_tester.prepare_config_and_inputs()\n+        vision_config, flattened_patches = self.vision_model_tester.prepare_config_and_inputs()\n+\n+        # build `image_embeds_position_mask`\n+        image_embeds_position_mask = torch.zeros_like(input_ids)\n+        image_embeds_position_mask[:, 1 : 1 + self.latent_query_num :] = 1\n+\n+        config = self.get_config()\n+\n+        return (\n+            config,\n+            input_ids,\n+            attention_mask,\n+            image_embeds_position_mask,\n+            flattened_patches,\n+        )\n+\n+    def get_config(self):\n+        return Kosmos2_5Config(\n+            self.text_model_tester.get_config().to_dict(),\n+            self.vision_model_tester.get_config().to_dict(),\n+            latent_query_num=self.latent_query_num,\n+        )\n+\n+    def create_and_check_model(\n+        self,\n+        config,\n+        input_ids,\n+        attention_mask,\n+        image_embeds_position_mask,\n+        flattened_patches,\n+    ):\n+        model = Kosmos2_5Model(config).to(torch_device).eval()\n+        with torch.no_grad():\n+            result = model(input_ids, flattened_patches, image_embeds_position_mask, attention_mask)\n+        self.parent.assertEqual(\n+            result.last_hidden_state.shape,\n+            (\n+                self.text_model_tester.batch_size,\n+                self.text_model_tester.seq_length,\n+                self.text_model_tester.hidden_size,\n+            ),\n+        )\n+        self.parent.assertEqual(\n+            result.image_embeds.shape,\n+            (\n+                self.text_model_tester.batch_size,\n+                self.latent_query_num,\n+                self.text_model_tester.hidden_size,\n+            ),\n+        )\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        (\n+            config,\n+            input_ids,\n+            attention_mask,\n+            image_embeds_position_mask,\n+            flattened_patches,\n+        ) = config_and_inputs\n+        inputs_dict = {\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+            \"image_embeds_position_mask\": image_embeds_position_mask,\n+            \"flattened_patches\": flattened_patches,\n+        }\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class Kosmos2_5ModelTest(ModelTesterMixin, GenerationTesterMixin, PipelineTesterMixin, unittest.TestCase):\n+    all_model_classes = (Kosmos2_5Model, Kosmos2_5ForConditionalGeneration) if is_torch_available() else ()\n+    all_generative_model_classes = (Kosmos2_5ForConditionalGeneration,) if is_torch_available() else ()\n+    pipeline_model_mapping = (\n+        {\n+            \"feature-extraction\": Kosmos2_5Model,\n+            \"image-to-text\": Kosmos2_5ForConditionalGeneration,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+    fx_compatible = False\n+    test_head_masking = False\n+    test_pruning = False\n+    test_resize_embeddings = False\n+    test_attention_outputs = False\n+    _is_composite = True\n+\n+    # TODO: `image-to-text` pipeline for this model needs Processor.\n+    def is_pipeline_test_to_skip(\n+        self,\n+        pipeline_test_casse_name,\n+        config_class,\n+        model_architecture,\n+        tokenizer_name,\n+        processor_name,\n+    ):\n+        return pipeline_test_casse_name == \"ImageToTextPipelineTests\"\n+\n+    def _prepare_for_class(self, inputs_dict, model_class, return_labels=False):\n+        inputs_dict = copy.deepcopy(inputs_dict)\n+\n+        if return_labels:\n+            if model_class.__name__ == \"Kosmos2_5ForConditionalGeneration\":\n+                inputs_dict[\"labels\"] = torch.zeros(\n+                    (\n+                        self.model_tester.text_model_tester.batch_size,\n+                        self.model_tester.text_model_tester.seq_length,\n+                    ),\n+                    dtype=torch.long,\n+                    device=torch_device,\n+                )\n+\n+        if model_class.__name__ in [\n+            \"Kosmos2_5Model\",\n+            \"Kosmos2_5ForConditionalGeneration\",\n+        ]:\n+            bs, _ = inputs_dict[\"input_ids\"].shape\n+            seqlen = self.model_tester.text_model_tester.seq_length\n+            inputs_dict[\"input_ids\"] = torch.arange(seqlen, device=torch_device).unsqueeze(0).expand(bs, seqlen)\n+            inputs_dict[\"input_ids\"] = inputs_dict[\"input_ids\"] % self.model_tester.text_model_tester.vocab_size\n+            inputs_dict[\"attention_mask\"] = torch.ones((bs, seqlen), device=torch_device)\n+            inputs_dict[\"image_embeds_position_mask\"] = torch.zeros((bs, seqlen), device=torch_device)\n+            inputs_dict[\"image_embeds_position_mask\"][:, : self.model_tester.latent_query_num] = 1\n+        return inputs_dict\n+\n+    def setUp(self):\n+        self.model_tester = Kosmos2_5ModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Kosmos2_5Config, hidden_size=37)\n+\n+    @unittest.skip(\"KOSMOS-2.5 doesn't support padding\")\n+    def test_eager_padding_matches_padding_free_with_position_ids(self):\n+        pass\n+\n+    @unittest.skip(\"KOSMOS-2.5 doesn't support padding\")\n+    def test_sdpa_padding_matches_padding_free_with_position_ids(self):\n+        pass\n+\n+    @parameterized.expand([(\"random\",), (\"same\",)])\n+    @pytest.mark.generate\n+    @unittest.skip(\n+        \"Kosmos-2.5 doesn't support assisted generation due to the need to extend `image_embeds_position_mask` length.\"\n+    )\n+    def test_assisted_decoding_matches_greedy_search(self):\n+        pass\n+\n+    @pytest.mark.generate\n+    @unittest.skip(\n+        \"Kosmos-2.5 doesn't support assisted generation due to the need to extend `image_embeds_position_mask` length.\"\n+    )\n+    def test_assisted_decoding_sample(self):\n+        pass\n+\n+    @unittest.skip(\n+        \"Kosmos-2.5 doesn't support assisted generation due to the need to extend `image_embeds_position_mask` length.\"\n+    )\n+    def test_prompt_lookup_decoding_matches_greedy_search(self):\n+        pass\n+\n+    # overwrite from common to skip `image_to_text_projection.latent_query`\n+    def test_initialization(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        configs_no_init = _config_zero_init(config)\n+        for model_class in self.all_model_classes:\n+            model = model_class(config=configs_no_init)\n+            for name, param in model.named_parameters():\n+                if param.requires_grad:\n+                    if name == \"image_to_text_projection.latent_query\":\n+                        # The original code use ` nn.Parameter(torch.randn(...))` for which this test won't pass.\n+                        continue\n+                    self.assertIn(\n+                        ((param.data.mean() * 1e9).round() / 1e9).item(),\n+                        [0.0, 1.0],\n+                        msg=f\"Parameter {name} of model {model_class} seems not properly initialized\",\n+                    )\n+\n+    def test_model(self):\n+        config_and_inputs = self.model_tester.prepare_config_and_inputs()\n+        self.model_tester.create_and_check_model(*config_and_inputs)\n+\n+    def test_forward_signature(self):\n+        config, _ = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            signature = inspect.signature(model.forward)\n+            # signature.parameters is an OrderedDict => so arg_names order is deterministic\n+            arg_names = [*signature.parameters.keys()]\n+\n+            expected_arg_names = [\"input_ids\"]\n+            self.assertListEqual(arg_names[:1], expected_arg_names)\n+\n+    def test_load_save_without_tied_weights(self):\n+        config, _ = self.model_tester.prepare_config_and_inputs_for_common()\n+        config.text_config.tie_word_embeddings = False\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            with tempfile.TemporaryDirectory() as d:\n+                model.save_pretrained(d)\n+\n+                model_reloaded, infos = model_class.from_pretrained(d, output_loading_info=True)\n+                # Checking the state dicts are correct\n+                reloaded_state = model_reloaded.state_dict()\n+                for k, v in model.state_dict().items():\n+                    self.assertIn(k, reloaded_state, f\"Key {k} is missing from reloaded\")\n+                    torch.testing.assert_close(\n+                        v,\n+                        reloaded_state[k],\n+                        msg=lambda x: f\"{model_class.__name__}: Tensor {k}: {x}\",\n+                    )\n+                # Checking there was no complain of missing weights\n+                self.assertEqual(infos[\"missing_keys\"], [])\n+\n+    # overwrite from common in order to use `self.model_tester.text_model_tester.num_hidden_layers`\n+    def test_hidden_states_output(self):\n+        def check_hidden_states_output(inputs_dict, config, model_class):\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            with torch.no_grad():\n+                outputs = model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            hidden_states = outputs.hidden_states\n+\n+            expected_num_layers = getattr(\n+                self.model_tester,\n+                \"expected_num_hidden_layers\",\n+                self.model_tester.text_model_tester.num_hidden_layers + 1,\n+            )\n+            self.assertEqual(len(hidden_states), expected_num_layers)\n+\n+            seq_length = self.model_tester.text_model_tester.seq_length\n+\n+            self.assertListEqual(\n+                list(hidden_states[0].shape[-2:]),\n+                [seq_length, self.model_tester.text_model_tester.hidden_size],\n+            )\n+\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            inputs_dict[\"output_hidden_states\"] = True\n+            check_hidden_states_output(inputs_dict, config, model_class)\n+\n+            # check that output_hidden_states also work using config\n+            del inputs_dict[\"output_hidden_states\"]\n+            config.output_hidden_states = True\n+\n+            check_hidden_states_output(inputs_dict, config, model_class)\n+\n+    # overwrite from common in order to use `config.text_config.vocab_size` instead of `config.vocab_size`\n+    def test_tie_model_weights(self):\n+        if not self.test_torchscript:\n+            self.skipTest(reason=\"test_torchscript is set to False\")\n+\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        def check_same_values(layer_1, layer_2):\n+            equal = True\n+            for p1, p2 in zip(layer_1.weight, layer_2.weight):\n+                if p1.data.ne(p2.data).sum() > 0:\n+                    equal = False\n+            return equal\n+\n+        for model_class in self.all_model_classes:\n+            config.torchscript = True\n+            model_not_tied = model_class(config)\n+            if model_not_tied.get_output_embeddings() is None:\n+                continue\n+\n+            config_tied = copy.deepcopy(config)\n+            config_tied.torchscript = False\n+            model_tied = model_class(config_tied)\n+            params_tied = list(model_tied.parameters())\n+            # Check that the embedding layer and decoding layer are the same in size and in value\n+            # self.assertTrue(check_same_values(embeddings, decoding))\n+\n+            # # Check that after modification, they remain the same.\n+            # embeddings.weight.data.div_(2)\n+            # # Check that the embedding layer and decoding layer are the same in size and in value\n+            # self.assertTrue(embeddings.weight.shape, decoding.weight.shape)\n+            # self.assertTrue(check_same_values(embeddings, decoding))\n+\n+            # # Check that after modification, they remain the same.\n+            # decoding.weight.data.div_(4)\n+            # # Check that the embedding layer and decoding layer are the same in size and in value\n+            # self.assertTrue(embeddings.weight.shape, decoding.weight.shape)\n+            # self.assertTrue(check_same_values(embeddings, decoding))\n+\n+            # Check that after resize they remain tied.\n+            model_tied.resize_token_embeddings(config.text_config.vocab_size + 10)\n+            params_tied_2 = list(model_tied.parameters())\n+            self.assertEqual(len(params_tied_2), len(params_tied))\n+\n+            # decoding.weight.data.mul_(20)\n+            # # Check that the embedding layer and decoding layer are the same in size and in value\n+            # self.assertTrue(model.transformer.wte.weight.shape, model.lm_head.weight.shape)\n+            # self.assertTrue(check_same_values(model.transformer.wte, model.lm_head))\n+\n+    @slow\n+    def test_model_from_pretrained(self):\n+        model_name = \"ydshieh/kosmos-2.5\"\n+        model = Kosmos2_5Model.from_pretrained(model_name)\n+        self.assertIsNotNone(model)\n+\n+    @unittest.skip(reason=\"Does not work on the tiny model as we keep hitting edge cases.\")\n+    def test_model_parallelism(self):\n+        super().test_model_parallelism()\n+\n+    # TODO: ydshieh\n+    @require_torch_gpu\n+    @pytest.mark.flash_attn_test\n+    @slow\n+    @unittest.skip(reason=\"kosmos-2.5 flash attention does not support right padding\")\n+    def test_flash_attn_2_inference_equivalence_right_padding(self):\n+        pass\n+\n+    # TODO: ydshieh\n+    @require_torch_gpu\n+    @pytest.mark.flash_attn_test\n+    @slow\n+    @unittest.skip(reason=\"kosmos-2.5 test : the dummy inputs should be tweaked: dummy_input = inputs_dict\")\n+    def test_flash_attn_2_inference_equivalence(self):\n+        pass\n+\n+    # TODO: ydshieh\n+    @require_torch_sdpa\n+    @require_torch_gpu\n+    @slow\n+    @unittest.skip(reason=\"_update_causal_mask is not implemented yet which fails this test\")\n+    def test_sdpa_can_dispatch_on_flash(self):\n+        pass\n+\n+    # TODO: ydshieh\n+    @unittest.skip(reason=\"doesn't support padding yet\")\n+    def test_eager_matches_sdpa_inference_1_bfloat16(self):\n+        pass\n+\n+    # TODO: ydshieh\n+    @unittest.skip(reason=\" the model hasn't been added to auto class\")\n+    def test_flash_attn_2_from_config(self):\n+        pass\n+\n+    @unittest.skip(\"This test is currently not well designed for multimodal model (float type as an input).\")\n+    def test_flash_attn_2_fp32_ln(self):\n+        pass\n+\n+    @unittest.skip(\"This test is currently not well designed for multimodal model (float type as an input).\")\n+    def test_flash_attention_2_padding_matches_padding_free_with_position_ids(self):\n+        pass\n+\n+    @unittest.skip(\"Kosmos 2.5 is multimodel and has specific input shapes.\")\n+    def test_flash_attn_2_generate_reuse_cache(self):\n+        pass\n+\n+    @pytest.mark.generate\n+    @parameterized.expand([(\"greedy\", 1), (\"beam search\", 2)])\n+    @unittest.skip(\n+        \"KOSMOS-2.5 doesn't support inputs embeds. The test isn't skipped by checking input args because KOSMOS-2 has `generate()` overwritten\",\n+    )\n+    def test_generate_from_inputs_embeds(self):\n+        pass\n+\n+    # TODO: ydshieh\n+    @pytest.mark.generate\n+    @unittest.skip(\n+        \"Kosmos2_5ForConditionalGeneration returns `vision_model_output` which is currently not working with `stack_model_outputs`\",\n+    )\n+    def test_beam_search_low_memory(self):\n+        pass\n+\n+    @pytest.mark.generate\n+    def test_left_padding_compatibility(self):\n+        # Overwrite because Kosmos-2.5 need to padd pixel values and pad image-attn-mask\n+\n+        def _prepare_model_kwargs(input_ids, attention_mask, pad_size, signature):\n+            model_kwargs = {\"input_ids\": input_ids, \"attention_mask\": attention_mask}\n+            if \"position_ids\" in signature:\n+                position_ids = torch.cumsum(attention_mask, dim=-1) - 1\n+                position_ids.masked_fill_(attention_mask == 0, 1)\n+                model_kwargs[\"position_ids\"] = position_ids\n+            if \"cache_position\" in signature:\n+                cache_position = torch.arange(input_ids.shape[-1], device=torch_device)\n+                model_kwargs[\"cache_position\"] = cache_position\n+            if \"image_embeds_position_mask\" in signature:\n+                image_embeds_position_mask = torch.zeros_like(input_ids)\n+                image_embeds_position_mask[:, (pad_size + 1) : pad_size + 1 + self.model_tester.latent_query_num] = 1\n+                model_kwargs[\"image_embeds_position_mask\"] = image_embeds_position_mask\n+            return model_kwargs\n+\n+        for model_class in self.all_generative_model_classes:\n+            config, inputs_dict = self.prepare_config_and_inputs_for_generate()\n+            input_ids = inputs_dict[\"input_ids\"]\n+            flattened_patches = inputs_dict[\"flattened_patches\"]\n+            attention_mask = inputs_dict.get(\"attention_mask\")\n+            if attention_mask is None:\n+                attention_mask = torch.ones_like(input_ids)\n+\n+            model = model_class(config).to(torch_device).eval()\n+            signature = inspect.signature(model.forward).parameters.keys()\n+\n+            # no cache as some models require special cache classes to be init outside forward\n+            model.generation_config.use_cache = False\n+\n+            # Without padding\n+            model_kwargs = _prepare_model_kwargs(input_ids, attention_mask, pad_size=0, signature=signature)\n+            next_logits_wo_padding = model(**model_kwargs, flattened_patches=flattened_patches).logits[:, -1, :]\n+\n+            # With left-padding (length 32)\n+            # can hardcode pad_token to be 0 as we'll do attn masking anyway\n+            pad_token_id = (\n+                config.get_text_config().pad_token_id if config.get_text_config().pad_token_id is not None else 0\n+            )\n+            pad_size = (input_ids.shape[0], 32)\n+            padding = torch.ones(pad_size, dtype=input_ids.dtype, device=torch_device) * pad_token_id\n+            padded_input_ids = torch.cat((padding, input_ids), dim=1)\n+            padded_attention_mask = torch.cat((torch.zeros_like(padding), attention_mask), dim=1)\n+            model_kwargs = _prepare_model_kwargs(\n+                padded_input_ids, padded_attention_mask, pad_size=32, signature=signature\n+            )\n+            next_logits_with_padding = model(**model_kwargs, flattened_patches=flattened_patches).logits[:, -1, :]\n+\n+            # They should result in very similar logits\n+            self.assertTrue(torch.allclose(next_logits_wo_padding, next_logits_with_padding, atol=1e-3))\n+\n+\n+@require_vision\n+@require_torch\n+@slow\n+class Kosmos2_5ModelIntegrationTest(unittest.TestCase):\n+    # This variable is used to determine which CUDA device are we using for our runners (A10 or T4)\n+    # Depending on the hardware we get different logits / generations\n+    cuda_compute_capability_major_version = None\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        if is_torch_available() and torch.cuda.is_available():\n+            # 8 is for A100 / A10 and 7 for T4\n+            cls.cuda_compute_capability_major_version = torch.cuda.get_device_capability()[0]\n+\n+    def run_example(self, prompt, image, model, processor):\n+        inputs = processor(text=prompt, images=image, return_tensors=\"pt\")\n+        inputs = {k: v.to(torch_device) if v is not None else None for k, v in inputs.items()}\n+        inputs[\"flattened_patches\"] = inputs[\"flattened_patches\"].to(model.dtype)\n+\n+        generation_outputs = model.generate(\n+            **inputs,\n+            max_new_tokens=1024,\n+        )\n+        generated_ids = generation_outputs\n+        generated_text = processor.batch_decode(generated_ids, skip_special_tokens=True)\n+\n+        return generated_ids, generated_text\n+\n+    def test_eager(self):\n+        url = \"https://huggingface.co/ydshieh/kosmos-2.5/resolve/main/receipt_00008.png\"\n+        image = Image.open(requests.get(url, stream=True).raw)\n+\n+        dtype = torch.bfloat16\n+        repo = \"ydshieh/kosmos-2.5\"\n+        model = Kosmos2_5ForConditionalGeneration.from_pretrained(\n+            repo, device_map=torch_device, torch_dtype=dtype, attn_implementation=\"eager\"\n+        )\n+        processor = AutoProcessor.from_pretrained(repo)\n+        prompt = \"<ocr>\"\n+        generated_ids, generated_text = self.run_example(prompt, image, model, processor)\n+        EXPECTED_TEXT = {\n+            7: [\n+                \"<bbox><x_53><y_573><x_69><y_606></bbox>1\\n<bbox><x_79><y_573><x_464><y_611></bbox>[REG] BLACK SAKURA\\n<bbox><x_690><y_569><x_810><y_606></bbox>45,455\\n<bbox><x_53><y_614><x_69><y_648></bbox>1\\n<bbox><x_79><y_614><x_468><y_651></bbox>COOKIE DOH SAUCES\\n<bbox><x_788><y_609><x_812><y_642></bbox>0\\n<bbox><x_50><y_658><x_69><y_693></bbox>1\\n<bbox><x_79><y_658><x_358><y_693></bbox>NATA DE COCO\\n<bbox><x_790><y_652><x_814><y_683></bbox>0\\n<bbox><x_31><y_742><x_820><y_781></bbox>Sub Total 45,455\\n<bbox><x_27><y_781><x_822><y_827></bbox>PB1 (10%) 4,545\\n<bbox><x_27><y_826><x_824><y_872></bbox>Rounding 0\\n<bbox><x_24><y_872><x_827><y_921></bbox>Total 50,000\\n<bbox><x_17><y_1056><x_836><y_1108></bbox>Card Payment 50,000\\n\"\n+            ],\n+            8: [\n+                \"<bbox><x_53><y_573><x_69><y_606></bbox>1\\n<bbox><x_79><y_573><x_464><y_611></bbox>[REG] BLACK SAKURA\\n<bbox><x_690><y_569><x_810><y_606></bbox>45,455\\n<bbox><x_53><y_614><x_69><y_648></bbox>1\\n<bbox><x_79><y_614><x_468><y_650></bbox>COOKIE DOH SAUCES\\n<bbox><x_788><y_609><x_812><y_644></bbox>0\\n<bbox><x_50><y_658><x_69><y_693></bbox>1\\n<bbox><x_79><y_658><x_358><y_693></bbox>NATA DE COCO\\n<bbox><x_790><y_652><x_814><y_687></bbox>0\\n<bbox><x_31><y_742><x_820><y_781></bbox>Sub Total 45,455\\n<bbox><x_27><y_781><x_822><y_827></bbox>PB1 (10%) 4,545\\n<bbox><x_27><y_826><x_824><y_872></bbox>Rounding 0\\n<bbox><x_24><y_872><x_827><y_921></bbox>Total 50,000\\n<bbox><x_17><y_1056><x_836><y_1108></bbox>Card Payment 50,000\\n\"\n+            ],\n+        }\n+\n+        self.assertListEqual(generated_text, EXPECTED_TEXT[self.cuda_compute_capability_major_version])\n+\n+        prompt = \"<md>\"\n+        generated_ids, generated_text = self.run_example(prompt, image, model, processor)\n+\n+        EXPECTED_TEXT = {\n+            7: [\n+                \"- **1 \\\\[REG\\\\] BLACK SAKURA** 45,455\\n- **1 COOKIE DOH SAUCES** 0\\n- **1 NATA DE COCO** 0\\n- **Sub Total** 45,455\\n- **PB1 (10%)** 4,545\\n- **Rounding** 0\\n- **Total** **50,000**\\n\\nCard Payment 50,000\"\n+            ],\n+            8: [\n+                \"- **1 \\\\[REG\\\\] BLACK SAKURA** 45,455\\n- **1 COOKIE DOH SAUCES** 0\\n- **1 NATA DE COCO** 0\\n- **Sub Total** 45,455\\n- **PB1 (10%)** 4,545\\n- **Rounding** 0\\n- **Total** **50,000**\\n\\nCard Payment 50,000\"\n+            ],\n+        }\n+\n+        self.assertListEqual(generated_text, EXPECTED_TEXT[self.cuda_compute_capability_major_version])\n+\n+    def test_sdpa(self):\n+        url = \"https://huggingface.co/ydshieh/kosmos-2.5/resolve/main/receipt_00008.png\"\n+        image = Image.open(requests.get(url, stream=True).raw)\n+\n+        dtype = torch.bfloat16\n+        repo = \"ydshieh/kosmos-2.5\"\n+        model = Kosmos2_5ForConditionalGeneration.from_pretrained(\n+            repo, device_map=torch_device, torch_dtype=dtype, attn_implementation=\"sdpa\"\n+        )\n+        processor = AutoProcessor.from_pretrained(repo)\n+        prompt = \"<ocr>\"\n+        generated_ids, generated_text = self.run_example(prompt, image, model, processor)\n+        EXPECTED_TEXT = {\n+            7: [\n+                \"<bbox><x_53><y_573><x_69><y_606></bbox>1\\n<bbox><x_79><y_573><x_464><y_611></bbox>[REG] BLACK SAKURA\\n<bbox><x_690><y_569><x_810><y_606></bbox>45,455\\n<bbox><x_53><y_614><x_69><y_648></bbox>1\\n<bbox><x_79><y_614><x_468><y_651></bbox>COOKIE DOH SAUCES\\n<bbox><x_788><y_609><x_812><y_642></bbox>0\\n<bbox><x_50><y_658><x_69><y_693></bbox>1\\n<bbox><x_79><y_658><x_358><y_693></bbox>NATA DE COCO\\n<bbox><x_790><y_652><x_814><y_683></bbox>0\\n<bbox><x_31><y_742><x_820><y_781></bbox>Sub Total 45,455\\n<bbox><x_27><y_781><x_822><y_827></bbox>PB1 (10%) 4,545\\n<bbox><x_27><y_826><x_824><y_872></bbox>Rounding 0\\n<bbox><x_24><y_872><x_827><y_921></bbox>Total 50,000\\n<bbox><x_17><y_1056><x_836><y_1108></bbox>Card Payment 50,000\\n\",\n+            ],\n+            8: [\n+                \"<bbox><x_53><y_573><x_69><y_606></bbox>1\\n<bbox><x_79><y_573><x_464><y_611></bbox>[REG] BLACK SAKURA\\n<bbox><x_690><y_569><x_810><y_606></bbox>45,455\\n<bbox><x_53><y_614><x_69><y_648></bbox>1\\n<bbox><x_79><y_614><x_468><y_651></bbox>COOKIE DOH SAUCES\\n<bbox><x_788><y_609><x_812><y_642></bbox>0\\n<bbox><x_50><y_658><x_69><y_693></bbox>1\\n<bbox><x_79><y_658><x_358><y_693></bbox>NATA DE COCO\\n<bbox><x_790><y_652><x_814><y_683></bbox>0\\n<bbox><x_31><y_742><x_820><y_781></bbox>Sub Total 45,455\\n<bbox><x_27><y_781><x_822><y_827></bbox>PB1 (10%) 4,545\\n<bbox><x_27><y_826><x_824><y_872></bbox>Rounding 0\\n<bbox><x_24><y_872><x_827><y_921></bbox>Total 50,000\\n<bbox><x_17><y_1056><x_836><y_1108></bbox>Card Payment 50,000\\n\"\n+            ],\n+        }\n+\n+        self.assertListEqual(generated_text, EXPECTED_TEXT[self.cuda_compute_capability_major_version])\n+\n+        prompt = \"<md>\"\n+        generated_ids, generated_text = self.run_example(prompt, image, model, processor)\n+\n+        EXPECTED_TEXT = {\n+            7: [\n+                \"- **1 \\\\[REG\\\\] BLACK SAKURA** 45,455\\n- **1 COOKIE DOH SAUCES** 0\\n- **1 NATA DE COCO** 0\\n- **Sub Total** 45,455\\n- **PB1 (10%)** 4,545\\n- **Rounding** 0\\n- **Total** **50,000**\\n\\nCard Payment 50,000\"\n+            ],\n+            8: [\n+                \"- **1 \\\\[REG\\\\] BLACK SAKURA** 45,455\\n- **1 COOKIE DOH SAUCES** 0\\n- **1 NATA DE COCO** 0\\n- **Sub Total** 45,455\\n- **PB1 (10%)** 4,545\\n- **Rounding** 0\\n- **Total** **50,000**\\n\\nCard Payment 50,000\"\n+            ],\n+        }\n+\n+        self.assertListEqual(generated_text, EXPECTED_TEXT[self.cuda_compute_capability_major_version])\n+\n+    @require_flash_attn\n+    @require_torch_gpu\n+    @pytest.mark.flash_attn_test\n+    @slow\n+    def test_FA2(self):\n+        url = \"https://huggingface.co/ydshieh/kosmos-2.5/resolve/main/receipt_00008.png\"\n+        image = Image.open(requests.get(url, stream=True).raw)\n+\n+        dtype = torch.bfloat16\n+        repo = \"ydshieh/kosmos-2.5\"\n+        model = Kosmos2_5ForConditionalGeneration.from_pretrained(\n+            repo,\n+            device_map=torch_device,\n+            torch_dtype=dtype,\n+            attn_implementation=\"flash_attention_2\",\n+        )\n+        processor = AutoProcessor.from_pretrained(repo)\n+        prompt = \"<ocr>\"\n+        generated_ids, generated_text = self.run_example(prompt, image, model, processor)\n+        EXPECTED_TEXT = [\n+            \"<bbox><x_53><y_573><x_69><y_606></bbox>1\\n<bbox><x_79><y_573><x_464><y_612></bbox>[REG] BLACK SAKURA\\n<bbox><x_690><y_569><x_812><y_606></bbox>45,455\\n<bbox><x_53><y_614><x_69><y_650></bbox>1\\n<bbox><x_79><y_614><x_468><y_650></bbox>COOKIE DOH SAUCES\\n<bbox><x_788><y_610><x_813><y_644></bbox>0\\n<bbox><x_50><y_658><x_65><y_693></bbox>1\\n<bbox><x_76><y_658><x_358><y_693></bbox>NATA DE COCO\\n<bbox><x_790><y_652><x_815><y_687></bbox>0\\n<bbox><x_31><y_742><x_822><y_781></bbox>Sub Total 45,455\\n<bbox><x_27><y_780><x_822><y_827></bbox>PB1 (10%) 4,545\\n<bbox><x_27><y_826><x_824><y_874></bbox>Rounding 0\\n<bbox><x_24><y_872><x_827><y_921></bbox>Total 50,000\\n<bbox><x_17><y_1056><x_835><y_1108></bbox>Card Payment 50,000\\n\"\n+        ]\n+\n+        self.assertListEqual(generated_text, EXPECTED_TEXT)\n+\n+        prompt = \"<md>\"\n+        generated_ids, generated_text = self.run_example(prompt, image, model, processor)\n+        # A10 gives the 1st one, but A100 gives the 2nd one\n+        EXPECTED_TEXT = [\n+            \"- **1 \\\\[REG\\\\] BLACK SAKURA** 45,455\\n- **1 COOKIE DOH SAUCES** 0\\n- **1 NATA DE COCO** 0\\n\\n<table>\\n<thead>\\n<tr>\\n<th>\\nSub Total\\n</th>\\n<th>\\n45,455\\n</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>\\nPB1 (10%)\\n</td>\\n<td>\\n4,545\\n</td>\\n</tr>\\n<tr>\\n<td>\\nRounding\\n</td>\\n<td>\\n0\\n</td>\\n</tr>\\n<tr>\\n<td>\\n<strong>\\nTotal\\n</strong>\\n</td>\\n<td>\\n<strong>\\n50,000\\n</strong>\\n</td>\\n</tr>\\n</tbody>\\n</table>\\n\\nCard Payment 50,000\",\n+            \"- **1 \\\\[REG\\\\] BLACK SAKURA** 45,455\\n- **1 COOKIE DOH SAUCES** 0\\n- **1 NATA DE COCO** 0\\n- **Sub Total** 45,455\\n- **PB1 (10%)** 4,545\\n- **Rounding** 0\\n- **Total** **50,000**\\n\",\n+        ]\n+        self.assertIn(generated_text[0], EXPECTED_TEXT)"
        },
        {
            "sha": "5af439182919a319881948ec52c79d30614e56f8",
            "filename": "tests/models/kosmos2_5/test_processor_kosmos2_5.py",
            "status": "added",
            "additions": 391,
            "deletions": 0,
            "changes": 391,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/tests%2Fmodels%2Fkosmos2_5%2Ftest_processor_kosmos2_5.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/tests%2Fmodels%2Fkosmos2_5%2Ftest_processor_kosmos2_5.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fkosmos2_5%2Ftest_processor_kosmos2_5.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -0,0 +1,391 @@\n+# coding=utf-8\n+# Copyright 2024 Microsoft Research and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import os\n+import shutil\n+import tempfile\n+import unittest\n+from tempfile import TemporaryDirectory\n+\n+import numpy as np\n+import pytest\n+import requests\n+\n+from transformers.testing_utils import (\n+    require_torch,\n+    require_vision,\n+)\n+from transformers.utils import is_vision_available\n+\n+from ...test_processing_common import ProcessorTesterMixin\n+\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+    from transformers import (\n+        AutoProcessor,\n+        AutoTokenizer,\n+        Kosmos2_5ImageProcessor,\n+        Kosmos2_5Processor,\n+        PreTrainedTokenizerFast,\n+    )\n+\n+\n+@require_vision\n+class Kosmos2_5ProcessorTest(ProcessorTesterMixin, unittest.TestCase):\n+    processor_class = Kosmos2_5Processor\n+    images_input_name = \"flattened_patches\"\n+\n+    def setUp(self):\n+        self.tmpdirname = tempfile.mkdtemp()\n+        image_processor = Kosmos2_5ImageProcessor()\n+        tokenizer = AutoTokenizer.from_pretrained(\"ydshieh/kosmos-2.5\")\n+        processor = Kosmos2_5Processor(image_processor, tokenizer)\n+        processor.save_pretrained(self.tmpdirname)\n+\n+    def get_tokenizer(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).tokenizer\n+\n+    def get_image_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).image_processor\n+\n+    def tearDown(self):\n+        shutil.rmtree(self.tmpdirname)\n+\n+    def test_image_procesor_load_save_reload(self):\n+        # make sure load from Hub repo. -> save -> reload locally work\n+        image_processor = Kosmos2_5ImageProcessor.from_pretrained(\"ydshieh/kosmos-2.5\")\n+        with TemporaryDirectory() as tmp_dir:\n+            image_processor.save_pretrained(tmp_dir)\n+            reloaded_image_processor = Kosmos2_5ImageProcessor.from_pretrained(tmp_dir)\n+            assert image_processor.to_dict() == reloaded_image_processor.to_dict()\n+            assert image_processor.to_json_string() == reloaded_image_processor.to_json_string()\n+\n+    def test_save_load_pretrained_additional_features(self):\n+        processor = Kosmos2_5Processor(tokenizer=self.get_tokenizer(), image_processor=self.get_image_processor())\n+        processor.save_pretrained(self.tmpdirname)\n+\n+        tokenizer_add_kwargs = self.get_tokenizer(bos_token=\"(BOS)\", eos_token=\"(EOS)\")\n+        image_processor_add_kwargs = self.get_image_processor(do_normalize=False, padding_value=1.0)\n+\n+        processor = Kosmos2_5Processor.from_pretrained(\n+            self.tmpdirname,\n+            bos_token=\"(BOS)\",\n+            eos_token=\"(EOS)\",\n+            do_normalize=False,\n+            padding_value=1.0,\n+        )\n+\n+        self.assertEqual(processor.tokenizer.get_vocab(), tokenizer_add_kwargs.get_vocab())\n+        self.assertIsInstance(processor.tokenizer, PreTrainedTokenizerFast)\n+\n+        self.assertEqual(\n+            processor.image_processor.to_json_string(),\n+            image_processor_add_kwargs.to_json_string(),\n+        )\n+        self.assertIsInstance(processor.image_processor, Kosmos2_5ImageProcessor)\n+\n+    @unittest.skip(reason=\"kosmos-2.5 must have both image and text\")\n+    def test_image_processor(self):\n+        pass\n+\n+    @unittest.skip(reason=\"kosmos-2.5 must have both image and text\")\n+    def test_tokenizer(self):\n+        pass\n+\n+    def test_tokenizer_decode(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+\n+        processor = Kosmos2_5Processor(tokenizer=tokenizer, image_processor=image_processor)\n+\n+        predicted_ids = [[1, 4, 5, 8, 1, 0, 8], [3, 4, 3, 1, 1, 8, 9]]\n+\n+        decoded_processor = processor.batch_decode(predicted_ids)\n+        decoded_tok = tokenizer.batch_decode(predicted_ids)\n+\n+        self.assertListEqual(decoded_tok, decoded_processor)\n+\n+    def test_can_load_various_tokenizers(self):\n+        for checkpoint in [\"ydshieh/kosmos-2.5\"]:\n+            processor = AutoProcessor.from_pretrained(checkpoint)\n+            tokenizer = AutoTokenizer.from_pretrained(checkpoint)\n+            self.assertEqual(processor.tokenizer.__class__, tokenizer.__class__)\n+\n+    @require_torch\n+    def test_model_input_names(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+\n+        processor = Kosmos2_5Processor(tokenizer=tokenizer, image_processor=image_processor)\n+\n+        input_str = \"This is a test\"\n+        image_input = self.prepare_image_inputs()\n+\n+        # both image and text\n+        inputs = processor(text=input_str, images=image_input)\n+        self.assertListEqual(\n+            list(inputs.keys()),\n+            [\n+                \"flattened_patches\",\n+                \"attention_mask\",\n+                \"width\",\n+                \"height\",\n+                \"input_ids\",\n+                \"image_embeds_position_mask\",\n+            ],\n+        )\n+        # test if it raises when no input is passed\n+        with pytest.raises(ValueError):\n+            processor()\n+\n+    @require_torch\n+    @require_vision\n+    def test_image_processor_defaults_preserved_by_image_kwargs(self):\n+        # Rewrite as KOSMOS-2.5 processor return \"flattened_patches\" and not \"pixel_values\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\", max_patches=1024, patch_size={\"height\": 8, \"width\": 8})\n+        tokenizer = self.get_component(\"tokenizer\", max_length=117, padding=\"max_length\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = self.prepare_text_inputs()\n+        image_input = self.prepare_image_inputs()\n+\n+        inputs = processor(text=input_str, images=image_input)\n+        self.assertEqual(len(inputs[\"flattened_patches\"][0][0]), 194)\n+\n+    @require_torch\n+    @require_vision\n+    def test_kwargs_overrides_default_image_processor_kwargs(self):\n+        # Rewrite as KOSMOS-2.5 processor return \"flattened_patches\" and not \"pixel_values\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\", max_patches=4096)\n+        tokenizer = self.get_component(\"tokenizer\", max_length=117, padding=\"max_length\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = self.prepare_text_inputs()\n+        image_input = self.prepare_image_inputs()\n+\n+        inputs = processor(text=input_str, images=image_input, max_patches=1024)\n+        self.assertEqual(len(inputs[\"flattened_patches\"][0]), 1024)\n+\n+    @require_torch\n+    @require_vision\n+    def test_unstructured_kwargs(self):\n+        # Rewrite as KOSMOS-2.5 processor doesn't use `rescale_factor`\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = self.prepare_text_inputs()\n+        image_input = self.prepare_image_inputs()\n+        inputs = processor(\n+            text=input_str,\n+            images=image_input,\n+            return_tensors=\"pt\",\n+            max_patches=1024,\n+            padding=\"max_length\",\n+            max_length=76,\n+        )\n+\n+        self.assertEqual(inputs[\"flattened_patches\"].shape[1], 1024)\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 76)\n+\n+    @require_torch\n+    @require_vision\n+    def test_unstructured_kwargs_batched(self):\n+        # Rewrite as KOSMOS-2.5 processor doesn't use `rescale_factor`\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = self.prepare_text_inputs(batch_size=2)\n+        image_input = self.prepare_image_inputs(batch_size=2)\n+        inputs = processor(\n+            text=input_str,\n+            images=image_input,\n+            return_tensors=\"pt\",\n+            max_patches=1024,\n+            padding=\"longest\",\n+            max_length=76,\n+        )\n+\n+        self.assertEqual(inputs[\"flattened_patches\"].shape[1], 1024)\n+\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 76)\n+\n+    @require_torch\n+    @require_vision\n+    def test_structured_kwargs_nested(self):\n+        # Rewrite as KOSMOS-2.5 processor doesn't use `rescale_factor`\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = self.prepare_text_inputs()\n+        image_input = self.prepare_image_inputs()\n+\n+        # Define the kwargs for each modality\n+        all_kwargs = {\n+            \"common_kwargs\": {\"return_tensors\": \"pt\"},\n+            \"images_kwargs\": {\"max_patches\": 1024},\n+            \"text_kwargs\": {\"padding\": \"max_length\", \"max_length\": 76},\n+        }\n+\n+        inputs = processor(text=input_str, images=image_input, **all_kwargs)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        self.assertEqual(inputs[\"flattened_patches\"].shape[1], 1024)\n+\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 76)\n+\n+    @require_torch\n+    @require_vision\n+    def test_structured_kwargs_nested_from_dict(self):\n+        # Rewrite as KOSMOS-2.5 processor doesn't use `rescale_factor`\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+        input_str = self.prepare_text_inputs()\n+        image_input = self.prepare_image_inputs()\n+\n+        # Define the kwargs for each modality\n+        all_kwargs = {\n+            \"common_kwargs\": {\"return_tensors\": \"pt\"},\n+            \"images_kwargs\": {\"max_patches\": 1024},\n+            \"text_kwargs\": {\"padding\": \"max_length\", \"max_length\": 76},\n+        }\n+\n+        inputs = processor(text=input_str, images=image_input, **all_kwargs)\n+        self.assertEqual(inputs[\"flattened_patches\"].shape[1], 1024)\n+\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 76)\n+\n+    @require_torch\n+    def test_full_processor(self):\n+        url = \"https://huggingface.co/kirp/kosmos2_5/resolve/main/receipt_00008.png\"\n+        processor = AutoProcessor.from_pretrained(\"ydshieh/kosmos-2.5\")\n+        texts = [\"<md>\", \"<ocr>\"]\n+        expected_input_ids = [\n+            [100288],\n+            [100282],\n+        ]\n+        expected_attention_mask = [[1], [1]]\n+\n+        image = Image.open(requests.get(url, stream=True).raw)\n+        # To match the official (microsoft) Kosmos-2 demo from which the expected values here are grabbed\n+        image_path = os.path.join(self.tmpdirname, \"image.png\")\n+        image.save(image_path)\n+        image = Image.open(image_path)\n+\n+        # test single image\n+        outputs = processor(images=image, text=texts[0])\n+        self.assertListEqual(\n+            outputs.input_ids[0].numpy().tolist(),\n+            [0, 100283] + [0] * 2048 + [100284] + expected_input_ids[0],\n+        )\n+        self.assertListEqual(\n+            outputs.image_embeds_position_mask[0].numpy().tolist(),\n+            [0, -1] + [1] * 2048 + [-1] + [0] * (len(expected_input_ids[0])),\n+        )\n+        self.assertListEqual(\n+            outputs.attention_mask[0].numpy().tolist(),\n+            [1, 1] + [1] * 2048 + [1] + expected_attention_mask[0],\n+        )\n+        EXPECTED_FP_1 = [\n+            1.0,\n+            2.0,\n+            -2.9527735710144043,\n+            -2.672085762023926,\n+            -2.9933173656463623,\n+            -2.905944585800171,\n+            -2.5891761779785156,\n+            -2.8751866817474365,\n+            -2.962153434753418,\n+            -2.588062047958374,\n+        ]\n+        EXPECTED_FP_200 = [\n+            4.0,\n+            45.0,\n+            1.5713728666305542,\n+            1.584628939628601,\n+            1.3589054346084595,\n+            1.6515952348709106,\n+            1.7014952898025513,\n+            1.3731343746185303,\n+            1.6010395288467407,\n+            1.6607422828674316,\n+        ]\n+        self.assertTupleEqual(outputs.flattened_patches.shape, (1, 4096, 770))\n+        np.testing.assert_allclose(\n+            outputs.flattened_patches[0][1][:10].numpy().tolist(),\n+            EXPECTED_FP_1,\n+            atol=1e-9,\n+        )\n+        np.testing.assert_allclose(\n+            outputs.flattened_patches[0][200][:10].numpy().tolist(),\n+            EXPECTED_FP_200,\n+            atol=1e-9,\n+        )\n+\n+        # test a batch of images and texts, right padding\n+        outputs = processor(images=[image, image], text=texts)\n+        self.assertListEqual(\n+            outputs.input_ids[1].numpy().tolist(),\n+            [0, 100283] + [0] * 2048 + [100284] + expected_input_ids[1],\n+        )\n+        self.assertListEqual(\n+            outputs.image_embeds_position_mask[1].numpy().tolist(),\n+            [0, -1] + [1] * 2048 + [-1] + [0] * (len(expected_input_ids[1])),\n+        )\n+        self.assertListEqual(\n+            outputs.attention_mask[1].numpy().tolist(),\n+            [1, 1] + [1] * 2048 + [1] + expected_attention_mask[1],\n+        )\n+        self.assertTupleEqual(outputs.flattened_patches.shape, (2, 4096, 770))\n+        np.testing.assert_allclose(\n+            outputs.flattened_patches[1][1][:10].numpy().tolist(),\n+            EXPECTED_FP_1,\n+            atol=1e-9,\n+        )\n+        np.testing.assert_allclose(\n+            outputs.flattened_patches[1][200][:10].numpy().tolist(),\n+            EXPECTED_FP_200,\n+            atol=1e-9,\n+        )"
        },
        {
            "sha": "3d15c6aa23a1a97d89f63ae0ca9f25243d630c61",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/5b3b7ea4720bec9775c28a986b038245eb7e9c36/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5b3b7ea4720bec9775c28a986b038245eb7e9c36/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=5b3b7ea4720bec9775c28a986b038245eb7e9c36",
            "patch": "@@ -86,6 +86,9 @@\n     \"Idefics2PerceiverResampler\",\n     \"Idefics2VisionTransformer\",\n     \"Idefics3VisionTransformer\",\n+    \"Kosmos2_5TextModel\",\n+    \"Kosmos2_5TextForCausalLM\",\n+    \"Kosmos2_5VisionModel\",\n     \"SmolVLMVisionTransformer\",\n     \"AriaTextForCausalLM\",\n     \"AriaTextModel\",\n@@ -412,6 +415,7 @@\n         (\"data2vec-audio\", \"data2vec\"),\n         (\"data2vec-vision\", \"data2vec\"),\n         (\"donut-swin\", \"donut\"),\n+        (\"kosmos-2.5\", \"kosmos2_5\"),\n         (\"dinov3_convnext\", \"dinov3\"),\n         (\"dinov3_vit\", \"dinov3\"),\n     ]"
        }
    ],
    "stats": {
        "total": 4877,
        "additions": 4873,
        "deletions": 4
    }
}