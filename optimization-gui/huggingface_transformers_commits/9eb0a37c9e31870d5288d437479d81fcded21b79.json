{
    "author": "RyanMullins",
    "message": "Adds use_repr to model_addition_debugger_context (#37984)\n\n* Adds use_repr to model_addition_debugger_context\n\n* Updating docs for use_repr option",
    "sha": "9eb0a37c9e31870d5288d437479d81fcded21b79",
    "files": [
        {
            "sha": "69f622ae1096ca137d1177a45cdf9a44cf5dbce4",
            "filename": "docs/source/en/internal/model_debugging_utils.md",
            "status": "modified",
            "additions": 52,
            "deletions": 16,
            "changes": 68,
            "blob_url": "https://github.com/huggingface/transformers/blob/9eb0a37c9e31870d5288d437479d81fcded21b79/docs%2Fsource%2Fen%2Finternal%2Fmodel_debugging_utils.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/9eb0a37c9e31870d5288d437479d81fcded21b79/docs%2Fsource%2Fen%2Finternal%2Fmodel_debugging_utils.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Finternal%2Fmodel_debugging_utils.md?ref=9eb0a37c9e31870d5288d437479d81fcded21b79",
            "patch": "@@ -16,7 +16,8 @@ rendered properly in your Markdown viewer.\n \n # Model debugging toolboxes\n \n-This page lists all the debugging and model adding tools used by the library, as well as the utility functions it provides for it.\n+This page lists all the debugging and model adding tools used by the library, as well as the utility functions it\n+provides for it.\n \n Most of those are only useful if you are adding new models in the library.\n \n@@ -26,13 +27,14 @@ Most of those are only useful if you are adding new models in the library.\n \n ### Model addition debugger - context manager for model adders\n \n-This context manager is a power user tool intended for model adders.\n-It tracks all forward calls within a model forward and logs a slice of each input and output on a nested Json.\n-To note, this context manager enforces `torch.no_grad()`.\n+This context manager is a power user tool intended for model adders. It tracks all forward calls within a model forward\n+and logs a slice of each input and output on a nested JSON. To note, this context manager enforces `torch.no_grad()`.\n \n ### Rationale\n \n-Because when porting models to transformers, even from python to python, model adders often have to do a lot of manual operations, involving saving and loading tensors, comparing dtypes, etc. This small tool can hopefully shave off some time.\n+When porting models to transformers, even from python to python, model adders often have to do a lot of manual\n+operations, involving saving and loading tensors, comparing dtypes, etc. This small tool can hopefully shave off some\n+time.\n \n ### Usage\n \n@@ -62,19 +64,19 @@ inputs = processor(text=prompt, images=random_image, return_tensors=\"pt\")\n \n # call forward method (not .generate!)\n with model_addition_debugger_context(\n-  model,\n-  debug_path=\"optional_path_to_your_directory\",\n-  do_prune_layers=False # This will output ALL the layers of a model.\n-  ):\n+    model,\n+    debug_path=\"optional_path_to_your_directory\",\n+    do_prune_layers=False # This will output ALL the layers of a model.\n+):\n     output = model.forward(**inputs)\n \n ```\n \n \n ### Reading results\n \n-The debugger generates two files from the forward call, both with the same base name, \n-but ending either with `_SUMMARY.json` or with `_FULL_TENSORS.json`. \n+The debugger generates two files from the forward call, both with the same base name, but ending either with\n+`_SUMMARY.json` or with `_FULL_TENSORS.json`.\n \n The first one will contain a summary of each module's _input_ and _output_ tensor values and shapes.\n \n@@ -142,8 +144,8 @@ The first one will contain a summary of each module's _input_ and _output_ tenso\n         { ... and so on\n ```\n \n-The `_FULL_TENSORS.json` file will display a full view of all tensors, which is useful\n-for comparing two files. \n+The `_FULL_TENSORS.json` file will display a full view of all tensors, which is useful for comparing two files.\n+\n ```json\n       \"pixel_values\": {\n         \"shape\": \"torch.Size([1, 5, 576, 588])\",\n@@ -196,18 +198,52 @@ for comparing two files.\n       },\n ```\n \n+#### Saving tensors to disk\n+\n+Some model adders may benefit from logging full tensor values to disk to support, for example, numerical analysis\n+across implementations.\n+\n+Set `use_repr=False` to write tensors to disk using [SafeTensors](https://huggingface.co/docs/safetensors/en/index).\n+\n+```python\n+with model_addition_debugger_context(\n+    model,\n+    debug_path=\"optional_path_to_your_directory\",\n+    do_prune_layers=False,\n+    use_repr=False,   # Defaults to True\n+):\n+    output = model.forward(**inputs)\n+```\n+\n+When using `use_repr=False`, tensors are written to the same disk location as the `_SUMMARY.json` and\n+`_FULL_TENSORS.json` files. The `value` property of entries in the `_FULL_TENSORS.json` file will contain a relative\n+path reference to the associated `.safetensors` file. Each tensor is written to its own file as the `data` property of\n+the state dictionary. File names are constructed using the `module_path` as a prefix with a few possible postfixes that\n+are built recursively.\n+\n+*   Module inputs are denoted with the `_inputs` and outputs by `_outputs`.\n+*   `list` and `tuple` instances, such as `args` or function return values, will be postfixed with `_{index}`.\n+*   `dict` instances will be postfixed with `_{key}`.\n+\n ### Comparing between implementations\n \n-Once the forward passes of two models have been traced by the debugger, one can compare the `json` output files. See below: we can see slight differences between these two implementations' key projection layer. Inputs are mostly identical, but not quite. Looking through the file differences makes it easier to pinpoint which layer is wrong. \n+Once the forward passes of two models have been traced by the debugger, one can compare the `json` output files. See\n+below: we can see slight differences between these two implementations' key projection layer. Inputs are mostly\n+identical, but not quite. Looking through the file differences makes it easier to pinpoint which layer is wrong.\n \n \n ![download-icon](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/files_difference_debugging.png)\n \n \n ### Limitations and scope\n \n-This feature will only work for torch-based models, and would require more work and case-by-case approach for say `jax`-based models that are usually compiled. Models relying heavily on external kernel calls may work, but trace will probably miss some things. Regardless, any python implementation that aims at mimicking another implementation can be traced once instead of reran N times with breakpoints.\n+This feature will only work for torch-based models, and would require more work and case-by-case approach for say\n+`jax`-based models that are usually compiled. Models relying heavily on external kernel calls may work, but trace will\n+probably miss some things. Regardless, any python implementation that aims at mimicking another implementation can be\n+traced once instead of reran N times with breakpoints.\n \n-If you pass `do_prune_layers=False` to your model debugger, ALL the layers will be outputted to `json`. Else, only the first and last layer will be shown. This is useful when some layers (typically cross-attention) appear only after N layers. \n+If you pass `do_prune_layers=False` to your model debugger, ALL the layers will be outputted to `json`. Else, only the\n+first and last layer will be shown. This is useful when some layers (typically cross-attention) appear only after N\n+layers.\n \n [[autodoc]] model_addition_debugger_context"
        },
        {
            "sha": "d09cfa24a72aa363d77f9ccabfac009e850a7963",
            "filename": "src/transformers/model_debugging_utils.py",
            "status": "modified",
            "additions": 123,
            "deletions": 51,
            "changes": 174,
            "blob_url": "https://github.com/huggingface/transformers/blob/9eb0a37c9e31870d5288d437479d81fcded21b79/src%2Ftransformers%2Fmodel_debugging_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9eb0a37c9e31870d5288d437479d81fcded21b79/src%2Ftransformers%2Fmodel_debugging_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodel_debugging_utils.py?ref=9eb0a37c9e31870d5288d437479d81fcded21b79",
            "patch": "@@ -21,6 +21,8 @@\n from io import StringIO\n from typing import Optional\n \n+from safetensors.torch import save_file\n+\n from transformers.utils.import_utils import requires\n \n from .utils import is_torch_available\n@@ -65,64 +67,94 @@ def _dtensor_repr(x):\n     return \"DTensor(non-rank0)\"\n \n \n-def _serialize_io(value):\n+def _serialize_tensor_like_io(\n+    value, debug_path: Optional[str] = None, use_repr: bool = True, path_to_value: Optional[str] = None\n+):\n+    \"\"\"\n+    Converts Tensors and DTensors to a JSON-serializable dictionary representation.\n+\n+    Args:\n+        value: Any Python object, often including torch Tensors, lists, dicts, etc.\n+        debug_path (`str`, *optional*, defaults to `None`): Directory to dump debug JSON and SafeTensors files.\n+        use_repr (bool, *optional*, defaults to `True`): Whether to save a `repr()`-ized version of the tensor as the\n+            `value` property in the asscoiated FULL_TENSORS.json file, or to store the full tensors in separate\n+            SafeTensors file and store the relative path to that file in the `value` property in the dictionary.\n+        path_to_value (`str`, *optional*, defaults to `None`): The file name for the SafeTensors file holding the full\n+            tensor value if `use_repr=False`.\n+\n+    Returns:\n+        A nested Python structure (list, dict, or sanitized string) that is safe to json.dump.\n+    \"\"\"\n+    torch.set_printoptions(sci_mode=True)\n+\n+    if use_repr:\n+        value_out = _repr_to_list(value)\n+    elif path_to_value:\n+        if not path_to_value.endswith(\".safetensors\"):\n+            path_to_value += \".safetensors\"\n+\n+        filepath = os.path.join(debug_path, path_to_value) if debug_path else path_to_value\n+        save_file({\"data\": value.contiguous().detach().cpu()}, filepath)\n+        value_out = f\"./{path_to_value}\"\n+    else:\n+        raise ValueError(f\"{use_repr=} and {path_to_value=} cannot both be falsy.\")\n+\n+    out = {\n+        \"shape\": repr(value.shape),\n+        \"dtype\": repr(value.dtype),\n+        \"value\": value_out,\n+    }\n+    if value.dtype in {torch.float16, torch.float32, torch.bfloat16}:\n+        out.update(\n+            {\n+                \"mean\": _sanitize_repr_for_diff(repr(value.mean())),\n+                \"std\": _sanitize_repr_for_diff(repr(value.std())),\n+                \"min\": _sanitize_repr_for_diff(repr(value.min())),\n+                \"max\": _sanitize_repr_for_diff(repr(value.max())),\n+            }\n+        )\n+    return out\n+\n+\n+def _serialize_io(value, debug_path: Optional[str] = None, use_repr: bool = True, path_to_value: Optional[str] = None):\n     \"\"\"\n     Recursively build a JSON-serializable Python structure from `value`.\n-    Tensors and DTensors become sanitized repr strings.\n+    Tensors and DTensors become either sanitized repr strings, or are saved to disk as SafeTensors files and their\n+    relative paths are recorded in the returned Python structure.\n     Lists/tuples/dicts are recursed into.\n     All memory addresses are replaced with a stable placeholder.\n \n     Args:\n         value: Any Python object, often including torch Tensors, lists, dicts, etc.\n+        debug_path (`str`, *optional*, defaults to `None`): Directory to dump debug JSON and SafeTensors files.\n+        use_repr (bool, *optional*, defaults to `True`): Whether to save a `repr()`-ized version of the tensors as the\n+            `value` property in the asscoiated FULL_TENSORS.json file, or to store full tensors in separate SafeTensors\n+            files and store the relative path to that file in the `value` property.\n+        path_to_value (`str`, *optional*, defaults to `None`): The file name for the SafeTensors file holding the full\n+            tensor value if `use_repr=False`.\n \n     Returns:\n         A nested Python structure (list, dict, or sanitized string) that is safe to json.dump.\n     \"\"\"\n     if isinstance(value, (list, tuple)):\n-        return [_serialize_io(v) for v in value]\n+        return [\n+            _serialize_io(v, debug_path=debug_path, use_repr=use_repr, path_to_value=f\"{path_to_value}_{i}\")\n+            for i, v in enumerate(value)\n+        ]\n \n     if isinstance(value, dict):\n-        return {k: _serialize_io(v) for k, v in value.items()}\n+        return {\n+            k: _serialize_io(v, debug_path=debug_path, use_repr=use_repr, path_to_value=f\"{path_to_value}_{k}\")\n+            for k, v in value.items()\n+        }\n \n     if hasattr(value, \"_local_tensor\"):\n-        # DTensor-like handling, just use local tensor attribute\n-        torch.set_printoptions(sci_mode=True)\n-        val_repr = _repr_to_list(value)\n-        out = {\n-            \"shape\": repr(value._local_tensor.shape),\n-            \"dtype\": repr(value._local_tensor.dtype),\n-            \"value\": val_repr,\n-        }\n-        if value._local_tensor.dtype in {torch.float16, torch.float32, torch.bfloat16}:\n-            value = value._local_tensor.clone()\n-            out.update(\n-                {\n-                    \"mean\": _sanitize_repr_for_diff(repr(value.mean())),\n-                    \"std\": _sanitize_repr_for_diff(repr(value.std())),\n-                    \"min\": _sanitize_repr_for_diff(repr(value.min())),\n-                    \"max\": _sanitize_repr_for_diff(repr(value.max())),\n-                }\n-            )\n-        return out\n+        return _serialize_tensor_like_io(\n+            value._local_tensor, debug_path=debug_path, use_repr=use_repr, path_to_value=path_to_value\n+        )\n \n     if isinstance(value, torch.Tensor):\n-        torch.set_printoptions(sci_mode=True)\n-        val_repr = _repr_to_list(value)\n-        out = {\n-            \"shape\": repr(value.shape),\n-            \"dtype\": repr(value.dtype),\n-            \"value\": val_repr,\n-        }\n-        if value.dtype in {torch.float16, torch.float32, torch.bfloat16}:\n-            out.update(\n-                {\n-                    \"mean\": _sanitize_repr_for_diff(repr(value.mean())),\n-                    \"std\": _sanitize_repr_for_diff(repr(value.std())),\n-                    \"min\": _sanitize_repr_for_diff(repr(value.min())),\n-                    \"max\": _sanitize_repr_for_diff(repr(value.max())),\n-                }\n-            )\n-        return out\n+        return _serialize_tensor_like_io(value, debug_path=debug_path, use_repr=use_repr, path_to_value=path_to_value)\n \n     return _sanitize_repr_for_diff(repr(value))\n \n@@ -199,7 +231,7 @@ def log_model_debug_trace(debug_path, model):\n             os.makedirs(debug_path, exist_ok=True)\n             base = os.path.join(debug_path, model._debugger_module_dump_name + \"_debug_tree\")\n         except Exception as e:\n-            raise ValueError(f\"Unexpected or existing debug_path={debug_path}. {e}\")\n+            raise ValueError(f\"Unexpected or existing debug_path={debug_path}.\") from e\n     else:\n         base = model._debugger_module_dump_name + \"_debug_tree\"\n \n@@ -240,6 +272,7 @@ def _attach_debugger_logic(\n     model,\n     debug_path: Optional[str] = \".\",\n     do_prune_layers: Optional[bool] = True,\n+    use_repr: bool = True,\n ):\n     \"\"\"\n     Attaches a debugging wrapper to every module in the model.\n@@ -250,6 +283,9 @@ def _attach_debugger_logic(\n         model (`PreTrainedModel`, `nn.Module`): Model to wrap.\n         debug_path (`str`): Optional directory to dump debug JSON files.\n         do_prune_layers (`bool`, *optional*, defaults to `True`): Whether to prune intermediate layers.\n+        use_repr (bool, *optional*, defaults to `True`): Whether to save a `repr()`-ized version of the tensors as the\n+            `value` property in the asscoiated FULL_TENSORS.json file, or to store full tensors in separate SafeTensors\n+            files and store the relative path to that file in the `value` property.\n     \"\"\"\n     class_name = model.__class__.__name__\n \n@@ -258,6 +294,12 @@ def _attach_debugger_logic(\n     model._debugger_model_call_stack = []\n     model._debugger_module_dump_name = class_name  # used for final JSON filename\n \n+    if debug_path:\n+        try:\n+            os.makedirs(debug_path, exist_ok=True)\n+        except Exception as e:\n+            raise ValueError(f\"Unexpected or existing debug_path={debug_path}.\") from e\n+\n     def wrap_forward(module, full_path):\n         orig_forward = module.forward\n \n@@ -268,7 +310,12 @@ def wrapped_forward(*inps, **kws):\n                 dict_inputs = {k: dict_inputs[k] for k in dict_inputs if len(dict_inputs[k]) > 0}\n                 node = {\n                     \"module_path\": full_path,\n-                    \"inputs\": _serialize_io(dict_inputs),\n+                    \"inputs\": _serialize_io(\n+                        dict_inputs,\n+                        debug_path=debug_path,\n+                        use_repr=use_repr,\n+                        path_to_value=f\"{full_path}_inputs\",\n+                    ),\n                     \"outputs\": None,\n                     \"children\": [],\n                 }\n@@ -280,7 +327,12 @@ def wrapped_forward(*inps, **kws):\n                 if sum(1 for _ in module.named_children()) > 0:\n                     node[\"outputs\"] = None\n                 else:\n-                    node[\"outputs\"] = _serialize_io(out)\n+                    node[\"outputs\"] = _serialize_io(\n+                        out,\n+                        debug_path=debug_path,\n+                        use_repr=use_repr,\n+                        path_to_value=f\"{full_path}_outputs\",\n+                    )\n \n                 finished = model._debugger_model_call_stack.pop()\n                 # prune empty vertices here as well (mostly empty children nodes)\n@@ -307,15 +359,25 @@ def top_wrapped_forward(*inps, **kws):\n         if _is_rank_zero():\n             top_node = {\n                 \"module_path\": f\"{class_name} (top-level)\",\n-                \"inputs\": _serialize_io({\"args\": inps, \"kwargs\": kws}),\n+                \"inputs\": _serialize_io(\n+                    {\"args\": inps, \"kwargs\": kws},\n+                    debug_path=debug_path,\n+                    use_repr=use_repr,\n+                    path_to_value=f\"{class_name}_inputs\",\n+                ),\n                 \"outputs\": None,\n                 \"children\": [],\n             }\n             model._debugger_model_call_stack.append(top_node)\n \n         out = real_top_forward(*inps, **kws)\n         if _is_rank_zero() and model._debugger_model_call_stack:\n-            top_node[\"outputs\"] = _serialize_io(out)\n+            top_node[\"outputs\"] = _serialize_io(\n+                out,\n+                debug_path=debug_path,\n+                use_repr=use_repr,\n+                path_to_value=f\"{class_name}_outputs\",\n+            )\n             finished = model._debugger_model_call_stack.pop()\n             model._call_tree[\"inputs\"] = finished[\"inputs\"]\n             model._call_tree[\"outputs\"] = finished[\"outputs\"]\n@@ -335,11 +397,21 @@ def top_wrapped_forward(*inps, **kws):\n \n @requires(backends=(\"torch\",))\n @contextmanager\n-def model_addition_debugger_context(model, debug_path: Optional[str] = None, do_prune_layers: Optional[bool] = True):\n+def model_addition_debugger_context(\n+    model,\n+    debug_path: Optional[str] = None,\n+    do_prune_layers: Optional[bool] = True,\n+    use_repr: Optional[bool] = True,\n+):\n     \"\"\"\n     # Model addition debugger - context manager for model adders\n     This context manager is a power user tool intended for model adders.\n-    It tracks all forward calls within a model forward and logs a slice of each input and output on a nested Json.\n+\n+    It tracks all forward calls within a model forward and logs a slice of each input and output on a nested JSON file.\n+    If `use_repr=True` (the default), the JSON file will record a `repr()`-ized version of the tensors as a list of\n+    strings. If `use_repr=False`, the full tensors will be stored in spearate SafeTensors files and the JSON file will\n+    provide a relative path to that file.\n+\n     To note, this context manager enforces `torch.no_grad()`.\n \n     ## Usage\n@@ -348,10 +420,10 @@ def model_addition_debugger_context(model, debug_path: Optional[str] = None, do_\n \n     ```python\n     import torch\n+\n     from PIL import Image\n-    import requests\n-    from transformers import LlavaProcessor, LlavaForConditionalGeneration\n-    from transformers.model_debugging_utils import model_addition_debugger_context\n+    from transformers import LlavaProcessor, LlavaForConditionalGeneration, model_addition_debugger_context\n+\n     torch.random.manual_seed(673)\n \n     # load pretrained model and processor\n@@ -376,7 +448,7 @@ def model_addition_debugger_context(model, debug_path: Optional[str] = None, do_\n     \"\"\"\n     orig_forwards = {m: m.forward for _, m in model.named_modules()}\n     orig_forwards[model] = model.forward\n-    _attach_debugger_logic(model, debug_path, do_prune_layers)\n+    _attach_debugger_logic(model, debug_path, do_prune_layers, use_repr)\n     try:\n         yield model\n     finally:"
        }
    ],
    "stats": {
        "total": 242,
        "additions": 175,
        "deletions": 67
    }
}