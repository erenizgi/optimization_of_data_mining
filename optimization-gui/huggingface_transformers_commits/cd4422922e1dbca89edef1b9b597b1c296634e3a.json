{
    "author": "molbap",
    "message": "Add modular detector (#41289)\n\n* doc\n\n* doc\n\n* no remote code\n\n* safe-ize the release + remove remote\n\n* fixes\n\n* add some documentation as well",
    "sha": "cd4422922e1dbca89edef1b9b597b1c296634e3a",
    "files": [
        {
            "sha": "482c0ecfb90f9d18378fbd5033a95af99292dcb3",
            "filename": "docs/source/en/internal/model_debugging_utils.md",
            "status": "modified",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/huggingface/transformers/blob/cd4422922e1dbca89edef1b9b597b1c296634e3a/docs%2Fsource%2Fen%2Finternal%2Fmodel_debugging_utils.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/cd4422922e1dbca89edef1b9b597b1c296634e3a/docs%2Fsource%2Fen%2Finternal%2Fmodel_debugging_utils.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Finternal%2Fmodel_debugging_utils.md?ref=cd4422922e1dbca89edef1b9b597b1c296634e3a",
            "patch": "@@ -352,3 +352,87 @@ Skipped : 124/323 (38.4%)\n ðŸ“„ JSON saved to /home/pablo/git/transformers/scan_test_inputs_embeds.json\n \n ```\n+\n+## Modular model detector\n+\n+### Code similarity analyzer - for model adders\n+\n+This utility analyzes code similarities between model implementations to identify opportunities for modularization. It compares a new or existing modeling file against all models in the library using embedding-based and token-based similarity metrics.\n+\n+### Rationale\n+\n+When adding a new model to transformers, many components (attention layers, MLPs, outputs, etc.) may already exist in similar form in other models. Instead of implementing everything from scratch, model adders can identify which existing classes are similar and potentially reusable through modularization.\n+\n+The tool computes two similarity scores:\n+- **Embedding score**: Uses semantic code embeddings (via `Qwen/Qwen3-Embedding-4B`) to detect functionally similar code even with different naming\n+- **Jaccard score**: Measures token set overlap to identify structurally similar code patterns\n+\n+A score of 1.00 means the code is identical.\n+\n+### Usage\n+\n+From the root of the `transformers` repository:\n+\n+```bash\n+python utils/modular_model_detector.py --modeling-file path/to/modeling_file.py\n+```\n+\n+The tool will automatically download the pre-built index from the Hub (requires RAM/VRAM for the embedding model).\n+\n+**Example output:**\n+\n+```text\n+Loading checkpoint shards: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 2/2 [00:00<00:00, 33.62it/s]\n+encoding 21 query definitions with Qwen/Qwen3-Embedding-4B (device=cuda, batch=16, max_length=4096)\n+\n+stuff.py::Beit3ImageTextMatchingOutput:\n+embedding:\n+    blip_2::Blip2ImageTextMatchingModelOutput (0.9994)\n+    chinese_clip::ChineseCLIPOutput (0.9818)\n+    owlvit::OwlViTOutput (0.9818)\n+jaccard:\n+    owlv2::Owlv2Output (0.9667)\n+    metaclip_2::MetaClip2Output (0.9667)\n+    altclip::AltCLIPOutput (0.9667)\n+intersection:\n+    blip::BlipOutput\n+    owlvit::OwlViTOutput\n+\n+stuff.py::Beit3MLP:\n+embedding:\n+    efficientloftr::EfficientLoFTRMLP (0.9718)\n+    seggpt::SegGptMlp (0.9650)\n+jaccard:\n+    chinese_clip::ChineseCLIPTextSelfOutput (0.5294)\n+    bert::BertSelfOutput (0.5294)\n+intersection:\n+```\n+\n+The `intersection` field shows classes that appear in both top-5 results, indicating high confidence for modularization candidates.\n+\n+### Building a custom index\n+\n+To rebuild the index from your local codebase (useful after adding new models or using a different embedding model):\n+\n+```bash\n+python utils/modular_model_detector.py --build\n+```\n+\n+To push the rebuilt index to a Hub dataset:\n+\n+```bash\n+python utils/modular_model_detector.py --build --push-new-index --hub-dataset your-org/your-dataset\n+```\n+\n+### Options\n+\n+- `--modeling-file`: Path to the modeling file to analyze\n+- `--build`: Build the code similarity index from all modeling files in `src/transformers/models/`\n+- `--push-new-index`: After building, push the index to a Hub dataset (requires `--build`)\n+- `--hub-dataset`: Hub dataset repository ID to pull/push the index (default: `hf-internal-testing/transformers_code_embeddings`)\n+\n+### Limitations\n+\n+This tool requires GPU/CPU resources to run the embedding model (`Qwen/Qwen3-Embedding-4B`). The pre-built index is downloaded from the Hub by default, which requires an internet connection on first use.\n+\n+Results are suggestions based on code similarity and should be manually reviewed before modularization. High similarity scores don't guarantee perfect compatibility."
        },
        {
            "sha": "205b009dbce726f3b7341d15649e26de7292bb73",
            "filename": "utils/modular_model_detector.py",
            "status": "added",
            "additions": 583,
            "deletions": 0,
            "changes": 583,
            "blob_url": "https://github.com/huggingface/transformers/blob/cd4422922e1dbca89edef1b9b597b1c296634e3a/utils%2Fmodular_model_detector.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/cd4422922e1dbca89edef1b9b597b1c296634e3a/utils%2Fmodular_model_detector.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fmodular_model_detector.py?ref=cd4422922e1dbca89edef1b9b597b1c296634e3a",
            "patch": "@@ -0,0 +1,583 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+# ðŸ”´ðŸ”´ðŸ”´ THIS IS AN INTERNAL TOOL. It WILL interact with the hub and use significant local compute resources. Use at your own risk.\n+\n+\n+\"\"\"\n+Modular model detector: utilities for detecting code similarities between model implementations.\n+\n+This module provides tools to analyze and detect similarities between different model implementations\n+in the transformers library. It uses both embedding-based and token-based (Jaccard) similarity metrics\n+to identify similar code patterns across different model definitions.\n+\n+Its function is to identify which models can be _modular_-ized, meaning, which already existing classes are\n+present in the codebase and look very similar to the one we have.\n+\n+Two scores are computed, one is a code embedding, and the other is a simple Jaccard bag-of-tokens index for overlap\n+of token sets. A score of 1.00 means the code is identical.\n+\n+Usage:\n+\n+```bash\n+cd transformers\n+\n+# Use directly the util, it will download the index embedding from the hub. It will require some RAM/VRAM.\n+\n+>>> python utils/modular_model_detector.py --modeling-file my_new_beit3_modeling_file.py\n+Loading checkpoint shards: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 2/2 [00:00<00:00, 33.62it/s]\n+encoding 21 query definitions with Qwen/Qwen3-Embedding-4B (device=cuda, batch=16, max_length=4096)\n+stuff.py::Beit3ImageTextMatchingOutput:\n+embedding:\n+    blip_2::Blip2ImageTextMatchingModelOutput (0.9994)\n+    chinese_clip::ChineseCLIPOutput (0.9818)\n+    owlvit::OwlViTOutput (0.9818)\n+    aimv2::Aimv2Output (0.9818)\n+    blip::BlipOutput (0.9818)\n+jaccard:\n+    owlv2::Owlv2Output (0.9667)\n+    metaclip_2::MetaClip2Output (0.9667)\n+    altclip::AltCLIPOutput (0.9667)\n+    owlvit::OwlViTOutput (0.9667)\n+    blip::BlipOutput (0.9667)\n+intersection:\n+    blip::BlipOutput\n+    owlvit::OwlViTOutput\n+\n+stuff.py::Beit3MLP:\n+embedding:\n+    efficientloftr::EfficientLoFTRMLP (0.9718)\n+    seggpt::SegGptMlp (0.9650)\n+    mgp_str::MgpstrMlp (0.9646)\n+    vitpose_backbone::VitPoseBackboneMLP (0.9640)\n+    granitemoeshared::GraniteMoeSharedMLP (0.9633)\n+jaccard:\n+    chinese_clip::ChineseCLIPTextSelfOutput (0.5294)\n+    convbert::ConvBertSelfOutput (0.5294)\n+    bert::BertSelfOutput (0.5294)\n+    roformer::RoFormerSelfOutput (0.5294)\n+    layoutlmv3::LayoutLMv3SelfOutput (0.5294)\n+intersection:\n+\n+stuff.py::Beit3FeedForwardNetwork:\n+embedding:\n+    prophetnet::ProphetNetFeedForward (0.9766)\n+    dab_detr::DabDetrDecoderLayerFFN (0.9730)\n+    kosmos2::Kosmos2TextFFN (0.9697)\n+    kosmos2_5::Kosmos2_5TextFFN (0.9697)\n+    parakeet::ParakeetEncoderFeedForward (0.9678)\n+jaccard:\n+    groupvit::GroupViTMLP (0.4898)\n+    convbert::ConvBertOutput (0.4600)\n+    chinese_clip::ChineseCLIPTextOutput (0.4565)\n+    bert::BertOutput (0.4565)\n+    roformer::RoFormerOutput (0.4565)\n+intersection:\n+\n+\n+\n+```\n+\n+\n+# If you wish to build the index first, you can run\n+\n+python utils/modular_model_detector.py --build\n+\n+# You can also change the embedding model for a larger/smaller one.\n+\"\"\"\n+\n+import argparse\n+import ast\n+import json\n+import logging\n+import os\n+import re\n+from pathlib import Path\n+\n+import numpy as np\n+import torch\n+from huggingface_hub import HfApi, hf_hub_download\n+from huggingface_hub import logging as huggingface_hub_logging\n+from safetensors.numpy import load_file as safetensors_load\n+from safetensors.numpy import save_file as safetensors_save\n+from tqdm import tqdm\n+\n+from transformers import AutoModel, AutoTokenizer\n+from transformers.utils import logging as transformers_logging\n+\n+\n+os.environ[\"HF_HUB_DISABLE_PROGRESS_BARS\"] = \"1\"\n+os.environ[\"TRANSFORMERS_VERBOSITY\"] = \"error\"\n+\n+MODELS_ROOT = Path(\"src/transformers/models\")\n+EMBEDDINGS_PATH = \"embeddings.safetensors\"\n+INDEX_MAP_PATH = \"code_index_map.json\"\n+TOKENS_PATH = \"code_index_tokens.json\"\n+HUB_DATASET_DEFAULT = \"hf-internal-testing/transformers_code_embeddings\"\n+\n+EMBEDDING_MODEL = \"Qwen/Qwen3-Embedding-4B\"\n+BATCH_SIZE = 16\n+MAX_LENGTH = 4096\n+\n+\n+def _normalize(string: str | None) -> str:\n+    \"\"\"\n+    Normalize a string by removing all non-alphanumeric characters and converting to lowercase.\n+\n+    Args:\n+        string (`str` or `None`): The string to normalize.\n+\n+    Returns:\n+        `str`: The normalized string, or empty string if input is None.\n+    \"\"\"\n+    return re.sub(r\"[^a-z0-9]+\", \"\", string.lower()) if string else \"\"\n+\n+\n+def _strip_source_for_tokens(code: str) -> str:\n+    \"\"\"\n+    Strip docstrings, comments, and import statements from source code.\n+\n+    Args:\n+        code (`str`): The source code to strip.\n+\n+    Returns:\n+        `str`: The stripped source code.\n+    \"\"\"\n+    code = re.sub(r'(\"\"\"|\\'\\'\\')(?:.|\\n)*?\\1', \"\", code)\n+    code = re.sub(r\"#.*\", \"\", code)\n+    return \"\\n\".join(line for line in code.splitlines() if not re.match(r\"\\s*(from|import)\\s+\", line))\n+\n+\n+def _tokenize(code: str) -> set[str]:\n+    \"\"\"\n+    Extract all Python identifiers from source code.\n+\n+    Args:\n+        code (`str`): The source code to tokenize.\n+\n+    Returns:\n+        `set[str]`: A set of all identifiers found in the code.\n+    \"\"\"\n+    return set(re.findall(r\"\\b[a-zA-Z_][a-zA-Z0-9_]*\\b\", code))\n+\n+\n+def _leading_symbol_prefix(name: str) -> str:\n+    \"\"\"\n+    Extract the leading prefix from a symbol name (e.g., 'Llama' from 'LlamaAttention').\n+\n+    Args:\n+        name (`str`): The symbol name to extract prefix from.\n+\n+    Returns:\n+        `str`: The leading prefix, or empty string if no match.\n+    \"\"\"\n+    match = re.match(r\"^([A-Z][a-z0-9]+)\", name) or re.match(r\"^([A-Za-z0-9]+)\", name)\n+    return match.group(1) if match else \"\"\n+\n+\n+def _sanitize_for_embedding(code: str, model_hint: str | None, symbol_hint: str | None) -> str:\n+    \"\"\"\n+    Sanitize code for embedding by replacing model-specific identifiers with generic placeholder.\n+\n+    Args:\n+        code (`str`): The source code to sanitize.\n+        model_hint (`str` or `None`): Hint about the model name (e.g., 'llama').\n+        symbol_hint (`str` or `None`): Hint about the symbol name (e.g., 'LlamaAttention').\n+\n+    Returns:\n+        `str`: The sanitized code with model-specific identifiers replaced by 'Model'.\n+    \"\"\"\n+    base = _strip_source_for_tokens(code)\n+    variants = set()\n+    if model_hint:\n+        variants.add(model_hint)\n+        variants.add(model_hint.replace(\"_\", \"\"))\n+        variants.add(re.sub(r\"\\d+\", \"\", model_hint))\n+    if symbol_hint:\n+        prefix = _leading_symbol_prefix(symbol_hint)\n+        if prefix:\n+            variants.add(prefix)\n+            variants.add(prefix.replace(\"_\", \"\"))\n+            variants.add(re.sub(r\"\\d+\", \"\", prefix))\n+    variants |= {variant.lower() for variant in list(variants)}\n+    sanitized = base\n+    for variant in sorted({x for x in variants if len(x) >= 3}, key=len, reverse=True):\n+        sanitized = re.sub(re.escape(variant), \"Model\", sanitized, flags=re.IGNORECASE)\n+    return sanitized\n+\n+\n+class CodeSimilarityAnalyzer:\n+    \"\"\"\n+    Analyzer for detecting code similarities between model implementations.\n+\n+    This class uses embedding-based and token-based similarity metrics to identify similar\n+    code patterns across different model definitions in the transformers library.\n+\n+    Args:\n+        hub_dataset (`str`): The Hub dataset repository ID containing the code embeddings index.\n+    \"\"\"\n+\n+    def __init__(self, hub_dataset: str):\n+        for name in (\"huggingface_hub\", \"httpx\", \"urllib3\", \"transformers\"):\n+            logging.getLogger(name).setLevel(logging.ERROR)\n+        huggingface_hub_logging.set_verbosity_error()\n+        transformers_logging.set_verbosity_error()\n+        torch.backends.cuda.matmul.allow_tf32 = True\n+        torch.set_grad_enabled(False)\n+\n+        self.models_root = MODELS_ROOT\n+        self.hub_dataset = hub_dataset\n+        self.device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n+        self.dtype = \"auto\"\n+        self.tokenizer = AutoTokenizer.from_pretrained(EMBEDDING_MODEL)\n+        self.model = (\n+            AutoModel.from_pretrained(\n+                EMBEDDING_MODEL,\n+                torch_dtype=self.dtype if self.device.type == \"cuda\" else torch.float32,\n+            )\n+            .eval()\n+            .to(self.device)\n+        )\n+\n+    # ---------- HUB IO ----------\n+\n+    def ensure_local_index(self) -> None:\n+        \"\"\"Download index files from Hub if they don't exist locally.\"\"\"\n+        have_all = Path(EMBEDDINGS_PATH).exists() and Path(INDEX_MAP_PATH).exists() and Path(TOKENS_PATH).exists()\n+        if have_all:\n+            return\n+        logging.info(f\"downloading index from hub: {self.hub_dataset}\")\n+        for fname in (EMBEDDINGS_PATH, INDEX_MAP_PATH, TOKENS_PATH):\n+            hf_hub_download(\n+                repo_id=self.hub_dataset,\n+                filename=fname,\n+                repo_type=\"dataset\",\n+                local_dir=\".\",\n+                local_dir_use_symlinks=False,\n+            )\n+\n+    def push_index_to_hub(self) -> None:\n+        \"\"\"Upload index files to the Hub dataset repository.\"\"\"\n+        api = HfApi()\n+        api.create_repo(repo_id=self.hub_dataset, repo_type=\"dataset\", exist_ok=True)\n+        for fname in (EMBEDDINGS_PATH, INDEX_MAP_PATH, TOKENS_PATH):\n+            logging.info(f\"pushing {fname} -> {self.hub_dataset}\")\n+            api.upload_file(\n+                path_or_fileobj=fname,\n+                path_in_repo=os.path.basename(fname),\n+                repo_id=self.hub_dataset,\n+                repo_type=\"dataset\",\n+            )\n+\n+    # ---------- parsing & encoding ----------\n+\n+    def _extract_definitions(\n+        self, file_path: Path, relative_to: Path | None = None, model_hint: str | None = None\n+    ) -> tuple[dict[str, str], dict[str, str], dict[str, list[str]]]:\n+        \"\"\"\n+        Extract class and function definitions from a Python file.\n+\n+        Args:\n+            file_path (`Path`): Path to the Python file to parse.\n+            relative_to (`Path` or `None`): Base path for computing relative identifiers.\n+            model_hint (`str` or `None`): Model name hint for sanitization.\n+\n+        Returns:\n+            `tuple[dict[str, str], dict[str, str], dict[str, list[str]]]`: A tuple containing:\n+                - definitions_raw: Mapping of identifiers to raw source code\n+                - definitions_sanitized: Mapping of identifiers to sanitized source code\n+                - definitions_tokens: Mapping of identifiers to sorted token lists\n+        \"\"\"\n+        definitions_raw = {}\n+        definitions_sanitized = {}\n+        definitions_tokens = {}\n+        source = file_path.read_text(encoding=\"utf-8\")\n+        lines = source.splitlines()\n+        tree = ast.parse(source)\n+        for node in ast.iter_child_nodes(tree):\n+            if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):\n+                segment = ast.get_source_segment(source, node)\n+                if segment is None and hasattr(node, \"lineno\") and hasattr(node, \"end_lineno\"):\n+                    start = max(0, node.lineno - 1)\n+                    end = node.end_lineno\n+                    segment = \"\\n\".join(lines[start:end])\n+                if segment:\n+                    identifier = (\n+                        f\"{file_path.relative_to(relative_to)}:{node.name}\"\n+                        if relative_to\n+                        else f\"{file_path.name}:{node.name}\"\n+                    )\n+                    definitions_raw[identifier] = segment\n+                    sanitized = _sanitize_for_embedding(segment, model_hint, node.name)\n+                    definitions_sanitized[identifier] = sanitized\n+                    definitions_tokens[identifier] = sorted(_tokenize(sanitized))\n+        return definitions_raw, definitions_sanitized, definitions_tokens\n+\n+    def _infer_model_from_relative_path(self, relative_path: Path) -> str | None:\n+        try:\n+            relative = relative_path.resolve().relative_to(self.models_root.resolve())\n+            return relative.parts[0]\n+        except Exception:\n+            return None\n+\n+    def _infer_query_model_name(self, modeling_file: Path) -> str | None:\n+        model = self._infer_model_from_relative_path(modeling_file)\n+        if model:\n+            return model\n+        stem = modeling_file.stem\n+        if stem.startswith(\"modeling_\") and len(stem) > len(\"modeling_\"):\n+            return stem[len(\"modeling_\") :]\n+        return None\n+\n+    def _encode_batch(self, texts: list[str]) -> np.ndarray:\n+        \"\"\"\n+        Encode a batch of texts into normalized embeddings.\n+\n+        Args:\n+            texts (`list[str]`): List of text strings to encode.\n+\n+        Returns:\n+            `np.ndarray`: Normalized embeddings as a float32 numpy array.\n+        \"\"\"\n+        encoded = self.tokenizer(texts, padding=True, truncation=True, max_length=MAX_LENGTH, return_tensors=\"pt\")\n+        encoded = {key: value.to(self.device) for key, value in encoded.items()}\n+        with (\n+            torch.autocast(device_type=self.device.type, dtype=self.dtype)\n+            if self.device.type == \"cuda\"\n+            else torch.no_grad()\n+        ):\n+            output = self.model(**encoded)\n+            if hasattr(output, \"last_hidden_state\"):\n+                embeddings = output.last_hidden_state\n+                mask = encoded[\"attention_mask\"].unsqueeze(-1)\n+                embeddings = (embeddings * mask).sum(dim=1) / mask.sum(dim=1).clamp_min(1e-9)\n+            elif hasattr(output, \"pooler_output\"):\n+                embeddings = output.pooler_output\n+            else:\n+                embeddings = output[0].mean(dim=1)\n+        embeddings = torch.nn.functional.normalize(embeddings.float(), p=2, dim=1)\n+        return embeddings.cpu().numpy().astype(\"float32\")\n+\n+    def encode(self, texts: list[str]) -> np.ndarray:\n+        \"\"\"\n+        Encode a list of texts into embeddings, processing in batches.\n+\n+        Args:\n+            texts (`list[str]`): List of text strings to encode.\n+\n+        Returns:\n+            `np.ndarray`: Stacked embeddings for all texts.\n+        \"\"\"\n+        output = []\n+        for i in tqdm(range(0, len(texts), BATCH_SIZE), desc=\"encode\", leave=False):\n+            output.append(self._encode_batch(texts[i : i + BATCH_SIZE]))\n+            if self.device.type == \"cuda\":\n+                torch.cuda.empty_cache()\n+        return np.vstack(output) if output else np.zeros((0, 0), dtype=\"float32\")\n+\n+    # ---------- build & search ----------\n+\n+    def build_index(self) -> None:\n+        \"\"\"Build the code similarity index from all modeling files and save to disk.\"\"\"\n+        logging.info(\"collecting files\")\n+        files = list(self.models_root.rglob(\"modeling_*.py\"))\n+        logging.info(f\"parsing {len(files)} files\")\n+\n+        identifiers = []\n+        sanitized_sources = []\n+        tokens_map = {}\n+\n+        for file_path in tqdm(files, desc=\"parse\", leave=False):\n+            model_hint = self._infer_model_from_relative_path(file_path)\n+            definitions_raw, definitions_sanitized, definitions_tokens = self._extract_definitions(\n+                file_path, self.models_root, model_hint\n+            )\n+            for identifier in definitions_sanitized.keys():\n+                identifiers.append(identifier)\n+                sanitized_sources.append(definitions_sanitized[identifier])\n+                tokens_map[identifier] = definitions_tokens[identifier]\n+\n+        logging.info(\n+            f\"encoding {len(sanitized_sources)} definitions with {EMBEDDING_MODEL} (device={self.device.type}, batch={BATCH_SIZE}, max_length={MAX_LENGTH})\"\n+        )\n+        embeddings = self.encode(sanitized_sources)\n+        safetensors_save({\"embeddings\": embeddings}, EMBEDDINGS_PATH)\n+        with open(INDEX_MAP_PATH, \"w\", encoding=\"utf-8\") as file:\n+            json.dump({int(i): identifiers[i] for i in range(len(identifiers))}, file)\n+        with open(TOKENS_PATH, \"w\", encoding=\"utf-8\") as file:\n+            json.dump(tokens_map, file)\n+\n+    def _topk_embedding(\n+        self,\n+        query_embedding_row: np.ndarray,\n+        base_embeddings: np.ndarray,\n+        identifier_map: dict[int, str],\n+        self_model_normalized: str,\n+        self_name: str,\n+        k: int,\n+    ) -> list[tuple[str, float]]:\n+        similarities = query_embedding_row @ base_embeddings.T\n+        indices = np.argpartition(-similarities, k + 32)[: k + 32]\n+        indices = indices[np.argsort(-similarities[indices])]\n+        output = []\n+        for match_id in indices:\n+            identifier = identifier_map[int(match_id)]\n+            parent_relative_path, match_name = identifier.split(\":\", 1)\n+            parent_model = Path(parent_relative_path).parts[0]\n+            if match_name == self_name:\n+                continue\n+            if self_model_normalized and _normalize(parent_model) == self_model_normalized:\n+                continue\n+            output.append((f\"{parent_model}::{match_name}\", float(similarities[match_id])))\n+            if len(output) >= k:\n+                break\n+        return output\n+\n+    def _topk_jaccard(\n+        self,\n+        query_tokens: set[str],\n+        identifiers: list[str],\n+        tokens_map: dict[str, list[str]],\n+        self_model_normalized: str,\n+        self_name: str,\n+        k: int,\n+    ) -> list[tuple[str, float]]:\n+        \"\"\"\n+        Find top-k most similar definitions using Jaccard similarity on token sets.\n+\n+        Args:\n+            query_tokens (`set[str]`): Set of tokens from the query definition.\n+            identifiers (`list[str]`): List of all definition identifiers in the index.\n+            tokens_map (`dict[str, list[str]]`): Mapping of identifiers to their token lists.\n+            self_model_normalized (`str`): Normalized name of the query model to exclude.\n+            self_name (`str`): Name of the query definition to exclude.\n+            k (`int`): Number of top results to return.\n+\n+        Returns:\n+            `list[tuple[str, float]]`: List of (identifier, score) tuples.\n+        \"\"\"\n+        scores = []\n+        for identifier in identifiers:\n+            parent_relative_path, match_name = identifier.split(\":\", 1)\n+            parent_model = Path(parent_relative_path).parts[0]\n+            if match_name == self_name:\n+                continue\n+            if self_model_normalized and _normalize(parent_model) == self_model_normalized:\n+                continue\n+            tokens = set(tokens_map.get(identifier, []))\n+            if not tokens or not query_tokens:\n+                continue\n+            score = len(query_tokens & tokens) / len(query_tokens | tokens)\n+            if score > 0:\n+                scores.append((f\"{parent_model}::{match_name}\", score))\n+        scores.sort(key=lambda x: x[1], reverse=True)\n+        return scores[:k]\n+\n+    def analyze_file(\n+        self, modeling_file: Path, top_k_per_item: int = 5, allow_hub_fallback: bool = True\n+    ) -> dict[str, dict[str, list]]:\n+        \"\"\"\n+        Analyze a modeling file and find similar code definitions in the index.\n+\n+        Args:\n+            modeling_file (`Path`): Path to the modeling file to analyze.\n+            top_k_per_item (`int`, *optional*, defaults to 5): Number of top matches to return per definition.\n+            allow_hub_fallback (`bool`, *optional*, defaults to `True`): Whether to download index from Hub if not found locally.\n+\n+        Returns:\n+            `dict[str, dict[str, list]]`: Dictionary mapping definition names to their similarity results.\n+                Each result contains 'embedding', 'jaccard', and 'intersection' keys.\n+        \"\"\"\n+        if allow_hub_fallback:\n+            self.ensure_local_index()\n+\n+        base = safetensors_load(EMBEDDINGS_PATH)\n+        base_embeddings = base[\"embeddings\"]\n+        with open(INDEX_MAP_PATH, \"r\", encoding=\"utf-8\") as file:\n+            identifier_map = {int(key): value for key, value in json.load(file).items()}\n+        identifiers = [identifier_map[i] for i in range(len(identifier_map))]\n+        with open(TOKENS_PATH, \"r\", encoding=\"utf-8\") as file:\n+            tokens_map = json.load(file)\n+\n+        self_model = self._infer_query_model_name(modeling_file)\n+        definitions_raw, definitions_sanitized, _ = self._extract_definitions(modeling_file, None, self_model)\n+        query_identifiers = list(definitions_raw.keys())\n+        query_sources_sanitized = [definitions_sanitized[key] for key in query_identifiers]\n+        query_tokens_list = [set(_tokenize(source)) for source in query_sources_sanitized]\n+        self_model_normalized = _normalize(self_model)\n+\n+        logging.info(\n+            f\"encoding {len(query_sources_sanitized)} query definitions with {EMBEDDING_MODEL} (device={self.device.type}, batch={BATCH_SIZE}, max_length={MAX_LENGTH})\"\n+        )\n+        query_embeddings = self.encode(query_sources_sanitized)\n+\n+        output = {}\n+        for i, query_identifier in enumerate(query_identifiers):\n+            query_name = query_identifier.split(\":\")[-1]\n+            embedding_top = self._topk_embedding(\n+                query_embeddings[i], base_embeddings, identifier_map, self_model_normalized, query_name, top_k_per_item\n+            )\n+            jaccard_top = self._topk_jaccard(\n+                query_tokens_list[i], identifiers, tokens_map, self_model_normalized, query_name, top_k_per_item\n+            )\n+            embedding_set = {identifier for identifier, _ in embedding_top}\n+            jaccard_set = {identifier for identifier, _ in jaccard_top}\n+            intersection = list(embedding_set & jaccard_set)\n+            output[query_name] = {\"embedding\": embedding_top, \"jaccard\": jaccard_top, \"intersection\": intersection}\n+        return output\n+\n+\n+def main():\n+    \"\"\"CLI entry point for the modular model detector.\"\"\"\n+    logging.basicConfig(level=logging.INFO, format=\"%(message)s\")\n+    parser = argparse.ArgumentParser(prog=\"hf-code-sim\")\n+    parser.add_argument(\"--build\", action=\"store_true\")\n+    parser.add_argument(\"--modeling-file\", type=str)\n+    parser.add_argument(\n+        \"--push-new-index\", action=\"store_true\", help=\"After --build, push index files to a Hub dataset.\"\n+    )\n+    parser.add_argument(\n+        \"--hub-dataset\", type=str, default=HUB_DATASET_DEFAULT, help=\"Hub dataset repo id to pull/push the index.\"\n+    )\n+    args = parser.parse_args()\n+\n+    analyzer = CodeSimilarityAnalyzer(hub_dataset=args.hub_dataset)\n+\n+    if args.build:\n+        analyzer.build_index()\n+        if args.push_new_index:\n+            analyzer.push_index_to_hub()\n+        return\n+\n+    if not args.modeling_file:\n+        raise SystemExit(\"Provide --modeling-file or use --build\")\n+\n+    results = analyzer.analyze_file(Path(args.modeling_file), top_k_per_item=5, allow_hub_fallback=True)\n+    modeling_filename = Path(args.modeling_file).name\n+    for query_name, data in results.items():\n+        logging.info(f\"{modeling_filename}::{query_name}:\")\n+        logging.info(\"  embedding:\")\n+        for identifier, score in data[\"embedding\"]:\n+            logging.info(f\"    {identifier} ({score:.4f})\")\n+        logging.info(\"  jaccard:\")\n+        for identifier, score in data[\"jaccard\"]:\n+            logging.info(f\"    {identifier} ({score:.4f})\")\n+        logging.info(\"  intersection:\")\n+        for identifier in data[\"intersection\"]:\n+            logging.info(f\"    {identifier}\")\n+        logging.info(\"\")\n+\n+\n+if __name__ == \"__main__\":\n+    main()"
        },
        {
            "sha": "d53f5120be1afd1e3f9af22cc80c41a75fa6191a",
            "filename": "utils/release.py",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/huggingface/transformers/blob/cd4422922e1dbca89edef1b9b597b1c296634e3a/utils%2Frelease.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/cd4422922e1dbca89edef1b9b597b1c296634e3a/utils%2Frelease.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Frelease.py?ref=cd4422922e1dbca89edef1b9b597b1c296634e3a",
            "patch": "@@ -53,6 +53,7 @@\n # All paths are defined with the intent that this script should be run from the root of the repo.\n PATH_TO_EXAMPLES = \"examples/\"\n PATH_TO_MODELS = \"src/transformers/models\"\n+PATH_TO_UTILS = \"utils\"\n # This maps a type of file to the pattern to look for when searching where the version is defined, as well as the\n # template to follow when replacing it with the new version.\n REPLACE_PATTERNS = {\n@@ -142,6 +143,13 @@ def remove_conversion_scripts():\n         conversion_script.unlink()\n \n \n+def remove_internal_utils():\n+    \"\"\"\n+    Delete internal utils that should not be included in releases for security reasons.\n+    \"\"\"\n+    (Path(PATH_TO_UTILS) / \"modular_model_detector.py\").unlink()\n+\n+\n def get_version() -> packaging.version.Version:\n     \"\"\"\n     Reads the current version in the main __init__.\n@@ -180,8 +188,9 @@ def pre_release_work(patch: bool = False):\n \n     print(f\"Updating version to {version}.\")\n     global_version_update(version, patch=patch)\n-    print(\"Deleting conversion scripts.\")\n+    print(\"Deleting conversion and internal utils scripts.\")\n     remove_conversion_scripts()\n+    remove_internal_utils()\n \n \n def post_release_work():"
        }
    ],
    "stats": {
        "total": 678,
        "additions": 677,
        "deletions": 1
    }
}