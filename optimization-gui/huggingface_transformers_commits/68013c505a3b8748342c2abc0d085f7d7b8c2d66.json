{
    "author": "manueldeprada",
    "message": "Improve Gemma3n model and tests (#39764)",
    "sha": "68013c505a3b8748342c2abc0d085f7d7b8c2d66",
    "files": [
        {
            "sha": "e993693c93e4b02e5d9d5c829a2dc62ef831f321",
            "filename": "src/transformers/cache_utils.py",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/68013c505a3b8748342c2abc0d085f7d7b8c2d66/src%2Ftransformers%2Fcache_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/68013c505a3b8748342c2abc0d085f7d7b8c2d66/src%2Ftransformers%2Fcache_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fcache_utils.py?ref=68013c505a3b8748342c2abc0d085f7d7b8c2d66",
            "patch": "@@ -1017,6 +1017,9 @@ def __init__(\n                     \"sliding_attention\" if sliding_window is not None else \"full_attention\"\n                     for _ in range(config.num_hidden_layers)\n                 ]\n+            # Some models have shared layers thus no cache is needed for them (e.g. Gemma3n)\n+            if hasattr(config, \"num_kv_shared_layers\"):\n+                layer_types = layer_types[: -config.num_kv_shared_layers]\n \n             for layer_type in layer_types:\n                 if layer_type in (\"sliding_attention\", \"chunked_attention\"):\n@@ -1128,6 +1131,9 @@ def __init__(\n                 layer_types = [\"chunked_attention\" for _ in range(config.num_hidden_layers)]\n             else:\n                 layer_types = [\"full_attention\" for _ in range(config.num_hidden_layers)]\n+        # Some models have shared layers thus no cache is needed for them (e.g. Gemma3n)\n+        if hasattr(config, \"num_kv_shared_layers\"):\n+            layer_types = layer_types[: -config.num_kv_shared_layers]\n \n         layers = []\n         for layer_type in layer_types:"
        },
        {
            "sha": "1cb2e1f7c7b29e8eee7bfb28162474afad7f39fe",
            "filename": "src/transformers/models/gemma3n/configuration_gemma3n.py",
            "status": "modified",
            "additions": 9,
            "deletions": 5,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/68013c505a3b8748342c2abc0d085f7d7b8c2d66/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fconfiguration_gemma3n.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/68013c505a3b8748342c2abc0d085f7d7b8c2d66/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fconfiguration_gemma3n.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fconfiguration_gemma3n.py?ref=68013c505a3b8748342c2abc0d085f7d7b8c2d66",
            "patch": "@@ -156,12 +156,13 @@ class Gemma3nTextConfig(PretrainedConfig):\n             The number of layer that share KV cache values. During the forward pass, the last `num_kv_shared_layers`\n             layers in the model \"share\" the KV values in that each local and global layer in this range uses the KV\n             cache values computed for the last local or global layer, respectively, before entering this range. The\n-            value should be `num_kv_shared_layers` should be a scalar of `sliding_window_pattern`.\n+            value should be a multiple of the attention pattern size (see `layer_types` parameter).\n         laurel_rank (int, *optional*, defaults to 64):\n             The intermediate size for the linear projections in the Learned Augmented Residual Layer.\n-        activation_sparsity_pattern (Sequence[float], *optional*, defaults to `(0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)`):\n+        activation_sparsity_pattern (Sequence[float], *optional*):\n             The sparsity factor used to extract the top-k activations for a given layer. The provided Sequence must\n-            explicitly provide a sparsity value for each layer in the model.\n+            explicitly provide a sparsity value for each layer in the model. By default, the first 10 layers are\n+            sparse with a sparsity factor of 0.95 and the rest are dense.\n \n     ```python\n     >>> from transformers import Gemma3nTextModel, Gemma3nTextConfig\n@@ -227,7 +228,7 @@ def __init__(\n         altup_num_inputs: int = 4,\n         num_kv_shared_layers: int = 15,\n         laurel_rank: int = 64,\n-        activation_sparsity_pattern: Optional[Union[float, Sequence[float]]] = (0.95,) * 10 + (0.0,) * 25,\n+        activation_sparsity_pattern: Optional[Union[float, Sequence[float]]] = None,\n         **kwargs,\n     ):\n         super().__init__(\n@@ -289,7 +290,10 @@ def __init__(\n         self.laurel_rank = laurel_rank\n \n         if activation_sparsity_pattern is None:\n-            activation_sparsity_pattern = [0.0] * num_hidden_layers\n+            num_sparse_layers = 10 if num_hidden_layers > 10 else 0\n+            activation_sparsity_pattern = (0.95,) * num_sparse_layers + (0.0,) * (\n+                num_hidden_layers - num_sparse_layers\n+            )\n \n         if (len_asp := len(activation_sparsity_pattern)) != num_hidden_layers:\n             raise ValueError("
        },
        {
            "sha": "c2f05d5d689500c573e8b42450ae1b1a2664e370",
            "filename": "src/transformers/models/gemma3n/modeling_gemma3n.py",
            "status": "modified",
            "additions": 25,
            "deletions": 23,
            "changes": 48,
            "blob_url": "https://github.com/huggingface/transformers/blob/68013c505a3b8748342c2abc0d085f7d7b8c2d66/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fmodeling_gemma3n.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/68013c505a3b8748342c2abc0d085f7d7b8c2d66/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fmodeling_gemma3n.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fmodeling_gemma3n.py?ref=68013c505a3b8748342c2abc0d085f7d7b8c2d66",
            "patch": "@@ -30,7 +30,7 @@\n import torch.nn.functional as F\n \n from ...activations import ACT2FN\n-from ...cache_utils import Cache, DynamicCache, SlidingWindowLayer\n+from ...cache_utils import Cache, DynamicCache\n from ...generation import GenerationMixin\n from ...masking_utils import create_causal_mask, create_sliding_window_causal_mask\n from ...modeling_flash_attention_utils import FlashAttentionKwargs\n@@ -1299,13 +1299,17 @@ def __init__(self, config: Gemma3nTextConfig, layer_idx: int):\n \n         first_kv_shared_layer_idx = self.config.num_hidden_layers - self.config.num_kv_shared_layers\n         self.is_kv_shared_layer = layer_idx >= first_kv_shared_layer_idx > 0\n-        # Find the index of the last sliding or full layer before sharing starts (or None if no sharing)\n-        layer_type = config.layer_types[layer_idx]\n-        self.kv_shared_layer_index = (\n-            first_kv_shared_layer_idx - 1 - config.layer_types[first_kv_shared_layer_idx - 1 :: -1].index(layer_type)\n-            if self.is_kv_shared_layer\n-            else None\n-        )\n+        prev_layers = config.layer_types[:first_kv_shared_layer_idx]\n+        if self.is_kv_shared_layer:\n+            # For shared layers, find the last non-shared layer of the same type before sharing starts\n+            self.kv_shared_layer_index = len(prev_layers) - 1 - prev_layers[::-1].index(config.layer_types[layer_idx])\n+            self.store_full_length_kv = False\n+        else:\n+            self.kv_shared_layer_index = None\n+            # For non-shared layers, store full-length kv if this is the last non-shared layer of its type\n+            self.store_full_length_kv = layer_idx == len(prev_layers) - 1 - prev_layers[::-1].index(\n+                config.layer_types[layer_idx]\n+            )\n \n     @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n     def forward(\n@@ -1327,21 +1331,12 @@ def forward(\n         query_states = apply_rotary_pos_emb(query_states, cos, sin, unsqueeze_dim=2)\n         query_states = query_states.transpose(1, 2)\n \n-        if self.is_kv_shared_layer and self.kv_shared_layer_index is not None and past_key_values is not None:\n-            # In this case we need special handling of the slice as the layer is of fixed small size (for full layers, we never go beyond)\n-            layer = past_key_values.layers[self.kv_shared_layer_index]\n+        # For layers with shared KV (from kv sharing point onwards), we reuse the same keys/values states as the last non-sharing layer\n+        if self.is_kv_shared_layer and past_key_values is not None:\n+            key_states, value_states = past_key_values.shared_layers[self.kv_shared_layer_index]\n             # Device of past layer may be different from current one\n-            indices = cache_position.to(layer.keys.device)\n-            # Sliding window cache layers might have smaller size (for full layers, we never go beyond)\n-            if isinstance(layer, SlidingWindowLayer):\n-                if cache_position.shape[0] > layer.get_max_cache_shape():\n-                    indices = slice(0, layer.get_max_cache_shape())\n-                else:\n-                    indices = indices.clamp(min=0, max=layer.get_max_cache_shape() - 1)\n-\n-            # Device of past layer may be different from current one\n-            key_states = layer.keys[:, :, indices].to(query_states.device)\n-            value_states = layer.values[:, :, indices].to(query_states.device)\n+            key_states = key_states.to(query_states.device)\n+            value_states = value_states.to(query_states.device)\n         else:\n             key_states = self.k_proj(hidden_states).view(hidden_shape)\n             key_states = self.k_norm(key_states)\n@@ -1360,7 +1355,14 @@ def forward(\n                 \"cache_position\": cache_position,\n                 \"sliding_window\": self.sliding_window,\n             }\n-            key_states, value_states = past_key_values.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+            if not self.is_kv_shared_layer:\n+                key_states, value_states = past_key_values.update(\n+                    key_states, value_states, self.layer_idx, cache_kwargs\n+                )\n+            if self.store_full_length_kv:\n+                if not hasattr(past_key_values, \"shared_layers\"):\n+                    past_key_values.shared_layers = {}\n+                past_key_values.shared_layers[self.layer_idx] = key_states, value_states\n \n         attention_interface: Callable = eager_attention_forward\n         if self.config._attn_implementation != \"eager\":"
        },
        {
            "sha": "6118752144b8d6b796d0dfa3aa05b36f2fec8ee0",
            "filename": "src/transformers/models/gemma3n/modular_gemma3n.py",
            "status": "modified",
            "additions": 34,
            "deletions": 28,
            "changes": 62,
            "blob_url": "https://github.com/huggingface/transformers/blob/68013c505a3b8748342c2abc0d085f7d7b8c2d66/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fmodular_gemma3n.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/68013c505a3b8748342c2abc0d085f7d7b8c2d66/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fmodular_gemma3n.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fmodular_gemma3n.py?ref=68013c505a3b8748342c2abc0d085f7d7b8c2d66",
            "patch": "@@ -23,7 +23,7 @@\n import torch.nn.functional as F\n \n from ...activations import ACT2FN\n-from ...cache_utils import Cache, DynamicCache, SlidingWindowLayer\n+from ...cache_utils import Cache, DynamicCache\n from ...configuration_utils import PretrainedConfig, layer_type_validation\n from ...masking_utils import create_causal_mask, create_sliding_window_causal_mask\n from ...modeling_flash_attention_utils import FlashAttentionKwargs\n@@ -184,12 +184,13 @@ class Gemma3nTextConfig(Gemma2Config, PretrainedConfig):\n             The number of layer that share KV cache values. During the forward pass, the last `num_kv_shared_layers`\n             layers in the model \"share\" the KV values in that each local and global layer in this range uses the KV\n             cache values computed for the last local or global layer, respectively, before entering this range. The\n-            value should be `num_kv_shared_layers` should be a scalar of `sliding_window_pattern`.\n+            value should be a multiple of the attention pattern size (see `layer_types` parameter).\n         laurel_rank (int, *optional*, defaults to 64):\n             The intermediate size for the linear projections in the Learned Augmented Residual Layer.\n-        activation_sparsity_pattern (Sequence[float], *optional*, defaults to `(0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)`):\n+        activation_sparsity_pattern (Sequence[float], *optional*):\n             The sparsity factor used to extract the top-k activations for a given layer. The provided Sequence must\n-            explicitly provide a sparsity value for each layer in the model.\n+            explicitly provide a sparsity value for each layer in the model. By default, the first 10 layers are\n+            sparse with a sparsity factor of 0.95 and the rest are dense.\n \n     ```python\n     >>> from transformers import Gemma3nTextModel, Gemma3nTextConfig\n@@ -240,7 +241,7 @@ def __init__(\n         altup_num_inputs: int = 4,\n         num_kv_shared_layers: int = 15,\n         laurel_rank: int = 64,\n-        activation_sparsity_pattern: Optional[Union[float, Sequence[float]]] = (0.95,) * 10 + (0.0,) * 25,\n+        activation_sparsity_pattern: Optional[Union[float, Sequence[float]]] = None,\n         **kwargs,\n     ):\n         PretrainedConfig.__init__(\n@@ -302,7 +303,10 @@ def __init__(\n         self.laurel_rank = laurel_rank\n \n         if activation_sparsity_pattern is None:\n-            activation_sparsity_pattern = [0.0] * num_hidden_layers\n+            num_sparse_layers = 10 if num_hidden_layers > 10 else 0\n+            activation_sparsity_pattern = (0.95,) * num_sparse_layers + (0.0,) * (\n+                num_hidden_layers - num_sparse_layers\n+            )\n \n         if (len_asp := len(activation_sparsity_pattern)) != num_hidden_layers:\n             raise ValueError(\n@@ -1746,13 +1750,17 @@ def __init__(self, config: Gemma3nTextConfig, layer_idx: int):\n \n         first_kv_shared_layer_idx = self.config.num_hidden_layers - self.config.num_kv_shared_layers\n         self.is_kv_shared_layer = layer_idx >= first_kv_shared_layer_idx > 0\n-        # Find the index of the last sliding or full layer before sharing starts (or None if no sharing)\n-        layer_type = config.layer_types[layer_idx]\n-        self.kv_shared_layer_index = (\n-            first_kv_shared_layer_idx - 1 - config.layer_types[first_kv_shared_layer_idx - 1 :: -1].index(layer_type)\n-            if self.is_kv_shared_layer\n-            else None\n-        )\n+        prev_layers = config.layer_types[:first_kv_shared_layer_idx]\n+        if self.is_kv_shared_layer:\n+            # For shared layers, find the last non-shared layer of the same type before sharing starts\n+            self.kv_shared_layer_index = len(prev_layers) - 1 - prev_layers[::-1].index(config.layer_types[layer_idx])\n+            self.store_full_length_kv = False\n+        else:\n+            self.kv_shared_layer_index = None\n+            # For non-shared layers, store full-length kv if this is the last non-shared layer of its type\n+            self.store_full_length_kv = layer_idx == len(prev_layers) - 1 - prev_layers[::-1].index(\n+                config.layer_types[layer_idx]\n+            )\n \n     @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n     def forward(\n@@ -1774,21 +1782,12 @@ def forward(\n         query_states = apply_rotary_pos_emb(query_states, cos, sin, unsqueeze_dim=2)\n         query_states = query_states.transpose(1, 2)\n \n-        if self.is_kv_shared_layer and self.kv_shared_layer_index is not None and past_key_values is not None:\n-            # In this case we need special handling of the slice as the layer is of fixed small size (for full layers, we never go beyond)\n-            layer = past_key_values.layers[self.kv_shared_layer_index]\n+        # For layers with shared KV (from kv sharing point onwards), we reuse the same keys/values states as the last non-sharing layer\n+        if self.is_kv_shared_layer and past_key_values is not None:\n+            key_states, value_states = past_key_values.shared_layers[self.kv_shared_layer_index]\n             # Device of past layer may be different from current one\n-            indices = cache_position.to(layer.keys.device)\n-            # Sliding window cache layers might have smaller size (for full layers, we never go beyond)\n-            if isinstance(layer, SlidingWindowLayer):\n-                if cache_position.shape[0] > layer.get_max_cache_shape():\n-                    indices = slice(0, layer.get_max_cache_shape())\n-                else:\n-                    indices = indices.clamp(min=0, max=layer.get_max_cache_shape() - 1)\n-\n-            # Device of past layer may be different from current one\n-            key_states = layer.keys[:, :, indices].to(query_states.device)\n-            value_states = layer.values[:, :, indices].to(query_states.device)\n+            key_states = key_states.to(query_states.device)\n+            value_states = value_states.to(query_states.device)\n         else:\n             key_states = self.k_proj(hidden_states).view(hidden_shape)\n             key_states = self.k_norm(key_states)\n@@ -1807,7 +1806,14 @@ def forward(\n                 \"cache_position\": cache_position,\n                 \"sliding_window\": self.sliding_window,\n             }\n-            key_states, value_states = past_key_values.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+            if not self.is_kv_shared_layer:\n+                key_states, value_states = past_key_values.update(\n+                    key_states, value_states, self.layer_idx, cache_kwargs\n+                )\n+            if self.store_full_length_kv:\n+                if not hasattr(past_key_values, \"shared_layers\"):\n+                    past_key_values.shared_layers = {}\n+                past_key_values.shared_layers[self.layer_idx] = key_states, value_states\n \n         attention_interface: Callable = eager_attention_forward\n         if self.config._attn_implementation != \"eager\":"
        },
        {
            "sha": "89d2880cd5c33655106de497a65d0e44c9a54bbe",
            "filename": "src/transformers/models/gemma3n/processing_gemma3n.py",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/68013c505a3b8748342c2abc0d085f7d7b8c2d66/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fprocessing_gemma3n.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/68013c505a3b8748342c2abc0d085f7d7b8c2d66/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fprocessing_gemma3n.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fprocessing_gemma3n.py?ref=68013c505a3b8748342c2abc0d085f7d7b8c2d66",
            "patch": "@@ -24,10 +24,6 @@\n \n \n class Gemma3nImagesKwargs(ImagesKwargs):\n-    do_pan_and_scan: Optional[bool]\n-    pan_and_scan_min_crop_size: Optional[int]\n-    pan_and_scan_max_num_crops: Optional[int]\n-    pan_and_scan_min_ratio_to_activate: Optional[float]\n     do_convert_rgb: Optional[bool]\n \n "
        },
        {
            "sha": "f5115efc59caccaa2d4c7009cd3b2953fddbaccd",
            "filename": "tests/models/gemma3n/test_modeling_gemma3n.py",
            "status": "modified",
            "additions": 322,
            "deletions": 81,
            "changes": 403,
            "blob_url": "https://github.com/huggingface/transformers/blob/68013c505a3b8748342c2abc0d085f7d7b8c2d66/tests%2Fmodels%2Fgemma3n%2Ftest_modeling_gemma3n.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/68013c505a3b8748342c2abc0d085f7d7b8c2d66/tests%2Fmodels%2Fgemma3n%2Ftest_modeling_gemma3n.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgemma3n%2Ftest_modeling_gemma3n.py?ref=68013c505a3b8748342c2abc0d085f7d7b8c2d66",
            "patch": "@@ -14,6 +14,8 @@\n # limitations under the License.\n \"\"\"Testing suite for the PyTorch Gemma3n model.\"\"\"\n \n+import copy\n+import inspect\n import tempfile\n import unittest\n \n@@ -26,11 +28,13 @@\n     AutoModelForCausalLM,\n     AutoProcessor,\n     AutoTokenizer,\n+    Cache,\n     Gemma3nAudioConfig,\n     Gemma3nAudioFeatureExtractor,\n     Gemma3nConfig,\n     Gemma3nTextConfig,\n     GenerationConfig,\n+    StaticCache,\n     is_torch_available,\n )\n from transformers.testing_utils import (\n@@ -39,11 +43,14 @@\n     require_read_token,\n     require_torch,\n     require_torch_gpu,\n+    set_config_for_less_flaky_test,\n+    set_model_for_less_flaky_test,\n     slow,\n     torch_device,\n )\n+from transformers.utils import is_flash_attn_2_available\n \n-from ...generation.test_utils import GenerationTesterMixin\n+from ...generation.test_utils import GenerationTesterMixin, has_similar_generate_outputs\n from ...test_configuration_common import ConfigTester\n from ...test_modeling_common import (\n     TEST_EAGER_MATCHES_SDPA_INFERENCE_PARAMETERIZATION,\n@@ -370,6 +377,13 @@ def _check_hidden_states_for_generate(\n                 [expected_shape] * len(iter_hidden_states),\n             )\n \n+    @require_flash_attn\n+    @require_torch_gpu\n+    @pytest.mark.flash_attn_test\n+    @slow\n+    def test_flash_attn_2_inference_equivalence_right_padding(self):\n+        self.skipTest(reason=\"Gemma3n flash attention does not support right padding\")\n+\n     @parameterized.expand(TEST_EAGER_MATCHES_SDPA_INFERENCE_PARAMETERIZATION)\n     def test_eager_matches_sdpa_inference(\n         self,\n@@ -433,6 +447,274 @@ def test_eager_padding_matches_padding_free_with_position_ids(self):\n     def test_sdpa_padding_matches_padding_free_with_position_ids(self):\n         pass\n \n+    @unittest.skip(\"Gemma3n only support fp16 and bf16 data type\")\n+    def test_flash_attn_2_fp32_ln(self):\n+        pass\n+\n+    @pytest.mark.generate\n+    def test_generate_from_inputs_embeds_with_static_cache(self):\n+        \"\"\"\n+        Test that StaticCache can generate from inputs_embeds and calculates max_cache_length\n+        correctly in `generate()`. We force the model to not stop generation until max-length is reached\n+        to verify that the cache length is indeed set correctly and we don't run out of index when slicing the cache.\n+        \"\"\"\n+        for model_class in self.all_generative_model_classes:\n+            # Here, we should ideally not skip any model, and test them all. However, some old models cannot correctly\n+            # use a static cache because they don't create the causal masks correctly.\n+            # TODO: cyril -> relax this by adding a `_support_static_cache` attribute\n+            if not model_class._can_compile_fullgraph:\n+                self.skipTest(reason=\"This model does not support the static cache format\")\n+\n+            config, inputs_dict = self.prepare_config_and_inputs_for_generate()\n+\n+            if config.get_text_config(decoder=True).is_encoder_decoder:\n+                self.skipTest(reason=\"This model is encoder-decoder and has Encoder-Decoder Cache\")\n+\n+            model = model_class(config).to(torch_device).eval()\n+            if \"inputs_embeds\" not in inspect.signature(model.prepare_inputs_for_generation).parameters:\n+                self.skipTest(reason=\"This model does not support `inputs_embeds` in generation\")\n+\n+            input_ids = inputs_dict.pop(\"input_ids\")\n+\n+            model.config.use_cache = True\n+            model.config.is_decoder = True\n+            batch_size = input_ids.shape[0]\n+            max_new_tokens = 10\n+\n+            # here we force to not stop at eos and go until max-length\n+            model.generation_config.eos_token_id = model.config.get_text_config().eos_token_id = -1\n+            generation_kwargs = {\n+                \"max_new_tokens\": max_new_tokens,\n+                \"cache_implementation\": \"static\",\n+                \"return_dict_in_generate\": True,  # Required to return `past_key_values`\n+            }\n+\n+            text_config = model.config.get_text_config()\n+            head_dim = (\n+                getattr(text_config, \"head_dim\", None) or text_config.hidden_size // text_config.num_attention_heads\n+            )\n+            num_key_value_heads = (\n+                text_config.num_attention_heads\n+                if getattr(text_config, \"num_key_value_heads\", None) is None\n+                else text_config.num_key_value_heads\n+            )\n+            num_hidden_layers = text_config.num_hidden_layers\n+\n+            inputs_embeds = model.get_input_embeddings()(input_ids)\n+            outputs = model.generate(inputs_embeds=inputs_embeds, **generation_kwargs, **inputs_dict)\n+\n+            # we should get `max_length - 1` in shape, not `max_length - embeds_length`.\n+            # -1 because the last generated token isn't yet in the cache.\n+            max_length = max_new_tokens + inputs_embeds.shape[1] - 1\n+            cache_shape = [batch_size, num_key_value_heads, max_length, head_dim]\n+            self.assertIsInstance(outputs.past_key_values, StaticCache)\n+            self.assertEqual(len(outputs.past_key_values), num_hidden_layers - text_config.num_kv_shared_layers)\n+            self.assertListEqual(list(outputs.past_key_values.layers[0].keys.shape), cache_shape)\n+\n+    @pytest.mark.generate\n+    def test_generate_with_static_cache(self):\n+        \"\"\"\n+        Tests that generating with static cache give almost same results as with dynamic cache, and the output cache\n+        has the expected shapes\n+        \"\"\"\n+        for model_class in self.all_generative_model_classes:\n+            # Here, we should ideally not skip any model, and test them all. However, some old models cannot correctly\n+            # use a static cache because they don't create the causal masks correctly.\n+            # TODO: cyril -> relax this by adding a `_support_static_cache` attribute\n+            if not model_class._can_compile_fullgraph:\n+                self.skipTest(reason=\"This model does not support the static cache format\")\n+\n+            config, inputs_dict = self.prepare_config_and_inputs_for_generate()\n+            set_config_for_less_flaky_test(config)\n+            main_input = inputs_dict[model_class.main_input_name]\n+\n+            if config.get_text_config(decoder=True).is_encoder_decoder:\n+                self.skipTest(reason=\"This model is encoder-decoder and has Encoder-Decoder Cache\")\n+\n+            config.is_decoder = True\n+            batch_size = main_input.shape[0]\n+            seq_length = self.model_tester.seq_length\n+            max_new_tokens = 20\n+\n+            for dtype in (torch.float32, torch.float16):\n+                model = model_class(copy.deepcopy(config)).to(torch_device).to(dtype).eval()\n+                inputs_dict = {\n+                    k: v.to(dtype) if isinstance(v, torch.Tensor) and torch.is_floating_point(v) else v\n+                    for k, v in inputs_dict.items()\n+                }\n+                set_model_for_less_flaky_test(model)\n+\n+                generation_kwargs = {\n+                    \"max_new_tokens\": max_new_tokens,\n+                    \"return_dict_in_generate\": True,  # Required to return `past_key_values`\n+                    \"output_scores\": True,\n+                    \"use_cache\": True,\n+                }\n+\n+                static_cache_generation = model.generate(\n+                    **generation_kwargs, **inputs_dict, cache_implementation=\"static\"\n+                )\n+\n+                # Check 1: The cache shapes must match the expected shapes\n+                max_cache_len = seq_length + max_new_tokens - 1  # cache len = gen len - 1, the last token has no cache\n+                text_config = config.text_config if hasattr(config, \"text_config\") else config\n+                head_dim = (\n+                    getattr(text_config, \"head_dim\", None)\n+                    or text_config.hidden_size // text_config.num_attention_heads\n+                )\n+                num_key_value_heads = (\n+                    text_config.num_attention_heads\n+                    if getattr(text_config, \"num_key_value_heads\", None) is None\n+                    else text_config.num_key_value_heads\n+                )\n+                num_hidden_layers = text_config.num_hidden_layers\n+                cache_shape = (batch_size, num_key_value_heads, max_cache_len, head_dim)\n+                self.assertTrue(isinstance(static_cache_generation.past_key_values, StaticCache))\n+                self.assertTrue(\n+                    len(static_cache_generation.past_key_values)\n+                    == num_hidden_layers - text_config.num_kv_shared_layers\n+                )\n+                self.assertTrue(static_cache_generation.past_key_values.layers[0].keys.shape == cache_shape)\n+\n+                # Check 2: The outputs must be similar to the case with dynamic cache\n+                dynamic_cache_generation = model.generate(**generation_kwargs, **inputs_dict)\n+                self.assertTrue(has_similar_generate_outputs(dynamic_cache_generation, static_cache_generation))\n+\n+    @pytest.mark.generate\n+    def test_past_key_values_format(self, custom_all_cache_shapes=None):\n+        \"\"\"\n+        Test that the KV cache is formatted correctly. Exceptions need to explicitly overwrite this test, or pass the\n+        expected cache shapes.\n+        Having a standard KV cache format is important for a consistent API (and for advanced generation methods).\n+        \"\"\"\n+        for model_class in self.all_generative_model_classes:\n+            config, inputs = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+            # 1. If it doesn't support cache, skip the test\n+            if not hasattr(config.get_text_config(), \"use_cache\"):\n+                self.skipTest(reason=f\"{model_class.__name__} doesn't support caching\")\n+\n+            model = model_class(config).to(torch_device)\n+            model = model.eval()\n+            if \"use_cache\" not in inputs:\n+                inputs[\"use_cache\"] = True\n+            outputs = model(**inputs)\n+\n+            if \"past_key_values\" not in outputs:\n+                self.skipTest(reason=\"This model doesn't return `past_key_values`\")\n+\n+            # 2. retrieve the KV cache and compute its default expected shapes (if no custom shapes are provided)\n+            past_kv = outputs[\"past_key_values\"]\n+            is_legacy_cache = not isinstance(past_kv, Cache)\n+\n+            text_config = config.get_text_config()\n+            num_decoder_layers = (\n+                getattr(text_config, \"decoder_layers\", None)\n+                or getattr(text_config, \"num_decoder_layers\", None)\n+                or text_config.num_hidden_layers\n+            )\n+\n+            if custom_all_cache_shapes is None:\n+                num_query_attention_heads = getattr(\n+                    text_config, \"decoder_attention_heads\", text_config.num_attention_heads\n+                )\n+                embed_dim = getattr(text_config, \"d_model\", text_config.hidden_size)\n+                per_head_embed_dim = embed_dim // num_query_attention_heads\n+                num_key_value_heads = (\n+                    text_config.num_key_value_heads\n+                    if getattr(text_config, \"num_key_value_heads\", None) is not None\n+                    else num_query_attention_heads\n+                )\n+                if config.is_encoder_decoder:\n+                    encoder_num_attention_heads = (\n+                        text_config.encoder_attention_heads\n+                        if hasattr(text_config, \"encoder_attention_heads\")\n+                        else text_config.num_attention_heads\n+                    )\n+                    encoder_per_head_embed_dim = embed_dim // encoder_num_attention_heads\n+                    batch_size, seq_length = inputs[\"decoder_input_ids\"].shape[:2]\n+                    # The sequence length for the encoder K V depends on the model. Since it is not manipulated in\n+                    # autoregressive generation, we're keeping the test general and not checking the 3rd dim\n+                    default_cross_attention_shape = (\n+                        batch_size,\n+                        encoder_num_attention_heads,\n+                        encoder_per_head_embed_dim,\n+                    )\n+                    default_self_attention_shape = (batch_size, num_key_value_heads, seq_length, per_head_embed_dim)\n+                    all_cache_shapes = [\n+                        [\n+                            default_self_attention_shape,\n+                            default_self_attention_shape,\n+                            default_cross_attention_shape,\n+                            default_cross_attention_shape,\n+                        ]\n+                        for _ in range(num_decoder_layers)\n+                    ]\n+                else:\n+                    batch_size, seq_length = inputs[\"input_ids\"].shape[:2]\n+                    default_self_attention_shape = (batch_size, num_key_value_heads, seq_length, per_head_embed_dim)\n+                    all_cache_shapes = [\n+                        [default_self_attention_shape, default_self_attention_shape] for _ in range(num_decoder_layers)\n+                    ]\n+\n+            else:\n+                all_cache_shapes = custom_all_cache_shapes\n+\n+            # 3. Check cache shapes\n+            # 3.1. Encoder-Decoder checks\n+            if config.is_encoder_decoder:\n+                num_cache_decoder_layers = len(past_kv) if is_legacy_cache else len(past_kv.self_attention_cache)\n+                self.assertEqual(num_cache_decoder_layers, num_decoder_layers)\n+\n+                for i in range(num_decoder_layers):\n+                    if is_legacy_cache:\n+                        self.assertEqual(len(past_kv[0]), 4)  # legacy check: confirm number of elements in tuple\n+\n+                    # Self attention\n+                    self_attention_layer_keys = (\n+                        past_kv[i][0] if is_legacy_cache else past_kv.self_attention_cache.layers[i].keys\n+                    )\n+                    self_attention_layer_values = (\n+                        past_kv[i][1] if is_legacy_cache else past_kv.self_attention_cache.layers[i].values\n+                    )\n+                    self.assertEqual(self_attention_layer_keys.shape, all_cache_shapes[i][0])\n+                    self.assertEqual(self_attention_layer_values.shape, all_cache_shapes[i][1])\n+\n+                    # Cross attention (ignore 3rd dim, see default shape preparation)\n+                    cross_attention_layer_keys = (\n+                        past_kv[i][2] if is_legacy_cache else past_kv.cross_attention_cache.layers[i].keys\n+                    )\n+                    cross_attention_layer_values = (\n+                        past_kv[i][3] if is_legacy_cache else past_kv.cross_attention_cache.layers[i].values\n+                    )\n+                    cross_attention_layer_keys = cross_attention_layer_keys[:, :, 0, :]\n+                    cross_attention_layer_values = cross_attention_layer_values[:, :, 0, :]\n+                    self.assertEqual(cross_attention_layer_keys.shape, all_cache_shapes[i][2])\n+                    self.assertEqual(cross_attention_layer_values.shape, all_cache_shapes[i][3])\n+\n+            # 3.2. Decoder-only checks\n+            else:\n+                num_cache_decoder_layers = len(past_kv)\n+                self.assertEqual(num_cache_decoder_layers, num_decoder_layers - text_config.num_kv_shared_layers)\n+\n+                for i in range(num_decoder_layers - text_config.num_kv_shared_layers):\n+                    if is_legacy_cache:\n+                        self.assertEqual(len(past_kv[0]), 2)  # legacy check: confirm number of elements in tuple\n+\n+                    # Self attention\n+                    if is_legacy_cache:\n+                        self_attention_layer_keys = past_kv[i][0]\n+                        self_attention_layer_values = past_kv[i][1]\n+                    elif getattr(past_kv, \"layers\", None) is None:\n+                        # Cache is lot layered (i.e, Mamba derivatives)\n+                        self_attention_layer_keys = past_kv.key_cache[i]\n+                        self_attention_layer_values = past_kv.value_cache[i]\n+                    else:\n+                        self_attention_layer_keys = past_kv.layers[i].keys\n+                        self_attention_layer_values = past_kv.layers[i].values\n+                    self.assertEqual(self_attention_layer_keys.shape, all_cache_shapes[i][0])\n+                    self.assertEqual(self_attention_layer_values.shape, all_cache_shapes[i][1])\n+\n \n class Gemma3nVision2TextModelTester:\n     text_config = {\"activation_sparsity_pattern\": None}\n@@ -606,7 +888,6 @@ def test_automodelforcausallm(self):\n             self.assertIsInstance(for_causal_lm, Gemma3nForCausalLM)\n \n \n-@unittest.skip(\"Skipped for now!\")\n @slow\n @require_torch_gpu\n @require_read_token\n@@ -629,17 +910,16 @@ def setUp(self):\n         audio_ds = load_dataset(\n             \"etechgrid/28.5k_wavfiles_dataset\", \"default\", data_files=\"wav_dataset/103-1240-0000.wav\"\n         )\n-        self.audio_file_path = audio_ds[\"train\"][0][\"audio\"][\"path\"]\n+        self.audio_file_path = audio_ds[\"train\"][0][\"audio\"].metadata.path\n+        cleanup(torch_device, gc_collect=True)\n \n     def tearDown(self):\n         cleanup(torch_device, gc_collect=True)\n \n     def test_model_4b_bf16(self):\n         model_id = \"Google/gemma-3n-E4B-it\"\n \n-        model = Gemma3nForConditionalGeneration.from_pretrained(\n-            model_id, low_cpu_mem_usage=True, dtype=torch.bfloat16\n-        ).to(torch_device)\n+        model = Gemma3nForConditionalGeneration.from_pretrained(model_id, dtype=torch.bfloat16).to(torch_device)\n \n         inputs = self.processor.apply_chat_template(\n             self.messages,\n@@ -651,8 +931,7 @@ def test_model_4b_bf16(self):\n \n         output = model.generate(**inputs, max_new_tokens=30, do_sample=False)\n         output_text = self.processor.batch_decode(output, skip_special_tokens=True)\n-\n-        EXPECTED_TEXTS = ['user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\nWhat is shown in this image?\\nmodel\\nCertainly! \\n\\nThe image shows a brown cow standing on a sandy beach with clear blue water and a blue sky in the background. It looks like']  # fmt: skip\n+        EXPECTED_TEXTS = ['user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\nWhat is shown in this image?\\nmodel\\nThe image shows a brown and white cow standing on a sandy beach next to a clear blue ocean. The cow is facing the viewer with its head slightly']  # fmt: skip\n         self.assertEqual(output_text, EXPECTED_TEXTS)\n \n     def test_model_with_audio(self):\n@@ -664,8 +943,8 @@ def test_model_with_audio(self):\n         model_id = \"Google/gemma-3n-E4B-it\"\n \n         model = Gemma3nForConditionalGeneration.from_pretrained(\n-            model_id, low_cpu_mem_usage=True, dtype=torch.bfloat16\n-        ).to(torch_device)\n+            model_id, dtype=torch.bfloat16, device_map=torch_device\n+        )\n \n         messages = [\n             [\n@@ -701,8 +980,8 @@ def test_model_4b_batch(self):\n         model_id = \"Google/gemma-3n-E4B-it\"\n \n         model = Gemma3nForConditionalGeneration.from_pretrained(\n-            model_id, low_cpu_mem_usage=False, dtype=torch.bfloat16\n-        ).to(torch_device)\n+            model_id, dtype=torch.bfloat16, device_map=torch_device\n+        )\n \n         messages_2 = [\n             {\"role\": \"system\", \"content\": [{\"type\": \"text\", \"text\": \"You are a helpful assistant.\"}]},\n@@ -731,51 +1010,38 @@ def test_model_4b_batch(self):\n         output = model.generate(**inputs, max_new_tokens=30, do_sample=False)\n         output_text = self.processor.batch_decode(output, skip_special_tokens=True)\n \n-        EXPECTED_TEXTS = [\n-            'user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\nWhat is shown in this image?\\nmodel\\nCertainly! \\n\\nThe image shows a brown cow standing on a sandy beach with clear turquoise water and a blue sky in the background. It looks like',\n-            \"user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nAre these images identical?\\nmodel\\nNo, these images are not identical. \\n\\nHere's a breakdown of the differences:\\n\\n*   **Image 1:** Shows a cow\"\n-        ]  # fmt: skip\n+        EXPECTED_TEXTS = ['user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\nWhat is shown in this image?\\nmodel\\nThe image shows a brown and white cow standing on a sandy beach next to a clear blue ocean. The cow is facing the viewer with its head slightly', \"user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nAre these images identical?\\nmodel\\nNo, the images are not identical. \\n\\nHere's a breakdown of the differences:\\n\\n* **Subject:** The first image features a cow\"]  # fmt: skip\n         self.assertEqual(output_text, EXPECTED_TEXTS)\n \n-    def test_model_4b_crops(self):\n+    def test_model_4b_image(self):\n         model_id = \"Google/gemma-3n-E4B-it\"\n \n         model = Gemma3nForConditionalGeneration.from_pretrained(\n-            model_id, low_cpu_mem_usage=True, dtype=torch.bfloat16\n-        ).to(torch_device)\n-\n-        crop_config = {\n-            \"images_kwargs\": {\n-                \"do_pan_and_scan\": True,\n-                \"pan_and_scan_max_num_crops\": 448,\n-                \"pan_and_scan_min_crop_size\": 32,\n-                \"pan_and_scan_min_ratio_to_activate\": 0.3,\n-            }\n-        }\n+            model_id, dtype=torch.bfloat16, device_map=torch_device\n+        )\n \n         inputs = self.processor.apply_chat_template(\n             self.messages,\n             tokenize=True,\n             return_dict=True,\n             return_tensors=\"pt\",\n             add_generation_prompt=True,\n-            **crop_config,\n         ).to(torch_device)\n \n         output = model.generate(**inputs, max_new_tokens=30, do_sample=False)\n         output_text = self.processor.batch_decode(output, skip_special_tokens=True)\n \n-        EXPECTED_NUM_IMAGES = 3  # one for the origin image and two crops of images\n-        EXPECTED_TEXTS = ['user\\nYou are a helpful assistant.\\n\\nHere is the original image \\n\\n\\n\\n and here are some crops to help you see better \\n\\n\\n\\n \\n\\n\\n\\nWhat is shown in this image?\\nmodel\\nThe image shows a brown cow standing on a beach with a turquoise ocean and blue sky in the background.']  # fmt: skip\n+        EXPECTED_NUM_IMAGES = 1  # Gemma3n does not support crops\n+        EXPECTED_TEXTS = ['user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\nWhat is shown in this image?\\nmodel\\nThe image shows a brown and white cow standing on a sandy beach next to a clear blue ocean. The cow is facing the viewer with its head slightly']  # fmt: skip\n         self.assertEqual(len(inputs[\"pixel_values\"]), EXPECTED_NUM_IMAGES)\n         self.assertEqual(output_text, EXPECTED_TEXTS)\n \n     def test_model_4b_multiimage(self):\n         model_id = \"Google/gemma-3n-E4B-it\"\n \n         model = Gemma3nForConditionalGeneration.from_pretrained(\n-            model_id, low_cpu_mem_usage=True, dtype=torch.bfloat16\n-        ).to(torch_device)\n+            model_id, dtype=torch.bfloat16, device_map=torch_device\n+        )\n \n         messages = [\n             {\"role\": \"system\", \"content\": [{\"type\": \"text\", \"text\": \"You are a helpful assistant.\"}]},\n@@ -800,15 +1066,14 @@ def test_model_4b_multiimage(self):\n         output = model.generate(**inputs, max_new_tokens=30, do_sample=False)\n         output_text = self.processor.batch_decode(output, skip_special_tokens=True)\n \n-        EXPECTED_TEXTS = [\"user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\nWhat do you see here?\\nmodel\\nOkay, let's break down what I see in this image:\\n\\n**Overall Scene:**\\n\\nIt looks like a street scene in a vibrant,\"]  # fmt: skip\n+        EXPECTED_TEXTS = ['user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\nWhat do you see here?\\nmodel\\nIn the image, I see a street scene in what appears to be a Chinatown district. Here are some key elements:\\n\\n* **A prominent red']  # fmt: skip\n         self.assertEqual(output_text, EXPECTED_TEXTS)\n \n+    @unittest.skip(\"For now, using a gemma model with the 3n class is not supported\")\n     def test_model_1b_text_only(self):\n         model_id = \"google/gemma-3-1b-it\"\n \n-        model = Gemma3nForCausalLM.from_pretrained(model_id, low_cpu_mem_usage=True, dtype=torch.bfloat16).to(\n-            torch_device\n-        )\n+        model = Gemma3nForCausalLM.from_pretrained(model_id, dtype=torch.bfloat16, device_map=torch_device)\n         tokenizer = AutoTokenizer.from_pretrained(model_id, padding_side=\"left\")\n         inputs = tokenizer(\"Write a poem about Machine Learning.\", return_tensors=\"pt\").to(torch_device)\n \n@@ -818,38 +1083,17 @@ def test_model_1b_text_only(self):\n         EXPECTED_TEXTS = ['Write a poem about Machine Learning.\\n\\n---\\n\\nThe data flows, a river deep,\\nWith patterns hidden, secrets sleep.\\nA neural net, a watchful eye,\\nLearning']  # fmt: skip\n         self.assertEqual(output_text, EXPECTED_TEXTS)\n \n-    # TODO: raushan FA2 generates gibberish for no reason, check later\n-    @require_flash_attn\n-    @require_torch_gpu\n-    @pytest.mark.flash_attn_test\n-    def test_model_4b_flash_attn(self):\n-        model_id = \"Google/gemma-3n-E4B-it\"\n-\n-        model = Gemma3nForConditionalGeneration.from_pretrained(\n-            model_id, dtype=torch.bfloat16, attn_implementation=\"flash_attention_2\"\n-        ).to(torch_device)\n-\n-        inputs = self.processor.apply_chat_template(\n-            self.messages,\n-            tokenize=True,\n-            return_dict=True,\n-            return_tensors=\"pt\",\n-            add_generation_prompt=True,\n-        ).to(torch_device)\n-\n-        output = model.generate(**inputs, max_new_tokens=30, do_sample=False)\n-        output_text = self.processor.batch_decode(output, skip_special_tokens=True)\n-\n-        EXPECTED_TEXTS = ['user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\nWhat is shown in this image?\\nmodel\\nCertainly! \\n\\nThe image shows a brown and white cow standing on a sandy beach next to a turquoise ocean. It looks like a very sunny and']  # fmt: skip\n-        self.assertEqual(output_text, EXPECTED_TEXTS)\n-\n-    @parameterized.expand([(\"flash_attention_2\",), (\"sdpa\",), (\"eager\",)])\n+    @parameterized.expand([(\"sdpa\",), (\"eager\",), (\"flash_attention_2\",)])\n     def test_generation_beyond_sliding_window(self, attn_implementation: str):\n         \"\"\"Test that we can correctly generate beyond the sliding window. This is non trivial as\n         we need to correctly slice the attention mask in all cases (because we use a hybrid cache).\n         Outputs for every attention functions should be coherent and identical.\n         \"\"\"\n-        model_id = \"google/gemma-3-1b-it\"\n+\n+        if attn_implementation == \"flash_attention_2\" and not is_flash_attn_2_available():\n+            self.skipTest(\"Test requires Flash Attention\")\n+\n+        model_id = \"google/gemma-3n-E2B-it\"\n \n         input_text = [\n             \"This is a nice place. \" * 800 + \"I really enjoy the scenery,\",  # This is larger than 4096 tokens\n@@ -859,26 +1103,25 @@ def test_generation_beyond_sliding_window(self, attn_implementation: str):\n         inputs = tokenizer(input_text, padding=True, return_tensors=\"pt\").to(torch_device)\n \n         model = AutoModelForCausalLM.from_pretrained(\n-            model_id, attn_implementation=attn_implementation, dtype=torch.float16\n-        ).to(torch_device)\n+            model_id, attn_implementation=attn_implementation, dtype=torch.float16, device_map=torch_device\n+        )\n \n         # Make sure prefill is larger than sliding window\n         input_size = inputs.input_ids.shape[-1]\n-        self.assertTrue(input_size > model.config.sliding_window)\n+        self.assertTrue(input_size > model.config.get_text_config().sliding_window)\n \n-        out = model.generate(**inputs, max_new_tokens=20)[:, input_size:]\n+        out = model.generate(**inputs, max_new_tokens=20, do_sample=False)[:, input_size:]\n         output_text = tokenizer.batch_decode(out)\n \n-        EXPECTED_COMPLETIONS = [\" and I'm going to take a walk.\\n\\nI really enjoy the scenery, and I'\", \", green, yellow, orange, purple, brown, black, white, gray.\\n\\nI'\"]  # fmt: skip\n+        EXPECTED_COMPLETIONS = [\" and I think it's a nice place to visit. This is a nice place. This is\", \", green, yellow, orange, purple, pink, brown, black, white.\\n\\nHere'\"]  # fmt: skip\n         self.assertEqual(output_text, EXPECTED_COMPLETIONS)\n \n     def test_generation_beyond_sliding_window_with_generation_config(self):\n-        \"\"\"\n-        Same as `test_generation_beyond_sliding_window`, but passing a GenerationConfig. Regression test for #36684 --\n+        \"\"\"Same as `test_generation_beyond_sliding_window`, but passing a GenerationConfig. Regression test for #36684 --\n         ensures `cache_implementation='hybrid'` is correctly inherited from the base `model.generation_config`.\n         \"\"\"\n-        model_id = \"google/gemma-3-1b-it\"\n-        attn_implementation = \"sdpa\"\n+\n+        model_id = \"google/gemma-3n-E2B-it\"\n \n         input_text = [\n             \"This is a nice place. \" * 800 + \"I really enjoy the scenery,\",  # This is larger than 4096 tokens\n@@ -887,18 +1130,16 @@ def test_generation_beyond_sliding_window_with_generation_config(self):\n         tokenizer = AutoTokenizer.from_pretrained(model_id, padding=\"left\")\n         inputs = tokenizer(input_text, padding=True, return_tensors=\"pt\").to(torch_device)\n \n-        model = AutoModelForCausalLM.from_pretrained(\n-            model_id, attn_implementation=attn_implementation, dtype=torch.float16\n-        ).to(torch_device)\n+        model = AutoModelForCausalLM.from_pretrained(model_id, dtype=torch.float16, device_map=torch_device)\n \n         # Make sure prefill is larger than sliding window\n         input_size = inputs.input_ids.shape[-1]\n-        self.assertTrue(input_size > model.config.sliding_window)\n+        self.assertTrue(input_size > model.config.get_text_config().sliding_window)\n \n-        generation_config = GenerationConfig(max_new_tokens=20)\n-\n-        out = model.generate(**inputs, generation_config=generation_config)[:, input_size:]\n+        out = model.generate(**inputs, generation_config=GenerationConfig(max_new_tokens=20, do_sample=False))[\n+            :, input_size:\n+        ]\n         output_text = tokenizer.batch_decode(out)\n \n-        EXPECTED_COMPLETIONS = [\" and I'm going to take a walk.\\n\\nI really enjoy the scenery, and I'\", \", green, yellow, orange, purple, brown, black, white, gray.\\n\\nI'\"]  # fmt: skip\n+        EXPECTED_COMPLETIONS = [\" and I am glad to be here. This is a nice place. This is a nice place.\", \", green, yellow, purple, orange, pink, brown, black, white.\\n\\nHere are\"]  # fmt: skip\n         self.assertEqual(output_text, EXPECTED_COMPLETIONS)"
        }
    ],
    "stats": {
        "total": 537,
        "additions": 396,
        "deletions": 141
    }
}