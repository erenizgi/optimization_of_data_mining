{
    "author": "zucchini-nlp",
    "message": "[masking utils] check `None` instead of try/except (#38561)\n\n* fix vllm's compile backend\n\n* fix the test\n\n* apply the same changes in other masking strategies",
    "sha": "7c6b1707c344cbf4e0416d7c86de1471311c96cd",
    "files": [
        {
            "sha": "64676bbf8821bc9d1c9ca7161ea21218061ed4d8",
            "filename": "src/transformers/masking_utils.py",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c6b1707c344cbf4e0416d7c86de1471311c96cd/src%2Ftransformers%2Fmasking_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c6b1707c344cbf4e0416d7c86de1471311c96cd/src%2Ftransformers%2Fmasking_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmasking_utils.py?ref=7c6b1707c344cbf4e0416d7c86de1471311c96cd",
            "patch": "@@ -684,9 +684,9 @@ def create_causal_mask(\n             useful to easily overlay another mask on top of the causal one, for example for image tokens handling.\n     \"\"\"\n     # If we have an HybridCache structure, here we want to create the mask for the full layers\n-    try:\n-        layer_idx = past_key_values.is_sliding.index(False)\n-    except (ValueError, AttributeError):\n+    if past_key_values is not None and hasattr(past_key_values, \"is_sliding\"):\n+        layer_idx = past_key_values.is_sliding.index(False) if False in past_key_values.is_sliding else 0\n+    else:\n         layer_idx = 0\n \n     early_exit, attention_mask, kv_length, kv_offset = _preprocess_mask_arguments(\n@@ -765,10 +765,10 @@ def create_sliding_window_causal_mask(\n             An optional mask function to combine with the sliding causal mask function (by doing the intersection of both). This is\n             useful to easily overlay another mask on top of the sliding causal one, for example for image tokens handling.\n     \"\"\"\n-    # If we have an HybridCache structure, here we want to create the mask for the sliding layers\n-    try:\n-        layer_idx = past_key_values.is_sliding.index(True)\n-    except (ValueError, AttributeError):\n+    # If we have an HybridCache structure, here we want to create the mask for the full layers\n+    if past_key_values is not None and hasattr(past_key_values, \"is_sliding\"):\n+        layer_idx = past_key_values.is_sliding.index(False) if False in past_key_values.is_sliding else 0\n+    else:\n         layer_idx = 0\n \n     early_exit, attention_mask, kv_length, kv_offset = _preprocess_mask_arguments(\n@@ -852,10 +852,10 @@ def create_chunked_causal_mask(\n             An optional mask function to combine with the chunked causal mask function (by doing the intersection of both). This is\n             useful to easily overlay another mask on top of the chunked causal one, for example for image tokens handling.\n     \"\"\"\n-    # If we have an HybridCache structure, here we want to create the mask for the sliding layers\n-    try:\n-        layer_idx = past_key_values.is_sliding.index(True)\n-    except (ValueError, AttributeError):\n+    # If we have an HybridCache structure, here we want to create the mask for the full layers\n+    if past_key_values is not None and hasattr(past_key_values, \"is_sliding\"):\n+        layer_idx = past_key_values.is_sliding.index(False) if False in past_key_values.is_sliding else 0\n+    else:\n         layer_idx = 0\n \n     early_exit, attention_mask, kv_length, kv_offset = _preprocess_mask_arguments("
        }
    ],
    "stats": {
        "total": 22,
        "additions": 11,
        "deletions": 11
    }
}