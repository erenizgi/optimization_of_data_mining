{
    "author": "gerbenvv",
    "message": "Add a static cache that offloads to the CPU or other device (#32161)\n\n* Add a static cache that offloads to the CPU or other device\r\n\r\n* Fix PR comments, add unit-tests",
    "sha": "51296712900f28023cecea6ff7333af4b3c81d30",
    "files": [
        {
            "sha": "a81d202c6634af6e3512319c2632ab158f021248",
            "filename": "docs/source/en/internal/generation_utils.md",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/51296712900f28023cecea6ff7333af4b3c81d30/docs%2Fsource%2Fen%2Finternal%2Fgeneration_utils.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/51296712900f28023cecea6ff7333af4b3c81d30/docs%2Fsource%2Fen%2Finternal%2Fgeneration_utils.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Finternal%2Fgeneration_utils.md?ref=51296712900f28023cecea6ff7333af4b3c81d30",
            "patch": "@@ -390,6 +390,11 @@ A [`Constraint`] can be used to force the generation to include specific tokens\n     - get_seq_length\n     - reset\n \n+[[autodoc]] OffloadedStaticCache\n+    - update\n+    - get_seq_length\n+    - reset\n+\n [[autodoc]] HybridCache\n     - update\n     - get_seq_length"
        },
        {
            "sha": "1ae97497d2ffefd280e8dd4b25c9687d8ed75081",
            "filename": "docs/source/en/kv_cache.md",
            "status": "modified",
            "additions": 34,
            "deletions": 11,
            "changes": 45,
            "blob_url": "https://github.com/huggingface/transformers/blob/51296712900f28023cecea6ff7333af4b3c81d30/docs%2Fsource%2Fen%2Fkv_cache.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/51296712900f28023cecea6ff7333af4b3c81d30/docs%2Fsource%2Fen%2Fkv_cache.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fkv_cache.md?ref=51296712900f28023cecea6ff7333af4b3c81d30",
            "patch": "@@ -96,14 +96,15 @@ with the [`~DynamicCache`] class being the default cache for most models. It all\n \n Refer to the table below to see the difference between cache types and choose the one that suits best for your use-case.\n \n-| Cache Type          | Memory Efficient | Supports torch.compile() | Initialization Recommended | Latency  |  Long Context Generation |\n-|---------------------|------------------|--------------------------|----------------------------|----------|--------------------------|\n-| Dynamic Cache       |      No          |        No                |         No                 |   Mid    |     No                   |\n-| Static Cache        |      No          |        Yes               |         Yes                |   High   |     No                   |\n-| Quantized Cache     |      Yes         |        No                |         No                 |   Low    |     Yes                  |\n-| Offloaded Cache     |      Yes         |        No                |         No                 |   Low    |     No                   |\n-| Sliding Window Cache|      No          |        Yes               |         Yes                |   High   |     No                   |\n-| Sink Cache          |      Yes         |        No                |         Yes                |   Mid    |     Yes                  |\n+| Cache Type             | Memory Efficient | Supports torch.compile() | Initialization Recommended | Latency | Long Context Generation |\n+|------------------------|------------------|--------------------------|----------------------------|---------|-------------------------|\n+| Dynamic Cache          | No               | No                       | No                         | Mid     | No                      |\n+| Static Cache           | No               | Yes                      | Yes                        | High    | No                      |\n+| Offloaded Cache        | Yes              | No                       | No                         | Low     | Yes                     |\n+| Offloaded Static Cache | No               | Yes                      | Yes                        | High    | Yes                     |\n+| Quantized Cache        | Yes              | No                       | No                         | Low     | Yes                     |\n+| Sliding Window Cache   | No               | Yes                      | Yes                        | High    | No                      |\n+| Sink Cache             | Yes              | No                       | Yes                        | Mid     | Yes                     |\n \n \n These cache classes can be set with a `cache_implementation` argument when generating. To learn about the available options for the cache_implementation flag, please refer to the [API Documentation](./main_classes/text_generation.md#transformers.GenerationConfig). Now, let's explore each cache type in detail and see how to use them. Note that the below examples are for decoder-only Tranformer-based models. We also support [\"Model-Specific Cache\"] classes for models such as Mamba or Jamba, keep reading for more details.\n@@ -142,7 +143,7 @@ I like rock music because it's loud and energetic. It's a great way to express m\n I like rock music because it's loud and energetic. I like to listen to it when I'm feeling\n ```\n \n-## OffloadedCache\n+## Offloaded Cache\n \n Similarly to KV cache quantization, [`~OffloadedCache`] strategy aims to reduce GPU VRAM usage.\n It does so by moving the KV cache for most layers to the CPU.\n@@ -154,7 +155,8 @@ Thus, it can serve as a drop-in replacement or a fallback for it.\n Depending on your model and the characteristics of your generation task (size of context, number of generated tokens, number of beams, etc.)\n you may notice a small degradation in generation throughput compared to the default KV cache implementation.\n \n-To enable KV cache offloading, pass `cache_implementation=\"offloaded\"` in the `generation_config` or directky to the `generate()` call.\n+To enable KV cache offloading, pass `cache_implementation=\"offloaded\"` in the `generation_config` or directly to the `generate()` call.\n+Use `cache_implementation=\"offloaded_static\"` for an offloaded static cache (see also [Offloaded Static Cache](#offloaded-static-cache) below).\n \n ```python\n >>> import torch\n@@ -216,7 +218,6 @@ retrying with cache_implementation='offloaded'\n before successfully generating 40 beams.\n \n \n-\n ### Static Cache\n \n Since the \"DynamicCache\" dynamically grows with each generation step, it prevents you from taking advantage of JIT optimizations. The [`~StaticCache`] pre-allocates \n@@ -238,6 +239,28 @@ For more examples with Static Cache and JIT compilation, take a look at [StaticC\n \"Hello, my name is [Your Name], and I am a [Your Profession] with [Number of Years] of\"\n ```\n \n+\n+## Offloaded Static Cache\n+\n+Like [`~OffloadedCache`] exists for offloading a \"DynamicCache\", there is also an offloaded static cache. It fully supports\n+JIT optimizations. Just pass `cache_implementation=\"offloaded_static\"` in the `generation_config` or directly to the `generate()` call.\n+This will use the [`~OffloadedStaticCache`] implementation instead.\n+\n+```python\n+>>> import torch\n+>>> from transformers import AutoTokenizer, AutoModelForCausalLM\n+\n+>>> tokenizer = AutoTokenizer.from_pretrained(\"meta-llama/Llama-2-7b-chat-hf\")\n+>>> model = AutoModelForCausalLM.from_pretrained(\"meta-llama/Llama-2-7b-chat-hf\", torch_dtype=torch.float16, device_map=\"auto\")\n+>>> inputs = tokenizer(\"Hello, my name is\", return_tensors=\"pt\").to(model.device)\n+\n+>>> # simply pass the cache implementation=\"static\"\n+>>> out = model.generate(**inputs, do_sample=False, max_new_tokens=20, cache_implementation=\"offloaded_static\")\n+>>> tokenizer.batch_decode(out, skip_special_tokens=True)[0]\n+\"Hello, my name is [Your Name], and I am a [Your Profession] with [Number of Years] of\"\n+```\n+\n+\n ### Sliding Window Cache\n \n As the name suggests, this cache type implements a sliding window over previous keys and values, retaining only the last `sliding_window` tokens. It should be used with models like Mistral that support sliding window attention. Additionally, similar to Static Cache, this one is JIT-friendly and can be used with the same compile tecniques as Static Cache."
        },
        {
            "sha": "74870501f7987e4a196bb51b1f4f5b3a150cd2a6",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/51296712900f28023cecea6ff7333af4b3c81d30/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/51296712900f28023cecea6ff7333af4b3c81d30/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=51296712900f28023cecea6ff7333af4b3c81d30",
            "patch": "@@ -1246,6 +1246,7 @@\n         \"HybridCache\",\n         \"MambaCache\",\n         \"OffloadedCache\",\n+        \"OffloadedStaticCache\",\n         \"QuantizedCache\",\n         \"QuantizedCacheConfig\",\n         \"QuantoQuantizedCache\",\n@@ -6052,6 +6053,7 @@\n             HybridCache,\n             MambaCache,\n             OffloadedCache,\n+            OffloadedStaticCache,\n             QuantizedCache,\n             QuantizedCacheConfig,\n             QuantoQuantizedCache,"
        },
        {
            "sha": "80c36b9f68eeb6a46cdd8752688578dacba76b7f",
            "filename": "src/transformers/cache_utils.py",
            "status": "modified",
            "additions": 272,
            "deletions": 0,
            "changes": 272,
            "blob_url": "https://github.com/huggingface/transformers/blob/51296712900f28023cecea6ff7333af4b3c81d30/src%2Ftransformers%2Fcache_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/51296712900f28023cecea6ff7333af4b3c81d30/src%2Ftransformers%2Fcache_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fcache_utils.py?ref=51296712900f28023cecea6ff7333af4b3c81d30",
            "patch": "@@ -1708,3 +1708,275 @@ def update_ssm_state(self, layer_idx: int, new_ssm_state: torch.Tensor):\n     def reset(self):\n         self.conv_states.zero_()\n         self.ssm_states.zero_()\n+\n+\n+class OffloadedStaticCache(StaticCache):\n+    \"\"\"\n+    Static cache class to be used with `torch.compile(model)` that offloads to the CPU or\n+    another device.\n+\n+    Args:\n+        config (`PretrainedConfig):\n+            The configuration file defining the shape-related attributes required to initialize\n+            the static cache.\n+        max_batch_size (`int`):\n+            The maximum batch size with which the model will be used.\n+        max_cache_len (`int`):\n+            The maximum sequence length with which the model will be used.\n+        device (`Union[str, torch.device]`):\n+            The device on which the cache should be initialized. Should be the same as the\n+            layer device.\n+        dtype (`torch.dtype`, *optional*):\n+            The default `dtype` to use when initializing the cache.\n+        offload_device (`Union[str, torch.device]`, *optional*, defaults to `cpu`):\n+            The device to offload to. Defaults to CPU.\n+\n+    Attributes:\n+        key_cache (`List[torch.Tensor]`):\n+            Off-loaded key cache tensors. First one will be on device, where-as the others are\n+            off-loaded.\n+        value_cache (`List[torch.Tensor]`):\n+            Off-loaded value cache tensors. First one will be on device, where-as the others are\n+            off-loaded.\n+        max_batch_size (`int`):\n+            The maximum batch size with which this cache can be used.\n+        max_cache_len (`int`):\n+            The maximum sequence length with which this cache can be used.\n+        device (`torch.device`):\n+            The device on which the cache is used.\n+        offload_device (`torch.device`):\n+            The device used to offload to.\n+        dtype (`torch.dtype`):\n+            The `dtype` used to initializing the cache.\n+\n+    Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, AutoModelForCausalLM, OffloadedStaticCache\n+\n+        >>> model = AutoModelForCausalLM.from_pretrained(\"openai-community/gpt2\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"openai-community/gpt2\")\n+\n+        >>> inputs = tokenizer(text=\"My name is GPT2\", return_tensors=\"pt\")\n+\n+        >>> # Prepare a cache class and pass it to model's forward\n+        >>> # Leave empty space for 10 new tokens, which can be used when calling forward iteratively 10 times to generate\n+        >>> max_generated_length = inputs.input_ids.shape[1] + 10\n+        >>> past_key_values = OffloadedStaticCache(config=model.config, max_batch_size=1, max_cache_len=max_generated_length, device=model.device, dtype=model.dtype)\n+        >>> outputs = model(**inputs, past_key_values=past_key_values, use_cache=True)\n+        >>> past_kv_length = outputs.past_key_values # access cache filled with key/values from generation\n+        ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        config: PretrainedConfig,\n+        max_batch_size: int,\n+        max_cache_len: Optional[int],\n+        device: Union[str, torch.device],\n+        dtype: Optional[torch.dtype] = None,\n+        offload_device: Union[str, torch.device] = torch.device(\"cpu\"),\n+    ) -> None:\n+        self.max_batch_size = max_batch_size\n+        self.max_cache_len = config.max_position_embeddings if max_cache_len is None else max_cache_len\n+        self.device = torch.device(device)\n+        self.offload_device = torch.device(offload_device)\n+        self.dtype = dtype if dtype is not None else torch.float32\n+\n+        # Some model define a custom `head_dim` != config.hidden_size // config.num_attention_heads\n+        head_dim = config.head_dim if hasattr(config, \"head_dim\") else config.hidden_size // config.num_attention_heads\n+\n+        num_key_value_heads = (\n+            config.num_attention_heads if config.num_key_value_heads is None else config.num_key_value_heads\n+        )\n+\n+        cache_shape = (max_batch_size, num_key_value_heads, self.max_cache_len, head_dim)\n+\n+        # Create offloaded CPU tensors.\n+        self.key_cache: List[torch.Tensor] = []\n+        self.value_cache: List[torch.Tensor] = []\n+\n+        for i in range(config.num_hidden_layers):\n+            # First layer is always on-device.\n+            device = self.device if i == 0 else self.offload_device\n+\n+            key_cache, value_cache = self._create_key_value_cache_tensors(cache_shape, device)\n+\n+            self.key_cache.append(key_cache)\n+            self.value_cache.append(value_cache)\n+\n+        # Create device tensors.\n+        self._device_key_cache: List[torch.Tensor] = []\n+        self._device_value_cache: List[torch.Tensor] = []\n+\n+        for i in range(2):\n+            key_cache, value_cache = self._create_key_value_cache_tensors(cache_shape, self.device)\n+\n+            self._device_key_cache.append(key_cache)\n+            self._device_value_cache.append(value_cache)\n+\n+        # For backwards compatibility.\n+        # TODO(gante): Remove this.\n+        self._seen_tokens = 0\n+\n+        # Create new CUDA stream for parallel prefetching.\n+        self._prefetch_stream = torch.cuda.Stream() if self.device.type == \"cuda\" else None\n+\n+    def update(\n+        self,\n+        key_states: torch.Tensor,\n+        value_states: torch.Tensor,\n+        layer_idx: int,\n+        cache_kwargs: Optional[Dict[str, Any]] = None,\n+    ) -> Tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Updates the cache with the new `key_states` and `value_states` for the layer `layer_idx`.\n+        It is VERY important to index using a tensor, otherwise you introduce a copy to the device.\n+\n+        Parameters:\n+            key_states (`torch.Tensor`):\n+                The new key states to cache.\n+            value_states (`torch.Tensor`):\n+                The new value states to cache.\n+            layer_idx (`int`):\n+                The index of the layer to cache the states for.\n+            cache_kwargs (`Dict[str, Any]`, *optional*):\n+                Additional arguments for the cache subclass. The `OffloadedStaticCache` needs the\n+                `cache_position` input to know how where to write in the cache.\n+\n+        Return:\n+            A tuple containing the updated key and value states.\n+        \"\"\"\n+\n+        if layer_idx == 0:\n+            # Update seen tokens.\n+            # TODO(gante): Remove this.\n+            self._seen_tokens += key_states.shape[-2]\n+\n+            # Always there.\n+            k_out = self.key_cache[0]\n+            v_out = self.value_cache[0]\n+        else:\n+            # Wait for prefetch stream.\n+            if self._prefetch_stream is not None:\n+                torch.cuda.default_stream(self.device).wait_stream(self._prefetch_stream)\n+\n+            k_out = self._device_key_cache[layer_idx & 1]\n+            v_out = self._device_value_cache[layer_idx & 1]\n+\n+        self._prefetch_layer(layer_idx + 1)\n+\n+        cache_position = cache_kwargs.get(\"cache_position\") if cache_kwargs is not None else None\n+        if cache_position is None:\n+            k_out.copy_(key_states)\n+            v_out.copy_(value_states)\n+\n+            # Copy the values to the offloaded device as well.\n+            if layer_idx == 0:\n+                self.key_cache[layer_idx].copy_(key_states.to(self.offload_device))\n+                self.value_cache[layer_idx].copy_(value_states.to(self.offload_device))\n+        else:\n+            # Note: here we use `tensor.index_copy_(dim, index, tensor)` that is equivalent to\n+            # `tensor[:, :, index] = tensor`, but the first one is compile-friendly and it does\n+            # explicitly an in-place operation, that avoids copies and uses less memory.\n+            try:\n+                k_out.index_copy_(2, cache_position, key_states)\n+                v_out.index_copy_(2, cache_position, value_states)\n+            except NotImplementedError:\n+                # The operator 'aten::index_copy.out' is not currently implemented for the MPS\n+                # device.\n+                k_out[:, :, cache_position] = key_states\n+                v_out[:, :, cache_position] = value_states\n+\n+            # Copy the values to the offloaded device as well.\n+            if layer_idx != 0:\n+                cache_position = cache_position.to(self.offload_device)\n+                key_states = key_states.to(self.offload_device)\n+                value_states = value_states.to(self.offload_device)\n+\n+                try:\n+                    self.key_cache[layer_idx].index_copy_(2, cache_position, key_states)\n+                    self.value_cache[layer_idx].index_copy_(2, cache_position, value_states)\n+                except NotImplementedError:\n+                    # The operator 'aten::index_copy.out' is not currently implemented for the MPS\n+                    # device.\n+                    self.key_cache[layer_idx][:, :, cache_position] = key_states\n+                    self.value_cache[layer_idx][:, :, cache_position] = value_states\n+\n+        return k_out, v_out\n+\n+    def get_seq_length(self, layer_idx: Optional[int] = 0) -> int:\n+        \"\"\"Returns the sequence length of the cached states that were seen by the model.\"\"\"\n+\n+        # TODO(gante): Remove this.\n+        return self._seen_tokens\n+\n+    def get_max_length(self) -> Optional[int]:\n+        \"\"\"Returns the maximum sequence length of the cached states.\"\"\"\n+\n+        return self.max_cache_len\n+\n+    def reset(self) -> None:\n+        \"\"\"Resets the cache values while preserving the objects.\"\"\"\n+\n+        # For backwards compatibility.\n+        # TODO(gante): Remove this.\n+        self._seen_tokens = 0\n+\n+        # Zero out cache.\n+        for layer_idx in range(len(self.key_cache)):\n+            # In-place ops prevent breaking the static address.\n+            self.key_cache[layer_idx].zero_()\n+            self.value_cache[layer_idx].zero_()\n+\n+    @property\n+    def seen_tokens(self) -> int:\n+        # For backwards compatibility.\n+        # TODO(gante): Remove this.\n+        return self._seen_tokens\n+\n+    def _create_key_value_cache_tensors(\n+        self, shape: Tuple[int, ...], device: torch.device\n+    ) -> Tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"Creates K/V cache tensors on a device. Pins memory for CPU tensors. Marks them as static\n+        addresses for non-CPU tensors.\n+\n+        Args:\n+            shape (`Tuple[int, ...]`): Shape.\n+            device (`torch.device`): Device.\n+\n+        Returns:\n+            Key and value cache tensors as a tuple.\n+        \"\"\"\n+\n+        is_cpu_device = device == torch.device(\"cpu\")\n+\n+        key_cache = torch.zeros(shape, dtype=self.dtype, device=device, pin_memory=is_cpu_device)\n+        value_cache = torch.zeros(shape, dtype=self.dtype, device=device, pin_memory=is_cpu_device)\n+\n+        # Note: `mark_static_address` is used to tag the cache as a fixed data pointer,\n+        # preventing compiled graph breaks when updating the cache.\n+        torch._dynamo.mark_static_address(key_cache)\n+        torch._dynamo.mark_static_address(value_cache)\n+\n+        return key_cache, value_cache\n+\n+    def _prefetch_layer(self, layer_idx: int) -> None:\n+        \"\"\"Prefetch a layer to the device. Needs to be called in order of layer indices.\"\"\"\n+\n+        # Don't fetch layers that do not exist.\n+        if layer_idx >= len(self.key_cache):\n+            return\n+\n+        # Alternate between two on-device caches.\n+        if self._prefetch_stream is not None:\n+            with torch.cuda.stream(self._prefetch_stream):\n+                self._prefetch_layer_in_context(layer_idx)\n+        else:\n+            self._prefetch_layer_in_context(layer_idx)\n+\n+    def _prefetch_layer_in_context(self, layer_idx: int) -> None:\n+        \"\"\"Performs the actual copy of the layer to device cache.\"\"\"\n+\n+        self._device_key_cache[layer_idx & 1].copy_(self.key_cache[layer_idx], non_blocking=True)\n+        self._device_value_cache[layer_idx & 1].copy_(self.value_cache[layer_idx], non_blocking=True)"
        },
        {
            "sha": "c0fe3acb9eb32a96a68114aad6eab2d759836f15",
            "filename": "src/transformers/generation/utils.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/51296712900f28023cecea6ff7333af4b3c81d30/src%2Ftransformers%2Fgeneration%2Futils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/51296712900f28023cecea6ff7333af4b3c81d30/src%2Ftransformers%2Fgeneration%2Futils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Futils.py?ref=51296712900f28023cecea6ff7333af4b3c81d30",
            "patch": "@@ -33,6 +33,7 @@\n     HybridCache,\n     MambaCache,\n     OffloadedCache,\n+    OffloadedStaticCache,\n     QuantizedCacheConfig,\n     QuantoQuantizedCache,\n     SlidingWindowCache,\n@@ -119,6 +120,7 @@\n \n NEED_SETUP_CACHE_CLASSES_MAPPING = {\n     \"static\": StaticCache,\n+    \"offloaded_static\": OffloadedStaticCache,\n     \"sliding_window\": SlidingWindowCache,\n     \"hybrid\": HybridCache,\n     \"mamba\": MambaCache,"
        },
        {
            "sha": "26f6c8a4b56b840c7c17b758c8142c2e269d7407",
            "filename": "src/transformers/utils/dummy_pt_objects.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/51296712900f28023cecea6ff7333af4b3c81d30/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/51296712900f28023cecea6ff7333af4b3c81d30/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py?ref=51296712900f28023cecea6ff7333af4b3c81d30",
            "patch": "@@ -72,6 +72,13 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torch\"])\n \n \n+class OffloadedStaticCache(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n class QuantizedCache(metaclass=DummyObject):\n     _backends = [\"torch\"]\n "
        },
        {
            "sha": "0bb604c96f8c265812a85313a0a34fdba74b3b65",
            "filename": "tests/utils/test_cache_utils.py",
            "status": "modified",
            "additions": 28,
            "deletions": 8,
            "changes": 36,
            "blob_url": "https://github.com/huggingface/transformers/blob/51296712900f28023cecea6ff7333af4b3c81d30/tests%2Futils%2Ftest_cache_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/51296712900f28023cecea6ff7333af4b3c81d30/tests%2Futils%2Ftest_cache_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Futils%2Ftest_cache_utils.py?ref=51296712900f28023cecea6ff7333af4b3c81d30",
            "patch": "@@ -380,8 +380,15 @@ def test_sink_cache_iterative_prompts(self):\n         self.assertTrue(decoded[0].endswith(last_output))\n \n     @require_torch_gpu\n-    @parameterized.expand([\"eager\", \"sdpa\"])\n-    def test_static_cache_greedy_decoding_pad_left(self, attn_implementation):\n+    @parameterized.expand(\n+        [\n+            (\"eager\", \"static\"),\n+            (\"sdpa\", \"static\"),\n+            (\"eager\", \"offloaded-static\"),\n+            (\"sdpa\", \"offloaded-static\"),\n+        ]\n+    )\n+    def test_static_cache_greedy_decoding_pad_left(self, attn_implementation, cache_implementation):\n         EXPECTED_GENERATION = [\n             \"The best color is the one that complements the skin tone of the\",\n             \"We should not undermind the issues at hand.\\nWe should not undermind the issues\",\n@@ -406,7 +413,7 @@ def test_static_cache_greedy_decoding_pad_left(self, attn_implementation):\n             self.assertListEqual(decoded, EXPECTED_GENERATION)\n \n         set_seed(0)\n-        model.generation_config.cache_implementation = \"static\"\n+        model.generation_config.cache_implementation = cache_implementation\n         gen_out = model.generate(**inputs, do_sample=False, max_new_tokens=10)\n         decoded = tokenizer.batch_decode(gen_out, skip_special_tokens=True)\n         with self.subTest(f\"{attn_implementation}, static, eager\"):\n@@ -420,8 +427,15 @@ def test_static_cache_greedy_decoding_pad_left(self, attn_implementation):\n             self.assertListEqual(decoded, EXPECTED_GENERATION)\n \n     @require_torch_gpu\n-    @parameterized.expand([\"eager\", \"sdpa\"])\n-    def test_static_cache_greedy_decoding_pad_right(self, attn_implementation):\n+    @parameterized.expand(\n+        [\n+            (\"eager\", \"static\"),\n+            (\"sdpa\", \"static\"),\n+            (\"eager\", \"offloaded-static\"),\n+            (\"sdpa\", \"offloaded-static\"),\n+        ]\n+    )\n+    def test_static_cache_greedy_decoding_pad_right(self, attn_implementation, cache_implementation):\n         EXPECTED_GENERATION = [\n             \"The best color is–ã the one that complements the skin tone of\",\n             \"We should not undermind the issues at hand.\\nWe should not undermind the issues\",\n@@ -446,7 +460,7 @@ def test_static_cache_greedy_decoding_pad_right(self, attn_implementation):\n             self.assertListEqual(decoded, EXPECTED_GENERATION)\n \n         set_seed(0)\n-        model.generation_config.cache_implementation = \"static\"\n+        model.generation_config.cache_implementation = cache_implementation\n         gen_out = model.generate(**inputs, do_sample=False, max_new_tokens=10)\n         decoded = tokenizer.batch_decode(gen_out, skip_special_tokens=True)\n         with self.subTest(f\"{attn_implementation}, static, eager\"):\n@@ -506,7 +520,13 @@ def test_dynamic_cache_extra_left_padding(self):\n         decoded = tokenizer.batch_decode(gen_out, skip_special_tokens=True)\n         self.assertListEqual(decoded, EXPECTED_GENERATION)\n \n-    def test_static_cache_extra_left_padding(self):\n+    @parameterized.expand(\n+        [\n+            \"static\",\n+            \"offloaded-static\",\n+        ]\n+    )\n+    def test_static_cache_extra_left_padding(self, cache_implementation):\n         \"\"\"Tests that adding extra left-padding does not affect the generation with the static cache\"\"\"\n         EXPECTED_GENERATION = [\n             \"The best color is the one that complements the skin tone of the\",\n@@ -524,7 +544,7 @@ def test_static_cache_extra_left_padding(self):\n             [\"The best color is\", \"We should not undermind the issues at hand\"], padding=True, return_tensors=\"pt\"\n         ).to(model.device)\n \n-        model.generation_config.cache_implementation = \"static\"\n+        model.generation_config.cache_implementation = cache_implementation\n \n         gen_out = model.generate(**inputs, do_sample=False, max_new_tokens=10)\n         decoded = tokenizer.batch_decode(gen_out, skip_special_tokens=True)"
        }
    ],
    "stats": {
        "total": 369,
        "additions": 350,
        "deletions": 19
    }
}