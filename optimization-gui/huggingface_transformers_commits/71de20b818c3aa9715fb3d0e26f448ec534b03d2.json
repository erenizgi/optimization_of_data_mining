{
    "author": "Crystalcareai",
    "message": "Add Arcee model support (#38621)\n\n* Add Arcee model support to transformers\n\n- Add ArceeConfig and model mappings for all task types (CausalLM, SequenceClassification, QuestionAnswering, TokenClassification)\n- Add auto-loading support through AutoModel, AutoConfig, and AutoTokenizer\n- Use LlamaTokenizer for tokenization\n- Add FX graph support for Arcee models\n- Create lazy loading module structure for Arcee\n\n* feat: update YARN scaling and RoPE validation for Arcee model\n\n* feat: add auto_docstring checkpoint config to Arcee model classes\n\n* docs: add pre-trained model weights reference to Arcee configuration files\n\n* refactor: move RoPE utilities to dedicated modeling_rope_utils module\n\n* Add comprehensive test suite for Arcee model\n\n- Add test_modeling_arcee.py following standard transformers test patterns\n- Include tests for all model variants (CausalLM, SequenceClassification, QuestionAnswering, TokenClassification)\n- Add specific test for ReLUÂ² activation in ArceeMLP\n- Add RoPE scaling tests including YARN support\n- Follow CausalLMModelTest pattern used by similar models\n\n* Add documentation for Arcee model\n\n- Add comprehensive model documentation with usage examples\n- Include all model variants in autodoc\n- Add to table of contents in proper alphabetical order\n- Fixes documentation coverage for Arcee model classes\n\n* Make style/fixup\n\n* fix copyright year\n\n* Sync modular conversion\n\n* revert in legacy supported models in src/transformers/utils/fx\n\n* cleaned redundant code in modular_arcee.py\n\n* cleaned testing\n\n* removed pretraining tp\n\n* fix styles\n\n* integration testing\n\n---------\n\nCo-authored-by: Pranav <veldurthipranav@gmail.com>\nCo-authored-by: Pranav <56645758+pranav4501@users.noreply.github.com>",
    "sha": "71de20b818c3aa9715fb3d0e26f448ec534b03d2",
    "files": [
        {
            "sha": "6ebe8044ad48431e19bbca011a26cc77b45f700a",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/71de20b818c3aa9715fb3d0e26f448ec534b03d2/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/71de20b818c3aa9715fb3d0e26f448ec534b03d2/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=71de20b818c3aa9715fb3d0e26f448ec534b03d2",
            "patch": "@@ -363,6 +363,8 @@\n     - sections:\n       - local: model_doc/albert\n         title: ALBERT\n+      - local: model_doc/arcee\n+        title: Arcee\n       - local: model_doc/bamba\n         title: Bamba\n       - local: model_doc/bart"
        },
        {
            "sha": "520e9a05bf266f96153e9aa18533d44e7668844e",
            "filename": "docs/source/en/model_doc/arcee.md",
            "status": "added",
            "additions": 104,
            "deletions": 0,
            "changes": 104,
            "blob_url": "https://github.com/huggingface/transformers/blob/71de20b818c3aa9715fb3d0e26f448ec534b03d2/docs%2Fsource%2Fen%2Fmodel_doc%2Farcee.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/71de20b818c3aa9715fb3d0e26f448ec534b03d2/docs%2Fsource%2Fen%2Fmodel_doc%2Farcee.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Farcee.md?ref=71de20b818c3aa9715fb3d0e26f448ec534b03d2",
            "patch": "@@ -0,0 +1,104 @@\n+<!--Copyright 2025 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+<div style=\"float: right;\">\n+    <div class=\"flex flex-wrap space-x-1\">\n+        <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+        <img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+        <img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+    </div>\n+</div>\n+\n+# Arcee\n+\n+Arcee is a decoder-only transformer model based on the Llama architecture with a key modification: it uses ReLUÂ² (ReLU-squared) activation in the MLP blocks instead of SiLU, following recent research showing improved training efficiency with squared activations. This architecture is designed for efficient training and inference while maintaining the proven stability of the Llama design.\n+\n+The Arcee model is architecturally similar to Llama but uses `x * relu(x)` in MLP layers for improved gradient flow and is optimized for efficiency in both training and inference scenarios.\n+\n+> [!TIP]\n+> The Arcee model supports extended context with RoPE scaling and all standard transformers features including Flash Attention 2, SDPA, gradient checkpointing, and quantization support.\n+\n+The example below demonstrates how to generate text with Arcee using [`Pipeline`] or the [`AutoModel`].\n+\n+<hfoptions id=\"usage\">\n+<hfoption id=\"Pipeline\">\n+\n+```py\n+import torch\n+from transformers import pipeline\n+\n+pipeline = pipeline(\n+    task=\"text-generation\",\n+    model=\"arcee-ai/AFM-4.5B\",\n+    torch_dtype=torch.float16,\n+    device=0\n+)\n+\n+output = pipeline(\"The key innovation in Arcee is\")\n+print(output[0][\"generated_text\"])\n+```\n+\n+</hfoption>\n+<hfoption id=\"AutoModel\">\n+\n+```py\n+import torch\n+from transformers import AutoTokenizer, ArceeForCausalLM\n+\n+tokenizer = AutoTokenizer.from_pretrained(\"arcee-ai/AFM-4.5B\")\n+model = ArceeForCausalLM.from_pretrained(\n+    \"arcee-ai/AFM-4.5B\",\n+    torch_dtype=torch.float16,\n+    device_map=\"auto\"\n+)\n+\n+inputs = tokenizer(\"The key innovation in Arcee is\", return_tensors=\"pt\")\n+with torch.no_grad():\n+    outputs = model.generate(**inputs, max_new_tokens=50)\n+print(tokenizer.decode(outputs[0], skip_special_tokens=True))\n+```\n+\n+</hfoption>\n+</hfoptions>\n+\n+## ArceeConfig\n+\n+[[autodoc]] ArceeConfig\n+\n+## ArceeModel\n+\n+[[autodoc]] ArceeModel\n+    - forward\n+\n+## ArceeForCausalLM\n+\n+[[autodoc]] ArceeForCausalLM\n+    - forward\n+\n+## ArceeForSequenceClassification\n+\n+[[autodoc]] ArceeForSequenceClassification\n+    - forward\n+\n+## ArceeForQuestionAnswering\n+\n+[[autodoc]] ArceeForQuestionAnswering\n+    - forward\n+\n+## ArceeForTokenClassification\n+\n+[[autodoc]] ArceeForTokenClassification\n+    - forward\n\\ No newline at end of file"
        },
        {
            "sha": "504fcc268483b4c9d05992b817e3226118054489",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=71de20b818c3aa9715fb3d0e26f448ec534b03d2",
            "patch": "@@ -21,6 +21,7 @@\n     from .albert import *\n     from .align import *\n     from .altclip import *\n+    from .arcee import *\n     from .aria import *\n     from .audio_spectrogram_transformer import *\n     from .auto import *"
        },
        {
            "sha": "1c3df45b2a3b14a72b36362c87833298be8fce48",
            "filename": "src/transformers/models/arcee/__init__.py",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/huggingface/transformers/blob/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Farcee%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Farcee%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Farcee%2F__init__.py?ref=71de20b818c3aa9715fb3d0e26f448ec534b03d2",
            "patch": "@@ -0,0 +1,27 @@\n+# Copyright 2025 Arcee AI and the HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_arcee import *\n+    from .modeling_arcee import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "b74dd1a4fe519722d82eb8a65b3a12883f5db9a6",
            "filename": "src/transformers/models/arcee/configuration_arcee.py",
            "status": "added",
            "additions": 202,
            "deletions": 0,
            "changes": 202,
            "blob_url": "https://github.com/huggingface/transformers/blob/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Farcee%2Fconfiguration_arcee.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Farcee%2Fconfiguration_arcee.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Farcee%2Fconfiguration_arcee.py?ref=71de20b818c3aa9715fb3d0e26f448ec534b03d2",
            "patch": "@@ -0,0 +1,202 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/arcee/modular_arcee.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_arcee.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 Arcee AI and the HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...modeling_rope_utils import rope_config_validation\n+\n+\n+class ArceeConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`ArceeModel`]. It is used to instantiate an Arcee\n+    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n+    defaults will yield a similar configuration to that of the AFM-4.5B-Base.\n+\n+    Pre-trained weights are available at\n+    [arcee-ai/AFM-4.5B](https://huggingface.co/arcee-ai/AFM-4.5B)\n+    and were used to build the examples below.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 32000):\n+            Vocabulary size of the Arcee model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`ArceeModel`]\n+        hidden_size (`int`, *optional*, defaults to 2560):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 18432):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 32):\n+            Number of hidden layers in the Transformer decoder.\n+        num_attention_heads (`int`, *optional*, defaults to 32):\n+            Number of attention heads for each attention layer in the Transformer decoder.\n+        num_key_value_heads (`int`, *optional*):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to\n+            `num_attention_heads`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"relu2\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 4096):\n+            The maximum sequence length that this model might ever be used with. AFM-4.5B-Base supports up to 16384 tokens.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        pad_token_id (`int`, *optional*):\n+            Padding token id.\n+        bos_token_id (`int`, *optional*, defaults to 128000):\n+            Beginning of stream token id.\n+        eos_token_id (`int`, *optional*, defaults to 128001):\n+            End of stream token id.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether to tie weight embeddings\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'yarn'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'yarn'. The original max position embeddings used during pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn'. The scaling factor to be applied on the attention computation. If unspecified,\n+                    it defaults to value recommended by the implementation, using the `factor` field to infer the suggested value.\n+                `beta_fast` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for extrapolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 32.\n+                `beta_slow` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for interpolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 1.\n+        attention_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        mlp_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use a bias in up_proj, down_proj and gate_proj layers in the MLP layers.\n+        head_dim (`int`, *optional*):\n+            The attention head dimension. If None, it will default to hidden_size // num_attention_heads\n+\n+    ```python\n+    >>> from transformers import ArceeModel, ArceeConfig\n+\n+    >>> # Initializing an Arcee AFM-4.5B-Base style configuration\n+    >>> configuration = ArceeConfig()\n+\n+    >>> # Initializing a model from the AFM-4.5B-Base style configuration\n+    >>> model = ArceeModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"arcee\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.up_proj\": \"colwise\",\n+        \"layers.*.mlp.down_proj\": \"rowwise\",\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=32000,\n+        hidden_size=2560,\n+        intermediate_size=18432,\n+        num_hidden_layers=32,\n+        num_attention_heads=32,\n+        num_key_value_heads=None,\n+        hidden_act=\"relu2\",\n+        max_position_embeddings=4096,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-5,\n+        use_cache=True,\n+        pad_token_id=None,\n+        bos_token_id=128000,\n+        eos_token_id=128001,\n+        tie_word_embeddings=False,\n+        rope_theta=10000.0,\n+        rope_scaling=None,\n+        attention_bias=False,\n+        attention_dropout=0.0,\n+        mlp_bias=False,\n+        head_dim=None,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+        self.mlp_bias = mlp_bias\n+        self.head_dim = head_dim if head_dim is not None else self.hidden_size // self.num_attention_heads\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, copy it it to 'rope_type'.\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self)\n+\n+\n+__all__ = [\"ArceeConfig\"]"
        },
        {
            "sha": "e9d59eb4d802b5b621194e6fa4794f6ce5d1747b",
            "filename": "src/transformers/models/arcee/modeling_arcee.py",
            "status": "added",
            "additions": 839,
            "deletions": 0,
            "changes": 839,
            "blob_url": "https://github.com/huggingface/transformers/blob/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Farcee%2Fmodeling_arcee.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Farcee%2Fmodeling_arcee.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Farcee%2Fmodeling_arcee.py?ref=71de20b818c3aa9715fb3d0e26f448ec534b03d2",
            "patch": "@@ -0,0 +1,839 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/arcee/modular_arcee.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_arcee.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 Arcee AI and the HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import Callable, Optional, Union\n+\n+import torch\n+from torch import nn\n+\n+from transformers.utils import auto_docstring, logging\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...integrations import use_kernel_forward_from_hub\n+from ...masking_utils import create_causal_mask\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import (\n+    BaseModelOutputWithPast,\n+    CausalLMOutputWithPast,\n+    QuestionAnsweringModelOutput,\n+    SequenceClassifierOutputWithPast,\n+    TokenClassifierOutput,\n+)\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS, dynamic_rope_update\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import LossKwargs, can_return_tuple\n+from .configuration_arcee import ArceeConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class ArceeMLP(nn.Module):\n+    \"\"\"Arcee MLP with configurable activation function (typically relu2)\"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=config.mlp_bias)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=config.mlp_bias)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, x):\n+        return self.down_proj(self.act_fn(self.up_proj(x)))\n+\n+\n+@use_kernel_forward_from_hub(\"RMSNorm\")\n+class ArceeRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        ArceeRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+@auto_docstring\n+class ArceePreTrainedModel(PreTrainedModel):\n+    \"\"\"\n+    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n+    models.\n+    \"\"\"\n+\n+    config_class = ArceeConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"ArceeDecoderLayer\"]\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = True\n+    _supports_flex_attn = True\n+    _supports_cache_class = True\n+    _supports_quantized_cache = True\n+    _supports_static_cache = True\n+    _supports_attention_backend = True\n+\n+    def _init_weights(self, module):\n+        std = self.config.initializer_range\n+        if isinstance(module, nn.Linear):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+        elif isinstance(module, ArceeRMSNorm):\n+            module.weight.data.fill_(1.0)\n+\n+\n+class ArceeRotaryEmbedding(nn.Module):\n+    def __init__(self, config: ArceeConfig, device=None):\n+        super().__init__()\n+        # BC: \"rope_type\" was originally \"type\"\n+        if hasattr(config, \"rope_scaling\") and config.rope_scaling is not None:\n+            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n+        else:\n+            self.rope_type = \"default\"\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = self.inv_freq\n+\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1).to(x.device)\n+        position_ids_expanded = position_ids[:, None, :].float()\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(1, 2)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos() * self.attention_scaling\n+            sin = emb.sin() * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`, *optional*):\n+            Deprecated and unused.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    return q_embed, k_embed\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs,\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+class ArceeAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: ArceeConfig, layer_idx: int):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.head_dim = getattr(config, \"head_dim\", config.hidden_size // config.num_attention_heads)\n+        self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.attention_dropout = config.attention_dropout\n+        self.is_causal = True\n+\n+        self.q_proj = nn.Linear(\n+            config.hidden_size, config.num_attention_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.k_proj = nn.Linear(\n+            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.v_proj = nn.Linear(\n+            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.o_proj = nn.Linear(\n+            config.num_attention_heads * self.head_dim, config.hidden_size, bias=config.attention_bias\n+        )\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor], Optional[tuple[torch.Tensor]]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class ArceeDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: ArceeConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        self.self_attn = ArceeAttention(config=config, layer_idx=layer_idx)\n+\n+        self.mlp = ArceeMLP(config)\n+        self.input_layernorm = ArceeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = ArceeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: Optional[bool] = False,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,  # necessary, but kept here for BC\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> tuple[torch.FloatTensor, Optional[tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        residual = hidden_states\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # Self Attention\n+        hidden_states, self_attn_weights = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        outputs = (hidden_states,)\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        return outputs\n+\n+\n+@auto_docstring\n+class ArceeModel(ArceePreTrainedModel):\n+    \"\"\"\n+    Transformer decoder consisting of *config.num_hidden_layers* layers. Each layer is a [`ArceeDecoderLayer`]\n+\n+    Args:\n+        config: ArceeConfig\n+    \"\"\"\n+\n+    def __init__(self, config: ArceeConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [ArceeDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = ArceeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = ArceeRotaryEmbedding(config=config)\n+        self.gradient_checkpointing = False\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.embed_tokens = value\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **flash_attn_kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> BaseModelOutputWithPast:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if self.gradient_checkpointing and self.training and use_cache:\n+            logger.warning_once(\n+                \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`.\"\n+            )\n+            use_cache = False\n+\n+        # TODO (joao): remove this exception in v4.56 -- it exists for users that try to pass a legacy cache\n+        if not isinstance(past_key_values, (type(None), Cache)):\n+            raise ValueError(\"The `past_key_values` should be either a `Cache` object or `None`.\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache()\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+        )\n+\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            layer_outputs = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask,\n+                position_ids=position_ids,\n+                past_key_value=past_key_values,\n+                output_attentions=output_attentions,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                position_embeddings=position_embeddings,\n+                **flash_attn_kwargs,\n+            )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        # add hidden states from the last decoder layer\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values if use_cache else None,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+        )\n+\n+\n+class KwargsForCausalLM(FlashAttentionKwargs, LossKwargs): ...\n+\n+\n+@auto_docstring\n+class ArceeForCausalLM(ArceePreTrainedModel, GenerationMixin):\n+    \"\"\"Arcee Model transformer with a language modeling head on top (linear layer with weights tied to the input embeddings).\"\"\"\n+\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+    _tp_plan = {\"lm_head\": \"colwise_rep\"}\n+    _pp_plan = {\"lm_head\": ([\"hidden_states\"], [\"logits\"])}\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = ArceeModel(config)\n+        self.vocab_size = config.vocab_size\n+        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    def get_output_embeddings(self):\n+        return self.lm_head\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.lm_head = new_embeddings\n+\n+    def set_decoder(self, decoder):\n+        self.model = decoder\n+\n+    def get_decoder(self):\n+        return self.model\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[KwargsForCausalLM],\n+    ) -> CausalLMOutputWithPast:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, ArceeForCausalLM\n+\n+        >>> model = ArceeForCausalLM.from_pretrained(\"meta-arcee/Arcee-2-7b-hf\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"meta-arcee/Arcee-2-7b-hf\")\n+\n+        >>> prompt = \"Hey, are you conscious? Can you talk to me?\"\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"Hey, are you conscious? Can you talk to me?\\nI'm not conscious, but I can talk to you.\"\n+        ```\"\"\"\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+\n+        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n+        outputs: BaseModelOutputWithPast = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs.last_hidden_state\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits=logits, labels=labels, vocab_size=self.config.vocab_size, **kwargs)\n+\n+        return CausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+\n+@auto_docstring(checkpoint=\"arcee-ai/AFM-4.5B\")\n+class ArceeForSequenceClassification(ArceePreTrainedModel):\n+    \"\"\"\n+    The Arcee Model transformer with a sequence classification head on top (linear layer).\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.num_labels = config.num_labels\n+        self.model = ArceeModel(config)\n+        self.score = nn.Linear(config.hidden_size, self.num_labels, bias=False)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+    ) -> SequenceClassifierOutputWithPast:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n+            Labels for computing the sequence classification/regression loss. Indices should be in `[0, ...,\n+            config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If\n+            `config.num_labels > 1` a classification loss is computed (Cross-Entropy).\n+        \"\"\"\n+\n+        transformer_outputs: BaseModelOutputWithPast = self.model(\n+            input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+        )\n+        hidden_states = transformer_outputs.last_hidden_state\n+        logits = self.score(hidden_states)\n+\n+        if input_ids is not None:\n+            batch_size = input_ids.shape[0]\n+        else:\n+            batch_size = inputs_embeds.shape[0]\n+\n+        if self.config.pad_token_id is None and batch_size != 1:\n+            raise ValueError(\"Cannot handle batch sizes > 1 if no padding token is defined.\")\n+        if self.config.pad_token_id is None:\n+            last_non_pad_token = -1\n+        elif input_ids is not None:\n+            # To handle both left- and right- padding, we take the rightmost token that is not equal to pad_token_id\n+            non_pad_mask = (input_ids != self.config.pad_token_id).to(logits.device, torch.int32)\n+            token_indices = torch.arange(input_ids.shape[-1], device=logits.device, dtype=torch.int32)\n+            last_non_pad_token = (token_indices * non_pad_mask).argmax(-1)\n+        else:\n+            last_non_pad_token = -1\n+            logger.warning_once(\n+                f\"{self.__class__.__name__} will not detect padding tokens in `inputs_embeds`. Results may be \"\n+                \"unexpected if using padding tokens in conjunction with `inputs_embeds.`\"\n+            )\n+\n+        pooled_logits = logits[torch.arange(batch_size, device=logits.device), last_non_pad_token]\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits=logits, labels=labels, pooled_logits=pooled_logits, config=self.config)\n+\n+        return SequenceClassifierOutputWithPast(\n+            loss=loss,\n+            logits=pooled_logits,\n+            past_key_values=transformer_outputs.past_key_values,\n+            hidden_states=transformer_outputs.hidden_states,\n+            attentions=transformer_outputs.attentions,\n+        )\n+\n+\n+@auto_docstring(checkpoint=\"arcee-ai/AFM-4.5B\")\n+class ArceeForQuestionAnswering(ArceePreTrainedModel):\n+    \"\"\"\n+    The Arcee Model transformer with a span classification head on top for extractive question-answering tasks.\n+    \"\"\"\n+\n+    base_model_prefix = \"transformer\"\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.transformer = ArceeModel(config)\n+        self.qa_outputs = nn.Linear(config.hidden_size, 2)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.transformer.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.transformer.embed_tokens = value\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        start_positions: Optional[torch.LongTensor] = None,\n+        end_positions: Optional[torch.LongTensor] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        **kwargs,\n+    ) -> QuestionAnsweringModelOutput:\n+        outputs: BaseModelOutputWithPast = self.transformer(\n+            input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+        )\n+\n+        sequence_output = outputs.last_hidden_state\n+\n+        logits = self.qa_outputs(sequence_output)\n+        start_logits, end_logits = logits.split(1, dim=-1)\n+        start_logits = start_logits.squeeze(-1).contiguous()\n+        end_logits = end_logits.squeeze(-1).contiguous()\n+\n+        loss = None\n+        if start_positions is not None and end_positions is not None:\n+            loss = self.loss_function(start_logits, end_logits, start_positions, end_positions, **kwargs)\n+\n+        return QuestionAnsweringModelOutput(\n+            loss=loss,\n+            start_logits=start_logits,\n+            end_logits=end_logits,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+\n+@auto_docstring(checkpoint=\"arcee-ai/AFM-4.5B\")\n+class ArceeForTokenClassification(ArceePreTrainedModel):\n+    \"\"\"\n+    The Arcee Model transformer with a token classification head on top.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.num_labels = config.num_labels\n+        self.model = ArceeModel(config)\n+        if getattr(config, \"classifier_dropout\", None) is not None:\n+            classifier_dropout = config.classifier_dropout\n+        elif getattr(config, \"hidden_dropout\", None) is not None:\n+            classifier_dropout = config.hidden_dropout\n+        else:\n+            classifier_dropout = 0.1\n+        self.dropout = nn.Dropout(classifier_dropout)\n+        self.score = nn.Linear(config.hidden_size, config.num_labels)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+    ) -> TokenClassifierOutput:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n+            Labels for computing the sequence classification/regression loss. Indices should be in `[0, ...,\n+            config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If\n+            `config.num_labels > 1` a classification loss is computed (Cross-Entropy).\n+        \"\"\"\n+\n+        outputs: BaseModelOutputWithPast = self.model(\n+            input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+        )\n+        sequence_output = outputs.last_hidden_state\n+        sequence_output = self.dropout(sequence_output)\n+        logits = self.score(sequence_output)\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits, labels, self.config)\n+\n+        return TokenClassifierOutput(\n+            loss=loss,\n+            logits=logits,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+\n+__all__ = [\n+    \"ArceeForCausalLM\",\n+    \"ArceeForQuestionAnswering\",\n+    \"ArceeForSequenceClassification\",\n+    \"ArceeForTokenClassification\",\n+    \"ArceeModel\",\n+    \"ArceePreTrainedModel\",\n+]"
        },
        {
            "sha": "b77906ae3cecef74221185e6dee511f18a288736",
            "filename": "src/transformers/models/arcee/modular_arcee.py",
            "status": "added",
            "additions": 263,
            "deletions": 0,
            "changes": 263,
            "blob_url": "https://github.com/huggingface/transformers/blob/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Farcee%2Fmodular_arcee.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Farcee%2Fmodular_arcee.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Farcee%2Fmodular_arcee.py?ref=71de20b818c3aa9715fb3d0e26f448ec534b03d2",
            "patch": "@@ -0,0 +1,263 @@\n+# coding=utf-8\n+# Copyright 2025 Arcee AI and the HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch Arcee model.\"\"\"\n+\n+from transformers.utils import auto_docstring, logging\n+\n+from ..llama.configuration_llama import LlamaConfig\n+from ..llama.modeling_llama import (\n+    LlamaForCausalLM,\n+    LlamaForQuestionAnswering,\n+    LlamaForSequenceClassification,\n+    LlamaForTokenClassification,\n+    LlamaModel,\n+    LlamaPreTrainedModel,\n+)\n+from ..nemotron.modeling_nemotron import NemotronMLP\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class ArceeConfig(LlamaConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`ArceeModel`]. It is used to instantiate an Arcee\n+    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n+    defaults will yield a similar configuration to that of the AFM-4.5B-Base.\n+\n+    Pre-trained weights are available at\n+    [arcee-ai/AFM-4.5B](https://huggingface.co/arcee-ai/AFM-4.5B)\n+    and were used to build the examples below.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 32000):\n+            Vocabulary size of the Arcee model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`ArceeModel`]\n+        hidden_size (`int`, *optional*, defaults to 2560):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 18432):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 32):\n+            Number of hidden layers in the Transformer decoder.\n+        num_attention_heads (`int`, *optional*, defaults to 32):\n+            Number of attention heads for each attention layer in the Transformer decoder.\n+        num_key_value_heads (`int`, *optional*):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to\n+            `num_attention_heads`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"relu2\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 4096):\n+            The maximum sequence length that this model might ever be used with. AFM-4.5B-Base supports up to 16384 tokens.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        pad_token_id (`int`, *optional*):\n+            Padding token id.\n+        bos_token_id (`int`, *optional*, defaults to 128000):\n+            Beginning of stream token id.\n+        eos_token_id (`int`, *optional*, defaults to 128001):\n+            End of stream token id.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether to tie weight embeddings\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'yarn'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'yarn'. The original max position embeddings used during pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn'. The scaling factor to be applied on the attention computation. If unspecified,\n+                    it defaults to value recommended by the implementation, using the `factor` field to infer the suggested value.\n+                `beta_fast` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for extrapolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 32.\n+                `beta_slow` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for interpolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 1.\n+        attention_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        mlp_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use a bias in up_proj, down_proj and gate_proj layers in the MLP layers.\n+        head_dim (`int`, *optional*):\n+            The attention head dimension. If None, it will default to hidden_size // num_attention_heads\n+\n+    ```python\n+    >>> from transformers import ArceeModel, ArceeConfig\n+\n+    >>> # Initializing an Arcee AFM-4.5B-Base style configuration\n+    >>> configuration = ArceeConfig()\n+\n+    >>> # Initializing a model from the AFM-4.5B-Base style configuration\n+    >>> model = ArceeModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"arcee\"\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.up_proj\": \"colwise\",\n+        \"layers.*.mlp.down_proj\": \"rowwise\",\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=32000,\n+        hidden_size=2560,\n+        intermediate_size=18432,\n+        num_hidden_layers=32,\n+        num_attention_heads=32,\n+        num_key_value_heads=None,\n+        hidden_act=\"relu2\",\n+        max_position_embeddings=4096,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-5,\n+        use_cache=True,\n+        pad_token_id=None,\n+        bos_token_id=128000,\n+        eos_token_id=128001,\n+        tie_word_embeddings=False,\n+        rope_theta=10000.0,\n+        rope_scaling=None,\n+        attention_bias=False,\n+        attention_dropout=0.0,\n+        mlp_bias=False,\n+        head_dim=None,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            vocab_size=vocab_size,\n+            hidden_size=hidden_size,\n+            intermediate_size=intermediate_size,\n+            num_hidden_layers=num_hidden_layers,\n+            num_attention_heads=num_attention_heads,\n+            num_key_value_heads=num_key_value_heads,\n+            hidden_act=hidden_act,\n+            max_position_embeddings=max_position_embeddings,\n+            initializer_range=initializer_range,\n+            rms_norm_eps=rms_norm_eps,\n+            use_cache=use_cache,\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            tie_word_embeddings=tie_word_embeddings,\n+            rope_theta=rope_theta,\n+            rope_scaling=rope_scaling,\n+            attention_bias=attention_bias,\n+            attention_dropout=attention_dropout,\n+            mlp_bias=mlp_bias,\n+            head_dim=head_dim,\n+            **kwargs,\n+        )\n+\n+        del self.pretraining_tp\n+\n+\n+class ArceeMLP(NemotronMLP):\n+    \"\"\"Arcee MLP with configurable activation function (typically relu2)\"\"\"\n+\n+    pass\n+\n+\n+class ArceePreTrainedModel(LlamaPreTrainedModel):\n+    \"\"\"\n+    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n+    models.\n+    \"\"\"\n+\n+    pass\n+\n+\n+class ArceeModel(LlamaModel):\n+    \"\"\"\n+    Transformer decoder consisting of *config.num_hidden_layers* layers. Each layer is a [`ArceeDecoderLayer`]\n+\n+    Args:\n+        config: ArceeConfig\n+    \"\"\"\n+\n+    pass\n+\n+\n+class ArceeForCausalLM(LlamaForCausalLM):\n+    \"\"\"Arcee Model transformer with a language modeling head on top (linear layer with weights tied to the input embeddings).\"\"\"\n+\n+    pass\n+\n+\n+@auto_docstring(checkpoint=\"arcee-ai/AFM-4.5B\")\n+class ArceeForSequenceClassification(LlamaForSequenceClassification):\n+    \"\"\"\n+    The Arcee Model transformer with a sequence classification head on top (linear layer).\n+    \"\"\"\n+\n+    pass\n+\n+\n+@auto_docstring(checkpoint=\"arcee-ai/AFM-4.5B\")\n+class ArceeForQuestionAnswering(LlamaForQuestionAnswering):\n+    \"\"\"\n+    The Arcee Model transformer with a span classification head on top for extractive question-answering tasks.\n+    \"\"\"\n+\n+    pass\n+\n+\n+@auto_docstring(checkpoint=\"arcee-ai/AFM-4.5B\")\n+class ArceeForTokenClassification(LlamaForTokenClassification):\n+    \"\"\"\n+    The Arcee Model transformer with a token classification head on top.\n+    \"\"\"\n+\n+    pass\n+\n+\n+__all__ = [\n+    \"ArceeConfig\",\n+    \"ArceeForCausalLM\",\n+    \"ArceeForQuestionAnswering\",\n+    \"ArceeForSequenceClassification\",\n+    \"ArceeForTokenClassification\",\n+    \"ArceeModel\",\n+    \"ArceePreTrainedModel\",\n+]"
        },
        {
            "sha": "d7529b2b63c7ea3325473e337123de5efdee7ca2",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=71de20b818c3aa9715fb3d0e26f448ec534b03d2",
            "patch": "@@ -39,6 +39,7 @@\n         (\"albert\", \"AlbertConfig\"),\n         (\"align\", \"AlignConfig\"),\n         (\"altclip\", \"AltCLIPConfig\"),\n+        (\"arcee\", \"ArceeConfig\"),\n         (\"aria\", \"AriaConfig\"),\n         (\"aria_text\", \"AriaTextConfig\"),\n         (\"audio-spectrogram-transformer\", \"ASTConfig\"),\n@@ -395,6 +396,7 @@\n         (\"albert\", \"ALBERT\"),\n         (\"align\", \"ALIGN\"),\n         (\"altclip\", \"AltCLIP\"),\n+        (\"arcee\", \"Arcee\"),\n         (\"aria\", \"Aria\"),\n         (\"aria_text\", \"AriaText\"),\n         (\"audio-spectrogram-transformer\", \"Audio Spectrogram Transformer\"),"
        },
        {
            "sha": "b3224b7d46a1baec7f616e638c5dbc5040856654",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=71de20b818c3aa9715fb3d0e26f448ec534b03d2",
            "patch": "@@ -35,6 +35,7 @@\n         (\"albert\", \"AlbertModel\"),\n         (\"align\", \"AlignModel\"),\n         (\"altclip\", \"AltCLIPModel\"),\n+        (\"arcee\", \"ArceeModel\"),\n         (\"aria\", \"AriaModel\"),\n         (\"aria_text\", \"AriaTextModel\"),\n         (\"audio-spectrogram-transformer\", \"ASTModel\"),\n@@ -536,6 +537,7 @@\n MODEL_FOR_CAUSAL_LM_MAPPING_NAMES = OrderedDict(\n     [\n         # Model for Causal LM mapping\n+        (\"arcee\", \"ArceeForCausalLM\"),\n         (\"aria_text\", \"AriaTextForCausalLM\"),\n         (\"bamba\", \"BambaForCausalLM\"),\n         (\"bart\", \"BartForCausalLM\"),\n@@ -1061,6 +1063,7 @@\n     [\n         # Model for Sequence Classification mapping\n         (\"albert\", \"AlbertForSequenceClassification\"),\n+        (\"arcee\", \"ArceeForSequenceClassification\"),\n         (\"bart\", \"BartForSequenceClassification\"),\n         (\"bert\", \"BertForSequenceClassification\"),\n         (\"big_bird\", \"BigBirdForSequenceClassification\"),\n@@ -1166,6 +1169,7 @@\n     [\n         # Model for Question Answering mapping\n         (\"albert\", \"AlbertForQuestionAnswering\"),\n+        (\"arcee\", \"ArceeForQuestionAnswering\"),\n         (\"bart\", \"BartForQuestionAnswering\"),\n         (\"bert\", \"BertForQuestionAnswering\"),\n         (\"big_bird\", \"BigBirdForQuestionAnswering\"),\n@@ -1268,6 +1272,7 @@\n     [\n         # Model for Token Classification mapping\n         (\"albert\", \"AlbertForTokenClassification\"),\n+        (\"arcee\", \"ArceeForTokenClassification\"),\n         (\"bert\", \"BertForTokenClassification\"),\n         (\"big_bird\", \"BigBirdForTokenClassification\"),\n         (\"biogpt\", \"BioGptForTokenClassification\"),"
        },
        {
            "sha": "27a926fae8c7af7e1376bb212f45cba348db3120",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/71de20b818c3aa9715fb3d0e26f448ec534b03d2/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=71de20b818c3aa9715fb3d0e26f448ec534b03d2",
            "patch": "@@ -64,6 +64,7 @@\n             ),\n         ),\n         (\"align\", (\"BertTokenizer\", \"BertTokenizerFast\" if is_tokenizers_available() else None)),\n+        (\"arcee\", (\"LlamaTokenizer\", \"LlamaTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"aria\", (\"LlamaTokenizer\", \"LlamaTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"aya_vision\", (None, \"CohereTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"bark\", (\"BertTokenizer\", \"BertTokenizerFast\" if is_tokenizers_available() else None)),"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/arcee/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/71de20b818c3aa9715fb3d0e26f448ec534b03d2/tests%2Fmodels%2Farcee%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/71de20b818c3aa9715fb3d0e26f448ec534b03d2/tests%2Fmodels%2Farcee%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Farcee%2F__init__.py?ref=71de20b818c3aa9715fb3d0e26f448ec534b03d2"
        },
        {
            "sha": "697be3ae76452dce2b1f638d3d23d9afacdf2631",
            "filename": "tests/models/arcee/test_modeling_arcee.py",
            "status": "added",
            "additions": 159,
            "deletions": 0,
            "changes": 159,
            "blob_url": "https://github.com/huggingface/transformers/blob/71de20b818c3aa9715fb3d0e26f448ec534b03d2/tests%2Fmodels%2Farcee%2Ftest_modeling_arcee.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/71de20b818c3aa9715fb3d0e26f448ec534b03d2/tests%2Fmodels%2Farcee%2Ftest_modeling_arcee.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Farcee%2Ftest_modeling_arcee.py?ref=71de20b818c3aa9715fb3d0e26f448ec534b03d2",
            "patch": "@@ -0,0 +1,159 @@\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch Arcee model.\"\"\"\n+\n+import unittest\n+\n+from pytest import mark\n+\n+from transformers import AutoTokenizer, is_torch_available\n+from transformers.testing_utils import (\n+    require_flash_attn,\n+    require_torch,\n+    require_torch_accelerator,\n+    slow,\n+)\n+\n+from ...causal_lm_tester import CausalLMModelTest, CausalLMModelTester\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import (\n+        ArceeConfig,\n+        ArceeForCausalLM,\n+        ArceeForQuestionAnswering,\n+        ArceeForSequenceClassification,\n+        ArceeForTokenClassification,\n+        ArceeModel,\n+    )\n+    from transformers.models.arcee.modeling_arcee import ArceeRotaryEmbedding\n+\n+\n+class ArceeModelTester(CausalLMModelTester):\n+    if is_torch_available():\n+        config_class = ArceeConfig\n+        base_model_class = ArceeModel\n+        causal_lm_class = ArceeForCausalLM\n+        sequence_class = ArceeForSequenceClassification\n+        token_class = ArceeForTokenClassification\n+\n+\n+@require_torch\n+class ArceeModelTest(CausalLMModelTest, unittest.TestCase):\n+    all_model_classes = (\n+        (\n+            ArceeModel,\n+            ArceeForCausalLM,\n+            ArceeForSequenceClassification,\n+            ArceeForQuestionAnswering,\n+            ArceeForTokenClassification,\n+        )\n+        if is_torch_available()\n+        else ()\n+    )\n+    pipeline_model_mapping = (\n+        {\n+            \"feature-extraction\": ArceeModel,\n+            \"text-classification\": ArceeForSequenceClassification,\n+            \"text-generation\": ArceeForCausalLM,\n+            \"zero-shot\": ArceeForSequenceClassification,\n+            \"question-answering\": ArceeForQuestionAnswering,\n+            \"token-classification\": ArceeForTokenClassification,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+    test_headmasking = False\n+    test_pruning = False\n+    fx_compatible = False\n+    model_tester_class = ArceeModelTester\n+    rotary_embedding_layer = ArceeRotaryEmbedding  # Enables RoPE tests if set\n+\n+    # Need to use `0.8` instead of `0.9` for `test_cpu_offload`\n+    # This is because we are hitting edge cases with the causal_mask buffer\n+    model_split_percents = [0.5, 0.7, 0.8]\n+\n+    # used in `test_torch_compile_for_training`\n+    _torch_compile_train_cls = ArceeForCausalLM if is_torch_available() else None\n+\n+    def test_arcee_mlp_uses_relu_squared(self):\n+        \"\"\"Test that ArceeMLP uses ReLUÂ² activation instead of SiLU.\"\"\"\n+        config, _ = self.model_tester.prepare_config_and_inputs_for_common()\n+        config.hidden_act = \"relu2\"  # Ensure we're using relu2 activation\n+        model = ArceeModel(config)\n+\n+        # Check that the MLP layers use the correct activation\n+        mlp = model.layers[0].mlp\n+        # Test with a simple input\n+        x = torch.randn(1, 10, config.hidden_size)\n+        up_output = mlp.up_proj(x)\n+\n+        # Verify ReLUÂ² activation: x * relu(x)\n+        expected_activation = up_output * torch.relu(up_output)\n+        actual_activation = mlp.act_fn(up_output)\n+\n+        self.assertTrue(torch.allclose(expected_activation, actual_activation, atol=1e-5))\n+\n+\n+@require_torch_accelerator\n+class ArceeIntegrationTest(unittest.TestCase):\n+    def tearDown(self):\n+        import gc\n+\n+        gc.collect()\n+        torch.cuda.empty_cache()\n+\n+    @slow\n+    def test_model_from_pretrained(self):\n+        # This test would be enabled once a pretrained model is available\n+        # For now, we just test that the model can be instantiated\n+        config = ArceeConfig()\n+        model = ArceeForCausalLM(config)\n+        self.assertIsInstance(model, ArceeForCausalLM)\n+\n+    @mark.skip(reason=\"Model is not currently public - will update test post release\")\n+    @slow\n+    def test_model_generation(self):\n+        EXPECTED_TEXT_COMPLETION = (\n+            \"\"\"Once upon a time,In a village there was a farmer who had three sons. The farmer was very old and he\"\"\"\n+        )\n+        prompt = \"Once upon a time\"\n+        tokenizer = AutoTokenizer.from_pretrained(\"arcee-ai/model-id\")\n+        model = ArceeForCausalLM.from_pretrained(\"arcee-ai/model-id\", device_map=\"auto\")\n+        input_ids = tokenizer.encode(prompt, return_tensors=\"pt\").to(model.model.embed_tokens.weight.device)\n+\n+        generated_ids = model.generate(input_ids, max_new_tokens=20)\n+        text = tokenizer.decode(generated_ids[0], skip_special_tokens=True)\n+        self.assertEqual(EXPECTED_TEXT_COMPLETION, text)\n+\n+    @mark.skip(reason=\"Model is not currently public - will update test post release\")\n+    @slow\n+    @require_flash_attn\n+    @mark.flash_attn_test\n+    def test_model_generation_flash_attn(self):\n+        EXPECTED_TEXT_COMPLETION = (\n+            \" the food, the people, and the overall experience. I would definitely recommend this place to others.\"\n+        )\n+        prompt = \"This is a nice place. \" * 1024 + \"I really enjoy the scenery,\"\n+        tokenizer = AutoTokenizer.from_pretrained(\"arcee-ai/model-id\")\n+        model = ArceeForCausalLM.from_pretrained(\n+            \"arcee-ai/model-id\", device_map=\"auto\", attn_implementation=\"flash_attention_2\", torch_dtype=\"auto\"\n+        )\n+        input_ids = tokenizer.encode(prompt, return_tensors=\"pt\").to(model.model.embed_tokens.weight.device)\n+\n+        generated_ids = model.generate(input_ids, max_new_tokens=20)\n+        text = tokenizer.decode(generated_ids[0], skip_special_tokens=True)\n+        self.assertEqual(EXPECTED_TEXT_COMPLETION, text[len(prompt) :])"
        }
    ],
    "stats": {
        "total": 1605,
        "additions": 1605,
        "deletions": 0
    }
}