{
    "author": "McPatate",
    "message": "docs: add continuous batching page (#41847)\n\n* docs: add continuous batching page\n\n* docs(cb): add `generate_batch` example\n\n* docs(cb): add `opentelemtry` and `serving` section\n\n* feat: add `TODO` note about opentelemetry dependency\n\n* docs(cb): add supported features\n\n* docs(cb): add unsupported features\n\n* docs(cb): add `ContinuousBatchingManager` example\n\n* docs(cb): x reference CB in optimizing inference",
    "sha": "22e39dfb319fdba0cd17302c285240f26fb4dcd2",
    "files": [
        {
            "sha": "c5ce9fbdb9c4f71d484e23f70166910de5d5d3c7",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/22e39dfb319fdba0cd17302c285240f26fb4dcd2/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/22e39dfb319fdba0cd17302c285240f26fb4dcd2/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=22e39dfb319fdba0cd17302c285240f26fb4dcd2",
            "patch": "@@ -119,6 +119,8 @@\n     title: Tools\n   - local: transformers_as_backend\n     title: Inference server backends\n+  - local: continuous_batching\n+    title: Continuous Batching\n   title: Inference\n - isExpanded: false\n   sections:"
        },
        {
            "sha": "06158a302cbb6655ca1f613f2d5a875cc2253d06",
            "filename": "docs/source/en/continuous_batching.md",
            "status": "added",
            "additions": 194,
            "deletions": 0,
            "changes": 194,
            "blob_url": "https://github.com/huggingface/transformers/blob/22e39dfb319fdba0cd17302c285240f26fb4dcd2/docs%2Fsource%2Fen%2Fcontinuous_batching.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/22e39dfb319fdba0cd17302c285240f26fb4dcd2/docs%2Fsource%2Fen%2Fcontinuous_batching.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fcontinuous_batching.md?ref=22e39dfb319fdba0cd17302c285240f26fb4dcd2",
            "patch": "@@ -0,0 +1,194 @@\n+<!--Copyright 2025 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# Continuous Batching\n+\n+Continuous Batching (CB) is an advanced technique to optimize the inference of transformer models by dynamically grouping multiple requests into batches. This approach maximizes GPU utilization and throughput, specifically for workloads with many variable-length inputs.\n+\n+We are particularly interested in having Continuous Batching in transformers for the following use cases:\n+- Evaluation of models on large datasets with variable-length inputs\n+- Generating outputs for multiple sequences for GRPO policies\n+\n+CB is what makes inference engines like vLLM or SGLang efficient. That being said, transformers does not aim to be a production-ready inference engine, but a complete framework for model development. For this reason, CB is available in `transformers serve`.\n+\n+If you are not familiar with some of the core concepts CB is built upon, we invite you to read the associated blog post: [Continuous Batching: Efficient Inference for Large Language Models](https://huggingface.co/blog/continuous-batching). _broken link for now_\n+\n+## API Reference\n+\n+## Usage Examples\n+\n+The main way to use CB in transformers is via the `generate_batch` method.\n+\n+Unlike `generate`, CB takes already tokenized inputs, known as input IDs. Each sequence of input IDs is represented as a list of integers, in python: `list[int]`. Since \n+\n+For a more detailed example, please refer to: [examples/continuous_batching](./path/to/example)\n+\n+### `generate_batch` example\n+\n+We have created a `ContinuousMixin` that is inherited by the `GenerationMixin` so that all auto regressive text models support CB.\n+\n+This adds the `generate_batch` method to all models that inherit from `GenerationMixin`.\n+\n+You can use it as follows:\n+\n+```py\n+import datasets\n+import torch\n+\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+from transformers.generation import GenerationConfig\n+\n+model = AutoModelForCausalLM.from_pretrained(\n+    \"Qwen/Qwen3-4B-Instruct-2507\",\n+    attn_implementation=\"spda_paged\",\n+    device_map=\"cuda\",  # if you need cuda\n+    dtype=torch.bfloat16,\n+)\n+tokenizer = AutoTokenizer.from_pretrained(MODEL_ID, padding_side=\"left\")\n+\n+# prepare a batch of inputs\n+dataset = datasets.load_dataset(\"openai/gsm8k\", \"socratic\", split=\"test\")\n+dataset = dataset.select(range(args.samples))\n+tokenized_datasets = dataset.map(lambda x: tokenizer(x[\"question\"]), batched=True)\n+simple_batch_inputs = [item[\"input_ids\"] for item in tokenized_datasets]\n+\n+generation_config = GenerationConfig(\n+    max_new_tokens=32,\n+    use_cuda_graph=False,  # Not supported for simple version\n+    eos_token_id=tokenizer.eos_token_id,\n+    pad_token_id=tokenizer.pad_token_id,\n+    do_sample=False,\n+    max_batch_tokens=512,  # max number of tokens in a batch, this is just a default value you should tune based on your hardware\n+)\n+\n+batch_outputs = model.generate_batch(\n+    inputs=simple_batch_inputs,\n+    generation_config=generation_config,\n+)\n+\n+for request_id, output in batch_outputs.items():\n+    generated_text = tokenizer.decode(output.generated_tokens, skip_special_tokens=True)\n+    print(f\"Request {request_id} output: {generated_text}\")\n+```\n+\n+### `ContinuousBatchingManager` example\n+\n+If you want more control w.r.t. how you want to schedule requests using CB, you can use the `ContinuousBatchingManager` class directly.\n+\n+This is what we use in `transformers serve` because requests arrive asynchronously and we can leverage the asynchronous nature of the CB process to make things more efficient.\n+\n+Under the hood, the `ContinuousBatchingManager` creates a background thread that receives inputs from a python `queue.Queue` which it uses to get requests to batch in each forward pass.\n+\n+Note that the manager is thread safe!\n+\n+```py\n+import datasets\n+import torch\n+\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+from transformers.generation import GenerationConfig\n+from transformers.generation.continuous_batching import RequestStatus\n+\n+model = AutoModelForCausalLM.from_pretrained(\n+    \"Qwen/Qwen3-4B-Instruct-2507\",\n+    attn_implementation=\"spda_paged\",\n+    device_map=\"cuda\",  # if you need cuda\n+    dtype=torch.bfloat16,\n+)\n+tokenizer = AutoTokenizer.from_pretrained(MODEL_ID, padding_side=\"left\")\n+\n+# prepare a batch of inputs\n+dataset = datasets.load_dataset(\"openai/gsm8k\", \"socratic\", split=\"test\")\n+dataset = dataset.select(range(args.samples))\n+tokenized_datasets = dataset.map(lambda x: tokenizer(x[\"question\"]), batched=True)\n+simple_batch_inputs = [item[\"input_ids\"] for item in tokenized_datasets]\n+\n+# initialize the manager, available method thanks to the `ContinuousMixin`\n+manager = model.init_continuous_batching(generation_config=generation_config)\n+\n+# start the background thread\n+manager.start()\n+\n+# this is for demonstration purposes only, in practice this is most useful to do concurrently\n+for i, input in enumerate(simple_batch_inputs):\n+    request_id = manager.add_request(input_ids=input, request_id=f\"request_{i}\")  # if you do not specify a request_id, one will be generated for you\n+\n+# Can be done in an other thread\n+for id, request in manager.get_result():\n+    generated_text = tokenizer.decode(request.generated_tokens, skip_special_tokens=True)\n+    print(f\"Request {id} output: {generated_text}\")\n+\n+# you can also get results for a specific request id\n+result = manager.get_result(request_id=\"request_5\")  # this is blocking and will wait for the result to be ready\n+\n+# or get results for a request that is streaming\n+manager.add_request(\n+    input_ids=input,\n+    request_id=\"streaming_request\",\n+    stream=True,\n+)\n+for chunk in manager.request_id_iter(request_id=\"streaming_request\"):\n+    generated_text = tokenizer.decode(chunk.generated_tokens, skip_special_tokens=True)\n+    print(generated_text)\n+    # FIXME: stop iteration in `request_id_iter` when finished instead of doing it externally\n+    if chunk.status == RequestStatus.FINISHED:\n+        break\n+\n+# stop the background thread before exiting the process\n+manager.stop()\n+```\n+\n+## Supported & Unsupported Features\n+\n+### Supported Features\n+\n+- Dynamic scheduling of variable-length requests\n+- Chunked prefill\n+- Paged Attention Cache\n+- Sliding window attention\n+- Chat templates\n+\n+### Unsupported Features\n+\n+At the moment, the following features are not supported with CB. We plan to add support to the following:\n+\n+- Prefix caching\n+- Beam search\n+- tool calling\n+\n+The others are unplanned, but depending on community requests we might consider adding them:\n+\n+- MTP (multi token prediction)\n+- Medusa\n+\n+## Performance Considerations\n+\n+\n+## Integration with Serving\n+\n+You can use CB in `transformers serve` by passing the `--continuous-batching` flag when starting the server.\n+\n+## Monitoring\n+\n+We have added `opentelemetry` support to Continuous Batching to help you monitor its performance in production. To enable it, you need to install the `opentelemetry` extra when installing `transformers`:\n+\n+```sh\n+# this installs `opentelemetry-api`, `opentelemetry-sdk` and `opentelemetry-exporter-otlp`\n+pip install transformers[open-telemetry]\n+```\n+\n+This will enable traces and metrics collection in CB. You will then have to setup the backend to collect and visualize the traces and metrics.\n+"
        },
        {
            "sha": "e7cadd4390605c4e4170b6a4a4048d2afdf57d30",
            "filename": "docs/source/en/llm_optims.md",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/22e39dfb319fdba0cd17302c285240f26fb4dcd2/docs%2Fsource%2Fen%2Fllm_optims.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/22e39dfb319fdba0cd17302c285240f26fb4dcd2/docs%2Fsource%2Fen%2Fllm_optims.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fllm_optims.md?ref=22e39dfb319fdba0cd17302c285240f26fb4dcd2",
            "patch": "@@ -393,3 +393,9 @@ model = AutoModelForCausalLM.from_pretrained(\n     \"mistralai/Mistral-7B-v0.1\", quantization_config=quant_config, device_map=\"auto\"\n )\n ```\n+\n+## Continuous Batching\n+\n+When serving LLMs for inference, you may have multiple requests arriving at different times. Continuous Batching (CB) is a technique that groups incoming requests into batches to maximize GPU utilization and throughput.\n+\n+See the [Continuous Batching](./continuous_batching) guide for more details on how to use CB in transformers."
        },
        {
            "sha": "a71582af051d91b50f48098cbaabcc0f87f70b54",
            "filename": "setup.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/22e39dfb319fdba0cd17302c285240f26fb4dcd2/setup.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/22e39dfb319fdba0cd17302c285240f26fb4dcd2/setup.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/setup.py?ref=22e39dfb319fdba0cd17302c285240f26fb4dcd2",
            "patch": "@@ -392,6 +392,7 @@ def run(self):\n extras[\"benchmark\"] = deps_list(\"optimum-benchmark\")\n \n # OpenTelemetry dependencies for metrics collection in continuous batching\n+# TODO: refactor this to split API and SDK; SDK and exporter should only be needed to run code that collects metrics whereas API is what people will need to instrument their code and handle exporter themselves\n extras[\"open-telemetry\"] = deps_list(\"opentelemetry-api\") + [\"opentelemetry-exporter-otlp\", \"opentelemetry-sdk\"]\n \n # when modifying the following list, make sure to update src/transformers/dependency_versions_check.py"
        },
        {
            "sha": "cf33290d239fa018916a714d4eb4f8942ed17a30",
            "filename": "src/transformers/generation/continuous_batching/continuous_api.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/22e39dfb319fdba0cd17302c285240f26fb4dcd2/src%2Ftransformers%2Fgeneration%2Fcontinuous_batching%2Fcontinuous_api.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/22e39dfb319fdba0cd17302c285240f26fb4dcd2/src%2Ftransformers%2Fgeneration%2Fcontinuous_batching%2Fcontinuous_api.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Fcontinuous_batching%2Fcontinuous_api.py?ref=22e39dfb319fdba0cd17302c285240f26fb4dcd2",
            "patch": "@@ -919,6 +919,7 @@ def __iter__(self):\n             if result is not None:\n                 yield result\n \n+    # FIXME: stop iteration when request status is finished?\n     def request_id_iter(self, request_id: str) -> Generator[GenerationOutput]:\n         \"\"\"Iterate over results matching a specific request id as they become available.\"\"\"\n         request_cancelled = False"
        }
    ],
    "stats": {
        "total": 204,
        "additions": 204,
        "deletions": 0
    }
}