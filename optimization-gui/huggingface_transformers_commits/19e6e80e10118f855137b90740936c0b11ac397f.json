{
    "author": "simonJJJ",
    "message": "support qwen2-vl (#32318)\n\n* support-qwen2-vl\r\n\r\n* tidy\r\n\r\n* tidy\r\n\r\n* tidy\r\n\r\n* tidy\r\n\r\n* tidy\r\n\r\n* tidy\r\n\r\n* tidy\r\n\r\n* hyphen->underscore\r\n\r\n* make style\r\n\r\n* add-flash2-tipd\r\n\r\n* delete-tokenize=False\r\n\r\n* remove-image_processor-in-init-file\r\n\r\n* add-qwen2_vl-in-MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES\r\n\r\n* format-doct\r\n\r\n* support-Qwen2VLVisionConfig\r\n\r\n* remove-standardize_cache_format\r\n\r\n* fix-letter-varaibles\r\n\r\n* remove-torch-in-image-processor\r\n\r\n* remove-useless-docstring\r\n\r\n* fix-one-letter-varaible-name\r\n\r\n* change-block-name\r\n\r\n* default-quick-gelu-in-vision\r\n\r\n* remove-useless-doc\r\n\r\n* use-preimplemented-flash-forward\r\n\r\n* fix-doc\r\n\r\n* fix-image-processing-doc\r\n\r\n* fix-apply-rotary-embed\r\n\r\n* fix-flash-attn-sliding-window\r\n\r\n* refactor\r\n\r\n* remove-default_template\r\n\r\n* remove-reorder_cache\r\n\r\n* simple-get-rope_deltas\r\n\r\n* update-prepare_inputs_for_generation\r\n\r\n* update-attention-mask\r\n\r\n* update-rotary_seq_len\r\n\r\n* remove-state\r\n\r\n* kv_seq_length\r\n\r\n* remove-warning\r\n\r\n* _supports_static_cache\r\n\r\n* remove-legacy-cache\r\n\r\n* refactor\r\n\r\n* fix-replace\r\n\r\n* mrope-section-doc\r\n\r\n* code-quality\r\n\r\n* code-quality\r\n\r\n* polish-doc\r\n\r\n* fix-image-processing-test\r\n\r\n* update readme\r\n\r\n* Update qwen2_vl.md\r\n\r\n* fix-test\r\n\r\n* Update qwen2_vl.md\r\n\r\n* nit\r\n\r\n* processor-kwargs\r\n\r\n* hard-code-norm_layer\r\n\r\n* code-quality\r\n\r\n* discard-pixel-values-in-gen\r\n\r\n* fix-inconsistent-error-msg\r\n\r\n* unify-image-video\r\n\r\n* hidden_act\r\n\r\n* add-docstring\r\n\r\n* vision-encode-as-PreTrainedModel\r\n\r\n* pixel-to-target-dtype\r\n\r\n* update doc and low memoryvit\r\n\r\n* format\r\n\r\n* format\r\n\r\n* channel-foramt\r\n\r\n* fix vit_flashatt\r\n\r\n* format\r\n\r\n* inherit-Qwen2VLPreTrainedModel\r\n\r\n* simplify\r\n\r\n* format-test\r\n\r\n* remove-one-line-func-in-image-processing\r\n\r\n* avoid-one-line-reshape\r\n\r\n* simplify-rotary_seq_len\r\n\r\n* avoid-single-letter-variable\r\n\r\n* no-for-loop-sdpa\r\n\r\n* avoid-single-letter-variable\r\n\r\n* remove-one-line-reshape\r\n\r\n* remove-one-line-reshape\r\n\r\n* remove-no-rope-in-vit-logic\r\n\r\n* default-mrope\r\n\r\n* add-copied-from\r\n\r\n* more-docs-for-mrope\r\n\r\n* polish-doc\r\n\r\n* comment-and-link\r\n\r\n* polish-doc\r\n\r\n* single-letter-variables\r\n\r\n* simplify-image-processing\r\n\r\n* video->images\r\n\r\n* kv_seq_len-update\r\n\r\n* vision-rope-on-the-fly\r\n\r\n* vision-eager-attention\r\n\r\n* change-processor-order\r\n\r\n---------\r\n\r\nCo-authored-by: baishuai <baishuai.bs@alibaba-inc.com>\r\nCo-authored-by: ShuaiBai623 <43326198+ShuaiBai623@users.noreply.github.com>",
    "sha": "19e6e80e10118f855137b90740936c0b11ac397f",
    "files": [
        {
            "sha": "ef2a33d463afd3872f81f47021e40d31b9b8382f",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -514,6 +514,8 @@\n         title: Qwen2Audio\n       - local: model_doc/qwen2_moe\n         title: Qwen2MoE\n+      - local: model_doc/qwen2_vl\n+        title: Qwen2VL\n       - local: model_doc/rag\n         title: RAG\n       - local: model_doc/realm"
        },
        {
            "sha": "1a8ca90ccbf079dea9ea66a6cd8562fd44321f88",
            "filename": "docs/source/en/index.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/docs%2Fsource%2Fen%2Findex.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/docs%2Fsource%2Fen%2Findex.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Findex.md?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -260,6 +260,7 @@ Flax), PyTorch, and/or TensorFlow.\n |                         [Qwen2](model_doc/qwen2)                         |       ✅        |         ❌         |      ❌      |\n |                   [Qwen2Audio](model_doc/qwen2_audio)                    |       ✅        |         ❌         |      ❌      |\n |                     [Qwen2MoE](model_doc/qwen2_moe)                      |       ✅        |         ❌         |      ❌      |\n+|                      [Qwen2VL](model_doc/qwen2_vl)                       |       ✅        |         ❌         |      ❌      |\n |                           [RAG](model_doc/rag)                           |       ✅        |         ✅         |      ❌      |\n |                         [REALM](model_doc/realm)                         |       ✅        |         ❌         |      ❌      |\n |               [RecurrentGemma](model_doc/recurrent_gemma)                |       ✅        |         ❌         |      ❌      |"
        },
        {
            "sha": "442475fdc21acb2c9e9296e6e1afb484ae8118b3",
            "filename": "docs/source/en/model_doc/qwen2_vl.md",
            "status": "added",
            "additions": 329,
            "deletions": 0,
            "changes": 329,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen2_vl.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen2_vl.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen2_vl.md?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -0,0 +1,329 @@\n+<!--Copyright 2024 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# Qwen2_VL\n+\n+\n+## Overview\n+\n+The [Qwen2_VL](https://qwenlm.github.io/blog/qwen2-vl/) is a major update to our [Qwen-VL](https://arxiv.org/pdf/2308.12966) model from the Qwen team. \n+\n+The abstract from the blog is the following:\n+\n+*This blog introduces Qwen2-VL, an advanced version of the Qwen-VL model that has undergone significant enhancements over the past year. Key improvements include enhanced image comprehension, advanced video understanding, integrated visual agent functionality, and expanded multilingual support. The model architecture has been optimized for handling arbitrary image resolutions through Naive Dynamic Resolution support and utilizes Multimodal Rotary Position Embedding (M-ROPE) to effectively process both 1D textual and multi-dimensional visual data. This updated model demonstrates competitive performance against leading AI systems like GPT-4o and Claude 3.5 Sonnet in vision-related tasks and ranks highly among open-source models in text capabilities. These advancements make Qwen2-VL a versatile tool for various applications requiring robust multimodal processing and reasoning abilities.*\n+\n+\n+## Usage example\n+\n+### Single Media inference\n+\n+The model can accept both images and videos as input. Here's an example code for inference.\n+\n+```python\n+\n+from PIL import Image\n+import requests\n+import torch\n+from torchvision import io\n+from typing import Dict\n+from transformers import Qwen2VLForConditionalGeneration, AutoTokenizer, AutoProcessor\n+\n+# Load the model in half-precision on the available device(s)\n+model = Qwen2VLForConditionalGeneration.from_pretrained(\"Qwen/Qwen2-VL-7B-Instruct\", device_map=\"auto\")\n+processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2-VL-7B-Instruct\")\n+\n+# Image\n+url = \"https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen-VL/assets/demo.jpeg\"\n+image = Image.open(requests.get(url, stream=True).raw)\n+\n+conversation = [\n+    {\n+        \"role\":\"user\",\n+        \"content\":[\n+            {\n+                \"type\":\"image\",\n+            },\n+            {\n+                \"type\":\"text\",\n+                \"text\":\"Describe this image.\"\n+            }\n+        ]\n+    }\n+]\n+\n+\n+# Preprocess the inputs\n+text_prompt = processor.apply_chat_template(conversation, add_generation_prompt=True)\n+# Excepted output: '<|im_start|>system\\nYou are a helpful assistant.<|im_end|>\\n<|im_start|>user\\n<|vision_start|><|image_pad|><|vision_end|>Describe this image.<|im_end|>\\n<|im_start|>assistant\\n'\n+\n+inputs = processor(text=[text_prompt], images=[image], padding=True, return_tensors=\"pt\")\n+inputs = inputs.to('cuda')\n+\n+# Inference: Generation of the output\n+output_ids = model.generate(**inputs, max_new_tokens=128)\n+generated_ids = [output_ids[len(input_ids):] for input_ids, output_ids in zip(inputs.input_ids, output_ids)]\n+output_text = processor.batch_decode(generated_ids, skip_special_tokens=True, clean_up_tokenization_spaces=True)\n+print(output_text)\n+\n+\n+\n+# Video\n+def fetch_video(ele: Dict, nframe_factor=2):\n+    if isinstance(ele['video'], str):\n+        def round_by_factor(number: int, factor: int) -> int:\n+            return round(number / factor) * factor\n+\n+        video = ele[\"video\"]\n+        if video.startswith(\"file://\"):\n+            video = video[7:]\n+\n+        video, _, info = io.read_video(\n+            video,\n+            start_pts=ele.get(\"video_start\", 0.0),\n+            end_pts=ele.get(\"video_end\", None),\n+            pts_unit=\"sec\",\n+            output_format=\"TCHW\",\n+        )\n+        assert not (\"fps\" in ele and \"nframes\" in ele), \"Only accept either `fps` or `nframes`\"\n+        if \"nframes\" in ele:\n+            nframes = round_by_factor(ele[\"nframes\"], nframe_factor)\n+        else:\n+            fps = ele.get(\"fps\", 1.0)\n+            nframes = round_by_factor(video.size(0) / info[\"video_fps\"] * fps, nframe_factor)\n+        idx = torch.linspace(0, video.size(0) - 1, nframes, dtype=torch.int64)\n+        return video[idx]\n+\n+video_info = {\"type\": \"video\", \"video\": \"/path/to/video.mp4\", \"fps\": 1.0}\n+video = fetch_video(video_info)\n+conversation = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"video\"},\n+            {\"type\": \"text\", \"text\": \"What happened in the video?\"},\n+        ],\n+    }\n+]\n+\n+# Preprocess the inputs\n+text_prompt = processor.apply_chat_template(conversation, add_generation_prompt=True)\n+# Excepted output: '<|im_start|>system\\nYou are a helpful assistant.<|im_end|>\\n<|im_start|>user\\n<|vision_start|><|video_pad|><|vision_end|>What happened in the video?<|im_end|>\\n<|im_start|>assistant\\n'\n+\n+inputs = processor(text=[text_prompt], videos=[video], padding=True, return_tensors=\"pt\")\n+inputs = inputs.to('cuda')\n+\n+# Inference: Generation of the output\n+output_ids = model.generate(**inputs, max_new_tokens=128)\n+generated_ids = [output_ids[len(input_ids):] for input_ids, output_ids in zip(inputs.input_ids, output_ids)]\n+output_text = processor.batch_decode(generated_ids, skip_special_tokens=True, clean_up_tokenization_spaces=True)\n+print(output_text)\n+\n+```\n+\n+\n+### Batch Mixed Media Inference\n+\n+The model can batch inputs composed of mixed samples of various types such as images, videos, and text. Here is an example.\n+\n+```python\n+\n+image1 = Image.open(\"/path/to/image1.jpg\")\n+image2 = Image.open(\"/path/to/image2.jpg\")\n+image3 = Image.open(\"/path/to/image3.jpg\")\n+image4 = Image.open(\"/path/to/image4.jpg\")\n+image5 = Image.open(\"/path/to/image5.jpg\")\n+video = fetch_video({\n+    \"type\": \"video\",\n+    \"video\": \"/path/to/video.mp4\",\n+    \"fps\": 1.0\n+})\n+\n+# Conversation for the first image\n+conversation1 = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\"},\n+            {\"type\": \"text\", \"text\": \"Describe this image.\"}\n+        ]\n+    }\n+]\n+\n+# Conversation with two images\n+conversation2 = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\"},\n+            {\"type\": \"image\"},\n+            {\"type\": \"text\", \"text\": \"What is written in the pictures?\"}\n+        ]\n+    }\n+]\n+\n+# Conversation with pure text\n+conversation3 = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": \"who are you?\"\n+    }\n+]\n+\n+\n+# Conversation with mixed midia\n+conversation4 = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\"},\n+            {\"type\": \"image\"},\n+            {\"type\": \"video\"},\n+            {\"type\": \"text\", \"text\": \"What are the common elements in these medias?\"},\n+        ],\n+    }\n+]\n+\n+conversations = [conversation1, conversation2, conversation3, conversation4]\n+# Preparation for batch inference\n+texts = [processor.apply_chat_template(msg, add_generation_prompt=True) for msg in conversations]\n+inputs = processor(\n+    text=texts,\n+    images=[image1, image2, image3, image4, image5],\n+    videos=[video],\n+    padding=True,\n+    return_tensors=\"pt\",\n+)\n+inputs = inputs.to('cuda')\n+\n+# Batch Inference\n+output_ids = model.generate(**inputs, max_new_tokens=128)\n+generated_ids = [output_ids[len(input_ids):] for input_ids, output_ids in zip(inputs.input_ids, output_ids)]\n+output_text = processor.batch_decode(generated_ids, skip_special_tokens=True, clean_up_tokenization_spaces=True)\n+print(output_text)\n+```\n+\n+### Usage Tips\n+\n+#### Image Resolution for performance boost\n+\n+The model supports a wide range of resolution inputs. By default, it uses the native resolution for input, but higher resolutions can enhance performance at the cost of more computation. Users can set the minimum and maximum number of pixels to achieve an optimal configuration for their needs.\n+\n+```python\n+\n+min_pixels = 224*224\n+max_pixels = 2048*2048\n+processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2-VL-7B-Instruct\", min_pixels=min_pixels, max_pixels=max_pixels)\n+\n+```\n+\n+\n+\n+#### Multiple Image Inputs\n+\n+By default, images and video content are directly included in the conversation. When handling multiple images, it's helpful to add labels to the images and videos for better reference. Users can control this behavior with the following settings:\n+\n+\n+\n+```python\n+\n+conversation = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\"}, \n+            {\"type\": \"text\", \"text\": \"Hello, how are you?\"}\n+        ]\n+    },\n+    {\n+        \"role\": \"assistant\",\n+        \"content\": \"I'm doing well, thank you for asking. How can I assist you today?\"\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"Can you describe these images and video?\"}, \n+            {\"type\": \"image\"}, \n+            {\"type\": \"image\"}, \n+            {\"type\": \"video\"}, \n+            {\"type\": \"text\", \"text\": \"These are from my vacation.\"}\n+        ]\n+    },\n+    {\n+        \"role\": \"assistant\",\n+        \"content\": \"I'd be happy to describe the images and video for you. Could you please provide more context about your vacation?\"\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": \"It was a trip to the mountains. Can you see the details in the images and video?\"\n+    }\n+]\n+\n+# default:\n+prompt_without_id = processor.apply_chat_template(conversation, add_generation_prompt=True)\n+# Excepted output: '<|im_start|>system\\nYou are a helpful assistant.<|im_end|>\\n<|im_start|>user\\n<|vision_start|><|image_pad|><|vision_end|>Hello, how are you?<|im_end|>\\n<|im_start|>assistant\\nI'm doing well, thank you for asking. How can I assist you today?<|im_end|>\\n<|im_start|>user\\nCan you describe these images and video?<|vision_start|><|image_pad|><|vision_end|><|vision_start|><|image_pad|><|vision_end|><|vision_start|><|video_pad|><|vision_end|>These are from my vacation.<|im_end|>\\n<|im_start|>assistant\\nI'd be happy to describe the images and video for you. Could you please provide more context about your vacation?<|im_end|>\\n<|im_start|>user\\nIt was a trip to the mountains. Can you see the details in the images and video?<|im_end|>\\n<|im_start|>assistant\\n'\n+\n+\n+# add ids\n+prompt_with_id = processor.apply_chat_template(conversation, add_generation_prompt=True, add_vision_id=True)\n+# Excepted output: '<|im_start|>system\\nYou are a helpful assistant.<|im_end|>\\n<|im_start|>user\\nPicture 1: <|vision_start|><|image_pad|><|vision_end|>Hello, how are you?<|im_end|>\\n<|im_start|>assistant\\nI'm doing well, thank you for asking. How can I assist you today?<|im_end|>\\n<|im_start|>user\\nCan you describe these images and video?Picture 2: <|vision_start|><|image_pad|><|vision_end|>Picture 3: <|vision_start|><|image_pad|><|vision_end|>Video 1: <|vision_start|><|video_pad|><|vision_end|>These are from my vacation.<|im_end|>\\n<|im_start|>assistant\\nI'd be happy to describe the images and video for you. Could you please provide more context about your vacation?<|im_end|>\\n<|im_start|>user\\nIt was a trip to the mountains. Can you see the details in the images and video?<|im_end|>\\n<|im_start|>assistant\\n'\n+\n+```\n+\n+#### Flash-Attention 2 to speed up generation\n+\n+First, make sure to install the latest version of Flash Attention 2:\n+\n+```bash\n+pip install -U flash-attn --no-build-isolation\n+```\n+\n+Also, you should have a hardware that is compatible with Flash-Attention 2. Read more about it in the official documentation of the [flash attention repository](https://github.com/Dao-AILab/flash-attention). FlashAttention-2 can only be used when a model is loaded in `torch.float16` or `torch.bfloat16`.\n+\n+To load and run a model using Flash Attention-2, simply add `attn_implementation=\"flash_attention_2\"` when loading the model as follows:\n+\n+```python\n+from transformers import Qwen2VLForConditionalGeneration\n+\n+model = Qwen2VLForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2-VL-7B-Instruct\", \n+    torch_dtype=torch.bfloat16, \n+    attn_implementation=\"flash_attention_2\",\n+)\n+```\n+\n+\n+## Qwen2VLConfig\n+\n+[[autodoc]] Qwen2VLConfig\n+\n+## Qwen2VLImageProcessor\n+\n+[[autodoc]] Qwen2VLImageProcessor\n+    - preprocess\n+\n+## Qwen2VLProcessor\n+\n+[[autodoc]] Qwen2VLProcessor\n+\n+## Qwen2VLModel\n+\n+[[autodoc]] Qwen2VLModel\n+    - forward\n+\n+## Qwen2VLForConditionalGeneration\n+\n+[[autodoc]] Qwen2VLForConditionalGeneration\n+    - forward"
        },
        {
            "sha": "ab713dc91c8f0149cfb8418107dac2713e10b43a",
            "filename": "docs/source/en/perf_infer_gpu_one.md",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -79,6 +79,7 @@ FlashAttention-2 is currently supported for the following architectures:\n * [Qwen2](https://huggingface.co/docs/transformers/model_doc/qwen2#transformers.Qwen2Model)\n * [Qwen2Audio](https://huggingface.co/docs/transformers/model_doc/qwen2_audio#transformers.Qwen2AudioEncoder)\n * [Qwen2MoE](https://huggingface.co/docs/transformers/model_doc/qwen2_moe#transformers.Qwen2MoeModel)\n+* [Qwen2VL](https://huggingface.co/docs/transformers/model_doc/qwen2_vl#transformers.Qwen2VLModel)\n * [Whisper](https://huggingface.co/docs/transformers/model_doc/whisper#transformers.WhisperModel)\n * [Wav2Vec2](https://huggingface.co/docs/transformers/model_doc/wav2vec2#transformers.Wav2Vec2Model)\n * [Hubert](https://huggingface.co/docs/transformers/model_doc/hubert#transformers.HubertModel)\n@@ -230,6 +231,7 @@ For now, Transformers supports SDPA inference and training for the following arc\n * [Qwen2](https://huggingface.co/docs/transformers/model_doc/qwen2#transformers.Qwen2Model)\n * [Qwen2Audio](https://huggingface.co/docs/transformers/model_doc/qwen2_audio#transformers.Qwen2AudioEncoder)\n * [Qwen2MoE](https://huggingface.co/docs/transformers/model_doc/qwen2_moe#transformers.Qwen2MoeModel)\n+* [Qwen2VL](https://huggingface.co/docs/transformers/model_doc/qwen2_vl#transformers.Qwen2VLModel)\n * [Musicgen](https://huggingface.co/docs/transformers/model_doc/musicgen#transformers.MusicgenModel)\n * [MusicGen Melody](https://huggingface.co/docs/transformers/model_doc/musicgen_melody#transformers.MusicgenMelodyModel)\n * [Nemotron](https://huggingface.co/docs/transformers/model_doc/nemotron)"
        },
        {
            "sha": "ecf7031086f4fa2bde47a8b0c36b4843efc60022",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -663,6 +663,10 @@\n         \"Qwen2AudioProcessor\",\n     ],\n     \"models.qwen2_moe\": [\"Qwen2MoeConfig\"],\n+    \"models.qwen2_vl\": [\n+        \"Qwen2VLConfig\",\n+        \"Qwen2VLProcessor\",\n+    ],\n     \"models.rag\": [\"RagConfig\", \"RagRetriever\", \"RagTokenizer\"],\n     \"models.recurrent_gemma\": [\"RecurrentGemmaConfig\"],\n     \"models.reformer\": [\"ReformerConfig\"],\n@@ -1189,6 +1193,7 @@\n     _import_structure[\"models.pix2struct\"].extend([\"Pix2StructImageProcessor\"])\n     _import_structure[\"models.poolformer\"].extend([\"PoolFormerFeatureExtractor\", \"PoolFormerImageProcessor\"])\n     _import_structure[\"models.pvt\"].extend([\"PvtImageProcessor\"])\n+    _import_structure[\"models.qwen2_vl\"].extend([\"Qwen2VLImageProcessor\"])\n     _import_structure[\"models.rt_detr\"].extend([\"RTDetrImageProcessor\"])\n     _import_structure[\"models.sam\"].extend([\"SamImageProcessor\"])\n     _import_structure[\"models.segformer\"].extend([\"SegformerFeatureExtractor\", \"SegformerImageProcessor\"])\n@@ -3017,6 +3022,13 @@\n             \"Qwen2MoePreTrainedModel\",\n         ]\n     )\n+    _import_structure[\"models.qwen2_vl\"].extend(\n+        [\n+            \"Qwen2VLForConditionalGeneration\",\n+            \"Qwen2VLModel\",\n+            \"Qwen2VLPreTrainedModel\",\n+        ]\n+    )\n     _import_structure[\"models.rag\"].extend(\n         [\n             \"RagModel\",\n@@ -5424,6 +5436,10 @@\n         Qwen2AudioProcessor,\n     )\n     from .models.qwen2_moe import Qwen2MoeConfig\n+    from .models.qwen2_vl import (\n+        Qwen2VLConfig,\n+        Qwen2VLProcessor,\n+    )\n     from .models.rag import RagConfig, RagRetriever, RagTokenizer\n     from .models.recurrent_gemma import RecurrentGemmaConfig\n     from .models.reformer import ReformerConfig\n@@ -5978,6 +5994,7 @@\n             PoolFormerImageProcessor,\n         )\n         from .models.pvt import PvtImageProcessor\n+        from .models.qwen2_vl import Qwen2VLImageProcessor\n         from .models.rt_detr import RTDetrImageProcessor\n         from .models.sam import SamImageProcessor\n         from .models.segformer import SegformerFeatureExtractor, SegformerImageProcessor\n@@ -7457,6 +7474,11 @@\n             Qwen2MoeModel,\n             Qwen2MoePreTrainedModel,\n         )\n+        from .models.qwen2_vl import (\n+            Qwen2VLForConditionalGeneration,\n+            Qwen2VLModel,\n+            Qwen2VLPreTrainedModel,\n+        )\n         from .models.rag import (\n             RagModel,\n             RagPreTrainedModel,"
        },
        {
            "sha": "fa05f83eee0923d851c88b750311b146d1c8494d",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -193,6 +193,7 @@\n     qwen2,\n     qwen2_audio,\n     qwen2_moe,\n+    qwen2_vl,\n     rag,\n     recurrent_gemma,\n     reformer,"
        },
        {
            "sha": "ed6aa19f602c15290b44851d4a1b75aa6650269f",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -213,6 +213,7 @@\n         (\"qwen2_audio\", \"Qwen2AudioConfig\"),\n         (\"qwen2_audio_encoder\", \"Qwen2AudioEncoderConfig\"),\n         (\"qwen2_moe\", \"Qwen2MoeConfig\"),\n+        (\"qwen2_vl\", \"Qwen2VLConfig\"),\n         (\"rag\", \"RagConfig\"),\n         (\"realm\", \"RealmConfig\"),\n         (\"recurrent_gemma\", \"RecurrentGemmaConfig\"),\n@@ -513,6 +514,7 @@\n         (\"qwen2_audio\", \"Qwen2Audio\"),\n         (\"qwen2_audio_encoder\", \"Qwen2AudioEncoder\"),\n         (\"qwen2_moe\", \"Qwen2MoE\"),\n+        (\"qwen2_vl\", \"Qwen2VL\"),\n         (\"rag\", \"RAG\"),\n         (\"realm\", \"REALM\"),\n         (\"recurrent_gemma\", \"RecurrentGemma\"),"
        },
        {
            "sha": "06809d371171c9e448efe033d3d3b32cbf725541",
            "filename": "src/transformers/models/auto/image_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -116,6 +116,7 @@\n             (\"poolformer\", (\"PoolFormerImageProcessor\",)),\n             (\"pvt\", (\"PvtImageProcessor\",)),\n             (\"pvt_v2\", (\"PvtImageProcessor\",)),\n+            (\"qwen2_vl\", (\"Qwen2VLImageProcessor\",)),\n             (\"regnet\", (\"ConvNextImageProcessor\",)),\n             (\"resnet\", (\"ConvNextImageProcessor\",)),\n             (\"rt_detr\", \"RTDetrImageProcessor\"),"
        },
        {
            "sha": "bb47857bd0c69006a31787323ed5f6757c2b0163",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -200,6 +200,7 @@\n         (\"qwen2\", \"Qwen2Model\"),\n         (\"qwen2_audio_encoder\", \"Qwen2AudioEncoder\"),\n         (\"qwen2_moe\", \"Qwen2MoeModel\"),\n+        (\"qwen2_vl\", \"Qwen2VLModel\"),\n         (\"recurrent_gemma\", \"RecurrentGemmaModel\"),\n         (\"reformer\", \"ReformerModel\"),\n         (\"regnet\", \"RegNetModel\"),\n@@ -726,6 +727,7 @@\n         (\"llava_next_video\", \"LlavaNextVideoForConditionalGeneration\"),\n         (\"paligemma\", \"PaliGemmaForConditionalGeneration\"),\n         (\"pix2struct\", \"Pix2StructForConditionalGeneration\"),\n+        (\"qwen2_vl\", \"Qwen2VLForConditionalGeneration\"),\n         (\"video_llava\", \"VideoLlavaForConditionalGeneration\"),\n         (\"vipllava\", \"VipLlavaForConditionalGeneration\"),\n         (\"vision-encoder-decoder\", \"VisionEncoderDecoderModel\"),"
        },
        {
            "sha": "197e4a1ebaa036864c4f9940020621f8bfff8fee",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -83,6 +83,7 @@\n         (\"pix2struct\", \"Pix2StructProcessor\"),\n         (\"pop2piano\", \"Pop2PianoProcessor\"),\n         (\"qwen2_audio\", \"Qwen2AudioProcessor\"),\n+        (\"qwen2_vl\", \"Qwen2VLProcessor\"),\n         (\"sam\", \"SamProcessor\"),\n         (\"seamless_m4t\", \"SeamlessM4TProcessor\"),\n         (\"sew\", \"Wav2Vec2Processor\"),"
        },
        {
            "sha": "08a0e8f15542e5f988681d3bd09a0223a65bbc34",
            "filename": "src/transformers/models/qwen2_vl/__init__.py",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2F__init__.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -0,0 +1,74 @@\n+# Copyright 2024 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import OptionalDependencyNotAvailable, _LazyModule, is_torch_available, is_vision_available\n+\n+\n+_import_structure = {\n+    \"configuration_qwen2_vl\": [\"Qwen2VLConfig\"],\n+    \"processing_qwen2_vl\": [\"Qwen2VLProcessor\"],\n+}\n+\n+\n+try:\n+    if not is_torch_available():\n+        raise OptionalDependencyNotAvailable()\n+except OptionalDependencyNotAvailable:\n+    pass\n+else:\n+    _import_structure[\"modeling_qwen2_vl\"] = [\n+        \"Qwen2VLForConditionalGeneration\",\n+        \"Qwen2VLModel\",\n+        \"Qwen2VLPreTrainedModel\",\n+    ]\n+\n+try:\n+    if not is_vision_available():\n+        raise OptionalDependencyNotAvailable()\n+except OptionalDependencyNotAvailable:\n+    pass\n+else:\n+    _import_structure[\"image_processing_qwen2_vl\"] = [\"Qwen2VLImageProcessor\"]\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_qwen2_vl import Qwen2VLConfig\n+    from .processing_qwen2_vl import Qwen2VLProcessor\n+\n+    try:\n+        if not is_torch_available():\n+            raise OptionalDependencyNotAvailable()\n+    except OptionalDependencyNotAvailable:\n+        pass\n+    else:\n+        from .modeling_qwen2_vl import (\n+            Qwen2VLForConditionalGeneration,\n+            Qwen2VLModel,\n+            Qwen2VLPreTrainedModel,\n+        )\n+\n+    try:\n+        if not is_vision_available():\n+            raise OptionalDependencyNotAvailable()\n+    except OptionalDependencyNotAvailable:\n+        pass\n+    else:\n+        from .image_processing_qwen2_vl import Qwen2VLImageProcessor\n+\n+\n+else:\n+    import sys\n+\n+    sys.modules[__name__] = _LazyModule(__name__, globals()[\"__file__\"], _import_structure)"
        },
        {
            "sha": "a8220e32eb18a5313fb7f90a5deda45b25dc846f",
            "filename": "src/transformers/models/qwen2_vl/configuration_qwen2_vl.py",
            "status": "added",
            "additions": 206,
            "deletions": 0,
            "changes": 206,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fconfiguration_qwen2_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fconfiguration_qwen2_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fconfiguration_qwen2_vl.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -0,0 +1,206 @@\n+# coding=utf-8\n+# Copyright 2024 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Qwen2VL model configuration\"\"\"\n+\n+import os\n+from typing import Union\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...utils import logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Qwen2VLVisionConfig(PretrainedConfig):\n+    model_type = \"qwen2_vl\"\n+\n+    def __init__(\n+        self,\n+        depth=32,\n+        embed_dim=1280,\n+        hidden_size=3584,\n+        hidden_act=\"quick_gelu\",\n+        mlp_ratio=4,\n+        num_heads=16,\n+        in_channels=3,\n+        patch_size=14,\n+        spatial_merge_size=2,\n+        temporal_patch_size=2,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.depth = depth\n+        self.embed_dim = embed_dim\n+        self.hidden_size = hidden_size\n+        self.hidden_act = hidden_act\n+        self.mlp_ratio = mlp_ratio\n+        self.num_heads = num_heads\n+        self.in_channels = in_channels\n+        self.patch_size = patch_size\n+        self.spatial_merge_size = spatial_merge_size\n+        self.temporal_patch_size = temporal_patch_size\n+\n+    @classmethod\n+    def from_pretrained(cls, pretrained_model_name_or_path: Union[str, os.PathLike], **kwargs) -> \"PretrainedConfig\":\n+        cls._set_token_in_kwargs(kwargs)\n+\n+        config_dict, kwargs = cls.get_config_dict(pretrained_model_name_or_path, **kwargs)\n+\n+        if config_dict.get(\"model_type\") == \"qwen2_vl\":\n+            config_dict = config_dict[\"vision_config\"]\n+\n+        if \"model_type\" in config_dict and hasattr(cls, \"model_type\") and config_dict[\"model_type\"] != cls.model_type:\n+            logger.warning(\n+                f\"You are using a model of type {config_dict['model_type']} to instantiate a model of type \"\n+                f\"{cls.model_type}. This is not supported for all configurations of models and can yield errors.\"\n+            )\n+\n+        return cls.from_dict(config_dict, **kwargs)\n+\n+\n+class Qwen2VLConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen2VLModel`]. It is used to instantiate a\n+    Qwen2-VL model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of\n+    Qwen2-VL-7B-Instruct [Qwen/Qwen2-VL-7B-Instruct](https://huggingface.co/Qwen/Qwen2-VL-7B-Instruct).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 152064):\n+            Vocabulary size of the Qwen2VL model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Qwen2VLModel`]\n+        hidden_size (`int`, *optional*, defaults to 8192):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 29568):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 80):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 64):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 8):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `32`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 32768):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_theta (`float`, *optional*, defaults to 1000000.0):\n+            The base period of the RoPE embeddings.\n+        use_sliding_window (`bool`, *optional*, defaults to `False`):\n+            Whether to use sliding window attention.\n+        sliding_window (`int`, *optional*, defaults to 4096):\n+            Sliding window attention (SWA) window size. If not specified, will default to `4096`.\n+        max_window_layers (`int`, *optional*, defaults to 80):\n+            The number of layers that use SWA (Sliding Window Attention). The bottom layers use SWA while the top use full attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        vision_config (`Dict`, *optional*):\n+            The config for the visual encoder initialization.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. Currently supports two scaling\n+            strategies: linear and dynamic. Their scaling factor must be a float greater than 1. The expected format is\n+            `{\"type\": strategy name, \"factor\": scaling factor}`. When using this flag, don't update\n+            `max_position_embeddings` to the expected new maximum. See the following thread for more information on how\n+            these scaling strategies behave:\n+            https://www.reddit.com/r/LocalLLaMA/comments/14mrgpr/dynamically_scaled_rope_further_increases/. This is an\n+            experimental feature, subject to breaking API changes in future versions.\n+\n+    ```python\n+    >>> from transformers import Qwen2VLForConditionalGeneration, Qwen2VLConfig\n+\n+    >>> # Initializing a Qwen2VL style configuration\n+    >>> configuration = Qwen2VLConfig()\n+\n+    >>> # Initializing a model from the Qwen2-VL-7B style configuration\n+    >>> model = Qwen2VLForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen2_vl\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        vocab_size=152064,\n+        hidden_size=8192,\n+        intermediate_size=29568,\n+        num_hidden_layers=80,\n+        num_attention_heads=64,\n+        num_key_value_heads=8,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=32768,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-05,\n+        use_cache=True,\n+        tie_word_embeddings=False,\n+        rope_theta=1000000.0,\n+        use_sliding_window=False,\n+        sliding_window=4096,\n+        max_window_layers=80,\n+        attention_dropout=0.0,\n+        vision_config=None,\n+        rope_scaling=None,\n+        **kwargs,\n+    ):\n+        if isinstance(vision_config, dict):\n+            self.vision_config = Qwen2VLVisionConfig(**vision_config)\n+        elif vision_config is None:\n+            self.vision_config = Qwen2VLVisionConfig()\n+\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.use_sliding_window = use_sliding_window\n+        self.sliding_window = sliding_window\n+        self.max_window_layers = max_window_layers\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.attention_dropout = attention_dropout\n+        self.rope_scaling = rope_scaling\n+\n+        super().__init__(tie_word_embeddings=tie_word_embeddings, **kwargs)"
        },
        {
            "sha": "2b3024187bf7f53e255ba27b734dc4b6537fb604",
            "filename": "src/transformers/models/qwen2_vl/image_processing_qwen2_vl.py",
            "status": "added",
            "additions": 458,
            "deletions": 0,
            "changes": 458,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fimage_processing_qwen2_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fimage_processing_qwen2_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fimage_processing_qwen2_vl.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -0,0 +1,458 @@\n+# coding=utf-8\n+# Copyright 2024 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Image processor class for Qwen2-VL.\"\"\"\n+\n+import math\n+from typing import Dict, List, Optional, Union\n+\n+import numpy as np\n+\n+from ...image_processing_utils import BaseImageProcessor, BatchFeature\n+from ...image_transforms import (\n+    convert_to_rgb,\n+    resize,\n+    to_channel_dimension_format,\n+)\n+from ...image_utils import (\n+    OPENAI_CLIP_MEAN,\n+    OPENAI_CLIP_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    VideoInput,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    is_scaled_image,\n+    is_valid_image,\n+    make_list_of_images,\n+    to_numpy_array,\n+    valid_images,\n+    validate_preprocess_arguments,\n+)\n+from ...utils import TensorType, is_vision_available, logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+def make_batched_images(images) -> List[List[ImageInput]]:\n+    \"\"\"\n+    Accepts images in list or nested list format, and makes a list of images for preprocessing.\n+\n+    Args:\n+        images (`Union[List[List[ImageInput]], List[ImageInput], ImageInput]`):\n+            The input image.\n+\n+    Returns:\n+        list: A list of images.\n+    \"\"\"\n+    if isinstance(images, (list, tuple)) and isinstance(images[0], (list, tuple)) and is_valid_image(images[0][0]):\n+        return [img for img_list in images for img in img_list]\n+\n+    elif isinstance(images, (list, tuple)) and is_valid_image(images[0]):\n+        return images\n+\n+    elif is_valid_image(images):\n+        return [images]\n+\n+    raise ValueError(f\"Could not make batched images from {images}\")\n+\n+\n+# Copied from transformers.models.llava_next_video.image_processing_llava_next_video.make_batched_videos\n+def make_batched_videos(videos) -> List[VideoInput]:\n+    if isinstance(videos, (list, tuple)) and isinstance(videos[0], (list, tuple)) and is_valid_image(videos[0][0]):\n+        return videos\n+\n+    elif isinstance(videos, (list, tuple)) and is_valid_image(videos[0]):\n+        if isinstance(videos[0], Image.Image):\n+            return [videos]\n+        elif len(videos[0].shape) == 4:\n+            return [list(video) for video in videos]\n+\n+    elif is_valid_image(videos) and len(videos.shape) == 4:\n+        return [list(videos)]\n+\n+    raise ValueError(f\"Could not make batched video from {videos}\")\n+\n+\n+def smart_resize(\n+    height: int, width: int, factor: int = 28, min_pixels: int = 56 * 56, max_pixels: int = 14 * 14 * 4 * 1280\n+):\n+    \"\"\"Rescales the image so that the following conditions are met:\n+\n+    1. Both dimensions (height and width) are divisible by 'factor'.\n+\n+    2. The total number of pixels is within the range ['min_pixels', 'max_pixels'].\n+\n+    3. The aspect ratio of the image is maintained as closely as possible.\n+\n+    \"\"\"\n+    if height < factor or width < factor:\n+        raise ValueError(f\"height:{height} or width:{width} must be larger than factor:{factor}\")\n+    elif max(height, width) / min(height, width) > 200:\n+        raise ValueError(\n+            f\"absolute aspect ratio must be smaller than 200, got {max(height, width) / min(height, width)}\"\n+        )\n+    h_bar = round(height / factor) * factor\n+    w_bar = round(width / factor) * factor\n+    if h_bar * w_bar > max_pixels:\n+        beta = math.sqrt((height * width) / max_pixels)\n+        h_bar = math.floor(height / beta / factor) * factor\n+        w_bar = math.floor(width / beta / factor) * factor\n+    elif h_bar * w_bar < min_pixels:\n+        beta = math.sqrt(min_pixels / (height * width))\n+        h_bar = math.ceil(height * beta / factor) * factor\n+        w_bar = math.ceil(width * beta / factor) * factor\n+    return h_bar, w_bar\n+\n+\n+class Qwen2VLImageProcessor(BaseImageProcessor):\n+    r\"\"\"\n+    Constructs a Qwen2-VL image processor that dynamically resizes images based on the original images.\n+\n+    Args:\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image's (height, width) dimensions.\n+        resample (`PILImageResampling`, *optional*, defaults to `Resampling.BICUBIC`):\n+            Resampling filter to use when resizing the image.\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image by the specified scale `rescale_factor`.\n+        rescale_factor (`int` or `float`, *optional*, defaults to `1/255`):\n+            Scale factor to use if rescaling the image.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image.\n+        image_mean (`float` or `List[float]`, *optional*, defaults to `[0.48145466, 0.4578275, 0.40821073]`):\n+            Mean to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        image_std (`float` or `List[float]`, *optional*, defaults to `[0.26862954, 0.26130258, 0.27577711]`):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB.\n+        min_pixels (`int`, *optional*, defaults to `56 * 56`):\n+            The min pixels of the image to resize the image.\n+        max_pixels (`int`, *optional*, defaults to `28 * 28 * 1280`):\n+            The max pixels of the image to resize the image.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spacial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The temporal patch size of the vision encoder.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    model_input_names = [\"pixel_values\", \"image_grid_thw\", \"pixel_values_videos\", \"video_grid_thw\"]\n+\n+    def __init__(\n+        self,\n+        do_resize: bool = True,\n+        resample: PILImageResampling = PILImageResampling.BICUBIC,\n+        do_rescale: bool = True,\n+        rescale_factor: Union[int, float] = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_convert_rgb: bool = True,\n+        min_pixels: int = 56 * 56,\n+        max_pixels: int = 28 * 28 * 1280,\n+        patch_size: int = 14,\n+        temporal_patch_size: int = 2,\n+        merge_size: int = 2,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        self.do_resize = do_resize\n+        self.resample = resample\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean if image_mean is not None else OPENAI_CLIP_MEAN\n+        self.image_std = image_std if image_std is not None else OPENAI_CLIP_STD\n+        self.min_pixels = min_pixels\n+        self.max_pixels = max_pixels\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.merge_size = merge_size\n+        self.size = {\"min_pixels\": min_pixels, \"max_pixels\": max_pixels}\n+        self.do_convert_rgb = do_convert_rgb\n+\n+    def _preprocess(\n+        self,\n+        images: Union[ImageInput, VideoInput],\n+        do_resize: bool = None,\n+        resample: PILImageResampling = None,\n+        do_rescale: bool = None,\n+        rescale_factor: float = None,\n+        do_normalize: bool = None,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_convert_rgb: bool = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n+\n+        Args:\n+            images (`ImageInput`):\n+                Image or batch of images to preprocess. Expects pixel values ranging from 0 to 255. If pixel values range from 0 to 1, set `do_rescale=False`.\n+            vision_info (`List[Dict]`, *optional*):\n+                Optional list of dictionaries containing additional information about vision inputs.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the `PILImageResampling` enums.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Scale factor to use if rescaling the image.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Mean to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Standard deviation to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            data_format (`ChannelDimension`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.   - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+        images = make_list_of_images(images)\n+\n+        if do_convert_rgb:\n+            images = [convert_to_rgb(image) for image in images]\n+\n+        # All transformations expect numpy arrays.\n+        images = [to_numpy_array(image) for image in images]\n+\n+        if is_scaled_image(images[0]) and do_rescale:\n+            logger.warning_once(\n+                \"It looks like you are trying to rescale already rescaled images. If the input\"\n+                \" images have pixel values between 0 and 1, set `do_rescale=False` to avoid rescaling them again.\"\n+            )\n+        if input_data_format is None:\n+            # We assume that all images have the same channel dimension format.\n+            input_data_format = infer_channel_dimension_format(images[0])\n+\n+        height, width = get_image_size(images[0], channel_dim=input_data_format)\n+        resized_height, resized_width = height, width\n+        processed_images = []\n+        for image in images:\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    height,\n+                    width,\n+                    factor=self.patch_size * self.merge_size,\n+                    min_pixels=self.min_pixels,\n+                    max_pixels=self.max_pixels,\n+                )\n+                image = resize(\n+                    image, size=(resized_height, resized_width), resample=resample, input_data_format=input_data_format\n+                )\n+\n+            if do_rescale:\n+                image = self.rescale(image, scale=rescale_factor, input_data_format=input_data_format)\n+\n+            if do_normalize:\n+                image = self.normalize(\n+                    image=image, mean=image_mean, std=image_std, input_data_format=input_data_format\n+                )\n+\n+            image = to_channel_dimension_format(image, data_format, input_channel_dim=input_data_format)\n+            processed_images.append(image)\n+\n+        patches = np.array(processed_images)\n+        if data_format == ChannelDimension.LAST:\n+            patches = patches.transpose(0, 3, 1, 2)\n+        if patches.shape[0] == 1:\n+            patches = np.tile(patches, (self.temporal_patch_size, 1, 1, 1))\n+        channel = patches.shape[1]\n+        grid_t = patches.shape[0] // self.temporal_patch_size\n+        grid_h, grid_w = resized_height // self.patch_size, resized_width // self.patch_size\n+        patches = patches.reshape(\n+            grid_t,\n+            self.temporal_patch_size,\n+            channel,\n+            grid_h // self.merge_size,\n+            self.merge_size,\n+            self.patch_size,\n+            grid_w // self.merge_size,\n+            self.merge_size,\n+            self.patch_size,\n+        )\n+        patches = patches.transpose(0, 3, 6, 4, 7, 2, 1, 5, 8)\n+        flatten_patches = patches.reshape(\n+            grid_t * grid_h * grid_w, channel * self.temporal_patch_size * self.patch_size * self.patch_size\n+        )\n+\n+        return flatten_patches, (grid_t, grid_h, grid_w)\n+\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        videos: VideoInput = None,\n+        do_resize: bool = None,\n+        size: Dict[str, int] = None,\n+        resample: PILImageResampling = None,\n+        do_rescale: bool = None,\n+        rescale_factor: float = None,\n+        do_normalize: bool = None,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_convert_rgb: bool = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Args:\n+            images (`ImageInput`):\n+                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n+                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n+            videos (`VideoInput`):\n+                Video to preprocess. Expects a single or batch of videos with pixel values ranging from 0 to 255. If\n+                passing in videos with pixel values between 0 and 1, set `do_rescale=False`.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n+                the longest edge resized to keep the input aspect ratio.\n+            resample (`int`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n+                has an effect if `do_resize` is set to `True`.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n+                `True`.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                - Unset: Return a list of `np.ndarray`.\n+                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n+                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n+            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n+                from the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+\n+        \"\"\"\n+        do_resize = do_resize if do_resize is not None else self.do_resize\n+        size = size if size is not None else self.size\n+        resample = resample if resample is not None else self.resample\n+        do_rescale = do_rescale if do_rescale is not None else self.do_rescale\n+        rescale_factor = rescale_factor if rescale_factor is not None else self.rescale_factor\n+        do_normalize = do_normalize if do_normalize is not None else self.do_normalize\n+        image_mean = image_mean if image_mean is not None else self.image_mean\n+        image_std = image_std if image_std is not None else self.image_std\n+        do_convert_rgb = do_convert_rgb if do_convert_rgb is not None else self.do_convert_rgb\n+\n+        if images is not None:\n+            images = make_batched_images(images)\n+        if videos is not None:\n+            videos = make_batched_videos(videos)\n+\n+        if images is not None and not valid_images(images):\n+            raise ValueError(\n+                \"Invalid image type. Must be of type PIL.Image.Image, numpy.ndarray, \"\n+                \"torch.Tensor, tf.Tensor or jax.ndarray.\"\n+            )\n+\n+        validate_preprocess_arguments(\n+            rescale_factor=rescale_factor,\n+            do_normalize=do_normalize,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            do_resize=do_resize,\n+            size=size,\n+            resample=resample,\n+        )\n+\n+        if images is not None:\n+            pixel_values, vision_grid_thws = [], []\n+            for image in images:\n+                patches, image_grid_thw = self._preprocess(\n+                    image,\n+                    do_resize=do_resize,\n+                    resample=resample,\n+                    do_rescale=do_rescale,\n+                    rescale_factor=rescale_factor,\n+                    do_normalize=do_normalize,\n+                    image_mean=image_mean,\n+                    image_std=image_std,\n+                    data_format=data_format,\n+                    do_convert_rgb=do_convert_rgb,\n+                    input_data_format=input_data_format,\n+                )\n+                pixel_values.extend(patches)\n+                vision_grid_thws.append(image_grid_thw)\n+            pixel_values = np.array(pixel_values)\n+            vision_grid_thws = np.array(vision_grid_thws)\n+            data = {\"pixel_values\": pixel_values, \"image_grid_thw\": vision_grid_thws}\n+\n+        if videos is not None:\n+            pixel_values, vision_grid_thws = [], []\n+            for images in videos:\n+                patches, video_grid_thw = self._preprocess(\n+                    images,\n+                    do_resize=do_resize,\n+                    resample=resample,\n+                    do_rescale=do_rescale,\n+                    rescale_factor=rescale_factor,\n+                    do_normalize=do_normalize,\n+                    image_mean=image_mean,\n+                    image_std=image_std,\n+                    data_format=data_format,\n+                    do_convert_rgb=do_convert_rgb,\n+                    input_data_format=input_data_format,\n+                )\n+                pixel_values.extend(patches)\n+                vision_grid_thws.append(video_grid_thw)\n+            pixel_values = np.array(pixel_values)\n+            vision_grid_thws = np.array(vision_grid_thws)\n+            data = {\"pixel_values_videos\": pixel_values, \"video_grid_thw\": vision_grid_thws}\n+\n+        return BatchFeature(data=data, tensor_type=return_tensors)"
        },
        {
            "sha": "13bacdc1993f559156ffb6f0e5272aa100b2eef5",
            "filename": "src/transformers/models/qwen2_vl/modeling_qwen2_vl.py",
            "status": "added",
            "additions": 1725,
            "deletions": 0,
            "changes": 1725,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fmodeling_qwen2_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fmodeling_qwen2_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fmodeling_qwen2_vl.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -0,0 +1,1725 @@\n+# coding=utf-8\n+# Copyright 2024 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch Qwen2-VL model.\"\"\"\n+\n+import math\n+from dataclasses import dataclass\n+from typing import Any, Dict, List, Optional, Tuple, Union\n+\n+import torch\n+import torch.nn as nn\n+import torch.nn.functional as F\n+import torch.utils.checkpoint\n+from torch.nn import CrossEntropyLoss, LayerNorm\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, StaticCache\n+from ...modeling_attn_mask_utils import (\n+    AttentionMaskConverter,\n+)\n+from ...modeling_outputs import (\n+    BaseModelOutputWithPast,\n+    ModelOutput,\n+)\n+from ...modeling_utils import PreTrainedModel\n+from ...utils import (\n+    add_start_docstrings,\n+    add_start_docstrings_to_model_forward,\n+    is_flash_attn_2_available,\n+    is_flash_attn_greater_or_equal_2_10,\n+    logging,\n+    replace_return_docstrings,\n+)\n+from .configuration_qwen2_vl import Qwen2VLConfig, Qwen2VLVisionConfig\n+\n+\n+if is_flash_attn_2_available():\n+    from flash_attn import flash_attn_varlen_func\n+\n+    from ...modeling_flash_attention_utils import _flash_attention_forward\n+else:\n+    flash_attn_varlen_func = None\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+_CONFIG_FOR_DOC = \"Qwen2VLConfig\"\n+\n+\n+@dataclass\n+class Qwen2VLCausalLMOutputWithPast(ModelOutput):\n+    \"\"\"\n+    Base class for Qwen2VL causal language model (or autoregressive) outputs.\n+\n+    Args:\n+        loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+            Language modeling loss (for next-token prediction).\n+        logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n+            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+            `past_key_values` input) to speed up sequential decoding.\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: torch.FloatTensor = None\n+    past_key_values: Optional[List[torch.FloatTensor]] = None\n+    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+    attentions: Optional[Tuple[torch.FloatTensor]] = None\n+    rope_deltas: Optional[torch.LongTensor] = None\n+\n+\n+# Copied from transformers.models.qwen2.modeling_qwen2.Qwen2RotaryEmbedding\n+class Qwen2RotaryEmbedding(nn.Module):\n+    def __init__(self, dim, max_position_embeddings=2048, base=10000, device=None):\n+        super().__init__()\n+\n+        self.dim = dim\n+        self.max_position_embeddings = max_position_embeddings\n+        self.base = base\n+        inv_freq = 1.0 / (self.base ** (torch.arange(0, self.dim, 2, dtype=torch.int64).float().to(device) / self.dim))\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+\n+        # Build here to make `torch.jit.trace` work.\n+        self._set_cos_sin_cache(\n+            seq_len=max_position_embeddings, device=self.inv_freq.device, dtype=torch.get_default_dtype()\n+        )\n+\n+    def _set_cos_sin_cache(self, seq_len, device, dtype):\n+        self.max_seq_len_cached = seq_len\n+        t = torch.arange(self.max_seq_len_cached, device=device, dtype=torch.int64).type_as(self.inv_freq)\n+\n+        freqs = torch.outer(t, self.inv_freq)\n+        # Different from paper, but it uses a different permutation in order to obtain the same calculation\n+        emb = torch.cat((freqs, freqs), dim=-1)\n+        self.register_buffer(\"cos_cached\", emb.cos().to(dtype), persistent=False)\n+        self.register_buffer(\"sin_cached\", emb.sin().to(dtype), persistent=False)\n+\n+    def forward(self, x, seq_len=None):\n+        # x: [bs, num_attention_heads, seq_len, head_size]\n+        if seq_len > self.max_seq_len_cached:\n+            self._set_cos_sin_cache(seq_len=seq_len, device=x.device, dtype=x.dtype)\n+\n+        return (\n+            self.cos_cached[:seq_len].to(dtype=x.dtype),\n+            self.sin_cached[:seq_len].to(dtype=x.dtype),\n+        )\n+\n+\n+# Copied from transformers.models.llama.modeling_llama.rotate_half\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+def apply_multimodal_rotary_pos_emb(q, k, cos, sin, position_ids, mrope_section, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding with Multimodal Sections to the query and key tensors (https://qwenlm.github.io/blog/qwen2-vl/).\n+\n+    Explanation:\n+        Multimodal 3D rotary position embedding is an extension to 1D rotary position embedding. The input embedding\n+        sequence contains vision (images / videos) embedding and text embedding or just contains text embedding. For\n+        vision embedding part, we apply rotary position embedding on temporal, height and width dimension seperately.\n+        Here we split the channel dimension to 3 chunks for the temporal, height and width rotary position embedding.\n+        For text embedding part, we just apply 1D rotary position embedding. The three rotary position index (temporal,\n+        height and width) of text embedding is always the same, so the text embedding rotary position embedding has no\n+        difference with modern LLMs.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`):\n+            The position indices of the tokens corresponding to the query and key tensors. For example, this can be\n+            used to pass offsetted position ids when working with a KV-cache.\n+        mrope_section(`List(int)`):\n+            Multimodal rope section is for channel dimension of temporal, height and width in rope calculation.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    cos = cos[position_ids]\n+    sin = sin[position_ids]\n+    mrope_section = mrope_section * 2\n+    cos = torch.cat([m[i % 3] for i, m in enumerate(cos.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+    sin = torch.cat([m[i % 3] for i, m in enumerate(sin.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    return q_embed, k_embed\n+\n+\n+def apply_rotary_pos_emb_vision(tensor: torch.Tensor, freqs: torch.Tensor) -> torch.Tensor:\n+    orig_dtype = tensor.dtype\n+    tensor = tensor.float()\n+    cos = freqs.cos()\n+    sin = freqs.sin()\n+    cos = cos.unsqueeze(1).repeat(1, 1, 2).unsqueeze(0).float()\n+    sin = sin.unsqueeze(1).repeat(1, 1, 2).unsqueeze(0).float()\n+    output = (tensor * cos) + (rotate_half(tensor) * sin)\n+    output = output.to(orig_dtype)\n+    return output\n+\n+\n+class VisionRotaryEmbedding(nn.Module):\n+    def __init__(self, dim: int, theta: float = 10000.0) -> None:\n+        super().__init__()\n+        inv_freq = 1.0 / (theta ** (torch.arange(0, dim, 2, dtype=torch.float) / dim))\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+\n+    def forward(self, seqlen: int) -> torch.Tensor:\n+        seq = torch.arange(seqlen, device=self.inv_freq.device, dtype=self.inv_freq.dtype)\n+        freqs = torch.outer(seq, self.inv_freq)\n+        return freqs\n+\n+\n+class PatchEmbed(nn.Module):\n+    def __init__(\n+        self,\n+        patch_size: int = 14,\n+        temporal_patch_size: int = 2,\n+        in_channels: int = 3,\n+        embed_dim: int = 1152,\n+    ) -> None:\n+        super().__init__()\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.in_channels = in_channels\n+        self.embed_dim = embed_dim\n+\n+        kernel_size = [temporal_patch_size, patch_size, patch_size]\n+        self.proj = nn.Conv3d(in_channels, embed_dim, kernel_size=kernel_size, stride=kernel_size, bias=False)\n+\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        target_dtype = self.proj.weight.dtype\n+        hidden_states = hidden_states.view(\n+            -1, self.in_channels, self.temporal_patch_size, self.patch_size, self.patch_size\n+        )\n+        hidden_states = self.proj(hidden_states.to(dtype=target_dtype)).view(-1, self.embed_dim)\n+        return hidden_states\n+\n+\n+class PatchMerger(nn.Module):\n+    def __init__(self, dim: int, context_dim: int, spatial_merge_size: int = 2) -> None:\n+        super().__init__()\n+        self.hidden_size = context_dim * (spatial_merge_size**2)\n+        self.ln_q = LayerNorm(context_dim, eps=1e-6)\n+        self.mlp = nn.Sequential(\n+            nn.Linear(self.hidden_size, self.hidden_size),\n+            nn.GELU(),\n+            nn.Linear(self.hidden_size, dim),\n+        )\n+\n+    def forward(self, x: torch.Tensor) -> torch.Tensor:\n+        x = self.mlp(self.ln_q(x).view(-1, self.hidden_size))\n+        return x\n+\n+\n+class VisionMlp(nn.Module):\n+    def __init__(self, dim: int, hidden_dim: int, hidden_act: str) -> None:\n+        super().__init__()\n+        self.fc1 = nn.Linear(dim, hidden_dim)\n+        self.act = ACT2FN[hidden_act]\n+        self.fc2 = nn.Linear(hidden_dim, dim)\n+\n+    def forward(self, x) -> torch.Tensor:\n+        return self.fc2(self.act(self.fc1(x)))\n+\n+\n+class VisionAttention(nn.Module):\n+    def __init__(self, dim: int, num_heads: int = 16) -> None:\n+        super().__init__()\n+        self.num_heads = num_heads\n+        self.qkv = nn.Linear(dim, dim * 3, bias=True)\n+        self.proj = nn.Linear(dim, dim)\n+\n+    def forward(\n+        self, hidden_states: torch.Tensor, cu_seqlens: torch.Tensor, rotary_pos_emb: torch.Tensor = None\n+    ) -> torch.Tensor:\n+        seq_length = hidden_states.shape[0]\n+        q, k, v = self.qkv(hidden_states).reshape(seq_length, 3, self.num_heads, -1).permute(1, 0, 2, 3).unbind(0)\n+        q = apply_rotary_pos_emb_vision(q.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+        k = apply_rotary_pos_emb_vision(k.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+\n+        attention_mask = torch.zeros([1, seq_length, seq_length], device=q.device, dtype=torch.bool)\n+        for i in range(1, len(cu_seqlens)):\n+            attention_mask[..., cu_seqlens[i - 1] : cu_seqlens[i], cu_seqlens[i - 1] : cu_seqlens[i]] = True\n+\n+        q = q.transpose(0, 1)\n+        k = k.transpose(0, 1)\n+        v = v.transpose(0, 1)\n+        attn_weights = torch.matmul(q, k.transpose(1, 2)) / math.sqrt(self.head_dim)\n+        attn_weights = attn_weights + attention_mask\n+        attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(q.dtype)\n+        attn_output = torch.matmul(attn_weights, v)\n+        attn_output = attn_output.transpose(0, 1)\n+        attn_output = attn_output.reshape(seq_length, -1)\n+        attn_output = self.proj(attn_output)\n+        return attn_output\n+\n+\n+class VisionFlashAttention2(nn.Module):\n+    def __init__(self, dim: int, num_heads: int = 16) -> None:\n+        super().__init__()\n+        self.num_heads = num_heads\n+        self.qkv = nn.Linear(dim, dim * 3, bias=True)\n+        self.proj = nn.Linear(dim, dim)\n+\n+    def forward(\n+        self, hidden_states: torch.Tensor, cu_seqlens: torch.Tensor, rotary_pos_emb: torch.Tensor = None\n+    ) -> torch.Tensor:\n+        seq_length = hidden_states.shape[0]\n+        q, k, v = self.qkv(hidden_states).reshape(seq_length, 3, self.num_heads, -1).permute(1, 0, 2, 3).unbind(0)\n+        q = apply_rotary_pos_emb_vision(q.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+        k = apply_rotary_pos_emb_vision(k.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+\n+        max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max().item()\n+        attn_output = flash_attn_varlen_func(q, k, v, cu_seqlens, cu_seqlens, max_seqlen, max_seqlen).reshape(\n+            seq_length, -1\n+        )\n+        attn_output = self.proj(attn_output)\n+        return attn_output\n+\n+\n+class VisionSdpaAttention(nn.Module):\n+    def __init__(self, dim: int, num_heads: int = 16) -> None:\n+        super().__init__()\n+        self.num_heads = num_heads\n+        self.qkv = nn.Linear(dim, dim * 3, bias=True)\n+        self.proj = nn.Linear(dim, dim)\n+\n+    def forward(\n+        self, hidden_states: torch.Tensor, cu_seqlens: torch.Tensor, rotary_pos_emb: torch.Tensor = None\n+    ) -> torch.Tensor:\n+        seq_length = hidden_states.shape[0]\n+        q, k, v = self.qkv(hidden_states).reshape(seq_length, 3, self.num_heads, -1).permute(1, 0, 2, 3).unbind(0)\n+        q = apply_rotary_pos_emb_vision(q.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+        k = apply_rotary_pos_emb_vision(k.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+\n+        attention_mask = torch.zeros([1, seq_length, seq_length], device=q.device, dtype=torch.bool)\n+        for i in range(1, len(cu_seqlens)):\n+            attention_mask[..., cu_seqlens[i - 1] : cu_seqlens[i], cu_seqlens[i - 1] : cu_seqlens[i]] = True\n+        q = q.transpose(0, 1)\n+        k = k.transpose(0, 1)\n+        v = v.transpose(0, 1)\n+        attn_output = F.scaled_dot_product_attention(q, k, v, attention_mask, dropout_p=0.0)\n+        attn_output = attn_output.transpose(0, 1)\n+        attn_output = attn_output.reshape(seq_length, -1)\n+        attn_output = self.proj(attn_output)\n+        return attn_output\n+\n+\n+QWEN2_VL_VISION_ATTENTION_CLASSES = {\n+    \"eager\": VisionAttention,\n+    \"flash_attention_2\": VisionFlashAttention2,\n+    \"sdpa\": VisionSdpaAttention,\n+}\n+\n+\n+class Qwen2VLVisionBlock(nn.Module):\n+    def __init__(self, config, attn_implementation: str = \"sdpa\") -> None:\n+        super().__init__()\n+        self.norm1 = LayerNorm(config.embed_dim, eps=1e-6)\n+        self.norm2 = LayerNorm(config.embed_dim, eps=1e-6)\n+        mlp_hidden_dim = int(config.embed_dim * config.mlp_ratio)\n+\n+        self.attn = QWEN2_VL_VISION_ATTENTION_CLASSES[attn_implementation](\n+            config.embed_dim, num_heads=config.num_heads\n+        )\n+        self.mlp = VisionMlp(dim=config.embed_dim, hidden_dim=mlp_hidden_dim, hidden_act=config.hidden_act)\n+\n+    def forward(self, hidden_states, cu_seqlens, rotary_pos_emb) -> torch.Tensor:\n+        hidden_states = hidden_states + self.attn(\n+            self.norm1(hidden_states), cu_seqlens=cu_seqlens, rotary_pos_emb=rotary_pos_emb\n+        )\n+        hidden_states = hidden_states + self.mlp(self.norm2(hidden_states))\n+        return hidden_states\n+\n+\n+# Copied from transformers.models.llama.modeling_llama._prepare_4d_causal_attention_mask_with_cache_position\n+def _prepare_4d_causal_attention_mask_with_cache_position(\n+    attention_mask: torch.Tensor,\n+    sequence_length: int,\n+    target_length: int,\n+    dtype: torch.dtype,\n+    device: torch.device,\n+    min_dtype: float,\n+    cache_position: torch.Tensor,\n+    batch_size: int,\n+):\n+    \"\"\"\n+    Creates a causal 4D mask of shape `(batch_size, 1, query_length, key_value_length)` from a 2D mask of shape\n+    `(batch_size, key_value_length)`, or if the input `attention_mask` is already 4D, do nothing.\n+\n+    Args:\n+        attention_mask (`torch.Tensor`):\n+            A 2D attention mask of shape `(batch_size, key_value_length)` or a 4D attention mask of shape `(batch_size, 1, query_length, key_value_length)`.\n+        sequence_length (`int`):\n+            The sequence length being processed.\n+        target_length (`int`):\n+            The target length: when generating with static cache, the mask should be as long as the static cache, to account for the 0 padding, the part of the cache that is not filled yet.\n+        dtype (`torch.dtype`):\n+            The dtype to use for the 4D attention mask.\n+        device (`torch.device`):\n+            The device to plcae the 4D attention mask on.\n+        min_dtype (`float`):\n+            The minimum value representable with the dtype `dtype`.\n+        cache_position (`torch.Tensor`):\n+            Indices depicting the position of the input sequence tokens in the sequence.\n+        batch_size (`torch.Tensor`):\n+            Batch size.\n+    \"\"\"\n+    if attention_mask is not None and attention_mask.dim() == 4:\n+        # In this case we assume that the mask comes already in inverted form and requires no inversion or slicing.\n+        causal_mask = attention_mask\n+    else:\n+        causal_mask = torch.full((sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device)\n+        if sequence_length != 1:\n+            causal_mask = torch.triu(causal_mask, diagonal=1)\n+        causal_mask *= torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n+        causal_mask = causal_mask[None, None, :, :].expand(batch_size, 1, -1, -1)\n+        if attention_mask is not None:\n+            causal_mask = causal_mask.clone()  # copy to contiguous memory for in-place edit\n+            mask_length = attention_mask.shape[-1]\n+            padding_mask = causal_mask[:, :, :, :mask_length] + attention_mask[:, None, None, :]\n+            padding_mask = padding_mask == 0\n+            causal_mask[:, :, :, :mask_length] = causal_mask[:, :, :, :mask_length].masked_fill(\n+                padding_mask, min_dtype\n+            )\n+\n+    return causal_mask\n+\n+\n+# Copied from transformers.models.qwen2.modeling_qwen2.Qwen2RMSNorm\n+class Qwen2RMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        Qwen2RMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+# Copied from transformers.models.qwen2.modeling_qwen2.Qwen2MLP\n+class Qwen2MLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=False)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, hidden_state):\n+        return self.down_proj(self.act_fn(self.gate_proj(hidden_state)) * self.up_proj(hidden_state))\n+\n+\n+# Copied from transformers.models.llama.modeling_llama.repeat_kv\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+class Qwen2VLAttention(nn.Module):\n+    \"\"\"\n+    Multi-headed attention from 'Attention Is All You Need' paper. Modified to use sliding window attention: Longformer\n+    and \"Generating Long Sequences with Sparse Transformers\".\n+    \"\"\"\n+\n+    def __init__(self, config: Qwen2VLConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        if layer_idx is None:\n+            logger.warning_once(\n+                f\"Instantiating {self.__class__.__name__} without passing `layer_idx` is not recommended and will \"\n+                \"to errors during the forward call, if caching is used. Please make sure to provide a `layer_idx` \"\n+                \"when creating this class.\"\n+            )\n+\n+        self.hidden_size = config.hidden_size\n+        self.num_heads = config.num_attention_heads\n+        self.head_dim = self.hidden_size // self.num_heads\n+        self.num_key_value_heads = config.num_key_value_heads\n+        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n+        self.max_position_embeddings = config.max_position_embeddings\n+        self.rope_theta = config.rope_theta\n+        self.is_causal = True\n+        self.attention_dropout = config.attention_dropout\n+        self.rope_scaling = config.rope_scaling\n+\n+        if (self.head_dim * self.num_heads) != self.hidden_size:\n+            raise ValueError(\n+                f\"hidden_size must be divisible by num_heads (got `hidden_size`: {self.hidden_size}\"\n+                f\" and `num_heads`: {self.num_heads}).\"\n+            )\n+        self.q_proj = nn.Linear(self.hidden_size, self.num_heads * self.head_dim, bias=True)\n+        self.k_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=True)\n+        self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=True)\n+        self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=False)\n+\n+        self.rotary_emb = Qwen2RotaryEmbedding(\n+            self.head_dim,\n+            max_position_embeddings=self.max_position_embeddings,\n+            base=self.rope_theta,\n+        )\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+\n+        kv_seq_len = key_states.shape[-2]\n+        if past_key_value is not None:\n+            kv_seq_len += cache_position[0] + 1\n+\n+        cos, sin = self.rotary_emb(value_states, seq_len=kv_seq_len)\n+        query_states, key_states = apply_multimodal_rotary_pos_emb(\n+            query_states, key_states, cos, sin, position_ids, self.rope_scaling[\"mrope_section\"]\n+        )\n+\n+        if past_key_value is not None:\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}  # Specific to RoPE models\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        # repeat k/v heads if n_kv_heads < n_heads\n+        key_states = repeat_kv(key_states, self.num_key_value_groups)\n+        value_states = repeat_kv(value_states, self.num_key_value_groups)\n+\n+        attn_weights = torch.matmul(query_states, key_states.transpose(2, 3)) / math.sqrt(self.head_dim)\n+\n+        if attention_mask is not None:  # no matter the length, we just slice it\n+            causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+            attn_weights = attn_weights + causal_mask\n+\n+        # upcast attention to fp32\n+        attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query_states.dtype)\n+        attn_weights = nn.functional.dropout(attn_weights, p=self.attention_dropout, training=self.training)\n+        attn_output = torch.matmul(attn_weights, value_states)\n+\n+        if attn_output.size() != (bsz, self.num_heads, q_len, self.head_dim):\n+            raise ValueError(\n+                f\"`attn_output` should be of size {(bsz, self.num_heads, q_len, self.head_dim)}, but is\"\n+                f\" {attn_output.size()}\"\n+            )\n+\n+        attn_output = attn_output.transpose(1, 2).contiguous()\n+        attn_output = attn_output.reshape(bsz, q_len, -1)\n+\n+        attn_output = self.o_proj(attn_output)\n+\n+        if not output_attentions:\n+            attn_weights = None\n+\n+        return attn_output, attn_weights, past_key_value\n+\n+\n+class Qwen2VLFlashAttention2(Qwen2VLAttention):\n+    \"\"\"\n+    Qwen2VL flash attention module, following Qwen2VL attention module. This module inherits from `Qwen2VLAttention`\n+    as the weights of the module stays untouched. The only required change would be on the forward pass\n+    where it needs to correctly call the public API of flash attention and deal with padding tokens\n+    in case the input contains any of them. Additionally, for sliding window attention, we apply SWA only to the bottom\n+    config.max_window_layers layers.\n+    \"\"\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        # TODO: Should be removed once Flash Attention for RoCm is bumped to 2.1.\n+        # flash_attn<2.1 generates top-left aligned causal mask, while what is needed here is bottom-right alignement, that was made default for flash_attn>=2.1. This attribute is used to handle this difference. Reference: https://github.com/Dao-AILab/flash-attention/releases/tag/v2.1.0.\n+        # Beware that with flash_attn<2.1, using q_seqlen != k_seqlen (except for the case q_seqlen == 1) produces a wrong mask (top-left).\n+        self._flash_attn_uses_top_left_mask = not is_flash_attn_greater_or_equal_2_10()\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+    ):\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+\n+        kv_seq_len = key_states.shape[-2]\n+        if past_key_value is not None:\n+            kv_seq_len += cache_position[0] + 1\n+\n+        # Because the input can be padded, the absolute sequence length depends on the max position id.\n+        rotary_seq_len = cache_position[-1]\n+        cos, sin = self.rotary_emb(value_states, seq_len=rotary_seq_len)\n+\n+        query_states, key_states = apply_multimodal_rotary_pos_emb(\n+            query_states, key_states, cos, sin, position_ids, self.rope_scaling[\"mrope_section\"]\n+        )\n+\n+        if past_key_value is not None:\n+            # Activate slicing cache only if the config has a value `sliding_windows` attribute\n+            cache_has_contents = past_key_value.get_seq_length(self.layer_idx) > 0\n+            if (\n+                getattr(self.config, \"sliding_window\", None) is not None\n+                and kv_seq_len > self.config.sliding_window\n+                and cache_has_contents\n+            ):\n+                slicing_tokens = 1 - self.config.sliding_window\n+\n+                past_key = past_key_value[self.layer_idx][0]\n+                past_value = past_key_value[self.layer_idx][1]\n+\n+                past_key = past_key[:, :, slicing_tokens:, :].contiguous()\n+                past_value = past_value[:, :, slicing_tokens:, :].contiguous()\n+\n+                if past_key.shape[-2] != self.config.sliding_window - 1:\n+                    raise ValueError(\n+                        f\"past key must have a shape of (`batch_size, num_heads, self.config.sliding_window-1, head_dim`), got\"\n+                        f\" {past_key.shape}\"\n+                    )\n+\n+                if attention_mask is not None:\n+                    attention_mask = attention_mask[:, slicing_tokens:]\n+                    attention_mask = torch.cat([attention_mask, torch.ones_like(attention_mask[:, -1:])], dim=-1)\n+\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}  # Specific to RoPE models\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        # repeat k/v heads if n_kv_heads < n_heads\n+        key_states = repeat_kv(key_states, self.num_key_value_groups)\n+        value_states = repeat_kv(value_states, self.num_key_value_groups)\n+        dropout_rate = 0.0 if not self.training else self.attention_dropout\n+\n+        # In PEFT, usually we cast the layer norms in float32 for training stability reasons\n+        # therefore the input hidden states gets silently casted in float32. Hence, we need\n+        # cast them back in float16 just to be sure everything works as expected.\n+        input_dtype = query_states.dtype\n+        if input_dtype == torch.float32:\n+            if torch.is_autocast_enabled():\n+                target_dtype = torch.get_autocast_gpu_dtype()\n+            # Handle the case where the model is quantized\n+            elif hasattr(self.config, \"_pre_quantization_dtype\"):\n+                target_dtype = self.config._pre_quantization_dtype\n+            else:\n+                target_dtype = self.q_proj.weight.dtype\n+\n+            logger.warning_once(\n+                f\"The input hidden states seems to be silently casted in float32, this might be related to\"\n+                f\" the fact you have upcasted embedding or layer norm layers in float32. We will cast back the input in\"\n+                f\" {target_dtype}.\"\n+            )\n+\n+            query_states = query_states.to(target_dtype)\n+            key_states = key_states.to(target_dtype)\n+            value_states = value_states.to(target_dtype)\n+\n+        # Reashape to the expected shape for Flash Attention\n+        query_states = query_states.transpose(1, 2)\n+        key_states = key_states.transpose(1, 2)\n+        value_states = value_states.transpose(1, 2)\n+\n+        if (\n+            self.config.use_sliding_window\n+            and getattr(self.config, \"sliding_window\", None) is not None\n+            and self.layer_idx >= self.config.max_window_layers\n+        ):\n+            sliding_window = self.config.sliding_window\n+        else:\n+            sliding_window = None\n+\n+        attn_output = _flash_attention_forward(\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            q_len,\n+            dropout=dropout_rate,\n+            sliding_window=sliding_window,\n+            is_causal=self.is_causal,\n+            use_top_left_mask=self._flash_attn_uses_top_left_mask,\n+        )\n+\n+        attn_output = attn_output.reshape(bsz, q_len, self.hidden_size).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+\n+        if not output_attentions:\n+            attn_weights = None\n+\n+        return attn_output, attn_weights, past_key_value\n+\n+\n+class Qwen2VLSdpaAttention(Qwen2VLAttention):\n+    \"\"\"\n+    Qwen2 attention module using torch.nn.functional.scaled_dot_product_attention. This module inherits from\n+    `Qwen2Attention` as the weights of the module stays untouched. The only changes are on the forward pass to adapt to\n+    SDPA API.\n+    \"\"\"\n+\n+    # Adapted from Qwen2Attention.forward\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        if output_attentions:\n+            # TODO: Improve this warning with e.g. `model.config.attn_implementation = \"manual\"` once this is implemented.\n+            logger.warning_once(\n+                \"Qwen2VLModel is using Qwen2VLSdpaAttention, but `torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. Falling back to the manual attention implementation, \"\n+                'but specifying the manual implementation will be required from Transformers version v5.0.0 onwards. This warning can be removed using the argument `attn_implementation=\"eager\"` when loading the model.'\n+            )\n+            return super().forward(\n+                hidden_states=hidden_states,\n+                attention_mask=attention_mask,\n+                position_ids=position_ids,\n+                past_key_value=past_key_value,\n+                output_attentions=output_attentions,\n+                use_cache=use_cache,\n+            )\n+\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+\n+        kv_seq_len = key_states.shape[-2]\n+        if past_key_value is not None:\n+            kv_seq_len += past_key_value.get_usable_length(kv_seq_len, self.layer_idx)\n+        cos, sin = self.rotary_emb(value_states, seq_len=kv_seq_len)\n+        query_states, key_states = apply_multimodal_rotary_pos_emb(\n+            query_states, key_states, cos, sin, position_ids, self.rope_scaling[\"mrope_section\"]\n+        )\n+\n+        if past_key_value is not None:\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}  # Specific to RoPE models\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        key_states = repeat_kv(key_states, self.num_key_value_groups)\n+        value_states = repeat_kv(value_states, self.num_key_value_groups)\n+\n+        causal_mask = attention_mask\n+        if attention_mask is not None:  # no matter the length, we just slice it\n+            causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+\n+        # SDPA with memory-efficient backend is currently (torch==2.1.2) bugged with non-contiguous inputs with custom attn_mask,\n+        # Reference: https://github.com/pytorch/pytorch/issues/112577.\n+        if query_states.device.type == \"cuda\" and attention_mask is not None:\n+            query_states = query_states.contiguous()\n+            key_states = key_states.contiguous()\n+            value_states = value_states.contiguous()\n+\n+        # We dispatch to SDPA's Flash Attention or Efficient kernels via this `is_causal` if statement instead of an inline conditional assignment\n+        # in SDPA to support both torch.compile's dynamic shapes and full graph options. An inline conditional prevents dynamic shapes from compiling.\n+        # The q_len > 1 is necessary to match with AttentionMaskConverter.to_causal_4d that does not create a causal mask in case q_len == 1.\n+        is_causal = True if causal_mask is None and q_len > 1 else False\n+\n+        attn_output = torch.nn.functional.scaled_dot_product_attention(\n+            query_states,\n+            key_states,\n+            value_states,\n+            attn_mask=causal_mask,\n+            dropout_p=self.attention_dropout if self.training else 0.0,\n+            is_causal=is_causal,\n+        )\n+\n+        attn_output = attn_output.transpose(1, 2).contiguous()\n+        attn_output = attn_output.view(bsz, q_len, self.hidden_size)\n+\n+        attn_output = self.o_proj(attn_output)\n+\n+        return attn_output, None, past_key_value\n+\n+\n+QWEN2_VL_ATTENTION_CLASSES = {\n+    \"eager\": Qwen2VLAttention,\n+    \"flash_attention_2\": Qwen2VLFlashAttention2,\n+    \"sdpa\": Qwen2VLSdpaAttention,\n+}\n+\n+\n+class Qwen2VLDecoderLayer(nn.Module):\n+    def __init__(self, config: Qwen2VLConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        if config.use_sliding_window and config._attn_implementation != \"flash_attention_2\":\n+            logger.warning_once(\n+                f\"Sliding Window Attention is enabled but not implemented for `{config._attn_implementation}`; \"\n+                \"unexpected results may be encountered.\"\n+            )\n+        self.self_attn = QWEN2_VL_ATTENTION_CLASSES[config._attn_implementation](config, layer_idx)\n+\n+        self.mlp = Qwen2MLP(config)\n+        self.input_layernorm = Qwen2RMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = Qwen2RMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Tuple[torch.Tensor]] = None,\n+        output_attentions: Optional[bool] = False,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> Tuple[torch.FloatTensor, Optional[Tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.FloatTensor`): input to the layer of shape `(batch, seq_len, embed_dim)`\n+            attention_mask (`torch.FloatTensor`, *optional*): attention mask of size\n+                `(batch, sequence_length)` where padding elements are indicated by 0.\n+            output_attentions (`bool`, *optional*):\n+                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n+                returned tensors for more detail.\n+            use_cache (`bool`, *optional*):\n+                If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding\n+                (see `past_key_values`).\n+            past_key_value (`Tuple(torch.FloatTensor)`, *optional*): cached past key and value projection states\n+            cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n+                Indices depicting the position of the input sequence tokens in the sequence.\n+            kwargs (`dict`, *optional*):\n+                Arbitrary kwargs to be ignored, used for FSDP and other methods that injects code\n+                into the model\n+        \"\"\"\n+\n+        residual = hidden_states\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # Self Attention\n+        hidden_states, self_attn_weights, present_key_value = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        outputs = (hidden_states,)\n+\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        if use_cache:\n+            outputs += (present_key_value,)\n+\n+        return outputs\n+\n+\n+QWEN2VL_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`Qwen2VLConfig`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare Qwen2VL Model outputting raw hidden-states without any specific head on top.\",\n+    QWEN2VL_START_DOCSTRING,\n+)\n+class Qwen2VLPreTrainedModel(PreTrainedModel):\n+    config_class = Qwen2VLConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"Qwen2VLDecoderLayer\", \"Qwen2VLVisionBlock\"]\n+    _skip_keys_device_placement = \"past_key_values\"\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = True\n+    _supports_cache_class = True\n+    _supports_static_cache = True\n+\n+    def _init_weights(self, module):\n+        std = self.config.initializer_range\n+        if isinstance(module, (nn.Linear, nn.Conv3d)):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+\n+\n+class Qwen2VisionTransformerPretrainedModel(Qwen2VLPreTrainedModel):\n+    config_class = Qwen2VLVisionConfig\n+    _no_split_modules = [\"Qwen2VLVisionBlock\"]\n+\n+    def __init__(self, config) -> None:\n+        super().__init__(config)\n+        self.spatial_merge_size = config.spatial_merge_size\n+\n+        self.patch_embed = PatchEmbed(\n+            patch_size=config.patch_size,\n+            temporal_patch_size=config.temporal_patch_size,\n+            in_channels=config.in_channels,\n+            embed_dim=config.embed_dim,\n+        )\n+\n+        head_dim = config.embed_dim // config.num_heads\n+        self.rotary_pos_emb = VisionRotaryEmbedding(head_dim // 2)\n+\n+        self.blocks = nn.ModuleList(\n+            [Qwen2VLVisionBlock(config, config._attn_implementation) for _ in range(config.depth)]\n+        )\n+        self.merger = PatchMerger(dim=config.hidden_size, context_dim=config.embed_dim)\n+\n+    def get_dtype(self) -> torch.dtype:\n+        return self.blocks[0].mlp.fc2.weight.dtype\n+\n+    def get_device(self) -> torch.device:\n+        return self.blocks[0].mlp.fc2.weight.device\n+\n+    def rot_pos_emb(self, grid_thw):\n+        pos_ids = []\n+        for t, h, w in grid_thw:\n+            hpos_ids = torch.arange(h).unsqueeze(1).expand(-1, w)\n+            hpos_ids = hpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            hpos_ids = hpos_ids.permute(0, 2, 1, 3)\n+            hpos_ids = hpos_ids.flatten()\n+\n+            wpos_ids = torch.arange(w).unsqueeze(0).expand(h, -1)\n+            wpos_ids = wpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            wpos_ids = wpos_ids.permute(0, 2, 1, 3)\n+            wpos_ids = wpos_ids.flatten()\n+            pos_ids.append(torch.stack([hpos_ids, wpos_ids], dim=-1).repeat(t, 1))\n+        pos_ids = torch.cat(pos_ids, dim=0)\n+        max_grid_size = grid_thw[:, 1:].max()\n+        rotary_pos_emb_full = self.rotary_pos_emb(max_grid_size)\n+        rotary_pos_emb = rotary_pos_emb_full[pos_ids].flatten(1)\n+        return rotary_pos_emb\n+\n+    def forward(self, hidden_states: torch.Tensor, grid_thw: torch.Tensor) -> torch.Tensor:\n+        hidden_states = self.patch_embed(hidden_states)\n+        rotary_pos_emb = self.rot_pos_emb(grid_thw)\n+\n+        cu_seqlens = torch.repeat_interleave(grid_thw[:, 1] * grid_thw[:, 2], grid_thw[:, 0]).cumsum(\n+            dim=0, dtype=torch.int32\n+        )\n+        cu_seqlens = F.pad(cu_seqlens, (1, 0), value=0)\n+\n+        for blk in self.blocks:\n+            hidden_states = blk(hidden_states, cu_seqlens=cu_seqlens, rotary_pos_emb=rotary_pos_emb)\n+\n+        return self.merger(hidden_states)\n+\n+\n+@add_start_docstrings(\n+    \"The bare Qwen2VL Model outputting raw hidden-states without any specific head on top.\",\n+    QWEN2VL_START_DOCSTRING,\n+)\n+class Qwen2VLModel(Qwen2VLPreTrainedModel):\n+    def __init__(self, config: Qwen2VLConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [Qwen2VLDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self._attn_implementation = config._attn_implementation\n+        self.norm = Qwen2RMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+        self.gradient_checkpointing = False\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.embed_tokens = value\n+\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+    ) -> Union[Tuple, BaseModelOutputWithPast]:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\n+                \"You cannot specify both input_ids and inputs_embeds at the same time, and must specify either one\"\n+            )\n+\n+        if self.gradient_checkpointing and self.training:\n+            if use_cache:\n+                logger.warning_once(\n+                    \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n+                )\n+                use_cache = False\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+        if position_ids is None:\n+            # the hard coded `3` is for temporal, height and width.\n+            position_ids = cache_position.view(1, 1, -1).expand(3, inputs_embeds.shape[0], -1)\n+\n+        causal_mask = self._update_causal_mask(\n+            attention_mask, inputs_embeds, cache_position, past_key_values, output_attentions\n+        )\n+\n+        hidden_states = inputs_embeds\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+        next_decoder_cache = None\n+\n+        for decoder_layer in self.layers:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            if self.gradient_checkpointing and self.training:\n+                layer_outputs = self._gradient_checkpointing_func(\n+                    decoder_layer.__call__,\n+                    hidden_states,\n+                    causal_mask,\n+                    position_ids,\n+                    past_key_values,\n+                    output_attentions,\n+                    use_cache,\n+                    cache_position,\n+                )\n+            else:\n+                layer_outputs = decoder_layer(\n+                    hidden_states,\n+                    attention_mask=causal_mask,\n+                    position_ids=position_ids,\n+                    past_key_value=past_key_values,\n+                    output_attentions=output_attentions,\n+                    use_cache=use_cache,\n+                    cache_position=cache_position,\n+                )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if use_cache:\n+                next_decoder_cache = layer_outputs[2 if output_attentions else 1]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        # add hidden states from the last decoder layer\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        next_cache = next_decoder_cache if use_cache else None\n+\n+        if not return_dict:\n+            return tuple(v for v in [hidden_states, next_cache, all_hidden_states, all_self_attns] if v is not None)\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=next_cache,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+        )\n+\n+    # Copied from transformers.models.llama.modeling_llama.LlamaModel._update_causal_mask\n+    def _update_causal_mask(\n+        self,\n+        attention_mask: torch.Tensor,\n+        input_tensor: torch.Tensor,\n+        cache_position: torch.Tensor,\n+        past_key_values: Cache,\n+        output_attentions: bool,\n+    ):\n+        # TODO: As of torch==2.2.0, the `attention_mask` passed to the model in `generate` is 2D and of dynamic length even when the static\n+        # KV cache is used. This is an issue for torch.compile which then recaptures cudagraphs at each decode steps due to the dynamic shapes.\n+        # (`recording cudagraph tree for symint key 13`, etc.), which is VERY slow. A workaround is `@torch.compiler.disable`, but this prevents using\n+        # `fullgraph=True`. See more context in https://github.com/huggingface/transformers/pull/29114\n+\n+        if self.config._attn_implementation == \"flash_attention_2\":\n+            if attention_mask is not None and 0.0 in attention_mask:\n+                return attention_mask\n+            return None\n+\n+        # For SDPA, when possible, we will rely on its `is_causal` argument instead of its `attn_mask` argument, in\n+        # order to dispatch on Flash Attention 2. This feature is not compatible with static cache, as SDPA will fail\n+        # to infer the attention mask.\n+        past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+        using_static_cache = isinstance(past_key_values, StaticCache)\n+\n+        # When output attentions is True, sdpa implementation's forward method calls the eager implementation's forward\n+        if self.config._attn_implementation == \"sdpa\" and not using_static_cache and not output_attentions:\n+            if AttentionMaskConverter._ignore_causal_mask_sdpa(\n+                attention_mask,\n+                inputs_embeds=input_tensor,\n+                past_key_values_length=past_seen_tokens,\n+                is_training=self.training,\n+            ):\n+                return None\n+\n+        dtype, device = input_tensor.dtype, input_tensor.device\n+        min_dtype = torch.finfo(dtype).min\n+        sequence_length = input_tensor.shape[1]\n+        if using_static_cache:\n+            target_length = past_key_values.get_max_length()\n+        else:\n+            target_length = (\n+                attention_mask.shape[-1]\n+                if isinstance(attention_mask, torch.Tensor)\n+                else past_seen_tokens + sequence_length + 1\n+            )\n+\n+        # In case the provided `attention` mask is 2D, we generate a causal mask here (4D).\n+        causal_mask = _prepare_4d_causal_attention_mask_with_cache_position(\n+            attention_mask,\n+            sequence_length=sequence_length,\n+            target_length=target_length,\n+            dtype=dtype,\n+            device=device,\n+            min_dtype=min_dtype,\n+            cache_position=cache_position,\n+            batch_size=input_tensor.shape[0],\n+        )\n+\n+        if (\n+            self.config._attn_implementation == \"sdpa\"\n+            and attention_mask is not None\n+            and attention_mask.device.type == \"cuda\"\n+            and not output_attentions\n+        ):\n+            # Attend to all tokens in fully masked rows in the causal_mask, for example the relevant first rows when\n+            # using left padding. This is required by F.scaled_dot_product_attention memory-efficient attention path.\n+            # Details: https://github.com/pytorch/pytorch/issues/110213\n+            causal_mask = AttentionMaskConverter._unmask_unattended(causal_mask, min_dtype)\n+\n+        return causal_mask\n+\n+\n+QWEN2_VL_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+            it.\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            [What are input IDs?](../glossary#input-ids)\n+        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+            - 1 for tokens that are **not masked**,\n+            - 0 for tokens that are **masked**.\n+\n+            [What are attention masks?](../glossary#attention-mask)\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            If `past_key_values` is used, optionally only the last `decoder_input_ids` have to be input (see\n+            `past_key_values`).\n+\n+            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n+            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n+            information on the default strategy.\n+\n+            - 1 indicates the head is **not masked**,\n+            - 0 indicates the head is **masked**.\n+        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n+            config.n_positions - 1]`. [What are position IDs?](../glossary#position-ids)\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`) and 2 additional tensors of shape\n+            `(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`.\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n+            blocks) that can be used (see `past_key_values` input) to speed up sequential decoding.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n+            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n+            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n+        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n+            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n+            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n+            model's internal embedding lookup matrix.\n+        use_cache (`bool`, *optional*):\n+            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n+            `past_key_values`).\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+        pixel_values (`torch.FloatTensor` of shape `(seq_length, num_channels * image_size * image_size)):\n+            The tensors corresponding to the input images. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`Qwen2VLImageProcessor.__call__`] for details. [`Qwen2VLProcessor`] uses\n+            [`Qwen2VLImageProcessor`] for processing images.\n+        pixel_values_videos (`torch.FloatTensor` of shape `(seq_length, num_channels * temporal_size * image_size * image_size)):\n+            The tensors corresponding to the input videos. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`Qwen2VLImageProcessor.__call__`] for details. [`Qwen2VLProcessor`] uses\n+            [`Qwen2VLImageProcessor`] for processing videos.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+\"\"\"\n+\n+\n+class Qwen2VLForConditionalGeneration(Qwen2VLPreTrainedModel):\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.visual = Qwen2VisionTransformerPretrainedModel._from_config(\n+            config.vision_config, attn_implementation=config._attn_implementation\n+        )\n+        self.model = Qwen2VLModel(config)\n+        self.vocab_size = config.vocab_size\n+        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n+        self.padding_side = \"left\"  # set it to left by default, user can use setter to change padding_sides\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    def get_output_embeddings(self):\n+        return self.lm_head\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.lm_head = new_embeddings\n+\n+    def set_decoder(self, decoder):\n+        self.model = decoder\n+\n+    def get_decoder(self):\n+        return self.model\n+\n+    def get_rope_index(\n+        self,\n+        input_ids: torch.LongTensor,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+    ) -> Tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Calculate the 3D rope index based on image and video's temporal, height and width in LLM.\n+\n+        Explanation:\n+            Each embedding sequence contains vision embedding and text embedding or just contains text embedding.\n+\n+            For pure text embedding sequence, the rotary position embedding has no difference with mordern LLMs.\n+            Examples:\n+                input_ids: [T T T T T], here T is for text.\n+                temporal position_ids: [0, 1, 2, 3, 4]\n+                height position_ids: [0, 1, 2, 3, 4]\n+                width position_ids: [0, 1, 2, 3, 4]\n+\n+            For vision and text embedding sequence, we calculate 3D rotary position embedding for vision part\n+            and 1D rotary position embeddin for text part.\n+            Examples:\n+                Assume we have a video input with 3 temporal patches, 2 height patches and 2 width patches.\n+                input_ids: [V V V V V V V V V V V V T T T T T], here V is for vision.\n+                vision temporal position_ids: [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]\n+                vision height position_ids: [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]\n+                vision width position_ids: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n+                text temporal position_ids: [3, 4, 5, 6, 7]\n+                text height position_ids: [3, 4, 5, 6, 7]\n+                text width position_ids: [3, 4, 5, 6, 7]\n+                Here we calculate the text start position_ids as the max vision position_ids plus 1.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+                it.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+\n+        Returns:\n+            position_ids (`torch.LongTensor` of shape `(3, batch_size, sequence_length)`)\n+            mrope_position_deltas (`torch.Tensor` of shape `(batch_size)`)\n+        \"\"\"\n+        spatial_merge_size = self.config.vision_config.spatial_merge_size\n+        image_token_id = self.config.image_token_id\n+        video_token_id = self.config.video_token_id\n+        vision_start_token_id = self.config.vision_start_token_id\n+        mrope_position_deltas = []\n+        if image_grid_thw is not None or video_grid_thw is not None:\n+            total_input_ids = input_ids\n+            position_ids = torch.ones(\n+                3, input_ids.shape[0], input_ids.shape[1], dtype=input_ids.dtype, device=input_ids.device\n+            )\n+            image_index, video_index = 0, 0\n+            for i, input_ids in enumerate(total_input_ids):\n+                if attention_mask is not None:\n+                    input_ids = input_ids[attention_mask[i] == 1]\n+                image_nums, video_nums = 0, 0\n+                vision_start_indices = torch.argwhere(input_ids == vision_start_token_id).squeeze(1)\n+                vision_tokens = input_ids[vision_start_indices + 1]\n+                image_nums = (vision_tokens == image_token_id).sum()\n+                video_nums = (vision_tokens == video_token_id).sum()\n+                input_tokens = input_ids.tolist()\n+                llm_pos_ids_list: list = []\n+                st = 0\n+                remain_images, remain_videos = image_nums, video_nums\n+                for _ in range(image_nums + video_nums):\n+                    if image_token_id in input_tokens and remain_images > 0:\n+                        ed_image = input_tokens.index(image_token_id, st)\n+                    else:\n+                        ed_image = len(input_tokens) + 1\n+                    if video_token_id in input_tokens and remain_videos > 0:\n+                        ed_video = input_tokens.index(video_token_id, st)\n+                    else:\n+                        ed_video = len(input_tokens) + 1\n+                    if ed_image < ed_video:\n+                        t, h, w = (\n+                            image_grid_thw[image_index][0],\n+                            image_grid_thw[image_index][1],\n+                            image_grid_thw[image_index][2],\n+                        )\n+                        image_index += 1\n+                        remain_images -= 1\n+                        ed = ed_image\n+                    else:\n+                        t, h, w = (\n+                            video_grid_thw[video_index][0],\n+                            video_grid_thw[video_index][1],\n+                            video_grid_thw[video_index][2],\n+                        )\n+                        video_index += 1\n+                        remain_videos -= 1\n+                        ed = ed_video\n+                    llm_grid_t, llm_grid_h, llm_grid_w = (\n+                        t.item(),\n+                        h.item() // spatial_merge_size,\n+                        w.item() // spatial_merge_size,\n+                    )\n+                    text_len = ed - st\n+\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+                    llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                    t_index = torch.arange(llm_grid_t).view(-1, 1).expand(-1, llm_grid_h * llm_grid_w).flatten()\n+                    h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(llm_grid_t, -1, llm_grid_w).flatten()\n+                    w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(llm_grid_t, llm_grid_h, -1).flatten()\n+                    llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + text_len + st_idx)\n+                    st = ed + llm_grid_t * llm_grid_h * llm_grid_w\n+\n+                if st < len(input_tokens):\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+                    text_len = len(input_tokens) - st\n+                    llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                llm_positions = torch.cat(llm_pos_ids_list, dim=1).reshape(3, -1)\n+                position_ids[..., i, attention_mask[i] == 1] = llm_positions.to(position_ids.device)\n+                mrope_position_deltas.append(llm_positions.max() + 1 - len(total_input_ids[i]))\n+            mrope_position_deltas = torch.tensor(mrope_position_deltas, device=input_ids.device).unsqueeze(1)\n+            return position_ids, mrope_position_deltas\n+        else:\n+            if attention_mask is not None:\n+                position_ids = attention_mask.long().cumsum(-1) - 1\n+                position_ids.masked_fill_(attention_mask == 0, 1)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1).to(input_ids.device)\n+                max_position_ids = position_ids.max(0, keepdim=False)[0].max(-1, keepdim=True)[0]\n+                mrope_position_deltas = max_position_ids + 1 - attention_mask.shape[-1]\n+            else:\n+                position_ids = (\n+                    torch.arange(input_ids.shape[1], device=input_ids.device)\n+                    .view(1, 1, -1)\n+                    .expand(3, input_ids.shape[0], -1)\n+                )\n+                mrope_position_deltas = torch.zeros(\n+                    [input_ids.shape[0], 1],\n+                    device=input_ids.device,\n+                    dtype=input_ids.dtype,\n+                )\n+\n+            return position_ids, mrope_position_deltas\n+\n+    def _update_model_kwargs_for_generation(\n+        self,\n+        outputs: ModelOutput,\n+        model_kwargs: Dict[str, Any],\n+        is_encoder_decoder: bool = False,\n+        num_new_tokens: int = 1,\n+    ) -> Dict[str, Any]:\n+        model_kwargs = super()._update_model_kwargs_for_generation(\n+            outputs=outputs,\n+            model_kwargs=model_kwargs,\n+            is_encoder_decoder=is_encoder_decoder,\n+            num_new_tokens=num_new_tokens,\n+        )\n+\n+        if getattr(outputs, \"rope_deltas\", None) is not None:\n+            model_kwargs[\"rope_deltas\"] = outputs.rope_deltas\n+\n+        return model_kwargs\n+\n+    @add_start_docstrings_to_model_forward(QWEN2_VL_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=Qwen2VLCausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+    ) -> Union[Tuple, Qwen2VLCausalLMOutputWithPast]:\n+        r\"\"\"\n+        Args:\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> from PIL import Image\n+        >>> import requests\n+        >>> from transformers import AutoProcessor, Qwen2VLForConditionalGeneration\n+\n+        >>> model = Qwen2VLForConditionalGeneration.from_pretrained(\"Qwen/Qwen2-VL-7B-Instruct\")\n+        >>> processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2-VL-7B-Instruct\")\n+\n+        >>> messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\"},\n+                    {\"type\": \"text\", \"text\": \"What is shown in this image?\"},\n+                ],\n+            },\n+        ]\n+        >>> url = \"https://www.ilankelman.org/stopsigns/australia.jpg\"\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> text = processor.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\n+        >>> inputs = processor(text=[text], images=[image], vision_infos=[vision_infos])\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"The image shows a street scene with a red stop sign in the foreground. In the background, there is a large red gate with Chinese characters ...\"\n+        ```\"\"\"\n+\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.model.embed_tokens(input_ids)\n+            if pixel_values is not None:\n+                pixel_values = pixel_values.type(self.visual.get_dtype())\n+                image_embeds = self.visual(pixel_values, grid_thw=image_grid_thw).to(inputs_embeds.device)\n+                image_mask = input_ids == self.config.image_token_id\n+                if self.training:\n+                    inputs_embeds = inputs_embeds.clone()\n+                inputs_embeds[image_mask] = image_embeds\n+            if pixel_values_videos is not None:\n+                pixel_values_videos = pixel_values_videos.type(self.visual.get_dtype())\n+                video_embeds = self.visual(pixel_values_videos, grid_thw=video_grid_thw).to(inputs_embeds.device)\n+                video_mask = input_ids == self.config.video_token_id\n+                inputs_embeds[video_mask] = video_embeds\n+            if attention_mask is not None:\n+                attention_mask = attention_mask.to(inputs_embeds.device)\n+\n+        outputs = self.model(\n+            input_ids=None,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+        )\n+\n+        hidden_states = outputs[0]\n+        logits = self.lm_head(hidden_states)\n+        logits = logits.float()\n+\n+        loss = None\n+        if labels is not None:\n+            # Shift so that tokens < n predict n\n+            shift_logits = logits[..., :-1, :].contiguous()\n+            shift_labels = labels[..., 1:].contiguous()\n+            # Flatten the tokens\n+            loss_fct = CrossEntropyLoss()\n+            shift_logits = shift_logits.view(-1, self.config.vocab_size)\n+            shift_labels = shift_labels.view(-1)\n+            # Enable model parallelism\n+            shift_labels = shift_labels.to(shift_logits.device)\n+            loss = loss_fct(shift_logits, shift_labels)\n+\n+        if not return_dict:\n+            output = (logits,) + outputs[1:]\n+            return (loss,) + output if loss is not None else output\n+\n+        return Qwen2VLCausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=rope_deltas,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        attention_mask=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        position_ids=None,\n+        use_cache=True,\n+        pixel_values=None,\n+        pixel_values_videos=None,\n+        image_grid_thw=None,\n+        video_grid_thw=None,\n+        **kwargs,\n+    ):\n+        # If we have cache: let's slice `input_ids` through `cache_position`, to keep only the unprocessed tokens\n+        # Exception 1: when passing input_embeds, input_ids may be missing entries\n+        # Exception 2: some generation methods do special slicing of input_ids, so we don't need to do it here\n+        if past_key_values is not None:\n+            if inputs_embeds is not None:  # Exception 1\n+                input_ids = input_ids[:, -cache_position.shape[0] :]\n+            elif input_ids.shape[1] != cache_position.shape[0]:  # Default case (the \"else\", a no op, is Exception 2)\n+                input_ids = input_ids[:, cache_position]\n+\n+        rope_deltas = kwargs.get(\"rope_deltas\", None)\n+        if attention_mask is not None and position_ids is None:\n+            if cache_position is None or (cache_position is not None and cache_position[0] == 0):\n+                position_ids, rope_deltas = self.get_rope_index(\n+                    input_ids, image_grid_thw, video_grid_thw, attention_mask\n+                )\n+            else:\n+                batch_size, seq_length = input_ids.shape\n+                delta = (\n+                    cache_position[0] + rope_deltas if cache_position is not None and rope_deltas is not None else 0\n+                )\n+                position_ids = torch.arange(seq_length, device=input_ids.device)\n+                position_ids = position_ids.view(1, -1).expand(batch_size, -1)\n+                position_ids = position_ids.add(delta)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1)\n+\n+        if cache_position[0] != 0:\n+            pixel_values = None\n+            pixel_values_videos = None\n+\n+        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n+        if inputs_embeds is not None and cache_position[0] == 0:\n+            model_inputs = {\"inputs_embeds\": inputs_embeds}\n+        else:\n+            model_inputs = {\"input_ids\": input_ids}\n+\n+        if isinstance(past_key_values, StaticCache) and attention_mask.ndim == 2:\n+            if inputs_embeds is not None:\n+                batch_size, sequence_length = inputs_embeds.shape\n+                device = inputs_embeds.device\n+            else:\n+                batch_size, sequence_length = input_ids.shape\n+                device = input_ids.device\n+\n+            dtype = self.lm_head.weight.dtype\n+            min_dtype = torch.finfo(dtype).min\n+\n+            attention_mask = _prepare_4d_causal_attention_mask_with_cache_position(\n+                attention_mask,\n+                sequence_length=sequence_length,\n+                target_length=past_key_values.get_max_length(),\n+                dtype=dtype,\n+                device=device,\n+                min_dtype=min_dtype,\n+                cache_position=cache_position,\n+                batch_size=batch_size,\n+            )\n+\n+        model_inputs.update(\n+            {\n+                \"position_ids\": position_ids,\n+                \"past_key_values\": past_key_values,\n+                \"use_cache\": use_cache,\n+                \"attention_mask\": attention_mask,\n+                \"pixel_values\": pixel_values,\n+                \"pixel_values_videos\": pixel_values_videos,\n+                \"image_grid_thw\": image_grid_thw,\n+                \"video_grid_thw\": video_grid_thw,\n+                \"rope_deltas\": rope_deltas,\n+            }\n+        )\n+        return model_inputs"
        },
        {
            "sha": "9f671ecfd29ae489864a7fec68cd6356594b4f82",
            "filename": "src/transformers/models/qwen2_vl/processing_qwen2_vl.py",
            "status": "added",
            "additions": 183,
            "deletions": 0,
            "changes": 183,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fprocessing_qwen2_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fprocessing_qwen2_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fprocessing_qwen2_vl.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -0,0 +1,183 @@\n+# coding=utf-8\n+# Copyright 2024 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"\n+Processor class for Qwen2-VL.\n+\"\"\"\n+\n+from typing import List, Optional, Union\n+\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_utils import ImageInput, VideoInput\n+from ...processing_utils import ProcessorMixin\n+from ...tokenization_utils_base import PaddingStrategy, PreTokenizedInput, TextInput, TruncationStrategy\n+from ...utils import TensorType, logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Qwen2VLProcessor(ProcessorMixin):\n+    r\"\"\"\n+    Constructs a Qwen2-VL processor which wraps a Qwen2-VL image processor and a Qwen2 tokenizer into a single processor.\n+\n+    [`Qwen2VLProcessor`] offers all the functionalities of [`Qwen2VLImageProcessor`] and [`Qwen2TokenizerFast`]. See the\n+    [`~Qwen2VLProcessor.__call__`] and [`~Qwen2VLProcessor.decode`] for more information.\n+\n+    Args:\n+        image_processor ([`Qwen2VLImageProcessor`], *optional*):\n+            The image processor is a required input.\n+        tokenizer ([`Qwen2TokenizerFast`], *optional*):\n+            The tokenizer is a required input.\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    attributes = [\"image_processor\", \"tokenizer\"]\n+    valid_kwargs = [\"chat_template\"]\n+    image_processor_class = \"Qwen2VLImageProcessor\"\n+    tokenizer_class = (\"Qwen2Tokenizer\", \"Qwen2TokenizerFast\")\n+\n+    def __init__(self, image_processor=None, tokenizer=None, chat_template=None, **kwargs):\n+        super().__init__(image_processor, tokenizer, chat_template=chat_template)\n+\n+    def __call__(\n+        self,\n+        images: ImageInput = None,\n+        text: Union[TextInput, PreTokenizedInput, List[TextInput], List[PreTokenizedInput]] = None,\n+        videos: VideoInput = None,\n+        padding: Union[bool, str, PaddingStrategy] = False,\n+        truncation: Union[bool, str, TruncationStrategy] = None,\n+        max_length: int = None,\n+        return_tensors: Optional[Union[str, TensorType]] = TensorType.PYTORCH,\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`\n+        and `kwargs` arguments to Qwen2TokenizerFast's [`~Qwen2TokenizerFast.__call__`] if `text` is not `None` to encode\n+        the text. To prepare the vision inputs, this method forwards the `vision_infos` and `kwrags` arguments to\n+        Qwen2VLImageProcessor's [`~Qwen2VLImageProcessor.__call__`] if `vision_infos` is not `None`.\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. Both channels-first and channels-last formats are supported.\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            videos (`np.ndarray`, `torch.Tensor`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n+                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n+            padding (`bool`, `str` or [`~utils.PaddingStrategy`], *optional*, defaults to `False`):\n+                Select a strategy to pad the returned sequences (according to the model's padding side and padding\n+                index) among:\n+                - `True` or `'longest'`: Pad to the longest sequence in the batch (or no padding if only a single\n+                  sequence if provided).\n+                - `'max_length'`: Pad to a maximum length specified with the argument `max_length` or to the maximum\n+                  acceptable input length for the model if that argument is not provided.\n+                - `False` or `'do_not_pad'` (default): No padding (i.e., can output a batch with sequences of different\n+                  lengths).\n+            max_length (`int`, *optional*):\n+                Maximum length of the returned list and optionally padding length (see above).\n+            truncation (`bool`, *optional*):\n+                Activates truncation to cut input sequences longer than `max_length` to `max_length`.\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+            - **pixel_values_videos** -- Pixel values of videos to be fed to a model. Returned when `videos` is not `None`.\n+            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n+            - **video_grid_thw** -- List of video 3D grid in LLM. Returned when `videos` is not `None`.\n+        \"\"\"\n+        if images is not None:\n+            image_inputs = self.image_processor(images=images, videos=None, return_tensors=return_tensors)\n+            image_grid_thw = image_inputs[\"image_grid_thw\"]\n+        else:\n+            image_inputs = {}\n+            image_grid_thw = None\n+\n+        if videos is not None:\n+            videos_inputs = self.image_processor(images=None, videos=videos, return_tensors=return_tensors)\n+            video_grid_thw = videos_inputs[\"video_grid_thw\"]\n+        else:\n+            videos_inputs = {}\n+            video_grid_thw = None\n+\n+        if not isinstance(text, list):\n+            text = [text]\n+\n+        if image_grid_thw is not None:\n+            merge_length = self.image_processor.merge_size**2\n+            index = 0\n+            for i in range(len(text)):\n+                while \"<|image_pad|>\" in text[i]:\n+                    text[i] = text[i].replace(\n+                        \"<|image_pad|>\", \"<|placeholder|>\" * (image_grid_thw[index].prod() // merge_length), 1\n+                    )\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", \"<|image_pad|>\")\n+\n+        if video_grid_thw is not None:\n+            merge_length = self.image_processor.merge_size**2\n+            index = 0\n+            for i in range(len(text)):\n+                while \"<|video_pad|>\" in text[i]:\n+                    text[i] = text[i].replace(\n+                        \"<|video_pad|>\", \"<|placeholder|>\" * (video_grid_thw[index].prod() // merge_length), 1\n+                    )\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", \"<|video_pad|>\")\n+\n+        text_inputs = self.tokenizer(\n+            text, return_tensors=return_tensors, padding=padding, truncation=truncation, max_length=max_length\n+        )\n+\n+        return BatchFeature(data={**text_inputs, **image_inputs, **videos_inputs})\n+\n+    def batch_decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to Qwen2TokenizerFast's [`~PreTrainedTokenizer.batch_decode`]. Please\n+        refer to the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.batch_decode(*args, **kwargs)\n+\n+    def decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to Qwen2TokenizerFast's [`~PreTrainedTokenizer.decode`]. Please refer to\n+        the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.decode(*args, **kwargs)\n+\n+    @property\n+    def model_input_names(self):\n+        tokenizer_input_names = self.tokenizer.model_input_names\n+        image_processor_input_names = self.image_processor.model_input_names\n+        return list(dict.fromkeys(tokenizer_input_names + image_processor_input_names))"
        },
        {
            "sha": "ce3f0045e3dfe17ebf7706835266a729ac623b68",
            "filename": "src/transformers/utils/dummy_pt_objects.py",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -7315,6 +7315,27 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torch\"])\n \n \n+class Qwen2VLForConditionalGeneration(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class Qwen2VLModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class Qwen2VLPreTrainedModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n class RagModel(metaclass=DummyObject):\n     _backends = [\"torch\"]\n "
        },
        {
            "sha": "62330d3d282f7840b1140f3f9bb24c763b2bb9e4",
            "filename": "src/transformers/utils/dummy_vision_objects.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -513,6 +513,13 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"vision\"])\n \n \n+class Qwen2VLImageProcessor(metaclass=DummyObject):\n+    _backends = [\"vision\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"vision\"])\n+\n+\n class RTDetrImageProcessor(metaclass=DummyObject):\n     _backends = [\"vision\"]\n "
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/qwen2_vl/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/tests%2Fmodels%2Fqwen2_vl%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/tests%2Fmodels%2Fqwen2_vl%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen2_vl%2F__init__.py?ref=19e6e80e10118f855137b90740936c0b11ac397f"
        },
        {
            "sha": "d69addb9a10cca7d6988e2c7e35687f66d0ca8a3",
            "filename": "tests/models/qwen2_vl/test_image_processing_qwen2_vl.py",
            "status": "added",
            "additions": 249,
            "deletions": 0,
            "changes": 249,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/tests%2Fmodels%2Fqwen2_vl%2Ftest_image_processing_qwen2_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/tests%2Fmodels%2Fqwen2_vl%2Ftest_image_processing_qwen2_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen2_vl%2Ftest_image_processing_qwen2_vl.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -0,0 +1,249 @@\n+# coding=utf-8\n+# Copyright 2024 HuggingFace Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+import numpy as np\n+\n+from transformers.image_utils import OPENAI_CLIP_MEAN, OPENAI_CLIP_STD\n+from transformers.models.qwen2_vl.image_processing_qwen2_vl import smart_resize\n+from transformers.testing_utils import require_torch, require_vision\n+from transformers.utils import is_torch_available, is_vision_available\n+\n+from ...test_image_processing_common import ImageProcessingTestMixin, prepare_image_inputs\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+    from transformers import Qwen2VLImageProcessor\n+\n+\n+class Qwen2VLImageProcessingTester(unittest.TestCase):\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=7,\n+        num_channels=3,\n+        min_resolution=56,\n+        max_resolution=1024,\n+        min_pixels=56 * 56,\n+        max_pixels=28 * 28 * 1280,\n+        do_normalize=True,\n+        image_mean=OPENAI_CLIP_MEAN,\n+        image_std=OPENAI_CLIP_STD,\n+        do_resize=True,\n+        patch_size=14,\n+        temporal_patch_size=2,\n+        merge_size=2,\n+        do_convert_rgb=True,\n+    ):\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.min_resolution = min_resolution\n+        self.max_resolution = max_resolution\n+        self.num_channels = num_channels\n+        self.image_mean = OPENAI_CLIP_MEAN\n+        self.image_std = OPENAI_CLIP_STD\n+        self.min_pixels = min_pixels\n+        self.max_pixels = max_pixels\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.merge_size = merge_size\n+        self.do_resize = do_resize\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean\n+        self.image_std = image_std\n+        self.do_convert_rgb = do_convert_rgb\n+\n+    def prepare_image_processor_dict(self):\n+        return {\n+            \"do_resize\": self.do_resize,\n+            \"image_mean\": self.image_mean,\n+            \"image_std\": self.image_std,\n+            \"min_pixels\": self.min_pixels,\n+            \"max_pixels\": self.max_pixels,\n+            \"patch_size\": self.patch_size,\n+            \"temporal_patch_size\": self.temporal_patch_size,\n+            \"merge_size\": self.merge_size,\n+        }\n+\n+    def prepare_image_inputs(self, equal_resolution=False, numpify=False, torchify=False):\n+        images = prepare_image_inputs(\n+            batch_size=self.batch_size,\n+            num_channels=self.num_channels,\n+            min_resolution=self.min_resolution,\n+            max_resolution=self.max_resolution,\n+            equal_resolution=equal_resolution,\n+            numpify=numpify,\n+            torchify=torchify,\n+        )\n+        return [[image] for image in images]\n+\n+\n+@require_torch\n+@require_vision\n+class Qwen2VLImageProcessingTest(ImageProcessingTestMixin, unittest.TestCase):\n+    image_processing_class = Qwen2VLImageProcessor if is_vision_available() else None\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.image_processor_tester = Qwen2VLImageProcessingTester(self)\n+\n+    @property\n+    def image_processor_dict(self):\n+        return self.image_processor_tester.prepare_image_processor_dict()\n+\n+    def test_image_processor_properties(self):\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        self.assertTrue(hasattr(image_processing, \"do_normalize\"))\n+        self.assertTrue(hasattr(image_processing, \"image_mean\"))\n+        self.assertTrue(hasattr(image_processing, \"image_std\"))\n+        self.assertTrue(hasattr(image_processing, \"do_resize\"))\n+        self.assertTrue(hasattr(image_processing, \"min_pixels\"))\n+        self.assertTrue(hasattr(image_processing, \"max_pixels\"))\n+        self.assertTrue(hasattr(image_processing, \"do_convert_rgb\"))\n+        self.assertTrue(hasattr(image_processing, \"patch_size\"))\n+        self.assertTrue(hasattr(image_processing, \"temporal_patch_size\"))\n+        self.assertTrue(hasattr(image_processing, \"merge_size\"))\n+\n+    def test_image_processor_from_dict_with_kwargs(self):\n+        image_processor = self.image_processing_class.from_dict(self.image_processor_dict)\n+        self.assertEqual(image_processor.min_pixels, 56 * 56)\n+        self.assertEqual(image_processor.max_pixels, 28 * 28 * 1280)\n+\n+        image_processor = self.image_processing_class.from_dict(\n+            self.image_processor_dict, min_pixels=256 * 256, max_pixels=640 * 640\n+        )\n+        self.assertEqual(image_processor.min_pixels, 256 * 256)\n+        self.assertEqual(image_processor.max_pixels, 640 * 640)\n+\n+    def test_select_best_resolution(self):\n+        # Test with a final resize resolution\n+        best_resolution = smart_resize(561, 278, factor=28)\n+        self.assertEqual(best_resolution, (560, 280))\n+\n+    def test_call_pil(self):\n+        # Initialize image_processing\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        # create random PIL images\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True)\n+        for image in image_inputs:\n+            self.assertIsInstance(image[0], Image.Image)\n+\n+        # Test not batched input\n+        prcocess_out = image_processing(image_inputs[0], return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (4900, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]])\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+        # Test batched\n+        prcocess_out = image_processing(image_inputs, return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (34300, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]] * 7)\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+    def test_call_numpy(self):\n+        # Initialize image_processing\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        # create random numpy tensors\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True, numpify=True)\n+        for image in image_inputs:\n+            self.assertIsInstance(image[0], np.ndarray)\n+\n+        # Test not batched input\n+        prcocess_out = image_processing(image_inputs[0], return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (4900, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]])\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+        # Test batched\n+        prcocess_out = image_processing(image_inputs, return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (34300, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]] * 7)\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+    def test_call_pytorch(self):\n+        # Initialize image_processing\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        # create random PyTorch tensors\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True, torchify=True)\n+\n+        for image in image_inputs:\n+            self.assertIsInstance(image[0], torch.Tensor)\n+\n+        # Test not batched input\n+        prcocess_out = image_processing(image_inputs[0], return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (4900, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]])\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+        # Test batched\n+        prcocess_out = image_processing(image_inputs, return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (34300, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]] * 7)\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+    @unittest.skip(reason=\"Qwen2VLImageProcessor doesn't treat 4 channel PIL and numpy consistently yet\")\n+    def test_call_numpy_4_channels(self):\n+        pass\n+\n+    def test_nested_input(self):\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True)\n+\n+        # Test batched as a list of images\n+        prcocess_out = image_processing(image_inputs, return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (34300, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]] * 7)\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+        # Test batched as a nested list of images, where each sublist is one batch\n+        image_inputs_nested = image_inputs[:3] + image_inputs[3:]\n+        prcocess_out = image_processing(image_inputs_nested, return_tensors=\"pt\")\n+        encoded_images_nested = prcocess_out.pixel_values\n+        image_grid_thws_nested = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (34300, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]] * 7)\n+        self.assertEqual(tuple(encoded_images_nested.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+        # Image processor should return same pixel values, independently of ipnut format\n+        self.assertTrue((encoded_images_nested == encoded_images).all())\n+        self.assertTrue((image_grid_thws_nested == expected_image_grid_thws).all())"
        },
        {
            "sha": "ba3b30d94533e07c15fe4c1cb1cd01f1c543eb5d",
            "filename": "tests/models/qwen2_vl/test_modeling_qwen2_vl.py",
            "status": "added",
            "additions": 448,
            "deletions": 0,
            "changes": 448,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/tests%2Fmodels%2Fqwen2_vl%2Ftest_modeling_qwen2_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/tests%2Fmodels%2Fqwen2_vl%2Ftest_modeling_qwen2_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen2_vl%2Ftest_modeling_qwen2_vl.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -0,0 +1,448 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch Qwen2-VL model.\"\"\"\n+\n+import gc\n+import unittest\n+\n+import requests\n+\n+from transformers import (\n+    AutoProcessor,\n+    Qwen2VLConfig,\n+    Qwen2VLForConditionalGeneration,\n+    is_torch_available,\n+    is_vision_available,\n+)\n+from transformers.testing_utils import (\n+    require_bitsandbytes,\n+    require_torch,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import (\n+    ModelTesterMixin,\n+    _config_zero_init,\n+    floats_tensor,\n+    ids_tensor,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+else:\n+    is_torch_greater_or_equal_than_2_0 = False\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+class Qwen2VLVisionText2TextModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=8,\n+        seq_length=7,\n+        num_channels=3,\n+        ignore_index=-100,\n+        image_size=28,\n+        bos_token_id=0,\n+        eos_token_id=1,\n+        vision_start_token_id=151652,\n+        image_token_id=151655,\n+        video_token_id=151656,\n+        hidden_act=\"silu\",\n+        hidden_size=32,\n+        vocab_size=152064,\n+        intermediate_size=37,\n+        max_position_embeddings=512,\n+        max_window_layers=3,\n+        model_type=\"qwen2_vl\",\n+        num_attention_heads=4,\n+        num_hidden_layers=3,\n+        num_key_value_heads=2,\n+        rope_theta=10000,\n+        tie_word_embeddings=True,\n+        is_training=True,\n+        vision_config={\n+            \"depth\": 2,\n+            \"embed_dim\": 32,\n+            \"hidden_act\": \"quick_gelu\",\n+            \"hidden_size\": 32,\n+            \"mlp_ratio\": 4,\n+            \"num_heads\": 4,\n+            \"patch_size\": 14,\n+            \"spatial_merge_size\": 2,\n+            \"temporal_patch_size\": 2,\n+        },\n+        rope_scaling={\"type\": \"mrope\", \"mrope_section\": [2, 1, 1]},\n+    ):\n+        self.parent = parent\n+        self.ignore_index = ignore_index\n+        self.bos_token_id = bos_token_id\n+        self.eos_token_id = eos_token_id\n+        self.vision_start_token_id = vision_start_token_id\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.hidden_act = hidden_act\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.max_window_layers = max_window_layers\n+        self.model_type = model_type\n+        self.num_attention_heads = num_attention_heads\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_key_value_heads = num_key_value_heads\n+        self.rope_theta = rope_theta\n+        self.tie_word_embeddings = tie_word_embeddings\n+        self.vision_config = vision_config\n+        self.rope_scaling = rope_scaling\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.image_size = image_size\n+        self.seq_length = seq_length\n+        self.is_training = is_training\n+        self.vocab_size = vocab_size\n+\n+    def get_config(self):\n+        return Qwen2VLConfig(\n+            hidden_size=self.hidden_size,\n+            intermediate_size=self.intermediate_size,\n+            num_hidden_layers=self.num_hidden_layers,\n+            num_attention_heads=self.num_attention_heads,\n+            num_key_value_heads=self.num_key_value_heads,\n+            hidden_act=self.hidden_act,\n+            max_position_embeddings=self.max_position_embeddings,\n+            vision_config=self.vision_config,\n+            model_type=self.model_type,\n+            max_window_layers=self.max_window_layers,\n+            rope_scaling=self.rope_scaling,\n+            tie_word_embeddings=self.tie_word_embeddings,\n+            bos_token_id=self.bos_token_id,\n+            eos_token_id=self.eos_token_id,\n+            vision_start_token_id=self.vision_start_token_id,\n+            image_token_id=self.image_token_id,\n+            video_token_id=self.video_token_id,\n+            vocab_size=self.vocab_size,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        config = self.get_config()\n+        patch_size = config.vision_config.patch_size\n+        temporal_patch_size = config.vision_config.temporal_patch_size\n+        pixel_values = floats_tensor(\n+            [\n+                self.batch_size * (self.image_size**2) // (patch_size**2),\n+                self.num_channels * (patch_size**2) * temporal_patch_size,\n+            ]\n+        )\n+\n+        return config, pixel_values\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        vision_seqlen = pixel_values.shape[0] // self.batch_size // (self.vision_config[\"spatial_merge_size\"] ** 2)\n+        input_ids = ids_tensor([self.batch_size, self.seq_length - 1 + vision_seqlen], self.vocab_size)\n+        attention_mask = torch.ones(input_ids.shape, dtype=torch.long, device=torch_device)\n+        input_ids[:, torch.arange(vision_seqlen, device=torch_device) + 1] = self.image_token_id\n+        labels = torch.zeros(\n+            (self.batch_size, self.seq_length - 1 + vision_seqlen), dtype=torch.long, device=torch_device\n+        )\n+        patch_size = self.vision_config[\"patch_size\"]\n+        inputs_dict = {\n+            \"pixel_values\": pixel_values,\n+            \"image_grid_thw\": torch.tensor(\n+                [[1, self.image_size // patch_size, self.image_size // patch_size]] * self.batch_size\n+            ),\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+            \"labels\": labels,\n+        }\n+        return config, inputs_dict\n+\n+    def create_and_check_qwen2_vl_model_fp16_forward(\n+        self, config, input_ids, pixel_values, attention_mask, image_grid_thw\n+    ):\n+        model = Qwen2VLForConditionalGeneration(config=config)\n+        model.to(torch_device)\n+        model.half()\n+        model.eval()\n+        logits = model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            image_grid_thw=image_grid_thw,\n+            pixel_values=pixel_values.to(torch.bfloat16),\n+            return_dict=True,\n+        )[\"logits\"]\n+        self.parent.assertFalse(torch.isnan(logits).any().item())\n+\n+    def create_and_check_qwen2_vl_model_fp16_autocast_forward(\n+        self, config, input_ids, pixel_values, attention_mask, image_grid_thw\n+    ):\n+        config.torch_dtype = torch.float16\n+        model = Qwen2VLForConditionalGeneration(config=config)\n+        model.to(torch_device)\n+        model.eval()\n+        with torch.autocast(device_type=\"cuda\", dtype=torch.float16):\n+            logits = model(\n+                input_ids=input_ids,\n+                attention_mask=attention_mask,\n+                image_grid_thw=image_grid_thw,\n+                pixel_values=pixel_values.to(torch.bfloat16),\n+                return_dict=True,\n+            )[\"logits\"]\n+        self.parent.assertFalse(torch.isnan(logits).any().item())\n+\n+\n+@require_torch\n+class Qwen2VLModelTest(ModelTesterMixin, GenerationTesterMixin, unittest.TestCase):\n+    \"\"\"\n+    Model tester for `Qwen2VLForConditionalGeneration`.\n+    \"\"\"\n+\n+    all_model_classes = (Qwen2VLForConditionalGeneration,) if is_torch_available() else ()\n+    test_pruning = False\n+    test_head_masking = False\n+\n+    def setUp(self):\n+        self.model_tester = Qwen2VLVisionText2TextModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Qwen2VLConfig, has_text_modality=False)\n+\n+    def test_initialization(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        configs_no_init = _config_zero_init(config)\n+        for model_class in self.all_model_classes:\n+            model = model_class(config=configs_no_init)\n+            for name, param in model.named_parameters():\n+                if param.requires_grad:\n+                    self.assertIn(\n+                        ((param.data.mean() * 1e9).round() / 1e9).item(),\n+                        [0.0, 1.0],\n+                        msg=f\"Parameter {name} of model {model_class} seems not properly initialized\",\n+                    )\n+\n+    @unittest.skip(\n+        reason=\"This architecure seem to not compute gradients properly when using GC, check: https://github.com/huggingface/transformers/pull/27124\"\n+    )\n+    def test_training_gradient_checkpointing(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"This architecure seem to not compute gradients properly when using GC, check: https://github.com/huggingface/transformers/pull/27124\"\n+    )\n+    def test_training_gradient_checkpointing_use_reentrant(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"This architecure seem to not compute gradients properly when using GC, check: https://github.com/huggingface/transformers/pull/27124\"\n+    )\n+    def test_training_gradient_checkpointing_use_reentrant_false(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Feedforward chunking is not yet supported\")\n+    def test_feed_forward_chunking(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Generate needs input ids\")\n+    def test_inputs_embeds_matches_input_ids_with_generate(self):\n+        pass\n+\n+    @unittest.skip(reason=\"CPU offload is not yet supported\")\n+    def test_cpu_offload(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Some undefined behavior encountered with test versions of this model. Skip for now.\")\n+    def test_disk_offload_bin(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Some undefined behavior encountered with test versions of this model. Skip for now.\")\n+    def test_disk_offload_safetensors(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Some undefined behavior encountered with test versions of this model. Skip for now.\")\n+    def test_model_parallelism(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Compile not yet supported because in Qwen2VL models\")\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Compile not yet supported because in Qwen2VL models\")\n+    def test_sdpa_can_dispatch_on_flash(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Got `CUDA error: misaligned address` with PyTorch 2.0.0.\")\n+    def test_multi_gpu_data_parallel_forward(self):\n+        pass\n+\n+    @unittest.skip(reason=\"We cannot configure to output a smaller model.\")\n+    def test_model_is_small(self):\n+        pass\n+\n+\n+@require_torch\n+class Qwen2VLIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2-VL-7B-Instruct\")\n+        self.messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\"},\n+                    {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+                ],\n+            }\n+        ]\n+        url = \"https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen-VL/assets/demo.jpeg\"\n+        self.image = Image.open(requests.get(url, stream=True).raw)\n+\n+    def tearDown(self):\n+        gc.collect()\n+        torch.cuda.empty_cache()\n+\n+    @slow\n+    @require_bitsandbytes\n+    def test_small_model_integration_test(self):\n+        model = Qwen2VLForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2-VL-7B-Instruct\",\n+            load_in_4bit=True,\n+        )\n+\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text], images=[self.image], return_tensors=\"pt\")\n+\n+        expected_input_ids = [151644, 8948, 198, 2610, 525, 264, 10950, 17847, 13, 151645, 198, 151644, 872, 198, 151652, 151655, 151655]  # fmt: skip\n+        assert expected_input_ids == inputs.input_ids[0].tolist()[:17]\n+\n+        expected_pixel_slice = torch.tensor(\n+            [\n+                [0.8501, 0.8647, 0.8647],\n+                [1.0106, 1.0106, 1.0252],\n+                [0.9960, 1.0106, 1.0252],\n+                [1.0982, 1.1128, 1.1274],\n+                [1.0836, 1.0982, 1.0982],\n+                [1.1858, 1.1858, 1.1858],\n+            ],\n+            dtype=torch.float32,\n+            device=\"cpu\",\n+        )\n+        assert torch.allclose(expected_pixel_slice, inputs.pixel_values[:6, :3], atol=1e-3)\n+\n+        # verify generation\n+        inputs = inputs.to(torch_device)\n+\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        EXPECTED_DECODED_TEXT = \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?assistant\\nThe dog in the picture appears to be a Labrador Retriever or a similar breed. Labradors are known for their friendly and intelligent nature,\"\n+\n+        self.assertEqual(\n+            self.processor.decode(output[0], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    @require_bitsandbytes\n+    def test_small_model_integration_test_batch(self):\n+        model = Qwen2VLForConditionalGeneration.from_pretrained(\"Qwen/Qwen2-VL-7B-Instruct\", load_in_4bit=True)\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text, text], images=[self.image, self.image], return_tensors=\"pt\").to(\n+            torch_device\n+        )\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?assistant\\nThe dog in the picture appears to be a Labrador Retriever or a similar breed. Labradors are known for their friendly and intelligent nature,\",\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?assistant\\nThe dog in the image appears to be a Labrador Retriever or a similar breed. Labradors are known for their friendly and outgoing nature,\",\n+        ]\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True)[0],\n+            self.processor.batch_decode(output, skip_special_tokens=True)[1],\n+        )\n+\n+    @slow\n+    @require_bitsandbytes\n+    def test_small_model_integration_test_batch_wo_image(self):\n+        model = Qwen2VLForConditionalGeneration.from_pretrained(\"Qwen/Qwen2-VL-7B-Instruct\", load_in_4bit=True)\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        messages2 = [\n+            {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n+            {\"role\": \"user\", \"content\": \"Who are you?\"},\n+        ]\n+        text2 = self.processor.apply_chat_template(messages2, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text, text2], images=[self.image], return_tensors=\"pt\").to(torch_device)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?assistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and outgoing personalities, as well as their\",\n+            \"system\\nYou are a helpful assistant.user\\nWho are you?assistant\\nI am Qwen, a large language model created by Alibaba Cloud. I am designed to assist with various tasks and answer a wide range of questions to\",\n+        ]\n+\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    @require_bitsandbytes\n+    def test_small_model_integration_test_batch_different_resolutions(self):\n+        model = Qwen2VLForConditionalGeneration.from_pretrained(\"Qwen/Qwen2-VL-7B-Instruct\", load_in_4bit=True)\n+        text, vision_infos = self.processor.apply_chat_template(\n+            self.messages, tokenize=False, add_generation_prompt=True\n+        )\n+        messages2 = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"image\",\n+                        \"image\": \"https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen-VL/assets/demo.jpeg\",\n+                        \"resized_height\": 504,\n+                        \"resized_width\": 252,\n+                    },\n+                    {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+                ],\n+            }\n+        ]\n+        text2, vision_infos2 = self.processor.apply_chat_template(\n+            messages2, tokenize=False, add_generation_prompt=True\n+        )\n+        inputs = self.processor(\n+            text=[text, text2], vision_infos=[vision_infos, vision_infos2], return_tensors=\"pt\"\n+        ).to(torch_device)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?assistant\\nThe dog in the picture appears to be a Labrador Retriever or a similar breed. Labradors are known for their friendly and intelligent nature,\",\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWho are you?assistant\\nI am a large language model created by Alibaba Cloud. I am called Qwen.\",\n+        ]\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )"
        },
        {
            "sha": "165d478d4fafbb4b73a42970eac36e4462a83325",
            "filename": "utils/check_config_attributes.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/utils%2Fcheck_config_attributes.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/utils%2Fcheck_config_attributes.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_config_attributes.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -43,6 +43,7 @@\n     ],\n     \"Qwen2Config\": [\"use_sliding_window\"],\n     \"Qwen2MoeConfig\": [\"use_sliding_window\"],\n+    \"Qwen2VLConfig\": [\"use_sliding_window\"],\n     \"Gemma2Config\": [\"tie_word_embeddings\"],\n     # used to compute the property `self.chunk_length`\n     \"EncodecConfig\": [\"overlap\"],"
        },
        {
            "sha": "68d344613399d042f089bca7069cf37921ebfe91",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 49,
            "deletions": 44,
            "changes": 93,
            "blob_url": "https://github.com/huggingface/transformers/blob/19e6e80e10118f855137b90740936c0b11ac397f/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/19e6e80e10118f855137b90740936c0b11ac397f/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=19e6e80e10118f855137b90740936c0b11ac397f",
            "patch": "@@ -70,6 +70,7 @@\n     \"UMT5Stack\",\n     \"Pop2PianoStack\",\n     \"Qwen2AudioEncoder\",\n+    \"Qwen2VisionTransformerPretrainedModel\",\n     \"SwitchTransformersStack\",\n     \"TFDPRSpanPredictor\",\n     \"MaskFormerSwinModel\",\n@@ -86,50 +87,54 @@\n \n # Update this list for models that are not tested with a comment explaining the reason it should not be.\n # Being in this list is an exception and should **not** be the rule.\n-IGNORE_NON_TESTED = PRIVATE_MODELS.copy() + [\n-    # models to ignore for not tested\n-    \"RecurrentGemmaModel\",  # Building part of bigger (tested) model.\n-    \"FuyuForCausalLM\",  # Not tested fort now\n-    \"InstructBlipQFormerModel\",  # Building part of bigger (tested) model.\n-    \"InstructBlipVideoQFormerModel\",  # Building part of bigger (tested) model.\n-    \"UMT5EncoderModel\",  # Building part of bigger (tested) model.\n-    \"Blip2QFormerModel\",  # Building part of bigger (tested) model.\n-    \"ErnieMForInformationExtraction\",\n-    \"FastSpeech2ConformerHifiGan\",  # Already tested by SpeechT5HifiGan (# Copied from)\n-    \"FastSpeech2ConformerWithHifiGan\",  # Built with two smaller (tested) models.\n-    \"GraphormerDecoderHead\",  # Building part of bigger (tested) model.\n-    \"JukeboxVQVAE\",  # Building part of bigger (tested) model.\n-    \"JukeboxPrior\",  # Building part of bigger (tested) model.\n-    \"DecisionTransformerGPT2Model\",  # Building part of bigger (tested) model.\n-    \"SegformerDecodeHead\",  # Building part of bigger (tested) model.\n-    \"MgpstrModel\",  # Building part of bigger (tested) model.\n-    \"BertLMHeadModel\",  # Needs to be setup as decoder.\n-    \"MegatronBertLMHeadModel\",  # Building part of bigger (tested) model.\n-    \"RealmBertModel\",  # Building part of bigger (tested) model.\n-    \"RealmReader\",  # Not regular model.\n-    \"RealmScorer\",  # Not regular model.\n-    \"RealmForOpenQA\",  # Not regular model.\n-    \"ReformerForMaskedLM\",  # Needs to be setup as decoder.\n-    \"TFElectraMainLayer\",  # Building part of bigger (tested) model (should it be a TFPreTrainedModel ?)\n-    \"TFRobertaForMultipleChoice\",  # TODO: fix\n-    \"TFRobertaPreLayerNormForMultipleChoice\",  # TODO: fix\n-    \"SeparableConv1D\",  # Building part of bigger (tested) model.\n-    \"FlaxBartForCausalLM\",  # Building part of bigger (tested) model.\n-    \"FlaxBertForCausalLM\",  # Building part of bigger (tested) model. Tested implicitly through FlaxRobertaForCausalLM.\n-    \"OPTDecoderWrapper\",\n-    \"TFSegformerDecodeHead\",  # Not a regular model.\n-    \"AltRobertaModel\",  # Building part of bigger (tested) model.\n-    \"BlipTextLMHeadModel\",  # No need to test it as it is tested by BlipTextVision models\n-    \"TFBlipTextLMHeadModel\",  # No need to test it as it is tested by BlipTextVision models\n-    \"BridgeTowerTextModel\",  # No need to test it as it is tested by BridgeTowerModel model.\n-    \"BridgeTowerVisionModel\",  # No need to test it as it is tested by BridgeTowerModel model.\n-    \"BarkCausalModel\",  # Building part of bigger (tested) model.\n-    \"BarkModel\",  # Does not have a forward signature - generation tested with integration tests.\n-    \"SeamlessM4TTextToUnitModel\",  # Building part of bigger (tested) model.\n-    \"SeamlessM4TCodeHifiGan\",  # Building part of bigger (tested) model.\n-    \"SeamlessM4TTextToUnitForConditionalGeneration\",  # Building part of bigger (tested) model.\n-    \"ChameleonVQVAE\",  # VQVAE here is used only for encoding (discretizing) and is tested as part of bigger model\n-]\n+IGNORE_NON_TESTED = (\n+    PRIVATE_MODELS.copy()\n+    + [\n+        # models to ignore for not tested\n+        \"RecurrentGemmaModel\",  # Building part of bigger (tested) model.\n+        \"FuyuForCausalLM\",  # Not tested fort now\n+        \"InstructBlipQFormerModel\",  # Building part of bigger (tested) model.\n+        \"InstructBlipVideoQFormerModel\",  # Building part of bigger (tested) model.\n+        \"UMT5EncoderModel\",  # Building part of bigger (tested) model.\n+        \"Blip2QFormerModel\",  # Building part of bigger (tested) model.\n+        \"ErnieMForInformationExtraction\",\n+        \"FastSpeech2ConformerHifiGan\",  # Already tested by SpeechT5HifiGan (# Copied from)\n+        \"FastSpeech2ConformerWithHifiGan\",  # Built with two smaller (tested) models.\n+        \"GraphormerDecoderHead\",  # Building part of bigger (tested) model.\n+        \"JukeboxVQVAE\",  # Building part of bigger (tested) model.\n+        \"JukeboxPrior\",  # Building part of bigger (tested) model.\n+        \"DecisionTransformerGPT2Model\",  # Building part of bigger (tested) model.\n+        \"SegformerDecodeHead\",  # Building part of bigger (tested) model.\n+        \"MgpstrModel\",  # Building part of bigger (tested) model.\n+        \"BertLMHeadModel\",  # Needs to be setup as decoder.\n+        \"MegatronBertLMHeadModel\",  # Building part of bigger (tested) model.\n+        \"RealmBertModel\",  # Building part of bigger (tested) model.\n+        \"RealmReader\",  # Not regular model.\n+        \"RealmScorer\",  # Not regular model.\n+        \"RealmForOpenQA\",  # Not regular model.\n+        \"ReformerForMaskedLM\",  # Needs to be setup as decoder.\n+        \"TFElectraMainLayer\",  # Building part of bigger (tested) model (should it be a TFPreTrainedModel ?)\n+        \"TFRobertaForMultipleChoice\",  # TODO: fix\n+        \"TFRobertaPreLayerNormForMultipleChoice\",  # TODO: fix\n+        \"SeparableConv1D\",  # Building part of bigger (tested) model.\n+        \"FlaxBartForCausalLM\",  # Building part of bigger (tested) model.\n+        \"FlaxBertForCausalLM\",  # Building part of bigger (tested) model. Tested implicitly through FlaxRobertaForCausalLM.\n+        \"OPTDecoderWrapper\",\n+        \"TFSegformerDecodeHead\",  # Not a regular model.\n+        \"AltRobertaModel\",  # Building part of bigger (tested) model.\n+        \"BlipTextLMHeadModel\",  # No need to test it as it is tested by BlipTextVision models\n+        \"TFBlipTextLMHeadModel\",  # No need to test it as it is tested by BlipTextVision models\n+        \"BridgeTowerTextModel\",  # No need to test it as it is tested by BridgeTowerModel model.\n+        \"BridgeTowerVisionModel\",  # No need to test it as it is tested by BridgeTowerModel model.\n+        \"BarkCausalModel\",  # Building part of bigger (tested) model.\n+        \"BarkModel\",  # Does not have a forward signature - generation tested with integration tests.\n+        \"SeamlessM4TTextToUnitModel\",  # Building part of bigger (tested) model.\n+        \"SeamlessM4TCodeHifiGan\",  # Building part of bigger (tested) model.\n+        \"SeamlessM4TTextToUnitForConditionalGeneration\",  # Building part of bigger (tested) model.\n+        \"ChameleonVQVAE\",  # VQVAE here is used only for encoding (discretizing) and is tested as part of bigger model\n+        \"Qwen2VLModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2VLForConditionalGeneration.\n+    ]\n+)\n \n # Update this list with test files that don't have a tester with a `all_model_classes` variable and which don't\n # trigger the common tests."
        }
    ],
    "stats": {
        "total": 3828,
        "additions": 3784,
        "deletions": 44
    }
}