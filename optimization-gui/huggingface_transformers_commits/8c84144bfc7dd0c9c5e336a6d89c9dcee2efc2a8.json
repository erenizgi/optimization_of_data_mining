{
    "author": "zhang-prog",
    "message": "[Model] Add PaddleOCR-VL Model Support (#42178)\n\n* init\n\n* refactor\n\n* update\n\n* update\n\n* fix unresolved problems\n\n* fix how position_ids work with flash_attn_2\n\n* add tests and fix code\n\n* add model_doc\n\n* update model_doc\n\n* fix ci\n\n* update docstring\n\n* add tests\n\n* update\n\n* add **kwargs\n\n* update\n\n* update\n\n* update\n\n* reduce max_position_embeddings in tests\n\n* update",
    "sha": "8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
    "files": [
        {
            "sha": "e6b6239358803980af8739536c1771f4b6c413b2",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -1119,6 +1119,8 @@\n         title: OWL-ViT\n       - local: model_doc/owlv2\n         title: OWLv2\n+      - local: model_doc/paddleocr_vl\n+        title: PaddleOCRVL\n       - local: model_doc/paligemma\n         title: PaliGemma\n       - local: model_doc/perceiver"
        },
        {
            "sha": "cc3b1f4ced6d119680e2de8e3222d8cd166952ab",
            "filename": "docs/source/en/model_doc/paddleocr_vl.md",
            "status": "added",
            "additions": 248,
            "deletions": 0,
            "changes": 248,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/docs%2Fsource%2Fen%2Fmodel_doc%2Fpaddleocr_vl.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/docs%2Fsource%2Fen%2Fmodel_doc%2Fpaddleocr_vl.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fpaddleocr_vl.md?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -0,0 +1,248 @@\n+<!--Copyright 2025 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+*This model was released on 2025.10.16 and added to Hugging Face Transformers on 2025.12.10*\n+\n+# PaddleOCR-VL\n+\n+<div class=\"flex flex-wrap space-x-1\">\n+<img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+<img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+<img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+</div>\n+\n+## Overview\n+\n+**Huggingface Hub**: [PaddleOCR-VL](https://huggingface.co/collections/PaddlePaddle/paddleocr-vl) | **Github Repo**: [PaddleOCR](https://github.com/PaddlePaddle/PaddleOCR)\n+\n+**Official Website**: [Baidu AI Studio](https://aistudio.baidu.com/paddleocr) | **arXiv**: [Technical Report](https://arxiv.org/pdf/2510.14528)\n+\n+**PaddleOCR-VL** is a SOTA and resource-efficient model tailored for document parsing. Its core component is PaddleOCR-VL-0.9B, a compact yet powerful vision-language model (VLM) that integrates a NaViT-style dynamic resolution visual encoder with the ERNIE-4.5-0.3B language model to enable accurate element recognition. This innovative model efficiently supports 109 languages and excels in recognizing complex elements (e.g., text, tables, formulas, and charts), while maintaining minimal resource consumption. Through comprehensive evaluations on widely used public benchmarks and in-house benchmarks, PaddleOCR-VL achieves SOTA performance in both page-level document parsing and element-level recognition. It significantly outperforms existing solutions, exhibits strong competitiveness against top-tier VLMs, and delivers fast inference speeds. These strengths make it highly suitable for practical deployment in real-world scenarios.\n+\n+<div align=\"center\">\n+<img src=\"https://huggingface.co/datasets/PaddlePaddle/PaddleOCR-VL_demo/resolve/main/imgs/allmetric.png\" width=\"800\"/>\n+</div>\n+\n+### **Core Features**\n+\n+1. **Compact yet Powerful VLM Architecture:** We present a novel vision-language model that is specifically designed for resource-efficient inference, achieving outstanding performance in element recognition. By integrating a NaViT-style dynamic high-resolution visual encoder with the lightweight ERNIE-4.5-0.3B language model, we significantly enhance the modelâ€™s recognition capabilities and decoding efficiency. This integration maintains high accuracy while reducing computational demands, making it well-suited for efficient and practical document processing applications.\n+\n+2. **SOTA Performance on Document Parsing:** PaddleOCR-VL achieves state-of-the-art performance in both page-level document parsing and element-level recognition. It significantly outperforms existing pipeline-based solutions and exhibiting strong competitiveness against leading vision-language models (VLMs) in document parsing. Moreover, it excels in recognizing complex document elements, such as text, tables, formulas, and charts, making it suitable for a wide range of challenging content types, including handwritten text and historical documents. This makes it highly versatile and suitable for a wide range of document types and scenarios.\n+\n+3. **Multilingual Support:** PaddleOCR-VL Supports 109 languages, covering major global languages, including but not limited to Chinese, English, Japanese, Latin, and Korean, as well as languages with different scripts and structures, such as Russian (Cyrillic script), Arabic, Hindi (Devanagari script), and Thai. This broad language coverage substantially enhances the applicability of our system to multilingual and globalized document processing scenarios.\n+\n+### **Model Architecture** \n+\n+<div align=\"center\">\n+<img src=\"https://huggingface.co/datasets/PaddlePaddle/PaddleOCR-VL_demo/resolve/main/imgs/paddleocrvl.png\" width=\"800\"/>\n+</div>\n+\n+## Usage\n+\n+### Usage tips\n+\n+> [!IMPORTANT]\n+> We currently recommend using the [PaddleOCR official method for inference](https://www.paddleocr.ai/latest/en/version3.x/pipeline_usage/PaddleOCR-VL.html), as it is faster and supports page-level document parsing. \n+> The example code below only supports element-level recognition.\n+\n+We have four types of element-level recognition:\n+\n+- Text recognition, indicated by the prompt `OCR:`.\n+- Formula recognition, indicated by the prompt `Formula Recognition:`.\n+- Table recognition, indicated by the prompt `Table Recognition:`.\n+- Chart recognition, indicated by the prompt `Chart Recognition:`.\n+\n+The following examples are all based on text recognition, with the prompt `OCR:`.\n+\n+### Single input inference\n+\n+The example below demonstrates how to generate text with PaddleOCRVL using [`Pipeline`] or the [`AutoModel`].\n+\n+<hfoptions id=\"usage\">\n+<hfoption id=\"Pipeline\">\n+\n+```py\n+from transformers import pipeline\n+\n+pipe = pipeline(\"image-text-to-text\", model=\"PaddlePaddle/PaddleOCR-VL\", dtype=\"bfloat16\")\n+messages = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\", \"url\": \"https://paddle-model-ecology.bj.bcebos.com/paddlex/imgs/demo_image/ocr_demo2.jpg\"},\n+            {\"type\": \"text\", \"text\": \"OCR:\"},\n+        ]\n+    }\n+]\n+result = pipe(text=messages)\n+print(result[0][\"generated_text\"])\n+```\n+\n+</hfoption>\n+\n+<hfoption id=\"AutoModel\">\n+\n+```py\n+from transformers import AutoProcessor, AutoModelForImageTextToText\n+\n+model = AutoModelForImageTextToText.from_pretrained(\"PaddlePaddle/PaddleOCR-VL\", dtype=\"bfloat16\")\n+processor = AutoProcessor.from_pretrained(\"PaddlePaddle/PaddleOCR-VL\")\n+messages = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\", \"url\": \"https://paddle-model-ecology.bj.bcebos.com/paddlex/imgs/demo_image/ocr_demo2.jpg\"},\n+            {\"type\": \"text\", \"text\": \"OCR:\"},\n+        ]\n+    }\n+]\n+inputs = processor.apply_chat_template(\n+\tmessages,\n+\tadd_generation_prompt=True,\n+\ttokenize=True,\n+\treturn_dict=True,\n+\treturn_tensors=\"pt\",\n+).to(model.device)\n+\n+outputs = model.generate(**inputs, max_new_tokens=100)\n+result = processor.decode(outputs[0][inputs[\"input_ids\"].shape[-1]:-1])\n+print(result)\n+```\n+\n+</hfoption>\n+</hfoptions>\n+\n+### Batched inference\n+\n+PaddleOCRVL also supports batched inference. We advise users to use `padding_side=\"left\"` when computing batched generation as it leads to more accurate results. Here is how you can do it with PaddleOCRVL using [`Pipeline`] or the [`AutoModel`]:\n+\n+<hfoptions id=\"usage\">\n+<hfoption id=\"Pipeline\">\n+\n+```py\n+from transformers import pipeline\n+\n+pipe = pipeline(\"image-text-to-text\", model=\"PaddlePaddle/PaddleOCR-VL\", dtype=\"bfloat16\")\n+messages = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\", \"url\": \"https://paddle-model-ecology.bj.bcebos.com/paddlex/imgs/demo_image/ocr_demo2.jpg\"},\n+            {\"type\": \"text\", \"text\": \"OCR:\"},\n+        ]\n+    }\n+]\n+result = pipe(text=[messages, messages])\n+print(result[0][0][\"generated_text\"])\n+print(result[1][0][\"generated_text\"])\n+```\n+\n+</hfoption>\n+\n+<hfoption id=\"AutoModel\">\n+\n+```py\n+from transformers import AutoProcessor, AutoModelForImageTextToText\n+\n+model = AutoModelForImageTextToText.from_pretrained(\"PaddlePaddle/PaddleOCR-VL\", dtype=\"bfloat16\")\n+processor = AutoProcessor.from_pretrained(\"PaddlePaddle/PaddleOCR-VL\")\n+messages = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\", \"url\": \"https://paddle-model-ecology.bj.bcebos.com/paddlex/imgs/demo_image/ocr_demo2.jpg\"},\n+            {\"type\": \"text\", \"text\": \"OCR:\"},\n+        ]\n+    }\n+]\n+batch_messages = [messages, messages]\n+inputs = processor.apply_chat_template(\n+\tbatch_messages,\n+\tadd_generation_prompt=True,\n+\ttokenize=True,\n+\treturn_dict=True,\n+\treturn_tensors=\"pt\",\n+    padding=True,\n+    padding_side='left',\n+).to(model.device)\n+\n+generated_ids = model.generate(**inputs, max_new_tokens=100)\n+generated_ids_trimmed = [out_ids[len(in_ids) :] for in_ids, out_ids in zip(inputs.input_ids, generated_ids)]\n+result = processor.batch_decode(generated_ids_trimmed, skip_special_tokens=True, clean_up_tokenization_spaces=False)\n+print(result)\n+```\n+\n+</hfoption>\n+</hfoptions>\n+\n+### Using Flash Attention 2\n+\n+Flash Attention 2 is an even faster, optimized version of the previous optimization, please refer to the [FlashAttention](https://huggingface.co/docs/transformers/perf_infer_gpu_one#flashattention).\n+\n+For example:\n+\n+```shell\n+pip install flash-attn --no-build-isolation\n+```\n+\n+```python\n+from transformers import AutoModelForImageTextToText\n+model = AutoModelForImageTextToText.from_pretrained(\"PaddlePaddle/PaddleOCR-VL\", dtype=\"bfloat16\", attn_implementation=\"flash_attention_2\")\n+```\n+\n+## PaddleOCRVLForConditionalGeneration\n+\n+[[autodoc]] PaddleOCRVLForConditionalGeneration\n+    - forward\n+\n+## PaddleOCRVLConfig\n+\n+[[autodoc]] PaddleOCRVLConfig\n+\n+## PaddleOCRVisionConfig\n+\n+[[autodoc]] PaddleOCRVisionConfig\n+\n+## PaddleOCRTextConfig\n+\n+[[autodoc]] PaddleOCRTextConfig\n+\n+## PaddleOCRTextModel\n+\n+[[autodoc]] PaddleOCRTextModel\n+\n+## PaddleOCRVisionModel\n+\n+[[autodoc]] PaddleOCRVisionModel\n+\n+## PaddleOCRVLImageProcessor\n+\n+[[autodoc]] PaddleOCRVLImageProcessor\n+\n+## PaddleOCRVLImageProcessorFast\n+\n+[[autodoc]] PaddleOCRVLImageProcessorFast\n+\n+## PaddleOCRVLModel\n+\n+[[autodoc]] PaddleOCRVLModel\n+\n+## PaddleOCRVLProcessor\n+\n+[[autodoc]] PaddleOCRVLProcessor\n+\n+## PaddleOCRVisionTransformer\n+\n+[[autodoc]] PaddleOCRVisionTransformer"
        },
        {
            "sha": "6c2f5618eedee5e4f69e9a843722ad284c758b25",
            "filename": "src/transformers/conversion_mapping.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fconversion_mapping.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fconversion_mapping.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fconversion_mapping.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -225,6 +225,7 @@ def register_checkpoint_conversion_mapping(\n     \"sam3\",\n     \"sam3_tracker\",\n     \"sam3_tracker_video\",\n+    \"paddleocrvl\",\n ]\n \n "
        },
        {
            "sha": "c25d1f2d298736a41fe6fdb980323fc475f428ad",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -265,6 +265,7 @@\n     from .ovis2 import *\n     from .owlv2 import *\n     from .owlvit import *\n+    from .paddleocr_vl import *\n     from .paligemma import *\n     from .parakeet import *\n     from .patchtsmixer import *"
        },
        {
            "sha": "281bb0e773f69287a205ecec6deb3e246c9a5cba",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -300,6 +300,7 @@\n         (\"ovis2\", \"Ovis2Config\"),\n         (\"owlv2\", \"Owlv2Config\"),\n         (\"owlvit\", \"OwlViTConfig\"),\n+        (\"paddleocr_vl\", \"PaddleOCRVLConfig\"),\n         (\"paligemma\", \"PaliGemmaConfig\"),\n         (\"parakeet_ctc\", \"ParakeetCTCConfig\"),\n         (\"parakeet_encoder\", \"ParakeetEncoderConfig\"),\n@@ -754,6 +755,7 @@\n         (\"ovis2\", \"Ovis2\"),\n         (\"owlv2\", \"OWLv2\"),\n         (\"owlvit\", \"OWL-ViT\"),\n+        (\"paddleocr_vl\", \"PaddleOCRVL\"),\n         (\"paligemma\", \"PaliGemma\"),\n         (\"parakeet\", \"Parakeet\"),\n         (\"parakeet_ctc\", \"Parakeet\"),"
        },
        {
            "sha": "50bd35a7199eaefb522f58a1464c0c0b68b57344",
            "filename": "src/transformers/models/auto/image_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -153,6 +153,7 @@\n             (\"ovis2\", (\"Ovis2ImageProcessor\", \"Ovis2ImageProcessorFast\")),\n             (\"owlv2\", (\"Owlv2ImageProcessor\", \"Owlv2ImageProcessorFast\")),\n             (\"owlvit\", (\"OwlViTImageProcessor\", \"OwlViTImageProcessorFast\")),\n+            (\"paddleocr_vl\", (\"PaddleOCRVLImageProcessor\", \"PaddleOCRVLImageProcessorFast\")),\n             (\"paligemma\", (\"SiglipImageProcessor\", \"SiglipImageProcessorFast\")),\n             (\"perceiver\", (\"PerceiverImageProcessor\", \"PerceiverImageProcessorFast\")),\n             (\"perception_lm\", (None, \"PerceptionLMImageProcessorFast\")),"
        },
        {
            "sha": "7799b11674de41a3e08e1750008272e5e00e27cb",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -1026,6 +1026,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"mistral3\", \"Mistral3ForConditionalGeneration\"),\n         (\"mllama\", \"MllamaForConditionalGeneration\"),\n         (\"ovis2\", \"Ovis2ForConditionalGeneration\"),\n+        (\"paddleocr_vl\", \"PaddleOCRVLForConditionalGeneration\"),\n         (\"paligemma\", \"PaliGemmaForConditionalGeneration\"),\n         (\"perception_lm\", \"PerceptionLMForConditionalGeneration\"),\n         (\"pix2struct\", \"Pix2StructForConditionalGeneration\"),"
        },
        {
            "sha": "7f8509c647700c92e730ff55a8df1a1e68fe44da",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -114,6 +114,7 @@\n         (\"ovis2\", \"Ovis2Processor\"),\n         (\"owlv2\", \"Owlv2Processor\"),\n         (\"owlvit\", \"OwlViTProcessor\"),\n+        (\"paddleocr_vl\", \"PaddleOCRVLProcessor\"),\n         (\"paligemma\", \"PaliGemmaProcessor\"),\n         (\"perception_lm\", \"PerceptionLMProcessor\"),\n         (\"phi4_multimodal\", \"Phi4MultimodalProcessor\"),"
        },
        {
            "sha": "bd6ef8f85785bb6931a2ffc76feef5c641d80b05",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -273,6 +273,7 @@\n         (\"ovis2\", \"Qwen2TokenizerFast\" if is_tokenizers_available() else None),\n         (\"owlv2\", \"CLIPTokenizerFast\" if is_tokenizers_available() else None),\n         (\"owlvit\", \"CLIPTokenizerFast\" if is_tokenizers_available() else None),\n+        (\"paddleocr_vl\", \"TokenizersBackend\" if is_tokenizers_available() else None),\n         (\"paligemma\", \"LlamaTokenizer\" if is_tokenizers_available() else None),\n         (\"pegasus\", \"PegasusTokenizer\" if is_tokenizers_available() else None),\n         (\"pegasus_x\", \"PegasusTokenizer\" if is_tokenizers_available() else None),"
        },
        {
            "sha": "d6be277b3f4dc66ebf69b52e95f32b299c2f8ae0",
            "filename": "src/transformers/models/paddleocr_vl/__init__.py",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2F__init__.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -0,0 +1,32 @@\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_paddleocr_vl import *\n+    from .image_processing_paddleocr_vl import *\n+    from .image_processing_paddleocr_vl_fast import *\n+    from .modeling_paddleocr_vl import *\n+    from .processing_paddleocr_vl import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "21e4db0d268c6fca17eb13bc70c132ae44846cea",
            "filename": "src/transformers/models/paddleocr_vl/configuration_paddleocr_vl.py",
            "status": "added",
            "additions": 336,
            "deletions": 0,
            "changes": 336,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fconfiguration_paddleocr_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fconfiguration_paddleocr_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fconfiguration_paddleocr_vl.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -0,0 +1,336 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/paddleocr_vl/modular_paddleocr_vl.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_paddleocr_vl.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# Copyright 2025 The PaddlePaddle Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import inspect\n+from typing import Optional\n+\n+from ...configuration_utils import PreTrainedConfig\n+from ...modeling_rope_utils import RopeParameters\n+\n+\n+class PaddleOCRVisionConfig(PreTrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`PaddleOCRVisionModel`]. It is used to instantiate a\n+    PaddleOCRVL vision encoder according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the vision encoder of the PaddleOCRVL\n+    [PaddlePaddle/PaddleOCRVL](https://huggingface.co/PaddlePaddle/PaddleOCR-VL) architecture.\n+\n+    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PreTrainedConfig`] for more information.\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 1152):\n+            Dimensionality of the encoder layers and the pooler layer.\n+        intermediate_size (`int`, *optional*, defaults to 4304):\n+            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+        num_hidden_layers (`int`, *optional*, defaults to 27):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_channels (`int`, *optional*, defaults to 3):\n+            Number of channels in the input images.\n+        image_size (`int`, *optional*, defaults to 384):\n+            The size (resolution) of each image.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The size (resolution) of each patch.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"gelu_pytorch_tanh\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+            `\"relu\"`, `\"selu\"` and `\"gelu_new\"` `\"quick_gelu\"` are supported.\n+        layer_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the layer normalization layers.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        spatial_merge_size (`int`, *optional*, defaults to 2):\n+            The size used for merging spatial dimensions.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import PaddleOCRVisionConfig, PaddleOCRVisionModel\n+\n+    >>> # Initializing a PaddleOCRVisionConfig with PaddlePaddle/PaddleOCR-VL style configuration\n+    >>> configuration = PaddleOCRVisionConfig()\n+\n+    >>> # Initializing a PaddleOCRVisionModel (with random weights) from the PaddlePaddle/PaddleOCR-VL style configuration\n+    >>> model = PaddleOCRVisionModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\n+    \"\"\"\n+\n+    model_type = \"paddleocr_vl_vision\"\n+    base_config_key = \"vision_config\"\n+\n+    def __init__(\n+        self,\n+        hidden_size=1152,\n+        intermediate_size=4304,\n+        num_hidden_layers=27,\n+        num_attention_heads=16,\n+        num_channels=3,\n+        image_size=384,\n+        patch_size=14,\n+        hidden_act=\"gelu_pytorch_tanh\",\n+        layer_norm_eps=1e-6,\n+        attention_dropout=0.0,\n+        spatial_merge_size=2,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.num_channels = num_channels\n+        self.patch_size = patch_size\n+        self.image_size = image_size\n+        self.attention_dropout = attention_dropout\n+        self.layer_norm_eps = layer_norm_eps\n+        self.hidden_act = hidden_act\n+        self.spatial_merge_size = spatial_merge_size\n+\n+\n+class PaddleOCRTextConfig(PreTrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`PaddleOCRTextModel`]. It is used to instantiate an Ernie 4.5\n+    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n+    defaults will yield a similar configuration to that of the Ernie 4.5 0.3B.\n+    e.g. [baidu/ERNIE-4.5-0.3B-PT](https://huggingface.co/baidu/ERNIE-4.5-0.3B-PT)\n+\n+    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PreTrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 103424):\n+            Vocabulary size of the Ernie 4.5 model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`PaddleOCRTextModel`]\n+        hidden_size (`int`, *optional*, defaults to 1024):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 3072):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 18):\n+            Number of hidden layers in the Transformer decoder.\n+        num_attention_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer in the Transformer decoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 2):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details, check out [this\n+            paper](https://huggingface.co/papers/2305.13245). If it is not specified, will default to\n+            `num_attention_heads`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 131072):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions.\n+        pad_token_id (`int`, *optional*, defaults to 0):\n+            Padding token id.\n+        bos_token_id (`int`, *optional*, defaults to 1):\n+            Beginning of stream token id.\n+        eos_token_id (`int`, *optional*, defaults to 2):\n+            End of stream token id.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `True`):\n+            Whether to tie weight embeddings\n+        rope_parameters (`RopeParameters`, *optional*):\n+            Dictionary containing the configuration parameters for the RoPE embeddings. The dictionary should contain\n+            a value for `rope_theta` and optionally parameters used for scaling in case you want to use RoPE\n+            with longer `max_position_embeddings`.\n+        use_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use a bias in any of the projections including mlp and attention for example.\n+        head_dim (`int`, *optional*, defaults to 128):\n+            The attention head dimension. If None, it will default to hidden_size // num_attention_heads\n+\n+    ```python\n+    >>> from transformers import PaddleOCRTextModel, PaddleOCRTextConfig\n+\n+    >>> # Initializing a PaddleOCRText 0.3B style configuration\n+    >>> configuration = PaddleOCRTextConfig()\n+\n+    >>> # Initializing a model from the 0.3B style configuration\n+    >>> model = PaddleOCRTextModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"paddleocr_vl_text\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    default_theta = 500000.0\n+    # Default tensor parallel plan for base model `PaddleOCRTextModel`\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.up_proj\": \"colwise\",\n+        \"layers.*.mlp.down_proj\": \"rowwise\",\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size: Optional[int] = 103424,\n+        hidden_size: Optional[int] = 1024,\n+        intermediate_size: Optional[int] = 3072,\n+        num_hidden_layers: Optional[int] = 18,\n+        num_attention_heads: Optional[int] = 16,\n+        num_key_value_heads: Optional[int] = 2,\n+        hidden_act: Optional[str] = \"silu\",\n+        max_position_embeddings: Optional[int] = 131072,\n+        initializer_range: Optional[float] = 0.02,\n+        rms_norm_eps: Optional[int] = 1e-05,\n+        use_cache: Optional[int] = True,\n+        pad_token_id: Optional[int] = 0,\n+        bos_token_id: Optional[int] = 1,\n+        eos_token_id: Optional[int] = 2,\n+        tie_word_embeddings: Optional[bool] = True,\n+        rope_parameters: Optional[RopeParameters | dict[str, RopeParameters]] = None,\n+        use_bias: Optional[bool] = False,\n+        head_dim: Optional[int] = 128,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.use_bias = use_bias\n+        self.head_dim = head_dim if head_dim is not None else self.hidden_size // self.num_attention_heads\n+        self.rope_parameters = rope_parameters\n+\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+\n+\n+class PaddleOCRVLConfig(PreTrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`PaddleOCRVLForConditionalGeneration`]. It is used to instantiate a\n+    PaddleOCRVL model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of\n+    PaddleOCRVL [PaddlePaddle/PaddleOCR-VL](https://huggingface.co/PaddlePaddle/PaddleOCR-VL).\n+\n+    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PreTrainedConfig`] for more information.\n+\n+\n+    Args:\n+        text_config (`Union[PreTrainedConfig, dict]`, *optional*, defaults to `PaddleOCRTextConfig`):\n+            The config object or dictionary of the text backbone.\n+        vision_config (`Union[PreTrainedConfig, dict]`,  *optional*, defaults to `PaddleOCRVisionConfig`):\n+            The config object or dictionary of the vision backbone.\n+        image_token_id (`int`, *optional*, defaults to 100295):\n+            The image token index to encode the image prompt.\n+        video_token_id (`int`, *optional*, defaults to 100296):\n+            The video token index to encode the image prompt.\n+        vision_start_token_id (`int`, *optional*, defaults to 101305):\n+            The token index to denote start of vision input.\n+        vision_end_token_id (`int`, *optional*, defaults to 101306):\n+            The token index to denote end of vision input.\n+\n+    ```python\n+    >>> from transformers import PaddleOCRVLForConditionalGeneration, PaddleOCRVLConfig\n+\n+    >>> # Initializing a PaddleOCRVL style configuration\n+    >>> configuration = PaddleOCRVLConfig()\n+\n+    >>> # Initializing a model from the PaddleOCRVL style configuration\n+    >>> model = PaddleOCRVLForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"paddleocr_vl\"\n+\n+    sub_configs = {\"vision_config\": PaddleOCRVisionConfig, \"text_config\": PaddleOCRTextConfig}\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        text_config=None,\n+        vision_config=None,\n+        image_token_id=100295,\n+        video_token_id=100296,\n+        vision_start_token_id=101305,\n+        vision_end_token_id=101306,\n+        **kwargs,\n+    ):\n+        if isinstance(vision_config, dict):\n+            self.vision_config = self.sub_configs[\"vision_config\"](**vision_config)\n+        elif vision_config is None:\n+            self.vision_config = self.sub_configs[\"vision_config\"]()\n+\n+        if isinstance(text_config, dict):\n+            self.text_config = self.sub_configs[\"text_config\"](**text_config)\n+        elif text_config is None:\n+            # Hub configs are saved as flat dicts so we pop some of kwargs to init `TextConfig`\n+            text_params = inspect.signature(self.sub_configs[\"text_config\"].__init__).parameters.keys()\n+            text_params = list(text_params) + [\"rope_scaling\", \"rope_theta\"]\n+            text_config = {key: kwargs.pop(key) for key in text_params if key in kwargs}\n+            text_config[\"dtype\"] = kwargs.get(\"torch_dtype\", kwargs.get(\"dtype\"))  # don't pop the dtype\n+            self.text_config = self.sub_configs[\"text_config\"](**text_config)\n+\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.vision_start_token_id = vision_start_token_id\n+        self.vision_end_token_id = vision_end_token_id\n+\n+        # FIXME: arthur/cyril - tying has to be used from the text config\n+        kwargs[\"tie_word_embeddings\"] = self.text_config.tie_word_embeddings\n+        super().__init__(**kwargs)\n+\n+\n+__all__ = [\"PaddleOCRVLConfig\", \"PaddleOCRVisionConfig\", \"PaddleOCRTextConfig\"]"
        },
        {
            "sha": "101668ea0335def02cfc51556587658cfced93a3",
            "filename": "src/transformers/models/paddleocr_vl/image_processing_paddleocr_vl.py",
            "status": "added",
            "additions": 503,
            "deletions": 0,
            "changes": 503,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fimage_processing_paddleocr_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fimage_processing_paddleocr_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fimage_processing_paddleocr_vl.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -0,0 +1,503 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/paddleocr_vl/modular_paddleocr_vl.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_paddleocr_vl.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# Copyright 2025 The PaddlePaddle Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import math\n+from typing import Optional, Union\n+\n+import numpy as np\n+\n+from ...image_processing_utils import BaseImageProcessor, BatchFeature\n+from ...image_transforms import convert_to_rgb, resize, to_channel_dimension_format\n+from ...image_utils import (\n+    OPENAI_CLIP_MEAN,\n+    OPENAI_CLIP_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    is_scaled_image,\n+    make_flat_list_of_images,\n+    make_list_of_images,\n+    to_numpy_array,\n+    valid_images,\n+    validate_preprocess_arguments,\n+)\n+from ...processing_utils import ImagesKwargs\n+from ...utils import TensorType, logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class PaddleOCRVLImageProcessorKwargs(ImagesKwargs, total=False):\n+    r\"\"\"\n+    min_pixels (`int`, *optional*, defaults to `56 * 56`):\n+        The min pixels of the image to resize the image.\n+    max_pixels (`int`, *optional*, defaults to `28 * 28 * 1280`):\n+        The max pixels of the image to resize the image.\n+    patch_size (`int`, *optional*, defaults to 14):\n+        The spatial patch size of the vision encoder.\n+    temporal_patch_size (`int`, *optional*, defaults to 2):\n+        The temporal patch size of the vision encoder.\n+    merge_size (`int`, *optional*, defaults to 2):\n+        The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    min_pixels: int\n+    max_pixels: int\n+    patch_size: int\n+    temporal_patch_size: int\n+    merge_size: int\n+\n+\n+def smart_resize(\n+    height: int,\n+    width: int,\n+    factor: int = 28,\n+    min_pixels: int = 384 * 384,\n+    max_pixels: int = 1536 * 1536,\n+):\n+    if height < factor:\n+        width = round((width * factor) / height)\n+        height = factor\n+\n+    if width < factor:\n+        height = round((height * factor) / width)\n+        width = factor\n+\n+    if max(height, width) / min(height, width) > 200:\n+        raise ValueError(\n+            f\"absolute aspect ratio must be smaller than 200, got {max(height, width) / min(height, width)}\"\n+        )\n+    h_bar = round(height / factor) * factor\n+    w_bar = round(width / factor) * factor\n+    if h_bar * w_bar > max_pixels:\n+        beta = math.sqrt((height * width) / max_pixels)\n+        h_bar = math.floor(height / beta / factor) * factor\n+        w_bar = math.floor(width / beta / factor) * factor\n+    elif h_bar * w_bar < min_pixels:\n+        beta = math.sqrt(min_pixels / (height * width))\n+        h_bar = math.ceil(height * beta / factor) * factor\n+        w_bar = math.ceil(width * beta / factor) * factor\n+    return h_bar, w_bar\n+\n+\n+class PaddleOCRVLImageProcessor(BaseImageProcessor):\n+    r\"\"\"\n+    Constructs a PaddleOCRVL image processor that dynamically resizes images based on the original images.\n+\n+    Args:\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image's (height, width) dimensions.\n+        size (`dict[str, int]`, *optional*):\n+            Size of the image after resizing. `shortest_edge` and `longest_edge` keys must be present.\n+        resample (`PILImageResampling`, *optional*, defaults to `Resampling.BICUBIC`):\n+            Resampling filter to use when resizing the image.\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image by the specified scale `rescale_factor`.\n+        rescale_factor (`int` or `float`, *optional*, defaults to `1/255`):\n+            Scale factor to use if rescaling the image.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image.\n+        image_mean (`float` or `list[float]`, *optional*):\n+            Mean to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        image_std (`float` or `list[float]`, *optional*):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB.\n+        min_pixels (`int`, *optional*, defaults to `384 * 384`):\n+            The min pixels of the image to resize the image.\n+        max_pixels (`int`, *optional*, defaults to `1536 * 1536`):\n+            The max pixels of the image to resize the image.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spatial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*, defaults to 1):\n+            The temporal patch size of the vision encoder.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    model_input_names = [\n+        \"pixel_values\",\n+        \"image_grid_thw\",\n+    ]\n+    valid_kwargs = PaddleOCRVLImageProcessorKwargs\n+\n+    def __init__(\n+        self,\n+        do_resize: bool = True,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = PILImageResampling.BICUBIC,\n+        do_rescale: bool = True,\n+        rescale_factor: Union[int, float] = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        do_convert_rgb: bool = True,\n+        min_pixels: int = 384 * 384,\n+        max_pixels: int = 1536 * 1536,\n+        patch_size: int = 14,\n+        temporal_patch_size: int = 1,\n+        merge_size: int = 2,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+        else:\n+            size = {\"shortest_edge\": 56 * 56, \"longest_edge\": 28 * 28 * 1280}\n+        # backward compatibility: override size with min_pixels and max_pixels if they are provided\n+        if min_pixels is not None:\n+            size[\"shortest_edge\"] = min_pixels\n+        if max_pixels is not None:\n+            size[\"longest_edge\"] = max_pixels\n+        self.min_pixels = size[\"shortest_edge\"]\n+        self.max_pixels = size[\"longest_edge\"]\n+        self.size = size\n+\n+        self.do_resize = do_resize\n+        self.resample = resample\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean if image_mean is not None else OPENAI_CLIP_MEAN\n+        self.image_std = image_std if image_std is not None else OPENAI_CLIP_STD\n+\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.merge_size = merge_size\n+        self.do_convert_rgb = do_convert_rgb\n+\n+    def _preprocess(\n+        self,\n+        images: ImageInput,\n+        do_resize: Optional[bool] = None,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = None,\n+        do_rescale: Optional[bool] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        do_convert_rgb: Optional[bool] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n+        Args:\n+            images (`ImageInput`):\n+                Image or batch of images to preprocess. Expects pixel values ranging from 0 to 255. If pixel values range from 0 to 1, set `do_rescale=False`.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. `shortest_edge` and `longest_edge` keys must be present.\n+            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the `PILImageResampling` enums.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Scale factor to use if rescaling the image.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Mean to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Standard deviation to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            patch_size (`int`, *optional*, defaults to `self.patch_size`):\n+                The spatial patch size of the vision encoder.\n+            temporal_patch_size (`int`, *optional*, defaults to `self.temporal_patch_size`):\n+                The temporal patch size of the vision encoder.\n+            merge_size (`int`, *optional*, defaults to `self.merge_size`):\n+                The merge size of the vision encoder to llm encoder.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            data_format (`ChannelDimension`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.   - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+        images = make_list_of_images(images)\n+        images = self.fetch_images(images)\n+\n+        if do_convert_rgb:\n+            images = [convert_to_rgb(image) for image in images]\n+\n+        # All transformations expect numpy arrays.\n+        images = [to_numpy_array(image) for image in images]\n+\n+        if is_scaled_image(images[0]) and do_rescale:\n+            logger.warning_once(\n+                \"It looks like you are trying to rescale already rescaled images. If the input\"\n+                \" images have pixel values between 0 and 1, set `do_rescale=False` to avoid rescaling them again.\"\n+            )\n+        if input_data_format is None:\n+            # We assume that all images have the same channel dimension format.\n+            input_data_format = infer_channel_dimension_format(images[0])\n+\n+        height, width = get_image_size(images[0], channel_dim=input_data_format)\n+        resized_height, resized_width = height, width\n+        processed_images = []\n+\n+        for image in images:\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    height,\n+                    width,\n+                    factor=patch_size * merge_size,\n+                    min_pixels=size[\"shortest_edge\"],\n+                    max_pixels=size[\"longest_edge\"],\n+                )\n+                image = resize(\n+                    image,\n+                    size=(resized_height, resized_width),\n+                    resample=resample,\n+                    input_data_format=input_data_format,\n+                )\n+\n+            if do_rescale:\n+                image = self.rescale(image, scale=rescale_factor, input_data_format=input_data_format)\n+\n+            if do_normalize:\n+                image = self.normalize(\n+                    image=image,\n+                    mean=image_mean,\n+                    std=image_std,\n+                    input_data_format=input_data_format,\n+                )\n+            image = to_channel_dimension_format(image, data_format, input_channel_dim=input_data_format)\n+            processed_images.append(image)\n+\n+        patches = np.array(processed_images)\n+        if data_format == ChannelDimension.LAST:\n+            patches = patches.transpose(0, 3, 1, 2)\n+        if patches.shape[0] == 1:\n+            patches = np.tile(patches, (temporal_patch_size, 1, 1, 1))\n+\n+        channel = patches.shape[1]\n+        grid_t = patches.shape[0] // temporal_patch_size\n+        grid_h, grid_w = (\n+            resized_height // patch_size,\n+            resized_width // patch_size,\n+        )\n+        patches = patches.reshape(\n+            grid_t,\n+            temporal_patch_size,\n+            channel,\n+            grid_h,\n+            patch_size,\n+            grid_w,\n+            patch_size,\n+        )\n+        patches = patches.transpose(0, 3, 5, 2, 1, 4, 6)\n+        if temporal_patch_size != 1:\n+            raise ValueError(f\"temporal_patch_size must be 1!, but got {temporal_patch_size}!\")\n+        flatten_patches = patches.reshape(grid_t * grid_h * grid_w, channel, patch_size, patch_size)\n+        return flatten_patches, (grid_t, grid_h, grid_w)\n+\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        do_resize: Optional[bool] = None,\n+        size: Optional[dict[str, int]] = None,\n+        min_pixels: Optional[int] = None,\n+        max_pixels: Optional[int] = None,\n+        resample: Optional[PILImageResampling] = None,\n+        do_rescale: Optional[bool] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        do_convert_rgb: Optional[bool] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Args:\n+            images (`ImageInput`):\n+                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n+                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n+                the longest edge resized to keep the input aspect ratio.\n+            resample (`int`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n+                has an effect if `do_resize` is set to `True`.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `list[float]`, *optional*, defaults to `self.image_mean`):\n+                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n+            image_std (`float` or `list[float]`, *optional*, defaults to `self.image_std`):\n+                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n+                `True`.\n+            min_pixels (`int`, *optional*, defaults to `self.min_pixels`):\n+                The min pixels of the image to resize the image.\n+            max_pixels (`int`, *optional*, defaults to `self.max_pixels`):\n+                The max pixels of the image to resize the image.\n+            patch_size (`int`, *optional*, defaults to `self.patch_size`):\n+                The spatial patch size of the vision encoder.\n+            temporal_patch_size (`int`, *optional*, defaults to `self.temporal_patch_size`):\n+                The temporal patch size of the vision encoder.\n+            merge_size (`int`, *optional*, defaults to `self.merge_size`):\n+                The merge size of the vision encoder to llm encoder.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                - Unset: Return a list of `np.ndarray`.\n+                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n+                from the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+\n+        \"\"\"\n+        min_pixels = min_pixels if min_pixels is not None else self.min_pixels\n+        max_pixels = max_pixels if max_pixels is not None else self.max_pixels\n+\n+        if size is not None:\n+            if \"shortest_edge\" not in size or \"longest_edge\" not in size:\n+                raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+            min_pixels = size[\"shortest_edge\"]\n+        elif min_pixels is not None and max_pixels is not None:\n+            # backward compatibility: override size with min_pixels and max_pixels if they are provided\n+            size = {\"shortest_edge\": min_pixels, \"longest_edge\": max_pixels}\n+        else:\n+            size = {**self.size}\n+\n+        do_resize = do_resize if do_resize is not None else self.do_resize\n+\n+        resample = resample if resample is not None else self.resample\n+        do_rescale = do_rescale if do_rescale is not None else self.do_rescale\n+        rescale_factor = rescale_factor if rescale_factor is not None else self.rescale_factor\n+        do_normalize = do_normalize if do_normalize is not None else self.do_normalize\n+        image_mean = image_mean if image_mean is not None else self.image_mean\n+        image_std = image_std if image_std is not None else self.image_std\n+        patch_size = patch_size if patch_size is not None else self.patch_size\n+        temporal_patch_size = temporal_patch_size if temporal_patch_size is not None else self.temporal_patch_size\n+        merge_size = merge_size if merge_size is not None else self.merge_size\n+        do_convert_rgb = do_convert_rgb if do_convert_rgb is not None else self.do_convert_rgb\n+\n+        if images is not None:\n+            images = self.fetch_images(images)\n+            images = make_flat_list_of_images(images)\n+\n+        if images is not None and not valid_images(images):\n+            raise ValueError(\"Invalid image type. Must be of type PIL.Image.Image, numpy.ndarray, or torch.Tensor\")\n+\n+        validate_preprocess_arguments(\n+            rescale_factor=rescale_factor,\n+            do_normalize=do_normalize,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            do_resize=do_resize,\n+            size=size,\n+            resample=resample,\n+        )\n+\n+        data = {}\n+        pixel_values, vision_grid_thws = [], []\n+        for image in images:\n+            patches, image_grid_thw = self._preprocess(\n+                image,\n+                do_resize=do_resize,\n+                size=size,\n+                resample=resample,\n+                do_rescale=do_rescale,\n+                rescale_factor=rescale_factor,\n+                do_normalize=do_normalize,\n+                image_mean=image_mean,\n+                image_std=image_std,\n+                patch_size=patch_size,\n+                temporal_patch_size=temporal_patch_size,\n+                merge_size=merge_size,\n+                data_format=data_format,\n+                do_convert_rgb=do_convert_rgb,\n+                input_data_format=input_data_format,\n+            )\n+            pixel_values.extend(patches)\n+            vision_grid_thws.append(image_grid_thw)\n+        pixel_values = np.array(pixel_values)\n+        vision_grid_thws = np.array(vision_grid_thws)\n+        data.update({\"pixel_values\": pixel_values, \"image_grid_thw\": vision_grid_thws})\n+\n+        return BatchFeature(data=data, tensor_type=return_tensors)\n+\n+    def get_number_of_image_patches(self, height: int, width: int, images_kwargs=None):\n+        \"\"\"\n+        A utility that returns number of image patches for a given image size.\n+\n+        Args:\n+            height (`int`):\n+                Height of the input image.\n+            width (`int`):\n+                Width of the input image.\n+            images_kwargs (`dict`, *optional*)\n+                Any kwargs to override defaults of the image processor.\n+        Returns:\n+            `int`: Number of image patches per image.\n+        \"\"\"\n+        min_pixels = images_kwargs[\"min_pixels\"] if \"min_pixels\" in images_kwargs else self.size[\"shortest_edge\"]\n+        max_pixels = images_kwargs[\"max_pixels\"] if \"max_pixels\" in images_kwargs else self.size[\"longest_edge\"]\n+        patch_size = images_kwargs.get(\"patch_size\", self.patch_size)\n+        merge_size = images_kwargs.get(\"merge_size\", self.merge_size)\n+\n+        factor = patch_size * merge_size\n+        resized_height, resized_width = smart_resize(\n+            height, width, factor, min_pixels=min_pixels, max_pixels=max_pixels\n+        )\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+        return grid_h * grid_w\n+\n+\n+__all__ = [\"PaddleOCRVLImageProcessor\"]"
        },
        {
            "sha": "cf6a65889b97c3372c605ff45f8e7dc20417b277",
            "filename": "src/transformers/models/paddleocr_vl/image_processing_paddleocr_vl_fast.py",
            "status": "added",
            "additions": 209,
            "deletions": 0,
            "changes": 209,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fimage_processing_paddleocr_vl_fast.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fimage_processing_paddleocr_vl_fast.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fimage_processing_paddleocr_vl_fast.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -0,0 +1,209 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/paddleocr_vl/modular_paddleocr_vl.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_paddleocr_vl.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# Copyright 2025 The PaddlePaddle Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import math\n+from typing import Optional, Union\n+\n+import torch\n+import torch.nn.functional as F\n+\n+from ...image_processing_utils import BatchFeature\n+from ...image_processing_utils_fast import BaseImageProcessorFast, group_images_by_shape, reorder_images\n+from ...image_utils import OPENAI_CLIP_MEAN, OPENAI_CLIP_STD, PILImageResampling, SizeDict\n+from ...utils import TensorType\n+\n+\n+def smart_resize(\n+    height: int,\n+    width: int,\n+    factor: int = 28,\n+    min_pixels: int = 384 * 384,\n+    max_pixels: int = 1536 * 1536,\n+):\n+    if height < factor:\n+        width = round((width * factor) / height)\n+        height = factor\n+\n+    if width < factor:\n+        height = round((height * factor) / width)\n+        width = factor\n+\n+    if max(height, width) / min(height, width) > 200:\n+        raise ValueError(\n+            f\"absolute aspect ratio must be smaller than 200, got {max(height, width) / min(height, width)}\"\n+        )\n+    h_bar = round(height / factor) * factor\n+    w_bar = round(width / factor) * factor\n+    if h_bar * w_bar > max_pixels:\n+        beta = math.sqrt((height * width) / max_pixels)\n+        h_bar = math.floor(height / beta / factor) * factor\n+        w_bar = math.floor(width / beta / factor) * factor\n+    elif h_bar * w_bar < min_pixels:\n+        beta = math.sqrt(min_pixels / (height * width))\n+        h_bar = math.ceil(height * beta / factor) * factor\n+        w_bar = math.ceil(width * beta / factor) * factor\n+    return h_bar, w_bar\n+\n+\n+class PaddleOCRVLImageProcessorFast(BaseImageProcessorFast):\n+    def __init__(\n+        self,\n+        do_resize: bool = True,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = PILImageResampling.BICUBIC,\n+        do_rescale: bool = True,\n+        rescale_factor: Union[int, float] = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        do_convert_rgb: bool = True,\n+        min_pixels: int = 384 * 384,\n+        max_pixels: int = 1536 * 1536,\n+        patch_size: int = 14,\n+        temporal_patch_size: int = 1,\n+        merge_size: int = 2,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+        else:\n+            size = {\"shortest_edge\": 384 * 384, \"longest_edge\": 1536 * 1536}\n+        # backward compatibility: override size with min_pixels and max_pixels if they are provided\n+        if min_pixels is not None:\n+            size[\"shortest_edge\"] = min_pixels\n+        if max_pixels is not None:\n+            size[\"longest_edge\"] = max_pixels\n+        self.min_pixels = size[\"shortest_edge\"]\n+        self.max_pixels = size[\"longest_edge\"]\n+        self.size = size\n+\n+        self.do_resize = do_resize\n+        self.resample = resample\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean if image_mean is not None else OPENAI_CLIP_MEAN\n+        self.image_std = image_std if image_std is not None else OPENAI_CLIP_STD\n+\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.merge_size = merge_size\n+        self.do_convert_rgb = do_convert_rgb\n+\n+    def _preprocess(\n+        self,\n+        images: list[\"torch.Tensor\"],\n+        do_resize: bool,\n+        size: SizeDict,\n+        interpolation: Optional[\"F.InterpolationMode\"],\n+        do_rescale: bool,\n+        rescale_factor: float,\n+        do_normalize: bool,\n+        image_mean: Optional[Union[float, list[float]]],\n+        image_std: Optional[Union[float, list[float]]],\n+        disable_grouping: Optional[bool],\n+        return_tensors: Optional[Union[str, TensorType]],\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        **kwargs,\n+    ):\n+        patch_size = patch_size if patch_size is not None else self.patch_size\n+        temporal_patch_size = temporal_patch_size if temporal_patch_size is not None else self.temporal_patch_size\n+        merge_size = merge_size if merge_size is not None else self.merge_size\n+\n+        grouped_images, grouped_images_index = group_images_by_shape(images, disable_grouping=disable_grouping)\n+        resized_images_grouped = {}\n+        for shape, stacked_images in grouped_images.items():\n+            height, width = stacked_images.shape[-2:]\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    height,\n+                    width,\n+                    factor=patch_size * merge_size,\n+                    min_pixels=size[\"shortest_edge\"],\n+                    max_pixels=size[\"longest_edge\"],\n+                )\n+                stacked_images = self.resize(\n+                    image=stacked_images,\n+                    size=SizeDict(height=resized_height, width=resized_width),\n+                    interpolation=interpolation,\n+                )\n+            resized_images_grouped[shape] = stacked_images\n+        resized_images = reorder_images(resized_images_grouped, grouped_images_index)\n+\n+        # Group images by size for further processing\n+        # Needed in case do_resize is False, or resize returns images with different sizes\n+        grouped_images, grouped_images_index = group_images_by_shape(resized_images, disable_grouping=disable_grouping)\n+        processed_images_grouped = {}\n+        processed_grids = {}\n+        for shape, stacked_images in grouped_images.items():\n+            resized_height, resized_width = stacked_images.shape[-2:]\n+            # Fused rescale and normalize\n+            patches = self.rescale_and_normalize(\n+                stacked_images, do_rescale, rescale_factor, do_normalize, image_mean, image_std\n+            )\n+\n+            if patches.ndim == 4:\n+                # add a temporal dimension if we have images\n+                patches = patches.unsqueeze(1)\n+            if patches.shape[1] % temporal_patch_size != 0:\n+                repeats = patches[:, -1:].repeat(1, temporal_patch_size - 1, 1, 1, 1)\n+                patches = torch.cat([patches, repeats], dim=1)\n+\n+            batch_size, grid_t, channel = patches.shape[:3]\n+            grid_t = grid_t // temporal_patch_size\n+            grid_h, grid_w = (\n+                resized_height // patch_size,\n+                resized_width // patch_size,\n+            )\n+            patches = patches.view(\n+                batch_size,\n+                grid_t,\n+                temporal_patch_size,\n+                channel,\n+                grid_h,\n+                patch_size,\n+                grid_w,\n+                patch_size,\n+            )\n+            patches = patches.permute(0, 1, 4, 6, 3, 2, 5, 7)\n+            flatten_patches = patches.reshape(batch_size, grid_t * grid_h * grid_w, channel, patch_size, patch_size)\n+\n+            processed_images_grouped[shape] = flatten_patches\n+            processed_grids[shape] = [[grid_t, grid_h, grid_w]] * batch_size\n+\n+        processed_images = reorder_images(processed_images_grouped, grouped_images_index)\n+        processed_grids = reorder_images(processed_grids, grouped_images_index)\n+        pixel_values = torch.cat(processed_images, dim=0)\n+        image_grid_thw = torch.tensor(processed_grids)\n+\n+        return BatchFeature(\n+            data={\"pixel_values\": pixel_values, \"image_grid_thw\": image_grid_thw}, tensor_type=return_tensors\n+        )\n+\n+\n+__all__ = [\"PaddleOCRVLImageProcessorFast\"]"
        },
        {
            "sha": "ebd48e8d9c69a6ca8fbd14c5dc8ab05db970a575",
            "filename": "src/transformers/models/paddleocr_vl/modeling_paddleocr_vl.py",
            "status": "added",
            "additions": 1668,
            "deletions": 0,
            "changes": 1668,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fmodeling_paddleocr_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fmodeling_paddleocr_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fmodeling_paddleocr_vl.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -0,0 +1,1668 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/paddleocr_vl/modular_paddleocr_vl.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_paddleocr_vl.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# Copyright 2025 The PaddlePaddle Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from collections.abc import Callable\n+from dataclasses import dataclass\n+from typing import Any, Optional, Union\n+\n+import torch\n+from torch import nn\n+\n+from ...activations import ACT2FN, GELUActivation\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...integrations import use_kernel_forward_from_hub\n+from ...masking_utils import create_bidirectional_mask, create_causal_mask\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import BaseModelOutput, BaseModelOutputWithPast, BaseModelOutputWithPooling, ModelOutput\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring, can_return_tuple, logging, torch_int\n+from ...utils.generic import check_model_inputs, maybe_autocast\n+from .configuration_paddleocr_vl import PaddleOCRTextConfig, PaddleOCRVisionConfig, PaddleOCRVLConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class PaddleOCRProjector(nn.Module):\n+    def __init__(self, config: PaddleOCRVLConfig):\n+        super().__init__()\n+        self.merge_kernel_size = (config.vision_config.spatial_merge_size, config.vision_config.spatial_merge_size)\n+\n+        hidden_size = config.vision_config.hidden_size * self.merge_kernel_size[0] * self.merge_kernel_size[1]\n+\n+        self.pre_norm = torch.nn.LayerNorm(config.vision_config.hidden_size, eps=1e-05)\n+        self.linear_1 = nn.Linear(hidden_size, hidden_size, bias=True)\n+        self.act = GELUActivation()\n+        self.linear_2 = nn.Linear(hidden_size, config.text_config.hidden_size, bias=True)\n+\n+    def forward(self, image_features: torch.Tensor, image_grid_thw: torch.Tensor) -> torch.Tensor:\n+        image_features_chunks = image_features.split(image_grid_thw.prod(dim=1).tolist(), dim=0)\n+        m1, m2 = self.merge_kernel_size\n+\n+        processed_features = []\n+        for image_feature, image_grid in zip(image_features_chunks, image_grid_thw):\n+            image_feature = self.pre_norm(image_feature)\n+            t, h, w = image_grid\n+            d = image_feature.shape[-1]\n+            h_block = h // m1\n+            w_block = w // m2\n+\n+            image_feature = image_feature.reshape(t, h_block, m1, w_block, m2, d)\n+            image_feature = image_feature.transpose(2, 3)\n+            image_feature = image_feature.reshape(t * h_block * w_block, m1 * m2 * d)\n+\n+            hidden_states = self.linear_1(image_feature)\n+            hidden_states = self.act(hidden_states)\n+            hidden_states = self.linear_2(hidden_states)\n+            processed_features.append(hidden_states)\n+\n+        return torch.cat(processed_features, dim=0)\n+\n+\n+class PaddleOCRVisionRotaryEmbedding(nn.Module):\n+    inv_freq: torch.Tensor  # fix linting for `register_buffer`\n+\n+    def __init__(self, dim: int, theta: float = 10000.0) -> None:\n+        super().__init__()\n+        inv_freq = 1.0 / (theta ** (torch.arange(0, dim, 2, dtype=torch.float) / dim))\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+\n+    def forward(self, seqlen: int) -> torch.Tensor:\n+        seq = torch.arange(seqlen, device=self.inv_freq.device, dtype=self.inv_freq.dtype)\n+        freqs = torch.outer(seq, self.inv_freq)\n+        return freqs\n+\n+\n+class PaddleOCRRotaryEmbedding(nn.Module):\n+    inv_freq: torch.Tensor  # fix linting for `register_buffer`\n+\n+    def __init__(self, config: PaddleOCRVLConfig, device=None):\n+        super().__init__()\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+\n+        self.rope_type = self.config.rope_parameters[\"rope_type\"]\n+        rope_init_fn: Callable = self.compute_default_rope_parameters\n+        if self.rope_type != \"default\":\n+            rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+        inv_freq, self.attention_scaling = rope_init_fn(self.config, device)\n+\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = inv_freq\n+\n+    @staticmethod\n+    def compute_default_rope_parameters(\n+        config: Optional[PaddleOCRVLConfig] = None,\n+        device: Optional[\"torch.device\"] = None,\n+        seq_len: Optional[int] = None,\n+    ) -> tuple[\"torch.Tensor\", float]:\n+        \"\"\"\n+        Computes the inverse frequencies according to the original RoPE implementation\n+        Args:\n+            config ([`~transformers.PreTrainedConfig`]):\n+                The model configuration.\n+            device (`torch.device`):\n+                The device to use for initialization of the inverse frequencies.\n+            seq_len (`int`, *optional*):\n+                The current sequence length. Unused for this type of RoPE.\n+        Returns:\n+            Tuple of (`torch.Tensor`, `float`), containing the inverse frequencies for the RoPE embeddings and the\n+            post-processing scaling factor applied to the computed cos/sin (unused in this type of RoPE).\n+        \"\"\"\n+        base = config.rope_parameters[\"rope_theta\"]\n+        dim = getattr(config, \"head_dim\", None) or config.hidden_size // config.num_attention_heads\n+\n+        attention_factor = 1.0  # Unused in this type of RoPE\n+\n+        # Compute the inverse frequencies\n+        inv_freq = 1.0 / (\n+            base ** (torch.arange(0, dim, 2, dtype=torch.int64).to(device=device, dtype=torch.float) / dim)\n+        )\n+        return inv_freq, attention_factor\n+\n+    # Ignore copy\n+    def forward(self, x, position_ids):\n+        # In contrast to other models, PaddleOCR has different position ids for the grids\n+        # So we expand the inv_freq to shape (3, ...)\n+        inv_freq_expanded = self.inv_freq[None, None, :, None].float().expand(3, position_ids.shape[1], -1, 1)\n+        position_ids_expanded = position_ids[:, :, None, :].float()  # shape (3, bs, 1, positions)\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with maybe_autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(2, 3)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos() * self.attention_scaling\n+            sin = emb.sin() * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+class PaddleOCRMLP(nn.Module):\n+    def __init__(self, config: PaddleOCRTextConfig):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size\n+\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=config.use_bias)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=config.use_bias)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=config.use_bias)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, x):\n+        down_proj = self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x))\n+        return down_proj\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs,\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+def apply_multimodal_rotary_pos_emb(q, k, cos, sin, mrope_section, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding with Multimodal Sections to the query and key tensors (https://qwenlm.github.io/blog/qwen2-vl/).\n+\n+    Explanation:\n+        Multimodal 3D rotary position embedding is an extension to 1D rotary position embedding. The input embedding\n+        sequence contains vision (images / videos) embedding and text embedding or just contains text embedding. For\n+        vision embedding part, we apply rotary position embedding on temporal, height and width dimension separately.\n+        Here we split the channel dimension to 3 chunks for the temporal, height and width rotary position embedding.\n+        For text embedding part, we just apply 1D rotary position embedding. The three rotary position index (temporal,\n+        height and width) of text embedding is always the same, so the text embedding rotary position embedding has no\n+        difference with modern LLMs.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`):\n+            The position indices of the tokens corresponding to the query and key tensors. For example, this can be\n+            used to pass offsetted position ids when working with a KV-cache.\n+        mrope_section(`List(int)`):\n+            Multimodal rope section is for channel dimension of temporal, height and width in rope calculation.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    mrope_section = mrope_section * 2\n+    cos = torch.cat([m[i % 3] for i, m in enumerate(cos.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+    sin = torch.cat([m[i % 3] for i, m in enumerate(sin.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    return q_embed, k_embed\n+\n+\n+class PaddleOCRAttention(nn.Module):\n+    \"\"\"\n+    Multi-headed attention from 'Attention Is All You Need' paper. Modified to use sliding window attention: Longformer\n+    and \"Generating Long Sequences with Sparse Transformers\".\n+    \"\"\"\n+\n+    def __init__(self, config: PaddleOCRVLConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        if layer_idx is None:\n+            logger.warning_once(\n+                f\"Instantiating {self.__class__.__name__} without passing `layer_idx` is not recommended and will \"\n+                \"to errors during the forward call, if caching is used. Please make sure to provide a `layer_idx` \"\n+                \"when creating this class.\"\n+            )\n+\n+        self.hidden_size = config.hidden_size\n+        self.num_heads = config.num_attention_heads\n+        self.head_dim = getattr(config, \"head_dim\", self.hidden_size // self.num_heads)\n+        self.num_key_value_heads = config.num_key_value_heads\n+        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n+        self.is_causal = True\n+\n+        self.attention_dropout = 0.0\n+        self.rope_parameters = config.rope_parameters\n+        self.scaling = self.head_dim**-0.5\n+        self.q_proj = nn.Linear(self.hidden_size, self.num_heads * self.head_dim, bias=config.use_bias)\n+        self.k_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=config.use_bias)\n+        self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=config.use_bias)\n+        self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=config.use_bias)\n+        self.layer_type = config.layer_types[layer_idx] if hasattr(config, \"layer_types\") else None\n+        self.sliding_window = config.sliding_window if self.layer_type == \"sliding_attention\" else None\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor], Optional[tuple[torch.Tensor]]]:\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_multimodal_rotary_pos_emb(\n+            query_states, key_states, cos, sin, self.config.rope_parameters[\"mrope_section\"]\n+        )\n+\n+        if past_key_values is not None:\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}  # Specific to RoPE models\n+            key_states, value_states = past_key_values.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            sliding_window=self.sliding_window,\n+            position_ids=position_ids,  # pass positions for FA2\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(bsz, q_len, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+@use_kernel_forward_from_hub(\"RMSNorm\")\n+class PaddleOCRRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        PaddleOCRRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class PaddleOCRDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: PaddleOCRTextConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        self.self_attn = PaddleOCRAttention(config=config, layer_idx=layer_idx)\n+\n+        self.mlp = PaddleOCRMLP(config)\n+        self.input_layernorm = PaddleOCRRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = PaddleOCRRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> torch.Tensor:\n+        residual = hidden_states\n+        hidden_states = self.input_layernorm(hidden_states)\n+        # Self Attention\n+        hidden_states, _ = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class PaddleOCRVLPreTrainedModel(PreTrainedModel):\n+    config: PaddleOCRVLConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"PaddleOCRDecoderLayer\"]\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _supports_flash_attn = True\n+    _supports_sdpa = True\n+    _supports_flex_attn = True\n+\n+    _can_compile_fullgraph = True\n+    _supports_attention_backend = True\n+\n+    _can_record_outputs = {\n+        \"hidden_states\": PaddleOCRDecoderLayer,\n+        \"attentions\": PaddleOCRAttention,\n+    }\n+\n+\n+@auto_docstring\n+class PaddleOCRTextModel(PaddleOCRVLPreTrainedModel):\n+    def __init__(self, config: PaddleOCRTextConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [PaddleOCRDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = PaddleOCRRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = PaddleOCRRotaryEmbedding(config=config)\n+        self.gradient_checkpointing = False\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @check_model_inputs\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> BaseModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds: torch.Tensor = self.embed_tokens(input_ids)\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache(config=self.config)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position: torch.Tensor = (\n+                torch.arange(inputs_embeds.shape[1], device=inputs_embeds.device) + past_seen_tokens\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.view(1, 1, -1).expand(3, inputs_embeds.shape[0], -1)\n+        elif position_ids.ndim == 2:\n+            position_ids = position_ids[None, ...].expand(3, position_ids.shape[0], -1)\n+\n+        if position_ids.ndim == 3 and position_ids.shape[0] == 4:\n+            text_position_ids = position_ids[0]\n+            position_ids = position_ids[1:]\n+        else:\n+            text_position_ids = None\n+\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=text_position_ids,\n+        )\n+\n+        hidden_states = inputs_embeds\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids=position_ids)\n+\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask,\n+                position_embeddings=position_embeddings,\n+                position_ids=text_position_ids,\n+                past_key_values=past_key_values,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+\n+        hidden_states = self.norm(hidden_states)\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+class PaddleOCRVisionModel(PaddleOCRVLPreTrainedModel):\n+    config: PaddleOCRVisionConfig\n+    main_input_name = \"pixel_values\"\n+    input_modalities = \"image\"\n+\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__(config)\n+\n+        self.vision_model = PaddleOCRVisionTransformer(config)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def forward(\n+        self,\n+        pixel_values: torch.FloatTensor,\n+        cu_seqlens: torch.Tensor,\n+        image_grid_thw: Optional[list[Union[tuple[int, int, int], list[tuple[int, int, int]]]]] = None,\n+        **kwargs,\n+    ) -> BaseModelOutputWithPooling:\n+        \"\"\"\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, sequence_length, image_channels, patch_size, patch_size)`):\n+                The tensors corresponding to the input images.\n+            cu_seqlens (`torch.Tensor` of shape `(num_images + 1,)`):\n+                The cumulative sequence lengths of each image or video feature.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        return self.vision_model(\n+            pixel_values=pixel_values,\n+            cu_seqlens=cu_seqlens,\n+            image_grid_thw=image_grid_thw,\n+        )\n+\n+\n+class PaddleOCRVisionEmbeddings(nn.Module):\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__()\n+        self.config = config\n+        self.embed_dim = config.hidden_size\n+        self.image_size = config.image_size\n+        self.patch_size = config.patch_size\n+\n+        self.patch_embedding = nn.Conv2d(\n+            in_channels=config.num_channels,\n+            out_channels=self.embed_dim,\n+            kernel_size=self.patch_size,\n+            stride=self.patch_size,\n+            padding=\"valid\",\n+        )\n+\n+        self.num_patches = (self.image_size // self.patch_size) ** 2\n+        self.num_positions = self.num_patches\n+        self.position_embedding = nn.Embedding(self.num_positions, self.embed_dim)\n+        self.register_buffer(\"position_ids\", torch.arange(self.num_positions).expand((1, -1)), persistent=False)\n+\n+    def interpolate_pos_encoding(self, embeddings: torch.Tensor, height: int, width: int) -> torch.Tensor:\n+        \"\"\"\n+        This method allows to interpolate the pre-trained position encodings, to be able to use the model on higher resolution\n+        images. This method is also adapted to support torch.jit tracing and no class embeddings.\n+\n+        Adapted from:\n+        - https://github.com/facebookresearch/dino/blob/de9ee3df6cf39fac952ab558447af1fa1365362a/vision_transformer.py#L174-L194, and\n+        - https://github.com/facebookresearch/dinov2/blob/e1277af2ba9496fbadf7aec6eba56e8d882d1e35/dinov2/models/vision_transformer.py#L179-L211\n+        \"\"\"\n+        num_positions = self.position_embedding.weight.shape[0]\n+\n+        patch_pos_embed = self.position_embedding.weight.unsqueeze(0)\n+\n+        dim = embeddings.shape[-1]\n+\n+        sqrt_num_positions = torch_int(num_positions**0.5)\n+        patch_pos_embed = patch_pos_embed.reshape(1, sqrt_num_positions, sqrt_num_positions, dim)\n+        patch_pos_embed = patch_pos_embed.permute(0, 3, 1, 2)\n+\n+        patch_pos_embed = nn.functional.interpolate(\n+            patch_pos_embed,\n+            size=(height, width),\n+            mode=\"bilinear\",\n+            align_corners=False,\n+        )\n+\n+        patch_pos_embed = patch_pos_embed.permute(0, 2, 3, 1).view(1, -1, dim)\n+        return patch_pos_embed\n+\n+    def forward(\n+        self,\n+        pixel_values: torch.FloatTensor,\n+        image_grid_thw: Optional[list[Union[tuple[int, int, int], list[tuple[int, int, int]]]]] = None,\n+    ) -> torch.Tensor:\n+        \"\"\"\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, sequence_length, image_channels, patch_size, patch_size)`):\n+                The tensors corresponding to the input images.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        batch_size, squence_len, channel, height, width = pixel_values.shape\n+        target_dtype = self.patch_embedding.weight.dtype\n+        pixel_values = pixel_values.reshape(batch_size * squence_len, channel, height, width)\n+        patch_embeds = self.patch_embedding(pixel_values.to(dtype=target_dtype))  # shape = [*, width, grid, grid]\n+        embeddings = patch_embeds.flatten(-2).squeeze(-1)\n+        embeddings = embeddings.reshape(batch_size, squence_len, -1)\n+\n+        start = 0\n+        embeddings = embeddings.squeeze(0)\n+        tmp_embeddings = []\n+        for image_grid in image_grid_thw:\n+            t, h, w = image_grid\n+            end = start + t * h * w\n+            image_embeddings = embeddings[start:end, :]\n+            position_embedding = self.interpolate_pos_encoding(image_embeddings, h, w).squeeze(0).repeat(t, 1)\n+            image_embeddings = image_embeddings + position_embedding\n+            tmp_embeddings.append(image_embeddings)\n+            start = end\n+        embeddings = torch.concat(tmp_embeddings, dim=0)\n+\n+        return embeddings\n+\n+\n+def apply_rotary_pos_emb_vision(\n+    q: torch.Tensor, k: torch.Tensor, cos: torch.Tensor, sin: torch.Tensor\n+) -> tuple[torch.Tensor, torch.Tensor]:\n+    orig_q_dtype = q.dtype\n+    orig_k_dtype = k.dtype\n+    q, k = q.float(), k.float()\n+    cos, sin = cos.unsqueeze(-2).float(), sin.unsqueeze(-2).float()\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    q_embed = q_embed.to(orig_q_dtype)\n+    k_embed = k_embed.to(orig_k_dtype)\n+    return q_embed, k_embed\n+\n+\n+class PaddleOCRVisionAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__()\n+        self.config = config\n+        self.embed_dim = config.hidden_size\n+        self.num_heads = config.num_attention_heads\n+        self.head_dim = self.embed_dim // self.num_heads\n+        if self.head_dim * self.num_heads != self.embed_dim:\n+            raise ValueError(\n+                f\"embed_dim must be divisible by num_heads (got `embed_dim`: {self.embed_dim} and `num_heads`:\"\n+                f\" {self.num_heads}).\"\n+            )\n+        self.is_causal = False\n+\n+        self.k_proj = nn.Linear(self.embed_dim, self.embed_dim)\n+        self.v_proj = nn.Linear(self.embed_dim, self.embed_dim)\n+        self.q_proj = nn.Linear(self.embed_dim, self.embed_dim)\n+        self.out_proj = nn.Linear(self.embed_dim, self.embed_dim)\n+        self.num_key_value_groups = 1\n+        self.scaling = self.head_dim**-0.5\n+        self.attention_dropout = config.attention_dropout\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cu_seqlens: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor]]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.Tensor`):\n+                Input to the layer of shape `(seq_len, embed_dim)`.\n+            cu_seqlens (`torch.Tensor` of shape `(num_images_or_videos + 1,)`):\n+                The cumulative sequence lengths of each image or video feature.\n+            position_embeddings (`tuple(torch.Tensor, torch.Tensor)` of shape `(num_patches, head_dim // 2)`):\n+                The cosine and sine position embeddings for vision attention.\n+        \"\"\"\n+        seq_length = hidden_states.shape[0]\n+        query_states = self.q_proj(hidden_states).view(seq_length, self.num_heads, self.head_dim)\n+        key_states = self.k_proj(hidden_states).view(seq_length, self.num_heads, self.head_dim)\n+        value_states = self.v_proj(hidden_states).view(seq_length, self.num_heads, self.head_dim)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb_vision(query_states, key_states, cos, sin)\n+\n+        query_states = query_states.transpose(0, 1).unsqueeze(0)\n+        key_states = key_states.transpose(0, 1).unsqueeze(0)\n+        value_states = value_states.transpose(0, 1).unsqueeze(0)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        if self.config._attn_implementation == \"flash_attention_2\":\n+            # Flash Attention 2: Use cu_seqlens for variable length attention\n+            max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max()\n+            attn_output, attn_weights = attention_interface(\n+                self,\n+                query_states,\n+                key_states,\n+                value_states,\n+                attention_mask=None,\n+                scaling=self.scaling,\n+                dropout=0.0 if not self.training else self.attention_dropout,\n+                cu_seq_lens_q=cu_seqlens,\n+                cu_seq_lens_k=cu_seqlens,\n+                max_length_q=max_seqlen,\n+                max_length_k=max_seqlen,\n+                is_causal=False,\n+                **kwargs,\n+            )\n+        else:\n+            # Other implementations: Process each chunk separately\n+            lengths = cu_seqlens[1:] - cu_seqlens[:-1]\n+            splits = [\n+                torch.split(tensor, lengths.tolist(), dim=2) for tensor in (query_states, key_states, value_states)\n+            ]\n+\n+            attn_outputs, attn_weights = [], []\n+            for q, k, v in zip(*splits):\n+                attn_output, attn_weight = attention_interface(\n+                    self,\n+                    q,\n+                    k,\n+                    v,\n+                    attention_mask=None,\n+                    scaling=self.scaling,\n+                    dropout=0.0 if not self.training else self.attention_dropout,\n+                    is_causal=False,\n+                    **kwargs,\n+                )\n+                attn_outputs.append(attn_output)\n+                attn_weights.append(attn_weight)\n+\n+            attn_output = torch.cat(attn_outputs, dim=1)\n+\n+        attn_output = attn_output.reshape(seq_length, -1).contiguous()\n+        attn_output = self.out_proj(attn_output)\n+\n+        return attn_output, attn_weights\n+\n+\n+class PaddleOCRVisionMLP(nn.Module):\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__()\n+        self.config = config\n+        self.activation_fn = ACT2FN[config.hidden_act]\n+        self.fc1 = nn.Linear(config.hidden_size, config.intermediate_size)\n+        self.fc2 = nn.Linear(config.intermediate_size, config.hidden_size)\n+\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        hidden_states = self.fc1(hidden_states)\n+        hidden_states = self.activation_fn(hidden_states)\n+        hidden_states = self.fc2(hidden_states)\n+        return hidden_states\n+\n+\n+class PaddleOCRVisionEncoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__()\n+        self.embed_dim = config.hidden_size\n+        self.layer_norm1 = nn.LayerNorm(self.embed_dim, eps=config.layer_norm_eps)\n+        self.self_attn = PaddleOCRVisionAttention(config=config)\n+        self.layer_norm2 = nn.LayerNorm(self.embed_dim, eps=config.layer_norm_eps)\n+        self.mlp = PaddleOCRVisionMLP(config=config)\n+\n+    @auto_docstring\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cu_seqlens: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> torch.Tensor:\n+        r\"\"\"\n+        cu_seqlens (`torch.Tensor` of shape `(num_images_or_videos + 1,)`):\n+            The cumulative sequence lengths of each image or video feature.\n+        position_embeddings (`tuple(torch.Tensor, torch.Tensor)` of shape `(num_patches, head_dim // 2)`):\n+            The cosine and sine position embeddings for vision attention.\n+        \"\"\"\n+        residual = hidden_states\n+\n+        hidden_states = self.layer_norm1(hidden_states)\n+        hidden_states, _ = self.self_attn(\n+            hidden_states,\n+            cu_seqlens=cu_seqlens,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        residual = hidden_states\n+        hidden_states = self.layer_norm2(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        return hidden_states\n+\n+\n+class PaddleOCRVisionEncoder(nn.Module):\n+    \"\"\"\n+    Transformer encoder consisting of `config.num_hidden_layers` self attention layers. Each layer is a\n+    [`PaddleOCRVisionEncoderLayer`].\n+\n+    Args:\n+        config: PaddleOCRVisionConfig\n+    \"\"\"\n+\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__()\n+        self.config = config\n+        self.layers = nn.ModuleList([PaddleOCRVisionEncoderLayer(config) for _ in range(config.num_hidden_layers)])\n+        self.gradient_checkpointing = False\n+        embed_dim = config.hidden_size\n+        num_heads = config.num_attention_heads\n+        head_dim = embed_dim // num_heads\n+        self.rotary_pos_emb = PaddleOCRVisionRotaryEmbedding(head_dim // 2)\n+\n+    # Ignore copy\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        inputs_embeds: torch.FloatTensor,\n+        cu_seqlens: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        image_grid_thw: Optional[list[Union[tuple[int, int, int], list[tuple[int, int, int]]]]] = None,\n+    ) -> BaseModelOutput:\n+        \"\"\"\n+        Args:\n+            inputs_embeds (`torch.FloatTensor` of shape `(sequence_length, hidden_size)`, *optional*):\n+                Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation.\n+                This is useful if you want more control over how to convert `input_ids` indices into associated vectors\n+                than the model's internal embedding lookup matrix.\n+            cu_seqlens (`torch.Tensor` of shape `(num_images + 1,)`):\n+                The cumulative sequence lengths of each image or video feature.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                The attention_mask used in forward function shape [batch_size X sequence_length] if not None.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        device = inputs_embeds.device\n+        hidden_states = inputs_embeds\n+        attention_mask = create_bidirectional_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+        )\n+        split_hids = []\n+        split_wids = []\n+        for t, h, w in image_grid_thw:\n+            image_pids = torch.arange(t * h * w, device=device) % (h * w)\n+            sample_hids = image_pids // w\n+            sample_wids = image_pids % w\n+            split_hids.append(sample_hids)\n+            split_wids.append(sample_wids)\n+        width_position_ids = torch.concat(split_wids, dim=0)\n+        height_position_ids = torch.concat(split_hids, dim=0)\n+\n+        pids = torch.stack([height_position_ids, width_position_ids], dim=-1)\n+        max_grid_size = pids.max() + 1\n+        rotary_embeddings_max_grid = self.rotary_pos_emb(max_grid_size)\n+        rotary_embeddings = rotary_embeddings_max_grid[pids].flatten(1)\n+        rotary_embeddings = rotary_embeddings.repeat(1, 2)\n+        position_embeddings = (rotary_embeddings.cos(), rotary_embeddings.sin())\n+\n+        for encoder_layer in self.layers:\n+            hidden_states = encoder_layer(\n+                hidden_states,\n+                cu_seqlens=cu_seqlens,\n+                position_embeddings=position_embeddings,\n+            )\n+\n+        return BaseModelOutput(\n+            last_hidden_state=hidden_states,\n+        )\n+\n+\n+class PaddleOCRVisionTransformer(PaddleOCRVLPreTrainedModel):\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__(config)\n+        self.config = config\n+        embed_dim = config.hidden_size\n+\n+        self.embeddings = PaddleOCRVisionEmbeddings(config)\n+        self.encoder = PaddleOCRVisionEncoder(config)\n+        self.post_layernorm = nn.LayerNorm(embed_dim, eps=config.layer_norm_eps)\n+\n+    def forward(\n+        self,\n+        pixel_values: torch.FloatTensor,\n+        cu_seqlens: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        image_grid_thw: Optional[list[Union[tuple[int, int, int], list[tuple[int, int, int]]]]] = None,\n+        **kwargs,\n+    ) -> BaseModelOutputWithPooling:\n+        \"\"\"\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, sequence_length, patch_size * patch_size * image_channels)`):\n+                The tensors corresponding to the input images.\n+            cu_seqlens (`torch.Tensor` of shape `(num_images + 1,)`):\n+                The cumulative sequence lengths of each image or video feature.\n+            attention_mask (`torch.Tensor`, *optional*):\n+                The attention_mask used in forward function shape [batch_size X sequence_length] if not None.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        hidden_states = self.embeddings(pixel_values, image_grid_thw=image_grid_thw)\n+\n+        encoder_outputs: BaseModelOutput = self.encoder(\n+            inputs_embeds=hidden_states,\n+            cu_seqlens=cu_seqlens,\n+            attention_mask=attention_mask,\n+            image_grid_thw=image_grid_thw,\n+        )\n+\n+        last_hidden_state = encoder_outputs.last_hidden_state\n+        last_hidden_state = self.post_layernorm(last_hidden_state)\n+\n+        return BaseModelOutputWithPooling(\n+            last_hidden_state=last_hidden_state,\n+            pooler_output=None,\n+            hidden_states=encoder_outputs.hidden_states,\n+            attentions=encoder_outputs.attentions,\n+        )\n+\n+\n+@dataclass\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    Base class for Llava outputs, with hidden states and attentions.\n+    \"\"\"\n+)\n+class PaddleOCRVLModelOutputWithPast(ModelOutput):\n+    r\"\"\"\n+    past_key_values (`Cache`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+        It is a [`~cache_utils.Cache`] instance. For more details, see our [kv cache guide](https://huggingface.co/docs/transformers/en/kv_cache).\n+\n+        Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+        `past_key_values` input) to speed up sequential decoding.\n+    rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+        The rope index difference between sequence length and multimodal rope.\n+    \"\"\"\n+\n+    last_hidden_state: Optional[torch.FloatTensor] = None\n+    past_key_values: Optional[Cache] = None\n+    hidden_states: Optional[tuple[torch.FloatTensor]] = None\n+    attentions: Optional[tuple[torch.FloatTensor]] = None\n+    rope_deltas: Optional[torch.LongTensor] = None\n+\n+\n+@dataclass\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    Base class for PaddleOCRVL causal language model (or autoregressive) outputs.\n+    \"\"\"\n+)\n+class PaddleOCRVLCausalLMOutputWithPast(ModelOutput):\n+    r\"\"\"\n+    loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+        Language modeling loss (for next-token prediction).\n+    logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n+        Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+    past_key_values (`Cache`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+        It is a [`~cache_utils.Cache`] instance. For more details, see our [kv cache guide](https://huggingface.co/docs/transformers/en/kv_cache).\n+\n+        Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+        `past_key_values` input) to speed up sequential decoding.\n+    rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+        The rope index difference between sequence length and multimodal rope.\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: Optional[torch.FloatTensor] = None\n+    past_key_values: Optional[Cache] = None\n+    hidden_states: Optional[tuple[torch.FloatTensor]] = None\n+    attentions: Optional[tuple[torch.FloatTensor]] = None\n+    rope_deltas: Optional[torch.LongTensor] = None\n+\n+\n+@auto_docstring\n+class PaddleOCRVLModel(PaddleOCRVLPreTrainedModel):\n+    base_model_prefix = \"model\"\n+    _checkpoint_conversion_mapping = {\"^model\": \"language_model\"}\n+    # Reference: fix gemma3 grad acc #37208\n+    accepts_loss_kwargs = False\n+    _keys_to_ignore_on_load_unexpected = [\"packing_position_embedding\", \"vision_model.head\"]\n+\n+    def __init__(self, config: PaddleOCRVLConfig):\n+        super().__init__(config)\n+        self.visual = PaddleOCRVisionModel._from_config(config.vision_config)\n+        self.language_model = PaddleOCRTextModel._from_config(config.text_config)\n+        self.rope_deltas = None\n+        self.projector = PaddleOCRProjector(config)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.language_model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.language_model.embed_tokens = value\n+\n+    def get_rope_index(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Calculate the 3D rope index based on image and video's temporal, height and width in LLM.\n+\n+        Explanation:\n+            Each embedding sequence contains vision embedding and text embedding or just contains text embedding.\n+\n+            For pure text embedding sequence, the rotary position embedding has no difference with modern LLMs.\n+            Examples:\n+                input_ids: [T T T T T], here T is for text.\n+                temporal position_ids: [0, 1, 2, 3, 4]\n+                height position_ids: [0, 1, 2, 3, 4]\n+                width position_ids: [0, 1, 2, 3, 4]\n+\n+            For vision and text embedding sequence, we calculate 3D rotary position embedding for vision part\n+            and 1D rotary position embedding for text part.\n+            Examples:\n+                Assume we have a video input with 3 temporal patches, 2 height patches and 2 width patches.\n+                input_ids: [V V V V V V V V V V V V T T T T T], here V is for vision.\n+                vision temporal position_ids: [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2]\n+                vision height position_ids: [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]\n+                vision width position_ids: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n+                text temporal position_ids: [3, 4, 5, 6, 7]\n+                text height position_ids: [3, 4, 5, 6, 7]\n+                text width position_ids: [3, 4, 5, 6, 7]\n+                Here we calculate the text start position_ids as the max vision position_ids plus 1.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+                it.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+\n+        Returns:\n+            position_ids (`torch.LongTensor` of shape `(3, batch_size, sequence_length)`)\n+            mrope_position_deltas (`torch.Tensor` of shape `(batch_size)`)\n+        \"\"\"\n+        spatial_merge_size = self.config.vision_config.spatial_merge_size\n+        image_token_id = self.config.image_token_id\n+        video_token_id = self.config.video_token_id\n+        vision_start_token_id = self.config.vision_start_token_id\n+        mrope_position_deltas = []\n+        if input_ids is not None and (image_grid_thw is not None or video_grid_thw is not None):\n+            total_input_ids = input_ids\n+            if attention_mask is None:\n+                attention_mask = torch.ones_like(total_input_ids)\n+            position_ids = torch.ones(\n+                3, input_ids.shape[0], input_ids.shape[1], dtype=input_ids.dtype, device=input_ids.device\n+            )\n+            image_index, video_index = 0, 0\n+            for i, input_ids in enumerate(total_input_ids):\n+                input_ids = input_ids[attention_mask[i].to(input_ids.device) == 1]\n+                image_nums, video_nums = 0, 0\n+                vision_start_indices = torch.argwhere(input_ids == vision_start_token_id).squeeze(1)\n+                vision_tokens = input_ids[vision_start_indices + 1]\n+                image_nums = (vision_tokens == image_token_id).sum()\n+                video_nums = (vision_tokens == video_token_id).sum()\n+                input_tokens = input_ids.tolist()\n+                llm_pos_ids_list: list = []\n+                st = 0\n+                remain_images, remain_videos = image_nums, video_nums\n+                for _ in range(image_nums + video_nums):\n+                    if image_token_id in input_tokens and remain_images > 0:\n+                        ed_image = input_tokens.index(image_token_id, st)\n+                    else:\n+                        ed_image = len(input_tokens) + 1\n+                    if video_token_id in input_tokens and remain_videos > 0:\n+                        ed_video = input_tokens.index(video_token_id, st)\n+                    else:\n+                        ed_video = len(input_tokens) + 1\n+                    if ed_image < ed_video:\n+                        t, h, w = (\n+                            image_grid_thw[image_index][0],\n+                            image_grid_thw[image_index][1],\n+                            image_grid_thw[image_index][2],\n+                        )\n+                        image_index += 1\n+                        remain_images -= 1\n+                        ed = ed_image\n+                    else:\n+                        t, h, w = (\n+                            video_grid_thw[video_index][0],\n+                            video_grid_thw[video_index][1],\n+                            video_grid_thw[video_index][2],\n+                        )\n+                        video_index += 1\n+                        remain_videos -= 1\n+                        ed = ed_video\n+                    llm_grid_t, llm_grid_h, llm_grid_w = (\n+                        t.item(),\n+                        h.item() // spatial_merge_size,\n+                        w.item() // spatial_merge_size,\n+                    )\n+                    text_len = ed - st\n+\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+                    llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                    t_index = torch.arange(llm_grid_t).view(-1, 1).expand(-1, llm_grid_h * llm_grid_w).flatten()\n+                    h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(llm_grid_t, -1, llm_grid_w).flatten()\n+                    w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(llm_grid_t, llm_grid_h, -1).flatten()\n+                    llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + text_len + st_idx)\n+                    st = ed + llm_grid_t * llm_grid_h * llm_grid_w\n+\n+                if st < len(input_tokens):\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+                    text_len = len(input_tokens) - st\n+                    llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                llm_positions = torch.cat(llm_pos_ids_list, dim=1).reshape(3, -1)\n+                position_ids[..., i, attention_mask[i] == 1] = llm_positions.to(position_ids.device)\n+                mrope_position_deltas.append(llm_positions.max() + 1 - len(total_input_ids[i]))\n+            mrope_position_deltas = torch.tensor(mrope_position_deltas, device=input_ids.device).unsqueeze(1)\n+            return position_ids, mrope_position_deltas\n+        else:\n+            if attention_mask is not None:\n+                position_ids = attention_mask.long().cumsum(-1) - 1\n+                position_ids.masked_fill_(attention_mask == 0, 1)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1).to(attention_mask.device)\n+                max_position_ids = position_ids.max(0, keepdim=False)[0].max(-1, keepdim=True)[0]\n+                mrope_position_deltas = max_position_ids + 1 - attention_mask.shape[-1]\n+            else:\n+                position_ids = (\n+                    torch.arange(input_ids.shape[1], device=input_ids.device)\n+                    .view(1, 1, -1)\n+                    .expand(3, input_ids.shape[0], -1)\n+                )\n+                mrope_position_deltas = torch.zeros(\n+                    [input_ids.shape[0], 1],\n+                    device=input_ids.device,\n+                    dtype=input_ids.dtype,\n+                )\n+\n+            return position_ids, mrope_position_deltas\n+\n+    def get_video_features(\n+        self, pixel_values_videos: torch.FloatTensor, video_grid_thw: Optional[torch.LongTensor] = None\n+    ):\n+        \"\"\"\n+        Encodes videos into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values_videos (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input videos.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+        \"\"\"\n+        pixel_values_videos = pixel_values_videos.type(self.visual.dtype)\n+        video_embeds = self.visual(pixel_values_videos, grid_thw=video_grid_thw)\n+        split_sizes = (video_grid_thw.prod(-1) // self.visual.spatial_merge_size**2).tolist()\n+        video_embeds = torch.split(video_embeds, split_sizes)\n+        return video_embeds\n+\n+    def get_image_features(self, pixel_values: torch.FloatTensor, image_grid_thw: Optional[torch.LongTensor] = None):\n+        \"\"\"\n+        Encodes images into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input images.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        pixel_values = pixel_values.type(self.visual.dtype).unsqueeze(0)\n+        cu_seqlens = torch.repeat_interleave(image_grid_thw[:, 1] * image_grid_thw[:, 2], image_grid_thw[:, 0]).cumsum(\n+            dim=0,\n+            # Select dtype based on the following factors:\n+            #  - FA2 requires that cu_seqlens_q must have dtype int32\n+            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n+            # See https://github.com/huggingface/transformers/pull/34852 for more information\n+            dtype=image_grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_seqlens = torch.nn.functional.pad(cu_seqlens, (1, 0), value=0)\n+        vision_outputs = self.visual(\n+            pixel_values=pixel_values,\n+            image_grid_thw=image_grid_thw,\n+            cu_seqlens=cu_seqlens,\n+        )\n+        image_embeds = vision_outputs.last_hidden_state\n+        image_embeds = self.projector(image_embeds, image_grid_thw)\n+        return image_embeds\n+\n+    def get_placeholder_mask(\n+        self, input_ids: torch.LongTensor, inputs_embeds: torch.FloatTensor, image_features: torch.FloatTensor\n+    ):\n+        \"\"\"\n+        Obtains multimodal placeholder mask from `input_ids` or `inputs_embeds`, and checks that the placeholder token count is\n+        equal to the length of multimodal features. If the lengths are different, an error is raised.\n+        \"\"\"\n+        if input_ids is None:\n+            special_image_mask = inputs_embeds == self.get_input_embeddings()(\n+                torch.tensor(self.config.image_token_id, dtype=torch.long, device=inputs_embeds.device)\n+            )\n+            special_image_mask = special_image_mask.all(-1)\n+        else:\n+            special_image_mask = input_ids == self.config.image_token_id\n+\n+        n_image_tokens = special_image_mask.sum()\n+        special_image_mask = special_image_mask.unsqueeze(-1).expand_as(inputs_embeds).to(inputs_embeds.device)\n+        n_image_features = image_features.shape[0] * image_features.shape[1]\n+        if inputs_embeds[special_image_mask].numel() != image_features.numel():\n+            raise ValueError(\n+                f\"Image features and image tokens do not match: tokens: {n_image_tokens}, features {n_image_features}\"\n+            )\n+        return special_image_mask\n+\n+    @can_return_tuple\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> Union[tuple, PaddleOCRVLModelOutputWithPast]:\n+        r\"\"\"\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+        \"\"\"\n+        if inputs_embeds is None:\n+            inputs_embeds = self.language_model.embed_tokens(input_ids)\n+\n+        if pixel_values is not None:\n+            image_embeds = self.get_image_features(pixel_values, image_grid_thw).to(\n+                inputs_embeds.device, inputs_embeds.dtype\n+            )\n+            image_mask = self.get_placeholder_mask(input_ids, inputs_embeds=inputs_embeds, image_features=image_embeds)\n+            inputs_embeds = inputs_embeds.masked_scatter(image_mask, image_embeds)\n+\n+        if position_ids is None:\n+            past_key_values_length = 0 if past_key_values is None else past_key_values.get_seq_length()\n+            if self.rope_deltas is None or past_key_values_length == 0:\n+                position_ids, rope_deltas = self.get_rope_index(\n+                    input_ids=input_ids,\n+                    image_grid_thw=image_grid_thw,\n+                    attention_mask=attention_mask,\n+                )\n+                self.rope_deltas = rope_deltas\n+            # then use the prev pre-calculated rope-deltas to get the correct position ids\n+            else:\n+                batch_size, seq_length, _ = inputs_embeds.shape\n+                position_ids = torch.arange(seq_length, device=inputs_embeds.device)\n+                position_ids = position_ids.view(1, 1, -1).expand(3, batch_size, -1)\n+                delta = (past_key_values_length + self.rope_deltas).to(inputs_embeds.device)\n+                delta = delta.repeat_interleave(batch_size // delta.shape[0], dim=0)\n+                position_ids = position_ids + delta.to(position_ids.device)\n+\n+        outputs = self.language_model(\n+            input_ids=None,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        output = PaddleOCRVLModelOutputWithPast(\n+            last_hidden_state=outputs.last_hidden_state,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=self.rope_deltas,\n+        )\n+\n+        return output\n+\n+\n+class PaddleOCRVLForConditionalGeneration(PaddleOCRVLPreTrainedModel, GenerationMixin):\n+    _checkpoint_conversion_mapping = {\n+        \"^visual\": \"model.visual\",\n+        \"^mlp_AR\": \"model.projector\",\n+        r\"^model(?!(\\.visual|\\.projector|\\.language_model))\": \"model.language_model\",\n+    }\n+    _tied_weights_keys = {\"lm_head.weight\": \"model.language_model.embed_tokens.weight\"}\n+    _keys_to_ignore_on_load_unexpected = [\"packing_position_embedding\", \"vision_model.head\"]\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = PaddleOCRVLModel(config)\n+        self.lm_head = nn.Linear(config.text_config.hidden_size, config.text_config.vocab_size, bias=False)\n+\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.model.set_input_embeddings(value)\n+\n+    def get_video_features(\n+        self, pixel_values_videos: torch.FloatTensor, video_grid_thw: Optional[torch.LongTensor] = None\n+    ):\n+        return self.model.get_video_features(pixel_values_videos, video_grid_thw)\n+\n+    def get_image_features(self, pixel_values: torch.FloatTensor, image_grid_thw: Optional[torch.LongTensor] = None):\n+        return self.model.get_image_features(pixel_values, image_grid_thw)\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, PaddleOCRVLCausalLMOutputWithPast]:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoProcessor, PaddleOCRVLForConditionalGeneration\n+\n+        >>> model = PaddleOCRVLForConditionalGeneration.from_pretrained(\"PaddlePaddle/PaddleOCR-VL\", dtype=\"bfloat16\")\n+        >>> processor = AutoProcessor.from_pretrained(\"PaddlePaddle/PaddleOCR-VL\")\n+\n+        >>> messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"image\",\n+                        \"image\": \"https://paddle-model-ecology.bj.bcebos.com/paddlex/imgs/demo_image/ocr_demo.jpg\",\n+                    },\n+                    {\"type\": \"text\", \"text\": \"OCR:\"},\n+                ],\n+            }\n+        ]\n+\n+        >>> inputs = processor.apply_chat_template(\n+            messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\"\n+        ).to(model.device)\n+\n+        >>> # Generate\n+        >>> generated_ids = model.generate(**inputs, max_new_tokens=1024)\n+        >>> generated_ids_trimmed = [out_ids[len(in_ids) :] for in_ids, out_ids in zip(inputs.input_ids, generated_ids)]\n+        >>> output_text = processor.batch_decode(generated_ids_trimmed, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        >>> print(output_text)\n+        ```\n+        \"\"\"\n+        outputs: PaddleOCRVLModelOutputWithPast = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            image_grid_thw=image_grid_thw,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            pixel_values=pixel_values,\n+            rope_deltas=rope_deltas,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = outputs.last_hidden_state\n+\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(\n+                logits=logits, labels=labels, vocab_size=self.config.text_config.vocab_size, **kwargs\n+            )\n+\n+        return PaddleOCRVLCausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=outputs.rope_deltas,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        attention_mask=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        position_ids=None,\n+        use_cache=True,\n+        pixel_values=None,\n+        pixel_values_videos=None,\n+        image_grid_thw=None,\n+        video_grid_thw=None,\n+        **kwargs,\n+    ):\n+        # Overwritten -- in specific circumstances we don't want to forward image inputs to the model\n+\n+        model_inputs = super().prepare_inputs_for_generation(\n+            input_ids,\n+            past_key_values=past_key_values,\n+            attention_mask=attention_mask,\n+            inputs_embeds=inputs_embeds,\n+            cache_position=cache_position,\n+            position_ids=position_ids,\n+            pixel_values=pixel_values,\n+            pixel_values_videos=pixel_values_videos,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            use_cache=use_cache,\n+            **kwargs,\n+        )\n+\n+        # Qwen2-VL position_ids are prepareed with rope_deltas in forward\n+        if position_ids is None:\n+            # Calculate RoPE index once per generation in the pre-fill stage only.\n+            # When compiling, we can't check tensor values thus we check only input length\n+            # It is safe to assume that `length!=1` means we're in pre-fill because compiled\n+            # models currently cannot do asssisted decoding\n+            if model_inputs[\"cache_position\"][0] == 0 or self.model.rope_deltas is None:\n+                vision_positions, rope_deltas = self.model.get_rope_index(\n+                    model_inputs.get(\"input_ids\", None),\n+                    image_grid_thw=image_grid_thw,\n+                    video_grid_thw=video_grid_thw,\n+                    attention_mask=attention_mask,\n+                )\n+                self.model.rope_deltas = rope_deltas\n+            # then use the prev pre-calculated rope-deltas to get the correct position ids\n+            elif \"position_ids\" in model_inputs:\n+                batch_size, seq_length = model_inputs[\"position_ids\"].shape\n+                device = model_inputs[\"position_ids\"].device\n+                position_ids = torch.arange(seq_length, device=device)\n+                position_ids = position_ids.view(1, 1, -1).expand(3, batch_size, -1)\n+                delta = cache_position[0] + self.model.rope_deltas\n+                delta = delta.repeat_interleave(batch_size // delta.shape[0], dim=0)\n+                vision_positions = position_ids + delta.expand_as(position_ids)\n+\n+            # Concatenate \"text + vision\" positions into [4, bs, seq-len]\n+            text_positions = model_inputs[\"position_ids\"][None, ...]\n+            model_inputs[\"position_ids\"] = torch.cat([text_positions, vision_positions], dim=0)\n+\n+        if model_inputs[\"cache_position\"][0] != 0:\n+            model_inputs[\"pixel_values\"] = None\n+            model_inputs[\"pixel_values_videos\"] = None\n+\n+        return model_inputs\n+\n+    def _get_image_nums_and_video_nums(\n+        self,\n+        input_ids: Optional[torch.LongTensor],\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Get the number of images and videos for each sample to calculate the separation length of the sample tensor.\n+        These parameters are not passed through the processor to avoid unpredictable impacts from interface modifications.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary.\n+\n+        Returns:\n+            image_nums (`torch.LongTensor` of shape `(batch_size, num_images_sample)`)\n+            video_nums (`torch.LongTensor` of shape `(batch_size, num_videos_sample)`)\n+        \"\"\"\n+        image_token_id = self.config.image_token_id\n+        video_token_id = self.config.video_token_id\n+        vision_start_token_id = self.config.vision_start_token_id\n+\n+        if inputs_embeds is not None:\n+            vision_start_mask = (\n+                inputs_embeds\n+                == self.get_input_embeddings()(\n+                    torch.tensor(vision_start_token_id, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            )[..., 0]\n+            image_mask = (\n+                inputs_embeds\n+                == self.get_input_embeddings()(\n+                    torch.tensor(image_token_id, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            )[..., 0]\n+            video_mask = (\n+                inputs_embeds\n+                == self.get_input_embeddings()(\n+                    torch.tensor(video_token_id, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            )[..., 0]\n+        else:\n+            vision_start_mask = input_ids == vision_start_token_id\n+            image_mask = input_ids == image_token_id\n+            video_mask = input_ids == video_token_id\n+\n+        vision_first_mask = torch.roll(vision_start_mask, shifts=1, dims=1)\n+        image_nums = torch.sum(vision_first_mask & image_mask, dim=1)\n+        video_nums = torch.sum(vision_first_mask & video_mask, dim=1)\n+\n+        return image_nums, video_nums\n+\n+    def _expand_inputs_for_generation(\n+        self,\n+        expand_size: int = 1,\n+        is_encoder_decoder: bool = False,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        **model_kwargs,\n+    ) -> tuple[torch.LongTensor, dict[str, Any]]:\n+        # Overwritten -- Support for expanding tensors without a batch size dimension\n+        # e.g., pixel_values, image_grid_thw, pixel_values_videos, video_grid_thw, second_per_grid_t\n+        # pixel_values.shape[0] is sum(seqlen_images for samples)\n+        # image_grid_thw.shape[0] is sum(num_images for samples)\n+\n+        if expand_size == 1:\n+            return input_ids, model_kwargs\n+\n+        visual_keys = [\"pixel_values\", \"image_grid_thw\", \"pixel_values_videos\", \"video_grid_thw\", \"second_per_grid_ts\"]\n+\n+        def _expand_dict_for_generation_visual(dict_to_expand):\n+            image_grid_thw = model_kwargs.get(\"image_grid_thw\", None)\n+            video_grid_thw = model_kwargs.get(\"video_grid_thw\", None)\n+            image_nums, video_nums = self._get_image_nums_and_video_nums(\n+                input_ids, inputs_embeds=model_kwargs.get(\"inputs_embeds\", None)\n+            )\n+\n+            def _repeat_interleave_samples(x, lengths, repeat_times):\n+                samples = torch.split(x, lengths)\n+                repeat_args = [repeat_times] + [1] * (x.dim() - 1)\n+                result = torch.cat([sample.repeat(*repeat_args) for sample in samples], dim=0)\n+                return result\n+\n+            for key in dict_to_expand:\n+                if key == \"pixel_values\":\n+                    # split images into samples\n+                    samples = torch.split(image_grid_thw, list(image_nums))\n+                    # compute the sequence length of images for each sample\n+                    lengths = [torch.prod(sample, dim=1).sum() for sample in samples]\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"image_grid_thw\":\n+                    # get the num of images for each sample\n+                    lengths = list(image_nums)\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"pixel_values_videos\":\n+                    samples = torch.split(video_grid_thw, list(video_nums))\n+                    lengths = [torch.prod(sample, dim=1).sum() for sample in samples]\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"video_grid_thw\":\n+                    lengths = list(video_nums)\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"second_per_grid_ts\":\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=list(video_nums), repeat_times=expand_size\n+                    )\n+            return dict_to_expand\n+\n+        def _expand_dict_for_generation(dict_to_expand):\n+            for key in dict_to_expand:\n+                if (\n+                    key != \"cache_position\"\n+                    and dict_to_expand[key] is not None\n+                    and isinstance(dict_to_expand[key], torch.Tensor)\n+                    and key not in visual_keys\n+                ):\n+                    dict_to_expand[key] = dict_to_expand[key].repeat_interleave(expand_size, dim=0)\n+            return dict_to_expand\n+\n+        model_kwargs = _expand_dict_for_generation_visual(model_kwargs)\n+\n+        if input_ids is not None:\n+            input_ids = input_ids.repeat_interleave(expand_size, dim=0)\n+\n+        model_kwargs = _expand_dict_for_generation(model_kwargs)\n+\n+        if is_encoder_decoder:\n+            if model_kwargs.get(\"encoder_outputs\") is None:\n+                raise ValueError(\"If `is_encoder_decoder` is True, make sure that `encoder_outputs` is defined.\")\n+            model_kwargs[\"encoder_outputs\"] = _expand_dict_for_generation(model_kwargs[\"encoder_outputs\"])\n+\n+        return input_ids, model_kwargs\n+\n+\n+__all__ = [\n+    \"PaddleOCRVLForConditionalGeneration\",\n+    \"PaddleOCRVLModel\",\n+    \"PaddleOCRVLPreTrainedModel\",\n+    \"PaddleOCRVisionTransformer\",\n+    \"PaddleOCRTextModel\",\n+    \"PaddleOCRVisionModel\",\n+]"
        },
        {
            "sha": "79e6fc45d8bf5326cf8c0a5a7f4874bc07ed3aa4",
            "filename": "src/transformers/models/paddleocr_vl/modular_paddleocr_vl.py",
            "status": "added",
            "additions": 1349,
            "deletions": 0,
            "changes": 1349,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fmodular_paddleocr_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fmodular_paddleocr_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fmodular_paddleocr_vl.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -0,0 +1,1349 @@\n+# Copyright 2025 The PaddlePaddle Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import math\n+from typing import Optional, Union\n+\n+import numpy as np\n+import torch\n+import torch.nn.functional as F\n+from torch import nn\n+\n+from ...activations import GELUActivation\n+from ...cache_utils import Cache, DynamicCache\n+from ...image_processing_utils import BatchFeature\n+from ...image_processing_utils_fast import BaseImageProcessorFast, group_images_by_shape, reorder_images\n+from ...image_transforms import convert_to_rgb, resize, to_channel_dimension_format\n+from ...image_utils import (\n+    OPENAI_CLIP_MEAN,\n+    OPENAI_CLIP_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    SizeDict,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    is_scaled_image,\n+    make_list_of_images,\n+    to_numpy_array,\n+)\n+from ...masking_utils import create_bidirectional_mask, create_causal_mask\n+from ...modeling_outputs import BaseModelOutput, BaseModelOutputWithPast, BaseModelOutputWithPooling\n+from ...modeling_utils import PreTrainedModel\n+from ...models.qwen2_vl.image_processing_qwen2_vl import Qwen2VLImageProcessor\n+from ...processing_utils import (\n+    ProcessingKwargs,\n+    ProcessorMixin,\n+    Unpack,\n+)\n+from ...tokenization_utils_base import PreTokenizedInput, TextInput\n+from ...utils import TensorType, TransformersKwargs, auto_docstring, can_return_tuple, logging, torch_int\n+from ...utils.generic import check_model_inputs\n+from ..ernie4_5.configuration_ernie4_5 import Ernie4_5Config\n+from ..ernie4_5.modeling_ernie4_5 import (\n+    Ernie4_5DecoderLayer,\n+    Ernie4_5MLP,\n+    Ernie4_5Model,\n+    Ernie4_5RMSNorm,\n+)\n+from ..qwen2_5_omni.modeling_qwen2_5_omni import (\n+    Qwen2_5OmniAttention,\n+)\n+from ..qwen2_vl.configuration_qwen2_vl import Qwen2VLConfig\n+from ..qwen2_vl.modeling_qwen2_vl import (\n+    Qwen2VLCausalLMOutputWithPast,\n+    Qwen2VLForConditionalGeneration,\n+    Qwen2VLModel,\n+    Qwen2VLModelOutputWithPast,\n+    Qwen2VLRotaryEmbedding,\n+    VisionRotaryEmbedding,\n+)\n+from ..siglip.configuration_siglip import SiglipVisionConfig\n+from ..siglip.modeling_siglip import (\n+    SiglipMLP,\n+    SiglipVisionEmbeddings,\n+)\n+from ..video_llama_3.modeling_video_llama_3 import (\n+    VideoLlama3VisionAttention,\n+    VideoLlama3VisionEncoder,\n+    VideoLlama3VisionEncoderLayer,\n+)\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+def smart_resize(\n+    height: int,\n+    width: int,\n+    factor: int = 28,\n+    min_pixels: int = 384 * 384,\n+    max_pixels: int = 1536 * 1536,\n+):\n+    if height < factor:\n+        width = round((width * factor) / height)\n+        height = factor\n+\n+    if width < factor:\n+        height = round((height * factor) / width)\n+        width = factor\n+\n+    if max(height, width) / min(height, width) > 200:\n+        raise ValueError(\n+            f\"absolute aspect ratio must be smaller than 200, got {max(height, width) / min(height, width)}\"\n+        )\n+    h_bar = round(height / factor) * factor\n+    w_bar = round(width / factor) * factor\n+    if h_bar * w_bar > max_pixels:\n+        beta = math.sqrt((height * width) / max_pixels)\n+        h_bar = math.floor(height / beta / factor) * factor\n+        w_bar = math.floor(width / beta / factor) * factor\n+    elif h_bar * w_bar < min_pixels:\n+        beta = math.sqrt(min_pixels / (height * width))\n+        h_bar = math.ceil(height * beta / factor) * factor\n+        w_bar = math.ceil(width * beta / factor) * factor\n+    return h_bar, w_bar\n+\n+\n+class PaddleOCRVLImageProcessor(Qwen2VLImageProcessor):\n+    r\"\"\"\n+    Constructs a PaddleOCRVL image processor that dynamically resizes images based on the original images.\n+\n+    Args:\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image's (height, width) dimensions.\n+        size (`dict[str, int]`, *optional*):\n+            Size of the image after resizing. `shortest_edge` and `longest_edge` keys must be present.\n+        resample (`PILImageResampling`, *optional*, defaults to `Resampling.BICUBIC`):\n+            Resampling filter to use when resizing the image.\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image by the specified scale `rescale_factor`.\n+        rescale_factor (`int` or `float`, *optional*, defaults to `1/255`):\n+            Scale factor to use if rescaling the image.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image.\n+        image_mean (`float` or `list[float]`, *optional*):\n+            Mean to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        image_std (`float` or `list[float]`, *optional*):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB.\n+        min_pixels (`int`, *optional*, defaults to `384 * 384`):\n+            The min pixels of the image to resize the image.\n+        max_pixels (`int`, *optional*, defaults to `1536 * 1536`):\n+            The max pixels of the image to resize the image.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spatial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*, defaults to 1):\n+            The temporal patch size of the vision encoder.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    model_input_names = [\n+        \"pixel_values\",\n+        \"image_grid_thw\",\n+    ]\n+\n+    def __init__(\n+        self,\n+        do_resize: bool = True,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = PILImageResampling.BICUBIC,\n+        do_rescale: bool = True,\n+        rescale_factor: Union[int, float] = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        do_convert_rgb: bool = True,\n+        min_pixels: int = 384 * 384,\n+        max_pixels: int = 1536 * 1536,\n+        patch_size: int = 14,\n+        temporal_patch_size: int = 1,\n+        merge_size: int = 2,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__()\n+\n+    def _preprocess(\n+        self,\n+        images: ImageInput,\n+        do_resize: Optional[bool] = None,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = None,\n+        do_rescale: Optional[bool] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        do_convert_rgb: Optional[bool] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n+        Args:\n+            images (`ImageInput`):\n+                Image or batch of images to preprocess. Expects pixel values ranging from 0 to 255. If pixel values range from 0 to 1, set `do_rescale=False`.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. `shortest_edge` and `longest_edge` keys must be present.\n+            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the `PILImageResampling` enums.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Scale factor to use if rescaling the image.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Mean to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Standard deviation to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            patch_size (`int`, *optional*, defaults to `self.patch_size`):\n+                The spatial patch size of the vision encoder.\n+            temporal_patch_size (`int`, *optional*, defaults to `self.temporal_patch_size`):\n+                The temporal patch size of the vision encoder.\n+            merge_size (`int`, *optional*, defaults to `self.merge_size`):\n+                The merge size of the vision encoder to llm encoder.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            data_format (`ChannelDimension`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.   - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+        images = make_list_of_images(images)\n+        images = self.fetch_images(images)\n+\n+        if do_convert_rgb:\n+            images = [convert_to_rgb(image) for image in images]\n+\n+        # All transformations expect numpy arrays.\n+        images = [to_numpy_array(image) for image in images]\n+\n+        if is_scaled_image(images[0]) and do_rescale:\n+            logger.warning_once(\n+                \"It looks like you are trying to rescale already rescaled images. If the input\"\n+                \" images have pixel values between 0 and 1, set `do_rescale=False` to avoid rescaling them again.\"\n+            )\n+        if input_data_format is None:\n+            # We assume that all images have the same channel dimension format.\n+            input_data_format = infer_channel_dimension_format(images[0])\n+\n+        height, width = get_image_size(images[0], channel_dim=input_data_format)\n+        resized_height, resized_width = height, width\n+        processed_images = []\n+\n+        for image in images:\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    height,\n+                    width,\n+                    factor=patch_size * merge_size,\n+                    min_pixels=size[\"shortest_edge\"],\n+                    max_pixels=size[\"longest_edge\"],\n+                )\n+                image = resize(\n+                    image,\n+                    size=(resized_height, resized_width),\n+                    resample=resample,\n+                    input_data_format=input_data_format,\n+                )\n+\n+            if do_rescale:\n+                image = self.rescale(image, scale=rescale_factor, input_data_format=input_data_format)\n+\n+            if do_normalize:\n+                image = self.normalize(\n+                    image=image,\n+                    mean=image_mean,\n+                    std=image_std,\n+                    input_data_format=input_data_format,\n+                )\n+            image = to_channel_dimension_format(image, data_format, input_channel_dim=input_data_format)\n+            processed_images.append(image)\n+\n+        patches = np.array(processed_images)\n+        if data_format == ChannelDimension.LAST:\n+            patches = patches.transpose(0, 3, 1, 2)\n+        if patches.shape[0] == 1:\n+            patches = np.tile(patches, (temporal_patch_size, 1, 1, 1))\n+\n+        channel = patches.shape[1]\n+        grid_t = patches.shape[0] // temporal_patch_size\n+        grid_h, grid_w = (\n+            resized_height // patch_size,\n+            resized_width // patch_size,\n+        )\n+        patches = patches.reshape(\n+            grid_t,\n+            temporal_patch_size,\n+            channel,\n+            grid_h,\n+            patch_size,\n+            grid_w,\n+            patch_size,\n+        )\n+        patches = patches.transpose(0, 3, 5, 2, 1, 4, 6)\n+        if temporal_patch_size != 1:\n+            raise ValueError(f\"temporal_patch_size must be 1!, but got {temporal_patch_size}!\")\n+        flatten_patches = patches.reshape(grid_t * grid_h * grid_w, channel, patch_size, patch_size)\n+        return flatten_patches, (grid_t, grid_h, grid_w)\n+\n+\n+class PaddleOCRVLImageProcessorFast(BaseImageProcessorFast):\n+    def __init__(\n+        self,\n+        do_resize: bool = True,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = PILImageResampling.BICUBIC,\n+        do_rescale: bool = True,\n+        rescale_factor: Union[int, float] = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        do_convert_rgb: bool = True,\n+        min_pixels: int = 384 * 384,\n+        max_pixels: int = 1536 * 1536,\n+        patch_size: int = 14,\n+        temporal_patch_size: int = 1,\n+        merge_size: int = 2,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+        else:\n+            size = {\"shortest_edge\": 384 * 384, \"longest_edge\": 1536 * 1536}\n+        # backward compatibility: override size with min_pixels and max_pixels if they are provided\n+        if min_pixels is not None:\n+            size[\"shortest_edge\"] = min_pixels\n+        if max_pixels is not None:\n+            size[\"longest_edge\"] = max_pixels\n+        self.min_pixels = size[\"shortest_edge\"]\n+        self.max_pixels = size[\"longest_edge\"]\n+        self.size = size\n+\n+        self.do_resize = do_resize\n+        self.resample = resample\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean if image_mean is not None else OPENAI_CLIP_MEAN\n+        self.image_std = image_std if image_std is not None else OPENAI_CLIP_STD\n+\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.merge_size = merge_size\n+        self.do_convert_rgb = do_convert_rgb\n+\n+    def _preprocess(\n+        self,\n+        images: list[\"torch.Tensor\"],\n+        do_resize: bool,\n+        size: SizeDict,\n+        interpolation: Optional[\"F.InterpolationMode\"],\n+        do_rescale: bool,\n+        rescale_factor: float,\n+        do_normalize: bool,\n+        image_mean: Optional[Union[float, list[float]]],\n+        image_std: Optional[Union[float, list[float]]],\n+        disable_grouping: Optional[bool],\n+        return_tensors: Optional[Union[str, TensorType]],\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        **kwargs,\n+    ):\n+        patch_size = patch_size if patch_size is not None else self.patch_size\n+        temporal_patch_size = temporal_patch_size if temporal_patch_size is not None else self.temporal_patch_size\n+        merge_size = merge_size if merge_size is not None else self.merge_size\n+\n+        grouped_images, grouped_images_index = group_images_by_shape(images, disable_grouping=disable_grouping)\n+        resized_images_grouped = {}\n+        for shape, stacked_images in grouped_images.items():\n+            height, width = stacked_images.shape[-2:]\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    height,\n+                    width,\n+                    factor=patch_size * merge_size,\n+                    min_pixels=size[\"shortest_edge\"],\n+                    max_pixels=size[\"longest_edge\"],\n+                )\n+                stacked_images = self.resize(\n+                    image=stacked_images,\n+                    size=SizeDict(height=resized_height, width=resized_width),\n+                    interpolation=interpolation,\n+                )\n+            resized_images_grouped[shape] = stacked_images\n+        resized_images = reorder_images(resized_images_grouped, grouped_images_index)\n+\n+        # Group images by size for further processing\n+        # Needed in case do_resize is False, or resize returns images with different sizes\n+        grouped_images, grouped_images_index = group_images_by_shape(resized_images, disable_grouping=disable_grouping)\n+        processed_images_grouped = {}\n+        processed_grids = {}\n+        for shape, stacked_images in grouped_images.items():\n+            resized_height, resized_width = stacked_images.shape[-2:]\n+            # Fused rescale and normalize\n+            patches = self.rescale_and_normalize(\n+                stacked_images, do_rescale, rescale_factor, do_normalize, image_mean, image_std\n+            )\n+\n+            if patches.ndim == 4:\n+                # add a temporal dimension if we have images\n+                patches = patches.unsqueeze(1)\n+            if patches.shape[1] % temporal_patch_size != 0:\n+                repeats = patches[:, -1:].repeat(1, temporal_patch_size - 1, 1, 1, 1)\n+                patches = torch.cat([patches, repeats], dim=1)\n+\n+            batch_size, grid_t, channel = patches.shape[:3]\n+            grid_t = grid_t // temporal_patch_size\n+            grid_h, grid_w = (\n+                resized_height // patch_size,\n+                resized_width // patch_size,\n+            )\n+            patches = patches.view(\n+                batch_size,\n+                grid_t,\n+                temporal_patch_size,\n+                channel,\n+                grid_h,\n+                patch_size,\n+                grid_w,\n+                patch_size,\n+            )\n+            patches = patches.permute(0, 1, 4, 6, 3, 2, 5, 7)\n+            flatten_patches = patches.reshape(batch_size, grid_t * grid_h * grid_w, channel, patch_size, patch_size)\n+\n+            processed_images_grouped[shape] = flatten_patches\n+            processed_grids[shape] = [[grid_t, grid_h, grid_w]] * batch_size\n+\n+        processed_images = reorder_images(processed_images_grouped, grouped_images_index)\n+        processed_grids = reorder_images(processed_grids, grouped_images_index)\n+        pixel_values = torch.cat(processed_images, dim=0)\n+        image_grid_thw = torch.tensor(processed_grids)\n+\n+        return BatchFeature(\n+            data={\"pixel_values\": pixel_values, \"image_grid_thw\": image_grid_thw}, tensor_type=return_tensors\n+        )\n+\n+\n+class PaddleOCRVLProcessorKwargs(ProcessingKwargs, total=False):\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": False,\n+        },\n+    }\n+\n+\n+class PaddleOCRVLProcessor(ProcessorMixin):\n+    r\"\"\"\n+    [`PaddleOCRVLProcessor`] offers all the functionalities of [`PaddleOCRVLImageProcessor`] and [`LLamaTokenizerFast`]. See the\n+    [`~PaddleOCRVLProcessor.__call__`] and [`~PaddleOCRVLProcessor.decode`] for more information.\n+    Args:\n+        image_processor ([`PaddleOCRVLImageProcessor`], *optional*):\n+            The image processor is a required input.\n+        tokenizer ([`LLamaTokenizerFast`], *optional*):\n+            The tokenizer is a required input.\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    image_processor_class = \"AutoImageProcessor\"\n+    tokenizer_class = \"AutoTokenizer\"\n+\n+    def __init__(self, image_processor=None, tokenizer=None, chat_template=None, **kwargs):\n+        self.image_token = tokenizer.image_token\n+        super().__init__(image_processor, tokenizer, chat_template=chat_template)\n+\n+    def __call__(\n+        self,\n+        images: ImageInput = None,\n+        text: Union[TextInput, PreTokenizedInput, list[TextInput], list[PreTokenizedInput]] = None,\n+        **kwargs: Unpack[PaddleOCRVLProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. Both channels-first and channels-last formats are supported.\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n+        \"\"\"\n+        output_kwargs = self._merge_kwargs(\n+            PaddleOCRVLProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+\n+        if images is not None:\n+            image_inputs = self.image_processor(images=images, **output_kwargs[\"images_kwargs\"])\n+            image_grid_thw = image_inputs[\"image_grid_thw\"]\n+\n+        else:\n+            image_inputs = {}\n+            image_grid_thw = None\n+\n+        if not isinstance(text, list):\n+            text = [text]\n+\n+        text = text.copy()\n+\n+        if image_grid_thw is not None:\n+            index = 0\n+            for i in range(len(text)):\n+                while self.image_token in text[i]:\n+                    text[i] = text[i].replace(\n+                        self.image_token,\n+                        \"<|placeholder|>\"\n+                        * (\n+                            image_grid_thw[index].prod()\n+                            // self.image_processor.merge_size\n+                            // self.image_processor.merge_size\n+                        ),\n+                        1,\n+                    )\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.image_token)\n+\n+        text_inputs = self.tokenizer(text, **output_kwargs[\"text_kwargs\"])\n+\n+        return BatchFeature(data={**text_inputs, **image_inputs})\n+\n+\n+class PaddleOCRVisionConfig(SiglipVisionConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`PaddleOCRVisionModel`]. It is used to instantiate a\n+    PaddleOCRVL vision encoder according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the vision encoder of the PaddleOCRVL\n+    [PaddlePaddle/PaddleOCRVL](https://huggingface.co/PaddlePaddle/PaddleOCR-VL) architecture.\n+\n+    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PreTrainedConfig`] for more information.\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 1152):\n+            Dimensionality of the encoder layers and the pooler layer.\n+        intermediate_size (`int`, *optional*, defaults to 4304):\n+            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+        num_hidden_layers (`int`, *optional*, defaults to 27):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_channels (`int`, *optional*, defaults to 3):\n+            Number of channels in the input images.\n+        image_size (`int`, *optional*, defaults to 384):\n+            The size (resolution) of each image.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The size (resolution) of each patch.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"gelu_pytorch_tanh\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+            `\"relu\"`, `\"selu\"` and `\"gelu_new\"` `\"quick_gelu\"` are supported.\n+        layer_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the layer normalization layers.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        spatial_merge_size (`int`, *optional*, defaults to 2):\n+            The size used for merging spatial dimensions.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import PaddleOCRVisionConfig, PaddleOCRVisionModel\n+\n+    >>> # Initializing a PaddleOCRVisionConfig with PaddlePaddle/PaddleOCR-VL style configuration\n+    >>> configuration = PaddleOCRVisionConfig()\n+\n+    >>> # Initializing a PaddleOCRVisionModel (with random weights) from the PaddlePaddle/PaddleOCR-VL style configuration\n+    >>> model = PaddleOCRVisionModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\n+    \"\"\"\n+\n+    model_type = \"paddleocr_vl_vision\"\n+    base_config_key = \"vision_config\"\n+\n+    def __init__(\n+        self,\n+        hidden_size=1152,\n+        intermediate_size=4304,\n+        num_hidden_layers=27,\n+        num_attention_heads=16,\n+        num_channels=3,\n+        image_size=384,\n+        patch_size=14,\n+        hidden_act=\"gelu_pytorch_tanh\",\n+        layer_norm_eps=1e-6,\n+        attention_dropout=0.0,\n+        spatial_merge_size=2,\n+        **kwargs,\n+    ):\n+        super().__init__()\n+        self.spatial_merge_size = spatial_merge_size\n+\n+\n+class PaddleOCRTextConfig(Ernie4_5Config):\n+    model_type = \"paddleocr_vl_text\"\n+\n+\n+class PaddleOCRVLConfig(Qwen2VLConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`PaddleOCRVLForConditionalGeneration`]. It is used to instantiate a\n+    PaddleOCRVL model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of\n+    PaddleOCRVL [PaddlePaddle/PaddleOCR-VL](https://huggingface.co/PaddlePaddle/PaddleOCR-VL).\n+\n+    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PreTrainedConfig`] for more information.\n+\n+\n+    Args:\n+        text_config (`Union[PreTrainedConfig, dict]`, *optional*, defaults to `PaddleOCRTextConfig`):\n+            The config object or dictionary of the text backbone.\n+        vision_config (`Union[PreTrainedConfig, dict]`,  *optional*, defaults to `PaddleOCRVisionConfig`):\n+            The config object or dictionary of the vision backbone.\n+        image_token_id (`int`, *optional*, defaults to 100295):\n+            The image token index to encode the image prompt.\n+        video_token_id (`int`, *optional*, defaults to 100296):\n+            The video token index to encode the image prompt.\n+        vision_start_token_id (`int`, *optional*, defaults to 101305):\n+            The token index to denote start of vision input.\n+        vision_end_token_id (`int`, *optional*, defaults to 101306):\n+            The token index to denote end of vision input.\n+\n+    ```python\n+    >>> from transformers import PaddleOCRVLForConditionalGeneration, PaddleOCRVLConfig\n+\n+    >>> # Initializing a PaddleOCRVL style configuration\n+    >>> configuration = PaddleOCRVLConfig()\n+\n+    >>> # Initializing a model from the PaddleOCRVL style configuration\n+    >>> model = PaddleOCRVLForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    sub_configs = {\"vision_config\": PaddleOCRVisionConfig, \"text_config\": PaddleOCRTextConfig}\n+\n+    def __init__(\n+        self,\n+        text_config=None,\n+        vision_config=None,\n+        image_token_id=100295,\n+        video_token_id=100296,\n+        vision_start_token_id=101305,\n+        vision_end_token_id=101306,\n+        **kwargs,\n+    ):\n+        super().__init__()\n+\n+\n+class PaddleOCRProjector(nn.Module):\n+    def __init__(self, config: PaddleOCRVLConfig):\n+        super().__init__()\n+        self.merge_kernel_size = (config.vision_config.spatial_merge_size, config.vision_config.spatial_merge_size)\n+\n+        hidden_size = config.vision_config.hidden_size * self.merge_kernel_size[0] * self.merge_kernel_size[1]\n+\n+        self.pre_norm = torch.nn.LayerNorm(config.vision_config.hidden_size, eps=1e-05)\n+        self.linear_1 = nn.Linear(hidden_size, hidden_size, bias=True)\n+        self.act = GELUActivation()\n+        self.linear_2 = nn.Linear(hidden_size, config.text_config.hidden_size, bias=True)\n+\n+    def forward(self, image_features: torch.Tensor, image_grid_thw: torch.Tensor) -> torch.Tensor:\n+        image_features_chunks = image_features.split(image_grid_thw.prod(dim=1).tolist(), dim=0)\n+        m1, m2 = self.merge_kernel_size\n+\n+        processed_features = []\n+        for image_feature, image_grid in zip(image_features_chunks, image_grid_thw):\n+            image_feature = self.pre_norm(image_feature)\n+            t, h, w = image_grid\n+            d = image_feature.shape[-1]\n+            h_block = h // m1\n+            w_block = w // m2\n+\n+            image_feature = image_feature.reshape(t, h_block, m1, w_block, m2, d)\n+            image_feature = image_feature.transpose(2, 3)\n+            image_feature = image_feature.reshape(t * h_block * w_block, m1 * m2 * d)\n+\n+            hidden_states = self.linear_1(image_feature)\n+            hidden_states = self.act(hidden_states)\n+            hidden_states = self.linear_2(hidden_states)\n+            processed_features.append(hidden_states)\n+\n+        return torch.cat(processed_features, dim=0)\n+\n+\n+class PaddleOCRVisionRotaryEmbedding(VisionRotaryEmbedding):\n+    pass\n+\n+\n+class PaddleOCRRotaryEmbedding(Qwen2VLRotaryEmbedding):\n+    pass\n+\n+\n+class PaddleOCRMLP(Ernie4_5MLP):\n+    def __init__(self, config: PaddleOCRTextConfig):\n+        super().__init__()\n+\n+\n+class PaddleOCRAttention(Qwen2_5OmniAttention):\n+    def __init__(self, config: PaddleOCRVLConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+\n+        self.attention_dropout = 0.0\n+        self.q_proj = nn.Linear(self.hidden_size, self.num_heads * self.head_dim, bias=config.use_bias)\n+        self.k_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=config.use_bias)\n+        self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=config.use_bias)\n+        self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=config.use_bias)\n+\n+\n+class PaddleOCRRMSNorm(Ernie4_5RMSNorm):\n+    pass\n+\n+\n+class PaddleOCRDecoderLayer(Ernie4_5DecoderLayer):\n+    def __init__(self, config: PaddleOCRTextConfig, layer_idx: int):\n+        super().__init__()\n+\n+\n+@auto_docstring\n+class PaddleOCRVLPreTrainedModel(PreTrainedModel):\n+    config: PaddleOCRVLConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"PaddleOCRDecoderLayer\"]\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _supports_flash_attn = True\n+    _supports_sdpa = True\n+    _supports_flex_attn = True\n+\n+    _can_compile_fullgraph = True\n+    _supports_attention_backend = True\n+\n+    _can_record_outputs = {\n+        \"hidden_states\": PaddleOCRDecoderLayer,\n+        \"attentions\": PaddleOCRAttention,\n+    }\n+\n+\n+class PaddleOCRTextModel(PaddleOCRVLPreTrainedModel, Ernie4_5Model):\n+    def __init__(self, config: PaddleOCRTextConfig):\n+        super().__init__(config)\n+\n+    @check_model_inputs\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> BaseModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds: torch.Tensor = self.embed_tokens(input_ids)\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache(config=self.config)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position: torch.Tensor = (\n+                torch.arange(inputs_embeds.shape[1], device=inputs_embeds.device) + past_seen_tokens\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.view(1, 1, -1).expand(3, inputs_embeds.shape[0], -1)\n+        elif position_ids.ndim == 2:\n+            position_ids = position_ids[None, ...].expand(3, position_ids.shape[0], -1)\n+\n+        if position_ids.ndim == 3 and position_ids.shape[0] == 4:\n+            text_position_ids = position_ids[0]\n+            position_ids = position_ids[1:]\n+        else:\n+            text_position_ids = None\n+\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=text_position_ids,\n+        )\n+\n+        hidden_states = inputs_embeds\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids=position_ids)\n+\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask,\n+                position_embeddings=position_embeddings,\n+                position_ids=text_position_ids,\n+                past_key_values=past_key_values,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+\n+        hidden_states = self.norm(hidden_states)\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+class PaddleOCRVisionModel(PaddleOCRVLPreTrainedModel):\n+    config: PaddleOCRVisionConfig\n+    main_input_name = \"pixel_values\"\n+    input_modalities = \"image\"\n+\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__(config)\n+\n+        self.vision_model = PaddleOCRVisionTransformer(config)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def forward(\n+        self,\n+        pixel_values: torch.FloatTensor,\n+        cu_seqlens: torch.Tensor,\n+        image_grid_thw: Optional[list[Union[tuple[int, int, int], list[tuple[int, int, int]]]]] = None,\n+        **kwargs,\n+    ) -> BaseModelOutputWithPooling:\n+        \"\"\"\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, sequence_length, image_channels, patch_size, patch_size)`):\n+                The tensors corresponding to the input images.\n+            cu_seqlens (`torch.Tensor` of shape `(num_images + 1,)`):\n+                The cumulative sequence lengths of each image or video feature.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        return self.vision_model(\n+            pixel_values=pixel_values,\n+            cu_seqlens=cu_seqlens,\n+            image_grid_thw=image_grid_thw,\n+        )\n+\n+\n+class PaddleOCRVisionEmbeddings(SiglipVisionEmbeddings):\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__()\n+\n+    def interpolate_pos_encoding(self, embeddings: torch.Tensor, height: int, width: int) -> torch.Tensor:\n+        num_positions = self.position_embedding.weight.shape[0]\n+\n+        patch_pos_embed = self.position_embedding.weight.unsqueeze(0)\n+\n+        dim = embeddings.shape[-1]\n+\n+        sqrt_num_positions = torch_int(num_positions**0.5)\n+        patch_pos_embed = patch_pos_embed.reshape(1, sqrt_num_positions, sqrt_num_positions, dim)\n+        patch_pos_embed = patch_pos_embed.permute(0, 3, 1, 2)\n+\n+        patch_pos_embed = nn.functional.interpolate(\n+            patch_pos_embed,\n+            size=(height, width),\n+            mode=\"bilinear\",\n+            align_corners=False,\n+        )\n+\n+        patch_pos_embed = patch_pos_embed.permute(0, 2, 3, 1).view(1, -1, dim)\n+        return patch_pos_embed\n+\n+    def forward(\n+        self,\n+        pixel_values: torch.FloatTensor,\n+        image_grid_thw: Optional[list[Union[tuple[int, int, int], list[tuple[int, int, int]]]]] = None,\n+    ) -> torch.Tensor:\n+        \"\"\"\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, sequence_length, image_channels, patch_size, patch_size)`):\n+                The tensors corresponding to the input images.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        batch_size, squence_len, channel, height, width = pixel_values.shape\n+        target_dtype = self.patch_embedding.weight.dtype\n+        pixel_values = pixel_values.reshape(batch_size * squence_len, channel, height, width)\n+        patch_embeds = self.patch_embedding(pixel_values.to(dtype=target_dtype))  # shape = [*, width, grid, grid]\n+        embeddings = patch_embeds.flatten(-2).squeeze(-1)\n+        embeddings = embeddings.reshape(batch_size, squence_len, -1)\n+\n+        start = 0\n+        embeddings = embeddings.squeeze(0)\n+        tmp_embeddings = []\n+        for image_grid in image_grid_thw:\n+            t, h, w = image_grid\n+            end = start + t * h * w\n+            image_embeddings = embeddings[start:end, :]\n+            position_embedding = self.interpolate_pos_encoding(image_embeddings, h, w).squeeze(0).repeat(t, 1)\n+            image_embeddings = image_embeddings + position_embedding\n+            tmp_embeddings.append(image_embeddings)\n+            start = end\n+        embeddings = torch.concat(tmp_embeddings, dim=0)\n+\n+        return embeddings\n+\n+\n+class PaddleOCRVisionAttention(VideoLlama3VisionAttention):\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__()\n+\n+\n+class PaddleOCRVisionMLP(SiglipMLP):\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__()\n+\n+\n+class PaddleOCRVisionEncoderLayer(VideoLlama3VisionEncoderLayer):\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__()\n+\n+\n+class PaddleOCRVisionEncoder(VideoLlama3VisionEncoder):\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__()\n+        embed_dim = config.hidden_size\n+        num_heads = config.num_attention_heads\n+        head_dim = embed_dim // num_heads\n+        self.rotary_pos_emb = PaddleOCRVisionRotaryEmbedding(head_dim // 2)\n+\n+    def forward(\n+        self,\n+        inputs_embeds: torch.FloatTensor,\n+        cu_seqlens: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        image_grid_thw: Optional[list[Union[tuple[int, int, int], list[tuple[int, int, int]]]]] = None,\n+    ) -> BaseModelOutput:\n+        \"\"\"\n+        Args:\n+            inputs_embeds (`torch.FloatTensor` of shape `(sequence_length, hidden_size)`, *optional*):\n+                Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation.\n+                This is useful if you want more control over how to convert `input_ids` indices into associated vectors\n+                than the model's internal embedding lookup matrix.\n+            cu_seqlens (`torch.Tensor` of shape `(num_images + 1,)`):\n+                The cumulative sequence lengths of each image or video feature.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                The attention_mask used in forward function shape [batch_size X sequence_length] if not None.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        device = inputs_embeds.device\n+        hidden_states = inputs_embeds\n+        attention_mask = create_bidirectional_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+        )\n+        split_hids = []\n+        split_wids = []\n+        for t, h, w in image_grid_thw:\n+            image_pids = torch.arange(t * h * w, device=device) % (h * w)\n+            sample_hids = image_pids // w\n+            sample_wids = image_pids % w\n+            split_hids.append(sample_hids)\n+            split_wids.append(sample_wids)\n+        width_position_ids = torch.concat(split_wids, dim=0)\n+        height_position_ids = torch.concat(split_hids, dim=0)\n+\n+        pids = torch.stack([height_position_ids, width_position_ids], dim=-1)\n+        max_grid_size = pids.max() + 1\n+        rotary_embeddings_max_grid = self.rotary_pos_emb(max_grid_size)\n+        rotary_embeddings = rotary_embeddings_max_grid[pids].flatten(1)\n+        rotary_embeddings = rotary_embeddings.repeat(1, 2)\n+        position_embeddings = (rotary_embeddings.cos(), rotary_embeddings.sin())\n+\n+        for encoder_layer in self.layers:\n+            hidden_states = encoder_layer(\n+                hidden_states,\n+                cu_seqlens=cu_seqlens,\n+                position_embeddings=position_embeddings,\n+            )\n+\n+        return BaseModelOutput(\n+            last_hidden_state=hidden_states,\n+        )\n+\n+\n+class PaddleOCRVisionTransformer(PaddleOCRVLPreTrainedModel):\n+    def __init__(self, config: PaddleOCRVisionConfig):\n+        super().__init__(config)\n+        self.config = config\n+        embed_dim = config.hidden_size\n+\n+        self.embeddings = PaddleOCRVisionEmbeddings(config)\n+        self.encoder = PaddleOCRVisionEncoder(config)\n+        self.post_layernorm = nn.LayerNorm(embed_dim, eps=config.layer_norm_eps)\n+\n+    def forward(\n+        self,\n+        pixel_values: torch.FloatTensor,\n+        cu_seqlens: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        image_grid_thw: Optional[list[Union[tuple[int, int, int], list[tuple[int, int, int]]]]] = None,\n+        **kwargs,\n+    ) -> BaseModelOutputWithPooling:\n+        \"\"\"\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, sequence_length, patch_size * patch_size * image_channels)`):\n+                The tensors corresponding to the input images.\n+            cu_seqlens (`torch.Tensor` of shape `(num_images + 1,)`):\n+                The cumulative sequence lengths of each image or video feature.\n+            attention_mask (`torch.Tensor`, *optional*):\n+                The attention_mask used in forward function shape [batch_size X sequence_length] if not None.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        hidden_states = self.embeddings(pixel_values, image_grid_thw=image_grid_thw)\n+\n+        encoder_outputs: BaseModelOutput = self.encoder(\n+            inputs_embeds=hidden_states,\n+            cu_seqlens=cu_seqlens,\n+            attention_mask=attention_mask,\n+            image_grid_thw=image_grid_thw,\n+        )\n+\n+        last_hidden_state = encoder_outputs.last_hidden_state\n+        last_hidden_state = self.post_layernorm(last_hidden_state)\n+\n+        return BaseModelOutputWithPooling(\n+            last_hidden_state=last_hidden_state,\n+            pooler_output=None,\n+            hidden_states=encoder_outputs.hidden_states,\n+            attentions=encoder_outputs.attentions,\n+        )\n+\n+\n+class PaddleOCRVLModelOutputWithPast(Qwen2VLModelOutputWithPast):\n+    pass\n+\n+\n+class PaddleOCRVLCausalLMOutputWithPast(Qwen2VLCausalLMOutputWithPast):\n+    pass\n+\n+\n+class PaddleOCRVLModel(Qwen2VLModel):\n+    _checkpoint_conversion_mapping = {\"^model\": \"language_model\"}\n+    _keys_to_ignore_on_load_unexpected = [\"packing_position_embedding\", \"vision_model.head\"]\n+\n+    def __init__(self, config: PaddleOCRVLConfig):\n+        super().__init__(config)\n+        self.visual = PaddleOCRVisionModel._from_config(config.vision_config)\n+        self.projector = PaddleOCRProjector(config)\n+        self.language_model = PaddleOCRTextModel._from_config(config.text_config)\n+        self.rope_deltas = None\n+\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.language_model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.language_model.embed_tokens = value\n+\n+    def get_image_features(self, pixel_values: torch.FloatTensor, image_grid_thw: Optional[torch.LongTensor] = None):\n+        \"\"\"\n+        Encodes images into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input images.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        pixel_values = pixel_values.type(self.visual.dtype).unsqueeze(0)\n+        cu_seqlens = torch.repeat_interleave(image_grid_thw[:, 1] * image_grid_thw[:, 2], image_grid_thw[:, 0]).cumsum(\n+            dim=0,\n+            # Select dtype based on the following factors:\n+            #  - FA2 requires that cu_seqlens_q must have dtype int32\n+            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n+            # See https://github.com/huggingface/transformers/pull/34852 for more information\n+            dtype=image_grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_seqlens = torch.nn.functional.pad(cu_seqlens, (1, 0), value=0)\n+        vision_outputs = self.visual(\n+            pixel_values=pixel_values,\n+            image_grid_thw=image_grid_thw,\n+            cu_seqlens=cu_seqlens,\n+        )\n+        image_embeds = vision_outputs.last_hidden_state\n+        image_embeds = self.projector(image_embeds, image_grid_thw)\n+        return image_embeds\n+\n+    def get_placeholder_mask(\n+        self, input_ids: torch.LongTensor, inputs_embeds: torch.FloatTensor, image_features: torch.FloatTensor\n+    ):\n+        \"\"\"\n+        Obtains multimodal placeholder mask from `input_ids` or `inputs_embeds`, and checks that the placeholder token count is\n+        equal to the length of multimodal features. If the lengths are different, an error is raised.\n+        \"\"\"\n+        if input_ids is None:\n+            special_image_mask = inputs_embeds == self.get_input_embeddings()(\n+                torch.tensor(self.config.image_token_id, dtype=torch.long, device=inputs_embeds.device)\n+            )\n+            special_image_mask = special_image_mask.all(-1)\n+        else:\n+            special_image_mask = input_ids == self.config.image_token_id\n+\n+        n_image_tokens = special_image_mask.sum()\n+        special_image_mask = special_image_mask.unsqueeze(-1).expand_as(inputs_embeds).to(inputs_embeds.device)\n+        n_image_features = image_features.shape[0] * image_features.shape[1]\n+        if inputs_embeds[special_image_mask].numel() != image_features.numel():\n+            raise ValueError(\n+                f\"Image features and image tokens do not match: tokens: {n_image_tokens}, features {n_image_features}\"\n+            )\n+        return special_image_mask\n+\n+    @can_return_tuple\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> Union[tuple, PaddleOCRVLModelOutputWithPast]:\n+        r\"\"\"\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+        \"\"\"\n+        if inputs_embeds is None:\n+            inputs_embeds = self.language_model.embed_tokens(input_ids)\n+\n+        if pixel_values is not None:\n+            image_embeds = self.get_image_features(pixel_values, image_grid_thw).to(\n+                inputs_embeds.device, inputs_embeds.dtype\n+            )\n+            image_mask = self.get_placeholder_mask(input_ids, inputs_embeds=inputs_embeds, image_features=image_embeds)\n+            inputs_embeds = inputs_embeds.masked_scatter(image_mask, image_embeds)\n+\n+        if position_ids is None:\n+            past_key_values_length = 0 if past_key_values is None else past_key_values.get_seq_length()\n+            if self.rope_deltas is None or past_key_values_length == 0:\n+                position_ids, rope_deltas = self.get_rope_index(\n+                    input_ids=input_ids,\n+                    image_grid_thw=image_grid_thw,\n+                    attention_mask=attention_mask,\n+                )\n+                self.rope_deltas = rope_deltas\n+            # then use the prev pre-calculated rope-deltas to get the correct position ids\n+            else:\n+                batch_size, seq_length, _ = inputs_embeds.shape\n+                position_ids = torch.arange(seq_length, device=inputs_embeds.device)\n+                position_ids = position_ids.view(1, 1, -1).expand(3, batch_size, -1)\n+                delta = (past_key_values_length + self.rope_deltas).to(inputs_embeds.device)\n+                delta = delta.repeat_interleave(batch_size // delta.shape[0], dim=0)\n+                position_ids = position_ids + delta.to(position_ids.device)\n+\n+        outputs = self.language_model(\n+            input_ids=None,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        output = PaddleOCRVLModelOutputWithPast(\n+            last_hidden_state=outputs.last_hidden_state,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=self.rope_deltas,\n+        )\n+\n+        return output\n+\n+\n+class PaddleOCRVLForConditionalGeneration(Qwen2VLForConditionalGeneration):\n+    _checkpoint_conversion_mapping = {\n+        \"^visual\": \"model.visual\",\n+        \"^mlp_AR\": \"model.projector\",\n+        r\"^model(?!(\\.visual|\\.projector|\\.language_model))\": \"model.language_model\",\n+    }\n+    _keys_to_ignore_on_load_unexpected = [\"packing_position_embedding\", \"vision_model.head\"]\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, PaddleOCRVLCausalLMOutputWithPast]:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoProcessor, PaddleOCRVLForConditionalGeneration\n+\n+        >>> model = PaddleOCRVLForConditionalGeneration.from_pretrained(\"PaddlePaddle/PaddleOCR-VL\", dtype=\"bfloat16\")\n+        >>> processor = AutoProcessor.from_pretrained(\"PaddlePaddle/PaddleOCR-VL\")\n+\n+        >>> messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"image\",\n+                        \"image\": \"https://paddle-model-ecology.bj.bcebos.com/paddlex/imgs/demo_image/ocr_demo.jpg\",\n+                    },\n+                    {\"type\": \"text\", \"text\": \"OCR:\"},\n+                ],\n+            }\n+        ]\n+\n+        >>> inputs = processor.apply_chat_template(\n+            messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\"\n+        ).to(model.device)\n+\n+        >>> # Generate\n+        >>> generated_ids = model.generate(**inputs, max_new_tokens=1024)\n+        >>> generated_ids_trimmed = [out_ids[len(in_ids) :] for in_ids, out_ids in zip(inputs.input_ids, generated_ids)]\n+        >>> output_text = processor.batch_decode(generated_ids_trimmed, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        >>> print(output_text)\n+        ```\n+        \"\"\"\n+        outputs: PaddleOCRVLModelOutputWithPast = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            image_grid_thw=image_grid_thw,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            pixel_values=pixel_values,\n+            rope_deltas=rope_deltas,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = outputs.last_hidden_state\n+\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(\n+                logits=logits, labels=labels, vocab_size=self.config.text_config.vocab_size, **kwargs\n+            )\n+\n+        return PaddleOCRVLCausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=outputs.rope_deltas,\n+        )\n+\n+\n+__all__ = [\n+    \"PaddleOCRVLForConditionalGeneration\",\n+    \"PaddleOCRVLModel\",\n+    \"PaddleOCRVLPreTrainedModel\",\n+    \"PaddleOCRVisionTransformer\",\n+    \"PaddleOCRVLConfig\",\n+    \"PaddleOCRTextModel\",\n+    \"PaddleOCRVisionModel\",\n+    \"PaddleOCRVisionConfig\",\n+    \"PaddleOCRTextConfig\",\n+    \"PaddleOCRVLImageProcessor\",\n+    \"PaddleOCRVLImageProcessorFast\",\n+    \"PaddleOCRVLProcessor\",\n+]"
        },
        {
            "sha": "e7bd822d3febd58981aa58e117bbfa7b1de3d8a2",
            "filename": "src/transformers/models/paddleocr_vl/processing_paddleocr_vl.py",
            "status": "added",
            "additions": 135,
            "deletions": 0,
            "changes": 135,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fprocessing_paddleocr_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fprocessing_paddleocr_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fpaddleocr_vl%2Fprocessing_paddleocr_vl.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -0,0 +1,135 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/paddleocr_vl/modular_paddleocr_vl.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_paddleocr_vl.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# Copyright 2025 The PaddlePaddle Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import Union\n+\n+from ...image_processing_utils import BatchFeature\n+from ...image_utils import ImageInput\n+from ...processing_utils import ProcessingKwargs, ProcessorMixin, Unpack\n+from ...tokenization_utils_base import PreTokenizedInput, TextInput\n+\n+\n+class PaddleOCRVLProcessorKwargs(ProcessingKwargs, total=False):\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": False,\n+        },\n+    }\n+\n+\n+class PaddleOCRVLProcessor(ProcessorMixin):\n+    r\"\"\"\n+    [`PaddleOCRVLProcessor`] offers all the functionalities of [`PaddleOCRVLImageProcessor`] and [`LLamaTokenizerFast`]. See the\n+    [`~PaddleOCRVLProcessor.__call__`] and [`~PaddleOCRVLProcessor.decode`] for more information.\n+    Args:\n+        image_processor ([`PaddleOCRVLImageProcessor`], *optional*):\n+            The image processor is a required input.\n+        tokenizer ([`LLamaTokenizerFast`], *optional*):\n+            The tokenizer is a required input.\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    image_processor_class = \"AutoImageProcessor\"\n+    tokenizer_class = \"AutoTokenizer\"\n+\n+    def __init__(self, image_processor=None, tokenizer=None, chat_template=None, **kwargs):\n+        self.image_token = tokenizer.image_token\n+        super().__init__(image_processor, tokenizer, chat_template=chat_template)\n+\n+    def __call__(\n+        self,\n+        images: ImageInput = None,\n+        text: Union[TextInput, PreTokenizedInput, list[TextInput], list[PreTokenizedInput]] = None,\n+        **kwargs: Unpack[PaddleOCRVLProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. Both channels-first and channels-last formats are supported.\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n+        \"\"\"\n+        output_kwargs = self._merge_kwargs(\n+            PaddleOCRVLProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+\n+        if images is not None:\n+            image_inputs = self.image_processor(images=images, **output_kwargs[\"images_kwargs\"])\n+            image_grid_thw = image_inputs[\"image_grid_thw\"]\n+\n+        else:\n+            image_inputs = {}\n+            image_grid_thw = None\n+\n+        if not isinstance(text, list):\n+            text = [text]\n+\n+        text = text.copy()\n+\n+        if image_grid_thw is not None:\n+            index = 0\n+            for i in range(len(text)):\n+                while self.image_token in text[i]:\n+                    text[i] = text[i].replace(\n+                        self.image_token,\n+                        \"<|placeholder|>\"\n+                        * (\n+                            image_grid_thw[index].prod()\n+                            // self.image_processor.merge_size\n+                            // self.image_processor.merge_size\n+                        ),\n+                        1,\n+                    )\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.image_token)\n+\n+        text_inputs = self.tokenizer(text, **output_kwargs[\"text_kwargs\"])\n+\n+        return BatchFeature(data={**text_inputs, **image_inputs})\n+\n+\n+__all__ = [\"PaddleOCRVLProcessor\"]"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/paddleocr_vl/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/tests%2Fmodels%2Fpaddleocr_vl%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/tests%2Fmodels%2Fpaddleocr_vl%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fpaddleocr_vl%2F__init__.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8"
        },
        {
            "sha": "65949ce402f0dbbea46059f4f00175826bbf506d",
            "filename": "tests/models/paddleocr_vl/test_modeling_paddleocr_vl.py",
            "status": "added",
            "additions": 507,
            "deletions": 0,
            "changes": 507,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/tests%2Fmodels%2Fpaddleocr_vl%2Ftest_modeling_paddleocr_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/tests%2Fmodels%2Fpaddleocr_vl%2Ftest_modeling_paddleocr_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fpaddleocr_vl%2Ftest_modeling_paddleocr_vl.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -0,0 +1,507 @@\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PaddleOCRVL model.\"\"\"\n+\n+import copy\n+import gc\n+import unittest\n+\n+import pytest\n+from parameterized import parameterized\n+\n+from transformers import (\n+    AutoProcessor,\n+    PaddleOCRVLConfig,\n+    PaddleOCRVLForConditionalGeneration,\n+    is_torch_available,\n+)\n+from transformers.testing_utils import (\n+    backend_empty_cache,\n+    require_flash_attn,\n+    require_torch,\n+    require_torch_accelerator,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import (\n+    ModelTesterMixin,\n+    floats_tensor,\n+    ids_tensor,\n+)\n+from ...test_pipeline_mixin import PipelineTesterMixin\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+class PaddleOCRVLVisionText2TextModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=7,\n+        seq_length=13,\n+        num_channels=3,\n+        image_height=28,\n+        image_width=28,\n+        text_config={\n+            \"pad_token_id\": 0,\n+            \"bos_token_id\": 1,\n+            \"eos_token_id\": 2,\n+            \"vocab_size\": 103424,\n+            \"head_dim\": 128,\n+            \"hidden_act\": \"silu\",\n+            \"hidden_dropout_prob\": 0.0,\n+            \"hidden_size\": 32,\n+            \"ignored_index\": -100,\n+            \"image_token_id\": 100295,\n+            \"intermediate_size\": 32,\n+            \"max_position_embeddings\": 512,\n+            \"model_type\": \"paddleocr_vl\",\n+            \"num_attention_heads\": 4,\n+            \"num_hidden_layers\": 2,\n+            \"num_key_value_heads\": 2,\n+            \"rms_norm_eps\": 1e-05,\n+            \"rope_scaling\": {\"mrope_section\": [16, 24, 24], \"rope_type\": \"default\", \"type\": \"default\"},\n+            \"rope_theta\": 500000,\n+            \"tie_word_embeddings\": False,\n+        },\n+        vision_start_token_id=101305,\n+        vision_end_token_id=101306,\n+        image_token_id=100295,\n+        is_training=True,\n+        vision_config={\n+            \"hidden_act\": \"gelu_pytorch_tanh\",\n+            \"hidden_size\": 144,\n+            \"intermediate_size\": 32,\n+            \"layer_norm_eps\": 1e-06,\n+            \"model_type\": \"paddleocr_vl\",\n+            \"num_attention_heads\": 4,\n+            \"num_channels\": 3,\n+            \"num_hidden_layers\": 2,\n+            \"pad_token_id\": 0,\n+            \"patch_size\": 14,\n+            \"spatial_merge_size\": 2,\n+        },\n+    ):\n+        self.parent = parent\n+        self.bos_token_id = text_config[\"bos_token_id\"]\n+        self.eos_token_id = text_config[\"eos_token_id\"]\n+        self.pad_token_id = text_config[\"pad_token_id\"]\n+        self.num_hidden_layers = text_config[\"num_hidden_layers\"]\n+        self.num_attention_heads = text_config[\"num_attention_heads\"]\n+        self.hidden_size = text_config[\"hidden_size\"]\n+        self.vision_start_token_id = vision_start_token_id\n+        self.vision_end_token_id = vision_end_token_id\n+        self.image_token_id = image_token_id\n+        self.text_config = text_config\n+        self.vision_config = vision_config\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.image_height = image_height\n+        self.image_width = image_width\n+        self.is_training = is_training\n+        self.vocab_size = text_config[\"vocab_size\"]\n+        self.num_image_tokens = 1\n+        self.seq_length = seq_length + self.num_image_tokens\n+\n+    def get_config(self):\n+        return PaddleOCRVLConfig(\n+            text_config=self.text_config,\n+            vision_config=self.vision_config,\n+            vision_start_token_id=self.vision_start_token_id,\n+            image_token_id=self.image_token_id,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        config = self.get_config()\n+        patch_size = config.vision_config.patch_size\n+        pixel_values = floats_tensor(\n+            [\n+                self.batch_size * (self.image_height * self.image_width) // (patch_size**2),\n+                config.vision_config.num_channels,\n+                patch_size,\n+                patch_size,\n+            ]\n+        )\n+\n+        return config, pixel_values\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], self.vocab_size)\n+        attention_mask = torch.ones(input_ids.shape, dtype=torch.long, device=torch_device)\n+\n+        input_ids[:, :4] = torch.tensor([100273, 2969, 93963, 93919], dtype=input_ids.dtype, device=input_ids.device)\n+        input_ids[:, 4] = self.vision_start_token_id\n+        input_ids[:, 5 : 5 + self.num_image_tokens] = self.image_token_id\n+        input_ids[:, -8] = self.vision_end_token_id\n+        input_ids[:, -7:] = torch.tensor(\n+            [93972, 2497, 93963, 23, 92267, 93963, 93919], dtype=input_ids.dtype, device=input_ids.device\n+        )\n+\n+        inputs_dict = {\n+            \"pixel_values\": pixel_values,\n+            \"image_grid_thw\": torch.tensor([[1, 2, 2]] * self.batch_size, device=torch_device),\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+        }\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class PaddleOCRVLModelTest(ModelTesterMixin, GenerationTesterMixin, PipelineTesterMixin, unittest.TestCase):\n+    \"\"\"\n+    Model tester for `PaddleOCRVLForConditionalGeneration`.\n+    \"\"\"\n+\n+    all_model_classes = (PaddleOCRVLForConditionalGeneration,) if is_torch_available() else ()\n+    pipeline_model_mapping = {\"image-text-to-text\": PaddleOCRVLForConditionalGeneration}\n+    _is_composite = True\n+\n+    def setUp(self):\n+        self.model_tester = PaddleOCRVLVisionText2TextModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=PaddleOCRVLConfig, has_text_modality=False)\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    def test_mismatching_num_image_tokens(self):\n+        \"\"\"\n+        Tests that an explicit error is thrown when the number of image tokens\n+        doesn't match the number of image placeholders in the text.\n+        We also test multi-image cases when one prompt has multiple image tokens.\n+        \"\"\"\n+        config, input_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+        for model_class in self.all_model_classes:\n+            model = model_class(config).to(torch_device)\n+            model.eval()\n+            curr_input_dict = copy.deepcopy(input_dict)  # in-place modifications further\n+            _ = model(**curr_input_dict)  # successful forward with no modifications\n+\n+            # remove one image but leave all the image tokens in text\n+            patch_size = config.vision_config.patch_size\n+            one_img_length = (self.model_tester.image_height * self.model_tester.image_width) // (patch_size**2)\n+            curr_input_dict[\"pixel_values\"] = curr_input_dict[\"pixel_values\"][-one_img_length:, ...]\n+            curr_input_dict[\"image_grid_thw\"] = curr_input_dict[\"image_grid_thw\"][-1:, ...]\n+            with self.assertRaises(ValueError):\n+                _ = model(**curr_input_dict)\n+\n+            # simulate multi-image case by concatenating inputs where each has exactly one image/image-token\n+            input_ids = curr_input_dict[\"input_ids\"][:1]\n+            pixel_values = curr_input_dict[\"pixel_values\"][:one_img_length]\n+            image_grid_thw = curr_input_dict[\"image_grid_thw\"][:1]\n+            input_ids = torch.cat([input_ids, input_ids], dim=0)\n+\n+            # one image and two image tokens raise an error\n+            with self.assertRaises(ValueError):\n+                _ = model(input_ids=input_ids, pixel_values=pixel_values, image_grid_thw=image_grid_thw)\n+\n+            # two images and two image tokens don't raise an error\n+            pixel_values = torch.cat([pixel_values, pixel_values], dim=0)\n+            image_grid_thw = torch.cat([image_grid_thw, image_grid_thw], dim=0)\n+            _ = model(input_ids=input_ids, pixel_values=pixel_values, image_grid_thw=image_grid_thw)\n+\n+    # PaddleOCRVL has pixel_values shaped as (bs*patch_len, image_channels, patch_size, patch_size) so we can't slice to batches in generate\n+    def prepare_config_and_inputs_for_generate(self, batch_size=2):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        # We don't want a few model inputs in our model input dictionary for generation tests\n+        input_keys_to_ignore = [\n+            # we don't want encoder-decoder models to start from filled decoder ids\n+            \"decoder_input_ids\",\n+            \"decoder_attention_mask\",\n+            # we'll set cache use in each test differently\n+            \"use_cache\",\n+            # Ignore labels if it is in the input dict\n+            \"labels\",\n+            # model-specific exceptions should overload/overwrite this function\n+        ]\n+\n+        # The diff from the general `prepare_config_and_inputs_for_generate` lies here\n+        patch_size = config.vision_config.patch_size\n+        filtered_image_length = (\n+            batch_size * (self.model_tester.image_height * self.model_tester.image_width) // (patch_size**2)\n+        )\n+        filtered_inputs_dict = {\n+            k: v[:batch_size, ...] if isinstance(v, torch.Tensor) else v\n+            for k, v in inputs_dict.items()\n+            if k not in input_keys_to_ignore\n+        }\n+        filtered_inputs_dict[\"pixel_values\"] = inputs_dict[\"pixel_values\"][:filtered_image_length]\n+\n+        # It is important set `eos_token_id` to `None` to avoid early stopping (would break for length-based checks)\n+        text_gen_config = config.get_text_config(decoder=True)\n+        if text_gen_config.eos_token_id is not None and text_gen_config.pad_token_id is None:\n+            text_gen_config.pad_token_id = (\n+                text_gen_config.eos_token_id\n+                if isinstance(text_gen_config.eos_token_id, int)\n+                else text_gen_config.eos_token_id[0]\n+            )\n+        text_gen_config.eos_token_id = None\n+        text_gen_config.forced_eos_token_id = None\n+\n+        return config, filtered_inputs_dict\n+\n+    @unittest.skip(reason=\"PaddleOCRVL does not support.\")\n+    def test_generate_compile_model_forward_fullgraph(self):\n+        pass\n+\n+    @unittest.skip(reason=\"PaddleOCRVL does not support.\")\n+    def test_multi_gpu_data_parallel_forward(self):\n+        pass\n+\n+    @pytest.mark.generate\n+    @unittest.skip(reason=\"PaddleOCRVL does not support beam search.\")\n+    def test_beam_sample_generate(self):\n+        pass\n+\n+    @pytest.mark.generate\n+    @unittest.skip(reason=\"PaddleOCRVL does not support beam search.\")\n+    def test_beam_search_generate(self):\n+        pass\n+\n+    @pytest.mark.generate\n+    @unittest.skip(reason=\"PaddleOCRVL does not support beam search.\")\n+    def test_beam_search_generate_dict_output(self):\n+        pass\n+\n+    @pytest.mark.generate\n+    @unittest.skip(reason=\"PaddleOCRVL does not support beam search.\")\n+    def test_beam_search_generate_dict_outputs_use_cache(self):\n+        pass\n+\n+    @pytest.mark.generate\n+    @unittest.skip(reason=\"PaddleOCRVL does not support beam search.\")\n+    def test_beam_sample_generate_dict_output(self):\n+        pass\n+\n+    @unittest.skip(reason=\"PaddleOCRVL needs to apply weight conversions.\")\n+    def test_can_load_from_already_mapped_keys(self):\n+        pass\n+\n+    @pytest.mark.generate\n+    @unittest.skip(reason=\"PaddleOCRVL does not support beam search.\")\n+    def test_generate_from_inputs_embeds_1_beam_search(self, _, num_beams):\n+        pass\n+\n+    @parameterized.expand([(\"random\",), (\"same\",)])\n+    @pytest.mark.generate\n+    @unittest.skip(reason=\"PaddleOCRVL does not support assisted decoding.\")\n+    def test_assisted_decoding_matches_greedy_search(self, assistant_type):\n+        pass\n+\n+    @pytest.mark.generate\n+    @unittest.skip(reason=\"PaddleOCRVL does not support assisted decoding.\")\n+    def test_assisted_decoding_sample(self):\n+        pass\n+\n+    @unittest.skip(\"PaddleOCRVL does not support this test.\")\n+    def test_model_is_small(self):\n+        pass\n+\n+\n+@require_torch\n+@slow\n+class PaddleOCRVLIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = AutoProcessor.from_pretrained(\"PaddlePaddle/PaddleOCR-VL\")\n+        self.messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"image\",\n+                        \"url\": \"https://paddle-model-ecology.bj.bcebos.com/paddlex/imgs/demo_image/ocr_demo2.jpg\",\n+                    },\n+                    {\"type\": \"text\", \"text\": \"OCR:\"},\n+                ],\n+            }\n+        ]\n+\n+    def tearDown(self):\n+        gc.collect()\n+        backend_empty_cache(torch_device)\n+\n+    def test_small_model_integration_test(self):\n+        model = (\n+            PaddleOCRVLForConditionalGeneration.from_pretrained(\n+                \"PaddlePaddle/PaddleOCR-VL\",\n+                dtype=\"bfloat16\",\n+            )\n+            .to(torch_device)\n+            .eval()\n+        )\n+\n+        inputs = self.processor.apply_chat_template(\n+            self.messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+        )\n+\n+        expected_input_ids_length = 211\n+        assert expected_input_ids_length == len(inputs.input_ids[0])\n+\n+        expected_input_ids = [100273, 2969, 93963, 93919, 101305, 100295, 100295, 100295, 100295, 100295]  # fmt: skip\n+        assert expected_input_ids == inputs.input_ids[0].tolist()[:10]\n+\n+        expected_pixel_slice = torch.tensor(\n+            [\n+                [1.0000, 1.0000, 1.0000],\n+                [1.0000, 1.0000, 1.0000],\n+                [0.9922, 0.9922, 0.9922],\n+                [1.0000, 1.0000, 1.0000],\n+                [1.0000, 1.0000, 1.0000],\n+            ],\n+            dtype=torch.float32,\n+            device=\"cpu\",\n+        )\n+\n+        assert torch.allclose(expected_pixel_slice, inputs.pixel_values[:5, :, 0, 0], atol=3e-3)\n+\n+        # verify generation\n+        inputs = inputs.to(torch_device)\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        result = self.processor.decode(output[0][inputs[\"input_ids\"].shape[-1] : -1])\n+\n+        EXPECTED_DECODED_TEXT = \"ç”Ÿç”˜è‰\"\n+\n+        self.assertEqual(\n+            result,\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    def test_small_model_integration_test_batch(self):\n+        model = (\n+            PaddleOCRVLForConditionalGeneration.from_pretrained(\"PaddlePaddle/PaddleOCR-VL\", dtype=\"bfloat16\")\n+            .to(torch_device)\n+            .eval()\n+        )\n+\n+        inputs = self.processor.apply_chat_template(\n+            [self.messages, self.messages],\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+            padding_side=\"left\",\n+        ).to(torch_device)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        generated_ids_trimmed = [out_ids[len(in_ids) :] for in_ids, out_ids in zip(inputs.input_ids, output)]\n+        result = self.processor.batch_decode(\n+            generated_ids_trimmed, skip_special_tokens=True, clean_up_tokenization_spaces=False\n+        )\n+\n+        EXPECTED_DECODED_TEXT = [\"ç”Ÿç”˜è‰\", \"ç”Ÿç”˜è‰\"]\n+\n+        self.assertEqual(\n+            result,\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @require_flash_attn\n+    @require_torch_accelerator\n+    @pytest.mark.flash_attn_test\n+    def test_small_model_integration_test_flashatt2(self):\n+        model = (\n+            PaddleOCRVLForConditionalGeneration.from_pretrained(\n+                \"PaddlePaddle/PaddleOCR-VL\", dtype=\"bfloat16\", attn_implementation=\"flash_attention_2\"\n+            )\n+            .to(torch_device)\n+            .eval()\n+        )\n+\n+        inputs = self.processor.apply_chat_template(\n+            self.messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+        )\n+\n+        expected_input_ids_length = 211\n+        assert expected_input_ids_length == len(inputs.input_ids[0])\n+\n+        expected_input_ids = [100273, 2969, 93963, 93919, 101305, 100295, 100295, 100295, 100295, 100295]  # fmt: skip\n+        assert expected_input_ids == inputs.input_ids[0].tolist()[:10]\n+\n+        expected_pixel_slice = torch.tensor(\n+            [\n+                [1.0000, 1.0000, 1.0000],\n+                [1.0000, 1.0000, 1.0000],\n+                [0.9922, 0.9922, 0.9922],\n+                [1.0000, 1.0000, 1.0000],\n+                [1.0000, 1.0000, 1.0000],\n+            ],\n+            dtype=torch.float32,\n+            device=\"cpu\",\n+        )\n+        assert torch.allclose(expected_pixel_slice, inputs.pixel_values[:5, :, 0, 0], atol=3e-3)\n+\n+        # verify generation\n+        inputs = inputs.to(torch_device)\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        result = self.processor.decode(output[0][inputs[\"input_ids\"].shape[-1] : -1])\n+\n+        EXPECTED_DECODED_TEXT = \"ç”Ÿç”˜è‰\"\n+\n+        self.assertEqual(\n+            result,\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @require_flash_attn\n+    @require_torch_accelerator\n+    @pytest.mark.flash_attn_test\n+    def test_small_model_integration_test_batch_flashatt2(self):\n+        model = (\n+            PaddleOCRVLForConditionalGeneration.from_pretrained(\n+                \"PaddlePaddle/PaddleOCR-VL\", dtype=\"bfloat16\", attn_implementation=\"flash_attention_2\"\n+            )\n+            .to(torch_device)\n+            .eval()\n+        )\n+\n+        inputs = self.processor.apply_chat_template(\n+            [self.messages, self.messages],\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+            padding_side=\"left\",\n+        ).to(torch_device)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        generated_ids_trimmed = [out_ids[len(in_ids) :] for in_ids, out_ids in zip(inputs.input_ids, output)]\n+        result = self.processor.batch_decode(\n+            generated_ids_trimmed, skip_special_tokens=True, clean_up_tokenization_spaces=False\n+        )\n+\n+        EXPECTED_DECODED_TEXT = [\"ç”Ÿç”˜è‰\", \"ç”Ÿç”˜è‰\"]\n+\n+        self.assertEqual(\n+            result,\n+            EXPECTED_DECODED_TEXT,\n+        )"
        },
        {
            "sha": "41606b1e1b6b6545eabb3e82a11b55cef921c8ef",
            "filename": "utils/check_config_attributes.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/utils%2Fcheck_config_attributes.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/utils%2Fcheck_config_attributes.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_config_attributes.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -58,6 +58,7 @@\n         \"expert_layer_offset\",\n         \"expert_layer_period\",\n     ],\n+    \"PaddleOCRTextConfig\": [\"tie_word_embeddings\"],\n     \"Qwen2Config\": [\"use_sliding_window\", \"max_window_layers\"],\n     \"Qwen2MoeConfig\": [\"use_sliding_window\", \"max_window_layers\"],\n     \"Qwen2VLTextConfig\": [\"use_sliding_window\", \"max_window_layers\"],"
        },
        {
            "sha": "651e6726ec44b0022e8b7d90d1e9016a442f01c3",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/huggingface/transformers/blob/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=8c84144bfc7dd0c9c5e336a6d89c9dcee2efc2a8",
            "patch": "@@ -153,6 +153,10 @@\n         \"SeamlessM4TCodeHifiGan\",  # Building part of bigger (tested) model.\n         \"SeamlessM4TTextToUnitForConditionalGeneration\",  # Building part of bigger (tested) model.\n         \"ChameleonVQVAE\",  # VQVAE here is used only for encoding (discretizing) and is tested as part of bigger model\n+        \"PaddleOCRVLModel\",  # Building part of bigger (tested) model. Tested implicitly through PaddleOCRVLForConditionalGeneration.\n+        \"PaddleOCRVisionModel\",  # Building part of bigger (tested) model. Tested implicitly through PaddleOCRVLForConditionalGeneration.\n+        \"PaddleOCRVisionTransformer\",  # Building part of bigger (tested) model. Tested implicitly through PaddleOCRVLForConditionalGeneration.\n+        \"PaddleOCRTextModel\",  # Building part of bigger (tested) model. Tested implicitly through PaddleOCRVLForConditionalGeneration.\n         \"Qwen2VLModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2VLForConditionalGeneration.\n         \"Qwen2_5_VLModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2_5_VLForConditionalGeneration.\n         \"Qwen3VLModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen3VLForConditionalGeneration.\n@@ -382,6 +386,10 @@\n     \"Emu3TextModel\",  # Building part of bigger (tested) model\n     \"JanusVQVAE\",  # no autoclass for VQ-VAE models\n     \"JanusVisionModel\",  # Building part of bigger (tested) model\n+    \"PaddleOCRVLModel\",  # Building part of bigger (tested) model\n+    \"PaddleOCRVisionModel\",  # Building part of bigger (tested) model\n+    \"PaddleOCRVisionTransformer\",  # Building part of bigger (tested) model\n+    \"PaddleOCRTextModel\",  # Building part of bigger (tested) model\n     \"Qwen2_5OmniTalkerForConditionalGeneration\",  # Building part of a bigger model\n     \"Qwen2_5OmniTalkerModel\",  # Building part of a bigger model\n     \"Qwen2_5OmniThinkerForConditionalGeneration\",  # Building part of a bigger model"
        }
    ],
    "stats": {
        "total": 5006,
        "additions": 5006,
        "deletions": 0
    }
}