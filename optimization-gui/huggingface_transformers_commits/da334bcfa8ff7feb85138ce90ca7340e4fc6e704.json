{
    "author": "eustlb",
    "message": "[Whisper] üö® Fix whisper decoding üö® (#34135)\n\n* do not remove decoder_input_ids for the first segment\r\n\r\n* do not remove eos token in generate_with_fallback\r\n\r\n* when removing padding tokens, do not remove eos token\r\n\r\n* remove eos token in generate (and not in generate_with_fallback!)\r\n\r\n* reconciliate short-from/ long-form behavior\r\n\r\n* correct avg_logprobs calculation\r\n\r\n* handle eos token in segments\r\n\r\n* handle decoder_input_ids and eos token in _prepare_decoder_input_ids\r\n\r\n* fix incorrect time precision\r\n\r\n* always remove eos token\r\n\r\n* always remove decoder_input_ids\r\n\r\n* no need to handle decoder_inputs_ids and eos token\r\n\r\n* no need to remove decoder_input_ids\r\n\r\n* no need to handle eos token\r\n\r\n* fix num_beams in _retrieve_logit_processors\r\n\r\n* remove todo unconsistency\r\n\r\n* no need to add eos token\r\n\r\n* last_timestamp_pos should indeed be timestamp token pos\r\n\r\n* patch generate to enable compatibility with GenerationTesterMixin tests\r\n\r\n* adapt test_generate_continue_from_past_key_values\r\n\r\n* adapt test_prompt_lookup_decoding_matches_greedy_search\r\n\r\n* adapt generic GenerationMixin tests to whisper's generate\r\n\r\n* fix speculative decoding\r\n\r\n* fix\r\n\r\n* [run-slow] whisper\r\n\r\n* change HF_HUB_TOKEN for require_read_token\r\n\r\n* [run-slow] whisper\r\n\r\n* prioritize kwargs over generation_config\r\n\r\n* remove unnecessary args\r\n\r\n* [run-slow] whisper\r\n\r\n* update tests\r\n\r\n* [run-slow] whisper\r\n\r\n* add comment\r\n\r\n* update test\r\n\r\n* [run-slow] whisper\r\n\r\n* update test + revert require_read_token\r\n\r\n* docstring updates\r\n\r\n* revert tokenizer decode args change\r\n\r\n* do not use a patch + docstring updates\r\n\r\n* [run-slow] whisper\r\n\r\n* make\r\n\r\n* [run-slow] whisper\r\n\r\n* add a flag to force unique call to generate\r\n\r\n* test update\r\n\r\n* [run-slow] whisper\r\n\r\n* add force_unique_generate_call arg\r\n\r\n* do not use a patch\r\n\r\n* correct the timestamps for the pad tokens\r\n\r\n* docstring update\r\n\r\n* docstring update\r\n\r\n* docstring update\r\n\r\n* upodate TF tests\r\n\r\n* add require_read_token\r\n\r\n* [run-slow] whisper\r\n\r\n* test reset dynamo\r\n\r\n* [run-slow] whisper\r\n\r\n* fix\r\n\r\n* [run-slow] whisper\r\n\r\n* avoid iterating twice on current_segments\r\n\r\n* [run-slow] whisper\r\n\r\n* [run-slow] whisper\r\n\r\n---------\r\n\r\nCo-authored-by: Eustache Le Bihan <eustlb@users.noreply.huggingface.co>\r\nCo-authored-by: ydshieh <ydshieh@users.noreply.github.com>",
    "sha": "da334bcfa8ff7feb85138ce90ca7340e4fc6e704",
    "files": [
        {
            "sha": "6b71671e14c852d6ba1b54a1d342808bf37e51c8",
            "filename": "src/transformers/models/whisper/generation_whisper.py",
            "status": "modified",
            "additions": 193,
            "deletions": 94,
            "changes": 287,
            "blob_url": "https://github.com/huggingface/transformers/blob/da334bcfa8ff7feb85138ce90ca7340e4fc6e704/src%2Ftransformers%2Fmodels%2Fwhisper%2Fgeneration_whisper.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/da334bcfa8ff7feb85138ce90ca7340e4fc6e704/src%2Ftransformers%2Fmodels%2Fwhisper%2Fgeneration_whisper.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fwhisper%2Fgeneration_whisper.py?ref=da334bcfa8ff7feb85138ce90ca7340e4fc6e704",
            "patch": "@@ -133,9 +133,12 @@ def _pad_to_max_length(\n     padding=\"longest\",\n     bos_token_tensor=None,\n     cut_off_length=None,\n+    return_token_timestamps=False,\n+    force_unique_generate_call=False,\n ):\n     max_total_length = 0\n     sequences = []\n+    token_timestamps_list = []\n \n     if padding_side not in [\"right\", \"left\"]:\n         raise ValueError(f\"`padding_side` must be either 'right' or 'left', not {padding_side}\")\n@@ -145,31 +148,74 @@ def _pad_to_max_length(\n     elif padding == \"max_length\" and cut_off_length is None:\n         raise ValueError(\"`cut_off_length` must be specified when `padding='max_length'`\")\n \n+    if force_unique_generate_call:\n+        sequences_list = []\n+        timestamps_list = []\n+        for segments in current_segments:\n+            result = segments[0][\"result\"]\n+            sequences_list.append(result if isinstance(result, torch.Tensor) else result[\"sequences\"])\n+            if return_token_timestamps:\n+                timestamps_list.append(result[\"token_timestamps\"])\n+\n+        sequences = torch.stack(sequences_list, dim=0)\n+        if return_token_timestamps:\n+            token_timestamps = torch.stack(timestamps_list, dim=0)\n+            return sequences, token_timestamps\n+        return sequences\n+\n     for current_segment_list in current_segments:\n         if current_segment_list is not None and len([d[\"tokens\"] for d in current_segment_list]) > 0:\n             sequence = torch.cat([d[\"tokens\"] for d in current_segment_list], dim=-1)\n+            if return_token_timestamps:\n+                token_timestamps = torch.cat(\n+                    [d[\"result\"][\"token_timestamps\"][d[\"idxs\"][0] : d[\"idxs\"][1]] for d in current_segment_list],\n+                    dim=-1,\n+                )\n \n             if cut_off_length is not None:\n                 sequence = sequence[-cut_off_length:]\n+                if return_token_timestamps:\n+                    token_timestamps = token_timestamps[-cut_off_length:]\n \n             if bos_token_tensor is not None:\n                 sequence = torch.cat([bos_token_tensor, sequence])\n-\n+                if return_token_timestamps:\n+                    token_timestamps = torch.cat(\n+                        [torch.ones_like(bos_token_tensor, device=device) * 0.0, token_timestamps]\n+                    )\n             sequences.append(sequence)\n+            if return_token_timestamps:\n+                token_timestamps_list.append(token_timestamps)\n             max_total_length = max(max_total_length, len(sequences[-1]))\n         elif bos_token_tensor is not None:\n             sequences.append(bos_token_tensor)\n+            if return_token_timestamps:\n+                token_timestamps_list.append(torch.ones_like(bos_token_tensor, device=device) * 0.0)\n         else:\n             sequences.append(torch.tensor([], device=device))\n+            if return_token_timestamps:\n+                token_timestamps_list.append(torch.tensor([], device=device))\n \n     max_total_length = cut_off_length + 1 if padding == \"max_length\" else max_total_length\n     for i in range(len(current_segments)):\n         pad_length = max_total_length - len(sequences[i])\n         pad = (0, pad_length) if padding_side == \"right\" else (pad_length, 0)\n+\n         sequences[i] = F.pad(sequences[i], pad=pad, value=pad_token_id)\n+        if return_token_timestamps:\n+            token_timestamps_list[i] = F.pad(\n+                token_timestamps_list[i],\n+                pad=pad,\n+                value=token_timestamps_list[i][-1] if len(token_timestamps_list[i]) > 0 else 0.0,\n+            )\n \n     sequences = torch.stack(sequences, dim=0)\n-    return sequences\n+\n+    if return_token_timestamps:\n+        token_timestamps = torch.stack(token_timestamps_list, dim=0)\n+        return sequences, token_timestamps\n+    else:\n+        return sequences\n \n \n class WhisperGenerationMixin(GenerationMixin):\n@@ -312,6 +358,7 @@ def generate(\n         return_token_timestamps: Optional[bool] = None,\n         return_segments: bool = False,\n         return_dict_in_generate: Optional[bool] = None,\n+        force_unique_generate_call: Optional[bool] = None,\n         **kwargs,\n     ):\n         \"\"\"\n@@ -432,27 +479,39 @@ def generate(\n                 Note that when doing long-form transcription, `return_dict_in_generate` can only be enabled when\n                 `return_segments` is set True. In this case the generation outputs of each segment is added to each\n                 segment.\n+            force_unique_generate_call (`bool`, *optional*):\n+                Whether to force a unique call to the underlying GenerationMixin's generate method. This is useful for assisted decoding and testing purposes to ensure\n+                that only one call to generate is made and therefore decoder input token ids and eos token ids are returned.\n             kwargs (`Dict[str, Any]`, *optional*):\n                 Ad hoc parametrization of `generate_config` and/or additional model-specific kwargs that will be\n                 forwarded to the `forward` function of the model. If the model is an encoder-decoder model, encoder\n                 specific kwargs should not be prefixed and decoder specific kwargs should be prefixed with *decoder_*.\n-\n         Return:\n-            [`~utils.ModelOutput`] or `torch.LongTensor` or `Dict[str, Any]`: A [`~utils.ModelOutput`] (if `return_dict_in_generate=True`\n-            or when `config.return_dict_in_generate=True`) or a `torch.FloatTensor` or a dict of segments when `return_segments=True`.\n+            [`~utils.ModelOutput`] or `Dict[str, Any]` or `torch.LongTensor`:\n \n-                If the passed input is > 30 seconds / > 3000 mel input features and `return_segments=True` then a dictionary of generated sequence ids, called `sequences` and a list of each generated segment is returned.\n+                A:\n+                - [`~utils.ModelOutput`] when `return_dict_in_generate=True` and (`return_timestamps=False` or `force_unique_generate_call=True`), including the decoder input ids and end of sequence id.\n+                - `Dict[str, Any]` when (`return_dict_in_generate=True` and `return_timestamps=True`) or `return_segments=True` or `return_token_timestamps=True`.\n+                - `torch.LongTensor` in all other cases, excluding the decoder input ids and end of sequence id.\n \n-                else if the passed input is <= 30 seconds / >= 3000 mel input features, the possible [`~utils.ModelOutput`] types are:\n+                The possible [`~utils.ModelOutput`] types are:\n+                - [`~utils.GenerateEncoderDecoderOutput`]\n+                - [`~utils.GenerateBeamEncoderDecoderOutput`]\n \n-                    - [`~generation.GenerateEncoderDecoderOutput`],\n-                    - [`~generation.GenerateBeamEncoderDecoderOutput`]\n+                `segments` is a list of lists (one list per batch element) of `segment`.\n+                A `segment` is a dictionary with keys `start`, `end`, `tokens`, `idxs`, and `result`.\n+                - `start`: the start timestamp of the segment.\n+                - `end`: the end timestamp of the segment.\n+                - `tokens`: the tokens of the segment, excluding the decoder input ids and end of sequence id.\n+                - `idxs`: the start (included) and end (excluded) indices of the `tokens` of the segment in the underlying call to GenerationMixin's `generate` (present in `result`).\n+                - `result`: the result of the underlying call to GenerationMixin's `generate`.\n \n-                else only the generated output sequence ids are returned.\n+                When `return_timestamps=True`, `return_dict_in_generate=True` applies to each call of the underlying GenerationMixin's `generate`, with outputs stored in `result` of each `segment`.\n \n         Example:\n \n-        - *Longform transcription*: To transcribe or translate audios longer than 30 seconds, process the audio files without truncation and pass all mel features at once to generate.\n+        - *Longform transcription*: To transcribe or translate audios longer than 30 seconds, process the audio files without truncation and pass all mel features at once to generate. It is necessary to set `return_timestamps=True`.\n+        Indeed, long-form transcription uses a sequential algorithm based on timestamps predictions, with heuristics like compression ratio threshold, log probability threshold and temperature fallback. This algorithm is described in the [the Whisper original paper](https://cdn.openai.com/papers/whisper.pdf), section *3.8. Long-form Transcription*.\n \n         ```python\n         >>> import torch\n@@ -483,7 +542,9 @@ def generate(\n         \" Folks, if you watch the show, you know, I spent a lot of time right over there. Patiently and astutely scrutinizing the boxwood and mahogany chest set of the day's biggest stories developing the central headline pawns, definitely maneuvering an oso topical night to F6, fainting a classic Sicilian, nade door variation on the news, all the while seeing eight moves deep and patiently marshalling the latest press releases into a fisher's shows in Lip Nitsky attack that culminates in the elegant lethal slow-played, all-passant checkmate that is my nightly monologue. But sometimes, sometimes, folks, I. CHEERING AND APPLAUSE Sometimes I startle away, cubside down in the monkey bars of a condemned playground on a super fun site. Get all hept up on goofballs. Rummage that were discarded tag bag of defective toys. Yank out a fist bowl of disembodied doll limbs, toss them on a stained kid's place mat from a defunct dennies. set up a table inside a rusty cargo container down by the Wharf and challenged toothless drifters to the godless bughouse blitz of tournament that is my segment. Meanwhile.\"\n         ```\n \n-        - *Shortform transcription*: If passed mel input features are < 30 seconds, the whole audio will be transcribed with a single call to generate.\n+        - *Shortform transcription*: If passed mel input features are <= 30 seconds, there are two possibilities:\n+            - `return_timestamps=False`: the whole audio will be transcribed with a single call to GenerationMixin's generate.\n+            - `return_timestamps=True`: the audio will be transcribed using the same logic as long-form transcription.\n \n         ```python\n         >>> import torch\n@@ -570,11 +631,21 @@ def generate(\n         # 3. Retrieve logits processors\n         device = kwargs[\"encoder_outputs\"][0].device if \"encoder_outputs\" in kwargs else input_features.device\n         begin_index = init_tokens.shape[1]\n+        num_beams = kwargs.get(\n+            \"num_beams\",\n+            generation_config.num_beams\n+            if hasattr(generation_config, \"num_beams\") and generation_config.num_beams is not None\n+            else 1,\n+        )\n+        if \"assistant_model\" in kwargs:\n+            # speculative decoding: the model should be able to return eos token\n+            generation_config.begin_suppress_tokens = None\n+\n         logits_processor = self._retrieve_logit_processors(\n             generation_config=generation_config,\n             logits_processor=logits_processor,\n             begin_index=begin_index,  # begin index is index of first generated decoder token\n-            num_beams=kwargs.get(\"num_beams\", 1),\n+            num_beams=num_beams,\n             device=device,\n         )\n \n@@ -618,6 +689,19 @@ def generate(\n             batch_size=cur_bsz,\n             generation_config=generation_config,\n         )\n+        # 5bis speculative decoding: ensure the assistant model does only one call to generate and therefore returns decoder input token ids and eos token id\n+        # we set a flag in the generation config to force the model to make only one call to generate and return the decoder input token ids and eos token id\n+        if \"assistant_model\" in kwargs:\n+            assistant_model = kwargs[\"assistant_model\"]\n+            assistant_model.generation_config.force_unique_generate_call = True\n+\n+        if force_unique_generate_call is None:\n+            if hasattr(generation_config, \"force_unique_generate_call\"):\n+                force_unique_generate_call = generation_config.force_unique_generate_call\n+            elif hasattr(self.generation_config, \"force_unique_generate_call\"):\n+                force_unique_generate_call = self.generation_config.force_unique_generate_call\n+            else:\n+                force_unique_generate_call = False\n \n         # 6 Transcribe audio until we reach the end of all input audios\n         while (seek < max_frames).any():\n@@ -729,14 +813,15 @@ def generate(\n                     prev_idx=prev_i,\n                     idx=i,\n                     return_token_timestamps=return_token_timestamps,\n+                    decoder_input_ids=decoder_input_ids,\n                 )\n \n+                seek[prev_i] += segment_offset\n+\n                 current_segments[prev_i] += segments\n \n-                if is_shortform:\n-                    seek[prev_i] += max_frames[i]\n-                else:\n-                    seek[prev_i] += segment_offset\n+            if force_unique_generate_call:\n+                break\n \n         # 7. Once all segments are added to the list of all segments, called `current_segments`, we extract the predicted\n         # output tokens from the list of dicts. If we use batch size > 1, we make sure to pad the output\n@@ -746,51 +831,62 @@ def generate(\n             else current_segments\n         )\n \n-        sequences = _pad_to_max_length(\n-            final_segments, generation_config.pad_token_id, device=self.device, padding_side=\"right\"\n-        )\n-\n-        # 8. If we return all segments, the predicted output sequences are put under `\"sequences\"`.\n-        if return_segments:\n-            return {\"sequences\": sequences, \"segments\": final_segments}\n-\n-        if is_shortform:\n-            # add eos token:\n-            if generation_config.max_new_tokens is None and generation_config.max_length is None:\n-                eos_tokens = torch.full((sequences.shape[0], 1), generation_config.eos_token_id)\n-                sequences = torch.cat([sequences, eos_tokens], dim=-1)\n+        # if return_dict_in_generate=True and we forced a unique call to generate or return_timestamps=False, meaning we are sure only one call to generate has been made,\n+        # -> we can return a ModelOutput\n+        # otherwise, return_dict_in_generate is applied in the 'result' of each segment in final_segments\n+        if (\n+            return_dict_in_generate\n+            and generation_config.return_dict_in_generate\n+            and (force_unique_generate_call or not return_timestamps)\n+        ):\n+            # only one call to generate_with_fallback, we can return a ModelOutput\n+            outputs = self._stack_split_outputs(seek_outputs, model_output_type, self.device, kwargs)\n+            if num_return_sequences > 1:\n+                if hasattr(outputs, \"encoder_attentions\") and outputs.encoder_attentions is not None:\n+                    outputs.encoder_attentions = tuple(\n+                        outputs.encoder_attentions[i][::num_return_sequences]\n+                        for i in range(len(outputs.encoder_attentions))\n+                    )\n+                if hasattr(outputs, \"encoder_hidden_states\") and outputs.encoder_hidden_states is not None:\n+                    outputs.encoder_hidden_states = tuple(\n+                        outputs.encoder_hidden_states[i][::num_return_sequences]\n+                        for i in range(len(outputs.encoder_hidden_states))\n+                    )\n+            return outputs\n \n-            if return_token_timestamps:\n-                outputs = {}\n-                outputs[\"sequences\"] = sequences\n-                outputs[\"token_timestamps\"] = torch.stack([d[\"token_timestamps\"] for d in seek_outputs], dim=0)\n-            else:\n-                outputs = sequences\n+        padded_outputs = _pad_to_max_length(\n+            current_segments=final_segments,\n+            pad_token_id=generation_config.pad_token_id,\n+            device=self.device,\n+            padding_side=\"right\",\n+            return_token_timestamps=return_token_timestamps,\n+            force_unique_generate_call=force_unique_generate_call,\n+        )\n \n-            if return_dict_in_generate and generation_config.return_dict_in_generate:\n-                dict_outputs = self._stack_split_outputs(seek_outputs, model_output_type, sequences.device, kwargs)\n+        if return_dict_in_generate and generation_config.return_dict_in_generate:\n+            logger.warning_once(\n+                \"You have passed `return_dict_in_generate=True` and `return_timestamps=True`, this automatically sets `return_segments=True` to access the resuls of the underlying calls to GenerationMixin's generate in the returned `segments`.\"\n+            )\n+            return_segments = True\n+        elif not return_segments and not return_token_timestamps:\n+            return padded_outputs\n \n-                if num_return_sequences > 1:\n-                    if hasattr(dict_outputs, \"encoder_attentions\") and dict_outputs.encoder_attentions is not None:\n-                        dict_outputs.encoder_attentions = tuple(\n-                            dict_outputs.encoder_attentions[i][::num_return_sequences]\n-                            for i in range(len(dict_outputs.encoder_attentions))\n-                        )\n-                    if (\n-                        hasattr(dict_outputs, \"encoder_hidden_states\")\n-                        and dict_outputs.encoder_hidden_states is not None\n-                    ):\n-                        dict_outputs.encoder_hidden_states = tuple(\n-                            dict_outputs.encoder_hidden_states[i][::num_return_sequences]\n-                            for i in range(len(dict_outputs.encoder_hidden_states))\n-                        )\n-                if return_token_timestamps:\n-                    dict_outputs[\"token_timestamps\"] = outputs[\"token_timestamps\"]\n-                return dict_outputs\n+        if return_token_timestamps:\n+            sequences, token_timestamps = padded_outputs\n+            outputs = {\n+                \"sequences\": sequences,\n+                \"token_timestamps\": token_timestamps,\n+            }\n+        else:\n+            sequences = padded_outputs\n+            outputs = {\n+                \"sequences\": sequences,\n+            }\n \n-            return outputs\n+        if return_segments:\n+            outputs[\"segments\"] = final_segments\n \n-        return sequences\n+        return outputs\n \n     def generate_with_fallback(\n         self,\n@@ -886,22 +982,14 @@ def generate_with_fallback(\n             new_decoder_attention_mask = []\n \n             for i, seek_sequence in enumerate(seek_sequences):\n-                # make sure we cut a predicted EOS token if we are not finished with the generation yet\n-                prev_i = batch_idx_map[fallback_index_map[i]]\n-                is_not_final = (seek[prev_i] + num_segment_frames) < max_frames[prev_i]\n-\n-                # remove eos token id\n-                if is_not_final and seek_sequence[-1] == generation_config.eos_token_id:\n-                    seek_sequence = seek_sequence[:-1]\n-                    if return_token_timestamps and not is_shortform:\n-                        seek_outputs[i][\"token_timestamps\"] = seek_outputs[i][\"token_timestamps\"][:-1]\n-\n-                # remove all padding tokens\n+                # remove all padding tokens, except for the eos token\n                 if seek_sequence[-1] == generation_config.pad_token_id:\n                     num_paddings = (seek_sequence == generation_config.pad_token_id).sum()\n-                    seek_sequence = seek_sequence[:-num_paddings]\n-                    if return_token_timestamps and not is_shortform:\n-                        seek_outputs[i][\"token_timestamps\"] = seek_outputs[i][\"token_timestamps\"][:-num_paddings]\n+                    if generation_config.pad_token_id == generation_config.eos_token_id:\n+                        # we do not remove the eos token id since it is needed for avg logprob calculation in _need_fallback\n+                        num_paddings -= 1\n+                    if num_paddings != 0:\n+                        seek_sequence = seek_sequence[:-num_paddings]\n \n                 # check which sequences in batch need fallback & which should be skipped\n                 needs_fallback[i], should_skip[i] = self._need_fallback(\n@@ -914,6 +1002,10 @@ def generate_with_fallback(\n                     temperature,\n                 )\n \n+                # remove eos token\n+                if seek_sequence[-1] == generation_config.eos_token_id:\n+                    seek_sequence = seek_sequence[:-1]\n+\n                 seek_sequence_list[fallback_index_map[i]] = seek_sequence\n                 seek_outputs_list[fallback_index_map[i]] = seek_outputs[i]\n                 is_low_temperature = temperature is None or temperature < 0.5\n@@ -956,14 +1048,19 @@ def _prepare_segments(prompt_ids, batch_size, generation_config):\n         return current_segments\n \n     def _postprocess_outputs(\n-        self, seek_outputs, decoder_input_ids, return_token_timestamps, generation_config, is_shortform\n+        self,\n+        seek_outputs,\n+        decoder_input_ids,\n+        return_token_timestamps,\n+        generation_config,\n+        is_shortform,\n     ):\n         # remove all previously passed decoder input ids\n-        start_idx = decoder_input_ids.shape[-1] if not is_shortform else torch.tensor(0)\n+        # should happen only if it is the first generated segment\n+        start_idx = decoder_input_ids.shape[-1]\n \n         if isinstance(seek_outputs, torch.Tensor):\n-            seek_outputs = seek_outputs[:, start_idx:]\n-            return seek_outputs, seek_outputs\n+            return seek_outputs[:, start_idx:], seek_outputs\n \n         if return_token_timestamps and hasattr(generation_config, \"alignment_heads\"):\n             num_frames = getattr(generation_config, \"num_frames\", None)\n@@ -973,9 +1070,6 @@ def _postprocess_outputs(\n                 num_frames=num_frames,\n                 num_input_ids=decoder_input_ids.shape[-1],\n             )\n-            seek_outputs[\"token_timestamps\"] = seek_outputs[\"token_timestamps\"][:, start_idx:]\n-\n-        seek_outputs[\"sequences\"] = seek_outputs[\"sequences\"][:, start_idx:]\n \n         def split_by_batch_index(values, key, batch_idx, is_shortform, beam_indices=None):\n             if beam_indices is not None and key == \"scores\":\n@@ -1011,7 +1105,7 @@ def split_by_batch_index(values, key, batch_idx, is_shortform, beam_indices=None\n \n             return values[batch_idx].cpu()\n \n-        sequence_tokens = seek_outputs[\"sequences\"]\n+        sequence_tokens = seek_outputs[\"sequences\"][:, start_idx:]\n         seek_outputs = [\n             {\n                 k: split_by_batch_index(v, k, i, is_shortform, beam_indices=seek_outputs.get(\"beam_indices\"))\n@@ -1026,7 +1120,7 @@ def _stack_split_outputs(self, seek_outputs, model_output_type, device, kwargs):\n         # Stack back seek_outputs tensors after splitting them with the split_by_batch_index method\n         outputs = {}\n         for key in seek_outputs[0].keys():\n-            if key in [\"sequences\", \"beam_indices\"]:\n+            if key in [\"sequences\", \"beam_indices\", \"token_timestamps\"]:\n                 outputs[key] = torch.stack([v[key] for v in seek_outputs], dim=0).to(device)\n             elif key in [\"scores\", \"encoder_attentions\", \"encoder_hidden_states\", \"logits\"]:\n                 outputs[key] = tuple(\n@@ -1057,6 +1151,10 @@ def _stack_split_outputs(self, seek_outputs, model_output_type, device, kwargs):\n                 else:\n                     outputs[key] = None\n \n+        token_timestamps = outputs.get(\"token_timestamps\", None)\n+        if token_timestamps is not None:\n+            model_output_type = dict\n+\n         return model_output_type(**outputs)\n \n     def _need_fallback(\n@@ -1083,7 +1181,9 @@ def _need_fallback(\n             else:\n                 scores = seek_outputs[index][\"scores\"]\n                 logprobs = self._retrieve_avg_logprobs(\n-                    scores, seek_sequence, generation_config.eos_token_id, temperature\n+                    scores,\n+                    seek_sequence,\n+                    temperature,\n                 )\n \n             if logprobs < generation_config.logprob_threshold:\n@@ -1179,13 +1279,6 @@ def _maybe_warn_unused_inputs(\n         if no_speech_threshold is not None:\n             logger.warning(warning_prefix.format(f\"no_speech_threshold is set to {no_speech_threshold}\"))\n \n-        # when passing temperature as a list it cannot just be ignored => throw error in this case\n-        if isinstance(temperature, (list, tuple)):\n-            raise ValueError(\n-                f\"Audio input consists of only {total_input_frames}. Short-form transcription is activated.\"\n-                f\"temperature cannot be set to {temperature} which can only be used for temperature fallback for long-form generation. Make sure to set `temperature` to a float value or `None` for short-form generation.\"\n-            )\n-\n     @staticmethod\n     def _set_return_outputs(return_dict_in_generate, return_token_timestamps, logprob_threshold, generation_config):\n         if return_dict_in_generate is None:\n@@ -1768,7 +1861,7 @@ def _retrieve_compression_ratio(tokens, vocab_size):\n         return compression_ratio\n \n     @staticmethod\n-    def _retrieve_avg_logprobs(scores, tokens, eos_token_id, temperature):\n+    def _retrieve_avg_logprobs(scores, tokens, temperature):\n         rescale_temperature = temperature if temperature > 0.0 else 1\n         scores = torch.stack(scores).to(tokens.device)\n \n@@ -1780,10 +1873,10 @@ def _retrieve_avg_logprobs(scores, tokens, eos_token_id, temperature):\n         logprobs = F.log_softmax((scores * rescale_temperature).float(), dim=-1).to(scores.dtype)\n \n         # retrieve logprob of selected tokens and sum\n-        sum_logprobs = sum((logprobs[i][tokens[i]] * (tokens[i] != eos_token_id)) for i in range(logprobs.shape[0]))\n-        length = (tokens != eos_token_id).sum(-1) if eos_token_id is not None else tokens.shape[0]\n+        # don't remove the eos token logprob! it counts in avg_logprob calculation in the original implementation\n+        sum_logprobs = sum(logprobs[i][tokens[i]] for i in range(logprobs.shape[0]))\n \n-        avg_logprobs = sum_logprobs / (length + 1)\n+        avg_logprobs = sum_logprobs / len(tokens)\n         return avg_logprobs\n \n     @staticmethod\n@@ -1799,6 +1892,7 @@ def _retrieve_segment(\n         prev_idx,\n         idx,\n         return_token_timestamps,\n+        decoder_input_ids,\n     ):\n         # find the predicted \"end of segment\" predictions of Whisper\n         # \"end of segment\" predictions occur whenever Whisper predicts a timestamp token\n@@ -1807,6 +1901,7 @@ def _retrieve_segment(\n         timestamp_segment_indices = torch.where(timestamp_tokens[:-1] & timestamp_tokens[1:])[0]\n         timestamp_segment_indices.add_(1)\n         token_timestamps = seek_outputs[idx][\"token_timestamps\"] if return_token_timestamps else []\n+        idx_offset = decoder_input_ids.shape[-1]\n         device = seek_sequence.device\n \n         # If whisper predicted a \"end of segment\" via a timestep token, let's go ever each\n@@ -1838,12 +1933,13 @@ def _retrieve_segment(\n                         + end_timestamp_pos.to(torch.float32 if device.type == \"mps\" else torch.float64)\n                         * time_precision,\n                         \"tokens\": sliced_tokens,\n+                        \"idxs\": (idx_offset + last_slice, idx_offset + current_slice),\n                         \"result\": seek_outputs[idx],\n                     }\n                 )\n                 if return_token_timestamps:\n                     segments[-1][\"token_timestamps\"] = (\n-                        token_timestamps[last_slice:current_slice] + time_offset[prev_idx]\n+                        token_timestamps[idx_offset + last_slice : idx_offset + current_slice] + time_offset[prev_idx]\n                     )\n                 last_slice = current_slice\n \n@@ -1871,11 +1967,14 @@ def _retrieve_segment(\n                     \"start\": time_offset[prev_idx],\n                     \"end\": time_offset[prev_idx] + last_timestamp_pos * time_precision,\n                     \"tokens\": seek_sequence,\n+                    \"idxs\": (idx_offset, idx_offset + len(seek_sequence)),\n                     \"result\": seek_outputs[idx],\n                 }\n             ]\n             if return_token_timestamps:\n-                segments[-1][\"token_timestamps\"] = token_timestamps + time_offset[prev_idx]\n+                segments[-1][\"token_timestamps\"] = (\n+                    token_timestamps[idx_offset : idx_offset + len(seek_sequence)] + time_offset[prev_idx]\n+                )\n             segment_offset = seek_num_frames[prev_idx]\n \n         return segments, segment_offset"
        },
        {
            "sha": "504b6174fc52ad816c69a350442c84d5f7c35ce7",
            "filename": "tests/models/whisper/test_modeling_tf_whisper.py",
            "status": "modified",
            "additions": 51,
            "deletions": 14,
            "changes": 65,
            "blob_url": "https://github.com/huggingface/transformers/blob/da334bcfa8ff7feb85138ce90ca7340e4fc6e704/tests%2Fmodels%2Fwhisper%2Ftest_modeling_tf_whisper.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/da334bcfa8ff7feb85138ce90ca7340e4fc6e704/tests%2Fmodels%2Fwhisper%2Ftest_modeling_tf_whisper.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fwhisper%2Ftest_modeling_tf_whisper.py?ref=da334bcfa8ff7feb85138ce90ca7340e4fc6e704",
            "patch": "@@ -17,14 +17,22 @@\n from __future__ import annotations\n \n import inspect\n+import os\n import tempfile\n import traceback\n import unittest\n \n import numpy as np\n \n-from transformers import WhisperConfig, WhisperFeatureExtractor, WhisperProcessor\n-from transformers.testing_utils import is_tf_available, require_tf, require_tokenizers, run_test_in_subprocess, slow\n+from transformers import GenerationConfig, WhisperConfig, WhisperFeatureExtractor, WhisperProcessor\n+from transformers.testing_utils import (\n+    is_tf_available,\n+    require_read_token,\n+    require_tf,\n+    require_tokenizers,\n+    run_test_in_subprocess,\n+    slow,\n+)\n from transformers.utils import cached_property\n from transformers.utils.import_utils import is_datasets_available\n \n@@ -749,7 +757,9 @@ def _test_large_generation(in_queue, out_queue, timeout):\n         input_features = processor.feature_extractor(raw_speech=input_speech, return_tensors=\"tf\").input_features\n \n         generated_ids = model.generate(\n-            input_features, do_sample=False, max_length=20, language=\"<|en|>\", task=\"transcribe\"\n+            input_features,\n+            do_sample=False,\n+            max_length=20,\n         )\n         transcript = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]\n \n@@ -772,29 +782,55 @@ def _test_large_generation_multilingual(in_queue, out_queue, timeout):\n         processor = WhisperProcessor.from_pretrained(\"openai/whisper-large\")\n         model = TFWhisperForConditionalGeneration.from_pretrained(\"openai/whisper-large\")\n \n-        ds = load_dataset(\"legacy-datasets/common_voice\", \"ja\", split=\"test\", streaming=True, trust_remote_code=True)\n+        # update generation config\n+        generation_config = GenerationConfig.from_pretrained(\"openai/whisper-large-v2\")\n+\n+        token = os.getenv(\"HF_HUB_READ_TOKEN\", True)\n+        ds = load_dataset(\n+            \"mozilla-foundation/common_voice_6_1\",\n+            \"ja\",\n+            split=\"test\",\n+            streaming=True,\n+            trust_remote_code=True,\n+            token=token,\n+        )\n         ds = ds.cast_column(\"audio\", datasets.Audio(sampling_rate=16_000))\n         input_speech = next(iter(ds))[\"audio\"][\"array\"]\n         input_features = processor.feature_extractor(raw_speech=input_speech, return_tensors=\"tf\").input_features\n \n         generated_ids = model.generate(\n-            input_features, do_sample=False, max_length=20, language=\"<|ja|>\", task=\"transcribe\"\n+            input_features,\n+            do_sample=False,\n+            max_length=20,\n+            language=\"<|ja|>\",\n+            task=\"transcribe\",\n+            generation_config=generation_config,\n         )\n         transcript = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]\n \n         EXPECTED_TRANSCRIPT = \"Êú®Êùë„Åï„Çì„Å´ÈõªË©±„ÇíË≤∏„Åó„Å¶„ÇÇ„Çâ„ÅÑ„Åæ„Åó„Åü\"\n         unittest.TestCase().assertEqual(transcript, EXPECTED_TRANSCRIPT)\n \n         generated_ids = model.generate(\n-            input_features, do_sample=False, max_length=20, language=\"<|en|>\", task=\"transcribe\"\n+            input_features,\n+            do_sample=False,\n+            max_length=20,\n+            language=\"<|en|>\",\n+            task=\"transcribe\",\n+            generation_config=generation_config,\n         )\n         transcript = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]\n \n         EXPECTED_TRANSCRIPT = \" Kimura-san called me.\"\n         unittest.TestCase().assertEqual(transcript, EXPECTED_TRANSCRIPT)\n \n         generated_ids = model.generate(\n-            input_features, do_sample=False, max_length=20, language=\"<|ja|>\", task=\"translate\"\n+            input_features,\n+            do_sample=False,\n+            max_length=20,\n+            language=\"<|ja|>\",\n+            task=\"translate\",\n+            generation_config=generation_config,\n         )\n         transcript = processor.batch_decode(generated_ids, skip_special_tokens=True)[0]\n \n@@ -825,21 +861,21 @@ def _test_large_batched_generation(in_queue, out_queue, timeout):\n \n         # fmt: off\n         EXPECTED_IDS = [\n-            [50258, 50358, 50363, 2221, 13, 2326, 388, 391, 307, 264, 50244, 295, 264, 2808, 5359, 293, 321, 366, 5404, 281],\n-            [50258, 50358, 50363, 6966, 307, 2221, 13, 2326, 388, 391, 311, 9060, 1570, 1880, 813, 702, 1871, 13, 50257, 50257],\n-            [50258, 50358, 50363, 634, 5112, 505, 300, 412, 341, 42729, 3196, 295, 264, 1064, 11, 365, 5272, 293, 12904, 9256],\n-            [50258, 50358, 50363, 634, 575, 12525, 22618, 1968, 6144, 35617, 20084, 1756, 311, 589, 307, 534, 10281, 934, 439, 11]\n+            [50258, 50259, 50359, 50363, 2221, 13, 2326, 388, 391, 307, 264, 50244, 295, 264, 2808, 5359, 293, 321, 366, 5404],\n+            [50258, 50259, 50359, 50363, 6966, 307, 2221, 13, 2326, 388, 391, 311, 9060, 1570, 1880, 813, 702, 1871, 13, 50257],\n+            [50258, 50259, 50359, 50363, 634, 5112, 505, 300, 412, 341, 42729, 3196, 295, 264, 1064, 11, 365, 5272, 293, 12904],\n+            [50258, 50259, 50359, 50363, 634, 575, 12525, 22618, 1968, 6144, 35617, 20084, 1756, 311, 589, 307, 534, 10281, 934, 439]\n         ]\n         # fmt: on\n \n         unittest.TestCase().assertEqual(generated_ids.tolist(), EXPECTED_IDS)\n \n         # fmt: off\n         EXPECTED_TRANSCRIPT = [\n-            \" Mr. Quilter is the apostle of the middle classes and we are glad to\",\n+            \" Mr. Quilter is the apostle of the middle classes and we are glad\",\n             \" Nor is Mr. Quilter's manner less interesting than his matter.\",\n-            \" He tells us that at this festive season of the year, with Christmas and roast beef\",\n-            \" He has grave doubts whether Sir Frederick Layton's work is really Greek after all,\"\n+            \" He tells us that at this festive season of the year, with Christmas and roast\",\n+            \" He has grave doubts whether Sir Frederick Layton's work is really Greek after all\"\n         ]\n         # fmt: on\n \n@@ -1009,6 +1045,7 @@ def test_large_generation(self):\n         run_test_in_subprocess(test_case=self, target_func=_test_large_generation, inputs=None)\n \n     @slow\n+    @require_read_token\n     def test_large_generation_multilingual(self):\n         run_test_in_subprocess(test_case=self, target_func=_test_large_generation_multilingual, inputs=None)\n "
        },
        {
            "sha": "2eff406a3b56fce78083e69209a1cbac97251951",
            "filename": "tests/models/whisper/test_modeling_whisper.py",
            "status": "modified",
            "additions": 24,
            "deletions": 13,
            "changes": 37,
            "blob_url": "https://github.com/huggingface/transformers/blob/da334bcfa8ff7feb85138ce90ca7340e4fc6e704/tests%2Fmodels%2Fwhisper%2Ftest_modeling_whisper.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/da334bcfa8ff7feb85138ce90ca7340e4fc6e704/tests%2Fmodels%2Fwhisper%2Ftest_modeling_whisper.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fwhisper%2Ftest_modeling_whisper.py?ref=da334bcfa8ff7feb85138ce90ca7340e4fc6e704",
            "patch": "@@ -445,6 +445,11 @@ def setUp(self):\n         self.config_tester = ConfigTester(self, config_class=WhisperConfig)\n         self.maxDiff = 3000\n \n+    def prepare_config_and_inputs_for_generate(self, batch_size=2):\n+        config, inputs_dict = super().prepare_config_and_inputs_for_generate(batch_size=batch_size)\n+        inputs_dict[\"force_unique_generate_call\"] = True\n+        return config, inputs_dict\n+\n     def test_config(self):\n         self.config_tester.run_common_tests()\n \n@@ -1891,8 +1896,8 @@ def test_large_batched_generation_multilingual(self):\n             \"ja\",\n             split=\"test\",\n             streaming=True,\n-            token=token,\n             trust_remote_code=True,\n+            token=token,\n         )\n         ds = ds.cast_column(\"audio\", datasets.Audio(sampling_rate=16_000))\n \n@@ -2144,11 +2149,16 @@ def test_small_longform_timestamps_generation(self):\n             },\n             {\n                 \"text\": \" He has grave doubts whether Sir Frederick Layton's work is really Greek after all and\",\n-                \"timestamp\": (39.80, 45.36),\n+                # \"timestamp\": (39.80, 45.36),\n+                # above is the expected output on A100.\n+                # on CI T4s, due to sligth difference in floating points operations, expected is below\n+                \"timestamp\": (39.80, 45.38),\n             },\n             {\n                 \"text\": \" can discover in it but little of rocky Ithaca.\",\n-                \"timestamp\": (45.36, 49.0),\n+                # \"timestamp\": (45.36, 49.0),\n+                # see above\n+                \"timestamp\": (45.38, 49.0),\n             },\n             {\n                 \"text\": \" Lenell's pictures are a sort of up-guards-and-atom paintings, and Mason's exquisite ittles\",\n@@ -2275,20 +2285,20 @@ def test_tiny_token_timestamp_generation(self):\n \n         # fmt: off\n         EXPECTED_OUTPUT = torch.tensor([\n-            [0.0000, 0.4800, 0.8200, 0.9600, 1.1200, 1.1200, 1.2200, 1.5000, 1.7200, 2.0000, 2.3400, 2.5000, 2.6600, 3.1800, 3.5600, 3.6800, 3.8000, 4.1000, 4.3000, 4.5800, 4.9400, 5.3800, 12.4200, 12.8400, 26.9200, 26.9200, 26.9200, 26.9200, 26.9200, 26.9200, 26.9200, 26.9200, 26.9200, 26.9200, 26.9200, 26.9400, 26.9400, 26.9400, 26.9400],\n-            [0.0000, 0.5200, 0.9000, 1.1400, 1.4200, 1.5200, 1.6800, 1.6800, 1.8800, 2.1000, 2.2200, 2.6200, 3.1400, 3.5800, 3.9600, 4.4000, 17.3000, 17.3000, 26.7200, 26.7200, 26.7200, 26.7200, 26.7200, 26.7200, 26.7200, 26.7200, 26.7200, 26.7200, 26.7200, 26.7200, 26.7200, 26.7200, 26.7200, 26.7400, 26.7400, 26.7400, 26.7400, 26.7400, 26.7400],\n+            [0.0000, 0.4800, 0.8200, 0.9600, 1.1200, 1.1200, 1.2200, 1.5000, 1.7200, 2.0000, 2.3400, 2.5000, 2.6600, 3.1800, 3.5600, 3.6800, 3.8000, 4.1000, 4.3000, 4.5800, 4.9400, 5.3800, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200, 12.4200],\n+            [0.0000, 0.5200, 0.9000, 1.1400, 1.4200, 1.5200, 1.6800, 1.6800, 1.8800, 2.1000, 2.2200, 2.6200, 3.1400, 3.5800, 3.9600, 4.4000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000, 17.3000],\n             [0.0000, 0.0000, 0.7600, 1.0000, 1.4200, 1.8000, 1.9400, 2.1800, 2.5200, 3.0200, 3.3200, 3.5400, 3.9400, 4.5600, 4.9200, 5.2800, 5.5600, 5.9000, 6.1600, 6.3000, 6.4800, 6.4800, 6.6400, 7.8200, 7.9600, 8.2200, 8.6000, 8.9200, 9.2200, 9.5200, 9.7200, 10.0600, 10.5400, 10.8800, 11.2600, 11.5400, 11.7400, 12.0800, 15.6800],\n-            [0.0000, 0.0000, 0.7400, 1.0400, 1.3200, 1.6800, 2.1400, 2.4800, 2.7800, 3.0800, 3.1600, 3.4000, 3.6000, 4.0200, 4.2200, 4.8600, 5.2400, 5.7400, 6.3400, 6.6200, 6.7600, 6.7600, 6.8600, 7.2400, 7.4200, 7.6800, 7.9200, 8.4800, 8.7600, 9.2000, 9.2000, 9.4200, 15.8200, 15.8200, 29.6400, 29.6600, 29.6600, 29.6600, 29.6600]\n+            [0.0000, 0.0000, 0.7400, 1.0400, 1.3200, 1.6800, 2.1400, 2.4800, 2.7800, 3.0800, 3.1600, 3.4000, 3.6000, 4.0200, 4.2200, 4.8600, 5.2400, 5.7400, 6.3400, 6.6200, 6.7600, 6.7600, 6.8600, 7.2400, 7.4200, 7.6800, 7.9200, 8.4800, 8.7600, 9.2000, 9.2000, 9.4200, 15.8200, 15.8200, 15.8200, 15.8200, 15.8200, 15.8200, 15.8200]\n         ])\n         # fmt: on\n \n         self.assertTrue(torch.allclose(generate_outputs[\"token_timestamps\"].to(\"cpu\"), EXPECTED_OUTPUT))\n \n     @slow\n-    def test_large_token_timestamp_generation(self):\n+    def test_small_token_timestamp_generation(self):\n         set_seed(0)\n-        processor = WhisperProcessor.from_pretrained(\"openai/whisper-large-v3\")\n-        model = WhisperForConditionalGeneration.from_pretrained(\"openai/whisper-large-v3\")\n+        processor = WhisperProcessor.from_pretrained(\"openai/whisper-small\")\n+        model = WhisperForConditionalGeneration.from_pretrained(\"openai/whisper-small\")\n         model.to(torch_device)\n \n         input_speech = self._load_datasamples(4)\n@@ -2305,10 +2315,10 @@ def test_large_token_timestamp_generation(self):\n \n         # fmt: off\n         EXPECTED_OUTPUT = torch.tensor([\n-            [0.0000, 0.0000,  0.6200,  0.7400,  0.8600, 1.0000,  1.0400,  1.3000,  1.4400,  1.7800,  2.1800,  2.2800,  2.5000, 2.9200,  3.0000,  3.3800,  3.5000,  3.6000,  3.8400,  4.1000,  4.4000, 4.6800,  5.1400,  5.3600,  5.8200,  5.8200,  5.8200,  5.8200,  5.8200, 5.8200,  5.8200,  5.8200,  5.8200,  5.8200,  5.8200,  5.8200,  5.8200],\n-            [0.0000, 0.0000,  0.6000,  0.9200,  1.2200, 1.3400,  1.4200,  1.5400,  1.5800,  1.7400,  2.0600,  2.3800,  3.0400, 3.3800,  3.6400,  4.1200,  4.3600,  4.7800,  4.7800,  4.7800,  4.7800, 4.7800,  4.7800,  4.7800,  4.7800,  4.7800,  4.7800,  4.7800,  4.7800, 4.7800,  4.7800,  4.7800,  4.7800,  4.7800,  4.7800,  4.7800,  4.7800],\n-            [0.0000, 0.0000,  0.5400,  0.8200,  1.1600, 1.4600,  1.7400,  1.8800,  2.3400,  2.7400,  3.1400,  3.2200,  3.5400, 4.2800,  4.5600,  4.8200,  5.0600,  5.3200,  5.6600,  5.9600,  6.1400, 6.4000,  6.8400,  7.8800,  8.0200,  8.3600,  8.7000,  9.0200,  9.3200, 9.5000,  9.8400, 10.3000, 10.6600, 11.0800, 11.3600, 11.4600, 11.8000],\n-            [0.0000, 0.0000,  0.5600,  0.7600,  1.0600, 1.4000,  1.8800,  2.2600,  2.6200,  2.8000,  2.9600,  3.0000,  3.2000, 3.4400,  3.6800,  4.0000,  4.6000,  5.0000,  5.3200,  5.4800,  6.0600, 6.0600,  6.1000,  6.3200,  6.7400,  7.0000,  7.2200,  7.4000,  7.7600, 8.0600,  8.5600,  8.8600,  8.9400,  9.1000,  9.3400,  9.8800,  9.8800]\n+            [0.0000, 0.0000, 0.7400, 0.8000, 0.9800, 1.0200, 1.1400, 1.4000, 1.5200, 1.9200, 2.2600, 2.3800, 2.5400, 2.8600, 3.2600, 3.3400, 3.4400, 3.6000, 3.6800, 3.9200, 4.2000, 4.4800, 4.7800, 5.2600, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200, 5.8200],\n+            [0.0000, 0.0000, 0.7600, 1.0000, 1.3000, 1.3800, 1.5200, 1.5800, 1.7000, 1.8400, 2.1000, 2.5000, 3.1400, 3.4400, 3.7400, 4.1800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800, 4.7800],\n+            [0.0000, 0.0000, 0.6600, 0.9000, 1.2200, 1.5200, 1.7600, 2.0200, 2.4000, 2.9200, 3.1800, 3.3200, 3.6200, 4.1000, 4.3600, 4.7800, 5.1200, 5.3400, 5.7200, 6.0600, 6.2000, 6.2000, 6.2000, 6.5000, 6.9000, 7.6400, 8.0000, 8.2400, 8.5200, 8.7400, 9.0800, 9.4000, 9.5400, 9.9400, 10.4200, 10.7600, 11.1200, 11.4400, 11.5800, 11.8600, 12.4600],\n+            [0.0000, 0.0000, 0.6600, 0.8600, 1.1400, 1.5000, 1.9600, 2.3600, 2.6400, 2.9800, 3.1200, 3.2400, 3.4800, 3.7800, 4.1400, 4.6400, 5.0800, 5.4400, 6.2200, 6.2200, 6.2200, 6.4000, 6.8400, 7.1200, 7.2600, 7.4800, 7.8200, 8.1400, 8.7000, 9.0200, 9.0200, 9.2000, 9.8800, 9.8800, 9.8800, 9.8800, 9.8800, 9.8800, 9.8800, 9.8800, 9.8800]\n         ])\n         # fmt: on\n \n@@ -3331,6 +3341,7 @@ def test_tiny_static_generation_long_form(self):\n \n         # only permit 4 compilations: 2 prefill steps and 2 decoding steps (1 for each of conditioned/not conditioned)\n         torch._dynamo.config.cache_size_limit = 4\n+        torch._dynamo.reset()\n \n         processor = WhisperProcessor.from_pretrained(\"openai/whisper-tiny.en\")\n         model = WhisperForConditionalGeneration.from_pretrained(\"openai/whisper-tiny.en\")"
        }
    ],
    "stats": {
        "total": 389,
        "additions": 268,
        "deletions": 121
    }
}