{
    "author": "jiqing-feng",
    "message": "Enable BNB multi-backend support (#31098)\n\n* enable cpu bnb path\r\n\r\n* fix style\r\n\r\n* fix code style\r\n\r\n* fix 4 bit path\r\n\r\n* Update src/transformers/utils/import_utils.py\r\n\r\nCo-authored-by: Aarni Koskela <akx@iki.fi>\r\n\r\n* add multi backend refactor tests\r\n\r\n* fix style\r\n\r\n* tweak 4bit quantizer + fix corresponding tests\r\n\r\n* tweak 8bit quantizer + *try* fixing corresponding tests\r\n\r\n* fix dequant bnb 8bit\r\n\r\n* account for Intel CPU in variability of expected outputs\r\n\r\n* enable cpu and xpu device map\r\n\r\n* further tweaks to account for Intel CPU\r\n\r\n* fix autocast to work with both cpu + cuda\r\n\r\n* fix comments\r\n\r\n* fix comments\r\n\r\n* switch to testing_utils.torch_device\r\n\r\n* allow for xpu in multi-gpu tests\r\n\r\n* fix tests 4bit for CPU NF4\r\n\r\n* fix bug with is_torch_xpu_available needing to be called as func\r\n\r\n* avoid issue where test reports attr err due to other failure\r\n\r\n* fix formatting\r\n\r\n* fix typo from resolving of merge conflict\r\n\r\n* polish based on last PR review\r\n\r\nCo-authored-by: Marc Sun <57196510+SunMarc@users.noreply.github.com>\r\n\r\n* fix CI\r\n\r\n* Update src/transformers/integrations/integration_utils.py\r\n\r\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>\r\n\r\n* Update src/transformers/integrations/integration_utils.py\r\n\r\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>\r\n\r\n* fix error log\r\n\r\n* fix error msg\r\n\r\n* add \\n in error log\r\n\r\n* make quality\r\n\r\n* rm bnb cuda restriction in doc\r\n\r\n* cpu model don't need dispatch\r\n\r\n* fix doc\r\n\r\n* fix style\r\n\r\n* check cuda avaliable in testing\r\n\r\n* fix tests\r\n\r\n* Update docs/source/en/model_doc/chameleon.md\r\n\r\nCo-authored-by: Marc Sun <57196510+SunMarc@users.noreply.github.com>\r\n\r\n* Update docs/source/en/model_doc/llava_next.md\r\n\r\nCo-authored-by: Aarni Koskela <akx@iki.fi>\r\n\r\n* Update tests/quantization/bnb/test_4bit.py\r\n\r\nCo-authored-by: Aarni Koskela <akx@iki.fi>\r\n\r\n* Update tests/quantization/bnb/test_4bit.py\r\n\r\nCo-authored-by: Aarni Koskela <akx@iki.fi>\r\n\r\n* fix doc\r\n\r\n* fix check multibackends\r\n\r\n* fix import sort\r\n\r\n* remove check torch in bnb\r\n\r\n* docs: update bitsandbytes references with multi-backend info\r\n\r\n* docs: fix small mistakes in bnb paragraph\r\n\r\n* run formatting\r\n\r\n* reveret bnb check\r\n\r\n* move bnb multi-backend check to import_utils\r\n\r\n* Update src/transformers/utils/import_utils.py\r\n\r\nCo-authored-by: Aarni Koskela <akx@iki.fi>\r\n\r\n* fix bnb check\r\n\r\n* minor fix for bnb\r\n\r\n* check lib first\r\n\r\n* fix code style\r\n\r\n* Revert \"run formatting\"\r\n\r\nThis reverts commit ac108c6d6b34f45a5745a736ba57282405cfaa61.\r\n\r\n* fix format\r\n\r\n* give warning when bnb version is low and no cuda found]\r\n\r\n* fix device assignment check to be multi-device capable\r\n\r\n* address akx feedback on get_avlbl_dev fn\r\n\r\n* revert partially, as we don't want the function that public, as docs would be too much (enforced)\r\n\r\n---------\r\n\r\nCo-authored-by: Aarni Koskela <akx@iki.fi>\r\nCo-authored-by: Titus von Koeller <9048635+Titus-von-Koeller@users.noreply.github.com>\r\nCo-authored-by: Marc Sun <57196510+SunMarc@users.noreply.github.com>\r\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>",
    "sha": "11c27dd331151e7d2ac20016cce11d9d7c4b1756",
    "files": [
        {
            "sha": "9d3d8ad6ba8b861cda2121702ced04c9f9183517",
            "filename": "docs/source/en/llm_tutorial_optimization.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fllm_tutorial_optimization.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fllm_tutorial_optimization.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fllm_tutorial_optimization.md?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -181,7 +181,7 @@ for every matrix multiplication. Dequantization and re-quantization is performed\n \n Therefore, inference time is often **not** reduced when using quantized weights, but rather increases.\n Enough theory, let's give it a try! To quantize the weights with Transformers, you need to make sure that\n-the [`bitsandbytes`](https://github.com/TimDettmers/bitsandbytes) library is installed.\n+the [`bitsandbytes`](https://github.com/bitsandbytes-foundation/bitsandbytes) library is installed.\n \n ```bash\n !pip install bitsandbytes"
        },
        {
            "sha": "2fa9c1db866c7ea2574824d6871ec7fe742bef4f",
            "filename": "docs/source/en/model_doc/chameleon.md",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_doc%2Fchameleon.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_doc%2Fchameleon.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fchameleon.md?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -128,7 +128,17 @@ processor.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokeniza\n \n ### Quantization using Bitsandbytes\n \n-The model can be loaded in 8 or 4 bits, greatly reducing the memory requirements while maintaining the performance of the original model. First make sure to install bitsandbytes, `pip install bitsandbytes` and make sure to have access to a CUDA compatible GPU device. Simply change the snippet above with:\n+The model can be loaded in 8 or 4 bits, greatly reducing the memory requirements while maintaining the performance of the original model. First make sure to install bitsandbytes, `pip install bitsandbytes` and to have access to a GPU/accelerator that is supported by the library.\n+\n+<Tip>\n+\n+bitsandbytes is being refactored to support multiple backends beyond CUDA. Currently, ROCm (AMD GPU) and Intel CPU implementations are mature, with Intel XPU in progress and Apple Silicon support expected by Q4/Q1. For installation instructions and the latest backend updates, visit [this link](https://huggingface.co/docs/bitsandbytes/main/en/installation#multi-backend).\n+\n+We value your feedback to help identify bugs before the full release! Check out [these docs](https://huggingface.co/docs/bitsandbytes/main/en/non_cuda_backends) for more details and feedback links.\n+\n+</Tip>\n+\n+Simply change the snippet above with:\n \n ```python\n from transformers import ChameleonForConditionalGeneration, BitsAndBytesConfig"
        },
        {
            "sha": "f04827cc7d5f74780a1f0c29811655267b91d0ec",
            "filename": "docs/source/en/model_doc/llava_next.md",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_doc%2Fllava_next.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_doc%2Fllava_next.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fllava_next.md?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -233,7 +233,17 @@ processor.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokeniza\n \n ### Quantization using Bitsandbytes\n \n-The model can be loaded in 8 or 4 bits, greatly reducing the memory requirements while maintaining the performance of the original model. First make sure to install bitsandbytes, `pip install bitsandbytes` and make sure to have access to a CUDA compatible GPU device. Simply change the snippet above with:\n+The model can be loaded in 8 or 4 bits, greatly reducing the memory requirements while maintaining the performance of the original model. First make sure to install bitsandbytes, `pip install bitsandbytes`, and to have access to a GPU/accelerator that is supported by the library.\n+\n+<Tip>\n+\n+bitsandbytes is being refactored to support multiple backends beyond CUDA. Currently, ROCm (AMD GPU) and Intel CPU implementations are mature, with Intel XPU in progress and Apple Silicon support expected by Q4/Q1. For installation instructions and the latest backend updates, visit [this link](https://huggingface.co/docs/bitsandbytes/main/en/installation#multi-backend).\n+\n+We value your feedback to help identify bugs before the full release! Check out [these docs](https://huggingface.co/docs/bitsandbytes/main/en/non_cuda_backends) for more details and feedback links.\n+\n+</Tip>\n+\n+Simply change the snippet above with:\n \n ```python\n from transformers import LlavaNextForConditionalGeneration, BitsAndBytesConfig"
        },
        {
            "sha": "fe905dfb7932ab9a77907236087c176cace4b4f2",
            "filename": "docs/source/en/model_doc/llava_next_video.md",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_doc%2Fllava_next_video.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_doc%2Fllava_next_video.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fllava_next_video.md?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -205,7 +205,17 @@ processor.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokeniza\n \n The model can be loaded in lower bits, significantly reducing memory burden while maintaining the performance of the original model. This allows for efficient deployment on resource-constrained cases. \n \n-First make sure to install bitsandbytes by running `pip install bitsandbytes` and to have access to a CUDA compatible GPU device. Load the quantized model by simply adding [`BitsAndBytesConfig`](../main_classes/quantization#transformers.BitsAndBytesConfig) as shown below:\n+First, make sure to install bitsandbytes by running `pip install bitsandbytes` and to have access to a GPU/accelerator that is supported by the library.\n+\n+<Tip>\n+\n+bitsandbytes is being refactored to support multiple backends beyond CUDA. Currently, ROCm (AMD GPU) and Intel CPU implementations are mature, with Intel XPU in progress and Apple Silicon support expected by Q4/Q1. For installation instructions and the latest backend updates, visit [this link](https://huggingface.co/docs/bitsandbytes/main/en/installation#multi-backend).\n+\n+We value your feedback to help identify bugs before the full release! Check out [these docs](https://huggingface.co/docs/bitsandbytes/main/en/non_cuda_backends) for more details and feedback links.\n+\n+</Tip>\n+\n+Then simply load the quantized model by adding [`BitsAndBytesConfig`](../main_classes/quantization#transformers.BitsAndBytesConfig) as shown below:\n \n \n ```python"
        },
        {
            "sha": "717784da738d8c29839a33a3e16f3614861a7b18",
            "filename": "docs/source/en/model_doc/llava_onevision.md",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_doc%2Fllava_onevision.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_doc%2Fllava_onevision.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fllava_onevision.md?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -264,9 +264,19 @@ processor.batch_decode(out, skip_special_tokens=True, clean_up_tokenization_spac\n \n ## Model optimization\n \n-### Quantization using Bitsandbytes\n+### Quantization using bitsandbytes\n \n-The model can be loaded in 8 or 4 bits, greatly reducing the memory requirements while maintaining the performance of the original model. First make sure to install bitsandbytes, `pip install bitsandbytes` and make sure to have access to a CUDA compatible GPU device. Simply change the snippet above with:\n+The model can be loaded in 8 or 4 bits, greatly reducing the memory requirements while maintaining the performance of the original model. First make sure to install bitsandbytes, `pip install bitsandbytes` and make sure to have access to a GPU/accelerator that is supported by the library.\n+\n+<Tip>\n+\n+bitsandbytes is being refactored to support multiple backends beyond CUDA. Currently, ROCm (AMD GPU) and Intel CPU implementations are mature, with Intel XPU in progress and Apple Silicon support expected by Q4/Q1. For installation instructions and the latest backend updates, visit [this link](https://huggingface.co/docs/bitsandbytes/main/en/installation#multi-backend).\n+\n+We value your feedback to help identify bugs before the full release! Check out [these docs](https://huggingface.co/docs/bitsandbytes/main/en/non_cuda_backends) for more details and feedback links.\n+\n+</Tip>\n+\n+Simply change the snippet above with:\n \n ```python\n from transformers import LlavaOnevisionForConditionalGeneration, BitsAndBytesConfig"
        },
        {
            "sha": "71c7d7921ef0052119fcd330aca5306936aa057a",
            "filename": "docs/source/en/model_doc/mixtral.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_doc%2Fmixtral.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_doc%2Fmixtral.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fmixtral.md?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -141,7 +141,7 @@ The Flash Attention-2 model uses also a more memory efficient cache slicing mech\n \n As the Mixtral model has 45 billion parameters, that would require about 90GB of GPU RAM in half precision (float16), since each parameter is stored in 2 bytes. However, one can shrink down the size of the model using [quantization](../quantization.md). If the model is quantized to 4 bits (or half a byte per parameter), a single A100 with 40GB of RAM is enough to fit the entire model, as in that case only about 27 GB of RAM is required.\n \n-Quantizing a model is as simple as passing a `quantization_config` to the model. Below, we'll leverage the BitsAndyBytes quantization (but refer to [this page](../quantization.md) for other quantization methods):\n+Quantizing a model is as simple as passing a `quantization_config` to the model. Below, we'll leverage the bitsandbytes quantization library (but refer to [this page](../quantization.md) for alternative quantization methods):\n \n ```python\n >>> import torch"
        },
        {
            "sha": "1c4b5b4b874dd776e55540dff1625e0a4e3cc228",
            "filename": "docs/source/en/model_doc/video_llava.md",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_doc%2Fvideo_llava.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_doc%2Fvideo_llava.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fvideo_llava.md?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -139,7 +139,17 @@ processor.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokeniza\n \n The model can be loaded in lower bits, significantly reducing memory burden while maintaining the performance of the original model. his allows for efficient deployment on resource-constrained cases. \n \n-First make sure to install bitsandbytes by running `pip install bitsandbytes` and to have access to a CUDA compatible GPU device. Load the quantized model by simply adding [`BitsAndBytesConfig`](../main_classes/quantization#transformers.BitsAndBytesConfig) as shown below:\n+First make sure to install bitsandbytes by running `pip install bitsandbytes` and to have access to a GPU/accelerator that is supported by the library.\n+\n+<Tip>\n+\n+bitsandbytes is being refactored to support multiple backends beyond CUDA. Currently, ROCm (AMD GPU) and Intel CPU implementations are mature, with Intel XPU in progress and Apple Silicon support expected by Q4/Q1. For installation instructions and the latest backend updates, visit [this link](https://huggingface.co/docs/bitsandbytes/main/en/installation#multi-backend).\n+\n+We value your feedback to help identify bugs before the full release! Check out [these docs](https://huggingface.co/docs/bitsandbytes/main/en/non_cuda_backends) for more details and feedback links.\n+\n+</Tip>\n+\n+Load the quantized model by simply adding [`BitsAndBytesConfig`](../main_classes/quantization#transformers.BitsAndBytesConfig) as shown below:\n \n \n ```python"
        },
        {
            "sha": "44c197aae5cfe4a9fd6b7b6b56df553d2cb287b2",
            "filename": "docs/source/en/model_memory_anatomy.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_memory_anatomy.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fmodel_memory_anatomy.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_memory_anatomy.md?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -233,7 +233,7 @@ Let's look at the details.\n **Optimizer States:**\n \n - 8 bytes * number of parameters for normal AdamW (maintains 2 states)\n-- 2 bytes * number of parameters for 8-bit AdamW optimizers like [bitsandbytes](https://github.com/TimDettmers/bitsandbytes)\n+- 2 bytes * number of parameters for 8-bit AdamW optimizers like [bitsandbytes](https://github.com/bitsandbytes-foundation/bitsandbytes)\n - 4 bytes * number of parameters for optimizers like SGD with momentum (maintains only 1 state)\n \n **Gradients**"
        },
        {
            "sha": "364fc46544c6fd027e7b47af201ee9f4616f68f1",
            "filename": "docs/source/en/perf_train_gpu_one.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fperf_train_gpu_one.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fperf_train_gpu_one.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fperf_train_gpu_one.md?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -284,7 +284,7 @@ training_args = TrainingArguments(per_device_train_batch_size=4, optim=\"adamw_bn\n \n However, we can also use a third-party implementation of the 8-bit optimizer for demonstration purposes to see how that can be integrated.\n \n-First, follow the installation guide in the GitHub [repo](https://github.com/TimDettmers/bitsandbytes) to install the `bitsandbytes` library \n+First, follow the installation guide in the GitHub [repo](https://github.com/bitsandbytes-foundation/bitsandbytes) to install the `bitsandbytes` library \n that implements the 8-bit Adam optimizer.\n \n Next you need to initialize the optimizer. This involves two steps: "
        },
        {
            "sha": "e9447555e824492384fb8937565bf1244f66090f",
            "filename": "docs/source/en/quantization/bitsandbytes.md",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fquantization%2Fbitsandbytes.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fquantization%2Fbitsandbytes.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fquantization%2Fbitsandbytes.md?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -38,6 +38,14 @@ pip install --upgrade accelerate transformers\n </hfoption>\n </hfoptions>\n \n+<Tip>\n+\n+bitsandbytes is being refactored to support multiple backends beyond CUDA. Currently, ROCm (AMD GPU) and Intel CPU implementations are mature, with Intel XPU in progress and Apple Silicon support expected by Q4/Q1. For installation instructions and the latest backend updates, visit [this link](https://huggingface.co/docs/bitsandbytes/main/en/installation#multi-backend).\n+\n+We value your feedback to help identify bugs before the full release! Check out [these docs](https://huggingface.co/docs/bitsandbytes/main/en/non_cuda_backends) for more details and feedback links.\n+\n+</Tip>\n+\n Now you can quantize a model by passing a `BitsAndBytesConfig` to [`~PreTrainedModel.from_pretrained`] method. This works for any model in any modality, as long as it supports loading with Accelerate and contains `torch.nn.Linear` layers.\n \n <hfoptions id=\"bnb\">"
        },
        {
            "sha": "97bb0cf5326308cb8237c1f106c67156e4373184",
            "filename": "docs/source/en/quantization/overview.md",
            "status": "modified",
            "additions": 15,
            "deletions": 1,
            "changes": 16,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fquantization%2Foverview.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/docs%2Fsource%2Fen%2Fquantization%2Foverview.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fquantization%2Foverview.md?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -49,11 +49,25 @@ Use the table below to help you decide which quantization method to use.\n |-------------------------------------|-------------------------|-----|----------|----------------|-----------------------|-------------------------|----------------|-------------------------------------|--------------|------------------------|---------------------------------------------|\n | [AQLM](./aqlm)                                | 游댮                       |  游릭   |     游릭     | 游댮              | 游댮                     | 游릭                      | 1 / 2          | 游릭                                   | 游릭            | 游릭                      | https://github.com/Vahe1994/AQLM            |\n | [AWQ](./awq) | 游댮                       | 游댮   | 游릭        | 游릭              | 游댮                     | ?                       | 4              | 游릭                                   | 游릭            | 游릭                      | https://github.com/casper-hansen/AutoAWQ    |\n-| [bitsandbytes](./bitsandbytes)                        | 游릭                       | 游댮   |     游릭     | 游댮              | 游댮                     | 游댮                       | 4 / 8          | 游릭                                   | 游릭            | 游릭                      | https://github.com/TimDettmers/bitsandbytes |\n+| [bitsandbytes](./bitsandbytes)     | 游릭            | 游리 *   |     游릭     | 游리 *            | 游댮 **    | 游댮    (soon!)          | 4 / 8          | 游릭                                   | 游릭            | 游릭                      | https://github.com/bitsandbytes-foundation/bitsandbytes |\n | [EETQ](./eetq)                                | 游릭                       | 游댮   | 游릭        | 游댮              | 游댮                     | ?                       | 8              | 游릭                                   | 游릭            | 游릭                      | https://github.com/NetEase-FuXi/EETQ        |\n | GGUF / GGML (llama.cpp)             | 游릭                       | 游릭   | 游릭        | 游댮              | 游릭                     | 游댮                       | 1 - 8          | 游댮                                   | [See GGUF section](../gguf)                | [See GGUF section](../gguf)                      | https://github.com/ggerganov/llama.cpp      |\n | [GPTQ](./gptq)                                | 游댮                       | 游댮   | 游릭        | 游릭              | 游댮                     | 游댮                       | 2 - 3 - 4 - 8          | 游릭                                   | 游릭            | 游릭                      | https://github.com/AutoGPTQ/AutoGPTQ        |\n | [HQQ](./hqq)                                 | 游릭                       | 游릭    | 游릭        | 游댮              | 游댮                     | 游릭                       | 1 - 8          | 游릭                                   | 游댮            | 游릭                      | https://github.com/mobiusml/hqq/            |\n | [Quanto](./quanto)                              | 游릭                       | 游릭   | 游릭        | 游댮              | 游릭                     | 游릭                       | 2 / 4 / 8      | 游댮                                   | 游댮            | 游릭                      | https://github.com/huggingface/quanto       |\n | [FBGEMM_FP8](./fbgemm_fp8.md)                              | 游릭                       | 游댮    | 游릭        | 游댮              | 游댮                      | 游댮                        | 8      | 游댮                                   | 游릭            | 游릭                      | https://github.com/pytorch/FBGEMM       |\n | [torchao](./torchao.md)                              | 游릭                       |     | 游릭        | 游댮              | partial support (int4 weight only)       |                       | 4 / 8      |                                   | 游릭游댮           | 游릭                      | https://github.com/pytorch/ao       |\n+\n+<Tip>\n+\n+\\* bitsandbytes is being refactored to support multiple backends beyond CUDA. Currently, ROCm (AMD GPU) and Intel CPU implementations are mature, with Intel XPU in progress and Apple Silicon support expected by Q4/Q1. For installation instructions and the latest backend updates, visit [this link](https://huggingface.co/docs/bitsandbytes/main/en/installation#multi-backend).\n+\n+We value your feedback to help identify bugs before the full release! Check out [these docs](https://huggingface.co/docs/bitsandbytes/main/en/non_cuda_backends) for more details and feedback links.\n+\n+</Tip>\n+\n+<Tip>\n+\n+\\** bitsandbytes is seeking contributors to help develop and lead the Apple Silicon backend. Interested? Contact them directly via their repo. Stipends may be available through sponsorships.\n+\n+</Tip>"
        },
        {
            "sha": "00bbcf2d060fe97ddb6e9312f3a0504b249b72f8",
            "filename": "src/transformers/integrations/__init__.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Fintegrations%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Fintegrations%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fintegrations%2F__init__.py?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -31,6 +31,7 @@\n         \"replace_with_bnb_linear\",\n         \"set_module_8bit_tensor_to_device\",\n         \"set_module_quantized_tensor_to_device\",\n+        \"validate_bnb_backend_availability\",\n     ],\n     \"deepspeed\": [\n         \"HfDeepSpeedConfig\",\n@@ -124,6 +125,7 @@\n         replace_with_bnb_linear,\n         set_module_8bit_tensor_to_device,\n         set_module_quantized_tensor_to_device,\n+        validate_bnb_backend_availability,\n     )\n     from .deepspeed import (\n         HfDeepSpeedConfig,"
        },
        {
            "sha": "2501261b55e091f2e12bce8567805c70b603474c",
            "filename": "src/transformers/integrations/bitsandbytes.py",
            "status": "modified",
            "additions": 93,
            "deletions": 5,
            "changes": 98,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Fintegrations%2Fbitsandbytes.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Fintegrations%2Fbitsandbytes.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fintegrations%2Fbitsandbytes.py?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -6,7 +6,15 @@\n \n from packaging import version\n \n-from ..utils import is_accelerate_available, is_bitsandbytes_available, logging\n+from ..utils import (\n+    get_available_devices,\n+    is_accelerate_available,\n+    is_bitsandbytes_available,\n+    is_bitsandbytes_multi_backend_available,\n+    is_ipex_available,\n+    is_torch_available,\n+    logging,\n+)\n \n \n if is_bitsandbytes_available():\n@@ -332,7 +340,7 @@ def get_keys_to_not_convert(model):\n \n \n # Copied from PEFT: https://github.com/huggingface/peft/blob/47b3712898539569c02ec5b3ed4a6c36811331a1/src/peft/utils/integrations.py#L41\n-def dequantize_bnb_weight(weight: \"torch.nn.Parameter\", state=None):\n+def dequantize_bnb_weight(weight: \"torch.nn.Parameter\", dtype: \"torch.dtype\", state=None):\n     \"\"\"\n     Helper function to dequantize 4bit or 8bit bnb weights.\n \n@@ -350,7 +358,7 @@ def dequantize_bnb_weight(weight: \"torch.nn.Parameter\", state=None):\n         logger.warning_once(\n             f\"The model is going to be dequantized in {output_tensor.dtype} - if you want to upcast it to another dtype, make sure to pass the desired dtype when quantizing the model through `bnb_4bit_quant_type` argument of `BitsAndBytesConfig`\"\n         )\n-        return output_tensor\n+        return output_tensor.to(dtype)\n \n     if state.SCB is None:\n         state.SCB = weight.SCB\n@@ -361,7 +369,7 @@ def dequantize_bnb_weight(weight: \"torch.nn.Parameter\", state=None):\n     if state.CxB is None:\n         state.CxB, state.SB = bnb.functional.transform(weight.data, to_order=state.formatB)\n     out32, Sout32 = bnb.functional.igemmlt(im, state.CxB, Sim, state.SB)\n-    return bnb.functional.mm_dequant(out32, Sout32, SCim, state.SCB, bias=None).t()\n+    return bnb.functional.mm_dequant(out32, Sout32, SCim, state.SCB, bias=None).t().to(dtype)\n \n \n def _create_accelerate_new_hook(old_hook):\n@@ -383,6 +391,7 @@ def _create_accelerate_new_hook(old_hook):\n \n def _dequantize_and_replace(\n     model,\n+    dtype,\n     modules_to_not_convert=None,\n     current_key_name=None,\n     quantization_config=None,\n@@ -422,7 +431,7 @@ def _dequantize_and_replace(\n                 else:\n                     state = None\n \n-                new_module.weight = torch.nn.Parameter(dequantize_bnb_weight(module.weight, state))\n+                new_module.weight = torch.nn.Parameter(dequantize_bnb_weight(module.weight, dtype, state))\n \n                 if bias is not None:\n                     new_module.bias = bias\n@@ -441,6 +450,7 @@ def _dequantize_and_replace(\n         if len(list(module.children())) > 0:\n             _, has_been_replaced = _dequantize_and_replace(\n                 module,\n+                dtype,\n                 modules_to_not_convert,\n                 current_key_name,\n                 quantization_config,\n@@ -458,6 +468,7 @@ def dequantize_and_replace(\n ):\n     model, has_been_replaced = _dequantize_and_replace(\n         model,\n+        model.dtype,\n         modules_to_not_convert=modules_to_not_convert,\n         quantization_config=quantization_config,\n     )\n@@ -468,3 +479,80 @@ def dequantize_and_replace(\n         )\n \n     return model\n+\n+\n+def _validate_bnb_multi_backend_availability(raise_exception):\n+    import bitsandbytes as bnb\n+\n+    bnb_supported_devices = getattr(bnb, \"supported_torch_devices\", set())\n+    available_devices = get_available_devices()\n+\n+    if available_devices == {\"cpu\"} and not is_ipex_available():\n+        from importlib.util import find_spec\n+\n+        if find_spec(\"intel_extension_for_pytorch\"):\n+            logger.warning(\n+                \"You have Intel IPEX installed but if you're intending to use it for CPU, it might not have the right version. Be sure to double check that your PyTorch and IPEX installs are compatible.\"\n+            )\n+\n+        available_devices.discard(\"cpu\")  # Only Intel CPU is supported by BNB at the moment\n+\n+    if not available_devices.intersection(bnb_supported_devices):\n+        if raise_exception:\n+            bnb_supported_devices_with_info = set(  # noqa: C401\n+                '\"cpu\" (needs an Intel CPU and intel_extension_for_pytorch installed and compatible with the PyTorch version)'\n+                if device == \"cpu\"\n+                else device\n+                for device in bnb_supported_devices\n+            )\n+            err_msg = (\n+                f\"None of the available devices `available_devices = {available_devices or None}` are supported by the bitsandbytes version you have installed: `bnb_supported_devices = {bnb_supported_devices_with_info}`. \"\n+                \"Please check the docs to see if the backend you intend to use is available and how to install it: https://huggingface.co/docs/bitsandbytes/main/en/installation#multi-backend\"\n+            )\n+\n+            logger.error(err_msg)\n+            raise RuntimeError(err_msg)\n+\n+        logger.warning(\"No supported devices found for bitsandbytes multi-backend.\")\n+        return False\n+\n+    logger.debug(\"Multi-backend validation successful.\")\n+    return True\n+\n+\n+def _validate_bnb_cuda_backend_availability(raise_exception):\n+    if not is_torch_available():\n+        return False\n+\n+    import torch\n+\n+    if not torch.cuda.is_available():\n+        log_msg = (\n+            \"CUDA is required but not available for bitsandbytes. Please consider installing the multi-platform enabled version of bitsandbytes, which is currently a work in progress. \"\n+            \"Please check currently supported platforms and installation instructions at https://huggingface.co/docs/bitsandbytes/main/en/installation#multi-backend\"\n+        )\n+        if raise_exception:\n+            logger.error(log_msg)\n+            raise RuntimeError(log_msg)\n+\n+        logger.warning(log_msg)\n+        return False\n+\n+    logger.debug(\"CUDA backend validation successful.\")\n+    return True\n+\n+\n+def validate_bnb_backend_availability(raise_exception=False):\n+    \"\"\"\n+    Validates if the available devices are supported by bitsandbytes, optionally raising an exception if not.\n+    \"\"\"\n+    if not is_bitsandbytes_available():\n+        if importlib.util.find_spec(\"bitsandbytes\") and version.parse(\n+            importlib.metadata.version(\"bitsandbytes\")\n+        ) < version.parse(\"0.43.1\"):\n+            return _validate_bnb_cuda_backend_availability(raise_exception)\n+        return False\n+\n+    if is_bitsandbytes_multi_backend_available():\n+        return _validate_bnb_multi_backend_availability(raise_exception)\n+    return _validate_bnb_cuda_backend_availability(raise_exception)"
        },
        {
            "sha": "73e7664aeb884d4c8117854cd1e8afa0109c15f4",
            "filename": "src/transformers/quantizers/quantizer_bnb_4bit.py",
            "status": "modified",
            "additions": 17,
            "deletions": 5,
            "changes": 22,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Fquantizers%2Fquantizer_bnb_4bit.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Fquantizers%2Fquantizer_bnb_4bit.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fquantizers%2Fquantizer_bnb_4bit.py?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -29,6 +29,7 @@\n     is_accelerate_available,\n     is_bitsandbytes_available,\n     is_torch_available,\n+    is_torch_xpu_available,\n     logging,\n )\n \n@@ -65,8 +66,6 @@ def __init__(self, quantization_config, **kwargs):\n             self.modules_to_not_convert = self.quantization_config.llm_int8_skip_modules\n \n     def validate_environment(self, *args, **kwargs):\n-        if not torch.cuda.is_available():\n-            raise RuntimeError(\"No GPU found. A GPU is needed for quantization.\")\n         if not is_accelerate_available():\n             raise ImportError(\n                 f\"Using `bitsandbytes` 4-bit quantization requires Accelerate: `pip install 'accelerate>={ACCELERATE_MIN_VERSION}'`\"\n@@ -76,6 +75,12 @@ def validate_environment(self, *args, **kwargs):\n                 \"Using `bitsandbytes` 4-bit quantization requires the latest version of bitsandbytes: `pip install -U bitsandbytes`\"\n             )\n \n+        from ..integrations import validate_bnb_backend_availability\n+        from ..utils import is_bitsandbytes_multi_backend_available\n+\n+        bnb_multibackend_is_enabled = is_bitsandbytes_multi_backend_available()\n+        validate_bnb_backend_availability(raise_exception=True)\n+\n         if kwargs.get(\"from_tf\", False) or kwargs.get(\"from_flax\", False):\n             raise ValueError(\n                 \"Converting into 4-bit or 8-bit weights from tf/flax weights is currently not supported, please make\"\n@@ -91,7 +96,9 @@ def validate_environment(self, *args, **kwargs):\n             device_map_without_lm_head = {\n                 key: device_map[key] for key in device_map.keys() if key not in self.modules_to_not_convert\n             }\n-            if \"cpu\" in device_map_without_lm_head.values() or \"disk\" in device_map_without_lm_head.values():\n+            if set(device_map.values()) == {\"cpu\"} and bnb_multibackend_is_enabled:\n+                pass\n+            elif \"cpu\" in device_map_without_lm_head.values() or \"disk\" in device_map_without_lm_head.values():\n                 raise ValueError(\n                     \"Some modules are dispatched on the CPU or the disk. Make sure you have enough GPU RAM to fit the \"\n                     \"quantized model. If you want to dispatch the model on the CPU or the disk while keeping these modules \"\n@@ -255,10 +262,15 @@ def update_torch_dtype(self, torch_dtype: \"torch.dtype\") -> \"torch.dtype\":\n     # Copied from transformers.quantizers.quantizer_bnb_8bit.Bnb8BitHfQuantizer.update_device_map\n     def update_device_map(self, device_map):\n         if device_map is None:\n-            device_map = {\"\": torch.cuda.current_device()}\n+            if torch.cuda.is_available():\n+                device_map = {\"\": torch.cuda.current_device()}\n+            elif is_torch_xpu_available():\n+                device_map = {\"\": f\"xpu:{torch.xpu.current_device()}\"}\n+            else:\n+                device_map = {\"\": \"cpu\"}\n             logger.info(\n                 \"The device_map was not initialized. \"\n-                \"Setting device_map to {'':torch.cuda.current_device()}. \"\n+                f\"Setting device_map to {device_map}. \"\n                 \"If you want to use the model for inference, please set device_map ='auto' \"\n             )\n         return device_map"
        },
        {
            "sha": "65d97716d02cf8fe679652b98ca26f72093dc9c9",
            "filename": "src/transformers/quantizers/quantizer_bnb_8bit.py",
            "status": "modified",
            "additions": 17,
            "deletions": 6,
            "changes": 23,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Fquantizers%2Fquantizer_bnb_8bit.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Fquantizers%2Fquantizer_bnb_8bit.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fquantizers%2Fquantizer_bnb_8bit.py?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -27,6 +27,7 @@\n     is_accelerate_available,\n     is_bitsandbytes_available,\n     is_torch_available,\n+    is_torch_xpu_available,\n     logging,\n )\n from .quantizers_utils import get_module_from_name\n@@ -64,9 +65,6 @@ def __init__(self, quantization_config, **kwargs):\n             self.modules_to_not_convert = self.quantization_config.llm_int8_skip_modules\n \n     def validate_environment(self, *args, **kwargs):\n-        if not torch.cuda.is_available():\n-            raise RuntimeError(\"No GPU found. A GPU is needed for quantization.\")\n-\n         if not is_accelerate_available():\n             raise ImportError(\n                 f\"Using `bitsandbytes` 8-bit quantization requires Accelerate: `pip install 'accelerate>={ACCELERATE_MIN_VERSION}'`\"\n@@ -76,6 +74,12 @@ def validate_environment(self, *args, **kwargs):\n                 \"Using `bitsandbytes` 8-bit quantization requires the latest version of bitsandbytes: `pip install -U bitsandbytes`\"\n             )\n \n+        from ..integrations import validate_bnb_backend_availability\n+        from ..utils import is_bitsandbytes_multi_backend_available\n+\n+        bnb_multibackend_is_enabled = is_bitsandbytes_multi_backend_available()\n+        validate_bnb_backend_availability(raise_exception=True)\n+\n         if kwargs.get(\"from_tf\", False) or kwargs.get(\"from_flax\", False):\n             raise ValueError(\n                 \"Converting into 4-bit or 8-bit weights from tf/flax weights is currently not supported, please make\"\n@@ -91,7 +95,9 @@ def validate_environment(self, *args, **kwargs):\n             device_map_without_lm_head = {\n                 key: device_map[key] for key in device_map.keys() if key not in self.modules_to_not_convert\n             }\n-            if \"cpu\" in device_map_without_lm_head.values() or \"disk\" in device_map_without_lm_head.values():\n+            if set(device_map.values()) == {\"cpu\"} and bnb_multibackend_is_enabled:\n+                pass\n+            elif \"cpu\" in device_map_without_lm_head.values() or \"disk\" in device_map_without_lm_head.values():\n                 raise ValueError(\n                     \"Some modules are dispatched on the CPU or the disk. Make sure you have enough GPU RAM to fit the \"\n                     \"quantized model. If you want to dispatch the model on the CPU or the disk while keeping these modules \"\n@@ -127,10 +133,15 @@ def update_torch_dtype(self, torch_dtype: \"torch.dtype\") -> \"torch.dtype\":\n \n     def update_device_map(self, device_map):\n         if device_map is None:\n-            device_map = {\"\": torch.cuda.current_device()}\n+            if torch.cuda.is_available():\n+                device_map = {\"\": torch.cuda.current_device()}\n+            elif is_torch_xpu_available():\n+                device_map = {\"\": f\"xpu:{torch.xpu.current_device()}\"}\n+            else:\n+                device_map = {\"\": \"cpu\"}\n             logger.info(\n                 \"The device_map was not initialized. \"\n-                \"Setting device_map to {'':torch.cuda.current_device()}. \"\n+                f\"Setting device_map to {device_map}. \"\n                 \"If you want to use the model for inference, please set device_map ='auto' \"\n             )\n         return device_map"
        },
        {
            "sha": "2cc0fa5710895a06fb9e529be4a4c7e9819b0819",
            "filename": "src/transformers/testing_utils.py",
            "status": "modified",
            "additions": 46,
            "deletions": 2,
            "changes": 48,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Ftesting_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Ftesting_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Ftesting_utils.py?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -61,6 +61,7 @@\n     is_auto_gptq_available,\n     is_av_available,\n     is_bitsandbytes_available,\n+    is_bitsandbytes_multi_backend_available,\n     is_bs4_available,\n     is_cv2_available,\n     is_cython_available,\n@@ -224,6 +225,17 @@ def parse_int_from_env(key, default=None):\n _run_third_party_device_tests = parse_flag_from_env(\"RUN_THIRD_PARTY_DEVICE_TESTS\", default=False)\n \n \n+def get_device_count():\n+    import torch\n+\n+    if is_torch_xpu_available():\n+        num_devices = torch.xpu.device_count()\n+    else:\n+        num_devices = torch.cuda.device_count()\n+\n+    return num_devices\n+\n+\n def is_pt_tf_cross_test(test_case):\n     \"\"\"\n     Decorator marking a test as a test that control interactions between PyTorch and TensorFlow.\n@@ -331,6 +343,29 @@ def tooslow(test_case):\n     return unittest.skip(reason=\"test is too slow\")(test_case)\n \n \n+def skip_if_not_implemented(test_func):\n+    @functools.wraps(test_func)\n+    def wrapper(*args, **kwargs):\n+        try:\n+            return test_func(*args, **kwargs)\n+        except NotImplementedError as e:\n+            raise unittest.SkipTest(f\"Test skipped due to NotImplementedError: {e}\")\n+\n+    return wrapper\n+\n+\n+def apply_skip_if_not_implemented(cls):\n+    \"\"\"\n+    Class decorator to apply @skip_if_not_implemented to all test methods.\n+    \"\"\"\n+    for attr_name in dir(cls):\n+        if attr_name.startswith(\"test_\"):\n+            attr = getattr(cls, attr_name)\n+            if callable(attr):\n+                setattr(cls, attr_name, skip_if_not_implemented(attr))\n+    return cls\n+\n+\n def custom_tokenizers(test_case):\n     \"\"\"\n     Decorator marking a test for a custom tokenizer.\n@@ -738,9 +773,9 @@ def require_torch_multi_gpu(test_case):\n     if not is_torch_available():\n         return unittest.skip(reason=\"test requires PyTorch\")(test_case)\n \n-    import torch\n+    device_count = get_device_count()\n \n-    return unittest.skipUnless(torch.cuda.device_count() > 1, \"test requires multiple GPUs\")(test_case)\n+    return unittest.skipUnless(device_count > 1, \"test requires multiple GPUs\")(test_case)\n \n \n def require_torch_multi_accelerator(test_case):\n@@ -947,6 +982,15 @@ def require_torch_gpu(test_case):\n     return unittest.skipUnless(torch_device == \"cuda\", \"test requires CUDA\")(test_case)\n \n \n+def require_torch_gpu_if_bnb_not_multi_backend_enabled(test_case):\n+    \"\"\"\n+    Decorator marking a test that requires a GPU if bitsandbytes multi-backend feature is not enabled.\n+    \"\"\"\n+    if is_bitsandbytes_available() and is_bitsandbytes_multi_backend_available():\n+        return test_case\n+    return require_torch_gpu(test_case)\n+\n+\n def require_torch_accelerator(test_case):\n     \"\"\"Decorator marking a test that requires an accessible accelerator and PyTorch.\"\"\"\n     return unittest.skipUnless(torch_device is not None and torch_device != \"cpu\", \"test requires accelerator\")("
        },
        {
            "sha": "93976c2375565bb254e9e3342c8376a9f27538ab",
            "filename": "src/transformers/utils/__init__.py",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Futils%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Futils%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2F__init__.py?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -15,6 +15,9 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n+from functools import lru_cache\n+from typing import FrozenSet\n+\n from huggingface_hub import get_full_repo_name  # for backward compatibility\n from huggingface_hub.constants import HF_HUB_DISABLE_TELEMETRY as DISABLE_TELEMETRY  # for backward compatibility\n from packaging import version\n@@ -118,6 +121,7 @@\n     is_auto_gptq_available,\n     is_av_available,\n     is_bitsandbytes_available,\n+    is_bitsandbytes_multi_backend_available,\n     is_bs4_available,\n     is_coloredlogs_available,\n     is_cv2_available,\n@@ -277,3 +281,31 @@ def check_min_version(min_version):\n             + \"Check out https://github.com/huggingface/transformers/tree/main/examples#important-note for the examples corresponding to other \"\n             \"versions of HuggingFace Transformers.\"\n         )\n+\n+\n+@lru_cache()\n+def get_available_devices() -> FrozenSet[str]:\n+    \"\"\"\n+    Returns a frozenset of devices available for the current PyTorch installation.\n+    \"\"\"\n+    devices = {\"cpu\"}  # `cpu` is always supported as a device in PyTorch\n+\n+    if is_torch_cuda_available():\n+        devices.add(\"cuda\")\n+\n+    if is_torch_mps_available():\n+        devices.add(\"mps\")\n+\n+    if is_torch_xpu_available():\n+        devices.add(\"xpu\")\n+\n+    if is_torch_npu_available():\n+        devices.add(\"npu\")\n+\n+    if is_torch_mlu_available():\n+        devices.add(\"mlu\")\n+\n+    if is_torch_musa_available():\n+        devices.add(\"musa\")\n+\n+    return frozenset(devices)"
        },
        {
            "sha": "289dd02fdd52c533f2abfedf9622aa5edb06edf9",
            "filename": "src/transformers/utils/import_utils.py",
            "status": "modified",
            "additions": 18,
            "deletions": 4,
            "changes": 22,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Futils%2Fimport_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/src%2Ftransformers%2Futils%2Fimport_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fimport_utils.py?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -849,15 +849,29 @@ def is_torch_xpu_available(check_device=False):\n     return hasattr(torch, \"xpu\") and torch.xpu.is_available()\n \n \n+@lru_cache()\n def is_bitsandbytes_available():\n-    if not is_torch_available():\n+    if not is_torch_available() or not _bitsandbytes_available:\n         return False\n \n-    # bitsandbytes throws an error if cuda is not available\n-    # let's avoid that by adding a simple check\n     import torch\n \n-    return _bitsandbytes_available and torch.cuda.is_available()\n+    # `bitsandbytes` versions older than 0.43.1 eagerly require CUDA at import time,\n+    # so those versions of the library are practically only available when CUDA is too.\n+    if version.parse(importlib.metadata.version(\"bitsandbytes\")) < version.parse(\"0.43.1\"):\n+        return torch.cuda.is_available()\n+\n+    # Newer versions of `bitsandbytes` can be imported on systems without CUDA.\n+    return True\n+\n+\n+def is_bitsandbytes_multi_backend_available() -> bool:\n+    if not is_bitsandbytes_available():\n+        return False\n+\n+    import bitsandbytes as bnb\n+\n+    return \"multi_backend\" in getattr(bnb, \"features\", set())\n \n \n def is_flash_attn_2_available():"
        },
        {
            "sha": "0ac9b3d82fc7b06c7519412609a420a0f434196c",
            "filename": "tests/quantization/bnb/test_4bit.py",
            "status": "modified",
            "additions": 65,
            "deletions": 35,
            "changes": 100,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/tests%2Fquantization%2Fbnb%2Ftest_4bit.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/tests%2Fquantization%2Fbnb%2Ftest_4bit.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fquantization%2Fbnb%2Ftest_4bit.py?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -30,12 +30,13 @@\n     pipeline,\n )\n from transformers.testing_utils import (\n+    apply_skip_if_not_implemented,\n     is_bitsandbytes_available,\n     is_torch_available,\n     require_accelerate,\n     require_bitsandbytes,\n     require_torch,\n-    require_torch_gpu,\n+    require_torch_gpu_if_bnb_not_multi_backend_enabled,\n     require_torch_multi_gpu,\n     slow,\n     torch_device,\n@@ -85,7 +86,7 @@ def forward(self, input, *args, **kwargs):\n @require_bitsandbytes\n @require_accelerate\n @require_torch\n-@require_torch_gpu\n+@require_torch_gpu_if_bnb_not_multi_backend_enabled\n @slow\n class Base4bitTest(unittest.TestCase):\n     # We keep the constants inside the init function and model loading inside setUp function\n@@ -111,6 +112,7 @@ def setUp(self):\n         self.tokenizer = AutoTokenizer.from_pretrained(self.model_name)\n \n \n+@apply_skip_if_not_implemented\n class Bnb4BitTest(Base4bitTest):\n     def setUp(self):\n         super().setUp()\n@@ -206,7 +208,7 @@ def test_rwkv_4bit(self):\n         tok = AutoTokenizer.from_pretrained(model_id)\n \n         text = \"Hello my name is\"\n-        input_ids = tok.encode(text, return_tensors=\"pt\").to(0)\n+        input_ids = tok.encode(text, return_tensors=\"pt\").to(torch_device)\n \n         _ = model.generate(input_ids, max_new_tokens=30)\n \n@@ -217,7 +219,9 @@ def test_generate_quality(self):\n         the same output across GPUs. So we'll generate few tokens (5-10) and check their output.\n         \"\"\"\n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n-        output_sequences = self.model_4bit.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+        output_sequences = self.model_4bit.generate(\n+            input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10\n+        )\n \n         self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n \n@@ -234,7 +238,7 @@ def test_generate_quality_config(self):\n \n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n         output_sequences = model_4bit_from_config.generate(\n-            input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10\n+            input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10\n         )\n \n         self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n@@ -252,7 +256,9 @@ def test_generate_quality_dequantize(self):\n         model_4bit.dequantize()\n \n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n-        output_sequences = model_4bit.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+        output_sequences = model_4bit.generate(\n+            input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10\n+        )\n \n         self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n \n@@ -267,15 +273,18 @@ def test_device_assignment(self):\n         self.assertEqual(self.model_4bit.device.type, \"cpu\")\n         self.assertAlmostEqual(self.model_4bit.get_memory_footprint(), mem_before)\n \n-        # Move back to CUDA device\n-        self.model_4bit.to(0)\n-        self.assertEqual(self.model_4bit.device, torch.device(0))\n-        self.assertAlmostEqual(self.model_4bit.get_memory_footprint(), mem_before)\n+        if torch.cuda.is_available():\n+            # Move back to CUDA device\n+            self.model_4bit.to(\"cuda\")\n+            self.assertEqual(self.model_4bit.device.type, \"cuda\")\n+            self.assertAlmostEqual(self.model_4bit.get_memory_footprint(), mem_before)\n \n     def test_device_and_dtype_assignment(self):\n         r\"\"\"\n-        Test whether trying to cast (or assigning a device to) a model after converting it in 4-bit will throw an error.\n-        Checks also if other models are casted correctly.\n+        Test whether attempting to change the device or cast the dtype of a model\n+        after converting it to 4-bit precision will raise an appropriate error.\n+        The test ensures that such operations are prohibited on 4-bit models\n+        to prevent invalid conversions.\n         \"\"\"\n \n         # Moving with `to` or `cuda` is not supported with versions < 0.43.2.\n@@ -297,25 +306,24 @@ def test_device_and_dtype_assignment(self):\n             self.model_4bit.to(torch.float16)\n \n         with self.assertRaises(ValueError):\n-            # Tries with a `dtype` and `device`\n-            self.model_4bit.to(device=\"cuda:0\", dtype=torch.float16)\n-\n-        with self.assertRaises(ValueError):\n-            # Tries with a cast\n+            # Tries to cast the 4-bit model to float32 using `float()`\n             self.model_4bit.float()\n \n         with self.assertRaises(ValueError):\n-            # Tries with a cast\n+            # Tries to cast the 4-bit model to float16 using `half()`\n             self.model_4bit.half()\n \n         # Test if we did not break anything\n+        self.model_4bit.to(torch.device(torch_device))\n+\n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n \n         self.model_fp16 = self.model_fp16.to(torch.float32)\n-        _ = self.model_fp16.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+        _ = self.model_fp16.generate(input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10)\n \n-        # Check that this does not throw an error\n-        _ = self.model_fp16.cuda()\n+        if torch.cuda.is_available():\n+            # Check that this does not throw an error\n+            _ = self.model_fp16.cuda()\n \n         # Check this does not throw an error\n         _ = self.model_fp16.to(\"cpu\")\n@@ -344,8 +352,9 @@ def test_bnb_4bit_wrong_config(self):\n @require_bitsandbytes\n @require_accelerate\n @require_torch\n-@require_torch_gpu\n+@require_torch_gpu_if_bnb_not_multi_backend_enabled\n @slow\n+@apply_skip_if_not_implemented\n class Bnb4BitT5Test(unittest.TestCase):\n     @classmethod\n     def setUpClass(cls):\n@@ -375,14 +384,14 @@ def test_inference_without_keep_in_fp32(self):\n \n         # test with `google-t5/t5-small`\n         model = T5ForConditionalGeneration.from_pretrained(self.model_name, load_in_4bit=True, device_map=\"auto\")\n-        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(0)\n+        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(torch_device)\n         _ = model.generate(**encoded_input)\n \n         # test with `flan-t5-small`\n         model = T5ForConditionalGeneration.from_pretrained(\n             self.dense_act_model_name, load_in_4bit=True, device_map=\"auto\"\n         )\n-        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(0)\n+        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(torch_device)\n         _ = model.generate(**encoded_input)\n         T5ForConditionalGeneration._keep_in_fp32_modules = modules\n \n@@ -400,17 +409,18 @@ def test_inference_with_keep_in_fp32(self):\n         # there was a bug with decoders - this test checks that it is fixed\n         self.assertTrue(isinstance(model.decoder.block[0].layer[0].SelfAttention.q, bnb.nn.Linear4bit))\n \n-        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(0)\n+        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(torch_device)\n         _ = model.generate(**encoded_input)\n \n         # test with `flan-t5-small`\n         model = T5ForConditionalGeneration.from_pretrained(\n             self.dense_act_model_name, load_in_4bit=True, device_map=\"auto\"\n         )\n-        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(0)\n+        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(torch_device)\n         _ = model.generate(**encoded_input)\n \n \n+@apply_skip_if_not_implemented\n class Classes4BitModelTest(Base4bitTest):\n     def setUp(self):\n         super().setUp()\n@@ -460,6 +470,7 @@ def test_correct_head_class(self):\n         self.assertTrue(self.seq_to_seq_model.lm_head.weight.__class__ == torch.nn.Parameter)\n \n \n+@apply_skip_if_not_implemented\n class Pipeline4BitTest(Base4bitTest):\n     def setUp(self):\n         super().setUp()\n@@ -469,7 +480,8 @@ def tearDown(self):\n         TearDown function needs to be called at the end of each test to free the GPU memory and cache, also to\n         avoid unexpected behaviors. Please see: https://discuss.pytorch.org/t/how-can-we-release-gpu-memory-cache/14530/27\n         \"\"\"\n-        del self.pipe\n+        if hasattr(self, \"pipe\"):\n+            del self.pipe\n \n         gc.collect()\n         torch.cuda.empty_cache()\n@@ -484,7 +496,12 @@ def test_pipeline(self):\n         self.pipe = pipeline(\n             \"text-generation\",\n             model=self.model_name,\n-            model_kwargs={\"device_map\": \"auto\", \"load_in_4bit\": True, \"torch_dtype\": torch.float16},\n+            model_kwargs={\n+                \"device_map\": \"auto\",\n+                \"load_in_4bit\": True,\n+                # float16 isn't supported on CPU, use bfloat16 instead\n+                \"torch_dtype\": torch.bfloat16 if torch_device == \"cpu\" else torch.float16,\n+            },\n             max_new_tokens=self.MAX_NEW_TOKENS,\n         )\n \n@@ -494,6 +511,7 @@ def test_pipeline(self):\n \n \n @require_torch_multi_gpu\n+@apply_skip_if_not_implemented\n class Bnb4bitTestMultiGpu(Base4bitTest):\n     def setUp(self):\n         super().setUp()\n@@ -515,10 +533,13 @@ def test_multi_gpu_loading(self):\n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n \n         # Second real batch\n-        output_parallel = model_parallel.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+        output_parallel = model_parallel.generate(\n+            input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10\n+        )\n         self.assertIn(self.tokenizer.decode(output_parallel[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n \n \n+@apply_skip_if_not_implemented\n class Bnb4BitTestTraining(Base4bitTest):\n     def setUp(self):\n         self.model_name = \"facebook/opt-350m\"\n@@ -531,7 +552,10 @@ def test_training(self):\n         # Step 1: freeze all parameters\n         model = AutoModelForCausalLM.from_pretrained(self.model_name, load_in_4bit=True)\n \n-        self.assertEqual(set(model.hf_device_map.values()), {torch.cuda.current_device()})\n+        if torch.cuda.is_available():\n+            self.assertEqual(set(model.hf_device_map.values()), {torch.cuda.current_device()})\n+        else:\n+            self.assertTrue(all(param.device.type == \"cpu\" for param in model.parameters()))\n \n         for param in model.parameters():\n             param.requires_grad = False  # freeze the model - train adapters later\n@@ -547,10 +571,10 @@ def test_training(self):\n                 module.v_proj = LoRALayer(module.v_proj, rank=16)\n \n         # Step 3: dummy batch\n-        batch = self.tokenizer(\"Test batch \", return_tensors=\"pt\").to(0)\n+        batch = self.tokenizer(\"Test batch \", return_tensors=\"pt\").to(torch_device)\n \n         # Step 4: Check if the gradient is not None\n-        with torch.cuda.amp.autocast():\n+        with torch.autocast(torch_device):\n             out = model.forward(**batch)\n             out.logits.norm().backward()\n \n@@ -562,6 +586,7 @@ def test_training(self):\n                 self.assertTrue(module.weight.grad is None)\n \n \n+@apply_skip_if_not_implemented\n class Bnb4BitGPT2Test(Bnb4BitTest):\n     model_name = \"openai-community/gpt2-xl\"\n     EXPECTED_RELATIVE_DIFFERENCE = 3.3191854854152187\n@@ -570,8 +595,9 @@ class Bnb4BitGPT2Test(Bnb4BitTest):\n @require_bitsandbytes\n @require_accelerate\n @require_torch\n-@require_torch_gpu\n+@require_torch_gpu_if_bnb_not_multi_backend_enabled\n @slow\n+@apply_skip_if_not_implemented\n class BaseSerializationTest(unittest.TestCase):\n     model_name = \"facebook/opt-125m\"\n     input_text = \"Mars colonists' favorite meals are\"\n@@ -635,7 +661,9 @@ def test_serialization(self, quant_type=\"nf4\", double_quant=True, safe_serializa\n                     d1[k].quant_state.as_dict().values(),\n                 ):\n                     if isinstance(v0, torch.Tensor):\n-                        self.assertTrue(torch.equal(v0, v1.to(v0.device)))\n+                        # The absmax will not be saved in the quant_state when using NF4 in CPU\n+                        if v0.numel() != 0:\n+                            self.assertTrue(torch.equal(v0, v1.to(v0.device)))\n                     else:\n                         self.assertTrue(v0 == v1)\n \n@@ -659,6 +687,7 @@ def _decode(token):\n         )\n \n \n+@apply_skip_if_not_implemented\n class ExtendedSerializationTest(BaseSerializationTest):\n     \"\"\"\n     tests more combinations of parameters\n@@ -706,8 +735,9 @@ class GPTSerializationTest(BaseSerializationTest):\n \n @require_bitsandbytes\n @require_accelerate\n-@require_torch_gpu\n+@require_torch_gpu_if_bnb_not_multi_backend_enabled\n @slow\n+@apply_skip_if_not_implemented\n class Bnb4BitTestBasicConfigTest(unittest.TestCase):\n     def test_load_in_4_and_8_bit_fails(self):\n         with self.assertRaisesRegex(ValueError, \"load_in_4bit and load_in_8bit are both True\"):"
        },
        {
            "sha": "5a99ab32e42b8c99194017e6fba9ee467f92e8c5",
            "filename": "tests/quantization/bnb/test_mixed_int8.py",
            "status": "modified",
            "additions": 63,
            "deletions": 32,
            "changes": 95,
            "blob_url": "https://github.com/huggingface/transformers/blob/11c27dd331151e7d2ac20016cce11d9d7c4b1756/tests%2Fquantization%2Fbnb%2Ftest_mixed_int8.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/11c27dd331151e7d2ac20016cce11d9d7c4b1756/tests%2Fquantization%2Fbnb%2Ftest_mixed_int8.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fquantization%2Fbnb%2Ftest_mixed_int8.py?ref=11c27dd331151e7d2ac20016cce11d9d7c4b1756",
            "patch": "@@ -30,14 +30,17 @@\n     pipeline,\n )\n from transformers.testing_utils import (\n+    apply_skip_if_not_implemented,\n     is_accelerate_available,\n+    is_bitsandbytes_available,\n     is_torch_available,\n     require_accelerate,\n     require_bitsandbytes,\n     require_torch,\n-    require_torch_gpu,\n+    require_torch_gpu_if_bnb_not_multi_backend_enabled,\n     require_torch_multi_gpu,\n     slow,\n+    torch_device,\n )\n \n \n@@ -77,10 +80,14 @@ def forward(self, input, *args, **kwargs):\n             return self.module(input, *args, **kwargs) + self.adapter(input)\n \n \n+if is_bitsandbytes_available():\n+    import bitsandbytes as bnb\n+\n+\n @require_bitsandbytes\n @require_accelerate\n @require_torch\n-@require_torch_gpu\n+@require_torch_gpu_if_bnb_not_multi_backend_enabled\n @slow\n class BaseMixedInt8Test(unittest.TestCase):\n     # We keep the constants inside the init function and model loading inside setUp function\n@@ -108,6 +115,7 @@ def setUp(self):\n         self.tokenizer = AutoTokenizer.from_pretrained(self.model_name)\n \n \n+@apply_skip_if_not_implemented\n class MixedInt8Test(BaseMixedInt8Test):\n     def setUp(self):\n         super().setUp()\n@@ -240,7 +248,6 @@ def test_llm_skip(self):\n         r\"\"\"\n         A simple test to check if `llm_int8_skip_modules` works as expected\n         \"\"\"\n-        import bitsandbytes as bnb\n \n         quantization_config = BitsAndBytesConfig(load_in_8bit=True, llm_int8_skip_modules=[\"classifier\"])\n         seq_classification_model = AutoModelForSequenceClassification.from_pretrained(\n@@ -263,7 +270,9 @@ def test_generate_quality(self):\n         the same output across GPUs. So we'll generate few tokens (5-10) and check their output.\n         \"\"\"\n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n-        output_sequences = self.model_8bit.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+        output_sequences = self.model_8bit.generate(\n+            input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10\n+        )\n \n         self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n \n@@ -280,7 +289,7 @@ def test_generate_quality_config(self):\n \n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n         output_sequences = model_8bit_from_config.generate(\n-            input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10\n+            input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10\n         )\n \n         self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n@@ -298,7 +307,9 @@ def test_generate_quality_dequantize(self):\n         model_8bit.dequantize()\n \n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n-        output_sequences = model_8bit.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+        output_sequences = model_8bit.generate(\n+            input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10\n+        )\n \n         self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n \n@@ -319,8 +330,10 @@ def test_raise_if_config_and_load_in_8bit(self):\n \n     def test_device_and_dtype_assignment(self):\n         r\"\"\"\n-        Test whether trying to cast (or assigning a device to) a model after converting it in 8-bit will throw an error.\n-        Checks also if other models are casted correctly.\n+        Test whether attempting to change the device or cast the dtype of a model\n+        after converting it to 8-bit precision will raise an appropriate error.\n+        The test ensures that such operations are prohibited on 8-bit models\n+        to prevent invalid conversions.\n         \"\"\"\n         with self.assertRaises(ValueError):\n             # Tries with `str`\n@@ -332,21 +345,21 @@ def test_device_and_dtype_assignment(self):\n \n         with self.assertRaises(ValueError):\n             # Tries with a `device`\n-            self.model_8bit.to(torch.device(\"cuda:0\"))\n+            self.model_8bit.to(torch.device(torch_device))\n \n         with self.assertRaises(ValueError):\n-            # Tries with a `device`\n+            # Tries to cast the 8-bit model to float32 using `float()`\n             self.model_8bit.float()\n \n         with self.assertRaises(ValueError):\n-            # Tries with a `device`\n+            # Tries to cast the 4-bit model to float16 using `half()`\n             self.model_8bit.half()\n \n         # Test if we did not break anything\n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n \n         self.model_fp16 = self.model_fp16.to(torch.float32)\n-        _ = self.model_fp16.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+        _ = self.model_fp16.generate(input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10)\n \n         # Check this does not throw an error\n         _ = self.model_fp16.to(\"cpu\")\n@@ -385,7 +398,9 @@ def test_int8_serialization(self):\n \n             # generate\n             encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n-            output_sequences = model_from_saved.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+            output_sequences = model_from_saved.generate(\n+                input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10\n+            )\n \n         self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n \n@@ -410,7 +425,9 @@ def test_int8_serialization_regression(self):\n \n             # generate\n             encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n-            output_sequences = model_from_saved.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+            output_sequences = model_from_saved.generate(\n+                input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10\n+            )\n \n         self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n \n@@ -435,7 +452,9 @@ def test_int8_serialization_sharded(self):\n \n             # generate\n             encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n-            output_sequences = model_from_saved.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+            output_sequences = model_from_saved.generate(\n+                input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10\n+            )\n \n             self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n \n@@ -455,15 +474,15 @@ def test_int8_from_pretrained(self):\n \n         # generate\n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n-        output_sequences = model.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+        output_sequences = model.generate(input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10)\n \n         self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n \n \n @require_bitsandbytes\n @require_accelerate\n @require_torch\n-@require_torch_gpu\n+@require_torch_gpu_if_bnb_not_multi_backend_enabled\n @slow\n class MixedInt8T5Test(unittest.TestCase):\n     @classmethod\n@@ -494,14 +513,14 @@ def test_inference_without_keep_in_fp32(self):\n \n         # test with `google-t5/t5-small`\n         model = T5ForConditionalGeneration.from_pretrained(self.model_name, load_in_8bit=True, device_map=\"auto\")\n-        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(0)\n+        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(torch_device)\n         _ = model.generate(**encoded_input)\n \n         # test with `flan-t5-small`\n         model = T5ForConditionalGeneration.from_pretrained(\n             self.dense_act_model_name, load_in_8bit=True, device_map=\"auto\"\n         )\n-        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(0)\n+        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(torch_device)\n         _ = model.generate(**encoded_input)\n         T5ForConditionalGeneration._keep_in_fp32_modules = modules\n \n@@ -511,7 +530,6 @@ def test_inference_with_keep_in_fp32(self):\n         `flan-t5-small` uses `T5DenseGatedActDense` whereas `google-t5/t5-small` uses `T5DenseReluDense`. We need to test\n         both cases.\n         \"\"\"\n-        import bitsandbytes as bnb\n \n         from transformers import T5ForConditionalGeneration\n \n@@ -521,14 +539,14 @@ def test_inference_with_keep_in_fp32(self):\n         # there was a bug with decoders - this test checks that it is fixed\n         self.assertTrue(isinstance(model.decoder.block[0].layer[0].SelfAttention.q, bnb.nn.Linear8bitLt))\n \n-        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(0)\n+        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(torch_device)\n         _ = model.generate(**encoded_input)\n \n         # test with `flan-t5-small`\n         model = T5ForConditionalGeneration.from_pretrained(\n             self.dense_act_model_name, load_in_8bit=True, device_map=\"auto\"\n         )\n-        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(0)\n+        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(torch_device)\n         _ = model.generate(**encoded_input)\n \n     def test_inference_with_keep_in_fp32_serialized(self):\n@@ -538,7 +556,6 @@ def test_inference_with_keep_in_fp32_serialized(self):\n         `flan-t5-small` uses `T5DenseGatedActDense` whereas `google-t5/t5-small` uses `T5DenseReluDense`. We need to test\n         both cases.\n         \"\"\"\n-        import bitsandbytes as bnb\n \n         from transformers import T5ForConditionalGeneration\n \n@@ -553,14 +570,14 @@ def test_inference_with_keep_in_fp32_serialized(self):\n             # there was a bug with decoders - this test checks that it is fixed\n             self.assertTrue(isinstance(model.decoder.block[0].layer[0].SelfAttention.q, bnb.nn.Linear8bitLt))\n \n-            encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(0)\n+            encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(torch_device)\n             _ = model.generate(**encoded_input)\n \n             # test with `flan-t5-small`\n             model = T5ForConditionalGeneration.from_pretrained(\n                 self.dense_act_model_name, load_in_8bit=True, device_map=\"auto\"\n             )\n-            encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(0)\n+            encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\").to(torch_device)\n             _ = model.generate(**encoded_input)\n \n \n@@ -614,6 +631,7 @@ def test_correct_head_class(self):\n         self.assertTrue(self.seq_to_seq_model.lm_head.weight.__class__ == torch.nn.Parameter)\n \n \n+@apply_skip_if_not_implemented\n class MixedInt8TestPipeline(BaseMixedInt8Test):\n     def setUp(self):\n         super().setUp()\n@@ -623,7 +641,8 @@ def tearDown(self):\n         TearDown function needs to be called at the end of each test to free the GPU memory and cache, also to\n         avoid unexpected behaviors. Please see: https://discuss.pytorch.org/t/how-can-we-release-gpu-memory-cache/14530/27\n         \"\"\"\n-        del self.pipe\n+        if hasattr(self, \"pipe\"):\n+            del self.pipe\n \n         gc.collect()\n         torch.cuda.empty_cache()\n@@ -648,6 +667,7 @@ def test_pipeline(self):\n \n \n @require_torch_multi_gpu\n+@apply_skip_if_not_implemented\n class MixedInt8TestMultiGpu(BaseMixedInt8Test):\n     def setUp(self):\n         super().setUp()\n@@ -669,11 +689,14 @@ def test_multi_gpu_loading(self):\n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n \n         # Second real batch\n-        output_parallel = model_parallel.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+        output_parallel = model_parallel.generate(\n+            input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10\n+        )\n         self.assertIn(self.tokenizer.decode(output_parallel[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n \n \n @require_torch_multi_gpu\n+@apply_skip_if_not_implemented\n class MixedInt8TestCpuGpu(BaseMixedInt8Test):\n     def setUp(self):\n         super().setUp()\n@@ -683,7 +706,7 @@ def check_inference_correctness(self, model):\n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n \n         # Check the exactness of the results\n-        output_parallel = model.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+        output_parallel = model.generate(input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10)\n \n         # Get the generation\n         output_text = self.tokenizer.decode(output_parallel[0], skip_special_tokens=True)\n@@ -819,6 +842,7 @@ def test_cpu_gpu_disk_loading_custom_device_map_kwargs(self):\n             self.check_inference_correctness(model_8bit)\n \n \n+@apply_skip_if_not_implemented\n class MixedInt8TestTraining(BaseMixedInt8Test):\n     def setUp(self):\n         self.model_name = \"facebook/opt-350m\"\n@@ -831,7 +855,10 @@ def test_training(self):\n         # Step 1: freeze all parameters\n         model = AutoModelForCausalLM.from_pretrained(self.model_name, load_in_8bit=True)\n \n-        self.assertEqual(set(model.hf_device_map.values()), {torch.cuda.current_device()})\n+        if torch.cuda.is_available():\n+            self.assertEqual(set(model.hf_device_map.values()), {torch.cuda.current_device()})\n+        else:\n+            self.assertTrue(all(param.device.type == \"cpu\" for param in model.parameters()))\n \n         for param in model.parameters():\n             param.requires_grad = False  # freeze the model - train adapters later\n@@ -847,10 +874,10 @@ def test_training(self):\n                 module.v_proj = LoRALayer(module.v_proj, rank=16)\n \n         # Step 3: dummy batch\n-        batch = self.tokenizer(\"Test batch \", return_tensors=\"pt\").to(0)\n+        batch = self.tokenizer(\"Test batch \", return_tensors=\"pt\").to(torch_device)\n \n         # Step 4: Check if the gradient is not None\n-        with torch.cuda.amp.autocast():\n+        with torch.autocast(torch_device):\n             out = model.forward(**batch)\n             out.logits.norm().backward()\n \n@@ -862,6 +889,7 @@ def test_training(self):\n                 self.assertTrue(module.weight.grad is None)\n \n \n+@apply_skip_if_not_implemented\n class MixedInt8GPT2Test(MixedInt8Test):\n     model_name = \"openai-community/gpt2-xl\"\n     EXPECTED_RELATIVE_DIFFERENCE = 1.8720077507258357\n@@ -870,6 +898,9 @@ class MixedInt8GPT2Test(MixedInt8Test):\n     EXPECTED_OUTPUTS.add(\"Hello my name is John Doe, and I'm a fan of the\")\n     # Expected values on a A10\n     EXPECTED_OUTPUTS.add(\"Hello my name is John Doe, and I am a member of the\")\n+    # Expected values on Intel CPU\n+    EXPECTED_OUTPUTS.add(\"Hello my name is John Doe. I am a man. I am\")\n+    EXPECTED_OUTPUTS.add(\"Hello my name is John, and I'm a writer. I'm\")\n \n     def test_int8_from_pretrained(self):\n         r\"\"\"\n@@ -887,6 +918,6 @@ def test_int8_from_pretrained(self):\n \n         # generate\n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n-        output_sequences = model.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+        output_sequences = model.generate(input_ids=encoded_input[\"input_ids\"].to(torch_device), max_new_tokens=10)\n \n         self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)"
        }
    ],
    "stats": {
        "total": 536,
        "additions": 436,
        "deletions": 100
    }
}