{
    "author": "XuehaiPan",
    "message": "Load dynamic module (remote code) only once if code isn't change (#33162)\n\n* Load remote code only once\r\n\r\n* Use hash as load indicator\r\n\r\n* Add a new option `force_reload` for old behavior (i.e. always reload)\r\n\r\n* Add test for dynamic module is cached\r\n\r\n* Add more type annotations to improve code readability\r\n\r\n* Address comments from code review",
    "sha": "e1c2b69c341f088d59949d1eabfc022c12d4c797",
    "files": [
        {
            "sha": "07cb5940dc4b61a32e097cc4611e0a2f63eb9dd7",
            "filename": "src/transformers/dynamic_module_utils.py",
            "status": "modified",
            "additions": 39,
            "deletions": 12,
            "changes": 51,
            "blob_url": "https://github.com/huggingface/transformers/blob/e1c2b69c341f088d59949d1eabfc022c12d4c797/src%2Ftransformers%2Fdynamic_module_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e1c2b69c341f088d59949d1eabfc022c12d4c797/src%2Ftransformers%2Fdynamic_module_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fdynamic_module_utils.py?ref=e1c2b69c341f088d59949d1eabfc022c12d4c797",
            "patch": "@@ -15,16 +15,19 @@\n \"\"\"Utilities to dynamically load objects from the Hub.\"\"\"\n \n import filecmp\n+import hashlib\n import importlib\n import importlib.util\n import os\n import re\n import shutil\n import signal\n import sys\n+import threading\n import typing\n import warnings\n from pathlib import Path\n+from types import ModuleType\n from typing import Any, Dict, List, Optional, Union\n \n from huggingface_hub import try_to_load_from_cache\n@@ -40,6 +43,7 @@\n \n \n logger = logging.get_logger(__name__)  # pylint: disable=invalid-name\n+_HF_REMOTE_CODE_LOCK = threading.Lock()\n \n \n def init_hf_modules():\n@@ -58,7 +62,7 @@ def init_hf_modules():\n         importlib.invalidate_caches()\n \n \n-def create_dynamic_module(name: Union[str, os.PathLike]):\n+def create_dynamic_module(name: Union[str, os.PathLike]) -> None:\n     \"\"\"\n     Creates a dynamic module in the cache directory for modules.\n \n@@ -191,13 +195,21 @@ def check_imports(filename: Union[str, os.PathLike]) -> List[str]:\n     return get_relative_imports(filename)\n \n \n-def get_class_in_module(class_name: str, module_path: Union[str, os.PathLike]) -> typing.Type:\n+def get_class_in_module(\n+    class_name: str,\n+    module_path: Union[str, os.PathLike],\n+    *,\n+    force_reload: bool = False,\n+) -> typing.Type:\n     \"\"\"\n     Import a module on the cache directory for modules and extract a class from it.\n \n     Args:\n         class_name (`str`): The name of the class to import.\n         module_path (`str` or `os.PathLike`): The path to the module to import.\n+        force_reload (`bool`, *optional*, defaults to `False`):\n+            Whether to reload the dynamic module from file if it already exists in `sys.modules`.\n+            Otherwise, the module is only reloaded if the file has changed.\n \n     Returns:\n         `typing.Type`: The class looked for.\n@@ -206,15 +218,30 @@ def get_class_in_module(class_name: str, module_path: Union[str, os.PathLike]) -\n     if name.endswith(\".py\"):\n         name = name[:-3]\n     name = name.replace(os.path.sep, \".\")\n-    module_spec = importlib.util.spec_from_file_location(name, location=Path(HF_MODULES_CACHE) / module_path)\n-    module = sys.modules.get(name)\n-    if module is None:\n-        module = importlib.util.module_from_spec(module_spec)\n-        # insert it into sys.modules before any loading begins\n-        sys.modules[name] = module\n-    # reload in both cases\n-    module_spec.loader.exec_module(module)\n-    return getattr(module, class_name)\n+    module_file: Path = Path(HF_MODULES_CACHE) / module_path\n+    with _HF_REMOTE_CODE_LOCK:\n+        if force_reload:\n+            sys.modules.pop(name, None)\n+            importlib.invalidate_caches()\n+        cached_module: Optional[ModuleType] = sys.modules.get(name)\n+        module_spec = importlib.util.spec_from_file_location(name, location=module_file)\n+\n+        # Hash the module file and all its relative imports to check if we need to reload it\n+        module_files: List[Path] = [module_file] + sorted(map(Path, get_relative_import_files(module_file)))\n+        module_hash: str = hashlib.sha256(b\"\".join(bytes(f) + f.read_bytes() for f in module_files)).hexdigest()\n+\n+        module: ModuleType\n+        if cached_module is None:\n+            module = importlib.util.module_from_spec(module_spec)\n+            # insert it into sys.modules before any loading begins\n+            sys.modules[name] = module\n+        else:\n+            module = cached_module\n+        # reload in both cases, unless the module is already imported and the hash hits\n+        if getattr(module, \"__transformers_module_hash__\", \"\") != module_hash:\n+            module_spec.loader.exec_module(module)\n+            module.__transformers_module_hash__ = module_hash\n+        return getattr(module, class_name)\n \n \n def get_cached_module_file(\n@@ -515,7 +542,7 @@ def get_class_from_dynamic_module(\n         local_files_only=local_files_only,\n         repo_type=repo_type,\n     )\n-    return get_class_in_module(class_name, final_module)\n+    return get_class_in_module(class_name, final_module, force_reload=force_download)\n \n \n def custom_object_save(obj: Any, folder: Union[str, os.PathLike], config: Optional[Dict] = None) -> List[str]:"
        },
        {
            "sha": "c208985ef63b4c0afbe3da457ba1b27fc74ea032",
            "filename": "tests/models/auto/test_configuration_auto.py",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/huggingface/transformers/blob/e1c2b69c341f088d59949d1eabfc022c12d4c797/tests%2Fmodels%2Fauto%2Ftest_configuration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e1c2b69c341f088d59949d1eabfc022c12d4c797/tests%2Fmodels%2Fauto%2Ftest_configuration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fauto%2Ftest_configuration_auto.py?ref=e1c2b69c341f088d59949d1eabfc022c12d4c797",
            "patch": "@@ -122,12 +122,27 @@ def test_from_pretrained_dynamic_config(self):\n         config = AutoConfig.from_pretrained(\"hf-internal-testing/test_dynamic_model\", trust_remote_code=True)\n         self.assertEqual(config.__class__.__name__, \"NewModelConfig\")\n \n+        # Test the dynamic module is loaded only once.\n+        reloaded_config = AutoConfig.from_pretrained(\"hf-internal-testing/test_dynamic_model\", trust_remote_code=True)\n+        self.assertIs(config.__class__, reloaded_config.__class__)\n+\n         # Test config can be reloaded.\n         with tempfile.TemporaryDirectory() as tmp_dir:\n             config.save_pretrained(tmp_dir)\n             reloaded_config = AutoConfig.from_pretrained(tmp_dir, trust_remote_code=True)\n         self.assertEqual(reloaded_config.__class__.__name__, \"NewModelConfig\")\n \n+        # The configuration file is cached in the snapshot directory. So the module file is not changed after dumping\n+        # to a temp dir. Because the revision of the configuration file is not changed.\n+        # Test the dynamic module is loaded only once if the configuration file is not changed.\n+        self.assertIs(config.__class__, reloaded_config.__class__)\n+\n+        # Test the dynamic module is reloaded if we force it.\n+        reloaded_config = AutoConfig.from_pretrained(\n+            \"hf-internal-testing/test_dynamic_model\", trust_remote_code=True, force_download=True\n+        )\n+        self.assertIsNot(config.__class__, reloaded_config.__class__)\n+\n     def test_from_pretrained_dynamic_config_conflict(self):\n         class NewModelConfigLocal(BertConfig):\n             model_type = \"new-model\""
        },
        {
            "sha": "d36183a63c6a9d67ed31ded255ca1fccde87ce7f",
            "filename": "tests/models/auto/test_feature_extraction_auto.py",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/huggingface/transformers/blob/e1c2b69c341f088d59949d1eabfc022c12d4c797/tests%2Fmodels%2Fauto%2Ftest_feature_extraction_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e1c2b69c341f088d59949d1eabfc022c12d4c797/tests%2Fmodels%2Fauto%2Ftest_feature_extraction_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fauto%2Ftest_feature_extraction_auto.py?ref=e1c2b69c341f088d59949d1eabfc022c12d4c797",
            "patch": "@@ -116,12 +116,29 @@ def test_from_pretrained_dynamic_feature_extractor(self):\n         )\n         self.assertEqual(feature_extractor.__class__.__name__, \"NewFeatureExtractor\")\n \n+        # Test the dynamic module is loaded only once.\n+        reloaded_feature_extractor = AutoFeatureExtractor.from_pretrained(\n+            \"hf-internal-testing/test_dynamic_feature_extractor\", trust_remote_code=True\n+        )\n+        self.assertIs(feature_extractor.__class__, reloaded_feature_extractor.__class__)\n+\n         # Test feature extractor can be reloaded.\n         with tempfile.TemporaryDirectory() as tmp_dir:\n             feature_extractor.save_pretrained(tmp_dir)\n             reloaded_feature_extractor = AutoFeatureExtractor.from_pretrained(tmp_dir, trust_remote_code=True)\n         self.assertEqual(reloaded_feature_extractor.__class__.__name__, \"NewFeatureExtractor\")\n \n+        # The feature extractor file is cached in the snapshot directory. So the module file is not changed after dumping\n+        # to a temp dir. Because the revision of the module file is not changed.\n+        # Test the dynamic module is loaded only once if the module file is not changed.\n+        self.assertIs(feature_extractor.__class__, reloaded_feature_extractor.__class__)\n+\n+        # Test the dynamic module is reloaded if we force it.\n+        reloaded_feature_extractor = AutoFeatureExtractor.from_pretrained(\n+            \"hf-internal-testing/test_dynamic_feature_extractor\", trust_remote_code=True, force_download=True\n+        )\n+        self.assertIsNot(feature_extractor.__class__, reloaded_feature_extractor.__class__)\n+\n     def test_new_feature_extractor_registration(self):\n         try:\n             AutoConfig.register(\"custom\", CustomConfig)"
        },
        {
            "sha": "c0046ae1c363cd44863e0911fed541b77f28ee30",
            "filename": "tests/models/auto/test_image_processing_auto.py",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/huggingface/transformers/blob/e1c2b69c341f088d59949d1eabfc022c12d4c797/tests%2Fmodels%2Fauto%2Ftest_image_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e1c2b69c341f088d59949d1eabfc022c12d4c797/tests%2Fmodels%2Fauto%2Ftest_image_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fauto%2Ftest_image_processing_auto.py?ref=e1c2b69c341f088d59949d1eabfc022c12d4c797",
            "patch": "@@ -167,12 +167,29 @@ def test_from_pretrained_dynamic_image_processor(self):\n         )\n         self.assertEqual(image_processor.__class__.__name__, \"NewImageProcessor\")\n \n+        # Test the dynamic module is loaded only once.\n+        reloaded_image_processor = AutoImageProcessor.from_pretrained(\n+            \"hf-internal-testing/test_dynamic_image_processor\", trust_remote_code=True\n+        )\n+        self.assertIs(image_processor.__class__, reloaded_image_processor.__class__)\n+\n         # Test image processor can be reloaded.\n         with tempfile.TemporaryDirectory() as tmp_dir:\n             image_processor.save_pretrained(tmp_dir)\n             reloaded_image_processor = AutoImageProcessor.from_pretrained(tmp_dir, trust_remote_code=True)\n         self.assertEqual(reloaded_image_processor.__class__.__name__, \"NewImageProcessor\")\n \n+        # The image processor file is cached in the snapshot directory. So the module file is not changed after dumping\n+        # to a temp dir. Because the revision of the module file is not changed.\n+        # Test the dynamic module is loaded only once if the module file is not changed.\n+        self.assertIs(image_processor.__class__, reloaded_image_processor.__class__)\n+\n+        # Test the dynamic module is reloaded if we force it.\n+        reloaded_image_processor = AutoImageProcessor.from_pretrained(\n+            \"hf-internal-testing/test_dynamic_image_processor\", trust_remote_code=True, force_download=True\n+        )\n+        self.assertIsNot(image_processor.__class__, reloaded_image_processor.__class__)\n+\n     def test_new_image_processor_registration(self):\n         try:\n             AutoConfig.register(\"custom\", CustomConfig)"
        },
        {
            "sha": "39770b091befe8c978305b74e513e539d60ddeb5",
            "filename": "tests/models/auto/test_modeling_auto.py",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/huggingface/transformers/blob/e1c2b69c341f088d59949d1eabfc022c12d4c797/tests%2Fmodels%2Fauto%2Ftest_modeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e1c2b69c341f088d59949d1eabfc022c12d4c797/tests%2Fmodels%2Fauto%2Ftest_modeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fauto%2Ftest_modeling_auto.py?ref=e1c2b69c341f088d59949d1eabfc022c12d4c797",
            "patch": "@@ -319,6 +319,10 @@ def test_from_pretrained_dynamic_model_distant(self):\n         model = AutoModel.from_pretrained(\"hf-internal-testing/test_dynamic_model\", trust_remote_code=True)\n         self.assertEqual(model.__class__.__name__, \"NewModel\")\n \n+        # Test the dynamic module is loaded only once.\n+        reloaded_model = AutoModel.from_pretrained(\"hf-internal-testing/test_dynamic_model\", trust_remote_code=True)\n+        self.assertIs(model.__class__, reloaded_model.__class__)\n+\n         # Test model can be reloaded.\n         with tempfile.TemporaryDirectory() as tmp_dir:\n             model.save_pretrained(tmp_dir)\n@@ -328,10 +332,27 @@ def test_from_pretrained_dynamic_model_distant(self):\n         for p1, p2 in zip(model.parameters(), reloaded_model.parameters()):\n             self.assertTrue(torch.equal(p1, p2))\n \n+        # The model file is cached in the snapshot directory. So the module file is not changed after dumping\n+        # to a temp dir. Because the revision of the module file is not changed.\n+        # Test the dynamic module is loaded only once if the module file is not changed.\n+        self.assertIs(model.__class__, reloaded_model.__class__)\n+\n+        # Test the dynamic module is reloaded if we force it.\n+        reloaded_model = AutoModel.from_pretrained(\n+            \"hf-internal-testing/test_dynamic_model\", trust_remote_code=True, force_download=True\n+        )\n+        self.assertIsNot(model.__class__, reloaded_model.__class__)\n+\n         # This one uses a relative import to a util file, this checks it is downloaded and used properly.\n         model = AutoModel.from_pretrained(\"hf-internal-testing/test_dynamic_model_with_util\", trust_remote_code=True)\n         self.assertEqual(model.__class__.__name__, \"NewModel\")\n \n+        # Test the dynamic module is loaded only once.\n+        reloaded_model = AutoModel.from_pretrained(\n+            \"hf-internal-testing/test_dynamic_model_with_util\", trust_remote_code=True\n+        )\n+        self.assertIs(model.__class__, reloaded_model.__class__)\n+\n         # Test model can be reloaded.\n         with tempfile.TemporaryDirectory() as tmp_dir:\n             model.save_pretrained(tmp_dir)\n@@ -341,6 +362,17 @@ def test_from_pretrained_dynamic_model_distant(self):\n         for p1, p2 in zip(model.parameters(), reloaded_model.parameters()):\n             self.assertTrue(torch.equal(p1, p2))\n \n+        # The model file is cached in the snapshot directory. So the module file is not changed after dumping\n+        # to a temp dir. Because the revision of the module file is not changed.\n+        # Test the dynamic module is loaded only once if the module file is not changed.\n+        self.assertIs(model.__class__, reloaded_model.__class__)\n+\n+        # Test the dynamic module is reloaded if we force it.\n+        reloaded_model = AutoModel.from_pretrained(\n+            \"hf-internal-testing/test_dynamic_model_with_util\", trust_remote_code=True, force_download=True\n+        )\n+        self.assertIsNot(model.__class__, reloaded_model.__class__)\n+\n     def test_from_pretrained_dynamic_model_distant_with_ref(self):\n         model = AutoModel.from_pretrained(\"hf-internal-testing/ref_to_test_dynamic_model\", trust_remote_code=True)\n         self.assertEqual(model.__class__.__name__, \"NewModel\")"
        },
        {
            "sha": "f49ece15fface24a1748470ddb185751cd22f573",
            "filename": "tests/models/auto/test_tokenization_auto.py",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/huggingface/transformers/blob/e1c2b69c341f088d59949d1eabfc022c12d4c797/tests%2Fmodels%2Fauto%2Ftest_tokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e1c2b69c341f088d59949d1eabfc022c12d4c797/tests%2Fmodels%2Fauto%2Ftest_tokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fauto%2Ftest_tokenization_auto.py?ref=e1c2b69c341f088d59949d1eabfc022c12d4c797",
            "patch": "@@ -314,6 +314,13 @@ def test_from_pretrained_dynamic_tokenizer(self):\n \n         tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/test_dynamic_tokenizer\", trust_remote_code=True)\n         self.assertTrue(tokenizer.special_attribute_present)\n+\n+        # Test the dynamic module is loaded only once.\n+        reloaded_tokenizer = AutoTokenizer.from_pretrained(\n+            \"hf-internal-testing/test_dynamic_tokenizer\", trust_remote_code=True\n+        )\n+        self.assertIs(tokenizer.__class__, reloaded_tokenizer.__class__)\n+\n         # Test tokenizer can be reloaded.\n         with tempfile.TemporaryDirectory() as tmp_dir:\n             tokenizer.save_pretrained(tmp_dir)\n@@ -340,6 +347,18 @@ def test_from_pretrained_dynamic_tokenizer(self):\n             self.assertEqual(tokenizer.__class__.__name__, \"NewTokenizer\")\n             self.assertEqual(reloaded_tokenizer.__class__.__name__, \"NewTokenizer\")\n \n+        # The tokenizer file is cached in the snapshot directory. So the module file is not changed after dumping\n+        # to a temp dir. Because the revision of the module file is not changed.\n+        # Test the dynamic module is loaded only once if the module file is not changed.\n+        self.assertIs(tokenizer.__class__, reloaded_tokenizer.__class__)\n+\n+        # Test the dynamic module is reloaded if we force it.\n+        reloaded_tokenizer = AutoTokenizer.from_pretrained(\n+            \"hf-internal-testing/test_dynamic_tokenizer\", trust_remote_code=True, force_download=True\n+        )\n+        self.assertIsNot(tokenizer.__class__, reloaded_tokenizer.__class__)\n+        self.assertTrue(reloaded_tokenizer.special_attribute_present)\n+\n     @require_tokenizers\n     def test_from_pretrained_dynamic_tokenizer_conflict(self):\n         class NewTokenizer(BertTokenizer):"
        }
    ],
    "stats": {
        "total": 151,
        "additions": 139,
        "deletions": 12
    }
}