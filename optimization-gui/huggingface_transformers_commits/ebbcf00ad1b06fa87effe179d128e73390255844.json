{
    "author": "BakerBunker",
    "message": "Adding support for Qwen3Omni (#41025)\n\n* Add Qwen3Omni\n\n* make fix-copies, import properly\n\n* nit\n\n* fix wrong setup. Why was audio_token_id renamed ?\n\n* upds\n\n* more processing fixes\n\n* yup\n\n* fix more generation tests\n\n* down to 1?\n\n* fix import issue\n\n* style, update check repo\n\n* up\n\n* fix quality at my best\n\n* final quality?\n\n* fix doc building\n\n* FINAL COMMIT: SKIP IMPORTANT BUT FAILING TESTS FOR MERGE\n\n* SKIP THE TEMPLATE ONE\n\n---------\n\nCo-authored-by: lvyuanjun.lyj <lvyuanjun.lyj@alibaba-inc.com>\nCo-authored-by: Arthur <arthur.zucker@gmail.com>",
    "sha": "ebbcf00ad1b06fa87effe179d128e73390255844",
    "files": [
        {
            "sha": "c690bddf36a0cca31290e3f29f8368a254716418",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -1143,6 +1143,8 @@\n         title: Qwen2Audio\n       - local: model_doc/qwen2_vl\n         title: Qwen2VL\n+      - local: model_doc/qwen3_omni_moe\n+        title: Qwen3-Omni-MoE\n       - local: model_doc/qwen3_vl\n         title: Qwen3VL\n       - local: model_doc/qwen3_vl_moe"
        },
        {
            "sha": "04d77534f649509db45b0a034eed1469c5ff4fa8",
            "filename": "docs/source/en/model_doc/qwen3_omni_moe.md",
            "status": "added",
            "additions": 414,
            "deletions": 0,
            "changes": 414,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen3_omni_moe.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen3_omni_moe.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen3_omni_moe.md?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -0,0 +1,414 @@\n+<!--Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+*This model was released on 2025-03-26 and added to Hugging Face Transformers on 2025-04-14.*\n+\n+# Qwen2.5-Omni\n+\n+<div class=\"flex flex-wrap space-x-1\">\n+<img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+<img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+<img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+</div>\n+\n+## Overview\n+\n+The [Qwen2.5-Omni](https://qwenlm.github.io/blog/qwen2.5-omni/) model is a unified multiple modalities model proposed in [Qwen2.5-Omni Technical Report](https://huggingface.co/papers/2503.20215) from Qwen team, Alibaba Group.\n+\n+The abstract from the technical report is the following:\n+\n+*We present Qwen2.5-Omni, an end-to-end multimodal model designed to perceive diverse modalities, including text, images, audio, and video, while simultaneously generating text and natural speech responses in a streaming manner. To enable the streaming of multimodal information inputs, both audio and visual encoders utilize a block-wise processing approach. This strategy effectively decouples the handling of long sequences of multimodal data, assigning the perceptual responsibilities to the multimodal encoder and entrusting the modeling of extended sequences to a large language model. Such a division of labor enhances the fusion of different modalities via the shared attention mechanism. To synchronize the timestamps of video inputs with audio, we organized the audio and video sequentially in an interleaved manner and propose a novel position embedding approach, named TMRoPE (Time-aligned Multimodal RoPE). To concurrently generate text and speech while avoiding interference between the two modalities, we propose Thinker-Talker architecture. In this framework, Thinker functions as a large language model tasked with text generation, while Talker is a dual-track autoregressive model that directly utilizes the hidden representations from the Thinker to produce audio tokens as output. Both the Thinker and Talker models are designed to be trained and inferred in an end-to-end manner. For decoding audio tokens in a streaming manner, we introduce a sliding-window DiT that restricts the receptive field, aiming to reduce the initial package delay. Qwen2.5-Omni outperforms the similarly sized Qwen2-VL and Qwen2-Audio in both image and audio capabilities. Furthermore, Qwen2.5-Omni achieves state-of-the-art performance on multimodal benchmarks like Omni-Bench. Notably, Qwen2.5-Omni is the first open-source model to achieve a level of performance in end-to-end speech instruction following that is comparable to its capabilities with text inputs, as evidenced by benchmarks such as MMLU and GSM8K. As for speech generation, Qwen2.5-Omniâ€™s streaming Talker outperform most existing streaming and non-streaming alternatives in robustness and naturalness.*\n+\n+\n+\n+## Notes\n+\n+- Use [`Qwen2_5OmniForConditionalGeneration`] to generate audio and text output. To generate only one output type, use [`Qwen2_5OmniThinkerForConditionalGeneration`] for text-only and [`Qwen2_5OmniTalkersForConditionalGeneration`] for audio-only outputs.\n+- Audio generation with [`Qwen2_5OmniForConditionalGeneration`] supports only single batch size at the moment.\n+- In case out out-of-memory errors hwen working with video input, decrease `processor.max_pixels`. By default the maximum is set to a very arge value and high resolution visuals will not be resized, unless resolution exceeds `processor.max_pixels`.\n+- The processor has its own [`~ProcessorMixin.apply_chat_template`] method to convert chat messages to model inputs.\n+\n+\n+## Usage example\n+\n+`Qwen2.5-Omni` can be found on the [Huggingface Hub](https://huggingface.co/Qwen).\n+\n+### Single Media inference\n+\n+The model can accept text, images, audio and videos as input. Here's an example code for inference.\n+\n+```python\n+import soundfile as sf\n+from transformers import Qwen2_5OmniForConditionalGeneration, Qwen2_5OmniProcessor\n+\n+model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-Omni-7B\",\n+    dtype=\"auto\",\n+    device_map=\"auto\"\n+)\n+processor = Qwen2_5OmniProcessor.from_pretrained(\"Qwen/Qwen2.5-Omni-7B\")\n+\n+conversations = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"}\n+        ],\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"video\", \"video\": \"/path/to/video.mp4\"},\n+            {\"type\": \"text\", \"text\": \"What cant you hear and see in this video?\"},\n+        ],\n+    },\n+]\n+\n+inputs = processor.apply_chat_template(\n+    conversations,\n+    load_audio_from_video=True,\n+    add_generation_prompt=True,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\",\n+    video_fps=1,\n+\n+    # kwargs to be passed to `Qwen2-5-OmniProcessor`\n+    padding=True,\n+    use_audio_in_video=True,\n+).to(model.device)\n+\n+# Generation params for audio or text can be different and have to be prefixed with `thinker_` or `talker_`\n+text_ids, audio = model.generate(**inputs, use_audio_in_video=True, thinker_do_sample=False, talker_do_sample=True)\n+text = processor.batch_decode(text_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)\n+\n+sf.write(\n+    \"output.wav\",\n+    audio.reshape(-1).detach().cpu().numpy(),\n+    samplerate=24000,\n+)\n+print(text)\n+```\n+\n+### Text-only generation\n+\n+To generate only text output and save compute by not loading the audio generation model, we can use `Qwen2_5OmniThinkerForConditionalGeneration` model.  \n+\n+```python\n+from transformers import Qwen2_5OmniThinkerForConditionalGeneration, Qwen2_5OmniProcessor\n+\n+model = Qwen2_5OmniThinkerForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-Omni-7B\",\n+    dtype=\"auto\",\n+    device_map=\"auto\",\n+)\n+processor = Qwen2_5OmniProcessor.from_pretrained(\"Qwen/Qwen2.5-Omni-7B\")\n+\n+conversations = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"}\n+        ],\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"video\", \"video\": \"/path/to/video.mp4\"},\n+            {\"type\": \"text\", \"text\": \"What cant you hear and see in this video?\"},\n+        ],\n+    },\n+]\n+\n+inputs = processor.apply_chat_template(\n+    conversations,\n+    load_audio_from_video=True,\n+    add_generation_prompt=True,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\",\n+    video_fps=1,\n+\n+    # kwargs to be passed to `Qwen2-5-OmniProcessor`\n+    padding=True,\n+    use_audio_in_video=True,\n+).to(model.device)\n+\n+\n+text_ids = model.generate(**inputs, use_audio_in_video=True)\n+text = processor.batch_decode(text_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)\n+\n+sf.write(\n+    \"output.wav\",\n+    audio.reshape(-1).detach().cpu().numpy(),\n+    samplerate=24000,\n+)\n+print(text)\n+```\n+\n+### Batch Mixed Media Inference\n+\n+The model can batch inputs composed of mixed samples of various types such as text, images, audio and videos as input when using `Qwen2_5OmniThinkerForConditionalGeneration` model. Here is an example.\n+\n+```python\n+import soundfile as sf\n+from transformers import Qwen2_5OmniForConditionalGeneration, Qwen2_5OmniProcessor\n+\n+model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-Omni-7B\",\n+    dtype=\"auto\",\n+    device_map=\"auto\"\n+)\n+processor = Qwen2_5OmniProcessor.from_pretrained(\"Qwen/Qwen2.5-Omni-7B\")\n+\n+# Conversation with video only\n+conversation1 = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"}\n+        ],\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"video\", \"path\": \"/path/to/video.mp4\"},\n+        ]\n+    }\n+]\n+\n+# Conversation with audio only\n+conversation2 = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"}\n+        ],\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"audio\", \"path\": \"/path/to/audio.wav\"},\n+        ]\n+    }\n+]\n+\n+# Conversation with pure text\n+conversation3 = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"}\n+        ],\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [{\"type\": \"text\", \"text\": \"who are you?\"}],\n+    }\n+]\n+\n+\n+# Conversation with mixed media\n+conversation4 = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"}\n+        ],\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\", \"path\": \"/path/to/image.jpg\"},\n+            {\"type\": \"video\", \"path\": \"/path/to/video.mp4\"},\n+            {\"type\": \"audio\", \"path\": \"/path/to/audio.wav\"},\n+            {\"type\": \"text\", \"text\": \"What are the elements can you see and hear in these medias?\"},\n+        ],\n+    }\n+]\n+\n+conversations = [conversation1, conversation2, conversation3, conversation4]\n+\n+inputs = processor.apply_chat_template(\n+    conversations,\n+    load_audio_from_video=True,\n+    add_generation_prompt=True,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\",\n+    video_fps=1,\n+\n+    # kwargs to be passed to `Qwen2-5-OmniProcessor`\n+    padding=True,\n+    use_audio_in_video=True,\n+).to(model.thinker.device)\n+\n+text_ids = model.generate(**inputs, use_audio_in_video=True)\n+text = processor.batch_decode(text_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)\n+\n+print(text)\n+```\n+\n+### Usage Tips\n+\n+#### Image Resolution trade-off\n+\n+The model supports a wide range of resolution inputs. By default, it uses the native resolution for input, but higher resolutions can enhance performance at the cost of more computation. Users can set the minimum and maximum number of pixels to achieve an optimal configuration for their needs.\n+\n+```python\n+min_pixels = 128*28*28\n+max_pixels = 768*28*28\n+processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2.5-Omni-7B\", min_pixels=min_pixels, max_pixels=max_pixels)\n+```\n+\n+#### Prompt for audio output\n+If users need audio output, the system prompt must be set as \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\", otherwise the audio output may not work as expected.\n+```\n+{\n+    \"role\": \"system\",\n+    \"content\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\",\n+}\n+```\n+\n+#### Use audio output or not\n+\n+The model supports both text and audio outputs, if users do not need audio outputs, they can set `enable_audio_output` in the `from_pretrained` function. This option will save about `~2GB` of GPU memory but the `return_audio` option for `generate` function will only allow to be set at `False`.\n+```python\n+model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-Omni-7B\",\n+    dtype=\"auto\",\n+    device_map=\"auto\",\n+    enable_audio_output=False,\n+)\n+```\n+\n+In order to obtain a flexible experience, we recommend that users set `enable_audio_output` at `True` when initializing the model through `from_pretrained` function, and then decide whether to return audio when `generate` function is called. When `return_audio` is set to `False`, the model will only return text outputs to get text responses faster.\n+\n+```python\n+model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-Omni-7B\",\n+    dtype=\"auto\",\n+    device_map=\"auto\",\n+    enable_audio_output=True,\n+)\n+...\n+text_ids = model.generate(**inputs, return_audio=False)\n+```\n+\n+#### Change voice type of output audio\n+Qwen2.5-Omni supports the ability to change the voice of the output audio. Users can use the `spk` parameter of `generate` function to specify the voice type. The `\"Qwen/Qwen2.5-Omni-7B\"` checkpoint support two voice types: `Chelsie` and `Ethan`, while `Chelsie` is a female voice and `Ethan` is a male voice. By default, if `spk` is not specified, the default voice type is `Chelsie`.\n+\n+```python\n+text_ids, audio = model.generate(**inputs, spk=\"Chelsie\")\n+```\n+\n+```python\n+text_ids, audio = model.generate(**inputs, spk=\"Ethan\")\n+```\n+\n+#### Flash-Attention 2 to speed up generation\n+\n+First, make sure to install the latest version of Flash Attention 2:\n+\n+```bash\n+pip install -U flash-attn --no-build-isolation\n+```\n+\n+Also, you should have hardware that is compatible with FlashAttention 2. Read more about it in the official documentation of the [flash attention repository](https://github.com/Dao-AILab/flash-attention). FlashAttention-2 can only be used when a model is loaded in `torch.float16` or `torch.bfloat16`.\n+\n+To load and run a model using FlashAttention-2, add `attn_implementation=\"flash_attention_2\"` when loading the model:\n+\n+```python\n+from transformers import Qwen2_5OmniForConditionalGeneration\n+\n+model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-Omni-7B\",\n+    device_map=\"auto\",\n+    dtype=torch.bfloat16,\n+    attn_implementation=\"flash_attention_2\",\n+)\n+```\n+\n+\n+\n+## Qwen3OmniMoeConfig\n+\n+[[autodoc]] Qwen3OmniMoeConfig\n+\n+## Qwen3OmniMoeThinkerConfig\n+\n+[[autodoc]] Qwen3OmniMoeThinkerConfig\n+\n+## Qwen3OmniMoeTalkerConfig\n+\n+[[autodoc]] Qwen3OmniMoeTalkerConfig\n+\n+## Qwen3OmniMoeForConditionalGeneration\n+\n+[[autodoc]] Qwen3OmniMoeForConditionalGeneration\n+\n+## Qwen3OmniMoeThinkerTextModel\n+\n+[[autodoc]] Qwen3OmniMoeThinkerTextModel\n+\n+## Qwen3OmniMoeThinkerForConditionalGeneration\n+\n+[[autodoc]] Qwen3OmniMoeThinkerForConditionalGeneration\n+\n+## Qwen3OmniMoeTalkerForConditionalGeneration\n+\n+[[autodoc]] Qwen3OmniMoeTalkerForConditionalGeneration\n+\n+## Qwen3OmniMoePreTrainedModel\n+\n+[[autodoc]] Qwen3OmniMoePreTrainedModel\n+\n+## Qwen3OmniMoePreTrainedModelForConditionalGeneration\n+\n+[[autodoc]] Qwen3OmniMoePreTrainedModelForConditionalGeneration\n+\n+## Qwen3OmniMoeTalkerModel\n+\n+[[autodoc]] Qwen3OmniMoeTalkerModel\n+\n+## Qwen3OmniMoeThinkerTextPreTrainedModel\n+\n+[[autodoc]] Qwen3OmniMoeThinkerTextPreTrainedModel\n+\n+## Qwen3OmniMoeProcessor\n+\n+[[autodoc]] Qwen3OmniMoeProcessor\n+\n+## Qwen3OmniMoeCode2Wav\n+\n+[[autodoc]] Qwen3OmniMoeCode2Wav\n+\n+## Qwen3OmniMoeCode2WavDecoderBlock\n+\n+[[autodoc]] Qwen3OmniMoeCode2WavDecoderBlock\n+\n+## Qwen3OmniMoeCode2WavTransformerModel\n+\n+[[autodoc]] Qwen3OmniMoeCode2WavTransformerModel\n+\n+## Qwen3OmniMoeTalkerCodePredictorModel\n+\n+[[autodoc]] Qwen3OmniMoeTalkerCodePredictorModel\n+\n+## Qwen3OmniMoeTalkerCodePredictorModelForConditionalGeneration\n+\n+[[autodoc]] Qwen3OmniMoeTalkerCodePredictorModelForConditionalGeneration\n+\n+"
        },
        {
            "sha": "1eb2b905ca4c380507156b45bc20c7a60e5b805d",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -283,6 +283,7 @@\n     from .qwen3 import *\n     from .qwen3_moe import *\n     from .qwen3_next import *\n+    from .qwen3_omni_moe import *\n     from .qwen3_vl import *\n     from .qwen3_vl_moe import *\n     from .rag import *"
        },
        {
            "sha": "0ee87f723d601ed4ac1e89966fdcb6fd6aa33502",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -330,6 +330,7 @@\n         (\"qwen3\", \"Qwen3Config\"),\n         (\"qwen3_moe\", \"Qwen3MoeConfig\"),\n         (\"qwen3_next\", \"Qwen3NextConfig\"),\n+        (\"qwen3_omni_moe\", \"Qwen3OmniMoeConfig\"),\n         (\"qwen3_vl\", \"Qwen3VLConfig\"),\n         (\"qwen3_vl_moe\", \"Qwen3VLMoeConfig\"),\n         (\"qwen3_vl_moe_text\", \"Qwen3VLMoeTextConfig\"),\n@@ -779,6 +780,7 @@\n         (\"qwen3\", \"Qwen3\"),\n         (\"qwen3_moe\", \"Qwen3MoE\"),\n         (\"qwen3_next\", \"Qwen3Next\"),\n+        (\"qwen3_omni_moe\", \"Qwen3OmniMoE\"),\n         (\"qwen3_vl\", \"Qwen3VL\"),\n         (\"qwen3_vl_moe\", \"Qwen3VLMoe\"),\n         (\"qwen3_vl_moe_text\", \"Qwen3VLMoe\"),"
        },
        {
            "sha": "01036e76222b94ec5cb9273387b9b25856fc3336",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -1654,6 +1654,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"musicgen\", \"MusicgenForConditionalGeneration\"),\n         (\"musicgen_melody\", \"MusicgenMelodyForConditionalGeneration\"),\n         (\"qwen2_5_omni\", \"Qwen2_5OmniForConditionalGeneration\"),\n+        (\"qwen3_omni_moe\", \"Qwen3OmniMoeForConditionalGeneration\"),\n         (\"seamless_m4t\", \"SeamlessM4TForTextToSpeech\"),\n         (\"seamless_m4t_v2\", \"SeamlessM4Tv2ForTextToSpeech\"),\n         (\"vits\", \"VitsModel\"),"
        },
        {
            "sha": "2b1ca09bb8df1ab0cbcd6360e5984a3a06f7935c",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -121,6 +121,7 @@\n         (\"qwen2_5_vl\", \"Qwen2_5_VLProcessor\"),\n         (\"qwen2_audio\", \"Qwen2AudioProcessor\"),\n         (\"qwen2_vl\", \"Qwen2VLProcessor\"),\n+        (\"qwen3_omni_moe\", \"Qwen3OmniMoeProcessor\"),\n         (\"qwen3_vl\", \"Qwen3VLProcessor\"),\n         (\"qwen3_vl_moe\", \"Qwen3VLProcessor\"),\n         (\"sam\", \"SamProcessor\"),"
        },
        {
            "sha": "c79bb7167b9aabc6112c602ef322187213f30646",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -586,6 +586,7 @@\n                 \"Qwen2TokenizerFast\" if is_tokenizers_available() else None,\n             ),\n         ),\n+        (\"qwen3_omni_moe\", (\"Qwen2Tokenizer\", \"Qwen2TokenizerFast\" if is_tokenizers_available() else None)),\n         (\"qwen3_vl\", (\"Qwen2Tokenizer\", \"Qwen2TokenizerFast\" if is_tokenizers_available() else None)),\n         (\"qwen3_vl_moe\", (\"Qwen2Tokenizer\", \"Qwen2TokenizerFast\" if is_tokenizers_available() else None)),\n         (\"rag\", (\"RagTokenizer\", None)),"
        },
        {
            "sha": "84bbc8e6fdb10ea5e0a72caec2135825ff95dc20",
            "filename": "src/transformers/models/auto/video_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fauto%2Fvideo_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fauto%2Fvideo_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fvideo_processing_auto.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -56,6 +56,7 @@\n             (\"qwen2_5_omni\", \"Qwen2VLVideoProcessor\"),\n             (\"qwen2_5_vl\", \"Qwen2VLVideoProcessor\"),\n             (\"qwen2_vl\", \"Qwen2VLVideoProcessor\"),\n+            (\"qwen3_omni_moe\", \"Qwen2VLVideoProcessor\"),\n             (\"qwen3_vl\", \"Qwen3VLVideoProcessor\"),\n             (\"qwen3_vl_moe\", \"Qwen3VLVideoProcessor\"),\n             (\"sam2_video\", \"Sam2VideoVideoProcessor\"),"
        },
        {
            "sha": "3d9d5f1066ef394b938339af0f75706b0b72b53f",
            "filename": "src/transformers/models/qwen2_5_omni/processing_qwen2_5_omni.py",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fprocessing_qwen2_5_omni.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fprocessing_qwen2_5_omni.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fprocessing_qwen2_5_omni.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -31,10 +31,10 @@\n \n \n class Qwen2_5_OmniVideosKwargs(VideosKwargs):\n-    fps: Optional[list[Union[int, float]]] = None\n-    use_audio_in_video: Optional[bool] = None\n-    seconds_per_chunk: Optional[float] = None\n-    position_id_per_seconds: Optional[int] = None\n+    fps: Optional[list[Union[int, float]]]\n+    use_audio_in_video: Optional[bool]\n+    seconds_per_chunk: Optional[float]\n+    position_id_per_seconds: Optional[int]\n     min_pixels: Optional[int]\n     max_pixels: Optional[int]\n     patch_size: Optional[int]"
        },
        {
            "sha": "bd9da380953378d7f9499d23c99535f16295b5e1",
            "filename": "src/transformers/models/qwen3_omni_moe/__init__.py",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2F__init__.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -0,0 +1,28 @@\n+# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_qwen3_omni_moe import *\n+    from .modeling_qwen3_omni_moe import *\n+    from .processing_qwen3_omni_moe import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "8eefcc595261e1c32380da81c894231703f0b4a8",
            "filename": "src/transformers/models/qwen3_omni_moe/configuration_qwen3_omni_moe.py",
            "status": "added",
            "additions": 1250,
            "deletions": 0,
            "changes": 1250,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fconfiguration_qwen3_omni_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fconfiguration_qwen3_omni_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fconfiguration_qwen3_omni_moe.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -0,0 +1,1250 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/qwen3_omni_moe/modular_qwen3_omni_moe.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_qwen3_omni_moe.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from ...configuration_utils import PretrainedConfig, layer_type_validation\n+from ...modeling_rope_utils import rope_config_validation\n+from ...utils import logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Qwen3OmniMoeAudioEncoderConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen3OmniMoeAudioEncoder`]. It is used to instantiate a\n+    Qwen2.5-Omni-Thinker audio encoder according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the audio encoder of the Qwen2-Audio\n+    architecture.\n+\n+    e.g. [Qwen/Qwen2.5-Omni-7B](https://huggingface.co/Qwen/Qwen2.5-Omni-7B)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        num_mel_bins (`int`, *optional*, defaults to 128):\n+            Number of mel features used per input features. Should correspond to the value used in the\n+            `Qwen3OmniMoeProcessor` class.\n+        encoder_layers (`int`, *optional*, defaults to 32):\n+            Number of encoder layers.\n+        encoder_attention_heads (`int`, *optional*, defaults to 20):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        encoder_ffn_dim (`int`, *optional*, defaults to 5120):\n+            Dimensionality of the \"intermediate\" (often named feed-forward) layer in encoder.\n+        d_model (`int`, *optional*, defaults to 1280):\n+            Dimensionality of the layers.\n+        dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        activation_function (`str`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+            `\"relu\"`, `\"silu\"` and `\"gelu_new\"` are supported.\n+        activation_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for activations inside the fully connected layer.\n+        scale_embedding (`bool`, *optional*, defaults to `False`):\n+            Scale embeddings by diving by sqrt(d_model).\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        max_source_positions (`int`, *optional*, defaults to 1500):\n+            The maximum sequence length of log-mel filter-bank features that this model might ever be used with.\n+        n_window (`int`, *optional*, defaults to 100):\n+            The chunk for conv and flash attn in AudioEncoder.\n+        output_dim (`int`, *optional*, defaults to 3584):\n+            The output dimension of AudioEncoder.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Qwen3OmniMoeAudioEncoderConfig, Qwen3OmniMoeAudioEncoder\n+\n+    >>> # Initializing a Qwen3OmniMoeAudioEncoderConfig\n+    >>> configuration = Qwen3OmniMoeAudioEncoderConfig()\n+\n+    >>> # Initializing a Qwen3OmniMoeAudioEncoder (with random weights)\n+    >>> model = Qwen3OmniMoeAudioEncoder(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen3_omni_moe_audio_encoder\"\n+\n+    def __init__(\n+        self,\n+        num_mel_bins=128,\n+        encoder_layers=32,\n+        encoder_attention_heads=20,\n+        encoder_ffn_dim=5120,\n+        d_model=1280,\n+        dropout=0,\n+        attention_dropout=0,\n+        activation_function=\"gelu\",\n+        activation_dropout=0,\n+        scale_embedding=False,\n+        initializer_range=0.02,\n+        max_source_positions=1500,\n+        n_window=100,\n+        output_dim=3584,\n+        n_window_infer=400,\n+        conv_chunksize=500,\n+        downsample_hidden_size=480,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.num_mel_bins = num_mel_bins\n+        self.d_model = d_model\n+        self.encoder_layers = encoder_layers\n+        self.encoder_attention_heads = encoder_attention_heads\n+        self.encoder_ffn_dim = encoder_ffn_dim\n+        self.dropout = dropout\n+        self.attention_dropout = attention_dropout\n+        self.activation_function = activation_function\n+        self.activation_dropout = activation_dropout\n+        self.num_hidden_layers = encoder_layers\n+        self.initializer_range = initializer_range\n+        self.scale_embedding = scale_embedding  # scale factor will be sqrt(d_model) if True\n+        self.max_source_positions = max_source_positions\n+        self.n_window = n_window\n+        self.output_dim = output_dim\n+        self.n_window_infer = n_window_infer\n+        self.conv_chunksize = conv_chunksize\n+        self.downsample_hidden_size = downsample_hidden_size\n+\n+\n+class Qwen3OmniMoeVisionEncoderConfig(PretrainedConfig):\n+    model_type = \"qwen3_omni_moe_vision_encoder\"\n+    base_config_key = \"vision_config\"\n+\n+    def __init__(\n+        self,\n+        depth=27,\n+        hidden_size=1152,\n+        hidden_act=\"gelu_pytorch_tanh\",\n+        intermediate_size=4304,\n+        num_heads=16,\n+        in_channels=3,\n+        patch_size=16,\n+        spatial_merge_size=2,\n+        temporal_patch_size=2,\n+        out_hidden_size=3584,\n+        num_position_embeddings=2304,\n+        deepstack_visual_indexes=[8, 16, 24],\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.depth = depth\n+        self.hidden_size = hidden_size\n+        self.hidden_act = hidden_act\n+        self.intermediate_size = intermediate_size\n+        self.num_heads = num_heads\n+        self.in_channels = in_channels\n+        self.patch_size = patch_size\n+        self.spatial_merge_size = spatial_merge_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.out_hidden_size = out_hidden_size\n+        self.num_position_embeddings = num_position_embeddings\n+        self.initializer_range = initializer_range\n+        self.deepstack_visual_indexes = deepstack_visual_indexes\n+\n+\n+class Qwen3OmniMoeTextConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen3OmniMoeTextModel`]. It is used to instantiate a\n+    Qwen3OmniMoeText model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of [Qwen/Qwen3-15B-A2B](https://huggingface.co/Qwen/Qwen3-15B-A2B).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 151936):\n+            Vocabulary size of the Qwen3OmniMoeText model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Qwen3OmniMoeTextModel`]\n+        hidden_size (`int`, *optional*, defaults to 2048):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 6144):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 24):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 32):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 4):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details, check out [this\n+            paper](https://huggingface.co/papers/2305.13245). If it is not specified, will default to `32`.\n+\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 32768):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n+                    'llama3'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n+                    pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n+                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n+                    `factor` field to infer the suggested value.\n+                `beta_fast` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for extrapolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 32.\n+                `beta_slow` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for interpolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 1.\n+                `short_factor` (`list[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to short contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `long_factor` (`list[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to long contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `low_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to low frequency components of the RoPE\n+                `high_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to high frequency components of the RoPE\n+        attention_bias (`bool`, defaults to `False`, *optional*, defaults to `False`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        use_sliding_window (`bool`, *optional*, defaults to `False`):\n+            Whether to use sliding window attention.\n+        sliding_window (`int`, *optional*, defaults to 4096):\n+            Sliding window attention (SWA) window size. If not specified, will default to `4096`.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        decoder_sparse_step (`int`, *optional*, defaults to 1):\n+            The frequency of the MoE layer.\n+        moe_intermediate_size (`int`, *optional*, defaults to 768):\n+            Intermediate size of the routed expert.\n+        num_experts_per_tok (`int`, *optional*, defaults to 8):\n+            Number of selected experts.\n+        num_experts (`int`, *optional*, defaults to 128):\n+            Number of routed experts.\n+        norm_topk_prob (`bool`, *optional*, defaults to `False`):\n+            Whether to normalize the topk probabilities.\n+        output_router_logits (`bool`, *optional*, defaults to `False`):\n+            Whether or not the router logits should be returned by the model. Enabling this will also\n+            allow the model to output the auxiliary loss, including load balancing loss and router z-loss.\n+        router_aux_loss_coef (`float`, *optional*, defaults to 0.001):\n+            The aux loss factor for the total loss.\n+        mlp_only_layers (`list[int]`, *optional*, defaults to `[]`):\n+            Indicate which layers use Qwen3OmniMoeTextMLP rather than Qwen3OmniMoeTextSparseMoeBlock\n+            The list contains layer index, from 0 to num_layers-1 if we have num_layers layers\n+            If `mlp_only_layers` is empty, `decoder_sparse_step` is used to determine the sparsity.\n+\n+    ```python\n+    >>> from transformers import Qwen3OmniMoeTextModel, Qwen3OmniMoeTextConfig\n+\n+    >>> # Initializing a Qwen3OmniMoeText style configuration\n+    >>> configuration = Qwen3OmniMoeTextConfig()\n+\n+    >>> # Initializing a model from the Qwen3-15B-A2B\" style configuration\n+    >>> model = Qwen3OmniMoeTextModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen3_omni_moe_text\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    # Default tensor parallel plan for base model `Qwen3OmniMoeText`\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.experts.*.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.experts.*.up_proj\": \"colwise\",\n+        \"layers.*.mlp.experts.*.down_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.up_proj\": \"colwise\",\n+        \"layers.*.mlp.down_proj\": \"rowwise\",\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=3584,\n+        hidden_size=2048,\n+        intermediate_size=18944,\n+        num_hidden_layers=28,\n+        num_attention_heads=28,\n+        num_key_value_heads=4,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=32768,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-6,\n+        use_cache=True,\n+        tie_word_embeddings=False,\n+        rope_theta=1000000.0,\n+        rope_scaling=None,\n+        attention_bias=False,\n+        sliding_window=None,\n+        attention_dropout=0,\n+        decoder_sparse_step=1,\n+        moe_intermediate_size=768,\n+        num_experts_per_tok=8,\n+        num_experts=128,\n+        norm_topk_prob=True,\n+        output_router_logits=False,\n+        router_aux_loss_coef=0.001,\n+        mlp_only_layers=None,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.sliding_window = sliding_window\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, move it to 'rope_type'.\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self)\n+\n+        # MoE arguments\n+        self.decoder_sparse_step = decoder_sparse_step\n+        self.moe_intermediate_size = moe_intermediate_size\n+        self.num_experts_per_tok = num_experts_per_tok\n+        self.num_experts = num_experts\n+        self.norm_topk_prob = norm_topk_prob\n+        self.output_router_logits = output_router_logits\n+        self.router_aux_loss_coef = router_aux_loss_coef\n+        self.mlp_only_layers = [] if mlp_only_layers is None else mlp_only_layers\n+\n+\n+class Qwen3OmniMoeThinkerConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen3OmniMoeThinker`]. It is used to instantiate a\n+    Qwen3-Omni-Thinker model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the thinker component of the Qwen3-Omni\n+    architecture.\n+\n+    e.g. [Qwen/Qwen3-Omni-7B](https://huggingface.co/Qwen/Qwen3-Omni-7B)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        audio_config (`dict`, *optional*):\n+            The config dictionary of the audio backbone.\n+        vision_config (`dict`, *optional*):\n+            The config dictionary of the vision backbone.\n+        text_config (`dict`, *optional*):\n+            The config dictionary of the text backbone.\n+        audio_token_id (`int`, *optional*, defaults to 151646):\n+            The audio token id to encode the audio prompt.\n+        image_token_id (`int`, *optional*, defaults to 151655):\n+            The image token id to encode the image prompt.\n+        video_token_id (`int`, *optional*, defaults to 151656):\n+            The video token id to encode the video prompt.\n+        position_id_per_seconds (`int`, *optional*, defaults to 25):\n+            The increment of position id per second.\n+        audio_start_token_id (`int`, *optional*, defaults to 151647):\n+            The audio start token id to encode the audio prompt.\n+        user_token_id (`int`, *optional*, defaults to 872):\n+            The user token id to encode the user token.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Qwen3OmniMoeThinkerModel, Qwen3OmniMoeThinkerConfig\n+\n+    >>> # Initializing a default Qwen3OmniMoeThinkerConfig\n+    >>> configuration = Qwen3OmniMoeThinkerConfig()\n+\n+    >>> # Initializing a model (with random weights) from the default configuration\n+    >>> model = Qwen3OmniMoeThinkerModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen3_omni_moe_thinker\"\n+    attribute_map = {\n+        \"image_token_id\": \"image_token_index\",\n+        \"video_token_id\": \"video_token_index\",\n+        \"audio_token_id\": \"audio_token_index\",\n+    }\n+    sub_configs = {\n+        \"audio_config\": Qwen3OmniMoeAudioEncoderConfig,\n+        \"vision_config\": Qwen3OmniMoeVisionEncoderConfig,\n+        \"text_config\": Qwen3OmniMoeTextConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        audio_config=None,\n+        vision_config=None,\n+        text_config=None,\n+        audio_token_id=151646,\n+        image_token_id=151655,\n+        video_token_id=151656,\n+        position_id_per_seconds=25,\n+        audio_start_token_id=151647,\n+        user_token_id=872,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        self.user_token_id = user_token_id\n+        self.position_id_per_seconds = position_id_per_seconds\n+        self.audio_start_token_id = audio_start_token_id\n+        self.initializer_range = initializer_range\n+\n+        if isinstance(vision_config, dict):\n+            vision_config = Qwen3OmniMoeVisionEncoderConfig(**vision_config)\n+        elif vision_config is None:\n+            vision_config = Qwen3OmniMoeVisionEncoderConfig()\n+        self.vision_config = vision_config\n+\n+        if isinstance(audio_config, dict):\n+            audio_config = Qwen3OmniMoeAudioEncoderConfig(**audio_config)\n+        elif audio_config is None:\n+            audio_config = Qwen3OmniMoeAudioEncoderConfig()\n+        self.audio_config = audio_config\n+\n+        if isinstance(text_config, dict):\n+            text_config = Qwen3OmniMoeTextConfig(**text_config)\n+        elif text_config is None:\n+            text_config = Qwen3OmniMoeTextConfig()\n+        self.text_config = text_config\n+        self.audio_token_id = audio_token_id\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+\n+\n+class Qwen3OmniMoeTalkerCodePredictorConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen3OmniMoeTalkerCodePredictorModel`]. It is used to instantiate a\n+    Qwen3OmniMoeTalkerCodePredictor model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of\n+    Qwen3OmniMoeTalkerCodePredictor-8B [Qwen/Qwen3OmniMoeTalkerCodePredictor-8B](https://huggingface.co/Qwen/Qwen3OmniMoeTalkerCodePredictor-8B).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 151936):\n+            Vocabulary size of the Qwen3OmniMoeTalkerCodePredictor model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Qwen3OmniMoeTalkerCodePredictorModel`]\n+        hidden_size (`int`, *optional*, defaults to 4096):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 22016):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 32):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 32):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 32):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details, check out [this\n+            paper](https://huggingface.co/papers/2305.13245). If it is not specified, will default to `32`.\n+        head_dim (`int`, *optional*, defaults to 128):\n+            The attention head dimension.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 32768):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n+                    'llama3'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n+                    pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n+                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n+                    `factor` field to infer the suggested value.\n+                `beta_fast` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for extrapolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 32.\n+                `beta_slow` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for interpolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 1.\n+                `short_factor` (`list[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to short contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `long_factor` (`list[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to long contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `low_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to low frequency components of the RoPE\n+                `high_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to high frequency components of the RoPE\n+        attention_bias (`bool`, defaults to `False`, *optional*, defaults to `False`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        use_sliding_window (`bool`, *optional*, defaults to `False`):\n+            Whether to use sliding window attention.\n+        sliding_window (`int`, *optional*, defaults to 4096):\n+            Sliding window attention (SWA) window size. If not specified, will default to `4096`.\n+        max_window_layers (`int`, *optional*, defaults to 28):\n+            The number of layers using full attention. The first `max_window_layers` layers will use full attention, while any\n+            additional layer afterwards will use SWA (Sliding Window Attention).\n+        layer_types (`list`, *optional*):\n+            Attention pattern for each layer.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+\n+    ```python\n+    >>> from transformers import Qwen3OmniMoeTalkerCodePredictorModel, Qwen3OmniMoeTalkerCodePredictorConfig\n+\n+    >>> # Initializing a Qwen3OmniMoeTalkerCodePredictor style configuration\n+    >>> configuration = Qwen3OmniMoeTalkerCodePredictorConfig()\n+\n+    >>> # Initializing a model from the Qwen3OmniMoeTalkerCodePredictor-8B style configuration\n+    >>> model = Qwen3OmniMoeTalkerCodePredictorModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen3_omni_moe_talker_code_predictor\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    # Default tensor parallel plan for base model `Qwen3OmniMoeTalkerCodePredictor`\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.up_proj\": \"colwise\",\n+        \"layers.*.mlp.down_proj\": \"rowwise\",\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=2048,\n+        hidden_size=1024,\n+        intermediate_size=3072,\n+        num_hidden_layers=5,\n+        num_attention_heads=16,\n+        num_key_value_heads=8,\n+        head_dim=128,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=32768,\n+        initializer_range=0.02,\n+        rms_norm_eps=0.000001,\n+        use_cache=True,\n+        tie_word_embeddings=False,\n+        rope_theta=10000,\n+        rope_scaling=None,\n+        attention_bias=False,\n+        sliding_window=None,\n+        layer_types=None,\n+        attention_dropout=0,\n+        num_code_groups=32,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.sliding_window = sliding_window\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.head_dim = head_dim\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, move it to 'rope_type'.\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self)\n+\n+        self.layer_types = layer_types\n+        if self.layer_types is None:\n+            self.layer_types = [\n+                \"sliding_attention\"\n+                if self.sliding_window is not None and i >= self.max_window_layers\n+                else \"full_attention\"\n+                for i in range(self.num_hidden_layers)\n+            ]\n+        layer_type_validation(self.layer_types, self.num_hidden_layers)\n+        self.num_code_groups = num_code_groups\n+\n+\n+class Qwen3OmniMoeTalkerTextConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen3OmniMoeTalkerTextModel`]. It is used to instantiate a\n+    Qwen3OmniMoeTalkerText model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of [Qwen/Qwen3-15B-A2B](https://huggingface.co/Qwen/Qwen3-15B-A2B).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 151936):\n+            Vocabulary size of the Qwen3OmniMoeTalkerText model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Qwen3OmniMoeTalkerTextModel`]\n+        hidden_size (`int`, *optional*, defaults to 2048):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 6144):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 24):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 32):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 4):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details, check out [this\n+            paper](https://huggingface.co/papers/2305.13245). If it is not specified, will default to `32`.\n+\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 32768):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n+                    'llama3'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n+                    pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n+                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n+                    `factor` field to infer the suggested value.\n+                `beta_fast` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for extrapolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 32.\n+                `beta_slow` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for interpolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 1.\n+                `short_factor` (`list[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to short contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `long_factor` (`list[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to long contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `low_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to low frequency components of the RoPE\n+                `high_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to high frequency components of the RoPE\n+        attention_bias (`bool`, defaults to `False`, *optional*, defaults to `False`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        use_sliding_window (`bool`, *optional*, defaults to `False`):\n+            Whether to use sliding window attention.\n+        sliding_window (`int`, *optional*, defaults to 4096):\n+            Sliding window attention (SWA) window size. If not specified, will default to `4096`.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        decoder_sparse_step (`int`, *optional*, defaults to 1):\n+            The frequency of the MoE layer.\n+        moe_intermediate_size (`int`, *optional*, defaults to 768):\n+            Intermediate size of the routed expert.\n+        num_experts_per_tok (`int`, *optional*, defaults to 8):\n+            Number of selected experts.\n+        num_experts (`int`, *optional*, defaults to 128):\n+            Number of routed experts.\n+        norm_topk_prob (`bool`, *optional*, defaults to `False`):\n+            Whether to normalize the topk probabilities.\n+        output_router_logits (`bool`, *optional*, defaults to `False`):\n+            Whether or not the router logits should be returned by the model. Enabling this will also\n+            allow the model to output the auxiliary loss, including load balancing loss and router z-loss.\n+        router_aux_loss_coef (`float`, *optional*, defaults to 0.001):\n+            The aux loss factor for the total loss.\n+        mlp_only_layers (`list[int]`, *optional*, defaults to `[]`):\n+            Indicate which layers use Qwen3OmniMoeTalkerTextMLP rather than Qwen3OmniMoeTalkerTextSparseMoeBlock\n+            The list contains layer index, from 0 to num_layers-1 if we have num_layers layers\n+            If `mlp_only_layers` is empty, `decoder_sparse_step` is used to determine the sparsity.\n+\n+    ```python\n+    >>> from transformers import Qwen3OmniMoeTalkerTextModel, Qwen3OmniMoeTalkerTextConfig\n+\n+    >>> # Initializing a Qwen3OmniMoeTalkerText style configuration\n+    >>> configuration = Qwen3OmniMoeTalkerTextConfig()\n+\n+    >>> # Initializing a model from the Qwen3-15B-A2B\" style configuration\n+    >>> model = Qwen3OmniMoeTalkerTextModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen3_omni_moe_talker_text\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    # Default tensor parallel plan for base model `Qwen3OmniMoeTalkerText`\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.experts.*.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.experts.*.up_proj\": \"colwise\",\n+        \"layers.*.mlp.experts.*.down_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.up_proj\": \"colwise\",\n+        \"layers.*.mlp.down_proj\": \"rowwise\",\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=3072,\n+        hidden_size=1024,\n+        intermediate_size=2048,\n+        num_hidden_layers=20,\n+        num_attention_heads=16,\n+        num_key_value_heads=2,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=32768,\n+        initializer_range=0.02,\n+        rms_norm_eps=0.000001,\n+        use_cache=True,\n+        tie_word_embeddings=False,\n+        rope_theta=10000,\n+        rope_scaling=None,\n+        attention_bias=False,\n+        sliding_window=None,\n+        attention_dropout=0,\n+        decoder_sparse_step=1,\n+        moe_intermediate_size=384,\n+        num_experts_per_tok=8,\n+        num_experts=128,\n+        norm_topk_prob=False,\n+        output_router_logits=False,\n+        router_aux_loss_coef=0.001,\n+        mlp_only_layers=None,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.sliding_window = sliding_window\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, move it to 'rope_type'.\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self)\n+\n+        # MoE arguments\n+        self.decoder_sparse_step = decoder_sparse_step\n+        self.moe_intermediate_size = moe_intermediate_size\n+        self.num_experts_per_tok = num_experts_per_tok\n+        self.num_experts = num_experts\n+        self.norm_topk_prob = norm_topk_prob\n+        self.output_router_logits = output_router_logits\n+        self.router_aux_loss_coef = router_aux_loss_coef\n+        self.mlp_only_layers = [] if mlp_only_layers is None else mlp_only_layers\n+\n+\n+class Qwen3OmniMoeTalkerConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen3OmniMoeTalker`]. It is used to instantiate a\n+    Qwen3-Omni multi-modal talker model capable of handling text, audio, and vision modalities in a unified architecture.\n+    The model integrates a text decoder with a code predictor for autoregressive generation of both semantic and acoustic\n+    tokens, enabling speech and multimodal content generation. This configuration wraps sub-configurations for the text and\n+    code predictor components, allowing modular setup and initialization.\n+\n+    e.g. [Qwen/Qwen3-Omni-7B](https://huggingface.co/Qwen/Qwen3-Omni-7B)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        code_predictor_config (`dict`, *optional*):\n+            A dictionary of configuration parameters used to initialize a [`Qwen3OmniMoeTalkerCodePredictorConfig`].\n+            If not provided, defaults will be used.\n+        text_config (`dict`, *optional*):\n+            A dictionary of configuration parameters used to initialize a [`Qwen3OmniMoeTalkerTextConfig`].\n+            If not provided, defaults will be used.\n+        num_code_groups (`int`, *optional*, defaults to 32):\n+            Number of codebook groups used in the predicted acoustic token sequence, corresponding to multi-codebook VQ representation.\n+        thinker_hidden_size (`int`, *optional*, defaults to 2048):\n+            Hidden dimension size of the thinker module used for intermediate reasoning or latent planning before audio generation.\n+        codec_eos_token_id (`int`, *optional*, defaults to 4198):\n+            Token ID representing the end-of-speech token in the codec-generated sequence.\n+        accept_hidden_layer (`int`, *optional*, defaults to 18):\n+            Index of the hidden layer whose output is used for accepting or refining generated tokens during think-and-speak process.\n+        codec_nothink_id (`int`, *optional*, defaults to 4203):\n+            Token ID indicating no thinking step is required during generation.\n+        codec_think_bos_id (`int`, *optional*, defaults to 4204):\n+            Token ID marking the beginning of a thinking sequence.\n+        codec_think_eos_id (`int`, *optional*, defaults to 4205):\n+            Token ID marking the end of a thinking sequence.\n+        codec_pad_id (`int`, *optional*, defaults to 4196):\n+            Padding token ID used in codec input sequences.\n+        codec_bos_id (`int`, *optional*, defaults to 4197):\n+            Beginning-of-speech token ID in codec sequences.\n+        audio_token_id (`int`, *optional*, defaults to 151646):\n+            Special token ID used to indicate the position of audio tokens in the input sequence.\n+        image_token_id (`int`, *optional*, defaults to 151655):\n+            Special token ID used to represent image inputs in the multimodal context.\n+        video_token_id (`int`, *optional*, defaults to 151656):\n+            Special token ID used to represent video inputs.\n+        vision_start_token_id (`int`, *optional*, defaults to 151652):\n+            Token ID indicating the start of a visual input sequence (e.g., image or video embeddings).\n+        position_id_per_seconds (`int`, *optional*, defaults to 25):\n+            Number of position IDs allocated per second of audio content, used for temporal alignment in generation.\n+        audio_start_token_id (`int`, *optional*, defaults to 151669):\n+            Token ID that indicates the start of an audio generation segment in the output.\n+        speaker_id (`dict`, *optional*):\n+            Speaker name to speaker id dict.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Qwen3OmniMoeTalkerConfig, Qwen3OmniMoeTalker\n+\n+    >>> # Initialize a Qwen3OmniMoeTalkerConfig with default sub-configurations\n+    >>> config = Qwen3OmniMoeTalkerConfig(\n+    ...     num_code_groups=32,\n+    ...     thinker_hidden_size=2048,\n+    ... )\n+\n+    >>> # Initialize the full Qwen3-Omni Talker model\n+    >>> model = Qwen3OmniMoeTalker(config)\n+\n+    >>> # Access the model configuration\n+    >>> config = model.config\n+    >>> print(config.text_config)  # Access text decoder configuration\n+    >>> print(config.code_predictor_config)  # Access code predictor configuration\n+    ```\"\"\"\n+\n+    sub_configs = {\n+        \"code_predictor_config\": Qwen3OmniMoeTalkerCodePredictorConfig,\n+        \"text_config\": Qwen3OmniMoeTalkerTextConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        code_predictor_config=None,\n+        text_config=None,\n+        num_code_groups=32,\n+        thinker_hidden_size=2048,\n+        codec_eos_token_id=4198,\n+        accept_hidden_layer=18,\n+        codec_nothink_id=4203,\n+        codec_think_bos_id=4204,\n+        codec_think_eos_id=4205,\n+        codec_pad_id=4196,\n+        codec_bos_id=4197,\n+        audio_token_id=151646,\n+        image_token_id=151655,\n+        video_token_id=151656,\n+        vision_start_token_id=151652,\n+        position_id_per_seconds=25,\n+        audio_start_token_id=151669,\n+        speaker_id=None,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        if code_predictor_config is None:\n+            code_predictor_config = {}\n+            self.code_predictor_config = Qwen3OmniMoeTalkerCodePredictorConfig()\n+            logger.info(\"code_predictor_config is None. Initializing code_predictor_config model with default values\")\n+        elif isinstance(code_predictor_config, Qwen3OmniMoeTalkerCodePredictorConfig):\n+            self.code_predictor_config = code_predictor_config\n+        else:\n+            self.code_predictor_config = Qwen3OmniMoeTalkerCodePredictorConfig(**code_predictor_config)\n+\n+        if text_config is None:\n+            text_config = {}\n+            self.text_config = Qwen3OmniMoeTalkerTextConfig()\n+            logger.info(\"talker text_config is None. Initializing talker text model with default values\")\n+        elif isinstance(text_config, Qwen3OmniMoeTalkerTextConfig):\n+            self.text_config = text_config\n+        else:\n+            self.text_config = Qwen3OmniMoeTalkerTextConfig(**text_config)\n+        self.num_code_groups = num_code_groups\n+        self.thinker_hidden_size = thinker_hidden_size\n+        self.codec_eos_token_id = codec_eos_token_id\n+        self.accept_hidden_layer = accept_hidden_layer\n+        self.codec_nothink_id = codec_nothink_id\n+        self.codec_think_bos_id = codec_think_bos_id\n+        self.codec_think_eos_id = codec_think_eos_id\n+        self.codec_pad_id = codec_pad_id\n+        self.codec_bos_id = codec_bos_id\n+        self.audio_token_id = audio_token_id\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.position_id_per_seconds = position_id_per_seconds\n+        self.audio_start_token_id = audio_start_token_id\n+        self.vision_start_token_id = vision_start_token_id\n+        self.speaker_id = speaker_id\n+\n+\n+class Qwen3OmniMoeCode2WavConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen3OmniMoeCode2WavConfig`]. It is used to instantiate a\n+    Qwen3-Omni code-to-waveform decoder, responsible for converting discrete audio codes into high-fidelity waveforms.\n+    The configuration defines the architecture of the decoder, including parameters for vector quantization, autoregressive modeling,\n+    and upsampling layers.\n+\n+    e.g. [Qwen/Qwen3-Omni-7B](https://huggingface.co/Qwen/Qwen3-Omni-7B)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        codebook_size (`int`, *optional*, defaults to 2048):\n+            Number of entries in each residual codebook used for acoustic token quantization.\n+        hidden_size (`int`, *optional*, defaults to 1024):\n+            Dimensionality of the hidden states and embeddings in the autoregressive transformer decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 8000):\n+            Maximum sequence length that the autoregressive decoder can handle. Determines positional embedding size.\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period for rotary position embeddings (RoPE) applied to attention layers.\n+        num_attention_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer in the decoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 16):\n+            Number of key and value attention heads used in grouped-query attention (if applicable).\n+        attention_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use bias in the attention projection layers.\n+        sliding_window (`int`, *optional*, defaults to 72):\n+            Window size for local attention mechanism, limiting attention context to improve efficiency.\n+        intermediate_size (`int`, *optional*, defaults to 3072):\n+            Dimensionality of the feed-forward (intermediate) layer in each transformer block.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function used in the feed-forward layers. Supports `\"silu\"`, `\"relu\"`, `\"gelu\"`, etc.\n+        layer_scale_initial_scale (`float`, *optional*, defaults to 0.01):\n+            Initial value for LayerScale applied in transformer blocks, helping stabilize training.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-5):\n+            Epsilon value for RMS normalization layers to prevent division by zero.\n+        num_hidden_layers (`int`, *optional*, defaults to 8):\n+            Number of transformer blocks in the autoregressive decoder.\n+        num_quantizers (`int`, *optional*, defaults to 16):\n+            Number of residual vector quantizers used in the vocoder for fine-grained audio reconstruction.\n+        upsample_rates (`Tuple[int]`, *optional*, defaults to `(8, 5, 4, 3)`):\n+            Rate at which features are upsampled in the final waveform synthesis stage.\n+        upsampling_ratios (`Tuple[int]`, *optional*, defaults to `(2, 2)`):\n+            Ratios used in transposed convolutional layers to progressively upsample feature maps to waveform.\n+        decoder_dim (`int`, *optional*, defaults to 1536):\n+            Final dimensionality of the decoder's output before waveform generation.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            Dropout probability applied to attention weights in the decoder.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Qwen3OmniMoeCode2WavConfig, Qwen3OmniMoeCode2WavModel\n+\n+    >>> # Initializing a default Qwen3OmniMoeCode2WavConfig\n+    >>> config = Qwen3OmniMoeCode2WavConfig()\n+\n+    >>> # Initializing the Code2Wav model with the configuration\n+    >>> model = Qwen3OmniMoeCode2WavModel(config)\n+\n+    >>> # Accessing configuration\n+    >>> config = model.config\n+    ```\"\"\"\n+\n+    def __init__(\n+        self,\n+        codebook_size=2048,\n+        hidden_size=1024,\n+        max_position_embeddings=8000,\n+        rope_theta=10000,\n+        num_attention_heads=16,\n+        num_key_value_heads=16,\n+        attention_bias=False,\n+        sliding_window=72,\n+        intermediate_size=3072,\n+        hidden_act=\"silu\",\n+        layer_scale_initial_scale=0.01,\n+        rms_norm_eps=1e-5,\n+        num_hidden_layers=8,\n+        num_quantizers=16,\n+        upsample_rates=(8, 5, 4, 3),\n+        upsampling_ratios=(2, 2),\n+        decoder_dim=1536,\n+        attention_dropout=0.0,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        self.codebook_size = codebook_size\n+        self.hidden_size = hidden_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.rope_theta = rope_theta\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads\n+        self.attention_bias = attention_bias\n+        self.sliding_window = sliding_window\n+        self.intermediate_size = intermediate_size\n+        self.hidden_act = hidden_act\n+        self.layer_scale_initial_scale = layer_scale_initial_scale\n+        self.rms_norm_eps = rms_norm_eps\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_quantizers = num_quantizers\n+        self.upsample_rates = upsample_rates\n+        self.upsampling_ratios = upsampling_ratios\n+        self.decoder_dim = decoder_dim\n+        self.attention_dropout = attention_dropout\n+\n+    @property\n+    def layer_types(self):\n+        \"\"\"\n+        All layer in code2wav should be sliding attention\n+        \"\"\"\n+        return [\"sliding_attention\"] * self.num_hidden_layers\n+\n+\n+class Qwen3OmniMoeConfig(PretrainedConfig):\n+    \"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen3OmniMoeForConditionalGeneration`]. It is used to instantiate a Qwen3Omni\n+    model according to the specified sub-models configurations, defining the model architecture.\n+\n+    Instantiating a configuration with the defaults will yield a similar configuration to that of the\n+    [Qwen/Qwen2.5-Omni-7B](https://huggingface.co/Qwen/Qwen2.5-Omni-7B) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        thinker_config (`dict`, *optional*): Configuration of the underlying thinker sub-model.\n+        talker_config (`dict`, *optional*): Configuration of the underlying talker sub-model.\n+        code2wav_config (`dict`, *optional*): Configuration of the underlying code2wav sub-model.\n+        enable_audio_output (`bool`, *optional*, defaults to `True`): Whether enable audio output and load talker and code2wav module.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import (\n+    ...     Qwen3OmniMoeThinkerConfig,\n+    ...     Qwen3OmniMoeTalkerConfig,\n+    ...     Qwen3OmniMoeCode2WavConfig,\n+    ...     Qwen3OmniMoeForConditionalGeneration,\n+    ...     Qwen3OmniMoeConfig,\n+    ... )\n+\n+    >>> # Initializing a Qwen3OmniMoe style configuration\n+    >>> configuration = Qwen3OmniMoeConfig()\n+\n+    >>> # Initializing a model from the configuration\n+    >>> model = Qwen3OmniMoeForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen3_omni_moe\"\n+    sub_configs = {\n+        \"thinker_config\": Qwen3OmniMoeThinkerConfig,\n+        \"talker_config\": Qwen3OmniMoeTalkerConfig,\n+        \"code2wav_config\": Qwen3OmniMoeCode2WavConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        thinker_config=None,\n+        talker_config=None,\n+        code2wav_config=None,\n+        enable_audio_output=True,\n+        im_start_token_id=151644,\n+        im_end_token_id=151645,\n+        tts_pad_token_id=151671,\n+        tts_bos_token_id=151672,\n+        tts_eos_token_id=151673,\n+        system_token_id=8948,\n+        user_token_id=872,\n+        assistant_token_id=77091,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        if thinker_config is None:\n+            thinker_config = {}\n+            logger.info(\"thinker_config is None. Initializing thinker model with default values\")\n+\n+        if talker_config is None:\n+            talker_config = {}\n+            logger.info(\"talker_config is None. Initializing talker model with default values\")\n+\n+        if code2wav_config is None:\n+            code2wav_config = {}\n+            logger.info(\"code2wav_config is None. Initializing code2wav model with default values\")\n+\n+        self.thinker_config = Qwen3OmniMoeThinkerConfig(**thinker_config)\n+        self.talker_config = Qwen3OmniMoeTalkerConfig(**talker_config)\n+        self.code2wav_config = Qwen3OmniMoeCode2WavConfig(**code2wav_config)\n+        self.enable_audio_output = enable_audio_output\n+        self.im_start_token_id = im_start_token_id\n+        self.im_end_token_id = im_end_token_id\n+        self.tts_pad_token_id = tts_pad_token_id\n+        self.tts_bos_token_id = tts_bos_token_id\n+        self.tts_eos_token_id = tts_eos_token_id\n+        self.system_token_id = system_token_id\n+        self.user_token_id = user_token_id\n+        self.assistant_token_id = assistant_token_id\n+\n+    def get_text_config(self, decoder=False) -> \"PretrainedConfig\":\n+        \"\"\"\n+        Returns the config that is meant to be used with text IO. On most models, it is the original config instance\n+        itself. On specific composite models, it is under a set of valid names.\n+\n+        Args:\n+            decoder (`Optional[bool]`, *optional*, defaults to `False`):\n+                If set to `True`, then only search for decoder config names.\n+        \"\"\"\n+        # Overridden for deeply nested config like Qwen2-Omni. We don't have any omni model\n+        # except for Qwen yet. This has to be generalized if more deeply nested configs are\n+        # added. NOTE: currently method used only by vLLM\n+        return self.thinker_config.get_text_config()\n+\n+\n+__all__ = [\"Qwen3OmniMoeConfig\", \"Qwen3OmniMoeThinkerConfig\", \"Qwen3OmniMoeTalkerConfig\"]"
        },
        {
            "sha": "2ddc4d656530aa3b0ba172707522461d9d559851",
            "filename": "src/transformers/models/qwen3_omni_moe/modeling_qwen3_omni_moe.py",
            "status": "added",
            "additions": 4067,
            "deletions": 0,
            "changes": 4067,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fmodeling_qwen3_omni_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fmodeling_qwen3_omni_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fmodeling_qwen3_omni_moe.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844"
        },
        {
            "sha": "8a7ba792f8467f475ad276890743d127860626d3",
            "filename": "src/transformers/models/qwen3_omni_moe/modular_qwen3_omni_moe.py",
            "status": "added",
            "additions": 2779,
            "deletions": 0,
            "changes": 2779,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fmodular_qwen3_omni_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fmodular_qwen3_omni_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fmodular_qwen3_omni_moe.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844"
        },
        {
            "sha": "f0506bf6930b91a4969501142fb68911f2c3d475",
            "filename": "src/transformers/models/qwen3_omni_moe/processing_qwen3_omni_moe.py",
            "status": "added",
            "additions": 360,
            "deletions": 0,
            "changes": 360,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fprocessing_qwen3_omni_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fprocessing_qwen3_omni_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fprocessing_qwen3_omni_moe.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -0,0 +1,360 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/qwen3_omni_moe/modular_qwen3_omni_moe.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_qwen3_omni_moe.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import re\n+from typing import Optional, Union\n+\n+import numpy as np\n+\n+from ...audio_utils import AudioInput\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_utils import ImageInput\n+from ...processing_utils import ImagesKwargs, ProcessingKwargs, ProcessorMixin, VideosKwargs\n+from ...tokenization_utils_base import TextInput\n+from ...video_utils import VideoInput, make_batched_videos\n+\n+\n+class Qwen3OmniMoeVideosKwargs(VideosKwargs):\n+    fps: Optional[list[Union[int, float]]]\n+    use_audio_in_video: Optional[bool]\n+    seconds_per_chunk: Optional[float]\n+    position_id_per_seconds: Optional[int]\n+    min_pixels: Optional[int]\n+    max_pixels: Optional[int]\n+    patch_size: Optional[int]\n+    temporal_patch_size: Optional[int]\n+    merge_size: Optional[int]\n+\n+\n+class Qwen3OmniMoeImagesKwargs(ImagesKwargs):\n+    min_pixels: Optional[int]\n+    max_pixels: Optional[int]\n+    patch_size: Optional[int]\n+    temporal_patch_size: Optional[int]\n+    merge_size: Optional[int]\n+\n+\n+class Qwen3OmniMoeProcessorKwargs(ProcessingKwargs, total=False):\n+    videos_kwargs: Qwen3OmniMoeVideosKwargs\n+    images_kwargs: Qwen3OmniMoeImagesKwargs\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": False,\n+            \"padding_side\": \"left\",\n+        },\n+        \"videos_kwargs\": {\n+            \"seconds_per_chunk\": 2.0,\n+            \"position_id_per_seconds\": 13.0,\n+            \"use_audio_in_video\": False,\n+            \"size\": {\n+                \"shortest_edge\": 128 * 32 * 32,\n+                \"longest_edge\": 768 * 32 * 32,\n+            },\n+        },\n+        \"audio_kwargs\": {\n+            \"sampling_rate\": 16000,\n+            \"padding\": True,\n+            \"return_attention_mask\": True,\n+        },\n+    }\n+\n+\n+def _get_feat_extract_output_lengths(input_lengths):\n+    \"\"\"\n+    Computes the output length of the convolutional layers and the output length of the audio encoder\n+    \"\"\"\n+\n+    input_lengths_leave = input_lengths % 100\n+    feat_lengths = (input_lengths_leave - 1) // 2 + 1\n+    output_lengths = ((feat_lengths - 1) // 2 + 1 - 1) // 2 + 1 + (input_lengths // 100) * 13\n+    return output_lengths\n+\n+\n+class Qwen3OmniMoeProcessor(ProcessorMixin):\n+    r\"\"\"\n+    Constructs a Qwen2.5Omni processor.\n+    [`Qwen3OmniMoeProcessor`] offers all the functionalities of [`Qwen2VLImageProcessor`], [`WhisperFeatureExtractor`], and [`Qwen2TokenizerFast`]. See the\n+    [`~Qwen3OmniMoeProcessor.__call__`] and [`~Qwen3OmniMoeProcessor.decode`] for more information.\n+\n+    Args:\n+        image_processor ([`Qwen2VLImageProcessor`], *optional*):\n+            The image processor.\n+        video_processor ([`Qwen2VLVideoProcessor`], *optional*):\n+            The video processor.\n+        feature_extractor ([`WhisperFeatureExtractor`], *optional*):\n+            The audio feature extractor.\n+        tokenizer ([`Qwen2TokenizerFast`], *optional*):\n+            The text tokenizer.\n+        chat_template (`Optional[str]`, *optional*):\n+            The Jinja template to use for formatting the conversation. If not provided, the default chat template is used.\n+    \"\"\"\n+\n+    attributes = [\"image_processor\", \"video_processor\", \"feature_extractor\", \"tokenizer\"]\n+    image_processor_class = \"AutoImageProcessor\"\n+    video_processor_class = \"AutoVideoProcessor\"\n+    feature_extractor_class = \"WhisperFeatureExtractor\"\n+    tokenizer_class = (\"Qwen2Tokenizer\", \"Qwen2TokenizerFast\")\n+\n+    def __init__(\n+        self, image_processor=None, video_processor=None, feature_extractor=None, tokenizer=None, chat_template=None\n+    ):\n+        super().__init__(image_processor, video_processor, feature_extractor, tokenizer, chat_template=chat_template)\n+        self.image_token = self.tokenizer.image_token\n+        self.audio_token = self.tokenizer.audio_token\n+        self.video_token = self.tokenizer.video_token\n+        self.vision_bos_token = self.tokenizer.vision_bos_token\n+        self.vision_eos_token = self.tokenizer.vision_eos_token\n+        self.audio_bos_token = self.tokenizer.audio_bos_token\n+        self.audio_eos_token = self.tokenizer.audio_eos_token\n+\n+    def __call__(\n+        self,\n+        text: TextInput = None,\n+        images: ImageInput = None,\n+        videos: VideoInput = None,\n+        audio: AudioInput = None,\n+        **kwargs,\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Main method to prepare for the model one or several sequences(s) and audio(s). This method forwards the `text`\n+        and `kwargs` arguments to Qwen2TokenizerFast's [`~Qwen2TokenizerFast.__call__`] if `text` is not `None` to encode\n+        the text. To prepare the audio(s), this method forwards the `audio` and `kwargs` arguments to\n+        WhisperFeatureExtractor's [`~WhisperFeatureExtractor.__call__`] if `audio` is not `None`. To prepare the vision inputs,\n+        this method forwards the `vision_infos` and `kwargs` arguments to Qwen2VLImageProcessor's [`~Qwen2VLImageProcessor.__call__`]\n+        if `vision_infos` is not `None`. Please refer to the doctsring\n+        of the above two methods for more information.\n+\n+        Args:\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. Both channels-first and channels-last formats are supported.\n+            videos (`np.ndarray`, `torch.Tensor`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n+                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n+            audio (`np.ndarray`, `List[np.ndarray]`):\n+                The audio or batch of audio to be prepared. Each audio can be a NumPy array.\n+        \"\"\"\n+\n+        if text is None:\n+            raise ValueError(\"You need to specify either a `text` input to process.\")\n+\n+        output_kwargs = self._merge_kwargs(\n+            Qwen3OmniMoeProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+\n+        seconds_per_chunk = output_kwargs[\"videos_kwargs\"].pop(\"seconds_per_chunk\")\n+        position_id_per_seconds = output_kwargs[\"videos_kwargs\"].pop(\"position_id_per_seconds\")\n+        use_audio_in_video = output_kwargs[\"videos_kwargs\"].pop(\"use_audio_in_video\")\n+        fps = output_kwargs[\"videos_kwargs\"].get(\"fps\", 1.0)\n+\n+        if audio is not None:\n+            output_kwargs[\"audio_kwargs\"][\"padding\"] = True  # Setting to True to avoid default truncation\n+            audio_inputs = self.feature_extractor(audio, **output_kwargs[\"audio_kwargs\"])\n+            audio_inputs[\"feature_attention_mask\"] = audio_inputs.pop(\n+                \"attention_mask\"\n+            )  # rename feature_attention_mask to prevent conflicts later on\n+            audio_inputs[\"input_features\"] = audio_inputs.pop(\n+                \"input_features\"\n+            )  # rename input_features to prevent conflicts later on\n+            audio_lengths = iter(_get_feat_extract_output_lengths(audio_inputs[\"feature_attention_mask\"].sum(-1)))\n+        else:\n+            audio_inputs = {}\n+            audio_lengths = iter([])\n+\n+        if images is not None:\n+            images_inputs = self.image_processor(images=images, videos=None, **output_kwargs[\"images_kwargs\"])\n+            image_grid_thw = iter(images_inputs[\"image_grid_thw\"])\n+        else:\n+            images_inputs = {}\n+            image_grid_thw = iter([])\n+\n+        if videos is not None:\n+            videos = make_batched_videos(videos)\n+            videos_inputs = self.video_processor(images=None, videos=videos, **output_kwargs[\"videos_kwargs\"])\n+            fps = [fps] * len(videos)\n+            videos_inputs[\"video_second_per_grid\"] = [\n+                self.video_processor.temporal_patch_size / fps[i] for i in range(len(fps))\n+            ]\n+            video_grid_thw = iter(videos_inputs[\"video_grid_thw\"])\n+            video_second_per_grid = iter(videos_inputs[\"video_second_per_grid\"])\n+        else:\n+            videos_inputs = {}\n+            video_grid_thw = iter([])\n+            video_second_per_grid = iter([])\n+\n+        if not isinstance(text, list):\n+            text = [text]\n+\n+        text = self.replace_multimodal_special_tokens(\n+            text,\n+            audio_lengths,\n+            image_grid_thw,\n+            video_grid_thw,\n+            video_second_per_grid=video_second_per_grid,\n+            use_audio_in_video=use_audio_in_video,\n+            position_id_per_seconds=position_id_per_seconds,\n+            seconds_per_chunk=seconds_per_chunk,\n+        )\n+\n+        texts_inputs = self.tokenizer(text, **output_kwargs[\"text_kwargs\"])\n+\n+        return BatchFeature(\n+            data={**texts_inputs, **images_inputs, **videos_inputs, **audio_inputs},\n+            tensor_type=kwargs.get(\"return_tensors\"),\n+        )\n+\n+    def replace_multimodal_special_tokens(\n+        self,\n+        text,\n+        audio_lengths,\n+        image_grid_thw,\n+        video_grid_thw,\n+        video_second_per_grid,\n+        use_audio_in_video,\n+        position_id_per_seconds,\n+        seconds_per_chunk,\n+    ):\n+        # Extend mm token length\n+        merge_length_image = self.image_processor.merge_size**2\n+        merge_length_video = self.video_processor.merge_size**2\n+\n+        processed_text = []\n+        for sample in text:\n+            positions = []\n+            special_tokens = [re.escape(tok) for tok in [self.audio_token, self.image_token, self.video_token]]\n+            pattern = \"|\".join(special_tokens)\n+            positions = sorted([(match.start(), match.group()) for match in re.finditer(pattern, sample)])\n+            positions.sort(key=lambda x: x[0])\n+\n+            for _, special_token in positions:\n+                if special_token == self.audio_token:\n+                    sample = sample.replace(self.audio_token, \"<|audio_placeholder|>\" * next(audio_lengths), 1)\n+                elif special_token == self.image_token:\n+                    image_seq_length = next(image_grid_thw).prod() // merge_length_image\n+                    sample = sample.replace(self.image_token, \"<|image_placeholder|>\" * image_seq_length, 1)\n+                elif special_token == self.video_token:\n+                    if not use_audio_in_video:\n+                        video_seq_length = next(video_grid_thw).prod() // merge_length_video\n+                        sample = sample.replace(self.video_token, \"<|video_placeholder|>\" * video_seq_length, 1)\n+                    else:\n+                        audio_token_indices = np.arange(next(audio_lengths))\n+                        curr_video_grid_thw = next(video_grid_thw)\n+                        height = curr_video_grid_thw[1] // self.video_processor.merge_size\n+                        width = curr_video_grid_thw[2] // self.video_processor.merge_size\n+                        video_token_indices = np.arange(curr_video_grid_thw[0]).reshape(-1, 1, 1)\n+                        video_token_indices = np.broadcast_to(\n+                            video_token_indices, (video_token_indices.shape[0], height, width)\n+                        ).reshape(-1)\n+                        video_token_indices = (\n+                            video_token_indices * next(video_second_per_grid) * position_id_per_seconds\n+                        )\n+\n+                        video_data_index, audio_data_index = 0, 0\n+                        placeholder_string = self.vision_bos_token + self.audio_bos_token\n+                        while video_data_index < len(video_token_indices) and audio_data_index < len(\n+                            audio_token_indices\n+                        ):\n+                            if video_token_indices[video_data_index] <= audio_token_indices[audio_data_index]:\n+                                placeholder_string += \"<|video_placeholder|>\"\n+                                video_data_index += 1\n+                            else:\n+                                placeholder_string += \"<|audio_placeholder|>\"\n+                                audio_data_index += 1\n+                        if video_data_index < len(video_token_indices):\n+                            placeholder_string += \"<|video_placeholder|>\" * (\n+                                len(video_token_indices) - video_data_index\n+                            )\n+                        if audio_data_index < len(audio_token_indices):\n+                            placeholder_string += \"<|audio_placeholder|>\" * (\n+                                len(audio_token_indices) - audio_data_index\n+                            )\n+                        placeholder_string += self.audio_eos_token + self.vision_eos_token\n+                        sample = sample.replace(\n+                            self.vision_bos_token + self.video_token + self.vision_eos_token,\n+                            placeholder_string,\n+                            1,\n+                        )\n+\n+            sample = sample.replace(\"<|audio_placeholder|>\", self.audio_token)\n+            sample = sample.replace(\"<|image_placeholder|>\", self.image_token)\n+            sample = sample.replace(\"<|video_placeholder|>\", self.video_token)\n+            processed_text.append(sample)\n+        return processed_text\n+\n+    def get_chunked_index(self, token_indices: np.ndarray, tokens_per_chunk: int) -> list[tuple[int, int]]:\n+        \"\"\"\n+        Splits token index list into chunks based on token value ranges.\n+\n+        Given a list of token indices, returns a list of (start, end) index tuples representing\n+        slices of the list where the token values fall within successive ranges of `t_ntoken_per_chunk`.\n+\n+        For example, if `t_ntoken_per_chunk` is 1000, the function will create chunks such that:\n+        - the first chunk contains token values < 1000,\n+        - the second chunk contains values >= 1000 and < 2000, and so on.\n+\n+        Parameters:\n+            token_indices (`np.ndarray`): A monotonically increasing list of token index values.\n+            t_ntoken_per_chunk (`int`): Number of tokens per chunk (used as the chunk size threshold).\n+\n+        Returns:\n+            `list[tuple[int, int]]`: A list of tuples, each representing the start (inclusive)\n+                                and end (exclusive) indices of a chunk in `token_indices`.\n+        \"\"\"\n+\n+        def _iter():\n+            i, start_idx = 0, 0  # skip bos token\n+            current_chunk = 1\n+            while i < len(token_indices):  # skip eos token\n+                if token_indices[i] >= current_chunk * tokens_per_chunk:\n+                    yield (start_idx, i)\n+                    start_idx = i\n+                    current_chunk += 1\n+                i += 1\n+            yield (start_idx, len(token_indices))\n+\n+        return list(_iter())\n+\n+    def apply_chat_template(self, conversations, chat_template=None, **kwargs):\n+        return super().apply_chat_template(conversations, chat_template, **kwargs)\n+\n+    @property\n+    def model_input_names(self):\n+        tokenizer_input_names = self.tokenizer.model_input_names\n+        feature_extractor_input_names = self.feature_extractor.model_input_names\n+        image_processor_input_names = self.image_processor.model_input_names\n+        return list(\n+            dict.fromkeys(\n+                tokenizer_input_names\n+                + feature_extractor_input_names\n+                + image_processor_input_names\n+                + [\"feature_attention_mask\"]\n+                + [\"video_second_per_grid\"]\n+            )\n+        )\n+\n+\n+__all__ = [\"Qwen3OmniMoeProcessor\"]"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/qwen3_omni_moe/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/tests%2Fmodels%2Fqwen3_omni_moe%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/tests%2Fmodels%2Fqwen3_omni_moe%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen3_omni_moe%2F__init__.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844"
        },
        {
            "sha": "c0870bceda8d5dc413019fe323b460ee9c4cf59d",
            "filename": "tests/models/qwen3_omni_moe/test_modeling_qwen3_omni_moe.py",
            "status": "added",
            "additions": 878,
            "deletions": 0,
            "changes": 878,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/tests%2Fmodels%2Fqwen3_omni_moe%2Ftest_modeling_qwen3_omni_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/tests%2Fmodels%2Fqwen3_omni_moe%2Ftest_modeling_qwen3_omni_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen3_omni_moe%2Ftest_modeling_qwen3_omni_moe.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -0,0 +1,878 @@\n+# coding=utf-8\n+# Copyright 2025 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch Qwen2.5-Omni model.\"\"\"\n+\n+import tempfile\n+import unittest\n+from io import BytesIO\n+from urllib.request import urlopen\n+\n+import librosa\n+import pytest\n+import requests\n+\n+from transformers import (\n+    AutoProcessor,\n+    Qwen3OmniMoeForConditionalGeneration,\n+    Qwen3OmniMoeThinkerConfig,\n+    Qwen3OmniMoeThinkerForConditionalGeneration,\n+    is_torch_available,\n+    is_vision_available,\n+)\n+from transformers.testing_utils import (\n+    Expectations,\n+    cleanup,\n+    require_flash_attn,\n+    require_torch,\n+    require_torch_gpu,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import (\n+    ModelTesterMixin,\n+    floats_tensor,\n+    ids_tensor,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+class Qwen3OmniMoeThinkerForConditionalGenerationTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=3,\n+        feat_seq_length=30,\n+        num_channels=3,\n+        image_size=16,\n+        seq_length=39,\n+        audio_token_id=1,\n+        image_token_id=2,\n+        video_token_id=3,\n+        position_id_per_seconds=13,\n+        seconds_per_chunk=2,\n+        audio_start_token_id=4,\n+        audio_end_token_id=5,\n+        user_token_id=6,\n+        vision_start_token_id=7,\n+        vision_end_token_id=8,\n+        initializer_range=0.02,\n+    ):\n+        self.parent = parent\n+        self.vision_config = {\n+            \"depth\": 2,\n+            \"embed_dim\": 32,\n+            \"hidden_act\": \"quick_gelu\",\n+            \"hidden_size\": 32,\n+            \"out_hidden_size\": 32,\n+            \"intermediate_size\": 24,\n+            \"mlp_ratio\": 4,\n+            \"num_heads\": 4,\n+            \"patch_size\": 16,\n+            \"spatial_merge_size\": 1,\n+            \"temporal_patch_size\": 2,\n+            \"initializer_range\": 0.02,\n+            \"deepstack_visual_indexes\": [1],\n+        }\n+        self.audio_config = {\n+            \"model_type\": \"qwen_omni_thinker_audio_encoder\",\n+            \"d_model\": 32,\n+            \"encoder_attention_heads\": 4,\n+            \"encoder_ffn_dim\": 32,\n+            \"encoder_layers\": 2,\n+            \"num_mel_bins\": 20,\n+            \"max_source_positions\": 1500,\n+            \"initializer_range\": 0.02,\n+            \"n_window\": 50,\n+            \"output_dim\": 32,\n+            \"n_window_infer\": 100,\n+        }\n+        self.text_config = {\n+            \"rope_scaling\": {\n+                \"mrope_section\": [1, 1, 2],\n+                \"rope_type\": \"default\",\n+                \"type\": \"default\",\n+                \"interleaved\": True,\n+            },\n+            \"vocab_size\": 99,\n+            \"hidden_size\": 32,\n+            \"intermediate_size\": 37,\n+            \"num_hidden_layers\": 4,\n+            \"num_attention_heads\": 4,\n+            \"num_key_value_heads\": 2,\n+            \"hidden_act\": \"silu\",\n+            \"max_position_embeddings\": 1024,\n+            \"rms_norm_eps\": 1e-06,\n+            \"use_cache\": True,\n+            \"tie_word_embeddings\": False,\n+            \"rope_theta\": 1000000.0,\n+            \"use_sliding_window\": False,\n+            \"sliding_window\": 50,\n+            \"max_window_layers\": 3,\n+            \"attention_dropout\": 0.0,\n+            \"pad_token_id\": 0,\n+            \"initializer_range\": 0.02,\n+            \"moe_intermediate_size\": 32,\n+            \"num_experts_per_tok\": 2,\n+            \"num_experts\": 8,\n+            \"decoder_sparse_step\": 1,\n+        }\n+        self.audio_token_id = audio_token_id\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.position_id_per_seconds = position_id_per_seconds\n+        self.seconds_per_chunk = seconds_per_chunk\n+        self.audio_start_token_id = audio_start_token_id\n+        self.audio_end_token_id = audio_end_token_id\n+        self.vision_start_token_id = vision_start_token_id\n+        self.vision_end_token_id = vision_end_token_id\n+        self.user_token_id = user_token_id\n+        self.initializer_range = initializer_range\n+        self.batch_size = batch_size\n+        self.feat_seq_length = feat_seq_length\n+        self.num_channels = num_channels\n+        self.image_size = image_size\n+        self.seq_length = seq_length\n+        self.is_training = False\n+\n+        # Used from `self.model_tester` by common model tests\n+        self.num_hidden_layers = self.text_config[\"num_hidden_layers\"]\n+        self.hidden_size = self.text_config[\"hidden_size\"]\n+        self.num_attention_heads = self.text_config[\"num_attention_heads\"]\n+        self.vocab_size = self.text_config[\"vocab_size\"]\n+\n+    def get_config(self):\n+        return Qwen3OmniMoeThinkerConfig(\n+            audio_config=self.audio_config,\n+            vision_config=self.vision_config,\n+            text_config=self.text_config,\n+            audio_token_id=self.audio_token_id,\n+            image_token_id=self.image_token_id,\n+            video_token_id=self.video_token_id,\n+            position_id_per_seconds=self.position_id_per_seconds,\n+            seconds_per_chunk=self.seconds_per_chunk,\n+            audio_start_token_id=self.audio_start_token_id,\n+            audio_end_token_id=self.audio_end_token_id,\n+            vision_start_token_id=self.vision_start_token_id,\n+            vision_end_token_id=self.vision_end_token_id,\n+            user_token_id=self.user_token_id,\n+            initializer_range=self.initializer_range,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        config = self.get_config()\n+        patch_size = config.vision_config.patch_size\n+        temporal_patch_size = config.vision_config.temporal_patch_size\n+        pixel_values = floats_tensor(\n+            [\n+                self.batch_size * (self.image_size**2) // (patch_size**2),\n+                self.num_channels * (patch_size**2) * temporal_patch_size,\n+            ]\n+        )\n+        pixel_grid_thw = torch.LongTensor(\n+            [[1, self.image_size / patch_size, self.image_size / patch_size]] * self.batch_size\n+        ).to(pixel_values.device)\n+        input_features_values = floats_tensor(\n+            [self.batch_size, self.audio_config[\"num_mel_bins\"], self.feat_seq_length]\n+        )\n+        feature_attention_mask = torch.ones([self.batch_size, self.feat_seq_length], dtype=torch.long).to(torch_device)\n+        return config, pixel_values, pixel_grid_thw, input_features_values, feature_attention_mask\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values, pixel_grid_thw, input_features_values, feature_attention_mask = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], config.get_text_config().vocab_size - 3) + 3\n+        attention_mask = torch.ones(input_ids.shape, dtype=torch.long).to(torch_device)\n+\n+        # Make sure no other tokens are set to special, to prevetn flakiness\n+        tokens_to_replace = torch.tensor(\n+            [\n+                config.image_token_id,\n+                config.audio_token_id,\n+                config.audio_start_token_id,\n+                config.audio_end_token_id,\n+                config.vision_start_token_id,\n+                config.vision_end_token_id,\n+            ],\n+            device=input_ids.device,\n+        )\n+        input_ids[torch.isin(input_ids, tokens_to_replace)] = config.text_config.pad_token_id\n+\n+        attention_mask[:, :1] = 0\n+\n+        # Audio token placeholders should be wrapped in start and end token ids\n+        audio_feat_length = (((self.feat_seq_length - 1) // 2 + 1 - 1) // 2 + 1 - 1) // 2 + 1\n+        input_ids[:, 1] = config.audio_start_token_id\n+        input_ids[:, 2 : (2 + audio_feat_length)] = config.audio_token_id\n+        input_ids[:, 2 + audio_feat_length] = config.audio_end_token_id\n+\n+        # Image token placeholders should be wrapped in start and end token ids\n+        input_ids[:, -4:-1] = torch.tensor(\n+            [config.vision_start_token_id, config.image_token_id, config.vision_end_token_id]\n+        )\n+        inputs_dict = {\n+            \"input_features\": input_features_values,\n+            \"feature_attention_mask\": feature_attention_mask,\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+            \"image_grid_thw\": pixel_grid_thw,\n+            \"pixel_values\": pixel_values,\n+        }\n+        return config, inputs_dict\n+\n+    def create_and_check_qwenomnithinker_model_fp16_forward(self, config, input_ids, pixel_values, attention_mask):\n+        model = Qwen3OmniMoeThinkerForConditionalGeneration(config=config)\n+        model.to(torch_device)\n+        model.eval()\n+        with torch.autocast(device_type=torch_device, dtype=torch.float16):\n+            logits = model(\n+                input_ids=input_ids,\n+                attention_mask=attention_mask,\n+                pixel_values=pixel_values.to(torch.bfloat16),\n+                return_dict=True,\n+            )[\"logits\"]\n+        self.parent.assertFalse(torch.isnan(logits).any().item())\n+\n+\n+@require_torch\n+class Qwen2_5OmniThinkerForConditionalGenerationModelTest(ModelTesterMixin, GenerationTesterMixin, unittest.TestCase):\n+    \"\"\"\n+    Model tester for `Qwen2_5OmniThinkerForConditionalGeneration`.\n+    \"\"\"\n+\n+    all_model_classes = (Qwen3OmniMoeThinkerForConditionalGeneration,) if is_torch_available() else ()\n+    all_generative_model_classes = (Qwen3OmniMoeThinkerForConditionalGeneration,) if is_torch_available() else ()\n+    test_pruning = False\n+    test_head_masking = False\n+    _is_composite = True\n+    model_split_percents = [0.5, 0.9]\n+\n+    def setUp(self):\n+        self.model_tester = Qwen3OmniMoeThinkerForConditionalGenerationTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Qwen3OmniMoeThinkerConfig, has_text_modality=False)\n+\n+    @unittest.skip(reason=\"Cpu not yet supported because in QwenOmniThinker models\")\n+    def test_disk_offload_bin(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Disk offload bin not yet supported because in QwenOmniThinker models\")\n+    def test_cpu_offload(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Disk offload safetensors not yet supported because in QwenOmniThinker models\")\n+    def test_disk_offload_safetensors(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Correct missing keys not yet supported because in QwenOmniThinker models\")\n+    def test_correct_missing_keys(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Compile not yet supported because in QwenOmniThinker models\")\n+    @pytest.mark.torch_compile_test\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Sdpa dispatch not yet supported because in QwenOmniThinker models\")\n+    def test_sdpa_can_dispatch_on_flash(self):\n+        pass\n+\n+    @unittest.skip(reason=\"QwenOmniThinker does not support output_hidden_states test\")\n+    def test_model_outputs_equivalence(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Don't have time to investigate at time of merge\")\n+    def test_eager_padding_matches_padding_free_with_position_ids(self):\n+        pass\n+\n+    def test_sdpa_can_dispatch_composite_models(self):\n+        # overwrite because Qwen2 is audio+text model (not vision+text)\n+        if not self.has_attentions:\n+            self.skipTest(reason=\"Model architecture does not support attentions\")\n+\n+        if not self._is_composite:\n+            self.skipTest(f\"{self.all_model_classes[0].__name__} does not support SDPA\")\n+\n+        for model_class in self.all_model_classes:\n+            config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+            model = model_class(config)\n+\n+            with tempfile.TemporaryDirectory() as tmpdirname:\n+                model.save_pretrained(tmpdirname)\n+                model_sdpa = model_class.from_pretrained(tmpdirname)\n+                model_sdpa = model_sdpa.eval().to(torch_device)\n+\n+                text_attn = \"sdpa\" if model.model._supports_sdpa else \"eager\"\n+                audio_attn = \"sdpa\" if model.audio_tower._supports_sdpa else \"eager\"\n+                vision_attn = \"sdpa\" if model.visual._supports_sdpa else \"eager\"\n+                # `None` as it is the requested one which will be assigned to each sub-config\n+                # Sub-model will dispatch to SDPA if it can (checked below that `SDPA` layers are present)\n+                self.assertTrue(model_sdpa.config._attn_implementation == \"sdpa\")\n+                self.assertTrue(model.model.config._attn_implementation == text_attn)\n+                self.assertTrue(model.audio_tower.config._attn_implementation == audio_attn)\n+                self.assertTrue(model.visual.config._attn_implementation == vision_attn)\n+\n+                model_eager = model_class.from_pretrained(tmpdirname, attn_implementation=\"eager\")\n+                model_eager = model_eager.eval().to(torch_device)\n+                self.assertTrue(model_eager.config._attn_implementation == \"eager\")\n+                self.assertTrue(model_eager.model.config._attn_implementation == \"eager\")\n+                self.assertTrue(model_eager.audio_tower.config._attn_implementation == \"eager\")\n+                self.assertTrue(model_eager.visual.config._attn_implementation == \"eager\")\n+\n+                for name, submodule in model_eager.named_modules():\n+                    class_name = submodule.__class__.__name__\n+                    if \"SdpaAttention\" in class_name or \"SdpaSelfAttention\" in class_name:\n+                        raise ValueError(\"The eager model should not have SDPA attention layers\")\n+\n+    def attention_mask_padding_matches_padding_free_with_position_ids(\n+        self, attn_implementation: str, fa_kwargs: bool = False\n+    ):\n+        max_new_tokens = 30\n+        for model_class in self.all_generative_model_classes:\n+            config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+            dummy_input = inputs_dict[model_class.main_input_name]\n+            if dummy_input.dtype in [torch.float32, torch.float16]:\n+                dummy_input = dummy_input.to(torch.bfloat16)\n+\n+            # make sure that all models have enough positions for generation\n+            if hasattr(config, \"max_position_embeddings\"):\n+                config.max_position_embeddings = max_new_tokens + dummy_input.shape[1] + 1\n+\n+            model = model_class(config)\n+\n+            with tempfile.TemporaryDirectory() as tmpdirname:\n+                model.save_pretrained(tmpdirname)\n+\n+                if 0 in inputs_dict[\"attention_mask\"][:, -1]:\n+                    inputs_dict[\"attention_mask\"] = inputs_dict[\"attention_mask\"].flip(1)\n+                dummy_attention_mask = inputs_dict[\"attention_mask\"]\n+                inputs_dict[\"input_ids\"][~dummy_attention_mask.bool()] = config.get_text_config().pad_token_id\n+\n+                model = (\n+                    model_class.from_pretrained(\n+                        tmpdirname,\n+                        dtype=torch.bfloat16,\n+                        attn_implementation=attn_implementation,\n+                    )\n+                    .to(torch_device)\n+                    .eval()\n+                )\n+\n+                # flatten\n+                padfree_inputs_dict = {\n+                    \"input_features\": inputs_dict[\"input_features\"],\n+                    \"feature_attention_mask\": inputs_dict[\"feature_attention_mask\"],\n+                    \"pixel_values\": inputs_dict[\"pixel_values\"],\n+                    \"image_grid_thw\": inputs_dict[\"image_grid_thw\"],\n+                    \"input_ids\": inputs_dict[\"input_ids\"][dummy_attention_mask.bool()].unsqueeze(0),\n+                }\n+\n+                # add position_ids\n+                vision_position_ids, deltas = model.get_rope_index(\n+                    input_ids=inputs_dict[\"input_ids\"],\n+                    image_grid_thw=inputs_dict[\"image_grid_thw\"],\n+                    attention_mask=inputs_dict[\"attention_mask\"],\n+                    audio_seqlens=torch.sum(inputs_dict[\"feature_attention_mask\"], dim=1),\n+                )  # [3, bs, padded-seq-len]\n+                vision_padfree_positions = vision_position_ids[:, dummy_attention_mask.bool()].view(\n+                    3, -1\n+                )  # [3, bs*padfree-len]\n+                text_padfree_positions = torch.cat(\n+                    [torch.arange(length) for length in dummy_attention_mask.sum(1).tolist()]\n+                )  # [1, bs*padfree-len]\n+                text_padfree_positions = text_padfree_positions.long().unsqueeze(0).to(torch_device)\n+                padfree_inputs_dict[\"position_ids\"] = torch.cat([text_padfree_positions, vision_padfree_positions])[\n+                    :, None, :\n+                ]\n+\n+                if fa_kwargs:\n+                    cu_seq_lens = [0] + dummy_attention_mask.sum(1).tolist()\n+                    cu_seq_lens = torch.tensor(cu_seq_lens, device=torch_device)\n+                    max_length = cu_seq_lens.diff().max().item()\n+                    padfree_inputs_dict.update(\n+                        {\n+                            \"cu_seq_lens_q\": cu_seq_lens.cumsum(-1).to(dtype=torch.int32),\n+                            \"cu_seq_lens_k\": cu_seq_lens.cumsum(-1).to(dtype=torch.int32),\n+                            \"max_length_q\": max_length,\n+                            \"max_length_k\": max_length,\n+                        }\n+                    )\n+\n+                res_padded = model(**inputs_dict, use_cache=False)\n+                res_padfree = model(**padfree_inputs_dict, use_cache=False)\n+\n+                logits_padded = res_padded.logits[inputs_dict[\"attention_mask\"].bool()]\n+                logits_padfree = res_padfree.logits[0]\n+\n+                # acceptable numerical instability\n+                tol = torch.finfo(torch.bfloat16).eps\n+                torch.testing.assert_close(logits_padded, logits_padfree, rtol=tol, atol=tol)\n+\n+    @unittest.skip(\"Cannot do contrastive generation, has custom `generate()`\")\n+    def test_contrastive_generate(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot do contrastive generation, has custom `generate()`\")\n+    def test_contrastive_generate_dict_outputs_use_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot do contrastive generation, has custom `generate()`\")\n+    def test_contrastive_generate_low_memory(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot generate from inputs embeds\")\n+    def test_generate_from_inputs_embeds_with_static_cache(self):\n+        pass\n+\n+    # TODO (joao, raushan): there are multiple standardization issues in this model that prevent this test from\n+    # passing, fix me\n+    @unittest.skip(\"Cannot handle 4D attention mask\")\n+    @pytest.mark.torch_compile_test\n+    def test_generate_compile_model_forward_fullgraph(self):\n+        pass\n+\n+    @unittest.skip(\n+        \"There seems to be something wrong with the config, that does not play well with this test. TODO fix me\"\n+    )\n+    def test_save_load(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot handle 4D attention mask\")\n+    def test_generate_compilation_all_outputs(self):\n+        pass\n+\n+    @unittest.skip(\"In a rush to merge, cannot investigate now\")\n+    def test_sdpa_padding_matches_padding_free_with_position_ids(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot handle 4D attention mask\")\n+    def test_generate_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot handle 4D attention mask\")\n+    def test_custom_4d_attention_mask(self):\n+        pass\n+\n+    @unittest.skip(\"We don't really care about this one, test is not that slow\")\n+    def test_model_is_small(self):\n+        pass\n+\n+    @unittest.skip(\"FIXME this is important, but in a rush to merge, cannot investigate now\")\n+    def test_get_rope_index_video_with_audio(self):\n+        image_grid_thw = torch.empty((0, 3), dtype=torch.long)\n+\n+        # 3 * 2 * 2 = 12 video tokens\n+        video_grid_thw = torch.tensor([[3, 2, 2]], dtype=torch.long)\n+\n+        # num_audio_tokens = ((audio_seqlen - 1) // 2 + 1 - 2) // 2 + 1\n+        # i.e.: 300 audio_seqlen -> 75 audio tokens\n+        audio_seqlens = torch.tensor([300], dtype=torch.long)\n+\n+        second_per_grids = torch.tensor([1.0], dtype=torch.float)\n+\n+        use_audio_in_video = True\n+\n+        # fmt: off\n+        expected_position_ids = torch.tensor([\n+            [[\n+                 0,  1, # text\n+                 2,  2, # vision_bos + audio_bos\n+\n+                # video chunk\n+                  3,  3,  3,  3,\n+                 28, 28, 28, 28,\n+\n+                # audio chunk\n+                 3,  4,  5,  6,  7,  8, 9, 10, 11, 12, 13, 14, 15, 16,\n+                17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+                31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,\n+                45, 46, 47, 48, 49, 50, 51, 52,\n+\n+                # video chunk\n+                53, 53, 53, 53,\n+\n+                # audio chunk\n+                53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\n+                67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,\n+\n+                78, 78, # audio_eos + vision_eos\n+                79, 80, # text\n+            ]],\n+            [[\n+                 0,  1, # text\n+                 2,  2, # vision_bos + audio_bos\n+\n+                # video chunk\n+                 3,  3,  4,  4,\n+                 3,  3,  4,  4,\n+\n+                # audio chunk\n+                 3,  4,  5,  6,  7,  8, 9, 10, 11, 12, 13, 14, 15, 16,\n+                17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+                31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,\n+                45, 46, 47, 48, 49, 50, 51, 52,\n+\n+                # video chunk\n+                 3,  3,  4,  4,\n+\n+                # audio chunk\n+                53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\n+                67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,\n+\n+                78, 78, # audio_eos + vision_eos\n+                79, 80, # text\n+            ]],\n+            [[\n+                 0,  1, # text\n+                 2,  2, # vision_bos + audio_bos\n+\n+                # video chunk\n+                 3,  4,  3,  4,\n+                 3,  4,  3,  4,\n+\n+                # audio chunk\n+                 3,  4,  5,  6,  7,  8, 9, 10, 11, 12, 13, 14, 15, 16,\n+                17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+                31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,\n+                45, 46, 47, 48, 49, 50, 51, 52,\n+\n+                # video chunk\n+                3,  4,  3,  4,\n+\n+                # audio chunk\n+                53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\n+                67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,\n+\n+                78, 78, # audio_eos + vision_eos\n+                79, 80, # text\n+            ]],\n+        ], dtype=torch.long)\n+        # fmt: on\n+\n+        for model_class in self.all_model_classes:\n+            config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+            input_ids = torch.tensor(\n+                [\n+                    [\n+                        100,\n+                        101,\n+                    ]\n+                    + [\n+                        config.vision_start_token_id,\n+                        config.audio_start_token_id,\n+                    ]\n+                    # 1st chunk: 8 video tokens, 50 audio tokens\n+                    + [config.video_token_id] * 2 * 2 * 2\n+                    + [config.audio_token_id] * 50\n+                    +\n+                    # 2nd chunk: 4 video tokens, 25 audio tokens\n+                    [config.video_token_id] * 1 * 2 * 2\n+                    + [config.audio_token_id] * 25\n+                    + [\n+                        config.audio_end_token_id,\n+                        config.vision_end_token_id,\n+                    ]\n+                    + [\n+                        102,\n+                        103,\n+                    ]\n+                ],\n+                dtype=torch.long,\n+            )\n+\n+            model = model_class(config)\n+\n+            position_ids, mrope_position_deltas = model.get_rope_index(\n+                input_ids=input_ids,\n+                image_grid_thw=image_grid_thw,\n+                video_grid_thw=video_grid_thw,\n+                attention_mask=None,\n+                use_audio_in_video=use_audio_in_video,\n+                audio_seqlens=audio_seqlens,\n+                second_per_grids=second_per_grids,\n+            )\n+\n+            self.assertTrue(torch.equal(position_ids, expected_position_ids))\n+\n+\n+@require_torch\n+class Qwen2_5OmniModelIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2.5-Omni-7B\")\n+        self.audio_url = \"https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen2-Audio/audio/glass-breaking-151256.mp3\"\n+        self.audio_url_additional = (\n+            \"https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen2-Audio/audio/f2641_0_throatclearing.wav\"\n+        )\n+        self.image_url = \"https://qianwen-res.oss-accelerate-overseas.aliyuncs.com/Qwen2-VL/demo_small.jpg\"\n+        self.messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"audio\", \"audio_url\": self.audio_url},\n+                    {\"type\": \"image\", \"image_url\": self.image_url},\n+                    {\"type\": \"text\", \"text\": \"What's that sound and what kind of dog is this?\"},\n+                ],\n+            }\n+        ]\n+\n+        self.raw_audio, _ = librosa.load(\n+            BytesIO(urlopen(self.audio_url).read()), sr=self.processor.feature_extractor.sampling_rate\n+        )\n+        self.raw_audio_additional, _ = librosa.load(\n+            BytesIO(urlopen(self.audio_url_additional).read()), sr=self.processor.feature_extractor.sampling_rate\n+        )\n+        self.raw_image = Image.open(requests.get(self.image_url, stream=True).raw)\n+\n+    def tearDown(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    @slow\n+    def test_small_model_integration_test(self):\n+        model = Qwen3OmniMoeForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-Omni-7B\", dtype=torch.bfloat16, device_map=\"auto\"\n+        )\n+\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(\n+            text=text, audio=[self.raw_audio], images=[self.raw_image], return_tensors=\"pt\", padding=True\n+        ).to(torch.bfloat16)\n+\n+        expected_input_ids = torch.tensor(\n+            [\n+                151644,\n+                8948,\n+                198,\n+                2610,\n+                525,\n+                264,\n+                10950,\n+                17847,\n+                13,\n+                151645,\n+                198,\n+                151644,\n+                872,\n+                198,\n+                151647,\n+                151646,\n+                151646,\n+            ]\n+        )\n+        assert torch.allclose(expected_input_ids, inputs.input_ids[0][:17], atol=3e-3)\n+\n+        expected_pixel_slice = torch.tensor(\n+            [\n+                [0.8792, 0.8792, 0.9084],\n+                [1.1858, 1.1858, 1.2296],\n+                [1.2004, 1.2004, 1.2150],\n+                [1.4340, 1.4340, 1.4194],\n+                [1.3902, 1.4048, 1.4194],\n+                [1.5216, 1.5362, 1.5362],\n+            ],\n+            dtype=torch.bfloat16,\n+            device=\"cpu\",\n+        )\n+        assert torch.allclose(expected_pixel_slice, inputs.pixel_values[:6, :3], atol=3e-3)\n+\n+        # verify generation\n+        inputs = inputs.to(torch_device)\n+\n+        output = model.generate(\n+            **inputs, thinker_temperature=0, thinker_do_sample=False, return_audio=False, thinker_max_new_tokens=20\n+        )\n+\n+        EXPECTED_DECODED_TEXT = Expectations({\n+            (\"cuda\", (8, 6)): \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog is a Labrador Retriever.\",\n+            (\"rocm\", (9, 4)): \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog is a Labrador Retriever.\",\n+        }).get_expectation()  # fmt: skip\n+\n+        decoded_text = self.processor.decode(output[0], skip_special_tokens=True)\n+        self.assertEqual(decoded_text, EXPECTED_DECODED_TEXT)\n+\n+    @slow\n+    def test_small_model_integration_test_batch(self):\n+        model = Qwen3OmniMoeForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-Omni-7B\", dtype=torch.bfloat16, device_map=\"auto\"\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(\n+            text=[text] * 2,\n+            audio=[self.raw_audio, self.raw_audio],\n+            images=[self.raw_image, self.raw_image],\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device, dtype=torch.bfloat16)\n+\n+        output = model.generate(\n+            **inputs, thinker_temperature=0, thinker_do_sample=False, return_audio=False, thinker_max_new_tokens=20\n+        )\n+\n+        EXPECTED_DECODED_TEXTS = Expectations(\n+            {\n+                (\"cuda\", 7) : [\n+                    \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is of glass shattering, and the dog in the picture is a Labrador Retriever\",\n+                    \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is of glass shattering, and the dog in the picture is a Labrador Retriever\",\n+                ],\n+                (\"cuda\", 8): [\n+                    \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog is a Labrador Retriever.\",\n+                    \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog is a Labrador Retriever.\",\n+                ],\n+                (\"rocm\", (9, 4)): [\n+                    \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog is a Labrador Retriever.\",\n+                    \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog is a Labrador Retriever.\",\n+                ],\n+            }\n+        ).get_expectation()  # fmt: skip\n+\n+        decoded_texts = self.processor.batch_decode(output, skip_special_tokens=True)\n+        self.assertEqual(decoded_texts, EXPECTED_DECODED_TEXTS)\n+\n+    @slow\n+    def test_small_model_integration_test_multiturn(self):\n+        model = Qwen3OmniMoeForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-Omni-7B\", dtype=torch.bfloat16, device_map=\"auto\"\n+        )\n+\n+        messages = [\n+            self.messages[0],\n+            {\n+                \"role\": \"assistant\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"text\",\n+                        \"text\": \"The sound is glass shattering, and the dog appears to be a Labrador Retriever.\",\n+                    }\n+                ],\n+            },\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"audio\", \"audio_url\": self.audio_url_additional},\n+                    {\"type\": \"text\", \"text\": \"How about this one?\"},\n+                ],\n+            },\n+        ]\n+\n+        text = self.processor.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(\n+            text=text,\n+            audio=[self.raw_audio, self.raw_audio_additional],\n+            images=[self.raw_image],\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device, dtype=torch.bfloat16)\n+\n+        output = model.generate(\n+            **inputs, thinker_temperature=0, thinker_do_sample=False, return_audio=False, thinker_max_new_tokens=20\n+        )\n+\n+        EXPECTED_DECODED_TEXT = \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog appears to be a Labrador Retriever.\\nuser\\nHow about this one?\\nassistant\\nThe sound is a cough.\"\n+\n+        self.assertEqual(\n+            self.processor.decode(output[0], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_w_audio(self):\n+        model = Qwen3OmniMoeForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-Omni-7B\", dtype=torch.bfloat16, device_map=\"auto\"\n+        )\n+        audio_url = \"https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen2-Audio/audio/guess_age_gender.wav\"\n+\n+        messages = [\n+            {\n+                \"role\": \"system\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"text\",\n+                        \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\",\n+                    }\n+                ],\n+            },\n+            {\n+                \"role\": \"user\",\n+                \"content\": [{\"type\": \"audio\", \"audio\": audio_url}],\n+            },\n+        ]\n+        audio, _ = librosa.load(BytesIO(urlopen(audio_url).read()), sr=self.processor.feature_extractor.sampling_rate)\n+\n+        text = self.processor.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=text, audio=[audio], return_tensors=\"pt\", padding=True).to(\n+            torch_device, dtype=torch.bfloat16\n+        )\n+\n+        output = model.generate(\n+            **inputs,\n+            thinker_temperature=0,\n+            thinker_do_sample=False,\n+            thinker_max_new_tokens=20,\n+            talker_max_new_tokens=10,\n+        )\n+\n+        EXPECTED_DECODED_TEXTS = Expectations(\n+            {\n+                (\"cuda\", 7): \"system\\nYou are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\\nuser\\n\\nassistant\\nWell, I can try. But it's not always that accurate. I might be able to make\",\n+                (\"cuda\", 8): \"system\\nYou are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\\nuser\\n\\nassistant\\nWell, I can't really guess your age and gender just from your voice. There are so many\",\n+            }\n+        )  # fmt: skip\n+        EXPECTED_DECODED_TEXT = EXPECTED_DECODED_TEXTS.get_expectation()\n+\n+        self.assertEqual(\n+            self.processor.decode(output[0][0], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+        self.assertFalse(torch.isnan(output[1]).any().item())\n+\n+    @slow\n+    @require_flash_attn\n+    @require_torch_gpu\n+    def test_small_model_integration_test_batch_flashatt2(self):\n+        model = Qwen3OmniMoeForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-Omni-7B\",\n+            dtype=torch.bfloat16,\n+            attn_implementation=\"flash_attention_2\",\n+            device_map=\"auto\",\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(\n+            text=[text, text],\n+            audio=[self.raw_audio, self.raw_audio],\n+            images=[self.raw_image, self.raw_image],\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        output = model.generate(**inputs, thinker_temperature=0, thinker_do_sample=False, return_audio=False)\n+\n+        EXPECTED_DECODED_TEXT = Expectations({\n+            (\"cuda\", None): \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog appears to be a Labrador Retriever.\",\n+            (\"cuda\", (8, 6)): \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog is a Labrador Retriever.\",\n+            (\"rocm\", (9, 4)): \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog is a Labrador Retriever.\",\n+        }).get_expectation()  # fmt: skip\n+\n+        decoded_texts = self.processor.batch_decode(output, skip_special_tokens=True)\n+        self.assertEqual(decoded_texts[0], EXPECTED_DECODED_TEXT)\n+        self.assertEqual(decoded_texts[1], EXPECTED_DECODED_TEXT)"
        },
        {
            "sha": "baaf22bd7831f0b1105c004fc6ffab03e54fb089",
            "filename": "tests/models/qwen3_omni_moe/test_processing_qwen3_omni_moe.py",
            "status": "added",
            "additions": 602,
            "deletions": 0,
            "changes": 602,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/tests%2Fmodels%2Fqwen3_omni_moe%2Ftest_processing_qwen3_omni_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/tests%2Fmodels%2Fqwen3_omni_moe%2Ftest_processing_qwen3_omni_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen3_omni_moe%2Ftest_processing_qwen3_omni_moe.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -0,0 +1,602 @@\n+# coding=utf-8\n+# Copyright 2025 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import inspect\n+import shutil\n+import tempfile\n+import unittest\n+\n+import numpy as np\n+import pytest\n+from huggingface_hub import hf_hub_download\n+from parameterized import parameterized\n+\n+from transformers import (\n+    AutoProcessor,\n+    Qwen2TokenizerFast,\n+    Qwen3OmniMoeProcessor,\n+    WhisperFeatureExtractor,\n+)\n+from transformers.testing_utils import (\n+    require_av,\n+    require_librosa,\n+    require_torch,\n+    require_torchaudio,\n+    require_torchvision,\n+    require_vision,\n+)\n+from transformers.utils import is_torch_available, is_vision_available\n+\n+from ...test_processing_common import ProcessorTesterMixin, url_to_local_path\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_vision_available():\n+    from transformers import Qwen2VLImageProcessorFast\n+\n+\n+@require_vision\n+@require_torch\n+@require_torchaudio\n+@require_torchvision\n+class Qwen3OmniMoeProcessorTest(ProcessorTesterMixin, unittest.TestCase):\n+    processor_class = Qwen3OmniMoeProcessor\n+\n+    #  text + audio kwargs testing\n+    @require_torch\n+    def test_tokenizer_defaults_preserved_by_kwargs_audio(self):\n+        if \"feature_extractor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n+        feature_extractor = self.get_component(\"feature_extractor\")\n+        if hasattr(self, \"get_tokenizer\"):\n+            tokenizer = self.get_tokenizer(max_length=800, padding=\"max_length\")\n+        elif hasattr(self, \"get_component\"):\n+            tokenizer = self.get_component(\"tokenizer\", max_length=800, padding=\"max_length\")\n+        else:\n+            self.assertTrue(False, \"Processor doesn't have get_tokenizer or get_component defined\")\n+        if not tokenizer.pad_token:\n+            tokenizer.pad_token = \"[TEST_PAD]\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        video_processor = self.get_component(\"video_processor\")\n+        processor = self.processor_class(\n+            tokenizer=tokenizer,\n+            video_processor=video_processor,\n+            feature_extractor=feature_extractor,\n+            image_processor=image_processor,\n+        )\n+        self.skip_processor_without_typed_kwargs(processor)\n+        input_str = \"lower newer\"\n+        raw_speech = self.prepare_audio_inputs()\n+        inputs = processor(text=input_str, audio=raw_speech, return_tensors=\"pt\")\n+        if \"input_ids\" in inputs:\n+            self.assertEqual(len(inputs[\"input_ids\"][0]), 800)\n+        elif \"labels\" in inputs:\n+            self.assertEqual(len(inputs[\"labels\"][0]), 800)\n+\n+    @require_torch\n+    @require_vision\n+    def test_structured_kwargs_audio_nested(self):\n+        if \"feature_extractor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n+        feature_extractor = self.get_component(\"feature_extractor\")\n+        if hasattr(self, \"get_tokenizer\"):\n+            tokenizer = self.get_tokenizer()\n+        elif hasattr(self, \"get_component\"):\n+            tokenizer = self.get_component(\"tokenizer\")\n+        if not tokenizer.pad_token:\n+            tokenizer.pad_token = \"[TEST_PAD]\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        video_processor = self.get_component(\"video_processor\")\n+        processor = self.processor_class(\n+            tokenizer=tokenizer,\n+            video_processor=video_processor,\n+            feature_extractor=feature_extractor,\n+            image_processor=image_processor,\n+        )\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = [\"lower newer\"]\n+        raw_speech = self.prepare_audio_inputs()\n+\n+        # Define the kwargs for each modality\n+        all_kwargs = {\n+            \"common_kwargs\": {\"return_tensors\": \"pt\"},\n+            \"audio_kwargs\": {\"max_length\": 800},\n+        }\n+\n+        inputs = processor(text=input_str, audio=raw_speech, **all_kwargs)\n+        if \"input_ids\" in inputs:\n+            self.assertEqual(len(inputs[\"input_ids\"][0]), 2)\n+        elif \"labels\" in inputs:\n+            self.assertEqual(len(inputs[\"labels\"][0]), 2)\n+\n+    @require_torch\n+    def test_unstructured_kwargs_audio(self):\n+        if \"feature_extractor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n+        feature_extractor = self.get_component(\"feature_extractor\")\n+        if hasattr(self, \"get_tokenizer\"):\n+            tokenizer = self.get_tokenizer(max_length=117)\n+        elif hasattr(self, \"get_component\"):\n+            tokenizer = self.get_component(\"tokenizer\", max_length=117)\n+        if not tokenizer.pad_token:\n+            tokenizer.pad_token = \"[TEST_PAD]\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        video_processor = self.get_component(\"video_processor\")\n+        processor = self.processor_class(\n+            tokenizer=tokenizer,\n+            video_processor=video_processor,\n+            feature_extractor=feature_extractor,\n+            image_processor=image_processor,\n+        )\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = \"lower newer\"\n+        raw_speech = self.prepare_audio_inputs()\n+        inputs = processor(\n+            text=input_str,\n+            audio=raw_speech,\n+            return_tensors=\"pt\",\n+            padding=\"max_length\",\n+            max_length=800,\n+        )\n+\n+        if \"input_ids\" in inputs:\n+            self.assertEqual(len(inputs[\"input_ids\"][0]), 800)\n+        elif \"labels\" in inputs:\n+            self.assertEqual(len(inputs[\"labels\"][0]), 800)\n+\n+    @require_torch\n+    def test_doubly_passed_kwargs_audio(self):\n+        if \"feature_extractor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n+        feature_extractor = self.get_component(\"feature_extractor\")\n+        if hasattr(self, \"get_tokenizer\"):\n+            tokenizer = self.get_tokenizer()\n+        elif hasattr(self, \"get_component\"):\n+            tokenizer = self.get_component(\"tokenizer\")\n+        if not tokenizer.pad_token:\n+            tokenizer.pad_token = \"[TEST_PAD]\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        video_processor = self.get_component(\"video_processor\")\n+        _ = self.processor_class(\n+            tokenizer=tokenizer,\n+            video_processor=video_processor,\n+            feature_extractor=feature_extractor,\n+            image_processor=image_processor,\n+        )  # Why delete test? TODO: raushan double check tests after cleaning model\n+\n+    @require_torch\n+    def test_kwargs_overrides_default_tokenizer_kwargs_audio(self):\n+        if \"feature_extractor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n+        feature_extractor = self.get_component(\"feature_extractor\")\n+        if hasattr(self, \"get_tokenizer\"):\n+            tokenizer = self.get_tokenizer(max_length=117)\n+        elif hasattr(self, \"get_component\"):\n+            tokenizer = self.get_component(\"tokenizer\", max_length=117)\n+        if not tokenizer.pad_token:\n+            tokenizer.pad_token = \"[TEST_PAD]\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        video_processor = self.get_component(\"video_processor\")\n+        _ = self.processor_class(\n+            tokenizer=tokenizer,\n+            video_processor=video_processor,\n+            feature_extractor=feature_extractor,\n+            image_processor=image_processor,\n+        )\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.tmpdirname = tempfile.mkdtemp()\n+        processor = Qwen3OmniMoeProcessor.from_pretrained(\"Qwen/Qwen2.5-Omni-7B\")\n+        processor.save_pretrained(cls.tmpdirname)\n+\n+    def get_tokenizer(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).tokenizer\n+\n+    def get_image_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).image_processor\n+\n+    def get_video_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).video_processor\n+\n+    def get_feature_extractor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).feature_extractor\n+\n+    def get_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs)\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        shutil.rmtree(cls.tmpdirname, ignore_errors=True)\n+\n+    def prepare_audio_inputs(self):\n+        \"\"\"This function prepares a list of numpy audios.\"\"\"\n+        audio_inputs = [np.random.rand(160000) * 2 - 1] * 3  # batch-size=3\n+        return audio_inputs\n+\n+    def test_save_load_pretrained_default(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+        feature_extractor = self.get_feature_extractor()\n+        video_processor = self.get_video_processor()\n+        processor = self.processor_class(\n+            tokenizer=tokenizer,\n+            video_processor=video_processor,\n+            feature_extractor=feature_extractor,\n+            image_processor=image_processor,\n+        )\n+\n+        processor.save_pretrained(self.tmpdirname)\n+        processor = Qwen3OmniMoeProcessor.from_pretrained(self.tmpdirname, use_fast=True)\n+\n+        self.assertEqual(processor.tokenizer.get_vocab(), tokenizer.get_vocab())\n+        self.assertEqual(processor.image_processor.to_json_string(), image_processor.to_json_string())\n+        self.assertEqual(processor.feature_extractor.to_json_string(), feature_extractor.to_json_string())\n+        self.assertIsInstance(processor.tokenizer, Qwen2TokenizerFast)\n+        self.assertIsInstance(processor.image_processor, Qwen2VLImageProcessorFast)\n+        self.assertIsInstance(processor.feature_extractor, WhisperFeatureExtractor)\n+\n+    def test_image_processor(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+        feature_extractor = self.get_feature_extractor()\n+        video_processor = self.get_video_processor()\n+        processor = self.processor_class(\n+            tokenizer=tokenizer,\n+            video_processor=video_processor,\n+            feature_extractor=feature_extractor,\n+            image_processor=image_processor,\n+        )\n+\n+        image_input = self.prepare_image_inputs()\n+\n+        input_image_proc = image_processor(image_input, return_tensors=\"pt\")\n+        input_processor = processor(images=image_input, text=\"dummy\", return_tensors=\"pt\")\n+\n+        for key in input_image_proc:\n+            self.assertAlmostEqual(input_image_proc[key].sum(), input_processor[key].sum(), delta=1e-2)\n+\n+    def test_processor(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+        feature_extractor = self.get_feature_extractor()\n+        video_processor = self.get_video_processor()\n+        processor = self.processor_class(\n+            tokenizer=tokenizer,\n+            video_processor=video_processor,\n+            feature_extractor=feature_extractor,\n+            image_processor=image_processor,\n+        )\n+\n+        input_str = \"lower newer\"\n+        image_input = self.prepare_image_inputs()\n+        audio_input = self.prepare_audio_inputs()\n+        inputs = processor(text=input_str, images=image_input, audio=audio_input)\n+        keys = list(inputs.keys())\n+        self.assertListEqual(\n+            keys,\n+            [\n+                \"input_ids\",\n+                \"attention_mask\",\n+                \"pixel_values\",\n+                \"image_grid_thw\",\n+                \"feature_attention_mask\",\n+                \"input_features\",\n+            ],\n+        )\n+\n+        # test if it raises when no input is passed\n+        with pytest.raises(ValueError):\n+            processor()\n+\n+        # test if it raises when no text is passed\n+        with pytest.raises(ValueError):\n+            processor(images=image_input)\n+\n+    @require_torch\n+    def _test_apply_chat_template(\n+        self,\n+        modality: str,\n+        batch_size: int,\n+        return_tensors: str,\n+        input_name: str,\n+        processor_name: str,\n+        input_data: list[str],\n+    ):\n+        processor = self.get_processor()\n+        if processor.chat_template is None:\n+            self.skipTest(\"Processor has no chat template\")\n+\n+        if processor_name not in self.processor_class.attributes:\n+            self.skipTest(f\"{processor_name} attribute not present in {self.processor_class}\")\n+\n+        batch_messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [{\"type\": \"text\", \"text\": \"Describe this.\"}],\n+                },\n+            ]\n+        ] * batch_size\n+\n+        # Test that jinja can be applied\n+        formatted_prompt = processor.apply_chat_template(batch_messages, add_generation_prompt=True, tokenize=False)\n+        self.assertEqual(len(formatted_prompt), batch_size)\n+\n+        # Test that tokenizing with template and directly with `self.tokenizer` gives same output\n+        formatted_prompt_tokenized = processor.apply_chat_template(\n+            batch_messages, add_generation_prompt=True, tokenize=True, return_tensors=return_tensors\n+        )\n+        add_special_tokens = True\n+        if processor.tokenizer.bos_token is not None and formatted_prompt[0].startswith(processor.tokenizer.bos_token):\n+            add_special_tokens = False\n+        tok_output = processor.tokenizer(\n+            formatted_prompt, return_tensors=return_tensors, add_special_tokens=add_special_tokens\n+        )\n+        expected_output = tok_output.input_ids\n+        self.assertListEqual(expected_output.tolist(), formatted_prompt_tokenized.tolist())\n+\n+        # Test that kwargs passed to processor's `__call__` are actually used\n+        tokenized_prompt_100 = processor.apply_chat_template(\n+            batch_messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            padding=\"max_length\",\n+            truncation=True,\n+            return_tensors=return_tensors,\n+            max_length=100,\n+        )\n+        self.assertEqual(len(tokenized_prompt_100[0]), 100)\n+\n+        # Test that `return_dict=True` returns text related inputs in the dict\n+        out_dict_text = processor.apply_chat_template(\n+            batch_messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=return_tensors,\n+        )\n+        self.assertTrue(all(key in out_dict_text for key in [\"input_ids\", \"attention_mask\"]))\n+        self.assertEqual(len(out_dict_text[\"input_ids\"]), batch_size)\n+        self.assertEqual(len(out_dict_text[\"attention_mask\"]), batch_size)\n+\n+        # Test that with modality URLs and `return_dict=True`, we get modality inputs in the dict\n+        for idx, url in enumerate(input_data[:batch_size]):\n+            batch_messages[idx][0][\"content\"] = [batch_messages[idx][0][\"content\"][0], {\"type\": modality, \"url\": url}]\n+\n+        out_dict = processor.apply_chat_template(\n+            batch_messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=return_tensors,\n+            num_frames=2,  # by default no more than 2 frames, otherwise too slow\n+        )\n+        input_name = getattr(self, input_name)\n+        self.assertTrue(input_name in out_dict)\n+        self.assertEqual(len(out_dict[\"input_ids\"]), batch_size)\n+        self.assertEqual(len(out_dict[\"attention_mask\"]), batch_size)\n+\n+        if modality == \"video\":\n+            # qwen pixels don't scale with bs same way as other models, calculate expected video token count based on video_grid_thw\n+            expected_video_token_count = 0\n+            for thw in out_dict[\"video_grid_thw\"]:\n+                expected_video_token_count += thw[0] * thw[1] * thw[2]\n+            mm_len = expected_video_token_count\n+        elif modality == \"audio\":\n+            mm_len = batch_size\n+        else:\n+            mm_len = batch_size * 1200\n+        self.assertEqual(len(out_dict[input_name]), mm_len)\n+\n+        return_tensor_to_type = {\"pt\": torch.Tensor, \"np\": np.ndarray, None: list}\n+        for k in out_dict:\n+            self.assertIsInstance(out_dict[k], return_tensor_to_type[return_tensors])\n+\n+    @unittest.skip(\"Skipping but this one is important, should be fixed ASAP\")\n+    @parameterized.expand([(1, \"pt\"), (2, \"pt\")])\n+    def test_apply_chat_template_image(self, batch_size: int, return_tensors: str):\n+        pass\n+\n+    @require_av\n+    def test_apply_chat_template_video_frame_sampling(self):\n+        processor = self.get_processor()\n+        if processor.chat_template is None:\n+            self.skipTest(\"Processor has no chat template\")\n+\n+        signature = inspect.signature(processor.__call__)\n+        if \"videos\" not in {*signature.parameters.keys()} or (\n+            signature.parameters.get(\"videos\") is not None\n+            and signature.parameters[\"videos\"].annotation == inspect._empty\n+        ):\n+            self.skipTest(\"Processor doesn't accept videos at input\")\n+\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\"type\": \"text\", \"text\": \"What is shown in this video?\"},\n+                    ],\n+                },\n+            ]\n+        ]\n+\n+        formatted_prompt = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=False)\n+        self.assertEqual(len(formatted_prompt), 1)\n+\n+        formatted_prompt_tokenized = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=True)\n+        expected_output = processor.tokenizer(formatted_prompt, return_tensors=None).input_ids\n+        self.assertListEqual(expected_output, formatted_prompt_tokenized)\n+\n+        out_dict = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=True, return_dict=True)\n+        self.assertListEqual(list(out_dict.keys()), [\"input_ids\", \"attention_mask\"])\n+\n+        # Add video URL for return dict and load with `num_frames` arg\n+        messages[0][0][\"content\"].append(\n+            {\n+                \"type\": \"video\",\n+                \"url\": url_to_local_path(\n+                    \"https://huggingface.co/datasets/raushan-testing-hf/videos-test/resolve/main/Big_Buck_Bunny_720_10s_10MB.mp4\"\n+                ),\n+            }\n+        )\n+        num_frames = 3\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            num_frames=num_frames,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 9568)\n+\n+        # Load with `fps` arg\n+        fps = 1\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            fps=fps,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 23920)\n+\n+        # Load with `fps` and `num_frames` args, should raise an error\n+        with self.assertRaises(ValueError):\n+            out_dict_with_video = processor.apply_chat_template(\n+                messages,\n+                add_generation_prompt=True,\n+                tokenize=True,\n+                return_dict=True,\n+                fps=fps,\n+                num_frames=num_frames,\n+            )\n+\n+        # Load without any arg should load the whole video\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 717600)\n+\n+        # Load video as a list of frames (i.e. images). NOTE: each frame should have same size\n+        # because we assume they come from one video\n+        messages[0][0][\"content\"][-1] = {\n+            \"type\": \"video\",\n+            \"url\": [\n+                \"https://www.ilankelman.org/stopsigns/australia.jpg\",\n+                \"https://www.ilankelman.org/stopsigns/australia.jpg\",\n+            ],\n+        }\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 11408)\n+\n+        # When the inputs are frame URLs/paths we expect that those are already\n+        # sampled and will raise an error is asked to sample again.\n+        with self.assertRaises(ValueError):\n+            out_dict_with_video = processor.apply_chat_template(\n+                messages,\n+                add_generation_prompt=True,\n+                tokenize=True,\n+                return_dict=True,\n+                do_sample_frames=True,\n+                num_frames=num_frames,\n+            )\n+\n+    @require_librosa\n+    @require_av\n+    def test_chat_template_audio_from_video(self):\n+        processor = self.get_processor()\n+        if processor.chat_template is None:\n+            self.skipTest(\"Processor has no chat template\")\n+\n+        signature = inspect.signature(processor.__call__)\n+        if \"videos\" not in {*signature.parameters.keys()} or (\n+            signature.parameters.get(\"videos\") is not None\n+            and signature.parameters[\"videos\"].annotation == inspect._empty\n+        ):\n+            self.skipTest(f\"{self.processor_class} does not support video inputs\")\n+\n+        if \"feature_extractor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n+\n+        video_file_path = hf_hub_download(\n+            repo_id=\"raushan-testing-hf/videos-test\", filename=\"sample_demo_1.mp4\", repo_type=\"dataset\"\n+        )\n+        messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"video\", \"path\": video_file_path},\n+                    {\"type\": \"text\", \"text\": \"Which of these animals is making the sound?\"},\n+                ],\n+            },\n+            {\n+                \"role\": \"assistant\",\n+                \"content\": [{\"type\": \"text\", \"text\": \"It is a cow.\"}],\n+            },\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"text\", \"text\": \"Tell me all about this animal.\"},\n+                ],\n+            },\n+        ]\n+\n+        formatted_prompt = processor.apply_chat_template([messages], add_generation_prompt=True, tokenize=False)\n+        self.assertEqual(len(formatted_prompt), 1)  # batch size=1\n+\n+        out_dict = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            load_audio_from_video=True,\n+        )\n+        self.assertTrue(self.audio_input_name in out_dict)\n+        self.assertTrue(self.videos_input_name in out_dict)\n+\n+        # should always have input_ids and attention_mask\n+        self.assertEqual(len(out_dict[\"input_ids\"]), 1)  # batch-size=1\n+        self.assertEqual(len(out_dict[\"attention_mask\"]), 1)  # batch-size=1\n+        self.assertEqual(len(out_dict[self.audio_input_name]), 1)  # 1 audio in the conversation\n+        self.assertEqual(len(out_dict[self.videos_input_name]), 145912)  # 1 video in the conversation"
        },
        {
            "sha": "d0b9675787324611d761631ab13868bda2bf21ae",
            "filename": "tests/test_modeling_common.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/tests%2Ftest_modeling_common.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/tests%2Ftest_modeling_common.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Ftest_modeling_common.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -688,6 +688,7 @@ def test_num_layers_is_small(self):\n             \"Owlv2ModelTest\": 12,\n             \"Owlv2TextModelTest\": 12,\n             \"Owlv2ForObjectDetectionTest\": 12,\n+            \"Qwen2_5OmniThinkerForConditionalGenerationModelTest\": 4,\n             \"SamHQModelTest\": 12,\n             \"Swin2SRModelTest\": 3,\n             \"XLNetModelTest\": 3,"
        },
        {
            "sha": "eff3f6865925982f242d033551b3d35ee5b3f28e",
            "filename": "utils/check_docstrings.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/utils%2Fcheck_docstrings.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/utils%2Fcheck_docstrings.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_docstrings.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -81,6 +81,7 @@\n OBJECTS_TO_IGNORE = {\n     \"ApertusConfig\",\n     \"Mxfp4Config\",\n+    \"Qwen3OmniMoeConfig\",\n     \"Exaone4Config\",\n     \"SmolLM3Config\",\n     \"Gemma3nVisionConfig\","
        },
        {
            "sha": "207be57f1b624ba36b4ec9a02f65852a70eec403",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbcf00ad1b06fa87effe179d128e73390255844/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbcf00ad1b06fa87effe179d128e73390255844/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=ebbcf00ad1b06fa87effe179d128e73390255844",
            "patch": "@@ -157,6 +157,16 @@\n         \"Qwen2_5OmniToken2WavModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2_5OmniModelIntergrationTest.\n         \"Qwen2_5OmniToken2WavDiTModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2_5OmniModelIntergrationTest.\n         \"Qwen2_5OmniToken2WavBigVGANModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2_5OmniModelIntergrationTest.\n+        \"Qwen3OmniMoeCode2Wav\",  # Building part of bigger (tested) model. Tested implicitly through Qwen3OmniMoeForConditionalGenerationIntegrationTest.\n+        \"Qwen3OmniMoeCode2WavDecoderBlock\",\n+        \"Qwen3OmniMoeText2Wav\",  # Building part of bigger (tested) model. Tested implicitly through Qwen3OmniMoeForConditionalGenerationIntegrationTest.\n+        \"Qwen3OmniMoeTalkerCodePredictorModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen3OmniMoeForConditionalGenerationIntegrationTest.\n+        \"Qwen3OmniMoeCode2WavTransformerModel\",\n+        \"Qwen3OmniMoeTalkerForConditionalGeneration\",\n+        \"Qwen3OmniMoeTalkerModel\",\n+        \"Qwen3OmniMoeThinkerTextModel\",\n+        \"Qwen3OmniMoeForConditionalGeneration\",  # Bigger model tested through Qwen3OmniMoeForConditionalGenerationIntegrationTest.\n+        \"Qwen3OmniMoeTalkerCodePredictorModelForConditionalGeneration\",  # Building part of bigger (tested) model. Tested implicitly through Qwen3OmniMoeForConditionalGenerationIntegrationTest.\n         \"MllamaTextModel\",  # Building part of bigger (tested) model. # TODO: add tests\n         \"MllamaVisionModel\",  # Building part of bigger (tested) model. # TODO: add tests\n         \"Llama4TextModel\",  # Building part of bigger (tested) model. # TODO: add tests\n@@ -369,6 +379,14 @@\n     \"CsmForConditionalGeneration\",  # Building part of a bigger model\n     \"BltPatcher\",  # Building part of a bigger model, tested implicitly through BltForCausalLM\n     \"Florence2VisionBackbone\",  # Building part of a bigger model\n+    \"Qwen3OmniMoeCode2Wav\",  # Building part of a bigger model\n+    \"Qwen3OmniMoeCode2WavTransformerModel\",  # Building part of a bigger model\n+    \"Qwen3OmniMoeTalkerCodePredictorModel\",  # Building part of a bigger model\n+    \"Qwen3OmniMoeTalkerCodePredictorModelForConditionalGeneration\",  # Building part of a bigger model\n+    \"Qwen3OmniMoeTalkerForConditionalGeneration\",  # Building part of a bigger model\n+    \"Qwen3OmniMoeTalkerModel\",  # Building part of a bigger model\n+    \"Qwen3OmniMoeThinkerForConditionalGeneration\",  # Building part of a bigger model\n+    \"Qwen3OmniMoeThinkerTextModel\",  # Building part of a bigger model\n ]\n \n "
        }
    ],
    "stats": {
        "total": 10415,
        "additions": 10411,
        "deletions": 4
    }
}