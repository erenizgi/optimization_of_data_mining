{
    "author": "MekkCyber",
    "message": "Adding FP8 Quantization to transformers (#36026)\n\n* first commit\r\n\r\n* adding kernels\r\n\r\n* fix create_quantized_param\r\n\r\n* fix quantization logic\r\n\r\n* end2end\r\n\r\n* fix style\r\n\r\n* fix imports\r\n\r\n* fix consistency\r\n\r\n* update\r\n\r\n* fix style\r\n\r\n* update\r\n\r\n* udpate after review\r\n\r\n* make style\r\n\r\n* update\r\n\r\n* update\r\n\r\n* fix\r\n\r\n* update\r\n\r\n* fix docstring\r\n\r\n* update\r\n\r\n* update after review\r\n\r\n* update\r\n\r\n* fix scheme\r\n\r\n* update\r\n\r\n* update\r\n\r\n* fix\r\n\r\n* update\r\n\r\n* fix docstring\r\n\r\n* add source\r\n\r\n* fix test\r\n\r\n---------\r\n\r\nCo-authored-by: Marc Sun <57196510+SunMarc@users.noreply.github.com>",
    "sha": "efe72fe21f4292e4f3a74344c0a065dc69480b3b",
    "files": [
        {
            "sha": "5540bd1826a908b858a9a06a9d46d42e66612717",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/efe72fe21f4292e4f3a74344c0a065dc69480b3b/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/efe72fe21f4292e4f3a74344c0a065dc69480b3b/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=efe72fe21f4292e4f3a74344c0a065dc69480b3b",
            "patch": "@@ -185,6 +185,8 @@\n     title: BitNet\n   - local: quantization/compressed_tensors\n     title: compressed-tensors\n+  - local: quantization/finegrained_fp8\n+    title: Fine-grained FP8\n   - local: quantization/contribute\n     title: Contribute new quantization method\n   title: Quantization Methods"
        },
        {
            "sha": "cd3e2705ab34043d768a0e8cf847b2901cd5db0b",
            "filename": "docs/source/en/main_classes/quantization.md",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/efe72fe21f4292e4f3a74344c0a065dc69480b3b/docs%2Fsource%2Fen%2Fmain_classes%2Fquantization.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/efe72fe21f4292e4f3a74344c0a065dc69480b3b/docs%2Fsource%2Fen%2Fmain_classes%2Fquantization.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmain_classes%2Fquantization.md?ref=efe72fe21f4292e4f3a74344c0a065dc69480b3b",
            "patch": "@@ -80,3 +80,7 @@ Learn how to quantize models in the [Quantization](../quantization) guide.\n ## BitNetConfig\n \n [[autodoc]] BitNetConfig\n+\n+## FineGrainedFP8Config\n+\n+[[autodoc]] FineGrainedFP8Config"
        },
        {
            "sha": "aaed35b4d99e80e956c8b735a18c92bb96fef4a4",
            "filename": "docs/source/en/quantization/finegrained_fp8.md",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/huggingface/transformers/blob/efe72fe21f4292e4f3a74344c0a065dc69480b3b/docs%2Fsource%2Fen%2Fquantization%2Ffinegrained_fp8.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/efe72fe21f4292e4f3a74344c0a065dc69480b3b/docs%2Fsource%2Fen%2Fquantization%2Ffinegrained_fp8.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fquantization%2Ffinegrained_fp8.md?ref=efe72fe21f4292e4f3a74344c0a065dc69480b3b",
            "patch": "@@ -0,0 +1,62 @@\n+<!--Copyright 2024 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+丘멆잺 Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# Fine-grained FP8\n+\n+With FP8 quantization method, you can quantize your model in FP8 (W8A8):\n+- the weights will be quantized in 8bit (FP8) per 2D block (e.g. weight_block_size=(128, 128)) which is inspired from the deepseek implementation\n+- Activations are quantized to 8 bits (FP8) per group per token, with the group value matching that of the weights in the input channels (128 by default)\n+\n+It's implemented to add support for DeepSeek-V3 and DeepSeek-R1 models, you can see the paper [here](https://arxiv.org/pdf/2412.19437), and the image below explains the quantization scheme : \n+\n+![](https://huggingface.co/datasets/huggingface/documentation-images/resolve/b7b3b34bf826a6423ea82ffc57ecac80c46c3c76/transformers/quantization/quantization_deepseek.png)\n+\n+> [!TIP]\n+> You need a GPU with compute capability>=9 (e.g. H100) \n+\n+Before you begin, make sure the following libraries are installed with their latest version:\n+\n+```bash\n+pip install --upgrade accelerate torch\n+```\n+> [!TIP]\n+> You need to install a torch version compatible with the cuda version of your GPU.\n+\n+\n+By default, the weights are loaded in full precision (torch.float32) regardless of the actual data type the weights are stored in such as torch.float16. Set `torch_dtype=\"auto\"` to load the weights in the data type defined in a model's `config.json` file to automatically load the most memory-optimal data type.\n+\n+```py\n+from transformers import FP8Config, AutoModelForCausalLM, AutoTokenizer\n+\n+model_name = \"meta-llama/Meta-Llama-3-8B\"\n+quantization_config = FP8Config()\n+quantized_model = AutoModelForCausalLM.from_pretrained(model_name, torch_dtype=\"auto\", device_map=\"auto\", quantization_config=quantization_config)\n+\n+tokenizer = AutoTokenizer.from_pretrained(model_name)\n+input_text = \"What are we having for dinner?\"\n+input_ids = tokenizer(input_text, return_tensors=\"pt\").to(\"cuda\")\n+\n+output = quantized_model.generate(**input_ids, max_new_tokens=10)\n+print(tokenizer.decode(output[0], skip_special_tokens=True))\n+```\n+\n+A quantized model can be saved via \"saved_pretrained\" and be reused again via the \"from_pretrained\".\n+\n+```py\n+quant_path = \"/path/to/save/quantized/model\"\n+model.save_pretrained(quant_path)\n+model = AutoModelForCausalLM.from_pretrained(quant_path, device_map=\"auto\")\n+```\n\\ No newline at end of file"
        },
        {
            "sha": "caebebe815478b3995a8b55f1954e8e1bfad31a2",
            "filename": "docs/source/en/quantization/overview.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/efe72fe21f4292e4f3a74344c0a065dc69480b3b/docs%2Fsource%2Fen%2Fquantization%2Foverview.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/efe72fe21f4292e4f3a74344c0a065dc69480b3b/docs%2Fsource%2Fen%2Fquantization%2Foverview.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fquantization%2Foverview.md?ref=efe72fe21f4292e4f3a74344c0a065dc69480b3b",
            "patch": "@@ -61,7 +61,7 @@ Use the table below to help you decide which quantization method to use.\n | [FBGEMM_FP8](./fbgemm_fp8.md)                 | 游릭                   | 游댮              | 游릭        | 游댮        | 游댮                                 | 游댮              | 游댮              | 8             | 游댮               | 游릭                          | 游릭                      | https://github.com/pytorch/FBGEMM       |\n | [torchao](./torchao.md)                       | 游릭                   |                 | 游릭        | 游댮        | 游리 <sub>5</sub> | 游댮              |                 | 4/8         |                  | 游릭游댮                        | 游릭                      | https://github.com/pytorch/ao       |\n | [VPTQ](./vptq.md)                             | 游댮                   | 游댮              |     游릭     | 游리        | 游댮                                 | 游댮              | 游릭              | 1/8         | 游댮               | 游릭                          | 游릭                      | https://github.com/microsoft/VPTQ            |\n-\n+| [FINEGRAINED_FP8](./finegrained_fp8.md)                 | 游릭                   | 游댮              | 游릭        | 游댮        | 游댮                                 | 游댮              | 游댮              | 8             | 游댮               | 游릭                          | 游릭                      |        |\n <Tip>\n   \n **1:** bitsandbytes is being refactored to support multiple backends beyond CUDA. Currently, ROCm (AMD GPU) and Intel CPU implementations are mature, with Intel XPU in progress and Apple Silicon support expected by Q4/Q1. For installation instructions and the latest backend updates, visit [this link](https://huggingface.co/docs/bitsandbytes/main/en/installation#multi-backend). Check out [these docs](https://huggingface.co/docs/bitsandbytes/main/en/non_cuda_backends) for more details and feedback links."
        },
        {
            "sha": "b6412cf593602c2543c95b15a5812d7ac49dad82",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/efe72fe21f4292e4f3a74344c0a065dc69480b3b/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/efe72fe21f4292e4f3a74344c0a065dc69480b3b/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=efe72fe21f4292e4f3a74344c0a065dc69480b3b",
            "patch": "@@ -1024,6 +1024,7 @@\n         \"CompressedTensorsConfig\",\n         \"EetqConfig\",\n         \"FbgemmFp8Config\",\n+        \"FineGrainedFP8Config\",\n         \"GPTQConfig\",\n         \"HiggsConfig\",\n         \"HqqConfig\",\n@@ -6196,6 +6197,7 @@\n         CompressedTensorsConfig,\n         EetqConfig,\n         FbgemmFp8Config,\n+        FineGrainedFP8Config,\n         GPTQConfig,\n         HiggsConfig,\n         HqqConfig,"
        },
        {
            "sha": "c78564dcba8e213a874a27273fae23a618721830",
            "filename": "src/transformers/integrations/__init__.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/efe72fe21f4292e4f3a74344c0a065dc69480b3b/src%2Ftransformers%2Fintegrations%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/efe72fe21f4292e4f3a74344c0a065dc69480b3b/src%2Ftransformers%2Fintegrations%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fintegrations%2F__init__.py?ref=efe72fe21f4292e4f3a74344c0a065dc69480b3b",
            "patch": "@@ -54,6 +54,7 @@\n     ],\n     \"eetq\": [\"replace_with_eetq_linear\"],\n     \"fbgemm_fp8\": [\"FbgemmFp8Linear\", \"replace_with_fbgemm_fp8_linear\"],\n+    \"finegrained_fp8\": [\"FP8Linear\", \"replace_with_fp8_linear\"],\n     \"fsdp\": [\"is_fsdp_managed_module\"],\n     \"ggml\": [\n         \"GGUF_CONFIG_MAPPING\",\n@@ -157,6 +158,7 @@\n     )\n     from .eetq import replace_with_eetq_linear\n     from .fbgemm_fp8 import FbgemmFp8Linear, replace_with_fbgemm_fp8_linear\n+    from .finegrained_fp8 import FP8Linear, replace_with_fp8_linear\n     from .fsdp import is_fsdp_managed_module\n     from .ggml import (\n         GGUF_CONFIG_MAPPING,"
        },
        {
            "sha": "0815df43445306b6b4aefd2c2d9a4ea35169a044",
            "filename": "src/transformers/integrations/finegrained_fp8.py",
            "status": "added",
            "additions": 420,
            "deletions": 0,
            "changes": 420,
            "blob_url": "https://github.com/huggingface/transformers/blob/efe72fe21f4292e4f3a74344c0a065dc69480b3b/src%2Ftransformers%2Fintegrations%2Ffinegrained_fp8.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/efe72fe21f4292e4f3a74344c0a065dc69480b3b/src%2Ftransformers%2Fintegrations%2Ffinegrained_fp8.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fintegrations%2Ffinegrained_fp8.py?ref=efe72fe21f4292e4f3a74344c0a065dc69480b3b",
            "patch": "@@ -0,0 +1,420 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import List, Optional, Tuple\n+\n+from ..utils import is_accelerate_available, is_torch_available, logging\n+\n+\n+if is_torch_available():\n+    import torch\n+    import torch.nn as nn\n+    import triton\n+    import triton.language as tl\n+    from torch.nn import functional as F\n+\n+if is_accelerate_available():\n+    from accelerate import init_empty_weights\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+# Copied from https://huggingface.co/deepseek-ai/DeepSeek-V3/blob/main/inference/kernel.py\n+@triton.jit\n+def act_quant_kernel(x_ptr, y_ptr, s_ptr, BLOCK_SIZE: tl.constexpr):\n+    pid = tl.program_id(axis=0)\n+    offs = pid * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n+    x = tl.load(x_ptr + offs).to(tl.float32)\n+    s = tl.max(tl.abs(x)) / 448.0\n+    y = x / s\n+    y = y.to(y_ptr.dtype.element_ty)\n+    tl.store(y_ptr + offs, y)\n+    tl.store(s_ptr + pid, s)\n+\n+\n+def act_quant(x: torch.Tensor, block_size: int = 128) -> Tuple[torch.Tensor, torch.Tensor]:\n+    assert x.is_contiguous()\n+    assert x.shape[-1] % block_size == 0\n+    y = torch.empty_like(x, dtype=torch.float8_e4m3fn)\n+    s = x.new_empty(*x.size()[:-1], x.size(-1) // block_size, dtype=torch.float32)\n+\n+    def grid(meta):\n+        return (triton.cdiv(x.numel(), meta[\"BLOCK_SIZE\"]),)\n+\n+    act_quant_kernel[grid](x, y, s, BLOCK_SIZE=block_size)\n+    return y, s\n+\n+\n+# Adapted from https://github.com/sgl-project/sglang/blob/main/python/sglang/srt/layers/quantization/fp8_kernel.py\n+@triton.jit\n+def _w8a8_block_fp8_matmul(\n+    # Pointers to inputs and output\n+    A,\n+    B,\n+    C,\n+    As,\n+    Bs,\n+    # Shape for matmul\n+    M,\n+    N,\n+    K,\n+    # Block size for block-wise quantization\n+    group_n,\n+    group_k,\n+    # Stride for inputs and output\n+    stride_am,\n+    stride_ak,\n+    stride_bk,\n+    stride_bn,\n+    stride_cm,\n+    stride_cn,\n+    stride_As_m,\n+    stride_As_k,\n+    stride_Bs_k,\n+    stride_Bs_n,\n+    # Meta-parameters\n+    BLOCK_SIZE_M: tl.constexpr,\n+    BLOCK_SIZE_N: tl.constexpr,\n+    BLOCK_SIZE_K: tl.constexpr,\n+    GROUP_SIZE_M: tl.constexpr,\n+):\n+    \"\"\"Triton-accelerated function used to perform linear operations (dot\n+    product) on input tensors `A` and `B` with block-wise quantization, and\n+    store the result in output tensor `C`.\n+    \"\"\"\n+\n+    pid = tl.program_id(axis=0)\n+    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n+    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n+    num_pid_in_group = GROUP_SIZE_M * num_pid_n\n+    group_id = pid // num_pid_in_group\n+    first_pid_m = group_id * GROUP_SIZE_M\n+    group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)\n+    pid_m = first_pid_m + (pid % group_size_m)\n+    pid_n = (pid % num_pid_in_group) // group_size_m\n+\n+    offs_am = (pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)) % M\n+    offs_bn = (pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)) % N\n+    offs_k = tl.arange(0, BLOCK_SIZE_K)\n+    a_ptrs = A + (offs_am[:, None] * stride_am + offs_k[None, :] * stride_ak)\n+    b_ptrs = B + (offs_k[:, None] * stride_bk + offs_bn[None, :] * stride_bn)\n+\n+    As_ptrs = As + offs_am * stride_As_m\n+    offs_bsn = offs_bn // group_n\n+    Bs_ptrs = Bs + offs_bsn * stride_Bs_n\n+\n+    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n+    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n+        a = tl.load(a_ptrs, mask=offs_k[None, :] < K - k * BLOCK_SIZE_K, other=0.0)\n+        b = tl.load(b_ptrs, mask=offs_k[:, None] < K - k * BLOCK_SIZE_K, other=0.0)\n+\n+        k_start = k * BLOCK_SIZE_K\n+        offs_ks = k_start // group_k\n+        a_s = tl.load(As_ptrs + offs_ks * stride_As_k)\n+        b_s = tl.load(Bs_ptrs + offs_ks * stride_Bs_k)\n+\n+        accumulator += tl.dot(a, b) * a_s[:, None] * b_s[None, :]\n+        a_ptrs += BLOCK_SIZE_K * stride_ak\n+        b_ptrs += BLOCK_SIZE_K * stride_bk\n+\n+    if C.dtype.element_ty == tl.bfloat16:\n+        c = accumulator.to(tl.bfloat16)\n+    elif C.dtype.element_ty == tl.float16:\n+        c = accumulator.to(tl.float16)\n+    else:\n+        c = accumulator.to(tl.float32)\n+\n+    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n+    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n+    c_ptrs = C + stride_cm * offs_cm[:, None] + stride_cn * offs_cn[None, :]\n+    c_mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n+    tl.store(c_ptrs, c, mask=c_mask)\n+\n+\n+def w8a8_block_fp8_matmul_triton(\n+    A: torch.Tensor,\n+    B: torch.Tensor,\n+    As: torch.Tensor,\n+    Bs: torch.Tensor,\n+    block_size: List[int],\n+    output_dtype: torch.dtype = torch.float32,\n+) -> torch.Tensor:\n+    \"\"\"This function performs matrix multiplication with block-wise\n+    quantization.\n+    It takes two input tensors `A` and `B` with scales `As` and `Bs`.\n+    The output is returned in the specified `output_dtype`.\n+    Args:\n+        A: The input tensor, e.g., activation.\n+        B: The input tensor, e.g., weight.\n+        As: The per-token-group quantization scale for `A`.\n+        Bs: The per-block quantization scale for `B`.\n+        block_size: The block size for per-block quantization. It should\n+        be 2-dim, e.g., [128, 128].\n+        output_dytpe: The dtype of the returned tensor.\n+    Returns:\n+        torch.Tensor: The result of matmul.\n+    \"\"\"\n+    assert len(block_size) == 2\n+    block_n, block_k = block_size[0], block_size[1]\n+\n+    assert A.shape[-1] == B.shape[-1]\n+    assert A.shape[:-1] == As.shape[:-1] and A.is_contiguous()\n+    assert triton.cdiv(A.shape[-1], block_k) == As.shape[-1]\n+    M = A.numel() // A.shape[-1]\n+\n+    assert B.ndim == 2 and B.is_contiguous() and Bs.ndim == 2\n+    N, K = B.shape\n+    assert triton.cdiv(N, block_n) == Bs.shape[0]\n+    assert triton.cdiv(K, block_k) == Bs.shape[1]\n+\n+    C_shape = A.shape[:-1] + (N,)\n+    C = A.new_empty(C_shape, dtype=output_dtype)\n+\n+    BLOCK_SIZE_M = 128\n+    if M < BLOCK_SIZE_M:\n+        BLOCK_SIZE_M = triton.next_power_of_2(M)\n+        BLOCK_SIZE_M = max(BLOCK_SIZE_M, 16)\n+    BLOCK_SIZE_K = block_k\n+    assert block_k % BLOCK_SIZE_K == 0\n+    BLOCK_SIZE_N = block_n\n+\n+    def grid(META):\n+        return (triton.cdiv(M, META[\"BLOCK_SIZE_M\"]) * triton.cdiv(N, META[\"BLOCK_SIZE_N\"]),)\n+\n+    _w8a8_block_fp8_matmul[grid](\n+        A,\n+        B,\n+        C,\n+        As,\n+        Bs,\n+        M,\n+        N,\n+        K,\n+        block_n,\n+        block_k,\n+        A.stride(-2),\n+        A.stride(-1),\n+        B.stride(1),\n+        B.stride(0),\n+        C.stride(-2),\n+        C.stride(-1),\n+        As.stride(-2),\n+        As.stride(-1),\n+        Bs.stride(1),\n+        Bs.stride(0),\n+        BLOCK_SIZE_M=BLOCK_SIZE_M,\n+        BLOCK_SIZE_N=BLOCK_SIZE_N,\n+        BLOCK_SIZE_K=BLOCK_SIZE_K,\n+        GROUP_SIZE_M=8,\n+    )\n+\n+    return C\n+\n+\n+# Python version of the above triton function, it's much slower than the triton version, for testing\n+@torch.compile\n+def w8a8_block_fp8_matmul_compile(\n+    input_q: torch.Tensor,  # [batch, seq_len, hidden_dim]\n+    weight_q: torch.Tensor,  # [out_features, hidden_dim]\n+    input_scale: torch.Tensor,  # [batch * seq_len, num_input_groups]\n+    weight_scale: torch.Tensor,  # [num_weight_blocks_m, num_weight_blocks_n]\n+    block_size: Optional[Tuple[int, int]] = None,  # (M=128, N=128) for weights for example\n+    output_dtype: torch.dtype = torch.float32,\n+) -> torch.Tensor:\n+    \"\"\"\n+    Performs blocked matrix multiplication with FP8 quantized matrices.\n+\n+    Args:\n+        input_q: Quantized input tensor with 1x128 block quantization\n+        weight_q: Quantized weight tensor with 128x128 block quantization\n+        input_scale: Scaling factors for input blocks\n+        weight_scale: Scaling factors for weight blocks\n+        block_size: Tuple of (M, N) for weight block dimensions\n+        output_dtype: Desired output dtype\n+    \"\"\"\n+    batch_size, seq_len, hidden_dim = input_q.shape if input_q.ndim == 3 else (1, input_q.shape[0], input_q.shape[1])\n+    out_features = weight_q.shape[0]\n+\n+    # Reshape input for batched matmul\n+    input_reshaped = input_q.view(-1, hidden_dim)  # [batch*seq_len, hidden_dim]\n+    input_scale_reshaped = input_scale.view(input_scale.shape[0], -1)  # [batch*seq_len, 1]\n+    # Calculate number of blocks\n+    num_weight_blocks_m = out_features // block_size[0]\n+    num_weight_blocks_n = hidden_dim // block_size[1]\n+\n+    output = torch.zeros((batch_size * seq_len, out_features), dtype=torch.float32, device=input_q.device)\n+\n+    for i in range(num_weight_blocks_m):\n+        m_start = i * block_size[0]\n+        m_end = m_start + block_size[0]\n+\n+        for j in range(num_weight_blocks_n):\n+            n_start = j * block_size[1]\n+            n_end = n_start + block_size[1]\n+\n+            # Extract current blocks\n+            input_block = input_reshaped[:, n_start:n_end]\n+            weight_block = weight_q[m_start:m_end, n_start:n_end]\n+\n+            # Get corresponding scales\n+            curr_input_scale = input_scale_reshaped[:, j : j + 1]  # [batch*seq_len, 1]\n+            curr_weight_scale = weight_scale[i, j]  # scalar\n+\n+            block_result = (\n+                torch._scaled_mm(\n+                    input_block,\n+                    weight_block.t(),\n+                    scale_a=torch.tensor(1, dtype=torch.float32, device=input_q.device),\n+                    scale_b=curr_weight_scale,\n+                    out_dtype=output_dtype,\n+                )\n+                * curr_input_scale\n+            )\n+\n+            output[:, m_start:m_end] += block_result\n+\n+    output = output.view(batch_size, seq_len, out_features)\n+\n+    return output.to(output_dtype)\n+\n+\n+class FP8Linear(nn.Module):\n+    dtype = torch.float8_e4m3fn\n+\n+    def __init__(\n+        self,\n+        in_features: int,\n+        out_features: int,\n+        bias: bool = False,\n+        dtype=None,\n+        block_size: Optional[Tuple[int, int]] = None,\n+        device=None,\n+        activation_scheme=\"dynamic\",\n+    ):\n+        super().__init__()\n+        self.in_features = in_features\n+        self.out_features = out_features\n+\n+        self.register_buffer(\"weight\", torch.empty(out_features, in_features, dtype=FP8Linear.dtype, device=device))\n+\n+        scale_out_features = (out_features + block_size[0] - 1) // block_size[0]\n+        scale_in_features = (in_features + block_size[1] - 1) // block_size[1]\n+        self.register_buffer(\n+            \"weight_scale_inv\", torch.empty(scale_out_features, scale_in_features, dtype=torch.float32, device=device)\n+        )\n+\n+        self.block_size = block_size\n+\n+        self.activation_scheme = activation_scheme\n+\n+        if bias:\n+            self.bias = nn.Parameter(torch.empty(self.out_features))\n+        else:\n+            self.register_parameter(\"bias\", None)\n+\n+    def forward(self, input: torch.Tensor) -> torch.Tensor:\n+        if self.weight.element_size() > 1:\n+            return F.linear(input, self.weight, self.bias)\n+        else:\n+            # Context manager used to switch among the available cuda devices\n+            with torch.cuda.device(input.device):\n+                qinput, scale = act_quant(input, self.block_size[1])\n+            # Blocks the CPU until all CUDA operations on the specified device are complete. It is used to ensure that the results of the\n+            # preceding operations are ready before proceeding\n+            torch.cuda.synchronize(device=input.device)\n+            with torch.cuda.device(input.device):\n+                output = w8a8_block_fp8_matmul_triton(\n+                    qinput,\n+                    self.weight,\n+                    scale,\n+                    self.weight_scale_inv,\n+                    self.block_size,\n+                    output_dtype=input.dtype,\n+                )\n+            torch.cuda.synchronize(device=input.device)\n+            if self.bias is not None:\n+                output = output + self.bias\n+            return output.to(dtype=input.dtype)\n+\n+\n+def _replace_with_fp8_linear(\n+    model,\n+    modules_to_not_convert=None,\n+    current_key_name=None,\n+    quantization_config=None,\n+    has_been_replaced=False,\n+):\n+    \"\"\"Replace Linear layers with FP8Linear.\"\"\"\n+    if current_key_name is None:\n+        current_key_name = []\n+\n+    for name, module in model.named_children():\n+        current_key_name.append(name)\n+\n+        if isinstance(module, nn.Linear) and name not in (modules_to_not_convert or []):\n+            current_key_name_str = \".\".join(current_key_name)\n+            if not any(key in current_key_name_str for key in (modules_to_not_convert or [])):\n+                with init_empty_weights():\n+                    model._modules[name] = FP8Linear(\n+                        in_features=module.in_features,\n+                        out_features=module.out_features,\n+                        bias=module.bias is not None,\n+                        device=module.weight.device,\n+                        dtype=module.weight.dtype,\n+                        activation_scheme=quantization_config.activation_scheme,\n+                        block_size=quantization_config.weight_block_size,\n+                    )\n+                    has_been_replaced = True\n+\n+        if len(list(module.children())) > 0:\n+            _, has_been_replaced = _replace_with_fp8_linear(\n+                module,\n+                modules_to_not_convert,\n+                current_key_name,\n+                quantization_config,\n+                has_been_replaced=has_been_replaced,\n+            )\n+\n+        current_key_name.pop(-1)\n+\n+    return model, has_been_replaced\n+\n+\n+def replace_with_fp8_linear(\n+    model,\n+    modules_to_not_convert=None,\n+    quantization_config=None,\n+):\n+    \"\"\"Helper function to replace model layers with FP8 versions.\"\"\"\n+    modules_to_not_convert = [\"lm_head\"] if modules_to_not_convert is None else modules_to_not_convert\n+\n+    if quantization_config.modules_to_not_convert is not None:\n+        modules_to_not_convert.extend(quantization_config.modules_to_not_convert)\n+    modules_to_not_convert = list(set(modules_to_not_convert))\n+\n+    model, has_been_replaced = _replace_with_fp8_linear(\n+        model,\n+        modules_to_not_convert=modules_to_not_convert,\n+        quantization_config=quantization_config,\n+    )\n+\n+    if not has_been_replaced:\n+        logger.warning(\n+            \"You are loading your model using fp8 but no linear modules were found in your model.\"\n+            \" Please double check your model architecture.\"\n+        )\n+\n+    return model"
        },
        {
            "sha": "0f279498f7eca2495fdcef93a222f65d9e00a021",
            "filename": "src/transformers/quantizers/auto.py",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/efe72fe21f4292e4f3a74344c0a065dc69480b3b/src%2Ftransformers%2Fquantizers%2Fauto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/efe72fe21f4292e4f3a74344c0a065dc69480b3b/src%2Ftransformers%2Fquantizers%2Fauto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fquantizers%2Fauto.py?ref=efe72fe21f4292e4f3a74344c0a065dc69480b3b",
            "patch": "@@ -24,6 +24,7 @@\n     CompressedTensorsConfig,\n     EetqConfig,\n     FbgemmFp8Config,\n+    FineGrainedFP8Config,\n     GPTQConfig,\n     HiggsConfig,\n     HqqConfig,\n@@ -41,6 +42,7 @@\n from .quantizer_compressed_tensors import CompressedTensorsHfQuantizer\n from .quantizer_eetq import EetqHfQuantizer\n from .quantizer_fbgemm_fp8 import FbgemmFp8HfQuantizer\n+from .quantizer_finegrained_fp8 import FineGrainedFP8HfQuantizer\n from .quantizer_gptq import GptqHfQuantizer\n from .quantizer_higgs import HiggsHfQuantizer\n from .quantizer_hqq import HqqHfQuantizer\n@@ -64,6 +66,7 @@\n     \"torchao\": TorchAoHfQuantizer,\n     \"bitnet\": BitNetHfQuantizer,\n     \"vptq\": VptqHfQuantizer,\n+    \"fp8\": FineGrainedFP8HfQuantizer,\n }\n \n AUTO_QUANTIZATION_CONFIG_MAPPING = {\n@@ -81,6 +84,7 @@\n     \"torchao\": TorchAoConfig,\n     \"bitnet\": BitNetConfig,\n     \"vptq\": VptqConfig,\n+    \"fp8\": FineGrainedFP8Config,\n }\n \n logger = logging.get_logger(__name__)"
        },
        {
            "sha": "7816ed2f583418e9127ec296a9186854ec5854ae",
            "filename": "src/transformers/quantizers/quantizer_finegrained_fp8.py",
            "status": "added",
            "additions": 207,
            "deletions": 0,
            "changes": 207,
            "blob_url": "https://github.com/huggingface/transformers/blob/efe72fe21f4292e4f3a74344c0a065dc69480b3b/src%2Ftransformers%2Fquantizers%2Fquantizer_finegrained_fp8.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/efe72fe21f4292e4f3a74344c0a065dc69480b3b/src%2Ftransformers%2Fquantizers%2Fquantizer_finegrained_fp8.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fquantizers%2Fquantizer_finegrained_fp8.py?ref=efe72fe21f4292e4f3a74344c0a065dc69480b3b",
            "patch": "@@ -0,0 +1,207 @@\n+import importlib\n+from typing import TYPE_CHECKING, Any, Dict, List, Optional\n+\n+from packaging import version\n+\n+from ..utils import is_accelerate_available, is_torch_available, logging\n+from .base import HfQuantizer\n+from .quantizers_utils import get_module_from_name\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+if TYPE_CHECKING:\n+    from ..modeling_utils import PreTrainedModel\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class FineGrainedFP8HfQuantizer(HfQuantizer):\n+    \"\"\"\n+    FP8 quantization implementation supporting both standard and MoE models.\n+    Supports both e4m3fn formats based on platform.\n+    \"\"\"\n+\n+    requires_parameters_quantization = True\n+    requires_calibration = False\n+    required_packages = [\"accelerate\"]\n+\n+    def __init__(self, quantization_config, **kwargs):\n+        super().__init__(quantization_config, **kwargs)\n+        self.quantization_config = quantization_config\n+\n+    def validate_environment(self, *args, **kwargs):\n+        if not is_torch_available() or version.parse(importlib.metadata.version(\"torch\")) < version.parse(\"2.1.0\"):\n+            raise ImportError(\n+                \"Using fp8 quantization requires torch >= 2.1.0\"\n+                \"Please install the latest version of torch ( pip install --upgrade torch )\"\n+            )\n+\n+        if not is_accelerate_available():\n+            raise ImportError(\"Loading an FP8 quantized model requires accelerate (`pip install accelerate`)\")\n+\n+        if kwargs.get(\"from_tf\", False) or kwargs.get(\"from_flax\", False):\n+            raise ValueError(\n+                \"Converting into FP8 weights from tf/flax weights is currently not supported, \"\n+                \"please make sure the weights are in PyTorch format.\"\n+            )\n+\n+        if not torch.cuda.is_available():\n+            raise RuntimeError(\"No GPU found. A GPU is needed for FP8 quantization.\")\n+\n+        compute_capability = torch.cuda.get_device_capability()\n+        major, minor = compute_capability\n+        if major < 9:\n+            raise ValueError(\n+                \"FP8 quantized models is only supported on GPUs with compute capability >= 9.0 (e.g H100)\"\n+            )\n+\n+        device_map = kwargs.get(\"device_map\", None)\n+        if device_map is None:\n+            logger.warning_once(\n+                \"You have loaded an FP8 model on CPU and have a CUDA device available, make sure to set \"\n+                \"your model on a GPU device in order to run your model. To remove this warning, pass device_map = 'cuda'. \"\n+            )\n+        elif device_map is not None:\n+            if (\n+                not self.pre_quantized\n+                and isinstance(device_map, dict)\n+                and (\"cpu\" in device_map.values() or \"disk\" in device_map.values())\n+            ):\n+                raise ValueError(\n+                    \"You are attempting to load an FP8 model with a device_map that contains a cpu/disk device.\"\n+                    \"This is not supported when the model is quantized on the fly. \"\n+                    \"Please use a quantized checkpoint or remove the cpu/disk device from the device_map.\"\n+                )\n+\n+    def update_torch_dtype(self, torch_dtype: \"torch.dtype\") -> \"torch.dtype\":\n+        if torch_dtype is None:\n+            logger.info(\"Setting torch_dtype to torch.float32 as no torch_dtype was specified in from_pretrained\")\n+            torch_dtype = torch.float32\n+        return torch_dtype\n+\n+    def create_quantized_param(\n+        self,\n+        model: \"PreTrainedModel\",\n+        param_value: \"torch.Tensor\",\n+        param_name: str,\n+        target_device: \"torch.device\",\n+        state_dict: Dict[str, Any],\n+        unexpected_keys: Optional[List[str]] = None,\n+    ):\n+        \"\"\"\n+        Quantizes weights to FP8 format using Block-wise quantization\n+        \"\"\"\n+        from accelerate.utils import set_module_tensor_to_device\n+\n+        set_module_tensor_to_device(model, param_name, target_device, param_value)\n+\n+        module, tensor_name = get_module_from_name(model, param_name)\n+\n+        # Get FP8 min/max values\n+        fp8_min = torch.finfo(torch.float8_e4m3fn).min\n+        fp8_max = torch.finfo(torch.float8_e4m3fn).max\n+\n+        block_size_m, block_size_n = self.quantization_config.weight_block_size\n+\n+        rows, cols = param_value.shape[-2:]\n+\n+        if rows % block_size_m != 0 or cols % block_size_n != 0:\n+            raise ValueError(\n+                f\"Matrix dimensions ({rows}, {cols}) must be divisible by block sizes ({block_size_m}, {block_size_n})\"\n+            )\n+        param_value_orig_shape = param_value.shape\n+\n+        param_value = param_value.reshape(\n+            -1, rows // block_size_m, block_size_m, cols // block_size_n, block_size_n\n+        ).permute(0, 1, 3, 2, 4)\n+\n+        # Calculate scaling factor for each block\n+        max_abs = torch.amax(torch.abs(param_value), dim=(-1, -2))\n+        scale = fp8_max / max_abs\n+        scale_orig_shape = scale.shape\n+        scale = scale.unsqueeze(-1).unsqueeze(-1)\n+\n+        # Quantize the weights\n+        quantized_param = torch.clamp(param_value * scale, min=fp8_min, max=fp8_max).to(torch.float8_e4m3fn)\n+\n+        quantized_param = quantized_param.permute(0, 1, 3, 2, 4)\n+        # Reshape back to matrix shape\n+        quantized_param = quantized_param.reshape(param_value_orig_shape)\n+\n+        # Reshape scale to match the number of blocks\n+        scale = scale.reshape(scale_orig_shape).squeeze().reciprocal()\n+\n+        module._buffers[tensor_name] = quantized_param.to(target_device)\n+        module._buffers[\"weight_scale_inv\"] = scale.to(target_device)\n+\n+    def check_quantized_param(\n+        self,\n+        model: \"PreTrainedModel\",\n+        param_value: \"torch.Tensor\",\n+        param_name: str,\n+        state_dict: Dict[str, Any],\n+        **kwargs,\n+    ):\n+        from ..integrations.finegrained_fp8 import FP8Linear\n+\n+        module, tensor_name = get_module_from_name(model, param_name)\n+\n+        if isinstance(module, FP8Linear):\n+            if self.pre_quantized or tensor_name == \"bias\":\n+                if tensor_name == \"weight\" and param_value.dtype != torch.float8_e4m3fn:\n+                    raise ValueError(\"Expect quantized weights but got an unquantized weight\")\n+                return False\n+            else:\n+                if tensor_name == \"weight_scale_inv\":\n+                    raise ValueError(\"Expect unquantized weights but got a quantized weight_scale\")\n+                return True\n+        return False\n+\n+    def _process_model_before_weight_loading(\n+        self,\n+        model: \"PreTrainedModel\",\n+        device_map,\n+        modules_to_not_convert: List[str] = [],\n+        **kwargs,\n+    ):\n+        from ..integrations.finegrained_fp8 import replace_with_fp8_linear\n+\n+        self.modules_to_not_convert = [\"lm_head\"] + modules_to_not_convert\n+\n+        if self.quantization_config.modules_to_not_convert:\n+            self.modules_to_not_convert.extend(self.quantization_config.modules_to_not_convert)\n+\n+        model = replace_with_fp8_linear(\n+            model,\n+            modules_to_not_convert=self.modules_to_not_convert,\n+            quantization_config=self.quantization_config,\n+        )\n+\n+        model.config.quantization_config = self.quantization_config\n+\n+    def _process_model_after_weight_loading(self, model: \"PreTrainedModel\", **kwargs):\n+        return model\n+\n+    def update_missing_keys(self, model, missing_keys: List[str], prefix: str) -> List[str]:\n+        from ..integrations import FP8Linear\n+\n+        not_missing_keys = []\n+        for name, module in model.named_modules():\n+            if isinstance(module, FP8Linear):\n+                for missing in missing_keys:\n+                    if (\n+                        (name in missing or name in f\"{prefix}.{missing}\")\n+                        and not missing.endswith(\".weight\")\n+                        and not missing.endswith(\".bias\")\n+                    ):\n+                        not_missing_keys.append(missing)\n+        return [k for k in missing_keys if k not in not_missing_keys]\n+\n+    def is_serializable(self, safe_serialization=None):\n+        return True\n+\n+    @property\n+    def is_trainable(self) -> bool:\n+        return False"
        },
        {
            "sha": "329123e0f4a42e3b4b87822dba0d22df36489430",
            "filename": "src/transformers/utils/quantization_config.py",
            "status": "modified",
            "additions": 42,
            "deletions": 1,
            "changes": 43,
            "blob_url": "https://github.com/huggingface/transformers/blob/efe72fe21f4292e4f3a74344c0a065dc69480b3b/src%2Ftransformers%2Futils%2Fquantization_config.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/efe72fe21f4292e4f3a74344c0a065dc69480b3b/src%2Ftransformers%2Futils%2Fquantization_config.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fquantization_config.py?ref=efe72fe21f4292e4f3a74344c0a065dc69480b3b",
            "patch": "@@ -21,7 +21,7 @@\n from dataclasses import dataclass\n from enum import Enum\n from inspect import Parameter, signature\n-from typing import Any, Dict, List, Optional, Union\n+from typing import Any, Dict, List, Optional, Tuple, Union\n \n from packaging import version\n \n@@ -56,6 +56,7 @@ class QuantizationMethod(str, Enum):\n     FBGEMM_FP8 = \"fbgemm_fp8\"\n     TORCHAO = \"torchao\"\n     BITNET = \"bitnet\"\n+    FP8 = \"fp8\"\n \n \n class AWQLinearVersion(str, Enum):\n@@ -1548,3 +1549,43 @@ def post_init(self):\n         Safety checker that arguments are correct\n         \"\"\"\n         pass\n+\n+\n+@dataclass\n+class FineGrainedFP8Config(QuantizationConfigMixin):\n+    \"\"\"\n+    FineGrainedFP8Config is a configuration class for fine-grained FP8 quantization used mainly for deepseek models.\n+\n+    Args:\n+        activation_scheme (`str`, *optional*, defaults to `\"dynamic\"`):\n+            The scheme used for activation, the defaults and only support scheme for now is \"dynamic\".\n+        weight_block_size (`typing.Tuple[int, int]`, *optional*, defaults to `(128, 128)`):\n+            The size of the weight blocks for quantization, default is (128, 128).\n+        modules_to_not_convert (`list`, *optional*):\n+            A list of module names that should not be converted during quantization.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        activation_scheme: str = \"dynamic\",\n+        weight_block_size: Tuple[int, int] = (128, 128),\n+        modules_to_not_convert: Optional[List] = None,\n+        **kwargs,\n+    ):\n+        self.quant_method = QuantizationMethod.FP8\n+        self.modules_to_not_convert = modules_to_not_convert\n+        self.activation_scheme = activation_scheme\n+        self.weight_block_size = weight_block_size\n+        self.post_init()\n+\n+    def post_init(self):\n+        r\"\"\"\n+        Safety checker that arguments are correct\n+        \"\"\"\n+        self.activation_scheme = self.activation_scheme.lower()\n+        if self.activation_scheme not in [\"dynamic\"]:\n+            raise ValueError(f\"Activation scheme {self.activation_scheme} not supported\")\n+        if len(self.weight_block_size) != 2:\n+            raise ValueError(\"weight_block_size must be a tuple of two integers\")\n+        if self.weight_block_size[0] <= 0 or self.weight_block_size[1] <= 0:\n+            raise ValueError(\"weight_block_size must be a tuple of two positive integers\")"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/quantization/finegrained_fp8/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/efe72fe21f4292e4f3a74344c0a065dc69480b3b/tests%2Fquantization%2Ffinegrained_fp8%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/efe72fe21f4292e4f3a74344c0a065dc69480b3b/tests%2Fquantization%2Ffinegrained_fp8%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fquantization%2Ffinegrained_fp8%2F__init__.py?ref=efe72fe21f4292e4f3a74344c0a065dc69480b3b"
        },
        {
            "sha": "f86898b40b090c3564a5b5e835e68dd9e54a191a",
            "filename": "tests/quantization/finegrained_fp8/test_fp8.py",
            "status": "added",
            "additions": 273,
            "deletions": 0,
            "changes": 273,
            "blob_url": "https://github.com/huggingface/transformers/blob/efe72fe21f4292e4f3a74344c0a065dc69480b3b/tests%2Fquantization%2Ffinegrained_fp8%2Ftest_fp8.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/efe72fe21f4292e4f3a74344c0a065dc69480b3b/tests%2Fquantization%2Ffinegrained_fp8%2Ftest_fp8.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fquantization%2Ffinegrained_fp8%2Ftest_fp8.py?ref=efe72fe21f4292e4f3a74344c0a065dc69480b3b",
            "patch": "@@ -0,0 +1,273 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import gc\n+import tempfile\n+import unittest\n+\n+from transformers import AutoConfig, AutoModelForCausalLM, AutoTokenizer, FineGrainedFP8Config, OPTForCausalLM\n+from transformers.testing_utils import (\n+    require_accelerate,\n+    require_torch_gpu,\n+    require_torch_multi_gpu,\n+    slow,\n+)\n+from transformers.utils import is_accelerate_available, is_torch_available\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_accelerate_available():\n+    from accelerate import init_empty_weights\n+\n+\n+@require_torch_gpu\n+class FineGrainedFP8ConfigTest(unittest.TestCase):\n+    def test_to_dict(self):\n+        \"\"\"\n+        Simple test that checks if one uses a config and converts it to a dict, the dict is the same as the config object\n+        \"\"\"\n+        quantization_config = FineGrainedFP8Config()\n+        config_to_dict = quantization_config.to_dict()\n+\n+        for key in config_to_dict:\n+            self.assertEqual(getattr(quantization_config, key), config_to_dict[key])\n+\n+    def test_from_dict(self):\n+        \"\"\"\n+        Simple test that checks if one uses a dict and converts it to a config object, the config object is the same as the dict\n+        \"\"\"\n+        dict = {\"modules_to_not_convert\": [\"lm_head.weight\"], \"quant_method\": \"fp8\"}\n+        quantization_config = FineGrainedFP8Config.from_dict(dict)\n+\n+        self.assertEqual(dict[\"modules_to_not_convert\"], quantization_config.modules_to_not_convert)\n+        self.assertEqual(dict[\"quant_method\"], quantization_config.quant_method)\n+\n+\n+@slow\n+@require_accelerate\n+@require_torch_gpu\n+class FP8QuantizerTest(unittest.TestCase):\n+    model_name = \"meta-llama/Llama-3.2-1B\"\n+    input_text = \"Once upon a time\"\n+    max_new_tokens = 10\n+    EXPECTED_OUTPUT = \"Once upon a time, there was a man who was very rich.\"\n+    device_map = \"cuda\"\n+    offload_device_map = {\n+        \"model.embed_tokens\": 0,\n+        \"model.layers.0\": 0,\n+        \"model.layers.1\": 0,\n+        \"model.layers.2\": 0,\n+        \"model.layers.3\": 0,\n+        \"model.layers.4\": 0,\n+        \"model.layers.5\": 0,\n+        \"model.layers.6\": 0,\n+        \"model.layers.7\": \"cpu\",\n+        \"model.layers.8\": \"cpu\",\n+        \"model.layers.9\": \"cpu\",\n+        \"model.layers.10\": \"cpu\",\n+        \"model.layers.11\": \"cpu\",\n+        \"model.layers.12\": \"cpu\",\n+        \"model.layers.13\": \"cpu\",\n+        \"model.layers.14\": \"cpu\",\n+        \"model.layers.15\": \"cpu\",\n+        \"model.rotary_emb\": \"disk\",\n+        \"model.norm\": \"disk\",\n+        \"lm_head\": 0,\n+    }\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        \"\"\"\n+        Setup quantized model\n+        \"\"\"\n+        cls.quantization_config = FineGrainedFP8Config()\n+        cls.tokenizer = AutoTokenizer.from_pretrained(cls.model_name)\n+        cls.quantized_model = AutoModelForCausalLM.from_pretrained(\n+            cls.model_name, device_map=cls.device_map, quantization_config=cls.quantization_config\n+        )\n+\n+    def tearDown(self):\n+        gc.collect()\n+        torch.cuda.empty_cache()\n+        gc.collect()\n+\n+    def test_quantized_model_conversion(self):\n+        \"\"\"\n+        Simple test that checks if the quantized model has been converted properly\n+        \"\"\"\n+\n+        from transformers.integrations import FP8Linear, replace_with_fp8_linear\n+\n+        model_id = \"facebook/opt-350m\"\n+        config = AutoConfig.from_pretrained(model_id, revision=\"cb32f77e905cccbca1d970436fb0f5e6b58ee3c5\")\n+        quantization_config = FineGrainedFP8Config()\n+\n+        with init_empty_weights():\n+            model = OPTForCausalLM(config)\n+\n+        nb_linears = 0\n+        for module in model.modules():\n+            if isinstance(module, torch.nn.Linear):\n+                nb_linears += 1\n+\n+        model = replace_with_fp8_linear(model, quantization_config=quantization_config)\n+        nb_fp8_linear = 0\n+        for module in model.modules():\n+            if isinstance(module, FP8Linear):\n+                nb_fp8_linear += 1\n+\n+        self.assertEqual(nb_linears - 1, nb_fp8_linear)\n+\n+        with init_empty_weights():\n+            model = OPTForCausalLM(config)\n+        quantization_config = FineGrainedFP8Config(modules_to_not_convert=[\"fc1\"])\n+        model = replace_with_fp8_linear(model, quantization_config=quantization_config)\n+        nb_fp8_linear = 0\n+        for module in model.modules():\n+            if isinstance(module, FP8Linear):\n+                nb_fp8_linear += 1\n+\n+        self.assertEqual(nb_linears - 25, nb_fp8_linear)\n+\n+    def test_quantized_model(self):\n+        \"\"\"\n+        Simple test that checks if the quantized model is working properly\n+        \"\"\"\n+        input_ids = self.tokenizer(self.input_text, return_tensors=\"pt\").to(self.device_map)\n+\n+        output = self.quantized_model.generate(**input_ids, max_new_tokens=self.max_new_tokens, do_sample=False)\n+        self.assertEqual(self.tokenizer.decode(output[0], skip_special_tokens=True), self.EXPECTED_OUTPUT)\n+\n+    def test_save_pretrained(self):\n+        \"\"\"\n+        Simple test that checks if the quantized model is working properly after being saved and loaded\n+        \"\"\"\n+        with tempfile.TemporaryDirectory() as tmpdirname:\n+            self.quantized_model.save_pretrained(tmpdirname)\n+\n+            model = AutoModelForCausalLM.from_pretrained(tmpdirname, device_map=self.device_map)\n+\n+            input_ids = self.tokenizer(self.input_text, return_tensors=\"pt\").to(self.device_map)\n+\n+            output = model.generate(**input_ids, max_new_tokens=self.max_new_tokens, do_sample=False)\n+            self.assertEqual(self.tokenizer.decode(output[0], skip_special_tokens=True), self.EXPECTED_OUTPUT)\n+\n+    def test_weight_and_weight_scale_inv(self):\n+        \"\"\"\n+        Simple test that checks if the weight and weight_scale_inv are working properly\n+        \"\"\"\n+        weight = self.quantized_model.model.layers[0].self_attn.q_proj.weight\n+        weight_scale_inv = self.quantized_model.model.layers[0].self_attn.q_proj.weight_scale_inv\n+        self.assertEqual(weight.dtype, torch.float8_e4m3fn)\n+        self.assertEqual(weight_scale_inv.dtype, torch.float32)\n+        self.assertEqual(weight.shape, (weight_scale_inv.shape[0] * 128, weight_scale_inv.shape[1] * 128))\n+\n+    def test_block_size(self):\n+        \"\"\"\n+        Simple test that checks if the block size is working properly\n+        \"\"\"\n+        self.assertEqual(self.quantized_model.config.quantization_config.weight_block_size, (128, 128))\n+        quantization_config = FineGrainedFP8Config(weight_block_size=(32, 32))\n+        quantized_model = AutoModelForCausalLM.from_pretrained(\n+            self.model_name, device_map=self.device_map, quantization_config=quantization_config\n+        )\n+        self.assertEqual(quantized_model.config.quantization_config.weight_block_size, (32, 32))\n+\n+    @require_torch_multi_gpu\n+    def test_quantized_model_multi_gpu(self):\n+        \"\"\"\n+        Simple test that checks if the quantized model is working properly with multiple GPUs\n+        set CUDA_VISIBLE_DEVICES=0,1 if you have more than 2 GPUS\n+        \"\"\"\n+        input_ids = self.tokenizer(self.input_text, return_tensors=\"pt\").to(self.device_map)\n+        quantization_config = FineGrainedFP8Config()\n+        quantized_model = AutoModelForCausalLM.from_pretrained(\n+            self.model_name, device_map=\"auto\", quantization_config=quantization_config\n+        )\n+        self.assertTrue(set(quantized_model.hf_device_map.values()) == {0, 1})\n+\n+        output = quantized_model.generate(**input_ids, max_new_tokens=self.max_new_tokens, do_sample=False)\n+        self.assertEqual(self.tokenizer.decode(output[0], skip_special_tokens=True), self.EXPECTED_OUTPUT)\n+\n+    @require_torch_multi_gpu\n+    def test_save_pretrained_multi_gpu(self):\n+        \"\"\"\n+        Simple test that checks if the quantized model is working properly after being saved and loaded\n+        \"\"\"\n+        with tempfile.TemporaryDirectory() as tmpdirname:\n+            self.quantized_model.save_pretrained(tmpdirname)\n+\n+            model = AutoModelForCausalLM.from_pretrained(tmpdirname, device_map=\"auto\")\n+            self.assertTrue(set(model.hf_device_map.values()) == {0, 1})\n+\n+            input_ids = self.tokenizer(self.input_text, return_tensors=\"pt\").to(self.device_map)\n+\n+            output = model.generate(**input_ids, max_new_tokens=self.max_new_tokens, do_sample=False)\n+            self.assertEqual(self.tokenizer.decode(output[0], skip_special_tokens=True), self.EXPECTED_OUTPUT)\n+\n+    def test_quantized_model_offload(self):\n+        \"\"\"\n+        Simple test that checks if the quantized model returns an error when loading with cpu/disk offloaded\n+        \"\"\"\n+        with self.assertRaisesRegex(\n+            ValueError, \"You are attempting to load an FP8 model with a device_map that contains a cpu/disk device.\"\n+        ):\n+            AutoModelForCausalLM.from_pretrained(\n+                self.model_name, device_map=self.offload_device_map, quantization_config=self.quantization_config\n+            )\n+\n+    def test_save_pretrained_offload(self):\n+        \"\"\"\n+        Simple test that checks if the saved quantized model is working properly cpu/disk offload\n+        \"\"\"\n+        with tempfile.TemporaryDirectory() as tmpdirname:\n+            self.quantized_model.save_pretrained(tmpdirname)\n+\n+            input_ids = self.tokenizer(self.input_text, return_tensors=\"pt\").to(self.device_map)\n+\n+            quantized_model = AutoModelForCausalLM.from_pretrained(tmpdirname, device_map=self.offload_device_map)\n+            output = quantized_model.generate(**input_ids, max_new_tokens=self.max_new_tokens, do_sample=False)\n+            self.assertEqual(self.tokenizer.decode(output[0], skip_special_tokens=True), self.EXPECTED_OUTPUT)\n+\n+\n+@require_torch_gpu\n+class FP8LinearTest(unittest.TestCase):\n+    device = \"cuda\"\n+\n+    def test_linear_preserves_shape(self):\n+        \"\"\"\n+        Test that FP8Linear preserves shape when in_features == out_features.\n+        \"\"\"\n+        from transformers.integrations import FP8Linear\n+\n+        linear = FP8Linear(256, 256, block_size=(128, 128), device=self.device)\n+        x = torch.rand((1, 5, 256)).to(self.device)\n+\n+        x_ = linear(x)\n+        self.assertEqual(x_.shape, x.shape)\n+\n+    def test_linear_with_diff_feature_size_preserves_shape(self):\n+        \"\"\"\n+        Test that FP8Linear generates the correct shape when in_features != out_features.\n+        \"\"\"\n+        from transformers.integrations import FP8Linear\n+\n+        linear = FP8Linear(128, 256, block_size=(128, 128), device=self.device)\n+        x = torch.rand((1, 5, 128)).to(self.device)\n+\n+        x_ = linear(x)\n+        self.assertEqual(x_.shape, (1, 5, 256))"
        }
    ],
    "stats": {
        "total": 1021,
        "additions": 1019,
        "deletions": 2
    }
}