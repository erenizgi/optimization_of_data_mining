{
    "author": "ArthurZucker",
    "message": "[`MllamaImageProcessing`] Update doc (#33747)\n\n* update docstring\r\n\r\n* style",
    "sha": "7f9a9ca1e03ef74c160a3d4b54d3385b7d5b0b96",
    "files": [
        {
            "sha": "241db002c8a6459ef532d117814567c4d0e9132c",
            "filename": "src/transformers/models/mllama/image_processing_mllama.py",
            "status": "modified",
            "additions": 69,
            "deletions": 1,
            "changes": 70,
            "blob_url": "https://github.com/huggingface/transformers/blob/7f9a9ca1e03ef74c160a3d4b54d3385b7d5b0b96/src%2Ftransformers%2Fmodels%2Fmllama%2Fimage_processing_mllama.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7f9a9ca1e03ef74c160a3d4b54d3385b7d5b0b96/src%2Ftransformers%2Fmodels%2Fmllama%2Fimage_processing_mllama.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmllama%2Fimage_processing_mllama.py?ref=7f9a9ca1e03ef74c160a3d4b54d3385b7d5b0b96",
            "patch": "@@ -135,7 +135,7 @@ def get_optimal_tiled_canvas(\n     max_image_tiles: int,\n     tile_size: int,\n ) -> Tuple[int, int]:\n-    \"\"\"\n+    r\"\"\"\n     Determines the best canvas based on image and tile size and maximum number of tiles.\n \n     First, calculates possible resolutions based on the maximum number of tiles and tile size.\n@@ -158,6 +158,74 @@ def get_optimal_tiled_canvas(\n     to minimize padding. E.g., the same image can be upscaled to 224x224 and 224x448, but the latter\n     has more padding.\n \n+    Example of canvases made from tiles:\n+\n+    To visualize how the image can fit onto different tile grids, let's try fitting an ASCII cat into the tiles.\n+\n+    Here's an ASCII cat image you want to fit into the tiles:\n+\n+       /\\_/\\\n+      ( o.o )\n+       > ^ <\n+\n+    If `num_tiles=6`, possible tile grids would look like this:\n+\n+    **2x3 Canvas (2 tiles wide, 3 tiles tall)**: -> total of 6 tiles\n+    +-------+-------+\n+    | /\\_/\\ |   0   |   <- Cat image split across two tiles horizontally\n+    +-------+-------+\n+    | > ^ < |   0   |   <- Remaining part of the cat occupies the left tile\n+    +-------+-------+\n+    |( o.o )|   0   |\n+    +-------+-------+\n+\n+    **3x2 Canvas (3 tiles wide, 2 tiles tall)**: -> total of 6 tiles\n+    +-------+-------+-------+\n+    | /\\_/\\ |( o.o )|   0   |   <- Cat image occupies the first two tiles, 1 tile remains empty\n+    +-------+-------+-------+\n+    | > ^ < |   0   |   0   |   <- Remaining part of the cat occupies the left tile\n+    +-------+-------+-------+\n+\n+    **1x6 Canvas (1 tile wide, 6 tiles tall)**: -> total of 6 tiles\n+    +-------+\n+    | /\\_/\\ |   <- Top part of the cat\n+    +-------+\n+    |( o.o )|   <- Middle part of the cat\n+    +-------+\n+    | > ^ < |   <- Bottom part of the cat\n+    +-------+\n+    |   0   |\n+    +-------+\n+    |   0   |\n+    +-------+\n+    |   0   |\n+    +-------+\n+\n+    Given that the tiles you get depend on the chosen aspect ratio, you have to add\n+    embedding in the modeling code to help it know if it got a 3x2 or a 1x6 or a 2x3\n+    aspect ratio.\n+\n+    The function tests these arrangements to find the smallest canvas where the image fits.\n+    If multiple canvases fit, it selects the one where the dimensions are closest to the image size.\n+\n+    In this case the first canvas is the closest to the original image.\n+\n+    You then feed all of the tiles to the model:\n+\n+        +-------+-------+-------+-------+-------+-------+\n+    -   | /\\_/\\ |( o.o )| > ^ < |   0   |   0   |   0   |  <- Last canvas\n+        +-------+-------+-------+-------+-------+-------+\n+\n+        +-------+-------+-------+-------+-------+-------+\n+    -   | /\\_/\\ | 0     |( o.o )|   0   | > ^ < |   0   | <- First canvas\n+        +-------+-------+-------+-------+-------+-------+\n+\n+        +-------+-------+-------+-------+-------+-------+\n+    -   | /\\_/\\ |( o.o )|   0   | > ^ < |   0   |   0   | <- second canvas\n+        +-------+-------+-------+-------+-------+-------+\n+\n+    For each tile, you have num_channels (usually RGB so 3), tile_width, tile_height\n+\n     Args:\n         image_height (`int`):\n             The height of the image."
        }
    ],
    "stats": {
        "total": 70,
        "additions": 69,
        "deletions": 1
    }
}