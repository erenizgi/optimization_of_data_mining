{
    "author": "zucchini-nlp",
    "message": "Cache docs: update (#32929)\n\n* some changes\r\n\r\n* more updates\r\n\r\n* fix cache copy\r\n\r\n* nits\r\n\r\n* nits\r\n\r\n* add tests",
    "sha": "ebbe8d8014900e16876938c3e4a0d15c6f8acb67",
    "files": [
        {
            "sha": "be566437a34704f370dd1c29f9cdc87e1d6b0a3b",
            "filename": "docs/source/en/kv_cache.md",
            "status": "modified",
            "additions": 44,
            "deletions": 10,
            "changes": 54,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbe8d8014900e16876938c3e4a0d15c6f8acb67/docs%2Fsource%2Fen%2Fkv_cache.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbe8d8014900e16876938c3e4a0d15c6f8acb67/docs%2Fsource%2Fen%2Fkv_cache.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fkv_cache.md?ref=ebbe8d8014900e16876938c3e4a0d15c6f8acb67",
            "patch": "@@ -22,15 +22,15 @@ Effective caching helps reduce computation time and improve response rates, espe\n \n Transformers support various caching methods, leveraging \"Cache\" classes to abstract and manage the caching logic.\n This document outlines best practices for using these classes to maximize performance and efficiency.\n-Check out all the available `Cache` classes in the [API documentation](./internal/generation_utils.md).\n+Check out all the available `Cache` classes in the [API documentation](./internal/generation_utils).\n \n ## What is Cache and why we should care?\n \n Imagine youâ€™re having a conversation with someone, and instead of remembering what was said previously, you have to start from scratch every time you respond. This would be slow and inefficient, right? In the world of Transformer models, a similar concept applies, and that's where Caching keys and values come into play. From now on, I'll refer to the concept as KV Cache.\n \n KV cache is needed to optimize the generation in autoregressive models, where the model predicts text token by token. This process can be slow since the model can generate only one token at a time, and each new prediction is dependent on the previous context. That means, to predict token number 1000 in the generation, you need information from the previous 999 tokens, which comes in the form of some matrix multiplications across the representations of those tokens. But to predict token number 1001, you also need the same information from the first 999 tokens, plus additional information from token number 1000. That is where key-value cache is used to optimize the sequential generation process by storing previous calculations to reuse in subsequent tokens, so they don't need to be computed again.\n \n-More concretely, key-value cache acts as a memory bank for these generative models, where the model stores key-value pairs derived from self-attention layers for previously processed tokens. By storing this information, the model can avoid redundant computations and instead retrieve keys and values of previous tokens from the cache.\n+More concretely, key-value cache acts as a memory bank for these generative models, where the model stores key-value pairs derived from self-attention layers for previously processed tokens. By storing this information, the model can avoid redundant computations and instead retrieve keys and values of previous tokens from the cache. Note that caching can be used only in inference and should be disabled when training, otherwise it might cause unexpected errors.\n \n <details>\n   <summary><em>For the Curious Minds Who Like to Dive Deep</em></summary>\n@@ -94,7 +94,7 @@ More concretely, key-value cache acts as a memory bank for these generative mode\n In ðŸ¤— Transformers, we support various Cache types to optimize the performance across different models and tasks. By default, all models generate with caching,\n with the [`~DynamicCache`] class being the default cache for most models. It allows us to dynamically grow cache size, by saving more and more keys and values as we generate. If for some reason you don't want to use caches, you can pass `use_cache=False` into the `generate()` method.\n \n-Refer to the table below to see the difference between cache types and choose the one that suits best for your use-case.\n+Refer to the table below to see the difference between cache types and choose the one that suits best for your use-case. Models for which initialization is recommended should be initialized before calling the model and passed to model as a kwarg. In all other cases you can simply define desired `cache_implementation` and we take care of the rest for you.\n \n | Cache Type             | Memory Efficient | Supports torch.compile() | Initialization Recommended | Latency | Long Context Generation |\n |------------------------|------------------|--------------------------|----------------------------|---------|-------------------------|\n@@ -107,7 +107,7 @@ Refer to the table below to see the difference between cache types and choose th\n | Sink Cache             | Yes              | No                       | Yes                        | Mid     | Yes                     |\n \n \n-These cache classes can be set with a `cache_implementation` argument when generating. To learn about the available options for the cache_implementation flag, please refer to the [API Documentation](./main_classes/text_generation.md#transformers.GenerationConfig). Now, let's explore each cache type in detail and see how to use them. Note that the below examples are for decoder-only Tranformer-based models. We also support [\"Model-Specific Cache\"] classes for models such as Mamba or Jamba, keep reading for more details.\n+These cache classes can be set with a `cache_implementation` argument when generating. To learn about the available options for the cache_implementation flag, please refer to the [API Documentation](./main_classes/text_generation#transformers.GenerationConfig). Now, let's explore each cache type in detail and see how to use them. Note that the below examples are for decoder-only Tranformer-based models. We also support [\"Model-Specific Cache\"] classes for models such as Mamba or Jamba, keep reading for more details.\n \n ### Quantized Cache\n \n@@ -120,6 +120,8 @@ To enable quantization of the key-value cache, one needs to indicate `cache_impl\n Quantization related arguments should be passed to the `generation_config` either as a `dict` or an instance of a [`~QuantizedCacheConfig`] class.\n One has to indicate which quantization backend to use in the [`~QuantizedCacheConfig`], the default is `quanto`.\n \n+It is recommended to set `axis-key/axis-value` parameters in the cache config to `0` if you're using the `quanto` backend and to `1` if you're using the `HQQ` backend. For other config values, please use the defaults unless you're running out of memory. In that case, you may consider decreasing the residual length. \n+\n <Tip warning={true}>\n \n Cache quantization can be detrimental in terms of latency if the context length is short and there is enough GPU VRAM available to run without cache quantization. It is recommended to seek balance between memory efficiency and latency.\n@@ -143,7 +145,7 @@ I like rock music because it's loud and energetic. It's a great way to express m\n I like rock music because it's loud and energetic. I like to listen to it when I'm feeling\n ```\n \n-## Offloaded Cache\n+### Offloaded Cache\n \n Similarly to KV cache quantization, [`~OffloadedCache`] strategy aims to reduce GPU VRAM usage.\n It does so by moving the KV cache for most layers to the CPU.\n@@ -223,7 +225,7 @@ before successfully generating 40 beams.\n Since the \"DynamicCache\" dynamically grows with each generation step, it prevents you from taking advantage of JIT optimizations. The [`~StaticCache`] pre-allocates \n a specific maximum size for the keys and values, allowing you to generate up to the maximum length without having to modify cache size. Check the below usage example.\n \n-For more examples with Static Cache and JIT compilation, take a look at [StaticCache & torchcompile](./llm_optims.md#static-kv-cache-and-torchcompile)\n+For more examples with Static Cache and JIT compilation, take a look at [StaticCache & torchcompile](./llm_optims#static-kv-cache-and-torchcompile)\n \n ```python\n >>> import torch\n@@ -306,21 +308,21 @@ Unlike other cache classes, this one can't be used directly by indicating a `cac\n \n ### Encoder-Decoder Cache\n \n-The [`~EncoderDecoderCache`] is a wrapper designed to handle the caching needs of encoder-decoder models. This cache type is specifically built to manage both self-attention and cross-attention caches, ensuring storage and retrieval of past key/values required for these complex models. Cool thing about Encoder-Decoder Cache is that you can set different cache types for the encoder and for the decoder, depending on your use case. Currently this cache is only supported in [Whisper](./model_doc/whisper.md) models but we will be adding more models soon. \n+The [`~EncoderDecoderCache`] is a wrapper designed to handle the caching needs of encoder-decoder models. This cache type is specifically built to manage both self-attention and cross-attention caches, ensuring storage and retrieval of past key/values required for these complex models. Cool thing about Encoder-Decoder Cache is that you can set different cache types for the encoder and for the decoder, depending on your use case. Currently this cache is only supported in [Whisper](./model_doc/whisper) models but we will be adding more models soon. \n \n In terms of usage, there is nothing special to be done and calling `generate()` or `forward()` will handle everything for you.\n \n \n ### Model-specific Cache Classes\n \n-Some models require storing previous keys, values, or states in a specific way, and the above cache classes cannot be used. For such cases, we have several specialized cache classes that are designed for specific models. These models only accept their own dedicated cache classes and do not support using any other cache types. Some examples include [`~HybridCache`] for [Gemma2](./model_doc/gemma2.md) series models or [`~MambaCache`] for [Mamba](./model_doc/mamba.md) architecture models.\n+Some models require storing previous keys, values, or states in a specific way, and the above cache classes cannot be used. For such cases, we have several specialized cache classes that are designed for specific models. These models only accept their own dedicated cache classes and do not support using any other cache types. Some examples include [`~HybridCache`] for [Gemma2](./model_doc/gemma2) series models or [`~MambaCache`] for [Mamba](./model_doc/mamba) architecture models.\n \n \n ## Iterative Generation with Cache\n \n We have seen how to use each of the cache types when generating. What if you want to use cache in iterative generation setting, for example in applications like chatbots, where interactions involve multiple turns and continuous back-and-forth exchanges. Iterative generation with cache allows these systems to handle ongoing conversations effectively without reprocessing the entire context at each step. But there are some tips that you should know before you start implementing:\n \n-The general format when doing iterative generation is as below. First you have to initialize an empty cache of the type you want, and you can start feeding in new prompts iteratively. Keeping track of dialogues history and formatting can be done with chat templates, read more on that in [chat_templating](./chat_templating.md)\n+The general format when doing iterative generation is as below. First you have to initialize an empty cache of the type you want, and you can start feeding in new prompts iteratively. Keeping track of dialogues history and formatting can be done with chat templates, read more on that in [chat_templating](./chat_templating)\n \n In case you are using Sink Cache, you have to crop your inputs to that maximum length because Sink Cache can generate text longer than its maximum window size, but it expects the first input to not exceed the maximum cache length.  \n \n@@ -366,4 +368,36 @@ print(messages)\n \n ## Re-use Cache to continue generation\n \n-Sometimes you would want to fist fill-in cache object with key/values for certain prefix prompt and re-use it several times to generate different sequences from it. We are working hard on adding this feature to ðŸ¤— Transformers and will update this section soon. \n+Sometimes you would want to first fill-in cache object with key/values for certain prefix prompt and re-use it several times to generate different sequences from it. In that case you can construct a `Cache` object that will hold the instruction prompt, and re-use it several times with different text sequences.\n+\n+```python\n+>>> import copy\n+>>> import torch\n+>>> from transformers import AutoModelForCausalLM, AutoTokenizer, DynamicCache, StaticCache\n+\n+>>> model_id = \"meta-llama/Llama-2-7b-chat-hf\"\n+>>> model = AutoModelForCausalLM.from_pretrained(model_id, torch_dtype=torch.bfloat16, device_map=\"cuda\")\n+>>> tokenizer = AutoTokenizer.from_pretrained(model_id)\n+\n+>>> # Init StaticCache with big enough max-length (1024 tokens for the below example) \n+>>> # You can also init a DynamicCache, if that suits you better\n+>>> prompt_cache = StaticCache(config=model.config, max_batch_size=1, max_cache_len=1024, device=\"cuda\", dtype=torch.bfloat16)\n+\n+>>> INITIAL_PROMPT = \"You are a helpful assistant. \"\n+>>> inputs_initial_prompt = tokenizer(INITIAL_PROMPT, return_tensors=\"pt\").to(\"cuda\")\n+>>> # This is the common prompt cached, we need to run forward without grad to be abel to copy\n+>>> with torch.no_grad():\n+...      prompt_cache = model(**inputs_initial_prompt, past_key_values = prompt_cache).past_key_values\n+\n+>>> prompts = [\"Help me to write a blogpost about travelling.\", \"What is the capital of France?\"]\n+>>> responses = []\n+>>> for prompt in prompts:\n+...     new_inputs = tokenizer(INITIAL_PROMPT + prompt, return_tensors=\"pt\").to(\"cuda\")\n+...     past_key_values = copy.deepcopy(prompt_cache)\n+...     outputs = model.generate(**new_inputs, past_key_values=past_key_values,max_new_tokens=20) \n+...     response = tokenizer.batch_decode(outputs)[0]\n+...     responses.append(response)\n+\n+>>> print(responses)\n+['<s> You are a helpful assistant. Help me to write a blogpost about travelling.\\n\\nTitle: The Ultimate Guide to Travelling: Tips, Tricks, and', '<s> You are a helpful assistant. What is the capital of France?\\n\\nYes, the capital of France is Paris.</s>']\n+```\n\\ No newline at end of file"
        },
        {
            "sha": "3c157018ecd214dc3073f597868bc5929e838955",
            "filename": "src/transformers/cache_utils.py",
            "status": "modified",
            "additions": 38,
            "deletions": 29,
            "changes": 67,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbe8d8014900e16876938c3e4a0d15c6f8acb67/src%2Ftransformers%2Fcache_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbe8d8014900e16876938c3e4a0d15c6f8acb67/src%2Ftransformers%2Fcache_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fcache_utils.py?ref=ebbe8d8014900e16876938c3e4a0d15c6f8acb67",
            "patch": "@@ -305,15 +305,16 @@ class DynamicCache(Cache):\n         ```python\n         >>> from transformers import AutoTokenizer, AutoModelForCausalLM, DynamicCache\n \n-        >>> model = AutoModelForCausalLM.from_pretrained(\"openai-community/gpt2\")\n-        >>> tokenizer = AutoTokenizer.from_pretrained(\"openai-community/gpt2\")\n+        >>> model = AutoModelForCausalLM.from_pretrained(\"Qwen/Qwen2-0.5B-Instruct\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"Qwen/Qwen2-0.5B-Instruct\")\n \n-        >>> inputs = tokenizer(text=\"My name is GPT2\", return_tensors=\"pt\")\n+        >>> inputs = tokenizer(text=\"My name is Qwen2\", return_tensors=\"pt\")\n \n         >>> # Prepare a cache class and pass it to model's forward\n         >>> past_key_values = DynamicCache()\n         >>> outputs = model(**inputs, past_key_values=past_key_values, use_cache=True)\n-        >>> past_kv_length = outputs.past_key_values # access cache filled with key/values from generation\n+        >>> outputs.past_key_values # access cache filled with key/values from generation\n+        DynamicCache()\n         ```\n     \"\"\"\n \n@@ -680,16 +681,17 @@ class QuantoQuantizedCache(QuantizedCache):\n         >>> # Run pip install quanto first if you don't have it yet\n         >>> from transformers import AutoTokenizer, AutoModelForCausalLM, QuantoQuantizedCache, QuantizedCacheConfig\n \n-        >>> model = AutoModelForCausalLM.from_pretrained(\"openai-community/gpt2\")\n-        >>> tokenizer = AutoTokenizer.from_pretrained(\"openai-community/gpt2\")\n+        >>> model = AutoModelForCausalLM.from_pretrained(\"Qwen/Qwen2-0.5B-Instruct\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"Qwen/Qwen2-0.5B-Instruct\")\n \n-        >>> inputs = tokenizer(text=\"My name is GPT2\", return_tensors=\"pt\")\n+        >>> inputs = tokenizer(text=\"My name is Qwen2\", return_tensors=\"pt\")\n \n         >>> # Prepare a cache class and pass it to model's forward\n         >>> cache_config = QuantizedCacheConfig(nbits=4)\n         >>> past_key_values = QuantoQuantizedCache(cache_config=cache_config)\n         >>> outputs = model(**inputs, past_key_values=past_key_values, use_cache=True)\n-        >>> past_kv_length = outputs.past_key_values # access cache filled with key/values from generation\n+        >>> outputs.past_key_values # access cache filled with key/values from generation\n+        QuantoQuantizedCache()\n         ```\n     \"\"\"\n \n@@ -739,16 +741,17 @@ class HQQQuantizedCache(QuantizedCache):\n         >>> # Run pip install hqq first if you don't have it yet\n         >>> from transformers import AutoTokenizer, AutoModelForCausalLM, HQQQuantizedCache, QuantizedCacheConfig\n \n-        >>> model = AutoModelForCausalLM.from_pretrained(\"openai-community/gpt2\")\n-        >>> tokenizer = AutoTokenizer.from_pretrained(\"openai-community/gpt2\")\n+        >>> model = AutoModelForCausalLM.from_pretrained(\"Qwen/Qwen2-0.5B-Instruct\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"Qwen/Qwen2-0.5B-Instruct\")\n \n-        >>> inputs = tokenizer(text=\"My name is GPT2\", return_tensors=\"pt\")\n+        >>> inputs = tokenizer(text=\"My name is Qwen2\", return_tensors=\"pt\")\n \n         >>> # Prepare a cache class and pass it to model's forward\n         >>> cache_config = QuantizedCacheConfig(nbits=4, axis_key=1, axis_value=1)\n         >>> past_key_values = HQQQuantizedCache(cache_config=cache_config)\n         >>> outputs = model(**inputs, past_key_values=past_key_values, use_cache=True)\n-        >>> past_kv_length = outputs.past_key_values # access cache filled with key/values from generation\n+        >>> outputs.past_key_values # access cache filled with key/values from generation\n+        HQQQuantizedCache()\n         ```\n     \"\"\"\n \n@@ -806,15 +809,16 @@ class SinkCache(Cache):\n         ```python\n         >>> from transformers import AutoTokenizer, AutoModelForCausalLM, SinkCache\n \n-        >>> model = AutoModelForCausalLM.from_pretrained(\"openai-community/gpt2\")\n-        >>> tokenizer = AutoTokenizer.from_pretrained(\"openai-community/gpt2\")\n+        >>> model = AutoModelForCausalLM.from_pretrained(\"Qwen/Qwen2-0.5B-Instruct\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"Qwen/Qwen2-0.5B-Instruct\")\n \n-        >>> inputs = tokenizer(text=\"My name is GPT2\", return_tensors=\"pt\")\n+        >>> inputs = tokenizer(text=\"My name is Qwen2\", return_tensors=\"pt\")\n \n         >>> # Prepare a cache class and pass it to model's forward\n         >>> past_key_values = SinkCache(window_length=256, num_sink_tokens=4)\n         >>> outputs = model(**inputs, past_key_values=past_key_values, use_cache=True)\n-        >>> past_kv_length = outputs.past_key_values # access cache filled with key/values from generation\n+        >>> outputs.past_key_values # access cache filled with key/values from generation\n+        SinkCache()\n         ```\n     \"\"\"\n \n@@ -992,17 +996,18 @@ class StaticCache(Cache):\n         ```python\n         >>> from transformers import AutoTokenizer, AutoModelForCausalLM, StaticCache\n \n-        >>> model = AutoModelForCausalLM.from_pretrained(\"openai-community/gpt2\")\n-        >>> tokenizer = AutoTokenizer.from_pretrained(\"openai-community/gpt2\")\n+        >>> model = AutoModelForCausalLM.from_pretrained(\"meta-llama/Llama-2-7b-chat-hf\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"meta-llama/Llama-2-7b-chat-hf\")\n \n-        >>> inputs = tokenizer(text=\"My name is GPT2\", return_tensors=\"pt\")\n+        >>> inputs = tokenizer(text=\"My name is Llama\", return_tensors=\"pt\")\n \n         >>> # Prepare a cache class and pass it to model's forward\n         >>> # Leave empty space for 10 new tokens, which can be used when calling forward iteratively 10 times to generate\n         >>> max_generated_length = inputs.input_ids.shape[1] + 10\n         >>> past_key_values = StaticCache(config=model.config, batch_size=1, max_cache_len=max_generated_length, device=model.device, dtype=model.dtype)\n         >>> outputs = model(**inputs, past_key_values=past_key_values, use_cache=True)\n-        >>> past_kv_length = outputs.past_key_values # access cache filled with key/values from generation\n+        >>> outputs.past_key_values # access cache filled with key/values from generation\n+        StaticCache()\n         ```\n     \"\"\"\n \n@@ -1161,17 +1166,18 @@ class SlidingWindowCache(StaticCache):\n         ```python\n         >>> from transformers import AutoTokenizer, AutoModelForCausalLM, SlidingWindowCache\n \n-        >>> model = AutoModelForCausalLM.from_pretrained(\"openai-community/gpt2\")\n-        >>> tokenizer = AutoTokenizer.from_pretrained(\"openai-community/gpt2\")\n+        >>> model = AutoModelForCausalLM.from_pretrained(\"mistralai/Mistral-7B-Instruct-v0.3\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"mistralai/Mistral-7B-Instruct-v0.3\")\n \n-        >>> inputs = tokenizer(text=\"My name is GPT2\", return_tensors=\"pt\")\n+        >>> inputs = tokenizer(text=\"My name is Mistral\", return_tensors=\"pt\")\n \n         >>> # Prepare a cache class and pass it to model's forward\n         >>> # Leave empty space for 10 new tokens, which can be used when calling forward iteratively 10 times to generate\n         >>> max_generated_length = inputs.input_ids.shape[1] + 10\n         >>> past_key_values = SlidingWindowCache(config=model.config, batch_size=1, max_cache_len=max_generated_length, device=model.device, dtype=model.dtype)\n         >>> outputs = model(**inputs, past_key_values=past_key_values, use_cache=True)\n-        >>> past_kv_length = outputs.past_key_values # access cache filled with key/values from generation\n+        >>> outputs.past_key_values # access cache filled with key/values from generation\n+        SlidingWindowCache()\n         ```\n     \"\"\"\n \n@@ -1281,7 +1287,8 @@ class EncoderDecoderCache(Cache):\n         >>> cross_attention_cache = DynamicCache()\n         >>> past_key_values = EncoderDecoderCache(self_attention_cache, cross_attention_cache)\n         >>> outputs = model(**inputs, past_key_values=past_key_values, use_cache=True)\n-        >>> past_kv_length = outputs.past_key_values # access cache filled with key/values from generation\n+        >>> outputs.past_key_values # access cache filled with key/values from generation\n+        EncoderDecoderCache()\n         ```\n \n     \"\"\"\n@@ -1453,8 +1460,8 @@ class HybridCache(Cache):\n         ```python\n         >>> from transformers import AutoTokenizer, AutoModelForCausalLM, HybridCache\n \n-        >>> model = AutoModelForCausalLM.from_pretrained(\"google/gemma-2-9b\")\n-        >>> tokenizer = AutoTokenizer.from_pretrained(\"google/gemma-2-9b\")\n+        >>> model = AutoModelForCausalLM.from_pretrained(\"google/gemma-2-2b\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"google/gemma-2-2b\")\n \n         >>> inputs = tokenizer(text=\"My name is Gemma\", return_tensors=\"pt\")\n \n@@ -1463,7 +1470,8 @@ class HybridCache(Cache):\n         >>> max_generated_length = inputs.input_ids.shape[1] + 10\n         >>> past_key_values = HybridCache(config=model.config, batch_size=1, max_cache_len=max_generated_length, device=model.device, dtype=model.dtype)\n         >>> outputs = model(**inputs, past_key_values=past_key_values, use_cache=True)\n-        >>> past_kv_length = outputs.past_key_values # access cache filled with key/values from generation\n+        >>> outputs.past_key_values # access cache filled with key/values from generation\n+        HybridCache()\n         ```\n     \"\"\"\n \n@@ -1645,7 +1653,8 @@ class MambaCache:\n         >>> # Prepare a cache class and pass it to model's forward\n         >>> past_key_values = MambaCache(config=model.config, batch_size=1, device=model.device, dtype=model.dtype)\n         >>> outputs = model(**inputs, past_key_values=past_key_values, use_cache=True)\n-        >>> past_kv = outputs.past_key_values\n+        >>> outputs.past_key_values\n+        MambaCache()\n         ```\n     \"\"\"\n "
        },
        {
            "sha": "fb5459be10cb858b152d35fa1813753d20f18928",
            "filename": "tests/utils/test_cache_utils.py",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/huggingface/transformers/blob/ebbe8d8014900e16876938c3e4a0d15c6f8acb67/tests%2Futils%2Ftest_cache_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ebbe8d8014900e16876938c3e4a0d15c6f8acb67/tests%2Futils%2Ftest_cache_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Futils%2Ftest_cache_utils.py?ref=ebbe8d8014900e16876938c3e4a0d15c6f8acb67",
            "patch": "@@ -13,6 +13,7 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n \n+import copy\n import unittest\n \n from packaging import version\n@@ -616,3 +617,34 @@ def test_offloaded_cache_uses_less_memory_than_dynamic_cache(self):\n         model.generate(generation_config=offloaded, **inputs)\n         offloaded_peak_memory = torch.cuda.max_memory_allocated(device)\n         assert offloaded_peak_memory < original_peak_memory\n+\n+    @require_torch_gpu\n+    def test_cache_copy(self):\n+        model_name = \"microsoft/Phi-3-mini-4k-instruct\"\n+        tokenizer = AutoTokenizer.from_pretrained(model_name)\n+        model = AutoModelForCausalLM.from_pretrained(model_name, device_map=\"cuda\", torch_dtype=torch.bfloat16)\n+\n+        prompt_cache = StaticCache(\n+            config=model.config, max_batch_size=1, max_cache_len=1024, device=\"cuda\", dtype=torch.bfloat16\n+        )\n+\n+        INITIAL_PROMPT = \"You are a helpful assistant. \"\n+        inputs_initial_prompt = tokenizer(INITIAL_PROMPT, return_tensors=\"pt\").to(\"cuda\")\n+        # This is the common prompt cached, we need to run forward without grad to be abel to copy\n+        with torch.no_grad():\n+            prompt_cache = model(**inputs_initial_prompt, past_key_values=prompt_cache).past_key_values\n+\n+        prompts = [\"Help me to write a blogpost about travelling.\", \"What is the capital of France?\"]\n+        responses = []\n+        for prompt in prompts:\n+            new_inputs = tokenizer(INITIAL_PROMPT + prompt, return_tensors=\"pt\").to(\"cuda\")\n+            past_key_values = copy.deepcopy(prompt_cache)\n+            outputs = model.generate(**new_inputs, past_key_values=past_key_values, max_new_tokens=40)\n+            response = tokenizer.batch_decode(outputs)[0]\n+            responses.append(response)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"You are a helpful assistant. Help me to write a blogpost about travelling.\\n\\nTraveling is an enriching experience that broadens our horizons and exposes us to new cultures, landscapes, and people. Whether it's a week\",\n+            'You are a helpful assistant. What is the capital of France?\\n\\n\\n## Response:Paris is the capital of France.\\n\\n\\n\\n\\n\\n## Query:\\n\\nIn a detailed analysis, compare the economic impacts of the introduction of the'\n+        ]  # fmt: skip\n+        self.assertTrue(responses == EXPECTED_DECODED_TEXT)"
        }
    ],
    "stats": {
        "total": 153,
        "additions": 114,
        "deletions": 39
    }
}