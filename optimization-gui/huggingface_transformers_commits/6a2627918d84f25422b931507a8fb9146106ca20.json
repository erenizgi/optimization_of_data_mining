{
    "author": "yonigozlan",
    "message": "Refactor Aya Vision with modular (#36688)\n\n* refactor aya_vision with modular (incorrect docstring)\n\n* Fix docstrings\n\n* Fix other modulars\n\n* fix docstring\n\n* revert changes\n\n* add tie_weights and resize_token_embeddings",
    "sha": "6a2627918d84f25422b931507a8fb9146106ca20",
    "files": [
        {
            "sha": "021898931aed978113eba362543d04a545ccc62d",
            "filename": "src/transformers/models/aya_vision/modeling_aya_vision.py",
            "status": "modified",
            "additions": 144,
            "deletions": 92,
            "changes": 236,
            "blob_url": "https://github.com/huggingface/transformers/blob/6a2627918d84f25422b931507a8fb9146106ca20/src%2Ftransformers%2Fmodels%2Faya_vision%2Fmodeling_aya_vision.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6a2627918d84f25422b931507a8fb9146106ca20/src%2Ftransformers%2Fmodels%2Faya_vision%2Fmodeling_aya_vision.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Faya_vision%2Fmodeling_aya_vision.py?ref=6a2627918d84f25422b931507a8fb9146106ca20",
            "patch": "@@ -1,3 +1,9 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/aya_vision/modular_aya_vision.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_aya_vision.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n # coding=utf-8\n # Copyright 2025 the Cohere Inc. team. All rights reserved.\n #\n@@ -12,13 +18,11 @@\n # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n # See the License for the specific language governing permissions and\n # limitations under the License.\n-\"\"\"PyTorch AyaVision model.\"\"\"\n \n from dataclasses import dataclass\n from typing import List, Optional, Tuple, Union\n \n import torch\n-import torch.utils.checkpoint\n from torch import nn\n \n from ...activations import ACT2FN\n@@ -29,59 +33,16 @@\n     add_start_docstrings,\n     add_start_docstrings_to_model_forward,\n     is_torchdynamo_compiling,\n-    logging,\n     replace_return_docstrings,\n )\n+from ...utils.deprecation import deprecate_kwarg\n from ..auto import AutoModel, AutoModelForCausalLM\n from .configuration_aya_vision import AyaVisionConfig\n \n \n-logger = logging.get_logger(__name__)\n-\n _CONFIG_FOR_DOC = \"AyaVisionConfig\"\n \n \n-# copied from transformers.models.Llava.modeling_llava.LlavaCausalLMOutputWithPast\n-@dataclass\n-class AyaVisionCausalLMOutputWithPast(ModelOutput):\n-    \"\"\"\n-    Base class for AyaVision causal language model (or autoregressive) outputs.\n-\n-    Args:\n-        loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n-            Language modeling loss (for next-token prediction).\n-        logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n-            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n-        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n-            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n-            `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n-\n-            Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n-            `past_key_values` input) to speed up sequential decoding.\n-        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n-            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n-            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n-\n-            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n-        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n-            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n-            sequence_length)`.\n-\n-            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n-            heads.\n-        image_hidden_states (`torch.FloatTensor`, *optional*):\n-            A `torch.FloatTensor` of size (batch_size * num_patches, num_images, sequence_length, hidden_size)`.\n-            image_hidden_states of the model produced by the vision encoder and after projecting the last hidden state.\n-    \"\"\"\n-\n-    loss: Optional[torch.FloatTensor] = None\n-    logits: torch.FloatTensor = None\n-    past_key_values: Optional[List[torch.FloatTensor]] = None\n-    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n-    attentions: Optional[Tuple[torch.FloatTensor]] = None\n-    image_hidden_states: Optional[torch.FloatTensor] = None\n-\n-\n class AyaVisionMultiModalProjector(nn.Module):\n     def __init__(self, config: AyaVisionConfig):\n         super().__init__()\n@@ -162,10 +123,13 @@ class AyaVisionPreTrainedModel(PreTrainedModel):\n     _supports_cache_class = True\n     _supports_flash_attn_2 = True\n     _supports_sdpa = True\n+    _supports_quantized_cache = False\n+    _supports_static_cache = False\n \n     def _init_weights(self, module):\n         # important: this ported version of AyaVision isn't meant for training from scratch - only\n         # inference and fine-tuning - so the proper init weights code has been removed - the original codebase\n+        # https://github.com/haotian-liu/AyaVision/tree/main/aya_vision should serve for that purpose\n         std = (\n             self.config.initializer_range\n             if hasattr(self.config, \"initializer_range\")\n@@ -185,7 +149,47 @@ def _init_weights(self, module):\n                 module.weight.data[module.padding_idx].zero_()\n \n \n-AYA_VISION_INPUTS_DOCSTRING = r\"\"\"\n+@dataclass\n+class AyaVisionCausalLMOutputWithPast(ModelOutput):\n+    \"\"\"\n+    Base class for AyaVision causal language model (or autoregressive) outputs.\n+\n+    Args:\n+        loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+            Language modeling loss (for next-token prediction).\n+        logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n+            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+            `past_key_values` input) to speed up sequential decoding.\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        image_hidden_states (`torch.FloatTensor`, *optional*):\n+            A `torch.FloatTensor` of size (batch_size, num_images, sequence_length, hidden_size)`.\n+            image_hidden_states of the model produced by the vision encoder and after projecting the last hidden state.\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: torch.FloatTensor = None\n+    past_key_values: Optional[List[torch.FloatTensor]] = None\n+    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+    attentions: Optional[Tuple[torch.FloatTensor]] = None\n+    image_hidden_states: Optional[torch.FloatTensor] = None\n+\n+\n+AYA_VISION_INPUTS_DOCSTRING = \"\"\"\n     Args:\n         input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n             Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n@@ -197,7 +201,7 @@ def _init_weights(self, module):\n             [What are input IDs?](../glossary#input-ids)\n         pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)):\n             The tensors corresponding to the input images. Pixel values can be obtained using\n-            [`AutoImageProcessor`]. See [`GotOcr2ImageProcessor.__call__`] for details. [`CohereProcessor`] uses\n+            [`AutoImageProcessor`]. See [`GotOcr2ImageProcessor.__call__`] for details. [`AyaVisionProcessor`] uses\n             [`GotOcr2ImageProcessor`] for processing images.\n         attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n             Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n@@ -237,12 +241,13 @@ def _init_weights(self, module):\n             Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n             is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n             model's internal embedding lookup matrix.\n-        vision_feature_layer (`int`, *optional*, defaults to -2):\n-            The index of the layer to select the vision feature.\n+        vision_feature_layer (`Union[int, List[int]], *optional*, defaults to -2`):\n+            The index of the layer to select the vision feature. If multiple indices are provided,\n+            the vision feature of the corresponding indices will be concatenated to form the\n+            vision features.\n         vision_feature_select_strategy (`str`, *optional*, defaults to `\"default\"`):\n             The feature selection strategy used to select the vision feature from the vision backbone.\n-            Can be one of `\"default\"` or `\"full\"`. If `\"default\"`, the CLS token is removed from the vision features.\n-            If `\"full\"`, the full vision features are used.\n+            Can be one of `\"default\"` or `\"full\"`.\n         use_cache (`bool`, *optional*):\n             If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n             `past_key_values`).\n@@ -271,13 +276,14 @@ def __init__(self, config: AyaVisionConfig):\n         self.vision_tower = AutoModel.from_config(config.vision_config)\n \n         self.multi_modal_projector = AyaVisionMultiModalProjector(config)\n-\n         self.vocab_size = config.text_config.vocab_size\n         self.language_model = AutoModelForCausalLM.from_config(config.text_config)\n+\n         if self.language_model._tied_weights_keys is not None:\n-            self._tied_weights_keys = [f\"language_model.{key}\" for key in self.language_model._tied_weights_keys]\n+            self._tied_weights_keys = [f\"language_model.{k}\" for k in self.language_model._tied_weights_keys]\n \n         self.pad_token_id = self.config.pad_token_id if self.config.pad_token_id is not None else -1\n+\n         self.post_init()\n \n     def get_input_embeddings(self):\n@@ -298,48 +304,53 @@ def set_decoder(self, decoder):\n     def get_decoder(self):\n         return self.language_model.get_decoder()\n \n-    def tie_weights(self):\n-        return self.language_model.tie_weights()\n-\n-    def resize_token_embeddings(self, new_num_tokens: Optional[int] = None, pad_to_multiple_of=None) -> nn.Embedding:\n-        model_embeds = self.language_model.resize_token_embeddings(new_num_tokens, pad_to_multiple_of)\n-        # update vocab size\n-        self.config.text_config.vocab_size = model_embeds.num_embeddings\n-        self.vocab_size = model_embeds.num_embeddings\n-        return model_embeds\n-\n     def get_image_features(\n         self,\n         pixel_values: torch.FloatTensor,\n-        vision_feature_layer: int,\n+        vision_feature_layer: Union[int, List[int]],\n         vision_feature_select_strategy: str,\n+        **kwargs,\n     ):\n         \"\"\"\n         Obtains image last hidden states from the vision tower and apply multimodal projection.\n \n         Args:\n-            pixel_values (`torch.FloatTensor]` of shape `(batch_size, num_patches, channels, height, width)`)\n+            pixel_values (`torch.FloatTensor]` of shape `(batch_size, channels, height, width)`)\n                The tensors corresponding to the input images.\n-            vision_feature_layer (`int`):\n-                The index of the layer to select the vision feature.\n+            vision_feature_layer (`Union[int, List[int]]`):\n+                The index of the layer to select the vision feature. If multiple indices are provided,\n+                the vision feature of the corresponding indices will be concatenated to form the\n+                vision features.\n             vision_feature_select_strategy (`str`):\n                 The feature selection strategy used to select the vision feature from the vision backbone.\n                 Can be one of `\"default\"` or `\"full\"`\n         Returns:\n-            image_features (List[`torch.Tensor`]): List of image feature tensor, each contains all the visual feature of all patches\n-            and are of shape `(num_patches, image_length, embed_dim)`).\n+            image_features (`torch.Tensor`): Image feature tensor of shape `(num_images, image_length, embed_dim)`).\n         \"\"\"\n+        if vision_feature_select_strategy not in [\"default\", \"full\"]:\n+            raise ValueError(f\"Unexpected select feature strategy: {self.config.vision_feature_select_strategy}\")\n+\n+        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n+        # this is not memory efficient at all (output_hidden_states=True) will save all the hidden states.\n+        image_outputs = self.vision_tower(pixel_values, output_hidden_states=True, **kwargs)\n+\n+        # If we have one vision feature layer, return the corresponding hidden states,\n+        # otherwise, select the hidden states of each feature layer and concatenate them\n+        if isinstance(vision_feature_layer, int):\n+            selected_image_feature = image_outputs.hidden_states[vision_feature_layer]\n+            if vision_feature_select_strategy == \"default\":\n+                selected_image_feature = selected_image_feature[:, 1:]\n+        else:\n+            hs_pool = [image_outputs.hidden_states[layer_idx] for layer_idx in vision_feature_layer]\n+            # For default; crop CLS from each hidden state in the hidden state pool\n+            if vision_feature_select_strategy == \"default\":\n+                hs_pool = [hs[:, 1:] for hs in hs_pool]\n+            selected_image_feature = torch.cat(hs_pool, dim=-1)\n \n-        image_features = self.vision_tower(pixel_values, output_hidden_states=True)\n-        selected_image_feature = image_features.hidden_states[vision_feature_layer]\n-        if vision_feature_select_strategy == \"default\":\n-            selected_image_feature = selected_image_feature[:, 1:]\n-        elif vision_feature_select_strategy == \"full\":\n-            selected_image_feature = selected_image_feature\n         image_features = self.multi_modal_projector(selected_image_feature)\n-\n         return image_features\n \n+    @deprecate_kwarg(\"num_logits_to_keep\", version=\"4.50\", new_name=\"logits_to_keep\")\n     @add_start_docstrings_to_model_forward(AYA_VISION_INPUTS_DOCSTRING)\n     @replace_return_docstrings(output_type=AyaVisionCausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC)\n     def forward(\n@@ -350,32 +361,64 @@ def forward(\n         position_ids: Optional[torch.LongTensor] = None,\n         past_key_values: Optional[List[torch.FloatTensor]] = None,\n         inputs_embeds: Optional[torch.FloatTensor] = None,\n-        vision_feature_layer: Optional[int] = None,\n+        vision_feature_layer: Optional[Union[int, List[int]]] = None,\n         vision_feature_select_strategy: Optional[str] = None,\n         labels: Optional[torch.LongTensor] = None,\n         use_cache: Optional[bool] = None,\n         output_attentions: Optional[bool] = None,\n         output_hidden_states: Optional[bool] = None,\n         return_dict: Optional[bool] = None,\n         cache_position: Optional[torch.LongTensor] = None,\n-        last_cache_position: int = 0,\n-        num_logits_to_keep: int = 0,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        image_sizes: torch.Tensor = None,\n         **lm_kwargs,\n     ) -> Union[Tuple, AyaVisionCausalLMOutputWithPast]:\n         r\"\"\"\n-        Args:\n             labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n                 Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n                 config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n                 (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n \n-            num_logits_to_keep (`int`, *optional*):\n-                Calculate logits for the last `num_logits_to_keep` tokens. If `0`, calculate logits for all\n+            logits_to_keep (`int` or `torch.Tensor`, *optional*):\n+                If an `int`, compute logits for the last `logits_to_keep` tokens. If `0`, calculate logits for all\n                 `input_ids` (special case). Only last token logits are needed for generation, and calculating them only for that\n                 token can save memory, which becomes pretty significant for long sequences or large vocabulary size.\n+                If a `torch.Tensor`, must be 1D corresponding to the indices to keep in the sequence length dimension.\n+                This is useful when using packed tensor format (single dimension for batch and sequence length).\n \n-            Returns:\n-        \"\"\"\n+\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoProcessor, AyaVisionForConditionalGeneration\n+        >>> import torch\n+\n+        >>> torch_device = \"cuda:0\"\n+        >>> processor = AutoProcessor.from_pretrained(\"CohereForAI/aya-vision-8b\", use_fast=True)\n+        >>> model = AyaVisionForConditionalGeneration.from_pretrained(\"CohereForAI/aya-vision-8b\", device_map=torch_device)\n+\n+        >>> messages = [\n+        ...     {\n+        ...         \"role\": \"user\",\n+        ...         \"content\": [\n+        ...             {\n+        ...                 \"type\": \"image\",\n+        ...                 \"url\": \"https://pbs.twimg.com/media/Fx7YvfQWYAIp6rZ?format=jpg&name=medium\",\n+        ...             },\n+        ...             {\"type\": \"text\", \"text\": \"à¤šà¤¿à¤¤à¥à¤° à¤®à¥‡à¤‚ à¤²à¤¿à¤–à¤¾ à¤ªà¤¾à¤  à¤•à¥à¤¯à¤¾ à¤•à¤¹à¤¤à¤¾ à¤¹à¥ˆ?\"},\n+        ...         ],\n+        ...     }\n+        ... ]\n+\n+        >>> inputs = processor.apply_chat_template(\n+        ...     messages, padding=True, add_generation_prompt=True, tokenize=True, return_dict=True, return_tensors=\"pt\", device=torch_device\n+        ... ).to(model.device)\n+\n+        >>> gen_tokens = model.generate(**inputs, max_new_tokens=300, do_sample=True, temperature=0.3)\n+        >>> processor.tokenizer.decode(gen_tokens[0][inputs.input_ids.shape[1]:], skip_special_tokens=True)\n+        ```\"\"\"\n \n         output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n         output_hidden_states = (\n@@ -407,6 +450,7 @@ def forward(\n                 pixel_values=pixel_values,\n                 vision_feature_layer=vision_feature_layer,\n                 vision_feature_select_strategy=vision_feature_select_strategy,\n+                image_sizes=image_sizes,\n             )\n \n             special_image_mask = (input_ids == self.config.image_token_index).unsqueeze(-1)\n@@ -430,9 +474,7 @@ def forward(\n             output_hidden_states=output_hidden_states,\n             return_dict=return_dict,\n             cache_position=cache_position,\n-            last_cache_position=last_cache_position,\n-            num_logits_to_keep=num_logits_to_keep,\n-            logits_to_keep=0,\n+            logits_to_keep=logits_to_keep,\n             **lm_kwargs,\n         )\n \n@@ -477,7 +519,7 @@ def prepare_inputs_for_generation(\n         pixel_values=None,\n         attention_mask=None,\n         cache_position=None,\n-        num_logits_to_keep=None,\n+        logits_to_keep=None,\n         **kwargs,\n     ):\n         # Overwritten -- in specific circumstances we don't want to forward image inputs to the model\n@@ -488,16 +530,26 @@ def prepare_inputs_for_generation(\n             inputs_embeds=inputs_embeds,\n             attention_mask=attention_mask,\n             cache_position=cache_position,\n-            num_logits_to_keep=num_logits_to_keep,\n+            logits_to_keep=logits_to_keep,\n             **kwargs,\n         )\n \n-        # If we're in cached decoding stage, pixel values should be None because input ids do not contain special image token anymore\n-        # Otherwise we need pixel values to be passed to model\n         if cache_position[0] == 0:\n+            # If we're in cached decoding stage, pixel values should be None because input ids do not contain special image token anymore\n+            # Otherwise we need pixel values to be passed to model\n             model_inputs[\"pixel_values\"] = pixel_values\n \n         return model_inputs\n \n+    def tie_weights(self):\n+        return self.language_model.tie_weights()\n+\n+    def resize_token_embeddings(self, new_num_tokens: Optional[int] = None, pad_to_multiple_of=None) -> nn.Embedding:\n+        model_embeds = self.language_model.resize_token_embeddings(new_num_tokens, pad_to_multiple_of)\n+        # update vocab size\n+        self.config.text_config.vocab_size = model_embeds.num_embeddings\n+        self.vocab_size = model_embeds.num_embeddings\n+        return model_embeds\n+\n \n __all__ = [\"AyaVisionForConditionalGeneration\", \"AyaVisionPreTrainedModel\"]"
        },
        {
            "sha": "b39c6e0803ead8a96bdbebb74d4f3a7552e270c8",
            "filename": "src/transformers/models/aya_vision/modular_aya_vision.py",
            "status": "added",
            "additions": 300,
            "deletions": 0,
            "changes": 300,
            "blob_url": "https://github.com/huggingface/transformers/blob/6a2627918d84f25422b931507a8fb9146106ca20/src%2Ftransformers%2Fmodels%2Faya_vision%2Fmodular_aya_vision.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6a2627918d84f25422b931507a8fb9146106ca20/src%2Ftransformers%2Fmodels%2Faya_vision%2Fmodular_aya_vision.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Faya_vision%2Fmodular_aya_vision.py?ref=6a2627918d84f25422b931507a8fb9146106ca20",
            "patch": "@@ -0,0 +1,300 @@\n+# coding=utf-8\n+# Copyright 2025 the Cohere Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch AyaVision model.\"\"\"\n+\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+from torch import nn\n+\n+from transformers.models.llava.modeling_llava import (\n+    LlavaCausalLMOutputWithPast,\n+    LlavaForConditionalGeneration,\n+    LlavaPreTrainedModel,\n+)\n+\n+from ...activations import ACT2FN\n+from ...utils import (\n+    add_start_docstrings,\n+    logging,\n+)\n+from .configuration_aya_vision import AyaVisionConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+_CONFIG_FOR_DOC = \"AyaVisionConfig\"\n+\n+\n+class AyaVisionMultiModalProjector(nn.Module):\n+    def __init__(self, config: AyaVisionConfig):\n+        super().__init__()\n+        self.config = config\n+        self.downsample_factor = config.downsample_factor\n+        self.alignment_intermediate_size = getattr(\n+            config, \"alignment_intermediate_size\", config.text_config.hidden_size\n+        )\n+        self.layernorm = nn.LayerNorm(\n+            config.vision_config.hidden_size * (config.downsample_factor**2), eps=config.adapter_layer_norm_eps\n+        )\n+\n+        self.linear_1 = nn.Linear(\n+            config.vision_config.hidden_size * (config.downsample_factor**2),\n+            self.alignment_intermediate_size,\n+            bias=True,\n+        )\n+\n+        self.act = ACT2FN[\"silu\"]  # SwiGLU uses SiLU activation\n+        # For SwiGLU, project down to half size since we split intermediate dim\n+        self.linear_2 = nn.Linear(self.alignment_intermediate_size // 2, config.text_config.hidden_size, bias=True)\n+\n+    def forward(self, image_features):\n+        image_features = self.pixel_shuffle(image_features)\n+        image_features = self.layernorm(image_features)\n+        hidden_states = self.linear_1(image_features)\n+\n+        # Split along last dimension and apply SwiGLU\n+        x, gate = hidden_states.chunk(2, dim=-1)\n+        hidden_states = self.act(gate) * x\n+\n+        hidden_states = self.linear_2(hidden_states)\n+        return hidden_states\n+\n+    def pixel_shuffle(self, image_features):  # B, S, D\n+        batch_size, seq_length, feature_dim = image_features.shape\n+        height = width = int(seq_length**0.5)\n+        image_features = image_features.reshape(image_features.shape[0], width, height, -1)\n+        channels = image_features.shape[-1]\n+        image_features = image_features.reshape(\n+            batch_size, width, int(height / self.downsample_factor), int(channels * self.downsample_factor)\n+        )\n+        image_features = image_features.permute(0, 2, 1, 3)\n+        image_features = image_features.reshape(\n+            batch_size, int(height / self.downsample_factor), int(width / self.downsample_factor), -1\n+        )\n+        image_features = image_features.permute(0, 2, 1, 3)\n+        return image_features\n+\n+\n+AYA_VISION_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`AyaVisionConfig`] or [`AyaVisionVisionConfig`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare Aya Vision Model outputting raw hidden-states without any specific head on top.\",\n+    AYA_VISION_START_DOCSTRING,\n+)\n+class AyaVisionPreTrainedModel(LlavaPreTrainedModel):\n+    _supports_quantized_cache = False\n+    _supports_static_cache = False\n+\n+\n+class AyaVisionCausalLMOutputWithPast(LlavaCausalLMOutputWithPast):\n+    pass\n+\n+\n+AYA_VISION_INPUTS_DOCSTRING = \"\"\"\n+    Args:\n+        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+            it.\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            [What are input IDs?](../glossary#input-ids)\n+        pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)):\n+            The tensors corresponding to the input images. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`GotOcr2ImageProcessor.__call__`] for details. [`AyaVisionProcessor`] uses\n+            [`GotOcr2ImageProcessor`] for processing images.\n+        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+            - 1 for tokens that are **not masked**,\n+            - 0 for tokens that are **masked**.\n+\n+            [What are attention masks?](../glossary#attention-mask)\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            If `past_key_values` is used, optionally only the last `decoder_input_ids` have to be input (see\n+            `past_key_values`).\n+\n+            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n+            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n+            information on the default strategy.\n+\n+            - 1 indicates the head is **not masked**,\n+            - 0 indicates the head is **masked**.\n+        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n+            config.n_positions - 1]`. [What are position IDs?](../glossary#position-ids)\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`) and 2 additional tensors of shape\n+            `(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`.\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n+            blocks) that can be used (see `past_key_values` input) to speed up sequential decoding.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n+            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n+            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n+        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n+            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n+            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n+            model's internal embedding lookup matrix.\n+        vision_feature_layer (`Union[int, List[int]], *optional*, defaults to -2`):\n+            The index of the layer to select the vision feature. If multiple indices are provided,\n+            the vision feature of the corresponding indices will be concatenated to form the\n+            vision features.\n+        vision_feature_select_strategy (`str`, *optional*, defaults to `\"default\"`):\n+            The feature selection strategy used to select the vision feature from the vision backbone.\n+            Can be one of `\"default\"` or `\"full\"`.\n+        use_cache (`bool`, *optional*):\n+            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n+            `past_key_values`).\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+        cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n+            Indices depicting the position of the input sequence tokens in the sequence. Contrarily to `position_ids`,\n+            this tensor is not affected by padding. It is used to update the cache in the correct position and to infer\n+            the complete sequence length.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"\"\"The AyaVision model which consists of a vision backbone and a language model.\"\"\",\n+    AYA_VISION_START_DOCSTRING,\n+)\n+class AyaVisionForConditionalGeneration(LlavaForConditionalGeneration):\n+    def tie_weights(self):\n+        return self.language_model.tie_weights()\n+\n+    def resize_token_embeddings(self, new_num_tokens: Optional[int] = None, pad_to_multiple_of=None) -> nn.Embedding:\n+        model_embeds = self.language_model.resize_token_embeddings(new_num_tokens, pad_to_multiple_of)\n+        # update vocab size\n+        self.config.text_config.vocab_size = model_embeds.num_embeddings\n+        self.vocab_size = model_embeds.num_embeddings\n+        return model_embeds\n+\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        pixel_values: torch.FloatTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        vision_feature_layer: Optional[Union[int, List[int]]] = None,\n+        vision_feature_select_strategy: Optional[str] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        image_sizes: torch.Tensor = None,\n+        **lm_kwargs,\n+    ) -> Union[Tuple, AyaVisionCausalLMOutputWithPast]:\n+        r\"\"\"\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+            logits_to_keep (`int` or `torch.Tensor`, *optional*):\n+                If an `int`, compute logits for the last `logits_to_keep` tokens. If `0`, calculate logits for all\n+                `input_ids` (special case). Only last token logits are needed for generation, and calculating them only for that\n+                token can save memory, which becomes pretty significant for long sequences or large vocabulary size.\n+                If a `torch.Tensor`, must be 1D corresponding to the indices to keep in the sequence length dimension.\n+                This is useful when using packed tensor format (single dimension for batch and sequence length).\n+\n+\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoProcessor, AyaVisionForConditionalGeneration\n+        >>> import torch\n+\n+        >>> torch_device = \"cuda:0\"\n+        >>> processor = AutoProcessor.from_pretrained(\"CohereForAI/aya-vision-8b\", use_fast=True)\n+        >>> model = AyaVisionForConditionalGeneration.from_pretrained(\"CohereForAI/aya-vision-8b\", device_map=torch_device)\n+\n+        >>> messages = [\n+        ...     {\n+        ...         \"role\": \"user\",\n+        ...         \"content\": [\n+        ...             {\n+        ...                 \"type\": \"image\",\n+        ...                 \"url\": \"https://pbs.twimg.com/media/Fx7YvfQWYAIp6rZ?format=jpg&name=medium\",\n+        ...             },\n+        ...             {\"type\": \"text\", \"text\": \"à¤šà¤¿à¤¤à¥à¤° à¤®à¥‡à¤‚ à¤²à¤¿à¤–à¤¾ à¤ªà¤¾à¤  à¤•à¥à¤¯à¤¾ à¤•à¤¹à¤¤à¤¾ à¤¹à¥ˆ?\"},\n+        ...         ],\n+        ...     }\n+        ... ]\n+\n+        >>> inputs = processor.apply_chat_template(\n+        ...     messages, padding=True, add_generation_prompt=True, tokenize=True, return_dict=True, return_tensors=\"pt\", device=torch_device\n+        ... ).to(model.device)\n+\n+        >>> gen_tokens = model.generate(**inputs, max_new_tokens=300, do_sample=True, temperature=0.3)\n+        >>> processor.tokenizer.decode(gen_tokens[0][inputs.input_ids.shape[1]:], skip_special_tokens=True)\n+        ```\"\"\"\n+        super().forward(\n+            input_ids=input_ids,\n+            pixel_values=pixel_values,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            vision_feature_layer=vision_feature_layer,\n+            vision_feature_select_strategy=vision_feature_select_strategy,\n+            labels=labels,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+            cache_position=cache_position,\n+            logits_to_keep=logits_to_keep,\n+            image_sizes=image_sizes,\n+            **lm_kwargs,\n+        )\n+\n+\n+__all__ = [\"AyaVisionForConditionalGeneration\", \"AyaVisionPreTrainedModel\"]"
        },
        {
            "sha": "20837000a83a92062a76fbd8eea10fbce8d8c987",
            "filename": "src/transformers/models/aya_vision/processing_aya_vision.py",
            "status": "modified",
            "additions": 0,
            "deletions": 12,
            "changes": 12,
            "blob_url": "https://github.com/huggingface/transformers/blob/6a2627918d84f25422b931507a8fb9146106ca20/src%2Ftransformers%2Fmodels%2Faya_vision%2Fprocessing_aya_vision.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6a2627918d84f25422b931507a8fb9146106ca20/src%2Ftransformers%2Fmodels%2Faya_vision%2Fprocessing_aya_vision.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Faya_vision%2Fprocessing_aya_vision.py?ref=6a2627918d84f25422b931507a8fb9146106ca20",
            "patch": "@@ -64,8 +64,6 @@ class AyaVisionProcessor(ProcessorMixin):\n             The size of image patches for tokenization.\n         img_size (`int`, *optional*, defaults to 364):\n             The size of the image to be tokenized. This should correspond to the size given to the image processor.\n-        vision_feature_select_strategy (`str`, *optional*, defaults to `\"full\"`):\n-            The feature selection strategy used to select the vision feature from the vision backbone.\n         image_token (`str`, *optional*, defaults to `\"<image>\"`):\n             The token to be used to represent an image in the text.\n         downsample_factor (`int`, *optional*, defaults to 1):\n@@ -93,7 +91,6 @@ class AyaVisionProcessor(ProcessorMixin):\n         \"patch_size\",\n         \"img_size\",\n         \"downsample_factor\",\n-        \"vision_feature_select_strategy\",\n         \"start_of_img_token\",\n         \"end_of_img_token\",\n         \"img_patch_token\",\n@@ -110,7 +107,6 @@ def __init__(\n         tokenizer=None,\n         patch_size: int = 28,\n         img_size: int = 364,\n-        vision_feature_select_strategy=\"full\",\n         image_token=\"<image>\",  # set the default and let users change if they have peculiar special tokens in rare cases\n         downsample_factor: int = 1,\n         start_of_img_token=\"<|START_OF_IMG|>\",\n@@ -127,7 +123,6 @@ def __init__(\n         self.image_token = image_token\n         self.patch_size = patch_size * downsample_factor\n         self.img_size = img_size\n-        self.vision_feature_select_strategy = vision_feature_select_strategy\n \n         self.start_of_img_token = start_of_img_token\n         self.end_of_img_token = end_of_img_token\n@@ -214,22 +209,15 @@ def __call__(\n             image_inputs = self.image_processor(images=images, **output_kwargs[\"images_kwargs\"])\n             num_patches = image_inputs.pop(\"num_patches\")\n             image_index = 0\n-            img_start_idx = 0\n             processed_text = []\n-            image_num_patches = []\n             for prompt in text:\n                 new_prompt = prompt\n-                curr_num_image_patches = 0\n                 while \"<image>\" in new_prompt:\n                     # Replace the image placeholder with structured image tokens\n                     image_tokens = self._prompt_split_image(num_patches[image_index])\n                     new_prompt = new_prompt.replace(\"<image>\", image_tokens, 1)\n-                    curr_num_image_patches += num_patches[image_index]\n                     image_index += 1\n-\n                 processed_text.append(new_prompt)\n-                image_num_patches.append(curr_num_image_patches.item())\n-                img_start_idx += curr_num_image_patches\n \n             if image_index != len(images):\n                 raise ValueError(\"Number of image placeholders in the prompt does not match the number of images.\")"
        }
    ],
    "stats": {
        "total": 548,
        "additions": 444,
        "deletions": 104
    }
}