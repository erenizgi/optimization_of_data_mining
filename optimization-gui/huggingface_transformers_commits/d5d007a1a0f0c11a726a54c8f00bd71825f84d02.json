{
    "author": "souvikchand",
    "message": "Updated Albert model Card (#37753)\n\n* Updated Albert model Card\n\n* Update docs/source/en/model_doc/albert.md\r\n\r\nadded the quotes in <hfoption id=\"Pipeline\">\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/albert.md\r\n\r\nupdated checkpoints\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/albert.md\r\n\r\nchanged !Tips description\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/albert.md\r\n\r\nupdated text\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/albert.md\r\n\r\nupdated transformer-cli implementation\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/albert.md\n\nchanged text\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/albert.md\n\nremoved repeated description\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update albert.md\n\nremoved lines\n\n* Update albert.md\n\nupdated pipeline code\n\n* Update albert.md\n\nupdated auto model code, removed quantization as model size is not large, removed the attention visualizer part\n\n* Update docs/source/en/model_doc/albert.md\r\n\r\nupdated notes\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update albert.md\n\nreduced a  repeating point in notes\n\n* Update docs/source/en/model_doc/albert.md\r\n\r\nupdated transformer-CLI\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/albert.md\r\n\r\nremoved extra notes\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n---------\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>",
    "sha": "d5d007a1a0f0c11a726a54c8f00bd71825f84d02",
    "files": [
        {
            "sha": "b56fca55b28d033d6b93f7416dc3fbd1e3dba24c",
            "filename": "docs/source/en/model_doc/albert.md",
            "status": "modified",
            "additions": 77,
            "deletions": 77,
            "changes": 154,
            "blob_url": "https://github.com/huggingface/transformers/blob/d5d007a1a0f0c11a726a54c8f00bd71825f84d02/docs%2Fsource%2Fen%2Fmodel_doc%2Falbert.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/d5d007a1a0f0c11a726a54c8f00bd71825f84d02/docs%2Fsource%2Fen%2Fmodel_doc%2Falbert.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Falbert.md?ref=d5d007a1a0f0c11a726a54c8f00bd71825f84d02",
            "patch": "@@ -14,100 +14,100 @@ rendered properly in your Markdown viewer.\n \n -->\n \n+<div style=\"float: right;\">\n+    <div class=\"flex flex-wrap space-x-1\">\n+        <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\" >\n+        <img alt= \"TensorFlow\" src= \"https://img.shields.io/badge/TensorFlow-FF6F00?style=flat&logo=tensorflow&logoColor=white\" >\n+        <img alt= \"Flax\" src=\"https://img.shields.io/badge/Flax-29a79b.svg?styleâ€¦Nu+W0m6K/I9gGPd/dfx/EN/wN62AhsBWuAAAAAElFTkSuQmCC\">\n+        <img alt=\"SDPA\" src= \"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\" > \n+    </div>\n+</div>\n+\n # ALBERT\n \n-<div class=\"flex flex-wrap space-x-1\">\n-<img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n-<img alt=\"TensorFlow\" src=\"https://img.shields.io/badge/TensorFlow-FF6F00?style=flat&logo=tensorflow&logoColor=white\">\n-<img alt=\"Flax\" src=\"https://img.shields.io/badge/Flax-29a79b.svg?style=flat&logo=data:image/png;base64,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\n-\">\n-<img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n-</div>\n+[ALBERT](https://huggingface.co/papers/1909.11942) is designed to address memory limitations of scaling and training of [BERT](./bert). It adds two parameter reduction techniques. The first, factorized embedding parametrization, splits the larger vocabulary embedding matrix into two smaller matrices so you can grow the hidden size without adding a lot more parameters. The second, cross-layer parameter sharing, allows layer to share parameters which keeps the number of learnable parameters lower.\n+\n+<<<<<<< HEAD\n+=======\n+\n+<<<<<<< HEAD\n+ALBERT was created to address problems like -- GPU/TPU memory limitations, longer training times, and unexpected model degradation in BERT. ALBERT uses two parameter-reduction techniques to lower memory consumption and increase the training speed of BERT:\n+\n+- **Factorized embedding parameterization:** The large vocabulary embedding matrix is decomposed into two smaller matrices, reducing memory consumption.\n+- **Cross-layer parameter sharing:** Instead of learning separate parameters for each transformer layer, ALBERT shares parameters across layers, further reducing the number of learnable weights.\n+\n+ALBERT uses absolute position embeddings (like BERT) so padding is applied at right. Size of embeddings is 128 While BERT uses 768. ALBERT can processes maximum 512 token at a time. \n+>>>>>>> 7ba1110083 (Update docs/source/en/model_doc/albert.md\r)\n \n-## Overview\n+=======\n+>>>>>>> 155b733538 (Update albert.md)\n+You can find all the original ALBERT checkpoints under the [ALBERT community](https://huggingface.co/albert) organization.\n \n-The ALBERT model was proposed in [ALBERT: A Lite BERT for Self-supervised Learning of Language Representations](https://huggingface.co/papers/1909.11942) by Zhenzhong Lan, Mingda Chen, Sebastian Goodman, Kevin Gimpel, Piyush Sharma,\n-Radu Soricut. It presents two parameter-reduction techniques to lower memory consumption and increase the training\n-speed of BERT:\n+> [!TIP]\n+> Click on the ALBERT models in the right sidebar for more examples of how to apply ALBERT to different language tasks.\n \n-- Splitting the embedding matrix into two smaller matrices.\n-- Using repeating layers split among groups.\n+The example below demonstrates how to predict the `[MASK]` token with [`Pipeline`], [`AutoModel`], and from the command line.\n \n-The abstract from the paper is the following:\n+<hfoptions id=\"usage\">\n+<hfoption id=\"Pipeline\">\n \n-*Increasing model size when pretraining natural language representations often results in improved performance on\n-downstream tasks. However, at some point further model increases become harder due to GPU/TPU memory limitations,\n-longer training times, and unexpected model degradation. To address these problems, we present two parameter-reduction\n-techniques to lower memory consumption and increase the training speed of BERT. Comprehensive empirical evidence shows\n-that our proposed methods lead to models that scale much better compared to the original BERT. We also use a\n-self-supervised loss that focuses on modeling inter-sentence coherence, and show it consistently helps downstream tasks\n-with multi-sentence inputs. As a result, our best model establishes new state-of-the-art results on the GLUE, RACE, and\n-SQuAD benchmarks while having fewer parameters compared to BERT-large.*\n+```py \n+import torch\n+from transformers import pipeline\n \n-This model was contributed by [lysandre](https://huggingface.co/lysandre). This model jax version was contributed by\n-[kamalkraj](https://huggingface.co/kamalkraj). The original code can be found [here](https://github.com/google-research/ALBERT).\n+pipeline = pipeline(\n+    task=\"fill-mask\",\n+    model=\"albert-base-v2\",\n+    torch_dtype=torch.float16,\n+    device=0\n+)\n+pipeline(\"Plants create [MASK] through a process known as photosynthesis.\", top_k=5)\n+```\n \n-## Usage tips\n+</hfoption>\n+<hfoption id=\"AutoModel\">\n \n-- ALBERT is a model with absolute position embeddings so it's usually advised to pad the inputs on the right rather\n-  than the left.\n-- ALBERT uses repeating layers which results in a small memory footprint, however the computational cost remains\n-  similar to a BERT-like architecture with the same number of hidden layers as it has to iterate through the same\n-  number of (repeating) layers.\n-- Embedding size E is different from hidden size H justified because the embeddings are context independent (one embedding vector represents one token), whereas hidden states are context dependent (one hidden state represents a sequence of tokens) so it's more logical to have H >> E. Also, the embedding matrix is large since it's V x E (V being the vocab size). If E < H, it has less parameters.\n-- Layers are split in groups that share parameters (to save memory).\n-Next sentence prediction is replaced by a sentence ordering prediction: in the inputs, we have two sentences A and B (that are consecutive) and we either feed A followed by B or B followed by A. The model must predict if they have been swapped or not.\n-- The `head_mask` argument is ignored when using all attention implementation other than \"eager\". If you have a `head_mask` and want it to have effect, load the model with `XXXModel.from_pretrained(model_id, attn_implementation=\"eager\")`  \n+```py\n+import torch\n+from transformers import AutoModelForMaskedLM, AutoTokenizer\n \n-### Using Scaled Dot Product Attention (SDPA)\n+tokenizer = AutoTokenizer.from_pretrained(\"albert/albert-base-v2\")\n+model = AutoModelForMaskedLM.from_pretrained(\n+    \"albert/albert-base-v2\",\n+    torch_dtype=torch.float16,\n+    attn_implementation=\"sdpa\",\n+    device_map=\"auto\"\n+)\n \n-PyTorch includes a native scaled dot-product attention (SDPA) operator as part of `torch.nn.functional`. This function \n-encompasses several implementations that can be applied depending on the inputs and the hardware in use. See the \n-[official documentation](https://pytorch.org/docs/stable/generated/torch.nn.functional.scaled_dot_product_attention.html) \n-or the [GPU Inference](https://huggingface.co/docs/transformers/main/en/perf_infer_gpu_one#pytorch-scaled-dot-product-attention)\n-page for more information.\n+prompt = \"Plants create energy through a process known as [MASK].\"\n+inputs = tokenizer(prompt, return_tensors=\"pt\").to(model.device) \n \n-SDPA is used by default for `torch>=2.1.1` when an implementation is available, but you may also set \n-`attn_implementation=\"sdpa\"` in `from_pretrained()` to explicitly request SDPA to be used.\n+with torch.no_grad():\n+    outputs = model(**inputs)\n+    mask_token_index = torch.where(inputs[\"input_ids\"] == tokenizer.mask_token_id)[1]\n+    predictions = outputs.logits[0, mask_token_index]\n \n+top_k = torch.topk(predictions, k=5).indices.tolist()\n+for token_id in top_k[0]:\n+    print(f\"Prediction: {tokenizer.decode([token_id])}\")\n ```\n-from transformers import AlbertModel\n-model = AlbertModel.from_pretrained(\"albert/albert-base-v1\", torch_dtype=torch.float16, attn_implementation=\"sdpa\")\n-...\n+\n+</hfoption>\n+<hfoption id=\"transformers CLI\">\n+\n+```bash\n+echo -e \"Plants create [MASK] through a process known as photosynthesis.\" | transformers run --task fill-mask --model albert-base-v2 --device 0\n ```\n \n-For the best speedups, we recommend loading the model in half-precision (e.g. `torch.float16` or `torch.bfloat16`).\n-\n-On a local benchmark (GeForce RTX 2060-8GB, PyTorch 2.3.1, OS Ubuntu 20.04) with `float16`, we saw the \n-following speedups during training and inference.\n-\n-#### Training for 100 iterations\n-\n-|batch_size|seq_len|Time per batch (eager - s)| Time per batch (sdpa - s)| Speedup (%)| Eager peak mem (MB)| sdpa peak mem (MB)| Mem saving (%)|\n-|----------|-------|--------------------------|--------------------------|------------|--------------------|-------------------|---------------|\n-|2         |256    |0.028                     |0.024                     |14.388      |358.411             |321.088            |11.624         |\n-|2         |512    |0.049                     |0.041                     |17.681      |753.458             |602.660            |25.022         |\n-|4         |256    |0.044                     |0.039                     |12.246      |679.534             |602.660            |12.756         |\n-|4         |512    |0.090                     |0.076                     |18.472      |1434.820            |1134.140           |26.512         |\n-|8         |256    |0.081                     |0.072                     |12.664      |1283.825            |1134.140           |13.198         |\n-|8         |512    |0.170                     |0.143                     |18.957      |2820.398            |2219.695           |27.062         |\n-\n-#### Inference with 50 batches\n-\n-|batch_size|seq_len|Per token latency eager (ms)|Per token latency SDPA (ms)|Speedup (%) |Mem eager (MB)|Mem BT (MB)|Mem saved (%)|\n-|----------|-------|----------------------------|---------------------------|------------|--------------|-----------|-------------|\n-|4         |128    |0.083                       |0.071                      |16.967      |48.319        |48.45      |-0.268       |\n-|4         |256    |0.148                       |0.127                      |16.37       |63.4          |63.922     |-0.817       |\n-|4         |512    |0.31                        |0.247                      |25.473      |110.092       |94.343     |16.693       |\n-|8         |128    |0.137                       |0.124                      |11.102      |63.4          |63.66      |-0.409       |\n-|8         |256    |0.271                       |0.231                      |17.271      |91.202        |92.246     |-1.132       |\n-|8         |512    |0.602                       |0.48                       |25.47       |186.159       |152.564    |22.021       |\n-|16        |128    |0.252                       |0.224                      |12.506      |91.202        |91.722     |-0.567       |\n-|16        |256    |0.526                       |0.448                      |17.604      |148.378       |150.467    |-1.388       |\n-|16        |512    |1.203                       |0.96                       |25.365      |338.293       |271.102    |24.784       |\n-\n-This model was contributed by [lysandre](https://huggingface.co/lysandre). This model jax version was contributed by\n-[kamalkraj](https://huggingface.co/kamalkraj). The original code can be found [here](https://github.com/google-research/ALBERT).\n+</hfoption>\n+\n+</hfoptions>\n+\n+\n+## Notes\n+\n+- Inputs should be padded on the right because BERT uses absolute position embeddings.\n+- The embedding size `E` is different from the hidden size `H` because the embeddings are context independent (one embedding vector represents one token) and the hidden states are context dependent (one hidden state represents a sequence of tokens). The embedding matrix is also larger because `V x E` where `V` is the vocabulary size. As a result, it's more logical if `H >> E`. If `E < H`, the model has less parameters.\n \n \n ## Resources"
        }
    ],
    "stats": {
        "total": 154,
        "additions": 77,
        "deletions": 77
    }
}