{
    "author": "molbap",
    "message": ":red_circle: :red_circle: :red_circle: supersede paligemma forward to shift pos id indexing (#36859)\n\n* supersede paligemma forward to shift pos id indexing\n\n* fix prepare_inputs_ as well\n\n* fix modular error\n\n---------\n\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>",
    "sha": "b8aadc31d56e49d8b9075e73e5c433f7c5b4e04b",
    "files": [
        {
            "sha": "a6889073de271f372fa2ab8998219a724b630783",
            "filename": "src/transformers/models/gemma3/modeling_gemma3.py",
            "status": "modified",
            "additions": 1,
            "deletions": 7,
            "changes": 8,
            "blob_url": "https://github.com/huggingface/transformers/blob/b8aadc31d56e49d8b9075e73e5c433f7c5b4e04b/src%2Ftransformers%2Fmodels%2Fgemma3%2Fmodeling_gemma3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b8aadc31d56e49d8b9075e73e5c433f7c5b4e04b/src%2Ftransformers%2Fmodels%2Fgemma3%2Fmodeling_gemma3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3%2Fmodeling_gemma3.py?ref=b8aadc31d56e49d8b9075e73e5c433f7c5b4e04b",
            "patch": "@@ -1313,9 +1313,6 @@ def forward(\n                 past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n             )\n \n-        if position_ids is None:\n-            position_ids = cache_position.unsqueeze(0) + 1  # Gemma3 positions are 1-indexed\n-\n         # Merge text and images\n         if pixel_values is not None:\n             image_features = self.get_image_features(pixel_values)\n@@ -1363,7 +1360,7 @@ def forward(\n             **lm_kwargs,\n         )\n \n-        logits = outputs[0]\n+        logits = outputs.logits\n         loss = None\n         if labels is not None:\n             # Upcast to float if we need to compute the loss to avoid potential precision issues\n@@ -1427,9 +1424,6 @@ def prepare_inputs_for_generation(\n             **kwargs,\n         )\n \n-        # position_ids in Gemma3 are 1-indexed\n-        if model_inputs.get(\"position_ids\") is not None:\n-            model_inputs[\"position_ids\"] += 1\n         # If we're in cached decoding stage, pixel values should be None because input ids do not contain special image token anymore\n         # Otherwise we need pixel values to be passed to model. NOTE: use_cache=False needs pixel_values always\n         if cache_position[0] == 0:"
        },
        {
            "sha": "649ae2192c8cdc776740e1d06c4643c8b023294e",
            "filename": "src/transformers/models/gemma3/modular_gemma3.py",
            "status": "modified",
            "additions": 215,
            "deletions": 0,
            "changes": 215,
            "blob_url": "https://github.com/huggingface/transformers/blob/b8aadc31d56e49d8b9075e73e5c433f7c5b4e04b/src%2Ftransformers%2Fmodels%2Fgemma3%2Fmodular_gemma3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b8aadc31d56e49d8b9075e73e5c433f7c5b4e04b/src%2Ftransformers%2Fmodels%2Fgemma3%2Fmodular_gemma3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3%2Fmodular_gemma3.py?ref=b8aadc31d56e49d8b9075e73e5c433f7c5b4e04b",
            "patch": "@@ -33,8 +33,12 @@\n from ...modeling_utils import ALL_ATTENTION_FUNCTIONS\n from ...processing_utils import Unpack\n from ...utils import (\n+    add_start_docstrings_to_model_forward,\n+    is_torchdynamo_compiling,\n     logging,\n+    replace_return_docstrings,\n )\n+from ...utils.deprecation import deprecate_kwarg\n from ..bart.modeling_bart import BartScaledWordEmbedding\n from ..gemma2.configuration_gemma2 import Gemma2Config\n from ..gemma2.modeling_gemma2 import (\n@@ -837,6 +841,217 @@ def _update_causal_mask(\n \n         return causal_mask\n \n+    @deprecate_kwarg(\"num_logits_to_keep\", version=\"4.50\", new_name=\"logits_to_keep\")\n+    @add_start_docstrings_to_model_forward(GEMMA3_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=Gemma3CausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        pixel_values: torch.FloatTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Union[List[torch.FloatTensor], Cache]] = None,\n+        token_type_ids: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **lm_kwargs,\n+    ) -> Union[Tuple, Gemma3CausalLMOutputWithPast]:\n+        r\"\"\"\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.text_config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, ..., config.text_config.vocab_size]`.\n+\n+            logits_to_keep (`int` or `torch.Tensor`, *optional*):\n+                If an `int`, compute logits for the last `logits_to_keep` tokens. If `0`, calculate logits for all\n+                `input_ids` (special case). Only last token logits are needed for generation, and calculating them only for that\n+                token can save memory, which becomes pretty significant for long sequences or large vocabulary size.\n+                If a `torch.Tensor`, must be 1D corresponding to the indices to keep in the sequence length dimension.\n+                This is useful when using packed tensor format (single dimension for batch and sequence length).\n+\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> from PIL import Image\n+        >>> import requests\n+        >>> from transformers import AutoProcessor, Gemma3ForConditionalGeneration\n+\n+        >>> model = Gemma3ForConditionalGeneration.from_pretrained(\"google/Gemma3-test-224px-hf\")\n+        >>> processor = AutoProcessor.from_pretrained(\"google/Gemma3-test-224px-hf\")\n+\n+        >>> prompt = \"answer en Where is the cow standing?\"\n+        >>> url = \"https://huggingface.co/gv-hf/Gemma3-test-224px-hf/resolve/main/cow_beach_1.png\"\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> inputs = processor(images=image, text=prompt,  return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(**inputs, max_length=30)\n+        >>> processor.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"answer en Where is the cow standing?\\nbeach\"\n+        ```\"\"\"\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        is_training = token_type_ids is not None and labels is not None\n+\n+        # Replace image id woth PAD if the image token if OOV, to avoid index-errors\n+        if input_ids is not None and self.config.image_token_index >= self.vocab_size:\n+            special_image_mask = input_ids == self.config.image_token_index\n+            llm_input_ids = input_ids.clone()\n+            llm_input_ids[special_image_mask] = 0\n+        else:\n+            llm_input_ids = input_ids\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.get_input_embeddings()(llm_input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        # Merge text and images\n+        if pixel_values is not None:\n+            image_features = self.get_image_features(pixel_values)\n+\n+            if input_ids is None:\n+                special_image_mask = inputs_embeds == self.get_input_embeddings()(\n+                    torch.tensor(self.config.image_token_index, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            else:\n+                special_image_mask = (input_ids == self.config.image_token_index).unsqueeze(-1)\n+                special_image_mask = special_image_mask.expand_as(inputs_embeds).to(inputs_embeds.device)\n+\n+            if not is_torchdynamo_compiling() and inputs_embeds[special_image_mask].numel() != image_features.numel():\n+                image_tokens_in_text = (special_image_mask).sum(dim=1).sum(dim=0)[0]\n+                raise ValueError(\n+                    f\"Number of images does not match number of special image tokens in the input text. \"\n+                    f\"Got {image_tokens_in_text} image tokens in the text but {image_features.shape[0] * image_features.shape[1]} \"\n+                    \"tokens from image embeddings.\"\n+                )\n+            image_features = image_features.to(inputs_embeds.device, inputs_embeds.dtype)\n+            inputs_embeds = inputs_embeds.masked_scatter(special_image_mask, image_features)\n+\n+        # mask out pad-token-ids in labels for BC\n+        if labels is not None and self.pad_token_id in labels:\n+            logger.warning_once(\n+                \"`labels` contains `pad_token_id` which will be masked with `config.ignore_index`. \"\n+                \"You have to mask out `pad_token_id` when preparing `labels`, this behavior will be removed in v.4.46.\",\n+            )\n+            labels = torch.where(input_ids == self.pad_token_id, self.config.ignore_index, labels)\n+\n+        causal_mask = self._update_causal_mask(\n+            attention_mask, token_type_ids, past_key_values, cache_position, inputs_embeds, is_training\n+        )\n+        outputs = self.language_model(\n+            attention_mask=causal_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+            cache_position=cache_position,\n+            logits_to_keep=logits_to_keep,\n+            **lm_kwargs,\n+        )\n+\n+        logits = outputs.logits\n+        loss = None\n+        if labels is not None:\n+            # Upcast to float if we need to compute the loss to avoid potential precision issues\n+            logits = logits.float()\n+            shift_logits = logits[..., :-1, :]\n+            shift_labels = labels[..., 1:]\n+            if attention_mask is not None:\n+                # we use the input attention mask to shift the logits and labels, because it is 2D.\n+                # we also crop attn mask in case it is longer, which happens in PrefixTuning with peft\n+                shift_attention_mask = attention_mask[:, -shift_logits.shape[1] :].to(logits.device)\n+                shift_logits = shift_logits[shift_attention_mask.to(logits.device) != 0].contiguous()\n+                shift_labels = shift_labels[shift_attention_mask.to(shift_labels.device) != 0].contiguous()\n+            else:\n+                shift_logits = shift_logits.contiguous()\n+                shift_labels = shift_labels.contiguous()\n+            # Flatten the tokens\n+            loss_fct = nn.CrossEntropyLoss()\n+\n+            flat_logits = shift_logits.view(-1, self.config.text_config.vocab_size)\n+            flat_labels = shift_labels.view(-1).to(shift_logits.device)\n+            loss = loss_fct(flat_logits, flat_labels)\n+        if not return_dict:\n+            output = (logits,) + outputs[1:]\n+            return (loss,) + output if loss is not None else output\n+\n+        return Gemma3CausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            image_hidden_states=image_features if pixel_values is not None else None,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        position_ids=None,\n+        pixel_values=None,\n+        attention_mask=None,\n+        token_type_ids=None,\n+        use_cache=True,\n+        logits_to_keep=None,\n+        labels=None,\n+        **kwargs,\n+    ):\n+        # Overwritten -- custom `position_ids` and `pixel_values` handling\n+        model_inputs = self.language_model.prepare_inputs_for_generation(\n+            input_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            cache_position=cache_position,\n+            use_cache=use_cache,\n+            logits_to_keep=logits_to_keep,\n+            token_type_ids=token_type_ids,\n+            **kwargs,\n+        )\n+\n+        # If we're in cached decoding stage, pixel values should be None because input ids do not contain special image token anymore\n+        # Otherwise we need pixel values to be passed to model. NOTE: use_cache=False needs pixel_values always\n+        if cache_position[0] == 0:\n+            model_inputs[\"pixel_values\"] = pixel_values\n+        is_training = token_type_ids is not None and labels is not None\n+        if cache_position[0] == 0 and isinstance(past_key_values, HybridCache):\n+            input_tensor = inputs_embeds if inputs_embeds is not None else input_ids\n+            causal_mask = self._update_causal_mask(\n+                attention_mask, token_type_ids, past_key_values, cache_position, input_tensor, is_training\n+            )\n+            model_inputs[\"attention_mask\"] = causal_mask\n+\n+        return model_inputs\n+\n \n __all__ = [\n     \"Gemma3Config\","
        }
    ],
    "stats": {
        "total": 223,
        "additions": 216,
        "deletions": 7
    }
}