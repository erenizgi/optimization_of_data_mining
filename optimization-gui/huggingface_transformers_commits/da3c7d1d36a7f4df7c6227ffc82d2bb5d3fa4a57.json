{
    "author": "vasqu",
    "message": ":rotating_light: [`DistilBert`] Refactor Attention (#41163)\n\n* refactor\n\n* allow pos ids for flattened sequences",
    "sha": "da3c7d1d36a7f4df7c6227ffc82d2bb5d3fa4a57",
    "files": [
        {
            "sha": "48fc12cbcbfc221c881506f4254ee3a68b3b0b0d",
            "filename": "src/transformers/models/distilbert/modeling_distilbert.py",
            "status": "modified",
            "additions": 176,
            "deletions": 442,
            "changes": 618,
            "blob_url": "https://github.com/huggingface/transformers/blob/da3c7d1d36a7f4df7c6227ffc82d2bb5d3fa4a57/src%2Ftransformers%2Fmodels%2Fdistilbert%2Fmodeling_distilbert.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/da3c7d1d36a7f4df7c6227ffc82d2bb5d3fa4a57/src%2Ftransformers%2Fmodels%2Fdistilbert%2Fmodeling_distilbert.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fdistilbert%2Fmodeling_distilbert.py?ref=da3c7d1d36a7f4df7c6227ffc82d2bb5d3fa4a57",
            "patch": "@@ -18,8 +18,7 @@\n part from HuggingFace PyTorch version of Google AI Bert model (https://github.com/google-research/bert)\n \"\"\"\n \n-import math\n-from typing import Optional, Union\n+from typing import Callable, Optional, Union\n \n import numpy as np\n import torch\n@@ -29,8 +28,7 @@\n from ...activations import get_activation\n from ...configuration_utils import PretrainedConfig\n from ...integrations.deepspeed import is_deepspeed_zero3_enabled\n-from ...modeling_attn_mask_utils import _prepare_4d_attention_mask_for_sdpa\n-from ...modeling_flash_attention_utils import flash_attn_supports_top_left_mask, is_flash_attn_available\n+from ...modeling_attn_mask_utils import _prepare_4d_attention_mask, _prepare_4d_attention_mask_for_sdpa\n from ...modeling_layers import GradientCheckpointingLayer\n from ...modeling_outputs import (\n     BaseModelOutput,\n@@ -40,21 +38,25 @@\n     SequenceClassifierOutput,\n     TokenClassifierOutput,\n )\n-from ...modeling_utils import PreTrainedModel\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n from ...pytorch_utils import (\n     apply_chunking_to_forward,\n     find_pruneable_heads_and_indices,\n     prune_linear_layer,\n )\n from ...utils import (\n+    TransformersKwargs,\n     auto_docstring,\n+    is_torch_flex_attn_available,\n     logging,\n )\n+from ...utils.generic import can_return_tuple, check_model_inputs\n from .configuration_distilbert import DistilBertConfig\n \n \n-if is_flash_attn_available():\n-    from ...modeling_flash_attention_utils import _flash_attention_forward\n+if is_torch_flex_attn_available():\n+    from ...integrations.flex_attention import make_flex_block_causal_mask\n \n \n logger = logging.get_logger(__name__)\n@@ -94,31 +96,26 @@ def __init__(self, config: PretrainedConfig):\n             \"position_ids\", torch.arange(config.max_position_embeddings).expand((1, -1)), persistent=False\n         )\n \n-    def forward(self, input_ids: torch.Tensor, input_embeds: Optional[torch.Tensor] = None) -> torch.Tensor:\n-        \"\"\"\n-        Parameters:\n-            input_ids (torch.Tensor):\n-                torch.tensor(bs, max_seq_length) The token ids to embed.\n-            input_embeds (*optional*, torch.Tensor):\n-                The pre-computed word embeddings. Can only be passed if the input ids are `None`.\n-\n-\n-        Returns: torch.tensor(bs, max_seq_length, dim) The embedded tokens (plus position embeddings, no token_type\n-        embeddings)\n-        \"\"\"\n+    def forward(\n+        self,\n+        input_ids: torch.Tensor,\n+        input_embeds: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+    ) -> torch.Tensor:\n         if input_ids is not None:\n             input_embeds = self.word_embeddings(input_ids)  # (bs, max_seq_length, dim)\n \n         seq_length = input_embeds.size(1)\n \n-        # Setting the position-ids to the registered buffer in constructor, it helps\n-        # when tracing the model without passing position-ids, solves\n-        # issues similar to issue #5664\n-        if hasattr(self, \"position_ids\"):\n-            position_ids = self.position_ids[:, :seq_length]\n-        else:\n-            position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device)  # (max_seq_length)\n-            position_ids = position_ids.unsqueeze(0).expand_as(input_ids)  # (bs, max_seq_length)\n+        if position_ids is None:\n+            # Setting the position-ids to the registered buffer in constructor, it helps\n+            # when tracing the model without passing position-ids, solves\n+            # issues similar to issue #5664\n+            if hasattr(self, \"position_ids\"):\n+                position_ids = self.position_ids[:, :seq_length]\n+            else:\n+                position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device)  # (max_seq_length)\n+                position_ids = position_ids.unsqueeze(0).expand_as(input_ids)  # (bs, max_seq_length)\n \n         position_embeddings = self.position_embeddings(position_ids)  # (bs, max_seq_length, dim)\n \n@@ -128,15 +125,42 @@ def forward(self, input_ids: torch.Tensor, input_embeds: Optional[torch.Tensor]\n         return embeddings\n \n \n-class MultiHeadSelfAttention(nn.Module):\n+# Copied from transformers.models.bart.modeling_bart.eager_attention_forward\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: Optional[float] = None,\n+    dropout: float = 0.0,\n+    **kwargs,\n+):\n+    if scaling is None:\n+        scaling = query.size(-1) ** -0.5\n+\n+    attn_weights = torch.matmul(query, key.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        attn_weights = attn_weights + attention_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1)\n+\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+class DistilBertSelfAttention(nn.Module):\n     def __init__(self, config: PretrainedConfig):\n         super().__init__()\n         self.config = config\n \n         self.n_heads = config.n_heads\n         self.dim = config.dim\n-        self.dropout = nn.Dropout(p=config.attention_dropout)\n-        self.is_causal = False\n+        self.attention_head_size = self.dim // self.n_heads\n+        self.scaling = self.attention_head_size**-0.5\n \n         # Have an even number of multi heads that divide the dimensions\n         if self.dim % self.n_heads != 0:\n@@ -148,8 +172,10 @@ def __init__(self, config: PretrainedConfig):\n         self.v_lin = nn.Linear(in_features=config.dim, out_features=config.dim)\n         self.out_lin = nn.Linear(in_features=config.dim, out_features=config.dim)\n \n+        self.dropout = nn.Dropout(p=config.attention_dropout)\n+        self.is_causal = False\n+\n         self.pruned_heads: set[int] = set()\n-        self.attention_head_size = self.dim // self.n_heads\n \n     def prune_heads(self, heads: list[int]):\n         if len(heads) == 0:\n@@ -169,231 +195,35 @@ def prune_heads(self, heads: list[int]):\n \n     def forward(\n         self,\n-        query: torch.Tensor,\n-        key: torch.Tensor,\n-        value: torch.Tensor,\n-        mask: torch.Tensor,\n-        output_attentions: bool = False,\n-    ) -> tuple[torch.Tensor, ...]:\n-        \"\"\"\n-        Parameters:\n-            query: torch.tensor(bs, seq_length, dim)\n-            key: torch.tensor(bs, seq_length, dim)\n-            value: torch.tensor(bs, seq_length, dim)\n-            mask: torch.tensor(bs, seq_length)\n-\n-        Returns:\n-            weights: torch.tensor(bs, n_heads, seq_length, seq_length) Attention weights context: torch.tensor(bs,\n-            seq_length, dim) Contextualized layer. Optional: only if `output_attentions=True`\n-        \"\"\"\n-        bs, q_length, dim = query.size()\n-        k_length = key.size(1)\n-        # assert dim == self.dim, f'Dimensions do not match: {dim} input vs {self.dim} configured'\n-        # assert key.size() == value.size()\n-\n-        dim_per_head = self.dim // self.n_heads\n-\n-        mask_reshp = (bs, 1, 1, k_length)\n-\n-        def shape(x: torch.Tensor) -> torch.Tensor:\n-            \"\"\"separate heads\"\"\"\n-            return x.view(bs, -1, self.n_heads, dim_per_head).transpose(1, 2)\n-\n-        def unshape(x: torch.Tensor) -> torch.Tensor:\n-            \"\"\"group heads\"\"\"\n-            return x.transpose(1, 2).contiguous().view(bs, -1, self.n_heads * dim_per_head)\n-\n-        q = shape(self.q_lin(query))  # (bs, n_heads, q_length, dim_per_head)\n-        k = shape(self.k_lin(key))  # (bs, n_heads, k_length, dim_per_head)\n-        v = shape(self.v_lin(value))  # (bs, n_heads, k_length, dim_per_head)\n-\n-        q = q / math.sqrt(dim_per_head)  # (bs, n_heads, q_length, dim_per_head)\n-        scores = torch.matmul(q, k.transpose(2, 3))  # (bs, n_heads, q_length, k_length)\n-        mask = (mask == 0).view(mask_reshp).expand_as(scores)  # (bs, n_heads, q_length, k_length)\n-        scores = scores.masked_fill(\n-            mask, torch.tensor(torch.finfo(scores.dtype).min)\n-        )  # (bs, n_heads, q_length, k_length)\n-\n-        weights = nn.functional.softmax(scores, dim=-1)  # (bs, n_heads, q_length, k_length)\n-        weights = self.dropout(weights)  # (bs, n_heads, q_length, k_length)\n-\n-        context = torch.matmul(weights, v)  # (bs, n_heads, q_length, dim_per_head)\n-        context = unshape(context)  # (bs, q_length, dim)\n-        context = self.out_lin(context)  # (bs, q_length, dim)\n-\n-        if output_attentions:\n-            return (context, weights)\n-        else:\n-            return (context,)\n-\n-\n-class DistilBertFlashAttention2(MultiHeadSelfAttention):\n-    \"\"\"\n-    DistilBert flash attention module. This module inherits from `MultiHeadSelfAttention` as the weights of the module\n-    stays untouched. The only required change would be on the forward pass where it needs to correctly call the public\n-    API of flash attention and deal with padding tokens in case the input contains any of them.\n-    \"\"\"\n-\n-    def __init__(self, *args, **kwargs):\n-        super().__init__(*args, **kwargs)\n-\n-        # TODO: Should be removed once Flash Attention for RoCm is bumped to 2.1.\n-        # flash_attn<2.1 generates top-left aligned causal mask, while what is needed here is bottom-right alignment, that was made default for flash_attn>=2.1. This attribute is used to handle this difference. Reference: https://github.com/Dao-AILab/flash-attention/releases/tag/v2.1.0.\n-        # Beware that with flash_attn<2.1, using q_seqlen != k_seqlen (except for the case q_seqlen == 1) produces a wrong mask (top-left).\n-        self._flash_attn_uses_top_left_mask = flash_attn_supports_top_left_mask()\n-\n-    def forward(\n-        self,\n-        query: torch.Tensor,\n-        key: torch.Tensor,\n-        value: torch.Tensor,\n-        mask: torch.Tensor,\n-        output_attentions: bool = False,\n-    ) -> tuple[torch.Tensor, ...]:\n-        \"\"\"\n-        Parameters:\n-            query: torch.tensor(bs, seq_length, dim)\n-            key: torch.tensor(bs, seq_length, dim)\n-            value: torch.tensor(bs, seq_length, dim)\n-            mask: torch.tensor(bs, seq_length)\n-\n-        Returns:\n-            weights: torch.tensor(bs, n_heads, seq_length, seq_length) Attention weights context: torch.tensor(bs,\n-            seq_length, dim) Contextualized layer. Optional: only if `output_attentions=True`\n-        \"\"\"\n-        batch_size, q_length, dim = query.size()\n-\n-        dim_per_head = self.dim // self.n_heads\n-\n-        def reshape(x: torch.Tensor) -> torch.Tensor:\n-            \"\"\"separate heads\"\"\"\n-            return x.view(batch_size, -1, self.n_heads, dim_per_head)\n-\n-        # Flash attention requires the input to have the shape\n-        # batch_size x seq_length x head_dim x hidden_dim\n-        query_states = reshape(self.q_lin(query))\n-        key_states = reshape(self.k_lin(key))\n-        value_states = reshape(self.v_lin(value))\n-\n-        attn_dropout = self.config.attention_dropout if self.training else 0.0\n-\n-        # In PEFT, usually we cast the layer norms in float32 for training stability reasons\n-        # therefore the input hidden states gets silently casted in float32. Hence, we need\n-        # cast them back in the correct dtype just to be sure everything works as expected.\n-        # This might slowdown training & inference so it is recommended to not cast the LayerNorms\n-        # in fp32. (LlamaRMSNorm handles it correctly)\n-\n-        device_type = query_states.device.type if query_states.device.type != \"mps\" else \"cpu\"\n-        if query_states.dtype == torch.float32:\n-            if torch.is_autocast_enabled():\n-                target_dtype = (\n-                    torch.get_autocast_dtype(device_type)\n-                    if hasattr(torch, \"get_autocast_dtype\")\n-                    else torch.get_autocast_gpu_dtype()\n-                )\n-            # Handle the case where the model is quantized\n-            elif hasattr(self.config, \"_pre_quantization_dtype\"):\n-                target_dtype = self.config._pre_quantization_dtype\n-            else:\n-                target_dtype = self.q_lin.weight.dtype\n-\n-            logger.warning_once(\n-                f\"The input hidden states seems to be silently casted in float32, this might be related to\"\n-                f\" the fact you have upcasted embedding or layer norm layers in float32. We will cast back the input in\"\n-                f\" {target_dtype}.\"\n-            )\n-\n-            query_states = query_states.to(target_dtype)\n-            key_states = key_states.to(target_dtype)\n-            value_states = value_states.to(target_dtype)\n-\n-        attn_weights = _flash_attention_forward(\n-            query_states,\n-            key_states,\n-            value_states,\n-            mask,\n-            q_length,\n-            dropout=attn_dropout,\n-            use_top_left_mask=self._flash_attn_uses_top_left_mask,\n-            is_causal=self.is_causal,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.FloatTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.attention_head_size)\n+\n+        # get all proj\n+        query_layer = self.q_lin(hidden_states).view(*hidden_shape).transpose(1, 2)\n+        key_layer = self.k_lin(hidden_states).view(*hidden_shape).transpose(1, 2)\n+        value_layer = self.v_lin(hidden_states).view(*hidden_shape).transpose(1, 2)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_layer,\n+            key_layer,\n+            value_layer,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.dropout.p,\n+            scaling=self.scaling,\n+            **kwargs,\n         )\n-\n-        attn_weights_reshaped = attn_weights.reshape(batch_size, q_length, self.n_heads * dim_per_head)\n-        attn_output = self.out_lin(attn_weights_reshaped)\n-\n-        if output_attentions:\n-            return (attn_output, attn_weights)\n-        else:\n-            return (attn_output,)\n-\n-\n-class DistilBertSdpaAttention(MultiHeadSelfAttention):\n-    def __init__(self, config: PretrainedConfig):\n-        super().__init__(config=config)\n-        self.dropout_prob = config.attention_dropout\n-\n-    def forward(\n-        self,\n-        query: torch.Tensor,\n-        key: torch.Tensor,\n-        value: torch.Tensor,\n-        mask: torch.Tensor,\n-        output_attentions: bool = False,\n-    ) -> tuple[torch.Tensor, ...]:\n-        \"\"\"\n-        Parameters:\n-            query: torch.tensor(bs, seq_length, dim)\n-            key: torch.tensor(bs, seq_length, dim)\n-            value: torch.tensor(bs, seq_length, dim)\n-            mask: torch.tensor(bs, seq_length)\n-\n-        Returns:\n-            weights: torch.tensor(bs, n_heads, seq_length, seq_length) Attention weights context: torch.tensor(bs,\n-            seq_length, dim) Contextualized layer. Optional: only if `output_attentions=True`\n-        \"\"\"\n-        if output_attentions:\n-            logger.warning_once(\n-                \"DistilBertSdpaAttention is used but `torch.nn.functional.scaled_dot_product_attention` does not support\"\n-                \" `output_attentions=True`. Falling back to the manual attention implementation, but specifying\"\n-                \" the manual implementation will be required from Transformers version v5.0.0 onwards. This warning can be\"\n-                ' removed using the argument `attn_implementation=\"eager\"` when loading the model.'\n-            )\n-            return super().forward(\n-                query,\n-                key,\n-                value,\n-                mask,\n-                output_attentions,\n-            )\n-\n-        batch_size, _, _ = query.size()\n-        dim_per_head = self.dim // self.n_heads\n-\n-        def shape(x: torch.Tensor) -> torch.Tensor:\n-            \"\"\"separate heads\"\"\"\n-            return x.view(batch_size, -1, self.n_heads, dim_per_head).transpose(1, 2)\n-\n-        def unshape(x: torch.Tensor) -> torch.Tensor:\n-            \"\"\"group heads\"\"\"\n-            return x.transpose(1, 2).contiguous().view(batch_size, -1, self.n_heads * dim_per_head)\n-\n-        q = shape(self.q_lin(query))  # (bs, n_heads, q_length, dim_per_head)\n-        k = shape(self.k_lin(key))  # (bs, n_heads, k_length, dim_per_head)\n-        v = shape(self.v_lin(value))  # (bs, n_heads, k_length, dim_per_head)\n-\n-        attn_output = torch.nn.functional.scaled_dot_product_attention(\n-            q,\n-            k,\n-            v,\n-            attn_mask=mask,\n-            dropout_p=self.dropout_prob if self.training else 0.0,\n-            is_causal=False,\n-        )\n-\n-        attn_output = unshape(attn_output)\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n         attn_output = self.out_lin(attn_output)\n-\n-        return (attn_output,)\n+        return attn_output, attn_weights\n \n \n class FFN(nn.Module):\n@@ -417,13 +247,6 @@ def ff_chunk(self, input: torch.Tensor) -> torch.Tensor:\n         return x\n \n \n-DISTILBERT_ATTENTION_CLASSES = {\n-    \"eager\": MultiHeadSelfAttention,\n-    \"flash_attention_2\": DistilBertFlashAttention2,\n-    \"sdpa\": DistilBertSdpaAttention,\n-}\n-\n-\n class TransformerBlock(GradientCheckpointingLayer):\n     def __init__(self, config: PretrainedConfig):\n         super().__init__()\n@@ -432,52 +255,31 @@ def __init__(self, config: PretrainedConfig):\n         if config.dim % config.n_heads != 0:\n             raise ValueError(f\"config.n_heads {config.n_heads} must divide config.dim {config.dim} evenly\")\n \n-        self.attention = DISTILBERT_ATTENTION_CLASSES[config._attn_implementation](config)\n+        self.attention = DistilBertSelfAttention(config)\n         self.sa_layer_norm = nn.LayerNorm(normalized_shape=config.dim, eps=1e-12)\n \n         self.ffn = FFN(config)\n         self.output_layer_norm = nn.LayerNorm(normalized_shape=config.dim, eps=1e-12)\n \n     def forward(\n         self,\n-        x: torch.Tensor,\n-        attn_mask: Optional[torch.Tensor] = None,\n-        output_attentions: bool = False,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n     ) -> tuple[torch.Tensor, ...]:\n-        \"\"\"\n-        Parameters:\n-            x: torch.tensor(bs, seq_length, dim)\n-            attn_mask: torch.tensor(bs, seq_length)\n-\n-        Returns:\n-            sa_weights: torch.tensor(bs, n_heads, seq_length, seq_length) The attention weights ffn_output:\n-            torch.tensor(bs, seq_length, dim) The output of the transformer block contextualization.\n-        \"\"\"\n         # Self-Attention\n-        sa_output = self.attention(\n-            query=x,\n-            key=x,\n-            value=x,\n-            mask=attn_mask,\n-            output_attentions=output_attentions,\n+        attention_output, _ = self.attention(\n+            hidden_states,\n+            attention_mask=attention_mask,\n+            **kwargs,\n         )\n-        if output_attentions:\n-            sa_output, sa_weights = sa_output  # (bs, seq_length, dim), (bs, n_heads, seq_length, seq_length)\n-        else:  # To handle these `output_attentions` or `output_hidden_states` cases returning tuples\n-            if type(sa_output) is not tuple:\n-                raise TypeError(f\"sa_output must be a tuple but it is {type(sa_output)} type\")\n-\n-            sa_output = sa_output[0]\n-        sa_output = self.sa_layer_norm(sa_output + x)  # (bs, seq_length, dim)\n+        attention_output = self.sa_layer_norm(attention_output + hidden_states)\n \n         # Feed Forward Network\n-        ffn_output = self.ffn(sa_output)  # (bs, seq_length, dim)\n-        ffn_output: torch.Tensor = self.output_layer_norm(ffn_output + sa_output)  # (bs, seq_length, dim)\n+        ffn_output = self.ffn(attention_output)\n+        ffn_output = self.output_layer_norm(ffn_output + attention_output)\n \n-        output = (ffn_output,)\n-        if output_attentions:\n-            output = (sa_weights,) + output\n-        return output\n+        return ffn_output\n \n \n class Transformer(nn.Module):\n@@ -489,61 +291,18 @@ def __init__(self, config: PretrainedConfig):\n \n     def forward(\n         self,\n-        x: torch.Tensor,\n-        attn_mask: Optional[torch.Tensor] = None,\n-        output_attentions: bool = False,\n-        output_hidden_states: bool = False,\n-        return_dict: Optional[bool] = None,\n-    ) -> Union[BaseModelOutput, tuple[torch.Tensor, ...]]:  # docstyle-ignore\n-        \"\"\"\n-        Parameters:\n-            x: torch.tensor(bs, seq_length, dim) Input sequence embedded.\n-            attn_mask: torch.tensor(bs, seq_length) Attention mask on the sequence.\n-\n-        Returns:\n-            hidden_state: torch.tensor(bs, seq_length, dim) Sequence of hidden states in the last (top)\n-            layer all_hidden_states: tuple[torch.tensor(bs, seq_length, dim)]\n-                Tuple of length n_layers with the hidden states from each layer.\n-                Optional: only if output_hidden_states=True\n-            all_attentions: tuple[torch.tensor(bs, n_heads, seq_length, seq_length)]\n-                Tuple of length n_layers with the attention weights from each layer\n-                Optional: only if output_attentions=True\n-        \"\"\"\n-        all_hidden_states = () if output_hidden_states else None\n-        all_attentions = () if output_attentions else None\n-\n-        hidden_state = x\n-        for i, layer_module in enumerate(self.layer):\n-            if output_hidden_states:\n-                all_hidden_states = all_hidden_states + (hidden_state,)\n-\n-            layer_outputs = layer_module(\n-                hidden_state,\n-                attn_mask,\n-                output_attentions,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[BaseModelOutput]:\n+        for layer_module in self.layer:\n+            hidden_states = layer_module(\n+                hidden_states,\n+                attention_mask,\n+                **kwargs,\n             )\n \n-            hidden_state = layer_outputs[-1]\n-\n-            if output_attentions:\n-                if len(layer_outputs) != 2:\n-                    raise ValueError(f\"The length of the layer_outputs should be 2, but it is {len(layer_outputs)}\")\n-\n-                attentions = layer_outputs[0]\n-                all_attentions = all_attentions + (attentions,)\n-            else:\n-                if len(layer_outputs) != 1:\n-                    raise ValueError(f\"The length of the layer_outputs should be 1, but it is {len(layer_outputs)}\")\n-\n-        # Add last layer\n-        if output_hidden_states:\n-            all_hidden_states = all_hidden_states + (hidden_state,)\n-\n-        if not return_dict:\n-            return tuple(v for v in [hidden_state, all_hidden_states, all_attentions] if v is not None)\n-        return BaseModelOutput(\n-            last_hidden_state=hidden_state, hidden_states=all_hidden_states, attentions=all_attentions\n-        )\n+        return BaseModelOutput(last_hidden_state=hidden_states)\n \n \n # INTERFACE FOR ENCODER AND TASK SPECIFIC MODEL #\n@@ -554,6 +313,12 @@ class DistilBertPreTrainedModel(PreTrainedModel):\n     supports_gradient_checkpointing = True\n     _supports_flash_attn = True\n     _supports_sdpa = True\n+    _supports_flex_attn = True\n+    _supports_attention_backend = True\n+    _can_record_outputs = {\n+        \"hidden_states\": TransformerBlock,\n+        \"attentions\": DistilBertSelfAttention,\n+    }\n \n     def _init_weights(self, module: nn.Module):\n         \"\"\"Initialize the weights.\"\"\"\n@@ -647,15 +412,15 @@ class PreTrainedModel\n         for layer, heads in heads_to_prune.items():\n             self.transformer.layer[layer].attention.prune_heads(heads)\n \n+    @check_model_inputs\n     @auto_docstring\n     def forward(\n         self,\n         input_ids: Optional[torch.Tensor] = None,\n         attention_mask: Optional[torch.Tensor] = None,\n         inputs_embeds: Optional[torch.Tensor] = None,\n-        output_attentions: Optional[bool] = None,\n-        output_hidden_states: Optional[bool] = None,\n-        return_dict: Optional[bool] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n     ) -> Union[BaseModelOutput, tuple[torch.Tensor, ...]]:\n         r\"\"\"\n         input_ids (`torch.LongTensor` of shape `(batch_size, num_choices)`):\n@@ -670,45 +435,43 @@ def forward(\n             is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n             model's internal embedding lookup matrix.\n         \"\"\"\n-        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n-        output_hidden_states = (\n-            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n-        )\n-        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n-\n-        if input_ids is not None and inputs_embeds is not None:\n-            raise ValueError(\"You cannot specify both input_ids and inputs_embeds at the same time\")\n-        elif input_ids is not None:\n-            self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n-            input_shape = input_ids.size()\n-        elif inputs_embeds is not None:\n-            input_shape = inputs_embeds.size()[:-1]\n-        else:\n-            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n \n-        device = input_ids.device if input_ids is not None else inputs_embeds.device\n+        embeddings = self.embeddings(input_ids, inputs_embeds, position_ids)\n \n-        embeddings = self.embeddings(input_ids, inputs_embeds)  # (bs, seq_length, dim)\n-\n-        if self.config._attn_implementation == \"flash_attention_2\":\n-            attention_mask = attention_mask if (attention_mask is not None and 0 in attention_mask) else None\n-        else:\n-            if attention_mask is None:\n-                attention_mask = torch.ones(input_shape, device=device)  # (bs, seq_length)\n-\n-            if self.config._attn_implementation == \"sdpa\" and not output_attentions:\n-                attention_mask = _prepare_4d_attention_mask_for_sdpa(\n-                    attention_mask, embeddings.dtype, tgt_len=input_shape[1]\n-                )\n+        attention_mask = self._update_full_mask(\n+            attention_mask,\n+            embeddings,\n+        )\n \n         return self.transformer(\n-            x=embeddings,\n-            attn_mask=attention_mask,\n-            output_attentions=output_attentions,\n-            output_hidden_states=output_hidden_states,\n-            return_dict=return_dict,\n+            hidden_states=embeddings,\n+            attention_mask=attention_mask,\n+            **kwargs,\n         )\n \n+    # Copied from transformers.models.bart.modeling_bart.BartPreTrainedModel._update_full_mask\n+    def _update_full_mask(\n+        self,\n+        attention_mask: Union[torch.Tensor, None],\n+        inputs_embeds: torch.Tensor,\n+    ):\n+        if attention_mask is not None:\n+            if \"flash\" in self.config._attn_implementation:\n+                attention_mask = attention_mask if 0 in attention_mask else None\n+            elif self.config._attn_implementation == \"sdpa\":\n+                # [bsz, seq_len] -> [bsz, 1, tgt_seq_len, src_seq_len]\n+                attention_mask = _prepare_4d_attention_mask_for_sdpa(attention_mask, inputs_embeds.dtype)\n+            elif self.config._attn_implementation == \"flex_attention\":\n+                if isinstance(attention_mask, torch.Tensor):\n+                    attention_mask = make_flex_block_causal_mask(attention_mask, is_causal=False)\n+            else:\n+                # [bsz, seq_len] -> [bsz, 1, tgt_seq_len, src_seq_len]\n+                attention_mask = _prepare_4d_attention_mask(attention_mask, inputs_embeds.dtype)\n+\n+        return attention_mask\n+\n \n @auto_docstring(\n     custom_intro=\"\"\"\n@@ -759,16 +522,16 @@ def get_output_embeddings(self) -> nn.Module:\n     def set_output_embeddings(self, new_embeddings: nn.Module):\n         self.vocab_projector = new_embeddings\n \n+    @can_return_tuple\n     @auto_docstring\n     def forward(\n         self,\n         input_ids: Optional[torch.Tensor] = None,\n         attention_mask: Optional[torch.Tensor] = None,\n         inputs_embeds: Optional[torch.Tensor] = None,\n         labels: Optional[torch.LongTensor] = None,\n-        output_attentions: Optional[bool] = None,\n-        output_hidden_states: Optional[bool] = None,\n-        return_dict: Optional[bool] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n     ) -> Union[MaskedLMOutput, tuple[torch.Tensor, ...]]:\n         r\"\"\"\n         input_ids (`torch.LongTensor` of shape `(batch_size, num_choices)`):\n@@ -787,15 +550,13 @@ def forward(\n             config.vocab_size]` (see `input_ids` docstring) Tokens with indices set to `-100` are ignored (masked), the\n             loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n         \"\"\"\n-        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n-\n         dlbrt_output = self.distilbert(\n             input_ids=input_ids,\n             attention_mask=attention_mask,\n             inputs_embeds=inputs_embeds,\n-            output_attentions=output_attentions,\n-            output_hidden_states=output_hidden_states,\n-            return_dict=return_dict,\n+            position_ids=position_ids,\n+            return_dict=True,\n+            **kwargs,\n         )\n         hidden_states = dlbrt_output[0]  # (bs, seq_length, dim)\n         prediction_logits = self.vocab_transform(hidden_states)  # (bs, seq_length, dim)\n@@ -807,10 +568,6 @@ def forward(\n         if labels is not None:\n             mlm_loss = self.mlm_loss_fct(prediction_logits.view(-1, prediction_logits.size(-1)), labels.view(-1))\n \n-        if not return_dict:\n-            output = (prediction_logits,) + dlbrt_output[1:]\n-            return ((mlm_loss,) + output) if mlm_loss is not None else output\n-\n         return MaskedLMOutput(\n             loss=mlm_loss,\n             logits=prediction_logits,\n@@ -859,32 +616,30 @@ def resize_position_embeddings(self, new_num_position_embeddings: int):\n         \"\"\"\n         self.distilbert.resize_position_embeddings(new_num_position_embeddings)\n \n+    @can_return_tuple\n     @auto_docstring\n     def forward(\n         self,\n         input_ids: Optional[torch.Tensor] = None,\n         attention_mask: Optional[torch.Tensor] = None,\n         inputs_embeds: Optional[torch.Tensor] = None,\n         labels: Optional[torch.LongTensor] = None,\n-        output_attentions: Optional[bool] = None,\n-        output_hidden_states: Optional[bool] = None,\n-        return_dict: Optional[bool] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n     ) -> Union[SequenceClassifierOutput, tuple[torch.Tensor, ...]]:\n         r\"\"\"\n         labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n             Labels for computing the sequence classification/regression loss. Indices should be in `[0, ...,\n             config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If\n             `config.num_labels > 1` a classification loss is computed (Cross-Entropy).\n         \"\"\"\n-        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n-\n         distilbert_output = self.distilbert(\n             input_ids=input_ids,\n             attention_mask=attention_mask,\n             inputs_embeds=inputs_embeds,\n-            output_attentions=output_attentions,\n-            output_hidden_states=output_hidden_states,\n-            return_dict=return_dict,\n+            position_ids=position_ids,\n+            return_dict=True,\n+            **kwargs,\n         )\n         hidden_state = distilbert_output[0]  # (bs, seq_len, dim)\n         pooled_output = hidden_state[:, 0]  # (bs, dim)\n@@ -916,10 +671,6 @@ def forward(\n                 loss_fct = BCEWithLogitsLoss()\n                 loss = loss_fct(logits, labels)\n \n-        if not return_dict:\n-            output = (logits,) + distilbert_output[1:]\n-            return ((loss,) + output) if loss is not None else output\n-\n         return SequenceClassifierOutput(\n             loss=loss,\n             logits=logits,\n@@ -963,6 +714,7 @@ def resize_position_embeddings(self, new_num_position_embeddings: int):\n         \"\"\"\n         self.distilbert.resize_position_embeddings(new_num_position_embeddings)\n \n+    @can_return_tuple\n     @auto_docstring\n     def forward(\n         self,\n@@ -971,9 +723,8 @@ def forward(\n         inputs_embeds: Optional[torch.Tensor] = None,\n         start_positions: Optional[torch.Tensor] = None,\n         end_positions: Optional[torch.Tensor] = None,\n-        output_attentions: Optional[bool] = None,\n-        output_hidden_states: Optional[bool] = None,\n-        return_dict: Optional[bool] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n     ) -> Union[QuestionAnsweringModelOutput, tuple[torch.Tensor, ...]]:\n         r\"\"\"\n         input_ids (`torch.LongTensor` of shape `(batch_size, num_choices)`):\n@@ -988,15 +739,13 @@ def forward(\n             is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n             model's internal embedding lookup matrix.\n         \"\"\"\n-        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n-\n         distilbert_output = self.distilbert(\n             input_ids=input_ids,\n             attention_mask=attention_mask,\n             inputs_embeds=inputs_embeds,\n-            output_attentions=output_attentions,\n-            output_hidden_states=output_hidden_states,\n-            return_dict=return_dict,\n+            position_ids=position_ids,\n+            return_dict=True,\n+            **kwargs,\n         )\n         hidden_states = distilbert_output[0]  # (bs, max_query_len, dim)\n \n@@ -1023,10 +772,6 @@ def forward(\n             end_loss = loss_fct(end_logits, end_positions)\n             total_loss = (start_loss + end_loss) / 2\n \n-        if not return_dict:\n-            output = (start_logits, end_logits) + distilbert_output[1:]\n-            return ((total_loss,) + output) if total_loss is not None else output\n-\n         return QuestionAnsweringModelOutput(\n             loss=total_loss,\n             start_logits=start_logits,\n@@ -1069,30 +814,28 @@ def resize_position_embeddings(self, new_num_position_embeddings: int):\n         \"\"\"\n         self.distilbert.resize_position_embeddings(new_num_position_embeddings)\n \n+    @can_return_tuple\n     @auto_docstring\n     def forward(\n         self,\n         input_ids: Optional[torch.Tensor] = None,\n         attention_mask: Optional[torch.Tensor] = None,\n         inputs_embeds: Optional[torch.Tensor] = None,\n         labels: Optional[torch.LongTensor] = None,\n-        output_attentions: Optional[bool] = None,\n-        output_hidden_states: Optional[bool] = None,\n-        return_dict: Optional[bool] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n     ) -> Union[TokenClassifierOutput, tuple[torch.Tensor, ...]]:\n         r\"\"\"\n         labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n             Labels for computing the token classification loss. Indices should be in `[0, ..., config.num_labels - 1]`.\n         \"\"\"\n-        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n-\n         outputs = self.distilbert(\n             input_ids,\n             attention_mask=attention_mask,\n             inputs_embeds=inputs_embeds,\n-            output_attentions=output_attentions,\n-            output_hidden_states=output_hidden_states,\n-            return_dict=return_dict,\n+            position_ids=position_ids,\n+            return_dict=True,\n+            **kwargs,\n         )\n \n         sequence_output = outputs[0]\n@@ -1105,10 +848,6 @@ def forward(\n             loss_fct = CrossEntropyLoss()\n             loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1))\n \n-        if not return_dict:\n-            output = (logits,) + outputs[1:]\n-            return ((loss,) + output) if loss is not None else output\n-\n         return TokenClassifierOutput(\n             loss=loss,\n             logits=logits,\n@@ -1150,16 +889,16 @@ def resize_position_embeddings(self, new_num_position_embeddings: int):\n         \"\"\"\n         self.distilbert.resize_position_embeddings(new_num_position_embeddings)\n \n+    @can_return_tuple\n     @auto_docstring\n     def forward(\n         self,\n         input_ids: Optional[torch.Tensor] = None,\n         attention_mask: Optional[torch.Tensor] = None,\n         inputs_embeds: Optional[torch.Tensor] = None,\n         labels: Optional[torch.LongTensor] = None,\n-        output_attentions: Optional[bool] = None,\n-        output_hidden_states: Optional[bool] = None,\n-        return_dict: Optional[bool] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n     ) -> Union[MultipleChoiceModelOutput, tuple[torch.Tensor, ...]]:\n         r\"\"\"\n         input_ids (`torch.LongTensor` of shape `(batch_size, num_choices, sequence_length)`):\n@@ -1199,7 +938,6 @@ def forward(\n         >>> loss = outputs.loss\n         >>> logits = outputs.logits\n         ```\"\"\"\n-        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n         num_choices = input_ids.shape[1] if input_ids is not None else inputs_embeds.shape[1]\n \n         input_ids = input_ids.view(-1, input_ids.size(-1)) if input_ids is not None else None\n@@ -1214,9 +952,9 @@ def forward(\n             input_ids,\n             attention_mask=attention_mask,\n             inputs_embeds=inputs_embeds,\n-            output_attentions=output_attentions,\n-            output_hidden_states=output_hidden_states,\n-            return_dict=return_dict,\n+            position_ids=position_ids,\n+            return_dict=True,\n+            **kwargs,\n         )\n \n         hidden_state = outputs[0]  # (bs * num_choices, seq_len, dim)\n@@ -1233,10 +971,6 @@ def forward(\n             loss_fct = CrossEntropyLoss()\n             loss = loss_fct(reshaped_logits, labels)\n \n-        if not return_dict:\n-            output = (reshaped_logits,) + outputs[1:]\n-            return ((loss,) + output) if loss is not None else output\n-\n         return MultipleChoiceModelOutput(\n             loss=loss,\n             logits=reshaped_logits,"
        },
        {
            "sha": "a1c4dc07e3ac1d921a4970518162b6aa624be4b9",
            "filename": "tests/models/distilbert/test_modeling_distilbert.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/da3c7d1d36a7f4df7c6227ffc82d2bb5d3fa4a57/tests%2Fmodels%2Fdistilbert%2Ftest_modeling_distilbert.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/da3c7d1d36a7f4df7c6227ffc82d2bb5d3fa4a57/tests%2Fmodels%2Fdistilbert%2Ftest_modeling_distilbert.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fdistilbert%2Ftest_modeling_distilbert.py?ref=da3c7d1d36a7f4df7c6227ffc82d2bb5d3fa4a57",
            "patch": "@@ -223,7 +223,7 @@ class DistilBertModelTest(ModelTesterMixin, PipelineTesterMixin, unittest.TestCa\n         if is_torch_available()\n         else {}\n     )\n-    fx_compatible = True\n+    fx_compatible = False  # won't be maintained\n     test_pruning = True\n     test_resize_embeddings = True\n     test_resize_position_embeddings = True"
        }
    ],
    "stats": {
        "total": 620,
        "additions": 177,
        "deletions": 443
    }
}