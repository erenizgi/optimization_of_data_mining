{
    "author": "manueldeprada",
    "message": "Fix custom generate from local directory (#38916)\n\nFix custom generate from local directory:\n1. Create parent dirs before copying files (custom_generate dir)\n2. Correctly copy relative imports to the submodule file.\n3. Update docs.",
    "sha": "166e823f770477b17988020b2476a796d49836a6",
    "files": [
        {
            "sha": "6453669f68966fe4fd79c3bb58056a47862bac06",
            "filename": "docs/source/en/generation_strategies.md",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/huggingface/transformers/blob/166e823f770477b17988020b2476a796d49836a6/docs%2Fsource%2Fen%2Fgeneration_strategies.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/166e823f770477b17988020b2476a796d49836a6/docs%2Fsource%2Fen%2Fgeneration_strategies.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fgeneration_strategies.md?ref=166e823f770477b17988020b2476a796d49836a6",
            "patch": "@@ -468,9 +468,17 @@ def generate(model, input_ids, generation_config=None, left_padding=None, **kwar\n Follow the recommended practices below to ensure your custom decoding method works as expected.\n - Feel free to reuse the logic for validation and input preparation in the original [`~GenerationMixin.generate`].\n - Pin the `transformers` version in the requirements if you use any private method/attribute in `model`.\n-- You can add other files in the `custom_generate` folder, and use relative imports.\n - Consider adding model validation, input validation, or even a separate test file to help users sanity-check your code in their environment.\n \n+Your custom `generate` method can relative import code from the `custom_generate` folder. For example, if you have a `utils.py` file, you can import it like this:\n+\n+```py\n+from .utils import some_function\n+```\n+\n+Only relative imports from the same-level `custom_generate` folder are supported. Parent/sibling folder imports are not valid. The `custom_generate` argument also works locally with any directory that contains a `custom_generate` structure. This is the recommended workflow for developing your custom decoding method.\n+\n+\n #### requirements.txt\n \n You can optionally specify additional Python requirements in a `requirements.txt` file inside the `custom_generate` folder. These are checked at runtime and an exception will be thrown if they're missing, nudging users to update their environment accordingly."
        },
        {
            "sha": "7a498721a9116e3e241a94e64df8672c7726093e",
            "filename": "src/transformers/dynamic_module_utils.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/166e823f770477b17988020b2476a796d49836a6/src%2Ftransformers%2Fdynamic_module_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/166e823f770477b17988020b2476a796d49836a6/src%2Ftransformers%2Fdynamic_module_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fdynamic_module_utils.py?ref=166e823f770477b17988020b2476a796d49836a6",
            "patch": "@@ -402,10 +402,11 @@ def get_cached_module_file(\n         if not (submodule_path / module_file).exists() or not filecmp.cmp(\n             resolved_module_file, str(submodule_path / module_file)\n         ):\n+            (submodule_path / module_file).parent.mkdir(parents=True, exist_ok=True)\n             shutil.copy(resolved_module_file, submodule_path / module_file)\n             importlib.invalidate_caches()\n         for module_needed in modules_needed:\n-            module_needed = f\"{module_needed}.py\"\n+            module_needed = Path(module_file).parent / f\"{module_needed}.py\"\n             module_needed_file = os.path.join(pretrained_model_name_or_path, module_needed)\n             if not (submodule_path / module_needed).exists() or not filecmp.cmp(\n                 module_needed_file, str(submodule_path / module_needed)"
        }
    ],
    "stats": {
        "total": 13,
        "additions": 11,
        "deletions": 2
    }
}