{
    "author": "gante",
    "message": "[tests] remove tf/flax tests in `/generation` (#36235)",
    "sha": "55493f13906acaa6fc1b90601098c50c3d0cb6a5",
    "files": [
        {
            "sha": "bd5f8f648cbb5b607e7105d62b458bf8310de64f",
            "filename": "tests/generation/test_flax_logits_process.py",
            "status": "removed",
            "additions": 0,
            "deletions": 343,
            "changes": 343,
            "blob_url": "https://github.com/huggingface/transformers/blob/c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95/tests%2Fgeneration%2Ftest_flax_logits_process.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95/tests%2Fgeneration%2Ftest_flax_logits_process.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_flax_logits_process.py?ref=c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95",
            "patch": "@@ -1,343 +0,0 @@\n-# coding=utf-8\n-# Copyright 2021 The HuggingFace Team Inc.\n-#\n-# Licensed under the Apache License, Version 2.0 (the \"License\");\n-# you may not use this file except in compliance with the License.\n-# You may obtain a clone of the License at\n-#\n-#     http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing, software\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# See the License for the specific language governing permissions and\n-# limitations under the License.\n-\n-\n-import unittest\n-\n-import numpy as np\n-\n-from transformers import is_flax_available\n-from transformers.testing_utils import require_flax\n-\n-from ..test_modeling_flax_common import ids_tensor\n-\n-\n-if is_flax_available():\n-    import jax\n-    import jax.numpy as jnp\n-\n-    from transformers.generation import (\n-        FlaxForcedBOSTokenLogitsProcessor,\n-        FlaxForcedEOSTokenLogitsProcessor,\n-        FlaxLogitsProcessorList,\n-        FlaxMinLengthLogitsProcessor,\n-        FlaxNoRepeatNGramLogitsProcessor,\n-        FlaxTemperatureLogitsWarper,\n-        FlaxTopKLogitsWarper,\n-        FlaxTopPLogitsWarper,\n-    )\n-\n-\n-@require_flax\n-class LogitsProcessorTest(unittest.TestCase):\n-    def _get_uniform_logits(self, batch_size: int, length: int):\n-        scores = jnp.ones((batch_size, length)) / length\n-        return scores\n-\n-    def test_temperature_dist_warper(self):\n-        input_ids = None\n-        length = 20\n-\n-        scores = self._get_uniform_logits(batch_size=2, length=length)\n-\n-        # tweak scores to not be uniform anymore\n-        scores = scores.at[1, 5].set((1 / length) + 0.1)  # peak, 1st batch\n-        scores = scores.at[1, 10].set((1 / length) - 0.4)  # valley, 1st batch\n-\n-        # compute softmax\n-        probs = jax.nn.softmax(scores, axis=-1)\n-\n-        temp_dist_warper_sharper = FlaxTemperatureLogitsWarper(temperature=0.5)\n-        temp_dist_warper_smoother = FlaxTemperatureLogitsWarper(temperature=1.3)\n-\n-        warped_prob_sharp = jax.nn.softmax(temp_dist_warper_sharper(input_ids, scores.copy(), cur_len=None), axis=-1)\n-        warped_prob_smooth = jax.nn.softmax(temp_dist_warper_smoother(input_ids, scores.copy(), cur_len=None), axis=-1)\n-\n-        # uniform distribution stays uniform\n-        self.assertTrue(jnp.allclose(probs[0, :], warped_prob_sharp[0, :], atol=1e-3))\n-        self.assertTrue(jnp.allclose(probs[0, :], warped_prob_smooth[0, :], atol=1e-3))\n-\n-        # sharp peaks get higher, valleys get lower\n-        self.assertLess(probs[1, :].max(), warped_prob_sharp[1, :].max())\n-        self.assertGreater(probs[1, :].min(), warped_prob_sharp[1, :].min())\n-\n-        # smooth peaks get lower, valleys get higher\n-        self.assertGreater(probs[1, :].max(), warped_prob_smooth[1, :].max())\n-        self.assertLess(probs[1, :].min(), warped_prob_smooth[1, :].min())\n-\n-    def test_top_k_dist_warper(self):\n-        input_ids = None\n-        vocab_size = 10\n-        batch_size = 2\n-\n-        # create ramp distribution\n-        ramp_logits = np.broadcast_to(np.arange(vocab_size)[None, :], (batch_size, vocab_size)).copy()\n-        ramp_logits[1:, : vocab_size // 2] = ramp_logits[1:, : vocab_size // 2] + vocab_size\n-\n-        top_k_warp = FlaxTopKLogitsWarper(3)\n-\n-        scores = top_k_warp(input_ids, ramp_logits, cur_len=None)\n-\n-        # check that correct tokens are filtered\n-        self.assertListEqual(jnp.isinf(scores[0]).tolist(), 7 * [True] + 3 * [False])\n-        self.assertListEqual(jnp.isinf(scores[1]).tolist(), 2 * [True] + 3 * [False] + 5 * [True])\n-\n-        # check special case\n-        length = 5\n-        top_k_warp_safety_check = FlaxTopKLogitsWarper(top_k=1, filter_value=0.0, min_tokens_to_keep=3)\n-\n-        ramp_logits = np.broadcast_to(np.arange(length)[None, :], (batch_size, length)).copy()\n-        scores = top_k_warp_safety_check(input_ids, ramp_logits, cur_len=None)\n-\n-        # min_tokens overwrites k: 3 tokens are kept => 2 tokens are nullified\n-        self.assertListEqual((scores == 0.0).sum(axis=-1).tolist(), [2, 2])\n-\n-    def test_top_p_dist_warper(self):\n-        input_ids = None\n-        vocab_size = 10\n-        batch_size = 2\n-\n-        # create distribution and take log (inverse to Softmax as taken in TopPLogitsWarper)\n-        dist = np.log(np.array([[0.3, 0.1, 0.1, 0.5], [0.15, 0.3, 0.3, 0.25]]))\n-\n-        top_p_warp = FlaxTopPLogitsWarper(0.8)\n-        filtered_dist = np.exp(top_p_warp(input_ids, dist, cur_len=None))\n-\n-        # dist should be filtered to keep min num values so that sum is >= top_p\n-        # exp (-inf) => 0\n-        EXPECTED_FILTERED_DIST = np.array([[0.3, 0.0, 0.0, 0.5], [0.0, 0.3, 0.3, 0.25]])\n-        self.assertTrue(np.allclose(filtered_dist, EXPECTED_FILTERED_DIST, atol=1e-3))\n-\n-        # check edge cases with negative and extreme logits\n-        ramp_logits = np.broadcast_to(np.arange(vocab_size)[None, :], (batch_size, vocab_size)).copy() - (\n-            vocab_size // 2\n-        )\n-\n-        # make ramp_logits more extreme\n-        ramp_logits[1] = ramp_logits[1] * 100.0\n-\n-        # make sure at least 2 tokens are kept\n-        top_p_warp = FlaxTopPLogitsWarper(0.9, min_tokens_to_keep=2, filter_value=0.0)\n-        filtered_dist = top_p_warp(input_ids, ramp_logits, cur_len=None)\n-\n-        # first batch should keep three tokens, second batch would keep only 1, but due to `min_tokens_to_keep=2` keeps 2.\n-        self.assertListEqual((filtered_dist != 0.0).sum(axis=-1).tolist(), [3, 2])\n-\n-    def test_min_length_dist_processor(self):\n-        vocab_size = 20\n-        batch_size = 4\n-        eos_token_id = 0\n-\n-        min_dist_processor = FlaxMinLengthLogitsProcessor(min_length=10, eos_token_id=eos_token_id)\n-\n-        # check that min length is applied at length 5\n-        input_ids = ids_tensor((batch_size, 20), vocab_size=20)\n-        cur_len = 5\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores_before_min_length = min_dist_processor(input_ids, scores, cur_len=cur_len)\n-        self.assertListEqual(scores_before_min_length[:, eos_token_id].tolist(), 4 * [-float(\"inf\")])\n-\n-        # check that min length is not applied anymore at length 15\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        cur_len = 15\n-        scores_before_min_length = min_dist_processor(input_ids, scores, cur_len=cur_len)\n-        self.assertFalse(jnp.isinf(scores_before_min_length).any())\n-\n-    def test_forced_bos_token_logits_processor(self):\n-        vocab_size = 20\n-        batch_size = 4\n-        bos_token_id = 0\n-\n-        logits_processor = FlaxForcedBOSTokenLogitsProcessor(bos_token_id=bos_token_id)\n-\n-        # check that all scores are -inf except the bos_token_id score\n-        input_ids = ids_tensor((batch_size, 1), vocab_size=20)\n-        cur_len = 1\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len=cur_len)\n-        self.assertTrue(jnp.isneginf(scores[:, bos_token_id + 1 :]).all())\n-        self.assertListEqual(scores[:, bos_token_id].tolist(), 4 * [0])  # score for bos_token_id shold be zero\n-\n-        # check that bos_token_id is not forced if current length is greater than 1\n-        cur_len = 3\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len=cur_len)\n-        self.assertFalse(jnp.isinf(scores).any())\n-\n-    def test_forced_eos_token_logits_processor(self):\n-        vocab_size = 20\n-        batch_size = 4\n-        eos_token_id = 0\n-        max_length = 5\n-\n-        logits_processor = FlaxForcedEOSTokenLogitsProcessor(max_length=max_length, eos_token_id=eos_token_id)\n-\n-        # check that all scores are -inf except the eos_token_id when max_length is reached\n-        input_ids = ids_tensor((batch_size, 4), vocab_size=20)\n-        cur_len = 4\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len=cur_len)\n-        self.assertTrue(jnp.isneginf(scores[:, eos_token_id + 1 :]).all())\n-        self.assertListEqual(scores[:, eos_token_id].tolist(), 4 * [0])  # score for eos_token_id should be zero\n-\n-        # check that eos_token_id is not forced if max_length is not reached\n-        cur_len = 3\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len=cur_len)\n-        self.assertFalse(jnp.isinf(scores).any())\n-\n-    def test_no_repeat_ngram_dist_processor(self):\n-        vocab_size = 3\n-        batch_size = 2\n-\n-        cur_len = 4\n-        input_ids = np.array([[1, 1, 2, 1], [0, 1, 0, 1]], dtype=\"i4\")\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-\n-        no_repeat_proc_2_gram = FlaxNoRepeatNGramLogitsProcessor(2)\n-        no_repeat_proc_3_gram = FlaxNoRepeatNGramLogitsProcessor(3)\n-\n-        filtered_scores_2_gram = no_repeat_proc_2_gram(input_ids, scores, cur_len=cur_len)\n-        filtered_scores_3_gram = no_repeat_proc_3_gram(input_ids, scores, cur_len=cur_len)\n-\n-        # 2-gram would forbid 2nd and 3rd token (1,2) at 1st batch and 1st token (0) at 2nd batch\n-        self.assertListEqual(jnp.isinf(filtered_scores_2_gram).tolist(), [[False, True, True], [True, False, False]])\n-\n-        # 3-gram would forbid no token at 1st batch and 1st token (0) at 2nd batch\n-        self.assertListEqual(jnp.isinf(filtered_scores_3_gram).tolist(), [[False, False, False], [True, False, False]])\n-\n-    def test_processor_list(self):\n-        batch_size = 4\n-        sequence_length = 10\n-        vocab_size = 15\n-        eos_token_id = 2\n-        bos_token_id = 1\n-        max_length = 15\n-\n-        # dummy input_ids and scores\n-        input_ids = ids_tensor((batch_size, sequence_length), vocab_size)\n-        input_ids_comp = input_ids.copy()\n-\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores_comp = scores.copy()\n-\n-        # instantiate all dist processors\n-        temp_dist_warp = FlaxTemperatureLogitsWarper(temperature=0.5)\n-        top_k_warp = FlaxTopKLogitsWarper(3)\n-        top_p_warp = FlaxTopPLogitsWarper(0.8)\n-        no_repeat_proc = FlaxNoRepeatNGramLogitsProcessor(2)\n-\n-        # instantiate all logits processors\n-        min_dist_proc = FlaxMinLengthLogitsProcessor(min_length=10, eos_token_id=eos_token_id)\n-        bos_dist_proc = FlaxForcedBOSTokenLogitsProcessor(bos_token_id=bos_token_id)\n-        eos_dist_proc = FlaxForcedEOSTokenLogitsProcessor(max_length=max_length, eos_token_id=eos_token_id)\n-\n-        cur_len = 10\n-\n-        # no processor list\n-        scores = temp_dist_warp(input_ids, scores, cur_len=cur_len)\n-        scores = top_k_warp(input_ids, scores, cur_len=cur_len)\n-        scores = top_p_warp(input_ids, scores, cur_len=cur_len)\n-        scores = min_dist_proc(input_ids, scores, cur_len=cur_len)\n-        scores = bos_dist_proc(input_ids, scores, cur_len=cur_len)\n-        scores = eos_dist_proc(input_ids, scores, cur_len=cur_len)\n-        scores = no_repeat_proc(input_ids, scores, cur_len=cur_len)\n-\n-        # with processor list\n-        processor = FlaxLogitsProcessorList(\n-            [\n-                temp_dist_warp,\n-                top_k_warp,\n-                top_p_warp,\n-                min_dist_proc,\n-                bos_dist_proc,\n-                eos_dist_proc,\n-                no_repeat_proc,\n-            ]\n-        )\n-        scores_comp = processor(input_ids, scores_comp, cur_len=cur_len)\n-\n-        # scores should be equal\n-        self.assertTrue(jnp.allclose(scores, scores_comp, atol=1e-3))\n-\n-        # input_ids should never be changed\n-        self.assertListEqual(input_ids.tolist(), input_ids_comp.tolist())\n-\n-    def test_processor_list_jitted(self):\n-        batch_size = 4\n-        sequence_length = 10\n-        vocab_size = 15\n-        eos_token_id = 2\n-        bos_token_id = 1\n-        max_length = 15\n-\n-        # dummy input_ids and scores\n-        input_ids = ids_tensor((batch_size, sequence_length), vocab_size)\n-        input_ids_comp = input_ids.copy()\n-\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores_comp = scores.copy()\n-\n-        # instantiate all dist processors\n-        temp_dist_warp = FlaxTemperatureLogitsWarper(temperature=0.5)\n-        top_k_warp = FlaxTopKLogitsWarper(3)\n-        top_p_warp = FlaxTopPLogitsWarper(0.8)\n-        no_repeat_proc = FlaxNoRepeatNGramLogitsProcessor(2)\n-\n-        # instantiate all logits processors\n-        min_dist_proc = FlaxMinLengthLogitsProcessor(min_length=10, eos_token_id=eos_token_id)\n-        bos_dist_proc = FlaxForcedBOSTokenLogitsProcessor(bos_token_id=bos_token_id)\n-        eos_dist_proc = FlaxForcedEOSTokenLogitsProcessor(max_length=max_length, eos_token_id=eos_token_id)\n-\n-        cur_len = 10\n-\n-        # no processor list\n-        def run_no_processor_list(input_ids, scores, cur_len):\n-            scores = temp_dist_warp(input_ids, scores, cur_len=cur_len)\n-            scores = top_k_warp(input_ids, scores, cur_len=cur_len)\n-            scores = top_p_warp(input_ids, scores, cur_len=cur_len)\n-            scores = min_dist_proc(input_ids, scores, cur_len=cur_len)\n-            scores = bos_dist_proc(input_ids, scores, cur_len=cur_len)\n-            scores = eos_dist_proc(input_ids, scores, cur_len=cur_len)\n-            scores = no_repeat_proc(input_ids, scores, cur_len=cur_len)\n-            return scores\n-\n-        # with processor list\n-        def run_processor_list(input_ids, scores, cur_len):\n-            processor = FlaxLogitsProcessorList(\n-                [\n-                    temp_dist_warp,\n-                    top_k_warp,\n-                    top_p_warp,\n-                    min_dist_proc,\n-                    bos_dist_proc,\n-                    eos_dist_proc,\n-                    no_repeat_proc,\n-                ]\n-            )\n-            scores = processor(input_ids, scores, cur_len=cur_len)\n-            return scores\n-\n-        jitted_run_no_processor_list = jax.jit(run_no_processor_list)\n-        jitted_run_processor_list = jax.jit(run_processor_list)\n-\n-        scores = jitted_run_no_processor_list(input_ids, scores, cur_len)\n-        scores_comp = jitted_run_processor_list(input_ids, scores_comp, cur_len)\n-\n-        # scores should be equal\n-        self.assertTrue(jnp.allclose(scores, scores_comp, atol=1e-3))\n-\n-        # input_ids should never be changed\n-        self.assertListEqual(input_ids.tolist(), input_ids_comp.tolist())"
        },
        {
            "sha": "302617c6688def1e7a46dc1f9b8478071e701792",
            "filename": "tests/generation/test_flax_utils.py",
            "status": "removed",
            "additions": 0,
            "deletions": 313,
            "changes": 313,
            "blob_url": "https://github.com/huggingface/transformers/blob/c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95/tests%2Fgeneration%2Ftest_flax_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95/tests%2Fgeneration%2Ftest_flax_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_flax_utils.py?ref=c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95",
            "patch": "@@ -1,313 +0,0 @@\n-# Copyright 2021 The HuggingFace Team. All rights reserved.\n-#\n-# Licensed under the Apache License, Version 2.0 (the \"License\");\n-# you may not use this file except in compliance with the License.\n-# You may obtain a copy of the License at\n-#\n-#     http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing, software\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# See the License for the specific language governing permissions and\n-# limitations under the License.\n-\n-import random\n-import unittest\n-\n-import numpy as np\n-\n-import transformers\n-from transformers import is_flax_available, is_torch_available\n-from transformers.testing_utils import is_pt_flax_cross_test, require_flax\n-\n-\n-if is_flax_available():\n-    import os\n-\n-    import jax.numpy as jnp\n-    from jax import jit\n-\n-    from transformers import AutoTokenizer, FlaxAutoModelForCausalLM\n-    from transformers.modeling_flax_pytorch_utils import load_flax_weights_in_pytorch_model\n-\n-    os.environ[\"XLA_PYTHON_CLIENT_MEM_FRACTION\"] = \"0.12\"  # assumed parallelism: 8\n-\n-\n-if is_torch_available():\n-    import torch\n-\n-\n-def ids_tensor(shape, vocab_size, rng=None):\n-    \"\"\"Creates a random int32 tensor of the shape within the vocab size.\"\"\"\n-    if rng is None:\n-        rng = random.Random()\n-\n-    total_dims = 1\n-    for dim in shape:\n-        total_dims *= dim\n-\n-    values = []\n-    for _ in range(total_dims):\n-        values.append(rng.randint(0, vocab_size - 1))\n-\n-    output = np.array(values, dtype=jnp.int32).reshape(shape)\n-\n-    return output\n-\n-\n-def random_attention_mask(shape, rng=None):\n-    attn_mask = ids_tensor(shape, vocab_size=2, rng=rng)\n-    # make sure that at least one token is attended to for each batch\n-    attn_mask[:, -1] = 1\n-    return attn_mask\n-\n-\n-@require_flax\n-class FlaxGenerationTesterMixin:\n-    model_tester = None\n-\n-    def _get_input_ids_and_config(self):\n-        config, inputs = self.model_tester.prepare_config_and_inputs_for_common()\n-\n-        # cut to half length & take max batch_size 3\n-        max_batch_size = 2\n-        sequence_length = inputs[\"input_ids\"].shape[-1] // 2\n-        input_ids = inputs[\"input_ids\"][:max_batch_size, :sequence_length]\n-\n-        attention_mask = jnp.ones_like(input_ids)\n-        attention_mask = attention_mask[:max_batch_size, :sequence_length]\n-\n-        # generate max 5 tokens\n-        max_length = input_ids.shape[-1] + 5\n-        if config.eos_token_id is not None and config.pad_token_id is None:\n-            # hack to allow generate for models such as GPT2 as is done in `generate()`\n-            config.pad_token_id = config.eos_token_id\n-        return config, input_ids, attention_mask, max_length\n-\n-    @is_pt_flax_cross_test\n-    def test_greedy_generate_pt_fx(self):\n-        config, input_ids, _, max_length = self._get_input_ids_and_config()\n-        config.do_sample = False\n-        config.max_length = max_length\n-        config.decoder_start_token_id = 0\n-\n-        for model_class in self.all_generative_model_classes:\n-            flax_model = model_class(config)\n-\n-            pt_model_class_name = model_class.__name__[4:]  # Skip the \"Flax\" at the beginning\n-            pt_model_class = getattr(transformers, pt_model_class_name)\n-            pt_model = pt_model_class(config).eval()\n-            pt_model = load_flax_weights_in_pytorch_model(pt_model, flax_model.params)\n-\n-            # Generate max 5 tokens only otherwise seems to be numerical error accumulation\n-            pt_model.generation_config.max_length = 5\n-            flax_model.generation_config.max_length = 5\n-\n-            flax_generation_outputs = flax_model.generate(input_ids).sequences\n-            pt_generation_outputs = pt_model.generate(torch.tensor(input_ids, dtype=torch.long))\n-\n-            if flax_generation_outputs.shape[-1] > pt_generation_outputs.shape[-1]:\n-                flax_generation_outputs = flax_generation_outputs[:, : pt_generation_outputs.shape[-1]]\n-\n-            self.assertListEqual(pt_generation_outputs.numpy().tolist(), flax_generation_outputs.tolist())\n-\n-    def test_greedy_generate(self):\n-        config, input_ids, _, max_length = self._get_input_ids_and_config()\n-        config.do_sample = False\n-        config.max_length = max_length\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            generation_outputs = model.generate(input_ids).sequences\n-            self.assertEqual(generation_outputs.shape[-1], max_length)\n-\n-            jit_generate = jit(model.generate)\n-            jit_generation_outputs = jit_generate(input_ids).sequences\n-\n-            self.assertListEqual(generation_outputs.tolist(), jit_generation_outputs.tolist())\n-\n-    def test_sample_generate(self):\n-        config, input_ids, _, max_length = self._get_input_ids_and_config()\n-        config.do_sample = True\n-        config.max_length = max_length\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            generation_outputs = model.generate(input_ids).sequences\n-            self.assertEqual(generation_outputs.shape[-1], max_length)\n-\n-            jit_generate = jit(model.generate)\n-            jit_generation_outputs = jit_generate(input_ids).sequences\n-\n-            self.assertListEqual(generation_outputs.tolist(), jit_generation_outputs.tolist())\n-\n-    def test_beam_search_generate(self):\n-        config, input_ids, _, max_length = self._get_input_ids_and_config()\n-        config.do_sample = False\n-        config.max_length = max_length\n-        config.num_beams = 2\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            generation_outputs = model.generate(input_ids).sequences\n-            self.assertEqual(generation_outputs.shape[-1], max_length)\n-\n-            jit_generate = jit(model.generate)\n-            jit_generation_outputs = jit_generate(input_ids).sequences\n-\n-            self.assertListEqual(generation_outputs.tolist(), jit_generation_outputs.tolist())\n-\n-    def test_beam_search_generate_num_return_sequences(self):\n-        config, input_ids, _, max_length = self._get_input_ids_and_config()\n-        config.do_sample = False\n-        config.max_length = max_length\n-        config.num_beams = 2\n-        config.num_return_sequences = 2\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            generation_outputs = model.generate(input_ids).sequences\n-            self.assertEqual(generation_outputs.shape[0], input_ids.shape[0] * config.num_return_sequences)\n-\n-    def test_sample_generate_logits_warper(self):\n-        config, input_ids, _, max_length = self._get_input_ids_and_config()\n-        config.do_sample = True\n-        config.max_length = max_length\n-        config.temperature = 0.8\n-        config.top_k = 10\n-        config.top_p = 0.3\n-        config.min_length = 1\n-        config.forced_bos_token_id = 8\n-        config.forced_eos_token_id = 9\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            generation_outputs = model.generate(input_ids).sequences\n-            self.assertEqual(generation_outputs.shape[-1], max_length)\n-\n-            jit_generate = jit(model.generate)\n-            jit_generation_outputs = jit_generate(input_ids).sequences\n-\n-            self.assertListEqual(generation_outputs.tolist(), jit_generation_outputs.tolist())\n-\n-    def test_greedy_generate_logits_warper(self):\n-        config, input_ids, _, max_length = self._get_input_ids_and_config()\n-        config.max_length = max_length\n-        config.min_length = 1\n-        config.forced_bos_token_id = 8\n-        config.forced_eos_token_id = 9\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            generation_outputs = model.generate(input_ids).sequences\n-            self.assertEqual(generation_outputs.shape[-1], max_length)\n-\n-            jit_generate = jit(model.generate)\n-            jit_generation_outputs = jit_generate(input_ids).sequences\n-\n-            self.assertListEqual(generation_outputs.tolist(), jit_generation_outputs.tolist())\n-\n-    def test_beam_search_generate_logits_warper(self):\n-        config, input_ids, _, max_length = self._get_input_ids_and_config()\n-        config.max_length = max_length\n-        config.num_beams = 2\n-        config.min_length = 1\n-        config.forced_bos_token_id = 8\n-        config.forced_eos_token_id = 9\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            generation_outputs = model.generate(input_ids).sequences\n-            self.assertEqual(generation_outputs.shape[-1], max_length)\n-\n-            jit_generate = jit(model.generate)\n-            jit_generation_outputs = jit_generate(input_ids).sequences\n-\n-            self.assertListEqual(generation_outputs.tolist(), jit_generation_outputs.tolist())\n-\n-    def test_greedy_generate_attn_mask(self):\n-        config, input_ids, attention_mask, max_length = self._get_input_ids_and_config()\n-\n-        # pad attention mask on the left\n-        attention_mask = attention_mask.at[(0, 0)].set(0)\n-\n-        config.do_sample = False\n-        config.max_length = max_length\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            generation_outputs = model.generate(input_ids, attention_mask=attention_mask).sequences\n-            self.assertEqual(generation_outputs.shape[-1], max_length)\n-\n-            jit_generate = jit(model.generate)\n-            jit_generation_outputs = jit_generate(input_ids, attention_mask=attention_mask).sequences\n-\n-            self.assertListEqual(generation_outputs.tolist(), jit_generation_outputs.tolist())\n-\n-    def test_sample_generate_attn_mask(self):\n-        config, input_ids, attention_mask, max_length = self._get_input_ids_and_config()\n-\n-        # pad attention mask on the left\n-        attention_mask = attention_mask.at[(0, 0)].set(0)\n-\n-        config.do_sample = True\n-        config.max_length = max_length\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            generation_outputs = model.generate(input_ids, attention_mask=attention_mask).sequences\n-            self.assertEqual(generation_outputs.shape[-1], max_length)\n-\n-            jit_generate = jit(model.generate)\n-            jit_generation_outputs = jit_generate(input_ids, attention_mask=attention_mask).sequences\n-\n-            self.assertListEqual(generation_outputs.tolist(), jit_generation_outputs.tolist())\n-\n-    def test_beam_search_generate_attn_mask(self):\n-        config, input_ids, attention_mask, max_length = self._get_input_ids_and_config()\n-\n-        # pad attention mask on the left\n-        attention_mask = attention_mask.at[(0, 0)].set(0)\n-\n-        config.num_beams = 2\n-        config.max_length = max_length\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            generation_outputs = model.generate(input_ids, attention_mask=attention_mask).sequences\n-            self.assertEqual(generation_outputs.shape[-1], max_length)\n-\n-            jit_generate = jit(model.generate)\n-            jit_generation_outputs = jit_generate(input_ids, attention_mask=attention_mask).sequences\n-\n-            self.assertListEqual(generation_outputs.tolist(), jit_generation_outputs.tolist())\n-\n-\n-@require_flax\n-class FlaxGenerationIntegrationTests(unittest.TestCase):\n-    def test_validate_generation_inputs(self):\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-bert\")\n-        model = FlaxAutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-bert-flax-only\")\n-\n-        encoder_input_str = \"Hello world\"\n-        input_ids = tokenizer(encoder_input_str, return_tensors=\"np\").input_ids\n-\n-        # typos are quickly detected (the correct argument is `do_sample`)\n-        with self.assertRaisesRegex(ValueError, \"do_samples\"):\n-            model.generate(input_ids, do_samples=True)\n-\n-        # arbitrary arguments that will not be used anywhere are also not accepted\n-        with self.assertRaisesRegex(ValueError, \"foo\"):\n-            fake_model_kwargs = {\"foo\": \"bar\"}\n-            model.generate(input_ids, **fake_model_kwargs)"
        },
        {
            "sha": "634824c2b38ea01c85e88adef19c485fcef33623",
            "filename": "tests/generation/test_framework_agnostic.py",
            "status": "removed",
            "additions": 0,
            "deletions": 688,
            "changes": 688,
            "blob_url": "https://github.com/huggingface/transformers/blob/c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95/tests%2Fgeneration%2Ftest_framework_agnostic.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95/tests%2Fgeneration%2Ftest_framework_agnostic.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_framework_agnostic.py?ref=c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95",
            "patch": "@@ -1,688 +0,0 @@\n-\"\"\"\n-Framework agnostic tests for generate()-related methods.\n-\"\"\"\n-\n-import numpy as np\n-\n-from transformers import AutoTokenizer\n-from transformers.testing_utils import slow, torch_device\n-\n-\n-class GenerationIntegrationTestsMixin:\n-    # To be populated by the child classes\n-    framework_dependent_parameters = {\n-        \"AutoModelForCausalLM\": None,\n-        \"AutoModelForSpeechSeq2Seq\": None,\n-        \"AutoModelForSeq2SeqLM\": None,\n-        \"AutoModelForVision2Seq\": None,\n-        \"LogitsProcessorList\": None,\n-        \"MinLengthLogitsProcessor\": None,\n-        \"create_tensor_fn\": None,\n-        \"floats_tensor\": None,\n-        \"return_tensors\": None,\n-        \"set_seed\": None,\n-    }\n-\n-    def test_validate_generation_inputs(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSeq2SeqLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        create_tensor_fn = self.framework_dependent_parameters[\"create_tensor_fn\"]\n-\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-t5\")\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-t5\")\n-\n-        encoder_input_str = \"Hello world\"\n-        input_ids = tokenizer(encoder_input_str, return_tensors=return_tensors).input_ids\n-\n-        # typos are quickly detected (the correct argument is `do_sample`)\n-        with self.assertRaisesRegex(ValueError, \"do_samples\"):\n-            model.generate(input_ids, do_samples=True)\n-\n-        # arbitrary arguments that will not be used anywhere are also not accepted\n-        with self.assertRaisesRegex(ValueError, \"foo\"):\n-            fake_model_kwargs = {\"foo\": \"bar\"}\n-            model.generate(input_ids, **fake_model_kwargs)\n-\n-        # however, valid model_kwargs are accepted\n-        valid_model_kwargs = {\"attention_mask\": create_tensor_fn(np.zeros_like(input_ids))}\n-        model.generate(input_ids, **valid_model_kwargs)\n-\n-    def test_custom_logits_processor(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSeq2SeqLM\"]\n-        logits_processor_list_cls = self.framework_dependent_parameters[\"LogitsProcessorList\"]\n-        min_length_logits_processor_cls = self.framework_dependent_parameters[\"MinLengthLogitsProcessor\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-\n-        bart_tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-        article = \"\"\"Justin Timberlake and Jessica Biel, welcome to parenthood.\"\"\"\n-        bart_model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-bart\", min_length=1)\n-        input_ids = bart_tokenizer(article, return_tensors=return_tensors).input_ids\n-\n-        logits_processor = logits_processor_list_cls()\n-        logits_processor.append(min_length_logits_processor_cls(min_length=10, eos_token_id=0))\n-        # it should not be allowed to both define `min_length` via config and `logits_processor` list\n-        with self.assertRaises(ValueError):\n-            bart_model.generate(input_ids, logits_processor=logits_processor)\n-\n-        bart_model.config.min_length = None\n-        bart_model.generate(input_ids, logits_processor=logits_processor)\n-\n-    def test_max_new_tokens_encoder_decoder(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSeq2SeqLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        article = \"\"\"Justin Timberlake and Jessica Biel, welcome to parenthood.\"\"\"\n-        bart_tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-\n-        bart_model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-        input_ids = bart_tokenizer(article, return_tensors=return_tensors).input_ids\n-        if is_pt:\n-            bart_model = bart_model.to(torch_device)\n-            input_ids = input_ids.to(torch_device)\n-\n-        self.assertEqual(list(input_ids.shape), [1, 29])\n-\n-        max_new_tokens = 3\n-        bart_model.config.max_length = 20\n-        bart_model.config.eos_token_id = None\n-\n-        # Encoder decoder call\n-        outputs = bart_model.generate(input_ids, max_new_tokens=max_new_tokens)\n-        # 1 BOS + 3 new tokens\n-        self.assertEqual(list(outputs.shape), [1, 4])\n-\n-        # Decoder only call\n-        outputs = bart_model.generate(decoder_input_ids=input_ids, max_new_tokens=max_new_tokens)\n-        # 1 BOS + 29 (input length) + 3 new tokens\n-        self.assertEqual(list(outputs.shape), [1, 33])\n-\n-        # Encoder decoder call > 20\n-        outputs = bart_model.generate(max_new_tokens=max_new_tokens + 20)\n-\n-        # 1 BOS + 20 + 3 new tokens\n-        self.assertEqual(list(outputs.shape), [1, 24])\n-\n-    def test_max_new_tokens_decoder_only(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForCausalLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        article = \"\"\"Justin Timberlake.\"\"\"\n-        gpt2_tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-\n-        gpt2_model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        input_ids = gpt2_tokenizer(article, return_tensors=return_tensors).input_ids\n-        if is_pt:\n-            gpt2_model = gpt2_model.to(torch_device)\n-            input_ids = input_ids.to(torch_device)\n-\n-        self.assertEqual(list(input_ids.shape), [1, 9])\n-\n-        max_new_tokens = 3\n-        gpt2_model.config.max_length = 20\n-\n-        # call < 20\n-        outputs = gpt2_model.generate(input_ids, max_new_tokens=max_new_tokens)\n-\n-        # 9 input_ids + 3 new tokens\n-        self.assertEqual(list(outputs.shape), [1, 12])\n-\n-        # call > 20\n-        outputs = gpt2_model.generate(max_new_tokens=max_new_tokens + 20)\n-\n-        # 1 BOS token + 23 new tokens\n-        self.assertEqual(list(outputs.shape), [1, 24])\n-\n-    def test_encoder_decoder_generate_with_inputs_embeds(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSeq2SeqLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-\n-        article = \"\"\"Justin Timberlake and Jessica Biel, welcome to parenthood.\"\"\"\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-bart\", max_length=5)\n-        model.config.eos_token_id = None\n-        input_ids = tokenizer(article, return_tensors=return_tensors).input_ids\n-\n-        inputs_embeds = model.get_input_embeddings()(input_ids)\n-\n-        output_sequences = model.generate(inputs_embeds=inputs_embeds)\n-\n-        # make sure model generated correctly until `max_length`\n-        self.assertEqual(output_sequences.shape, (1, 5))\n-\n-    def test_transition_scores_greedy_search(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForCausalLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        articles = [\"Justin Timberlake\", \"Michael Phelps\"]\n-        tokenizer = AutoTokenizer.from_pretrained(\"distilbert/distilgpt2\", padding_side=\"left\")\n-        tokenizer.pad_token = tokenizer.eos_token\n-\n-        model = model_cls.from_pretrained(\"distilbert/distilgpt2\")\n-        model.generation_config.eos_token_id = None\n-        input_ids = tokenizer(articles, return_tensors=return_tensors, padding=True).input_ids\n-        if is_pt:\n-            model = model.to(torch_device)\n-            input_ids = input_ids.to(torch_device)\n-\n-        outputs = model.generate(\n-            input_ids=input_ids,\n-            max_new_tokens=5,\n-            pad_token_id=tokenizer.eos_token_id,\n-            return_dict_in_generate=True,\n-            output_scores=True,\n-        )\n-\n-        transition_scores = model.compute_transition_scores(outputs.sequences, outputs.scores)\n-        if is_pt:\n-            transition_scores = transition_scores.cpu().numpy()\n-\n-        expected_scores = np.array(\n-            [\n-                [-57.8844, -60.45698, -70.16364, -65.50791, -66.35648],\n-                [-54.417572, -60.216614, -62.661243, -58.621933, -58.298683],\n-            ]\n-        )\n-        self.assertTrue(np.allclose(transition_scores, expected_scores, atol=1e-3))\n-\n-    def test_transition_scores_greedy_search_normalized(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForCausalLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        articles = [\"Justin Timberlake\", \"Michael Phelps\"]\n-        tokenizer = AutoTokenizer.from_pretrained(\"distilbert/distilgpt2\", padding_side=\"left\")\n-        tokenizer.pad_token = tokenizer.eos_token\n-\n-        model = model_cls.from_pretrained(\"distilbert/distilgpt2\")\n-        model.generation_config.eos_token_id = None\n-        input_ids = tokenizer(articles, return_tensors=return_tensors, padding=True).input_ids\n-        if is_pt:\n-            model = model.to(torch_device)\n-            input_ids = input_ids.to(torch_device)\n-\n-        outputs = model.generate(\n-            input_ids=input_ids,\n-            max_new_tokens=5,\n-            pad_token_id=tokenizer.eos_token_id,\n-            return_dict_in_generate=True,\n-            output_scores=True,\n-        )\n-\n-        transition_scores = model.compute_transition_scores(outputs.sequences, outputs.scores, normalize_logits=True)\n-        if is_pt:\n-            transition_scores = transition_scores.cpu().numpy()\n-\n-        expected_scores = np.array(\n-            [\n-                [-2.538938, -2.2694316, -2.1580915, -1.572299, -2.6719835],\n-                [-1.8826028, -2.2461371, -1.7556462, -2.9644494, -1.7996008],\n-            ]\n-        )\n-        self.assertTrue(np.allclose(transition_scores, expected_scores, atol=1e-3))\n-\n-    def test_transition_scores_beam_search_encoder_decoder(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSeq2SeqLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        articles = [\n-            \"Justin Timberlake and Jessica Biel, welcome to parenthood.\",\n-            \"Michael Phelps is arguably the most decorated Olympian of all time.\",\n-        ]\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-\n-        model = model_cls.from_pretrained(\n-            \"hf-internal-testing/tiny-random-bart\",\n-            max_length=10,\n-            num_beams=4,\n-            num_return_sequences=2,\n-            eos_token_id=None,\n-            return_dict_in_generate=True,\n-            output_scores=True,\n-            length_penalty=0.0,\n-        )\n-        input_ids = tokenizer(articles, return_tensors=return_tensors, padding=True).input_ids\n-        if is_pt:\n-            model = model.to(torch_device)\n-            input_ids = input_ids.to(torch_device)\n-\n-        outputs = model.generate(input_ids=input_ids)\n-\n-        transition_scores = model.compute_transition_scores(outputs.sequences, outputs.scores, outputs.beam_indices)\n-        if is_pt:\n-            transition_scores = transition_scores.cpu().numpy()\n-            outputs.sequences_scores = outputs.sequences_scores.cpu().numpy()\n-\n-        self.assertTrue(np.allclose(np.sum(transition_scores, axis=-1), outputs.sequences_scores, atol=1e-3))\n-\n-    def test_transition_scores_beam_search_encoder_decoder_with_eos(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSeq2SeqLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        articles = [\n-            \"Justin Timberlake and Jessica Biel, welcome to parenthood.\",\n-            \"Michael Phelps is arguably the most decorated Olympian of all time.\",\n-        ]\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-\n-        model = model_cls.from_pretrained(\n-            \"hf-internal-testing/tiny-random-bart\",\n-            max_length=10,\n-            num_beams=4,\n-            num_return_sequences=2,\n-            return_dict_in_generate=True,\n-            output_scores=True,\n-            length_penalty=0.0,\n-        )\n-        input_ids = tokenizer(articles, return_tensors=return_tensors, padding=True).input_ids\n-        if is_pt:\n-            model = model.to(torch_device)\n-            input_ids = input_ids.to(torch_device)\n-\n-        outputs = model.generate(input_ids=input_ids)\n-\n-        transition_scores = model.compute_transition_scores(outputs.sequences, outputs.scores, outputs.beam_indices)\n-        if is_pt:\n-            transition_scores = transition_scores.cpu().numpy()\n-            outputs.sequences_scores = outputs.sequences_scores.cpu().numpy()\n-\n-        self.assertTrue(np.allclose(np.sum(transition_scores, axis=-1), outputs.sequences_scores, atol=1e-3))\n-\n-    def test_transition_scores_beam_search_decoder_only(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForCausalLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        articles = [\n-            \"Justin Timberlake\",\n-            \"Michael Phelps\",\n-        ]\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        tokenizer.pad_token = tokenizer.eos_token\n-\n-        model = model_cls.from_pretrained(\n-            \"hf-internal-testing/tiny-random-gpt2\",\n-            max_length=10,\n-            num_beams=4,\n-            num_return_sequences=2,\n-            pad_token_id=tokenizer.eos_token_id,\n-            eos_token_id=None,\n-            return_dict_in_generate=True,\n-            output_scores=True,\n-            length_penalty=0.0,\n-        )\n-        input_ids = tokenizer(articles, return_tensors=return_tensors, padding=True).input_ids\n-        if is_pt:\n-            model = model.to(torch_device)\n-            input_ids = input_ids.to(torch_device)\n-\n-        outputs = model.generate(input_ids=input_ids)\n-\n-        transition_scores = model.compute_transition_scores(outputs.sequences, outputs.scores, outputs.beam_indices)\n-        if is_pt:\n-            transition_scores = transition_scores.cpu().numpy()\n-            outputs.sequences_scores = outputs.sequences_scores.cpu().numpy()\n-\n-        self.assertTrue(np.allclose(np.sum(transition_scores, axis=-1), outputs.sequences_scores, atol=1e-3))\n-\n-    def test_transition_scores_beam_sample_encoder_decoder(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSeq2SeqLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        articles = [\n-            \"Justin Timberlake and Jessica Biel, welcome to parenthood.\",\n-            \"Michael Phelps is arguably the most decorated Olympian of all time.\",\n-        ]\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-\n-        model = model_cls.from_pretrained(\n-            \"hf-internal-testing/tiny-random-bart\",\n-            do_sample=True,\n-            max_length=10,\n-            num_beams=4,\n-            num_return_sequences=2,\n-            eos_token_id=None,\n-            return_dict_in_generate=True,\n-            output_scores=True,\n-            length_penalty=0.0,\n-        )\n-        input_ids = tokenizer(articles, return_tensors=return_tensors, padding=True).input_ids\n-        if is_pt:\n-            model = model.to(torch_device)\n-            input_ids = input_ids.to(torch_device)\n-\n-        outputs = model.generate(input_ids=input_ids)\n-\n-        transition_scores = model.compute_transition_scores(outputs.sequences, outputs.scores, outputs.beam_indices)\n-        if is_pt:\n-            transition_scores = transition_scores.cpu().numpy()\n-            outputs.sequences_scores = outputs.sequences_scores.cpu().numpy()\n-\n-        self.assertTrue(np.allclose(np.sum(transition_scores, axis=-1), outputs.sequences_scores, atol=1e-3))\n-\n-    @slow\n-    def test_transition_scores_early_stopping(self):\n-        # This is an aggressive test that makes sure that `beam_search's`\n-        # transition scores are computed correctly for varying `num_return_sequences`, `num_beams` and `batch_size > 1`\n-        # 2 x input_ids for \"question: How are you? \\n context: I had a long day, \"\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSeq2SeqLM\"]\n-        create_tensor_fn = self.framework_dependent_parameters[\"create_tensor_fn\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        input_ids = create_tensor_fn(2 * [[822, 10, 571, 33, 25, 58, 2625, 10, 27, 141, 3, 9, 307, 239, 6, 1]])\n-        model = model_cls.from_pretrained(\"google-t5/t5-small\")\n-        if is_pt:\n-            model = model.to(torch_device)\n-            input_ids = input_ids.to(torch_device)\n-\n-        outputs = model.generate(\n-            input_ids,\n-            max_length=10,\n-            return_dict_in_generate=True,\n-            output_scores=True,\n-            forced_eos_token_id=model.config.eos_token_id,\n-            num_beams=4,\n-            do_sample=False,\n-            num_return_sequences=3,\n-            length_penalty=0.0,\n-        )\n-\n-        transition_scores = model.compute_transition_scores(\n-            sequences=outputs.sequences, scores=outputs.scores, beam_indices=outputs.beam_indices\n-        )\n-        if is_pt:\n-            transition_scores = transition_scores.cpu().numpy()\n-            outputs.sequences_scores = outputs.sequences_scores.cpu().numpy()\n-\n-        self.assertTrue(np.allclose(np.sum(transition_scores, axis=-1), outputs.sequences_scores))\n-\n-    def test_encoder_decoder_generate_attention_mask(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSeq2SeqLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        articles = [\"Timberlake\", \"Jessica Biel, welcome to parenthood among other things\"]\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-        # need extreme generation values here to force this test\n-        # to fail when `attention_mask` is not correctly treated in generate\n-        model = model_cls.from_pretrained(\n-            \"hf-internal-testing/tiny-random-bart\", max_length=50, num_beams=5, num_return_sequences=5\n-        )\n-        model.config.eos_token_id = None\n-        input_ids = tokenizer(articles[0], return_tensors=return_tensors).input_ids\n-        input_ids_batched = tokenizer(articles, padding=True, return_tensors=return_tensors).input_ids\n-        if is_pt:\n-            model = model.to(torch_device)\n-            input_ids = input_ids.to(torch_device)\n-            input_ids_batched = input_ids_batched.to(torch_device)\n-\n-        output_sequences_batched = model.generate(\n-            input_ids=input_ids_batched, return_dict_in_generate=True, output_scores=True\n-        )\n-        output_sequences = model.generate(input_ids=input_ids, return_dict_in_generate=True, output_scores=True)\n-\n-        batched_out = output_sequences_batched.sequences_scores\n-        out = output_sequences.sequences_scores\n-        if is_pt:\n-            batched_out = batched_out.cpu().numpy()\n-            out = out.cpu().numpy()\n-\n-        diff = np.abs(np.sum(batched_out[:5]) - np.sum(out))\n-        self.assertTrue(diff < 1e-4)\n-\n-    def test_generate_input_ids_as_kwarg(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForCausalLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        article = \"\"\"I need input_ids to generate\"\"\"\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\", max_length=15)\n-        input_ids = tokenizer(article, return_tensors=return_tensors).input_ids\n-        if is_pt:\n-            model = model.to(torch_device)\n-            input_ids = input_ids.to(torch_device)\n-\n-        output_sequences_kwargs = model.generate(input_ids=input_ids)\n-        output_sequences = model.generate(input_ids)\n-        if is_pt:\n-            output_sequences_kwargs = output_sequences_kwargs.cpu().numpy()\n-            output_sequences = output_sequences.cpu().numpy()\n-\n-        self.assertTrue(np.array_equal(output_sequences, output_sequences_kwargs))\n-        self.assertEqual(output_sequences.shape, (1, 15))\n-\n-    def test_generate_input_ids_as_encoder_kwarg(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSeq2SeqLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        article = \"\"\"Justin Timberlake and Jessica Biel, welcome to parenthood.\"\"\"\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-bart\", max_length=5)\n-        model.config.eos_token_id = None\n-        input_ids = tokenizer(article, return_tensors=return_tensors).input_ids\n-        if is_pt:\n-            model = model.to(torch_device)\n-            input_ids = input_ids.to(torch_device)\n-\n-        output_sequences_kwargs = model.generate(input_ids=input_ids)\n-        output_sequences = model.generate(input_ids)\n-        if is_pt:\n-            output_sequences_kwargs = output_sequences_kwargs.cpu().numpy()\n-            output_sequences = output_sequences.cpu().numpy()\n-\n-        self.assertTrue(np.array_equal(output_sequences, output_sequences_kwargs))\n-        self.assertEqual(output_sequences.shape, (1, 5))\n-\n-    def test_generate_inputs_and_encoder_kwargs(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForCausalLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-\n-        article = \"\"\"I need input_ids to generate\"\"\"\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\", max_length=10)\n-        input_ids = tokenizer(article, return_tensors=return_tensors).input_ids\n-        with self.assertRaises(ValueError):\n-            model.generate(input_ids, input_ids=input_ids)\n-\n-    def test_generate_too_many_encoder_kwargs(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSeq2SeqLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-\n-        article = \"\"\"I need input_ids to generate\"\"\"\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-bart\", max_length=10)\n-        input_ids = tokenizer(article, return_tensors=return_tensors).input_ids\n-        with self.assertRaises(ValueError):\n-            model.generate(input_ids=input_ids, inputs_embeds=input_ids)\n-\n-    def test_generate_input_features_as_encoder_kwarg(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSpeechSeq2Seq\"]\n-        floats_tensor = self.framework_dependent_parameters[\"floats_tensor\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        input_features = floats_tensor((3, 80, 60))\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-WhisperForConditionalGeneration\")\n-        if is_pt:\n-            input_features.to(torch_device)\n-            model = model.to(torch_device)\n-\n-        output_sequences_kwargs = model.generate(input_features=input_features, max_length=5)\n-        output_sequences = model.generate(input_features, max_length=5)\n-        if is_pt:\n-            output_sequences_kwargs = output_sequences_kwargs.cpu().numpy()\n-            output_sequences = output_sequences.cpu().numpy()\n-\n-        self.assertTrue(np.array_equal(output_sequences, output_sequences_kwargs))\n-        self.assertEqual(output_sequences.shape, (3, 5))\n-\n-    def test_generate_pixel_values_as_encoder_kwarg(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForVision2Seq\"]\n-        floats_tensor = self.framework_dependent_parameters[\"floats_tensor\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        pixel_values = floats_tensor((2, 3, 30, 30))\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-VisionEncoderDecoderModel-vit-gpt2\")\n-        model.generation_config.eos_token_id = None\n-        if is_pt:\n-            pixel_values = pixel_values.to(torch_device)\n-            model = model.to(torch_device)\n-\n-        output_sequences_kwargs = model.generate(pixel_values=pixel_values, max_length=5)\n-        output_sequences = model.generate(pixel_values, max_length=5)\n-        if is_pt:\n-            output_sequences_kwargs = output_sequences_kwargs.cpu().numpy()\n-            output_sequences = output_sequences.cpu().numpy()\n-\n-        self.assertTrue(np.array_equal(output_sequences, output_sequences_kwargs))\n-        self.assertEqual(output_sequences.shape, (2, 5))\n-\n-    def test_generate_encoder_outputs_attention_mask(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForSpeechSeq2Seq\"]\n-        floats_tensor = self.framework_dependent_parameters[\"floats_tensor\"]\n-        create_tensor_fn = self.framework_dependent_parameters[\"create_tensor_fn\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        input_features = floats_tensor((3, 80, 60))\n-        attention_mask = create_tensor_fn(np.ones(input_features.shape))\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-WhisperForConditionalGeneration\")\n-        if is_pt:\n-            input_features = input_features.to(torch_device)\n-            attention_mask = attention_mask.to(torch_device)\n-            model = model.to(torch_device)\n-\n-        encoder = model.get_encoder()\n-        encoder_outputs = encoder(input_features)\n-\n-        output_sequences_no_mask = model.generate(encoder_outputs=encoder_outputs)\n-        output_sequences_with_mask = model.generate(encoder_outputs=encoder_outputs, attention_mask=attention_mask)\n-        if is_pt:\n-            output_sequences_no_mask = output_sequences_no_mask.cpu().numpy()\n-            output_sequences_with_mask = output_sequences_with_mask.cpu().numpy()\n-\n-        self.assertTrue(np.array_equal(output_sequences_no_mask, output_sequences_with_mask))\n-\n-    def test_eos_token_id_int_and_list_greedy_search(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForCausalLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        generation_kwargs = {\n-            \"do_sample\": False,\n-            \"num_beams\": 1,\n-        }\n-        expectation = 13\n-\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        text = \"\"\"Hello, my dog is cute and\"\"\"\n-        tokens = tokenizer(text, return_tensors=return_tensors)\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        if is_pt:\n-            model = model.to(torch_device)\n-            tokens = tokens.to(torch_device)\n-\n-        eos_token_id = 873\n-        generated_tokens = model.generate(**tokens, eos_token_id=eos_token_id, **generation_kwargs)\n-        self.assertTrue(expectation == len(generated_tokens[0]))\n-\n-        eos_token_id = [873, 198]\n-        generated_tokens = model.generate(**tokens, eos_token_id=eos_token_id, **generation_kwargs)\n-        self.assertTrue(expectation == len(generated_tokens[0]))\n-\n-    def test_eos_token_id_int_and_list_contrastive_search(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForCausalLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        generation_kwargs = {\n-            \"do_sample\": False,\n-            \"num_beams\": 1,\n-            \"penalty_alpha\": 0.6,\n-            \"top_k\": 4,\n-        }\n-        expectation = 17\n-\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        text = \"\"\"Hello, my dog is cute and\"\"\"\n-        tokens = tokenizer(text, return_tensors=return_tensors)\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        if is_pt:\n-            model = model.to(torch_device)\n-            tokens = tokens.to(torch_device)\n-\n-        eos_token_id = 225\n-        generated_tokens = model.generate(**tokens, eos_token_id=eos_token_id, **generation_kwargs)\n-        self.assertTrue(expectation == len(generated_tokens[0]))\n-\n-        eos_token_id = [225, 198]\n-        generated_tokens = model.generate(**tokens, eos_token_id=eos_token_id, **generation_kwargs)\n-        self.assertTrue(expectation == len(generated_tokens[0]))\n-\n-    def test_eos_token_id_int_and_list_beam_search(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForCausalLM\"]\n-        return_tensors = self.framework_dependent_parameters[\"return_tensors\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        generation_kwargs = {\n-            \"do_sample\": False,\n-            \"num_beams\": 3,\n-        }\n-        expectation = 13\n-\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        text = \"\"\"Hello, my dog is cute and\"\"\"\n-        tokens = tokenizer(text, return_tensors=return_tensors)\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        if is_pt:\n-            model = model.to(torch_device)\n-            tokens = tokens.to(torch_device)\n-\n-        eos_token_id = 873\n-        generated_tokens = model.generate(**tokens, eos_token_id=eos_token_id, **generation_kwargs)\n-        unpadded_correct_condition = expectation == len(generated_tokens[0])\n-        padded_correct_condition = expectation < len(generated_tokens[0]) and all(\n-            token == model.config.pad_token_id for token in generated_tokens[0][expectation:]\n-        )\n-        self.assertTrue(unpadded_correct_condition or padded_correct_condition)\n-\n-        eos_token_id = [873, 198]\n-        generated_tokens = model.generate(**tokens, eos_token_id=eos_token_id, **generation_kwargs)\n-        unpadded_correct_condition = expectation == len(generated_tokens[0])\n-        padded_correct_condition = expectation < len(generated_tokens[0]) and all(\n-            token == model.config.pad_token_id for token in generated_tokens[0][expectation:]\n-        )\n-        self.assertTrue(unpadded_correct_condition or padded_correct_condition)\n-\n-    def test_generate_vision2text_conditioning(self):\n-        model_cls = self.framework_dependent_parameters[\"AutoModelForVision2Seq\"]\n-        floats_tensor = self.framework_dependent_parameters[\"floats_tensor\"]\n-        create_tensor_fn = self.framework_dependent_parameters[\"create_tensor_fn\"]\n-        is_pt = not model_cls.__name__.startswith(\"TF\")\n-\n-        pixel_values = floats_tensor((2, 3, 30, 30))\n-        conditioning_input = create_tensor_fn([[10], [10]])  # this should be the 2nd output token, after the BOS token\n-        model = model_cls.from_pretrained(\"hf-internal-testing/tiny-random-VisionEncoderDecoderModel-vit-gpt2\")\n-        if is_pt:\n-            pixel_values = pixel_values.to(torch_device)\n-            model = model.to(torch_device)\n-            conditioning_input = conditioning_input.to(torch_device)\n-\n-        # we can condition on decoder_input_ids (expected decoder input) and input_ids (which we pipe internally as\n-        # decoder_input_ids, if the encoder is not a model with text input)\n-        output_sequences_decoder_input_ids = model.generate(\n-            pixel_values, max_length=5, decoder_input_ids=conditioning_input\n-        )\n-        output_sequences_input_ids = model.generate(pixel_values, max_length=5, input_ids=conditioning_input)\n-        if is_pt:\n-            output_sequences_decoder_input_ids = output_sequences_decoder_input_ids.cpu().numpy()\n-            output_sequences_input_ids = output_sequences_input_ids.cpu().numpy()\n-            conditioning_input = conditioning_input.cpu().numpy()\n-\n-        self.assertTrue(np.array_equal(output_sequences_decoder_input_ids, output_sequences_input_ids))\n-        self.assertTrue(np.array_equal(output_sequences_decoder_input_ids[:, 1:2], conditioning_input))"
        },
        {
            "sha": "f06f5695b1cef88a01ada684761aa06bd0f7919c",
            "filename": "tests/generation/test_tf_logits_process.py",
            "status": "removed",
            "additions": 0,
            "deletions": 487,
            "changes": 487,
            "blob_url": "https://github.com/huggingface/transformers/blob/c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95/tests%2Fgeneration%2Ftest_tf_logits_process.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95/tests%2Fgeneration%2Ftest_tf_logits_process.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_tf_logits_process.py?ref=c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95",
            "patch": "@@ -1,487 +0,0 @@\n-# coding=utf-8\n-# Copyright 2020 The HuggingFace Team Inc.\n-#\n-# Licensed under the Apache License, Version 2.0 (the \"License\");\n-# you may not use this file except in compliance with the License.\n-# You may obtain a clone of the License at\n-#\n-#     http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing, software\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# See the License for the specific language governing permissions and\n-# limitations under the License.\n-\n-\n-from __future__ import annotations\n-\n-import unittest\n-\n-import numpy as np\n-from parameterized import parameterized\n-\n-from transformers import is_tf_available\n-from transformers.testing_utils import require_tf\n-\n-\n-if is_tf_available():\n-    import tensorflow as tf\n-\n-    from transformers.generation import (\n-        TFForcedBOSTokenLogitsProcessor,\n-        TFForcedEOSTokenLogitsProcessor,\n-        TFForceTokensLogitsProcessor,\n-        TFLogitsProcessorList,\n-        TFMinLengthLogitsProcessor,\n-        TFNoBadWordsLogitsProcessor,\n-        TFNoRepeatNGramLogitsProcessor,\n-        TFRepetitionPenaltyLogitsProcessor,\n-        TFSuppressTokensAtBeginLogitsProcessor,\n-        TFSuppressTokensLogitsProcessor,\n-        TFTemperatureLogitsWarper,\n-        TFTopKLogitsWarper,\n-        TFTopPLogitsWarper,\n-    )\n-\n-    from ..test_modeling_tf_common import ids_tensor\n-\n-\n-@require_tf\n-class TFLogitsProcessorTest(unittest.TestCase):\n-    def _get_uniform_logits(self, batch_size: int, length: int):\n-        scores = tf.ones((batch_size, length), dtype=tf.float32) / length\n-        return scores\n-\n-    @parameterized.expand([(False,), (True,)])\n-    def test_min_length_dist_processor(self, use_xla):\n-        vocab_size = 20\n-        batch_size = 4\n-        eos_token_id = 0\n-\n-        min_dist_processor = TFMinLengthLogitsProcessor(min_length=10, eos_token_id=eos_token_id)\n-        if use_xla:\n-            min_dist_processor = tf.function(min_dist_processor, jit_compile=True)\n-\n-        # check that min length is applied at length 5\n-        cur_len = 5\n-        input_ids = ids_tensor((batch_size, cur_len), vocab_size=20)\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores_before_min_length = min_dist_processor(input_ids, scores, cur_len)\n-        self.assertListEqual(scores_before_min_length[:, eos_token_id].numpy().tolist(), 4 * [-float(\"inf\")])\n-\n-        # check that min length is not applied anymore at length 15\n-        cur_len = 15\n-        input_ids = ids_tensor((batch_size, cur_len), vocab_size=20)\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores_before_min_length = min_dist_processor(input_ids, scores, cur_len)\n-        self.assertFalse(tf.math.reduce_any(tf.math.is_inf(scores_before_min_length)).numpy())\n-\n-    @parameterized.expand([(False,), (True,)])\n-    def test_temperature_dist_warper(self, use_xla):\n-        input_ids = None\n-        cur_len = None\n-        length = 20\n-\n-        scores = self._get_uniform_logits(batch_size=2, length=length)\n-\n-        # tweak scores to not be uniform anymore\n-        scores = scores.numpy()\n-        scores[1, 5] = (1 / length) + 0.1  # peak, 1st batch\n-        scores[1, 10] = (1 / length) - 0.4  # valley, 1st batch\n-        scores = tf.convert_to_tensor(scores)\n-\n-        # compute softmax\n-        probs = tf.nn.softmax(scores, axis=-1)\n-\n-        temp_dist_warper_sharper = TFTemperatureLogitsWarper(temperature=0.5)\n-        temp_dist_warper_smoother = TFTemperatureLogitsWarper(temperature=1.3)\n-        if use_xla:\n-            temp_dist_warper_sharper = tf.function(temp_dist_warper_sharper, jit_compile=True)\n-            temp_dist_warper_smoother = tf.function(temp_dist_warper_smoother, jit_compile=True)\n-\n-        warped_prob_sharp = tf.nn.softmax(temp_dist_warper_sharper(input_ids, tf.identity(scores), cur_len), axis=-1)\n-        warped_prob_smooth = tf.nn.softmax(temp_dist_warper_smoother(input_ids, tf.identity(scores), cur_len), axis=-1)\n-\n-        # uniform distribution stays uniform\n-        tf.debugging.assert_near(probs[0, :], warped_prob_sharp[0, :], atol=1e-3)\n-        tf.debugging.assert_near(probs[0, :], warped_prob_smooth[0, :], atol=1e-3)\n-\n-        # sharp peaks get higher, valleys get lower\n-        self.assertLess(tf.math.reduce_max(probs[1, :]), tf.math.reduce_max(warped_prob_sharp[1, :]))\n-        self.assertGreater(tf.math.reduce_min(probs[1, :]), tf.math.reduce_min(warped_prob_sharp[1, :]))\n-\n-        # smooth peaks get lower, valleys get higher\n-        self.assertGreater(tf.math.reduce_max(probs[1, :]), tf.math.reduce_max(warped_prob_smooth[1, :]))\n-        self.assertLess(tf.math.reduce_min(probs[1, :]), tf.math.reduce_min(warped_prob_smooth[1, :]))\n-\n-    @parameterized.expand([(False,), (True,)])\n-    def test_repetition_penalty_dist_process(self, use_xla):\n-        vocab_size = 10\n-        cur_len = 2\n-\n-        input_ids = tf.constant([[0, 1], [5, 0]], dtype=tf.int32)\n-        self.assertEqual(cur_len, input_ids.shape[1])\n-\n-        scores = self._get_uniform_logits(batch_size=2, length=vocab_size)\n-\n-        mask = tf.cast(tf.constant([[1] + 9 * [0], 10 * [0]]), tf.bool)\n-        scores = tf.where(mask, -1 / vocab_size, scores)\n-        mask = tf.cast(tf.constant([10 * [0], 5 * [0] + [1] + 4 * [0]]), tf.bool)\n-        scores = tf.where(mask, 4 / vocab_size, scores)\n-        rep_penalty_proc = TFRepetitionPenaltyLogitsProcessor(penalty=2.0)\n-        if use_xla:\n-            rep_penalty_proc = tf.function(rep_penalty_proc, jit_compile=True)\n-\n-        scores = rep_penalty_proc(input_ids, tf.identity(scores), cur_len)\n-\n-        # check that values were correctly changed (negative scores for used tokens should increase, others\n-        # should decrease)\n-        self.assertAlmostEqual(scores[0, 0].numpy(), -(1 / vocab_size) * 2)\n-        self.assertAlmostEqual(scores[0, 1].numpy(), (1 / vocab_size) / 2)\n-        self.assertAlmostEqual(scores[0, 2].numpy(), (1 / vocab_size))  # unused tokens should see no change\n-\n-        self.assertAlmostEqual(scores[1, 0].numpy(), (1 / vocab_size) / 2)\n-        self.assertAlmostEqual(scores[1, 5].numpy(), (4 / vocab_size) / 2)\n-        self.assertAlmostEqual(scores[0, 2].numpy(), (1 / vocab_size))  # unused tokens should see no change\n-\n-    @parameterized.expand([(False,), (True,)])\n-    def test_top_k_dist_warper(self, use_xla):\n-        input_ids = None\n-        cur_len = None\n-        vocab_size = 10\n-        batch_size = 2\n-\n-        # create ramp distribution\n-        ramp_logits = np.broadcast_to(np.arange(vocab_size, dtype=np.float32), (batch_size, vocab_size)).copy()\n-        ramp_logits[1:, : vocab_size // 2] = ramp_logits[1:, : vocab_size // 2] + vocab_size\n-\n-        top_k_warp = TFTopKLogitsWarper(3)\n-        if use_xla:\n-            top_k_warp = tf.function(top_k_warp, jit_compile=True)\n-\n-        scores = top_k_warp(input_ids, ramp_logits, cur_len)\n-\n-        # check that correct tokens are filtered\n-        self.assertListEqual(tf.math.is_inf(scores[0]).numpy().tolist(), 7 * [True] + 3 * [False])\n-        self.assertListEqual(tf.math.is_inf(scores[1]).numpy().tolist(), 2 * [True] + 3 * [False] + 5 * [True])\n-\n-        # check special cases\n-        length = 5\n-\n-        logits = self._get_uniform_logits(batch_size=batch_size, length=length)\n-        top_k_warp_safety_check = TFTopKLogitsWarper(top_k=1, filter_value=0.0, min_tokens_to_keep=3)\n-        if use_xla:\n-            top_k_warp_safety_check = tf.function(top_k_warp_safety_check, jit_compile=True)\n-\n-        scores = top_k_warp_safety_check(input_ids, logits, cur_len)\n-        # uniform dist is not changed\n-        self.assertListEqual(tf.math.reduce_sum(tf.where(scores == 0.0, 1, 0), axis=-1).numpy().tolist(), [0, 0])\n-\n-        ramp_logits = np.broadcast_to(np.arange(length, dtype=np.float32), (batch_size, length)).copy()\n-        scores = top_k_warp_safety_check(input_ids, ramp_logits, cur_len)\n-\n-        # min_tokens overwrites k: 3 tokens are kept => 2 tokens are nullified\n-        self.assertListEqual(tf.math.reduce_sum(tf.where(scores == 0.0, 1, 0), axis=-1).numpy().tolist(), [2, 2])\n-\n-    @parameterized.expand([(False,), (True,)])\n-    def test_top_p_dist_warper(self, use_xla):\n-        input_ids = None\n-        cur_len = None\n-        vocab_size = 10\n-        batch_size = 2\n-\n-        # create distribution and take log (inverse to Softmax as taken in TFTopPLogitsWarper)\n-        dist = np.log(np.array([[0.3, 0.1, 0.1, 0.5], [0.15, 0.3, 0.3, 0.25]], dtype=np.float32))\n-\n-        # top_p should have been 0.8 to test the edge case of top_p being exactly equal to sum of some token prob\n-        # However, due to the numerical instability of softmax in TF we choose this as the edge case\n-        # top_p as 0.8 passes when use_xla is True and fails when False. Refer PR #18984.\n-        top_p_warp = TFTopPLogitsWarper(0.79999995)\n-        if use_xla:\n-            top_p_warp = tf.function(top_p_warp, jit_compile=True)\n-        filtered_dist = tf.exp(top_p_warp(input_ids, dist, cur_len))\n-\n-        # dist should be filtered to keep min num values so that sum is >= top_p\n-        # exp (-inf) => 0\n-        EXPECTED_FILTERED_DIST = tf.constant([[0.3, 0.0, 0.0, 0.5], [0.0, 0.3, 0.3, 0.25]], dtype=tf.float32)\n-        tf.debugging.assert_near(filtered_dist, EXPECTED_FILTERED_DIST, atol=1e-3)\n-\n-        # check edge cases with negative and extreme logits\n-        ramp_logits = np.broadcast_to(\n-            np.arange(vocab_size, dtype=np.float32)[None, :], (batch_size, vocab_size)\n-        ).copy() - (vocab_size // 2)\n-\n-        # make ramp_logits more extreme\n-        ramp_logits[1] = ramp_logits[1] * 100.0\n-\n-        # make sure at least 2 tokens are kept\n-        top_p_warp = TFTopPLogitsWarper(0.9, min_tokens_to_keep=2, filter_value=0.0)\n-        if use_xla:\n-            top_p_warp = tf.function(top_p_warp, jit_compile=True)\n-        filtered_dist = top_p_warp(input_ids, ramp_logits, cur_len)\n-\n-        # first batch should keep three tokens, second batch would keep only 1, but due to `min_tokens_to_keep=2` keeps\n-        # 2.\n-        self.assertListEqual(\n-            tf.math.reduce_sum(tf.where(filtered_dist != 0.0, 1, 0), axis=-1).numpy().tolist(), [3, 2]\n-        )\n-\n-    def test_no_repeat_ngram_dist_processor(self):\n-        vocab_size = 3\n-        batch_size = 2\n-        cur_len = 4\n-\n-        input_ids = tf.constant([[1, 1, 2, 1], [0, 1, 0, 1]], dtype=tf.int32)\n-        self.assertEqual(cur_len, input_ids.shape[1])\n-\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-\n-        no_repeat_proc_2_gram = TFNoRepeatNGramLogitsProcessor(2)\n-        no_repeat_proc_3_gram = TFNoRepeatNGramLogitsProcessor(3)\n-\n-        filtered_scores_2_gram = no_repeat_proc_2_gram(input_ids, tf.identity(scores), cur_len)\n-        filtered_scores_3_gram = no_repeat_proc_3_gram(input_ids, tf.identity(scores), cur_len)\n-\n-        # 2-gram would forbid 2nd and 3rd token (1,2) at 1st batch and 1st token (0) at 2nd batch\n-        self.assertListEqual(\n-            tf.math.is_inf(filtered_scores_2_gram).numpy().tolist(), [[False, True, True], [True, False, False]]\n-        )\n-\n-        # 3-gram would forbid no token at 1st batch and 1st token (0) at 2nd batch\n-        self.assertListEqual(\n-            tf.math.is_inf(filtered_scores_3_gram).numpy().tolist(), [[False, False, False], [True, False, False]]\n-        )\n-\n-    @parameterized.expand([(False,), (True,)])\n-    def test_no_bad_words_dist_processor(self, use_xla):\n-        vocab_size = 5\n-        batch_size = 2\n-        eos_token_id = 4\n-        cur_len = 4\n-\n-        input_ids = tf.constant([[0, 1, 3, 1], [0, 1, 0, 1]], dtype=tf.int32)\n-        self.assertEqual(cur_len, input_ids.shape[1])\n-\n-        bad_word_tokens = [[1], [4], [1, 0], [0, 1, 2], [1, 3, 1, 3]]\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-\n-        no_bad_words_dist_proc = TFNoBadWordsLogitsProcessor(bad_words_ids=bad_word_tokens, eos_token_id=eos_token_id)\n-        if use_xla:\n-            no_bad_words_dist_proc = tf.function(no_bad_words_dist_proc, jit_compile=True)\n-\n-        filtered_scores = no_bad_words_dist_proc(input_ids, tf.identity(scores), cur_len)\n-\n-        # batch 1: 1st, 2nd, and 4th (0, 1, 3) token are forbidden\n-        # batch 2: 1st, 2nd, and 3rd (0, 1, 2) token are forbidden\n-        self.assertListEqual(\n-            tf.math.is_inf(filtered_scores).numpy().tolist(),\n-            [[True, True, False, True, True], [True, True, True, False, True]],\n-        )\n-\n-    @parameterized.expand([(False,), (True,)])\n-    def test_forced_bos_token_logits_processor(self, use_xla):\n-        vocab_size = 20\n-        batch_size = 4\n-        bos_token_id = 0\n-\n-        logits_processor = TFForcedBOSTokenLogitsProcessor(bos_token_id=bos_token_id)\n-        if use_xla:\n-            logits_processor = tf.function(logits_processor, jit_compile=True)\n-\n-        # check that all scores are -inf except the bos_token_id score\n-        cur_len = 1\n-        input_ids = ids_tensor((batch_size, cur_len), vocab_size=20)\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len)\n-        self.assertTrue(\n-            tf.math.reduce_all(tf.math.is_inf(scores[:, bos_token_id + 1 :]) & (scores[:, bos_token_id + 1 :] < 0))\n-        )\n-        self.assertListEqual(scores[:, bos_token_id].numpy().tolist(), 4 * [0])  # score for bos_token_id shold be zero\n-\n-        # check that bos_token_id is not forced if current length is greater than 1\n-        cur_len = 4\n-        input_ids = ids_tensor((batch_size, cur_len), vocab_size=20)\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len)\n-        self.assertFalse(tf.math.reduce_any(tf.math.is_inf((scores))))\n-\n-    @parameterized.expand([(False,), (True,)])\n-    def test_forced_eos_token_logits_processor(self, use_xla):\n-        vocab_size = 20\n-        batch_size = 4\n-        eos_token_id = 0\n-        max_length = 5\n-\n-        logits_processor = TFForcedEOSTokenLogitsProcessor(max_length=max_length, eos_token_id=eos_token_id)\n-        if use_xla:\n-            logits_processor = tf.function(logits_processor, jit_compile=True)\n-\n-        # check that all scores are -inf except the eos_token_id when max_length-1 is reached\n-        cur_len = 4\n-        input_ids = ids_tensor((batch_size, cur_len), vocab_size=20)\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len)\n-        self.assertTrue(\n-            tf.math.reduce_all(tf.math.is_inf(scores[:, eos_token_id + 1 :]) & (scores[:, eos_token_id + 1 :] < 0))\n-        )\n-        self.assertListEqual(\n-            scores[:, eos_token_id].numpy().tolist(), 4 * [0]\n-        )  # score for eos_token_id should be zero\n-\n-        # check that eos_token_id is not forced if max_length-1 is not reached\n-        cur_len = 3\n-        input_ids = ids_tensor((batch_size, cur_len), vocab_size=20)\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len)\n-        self.assertFalse(tf.math.reduce_any(tf.math.is_inf((scores))))\n-\n-    @parameterized.expand([(False,), (True,)])\n-    def test_suppress_tokens_at_begin_logits_processor(self, use_xla):\n-        vocab_size = 20\n-        batch_size = 4\n-\n-        begin_suppress_tokens = [1, 2, 3]\n-        begin_index = 5\n-\n-        logits_processor = TFSuppressTokensAtBeginLogitsProcessor(\n-            begin_suppress_tokens=begin_suppress_tokens, begin_index=begin_index\n-        )\n-        if use_xla:\n-            logits_processor = tf.function(logits_processor, jit_compile=True)\n-\n-        # Check that no scores are suppressed if begin_index is not reached\n-        cur_len = 4\n-        input_ids = tf.convert_to_tensor([[11, 17, 15, 8], [14, 0, 19, 5], [13, 11, 18, 19], [11, 12, 16, 15]])\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len)\n-        self.assertFalse(tf.math.reduce_any(tf.math.is_inf((scores))))\n-\n-        # Check that scores are suppressed if begin_index is reached\n-        cur_len = 5\n-        input_ids = tf.convert_to_tensor([[5, 5, 5, 0, 17], [18, 1, 9, 14, 17], [18, 6, 8, 15, 19], [8, 12, 17, 1, 2]])\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len)\n-        self.assertTrue(tf.math.reduce_all(tf.math.is_inf(tf.gather(scores, begin_suppress_tokens, axis=1))))\n-\n-    @parameterized.expand([(False,), (True,)])\n-    def test_suppress_tokens_logits_processor(self, use_xla):\n-        vocab_size = 20\n-        batch_size = 4\n-\n-        suppress_tokens = [1, 3, 5]\n-        keep_tokens = [i for i in range(vocab_size) if i not in suppress_tokens]\n-\n-        logits_processor = TFSuppressTokensLogitsProcessor(suppress_tokens=suppress_tokens)\n-        if use_xla:\n-            logits_processor = tf.function(logits_processor, jit_compile=True)\n-\n-        # Check that suppress_tokens are suppressed and others are not\n-        cur_len = 5\n-        input_ids = tf.convert_to_tensor([[0, 10, 19, 6, 3], [17, 4, 8, 17, 2], [7, 1, 11, 6, 15], [5, 8, 13, 16, 0]])\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len)\n-        self.assertTrue(tf.math.reduce_all(tf.math.is_inf(tf.gather(scores, suppress_tokens, axis=1))))\n-        self.assertFalse(tf.math.reduce_any(tf.math.is_inf(tf.gather(scores, keep_tokens, axis=1))))\n-\n-    @parameterized.expand([(False,), (True,)])\n-    def test_force_tokens_logits_processor(self, use_xla):\n-        vocab_size = 20\n-        batch_size = 4\n-\n-        force_token_map = {1: 2, 3: 2}\n-\n-        logits_processor = TFForceTokensLogitsProcessor(force_token_map=force_token_map)\n-        if use_xla:\n-            logits_processor = tf.function(logits_processor, jit_compile=True)\n-\n-        # check that if the cur_len is contained in the force_token_map, the logits are the same\n-        # for all tokens except the one the force_token_map points to\n-        cur_len = 1\n-        input_ids = tf.convert_to_tensor([[11], [7], [5], [15]])\n-        ids_tensor((batch_size, cur_len), vocab_size=20)\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len)\n-        tf.debugging.assert_near(tf.gather(scores, [force_token_map[cur_len]], axis=1), 0.0)\n-\n-        non_forced_inds = [i for i in range(vocab_size) if i != force_token_map[cur_len]]\n-        self.assertTrue(\n-            tf.math.reduce_all(\n-                tf.experimental.numpy.isclose(\n-                    tf.gather(scores, [non_forced_inds], axis=1),\n-                    tf.constant(scores.dtype.min),\n-                )\n-            )\n-        )\n-\n-        # check that if the cur_len is not contained in the force_token_map, the logits are not modified\n-        cur_len = 2\n-        input_ids = tf.convert_to_tensor([[2, 19], [19, 15], [4, 9], [7, 6]])\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores = logits_processor(input_ids, scores, cur_len)\n-        self.assertFalse(tf.math.reduce_any(tf.math.is_inf((scores))))\n-\n-    @parameterized.expand([(False,), (True,)])\n-    def test_processor_list(self, use_xla):\n-        # TODO (Joao): reintroduce TFNoRepeatNGramLogitsProcessor when it gets compatible with XLA\n-        batch_size = 4\n-        cur_len = 10\n-        vocab_size = 15\n-        eos_token_id = 0\n-\n-        # dummy input_ids and scores\n-        input_ids = ids_tensor((batch_size, cur_len), vocab_size)\n-        input_ids_comp = tf.identity(input_ids)\n-\n-        scores = self._get_uniform_logits(batch_size, vocab_size)\n-        scores_comp = tf.identity(scores)\n-\n-        # instantiate all dist processors\n-        min_dist_proc = TFMinLengthLogitsProcessor(min_length=10, eos_token_id=eos_token_id)\n-        temp_dist_warp = TFTemperatureLogitsWarper(temperature=0.5)\n-        rep_penalty_proc = TFRepetitionPenaltyLogitsProcessor(penalty=2.0)\n-        top_k_warp = TFTopKLogitsWarper(3)\n-        top_p_warp = TFTopPLogitsWarper(0.8)\n-        # no_repeat_proc = TFNoRepeatNGramLogitsProcessor(2)\n-        no_bad_words_dist_proc = TFNoBadWordsLogitsProcessor(bad_words_ids=[[1]], eos_token_id=eos_token_id)\n-        if use_xla:\n-            min_dist_proc = tf.function(min_dist_proc, jit_compile=True)\n-            temp_dist_warp = tf.function(temp_dist_warp, jit_compile=True)\n-            rep_penalty_proc = tf.function(rep_penalty_proc, jit_compile=True)\n-            top_k_warp = tf.function(top_k_warp, jit_compile=True)\n-            top_p_warp = tf.function(top_p_warp, jit_compile=True)\n-            # no_repeat_proc = tf.function(no_repeat_proc, jit_compile=True)\n-            no_bad_words_dist_proc = tf.function(no_bad_words_dist_proc, jit_compile=True)\n-\n-        # no processor list\n-        scores = min_dist_proc(input_ids, scores, cur_len)\n-        scores = temp_dist_warp(input_ids, scores, cur_len)\n-        scores = rep_penalty_proc(input_ids, scores, cur_len)\n-        scores = top_k_warp(input_ids, scores, cur_len)\n-        scores = top_p_warp(input_ids, scores, cur_len)\n-        # scores = no_repeat_proc(input_ids, scores, cur_len)\n-        scores = no_bad_words_dist_proc(input_ids, scores, cur_len)\n-\n-        # with processor list\n-        processor = TFLogitsProcessorList(\n-            [\n-                min_dist_proc,\n-                temp_dist_warp,\n-                rep_penalty_proc,\n-                top_k_warp,\n-                top_p_warp,\n-                # no_repeat_proc,\n-                no_bad_words_dist_proc,\n-            ]\n-        )\n-        scores_comp = processor(input_ids, scores_comp, cur_len)\n-\n-        # remove inf\n-        scores = tf.where(tf.math.is_inf(scores), -1e9, scores)\n-        scores_comp = tf.where(tf.math.is_inf(scores_comp), -1e9, scores_comp)\n-\n-        # scores should be equal\n-        tf.debugging.assert_near(scores, scores_comp, atol=1e-3)\n-\n-        # input_ids should never be changed\n-        self.assertListEqual(input_ids.numpy().tolist(), input_ids_comp.numpy().tolist())"
        },
        {
            "sha": "f40ceebef76fbc764bb72cb4b13938d215810c64",
            "filename": "tests/generation/test_tf_utils.py",
            "status": "removed",
            "additions": 0,
            "deletions": 245,
            "changes": 245,
            "blob_url": "https://github.com/huggingface/transformers/blob/c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95/tests%2Fgeneration%2Ftest_tf_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95/tests%2Fgeneration%2Ftest_tf_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_tf_utils.py?ref=c877c9fa5bc5ef32310dd2ba5115e0e9d9862f95",
            "patch": "@@ -1,245 +0,0 @@\n-# coding=utf-8\n-# Copyright 2022 The HuggingFace Team Inc.\n-#\n-# Licensed under the Apache License, Version 2.0 (the \"License\");\n-# you may not use this file except in compliance with the License.\n-# You may obtain a clone of the License at\n-#\n-#     http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing, software\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# See the License for the specific language governing permissions and\n-# limitations under the License.\n-\n-from __future__ import annotations\n-\n-import os\n-import tempfile\n-import unittest\n-\n-import numpy as np\n-from huggingface_hub import hf_hub_download\n-\n-from transformers import is_tensorflow_text_available, is_tf_available\n-from transformers.testing_utils import require_tensorflow_text, require_tf, slow\n-\n-from ..test_modeling_tf_common import floats_tensor\n-from .test_framework_agnostic import GenerationIntegrationTestsMixin\n-\n-\n-if is_tf_available():\n-    import tensorflow as tf\n-\n-    from transformers import (\n-        AutoTokenizer,\n-        TFAutoModelForCausalLM,\n-        TFAutoModelForSeq2SeqLM,\n-        TFAutoModelForSpeechSeq2Seq,\n-        TFAutoModelForVision2Seq,\n-        TFBartForConditionalGeneration,\n-        TFLogitsProcessorList,\n-        TFMinLengthLogitsProcessor,\n-    )\n-    from transformers.modeling_tf_utils import keras\n-\n-if is_tensorflow_text_available():\n-    import tensorflow_text as text\n-\n-\n-@require_tf\n-class TFGenerationIntegrationTests(unittest.TestCase, GenerationIntegrationTestsMixin):\n-    # setting framework_dependent_parameters needs to be gated, just like its contents' imports\n-    if is_tf_available():\n-        framework_dependent_parameters = {\n-            \"AutoModelForCausalLM\": TFAutoModelForCausalLM,\n-            \"AutoModelForSpeechSeq2Seq\": TFAutoModelForSpeechSeq2Seq,\n-            \"AutoModelForSeq2SeqLM\": TFAutoModelForSeq2SeqLM,\n-            \"AutoModelForVision2Seq\": TFAutoModelForVision2Seq,\n-            \"LogitsProcessorList\": TFLogitsProcessorList,\n-            \"MinLengthLogitsProcessor\": TFMinLengthLogitsProcessor,\n-            \"create_tensor_fn\": tf.convert_to_tensor,\n-            \"floats_tensor\": floats_tensor,\n-            \"return_tensors\": \"tf\",\n-        }\n-\n-    @slow\n-    def test_generate_tf_function_export_fixed_input_length(self):\n-        # TF-only test: tf.saved_model export\n-        test_model = TFAutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        input_length = 2\n-        max_new_tokens = 2\n-\n-        class DummyModel(tf.Module):\n-            def __init__(self, model):\n-                super(DummyModel, self).__init__()\n-                self.model = model\n-\n-            @tf.function(\n-                input_signature=(\n-                    tf.TensorSpec((None, input_length), tf.int32, name=\"input_ids\"),\n-                    tf.TensorSpec((None, input_length), tf.int32, name=\"attention_mask\"),\n-                ),\n-                jit_compile=True,\n-            )\n-            def serving(self, input_ids, attention_mask):\n-                outputs = self.model.generate(\n-                    input_ids=input_ids,\n-                    attention_mask=attention_mask,\n-                    max_new_tokens=max_new_tokens,\n-                    return_dict_in_generate=True,\n-                )\n-                return {\"sequences\": outputs[\"sequences\"]}\n-\n-        dummy_input_ids = [[2, 0], [102, 103]]\n-        dummy_attention_masks = [[1, 0], [1, 1]]\n-        dummy_model = DummyModel(model=test_model)\n-        with tempfile.TemporaryDirectory() as tmp_dir:\n-            tf.saved_model.save(dummy_model, tmp_dir, signatures={\"serving_default\": dummy_model.serving})\n-            serving_func = tf.saved_model.load(tmp_dir).signatures[\"serving_default\"]\n-            for batch_size in range(1, len(dummy_input_ids) + 1):\n-                inputs = {\n-                    \"input_ids\": tf.constant(dummy_input_ids[:batch_size]),\n-                    \"attention_mask\": tf.constant(dummy_attention_masks[:batch_size]),\n-                }\n-                tf_func_outputs = serving_func(**inputs)[\"sequences\"]\n-                tf_model_outputs = test_model.generate(**inputs, max_new_tokens=max_new_tokens)\n-                tf.debugging.assert_equal(tf_func_outputs, tf_model_outputs)\n-\n-    @slow\n-    def test_generate_tf_function_export_fixed_batch_size(self):\n-        # TF-only test: tf.saved_model export\n-        test_model = TFAutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        batch_size = 1\n-        max_new_tokens = 2\n-\n-        class DummyModel(tf.Module):\n-            def __init__(self, model):\n-                super(DummyModel, self).__init__()\n-                self.model = model\n-\n-            @tf.function(\n-                input_signature=(\n-                    tf.TensorSpec((batch_size, None), tf.int32, name=\"input_ids\"),\n-                    tf.TensorSpec((batch_size, None), tf.int32, name=\"attention_mask\"),\n-                ),\n-                jit_compile=True,\n-            )\n-            def serving(self, input_ids, attention_mask):\n-                outputs = self.model.generate(\n-                    input_ids=input_ids,\n-                    attention_mask=attention_mask,\n-                    max_new_tokens=max_new_tokens,\n-                    return_dict_in_generate=True,\n-                )\n-                return {\"sequences\": outputs[\"sequences\"]}\n-\n-        dummy_input_ids = [[2], [102, 103]]\n-        dummy_attention_masks = [[1], [1, 1]]\n-        dummy_model = DummyModel(model=test_model)\n-        with tempfile.TemporaryDirectory() as tmp_dir:\n-            tf.saved_model.save(dummy_model, tmp_dir, signatures={\"serving_default\": dummy_model.serving})\n-            serving_func = tf.saved_model.load(tmp_dir).signatures[\"serving_default\"]\n-            for input_row in range(len(dummy_input_ids)):\n-                inputs = {\n-                    \"input_ids\": tf.constant([dummy_input_ids[input_row]]),\n-                    \"attention_mask\": tf.constant([dummy_attention_masks[input_row]]),\n-                }\n-                tf_func_outputs = serving_func(**inputs)[\"sequences\"]\n-                tf_model_outputs = test_model.generate(**inputs, max_new_tokens=max_new_tokens)\n-                tf.debugging.assert_equal(tf_func_outputs, tf_model_outputs)\n-\n-    @slow\n-    @require_tensorflow_text\n-    def test_generate_tf_function_export_with_tf_tokenizer(self):\n-        # TF-only test: tf.saved_model export\n-        with tempfile.TemporaryDirectory() as tmp_dir:\n-            # file needed to load the TF tokenizer\n-            hf_hub_download(repo_id=\"google/flan-t5-small\", filename=\"spiece.model\", local_dir=tmp_dir)\n-\n-            class CompleteSentenceTransformer(keras.layers.Layer):\n-                def __init__(self):\n-                    super().__init__()\n-                    self.tokenizer = text.SentencepieceTokenizer(\n-                        model=tf.io.gfile.GFile(os.path.join(tmp_dir, \"spiece.model\"), \"rb\").read()\n-                    )\n-                    self.model = TFAutoModelForSeq2SeqLM.from_pretrained(\"hf-internal-testing/tiny-random-t5\")\n-\n-                def call(self, inputs, *args, **kwargs):\n-                    tokens = self.tokenizer.tokenize(inputs)\n-                    input_ids, attention_mask = text.pad_model_inputs(\n-                        tokens, max_seq_length=64, pad_value=self.model.config.pad_token_id\n-                    )\n-                    outputs = self.model.generate(input_ids=input_ids, attention_mask=attention_mask)\n-                    return self.tokenizer.detokenize(outputs)\n-\n-            complete_model = CompleteSentenceTransformer()\n-            inputs = keras.layers.Input(shape=(1,), dtype=tf.string, name=\"inputs\")\n-            outputs = complete_model(inputs)\n-            keras_model = keras.Model(inputs, outputs)\n-            keras_model.save(tmp_dir)\n-\n-    def test_eos_token_id_int_and_list_top_k_top_sampling(self):\n-        # Has PT equivalent: this test relies on random sampling\n-        generation_kwargs = {\n-            \"do_sample\": True,\n-            \"num_beams\": 1,\n-            \"top_p\": 0.7,\n-            \"top_k\": 10,\n-            \"temperature\": 0.7,\n-        }\n-        expectation = 14\n-\n-        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-        text = \"\"\"Hello, my dog is cute and\"\"\"\n-        tokens = tokenizer(text, return_tensors=\"tf\")\n-        model = TFAutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n-\n-        eos_token_id = 638\n-        # forces the generation to happen on CPU, to avoid GPU-related quirks\n-        with tf.device(\":/CPU:0\"):\n-            tf.random.set_seed(0)\n-            generated_tokens = model.generate(**tokens, eos_token_id=eos_token_id, **generation_kwargs)\n-        self.assertTrue(expectation == len(generated_tokens[0]))\n-\n-        eos_token_id = [638, 198]\n-        with tf.device(\":/CPU:0\"):\n-            tf.random.set_seed(0)\n-            generated_tokens = model.generate(**tokens, eos_token_id=eos_token_id, **generation_kwargs)\n-        self.assertTrue(expectation == len(generated_tokens[0]))\n-\n-    def test_model_kwarg_encoder_signature_filtering(self):\n-        # Has PT equivalent: ample use of framework-specific code\n-        bart_tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-        article = \"\"\"Hugging Face is a technology company based in New York and Paris.\"\"\"\n-        input_ids = bart_tokenizer(article, return_tensors=\"tf\").input_ids\n-        bart_model = TFBartForConditionalGeneration.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-        output = bart_model.generate(input_ids).numpy()\n-\n-        # Let's create a fake model that has a different signature. In particular, this fake model accepts \"foo\" as an\n-        # argument. Because \"foo\" is not in the encoder signature and doesn't start with \"decoder_\", it will be part of\n-        # the encoder kwargs prior to signature filtering, which would lead to an exception. But filtering kicks in and\n-        # saves the day.\n-        class FakeBart(TFBartForConditionalGeneration):\n-            def call(self, input_ids, foo=None, **kwargs):\n-                return super().call(input_ids, **kwargs)\n-\n-        bart_model = FakeBart.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n-        fake_output = bart_model.generate(input_ids, foo=\"bar\").numpy()\n-        self.assertTrue(np.array_equal(output, fake_output))\n-\n-        # Encoder signature filtering only kicks in if it doesn't accept wildcard kwargs. The following test will fail\n-        # because it doesn't do signature filtering.\n-        class FakeEncoder(bart_model.model.encoder.__class__):\n-            def call(self, input_ids, **kwargs):\n-                return super().call(input_ids, **kwargs)\n-\n-        fake_encoder = FakeEncoder(bart_model.config, bart_model.model.shared)\n-        bart_model.model.encoder = fake_encoder\n-\n-        # Normal generation still works (the output will be different because the encoder weights are different)\n-        fake_output = bart_model.generate(input_ids).numpy()\n-        with self.assertRaises(ValueError):\n-            # FakeEncoder.call() accepts **kwargs -> no filtering -> value error due to unexpected input \"foo\"\n-            bart_model.generate(input_ids, foo=\"bar\")"
        },
        {
            "sha": "9b63e42946a00187bb194852c17b94bc2c58b830",
            "filename": "tests/generation/test_utils.py",
            "status": "modified",
            "additions": 411,
            "deletions": 41,
            "changes": 452,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fgeneration%2Ftest_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fgeneration%2Ftest_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_utils.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -49,7 +49,6 @@\n from transformers.utils import is_ipex_available\n \n from ..test_modeling_common import floats_tensor, ids_tensor\n-from .test_framework_agnostic import GenerationIntegrationTestsMixin\n \n \n if is_torch_available():\n@@ -2783,24 +2782,9 @@ def test_speculative_sampling_target_distribution(self):\n \n @pytest.mark.generate\n @require_torch\n-class GenerationIntegrationTests(unittest.TestCase, GenerationIntegrationTestsMixin):\n-    # setting framework_dependent_parameters needs to be gated, just like its contents' imports\n-    if is_torch_available():\n-        framework_dependent_parameters = {\n-            \"AutoModelForCausalLM\": AutoModelForCausalLM,\n-            \"AutoModelForSpeechSeq2Seq\": AutoModelForSpeechSeq2Seq,\n-            \"AutoModelForSeq2SeqLM\": AutoModelForSeq2SeqLM,\n-            \"AutoModelForVision2Seq\": AutoModelForVision2Seq,\n-            \"LogitsProcessorList\": LogitsProcessorList,\n-            \"MinLengthLogitsProcessor\": MinLengthLogitsProcessor,\n-            \"create_tensor_fn\": torch.tensor,\n-            \"floats_tensor\": floats_tensor,\n-            \"return_tensors\": \"pt\",\n-        }\n-\n+class GenerationIntegrationTests(unittest.TestCase):\n     @slow\n     def test_diverse_beam_search(self):\n-        # PT-only test: TF doesn't have a diverse beam search implementation\n         article = \"\"\"Justin Timberlake and Jessica Biel, welcome to parenthood.\n         The celebrity couple announced the arrival of their son, Silas Randall Timberlake, in statements to People.\n         \"Silas was the middle name of Timberlake's maternal grandfather Bill Bomar, who died in 2012, while Randall is the musician's own middle name, as well as his father's first,\" People reports.\n@@ -2834,7 +2818,6 @@ def test_diverse_beam_search(self):\n         )\n \n     def test_max_length_if_input_embeds(self):\n-        # PT-only test: TF doesn't have StoppingCriteria\n         article = \"Today a dragon flew over Paris.\"\n         model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\").to(torch_device)\n         tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n@@ -2848,7 +2831,6 @@ def test_max_length_if_input_embeds(self):\n         self.assertEqual(out_gen.shape[-1], input_len + out_gen_embeds.shape[-1])\n \n     def test_min_length_if_input_embeds(self):\n-        # PT-only test: TF doesn't have StoppingCriteria\n         article = \"Today a dragon flew over Paris.\"\n         model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\").to(torch_device)\n         tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n@@ -2862,7 +2844,6 @@ def test_min_length_if_input_embeds(self):\n         self.assertEqual(out_gen.shape[-1], input_len + out_gen_embeds.shape[-1])\n \n     def test_custom_stopping_criteria_overload_error(self):\n-        # PT-only test: TF doesn't have StoppingCriteria\n         article = \"\"\"Justin Timberlake and Jessica Biel, welcome to parenthood.\"\"\"\n         bart_tokenizer = BartTokenizer.from_pretrained(\"sshleifer/bart-tiny-random\")\n         bart_model = BartForConditionalGeneration.from_pretrained(\"sshleifer/bart-tiny-random\").to(torch_device)\n@@ -2876,7 +2857,6 @@ def test_custom_stopping_criteria_overload_error(self):\n             bart_model.generate(input_ids, stopping_criteria=stopping_criteria, max_length=32)\n \n     def test_custom_stopping_criteria(self):\n-        # PT-only test: TF doesn't have StoppingCriteria\n         article = \"\"\"Justin Timberlake and Jessica Biel, welcome to parenthood.\"\"\"\n         bart_tokenizer = BartTokenizer.from_pretrained(\"sshleifer/bart-tiny-random\")\n         bart_model = BartForConditionalGeneration.from_pretrained(\"sshleifer/bart-tiny-random\").to(torch_device)\n@@ -2900,7 +2880,6 @@ def __call__(self, input_ids: torch.LongTensor, scores: torch.FloatTensor, **kwa\n \n     # TODO (joao): replace `stop_sequence` in the pipeline by the more recent `generate` functionality\n     def test_stop_sequence_stopping_criteria(self):\n-        # PT-only test: TF doesn't have StoppingCriteria\n         prompt = \"\"\"Hello I believe in\"\"\"\n         generator = pipeline(\"text-generation\", model=\"hf-internal-testing/tiny-random-bart\")\n         output = generator(prompt)\n@@ -2913,7 +2892,6 @@ def test_stop_sequence_stopping_criteria(self):\n         self.assertEqual(output, [{\"generated_text\": \"Hello I believe in we\"}])\n \n     def test_generate_non_nlp_input_ids_as_kwarg(self):\n-        # PT-only test: AFAIK there's no non-NLP model architecture in TF that supports `input_ids` as its only input\n         model = ImageGPTForCausalImageModeling.from_pretrained(\n             \"hf-internal-testing/tiny-random-imagegpt\", max_length=10\n         ).to(torch_device)\n@@ -2926,7 +2904,6 @@ def test_generate_non_nlp_input_ids_as_kwarg(self):\n         self.assertEqual(output_sequences.shape, (3, 10))\n \n     def test_generate_input_values_as_encoder_kwarg(self):\n-        # PT-only test: AFAIK there's no generate-capable architecture in TF that supports `input_values` as its input\n         input_values = floats_tensor((2, 250))\n         model = SpeechEncoderDecoderModel.from_pretrained(\"hf-internal-testing/tiny-random-speech-encoder-decoder\")\n         model = model.to(torch_device)\n@@ -2937,7 +2914,6 @@ def test_generate_input_values_as_encoder_kwarg(self):\n         self.assertEqual(output_sequences.shape, (2, 5))\n \n     def test_transition_scores_group_beam_search_encoder_decoder(self):\n-        # PT-only test: TF doesn't have group beam search\n         articles = [\n             \"Justin Timberlake and Jessica Biel, welcome to parenthood.\",\n             \"Michael Phelps is arguably the most decorated Olympian of all time.\",\n@@ -3067,7 +3043,6 @@ def test_synthid_text_watermark_generation_mean_expected_bias(self):\n \n     @slow\n     def test_beam_search_example_integration(self):\n-        # PT-only test: TF doesn't have a BeamSearchScorer\n         # exactly the example provided in the docstrings of beam search, which previously\n         # failed after directly copying from it. Refer to PR #15555\n         tokenizer = AutoTokenizer.from_pretrained(\"google-t5/t5-base\")\n@@ -3094,7 +3069,6 @@ def test_beam_search_example_integration(self):\n \n     @slow\n     def test_constrained_beam_search(self):\n-        # PT-only test: TF doesn't have constrained beam search\n         model = GPT2LMHeadModel.from_pretrained(\"openai-community/gpt2\").to(torch_device)\n         tokenizer = GPT2Tokenizer.from_pretrained(\"openai-community/gpt2\")\n \n@@ -3132,7 +3106,6 @@ def test_constrained_beam_search(self):\n \n     @slow\n     def test_constrained_beam_search_mixed(self):\n-        # PT-only test: TF doesn't have constrained beam search\n         model = GPT2LMHeadModel.from_pretrained(\"openai-community/gpt2\").to(torch_device)\n         tokenizer = GPT2Tokenizer.from_pretrained(\"openai-community/gpt2\")\n \n@@ -3173,7 +3146,6 @@ def test_constrained_beam_search_mixed(self):\n \n     @slow\n     def test_constrained_beam_search_mixed_mixin(self):\n-        # PT-only test: TF doesn't have constrained beam search\n         model = GPT2LMHeadModel.from_pretrained(\"openai-community/gpt2\").to(torch_device)\n         tokenizer = GPT2Tokenizer.from_pretrained(\"openai-community/gpt2\")\n \n@@ -3251,7 +3223,6 @@ def test_cfg_mixin(self):\n \n     @slow\n     def test_constrained_beam_search_example_translation_mixin(self):\n-        # PT-only test: TF doesn't have constrained beam search\n         tokenizer = AutoTokenizer.from_pretrained(\"google-t5/t5-base\")\n         model = AutoModelForSeq2SeqLM.from_pretrained(\"google-t5/t5-base\")\n \n@@ -3276,7 +3247,6 @@ def test_constrained_beam_search_example_translation_mixin(self):\n \n     @slow\n     def test_constrained_beam_search_example_integration(self):\n-        # PT-only test: TF doesn't have constrained beam search\n         tokenizer = AutoTokenizer.from_pretrained(\"google-t5/t5-base\")\n         model = AutoModelForSeq2SeqLM.from_pretrained(\"google-t5/t5-base\")\n \n@@ -3345,7 +3315,6 @@ def test_per_row_stopping_criteria(self):\n         self.assertListEqual(out_text, expected_out)\n \n     def test_constrained_beam_search_mixin_type_checks(self):\n-        # PT-only test: TF doesn't have constrained beam search\n         tokenizer = AutoTokenizer.from_pretrained(\"patrickvonplaten/t5-tiny-random\")\n         model = AutoModelForSeq2SeqLM.from_pretrained(\"patrickvonplaten/t5-tiny-random\")\n \n@@ -3386,7 +3355,6 @@ def test_constrained_beam_search_mixin_type_checks(self):\n             model.generate(input_ids, force_words_ids=[[[-1]]])\n \n     def test_batched_decoder_start_id(self):\n-        # PT-only test: TF doesn't support batched_decoder_start_id\n         articles = [\n             \"Justin Timberlake and Jessica Biel, welcome to parenthood.\",\n             \"Michael Phelps is arguably the most decorated Olympian of all time.\",\n@@ -3435,7 +3403,6 @@ def test_decoder_start_id_from_config(self):\n             outputs = bart_model.generate(input_ids, generation_config=GenerationConfig(do_sample=False))\n \n     def test_contrastive_search_batched(self):\n-        # PT-only test: TF doesn't have constrained beam search\n         # Tests that contrastive search works with batched inputs (i.e. has the same output as for non-batched inputs)\n         articles = [\"Foo\", \"Bar Baz\"]\n         tokenizer = BartTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n@@ -3461,7 +3428,6 @@ def test_contrastive_search_batched(self):\n         self.assertTrue(max_score_diff < 1e-5)\n \n     def test_logits_processor_not_inplace(self):\n-        # PT-only test: TF fixes were not made\n         article = \"Today a dragon flew over Paris.\"\n         model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\").to(torch_device)\n         tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n@@ -3572,7 +3538,6 @@ def test_default_max_length_warning(self):\n             self.assertEqual(len(warning_list), 0)\n \n     def test_length_warning_assisted_generation(self):\n-        # PT-only test: TF doesn't support assisted decoding yet.\n         model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\").to(torch_device)\n         assistant = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\").to(torch_device)\n         tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n@@ -3604,7 +3569,6 @@ def test_default_assisted_generation(self):\n         self.assertEqual(config.is_assistant, False)\n \n     def test_generated_length_assisted_generation(self):\n-        # PT-only test: TF doesn't support assisted decoding yet.\n         model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\").to(torch_device)\n         assistant = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\").to(torch_device)\n         tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n@@ -3639,7 +3603,6 @@ def test_generated_length_assisted_generation(self):\n         self.assertTrue(out.shape[-1] <= (input_length + 7))\n \n     def test_model_kwarg_assisted_decoding_decoder_only(self):\n-        # PT-only test: TF doesn't support assisted decoding yet.\n         model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\").to(torch_device)\n         tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n         model.generation_config.pad_token_id = tokenizer.eos_token_id\n@@ -3839,7 +3802,6 @@ def test_return_unprocessed_logit_scores(self):\n     @slow\n     @require_torch_multi_gpu\n     def test_assisted_decoding_in_different_gpu(self):\n-        # PT-only test: TF doesn't support assisted decoding yet.\n         model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-MistralForCausalLM\").to(\"cuda:0\")\n         assistant = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-MistralForCausalLM\").to(\n             \"cuda:1\"\n@@ -3863,7 +3825,6 @@ def test_assisted_decoding_in_different_gpu(self):\n     @slow\n     @require_torch_accelerator\n     def test_assisted_decoding_model_in_gpu_assistant_in_cpu(self):\n-        # PT-only test: TF doesn't support assisted decoding yet.\n         model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-MistralForCausalLM\").to(\n             torch_device\n         )\n@@ -3887,7 +3848,6 @@ def test_assisted_decoding_model_in_gpu_assistant_in_cpu(self):\n         self.assertTrue(input_length <= out.shape[-1] <= input_length + 20)\n \n     def test_special_tokens_fall_back_to_model_default(self):\n-        # PT-only test: TF doesn't support assisted decoding yet.\n         model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-MistralForCausalLM\").to(\n             torch_device\n         )\n@@ -4367,6 +4327,416 @@ def test_max_time(self):\n         duration = datetime.datetime.now() - start\n         self.assertGreater(duration, datetime.timedelta(seconds=1.5 * MAX_TIME))\n \n+    def test_validate_generation_inputs(self):\n+        \"\"\"Tests validation of inputs to `generate`\"\"\"\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-t5\")\n+        model = AutoModelForSeq2SeqLM.from_pretrained(\"hf-internal-testing/tiny-random-t5\")\n+\n+        encoder_input_str = \"Hello world\"\n+        input_ids = tokenizer(encoder_input_str, return_tensors=\"pt\").input_ids\n+\n+        # typos are quickly detected (the correct argument is `do_sample`)\n+        with self.assertRaisesRegex(ValueError, \"do_samples\"):\n+            model.generate(input_ids, do_samples=True)\n+\n+        # arbitrary arguments that will not be used anywhere are also not accepted\n+        with self.assertRaisesRegex(ValueError, \"foo\"):\n+            fake_model_kwargs = {\"foo\": \"bar\"}\n+            model.generate(input_ids, **fake_model_kwargs)\n+\n+        # however, valid model_kwargs are accepted\n+        valid_model_kwargs = {\"attention_mask\": torch.tensor(np.zeros_like(input_ids))}\n+        model.generate(input_ids, **valid_model_kwargs)\n+\n+    def test_custom_logits_processor(self):\n+        \"\"\"Tests that custom logits processors can be used in `generate`, and that redundant arguments are caught.\"\"\"\n+        bart_tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n+        article = \"\"\"Justin Timberlake and Jessica Biel, welcome to parenthood.\"\"\"\n+        bart_model = AutoModelForSeq2SeqLM.from_pretrained(\"hf-internal-testing/tiny-random-bart\", min_length=1)\n+        input_ids = bart_tokenizer(article, return_tensors=\"pt\").input_ids\n+\n+        logits_processor = LogitsProcessorList()\n+        logits_processor.append(MinLengthLogitsProcessor(min_length=10, eos_token_id=0))\n+\n+        # it should not be allowed to both define `min_length` via config and `logits_processor` list\n+        with self.assertRaises(ValueError):\n+            bart_model.generate(input_ids, logits_processor=logits_processor, min_length=10)\n+        bart_model.generate(input_ids, logits_processor=logits_processor)\n+\n+    def test_transition_scores_greedy_search(self):\n+        \"\"\"Test that `compute_transition_scores` is working as expected with gready search\"\"\"\n+        articles = [\"Justin Timberlake\", \"Michael Phelps\"]\n+        tokenizer = AutoTokenizer.from_pretrained(\"distilbert/distilgpt2\", padding_side=\"left\")\n+        tokenizer.pad_token = tokenizer.eos_token\n+\n+        model = AutoModelForCausalLM.from_pretrained(\"distilbert/distilgpt2\")\n+        model.generation_config.eos_token_id = None\n+        input_ids = tokenizer(articles, return_tensors=\"pt\", padding=True).input_ids\n+        model = model.to(torch_device)\n+        input_ids = input_ids.to(torch_device)\n+\n+        outputs = model.generate(\n+            input_ids=input_ids,\n+            max_new_tokens=5,\n+            pad_token_id=tokenizer.eos_token_id,\n+            return_dict_in_generate=True,\n+            output_scores=True,\n+        )\n+\n+        transition_scores = model.compute_transition_scores(outputs.sequences, outputs.scores)\n+        transition_scores = transition_scores.cpu().numpy()\n+\n+        expected_scores = np.array(\n+            [\n+                [-57.8844, -60.45698, -70.16364, -65.50791, -66.35648],\n+                [-54.417572, -60.216614, -62.661243, -58.621933, -58.298683],\n+            ]\n+        )\n+        self.assertTrue(np.allclose(transition_scores, expected_scores, atol=1e-3))\n+\n+    def test_transition_scores_greedy_search_normalized(self):\n+        \"\"\"\n+        Test that `compute_transition_scores` is working as expected with gready search, with `normalize_logits=True`\n+        \"\"\"\n+        articles = [\"Justin Timberlake\", \"Michael Phelps\"]\n+        tokenizer = AutoTokenizer.from_pretrained(\"distilbert/distilgpt2\", padding_side=\"left\")\n+        tokenizer.pad_token = tokenizer.eos_token\n+\n+        model = AutoModelForCausalLM.from_pretrained(\"distilbert/distilgpt2\")\n+        model.generation_config.eos_token_id = None\n+        input_ids = tokenizer(articles, return_tensors=\"pt\", padding=True).input_ids\n+        model = model.to(torch_device)\n+        input_ids = input_ids.to(torch_device)\n+\n+        outputs = model.generate(\n+            input_ids=input_ids,\n+            max_new_tokens=5,\n+            pad_token_id=tokenizer.eos_token_id,\n+            return_dict_in_generate=True,\n+            output_scores=True,\n+        )\n+\n+        transition_scores = model.compute_transition_scores(outputs.sequences, outputs.scores, normalize_logits=True)\n+        transition_scores = transition_scores.cpu().numpy()\n+\n+        expected_scores = np.array(\n+            [\n+                [-2.538938, -2.2694316, -2.1580915, -1.572299, -2.6719835],\n+                [-1.8826028, -2.2461371, -1.7556462, -2.9644494, -1.7996008],\n+            ]\n+        )\n+        self.assertTrue(np.allclose(transition_scores, expected_scores, atol=1e-3))\n+\n+    def test_transition_scores_beam_search_encoder_decoder(self):\n+        \"\"\"\n+        Test that `compute_transition_scores` is working as expected with beam search and encoder-decoder models\n+        \"\"\"\n+        articles = [\n+            \"Justin Timberlake and Jessica Biel, welcome to parenthood.\",\n+            \"Michael Phelps is arguably the most decorated Olympian of all time.\",\n+        ]\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n+        model = AutoModelForSeq2SeqLM.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n+        input_ids = tokenizer(articles, return_tensors=\"pt\", padding=True).input_ids\n+        model = model.to(torch_device)\n+        input_ids = input_ids.to(torch_device)\n+\n+        outputs = model.generate(\n+            input_ids=input_ids,\n+            max_length=10,\n+            num_beams=4,\n+            num_return_sequences=2,\n+            eos_token_id=None,\n+            return_dict_in_generate=True,\n+            output_scores=True,\n+            length_penalty=0.0,\n+        )\n+\n+        transition_scores = model.compute_transition_scores(outputs.sequences, outputs.scores, outputs.beam_indices)\n+        transition_scores = transition_scores.cpu().numpy()\n+        outputs.sequences_scores = outputs.sequences_scores.cpu().numpy()\n+\n+        self.assertTrue(np.allclose(np.sum(transition_scores, axis=-1), outputs.sequences_scores, atol=1e-3))\n+\n+    def test_transition_scores_beam_search_encoder_decoder_with_eos(self):\n+        \"\"\"\n+        Test that `compute_transition_scores` is working as expected with beam search and encoder-decoder models, when\n+        an EOS token is defined\n+        \"\"\"\n+        articles = [\n+            \"Justin Timberlake and Jessica Biel, welcome to parenthood.\",\n+            \"Michael Phelps is arguably the most decorated Olympian of all time.\",\n+        ]\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n+\n+        model = AutoModelForSeq2SeqLM.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n+        input_ids = tokenizer(articles, return_tensors=\"pt\", padding=True).input_ids\n+        model = model.to(torch_device)\n+        input_ids = input_ids.to(torch_device)\n+\n+        outputs = model.generate(\n+            input_ids=input_ids,\n+            max_length=10,\n+            num_beams=4,\n+            num_return_sequences=2,\n+            return_dict_in_generate=True,\n+            output_scores=True,\n+            length_penalty=0.0,\n+        )\n+\n+        transition_scores = model.compute_transition_scores(outputs.sequences, outputs.scores, outputs.beam_indices)\n+        transition_scores = transition_scores.cpu().numpy()\n+        outputs.sequences_scores = outputs.sequences_scores.cpu().numpy()\n+\n+        self.assertTrue(np.allclose(np.sum(transition_scores, axis=-1), outputs.sequences_scores, atol=1e-3))\n+\n+    def test_transition_scores_beam_search_decoder_only(self):\n+        \"\"\"\n+        Test that `compute_transition_scores` is working as expected with beam search and decoder-only models\n+        \"\"\"\n+        articles = [\n+            \"Justin Timberlake\",\n+            \"Michael Phelps\",\n+        ]\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n+        tokenizer.pad_token = tokenizer.eos_token\n+\n+        model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n+        input_ids = tokenizer(articles, return_tensors=\"pt\", padding=True).input_ids\n+        model = model.to(torch_device)\n+        input_ids = input_ids.to(torch_device)\n+\n+        outputs = model.generate(\n+            input_ids=input_ids,\n+            max_length=10,\n+            num_beams=4,\n+            num_return_sequences=2,\n+            pad_token_id=tokenizer.eos_token_id,\n+            eos_token_id=None,\n+            return_dict_in_generate=True,\n+            output_scores=True,\n+            length_penalty=0.0,\n+        )\n+\n+        transition_scores = model.compute_transition_scores(outputs.sequences, outputs.scores, outputs.beam_indices)\n+        transition_scores = transition_scores.cpu().numpy()\n+        outputs.sequences_scores = outputs.sequences_scores.cpu().numpy()\n+\n+        self.assertTrue(np.allclose(np.sum(transition_scores, axis=-1), outputs.sequences_scores, atol=1e-3))\n+\n+    @slow\n+    def test_transition_scores_early_stopping(self):\n+        \"\"\"\n+        Test that `compute_transition_scores` is working as expected with beam search and early stopping\n+\n+        This is an aggressive test that makes sure that `beam_search's`\n+        transition scores are computed correctly for varying `num_return_sequences`, `num_beams` and `batch_size > 1`\n+        2 x input_ids for \"question: How are you? \\n context: I had a long day, \"\n+        \"\"\"\n+        input_ids = torch.tensor(2 * [[822, 10, 571, 33, 25, 58, 2625, 10, 27, 141, 3, 9, 307, 239, 6, 1]])\n+        model = AutoModelForSeq2SeqLM.from_pretrained(\"google-t5/t5-small\")\n+        model = model.to(torch_device)\n+        input_ids = input_ids.to(torch_device)\n+\n+        outputs = model.generate(\n+            input_ids,\n+            max_length=10,\n+            return_dict_in_generate=True,\n+            output_scores=True,\n+            forced_eos_token_id=model.config.eos_token_id,\n+            num_beams=4,\n+            do_sample=False,\n+            num_return_sequences=3,\n+            length_penalty=0.0,\n+        )\n+\n+        transition_scores = model.compute_transition_scores(\n+            sequences=outputs.sequences, scores=outputs.scores, beam_indices=outputs.beam_indices\n+        )\n+        transition_scores = transition_scores.cpu().numpy()\n+        outputs.sequences_scores = outputs.sequences_scores.cpu().numpy()\n+\n+        self.assertTrue(np.allclose(np.sum(transition_scores, axis=-1), outputs.sequences_scores))\n+\n+    def test_encoder_decoder_generate_attention_mask(self):\n+        \"\"\"\n+        Test that `generate` automagically creates the correct `attention_mask` for encoder-decoder models (which\n+        has a different keyword)\n+        \"\"\"\n+        articles = [\"Timberlake\", \"Jessica Biel, welcome to parenthood among other things\"]\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n+        # need extreme generation values here to force this test\n+        # to fail when `attention_mask` is not correctly treated in generate\n+        model = AutoModelForSeq2SeqLM.from_pretrained(\n+            \"hf-internal-testing/tiny-random-bart\",\n+        )\n+        model.config.eos_token_id = None\n+        input_ids = tokenizer(articles[0], return_tensors=\"pt\").input_ids\n+        input_ids_batched = tokenizer(articles, padding=True, return_tensors=\"pt\").input_ids\n+        model = model.to(torch_device)\n+        input_ids = input_ids.to(torch_device)\n+        input_ids_batched = input_ids_batched.to(torch_device)\n+\n+        generate_kwargs = {\n+            \"return_dict_in_generate\": True,\n+            \"output_scores\": True,\n+            \"max_length\": 50,\n+            \"num_beams\": 5,\n+            \"num_return_sequences\": 5,\n+        }\n+\n+        output_sequences_batched = model.generate(input_ids=input_ids_batched, **generate_kwargs)\n+        output_sequences = model.generate(input_ids=input_ids, **generate_kwargs)\n+\n+        batched_out = output_sequences_batched.sequences_scores\n+        out = output_sequences.sequences_scores\n+        batched_out = batched_out.cpu().numpy()\n+        out = out.cpu().numpy()\n+\n+        diff = np.abs(np.sum(batched_out[:5]) - np.sum(out))\n+        self.assertTrue(diff < 1e-4)\n+\n+    def test_generate_input_ids_as_kwarg(self):\n+        \"\"\"Test that `input_ids` work equaly as a positional and keyword argument in decoder-only models\"\"\"\n+        article = \"I need input_ids to generate\"\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n+        model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\", max_length=15)\n+        input_ids = tokenizer(article, return_tensors=\"pt\").input_ids\n+        model = model.to(torch_device)\n+        input_ids = input_ids.to(torch_device)\n+\n+        output_sequences_kwargs = model.generate(input_ids=input_ids)\n+        output_sequences = model.generate(input_ids)\n+        output_sequences_kwargs = output_sequences_kwargs.cpu().numpy()\n+        output_sequences = output_sequences.cpu().numpy()\n+\n+        self.assertTrue(np.array_equal(output_sequences, output_sequences_kwargs))\n+        self.assertEqual(output_sequences.shape, (1, 15))\n+\n+    def test_generate_input_ids_as_encoder_kwarg(self):\n+        \"\"\"Test that `input_ids` work equaly as a positional and keyword argument in encoder-decoder models\"\"\"\n+        article = \"Justin Timberlake and Jessica Biel, welcome to parenthood.\"\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n+        model = AutoModelForSeq2SeqLM.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n+        model.config.eos_token_id = None\n+        input_ids = tokenizer(article, return_tensors=\"pt\").input_ids\n+        model = model.to(torch_device)\n+        input_ids = input_ids.to(torch_device)\n+\n+        output_sequences_kwargs = model.generate(input_ids=input_ids, max_length=5)\n+        output_sequences = model.generate(input_ids, max_length=5)\n+        output_sequences_kwargs = output_sequences_kwargs.cpu().numpy()\n+        output_sequences = output_sequences.cpu().numpy()\n+\n+        self.assertTrue(np.array_equal(output_sequences, output_sequences_kwargs))\n+        self.assertEqual(output_sequences.shape, (1, 5))\n+\n+    def test_generate_inputs_and_encoder_kwargs(self):\n+        \"\"\"\n+        Test that an exception is thrown if the main tensor (`input_ids` in LLMs) is passed as both a positional and\n+        keyword argument\n+        \"\"\"\n+        article = \"I need input_ids to generate\"\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n+        model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\", max_length=10)\n+        input_ids = tokenizer(article, return_tensors=\"pt\").input_ids\n+        with self.assertRaises(ValueError):\n+            model.generate(input_ids, input_ids=input_ids)\n+\n+    def test_generate_too_many_encoder_kwargs(self):\n+        \"\"\"Test that passing redundant inputs results in an exception (`input_ids` and `inputs_embeds` in LLMs)\"\"\"\n+        article = \"I need input_ids to generate\"\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-bart\")\n+        model = AutoModelForSeq2SeqLM.from_pretrained(\"hf-internal-testing/tiny-random-bart\", max_length=10)\n+        input_ids = tokenizer(article, return_tensors=\"pt\").input_ids\n+        with self.assertRaises(ValueError):\n+            model.generate(input_ids=input_ids, inputs_embeds=input_ids)\n+\n+    def test_generate_input_features_as_encoder_kwarg(self):\n+        \"\"\"Test that non-`input_ids` main model inputs are correctly handled as positional arguments\"\"\"\n+        input_features = floats_tensor((3, 80, 60))\n+        model = AutoModelForSpeechSeq2Seq.from_pretrained(\n+            \"hf-internal-testing/tiny-random-WhisperForConditionalGeneration\"\n+        )\n+        input_features.to(torch_device)\n+        model = model.to(torch_device)\n+\n+        output_sequences_kwargs = model.generate(input_features=input_features, max_length=5)\n+        output_sequences = model.generate(input_features, max_length=5)\n+        output_sequences_kwargs = output_sequences_kwargs.cpu().numpy()\n+        output_sequences = output_sequences.cpu().numpy()\n+\n+        self.assertTrue(np.array_equal(output_sequences, output_sequences_kwargs))\n+        self.assertEqual(output_sequences.shape, (3, 5))\n+\n+    def test_generate_encoder_outputs_attention_mask(self):\n+        \"\"\"Test that `generate` can handle attention masks when the encoder outputs are passed\"\"\"\n+        input_features = floats_tensor((3, 80, 60))\n+        attention_mask = torch.randint(0, 2, input_features.shape).to(torch_device)\n+        model = AutoModelForSpeechSeq2Seq.from_pretrained(\n+            \"hf-internal-testing/tiny-random-WhisperForConditionalGeneration\"\n+        )\n+        input_features = input_features.to(torch_device)\n+        attention_mask = attention_mask.to(torch_device)\n+        model = model.to(torch_device)\n+\n+        encoder = model.get_encoder()\n+        encoder_outputs = encoder(input_features)\n+\n+        output_sequences_no_mask = model.generate(encoder_outputs=encoder_outputs)\n+        output_sequences_with_mask = model.generate(encoder_outputs=encoder_outputs, attention_mask=attention_mask)\n+        output_sequences_no_mask = output_sequences_no_mask.cpu().numpy()\n+        output_sequences_with_mask = output_sequences_with_mask.cpu().numpy()\n+\n+        self.assertFalse(np.array_equal(output_sequences_no_mask, output_sequences_with_mask))\n+\n+    def test_eos_token_id_int_and_list_greedy_search(self):\n+        \"\"\"Test that `generate` can handle multiple EOS tokens\"\"\"\n+        generation_kwargs = {\n+            \"do_sample\": False,\n+            \"num_beams\": 1,\n+        }\n+        expectation = 13\n+\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n+        text = \"\"\"Hello, my dog is cute and\"\"\"\n+        tokens = tokenizer(text, return_tensors=\"pt\")\n+        model = AutoModelForCausalLM.from_pretrained(\"hf-internal-testing/tiny-random-gpt2\")\n+        model = model.to(torch_device)\n+        tokens = tokens.to(torch_device)\n+\n+        eos_token_id = 873\n+        generated_tokens = model.generate(**tokens, eos_token_id=eos_token_id, **generation_kwargs)\n+        self.assertTrue(expectation == len(generated_tokens[0]))\n+\n+        eos_token_id = [873, 198]\n+        generated_tokens = model.generate(**tokens, eos_token_id=eos_token_id, **generation_kwargs)\n+        self.assertTrue(expectation == len(generated_tokens[0]))\n+\n+    def test_generate_vision2text_conditioning(self):\n+        \"\"\"Test that `decoder_input_ids` can be used to condition the generation in vision-to-text models\"\"\"\n+        pixel_values = floats_tensor((2, 3, 30, 30))\n+        conditioning_input = torch.tensor([[10], [10]])  # this should be the 2nd output token, after the BOS token\n+        model = AutoModelForVision2Seq.from_pretrained(\n+            \"hf-internal-testing/tiny-random-VisionEncoderDecoderModel-vit-gpt2\"\n+        )\n+        pixel_values = pixel_values.to(torch_device)\n+        model = model.to(torch_device)\n+        conditioning_input = conditioning_input.to(torch_device)\n+\n+        # we can condition on decoder_input_ids (expected decoder input) and input_ids (which we pipe internally as\n+        # decoder_input_ids, if the encoder is not a model with text input)\n+        output_sequences_decoder_input_ids = model.generate(\n+            pixel_values, max_length=5, decoder_input_ids=conditioning_input\n+        )\n+        output_sequences_input_ids = model.generate(pixel_values, max_length=5, input_ids=conditioning_input)\n+        output_sequences_decoder_input_ids = output_sequences_decoder_input_ids.cpu().numpy()\n+        output_sequences_input_ids = output_sequences_input_ids.cpu().numpy()\n+        conditioning_input = conditioning_input.cpu().numpy()\n+\n+        self.assertTrue(np.array_equal(output_sequences_decoder_input_ids, output_sequences_input_ids))\n+        self.assertTrue(np.array_equal(output_sequences_decoder_input_ids[:, 1:2], conditioning_input))\n+\n \n @require_torch\n class TokenHealingTestCase(unittest.TestCase):"
        },
        {
            "sha": "df2c689133e8390d5a3e64c247bffb7075d142ce",
            "filename": "tests/models/bart/test_modeling_flax_bart.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fbart%2Ftest_modeling_flax_bart.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fbart%2Ftest_modeling_flax_bart.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fbart%2Ftest_modeling_flax_bart.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -19,7 +19,6 @@\n from transformers import BartConfig, BartTokenizer, is_flax_available\n from transformers.testing_utils import require_flax, slow\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, floats_tensor, ids_tensor, random_attention_mask\n \n \n@@ -324,7 +323,7 @@ def test_shift_tokens_right(self):\n \n \n @require_flax\n-class FlaxBartModelTest(FlaxModelTesterMixin, unittest.TestCase, FlaxGenerationTesterMixin):\n+class FlaxBartModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     is_encoder_decoder = True\n     all_model_classes = (\n         ("
        },
        {
            "sha": "09af037e9ca2a7cc343d3f587f238943c85819ff",
            "filename": "tests/models/blenderbot/test_modeling_flax_blenderbot.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fblenderbot%2Ftest_modeling_flax_blenderbot.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fblenderbot%2Ftest_modeling_flax_blenderbot.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fblenderbot%2Ftest_modeling_flax_blenderbot.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -20,7 +20,6 @@\n from transformers import BlenderbotConfig, is_flax_available\n from transformers.testing_utils import jax_device, require_flax, slow\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor\n \n \n@@ -309,7 +308,7 @@ def test_shift_tokens_right(self):\n \n \n @require_flax\n-class FlaxBlenderbotModelTest(FlaxModelTesterMixin, unittest.TestCase, FlaxGenerationTesterMixin):\n+class FlaxBlenderbotModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     is_encoder_decoder = True\n     all_model_classes = (\n         ("
        },
        {
            "sha": "7818dd67c7c32b746fe5e62c7fe4d5aef0762ab4",
            "filename": "tests/models/blenderbot_small/test_modeling_flax_blenderbot_small.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fblenderbot_small%2Ftest_modeling_flax_blenderbot_small.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fblenderbot_small%2Ftest_modeling_flax_blenderbot_small.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fblenderbot_small%2Ftest_modeling_flax_blenderbot_small.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -20,7 +20,6 @@\n from transformers import BlenderbotSmallConfig, is_flax_available\n from transformers.testing_utils import require_flax, slow\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor\n \n \n@@ -308,7 +307,7 @@ def test_shift_tokens_right(self):\n \n \n @require_flax\n-class FlaxBlenderbotSmallModelTest(FlaxModelTesterMixin, unittest.TestCase, FlaxGenerationTesterMixin):\n+class FlaxBlenderbotSmallModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     is_encoder_decoder = True\n     all_model_classes = (\n         ("
        },
        {
            "sha": "60b865a45fe276f4767d791ea74204b0f310ea6c",
            "filename": "tests/models/bloom/test_modeling_flax_bloom.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fbloom%2Ftest_modeling_flax_bloom.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fbloom%2Ftest_modeling_flax_bloom.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fbloom%2Ftest_modeling_flax_bloom.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -18,7 +18,6 @@\n from transformers import BloomConfig, BloomTokenizerFast, is_flax_available\n from transformers.testing_utils import require_flax, slow\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor\n \n \n@@ -169,7 +168,7 @@ def check_use_cache_forward_with_attn_mask(self, model_class_name, config, input\n \n \n @require_flax\n-class FlaxBloomModelTest(FlaxModelTesterMixin, unittest.TestCase, FlaxGenerationTesterMixin):\n+class FlaxBloomModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     all_model_classes = (FlaxBloomModel, FlaxBloomForCausalLM) if is_flax_available() else ()\n \n     def setUp(self):"
        },
        {
            "sha": "e8582268fee982abffb28ea7acdeb5aeea1e4259",
            "filename": "tests/models/gemma/test_modeling_flax_gemma.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fgemma%2Ftest_modeling_flax_gemma.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fgemma%2Ftest_modeling_flax_gemma.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgemma%2Ftest_modeling_flax_gemma.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -18,7 +18,6 @@\n from transformers import AutoTokenizer, GemmaConfig, is_flax_available\n from transformers.testing_utils import require_flax, require_read_token, slow\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor\n \n \n@@ -174,7 +173,7 @@ def check_use_cache_forward_with_attn_mask(self, model_class_name, config, input\n \n \n @require_flax\n-class FlaxGemmaModelTest(FlaxModelTesterMixin, FlaxGenerationTesterMixin, unittest.TestCase):\n+class FlaxGemmaModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     all_model_classes = (FlaxGemmaModel, FlaxGemmaForCausalLM) if is_flax_available() else ()\n \n     def setUp(self):"
        },
        {
            "sha": "3b80cd52bdef819a99465dde5c77b233c7f289eb",
            "filename": "tests/models/gpt2/test_modeling_flax_gpt2.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fgpt2%2Ftest_modeling_flax_gpt2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fgpt2%2Ftest_modeling_flax_gpt2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgpt2%2Ftest_modeling_flax_gpt2.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -22,7 +22,6 @@\n from transformers import GPT2Config, GPT2Tokenizer, is_flax_available, is_torch_available\n from transformers.testing_utils import is_pt_flax_cross_test, require_flax, slow\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, floats_tensor, ids_tensor, random_attention_mask\n \n \n@@ -209,7 +208,7 @@ def check_bool_attention_mask_in_generation(self, model_class_name, config, inpu\n \n \n @require_flax\n-class FlaxGPT2ModelTest(FlaxModelTesterMixin, FlaxGenerationTesterMixin, unittest.TestCase):\n+class FlaxGPT2ModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     all_model_classes = (FlaxGPT2Model, FlaxGPT2LMHeadModel) if is_flax_available() else ()\n \n     def setUp(self):"
        },
        {
            "sha": "6875a46299fc737fe2f3aa82edc72f4e42c5909a",
            "filename": "tests/models/gpt_neo/test_modeling_flax_gpt_neo.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fgpt_neo%2Ftest_modeling_flax_gpt_neo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fgpt_neo%2Ftest_modeling_flax_gpt_neo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgpt_neo%2Ftest_modeling_flax_gpt_neo.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -22,7 +22,6 @@\n from transformers import GPT2Tokenizer, GPTNeoConfig, is_flax_available, is_torch_available\n from transformers.testing_utils import is_pt_flax_cross_test, require_flax, slow\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor, random_attention_mask\n \n \n@@ -181,7 +180,7 @@ def check_use_cache_forward_with_attn_mask(self, model_class_name, config, input\n \n \n @require_flax\n-class FlaxGPTNeoModelTest(FlaxModelTesterMixin, FlaxGenerationTesterMixin, unittest.TestCase):\n+class FlaxGPTNeoModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     all_model_classes = (FlaxGPTNeoModel, FlaxGPTNeoForCausalLM) if is_flax_available() else ()\n \n     def setUp(self):"
        },
        {
            "sha": "09f2aa99d7ea6a105b97a72c4f43ee450559f466",
            "filename": "tests/models/gptj/test_modeling_flax_gptj.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fgptj%2Ftest_modeling_flax_gptj.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fgptj%2Ftest_modeling_flax_gptj.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgptj%2Ftest_modeling_flax_gptj.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -22,7 +22,6 @@\n from transformers import GPT2Tokenizer, GPTJConfig, is_flax_available, is_torch_available\n from transformers.testing_utils import is_pt_flax_cross_test, require_flax, tooslow\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor, random_attention_mask\n \n \n@@ -178,7 +177,7 @@ def check_use_cache_forward_with_attn_mask(self, model_class_name, config, input\n \n \n @require_flax\n-class FlaxGPTJModelTest(FlaxModelTesterMixin, FlaxGenerationTesterMixin, unittest.TestCase):\n+class FlaxGPTJModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     all_model_classes = (FlaxGPTJModel, FlaxGPTJForCausalLM) if is_flax_available() else ()\n \n     def setUp(self):"
        },
        {
            "sha": "e4d9418bec1c66eb7a1a772a529a6e5f8c24b4a0",
            "filename": "tests/models/llama/test_modeling_flax_llama.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fllama%2Ftest_modeling_flax_llama.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fllama%2Ftest_modeling_flax_llama.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fllama%2Ftest_modeling_flax_llama.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -20,7 +20,6 @@\n from transformers import LlamaConfig, is_flax_available, is_tokenizers_available\n from transformers.testing_utils import require_flax, slow\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor\n \n \n@@ -174,7 +173,7 @@ def check_use_cache_forward_with_attn_mask(self, model_class_name, config, input\n \n \n @require_flax\n-class FlaxLlamaModelTest(FlaxModelTesterMixin, FlaxGenerationTesterMixin, unittest.TestCase):\n+class FlaxLlamaModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     all_model_classes = (FlaxLlamaModel, FlaxLlamaForCausalLM) if is_flax_available() else ()\n \n     def setUp(self):"
        },
        {
            "sha": "fa8673ec439ab05c5155d24e8a0c3d7940e321ff",
            "filename": "tests/models/longt5/test_modeling_flax_longt5.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Flongt5%2Ftest_modeling_flax_longt5.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Flongt5%2Ftest_modeling_flax_longt5.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Flongt5%2Ftest_modeling_flax_longt5.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -28,7 +28,6 @@\n     slow,\n )\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_configuration_common import ConfigTester\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor\n \n@@ -235,7 +234,7 @@ def prepare_config_and_inputs_for_common(self):\n \n \n @require_flax\n-class FlaxLongT5ModelTest(FlaxModelTesterMixin, FlaxGenerationTesterMixin, unittest.TestCase):\n+class FlaxLongT5ModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     all_model_classes = (FlaxLongT5Model, FlaxLongT5ForConditionalGeneration) if is_flax_available() else ()\n     is_encoder_decoder = True\n "
        },
        {
            "sha": "4353bd173235852cfd13086d34572900aad66ca2",
            "filename": "tests/models/marian/test_modeling_flax_marian.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fmarian%2Ftest_modeling_flax_marian.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fmarian%2Ftest_modeling_flax_marian.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmarian%2Ftest_modeling_flax_marian.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -21,7 +21,6 @@\n from transformers.testing_utils import require_flax, require_sentencepiece, require_tokenizers, slow\n from transformers.utils import cached_property\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor\n \n \n@@ -228,7 +227,7 @@ def check_use_cache_forward_with_attn_mask(self, model_class_name, config, input\n \n \n @require_flax\n-class FlaxMarianModelTest(FlaxModelTesterMixin, unittest.TestCase, FlaxGenerationTesterMixin):\n+class FlaxMarianModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     is_encoder_decoder = True\n     all_model_classes = (FlaxMarianModel, FlaxMarianMTModel) if is_flax_available() else ()\n "
        },
        {
            "sha": "bacecec8571eec1976e91d82b258a30c0ace0774",
            "filename": "tests/models/mbart/test_modeling_flax_mbart.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fmbart%2Ftest_modeling_flax_mbart.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fmbart%2Ftest_modeling_flax_mbart.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmbart%2Ftest_modeling_flax_mbart.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -21,7 +21,6 @@\n from transformers.testing_utils import require_flax, require_sentencepiece, require_tokenizers, slow\n from transformers.utils import cached_property\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor\n \n \n@@ -330,7 +329,7 @@ def test_shift_tokens_right(self):\n \n \n @require_flax\n-class FlaxMBartModelTest(FlaxModelTesterMixin, unittest.TestCase, FlaxGenerationTesterMixin):\n+class FlaxMBartModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     is_encoder_decoder = True\n     all_model_classes = (\n         ("
        },
        {
            "sha": "14c91be258f98d5650d4740fb965f7cdcba36aa8",
            "filename": "tests/models/mistral/test_modeling_flax_mistral.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fmistral%2Ftest_modeling_flax_mistral.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fmistral%2Ftest_modeling_flax_mistral.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmistral%2Ftest_modeling_flax_mistral.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -20,7 +20,6 @@\n from transformers import MistralConfig, is_flax_available, is_tokenizers_available\n from transformers.testing_utils import require_flax, slow\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor\n \n \n@@ -185,7 +184,7 @@ def check_use_cache_forward_with_attn_mask(self, model_class_name, config, input\n \n \n @require_flax\n-class FlaxMistralModelTest(FlaxModelTesterMixin, FlaxGenerationTesterMixin, unittest.TestCase):\n+class FlaxMistralModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     all_model_classes = (FlaxMistralModel, FlaxMistralForCausalLM) if is_flax_available() else ()\n \n     def setUp(self):"
        },
        {
            "sha": "dd4eff6ba908d9330b1869711e8f765aeb99dc89",
            "filename": "tests/models/mistral/test_modeling_tf_mistral.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fmistral%2Ftest_modeling_tf_mistral.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fmistral%2Ftest_modeling_tf_mistral.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmistral%2Ftest_modeling_tf_mistral.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -24,7 +24,6 @@\n     slow,\n )\n \n-from ...generation.test_tf_utils import TFGenerationIntegrationTests\n from ...test_configuration_common import ConfigTester\n from ...test_modeling_tf_common import TFModelTesterMixin, ids_tensor, random_attention_mask\n from ...test_pipeline_mixin import PipelineTesterMixin\n@@ -244,7 +243,7 @@ def prepare_config_and_inputs_for_common(self):\n \n \n @require_tf\n-class TFMistralModelTest(TFModelTesterMixin, TFGenerationIntegrationTests, PipelineTesterMixin, unittest.TestCase):\n+class TFMistralModelTest(TFModelTesterMixin, PipelineTesterMixin, unittest.TestCase):\n     all_model_classes = (\n         (TFMistralModel, TFMistralForCausalLM, TFMistralForSequenceClassification) if is_tf_available() else ()\n     )"
        },
        {
            "sha": "0b943de559da743c976e54c8adc0b00d49cca433",
            "filename": "tests/models/opt/test_modeling_flax_opt.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fopt%2Ftest_modeling_flax_opt.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fopt%2Ftest_modeling_flax_opt.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fopt%2Ftest_modeling_flax_opt.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -19,7 +19,6 @@\n from transformers import OPTConfig, is_flax_available\n from transformers.testing_utils import require_flax, require_sentencepiece, slow\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor\n \n \n@@ -203,7 +202,7 @@ def check_use_cache_forward_with_attn_mask(self, model_class_name, config, input\n \n \n @require_flax\n-class FlaxOPTModelTest(FlaxModelTesterMixin, unittest.TestCase, FlaxGenerationTesterMixin):\n+class FlaxOPTModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     all_model_classes = (FlaxOPTModel, FlaxOPTForCausalLM) if is_flax_available() else ()\n \n     def setUp(self):"
        },
        {
            "sha": "a07f32350d95de6bcd86f1a80addd3ba4d8a94ea",
            "filename": "tests/models/speech_to_text/test_modeling_tf_speech_to_text.py",
            "status": "modified",
            "additions": 0,
            "deletions": 76,
            "changes": 76,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fspeech_to_text%2Ftest_modeling_tf_speech_to_text.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fspeech_to_text%2Ftest_modeling_tf_speech_to_text.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fspeech_to_text%2Ftest_modeling_tf_speech_to_text.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -416,82 +416,6 @@ def test_resize_embeddings_untied(self):\n     def test_generate_without_input_ids(self):\n         pass\n \n-    # overwritten from parent due to the inability to work when non-text inputs are not passed AND because the input is\n-    # `input_features`\n-    def test_lm_head_model_random_no_beam_search_generate(self):\n-        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-        input_features = inputs_dict.get(\"input_features\", None)\n-\n-        # iterate over all generative models\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            if config.bos_token_id is None:\n-                # if bos token id is not defined model needs input_features\n-                with self.assertRaises(AssertionError):\n-                    model.generate(do_sample=True, max_length=5)\n-                # num_return_sequences = 1\n-                self._check_generated_ids(model.generate(input_features, do_sample=True))\n-\n-            with self.assertRaises(ValueError):\n-                # generating multiple sequences when no beam search generation\n-                # is not allowed as it would always generate the same sequences\n-                model.generate(input_features, do_sample=False, num_return_sequences=2)\n-\n-            # num_return_sequences > 1, sample\n-            self._check_generated_ids(model.generate(input_features, do_sample=True, num_return_sequences=2))\n-\n-            # check bad words tokens language generation\n-            # create list of 1-seq bad token and list of 2-seq of bad tokens\n-            bad_words_ids = [self._generate_random_bad_tokens(1, model), self._generate_random_bad_tokens(2, model)]\n-            output_tokens = model.generate(\n-                input_features, do_sample=True, bad_words_ids=bad_words_ids, num_return_sequences=2\n-            )\n-            # only count generated tokens\n-            generated_ids = output_tokens[:, input_features.shape[-1] :]\n-            self.assertFalse(self._check_match_tokens(generated_ids.numpy().tolist(), bad_words_ids))\n-\n-    # overwritten from parent due to the inability to work when non-text inputs are not passed AND because the input is\n-    # `input_features`\n-    def test_lm_head_model_random_beam_search_generate(self):\n-        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-        input_features = inputs_dict.get(\"input_features\", None)\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            if config.bos_token_id is None:\n-                # if bos token id is not defined model needs input_ids, num_return_sequences = 1\n-                self._check_generated_ids(model.generate(input_features, do_sample=True, num_beams=2))\n-\n-            with self.assertRaises(ValueError):\n-                # generating more sequences than having beams leads is not possible\n-                model.generate(input_features, do_sample=False, num_return_sequences=3, num_beams=2)\n-\n-            # num_return_sequences > 1, sample\n-            self._check_generated_ids(\n-                model.generate(\n-                    input_features,\n-                    do_sample=True,\n-                    num_beams=2,\n-                    num_return_sequences=2,\n-                )\n-            )\n-            # num_return_sequences > 1, greedy\n-            self._check_generated_ids(\n-                model.generate(input_features, do_sample=False, num_beams=2, num_return_sequences=2)\n-            )\n-\n-            # check bad words tokens language generation\n-            # create list of 1-seq bad token and list of 2-seq of bad tokens\n-            bad_words_ids = [self._generate_random_bad_tokens(1, model), self._generate_random_bad_tokens(2, model)]\n-            output_tokens = model.generate(\n-                input_features, do_sample=False, bad_words_ids=bad_words_ids, num_beams=2, num_return_sequences=2\n-            )\n-            # only count generated tokens\n-            generated_ids = output_tokens[:, input_features.shape[-1] :]\n-            self.assertFalse(self._check_match_tokens(generated_ids.numpy().tolist(), bad_words_ids))\n-\n     # overwritten from parent -- the input is `input_features`, not `input_ids`\n     def test_forward_signature(self):\n         config, _ = self.model_tester.prepare_config_and_inputs_for_common()"
        },
        {
            "sha": "963bf91716d134009ebbb4f37acb4f59f6914523",
            "filename": "tests/models/t5/test_modeling_flax_t5.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Ft5%2Ftest_modeling_flax_t5.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Ft5%2Ftest_modeling_flax_t5.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Ft5%2Ftest_modeling_flax_t5.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -27,7 +27,6 @@\n     slow,\n )\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_configuration_common import ConfigTester\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor\n \n@@ -227,7 +226,7 @@ def prepare_config_and_inputs_for_common(self):\n \n \n @require_flax\n-class FlaxT5ModelTest(FlaxModelTesterMixin, FlaxGenerationTesterMixin, unittest.TestCase):\n+class FlaxT5ModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     all_model_classes = (FlaxT5Model, FlaxT5ForConditionalGeneration) if is_flax_available() else ()\n     is_encoder_decoder = True\n "
        },
        {
            "sha": "6e47a1b40b6402e50a382b845e9f06feacdbbde3",
            "filename": "tests/models/whisper/test_modeling_tf_whisper.py",
            "status": "modified",
            "additions": 0,
            "deletions": 121,
            "changes": 121,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fwhisper%2Ftest_modeling_tf_whisper.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fwhisper%2Ftest_modeling_tf_whisper.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fwhisper%2Ftest_modeling_tf_whisper.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -524,127 +524,6 @@ def test_attention_outputs(self):\n                 [self.model_tester.num_attention_heads, subsampled_encoder_seq_length, subsampled_encoder_key_length],\n             )\n \n-    def test_generate_without_input_ids(self):\n-        pass\n-\n-    # overwritten from parent due to the inability to work when non-text inputs are not passed AND because the input is\n-    # `input_features`\n-    def test_lm_head_model_random_no_beam_search_generate(self):\n-        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-        input_features = inputs_dict.get(\"input_features\", None)\n-\n-        # iterate over all generative models\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            if config.bos_token_id is None:\n-                # if bos token id is not defined model needs input_features\n-                with self.assertRaises(AssertionError):\n-                    model.generate(do_sample=True, max_length=5)\n-                # num_return_sequences = 1\n-                self._check_generated_ids(model.generate(input_features, do_sample=True))\n-\n-            with self.assertRaises(ValueError):\n-                # generating multiple sequences when no beam search generation\n-                # is not allowed as it would always generate the same sequences\n-                model.generate(input_features, do_sample=False, num_return_sequences=2)\n-\n-            # num_return_sequences > 1, sample\n-            self._check_generated_ids(model.generate(input_features, do_sample=True, num_return_sequences=2))\n-\n-            # check bad words tokens language generation\n-            # create list of 1-seq bad token and list of 2-seq of bad tokens\n-            bad_words_ids = [self._generate_random_bad_tokens(1, model), self._generate_random_bad_tokens(2, model)]\n-            output_tokens = model.generate(\n-                input_features, do_sample=True, bad_words_ids=bad_words_ids, num_return_sequences=2\n-            )\n-            # only count generated tokens\n-            generated_ids = output_tokens[:, input_features.shape[-1] :]\n-            self.assertFalse(self._check_match_tokens(generated_ids.numpy().tolist(), bad_words_ids))\n-\n-    # overwritten from parent due to the inability to work when non-text inputs are not passed AND because the input is\n-    # `input_features`\n-    def test_lm_head_model_random_beam_search_generate(self):\n-        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-        input_features = inputs_dict.get(\"input_features\", None)\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            if config.bos_token_id is None:\n-                # if bos token id is not defined model needs input_ids, num_return_sequences = 1\n-                self._check_generated_ids(model.generate(input_features, do_sample=True, num_beams=2))\n-\n-            with self.assertRaises(ValueError):\n-                # generating more sequences than having beams leads is not possible\n-                model.generate(input_features, do_sample=False, num_return_sequences=3, num_beams=2)\n-\n-            # num_return_sequences > 1, sample\n-            self._check_generated_ids(\n-                model.generate(\n-                    input_features,\n-                    do_sample=True,\n-                    num_beams=2,\n-                    num_return_sequences=2,\n-                )\n-            )\n-            # num_return_sequences > 1, greedy\n-            self._check_generated_ids(\n-                model.generate(input_features, do_sample=False, num_beams=2, num_return_sequences=2)\n-            )\n-\n-            # check bad words tokens language generation\n-            # create list of 1-seq bad token and list of 2-seq of bad tokens\n-            bad_words_ids = [self._generate_random_bad_tokens(1, model), self._generate_random_bad_tokens(2, model)]\n-            output_tokens = model.generate(\n-                input_features, do_sample=False, bad_words_ids=bad_words_ids, num_beams=2, num_return_sequences=2\n-            )\n-            # only count generated tokens\n-            generated_ids = output_tokens[:, input_features.shape[-1] :]\n-            self.assertFalse(self._check_match_tokens(generated_ids.numpy().tolist(), bad_words_ids))\n-\n-    def test_generate_with_prompt_ids_and_task_and_language(self):\n-        config, input_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-        model = TFWhisperForConditionalGeneration(config)\n-        input_features = input_dict[\"input_features\"]\n-        prompt_ids = np.arange(5)\n-        language = \"<|de|>\"\n-        task = \"translate\"\n-        lang_id = 6\n-        task_id = 7\n-        model.generation_config.__setattr__(\"lang_to_id\", {language: lang_id})\n-        model.generation_config.__setattr__(\"task_to_id\", {task: task_id})\n-\n-        output = model.generate(input_features, max_new_tokens=5, task=task, language=language, prompt_ids=prompt_ids)\n-\n-        expected_output_start = [\n-            *prompt_ids.tolist(),\n-            model.generation_config.decoder_start_token_id,\n-            lang_id,\n-            task_id,\n-        ]\n-        for row in output.numpy().tolist():\n-            self.assertListEqual(row[: len(expected_output_start)], expected_output_start)\n-\n-    def test_generate_with_prompt_ids_and_forced_decoder_ids(self):\n-        config, input_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-        model = TFWhisperForConditionalGeneration(config)\n-        input_features = input_dict[\"input_features\"]\n-        prompt_ids = np.asarray(range(5))\n-        forced_decoder_ids = [(1, 6), (2, 7), (3, 8)]\n-\n-        output = model.generate(\n-            input_features, max_new_tokens=5, forced_decoder_ids=forced_decoder_ids, prompt_ids=prompt_ids\n-        )\n-\n-        expected_output_start = [\n-            *prompt_ids.tolist(),\n-            model.generation_config.decoder_start_token_id,\n-            *[token for _rank, token in forced_decoder_ids],\n-        ]\n-        for row in output.numpy().tolist():\n-            self.assertListEqual(row[: len(expected_output_start)], expected_output_start)\n-\n \n def _load_datasamples(num_samples):\n     ds = load_dataset(\"hf-internal-testing/librispeech_asr_dummy\", \"clean\", split=\"validation\")"
        },
        {
            "sha": "8dcdb8ae07313a58d2d2d99b610cdba58e72749e",
            "filename": "tests/models/xglm/test_modeling_flax_xglm.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fxglm%2Ftest_modeling_flax_xglm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Fmodels%2Fxglm%2Ftest_modeling_flax_xglm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fxglm%2Ftest_modeling_flax_xglm.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -21,7 +21,6 @@\n from transformers import XGLMConfig, XGLMTokenizer, is_flax_available, is_torch_available\n from transformers.testing_utils import is_pt_flax_cross_test, require_flax, require_sentencepiece, slow\n \n-from ...generation.test_flax_utils import FlaxGenerationTesterMixin\n from ...test_modeling_flax_common import FlaxModelTesterMixin, ids_tensor, random_attention_mask\n \n \n@@ -181,7 +180,7 @@ def check_use_cache_forward_with_attn_mask(self, model_class_name, config, input\n \n @require_sentencepiece\n @require_flax\n-class FlaxXGLMModelTest(FlaxModelTesterMixin, FlaxGenerationTesterMixin, unittest.TestCase):\n+class FlaxXGLMModelTest(FlaxModelTesterMixin, unittest.TestCase):\n     all_model_classes = (FlaxXGLMModel, FlaxXGLMForCausalLM) if is_flax_available() else ()\n \n     def setUp(self):"
        },
        {
            "sha": "309b1976b500d285ef1504b37068ed5d59e7ed07",
            "filename": "tests/test_modeling_tf_common.py",
            "status": "modified",
            "additions": 0,
            "deletions": 315,
            "changes": 315,
            "blob_url": "https://github.com/huggingface/transformers/blob/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Ftest_modeling_tf_common.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55493f13906acaa6fc1b90601098c50c3d0cb6a5/tests%2Ftest_modeling_tf_common.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Ftest_modeling_tf_common.py?ref=55493f13906acaa6fc1b90601098c50c3d0cb6a5",
            "patch": "@@ -70,16 +70,6 @@\n         TFAutoModelForSequenceClassification,\n         TFSharedEmbeddings,\n     )\n-    from transformers.generation import (\n-        TFBeamSampleDecoderOnlyOutput,\n-        TFBeamSampleEncoderDecoderOutput,\n-        TFBeamSearchDecoderOnlyOutput,\n-        TFBeamSearchEncoderDecoderOutput,\n-        TFGreedySearchDecoderOnlyOutput,\n-        TFGreedySearchEncoderDecoderOutput,\n-        TFSampleDecoderOnlyOutput,\n-        TFSampleEncoderDecoderOutput,\n-    )\n     from transformers.modeling_tf_utils import keras\n \n     tf.config.experimental.enable_tensor_float_32_execution(False)\n@@ -1211,150 +1201,6 @@ def test_embeddings_out_of_bounds_raise_exception(self):\n             with self.assertRaises(tf.errors.InvalidArgumentError):\n                 model(**prepared_inputs)\n \n-    def test_lm_head_model_random_no_beam_search_generate(self):\n-        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-        input_ids = inputs_dict.get(\"input_ids\", None)\n-\n-        # iterate over all generative models\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            if config.bos_token_id is None:\n-                # if bos token id is not defined model needs input_ids\n-                with self.assertRaises(ValueError):\n-                    model.generate(do_sample=True, max_length=5)\n-                # num_return_sequences = 1\n-                self._check_generated_ids(model.generate(input_ids, do_sample=True))\n-            elif model_class.__name__ not in [\"TFSpeech2TextForConditionalGeneration\"]:\n-                # Models with non-text inputs won't work here; num_return_sequences = 1\n-                self._check_generated_ids(model.generate(do_sample=True, max_length=5))\n-\n-            with self.assertRaises(ValueError):\n-                # generating multiple sequences when no beam search generation\n-                # is not allowed as it would always generate the same sequences\n-                model.generate(input_ids, do_sample=False, num_return_sequences=2)\n-\n-            # num_return_sequences > 1, sample\n-            self._check_generated_ids(model.generate(input_ids, do_sample=True, num_return_sequences=2))\n-\n-            # check bad words tokens language generation\n-            # create list of 1-seq bad token and list of 2-seq of bad tokens\n-            bad_words_ids = [self._generate_random_bad_tokens(1, model), self._generate_random_bad_tokens(2, model)]\n-            output_tokens = model.generate(\n-                input_ids, do_sample=True, bad_words_ids=bad_words_ids, num_return_sequences=2\n-            )\n-            # only count generated tokens\n-            generated_ids = output_tokens[:, input_ids.shape[-1] :]\n-            self.assertFalse(self._check_match_tokens(generated_ids.numpy().tolist(), bad_words_ids))\n-\n-    def test_lm_head_model_no_beam_search_generate_dict_outputs(self):\n-        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-        input_ids = inputs_dict.get(\"input_ids\", None)\n-        if input_ids is None:\n-            input_ids = inputs_dict.get(\"input_features\", None)\n-\n-        # iterate over all generative models\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-            output_greedy = model.generate(\n-                input_ids,\n-                do_sample=False,\n-                output_scores=True,\n-                output_hidden_states=True,\n-                output_attentions=True,\n-                return_dict_in_generate=True,\n-            )\n-            output_sample = model.generate(\n-                input_ids,\n-                do_sample=True,\n-                output_scores=True,\n-                output_hidden_states=True,\n-                output_attentions=True,\n-                return_dict_in_generate=True,\n-            )\n-\n-            if model.config.is_encoder_decoder:\n-                self.assertIsInstance(output_greedy, TFGreedySearchEncoderDecoderOutput)\n-                self.assertIsInstance(output_sample, TFSampleEncoderDecoderOutput)\n-            else:\n-                self.assertIsInstance(output_greedy, TFGreedySearchDecoderOnlyOutput)\n-                self.assertIsInstance(output_sample, TFSampleDecoderOnlyOutput)\n-\n-    def test_lm_head_model_random_beam_search_generate(self):\n-        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-        input_ids = inputs_dict.get(\"input_ids\", None)\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            if config.bos_token_id is None:\n-                # if bos token id is not defined model needs input_ids, num_return_sequences = 1\n-                self._check_generated_ids(model.generate(input_ids, do_sample=True, num_beams=2))\n-            else:\n-                # num_return_sequences = 1\n-                self._check_generated_ids(model.generate(do_sample=True, max_length=5, num_beams=2))\n-\n-            with self.assertRaises(ValueError):\n-                # generating more sequences than having beams leads is not possible\n-                model.generate(input_ids, do_sample=False, num_return_sequences=3, num_beams=2)\n-\n-            # num_return_sequences > 1, sample\n-            self._check_generated_ids(\n-                model.generate(\n-                    input_ids,\n-                    do_sample=True,\n-                    num_beams=2,\n-                    num_return_sequences=2,\n-                )\n-            )\n-            # num_return_sequences > 1, greedy\n-            self._check_generated_ids(model.generate(input_ids, do_sample=False, num_beams=2, num_return_sequences=2))\n-\n-            # check bad words tokens language generation\n-            # create list of 1-seq bad token and list of 2-seq of bad tokens\n-            bad_words_ids = [self._generate_random_bad_tokens(1, model), self._generate_random_bad_tokens(2, model)]\n-            output_tokens = model.generate(\n-                input_ids, do_sample=False, bad_words_ids=bad_words_ids, num_beams=2, num_return_sequences=2\n-            )\n-            # only count generated tokens\n-            generated_ids = output_tokens[:, input_ids.shape[-1] :]\n-            self.assertFalse(self._check_match_tokens(generated_ids.numpy().tolist(), bad_words_ids))\n-\n-    def test_lm_head_model_beam_search_generate_dict_outputs(self):\n-        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-        input_ids = inputs_dict.get(\"input_ids\", None)\n-        if input_ids is None:\n-            input_ids = inputs_dict.get(\"input_features\", None)\n-\n-        # iterate over all generative models\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-            output_beam_search = model.generate(\n-                input_ids,\n-                num_beams=2,\n-                do_sample=False,\n-                output_scores=True,\n-                output_hidden_states=True,\n-                output_attentions=True,\n-                return_dict_in_generate=True,\n-            )\n-            output_beam_sample = model.generate(\n-                input_ids,\n-                num_beams=2,\n-                do_sample=True,\n-                output_scores=True,\n-                output_hidden_states=True,\n-                output_attentions=True,\n-                return_dict_in_generate=True,\n-            )\n-\n-            if model.config.is_encoder_decoder:\n-                self.assertIsInstance(output_beam_search, TFBeamSearchEncoderDecoderOutput)\n-                self.assertIsInstance(output_beam_sample, TFBeamSampleEncoderDecoderOutput)\n-            else:\n-                self.assertIsInstance(output_beam_search, TFBeamSearchDecoderOnlyOutput)\n-                self.assertIsInstance(output_beam_sample, TFBeamSampleDecoderOnlyOutput)\n-\n     def test_loss_computation(self):\n         config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n         for model_class in self.all_model_classes:\n@@ -1574,40 +1420,6 @@ def test_int_support(self):\n                 if tensor_spec.dtype.is_integer:\n                     self.assertTrue(tensor_spec.dtype == tf.int32, \"Input signatures should use tf.int32 for ints!\")\n \n-    def test_generate_with_headmasking(self):\n-        attention_names = [\"encoder_attentions\", \"decoder_attentions\", \"cross_attentions\"]\n-        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-\n-        for model_class in self.all_generative_model_classes:\n-            model = model_class(config)\n-\n-            # We want to test only encoder-decoder models\n-            if not config.is_encoder_decoder:\n-                continue\n-\n-            head_masking = {\n-                \"head_mask\": tf.zeros((config.encoder_layers, config.encoder_attention_heads)),\n-                \"decoder_head_mask\": tf.zeros((config.decoder_layers, config.decoder_attention_heads)),\n-                \"cross_attn_head_mask\": tf.zeros((config.decoder_layers, config.decoder_attention_heads)),\n-            }\n-\n-            signature = inspect.signature(model.call)\n-            if set(head_masking.keys()) < {*signature.parameters.keys()}:\n-                continue\n-\n-            for attn_name, (name, mask) in zip(attention_names, head_masking.items()):\n-                out = model.generate(\n-                    inputs_dict[\"input_ids\"],\n-                    num_beams=1,\n-                    max_length=inputs_dict[\"input_ids\"] + 5,\n-                    output_attentions=True,\n-                    return_dict_in_generate=True,\n-                    **{name: mask},\n-                )\n-                # We check the state of decoder_attentions and cross_attentions just from the last step\n-                attn_weights = out[attn_name] if attn_name == attention_names[0] else out[attn_name][-1]\n-                self.assertEqual(sum([tf.reduce_sum(w).numpy() for w in attn_weights]), 0.0)\n-\n     def test_load_with_mismatched_shapes(self):\n         if not self.test_mismatched_shapes:\n             return\n@@ -1717,133 +1529,6 @@ def test_dataset_conversion(self):\n                 model.compile(optimizer=\"sgd\", run_eagerly=True)\n                 model.train_on_batch(test_batch, test_batch_labels)\n \n-    def _test_xla_generate(self, **generate_kwargs):\n-        def _generate_and_check_results(model, inputs, is_input_ids):\n-            # make sure there are no pad tokens in prompt, which may trigger unwanted behavior\n-            if is_input_ids:\n-                if model.generation_config.pad_token_id is not None:\n-                    if config.pad_token_id == 0:\n-                        new_pad_token = model.generation_config.pad_token_id + 1\n-                    else:\n-                        new_pad_token = model.generation_config.pad_token_id - 1\n-                else:\n-                    new_pad_token = None\n-                inputs = tf.where(inputs != model.generation_config.pad_token_id, inputs, new_pad_token)\n-\n-            generated = model.generate(inputs, **generate_kwargs).numpy()\n-            generate_xla = tf.function(model.generate, jit_compile=True)\n-            generated_xla = generate_xla(inputs, **generate_kwargs).numpy()\n-\n-            # Due to numerical instability, let's fail the test only if there are more than 10% of input sequences give\n-            # different outputs between XLA and non-XLA versions. If there are less than 10 examples, let's be strict\n-            # and not allow any difference.\n-            diff = [[], []]\n-            for _generated, _generated_xla in zip(generated.tolist(), generated_xla.tolist()):\n-                if _generated != _generated_xla:\n-                    diff[0].append(_generated)\n-                    diff[1].append(_generated_xla)\n-            ratio = len(diff[0]) / len(generated)\n-            if ratio > 0.1 or (len(diff[0]) > 0 and len(generated) < 10):\n-                self.assertListEqual(diff[0], diff[1])\n-\n-        for model_class in self.all_generative_model_classes:\n-            config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-            config.eos_token_id = None  # Generate until max length\n-            config.do_sample = False\n-\n-            # extract the input to the model\n-            is_input_ids = \"input_ids\" in inputs_dict\n-            is_input_features = \"input_features\" in inputs_dict\n-            if not (is_input_ids or is_input_features):\n-                raise ValueError(\"No valid generate input found in inputs_dict\")\n-            inputs = inputs_dict[\"input_ids\"] if is_input_ids else inputs_dict[\"input_features\"]\n-\n-            # fix config for models with additional sequence-length limiting settings\n-            seq_len = inputs.get_shape()[1]\n-            for var_name in [\"max_position_embeddings\", \"max_target_positions\"]:\n-                attr = getattr(config, var_name, None)\n-                if attr is not None and attr < seq_len + generate_kwargs[\"max_new_tokens\"]:\n-                    try:\n-                        setattr(config, var_name, seq_len + generate_kwargs[\"max_new_tokens\"])\n-                    except NotImplementedError:\n-                        # xlnet will raise an exception when trying to set\n-                        # max_position_embeddings.\n-                        pass\n-\n-            model = model_class(config)\n-\n-            if model.supports_xla_generation:\n-                _generate_and_check_results(model, inputs, is_input_ids)\n-            else:\n-                with self.assertRaises(ValueError):\n-                    _generate_and_check_results(model, inputs, is_input_ids)\n-\n-    def test_xla_generate_fast(self):\n-        \"\"\"\n-        Basic quick test for generate-compatible classes that confirms that XLA-generated tokens are the same as their\n-        non XLA counterparts.\n-\n-        Either the model supports XLA generation and passes the inner test, or it raises an appropriate exception\n-        \"\"\"\n-        self._test_xla_generate(num_beams=1, num_return_sequences=1, max_new_tokens=3)\n-\n-    @slow\n-    def test_xla_generate_contrastive(self):\n-        \"\"\"\n-        Slow and challenging version of `test_xla_generate_fast` for contrastive search -- contrastive search directly\n-        manipulates the model cache and other outputs, and this test ensures that they are in a valid format that is\n-        also supported by XLA.\n-\n-        Either the model supports XLA generation and passes the inner test, or it raises an appropriate exception\n-        \"\"\"\n-        self._test_xla_generate(num_beams=1, num_return_sequences=1, max_new_tokens=16, penalty_alpha=0.5, top_k=4)\n-\n-    @slow\n-    def test_xla_generate_slow(self):\n-        \"\"\"\n-        Slow and challenging version of `test_xla_generate_fast` -- this test asks for several long sequences using\n-        beam search, with and without XLA. The two outputs should match, and a failure in this test indicates that the\n-        model may need further analysis if it is to be used for XLA generation.\n-\n-        Either the model supports XLA generation and passes the inner test, or it raises an appropriate exception\n-        \"\"\"\n-        self._test_xla_generate(num_beams=8, num_return_sequences=2, max_new_tokens=128)\n-\n-    def _generate_random_bad_tokens(self, num_bad_tokens, model):\n-        # special tokens cannot be bad tokens\n-        special_tokens = []\n-        if model.config.bos_token_id is not None:\n-            special_tokens.append(model.config.bos_token_id)\n-        if model.config.pad_token_id is not None:\n-            special_tokens.append(model.config.pad_token_id)\n-        if model.config.eos_token_id is not None:\n-            special_tokens.append(model.config.eos_token_id)\n-\n-        # create random bad tokens that are not special tokens\n-        bad_tokens = []\n-        while len(bad_tokens) < num_bad_tokens:\n-            token = tf.squeeze(ids_tensor((1, 1), self.model_tester.vocab_size), 0).numpy()[0]\n-            if token not in special_tokens:\n-                bad_tokens.append(token)\n-        return bad_tokens\n-\n-    def _check_generated_ids(self, output_ids):\n-        for token_id in output_ids[0].numpy().tolist():\n-            self.assertGreaterEqual(token_id, 0)\n-            self.assertLess(token_id, self.model_tester.vocab_size)\n-\n-    def _check_match_tokens(self, generated_ids, bad_words_ids):\n-        # for all bad word tokens\n-        for bad_word_ids in bad_words_ids:\n-            # for all slices in batch\n-            for generated_ids_slice in generated_ids:\n-                # for all word idx\n-                for i in range(len(bad_word_ids), len(generated_ids_slice)):\n-                    # if tokens match\n-                    if generated_ids_slice[i - len(bad_word_ids) : i] == bad_word_ids:\n-                        return True\n-        return False\n-\n \n def ids_tensor(shape, vocab_size, rng=None, name=None, dtype=None):\n     \"\"\"Creates a random int32 tensor of the shape within the vocab size.\"\"\""
        }
    ],
    "stats": {
        "total": 3091,
        "additions": 428,
        "deletions": 2663
    }
}