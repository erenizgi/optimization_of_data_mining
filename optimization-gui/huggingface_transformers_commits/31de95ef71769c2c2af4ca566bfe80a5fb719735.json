{
    "author": "stevhliu",
    "message": "[docs] optimizations quickstart (#42538)\n\n* quickstart\n\n* feedback\n\n* feedback",
    "sha": "31de95ef71769c2c2af4ca566bfe80a5fb719735",
    "files": [
        {
            "sha": "d12667e9a0c6006b86176a46d2af4821daf56c64",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/31de95ef71769c2c2af4ca566bfe80a5fb719735/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/31de95ef71769c2c2af4ca566bfe80a5fb719735/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=31de95ef71769c2c2af4ca566bfe80a5fb719735",
            "patch": "@@ -68,6 +68,8 @@\n       title: Perplexity of fixed-length models\n     title: Generate API\n   - sections:\n+    - local: optimization_overview\n+      title: Overview\n     - local: attention_interface\n       title: Attention backends\n     - local: continuous_batching"
        },
        {
            "sha": "86f3d7b009e718ecbacf4cf5556c35765b939f63",
            "filename": "docs/source/en/optimization_overview.md",
            "status": "added",
            "additions": 178,
            "deletions": 0,
            "changes": 178,
            "blob_url": "https://github.com/huggingface/transformers/blob/31de95ef71769c2c2af4ca566bfe80a5fb719735/docs%2Fsource%2Fen%2Foptimization_overview.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/31de95ef71769c2c2af4ca566bfe80a5fb719735/docs%2Fsource%2Fen%2Foptimization_overview.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Foptimization_overview.md?ref=31de95ef71769c2c2af4ca566bfe80a5fb719735",
            "patch": "@@ -0,0 +1,178 @@\n+<!--Copyright 2025 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# Overview\n+\n+Transformers provides multiple inference optimization techniques to make models fast, affordable, and accessible. Options include alternative attention mechanisms for reduced memory traffic, code compilation for faster execution, and optimized kernels for throughput. Stack these techniques for maximum performance.\n+\n+> [!NOTE]\n+> Memory and speed are closely related but not the same. Shrinking your memory footprint makes a model \"faster\" because there is less data to move around. Pure speed optimizations don't always reduce memory and sometimes increase usage. Choose the appropriate optimization based on your use case and hardware.\n+\n+Use the table below to pick an optimization technique.\n+\n+| Technique | Speed | Memory |\n+|---|:---:|:---:|\n+| [Compilation](#compilation) | ✅ | |\n+| [Attention backends](#attention-backends) | ✅ | ✅ |\n+| [Kernels](#kernels) | ✅ | ✅ |\n+| [Quantization](#quantization) | ✅ | ✅ |\n+| [Caching](#caching) | ✅ | ✅ |\n+| [Parallelism](#parallelism) | ✅ | |\n+| [Continuous batching](#continuous-batching) | ✅ | |\n+\n+This guide gives you a quick start on Transformers optimizations.\n+\n+## Compilation\n+\n+[torch.compile](./perf_torch_compile) reduces Python overhead, fuses operations, and creates kernels tuned for your shapes and hardware. The first run warms it up and subsequent runs use the faster compiled path.\n+\n+Pass a [fixed size cache](./kv_cache#fixed-size-cache) to [`~GenerationMixin.generate`] to trigger `torch.compile` automatically.\n+\n+```py\n+import torch\n+from transformers import AutoTokenizer, AutoModelForCausalLM\n+\n+tokenizer = AutoTokenizer.from_pretrained(\"Qwen/Qwen3-0.6B\")\n+model = AutoModelForCausalLM.from_pretrained(\"Qwen/Qwen3-0.6B\", dtype=torch.float16, device_map=\"auto\")\n+input = tokenizer(\"The French Bread Law states\", return_tensors=\"pt\").to(model.device)\n+\n+output = model.generate(**input, do_sample=False, max_new_tokens=20, cache_implementation=\"static\")\n+tokenizer.batch_decode(output, skip_special_tokens=True)[0]\n+```\n+\n+> [!WARNING]\n+> Avoid calling `torch.compile(model)` outside of [`~GenerationMixin.generate`] to prevent the model from recompiling every step.\n+\n+## Attention backends\n+\n+Alternative [attention backends](./attention_interface) lower memory traffic. For example, FlashAttention tiles attention computations and avoids large intermediate tensors to reduce memory footprint.\n+\n+Set `attn_implementation` in [`~PreTrainedModel.from_pretrained`] to load an optimized attention backend.\n+\n+```py\n+from transformers import AutoModelForCausalLM\n+\n+model = AutoModelForCausalLM.from_pretrained(\"Qwen/Qwen3-0.6B\", attn_implementation=\"flash_attention_2\")\n+```\n+\n+## Kernels\n+\n+Kernels fuse operations to boost throughput and reduce memory usage. The [Kernels](https://huggingface.co/docs/kernels/en/index) library loads optimized compute kernels from the [Hub](https://huggingface.co/kernels-community) in a flexible and version-safe way.\n+\n+The example below loads an optimized FlashAttention-2 kernel without installing the package.\n+\n+```py\n+import torch\n+from transformers import AutoModelForCausalLM\n+\n+model = AutoModelForCausalLM.from_pretrained(\n+    \"Qwen/Qwen3-0.6B\", attn_implementation=\"kernels-community/flash-attn2\"\n+)\n+```\n+\n+## Quantization\n+\n+[Quantization](./quantization/overview) shrinks the size of every parameter which lowers memory footprint and increases speed because you can do more operations.\n+\n+Pass a quantization config to the `quantization_config` argument in [`~PreTrainedModel.from_pretrained`]. Each quantization backend has a different config with different arguments. The example below quantizes a model to 4-bits and configures the computation dtype with the [bitsandbytes](./quantization/bitsandbytes) backend.\n+\n+```py\n+import torch\n+from transformers import AutoModelForCausalLM, BitsAndBytesConfig\n+\n+bnb_config = BitsAndBytesConfig(load_in_4bit=True, bnb_4bit_compute_dtype=torch.bfloat16)\n+\n+model = AutoModelForCausalLM.from_pretrained(\n+    \"allenai/Olmo-3-7B-Think\", quantization_config=bnb_config\n+)\n+```\n+\n+## Caching\n+\n+[Caching](./kv_cache) speeds up generation by reusing past keys and values instead of recomputing them for every token. To offset and reduce the memory cost of storing past keys and values, Transformers \n+supports offloading the cache to the CPU. Only the current layer remains on the GPU.\n+\n+Use the `cache_implementation` argument in [`~GenerationMixin.generate`] to set a cache strategy.\n+\n+```py\n+import torch\n+from transformers import AutoTokenizer, AutoModelForCausalLM\n+\n+tokenizer = AutoTokenizer.from_pretrained(\"Qwen/Qwen3-0.6B\")\n+model = AutoModelForCausalLM.from_pretrained(\n+    \"Qwen/Qwen3-0.6B\", attn_implementation=\"kernels-community/flash-attn2\"\n+)\n+inputs = tokenizer(\"The Le Décret Pain states that a baguette must,\", return_tensors=\"pt\")\n+outputs = model.generate(**inputs, do_sample=False, max_new_tokens=50, cache_implementation=\"offloaded\")\n+```\n+\n+## Parallelism\n+\n+[Parallelism](./perf_infer_gpu_multi) distributes a model across devices so models too big for one device run fast. This approach uses more memory due to sharding overhead and communication to sync results.\n+\n+[Tensor parallelism](./perf_infer_gpu_multi) splits a model layer across devices. Set `tp_plan=\"auto\"` in [`~PreTrainedModel.from_pretrained`] to enable it.\n+\n+```py\n+import torch\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+model = AutoModelForCausalLM.from_pretrained(\"meta-llama/Meta-Llama-3-8B-Instruct\", tp_plan=\"auto\")\n+print(model._tp_plan)\n+```\n+\n+## Continuous batching\n+\n+[Continuous batching](./continuous_batching) maximizes throughput by keeping the GPU busy with dynamic scheduling and chunked prefill. [Serving](./serving.md) applications use it to process multiple incoming requests concurrently.\n+\n+Use [`~ContinuousMixin.generate_batch`] to enable continuous batching.\n+\n+```py\n+import torch\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+from transformers.generation import GenerationConfig\n+\n+model = AutoModelForCausalLM.from_pretrained(\n+    \"Qwen/Qwen3-0.6B\",\n+    attn_implementation=\"paged|sdpa\",\n+    device_map=\"cuda\",\n+    torch_dtype=torch.bfloat16,\n+)\n+tokenizer = AutoTokenizer.from_pretrained(\"Qwen/Qwen3-0.6B\")\n+\n+prompts = [\n+    \"The Le Décret Pain states that a baguette must\",\n+    \"Explain gravity in one sentence.\",\n+    \"Name the capital of France.\",\n+]\n+inputs = [tokenizer.encode(p) for p in prompts]\n+\n+generation_config = GenerationConfig(\n+    max_new_tokens=32,\n+    eos_token_id=tokenizer.eos_token_id,\n+    pad_token_id=tokenizer.pad_token_id,\n+    do_sample=False,\n+    max_batch_tokens=512,\n+)\n+\n+outputs = model.generate_batch(\n+    inputs=inputs,\n+    generation_config=generation_config,\n+)\n+\n+for request_id, output in outputs.items():\n+    text = tokenizer.decode(output.generated_tokens, skip_special_tokens=True)\n+    print(f\"[{request_id}] {text}\")\n+```\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 180,
        "additions": 180,
        "deletions": 0
    }
}