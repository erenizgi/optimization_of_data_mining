{
    "author": "remi-or",
    "message": "Benchmark overhaul (#41408)\n\n* Big refactor, still classes to move around and script to re-complexify\n\n* Move to streamer, isolate benches, propagate num tokens\n\n* Some refacto\n\n* Added compile mode to name\n\n* Re-order\n\n* Move to dt_tokens\n\n* Better format\n\n* Fix and disable use_cache by default\n\n* Fixed compile and SDPA backend default\n\n* Refactor results format\n\n* Added default compile mode\n\n* Always use cache\n\n* Fixed cache and added flex\n\n* Plan for missing modules\n\n* Experiments: no cg and shuffle\n\n* Disable compile for FA\n\n* Remove wall time, add sweep mode, get git commit\n\n* Review compliance, start\n\n* Apply suggestions from code review\n\nCo-authored-by: Luc Georges <McPatate@users.noreply.github.com>\n\n* Update benchmark_v2/framework/benchmark_runner.py\n\nCo-authored-by: Luc Georges <McPatate@users.noreply.github.com>\n\n* Disable workflow\n\n* Pretty print\n\n* Added some pretty names to have pretty logs\n\n* Review n2 compliance (end?)\n\n* Style and end of PR\n\n---------\n\nCo-authored-by: Luc Georges <McPatate@users.noreply.github.com>",
    "sha": "94df0e65602922be2831b3faa457a2bde78b936b",
    "files": [
        {
            "sha": "d74f988f8935371f5714ccd45defd2eb9c075321",
            "filename": ".github/workflows/benchmark.yml",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/94df0e65602922be2831b3faa457a2bde78b936b/.github%2Fworkflows%2Fbenchmark.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/94df0e65602922be2831b3faa457a2bde78b936b/.github%2Fworkflows%2Fbenchmark.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/.github%2Fworkflows%2Fbenchmark.yml?ref=94df0e65602922be2831b3faa457a2bde78b936b",
            "patch": "@@ -1,10 +1,7 @@\n name: Self-hosted runner (benchmark)\r\n \r\n on:\r\n-  push:\r\n-    branches: [main]\r\n-  pull_request:\r\n-    types: [ opened, labeled, reopened, synchronize ]\r\n+  workflow_dispatch:\r\n \r\n concurrency:\r\n   group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}\r"
        },
        {
            "sha": "80b31345409d4f888df118481d4d92eb37597ad9",
            "filename": ".github/workflows/benchmark_v2.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 30,
            "changes": 32,
            "blob_url": "https://github.com/huggingface/transformers/blob/94df0e65602922be2831b3faa457a2bde78b936b/.github%2Fworkflows%2Fbenchmark_v2.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/94df0e65602922be2831b3faa457a2bde78b936b/.github%2Fworkflows%2Fbenchmark_v2.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/.github%2Fworkflows%2Fbenchmark_v2.yml?ref=94df0e65602922be2831b3faa457a2bde78b936b",
            "patch": "@@ -1,35 +1,7 @@\n name: Benchmark v2 Framework\n \n on:\n-  workflow_call:\n-    inputs:\n-      runner:\n-        description: 'GH Actions runner group to use'\n-        required: true\n-        type: string\n-      container_image:\n-        description: 'Docker image to use'\n-        required: true\n-        type: string\n-      container_options:\n-        description: 'Container options to use'\n-        required: true\n-        type: string\n-      commit_sha:\n-        description: 'Commit SHA to benchmark'\n-        required: false\n-        type: string\n-        default: ''\n-      run_id:\n-        description: 'Custom run ID for organizing results (auto-generated if not provided)'\n-        required: false\n-        type: string\n-        default: ''\n-      benchmark_repo_id:\n-        description: 'HuggingFace Dataset to upload results to (e.g., \"org/benchmark-results\")'\n-        required: false\n-        type: string\n-        default: ''\n+  workflow_dispatch:\n \n env:\n   HF_HOME: /mnt/cache\n@@ -82,4 +54,4 @@ jobs:\n           --token '${{ secrets.TRANSFORMERS_CI_RESULTS_UPLOAD_TOKEN }}' \\\n           --log-level INFO\n         env:\n-          HF_TOKEN: ${{ secrets.HF_HUB_READ_TOKEN }}\n\\ No newline at end of file\n+          HF_TOKEN: ${{ secrets.HF_HUB_READ_TOKEN }}"
        },
        {
            "sha": "1a6f5beae5b8249c864c5475d735294d16b7ebe6",
            "filename": ".github/workflows/benchmark_v2_a10_caller.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/huggingface/transformers/blob/94df0e65602922be2831b3faa457a2bde78b936b/.github%2Fworkflows%2Fbenchmark_v2_a10_caller.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/94df0e65602922be2831b3faa457a2bde78b936b/.github%2Fworkflows%2Fbenchmark_v2_a10_caller.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/.github%2Fworkflows%2Fbenchmark_v2_a10_caller.yml?ref=94df0e65602922be2831b3faa457a2bde78b936b",
            "patch": "@@ -1,11 +1,7 @@\n name: Benchmark v2 Scheduled Runner - A10 Single-GPU\n \n on:\n-  schedule:\n-    # Run daily at 16:30 UTC\n-    - cron: \"30 16 * * *\"\n-  pull_request:\n-    types: [ opened, labeled, reopened, synchronize ]\n+  workflow_dispatch:\n \n jobs:\n   benchmark-v2-default:\n@@ -18,4 +14,4 @@ jobs:\n       commit_sha: ${{ github.sha }}\n       run_id: ${{ github.run_id }}\n       benchmark_repo_id: hf-internal-testing/transformers-daily-benchmarks\n-    secrets: inherit\n\\ No newline at end of file\n+    secrets: inherit"
        },
        {
            "sha": "94ca382c15d0c5662577468b3a20e623a42bb738",
            "filename": ".github/workflows/benchmark_v2_mi325_caller.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/huggingface/transformers/blob/94df0e65602922be2831b3faa457a2bde78b936b/.github%2Fworkflows%2Fbenchmark_v2_mi325_caller.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/94df0e65602922be2831b3faa457a2bde78b936b/.github%2Fworkflows%2Fbenchmark_v2_mi325_caller.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/.github%2Fworkflows%2Fbenchmark_v2_mi325_caller.yml?ref=94df0e65602922be2831b3faa457a2bde78b936b",
            "patch": "@@ -1,11 +1,7 @@\n name: Benchmark v2 Scheduled Runner - MI325 Single-GPU\n \n on:\n-  schedule:\n-    # Run daily at 16:30 UTC\n-    - cron: \"30 16 * * *\"\n-  pull_request:\n-    types: [ opened, labeled, reopened, synchronize ]\n+  workflow_dispatch:\n \n jobs:\n   benchmark-v2-default:\n@@ -18,4 +14,4 @@ jobs:\n       commit_sha: ${{ github.sha }}\n       run_id: ${{ github.run_id }}\n       benchmark_repo_id: hf-internal-testing/transformers-daily-benchmarks\n-    secrets: inherit\n\\ No newline at end of file\n+    secrets: inherit"
        },
        {
            "sha": "a4ae560adee09c3473aa788f2364943116c50695",
            "filename": "benchmark_v2/.gitignore",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/94df0e65602922be2831b3faa457a2bde78b936b/benchmark_v2%2F.gitignore",
            "raw_url": "https://github.com/huggingface/transformers/raw/94df0e65602922be2831b3faa457a2bde78b936b/benchmark_v2%2F.gitignore",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/benchmark_v2%2F.gitignore?ref=94df0e65602922be2831b3faa457a2bde78b936b",
            "patch": "@@ -1 +1,2 @@\n-benchmark_results/\n\\ No newline at end of file\n+benchmark_results/\n+benchmark_results_profiles/"
        },
        {
            "sha": "64b106a00370c7f6a4b2c3912d0cd5de149a93e6",
            "filename": "benchmark_v2/benches/__init__.py",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/9e4199ede396f136b3dff1e918816fcc3a65f0a0/benchmark_v2%2Fbenches%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9e4199ede396f136b3dff1e918816fcc3a65f0a0/benchmark_v2%2Fbenches%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/benchmark_v2%2Fbenches%2F__init__.py?ref=9e4199ede396f136b3dff1e918816fcc3a65f0a0",
            "patch": "@@ -1 +0,0 @@\n-# Benchmark implementations directory"
        },
        {
            "sha": "2349e75f1347d95717e484a2e31e7abfab5309af",
            "filename": "benchmark_v2/benches/llama.py",
            "status": "removed",
            "additions": 0,
            "deletions": 165,
            "changes": 165,
            "blob_url": "https://github.com/huggingface/transformers/blob/9e4199ede396f136b3dff1e918816fcc3a65f0a0/benchmark_v2%2Fbenches%2Fllama.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9e4199ede396f136b3dff1e918816fcc3a65f0a0/benchmark_v2%2Fbenches%2Fllama.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/benchmark_v2%2Fbenches%2Fllama.py?ref=9e4199ede396f136b3dff1e918816fcc3a65f0a0",
            "patch": "@@ -1,165 +0,0 @@\n-# Copyright 2025 The HuggingFace Team. All rights reserved.\n-#\n-# Licensed under the Apache License, Version 2.0 (the \"License\");\n-# you may not use this file except in compliance with the License.\n-# You may obtain a copy of the License at\n-#\n-#     http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing, software\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# See the License for the specific language governing permissions and\n-# limitations under the License.\n-\n-import logging\n-import os\n-from typing import Any\n-\n-import torch\n-from benchmark_framework import ModelBenchmark\n-\n-\n-os.environ[\"TOKENIZERS_PARALLELISM\"] = \"1\"\n-torch.set_float32_matmul_precision(\"high\")\n-\n-\n-class LLaMABenchmark(ModelBenchmark):\n-    \"\"\"Simplified LLaMA model benchmark implementation using the ModelBenchmark base class.\"\"\"\n-\n-    def __init__(self, logger: logging.Logger):\n-        super().__init__(logger)\n-        self._default_prompt = \"Why dogs are so cute?\"  # Custom prompt for LLaMA\n-\n-    def get_scenario_configs(self) -> list[dict[str, Any]]:\n-        \"\"\"\n-        Get LLaMA-specific scenario configurations.\n-\n-        Returns:\n-            List of scenario configuration dictionaries\n-        \"\"\"\n-        return [\n-            # Eager variants\n-            {\"variant\": \"eager\", \"compile_mode\": None, \"use_cache\": True, \"description\": \"Eager execution with cache\"},\n-            # Compiled variants\n-            {\n-                \"variant\": \"compiled\",\n-                \"compile_mode\": \"max-autotune\",\n-                \"use_cache\": True,\n-                \"description\": \"Compiled with max autotune\",\n-            },\n-            # Kernelized variant (if available)\n-            {\n-                \"variant\": \"kernelized\",\n-                \"compile_mode\": \"max-autotune\",\n-                \"use_cache\": True,\n-                \"description\": \"Kernelized execution\",\n-            },\n-        ]\n-\n-    def _is_kernelization_available(self) -> bool:\n-        \"\"\"Check if kernelization is available for LLaMA.\"\"\"\n-        try:\n-            from kernels import Mode, kernelize  # noqa: F401\n-\n-            return True\n-        except ImportError:\n-            self.logger.debug(\"Kernelization not available: kernels module not found\")\n-            return False\n-\n-    def get_default_generation_config(self) -> dict[str, Any]:\n-        \"\"\"Get LLaMA-specific generation configuration.\"\"\"\n-        return {\n-            \"do_sample\": False,\n-            \"top_p\": 1.0,\n-            \"temperature\": 1.0,\n-            \"repetition_penalty\": 1.0,\n-            \"max_new_tokens\": None,  # Will be set per scenario\n-        }\n-\n-    def get_model_init_kwargs(self, config) -> dict[str, Any]:\n-        \"\"\"Get LLaMA-specific model initialization kwargs.\"\"\"\n-        return {\n-            \"torch_dtype\": getattr(torch, config.torch_dtype),\n-            \"attn_implementation\": config.attn_implementation,\n-            \"use_cache\": True,\n-        }\n-\n-    def get_default_torch_dtype(self) -> str:\n-        \"\"\"Get default torch dtype for LLaMA.\"\"\"\n-        return \"float16\"  # LLaMA works well with float16\n-\n-    def get_default_device(self) -> str:\n-        \"\"\"Get default device for LLaMA.\"\"\"\n-        return \"cuda\"  # LLaMA prefers CUDA\n-\n-\n-def run_llama(logger, output_dir, **kwargs):\n-    \"\"\"\n-    Run LLaMA benchmark with the given configuration.\n-\n-    Args:\n-        logger: Logger instance\n-        output_dir: Output directory for results\n-        **kwargs: Additional configuration options\n-\n-    Returns:\n-        Path to output file if successful\n-    \"\"\"\n-    from benchmark_framework import BenchmarkRunner\n-\n-    # Extract parameters with defaults\n-    model_id = kwargs.get(\"model_id\", \"meta-llama/Llama-2-7b-hf\")\n-    warmup_iterations = kwargs.get(\"warmup_iterations\", 3)\n-    measurement_iterations = kwargs.get(\"measurement_iterations\", 5)\n-    num_tokens_to_generate = kwargs.get(\"num_tokens_to_generate\", 100)\n-    include_sdpa_variants = kwargs.get(\"include_sdpa_variants\", True)\n-    device = kwargs.get(\"device\", \"cuda\")\n-    torch_dtype = kwargs.get(\"torch_dtype\", \"float16\")\n-    batch_size = kwargs.get(\"batch_size\", 1)\n-    commit_id = kwargs.get(\"commit_id\")\n-\n-    logger.info(f\"Starting LLaMA benchmark for model: {model_id}\")\n-    logger.info(\n-        f\"Configuration: warmup={warmup_iterations}, measurement={measurement_iterations}, tokens={num_tokens_to_generate}\"\n-    )\n-\n-    try:\n-        # Create benchmark instance\n-        benchmark = LLaMABenchmark(logger)\n-\n-        # Create scenarios\n-        scenarios = benchmark.create_scenarios(\n-            model_id=model_id,\n-            warmup_iterations=warmup_iterations,\n-            measurement_iterations=measurement_iterations,\n-            num_tokens_to_generate=num_tokens_to_generate,\n-            include_sdpa_variants=include_sdpa_variants,\n-            device=device,\n-            torch_dtype=torch_dtype,\n-            batch_size=batch_size,\n-        )\n-\n-        logger.info(f\"Created {len(scenarios)} benchmark scenarios\")\n-\n-        # Create runner and execute benchmarks\n-        runner = BenchmarkRunner(logger, output_dir)\n-        results = runner.run_benchmark(benchmark, scenarios, commit_id=commit_id)\n-\n-        if not results:\n-            logger.warning(\"No successful benchmark results\")\n-            return None\n-\n-        # Save results\n-        model_name = model_id.split(\"/\")[-1]  # Extract model name from ID\n-        output_file = runner.save_results(model_name, results)\n-\n-        logger.info(f\"LLaMA benchmark completed successfully. Results saved to: {output_file}\")\n-        return output_file\n-\n-    except Exception as e:\n-        logger.error(f\"LLaMA benchmark failed: {e}\")\n-        import traceback\n-\n-        logger.debug(traceback.format_exc())\n-        raise"
        },
        {
            "sha": "3e4005b9f4b0c759c70f76fa16ba7996fddce36d",
            "filename": "benchmark_v2/benchmark_framework.py",
            "status": "removed",
            "additions": 0,
            "deletions": 1199,
            "changes": 1199,
            "blob_url": "https://github.com/huggingface/transformers/blob/9e4199ede396f136b3dff1e918816fcc3a65f0a0/benchmark_v2%2Fbenchmark_framework.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9e4199ede396f136b3dff1e918816fcc3a65f0a0/benchmark_v2%2Fbenchmark_framework.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/benchmark_v2%2Fbenchmark_framework.py?ref=9e4199ede396f136b3dff1e918816fcc3a65f0a0",
            "patch": "@@ -1,1199 +0,0 @@\n-# Copyright 2025 The HuggingFace Team. All rights reserved.\n-#\n-# Licensed under the Apache License, Version 2.0 (the \"License\");\n-# you may not use this file except in compliance with the License.\n-# You may obtain a copy of the License at\n-#\n-#     http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing, software\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# See the License for the specific language governing permissions and\n-# limitations under the License.\n-\n-import gc\n-import json\n-import logging\n-import os\n-import statistics\n-import sys\n-import threading\n-import time\n-from abc import ABC, abstractmethod\n-from dataclasses import asdict, dataclass, field\n-from datetime import datetime\n-from typing import Any, Optional, TypedDict, Union\n-\n-import gpustat\n-import numpy as np\n-import psutil\n-import torch\n-\n-\n-class GPUMetrics(TypedDict):\n-    \"\"\"GPU monitoring result with GPU metrics.\"\"\"\n-\n-    gpu_utilization_mean: float\n-    gpu_utilization_max: float\n-    gpu_utilization_min: float\n-    gpu_memory_used_mean: float\n-    gpu_memory_used_max: float\n-    gpu_memory_used_min: float\n-    sample_count: int\n-    gpu_monitoring_status: str\n-\n-\n-class NoGPU(TypedDict):\n-    \"\"\"GPU monitoring result without GPU metrics.\"\"\"\n-\n-    gpu_monitoring_status: str\n-    gpu_monitoring_reason: str\n-\n-\n-class ArchAwareTimer:\n-    \"\"\"Architecture-aware timer for supposedly better prescision\"\"\"\n-\n-    def __init__(self, device: Optional[str] = None):\n-        \"\"\"\n-        Initialize architecture-aware timer.\n-\n-        Args:\n-            device: Device to use. If None, uses current device.\n-        \"\"\"\n-        self.device = device\n-        self.use_cuda = torch.cuda.is_available()\n-\n-        if self.use_cuda:\n-            if device and device != \"cpu\":\n-                self.device_obj = torch.device(device)\n-            else:\n-                # Fall back to CPU timing if device is CPU or CUDA not available\n-                self.use_cuda = False\n-\n-        if self.use_cuda:\n-            try:\n-                # Create CUDA events for timing\n-                self.start_event = torch.cuda.Event(enable_timing=True)\n-                self.end_event = torch.cuda.Event(enable_timing=True)\n-            except RuntimeError:\n-                # Fall back to CPU timing if CUDA events fail\n-                self.use_cuda = False\n-\n-        if not self.use_cuda:\n-            self.start_time = None\n-            self.end_time = None\n-\n-    def start(self):\n-        \"\"\"Start timing.\"\"\"\n-        if self.use_cuda:\n-            torch.cuda.synchronize(self.device_obj)\n-            self.start_event.record(stream=torch.cuda.current_stream(self.device_obj))\n-        else:\n-            self.start_time = time.perf_counter()\n-\n-    def stop(self):\n-        \"\"\"Stop timing.\"\"\"\n-        if self.use_cuda:\n-            self.end_event.record(stream=torch.cuda.current_stream(self.device_obj))\n-            torch.cuda.synchronize(self.device_obj)\n-        else:\n-            self.end_time = time.perf_counter()\n-\n-    def elapsed_time(self) -> float:\n-        \"\"\"\n-        Get elapsed time in seconds.\n-\n-        Returns:\n-            Elapsed time in seconds\n-        \"\"\"\n-        if self.use_cuda:\n-            # CUDA events return time in milliseconds, convert to seconds\n-            return self.start_event.elapsed_time(self.end_event) / 1000.0\n-        else:\n-            if self.start_time is None or self.end_time is None:\n-                raise RuntimeError(\"Timer not properly started/stopped\")\n-            return self.end_time - self.start_time\n-\n-    @property\n-    def timing_method(self) -> str:\n-        \"\"\"Get the timing method being used.\"\"\"\n-        return \"CUDA Events\" if self.use_cuda else \"CPU perf_counter\"\n-\n-    def __enter__(self):\n-        \"\"\"Context manager entry.\"\"\"\n-        self.start()\n-        return self\n-\n-    def __exit__(self, exc_type, exc_val, exc_tb):\n-        \"\"\"Context manager exit.\"\"\"\n-        self.stop()\n-\n-\n-@dataclass\n-class BenchmarkConfig:\n-    \"\"\"Configuration for a single benchmark scenario.\"\"\"\n-\n-    name: str\n-    model_id: str\n-    variant: str = \"eager\"  # \"eager\", \"compiled\", \"kernelized\"\n-    warmup_iterations: int = 3\n-    measurement_iterations: int = 10\n-    num_tokens_to_generate: int = 100\n-    device: str = \"cuda\"\n-    torch_dtype: str = \"float16\"\n-    compile_mode: Optional[str] = None  # None, \"default\", \"reduce-overhead\", \"max-autotune\"\n-    compile_options: dict[str, Any] = field(default_factory=dict)\n-    use_cache: bool = True\n-    batch_size: int = 1\n-    sequence_length: Optional[int] = None\n-    attn_implementation: str = \"sdpa\"  # \"eager\", \"sdpa\", \"flash_attention_2\"\n-    sdpa_backend: Optional[str] = None  # None, \"math\", \"flash_attention\", \"efficient_attention\", \"cudnn_attention\"\n-    custom_params: dict[str, Any] = field(default_factory=dict)\n-\n-\n-class BenchmarkScenario:\n-    \"\"\"\n-    A benchmark scenario that encapsulates both configuration and setup logic.\n-    This makes it easier to define and adapt benchmarks for different models.\n-    \"\"\"\n-\n-    def __init__(self, name: str, config: BenchmarkConfig, description: str = \"\"):\n-        self.name = name\n-        self.config = config\n-        self.description = description\n-        self._setup_callbacks = []\n-        self._teardown_callbacks = []\n-\n-    def add_setup_callback(self, callback: callable):\n-        \"\"\"Add a callback to be executed during scenario setup.\"\"\"\n-        self._setup_callbacks.append(callback)\n-\n-    def add_teardown_callback(self, callback: callable):\n-        \"\"\"Add a callback to be executed during scenario teardown.\"\"\"\n-        self._teardown_callbacks.append(callback)\n-\n-    def setup(self, model, tokenizer, logger=None):\n-        \"\"\"Execute setup callbacks for this scenario.\"\"\"\n-        for callback in self._setup_callbacks:\n-            try:\n-                callback(model, tokenizer, self.config, logger)\n-            except Exception as e:\n-                if logger:\n-                    logger.warning(f\"Setup callback failed for scenario {self.name}: {e}\")\n-\n-    def teardown(self, model, tokenizer, logger=None):\n-        \"\"\"Execute teardown callbacks for this scenario.\"\"\"\n-        for callback in self._teardown_callbacks:\n-            try:\n-                callback(model, tokenizer, self.config, logger)\n-            except Exception as e:\n-                if logger:\n-                    logger.warning(f\"Teardown callback failed for scenario {self.name}: {e}\")\n-\n-    def __repr__(self):\n-        return f\"BenchmarkScenario(name='{self.name}', variant='{self.config.variant}')\"\n-\n-\n-@dataclass\n-class TimingResult:\n-    \"\"\"Result from a timing measurement.\"\"\"\n-\n-    time_to_first_token_seconds: Optional[float] = None\n-    latency_seconds: float = 0.0\n-    tokens_per_second: Optional[float] = None\n-    time_per_output_token_seconds: Optional[float] = None\n-    total_tokens_generated: int = 0\n-    metadata: dict[str, Any] = field(default_factory=dict)\n-\n-\n-@dataclass\n-class BenchmarkStatistics:\n-    \"\"\"Statistical analysis of benchmark measurements.\"\"\"\n-\n-    name: str\n-    measurements: list[float]\n-    mean: float\n-    median: float\n-    std: float\n-    min: float\n-    max: float\n-    p25: float  # 25th percentile\n-    p75: float  # 75th percentile\n-    p90: float  # 90th percentile\n-    p95: float  # 95th percentile\n-    p99: float  # 99th percentile\n-    unit: str = \"seconds\"\n-\n-    @classmethod\n-    def from_measurements(cls, name: str, measurements: list[float], unit: str = \"seconds\") -> \"BenchmarkStatistics\":\n-        \"\"\"Create statistics from a list of measurements.\"\"\"\n-        if not measurements:\n-            raise ValueError(\"Cannot create statistics from empty measurements\")\n-\n-        measurements_array = np.array(measurements)\n-\n-        return cls(\n-            name=name,\n-            measurements=measurements,\n-            mean=float(np.mean(measurements_array)),\n-            median=float(np.median(measurements_array)),\n-            std=float(np.std(measurements_array)),\n-            min=float(np.min(measurements_array)),\n-            max=float(np.max(measurements_array)),\n-            p25=float(np.percentile(measurements_array, 25)),\n-            p75=float(np.percentile(measurements_array, 75)),\n-            p90=float(np.percentile(measurements_array, 90)),\n-            p95=float(np.percentile(measurements_array, 95)),\n-            p99=float(np.percentile(measurements_array, 99)),\n-            unit=unit,\n-        )\n-\n-\n-@dataclass\n-class HardwareInfo:\n-    \"\"\"Hardware information collected during benchmarking.\"\"\"\n-\n-    gpu_name: str\n-    gpu_memory_total_mb: int\n-    cpu_count: int\n-    memory_total_mb: int\n-    python_version: str\n-    torch_version: Optional[str] = None\n-    cuda_version: Optional[str] = None\n-\n-\n-@dataclass\n-class BenchmarkMetadata:\n-    \"\"\"Metadata collected for each benchmark run.\"\"\"\n-\n-    timestamp: str\n-    commit_id: str\n-    hardware_info: HardwareInfo\n-    config: BenchmarkConfig\n-\n-\n-class GPUMonitor:\n-    \"\"\"Monitor GPU utilization during benchmark execution.\"\"\"\n-\n-    def __init__(self, sample_interval: float = 0.1, logger: Optional[logging.Logger] = None):\n-        self.sample_interval = sample_interval\n-        self.logger = logger or logging.getLogger(__name__)\n-        self.stop_event = threading.Event()\n-        self.thread = None\n-        self.gpu_utilization = []\n-        self.gpu_memory_used = []\n-        self.timestamps = []\n-        self.gpu_available = False\n-        self.warning_logged = False\n-\n-        # Test GPU availability on initialization\n-        self._test_gpu_availability()\n-\n-    def _test_gpu_availability(self):\n-        \"\"\"Test if GPU monitoring is available.\"\"\"\n-        try:\n-            gpu_stats = gpustat.GPUStatCollection.new_query()\n-            if gpu_stats and len(gpu_stats) > 0:\n-                self.gpu_available = True\n-                self.logger.debug(f\"GPU monitoring available: {len(gpu_stats)} GPU(s) detected\")\n-            else:\n-                self.gpu_available = False\n-                self.logger.debug(\"No GPUs detected by gpustat\")\n-        except Exception as e:\n-            self.gpu_available = False\n-            self.logger.debug(f\"GPU monitoring not available: {e}\")\n-\n-    def start(self):\n-        \"\"\"Start monitoring GPU metrics.\"\"\"\n-        if not self.gpu_available:\n-            self.logger.debug(\"GPU monitoring disabled: no GPUs available\")\n-            return\n-\n-        # Clear the stop event to enable monitoring\n-        self.stop_event.clear()\n-        self.gpu_utilization = []\n-        self.gpu_memory_used = []\n-        self.timestamps = []\n-        self.warning_logged = False  # Reset warning flag for new monitoring session\n-        self.thread = threading.Thread(target=self._monitor_loop)\n-        self.thread.start()\n-        self.logger.debug(\"GPU monitoring started\")\n-\n-    def stop_and_collect(self) -> Union[GPUMetrics, NoGPU]:\n-        \"\"\"Stop monitoring and return collected metrics.\"\"\"\n-        if not self.gpu_available:\n-            return NoGPU(gpu_monitoring_status=\"disabled\", gpu_monitoring_reason=\"no_gpus_available\")\n-\n-        # Signal the monitoring thread to stop\n-        self.stop_event.set()\n-        if self.thread:\n-            self.thread.join()\n-\n-        if self.gpu_utilization:\n-            metrics = GPUMetrics(\n-                gpu_utilization_mean=statistics.mean(self.gpu_utilization),\n-                gpu_utilization_max=max(self.gpu_utilization),\n-                gpu_utilization_min=min(self.gpu_utilization),\n-                gpu_memory_used_mean=statistics.mean(self.gpu_memory_used),\n-                gpu_memory_used_max=max(self.gpu_memory_used),\n-                gpu_memory_used_min=min(self.gpu_memory_used),\n-                sample_count=len(self.gpu_utilization),\n-                gpu_monitoring_status=\"success\",\n-            )\n-            self.logger.debug(f\"GPU monitoring completed: {len(self.gpu_utilization)} samples collected\")\n-            return metrics\n-        else:\n-            return NoGPU(gpu_monitoring_status=\"failed\", gpu_monitoring_reason=\"no_samples_collected\")\n-\n-    def _monitor_loop(self):\n-        \"\"\"Background monitoring loop using threading.Event for communication.\"\"\"\n-        consecutive_failures = 0\n-        max_consecutive_failures = 5\n-\n-        # Continue monitoring until stop_event is set\n-        while not self.stop_event.is_set():\n-            try:\n-                gpu_stats = gpustat.GPUStatCollection.new_query()\n-                if gpu_stats and len(gpu_stats) > 0:\n-                    gpu = gpu_stats[0]\n-                    self.gpu_utilization.append(gpu[\"utilization.gpu\"])\n-                    self.gpu_memory_used.append(gpu[\"memory.used\"])\n-                    self.timestamps.append(time.time())\n-                    consecutive_failures = 0  # Reset failure counter on success\n-                else:\n-                    consecutive_failures += 1\n-                    if consecutive_failures >= max_consecutive_failures and not self.warning_logged:\n-                        self.logger.warning(\"GPU monitoring: No GPU data returned by gpustat\")\n-                        self.warning_logged = True\n-\n-            except Exception as e:\n-                consecutive_failures += 1\n-                if consecutive_failures >= max_consecutive_failures and not self.warning_logged:\n-                    self.logger.warning(f\"GPU monitoring failed after {max_consecutive_failures} attempts: {e}\")\n-                    self.warning_logged = True\n-\n-            # Use Event.wait() with timeout instead of time.sleep()\n-            # This allows for immediate response to stop signal while still maintaining sample interval\n-            if self.stop_event.wait(timeout=self.sample_interval):\n-                # Event was set, break out of loop immediately\n-                break\n-\n-\n-def get_hardware_info() -> HardwareInfo:\n-    \"\"\"Collect hardware information.\"\"\"\n-    gpu_name = \"unknown\"\n-    gpu_memory_total = 0\n-\n-    try:\n-        gpu_stats = gpustat.GPUStatCollection.new_query()\n-        if gpu_stats and len(gpu_stats) > 0:\n-            gpu = gpu_stats[0]\n-            gpu_name = gpu[\"name\"]\n-            gpu_memory_total = gpu[\"memory.total\"]\n-    except Exception:\n-        pass\n-\n-    torch_version = torch.__version__\n-    cuda_version = None\n-    if hasattr(torch, \"cuda\") and torch.cuda.is_available():\n-        cuda_version = torch.version.cuda\n-\n-    return HardwareInfo(\n-        gpu_name=gpu_name,\n-        gpu_memory_total_mb=gpu_memory_total,\n-        cpu_count=psutil.cpu_count(),\n-        memory_total_mb=int(psutil.virtual_memory().total / (1024 * 1024)),\n-        python_version=f\"{sys.version.split()[0]}\",\n-        torch_version=torch_version,\n-        cuda_version=cuda_version,\n-    )\n-\n-\n-def flush_memory():\n-    \"\"\"Flush GPU memory and run garbage collection.\"\"\"\n-    gc.collect()\n-    if hasattr(torch, \"cuda\") and torch.cuda.is_available():\n-        torch.cuda.empty_cache()\n-        torch.cuda.reset_max_memory_allocated()\n-        torch.cuda.reset_peak_memory_stats()\n-        torch.cuda.synchronize()\n-\n-\n-def get_sdpa_backend(backend_name: Optional[str]):\n-    \"\"\"Get the SDPA backend enum from string name.\"\"\"\n-    if backend_name is None:\n-        return None\n-\n-    try:\n-        backend_map = {\n-            \"math\": torch.nn.attention.SDPBackend.MATH,\n-            \"flash_attention\": torch.nn.attention.SDPBackend.FLASH_ATTENTION,\n-            \"efficient_attention\": torch.nn.attention.SDPBackend.EFFICIENT_ATTENTION,\n-            \"cudnn_attention\": torch.nn.attention.SDPBackend.CUDNN_ATTENTION,\n-        }\n-        return backend_map.get(backend_name.lower())\n-    except AttributeError:\n-        # torch.nn.attention.SDPBackend not available in older torch versions\n-        return None\n-\n-\n-class SDPAContext:\n-    \"\"\"Context manager for SDPA kernel selection.\"\"\"\n-\n-    def __init__(self, backend_name: Optional[str], logger: Optional[logging.Logger] = None):\n-        self.backend_name = backend_name\n-        self.logger = logger or logging.getLogger(__name__)\n-        self.backend = get_sdpa_backend(backend_name) if backend_name else None\n-        self.context = None\n-\n-    def __enter__(self):\n-        if self.backend is not None:\n-            try:\n-                self.context = torch.nn.attention.sdpa_kernel(self.backend)\n-                self.context.__enter__()\n-                if self.logger:\n-                    self.logger.debug(f\"Using SDPA backend: {self.backend_name}\")\n-            except Exception as e:\n-                if self.logger:\n-                    self.logger.warning(f\"Failed to set SDPA backend {self.backend_name}: {e}\")\n-                self.context = None\n-        elif self.backend_name and self.logger:\n-            self.logger.debug(\n-                f\"SDPA backend '{self.backend_name}' requested but not using kernel context (backend={self.backend})\"\n-            )\n-        return self\n-\n-    def __exit__(self, exc_type, exc_val, exc_tb):\n-        if self.context is not None:\n-            try:\n-                self.context.__exit__(exc_type, exc_val, exc_tb)\n-            except Exception as e:\n-                if self.logger:\n-                    self.logger.warning(f\"Error exiting SDPA context: {e}\")\n-        return False\n-\n-\n-class AbstractModelBenchmark(ABC):\n-    \"\"\"Abstract base class for model benchmarks.\"\"\"\n-\n-    def __init__(self, logger: logging.Logger):\n-        self.logger = logger\n-        self.model = None\n-        self.tokenizer = None\n-        self.device = None\n-        self.scenarios = {}  # Map of scenario_name -> BenchmarkScenario\n-\n-    @abstractmethod\n-    def create_scenarios(self, **kwargs) -> dict[str, \"BenchmarkScenario\"]:\n-        \"\"\"Create and return a dictionary of benchmark scenarios.\"\"\"\n-        pass\n-\n-    @abstractmethod\n-    def setup_model(self, config: BenchmarkConfig) -> None:\n-        \"\"\"Setup the model for benchmarking with the given configuration.\"\"\"\n-        pass\n-\n-    @abstractmethod\n-    def cleanup_model(self) -> None:\n-        \"\"\"Cleanup model resources.\"\"\"\n-        pass\n-\n-    @abstractmethod\n-    def measure_time_to_first_token(self, config: BenchmarkConfig) -> float:\n-        \"\"\"Measure time to first token generation.\"\"\"\n-        pass\n-\n-    @abstractmethod\n-    def measure_latency(self, config: BenchmarkConfig) -> TimingResult:\n-        \"\"\"Measure full generation latency and compute tokens/sec.\"\"\"\n-        pass\n-\n-    def prepare_inputs(self, config: BenchmarkConfig) -> Any:\n-        \"\"\"Prepare inputs for the model. Override if needed.\"\"\"\n-        return None\n-\n-    def get_scenarios(self, **kwargs) -> dict[str, \"BenchmarkScenario\"]:\n-        \"\"\"Get benchmark scenarios. Creates them if they don't exist.\"\"\"\n-        if not self.scenarios:\n-            self.scenarios = self.create_scenarios(**kwargs)\n-        return self.scenarios\n-\n-\n-class ModelBenchmark(AbstractModelBenchmark):\n-    \"\"\"\n-    Base class for HuggingFace Transformers model benchmarks.\n-\n-    This class provides common scenario creation logic and handles the standard\n-    patterns for eager, compiled, and kernelized execution variants with different\n-    attention implementations and SDPA backends.\n-    \"\"\"\n-\n-    def __init__(self, logger: logging.Logger):\n-        super().__init__(logger)\n-        self.inputs = None\n-        self.compiled_model = None\n-        self.past_key_values = None\n-        self.config = None\n-        self._default_prompt = \"Why dogs are so cute?\"\n-\n-    @property\n-    def default_prompt(self) -> str:\n-        \"\"\"Default prompt for text generation. Override in subclasses if needed.\"\"\"\n-        return self._default_prompt\n-\n-    def get_attention_configs(self, include_sdpa_variants: bool = True) -> list[dict[str, Any]]:\n-        \"\"\"\n-        Get attention implementation configurations.\n-\n-        Args:\n-            include_sdpa_variants: Whether to include SDPA backend variants\n-\n-        Returns:\n-            List of attention configuration dictionaries\n-        \"\"\"\n-        attention_configs = [\n-            {\"attn_implementation\": \"eager\", \"sdpa_backends\": [None], \"desc_suffix\": \" with eager attention\"},\n-        ]\n-\n-        # Add SDPA variants if requested\n-        if include_sdpa_variants:\n-            attention_configs.append(\n-                {\n-                    \"attn_implementation\": \"sdpa\",\n-                    \"sdpa_backends\": [None, \"math\", \"flash_attention\", \"efficient_attention\"],\n-                    \"desc_suffix\": \"\",\n-                }\n-            )\n-\n-        return attention_configs\n-\n-    def get_scenario_configs(self) -> list[dict[str, Any]]:\n-        \"\"\"\n-        Get base scenario configurations. Override in subclasses to customize.\n-\n-        Returns:\n-            List of scenario configuration dictionaries\n-        \"\"\"\n-        return [\n-            # Eager variants\n-            {\"variant\": \"eager\", \"compile_mode\": None, \"use_cache\": True, \"description\": \"Eager execution with cache\"},\n-            # Compiled variants\n-            {\n-                \"variant\": \"compiled\",\n-                \"compile_mode\": \"max-autotune\",\n-                \"use_cache\": True,\n-                \"description\": \"Compiled with max autotune\",\n-            },\n-            # Kernelized variant (if available)\n-            {\n-                \"variant\": \"kernelized\",\n-                \"compile_mode\": \"max-autotune\",\n-                \"use_cache\": True,\n-                \"description\": \"Kernelized execution\",\n-            },\n-        ]\n-\n-    def _is_kernelization_available(self) -> bool:\n-        \"\"\"Check if kernelization is available. Override in subclasses.\"\"\"\n-        try:\n-            from kernels import Mode, kernelize  # noqa: F401\n-\n-            return True\n-        except ImportError:\n-            return False\n-\n-    def get_default_generation_config(self) -> dict[str, Any]:\n-        \"\"\"Get default generation configuration. Override in subclasses for model-specific defaults.\"\"\"\n-        return {\"do_sample\": False, \"top_p\": 1.0, \"temperature\": 1.0}\n-\n-    def get_model_init_kwargs(self, config: BenchmarkConfig) -> dict[str, Any]:\n-        \"\"\"Get model initialization kwargs. Override in subclasses for model-specific parameters.\"\"\"\n-        return {\"torch_dtype\": getattr(torch, config.torch_dtype), \"attn_implementation\": config.attn_implementation}\n-\n-    def get_default_torch_dtype(self) -> str:\n-        \"\"\"Get default torch dtype. Override in subclasses.\"\"\"\n-        return \"float16\"\n-\n-    def get_default_device(self) -> str:\n-        \"\"\"Get default device. Override in subclasses.\"\"\"\n-        return \"cuda\"\n-\n-    def create_scenarios(self, **kwargs) -> dict[str, \"BenchmarkScenario\"]:\n-        \"\"\"Create benchmark scenarios for HuggingFace models.\"\"\"\n-        scenarios = {}\n-\n-        # Extract parameters with model-specific defaults\n-        model_id = kwargs.get(\"model_id\", \"microsoft/DialoGPT-medium\")\n-        warmup_iterations = kwargs.get(\"warmup_iterations\", 3)\n-        measurement_iterations = kwargs.get(\"measurement_iterations\", 5)\n-        num_tokens_to_generate = kwargs.get(\"num_tokens_to_generate\", 100)\n-        include_sdpa_variants = kwargs.get(\"include_sdpa_variants\", True)\n-        device = kwargs.get(\"device\", self.get_default_device())\n-        torch_dtype = kwargs.get(\"torch_dtype\", self.get_default_torch_dtype())\n-        batch_size = kwargs.get(\"batch_size\", 1)\n-\n-        # Get configurations\n-        attention_configs = self.get_attention_configs(include_sdpa_variants)\n-        scenario_configs = self.get_scenario_configs()\n-\n-        # Create scenarios for each attention config and variant combination\n-        for attn_config in attention_configs:\n-            attn_implementation = attn_config[\"attn_implementation\"]\n-            sdpa_backends = attn_config[\"sdpa_backends\"]\n-            desc_suffix = attn_config[\"desc_suffix\"]\n-\n-            for scenario_config in scenario_configs:\n-                for sdpa_backend in sdpa_backends:\n-                    # Skip kernelized if not available\n-                    if scenario_config[\"variant\"] == \"kernelized\" and not self._is_kernelization_available():\n-                        continue\n-\n-                    # Create unique config for this scenario\n-                    config = BenchmarkConfig(\n-                        name=scenario_config[\"variant\"],\n-                        model_id=model_id,\n-                        variant=scenario_config[\"variant\"],\n-                        compile_mode=scenario_config[\"compile_mode\"],\n-                        use_cache=scenario_config[\"use_cache\"],\n-                        warmup_iterations=warmup_iterations,\n-                        measurement_iterations=measurement_iterations,\n-                        num_tokens_to_generate=num_tokens_to_generate,\n-                        device=device,\n-                        torch_dtype=torch_dtype,\n-                        batch_size=batch_size,\n-                        attn_implementation=attn_implementation,\n-                        sdpa_backend=sdpa_backend if attn_implementation == \"sdpa\" else None,\n-                    )\n-\n-                    # Create scenario name\n-                    scenario_name_parts = [scenario_config[\"variant\"]]\n-                    if scenario_config[\"compile_mode\"]:\n-                        scenario_name_parts.append(f\"compile_{scenario_config['compile_mode']}\")\n-\n-                    # Add attention implementation to name\n-                    if attn_implementation == \"eager\":\n-                        scenario_name_parts.append(\"eager_attn\")\n-                    elif attn_implementation == \"sdpa\":\n-                        if sdpa_backend:\n-                            scenario_name_parts.append(f\"sdpa_{sdpa_backend}\")\n-                        else:\n-                            scenario_name_parts.append(\"sdpa_default\")\n-\n-                    scenario_name = \"_\".join(scenario_name_parts)\n-\n-                    # Create description\n-                    description = scenario_config[\"description\"]\n-                    if attn_implementation == \"sdpa\" and sdpa_backend:\n-                        description += f\" with SDPA {sdpa_backend} backend\"\n-                    elif attn_implementation == \"sdpa\":\n-                        description += \" with SDPA default backend\"\n-                    else:\n-                        description += desc_suffix\n-\n-                    # Create scenario\n-                    scenario = BenchmarkScenario(name=scenario_name, config=config, description=description)\n-\n-                    # Add setup callbacks based on variant\n-                    if scenario_config[\"variant\"] == \"compiled\":\n-                        scenario.add_setup_callback(self._setup_compilation_callback)\n-                    elif scenario_config[\"variant\"] == \"kernelized\":\n-                        scenario.add_setup_callback(self._setup_kernelization_callback)\n-\n-                    scenarios[scenario_name] = scenario\n-\n-        return scenarios\n-\n-    def _setup_compilation_callback(self, model, tokenizer, config, logger):\n-        \"\"\"Setup callback for compilation scenarios.\"\"\"\n-        if logger:\n-            logger.info(f\"Setting up compilation with mode: {config.compile_mode}\")\n-\n-        # Perform torch.compile\n-        if config.compile_mode is not None:\n-            self.compiled_model = torch.compile(model, mode=config.compile_mode, **config.compile_options)\n-        else:\n-            self.compiled_model = torch.compile(model, **config.compile_options)\n-\n-        # Setup static cache for compiled mode if needed\n-        if config.use_cache and hasattr(self, \"inputs\") and self.inputs is not None:\n-            self._setup_static_cache(config)\n-\n-    def _setup_kernelization_callback(self, model, tokenizer, config, logger):\n-        \"\"\"Setup callback for kernelization scenarios.\"\"\"\n-        if logger:\n-            logger.info(\"Setting up kernelization\")\n-\n-        try:\n-            from kernels import Mode, kernelize\n-\n-            self.compiled_model = kernelize(model, mode=Mode.INFERENCE)\n-        except Exception as e:\n-            if logger:\n-                logger.warning(f\"Failed to setup kernelized mode: {e}\")\n-                logger.warning(\"Falling back to eager mode\")\n-            config.variant = \"eager\"\n-\n-    def _setup_static_cache(self, config: BenchmarkConfig):\n-        \"\"\"Setup static cache for compiled models. Override if needed.\"\"\"\n-        if hasattr(self, \"inputs\") and self.inputs is not None:\n-            try:\n-                from transformers import StaticCache\n-\n-                seq_length = self.inputs[\"input_ids\"].shape[1]\n-\n-                # Get the actual device the model is on\n-                if hasattr(self.model, \"device\"):\n-                    cache_device = self.model.device\n-                else:\n-                    cache_device = self.device\n-\n-                self.past_key_values = StaticCache(\n-                    config=self.model.config,\n-                    max_batch_size=config.batch_size,\n-                    max_cache_len=seq_length + config.num_tokens_to_generate,\n-                    device=cache_device,\n-                    dtype=getattr(torch, config.torch_dtype),\n-                )\n-                self.logger.debug(f\"StaticCache created on device: {cache_device}\")\n-            except (ImportError, TypeError) as e:\n-                # StaticCache not available or incompatible, continue without it\n-                self.logger.debug(f\"StaticCache setup failed: {e}, continuing without cache\")\n-                self.past_key_values = None\n-\n-    def setup_model(self, config: BenchmarkConfig) -> None:\n-        \"\"\"Setup the HuggingFace model for benchmarking with the given configuration.\"\"\"\n-\n-        self.logger.info(f\"Setting up model: {config.model_id} with variant: {config.variant}\")\n-        self.device = config.device\n-        self.config = config\n-\n-        # Load model and tokenizer\n-        self._load_model_and_tokenizer(config)\n-\n-        # Prepare inputs\n-        self._prepare_model_inputs(config)\n-\n-        # Configure generation settings\n-        self._configure_generation(config)\n-\n-        self.logger.info(\"Model setup complete\")\n-\n-    def _load_model_and_tokenizer(self, config: BenchmarkConfig):\n-        \"\"\"Load the model and tokenizer. Override in subclasses for custom loading.\"\"\"\n-\n-        from transformers import AutoModelForCausalLM, AutoTokenizer, GenerationConfig\n-\n-        # Load tokenizer\n-        self.tokenizer = AutoTokenizer.from_pretrained(config.model_id)\n-        if self.tokenizer.pad_token is None:\n-            self.tokenizer.pad_token = self.tokenizer.eos_token\n-\n-        # Prepare generation config\n-        generation_config_dict = self.get_default_generation_config()\n-        gen_config = GenerationConfig(**generation_config_dict)\n-\n-        # Load model\n-        self.logger.info(\"Loading model...\")\n-\n-        target_device = config.device\n-        # Get model initialization kwargs\n-        model_init_kwargs = self.get_model_init_kwargs(config)\n-        model_init_kwargs.update({\"generation_config\": gen_config})\n-\n-        self.model = AutoModelForCausalLM.from_pretrained(config.model_id, **model_init_kwargs).eval()\n-\n-        # Move model to target device\n-        self.logger.info(f\"Moving model to device: {target_device}\")\n-        self.model.to(target_device)\n-        self.device = target_device  # Update device to match actual device used\n-\n-    def _prepare_model_inputs(self, config: BenchmarkConfig):\n-        \"\"\"Prepare model inputs. Override in subclasses for custom inputs.\"\"\"\n-        # Prepare inputs\n-        self.inputs = self.tokenizer(self.default_prompt, return_tensors=\"pt\")\n-\n-        # Move inputs to the same device as the model\n-        if hasattr(self.model, \"device\"):\n-            # Model is on a single device\n-            model_device = self.model.device\n-        else:\n-            # Model might be distributed, use self.device which was set during model loading\n-            model_device = self.device\n-\n-        self.inputs = {k: v.to(model_device) for k, v in self.inputs.items()}\n-        self.logger.debug(f\"Moved inputs to device: {model_device}\")\n-\n-    def _configure_generation(self, config: BenchmarkConfig):\n-        \"\"\"Configure generation settings.\"\"\"\n-        seq_length = self.inputs[\"input_ids\"].shape[1]\n-        self.model.generation_config.max_length = seq_length + config.num_tokens_to_generate\n-\n-    def cleanup_model(self) -> None:\n-        \"\"\"Cleanup model resources.\"\"\"\n-        if hasattr(self, \"model\") and self.model is not None:\n-            del self.model\n-            self.model = None\n-        if hasattr(self, \"compiled_model\") and self.compiled_model is not None:\n-            del self.compiled_model\n-            self.compiled_model = None\n-        if hasattr(self, \"tokenizer\") and self.tokenizer is not None:\n-            del self.tokenizer\n-            self.tokenizer = None\n-        if hasattr(self, \"past_key_values\") and self.past_key_values is not None:\n-            del self.past_key_values\n-            self.past_key_values = None\n-\n-        # Clear CUDA cache\n-        flush_memory()\n-\n-    def measure_time_to_first_token(self, config: BenchmarkConfig) -> float:\n-        \"\"\"Measure time to first token generation.\"\"\"\n-        model_to_use = self.compiled_model if self.compiled_model is not None else self.model\n-\n-        # Prepare generation kwargs\n-        generation_kwargs = self._get_generation_kwargs(config, max_new_tokens=1)\n-\n-        # Use CUDA timer for high-precision measurement\n-        with ArchAwareTimer(device=config.device) as timer:\n-            # Use SDPA context if specified\n-            with SDPAContext(config.sdpa_backend, self.logger):\n-                with torch.no_grad():\n-                    _ = model_to_use.generate(**generation_kwargs)\n-\n-        return timer.elapsed_time()\n-\n-    def measure_latency(self, config: BenchmarkConfig) -> TimingResult:\n-        \"\"\"Measure full generation latency and compute tokens/sec.\"\"\"\n-        model_to_use = self.compiled_model if self.compiled_model is not None else self.model\n-\n-        # Prepare generation kwargs\n-        generation_kwargs = self._get_generation_kwargs(config, max_new_tokens=config.num_tokens_to_generate)\n-\n-        # Use CUDA timer for high-precision measurement\n-        with ArchAwareTimer(device=config.device) as timer:\n-            # Use SDPA context if specified\n-            with SDPAContext(config.sdpa_backend, self.logger):\n-                with torch.no_grad():\n-                    outputs = model_to_use.generate(**generation_kwargs)\n-\n-        # Calculate metrics\n-        latency = timer.elapsed_time()\n-        input_length = self.inputs[\"input_ids\"].shape[1]\n-        output_length = outputs.shape[1]\n-        tokens_generated = output_length - input_length\n-\n-        tokens_per_second = tokens_generated / latency if latency > 0 else 0\n-        time_per_output_token = latency / tokens_generated if tokens_generated > 0 else None\n-\n-        return TimingResult(\n-            latency_seconds=latency,\n-            tokens_per_second=tokens_per_second,\n-            time_per_output_token_seconds=time_per_output_token,\n-            total_tokens_generated=tokens_generated,\n-            metadata={\n-                \"input_length\": input_length,\n-                \"output_length\": output_length,\n-                \"variant\": config.variant,\n-                \"compile_mode\": config.compile_mode,\n-                \"attn_implementation\": config.attn_implementation,\n-                \"sdpa_backend\": config.sdpa_backend,\n-            },\n-        )\n-\n-    def _get_generation_kwargs(self, config: BenchmarkConfig, max_new_tokens: int) -> dict[str, Any]:\n-        \"\"\"Get generation kwargs. Override in subclasses for custom generation.\"\"\"\n-        generation_config_dict = self.get_default_generation_config()\n-        generation_kwargs = {\n-            **self.inputs,\n-            \"max_new_tokens\": max_new_tokens,\n-            \"do_sample\": generation_config_dict.get(\"do_sample\", False),\n-            \"temperature\": generation_config_dict.get(\"temperature\", 1.0),\n-            \"top_p\": generation_config_dict.get(\"top_p\", 1.0),\n-            \"pad_token_id\": self.tokenizer.pad_token_id,\n-        }\n-\n-        # Handle static cache for compiled models\n-        if self.past_key_values is not None and config.variant == \"compiled\":\n-            try:\n-                from transformers import StaticCache\n-\n-                # Reset cache for each measurement\n-                seq_length = self.inputs[\"input_ids\"].shape[1]\n-\n-                # Get the actual device the model is on\n-                if hasattr(self.model, \"device\"):\n-                    cache_device = self.model.device\n-                else:\n-                    cache_device = self.device\n-\n-                fresh_cache = StaticCache(\n-                    config=self.model.config,\n-                    max_batch_size=config.batch_size,\n-                    max_cache_len=seq_length + max_new_tokens,\n-                    device=cache_device,\n-                    dtype=getattr(torch, config.torch_dtype),\n-                )\n-                generation_kwargs[\"past_key_values\"] = fresh_cache\n-            except (ImportError, TypeError) as e:\n-                self.logger.debug(f\"Fresh StaticCache creation failed: {e}\")\n-                pass\n-\n-        return generation_kwargs\n-\n-\n-class BenchmarkRunner:\n-    \"\"\"Main benchmark runner that coordinates benchmark execution.\"\"\"\n-\n-    def __init__(self, logger: logging.Logger, output_dir: str = \"benchmark_results\"):\n-        self.logger = logger\n-        self.output_dir = output_dir\n-        os.makedirs(output_dir, exist_ok=True)\n-\n-    def run_benchmark(\n-        self,\n-        benchmark: ModelBenchmark,\n-        scenarios: dict[str, BenchmarkScenario],\n-        collect_gpu_metrics: bool = True,\n-        commit_id: Optional[str] = None,\n-    ) -> dict[str, dict[str, Any]]:\n-        \"\"\"\n-        Run benchmarks using scenarios.\n-\n-        Args:\n-            benchmark: The benchmark instance to run\n-            scenarios: Dictionary mapping scenario names to BenchmarkScenario instances\n-            collect_gpu_metrics: Whether to collect GPU utilization metrics\n-            commit_id: Git commit ID for metadata (if not provided, will auto-detect from git)\n-\n-        Returns:\n-            Dictionary mapping scenario names to results with statistics\n-        \"\"\"\n-        all_results = {}\n-\n-        for scenario_name, scenario in scenarios.items():\n-            self.logger.info(f\"Running benchmark scenario: {scenario_name}\")\n-            config = scenario.config\n-\n-            try:\n-                # Setup model for this configuration\n-                benchmark.setup_model(config)\n-\n-                # Run scenario setup callbacks\n-                scenario.setup(benchmark.model, benchmark.tokenizer, self.logger)\n-\n-                # Quick validation: try one measurement first to see if this scenario works\n-                try:\n-                    flush_memory()\n-                    test_result = benchmark.measure_time_to_first_token(config)\n-                    if test_result is None or test_result <= 0:\n-                        raise ValueError(\"Invalid measurement result\")\n-                except Exception as validation_error:\n-                    self.logger.warning(f\"Skipping scenario {scenario_name}: validation failed - {validation_error}\")\n-                    # Clean up and skip this scenario\n-                    try:\n-                        scenario.teardown(benchmark.model, benchmark.tokenizer, self.logger)\n-                        benchmark.cleanup_model()\n-                    except Exception:\n-                        pass\n-                    continue\n-\n-                # Collect metadata\n-                metadata = BenchmarkMetadata(\n-                    timestamp=datetime.utcnow().isoformat(),\n-                    commit_id=commit_id,\n-                    hardware_info=get_hardware_info(),\n-                    config=config,\n-                )\n-\n-                # Initialize GPU monitor\n-                gpu_monitor = None\n-                if collect_gpu_metrics:\n-                    gpu_monitor = GPUMonitor(logger=self.logger)\n-\n-                # Warmup runs\n-                self.logger.info(f\"Warming up with {config.warmup_iterations} iterations...\")\n-                warmup_failures = 0\n-                for i in range(config.warmup_iterations):\n-                    try:\n-                        _ = benchmark.measure_latency(config)\n-                    except Exception as e:\n-                        warmup_failures += 1\n-                        self.logger.warning(f\"Warmup iteration {i + 1} failed: {e}\")\n-\n-                # If more than half the warmup iterations failed, skip this scenario\n-                if warmup_failures > config.warmup_iterations // 2:\n-                    self.logger.warning(\n-                        f\"Skipping scenario {scenario_name}: too many warmup failures ({warmup_failures}/{config.warmup_iterations})\"\n-                    )\n-                    try:\n-                        scenario.teardown(benchmark.model, benchmark.tokenizer, self.logger)\n-                        benchmark.cleanup_model()\n-                    except Exception:\n-                        pass\n-                    continue\n-\n-                # Start GPU monitoring\n-                if gpu_monitor:\n-                    gpu_monitor.start()\n-\n-                # Measurement runs for latency\n-                self.logger.info(f\"Measuring latency with {config.measurement_iterations} iterations...\")\n-                latency_measurements = []\n-                ttft_measurements = []\n-                tokens_per_sec_measurements = []\n-                itl_measurements = []  # Inter-Token Latency\n-                measurement_failures = 0\n-\n-                for i in range(config.measurement_iterations):\n-                    try:\n-                        # Measure time to first token\n-                        ttft = benchmark.measure_time_to_first_token(config)\n-                        ttft_measurements.append(ttft)\n-\n-                        # Measure full latency\n-                        timing_result = benchmark.measure_latency(config)\n-                        latency_measurements.append(timing_result.latency_seconds)\n-\n-                        if timing_result.tokens_per_second is not None:\n-                            tokens_per_sec_measurements.append(timing_result.tokens_per_second)\n-\n-                        if timing_result.time_per_output_token_seconds is not None:\n-                            itl_measurements.append(timing_result.time_per_output_token_seconds)\n-\n-                        itl_str = (\n-                            f\", itl={timing_result.time_per_output_token_seconds:.4f}s/token\"\n-                            if timing_result.time_per_output_token_seconds\n-                            else \"\"\n-                        )\n-                        self.logger.debug(\n-                            f\"Iteration {i + 1}: latency={timing_result.latency_seconds:.4f}s, ttft={ttft:.4f}s{itl_str}\"\n-                        )\n-\n-                    except Exception as e:\n-                        measurement_failures += 1\n-                        self.logger.warning(f\"Measurement iteration {i + 1} failed: {e}\")\n-\n-                # Stop GPU monitoring\n-                gpu_metrics = {}\n-                if gpu_monitor:\n-                    gpu_metrics = gpu_monitor.stop_and_collect()\n-\n-                # If we don't have enough successful measurements, skip this scenario\n-                if not latency_measurements or len(latency_measurements) < config.measurement_iterations // 2:\n-                    self.logger.warning(\n-                        f\"Skipping scenario {scenario_name}: insufficient successful measurements ({len(latency_measurements)}/{config.measurement_iterations})\"\n-                    )\n-                    try:\n-                        scenario.teardown(benchmark.model, benchmark.tokenizer, self.logger)\n-                        benchmark.cleanup_model()\n-                    except Exception:\n-                        pass\n-                    continue\n-\n-                # Calculate statistics\n-                scenario_results = {\n-                    \"metadata\": asdict(metadata),\n-                    \"measurements\": {},\n-                    \"gpu_metrics\": gpu_metrics,\n-                    \"scenario_description\": scenario.description,\n-                }\n-\n-                if latency_measurements:\n-                    latency_stats = BenchmarkStatistics.from_measurements(\"latency_seconds\", latency_measurements)\n-                    scenario_results[\"measurements\"][\"latency_seconds\"] = asdict(latency_stats)\n-\n-                if ttft_measurements:\n-                    ttft_stats = BenchmarkStatistics.from_measurements(\n-                        \"time_to_first_token_seconds\", ttft_measurements\n-                    )\n-                    scenario_results[\"measurements\"][\"time_to_first_token_seconds\"] = asdict(ttft_stats)\n-\n-                if tokens_per_sec_measurements:\n-                    tps_stats = BenchmarkStatistics.from_measurements(\n-                        \"tokens_per_second\", tokens_per_sec_measurements, \"tokens/sec\"\n-                    )\n-                    scenario_results[\"measurements\"][\"tokens_per_second\"] = asdict(tps_stats)\n-\n-                if itl_measurements:\n-                    itl_stats = BenchmarkStatistics.from_measurements(\n-                        \"time_per_output_token_seconds\", itl_measurements, \"seconds/token\"\n-                    )\n-                    scenario_results[\"measurements\"][\"time_per_output_token_seconds\"] = asdict(itl_stats)\n-\n-                # Log summary\n-                if latency_measurements:\n-                    self.logger.info(f\"Latency: {latency_stats.mean:.4f}{latency_stats.std:.4f}s (meanstd)\")\n-                if ttft_measurements:\n-                    self.logger.info(f\"TTFT: {ttft_stats.mean:.4f}{ttft_stats.std:.4f}s (meanstd)\")\n-                if tokens_per_sec_measurements:\n-                    self.logger.info(f\"Throughput: {tps_stats.mean:.2f}{tps_stats.std:.2f} tokens/sec (meanstd)\")\n-                if itl_measurements:\n-                    self.logger.info(f\"ITL: {itl_stats.mean:.4f}{itl_stats.std:.4f}s/token (meanstd)\")\n-\n-                # Add note about partial results if some measurements failed\n-                if measurement_failures > 0:\n-                    scenario_results[\"warnings\"] = [f\"Some measurements failed ({measurement_failures} failures)\"]\n-                    self.logger.info(f\"Scenario completed with {measurement_failures} measurement failures\")\n-\n-                # Run scenario teardown callbacks\n-                scenario.teardown(benchmark.model, benchmark.tokenizer, self.logger)\n-\n-                # Cleanup model\n-                benchmark.cleanup_model()\n-\n-                all_results[scenario_name] = scenario_results\n-\n-            except Exception as e:\n-                self.logger.warning(f\"Skipping scenario {scenario_name}: setup failed - {e}\")\n-                import traceback\n-\n-                self.logger.debug(traceback.format_exc())\n-\n-                # Try to clean up if possible\n-                try:\n-                    scenario.teardown(benchmark.model, benchmark.tokenizer, self.logger)\n-                    benchmark.cleanup_model()\n-                except Exception:\n-                    pass\n-                # Skip storing failed scenarios - just continue to the next one\n-            finally:\n-                try:\n-                    scenario.teardown(benchmark.model, benchmark.tokenizer, self.logger)\n-                    benchmark.cleanup_model()\n-                except Exception as cleanup_error:\n-                    self.logger.warning(f\"Cleanup failed for scenario {scenario_name}: {cleanup_error}\")\n-\n-                flush_memory()\n-\n-        return all_results\n-\n-    def save_results(self, model_name: str, results: dict[str, dict[str, Any]]) -> str:\n-        \"\"\"Save benchmark results to JSON file.\"\"\"\n-        # Create model-specific subdirectory\n-        model_dir = os.path.join(self.output_dir, model_name)\n-        os.makedirs(model_dir, exist_ok=True)\n-\n-        # Create filename with timestamp\n-        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n-        filename = f\"{model_name}_benchmark_{timestamp}.json\"\n-        filepath = os.path.join(model_dir, filename)\n-\n-        # Prepare output structure\n-        output_data = {\"model_name\": model_name, \"benchmark_scenarios\": []}\n-\n-        for config_name, config_results in results.items():\n-            scenario = {\n-                \"scenario_name\": config_name,\n-                \"metadata\": config_results[\"metadata\"],\n-                \"measurements\": config_results[\"measurements\"],\n-                \"gpu_metrics\": config_results.get(\"gpu_metrics\", {}),\n-            }\n-            output_data[\"benchmark_scenarios\"].append(scenario)\n-\n-        # Save to JSON file\n-        with open(filepath, \"w\") as f:\n-            json.dump(output_data, f, indent=2, default=str)\n-\n-        self.logger.info(f\"Results saved to {filepath}\")\n-        return filepath"
        },
        {
            "sha": "c1754d8aa80cd5d9536cbd59c1da4199eea400ba",
            "filename": "benchmark_v2/framework/benchmark_config.py",
            "status": "added",
            "additions": 218,
            "deletions": 0,
            "changes": 218,
            "blob_url": "https://github.com/huggingface/transformers/blob/94df0e65602922be2831b3faa457a2bde78b936b/benchmark_v2%2Fframework%2Fbenchmark_config.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/94df0e65602922be2831b3faa457a2bde78b936b/benchmark_v2%2Fframework%2Fbenchmark_config.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/benchmark_v2%2Fframework%2Fbenchmark_config.py?ref=94df0e65602922be2831b3faa457a2bde78b936b",
            "patch": "@@ -0,0 +1,218 @@\n+import hashlib\n+import json\n+import logging\n+from typing import Any, Optional\n+\n+\n+KERNELIZATION_AVAILABLE = False\n+try:\n+    from kernels import Mode, kernelize  # noqa: F401\n+\n+    KERNELIZATION_AVAILABLE = True\n+except ImportError:\n+    pass\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class BenchmarkConfig:\n+    \"\"\"Configuration for a single benchmark scenario.\"\"\"\n+\n+    def __init__(\n+        self,\n+        warmup_iterations: int = 5,\n+        measurement_iterations: int = 20,\n+        gpu_monitoring: bool = False,  # False by default because it slows down the benchmark by a lot\n+        batch_size: int = 1,\n+        sequence_length: int = 128,\n+        num_tokens_to_generate: int = 128,\n+        attn_implementation: str = \"eager\",\n+        sdpa_backend: Optional[str] = None,\n+        compile_mode: Optional[str] = None,\n+        compile_options: Optional[dict[str, Any]] = None,\n+        kernelize: bool = False,\n+        name: Optional[str] = None,\n+        skip_validity_check: bool = False,\n+    ) -> None:\n+        # Benchmark parameters\n+        self.warmup_iterations = warmup_iterations\n+        self.measurement_iterations = measurement_iterations\n+        self.gpu_monitoring = gpu_monitoring\n+        # Input parameters\n+        self.batch_size = batch_size\n+        self.sequence_length = sequence_length\n+        self.num_tokens_to_generate = num_tokens_to_generate\n+        # Generation parameters\n+        self.attn_implementation = attn_implementation\n+        self.sdpa_backend = sdpa_backend\n+        # Optimization parameters\n+        self.compile_mode = compile_mode\n+        self.compile_options = compile_options if compile_options is not None else {}\n+        self.kernelize = kernelize\n+        # Constant parameters\n+        self.dtype = \"torch.bfloat16\"\n+        self.device = \"cuda\"\n+\n+        self.check_validity(skip_validity_check)\n+        self.name = name if name is not None else self.infer_name()\n+\n+    def check_validity(self, skip_validity_check: bool = False) -> None:\n+        if skip_validity_check:\n+            return\n+        # Flash attention does not support compile mode, so we turn it off # FIXME: it would be better to support it\n+        is_fa = self.attn_implementation == \"flash_attention_2\"\n+        is_fa |= self.attn_implementation == \"sdpa\" and self.sdpa_backend == \"flash_attention\"\n+        if is_fa:\n+            logger.warning(\"Flash attention does not support compile mode. Turning off compile mode.\")\n+            self.compile_mode = None\n+\n+    @property\n+    def hash(self) -> str:\n+        return hashlib.sha256(json.dumps(self.to_dict()).encode()).hexdigest()\n+\n+    def infer_name(self, compact: bool = True) -> str:\n+        \"\"\"Infer a human-readable name for the benchmark config, either compact or verbose.\"\"\"\n+        if compact:\n+            iter_str = f\"w{self.warmup_iterations}_i{self.measurement_iterations}\"\n+            gpu_monitor_str = \"monitored\" if self.gpu_monitoring else \"unmonitored\"\n+            dimensions_str = f\"b{self.batch_size}_s{self.sequence_length}_n{self.num_tokens_to_generate}\"\n+            attn_code = self.attn_implementation\n+            attn_code += f\"_{self.sdpa_backend}\" if self.attn_implementation == \"sdpa\" else \"\"\n+            compile_str = f\"compiled_{self.compile_mode}\" if self.compile_mode is not None else \"uncompiled\"\n+            kernelize_str = \"kernelized\" if self.kernelize else \"unkernelized\"\n+            sep = \"-\"\n+        else:\n+            iter_str = f\"{self.warmup_iterations} warmup, {self.measurement_iterations} iterations\"\n+            gpu_monitor_str = (\"with\" if self.gpu_monitoring else \"no\") + \" GPU monitoring\"\n+            dimensions_str = f\"batch size {self.batch_size}, sequence length {self.sequence_length}, {self.num_tokens_to_generate} generated tokens\"\n+            attn_code = f\"{self.attn_implementation} attention\"\n+            attn_code += f\" with {self.sdpa_backend} backend\" if self.attn_implementation == \"sdpa\" else \"\"\n+            compile_str = \"compiled\" if self.compile_mode is not None else \"not compiled\"\n+            kernelize_str = \"kernelized\" if self.kernelize else \"not kernelized\"\n+            sep = \", \"\n+        return sep.join([iter_str, gpu_monitor_str, dimensions_str, attn_code, compile_str, kernelize_str])\n+\n+    def to_dict(self) -> dict[str, Any]:\n+        return {\n+            \"name\": self.name,\n+            \"warmup_iterations\": self.warmup_iterations,\n+            \"measurement_iterations\": self.measurement_iterations,\n+            \"gpu_monitoring\": self.gpu_monitoring,\n+            \"batch_size\": self.batch_size,\n+            \"sequence_length\": self.sequence_length,\n+            \"num_tokens_to_generate\": self.num_tokens_to_generate,\n+            \"attn_implementation\": self.attn_implementation,\n+            \"sdpa_backend\": self.sdpa_backend,\n+            \"compile_mode\": self.compile_mode,\n+            \"compile_options\": self.compile_options,\n+            \"kernelize\": self.kernelize,\n+        }\n+\n+    @classmethod\n+    def from_dict(cls, data: dict[str, Any], skip_validity_check: bool = False) -> \"BenchmarkConfig\":\n+        return cls(\n+            warmup_iterations=data.get(\"warmup_iterations\", 5),\n+            measurement_iterations=data.get(\"measurement_iterations\", 20),\n+            gpu_monitoring=data.get(\"gpu_monitoring\", False),\n+            batch_size=data.get(\"batch_size\", 1),\n+            sequence_length=data.get(\"sequence_length\", 128),\n+            num_tokens_to_generate=data.get(\"num_tokens_to_generate\", 128),\n+            attn_implementation=data.get(\"attn_implementation\", \"eager\"),\n+            sdpa_backend=data.get(\"sdpa_backend\"),\n+            compile_mode=data.get(\"compile_mode\"),\n+            compile_options=data.get(\"compile_options\"),\n+            kernelize=data.get(\"kernelize\", False),\n+            name=data.get(\"name\"),\n+            skip_validity_check=skip_validity_check,\n+        )\n+\n+\n+def cross_generate_configs(\n+    attn_impl_and_sdpa_backend: list[tuple[str, Optional[str]]],\n+    compiled_mode: list[Optional[str]],\n+    kernelized: list[bool],\n+    warmup_iterations: int = 5,\n+    measurement_iterations: int = 20,\n+    batch_size: int = 1,\n+    sequence_length: int = 128,\n+    num_tokens_to_generate: int = 128,\n+    gpu_monitoring: bool = False,  # this slows down the benchmark by a lot so we disable it by default\n+) -> list[BenchmarkConfig]:\n+    # Create kwargs common to all configs\n+    kwargs = {\n+        \"warmup_iterations\": warmup_iterations,\n+        \"measurement_iterations\": measurement_iterations,\n+        \"batch_size\": batch_size,\n+        \"sequence_length\": sequence_length,\n+        \"num_tokens_to_generate\": num_tokens_to_generate,\n+        \"gpu_monitoring\": gpu_monitoring,\n+    }\n+    # Cross-generate all combinations of attn_implementation, compiled_mode, and kernelized\n+    configs = []\n+    for attn_implementation, sdpa_backend in list(dict.fromkeys(attn_impl_and_sdpa_backend)):\n+        for cm in list(dict.fromkeys(compiled_mode)):\n+            for kernelize_on in list(dict.fromkeys(kernelized)):\n+                config = BenchmarkConfig(\n+                    attn_implementation=attn_implementation,\n+                    sdpa_backend=sdpa_backend,\n+                    compile_mode=cm,\n+                    kernelize=kernelize_on,\n+                    **kwargs,\n+                )\n+                configs.append(config)\n+    return configs\n+\n+\n+def generate_all_configs(\n+    warmup_iterations: int = 5,\n+    measurement_iterations: int = 20,\n+    batch_size: int = 1,\n+    sequence_length: int = 128,\n+    num_tokens_to_generate: int = 128,\n+    gpu_monitoring: bool = False,\n+) -> list[BenchmarkConfig]:\n+    all_attn_implementations = [\n+        (\"flash_attention_2\", None),\n+        (\"eager\", None),\n+        (\"sdpa\", \"math\"),\n+        (\"sdpa\", \"flash_attention\"),\n+        (\"flex_attention\", None),\n+    ]\n+    return cross_generate_configs(\n+        attn_impl_and_sdpa_backend=all_attn_implementations,\n+        compiled_mode=[None, \"default\", \"reduce-overhead\", \"max-autotune\", \"max-autotune-no-cudagraphs\"],\n+        kernelized=[False, KERNELIZATION_AVAILABLE],\n+        warmup_iterations=warmup_iterations,\n+        measurement_iterations=measurement_iterations,\n+        batch_size=batch_size,\n+        sequence_length=sequence_length,\n+        num_tokens_to_generate=num_tokens_to_generate,\n+        gpu_monitoring=gpu_monitoring,\n+    )\n+\n+\n+def generate_default_configs(\n+    warmup_iterations: int = 5,\n+    measurement_iterations: int = 20,\n+    batch_size: int = 1,\n+    sequence_length: int = 128,\n+    num_tokens_to_generate: int = 128,\n+    gpu_monitoring: bool = False,\n+) -> list[BenchmarkConfig]:\n+    all_attn_implementations = [\n+        (\"flash_attention_2\", None),\n+        (\"eager\", None),\n+        (\"sdpa\", \"math\"),\n+        (\"sdpa\", \"flash_attention\"),  # note: this one can fail with compile because of attn mask\n+    ]\n+    return cross_generate_configs(\n+        attn_impl_and_sdpa_backend=all_attn_implementations,\n+        compiled_mode=[None, \"max-autotune\"],\n+        kernelized=[False, KERNELIZATION_AVAILABLE],\n+        warmup_iterations=warmup_iterations,\n+        measurement_iterations=measurement_iterations,\n+        batch_size=batch_size,\n+        sequence_length=sequence_length,\n+        num_tokens_to_generate=num_tokens_to_generate,\n+        gpu_monitoring=gpu_monitoring,\n+    )"
        },
        {
            "sha": "b5c4796b3fe0db1bee9327b4a624eb7c4462a903",
            "filename": "benchmark_v2/framework/benchmark_runner.py",
            "status": "added",
            "additions": 388,
            "deletions": 0,
            "changes": 388,
            "blob_url": "https://github.com/huggingface/transformers/blob/94df0e65602922be2831b3faa457a2bde78b936b/benchmark_v2%2Fframework%2Fbenchmark_runner.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/94df0e65602922be2831b3faa457a2bde78b936b/benchmark_v2%2Fframework%2Fbenchmark_runner.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/benchmark_v2%2Fframework%2Fbenchmark_runner.py?ref=94df0e65602922be2831b3faa457a2bde78b936b",
            "patch": "@@ -0,0 +1,388 @@\n+import gc\n+import json\n+import logging\n+import os\n+import pathlib\n+import re\n+import time\n+from contextlib import nullcontext\n+from datetime import datetime\n+from queue import Queue\n+from typing import Any, Optional\n+\n+import torch\n+from tqdm import trange\n+\n+from transformers import (\n+    AutoModelForCausalLM,\n+    AutoTokenizer,\n+    CompileConfig,\n+    GenerationConfig,\n+    GenerationMixin,\n+)\n+from transformers.generation.streamers import BaseStreamer\n+\n+from .benchmark_config import BenchmarkConfig\n+from .data_classes import BenchmarkMetadata, BenchmarkResult, GPURawMetrics, pretty_print_dict\n+from .hardware_metrics import GPUMonitor\n+\n+\n+try:\n+    from kernels import Mode, kernelize  # noqa: F401\n+except ImportError:\n+    kernelize = None\n+    Mode = None\n+\n+\n+DEFAULT_PROMPT = \"\\n\".join([\n+    \"The French Revolution was a period of political and societal change in France that began with the Estates General of 1789 and ended with the Coup of 18 Brumaire on 9 November 1799.\",\n+    \"Many of the revolution's ideas are considered fundamental principles of liberal democracy, and its values remain central to modern French political discourse.\",\n+    \"It was caused by a combination of social, political, and economic factors which the existing regime proved unable to manage.\",\n+    \"Financial crisis and widespread social distress led to the convocation of the Estates General in May 1789, its first meeting since 1614.\",\n+    \"The representatives of the Third Estate broke away and re-constituted themselves as a National Assembly in June.\",\n+    \"The Storming of the Bastille in Paris on 14 July led to a series of radical measures by the Assembly, including the abolition of feudalism, state control over the Catholic Church in France, and issuing the Declaration of the Rights of Man and of the Citizen.\",\n+    \"The next three years were dominated by a struggle for political control.\",\n+    \"King Louis XVI's attempted flight to Varennes in June 1791 further discredited the monarchy, and military defeats after the outbreak of the French Revolutionary Wars in April 1792 led to the insurrection of 10 August 1792.\",\n+    \"As a result, the monarchy was replaced by the French First Republic in September, followed by the execution of Louis XVI himself in January 1793.\",\n+    \"After another revolt in June 1793, the constitution was suspended, and political power passed from the National Convention to the Committee of Public Safety, dominated by radical Jacobins led by Maximilien Robespierre.\",\n+    \"About 16,000 people were sentenced by the Revolutionary Tribunal and executed in the Reign of Terror, which ended in July 1794 with the Thermidorian Reaction.\",\n+    \"Weakened by external threats and internal opposition, the Committee of Public Safety was replaced in November 1795 by the Directory.\",\n+    \"Its instability ended in the coup of 18 Brumaire and the establishment of the Consulate, with Napoleon Bonaparte as First Consul.\",\n+])  # fmt: skip\n+\n+\n+def compact_json_numeric_arrays(data: dict):\n+    # Match arrays that contain only numbers (ints/floats), whitespace, commas, and newlines\n+    pattern = r\"\\[\\s*\\n\\s*((?:\\d+(?:\\.\\d+)?\\s*,\\s*)*\\d+(?:\\.\\d+)?)\\s*\\n\\s*\\]\"\n+\n+    def replace_numeric_array(match):\n+        # Get the array content\n+        content = match.group(1)\n+        # Remove extra whitespace but keep commas\n+        compact_content = re.sub(r\"\\s+\", \" \", content).strip()\n+        return f\"[{compact_content}]\"\n+\n+    return re.sub(pattern, replace_numeric_array, json.dumps(data, indent=4, default=str), flags=re.DOTALL)\n+\n+\n+def get_git_revision() -> str:\n+    base_path = pathlib.Path(__file__).parent.parent.parent\n+    git_dir = base_path / \".git\"\n+    with (git_dir / \"HEAD\").open(\"r\") as head:\n+        ref = head.readline().split(\" \")[-1].strip()\n+    with (git_dir / ref).open(\"r\") as git_hash:\n+        return git_hash.readline().strip()\n+\n+\n+def get_sdpa_backend(backend_name: Optional[str]) -> Optional[torch.nn.attention.SDPBackend]:\n+    \"\"\"Get the SDPA backend enum from string name.\"\"\"\n+    if backend_name is None:\n+        return None\n+\n+    try:\n+        backend_map = {\n+            \"math\": torch.nn.attention.SDPBackend.MATH,\n+            \"flash_attention\": torch.nn.attention.SDPBackend.FLASH_ATTENTION,\n+            \"efficient_attention\": torch.nn.attention.SDPBackend.EFFICIENT_ATTENTION,\n+            \"cudnn_attention\": torch.nn.attention.SDPBackend.CUDNN_ATTENTION,\n+        }\n+        return backend_map.get(backend_name.lower())\n+    except AttributeError:\n+        # torch.nn.attention.SDPBackend not available in older torch versions\n+        return None\n+\n+\n+def flush_memory():\n+    \"\"\"Flush GPU memory and run garbage collection.\"\"\"\n+    gc.collect()\n+    # Dynamo resets\n+    torch._dynamo.reset()\n+    torch._dynamo.reset_code_caches()\n+    if hasattr(torch._inductor, \"codecache\"):\n+        # Clear FX graph cache\n+        if hasattr(torch._inductor.codecache, \"FxGraphCache\"):\n+            torch._inductor.codecache.FxGraphCache.clear()\n+        # Clear PyCodeCache\n+        if hasattr(torch._inductor.codecache, \"PyCodeCache\"):\n+            torch._inductor.codecache.PyCodeCache.cache_clear()\n+        # Clear TritonFuture cache (for async compilation)\n+        if hasattr(torch._inductor.codecache, \"TritonFuture\"):\n+            if hasattr(torch._inductor.codecache.TritonFuture, \"_compile_cache\"):\n+                torch._inductor.codecache.TritonFuture._compile_cache.clear()\n+    # Clear CUDA cache\n+    if torch.cuda.is_available():\n+        torch.cuda.empty_cache()\n+        torch.cuda.reset_max_memory_allocated()\n+        torch.cuda.reset_peak_memory_stats()\n+        torch.cuda.synchronize()\n+    gc.collect()\n+\n+\n+class BenchmarkStreamer(BaseStreamer):\n+    def __init__(self, **kwargs) -> None:\n+        self.timestamps = []\n+        self.text_queue = Queue()\n+\n+    def put(self, value):\n+        \"\"\"Receives tokens and logs the timestamp of the generation.\"\"\"\n+        self.timestamps.append(time.perf_counter())\n+\n+    def end(self):\n+        self.timestamps.append(time.perf_counter())\n+\n+    def __iter__(self):\n+        return self\n+\n+    def __next__(self):\n+        value = self.text_queue.get(timeout=self.timeout)\n+        if value == self.stop_signal:\n+            raise StopIteration()\n+        else:\n+            return value\n+\n+\n+class BenchmarkRunner:\n+    \"\"\"Main benchmark runner that coordinates benchmark execution.\"\"\"\n+\n+    def __init__(\n+        self, logger: logging.Logger, output_dir: str = \"benchmark_results\", commit_id: Optional[str] = None\n+    ) -> None:\n+        # Those stay constant for the whole run\n+        self.logger = logger\n+        self.output_dir = output_dir\n+        self.commit_id = get_git_revision() if commit_id is None else commit_id\n+        os.makedirs(self.output_dir, exist_ok=True)\n+        self.profile_dir = None\n+        # Attributes that are reset for each model\n+        self._setup_for = \"\"\n+        # Attributes that are reset for each run\n+        self.model: Optional[GenerationMixin] = None\n+\n+    def cleanup(self) -> None:\n+        del self.model\n+        self.model = None\n+        flush_memory()\n+\n+    def setup_one_run(self, model_id: str, config: BenchmarkConfig) -> None:\n+        # Some attributes only need to be set once per model\n+        if self._setup_for != model_id:\n+            self.tokenizer = AutoTokenizer.from_pretrained(model_id)\n+            # We set the EOS token to the padding token for open-ended generation\n+            self.tokenizer.eos_token = self.tokenizer.pad_token\n+            self._setup_for = model_id\n+\n+        # Prepare inputs\n+        self.inputs = self.tokenizer(\n+            [DEFAULT_PROMPT for _ in range(config.batch_size)],\n+            return_tensors=\"pt\",\n+            max_length=config.sequence_length,\n+            truncation=True,\n+            return_attention_mask=True,\n+        ).to(config.device)\n+        self.inputs[\"use_cache\"] = True\n+\n+        # Prepare generation config\n+        gen_config = GenerationConfig(\n+            do_sample=False, top_p=1.0, temperature=1.0, max_new_tokens=config.num_tokens_to_generate\n+        )\n+\n+        # Prepare compile config\n+        if config.compile_mode is not None:\n+            gen_config.compile_config = CompileConfig(mode=config.compile_mode, options=config.compile_options)\n+            gen_config.cache_implementation = \"static\"\n+\n+        # Load model\n+        self.logger.debug(f\"Loading model {model_id} on device {config.device}...\")\n+        dtype = getattr(torch, config.dtype.removeprefix(\"torch.\"))\n+        self.model = AutoModelForCausalLM.from_pretrained(\n+            model_id, dtype=dtype, attn_implementation=config.attn_implementation, generation_config=gen_config\n+        )\n+        self.model = self.model.eval().to(config.device)\n+\n+        # Kernelize the model if needed\n+        if config.kernelize:\n+            self.model = kernelize(self.model, mode=Mode.INFERENCE)\n+\n+    def run_one_benchmark(self, model_id: str, config: BenchmarkConfig, num_tokens_to_profile: int = 0) -> None:\n+        sdpa_ctx = nullcontext()\n+        if config.attn_implementation == \"sdpa\":\n+            sdpa_backend = get_sdpa_backend(config.sdpa_backend)\n+            sdpa_ctx = torch.nn.attention.sdpa_kernel(sdpa_backend)\n+\n+        with sdpa_ctx, torch.no_grad():\n+            self.logger.info(f\"Running benchmark scenario: {config.name}\")\n+\n+            # Quick validation: try one measurement first to see if this scenario works\n+            flush_memory()\n+            e2e_latency, token_generation_times, decoded_output, gpu_metrics = self.time_generate(\n+                max_new_tokens=1, gpu_monitor=None\n+            )\n+            if e2e_latency < 0:\n+                self.logger.warning(f\"Skipping config {config.name}: {e2e_latency = } (no GPU monitoring)\")\n+                return None\n+\n+            # Warmup runs\n+            self.logger.info(f\"Warming up with {config.warmup_iterations} iterations...\")\n+            for _ in trange(config.warmup_iterations):\n+                _ = self.time_generate(max_new_tokens=config.num_tokens_to_generate)\n+            self.logger.info(\"Warmup over.\")\n+\n+            # Measurement runs\n+            result = BenchmarkResult()\n+            self.logger.info(f\"Benchmarking with {config.measurement_iterations} iterations.\")\n+            for _ in trange(config.measurement_iterations):\n+                e2e_latency, token_generation_times, decoded_output, gpu_metrics = self.time_generate(\n+                    max_new_tokens=config.num_tokens_to_generate,\n+                    gpu_monitor=(GPUMonitor(logger=self.logger) if config.gpu_monitoring else None),\n+                )\n+                result.accumulate(e2e_latency, token_generation_times, decoded_output, gpu_metrics)\n+            self.logger.info(\"Benchmarking done. Cleaning up.\")\n+\n+            # Profile if needed\n+            if num_tokens_to_profile > 0:\n+                self.profile_generate(num_tokens_to_profile, config.name)\n+\n+            return {\n+                \"metadata\": BenchmarkMetadata(model_id=model_id, commit_id=self.commit_id),\n+                \"measurements\": result,\n+                \"config\": config,\n+            }\n+\n+    def time_generate(\n+        self,\n+        max_new_tokens: int,\n+        gpu_monitor: Optional[GPUMonitor] = None,\n+    ) -> tuple[float, list[float], str, Optional[GPURawMetrics]]:\n+        \"\"\"Time the latency of a call to model.generate() with the given (inputs) and (max_new_tokens).\"\"\"\n+        # Prepare gpu monitoring if needed\n+        if gpu_monitor is not None:\n+            gpu_monitor.start()\n+        # Prepare streamer\n+        streamer = BenchmarkStreamer()\n+        # Generate and time\n+        wall_time_0 = time.perf_counter()\n+        outputs = self.model.generate(\n+            **self.inputs,\n+            max_new_tokens=max_new_tokens,\n+            streamer=streamer,\n+        )\n+        wall_time_1 = time.perf_counter()\n+        # Stop gpu monitoring if needed\n+        gpu_metrics = gpu_monitor.stop_and_collect() if gpu_monitor is not None else None\n+        # Check if generation had the right number of tokens\n+        input_tokens = self.inputs[\"input_ids\"].size(-1)\n+        batch_size, output_tokens = outputs.shape\n+        new_tokens = output_tokens - input_tokens\n+        if new_tokens != max_new_tokens:\n+            raise RuntimeError(f\"Generated {new_tokens} tokens, expected {max_new_tokens}\")\n+        # Decode outputs\n+        decoded_output = self.tokenizer.decode(outputs[0, input_tokens:], skip_special_tokens=True)\n+        # Compute intermediate quantities\n+        e2e_latency = wall_time_1 - wall_time_0\n+        token_generation_times = [t - wall_time_0 for t in streamer.timestamps[1:]]\n+        return e2e_latency, token_generation_times, decoded_output, gpu_metrics\n+\n+    def profile_generate(self, num_tokens_to_profile: int, config_name: str) -> None:\n+        \"\"\"Profile the latency of a call to model.generate() with the given (inputs) and (max_new_tokens).\"\"\"\n+        profiler = torch.profiler.profile(\n+            activities=[torch.profiler.ProfilerActivity.CPU, torch.profiler.ProfilerActivity.CUDA],\n+            record_shapes=True,\n+        )\n+        with profiler as prof:\n+            _ = self.model.generate(\n+                **self.inputs,\n+                max_new_tokens=num_tokens_to_profile,\n+            )\n+        if self.profile_dir is None:\n+            self.profile_dir = self.output_dir + \"_profiles\"\n+            os.makedirs(self.profile_dir, exist_ok=True)\n+        prof.export_chrome_trace(f\"{self.profile_dir}/{config_name}.json\")\n+\n+    def run_benchmarks(\n+        self,\n+        model_id: str,\n+        benchmark_configs: list[BenchmarkConfig],\n+        num_tokens_to_profile: int = 0,\n+        pretty_print_summary: bool = True,\n+    ) -> dict[str, Any]:\n+        all_results = {}\n+        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n+        start_time = time.perf_counter()\n+\n+        n_configs = len(benchmark_configs)\n+        for i, config in enumerate(benchmark_configs):\n+            # Handle SDPA backend if not determined by the config (needs to be done before skipping duplicates)\n+            if config.attn_implementation == \"sdpa\" and config.sdpa_backend is None:\n+                default_backend = \"flash_attention\"  # FIXME: torch has a _cur_sdpa_kernel_backends but it fails\n+                self.logger.warning(f\"No SDPA backend provided, using {default_backend} instead.\")\n+                config.sdpa_backend = default_backend\n+\n+            # Skip if already run\n+            if config.hash in all_results:\n+                self.logger.info(f\"Skipping duplicate config {config.name} for model {model_id} ({i + 1}/{n_configs})\")\n+                continue\n+\n+            # Otherwise, run the benchmark\n+            self.setup_one_run(model_id, config)\n+            self.logger.info(\n+                f\"Running benchmark of model {model_id} with scenario: {config.name} ({i + 1}/{n_configs})\"\n+            )\n+\n+            # Launch benchmark in a try/except block to avoid stopping the whole run if one benchmark fails\n+            try:\n+                results = self.run_one_benchmark(model_id, config, num_tokens_to_profile)\n+                if results is not None:\n+                    all_results[config.hash] = results\n+\n+            except Exception as e:\n+                self.logger.error(f\"Error running with scenario: {config.name}:\\n{repr(e)}\")\n+            # Cleanup model and save results\n+            self.cleanup()\n+            self.save_results(model_id, all_results, timestamp=timestamp)\n+\n+        if pretty_print_summary:\n+            print()\n+            print(\"=\" * 100)\n+            print(f\"Finished benchmarks in {time.perf_counter() - start_time:.2f} seconds\")\n+            print(f\"Total number of benchmarks: {len(all_results)}\")\n+            if len(all_results) > 0:\n+                print(\"First run metadata:\")\n+                first_key = list(all_results.keys())[0]\n+                first_metadata = all_results[first_key][\"metadata\"].to_dict()\n+                hardware_info = first_metadata.pop(\"hardware_info\")\n+                pretty_print_dict(first_metadata | hardware_info, tabs=1)\n+            for value in all_results.values():\n+                print(\"=\" * 100)\n+                print(f\"Config: {value['config'].infer_name(compact=False)}\\n\")\n+                value[\"measurements\"].pprint(tabs=1)\n+            print(\"=\" * 100)\n+\n+        return all_results\n+\n+    def save_results(self, model_name: str, results: dict, timestamp: str = \"\") -> str:\n+        \"\"\"Save benchmark results to JSON file.\"\"\"\n+        # Create model-specific subdirectory\n+        model_name = model_name.replace(\"/\", \"_\")\n+        model_dir = os.path.join(self.output_dir, model_name)\n+        os.makedirs(model_dir, exist_ok=True)\n+\n+        # Create filename with timestamp\n+        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\") if not timestamp else timestamp\n+        filename = f\"{model_name}_benchmark_{timestamp}.json\"\n+        filepath = os.path.join(model_dir, filename)\n+\n+        # Convert results to dict\n+        converted_results = {}\n+        for cfg_hash in results.keys():\n+            converted_results[cfg_hash] = {\n+                \"metadata\": results[cfg_hash][\"metadata\"].to_dict(),\n+                \"measurements\": results[cfg_hash][\"measurements\"].to_dict(),\n+                \"config\": results[cfg_hash][\"config\"].to_dict(),\n+            }\n+\n+        # Save to JSON file\n+        with open(filepath, \"w\") as f:\n+            f.write(compact_json_numeric_arrays(converted_results))\n+\n+        self.logger.info(f\"Results saved to {filepath}\")\n+        return filepath"
        },
        {
            "sha": "b47119341a7ad8cff2398637afef0fa5ee1c1750",
            "filename": "benchmark_v2/framework/data_classes.py",
            "status": "added",
            "additions": 152,
            "deletions": 0,
            "changes": 152,
            "blob_url": "https://github.com/huggingface/transformers/blob/94df0e65602922be2831b3faa457a2bde78b936b/benchmark_v2%2Fframework%2Fdata_classes.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/94df0e65602922be2831b3faa457a2bde78b936b/benchmark_v2%2Fframework%2Fdata_classes.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/benchmark_v2%2Fframework%2Fdata_classes.py?ref=94df0e65602922be2831b3faa457a2bde78b936b",
            "patch": "@@ -0,0 +1,152 @@\n+from dataclasses import dataclass\n+from datetime import datetime\n+from typing import Any, Optional, Union\n+\n+import numpy as np\n+\n+from .hardware_metrics import GPURawMetrics, HardwareInfo\n+\n+\n+def compute_basic_statistics(measurements: list[float]) -> dict[str, float]:\n+    return {\n+        \"avg\": np.mean(measurements),\n+        \"std\": np.std(measurements),\n+        \"min\": np.min(measurements),\n+        \"med\": np.median(measurements),\n+        \"max\": np.max(measurements),\n+        \"p95\": np.percentile(measurements, 95),\n+    }\n+\n+\n+def add_unit_to_duration(stats: dict[str, float]) -> dict[str, str]:\n+    for key in list(stats.keys()):\n+        value = stats[key]\n+        if value > 3600:\n+            stats[key] = f\"{(value / 3600):.2f}hr\"\n+        elif value > 60:\n+            stats[key] = f\"{(value / 60):.2f}min\"\n+        elif value > 1:\n+            stats[key] = f\"{value:.2f}s\"\n+        elif value > 1e-3:\n+            stats[key] = f\"{(value * 1e3):.2f}ms\"\n+        elif value > 1e-6:\n+            stats[key] = f\"{(value * 1e6):.2f}us\"\n+        else:\n+            stats[key] = f\"{(value * 1e9):.2f}ns\"\n+    return stats\n+\n+\n+def equalize_lengths_and_collate(stats: list[dict[str, str]]) -> list[str]:\n+    keys = [\"avg\", \"std\", \"min\", \"med\", \"max\", \"p95\"]\n+    for key in keys:\n+        max_length = max(len(stat[key]) for stat in stats)\n+        for stat in stats:\n+            stat[key] = stat[key].ljust(max_length, \" \")\n+    return [\" \".join([f\"{key}={stat[key]}\" for key in keys]) for stat in stats]\n+\n+\n+def pretty_print_dict(data: dict[str, Any], tabs: int = 0) -> None:\n+    max_key_length = max([len(key) for key in data.keys()])\n+    for key, value in data.items():\n+        tabs_str = \"  \" * tabs\n+        padded_key = key.ljust(max_key_length + 1, \".\")\n+        print(f\"{tabs_str}{padded_key}: {value}\")\n+\n+\n+@dataclass\n+class BenchmarkMetadata:\n+    \"\"\"Metadata collected for each benchmark run.\"\"\"\n+\n+    model_id: str\n+    timestamp: str\n+    commit_id: str\n+    hardware_info: HardwareInfo\n+\n+    def __init__(self, model_id: str, commit_id: str):\n+        self.model_id = model_id\n+        self.timestamp = datetime.utcnow().isoformat()\n+        self.commit_id = commit_id\n+        self.hardware_info = HardwareInfo()\n+\n+    def to_dict(self) -> dict[str, Any]:\n+        return {\n+            \"timestamp\": self.timestamp,\n+            \"commit_id\": self.commit_id,\n+            \"hardware_info\": self.hardware_info.to_dict(),\n+        }\n+\n+\n+class BenchmarkResult:\n+    \"\"\"Result from a series of benchmark runs.\"\"\"\n+\n+    def __init__(self) -> None:\n+        self.e2e_latency = []\n+        self.token_generation_times = []  # time at which each token was generated (relative to start of the generation)\n+        self.decoded_outputs = []\n+        self.gpu_metrics = []\n+\n+    def accumulate(\n+        self,\n+        e2e_latency: float,\n+        token_generation_times: list[float],\n+        decoded_output: str,\n+        gpu_metrics: Optional[GPURawMetrics],\n+    ) -> None:\n+        self.e2e_latency.append(e2e_latency)\n+        self.token_generation_times.append(token_generation_times)\n+        self.decoded_outputs.append(decoded_output)\n+        self.gpu_metrics.append(gpu_metrics)\n+\n+    def to_dict(self) -> dict[str, Union[None, int, float]]:\n+        # Save GPU metrics as None if it contains only None values\n+        if all(gm is None for gm in self.gpu_metrics):\n+            gpu_metrics = None\n+        else:\n+            gpu_metrics = [gm.to_dict() for gm in self.gpu_metrics]\n+        return {\n+            \"e2e_latency\": self.e2e_latency,\n+            \"token_generation_times\": self.token_generation_times,\n+            \"decoded_outputs\": self.decoded_outputs,\n+            \"gpu_metrics\": gpu_metrics,\n+        }\n+\n+    @classmethod\n+    def from_dict(cls, data: dict[str, Union[None, int, float]]) -> \"BenchmarkResult\":\n+        # Handle GPU metrics, which is saved as None if it contains only None values\n+        if data[\"gpu_metrics\"] is None:\n+            gpu_metrics = [None for _ in range(len(data[\"e2e_latency\"]))]\n+        else:\n+            gpu_metrics = [GPURawMetrics.from_dict(gm) for gm in data[\"gpu_metrics\"]]\n+        # Create a new instance and accumulate the data\n+        new_instance = cls()\n+        for i in range(len(data[\"e2e_latency\"])):\n+            new_instance.accumulate(\n+                e2e_latency=data[\"e2e_latency\"][i],\n+                token_generation_times=data[\"token_generation_times\"][i],\n+                decoded_output=data[\"decoded_output\"][i],\n+                gpu_metrics=gpu_metrics[i],\n+            )\n+        return new_instance\n+\n+    def get_measured_ttft(self) -> list[float]:\n+        return [dt[0] for dt in self.token_generation_times if len(dt) > 0]\n+\n+    def get_measured_itl(self) -> list[float]:\n+        return [(dt[-1] - dt[0]) / (len(dt) - 1) for dt in self.token_generation_times if len(dt) > 1]\n+\n+    def pprint(self, tabs: int = 0) -> None:\n+        collated_stats = equalize_lengths_and_collate(\n+            [\n+                add_unit_to_duration(compute_basic_statistics(self.e2e_latency)),\n+                add_unit_to_duration(compute_basic_statistics(self.get_measured_ttft())),\n+                add_unit_to_duration(compute_basic_statistics(self.get_measured_itl())),\n+            ]\n+        )\n+        pretty_print_dict(\n+            {\n+                \"E2E Latency\": collated_stats[0],\n+                \"Time to First Token\": collated_stats[1],\n+                \"Inter-Token Latency\": collated_stats[2],\n+            },\n+            tabs=tabs,\n+        )"
        },
        {
            "sha": "d301e5dbc4e345a5432cdfc2d67e4eabb960dee2",
            "filename": "benchmark_v2/framework/hardware_metrics.py",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/huggingface/transformers/blob/94df0e65602922be2831b3faa457a2bde78b936b/benchmark_v2%2Fframework%2Fhardware_metrics.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/94df0e65602922be2831b3faa457a2bde78b936b/benchmark_v2%2Fframework%2Fhardware_metrics.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/benchmark_v2%2Fframework%2Fhardware_metrics.py?ref=94df0e65602922be2831b3faa457a2bde78b936b",
            "patch": "@@ -0,0 +1,172 @@\n+import json\n+import logging\n+import subprocess\n+import sys\n+import threading\n+import time\n+from dataclasses import dataclass\n+from enum import Enum\n+from logging import Logger\n+from typing import Optional, Union\n+\n+import gpustat\n+import psutil\n+import torch\n+\n+\n+# Data class to hold the hardware information\n+def get_device_name_and_memory_total() -> tuple[str, float]:\n+    \"\"\"Returns the name and memory total of GPU 0.\"\"\"\n+    device_name = torch.cuda.get_device_properties(0).name\n+    device_memory_total = torch.cuda.get_device_properties(0).total_memory / 1024**3\n+    return device_name, device_memory_total\n+\n+\n+class HardwareInfo:\n+    \"\"\"A class to hold information about the hardware.\"\"\"\n+\n+    def __init__(self) -> None:\n+        # Retrieve GPU stats\n+        try:\n+            self.gpu_name, self.gpu_memory_total_gb = get_device_name_and_memory_total()\n+        except Exception:\n+            self.gpu_name, self.gpu_memory_total_gb = None, None\n+        # Retrieve python, torch and CUDA version\n+        self.python_version = f\"{sys.version.split()[0]}\"\n+        self.torch_version = torch.__version__\n+        if hasattr(torch, \"cuda\") and torch.cuda.is_available():\n+            self.cuda_version = torch.version.cuda\n+        else:\n+            self.cuda_version = None\n+        # Retrieve general hardware information\n+        self.cpu_count = psutil.cpu_count()\n+        self.memory_total_mb = int(psutil.virtual_memory().total / (1024 * 1024))\n+\n+    def to_dict(self) -> dict[str, Union[None, int, float, str]]:\n+        return {\n+            \"gpu_name\": self.gpu_name,\n+            \"gpu_memory_total_gb\": self.gpu_memory_total_gb,\n+            \"python_version\": self.python_version,\n+            \"torch_version\": self.torch_version,\n+        }\n+\n+\n+# Functions to get information about the GPU\n+def get_amd_gpu_stats() -> tuple[int, float]:\n+    \"\"\"Returns the utilization and memory used of an AMD GPU, both in percent\"\"\"\n+    rocm_smi_output = subprocess.check_output([\"rocm-smi\", \"--json\", \"--showuse\", \"--showmeminfo\", \"VRAM\"])\n+    gpu_stats = json.loads(rocm_smi_output.decode(\"utf-8\"))\n+    gpu_stats = [\n+        (card_id, stats[\"GPU use (%)\"], stats[\"VRAM Total Used Memory (B)\"]) for card_id, stats in gpu_stats.items()\n+    ]\n+    gpu_stats.sort(key=lambda x: x[1], reverse=True)\n+    return int(gpu_stats[0][1]), float(gpu_stats[0][2]) / 1024**3\n+\n+\n+def get_nvidia_gpu_stats() -> tuple[int, float]:\n+    \"\"\"Returns the utilization and memory used of an NVIDIA GPU, both in percent\"\"\"\n+    gpu_stats = gpustat.GPUStatCollection.new_query()\n+    gpu_stats = gpu_stats[0]\n+    return int(gpu_stats[\"utilization.gpu\"]), float(gpu_stats[\"memory.used\"]) / 1024**3\n+\n+\n+class GPUStatsCollector:\n+    \"\"\"A class to get statistics about the GPU. It serves as a wrapper that holds the GPU total memory and its name,\n+    which is used to call the right function to get the utilization and memory used.\"\"\"\n+\n+    def __init__(self) -> None:\n+        self.device_name, self.device_memory_total = get_device_name_and_memory_total()\n+        # Monkey patch the get_utilization_and_memory_used method based on the GPU type\n+        if \"amd\" in self.device_name.lower():\n+            self.get_utilization_and_memory_used = get_amd_gpu_stats\n+        elif \"nvidia\" in self.device_name.lower():\n+            self.get_utilization_and_memory_used = get_nvidia_gpu_stats\n+        else:\n+            raise RuntimeError(f\"Unsupported GPU: {self.device_name}\")\n+\n+    def get_measurements(self) -> tuple[int, float]:\n+        \"\"\"Get the utilization and memory used of the GPU, both in percent\"\"\"\n+        raise NotImplementedError(\"This method is meant to be monkey patched during __init__\")\n+\n+\n+# Simple data classes to hold the raw GPU metrics\n+class GPUMonitoringStatus(Enum):\n+    \"\"\"Status of GPU monitoring.\"\"\"\n+\n+    SUCCESS = \"success\"\n+    FAILED = \"failed\"\n+    NO_GPUS_AVAILABLE = \"no_gpus_available\"\n+    NO_SAMPLES_COLLECTED = \"no_samples_collected\"\n+\n+\n+@dataclass\n+class GPURawMetrics:\n+    \"\"\"Raw values for GPU utilization and memory used.\"\"\"\n+\n+    utilization: list[float]  # in percent\n+    memory_used: list[float]  # in GB\n+    timestamps: list[float]  # in seconds\n+    timestamp_0: float  # in seconds\n+    monitoring_status: GPUMonitoringStatus\n+\n+    def to_dict(self) -> dict[str, Union[None, int, float, str]]:\n+        return {\n+            \"utilization\": self.utilization,\n+            \"memory_used\": self.memory_used,\n+            \"timestamps\": self.timestamps,\n+            \"timestamp_0\": self.timestamp_0,\n+            \"monitoring_status\": self.monitoring_status.value,\n+        }\n+\n+\n+# Main class, used to monitor the GPU utilization during benchmark execution\n+class GPUMonitor:\n+    \"\"\"Monitor GPU utilization during benchmark execution.\"\"\"\n+\n+    def __init__(self, sample_interval_sec: float = 0.1, logger: Optional[Logger] = None):\n+        self.sample_interval_sec = sample_interval_sec\n+        self.logger = logger if logger is not None else logging.getLogger(__name__)\n+\n+        self.num_available_gpus = torch.cuda.device_count()\n+        if self.num_available_gpus == 0:\n+            raise RuntimeError(\"No GPUs detected by torch.cuda.device_count().\")\n+        self.gpu_stats_getter = GPUStatsCollector()\n+\n+    def start(self):\n+        \"\"\"Start monitoring GPU metrics.\"\"\"\n+        # Clear the stop event to enable monitoring\n+        self.stop_event = threading.Event()\n+        self.gpu_utilization = []\n+        self.gpu_memory_used = []\n+        self.timestamps = []\n+        self.thread = threading.Thread(target=self._monitor_loop)\n+        self.thread.start()\n+        self.logger.debug(\"GPU monitoring started\")\n+\n+    def stop_and_collect(self) -> GPURawMetrics:\n+        \"\"\"Stop monitoring and return collected metrics.\"\"\"\n+        self.stop_event.set()\n+        self.thread.join()\n+        if self.gpu_utilization:\n+            timestamp_0 = self.timestamps[0]\n+            metrics = GPURawMetrics(\n+                utilization=self.gpu_utilization,\n+                memory_used=self.gpu_memory_used,\n+                timestamps=[t - timestamp_0 for t in self.timestamps],\n+                timestamp_0=timestamp_0,\n+                monitoring_status=GPUMonitoringStatus.SUCCESS,\n+            )\n+            self.logger.debug(f\"GPU monitoring completed: {len(self.gpu_utilization)} samples collected\")\n+        else:\n+            metrics = GPURawMetrics(monitoring_status=GPUMonitoringStatus.NO_SAMPLES_COLLECTED)\n+        return metrics\n+\n+    def _monitor_loop(self):\n+        \"\"\"Background monitoring loop using threading.Event for communication.\"\"\"\n+        while not self.stop_event.is_set():\n+            utilization, memory_used = self.gpu_stats_getter.get_utilization_and_memory_used()\n+            self.gpu_utilization.append(utilization)\n+            self.gpu_memory_used.append(memory_used)\n+            self.timestamps.append(time.time())\n+            if self.stop_event.wait(timeout=self.sample_interval_sec):\n+                break"
        },
        {
            "sha": "85fb5a9493f5ea5311185862c5d88fb131cf65c9",
            "filename": "benchmark_v2/run_benchmarks.py",
            "status": "modified",
            "additions": 68,
            "deletions": 452,
            "changes": 520,
            "blob_url": "https://github.com/huggingface/transformers/blob/94df0e65602922be2831b3faa457a2bde78b936b/benchmark_v2%2Frun_benchmarks.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/94df0e65602922be2831b3faa457a2bde78b936b/benchmark_v2%2Frun_benchmarks.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/benchmark_v2%2Frun_benchmarks.py?ref=94df0e65602922be2831b3faa457a2bde78b936b",
            "patch": "@@ -19,477 +19,93 @@\n \"\"\"\n \n import argparse\n-import importlib.util\n-import json\n import logging\n-import os\n+import random\n import sys\n import uuid\n-from datetime import datetime\n-from pathlib import Path\n-from typing import Any, Optional\n \n+from framework.benchmark_config import BenchmarkConfig, generate_all_configs\n+from framework.benchmark_runner import BenchmarkRunner\n \n-def setup_logging(log_level: str = \"INFO\", enable_file_logging: bool = False) -> logging.Logger:\n-    \"\"\"Setup logging configuration.\"\"\"\n-    numeric_level = getattr(logging, log_level.upper(), None)\n-    if not isinstance(numeric_level, int):\n-        raise ValueError(f\"Invalid log level: {log_level}\")\n-\n-    handlers = [logging.StreamHandler(sys.stdout)]\n-\n-    if enable_file_logging:\n-        handlers.append(logging.FileHandler(f\"benchmark_run_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log\"))\n-\n-    logging.basicConfig(\n-        level=numeric_level, format=\"[%(levelname)s - %(asctime)s] %(name)s: %(message)s\", handlers=handlers\n-    )\n-\n-    return logging.getLogger(__name__)\n-\n-\n-def discover_benchmarks(benches_dir: str) -> list[dict[str, Any]]:\n-    \"\"\"\n-    Discover all benchmark modules in the benches directory.\n-\n-    Returns:\n-        List of dictionaries containing benchmark module info\n-    \"\"\"\n-    benchmarks = []\n-    benches_path = Path(benches_dir)\n-\n-    if not benches_path.exists():\n-        raise FileNotFoundError(f\"Benches directory not found: {benches_dir}\")\n-\n-    for py_file in benches_path.glob(\"*.py\"):\n-        if py_file.name.startswith(\"__\"):\n-            continue\n-\n-        module_name = py_file.stem\n-\n-        try:\n-            # Import the module\n-            spec = importlib.util.spec_from_file_location(module_name, py_file)\n-            module = importlib.util.module_from_spec(spec)\n-            spec.loader.exec_module(module)\n-\n-            # Check if it has a benchmark runner function\n-            if hasattr(module, f\"run_{module_name}\"):\n-                benchmarks.append(\n-                    {\n-                        \"name\": module_name,\n-                        \"path\": str(py_file),\n-                        \"module\": module,\n-                        \"runner_function\": getattr(module, f\"run_{module_name}\"),\n-                    }\n-                )\n-            elif hasattr(module, \"run_benchmark\"):\n-                benchmarks.append(\n-                    {\n-                        \"name\": module_name,\n-                        \"path\": str(py_file),\n-                        \"module\": module,\n-                        \"runner_function\": getattr(module, \"run_benchmark\"),\n-                    }\n-                )\n-            else:\n-                logging.warning(f\"No runner function found in {py_file}\")\n-\n-        except Exception as e:\n-            logging.error(f\"Failed to import {py_file}: {e}\")\n-\n-    return benchmarks\n-\n-\n-def run_single_benchmark(\n-    benchmark_info: dict[str, Any], output_dir: str, logger: logging.Logger, **kwargs\n-) -> Optional[str]:\n-    \"\"\"\n-    Run a single benchmark and return the output file path.\n-\n-    Args:\n-        benchmark_info: Dictionary containing benchmark module info\n-        output_dir: Base output directory\n-        logger: Logger instance\n-        **kwargs: Additional arguments to pass to the benchmark\n-\n-    Returns:\n-        Path to the output file if successful, None otherwise\n-    \"\"\"\n-    benchmark_name = benchmark_info[\"name\"]\n-    runner_func = benchmark_info[\"runner_function\"]\n-\n-    logger.info(f\"Running benchmark: {benchmark_name}\")\n-\n-    try:\n-        # Check function signature to determine what arguments to pass\n-        import inspect\n-\n-        sig = inspect.signature(runner_func)\n-\n-        # Prepare arguments based on function signature\n-        func_kwargs = {\"logger\": logger, \"output_dir\": output_dir}\n-\n-        # Add other kwargs if the function accepts them\n-        for param_name in sig.parameters:\n-            if param_name in kwargs:\n-                func_kwargs[param_name] = kwargs[param_name]\n-\n-        # Filter kwargs to only include parameters the function accepts\n-        # If function has **kwargs, include all provided kwargs\n-        has_var_kwargs = any(param.kind == param.VAR_KEYWORD for param in sig.parameters.values())\n-        if has_var_kwargs:\n-            valid_kwargs = {**func_kwargs, **kwargs}\n-        else:\n-            valid_kwargs = {k: v for k, v in func_kwargs.items() if k in sig.parameters}\n-\n-        # Run the benchmark\n-        result = runner_func(**valid_kwargs)\n-\n-        if isinstance(result, str):\n-            # Function returned a file path\n-            return result\n-        else:\n-            logger.info(f\"Benchmark {benchmark_name} completed successfully\")\n-            return \"completed\"\n-\n-    except Exception as e:\n-        logger.error(f\"Benchmark {benchmark_name} failed: {e}\")\n-        import traceback\n-\n-        logger.debug(traceback.format_exc())\n-        return None\n-\n-\n-def generate_summary_report(\n-    output_dir: str,\n-    benchmark_results: dict[str, Any],\n-    logger: logging.Logger,\n-    benchmark_run_uuid: Optional[str] = None,\n-) -> str:\n-    \"\"\"Generate a summary report of all benchmark runs.\"\"\"\n-    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n-    summary_file = os.path.join(output_dir, f\"benchmark_summary_{timestamp}.json\")\n-\n-    summary_data = {\n-        \"run_metadata\": {\n-            \"timestamp\": datetime.utcnow().isoformat(),\n-            \"benchmark_run_uuid\": benchmark_run_uuid,\n-            \"total_benchmarks\": len(benchmark_results),\n-            \"successful_benchmarks\": len([r for r in benchmark_results.values() if r is not None]),\n-            \"failed_benchmarks\": len([r for r in benchmark_results.values() if r is None]),\n-        },\n-        \"benchmark_results\": benchmark_results,\n-        \"output_directory\": output_dir,\n-    }\n-\n-    with open(summary_file, \"w\") as f:\n-        json.dump(summary_data, f, indent=2, default=str)\n-\n-    logger.info(f\"Summary report saved to: {summary_file}\")\n-    return summary_file\n-\n-\n-def upload_results_to_hf_dataset(\n-    output_dir: str,\n-    summary_file: str,\n-    dataset_name: str,\n-    run_id: Optional[str] = None,\n-    token: Optional[str] = None,\n-    logger: Optional[logging.Logger] = None,\n-) -> Optional[str]:\n-    \"\"\"\n-    Upload benchmark results to a HuggingFace Dataset.\n-    Based on upload_collated_report() from utils/collated_reports.py\n-    Args:\n-        output_dir: Local output directory containing results\n-        summary_file: Path to the summary file\n-        dataset_name: Name of the HuggingFace dataset to upload to\n-        run_id: Unique run identifier (if None, will generate one)\n-        token: HuggingFace token for authentication (if None, will use environment variables)\n-        logger: Logger instance\n-    Returns:\n-        The run_id used for the upload, None if upload failed\n-    \"\"\"\n-    if logger is None:\n-        logger = logging.getLogger(__name__)\n-\n-    import os\n-\n-    from huggingface_hub import HfApi\n-\n-    api = HfApi()\n-\n-    if run_id is None:\n-        github_run_number = os.getenv(\"GITHUB_RUN_NUMBER\")\n-        github_run_id = os.getenv(\"GITHUB_RUN_ID\")\n-        if github_run_number and github_run_id:\n-            run_id = f\"{github_run_number}-{github_run_id}\"\n-\n-    date_folder = datetime.now().strftime(\"%Y-%m-%d\")\n-\n-    github_event_name = os.getenv(\"GITHUB_EVENT_NAME\")\n-    if github_event_name != \"schedule\":\n-        # Non-scheduled runs go under a runs subfolder\n-        repo_path = f\"{date_folder}/runs/{run_id}/benchmark_results\"\n-    else:\n-        # Scheduled runs go directly under the date\n-        repo_path = f\"{date_folder}/{run_id}/benchmark_results\"\n-\n-    logger.info(f\"Uploading benchmark results to dataset '{dataset_name}' at path '{repo_path}'\")\n-\n-    try:\n-        # Upload all files in the output directory\n-        from pathlib import Path\n-\n-        output_path = Path(output_dir)\n-\n-        for file_path in output_path.rglob(\"*\"):\n-            if file_path.is_file():\n-                # Calculate relative path from output_dir\n-                relative_path = file_path.relative_to(output_path)\n-                path_in_repo = f\"{repo_path}/{relative_path}\"\n-\n-                logger.debug(f\"Uploading {file_path} to {path_in_repo}\")\n-\n-                api.upload_file(\n-                    path_or_fileobj=str(file_path),\n-                    path_in_repo=path_in_repo,\n-                    repo_id=dataset_name,\n-                    repo_type=\"dataset\",\n-                    token=token,\n-                    commit_message=f\"Upload benchmark results for run {run_id}\",\n-                )\n-\n-        logger.info(\n-            f\"Successfully uploaded results to: https://huggingface.co/datasets/{dataset_name}/tree/main/{repo_path}\"\n-        )\n-\n-        return run_id\n-\n-    except Exception as upload_error:\n-        logger.error(f\"Failed to upload results: {upload_error}\")\n-        import traceback\n-\n-        logger.debug(traceback.format_exc())\n-        return None\n-\n-\n-def main():\n-    \"\"\"Main entry point for the benchmarking script.\"\"\"\n-    # Generate a unique UUID for this benchmark run\n-    benchmark_run_uuid = str(uuid.uuid4())[:8]\n-\n-    parser = argparse.ArgumentParser(\n-        description=\"Run all benchmarks in the ./benches directory\",\n-        epilog=\"\"\"\n-Examples:\n-  # Run all available benchmarks\n-  python3 run_benchmarks.py\n-  \n-  # Run with specific model and upload to HuggingFace Dataset\n-  python3 run_benchmarks.py --model-id meta-llama/Llama-2-7b-hf --upload-to-hf username/benchmark-results\n-  \n-  # Run with custom run ID and upload to HuggingFace Dataset\n-  python3 run_benchmarks.py --run-id experiment_v1 --upload-to-hf org/benchmarks\n-  \n-  # Run only specific benchmarks with file logging\n-  python3 run_benchmarks.py --include llama --enable-file-logging\n-        \"\"\",  # noqa: W293\n-        formatter_class=argparse.RawDescriptionHelpFormatter,\n-    )\n-\n-    parser.add_argument(\n-        \"--output-dir\",\n-        type=str,\n-        default=\"benchmark_results\",\n-        help=\"Base output directory for benchmark results (default: benchmark_results)\",\n-    )\n-\n-    parser.add_argument(\n-        \"--benches-dir\",\n-        type=str,\n-        default=\"./benches\",\n-        help=\"Directory containing benchmark implementations (default: ./benches)\",\n-    )\n-\n-    parser.add_argument(\n-        \"--log-level\",\n-        type=str,\n-        choices=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"],\n-        default=\"INFO\",\n-        help=\"Logging level (default: INFO)\",\n-    )\n \n+if __name__ == \"__main__\":\n+    # Parse arguments\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\"--output-dir\", type=str, default=\"benchmark_results\", help=\"Output dir for benchmark results\")\n+    parser.add_argument(\"--log-level\", type=str, choices=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"], default=\"INFO\")\n     parser.add_argument(\"--model-id\", type=str, help=\"Specific model ID to benchmark (if supported by benchmarks)\")\n \n-    parser.add_argument(\"--warmup-iterations\", type=int, default=3, help=\"Number of warmup iterations (default: 3)\")\n+    parser.add_argument(\"--warmup\", type=int, default=5, help=\"Number of warmup iterations\")\n+    parser.add_argument(\"--iterations\", type=int, default=20, help=\"Number of measurement iterations\")\n \n-    parser.add_argument(\n-        \"--measurement-iterations\", type=int, default=5, help=\"Number of measurement iterations (default: 5)\"\n-    )\n-\n-    parser.add_argument(\n-        \"--num-tokens-to-generate\",\n-        type=int,\n-        default=100,\n-        help=\"Number of tokens to generate in benchmarks (default: 100)\",\n-    )\n+    parser.add_argument(\"--batch-size\", \"-b\", type=int, nargs=\"+\", help=\"Batch size\")\n+    parser.add_argument(\"--sequence-length\", \"-s\", type=int, nargs=\"+\", help=\"Sequence length\")\n+    parser.add_argument(\"--num-tokens-to-generate\", \"-n\", type=int, nargs=\"+\", help=\"Number of tokens to generate\")\n \n-    parser.add_argument(\"--include\", type=str, nargs=\"*\", help=\"Only run benchmarks matching these names\")\n-\n-    parser.add_argument(\"--exclude\", type=str, nargs=\"*\", help=\"Exclude benchmarks matching these names\")\n-\n-    parser.add_argument(\"--enable-file-logging\", action=\"store_true\", help=\"Enable file logging (disabled by default)\")\n-\n-    parser.add_argument(\n-        \"--commit-id\", type=str, help=\"Git commit ID for metadata (if not provided, will auto-detect from git)\"\n-    )\n-\n-    parser.add_argument(\n-        \"--push-to-hub\",\n-        type=str,\n-        help=\"Upload results to HuggingFace Dataset (provide dataset name, e.g., 'username/benchmark-results')\",\n-    )\n-\n-    parser.add_argument(\n-        \"--run-id\", type=str, help=\"Custom run ID for organizing results (if not provided, will generate a unique ID)\"\n-    )\n-\n-    parser.add_argument(\n-        \"--token\",\n-        type=str,\n-        help=\"HuggingFace token for dataset uploads (if not provided, will use HF_TOKEN environment variable)\",\n-    )\n+    parser.add_argument(\"--num-tokens-to-profile\", \"-p\", type=int, default=0, help=\"Number of tokens to profile\")\n \n+    parser.add_argument(\"--commit-id\", type=str, help=\"Git commit ID (if not provided, will auto-detect from git)\")\n     args = parser.parse_args()\n \n     # Setup logging\n-    logger = setup_logging(args.log_level, args.enable_file_logging)\n+    benchmark_run_uuid = str(uuid.uuid4())[:8]\n+    numeric_level = getattr(logging, args.log_level.upper())\n \n+    handlers = [logging.StreamHandler(sys.stdout)]\n+    logging.basicConfig(\n+        level=numeric_level, format=\"[%(levelname)s - %(asctime)s] %(name)s: %(message)s\", handlers=handlers\n+    )\n+\n+    logger = logging.getLogger(\"benchmark_v2\")\n     logger.info(\"Starting benchmark discovery and execution\")\n     logger.info(f\"Benchmark run UUID: {benchmark_run_uuid}\")\n     logger.info(f\"Output directory: {args.output_dir}\")\n-    logger.info(f\"Benches directory: {args.benches_dir}\")\n-\n-    # Create output directory\n-    os.makedirs(args.output_dir, exist_ok=True)\n-\n-    try:\n-        # Discover benchmarks\n-        benchmarks = discover_benchmarks(args.benches_dir)\n-        logger.info(f\"Discovered {len(benchmarks)} benchmark(s): {[b['name'] for b in benchmarks]}\")\n-\n-        if not benchmarks:\n-            logger.warning(\"No benchmarks found!\")\n-            return 1\n-\n-        # Filter benchmarks based on include/exclude\n-        filtered_benchmarks = benchmarks\n-\n-        if args.include:\n-            filtered_benchmarks = [\n-                b for b in filtered_benchmarks if any(pattern in b[\"name\"] for pattern in args.include)\n-            ]\n-            logger.info(f\"Filtered to include: {[b['name'] for b in filtered_benchmarks]}\")\n \n-        if args.exclude:\n-            filtered_benchmarks = [\n-                b for b in filtered_benchmarks if not any(pattern in b[\"name\"] for pattern in args.exclude)\n-            ]\n-            logger.info(f\"After exclusion: {[b['name'] for b in filtered_benchmarks]}\")\n+    # Error out if one of the arguments is not provided\n+    if len(args.batch_size) * len(args.sequence_length) * len(args.num_tokens_to_generate) == 0:\n+        raise ValueError(\n+            \"At least one of the arguments --batch-size, --sequence-length, or --num-tokens-to-generate is required\"\n+        )\n \n-        if not filtered_benchmarks:\n-            logger.warning(\"No benchmarks remaining after filtering!\")\n-            return 1\n+    # If there is only one (batch_size, sequence_length, num_tokens_to_generate), we benchmark across configs\n+    elif len(args.batch_size) * len(args.sequence_length) * len(args.num_tokens_to_generate) == 1:\n+        benchmark_configs = generate_all_configs(\n+            warmup_iterations=args.warmup,\n+            measurement_iterations=args.iterations,\n+            batch_size=args.batch_size[0],\n+            sequence_length=args.sequence_length[0],\n+            num_tokens_to_generate=args.num_tokens_to_generate[0],\n+        )\n+        random.shuffle(benchmark_configs)\n \n-        # Prepare common kwargs for benchmarks\n-        benchmark_kwargs = {\n-            \"warmup_iterations\": args.warmup_iterations,\n-            \"measurement_iterations\": args.measurement_iterations,\n-            \"num_tokens_to_generate\": args.num_tokens_to_generate,\n+    # Otherwise, we benchmark across all combinations of dimensions\n+    else:\n+        kwargs = {\n+            \"warmup_iterations\": args.warmup,\n+            \"measurement_iterations\": args.iterations,\n+            \"gpu_monitoring\": False,\n+            \"batch_size\": args.batch_size[0],\n+            \"sequence_length\": args.sequence_length[0],\n+            \"num_tokens_to_generate\": args.num_tokens_to_generate[0],\n+            \"attn_implementation\": \"flex_attention\",\n+            \"sdpa_backend\": None,\n+            \"compile_mode\": \"default\",\n+            \"kernelize\": False,\n         }\n-\n-        if args.model_id:\n-            benchmark_kwargs[\"model_id\"] = args.model_id\n-\n-        # Add commit_id if provided\n-        if args.commit_id:\n-            benchmark_kwargs[\"commit_id\"] = args.commit_id\n-\n-        # Run benchmarks\n-        benchmark_results = {}\n-        successful_count = 0\n-\n-        for benchmark_info in filtered_benchmarks:\n-            result = run_single_benchmark(benchmark_info, args.output_dir, logger, **benchmark_kwargs)\n-\n-            benchmark_results[benchmark_info[\"name\"]] = result\n-\n-            if result is not None:\n-                successful_count += 1\n-\n-        # Generate summary report\n-        summary_file = generate_summary_report(args.output_dir, benchmark_results, logger, benchmark_run_uuid)\n-\n-        # Upload results to HuggingFace Dataset if requested\n-        upload_run_id = None\n-        if args.push_to_hub:\n-            logger.info(\"=\" * 60)\n-            logger.info(\"UPLOADING TO HUGGINGFACE DATASET\")\n-            logger.info(\"=\" * 60)\n-            # Use provided run_id or fallback to benchmark run UUID\n-            effective_run_id = args.run_id or benchmark_run_uuid\n-            upload_run_id = upload_results_to_hf_dataset(\n-                output_dir=args.output_dir,\n-                summary_file=summary_file,\n-                dataset_name=args.push_to_hub,\n-                run_id=effective_run_id,\n-                token=args.token,\n-                logger=logger,\n-            )\n-            if upload_run_id:\n-                logger.info(f\"Upload completed with run ID: {upload_run_id}\")\n-            else:\n-                logger.warning(\"Upload failed - continuing with local results\")\n-\n-        # Final summary\n-        total_benchmarks = len(filtered_benchmarks)\n-        failed_count = total_benchmarks - successful_count\n-\n-        logger.info(\"=\" * 60)\n-        logger.info(\"BENCHMARK RUN SUMMARY\")\n-        logger.info(\"=\" * 60)\n-        logger.info(f\"Total benchmarks: {total_benchmarks}\")\n-        logger.info(f\"Successful: {successful_count}\")\n-        logger.info(f\"Failed: {failed_count}\")\n-        logger.info(f\"Output directory: {args.output_dir}\")\n-        logger.info(f\"Summary report: {summary_file}\")\n-\n-        if args.push_to_hub:\n-            if upload_run_id:\n-                logger.info(f\"HuggingFace Dataset: {args.push_to_hub}\")\n-                logger.info(f\"Run ID: {upload_run_id}\")\n-                logger.info(\n-                    f\"View results: https://huggingface.co/datasets/{args.push_to_hub}/tree/main/{datetime.now().strftime('%Y-%m-%d')}/runs/{upload_run_id}\"\n-                )\n-            else:\n-                logger.warning(\"Upload to HuggingFace Dataset failed\")\n-\n-        if failed_count > 0:\n-            logger.warning(f\"{failed_count} benchmark(s) failed. Check logs for details.\")\n-            return 1\n-        else:\n-            logger.info(\"All benchmarks completed successfully!\")\n-            return 0\n-\n-    except Exception as e:\n-        logger.error(f\"Benchmark run failed: {e}\")\n-        import traceback\n-\n-        logger.debug(traceback.format_exc())\n-        return 1\n-\n-\n-if __name__ == \"__main__\":\n-    sys.exit(main())\n+        benchmark_configs = []\n+        for num_tokens_to_generate in args.num_tokens_to_generate:\n+            for sequence_length in args.sequence_length:\n+                for batch_size in args.batch_size:\n+                    kwargs[\"batch_size\"] = batch_size\n+                    kwargs[\"sequence_length\"] = sequence_length\n+                    kwargs[\"num_tokens_to_generate\"] = num_tokens_to_generate\n+                    benchmark_configs.append(BenchmarkConfig(**kwargs))\n+\n+    runner = BenchmarkRunner(logger, args.output_dir, args.commit_id)\n+    results = runner.run_benchmarks(\n+        args.model_id,\n+        benchmark_configs[:3],\n+        args.num_tokens_to_profile,\n+        pretty_print_summary=True,\n+    )\n+    # runner.save_results(args.model_id, results)"
        }
    ],
    "stats": {
        "total": 2871,
        "additions": 1007,
        "deletions": 1864
    }
}