{
    "author": "vasqu",
    "message": "[`Ernie 4.5`] Ernie VL models (#39585)\n\n* more attention cleanup\n\n* llama like text attention\n\n* generates different text but cos and sin tensors are always close - 1e-8\n\n* another round of rope fixups\n\n* yea, gonna check tomorrow cant cheat w freqs for whatever reason\n\n* NOTE: last time where comp with old rope\n\n* rope cleanup\n\n* more rope\n\n* somewhat clean 3d rope with attn - sin / cos has very small diffs to original formula (torch.allclose always True) leading to slightly different generations\n\n* new rope type\n\n* style\n\n* attempt at moe, gonna need a deeper look\n\n* cleanup gate\n\n* more cleaning\n\n* NOTE remove attempt at moe for now\n\n* another round of cleanups\n\n* whoops\n\n* we back boys, reattempting moe start\n\n* moe should be done with this\n\n* cleanup\n\n* more cleanup\n\n* nits\n\n* add conversion and adjust code accordingly\n\n* fix\n\n* make moe copyable as far as we can\n\n* cleanup conversion a bit, next config\n\n* cleanup config part1\n\n* small removal of unused things\n\n* config conversion, rope type doesnt get loaded tho...\n\n* fix rope\n\n* last hardcoded values\n\n* remove unnecessary class\n\n* starting to make copies available for vision, vision rope refactor tomorrow\n\n* vl rope changes\n\n* simplify variable resolution resampler\n\n* nit\n\n* conversion update\n\n* more conversions, standardization, and big dtype fix!\n\n* remove some docs (tmp), focus on code for me\n\n* oops\n\n* nit\n\n* fixup embeddings, add todos\n\n* more cleanup\n\n* more cleanup, next caching changes\n\n* revert fp16, internally discussed weights are supposed to be bf16\n\n* fix rope (a bit), prepare cache logic changes\n\n* more prep for cache\n\n* cache class is used, fixup some flags\n\n* modular refactor\n\n* partially docstrings, docs, etc\n\n* cleaner order\n\n* nit\n\n* fix config\n\n* remove old artefacts/todos\n\n* sync with remote and add some todos for orientation\n\n* remove img process dep on modeling code\n\n* image processor with a few diffs highlighted to copy from maybe\n\n* fast img processor version\n\n* modular image processors\n\n* convert tokenizer to have dedicated video placeholder token\n\n* before i forget\n\n* a modular bug :/\n\n* more processor things, some modular adjustments\n\n* remove dependency on token type ids\n\n* position ids ala qwen vl and modular is bugging\n\n* fixup some inheritances + nits\n\n* token type ids\n\n* moe loss, docs, simplify pos ids\n\n* align some feature getters\n\n* docs\n\n* rename conv -> merge aka our naming convention\n\n* style\n\n* fixup tokenizer class in auto\n\n* no more nn sequential\n\n* fix chat template, fix tokenizer conversion, modular bug\n\n* remove this\n\n* remove old deps (from the remote processor)\n\n* whoops\n\n* argh\n\n* todo, restarting progress tomorrow\n\n* fast image processor changes output, keeping slow for now\n\n* NOTE rm debugging code on processor conversion\n\n* first complete conversion script version, todo on whether to use fast processor\n\n* config docs\n\n* image processor tests, only kept to images as videos need different resolutions\n\n* processor tests\n\n* first ish version for video processor, very much WIP tho\n\n* sync with main and all the changes that happened, fix ernie moe bug in dtype casting\n\n* mini style fix\n\n* vid processor is properly separated now\n\n* make vid processor its own thing\n\n* style\n\n* video processing and cleanups, img processing done, processing needs one TODO, vid processing needs tests\n\n* readd vid patch fn\n\n* make 4D RoPE possible if manually passed\n\n* simplify the msg on packing, allow external prep but not internal one\n\n* nit\n\n* revert general changes video utils, make it specific to ernie, fixup tests\n\n* vid to auto\n\n* left to check: pos ids (rope) + token type ids\n\n* move token type ids to processor, fix processor to ernie logic\n\nTODOs: tests, tests, tests\n\n* processor fixes, conversion todo for fast img processor\n\nTODOs: tests for vid processor and modeling\n\n* fix\n\n* video processor tests, torch compile does not work due to PIL drawing being needed\n\n* fix config consistency\n\n* style\n\n* wip tests\n\n* fix most tests, 2 failing ones remain\n\n* fix last tests\n\n* check\n\n* docs consistency\n\n* fix conversion script, more docs\n\n* optional drawing on frames, style\n\n* add error on compile x draw on frames\n\n* fix\n\n* fix\n\n* change font loading to hub dep with default font\n\n* fix config try 2\n\n* fix diff resolution, tests (not fast processor, a100)\n\n* fix test\n\n* style\n\n* torch 2.9 (fa2 untested, video from 2.6)\n\n* raushan's review (part 1)\n\n* Update docs/source/en/model_doc/ernie4_5_vl.md\n\nCo-authored-by: Pablo Montalvo <39954772+molbap@users.noreply.github.com>\n\n* Pablo's review\n\n* style\n\n* fix device/dtype stuff that is no longer needed\n\n* revert vision property rm, necessary for composite sdpa test\n\n* fixup few smaller things + refactor how we load the font entirely (based on font name with expected associated file at same repo)\n\n* remove bc min max pixels --> less modular on processor parts but way cleaner code\n\n* fix fps and add fixme to the inefficient conversion stuff\n\n* rope\n\n* style\n\n* copies and last rope stuff i fogot\n\n* revert glm4v copies\n\n* fix\n\n* simplify temporal slicing and add more descriptions\n\n* that \":\" :cry:\n\n* fixup init\n\n* conversion for moe split and merge + general renamings etc -- encountering OOM (automap maybe?)\n\n* wrong order whoops\n\n* style\n\n* copies\n\n* fix init\n\n* fix\n\n* fix\n\n* allow the resolved path to be passed to explicit video processor classes and refactor how we load them for ernie\n\n* simplify\n\n* shoot, I need it there as well\n\n* better err handling\n\n* style\n\n* initial fixes after merge\n\n* working loading version\n\n* cleanup\n\n* change moe order and fix vl version\n\n* reverse op is mapping incorrectly TODO\n\n* reverse loading somewhat works, name conversion has issues it seems :eyes:\n\n* fix renaming issue, slow tests pass (except the integration ones ~ expected due to fused weights)\n\n* conversion mapping with native features + remove conversion mapping restriction\n\n* add test for new conversion\n\n* style\n\n* update conversion\n\n* fix integration tests, remove fa tests\n\n* fix\n\n* update docs a bit\n\n* style\n\n* fix ernie moe and routing ernie series\n\n* style\n\n* fix rope warning\n\n* i fucked up again pain\n\n* update expectations\n\n* remove EP, broken atm be it sole or in combination with TP\n\n* update docs a bit\n\n* first part of addressing review comments\n\n* fixup\n\n* fix vid processor\n\n* fix font saving\n\n* readd decorators oops\n\n* add mm token type id shortcut\n\n* always compose mm token type ids if needed\n\n* move config to modular\n\n* fix loading by enforcing correct order\n\n* fix\n\n* address first bunch of comments\n\n* smaller comments\n\n* let's make moe layer types, ill fix modular in a second\n\n* modular\n\n* style\n\n* renamed version along a few fixes in conversion and processor tests\n\n* fix\n\n* style + decorator\n\n* fix tokenizer handling of additional special tokens\n\n* style\n\n* fix doc refs\n\n* test fix\n\n* fix\n\n* was this too breaking?\n\n* fix conversion via workaround for now\n\n* post merge fix\n\n* revert a few tok things (additional_special_tokens), updated conversion\n\n* fix video processing loading logic\n\nadd exception for auto class (reload config as we have a circular dep on finding which class we have, i.e. we need to load to find the class then load with specific logic)\n\nremove some original ideas\n\n* style\n\n* processor path change\n\n* add small dummy integration tests\n\n* style\n\n* fix rope modeling to follow qwen2 vl instead + change auto loading to specifically load via pretrained (overridable from pretrained for auto classes)\n\n* seems to be skipped in other similar vlms\n\n* small conversion updates and adjust max vram usage during the big integration test\n\n* update test paths\n\n* style\n\n* style attmpt 2\n\n* docs\n\n* trigger ci\n\n* review\n\n* post merge fixes\n\n* fix\n\n* safety\n\n* fix test\n\n* style\n\n* oops\n\n* fix\n\n* ...\n\n* simplify the config init for moe pattern\n\n* gonna be fixed by #42963\n\n---------\n\nCo-authored-by: Pablo Montalvo <39954772+molbap@users.noreply.github.com>",
    "sha": "a8a22624f5598167eb82a3e0bc4228021e5440f6",
    "files": [
        {
            "sha": "383e7f39c035eb9008c1b94cf02c95f0ffcf4ea2",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -1037,6 +1037,8 @@\n         title: EdgeTamVideo\n       - local: model_doc/emu3\n         title: Emu3\n+      - local: model_doc/ernie4_5_vl_moe\n+        title: ernie4_5_vl_moe\n       - local: model_doc/evolla\n         title: Evolla\n       - local: model_doc/fast_vlm"
        },
        {
            "sha": "c3c7ddb081e5e0b2638b74f7acd5ad76915cd2c8",
            "filename": "docs/source/en/model_doc/ernie4_5.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/docs%2Fsource%2Fen%2Fmodel_doc%2Fernie4_5.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/docs%2Fsource%2Fen%2Fmodel_doc%2Fernie4_5.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fernie4_5.md?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -32,7 +32,7 @@ The Ernie 4.5 model was released in the [Ernie 4.5 Model Family](https://ernie.b\n This family of models contains multiple different architectures and model sizes. This model in specific targets the base text\n model without mixture of experts (moe) with 0.3B parameters in total. It uses the standard [Llama](./llama) at its core.\n \n-Other models from the family can be found at [Ernie 4.5 Moe](./ernie4_5_moe).\n+Other models from the family can be found at [Ernie 4.5 Moe](./ernie4_5_moe) and [Ernie 4.5 VL MoE](./ernie4_5_vl_moe.md).\n \n <div class=\"flex justify-center\">\n     <img src=\"https://ernie.baidu.com/blog/posts/ernie4.5/overview.png\"/>"
        },
        {
            "sha": "635b71ec768f524235a46c8709bdbcf5c62b16ba",
            "filename": "docs/source/en/model_doc/ernie4_5_moe.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/docs%2Fsource%2Fen%2Fmodel_doc%2Fernie4_5_moe.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/docs%2Fsource%2Fen%2Fmodel_doc%2Fernie4_5_moe.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fernie4_5_moe.md?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -34,7 +34,7 @@ model with mixture of experts (moe) - one with 21B total, 3B active parameters a\n It uses the standard [Llama](./llama) at its core combined with a specialized MoE based on [Mixtral](./mixtral) with additional shared\n experts.\n \n-Other models from the family can be found at [Ernie 4.5](./ernie4_5).\n+Other models from the family can be found at [Ernie 4.5](./ernie4_5) and [Ernie 4.5 VL MoE](./ernie4_5_vl_moe.md).\n \n <div class=\"flex justify-center\">\n     <img src=\"https://ernie.baidu.com/blog/posts/ernie4.5/overview.png\"/>"
        },
        {
            "sha": "568c1591458aca8555f3f36335318abb98d3e9b8",
            "filename": "docs/source/en/model_doc/ernie4_5_vl_moe.md",
            "status": "added",
            "additions": 230,
            "deletions": 0,
            "changes": 230,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/docs%2Fsource%2Fen%2Fmodel_doc%2Fernie4_5_vl_moe.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/docs%2Fsource%2Fen%2Fmodel_doc%2Fernie4_5_vl_moe.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fernie4_5_vl_moe.md?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,230 @@\n+<!--Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+*This model was released on 2025-06-30 and added to Hugging Face Transformers on TBD.*\n+\n+<div style=\"float: right;\">\n+    <div class=\"flex flex-wrap space-x-1\">\n+        <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+        <img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+        <img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+        <img alt=\"Tensor parallelism\" src=\"https://img.shields.io/badge/Tensor%20parallelism-06b6d4?style=flat&logoColor=white\">\n+    </div>\n+</div>\n+\n+# Ernie 4.5 VL MoE\n+\n+## Overview\n+\n+The Ernie 4.5 VL MoE model was released in the [Ernie 4.5 Model Family](https://ernie.baidu.com/blog/posts/ernie4.5/) release by baidu.\n+This family of models contains multiple different architectures and model sizes. The Vision-Language series in specific is\n+composed of a novel multimodal heterogeneous structure, sharing paremeters across modalities and dedicating parameters\n+to specific modalities. This becomes especially apparent in the Mixture of Expert (MoE) which is composed of\n+\n+- Dedicated Text Experts\n+- Dedicated Vision Experts\n+- Shared Experts\n+\n+This architecture has the advantage to enhance multimodal understanding without compromising, and even improving, performance on text-related tasks. An more detailed breakdown is given in the [Technical Report](https://ernie.baidu.com/blog/publication/ERNIE_Technical_Report.pdf).\n+\n+<div class=\"flex justify-center\">\n+    <img src=\"https://huggingface.co/datasets/AntonV/doc-images/resolve/main/Ernie4_5_VL_Moe.png\"/>\n+</div>\n+\n+Other models from the family can be found at [Ernie 4.5](./ernie4_5) and at [Ernie 4.5 MoE](./ernie4_5_moe.md).\n+\n+\n+## Usage\n+\n+The example below demonstrates how to generate text based on an image with [`Pipeline`] or the [`AutoModel`] class.\n+\n+<hfoptions id=\"usage\">\n+<hfoption id=\"Pipeline\">\n+\n+```py\n+from transformers import pipeline\n+\n+pipe = pipeline(\n+    task=\"image-text-to-text\",\n+    model=\"baidu/ERNIE-4.5-VL-28B-A3B-PT\",\n+    device_map=\"auto\",\n+    revision=\"refs/pr/10\",\n+)\n+message = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+            {\n+                \"type\": \"image\",\n+                \"url\": \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/pipeline-cat-chonk.jpeg\",\n+            },\n+        ],\n+    }\n+]\n+print(pipe(text=message, max_new_tokens=20, return_full_text=False))\n+```\n+\n+</hfoption>\n+<hfoption id=\"AutoModel\">\n+\n+```py\n+from transformers import AutoModelForImageTextToText, AutoProcessor\n+\n+model = AutoModelForImageTextToText.from_pretrained(\n+    \"baidu/ERNIE-4.5-VL-28B-A3B-PT\",\n+    dtype=\"auto\",\n+    device_map=\"auto\",  # Use tp_plan=\"auto\" instead to enable Tensor Parallelism!\n+    revision=\"refs/pr/10\",\n+)\n+processor = AutoProcessor.from_pretrained(\n+    \"baidu/ERNIE-4.5-VL-28B-A3B-PT\",\n+    # use_fast=False,  # closer to the original implementation for less speed\n+    revision=\"refs/pr/10\",\n+)\n+message = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+            {\n+                \"type\": \"image\",\n+                \"url\": \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/pipeline-cat-chonk.jpeg\",\n+            },\n+        ],\n+    }\n+]\n+\n+inputs = processor.apply_chat_template(\n+    message,\n+    add_generation_prompt=True,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\"\n+).to(model.device)\n+\n+generated_ids = model.generate(**inputs, max_new_tokens=128)\n+generated_ids_trimmed = [\n+    out_ids[len(in_ids) :] for in_ids, out_ids in zip(inputs.input_ids, generated_ids)\n+]\n+output_text = processor.batch_decode(\n+    generated_ids_trimmed, skip_special_tokens=True, clean_up_tokenization_spaces=False\n+)\n+print(output_text)\n+```\n+\n+</hfoption>\n+</hfoptions>\n+\n+Using Ernie 4.5 VL MoE with video input is similar to using it with image input.\n+The model can process video data and generate text based on the content of the video.\n+\n+```python\n+from transformers import AutoModelForImageTextToText, AutoProcessor\n+\n+model = AutoModelForImageTextToText.from_pretrained(\n+    \"baidu/ERNIE-4.5-VL-28B-A3B-PT\",\n+    dtype=\"auto\",\n+    device_map=\"auto\",  # Use tp_plan=\"auto\" instead to enable Tensor Parallelism!\n+    revision=\"refs/pr/10\",\n+)\n+processor = AutoProcessor.from_pretrained(\"baidu/ERNIE-4.5-VL-28B-A3B-PT\", revision=\"refs/pr/10\")\n+message = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"Please describe what you can see during this video.\"},\n+            {\n+                \"type\": \"video\",\n+                \"url\": \"https://huggingface.co/datasets/raushan-testing-hf/videos-test/resolve/main/tiny_video.mp4\",\n+            },\n+        ],\n+    }\n+]\n+\n+inputs = processor.apply_chat_template(\n+    message,\n+    add_generation_prompt=True,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\"\n+).to(model.device)\n+\n+generated_ids = model.generate(**inputs, max_new_tokens=128)\n+generated_ids_trimmed = [\n+    out_ids[len(in_ids) :] for in_ids, out_ids in zip(inputs.input_ids, generated_ids)\n+]\n+output_text = processor.batch_decode(\n+    generated_ids_trimmed, skip_special_tokens=True, clean_up_tokenization_spaces=False\n+)\n+print(output_text)\n+```\n+\n+\n+## Ernie4_5_VL_MoeConfig\n+\n+[[autodoc]] Ernie4_5_VL_MoeConfig\n+\n+## Ernie4_5_VL_MoeTextConfig\n+\n+[[autodoc]] Ernie4_5_VL_MoeTextConfig\n+\n+## Ernie4_5_VL_MoeVisionConfig\n+\n+[[autodoc]] Ernie4_5_VL_MoeVisionConfig\n+\n+## Ernie4_5_VL_MoeImageProcessor\n+\n+[[autodoc]] Ernie4_5_VL_MoeImageProcessor\n+    - preprocess\n+\n+## Ernie4_5_VL_MoeImageProcessorFast\n+\n+[[autodoc]] Ernie4_5_VL_MoeImageProcessorFast\n+    - preprocess\n+\n+## Ernie4_5_VL_MoeVideoProcessor\n+\n+[[autodoc]] Ernie4_5_VL_MoeVideoProcessor\n+    - preprocess\n+\n+## Ernie4_5_VL_MoeProcessor\n+\n+[[autodoc]] Ernie4_5_VL_MoeProcessor\n+\n+## Ernie4_5_VL_MoeTextModel\n+\n+[[autodoc]] Ernie4_5_VL_MoeTextModel\n+    - forward\n+\n+## Ernie4_5_VL_MoeVisionTransformerPretrainedModel\n+\n+[[autodoc]] Ernie4_5_VL_MoeVisionTransformerPretrainedModel\n+    - forward\n+\n+## Ernie4_5_VL_MoeVariableResolutionResamplerModel\n+\n+[[autodoc]] Ernie4_5_VL_MoeVariableResolutionResamplerModel\n+    - forward\n+\n+## Ernie4_5_VL_MoeModel\n+\n+[[autodoc]] Ernie4_5_VL_MoeModel\n+    - forward\n+\n+## Ernie4_5_VL_MoeForConditionalGeneration\n+\n+[[autodoc]] Ernie4_5_VL_MoeForConditionalGeneration\n+    - forward"
        },
        {
            "sha": "3d5d2ef798e628f955e67353495680e7ba21b669",
            "filename": "src/transformers/configuration_utils.py",
            "status": "modified",
            "additions": 10,
            "deletions": 4,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fconfiguration_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fconfiguration_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fconfiguration_utils.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -1266,18 +1266,24 @@ def recursive_diff_dict(dict_a, dict_b, config_obj=None):\n PretrainedConfig = PreTrainedConfig\n \n \n-ALLOWED_LAYER_TYPES = (\n+ALLOWED_ATTENTION_LAYER_TYPES = (\n     \"full_attention\",\n     \"sliding_attention\",\n     \"chunked_attention\",\n     \"linear_attention\",  # used in minimax\n )\n \n+ALLOWED_MLP_LAYER_TYPES = (\n+    \"sparse\",\n+    \"dense\",\n+)\n+\n \n-def layer_type_validation(layer_types: list[str], num_hidden_layers: Optional[int] = None):\n+def layer_type_validation(layer_types: list[str], num_hidden_layers: Optional[int] = None, attention: bool = True):\n     \"\"\"Check that `layer_types` is correctly defined.\"\"\"\n-    if not all(layer_type in ALLOWED_LAYER_TYPES for layer_type in layer_types):\n-        raise ValueError(f\"The `layer_types` entries must be in {ALLOWED_LAYER_TYPES}\")\n+    allowed_layer_types = ALLOWED_ATTENTION_LAYER_TYPES if attention else ALLOWED_MLP_LAYER_TYPES\n+    if not all(layer_type in allowed_layer_types for layer_type in layer_types):\n+        raise ValueError(f\"The `layer_types` entries must be in {allowed_layer_types}\")\n     if num_hidden_layers is not None and num_hidden_layers != len(layer_types):\n         raise ValueError(\n             f\"`num_hidden_layers` ({num_hidden_layers}) must be equal to the number of layer types \""
        },
        {
            "sha": "7eadf603af5ccd371a2a11fe97c7245b6b0bbd93",
            "filename": "src/transformers/conversion_mapping.py",
            "status": "modified",
            "additions": 61,
            "deletions": 1,
            "changes": 62,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fconversion_mapping.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fconversion_mapping.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fconversion_mapping.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -18,7 +18,15 @@\n from copy import deepcopy\n from typing import TYPE_CHECKING\n \n-from .core_model_loading import Concatenate, MergeModulelist, WeightConverter, WeightRenaming\n+from .core_model_loading import (\n+    Chunk,\n+    Concatenate,\n+    ErnieFuseAndSplitTextVisionExperts,\n+    MergeModulelist,\n+    Transpose,\n+    WeightConverter,\n+    WeightRenaming,\n+)\n from .utils import is_torch_available\n \n \n@@ -105,6 +113,57 @@ def _build_checkpoint_conversion_mapping():\n                 operations=[MergeModulelist(dim=0)],\n             ),\n         ],\n+        \"ernie4_5_vl_moe\": [\n+            # vision\n+            WeightRenaming(\"vision_model\", \"vision_tower\"),\n+            # resampler\n+            WeightRenaming(\"spatial_linear.0\", \"spatial_linear.fc1\"),\n+            WeightRenaming(\"spatial_linear.2\", \"spatial_linear.fc2\"),\n+            WeightRenaming(\"spatial_linear.3\", \"spatial_linear.ln\"),\n+            WeightRenaming(\"temporal_linear.0\", \"temporal_linear.fc1\"),\n+            WeightRenaming(\"temporal_linear.2\", \"temporal_linear.fc2\"),\n+            WeightRenaming(\"temporal_linear.3\", \"temporal_linear.ln\"),\n+            # language model\n+            WeightRenaming(r\"(?<!language_model\\.)embed_tokens\", \"language_model.embed_tokens\"),\n+            WeightRenaming(r\"(?<!language_model\\.)layers\", \"language_model.layers\"),\n+            WeightConverter(\n+                source_patterns=\"mlp.gate.weight_1\",\n+                target_patterns=\"mlp.vision_moe.gate.weight\",\n+                operations=[Transpose(dim0=0, dim1=1)],\n+            ),\n+            WeightConverter(\n+                source_patterns=\"mlp.gate.weight\",\n+                target_patterns=\"mlp.text_moe.gate.weight\",\n+                operations=[Transpose(dim0=0, dim1=1)],\n+            ),\n+            WeightConverter(\n+                source_patterns=[\"mlp.moe_statics.e_score_correction_bias\"],\n+                target_patterns=[\n+                    \"mlp.text_moe.gate.moe_statics.e_score_correction_bias\",\n+                    \"mlp.vision_moe.gate.moe_statics.e_score_correction_bias\",\n+                ],\n+                operations=[Chunk(dim=0)],\n+            ),\n+            WeightConverter(\n+                source_patterns=[\"experts.*.down_proj.weight\"],\n+                target_patterns=[\n+                    \"text_moe.experts.down_proj\",\n+                    \"vision_moe.experts.down_proj\",\n+                ],\n+                operations=[ErnieFuseAndSplitTextVisionExperts(stack_dim=0, concat_dim=1)],\n+            ),\n+            WeightConverter(\n+                source_patterns=[\n+                    \"experts.*.gate_proj.weight\",\n+                    \"experts.*.up_proj.weight\",\n+                ],\n+                target_patterns=[\n+                    \"text_moe.experts.gate_up_proj\",\n+                    \"vision_moe.experts.gate_up_proj\",\n+                ],\n+                operations=[ErnieFuseAndSplitTextVisionExperts(stack_dim=0, concat_dim=1)],\n+            ),\n+        ],\n         \"jamba\": [\n             WeightConverter(\n                 source_patterns=[\n@@ -229,6 +288,7 @@ def register_checkpoint_conversion_mapping(\n     \"sam3_tracker\",\n     \"sam3_tracker_video\",\n     \"paddleocrvl\",\n+    \"ernie4_5_vl_moe\",\n ]\n \n "
        },
        {
            "sha": "0adbfb886c5cad2c72e2f21cf8ba54355d33977c",
            "filename": "src/transformers/core_model_loading.py",
            "status": "modified",
            "additions": 179,
            "deletions": 7,
            "changes": 186,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fcore_model_loading.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fcore_model_loading.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fcore_model_loading.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -16,6 +16,7 @@\n \n from __future__ import annotations\n \n+import math\n import os\n import re\n from abc import abstractmethod\n@@ -25,6 +26,7 @@\n from contextlib import contextmanager\n from copy import deepcopy\n from dataclasses import dataclass, field\n+from itertools import chain\n from typing import TYPE_CHECKING, Any, Optional, Union\n \n import torch\n@@ -278,6 +280,166 @@ def convert(\n         return output\n \n \n+class ErnieFuseAndSplitTextVisionExperts(ConversionOps):\n+    r\"\"\"\n+    Special operation that splits a module list over all keys and fuses over the number of original modules.\n+\n+    Example with 2 original modules \"Gate\" and \"Up\" with 2 target keys \"Text\" and \"Vision\":\n+\n+                 ModuleList 1            ModuleList 2\n+                [   Gate    ]            [   Up    ]\n+                |           |            |         |\n+          [Gate_Text] [Gate_Vision] [Up_Text]   [Up_Vision]\n+              \\                  \\  /                /\n+               \\                 \\ /                /\n+                \\               /  \\               /\n+                 \\            /     \\             /\n+                 [GateUp_Text]      [GateUp_Vision]\n+\n+    The splits are equal and are defined by the amount of target keys.\n+    The final fusions are defined by the amount of original module lists.\n+    \"\"\"\n+\n+    def __init__(self, stack_dim: int = 0, concat_dim: int = 1):\n+        self.stack_dim = stack_dim\n+        self.concat_dim = concat_dim\n+\n+    def split_list_into_chunks(self, tensor_list: list[torch.Tensor], chunks: int = 2):\n+        split_size = math.ceil(len(tensor_list) / chunks)  # best effort split size\n+        return [tensor_list[i * split_size : (i + 1) * split_size] for i in range(chunks)]\n+\n+    @torch.no_grad()\n+    def convert(\n+        self,\n+        input_dict: dict[str, list[torch.Tensor]],\n+        source_patterns: list[str],\n+        target_patterns: list[str],\n+        config,\n+        **kwargs,\n+    ) -> dict[str, list[torch.Tensor]]:\n+        valid_keys = input_dict.keys()\n+        split_and_fused = defaultdict(list)\n+        for key in source_patterns:\n+            if key not in valid_keys:\n+                raise ValueError(\n+                    f\"Expected pattern {key} in collected tensors but only found tensors for: {valid_keys}\"\n+                )\n+\n+            tensors = input_dict.get(key, [])\n+            split_tensor_lists = self.split_list_into_chunks(tensors, chunks=len(target_patterns))\n+            stacked_tensors = (torch.stack(tensor_group, dim=self.stack_dim) for tensor_group in split_tensor_lists)\n+            for idx, tensor_group in enumerate(stacked_tensors):\n+                split_and_fused[target_patterns[idx]].append(tensor_group)\n+\n+        for k, v in split_and_fused.items():\n+            split_and_fused[k] = torch.cat(v, dim=self.concat_dim)\n+\n+        return split_and_fused\n+\n+    @property\n+    def reverse_op(self) -> ConversionOps:\n+        return ErnieSplitAndDecoupleTextVisionExperts(stack_dim=self.stack_dim, concat_dim=self.concat_dim)\n+\n+\n+class ErnieSplitAndDecoupleTextVisionExperts(ConversionOps):\n+    r\"\"\"\n+    Special operation that splits a fused module list over all original modules and\n+    then decouples them into a mixed module list each over all keys.\n+\n+    Example with 2 original modules \"Gate\" and \"Up\" with 2 target keys \"Text\" and \"Vision\":\n+\n+                    [GateUp_Text]     [GateUp_Vision]\n+                  /              \\   /             \\\n+                 /                \\ /               \\\n+                /                / \\                 \\\n+               /                /   \\                 \\\n+          [Gate_Text] [Gate_Vision] [Up_Text]   [Up_Vision]\n+                |           |            |         |\n+                [   Gate    ]            [   Up    ]\n+                 ModuleList 1            ModuleList 2\n+\n+    The splits are equal and are defined by the amount of original module lists.\n+    The final decoupled module lists are defined by the amount of keys.\n+    \"\"\"\n+\n+    def __init__(self, stack_dim: int = 0, concat_dim: int = 1):\n+        self.stack_dim = stack_dim\n+        self.concat_dim = concat_dim\n+\n+    @torch.no_grad()\n+    def convert(\n+        self,\n+        input_dict: dict[str, list[torch.Tensor]],\n+        source_patterns: list[str],\n+        target_patterns: list[str],\n+        config,\n+        **kwargs,\n+    ) -> dict[str, list[torch.Tensor]]:\n+        fused_modules = len(target_patterns)\n+        valid_keys = input_dict.keys()\n+        split_tensors = []\n+        for key in source_patterns:\n+            if key not in valid_keys:\n+                raise ValueError(\n+                    f\"Expected pattern {key} in collected tensors but only found tensors for: {valid_keys}\"\n+                )\n+\n+            # Assuming that we get single sized lists here to index with 0\n+            split_tensors.append(input_dict[key][0].chunk(fused_modules, dim=self.concat_dim))\n+\n+        decoupled = {}\n+        for idx, key in enumerate(target_patterns):\n+            tensor_groups = [\n+                list(torch.unbind(tensor_group[idx], dim=self.stack_dim)) for tensor_group in split_tensors\n+            ]\n+            tensor_list = list(chain.from_iterable(tensor_groups))\n+            targets = [key.replace(\"*\", f\"{i}\") for i in range(len(tensor_list))]\n+            decoupled |= dict(zip(targets, tensor_list))\n+\n+        return decoupled\n+\n+    @property\n+    def reverse_op(self) -> ConversionOps:\n+        return ErnieFuseAndSplitTextVisionExperts(stack_dim=self.stack_dim, concat_dim=self.concat_dim)\n+\n+\n+class Transpose(ConversionOps):\n+    \"\"\"\n+    Transposes the given tensor along dim0 and dim1.\n+    \"\"\"\n+\n+    def __init__(self, dim0: int = 0, dim1: int = 1):\n+        self.dim0 = dim0\n+        self.dim1 = dim1\n+\n+    @torch.no_grad()\n+    def convert(\n+        self,\n+        input_dict: dict[str, list[torch.Tensor]],\n+        source_patterns: list[str],\n+        target_patterns: list[str],\n+        config,\n+        **kwargs,\n+    ) -> dict[str, list[torch.Tensor]]:\n+        if len(input_dict) != len(target_patterns):\n+            raise ValueError(\n+                f\"Transpose conversion can only happen on each key ({len(input_dict)}) \"\n+                f\"and should match exact one target ({len(target_patterns)}).\"\n+            )\n+\n+        output: dict[str, list[torch.Tensor]] = {}\n+        for key, target_pattern in zip(input_dict.keys(), target_patterns):\n+            tensor = input_dict.get(key, [])\n+            if len(tensor) != 1:\n+                raise ValueError(f\"Transpose conversion requires exactly one tensor, found {len(tensor)}.\")\n+            output[target_pattern] = torch.transpose(tensor[0], dim0=self.dim0, dim1=self.dim1)\n+        return output\n+\n+    @property\n+    def reverse_op(self) -> ConversionOps:\n+        return Transpose(dim0=self.dim1, dim1=self.dim0)\n+\n+\n @dataclass(slots=True)\n class WeightTransform:\n     source_patterns: Union[str, list[str]] = field(init=True)\n@@ -304,8 +466,9 @@ def __post_init__(self):\n             pattern = pattern.removeprefix(\"^\")\n             # Some mapping contains `$` to notify end of string when matching -> remove it during reverse mapping\n             pattern = pattern.removesuffix(\"$\")\n-            # Remove negative lookahead if any. This is ugly but needed for reverse mapping of Qwen2.5 and Sam3!\n-            pattern = re.sub(r\"\\(\\?!.+\\)\", \"\", pattern)\n+            # Remove negative lookahead/behind if any. This is ugly but needed for reverse mapping of\n+            # Qwen2.5, Sam3, Ernie4.5 VL MoE!\n+            pattern = re.sub(r\"\\(\\?.+\\)\", \"\", pattern)\n             # Allow capturing groups in patterns, i.e. to add/remove a prefix to all keys (e.g. timm_wrapper, sam3)\n             if r\"(.+)\" in pattern:\n                 pattern = pattern.replace(r\"(.+)\", r\"\\1\")\n@@ -340,19 +503,19 @@ def rename_source_key(self, source_key: str) -> tuple[str, str | None]:\n         match_object = self.compiled_sources.search(source_key)\n         if match_object is None:\n             return source_key, None\n+\n         # Find the source that produced the match (it's the first group that matched, as the search stops after first branch match)\n         matching_group_name = next(name for name, val in match_object.groupdict().items() if val is not None)\n         source_pattern_that_matched = self.source_patterns[int(matching_group_name[1:])]\n         # If we matched, we always replace with the first target pattern, in case we have several (one to many transform)\n         replacement = self.target_patterns[0]\n-        # # Allow capturing groups in patterns, i.e. to add a prefix to all keys (e.g. timm_wrapper, sam3)\n+        # Allow capturing groups in patterns, i.e. to add a prefix to all keys (e.g. timm_wrapper, sam3)\n         if r\"\\1\" in replacement:\n             # The index of the internal group we need to replace is the index of the matched named group as it comes\n             # inside that matched named group\n             replaced_group_idx = self.compiled_sources.groupindex[matching_group_name] + 1\n             replacement = replacement.replace(r\"\\1\", match_object.group(replaced_group_idx))\n         renamed_key = source_key.replace(match_object.group(0), replacement)\n-\n         return renamed_key, source_pattern_that_matched\n \n     def reverse_transform(self) -> WeightTransform:\n@@ -439,16 +602,25 @@ def convert(\n         return collected_tensors, conversion_errors\n \n \n+# List of classes that are known to be able to use m:n\n+_INTERNAL_MANY_TO_MANY_CONVERSIONS = (\n+    ErnieFuseAndSplitTextVisionExperts,\n+    ErnieSplitAndDecoupleTextVisionExperts,\n+)\n+\n+\n @dataclass(slots=True)\n class WeightConverter(WeightTransform):\n     operations: list[ConversionOps] = field(default_factory=list, repr=False)\n \n     def __post_init__(self):\n         WeightTransform.__post_init__(self)\n         if bool(len(self.source_patterns) - 1) + bool(len(self.target_patterns) - 1) >= 2:\n-            raise ValueError(\n-                f\"source keys={self.source_patterns}, target_patterns={self.target_patterns} but you can only have one to many, one to one or many to one.\"\n-            )\n+            # We allow many-to-many only if we use an internal operation that can handle it\n+            if not any(isinstance(op, _INTERNAL_MANY_TO_MANY_CONVERSIONS) for op in self.operations):\n+                raise ValueError(\n+                    f\"source keys={self.source_patterns}, target_patterns={self.target_patterns} but you can only have one to many, one to one or many to one.\"\n+                )\n         if not self.operations:\n             raise ValueError(\"WeightConverter requires at least one operation.\")\n "
        },
        {
            "sha": "2b883b44c58c2a781fedd3c46d32a9ea88866b64",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -142,6 +142,7 @@\n         (\"ernie\", \"ErnieConfig\"),\n         (\"ernie4_5\", \"Ernie4_5Config\"),\n         (\"ernie4_5_moe\", \"Ernie4_5_MoeConfig\"),\n+        (\"ernie4_5_vl_moe\", \"Ernie4_5_VL_MoeConfig\"),\n         (\"esm\", \"EsmConfig\"),\n         (\"evolla\", \"EvollaConfig\"),\n         (\"exaone4\", \"Exaone4Config\"),\n@@ -590,6 +591,7 @@\n         (\"ernie\", \"ERNIE\"),\n         (\"ernie4_5\", \"Ernie4_5\"),\n         (\"ernie4_5_moe\", \"Ernie4_5_MoE\"),\n+        (\"ernie4_5_vl_moe\", \"Ernie4_5_VL_MoE\"),\n         (\"esm\", \"ESM\"),\n         (\"evolla\", \"Evolla\"),\n         (\"exaone4\", \"EXAONE-4.0\"),"
        },
        {
            "sha": "9d5b531def2ade7ce4825690230aef86843b4d57",
            "filename": "src/transformers/models/auto/image_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -100,6 +100,7 @@\n             (\"efficientnet\", (\"EfficientNetImageProcessor\", \"EfficientNetImageProcessorFast\")),\n             (\"emu3\", (\"Emu3ImageProcessor\", None)),\n             (\"eomt\", (\"EomtImageProcessor\", \"EomtImageProcessorFast\")),\n+            (\"ernie4_5_vl_moe\", (\"Ernie4_5_VL_MoeImageProcessor\", \"Ernie4_5_VL_MoeImageProcessorFast\")),\n             (\"flava\", (\"FlavaImageProcessor\", \"FlavaImageProcessorFast\")),\n             (\"florence2\", (\"CLIPImageProcessor\", \"CLIPImageProcessorFast\")),\n             (\"focalnet\", (\"BitImageProcessor\", \"BitImageProcessorFast\")),"
        },
        {
            "sha": "711c9553d45b03dcc952be756163d7b49e549bb3",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -145,6 +145,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"ernie\", \"ErnieModel\"),\n         (\"ernie4_5\", \"Ernie4_5Model\"),\n         (\"ernie4_5_moe\", \"Ernie4_5_MoeModel\"),\n+        (\"ernie4_5_vl_moe\", \"Ernie4_5_VL_MoeModel\"),\n         (\"esm\", \"EsmModel\"),\n         (\"evolla\", \"EvollaModel\"),\n         (\"exaone4\", \"Exaone4Model\"),\n@@ -1008,6 +1009,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"deepseek_vl\", \"DeepseekVLForConditionalGeneration\"),\n         (\"deepseek_vl_hybrid\", \"DeepseekVLHybridForConditionalGeneration\"),\n         (\"emu3\", \"Emu3ForConditionalGeneration\"),\n+        (\"ernie4_5_vl_moe\", \"Ernie4_5_VL_MoeForConditionalGeneration\"),\n         (\"evolla\", \"EvollaForProteinText2Text\"),\n         (\"fast_vlm\", \"FastVlmForConditionalGeneration\"),\n         (\"florence2\", \"Florence2ForConditionalGeneration\"),"
        },
        {
            "sha": "c0d88d163b442fb175262d9fc347acd88b782be9",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -68,6 +68,7 @@\n         (\"dia\", \"DiaProcessor\"),\n         (\"edgetam\", \"Sam2Processor\"),\n         (\"emu3\", \"Emu3Processor\"),\n+        (\"ernie4_5_vl_moe\", \"Ernie4_5_VL_MoeProcessor\"),\n         (\"evolla\", \"EvollaProcessor\"),\n         (\"flava\", \"FlavaProcessor\"),\n         (\"florence2\", \"Florence2Processor\"),"
        },
        {
            "sha": "dd91a1c376d024be0bc84908f9230cb725fb8d87",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -128,6 +128,7 @@\n         (\"ernie\", \"BertTokenizer\" if is_tokenizers_available() else None),\n         (\"ernie4_5\", \"LlamaTokenizer\" if is_tokenizers_available() else None),\n         (\"ernie4_5_moe\", \"LlamaTokenizer\" if is_tokenizers_available() else None),\n+        (\"ernie4_5_vl_moe\", \"TokenizersBackend\" if is_tokenizers_available() else None),\n         (\"esm\", \"EsmTokenizer\"),\n         (\"exaone4\", \"GPT2Tokenizer\" if is_tokenizers_available() else None),\n         (\"falcon\", \"TokenizersBackend\" if is_tokenizers_available() else None),"
        },
        {
            "sha": "b7bf976a72fd623abf47386bba92fc1209c1cad1",
            "filename": "src/transformers/models/auto/video_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fauto%2Fvideo_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fauto%2Fvideo_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fvideo_processing_auto.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -53,6 +53,7 @@\n else:\n     VIDEO_PROCESSOR_MAPPING_NAMES = OrderedDict(\n         [\n+            (\"ernie4_5_vl_moe\", \"Ernie4_5_VL_MoeVideoProcessor\"),\n             (\"glm46v\", \"Glm46VVideoProcessor\"),\n             (\"glm4v\", \"Glm4vVideoProcessor\"),\n             (\"instructblip\", \"InstructBlipVideoVideoProcessor\"),"
        },
        {
            "sha": "b589e59fdcc79035d87288c1290bc69cc7ce0451",
            "filename": "src/transformers/models/ernie4_5_vl_moe/__init__.py",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2F__init__.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,31 @@\n+# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_ernie4_5_vl_moe import *\n+    from .image_processing_ernie4_5_vl_moe import *\n+    from .image_processing_ernie4_5_vl_moe_fast import *\n+    from .modeling_ernie4_5_vl_moe import *\n+    from .processing_ernie4_5_vl_moe import *\n+    from .video_processing_ernie4_5_vl_moe import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "e6716c584b8ce450a38861e50496b8bb82250968",
            "filename": "src/transformers/models/ernie4_5_vl_moe/configuration_ernie4_5_vl_moe.py",
            "status": "added",
            "additions": 330,
            "deletions": 0,
            "changes": 330,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fconfiguration_ernie4_5_vl_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fconfiguration_ernie4_5_vl_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fconfiguration_ernie4_5_vl_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,330 @@\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+#           This file was automatically generated from src/transformers/models/ernie4_5_vl_moe/modular_ernie4_5_vl_moe.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_ernie4_5_vl_moe.py file directly. One of our CI enforces this.\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+# coding=utf-8\n+# Copyright 2025 Baidu and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from ...configuration_utils import PreTrainedConfig, layer_type_validation\n+\n+\n+class Ernie4_5_VL_MoeVisionConfig(PreTrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of the [`Ernie4_5_VL_MoeVisionTransformerPretrainedModel`].\n+    It is used to instantiate the vision models portion of the complete Ernie4.5-VL Moe model according to the specified\n+    arguments, defining the model architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        depth (`int`, *optional*, defaults to 32):\n+            Number of layers (depth) in the model.\n+        hidden_size (`int`, *optional*, defaults to 1280):\n+            Dimensionality of the encoder layers and the pooler layer.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"quick_gelu\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler.\n+        intermediate_size (`int`, *optional*, defaults to 5120):\n+            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+        num_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        in_channels (`int`, *optional*, defaults to 3):\n+            The number of input channels.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The size (resolution) of each patch.\n+        spatial_merge_size (`int`, *optional*, defaults to 2):\n+            The size used for merging spatial dimensions.\n+        temporal_merge_size (`int`, *optional*, defaults to 2):\n+            The size used for merge along the temporal dimension.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the rms normalization layers.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+    \"\"\"\n+\n+    model_type = \"ernie4_5_vl_moe_vision\"\n+    base_config_key = \"vision_config\"\n+\n+    base_model_tp_plan = {\n+        \"blocks.*.attn.qkv\": \"colwise\",\n+        \"blocks.*.attn.proj\": \"rowwise\",\n+        \"blocks.*.mlp.fc1\": \"colwise\",\n+        \"blocks.*.mlp.fc2\": \"rowwise\",\n+    }\n+\n+    def __init__(\n+        self,\n+        depth=32,\n+        hidden_size=1280,\n+        hidden_act=\"quick_gelu\",\n+        intermediate_size=4 * 1280,\n+        num_heads=16,\n+        in_channels=3,\n+        patch_size=14,\n+        spatial_merge_size=2,\n+        temporal_merge_size=2,\n+        rms_norm_eps=1e-6,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.depth = depth\n+        self.hidden_size = hidden_size\n+        self.hidden_act = hidden_act\n+        self.num_heads = num_heads\n+        self.in_channels = in_channels\n+        self.patch_size = patch_size\n+        self.spatial_merge_size = spatial_merge_size\n+        self.initializer_range = initializer_range\n+\n+        self.intermediate_size = intermediate_size\n+        self.temporal_merge_size = temporal_merge_size\n+        self.rms_norm_eps = rms_norm_eps\n+\n+\n+class Ernie4_5_VL_MoeTextConfig(PreTrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Ernie4_5_VL_MoeTextModel`]. It is used to instantiate a\n+    the text model portion of the complete Ernie4.5-VL Moe model according to the specified arguments, defining the model architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 103424):\n+            Vocabulary size of the Ernie 4.5 VL model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Ernie4_5_VL_MoeTextModel`]\n+        hidden_size (`int`, *optional*, defaults to 2560):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 12288):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 28):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 20):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 4):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details, check out [this\n+            paper](https://huggingface.co/papers/2305.13245). If it is not specified, will default to `4`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 131072):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        use_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use a bias in any of the projections including mlp and attention for example.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `True`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_parameters (`RopeParameters`, *optional*):\n+            Dictionary containing the configuration parameters for the RoPE embeddings. The dictionaty should contain\n+            a value for `rope_theta` and optionally parameters used for scaling in case you want to use RoPE\n+            with longer `max_position_embeddings`.\n+        mlp_layer_types (`list`, *optional*):\n+            MLP (Moe vs Dense) pattern for each layer.\n+        moe_intermediate_size (`list[int]`, *optional*, defaults to `[1536, 512]`):\n+            Intermediate size of the routed experts; differs between text (first) and image (second) experts.\n+        moe_k (`int`, *optional*, defaults to 6):\n+            Number of selected experts.\n+        moe_num_experts (`int`, *optional*, defaults to 64):\n+            Number of routed experts.\n+        moe_num_shared_experts (`int`, *optional*, defaults to 2):\n+            The number of experts that are shared for all MoE forwards.\n+        moe_norm_min (`float`, *optional*, defaults to 1e-12):\n+            Minimum division value during routing normalization.\n+        output_router_logits (`bool`, *optional*, defaults to `False`):\n+            Whether or not the router logits should be returned by the model. Enabling this will also\n+            allow the model to output the auxiliary loss, including load balancing loss and router z-loss.\n+        router_aux_loss_coef (`float`, *optional*, defaults to 0.001):\n+            The aux loss factor for the total loss.\n+    \"\"\"\n+\n+    model_type = \"ernie4_5_vl_moe_text\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    attribute_map = {\"num_experts\": \"moe_num_experts\", \"num_experts_per_tok\": \"moe_k\"}\n+    default_theta = 500000.0\n+\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.shared_experts.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.shared_experts.up_proj\": \"colwise\",\n+        \"layers.*.mlp.shared_experts.down_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.up_proj\": \"colwise\",\n+        \"layers.*.mlp.down_proj\": \"rowwise\",\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+    base_config_key = \"text_config\"\n+\n+    def __init__(\n+        self,\n+        vocab_size=103424,\n+        hidden_size=2560,\n+        intermediate_size=12288,\n+        num_hidden_layers=28,\n+        num_attention_heads=20,\n+        num_key_value_heads=4,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=131072,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-5,\n+        use_cache=True,\n+        use_bias=False,\n+        tie_word_embeddings=True,\n+        rope_parameters=None,\n+        mlp_layer_types=None,\n+        moe_intermediate_size=None,\n+        moe_k=6,\n+        moe_num_experts=64,\n+        moe_num_shared_experts=2,\n+        moe_norm_min=1e-12,\n+        output_router_logits=False,\n+        router_aux_loss_coef=0.001,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.max_position_embeddings = max_position_embeddings\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.use_bias = use_bias\n+        self.rope_parameters = rope_parameters\n+\n+        # Default to MoE from the second layer and on\n+        self.mlp_layer_types = mlp_layer_types\n+        if self.mlp_layer_types is None:\n+            self.mlp_layer_types = [\"dense\"] + [\"sparse\"] * (self.num_hidden_layers - 1)\n+        layer_type_validation(self.mlp_layer_types, self.num_hidden_layers, attention=False)\n+\n+        self.moe_intermediate_size = moe_intermediate_size\n+        if self.moe_intermediate_size is None:\n+            self.moe_intermediate_size = [1536, 512]\n+        self.moe_k = moe_k\n+        self.moe_num_experts = moe_num_experts\n+        self.moe_num_shared_experts = moe_num_shared_experts\n+        self.moe_norm_min = moe_norm_min\n+        self.output_router_logits = output_router_logits\n+        self.router_aux_loss_coef = router_aux_loss_coef\n+\n+        super().__init__(\n+            tie_word_embeddings=tie_word_embeddings, ignore_keys_at_rope_validation={\"mrope_section\"}, **kwargs\n+        )\n+\n+\n+class Ernie4_5_VL_MoeConfig(PreTrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Ernie4_5_VL_MoeModel`]. It is used to instantiate a\n+    Ernie4.5-VL MoE model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of\n+    Ernie 4.5 VL 28B A3B [baidu/ERNIE-4.5-VL-28B-A3B-PT](https://huggingface.co/baidu/ERNIE-4.5-VL-28B-A3B-PT).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        text_config (`Union[PreTrainedConfig, dict]`, *optional*, defaults to `Ernie4_5_VL_MoeTextConfig`):\n+            The config object or dictionary of the text backbone.\n+        vision_config (`Union[PreTrainedConfig, dict]`,  *optional*, defaults to `Ernie4_5_VL_MoeVisionConfig`):\n+            The config object or dictionary of the vision backbone.\n+        image_start_token_id (`int`, *optional*, defaults to 101304):\n+            The image token index to encode the start of image.\n+        image_end_token_id (`int`, *optional*, defaults to 101305):\n+            The image token index to encode the end of image.\n+        image_token_id (`int`, *optional*, defaults to 100295):\n+            The image token index to encode the image prompt.\n+        video_start_token_id (`int`, *optional*, defaults to 101306):\n+            The video token index to encode the start of video.\n+        video_end_token_id (`int`, *optional*, defaults to 101307):\n+            The video token index to encode the end of video.\n+        video_token_id (`int`, *optional*, defaults to 103367):\n+            The video token index to encode the video prompt.\n+\n+    ```python\n+    >>> from transformers import Ernie4_5_VL_MoeForConditionalGeneration, Ernie4_5_VL_MoeConfig\n+\n+    >>> # Initializing a Ernie4_5_VL_Moe style configuration\n+    >>> configuration = Ernie4_5_VL_MoeConfig()\n+\n+    >>> # Initializing a model from the Ernie 4.5 VL 28B A3B configuration\n+    >>> model = Ernie4_5_VL_MoeForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"ernie4_5_vl_moe\"\n+    sub_configs = {\"vision_config\": Ernie4_5_VL_MoeVisionConfig, \"text_config\": Ernie4_5_VL_MoeTextConfig}\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        text_config=None,\n+        vision_config=None,\n+        image_start_token_id=101304,\n+        image_end_token_id=101305,\n+        image_token_id=100295,\n+        video_start_token_id=101306,\n+        video_end_token_id=101307,\n+        video_token_id=103367,\n+        **kwargs,\n+    ):\n+        if isinstance(vision_config, dict):\n+            self.vision_config = self.sub_configs[\"vision_config\"](**vision_config)\n+        elif isinstance(vision_config, Ernie4_5_VL_MoeVisionConfig):\n+            self.vision_config = vision_config\n+        elif vision_config is None:\n+            self.vision_config = self.sub_configs[\"vision_config\"]()\n+\n+        if isinstance(text_config, dict):\n+            self.text_config = self.sub_configs[\"text_config\"](**text_config)\n+        elif isinstance(text_config, Ernie4_5_VL_MoeTextConfig):\n+            self.text_config = text_config\n+        elif text_config is None:\n+            self.text_config = self.sub_configs[\"text_config\"](**kwargs)\n+\n+        self.image_start_token_id = image_start_token_id\n+        self.image_end_token_id = image_end_token_id\n+        self.image_token_id = image_token_id\n+        self.video_start_token_id = video_start_token_id\n+        self.video_end_token_id = video_end_token_id\n+        self.video_token_id = video_token_id\n+\n+        super().__init__(**kwargs)\n+\n+\n+__all__ = [\"Ernie4_5_VL_MoeConfig\", \"Ernie4_5_VL_MoeTextConfig\", \"Ernie4_5_VL_MoeVisionConfig\"]"
        },
        {
            "sha": "edfb431fad8e7bdd9ff31cd0c0a6e94b6037ee46",
            "filename": "src/transformers/models/ernie4_5_vl_moe/convert_ernie4_5_vl_moe_to_hf.py",
            "status": "added",
            "additions": 349,
            "deletions": 0,
            "changes": 349,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fconvert_ernie4_5_vl_moe_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fconvert_ernie4_5_vl_moe_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fconvert_ernie4_5_vl_moe_to_hf.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,349 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Converts Ernie 4.5 VL config and processor to Hugging Face format.\"\"\"\n+\n+import argparse\n+import json\n+import os\n+from pathlib import Path\n+from shutil import copyfile\n+\n+from huggingface_hub import hf_hub_download, snapshot_download\n+from tokenizers import AddedToken\n+\n+from transformers import (\n+    AutoTokenizer,\n+    Ernie4_5_VL_MoeConfig,\n+    Ernie4_5_VL_MoeImageProcessorFast,\n+    Ernie4_5_VL_MoeProcessor,\n+    Ernie4_5_VL_MoeVideoProcessor,\n+    LlamaTokenizer,\n+)\n+\n+\n+CONFIG_NAME = \"config.json\"\n+VALID_VISION_CONFIG_KEYS = [\n+    \"depth\",\n+    \"hidden_size\",\n+    \"hidden_act\",\n+    \"num_heads\",\n+    \"in_channels\",\n+    \"patch_size\",\n+    \"spatial_merge_size\",\n+]\n+VALID_TEXT_CONFIG_KEYS = [\n+    \"hidden_size\",\n+    \"intermediate_size\",\n+    \"max_position_embeddings\",\n+    \"moe_intermediate_size\",\n+    \"moe_k\",\n+    \"moe_layer_interval\",\n+    \"moe_num_shared_experts\",\n+    \"num_attention_heads\",\n+    \"num_hidden_layers\",\n+    \"num_key_value_heads\",\n+    \"rms_norm_eps\",\n+    \"rope_theta\",\n+    \"vocab_size\",\n+    \"tie_word_embeddings\",\n+    \"use_cache\",\n+    \"use_bias\",\n+]\n+TEXT_TO_VISION_CONFIG_KEYS = [\n+    \"spatial_conv_size\",\n+    \"temporal_conv_size\",\n+]\n+ALL_VISION_CONFIG_KEYS = VALID_VISION_CONFIG_KEYS + TEXT_TO_VISION_CONFIG_KEYS + [\"intermediate_size\"]\n+ALL_TEXT_CONFIG_KEYS = VALID_TEXT_CONFIG_KEYS + [\n+    \"hidden_act\",\n+    \"mlp_layer_types\",\n+    \"moe_num_experts\",\n+    \"rope_parameters\",\n+]\n+\n+TMP_TOKENIZER_DIR = \"/tmp/ernie_vl_tokenizer\"\n+TOKENIZER_CONFIG_FILE = \"tokenizer_config.json\"\n+DEFAULT_CHAT_TEMPLATE = \"\"\"\n+{%- set image_count = namespace(value=0) -%}\n+{%- set video_count = namespace(value=0) -%}\n+{{- '<|begin_of_sentence|>' }}\n+{%- for message in messages -%}\n+    {%- if message.role in ['system', 'user'] -%}\n+        {%- if message.role == 'user' -%}\n+            {{- 'User: ' -}}\n+        {%- endif -%}\n+        {%- if message.content is string -%}\n+            {{- message.content -}}\n+        {%- else -%}\n+            {%- for content_item in message.content -%}\n+                {%- if content_item.type == 'text' -%}\n+                    {{- content_item.text -}}\n+                {%- elif content_item.type in ['image_url', 'image'] -%}\n+                    {%- set image_count.value = image_count.value + 1 -%}\n+                    Picture {{ image_count.value }}:<|IMAGE_START|><|IMAGE_PLACEHOLDER|><|IMAGE_END|>\n+                {%- elif content_item.type in ['video_url', 'video'] -%}\n+                    {%- set video_count.value = video_count.value + 1 -%}\n+                    Video {{ video_count.value }}:<|VIDEO_START|><|VIDEO_PLACEHOLDER|><|VIDEO_END|>\n+                {%- endif -%}\n+            {%- endfor -%}\n+        {%- endif -%}\n+        {%- if message.role == 'system' -%}\n+            {{- '\n+            ' -}}\n+        {%- endif -%}\n+    {%- elif message.role == 'assistant' -%}\n+        {%- macro extract_text_content(content_field) -%}\n+            {%- if content_field is string -%}\n+                {{- content_field -}}\n+            {%- elif content_field is iterable and content_field is not string -%}\n+                {%- set ns = namespace(text_parts=[]) -%}\n+                {%- set text_parts = [] -%}\n+                {%- for item in content_field -%}\n+                    {%- if item.type == 'text' -%}\n+                        {%- set ns.text_parts = ns.text_parts + [item.text] -%}\n+                    {%- endif -%}\n+                {%- endfor -%}\n+                {{- ns.text_parts | join(\"\") -}}\n+            {%- else -%}\n+                {{- '' -}}\n+            {%- endif -%}\n+        {%- endmacro -%}\n+        {%- set reasoning_content = extract_text_content(message.reasoning_content) -%}\n+        {%- set content = extract_text_content(message.content) -%}\n+        {%- if '</think>' in content %}\n+            {%- set reasoning_content = content.split('</think>')[0].rstrip('\n+                        ').split('<think>')[-1].lstrip('\n+                        ') %}\n+            {%- set content = content.split('</think>')[-1].lstrip('\n+                        ') %}\n+        {%- endif %}\n+        {%- if reasoning_content %}\n+            {{- '\n+            ' + 'Assistant: ' + '<think>\n+            ' + reasoning_content.strip('\n+                        ') + '\n+            </think>\n+            ' + content.lstrip('\n+            ') }}\n+        {%- else %}\n+            {{- '\n+            ' + 'Assistant: ' + content }}\n+        {%- endif %}\n+        {{- '<|end_of_sentence |>' }}\n+    {%- endif -%}\n+{%- endfor -%}\n+{%- if add_generation_prompt is not defined or add_generation_prompt is true %}\n+    {{- '\\nAssistant: ' -}}\n+    {%- if (enable_thinking is defined and enable_thinking is false) or enable_thinking is not defined %}\n+        {{- '<think>\\n\\n</think>\\n\\n' }}\n+    {%- endif %}\n+    {%- if enable_thinking is defined and enable_thinking is true %}{{- '<think>' }}{%- endif %}\n+{%- endif %}\"\"\"\n+FONT_REPO = \"AntonV/ernie4_5_fonts\"\n+FONT_NAME = \"Roboto-Regular.ttf\"\n+\n+\n+def load_json(save_dir, filename):\n+    with open(os.path.join(save_dir, filename), \"r\") as f:\n+        return json.load(f)\n+\n+\n+def write_json(json_object, save_dir, filename):\n+    with open(os.path.join(save_dir, filename), \"w\") as f:\n+        json.dump(json_object, f, indent=2, sort_keys=True, ensure_ascii=False)\n+\n+\n+def convert_vision_config_to_hf(vision_config, original_config, original_vision_config):\n+    # convert vision related stuff\n+    for key in VALID_VISION_CONFIG_KEYS:\n+        vision_config[key] = original_vision_config[key]\n+    vision_config[\"intermediate_size\"] = original_vision_config[\"hidden_size\"] * original_vision_config[\"mlp_ratio\"]\n+\n+    # convert originally text attributes to vision\n+    for key in TEXT_TO_VISION_CONFIG_KEYS:\n+        vision_config[key.replace(\"conv\", \"merge\")] = original_config[key]\n+    vision_config[\"rms_norm_eps\"] = 1e-6\n+\n+    # delete everything else\n+    for key in list(vision_config.keys()):\n+        if key not in ALL_VISION_CONFIG_KEYS:\n+            del vision_config[key]\n+\n+    return vision_config\n+\n+\n+def convert_text_config_to_hf(text_config, original_config):\n+    # carry directly over\n+    for key in VALID_TEXT_CONFIG_KEYS:\n+        text_config[key] = original_config.get(key)\n+\n+    # special cases\n+    text_config[\"hidden_act\"] = \"silu\"  # default value which is not explicit in their json\n+    text_config[\"use_cache\"] = True  # not always included but we should default to `True`\n+    text_config[\"moe_num_experts\"] = original_config[\"moe_num_experts\"][0]  # the same for both modalities\n+    text_config[\"rope_parameters\"] = {\n+        \"rope_type\": \"default\",\n+        \"rope_theta\": 500_000.0,\n+        \"mrope_section\": [22, 22, 20],\n+    }\n+    if text_config[\"moe_num_shared_experts\"] is None:\n+        text_config[\"moe_num_shared_experts\"] = 0\n+\n+    # ernie logic to construct mlp/moe layers\n+    text_config[\"mlp_layer_types\"] = []\n+    for layer_idx in range(text_config[\"num_hidden_layers\"]):\n+        if (\n+            ((layer_idx + 1) % text_config[\"moe_layer_interval\"] == 0)\n+            and layer_idx >= min(original_config[\"moe_layer_start_index\"])\n+            and layer_idx <= max(original_config[\"moe_layer_end_index\"])\n+        ):\n+            text_config[\"mlp_layer_types\"].append(\"sparse\")\n+        else:\n+            text_config[\"mlp_layer_types\"].append(\"dense\")\n+    text_config.pop(\"moe_layer_interval\", None)\n+\n+    # delete everything else\n+    for key in list(text_config.keys()):\n+        if key not in ALL_TEXT_CONFIG_KEYS:\n+            del text_config[key]\n+\n+    return text_config\n+\n+\n+def convert_config(model_path, save_dir):\n+    checkpoint_path = snapshot_download(repo_id=model_path, allow_patterns=[\"*config*\"])\n+    for filename in sorted(os.listdir(checkpoint_path)):\n+        if filename == CONFIG_NAME:\n+            hf_config = Ernie4_5_VL_MoeConfig()\n+            original_config = load_json(checkpoint_path, filename)\n+\n+            # general config\n+            image_token_id = original_config[\"im_patch_id\"]\n+\n+            # vision config\n+            vision_config = hf_config.vision_config.to_dict()\n+            original_vision_config = original_config[\"vision_config\"]\n+            vision_config = convert_vision_config_to_hf(vision_config, original_config, original_vision_config)\n+\n+            # text config\n+            text_config = hf_config.text_config.to_dict()\n+            text_config = convert_text_config_to_hf(text_config, original_config)\n+\n+            # total config\n+            final_config = Ernie4_5_VL_MoeConfig(\n+                text_config=text_config,\n+                vision_config=vision_config,\n+                image_token_id=image_token_id,\n+            )\n+\n+            final_config.save_pretrained(save_dir)\n+            break\n+    print(\"Converted model config\\n\")\n+\n+\n+def convert_tokenizer(original_tokenizer_path, save_dir):\n+    # Load in legacy mode\n+    hf_tok = LlamaTokenizer.from_pretrained(\n+        original_tokenizer_path,\n+        pad_token=\"<unk>\",\n+        cls_token=\"<|begin_of_sentence|>\",\n+        sep_token=\"<|end_of_sentence|>\",\n+        mask_token=\"<mask:1>\",\n+        add_bos_token=False,\n+        add_prefix_space=False,\n+        chat_template=DEFAULT_CHAT_TEMPLATE,\n+    )\n+    hf_tok.model_max_length = 131072\n+    hf_tok.init_kwargs.pop(\"auto_map\", None)  # remote specific\n+    # SPM special added but we want to treat them as non-special\n+    hf_tok.add_tokens([AddedToken(f\"{i}\", normalized=False, special=False) for i in range(10)])\n+    hf_tok.save_pretrained(TMP_TOKENIZER_DIR)\n+\n+    # Manipulate special tokens and add video token\n+    tokenizer_config = load_json(TMP_TOKENIZER_DIR, TOKENIZER_CONFIG_FILE)\n+    # Doubled usage of extra and inherint special tokens\n+    tokenizer_config[\"extra_special_tokens\"].remove(\"<s>\")\n+    tokenizer_config[\"extra_special_tokens\"].remove(\"</s>\")\n+    # SPM special added but we want to treat them as non-special\n+    for i in range(10):\n+        tokenizer_config[\"extra_special_tokens\"].remove(f\"{i}\")\n+    # Removed from list, re-add\n+    tokenizer_config[\"extra_special_tokens\"].append(\"<|IMAGE_PLACEHOLDER|>\")\n+    tokenizer_config[\"extra_special_tokens\"].append(\"<|IMAGE_START|>\")\n+    tokenizer_config[\"extra_special_tokens\"].append(\"<|IMAGE_END|>\")\n+    tokenizer_config[\"extra_special_tokens\"].append(\"<|VIDEO_PLACEHOLDER|>\")\n+    tokenizer_config[\"extra_special_tokens\"].append(\"<|VIDEO_START|>\")\n+    tokenizer_config[\"extra_special_tokens\"].append(\"<|VIDEO_END|>\")\n+    tokenizer_config[\"extra_special_tokens\"].append(\"<think>\")\n+    tokenizer_config[\"extra_special_tokens\"].append(\"</think>\")\n+    # To be called via `.xxx_token`\n+    tokenizer_config |= {\n+        \"image_token\": \"<|IMAGE_PLACEHOLDER|>\",\n+        \"image_end_token\": \"<|IMAGE_END|>\",\n+        \"image_start_token\": \"<|IMAGE_START|>\",\n+        \"video_token\": \"<|VIDEO_PLACEHOLDER|>\",\n+        \"video_end_token\": \"<|VIDEO_END|>\",\n+        \"video_start_token\": \"<|VIDEO_START|>\",\n+    }\n+    write_json(tokenizer_config, TMP_TOKENIZER_DIR, TOKENIZER_CONFIG_FILE)\n+\n+    # Reload and save to get correct formatting\n+    tokenizer = AutoTokenizer.from_pretrained(TMP_TOKENIZER_DIR)\n+    tokenizer.save_pretrained(save_dir)\n+\n+\n+def convert_processor(model_path, save_dir):\n+    print(\"Starting to convert processor\")\n+\n+    convert_tokenizer(model_path, save_dir)\n+    tokenizer = AutoTokenizer.from_pretrained(save_dir)\n+\n+    # font used within the video processor\n+    copyfile(hf_hub_download(FONT_REPO, FONT_NAME), Path(save_dir, FONT_NAME))\n+\n+    processor = Ernie4_5_VL_MoeProcessor(\n+        image_processor=Ernie4_5_VL_MoeImageProcessorFast(),\n+        tokenizer=tokenizer,\n+        video_processor=Ernie4_5_VL_MoeVideoProcessor(font=str(Path(save_dir, FONT_NAME))),\n+        chat_template=tokenizer.chat_template,\n+    )\n+    processor.save_pretrained(save_dir)\n+\n+    print(\"Finished converting the processor\\n\")\n+\n+\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser()\n+    # Required parameters\n+    parser.add_argument(\n+        \"--checkpoint_path\",\n+        type=str,\n+        default=\"baidu/ERNIE-4.5-VL-28B-A3B-PT\",\n+        help=\"Path to the downloaded checkpoint\",\n+    )\n+    parser.add_argument(\"--output_folder\", default=\"AntonV/ErnieVL\", type=str, help=\"Path to your output directory.\")\n+    parser.add_argument(\n+        \"--convert_preprocessor\",\n+        type=bool,\n+        default=True,\n+        help=\"Whether or not the preprocessor (tokenizer + image/video processors) should be converted along with the model.\",\n+    )\n+    args = parser.parse_args()\n+\n+    convert_config(args.checkpoint_path, args.output_folder)\n+    if args.convert_preprocessor:\n+        convert_processor(args.checkpoint_path, args.output_folder)\n+\n+    print(f\"Saved converted checkpoint to {args.output_folder}\")"
        },
        {
            "sha": "048c0f3dea239adb5a179d73174ce8cf2e404a87",
            "filename": "src/transformers/models/ernie4_5_vl_moe/image_processing_ernie4_5_vl_moe.py",
            "status": "added",
            "additions": 456,
            "deletions": 0,
            "changes": 456,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fimage_processing_ernie4_5_vl_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fimage_processing_ernie4_5_vl_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fimage_processing_ernie4_5_vl_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,456 @@\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+#           This file was automatically generated from src/transformers/models/ernie4_5_vl_moe/modular_ernie4_5_vl_moe.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_ernie4_5_vl_moe.py file directly. One of our CI enforces this.\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+# coding=utf-8\n+# Copyright 2025 Baidu and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import math\n+from typing import Optional, Union\n+\n+import numpy as np\n+\n+from ...image_processing_utils import BaseImageProcessor, BatchFeature\n+from ...image_transforms import convert_to_rgb, resize, to_channel_dimension_format\n+from ...image_utils import (\n+    OPENAI_CLIP_MEAN,\n+    OPENAI_CLIP_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    is_scaled_image,\n+    make_flat_list_of_images,\n+    make_list_of_images,\n+    to_numpy_array,\n+    valid_images,\n+    validate_preprocess_arguments,\n+)\n+from ...processing_utils import ImagesKwargs\n+from ...utils import TensorType, logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Ernie4_5_VL_MoeImageProcessorKwargs(ImagesKwargs, total=False):\n+    r\"\"\"\n+    patch_size (`int`, *optional*, defaults to 14):\n+        The spatial patch size of the vision encoder.\n+    temporal_patch_size (`int`, *optional*):\n+        The temporal patch size of the vision encoder. Unused in the image processor, only used for videos.\n+    merge_size (`int`, *optional*, defaults to 2):\n+        The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    patch_size: int\n+    temporal_patch_size: int\n+    merge_size: int\n+\n+\n+def smart_resize(\n+    height: int, width: int, factor: int = 28, min_pixels: int = 56 * 56, max_pixels: int = 14 * 14 * 4 * 1280\n+):\n+    \"\"\"Rescales the image so that the following conditions are met:\n+\n+    1. Both dimensions (height and width) are divisible by 'factor'.\n+\n+    2. The total number of pixels is within the range ['min_pixels', 'max_pixels'].\n+\n+    3. The aspect ratio of the image is maintained as closely as possible.\n+\n+    \"\"\"\n+    if max(height, width) / min(height, width) > 200:\n+        raise ValueError(\n+            f\"absolute aspect ratio must be smaller than 200, got {max(height, width) / min(height, width)}\"\n+        )\n+    h_bar = round(height / factor) * factor\n+    w_bar = round(width / factor) * factor\n+    if h_bar * w_bar > max_pixels:\n+        beta = math.sqrt((height * width) / max_pixels)\n+        h_bar = max(factor, math.floor(height / beta / factor) * factor)\n+        w_bar = max(factor, math.floor(width / beta / factor) * factor)\n+    elif h_bar * w_bar < min_pixels:\n+        beta = math.sqrt(min_pixels / (height * width))\n+        h_bar = math.ceil(height * beta / factor) * factor\n+        w_bar = math.ceil(width * beta / factor) * factor\n+    return h_bar, w_bar\n+\n+\n+class Ernie4_5_VL_MoeImageProcessor(BaseImageProcessor):\n+    r\"\"\"\n+    Constructs a Ernie 4.5 VL image processor that dynamically resizes images based on the original images.\n+\n+    Args:\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image's (height, width) dimensions.\n+        size (`dict[str, int]`, *optional*, defaults to `{\"shortest_edge\": 56 * 56, \"longest_edge\": 28 * 28 * 6177}`):\n+            Size of the image after resizing. `shortest_edge` and `longest_edge` keys must be present.\n+        resample (`PILImageResampling`, *optional*, defaults to `Resampling.BICUBIC`):\n+            Resampling filter to use when resizing the image.\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image by the specified scale `rescale_factor`.\n+        rescale_factor (`int` or `float`, *optional*, defaults to `1/255`):\n+            Scale factor to use if rescaling the image.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image.\n+        image_mean (`float` or `list[float]`, *optional*, defaults to `[0.48145466, 0.4578275, 0.40821073]`):\n+            Mean to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        image_std (`float` or `list[float]`, *optional*, defaults to `[0.26862954, 0.26130258, 0.27577711]`):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats for each channel\n+            in the image.\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spatial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*):\n+            The temporal patch size of the vision encoder. Unused in the image processor, only used for videos.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    model_input_names = [\"pixel_values\", \"image_grid_thw\"]\n+    valid_kwargs = Ernie4_5_VL_MoeImageProcessorKwargs\n+\n+    def __init__(\n+        self,\n+        do_resize: bool = True,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = PILImageResampling.BICUBIC,\n+        do_rescale: bool = True,\n+        rescale_factor: Union[int, float] = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        do_convert_rgb: bool = True,\n+        patch_size: int = 14,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: int = 2,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        if size is not None:\n+            if \"shortest_edge\" not in size or \"longest_edge\" not in size:\n+                raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+            size = {\"shortest_edge\": size[\"shortest_edge\"], \"longest_edge\": size[\"longest_edge\"]}\n+        else:\n+            size = {\"shortest_edge\": 56 * 56, \"longest_edge\": 6177 * 28 * 28}\n+        self.size = size\n+\n+        self.do_resize = do_resize\n+        self.resample = resample\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean if image_mean is not None else OPENAI_CLIP_MEAN\n+        self.image_std = image_std if image_std is not None else OPENAI_CLIP_STD\n+\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.merge_size = merge_size\n+        self.do_convert_rgb = do_convert_rgb\n+\n+    def _preprocess(\n+        self,\n+        images: ImageInput,\n+        do_resize: Optional[bool] = None,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = None,\n+        do_rescale: Optional[bool] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        do_convert_rgb: Optional[bool] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n+\n+        Args:\n+            images (`ImageInput`):\n+                Image or batch of images to preprocess. Expects pixel values ranging from 0 to 255. If pixel values range from 0 to 1, set `do_rescale=False`.\n+            vision_info (`list[Dict]`, *optional*):\n+                Optional list of dictionaries containing additional information about vision inputs.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. `shortest_edge` and `longest_edge` keys must be present.\n+            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the `PILImageResampling` enums.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Scale factor to use if rescaling the image.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `list[float]`, *optional*, defaults to `self.image_mean`):\n+                Mean to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            image_std (`float` or `list[float]`, *optional*, defaults to `self.image_std`):\n+                Standard deviation to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            patch_size (`int`, *optional*, defaults to `self.patch_size`):\n+                The spatial patch size of the vision encoder.\n+            temporal_patch_size (`int`, *optional*):\n+                The temporal patch size of the vision encoder. Unused in the image processor, only used for videos.\n+            merge_size (`int`, *optional*, defaults to `self.merge_size`):\n+                The merge size of the vision encoder to llm encoder.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            data_format (`ChannelDimension`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.   - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+        images = make_list_of_images(images)\n+\n+        if do_convert_rgb:\n+            images = [convert_to_rgb(image) for image in images]\n+\n+        # All transformations expect numpy arrays.\n+        images = [to_numpy_array(image) for image in images]\n+\n+        if do_rescale and is_scaled_image(images[0]):\n+            logger.warning_once(\n+                \"It looks like you are trying to rescale already rescaled images. If the input\"\n+                \" images have pixel values between 0 and 1, set `do_rescale=False` to avoid rescaling them again.\"\n+            )\n+        if input_data_format is None:\n+            # We assume that all images have the same channel dimension format.\n+            input_data_format = infer_channel_dimension_format(images[0])\n+\n+        height, width = get_image_size(images[0], channel_dim=input_data_format)\n+        resized_height, resized_width = height, width\n+        processed_images = []\n+        for image in images:\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    height,\n+                    width,\n+                    factor=patch_size * merge_size,\n+                    min_pixels=size[\"shortest_edge\"],\n+                    max_pixels=size[\"longest_edge\"],\n+                )\n+                image = resize(\n+                    image, size=(resized_height, resized_width), resample=resample, input_data_format=input_data_format\n+                )\n+\n+            if do_rescale:\n+                image = self.rescale(image, scale=rescale_factor, input_data_format=input_data_format)\n+\n+            if do_normalize:\n+                image = self.normalize(\n+                    image=image, mean=image_mean, std=image_std, input_data_format=input_data_format\n+                )\n+\n+            image = to_channel_dimension_format(image, data_format, input_channel_dim=input_data_format)\n+            processed_images.append(image)\n+\n+        patches = np.array(processed_images)\n+        if data_format == ChannelDimension.LAST:\n+            patches = patches.transpose([0, 3, 1, 2])\n+\n+        # Main difference to Qwen2 VL - no temporal patches\n+        channel = patches.shape[1]\n+        grid_t = patches.shape[0]\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+        patches = patches.reshape(\n+            [\n+                grid_t,\n+                channel,\n+                grid_h // merge_size,\n+                merge_size,\n+                patch_size,\n+                grid_w // merge_size,\n+                merge_size,\n+                patch_size,\n+            ]\n+        )\n+        # [grid_t, grid_h/merge, grid_w/merge, merge, merge, channel, patch, patch]\n+        patches = patches.transpose([0, 2, 5, 3, 6, 1, 4, 7])\n+        flatten_patches = patches.reshape(grid_t * grid_h * grid_w, channel * patch_size * patch_size)\n+\n+        return flatten_patches, (grid_t, grid_h, grid_w)\n+\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        do_resize: Optional[bool] = None,\n+        size: Optional[dict[str, int]] = None,\n+        resample: Optional[PILImageResampling] = None,\n+        do_rescale: Optional[bool] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        do_convert_rgb: Optional[bool] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Args:\n+            images (`ImageInput`):\n+                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n+                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n+                the longest edge resized to keep the input aspect ratio.\n+            resample (`int`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n+                has an effect if `do_resize` is set to `True`.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n+                `True`.\n+            patch_size (`int`, *optional*, defaults to `self.patch_size`):\n+                The spatial patch size of the vision encoder.\n+            temporal_patch_size (`int`, *optional*, defaults to `self.temporal_patch_size`):\n+                The temporal patch size of the vision encoder.\n+            merge_size (`int`, *optional*, defaults to `self.merge_size`):\n+                The merge size of the vision encoder to llm encoder.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                - Unset: Return a list of `np.ndarray`.\n+                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n+                from the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+\n+        \"\"\"\n+        size = size if size is not None else self.size\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+\n+        do_resize = do_resize if do_resize is not None else self.do_resize\n+        resample = resample if resample is not None else self.resample\n+        do_rescale = do_rescale if do_rescale is not None else self.do_rescale\n+        rescale_factor = rescale_factor if rescale_factor is not None else self.rescale_factor\n+        do_normalize = do_normalize if do_normalize is not None else self.do_normalize\n+        image_mean = image_mean if image_mean is not None else self.image_mean\n+        image_std = image_std if image_std is not None else self.image_std\n+        patch_size = patch_size if patch_size is not None else self.patch_size\n+        temporal_patch_size = temporal_patch_size if temporal_patch_size is not None else self.temporal_patch_size\n+        merge_size = merge_size if merge_size is not None else self.merge_size\n+        do_convert_rgb = do_convert_rgb if do_convert_rgb is not None else self.do_convert_rgb\n+\n+        if images is not None:\n+            images = self.fetch_images(images)\n+            images = make_flat_list_of_images(images)\n+\n+        if images is not None and not valid_images(images):\n+            raise ValueError(\"Invalid image type. Must be of type PIL.Image.Image, numpy.ndarray, or torch.Tensor\")\n+\n+        validate_preprocess_arguments(\n+            rescale_factor=rescale_factor,\n+            do_normalize=do_normalize,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            do_resize=do_resize,\n+            size=size,\n+            resample=resample,\n+        )\n+\n+        data = {}\n+        if images is not None:\n+            pixel_values, vision_grid_thws = [], []\n+            for image in images:\n+                patches, image_grid_thw = self._preprocess(\n+                    image,\n+                    do_resize=do_resize,\n+                    size=size,\n+                    resample=resample,\n+                    do_rescale=do_rescale,\n+                    rescale_factor=rescale_factor,\n+                    do_normalize=do_normalize,\n+                    image_mean=image_mean,\n+                    image_std=image_std,\n+                    patch_size=patch_size,\n+                    temporal_patch_size=temporal_patch_size,\n+                    merge_size=merge_size,\n+                    data_format=data_format,\n+                    do_convert_rgb=do_convert_rgb,\n+                    input_data_format=input_data_format,\n+                )\n+                pixel_values.extend(patches)\n+                vision_grid_thws.append(image_grid_thw)\n+            pixel_values = np.array(pixel_values)\n+            vision_grid_thws = np.array(vision_grid_thws)\n+            data.update({\"pixel_values\": pixel_values, \"image_grid_thw\": vision_grid_thws})\n+\n+        return BatchFeature(data=data, tensor_type=return_tensors)\n+\n+    def get_number_of_image_patches(self, height: int, width: int, images_kwargs=None):\n+        \"\"\"\n+        A utility that returns number of image patches for a given image size.\n+\n+        Args:\n+            height (`int`):\n+                Height of the input image.\n+            width (`int`):\n+                Width of the input image.\n+            images_kwargs (`dict`, *optional*)\n+                Any kwargs to override defaults of the image processor.\n+        Returns:\n+            `int`: Number of image patches per image.\n+        \"\"\"\n+        min_pixels = self.size[\"shortest_edge\"]\n+        max_pixels = self.size[\"longest_edge\"]\n+        patch_size = images_kwargs.get(\"patch_size\", self.patch_size)\n+        merge_size = images_kwargs.get(\"merge_size\", self.merge_size)\n+\n+        factor = patch_size * merge_size\n+        resized_height, resized_width = smart_resize(\n+            height, width, factor, min_pixels=min_pixels, max_pixels=max_pixels\n+        )\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+        return grid_h * grid_w\n+\n+\n+__all__ = [\"Ernie4_5_VL_MoeImageProcessor\"]"
        },
        {
            "sha": "54e0c357ce6c836b9acc51cb3a0ac22a8a832245",
            "filename": "src/transformers/models/ernie4_5_vl_moe/image_processing_ernie4_5_vl_moe_fast.py",
            "status": "added",
            "additions": 232,
            "deletions": 0,
            "changes": 232,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fimage_processing_ernie4_5_vl_moe_fast.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fimage_processing_ernie4_5_vl_moe_fast.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fimage_processing_ernie4_5_vl_moe_fast.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,232 @@\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+#           This file was automatically generated from src/transformers/models/ernie4_5_vl_moe/modular_ernie4_5_vl_moe.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_ernie4_5_vl_moe.py file directly. One of our CI enforces this.\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+# coding=utf-8\n+# Copyright 2025 Baidu and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import math\n+from typing import Optional, Union\n+\n+import torch\n+import torch.nn.functional as F\n+\n+from ...image_processing_utils import BatchFeature\n+from ...image_processing_utils_fast import BaseImageProcessorFast, group_images_by_shape, reorder_images\n+from ...image_utils import OPENAI_CLIP_MEAN, OPENAI_CLIP_STD, ImageInput, PILImageResampling, SizeDict\n+from ...processing_utils import Unpack\n+from ...utils import TensorType, auto_docstring\n+from .image_processing_ernie4_5_vl_moe import Ernie4_5_VL_MoeImageProcessorKwargs\n+\n+\n+def smart_resize(\n+    height: int, width: int, factor: int = 28, min_pixels: int = 56 * 56, max_pixels: int = 14 * 14 * 4 * 1280\n+):\n+    \"\"\"Rescales the image so that the following conditions are met:\n+\n+    1. Both dimensions (height and width) are divisible by 'factor'.\n+\n+    2. The total number of pixels is within the range ['min_pixels', 'max_pixels'].\n+\n+    3. The aspect ratio of the image is maintained as closely as possible.\n+\n+    \"\"\"\n+    if max(height, width) / min(height, width) > 200:\n+        raise ValueError(\n+            f\"absolute aspect ratio must be smaller than 200, got {max(height, width) / min(height, width)}\"\n+        )\n+    h_bar = round(height / factor) * factor\n+    w_bar = round(width / factor) * factor\n+    if h_bar * w_bar > max_pixels:\n+        beta = math.sqrt((height * width) / max_pixels)\n+        h_bar = max(factor, math.floor(height / beta / factor) * factor)\n+        w_bar = max(factor, math.floor(width / beta / factor) * factor)\n+    elif h_bar * w_bar < min_pixels:\n+        beta = math.sqrt(min_pixels / (height * width))\n+        h_bar = math.ceil(height * beta / factor) * factor\n+        w_bar = math.ceil(width * beta / factor) * factor\n+    return h_bar, w_bar\n+\n+\n+@auto_docstring\n+class Ernie4_5_VL_MoeImageProcessorFast(BaseImageProcessorFast):\n+    do_resize = True\n+    resample = PILImageResampling.BICUBIC\n+    size = {\"shortest_edge\": 56 * 56, \"longest_edge\": 28 * 28 * 6177}\n+    do_rescale = True\n+    do_normalize = True\n+    image_mean = OPENAI_CLIP_MEAN\n+    image_std = OPENAI_CLIP_STD\n+    do_convert_rgb = True\n+    patch_size = 14\n+    temporal_patch_size = None  # Unused\n+    merge_size = 2\n+    valid_kwargs = Ernie4_5_VL_MoeImageProcessorKwargs\n+    model_input_names = [\"pixel_values\", \"image_grid_thw\"]\n+\n+    def __init__(self, **kwargs: Unpack[Ernie4_5_VL_MoeImageProcessorKwargs]):\n+        super().__init__(**kwargs)\n+        if self.size is not None and (\n+            self.size.get(\"shortest_edge\", None) is None or self.size.get(\"longest_edge\", None) is None\n+        ):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+\n+    def _further_process_kwargs(\n+        self,\n+        size: Optional[SizeDict] = None,\n+        **kwargs,\n+    ) -> dict:\n+        \"\"\"\n+        Update kwargs that need further processing before being validated\n+        Can be overridden by subclasses to customize the processing of kwargs.\n+        \"\"\"\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+\n+        return super()._further_process_kwargs(size=size, **kwargs)\n+\n+    def _preprocess(\n+        self,\n+        images: list[\"torch.Tensor\"],\n+        do_resize: bool,\n+        size: SizeDict,\n+        interpolation: Optional[\"F.InterpolationMode\"],\n+        do_rescale: bool,\n+        rescale_factor: float,\n+        do_normalize: bool,\n+        image_mean: Optional[Union[float, list[float]]],\n+        image_std: Optional[Union[float, list[float]]],\n+        patch_size: int,\n+        merge_size: int,\n+        disable_grouping: Optional[bool],\n+        return_tensors: Optional[Union[str, TensorType]],\n+        **kwargs,\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n+        \"\"\"\n+        # Group images by size for batched resizing\n+        grouped_images, grouped_images_index = group_images_by_shape(images, disable_grouping=disable_grouping)\n+        resized_images_grouped = {}\n+        for shape, stacked_images in grouped_images.items():\n+            height, width = stacked_images.shape[-2:]\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    height,\n+                    width,\n+                    factor=patch_size * merge_size,\n+                    min_pixels=size[\"shortest_edge\"],\n+                    max_pixels=size[\"longest_edge\"],\n+                )\n+                stacked_images = self.resize(\n+                    image=stacked_images,\n+                    size=SizeDict(height=resized_height, width=resized_width),\n+                    interpolation=interpolation,\n+                )\n+            resized_images_grouped[shape] = stacked_images\n+        resized_images = reorder_images(resized_images_grouped, grouped_images_index)\n+\n+        # Group images by size for further processing\n+        # Needed in case do_resize is False, or resize returns images with different sizes\n+        grouped_images, grouped_images_index = group_images_by_shape(resized_images, disable_grouping=disable_grouping)\n+        processed_images_grouped = {}\n+        processed_grids = {}\n+        for shape, stacked_images in grouped_images.items():\n+            resized_height, resized_width = stacked_images.shape[-2:]\n+            # Fused rescale and normalize\n+            patches = self.rescale_and_normalize(\n+                stacked_images, do_rescale, rescale_factor, do_normalize, image_mean, image_std\n+            )\n+            if patches.ndim == 4:\n+                # add a temporal dimension if we have images\n+                patches = patches.unsqueeze(1)\n+\n+            # Main difference to Qwen2 VL - no temporal patches\n+            batch_size, grid_t, channel = patches.shape[:3]\n+            grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+\n+            patches = patches.view(\n+                batch_size,\n+                grid_t,\n+                channel,\n+                grid_h // merge_size,\n+                merge_size,\n+                patch_size,\n+                grid_w // merge_size,\n+                merge_size,\n+                patch_size,\n+            )\n+            # Reorder dimensions to group grid and patch information for subsequent flattening.\n+            # [batch, grid_t, grid_h/merge, grid_w/merge, merge, merge, channel, patch, patch]\n+            patches = patches.permute(0, 1, 3, 6, 4, 7, 2, 5, 8)\n+\n+            flatten_patches = patches.reshape(\n+                batch_size,\n+                grid_t * grid_h * grid_w,\n+                channel * patch_size * patch_size,\n+            )\n+\n+            processed_images_grouped[shape] = flatten_patches\n+            processed_grids[shape] = [[grid_t, grid_h, grid_w]] * batch_size\n+\n+        processed_images = reorder_images(processed_images_grouped, grouped_images_index)\n+        processed_grids = reorder_images(processed_grids, grouped_images_index)\n+        pixel_values = torch.cat(processed_images, dim=0)\n+        image_grid_thw = torch.tensor(processed_grids)\n+\n+        return BatchFeature(\n+            data={\"pixel_values\": pixel_values, \"image_grid_thw\": image_grid_thw}, tensor_type=return_tensors\n+        )\n+\n+    @auto_docstring\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        **kwargs: Unpack[Ernie4_5_VL_MoeImageProcessorKwargs],\n+    ) -> BatchFeature:\n+        return super().preprocess(images, **kwargs)\n+\n+    def get_number_of_image_patches(self, height: int, width: int, images_kwargs=None):\n+        \"\"\"\n+        A utility that returns number of image patches for a given image size.\n+\n+        Note: Do not remove this method! It is used by vLLM to infer the number of patches and placeholders\n+        without an image input.\n+\n+        Args:\n+            height (`int`):\n+                Height of the input image.\n+            width (`int`):\n+                Width of the input image.\n+            images_kwargs (`dict`, *optional*)\n+                Any kwargs to override defaults of the image processor.\n+        Returns:\n+            `int`: Number of image patches per image.\n+        \"\"\"\n+        min_pixels = self.size[\"shortest_edge\"]\n+        max_pixels = self.size[\"longest_edge\"]\n+        patch_size = images_kwargs.get(\"patch_size\", self.patch_size)\n+        merge_size = images_kwargs.get(\"merge_size\", self.merge_size)\n+\n+        factor = patch_size * merge_size\n+        resized_height, resized_width = smart_resize(\n+            height, width, factor, min_pixels=min_pixels, max_pixels=max_pixels\n+        )\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+        return grid_h * grid_w\n+\n+\n+__all__ = [\"Ernie4_5_VL_MoeImageProcessorFast\"]"
        },
        {
            "sha": "905fbb2377baf76aa411d57f0899dbade012b2f2",
            "filename": "src/transformers/models/ernie4_5_vl_moe/modeling_ernie4_5_vl_moe.py",
            "status": "added",
            "additions": 1893,
            "deletions": 0,
            "changes": 1893,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fmodeling_ernie4_5_vl_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fmodeling_ernie4_5_vl_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fmodeling_ernie4_5_vl_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,1893 @@\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+#           This file was automatically generated from src/transformers/models/ernie4_5_vl_moe/modular_ernie4_5_vl_moe.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_ernie4_5_vl_moe.py file directly. One of our CI enforces this.\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+# coding=utf-8\n+# Copyright 2025 Baidu and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import itertools\n+from collections.abc import Callable\n+from typing import Any, Optional, Union\n+\n+import torch\n+import torch.nn as nn\n+import torch.nn.functional as F\n+\n+from ... import initialization as init\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...integrations import use_kernel_forward_from_hub, use_kernelized_func\n+from ...masking_utils import create_causal_mask\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import MoeCausalLMOutputWithPast, MoeModelOutputWithPast\n+from ...modeling_rope_utils import dynamic_rope_update\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring, can_return_tuple, is_torchdynamo_compiling\n+from ...utils.generic import OutputRecorder, check_model_inputs, maybe_autocast\n+from .configuration_ernie4_5_vl_moe import (\n+    Ernie4_5_VL_MoeConfig,\n+    Ernie4_5_VL_MoeTextConfig,\n+    Ernie4_5_VL_MoeVisionConfig,\n+)\n+\n+\n+class Ernie4_5_VL_MoeTextRotaryEmbedding(nn.Module):\n+    inv_freq: torch.Tensor  # fix linting for `register_buffer`\n+\n+    def __init__(self, config, device=None):\n+        super().__init__()\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+\n+        self.rope_type = self.config.rope_parameters[\"rope_type\"]\n+        rope_init_fn: Callable = self.compute_default_rope_parameters\n+        if self.rope_type != \"default\":\n+            raise ValueError(f\"Ernie 4.5 VL requires the `default` rope type, but found {self.rope_type} instead.\")\n+        inv_freq, self.attention_scaling = rope_init_fn(self.config, device)\n+\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = inv_freq\n+\n+        self.mrope_section = config.rope_parameters.get(\"mrope_section\", [22, 22, 20])\n+\n+    @staticmethod\n+    def compute_default_rope_parameters(\n+        config: Optional[Ernie4_5_VL_MoeTextConfig] = None,\n+        device: Optional[\"torch.device\"] = None,\n+        seq_len: Optional[int] = None,\n+    ) -> tuple[\"torch.Tensor\", float]:\n+        \"\"\"\n+        Computes the inverse frequencies according to the original RoPE implementation\n+        Args:\n+            config ([`~transformers.PreTrainedConfig`]):\n+                The model configuration.\n+            device (`torch.device`):\n+                The device to use for initialization of the inverse frequencies.\n+            seq_len (`int`, *optional*):\n+                The current sequence length. Unused for this type of RoPE.\n+        Returns:\n+            Tuple of (`torch.Tensor`, `float`), containing the inverse frequencies for the RoPE embeddings and the\n+            post-processing scaling factor applied to the computed cos/sin (unused in this type of RoPE).\n+        \"\"\"\n+        base = config.rope_parameters[\"rope_theta\"]\n+        dim = getattr(config, \"head_dim\", None) or config.hidden_size // config.num_attention_heads\n+\n+        attention_factor = 1.0  # Unused in this type of RoPE\n+\n+        # Compute the inverse frequencies\n+        inv_freq = 1.0 / (\n+            base ** (torch.arange(0, dim, 2, dtype=torch.int64).to(device=device, dtype=torch.float) / dim)\n+        )\n+\n+        # Special to ernie, we prerotate on the hw dim\n+        mrope_section = config.rope_parameters.get(\"mrope_section\", [22, 22, 20])\n+        hw_dim = mrope_section[0] + mrope_section[1]\n+        t_dim = mrope_section[2]\n+\n+        inv_freq_3d = torch.empty_like(inv_freq)\n+        # (Pre-)Rotate to avoid another rotation during the forward\n+        inv_freq_3d[:hw_dim] = torch.cat([inv_freq[:-t_dim][0::2], inv_freq[:-t_dim][1::2]])\n+        inv_freq_3d[-t_dim:] = inv_freq[-t_dim:]\n+\n+        return inv_freq_3d, attention_factor\n+\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        inv_freq_expanded = (\n+            self.inv_freq[None, None, :, None].float().expand(3, position_ids.shape[1], -1, 1).to(x.device)\n+        )\n+        position_ids_expanded = position_ids[:, :, None, :].float()  # shape (3, bs, 1, positions)\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with maybe_autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(2, 3)\n+            cos = freqs.cos() * self.attention_scaling\n+            sin = freqs.sin() * self.attention_scaling\n+\n+        sin = self.recomposition_to_3d(sin)\n+        cos = self.recomposition_to_3d(cos)\n+\n+        return cos, sin\n+\n+    def recomposition_to_3d(self, freq):\n+        freq_h, freq_w, freq_t = (m[(i + 1) % 3] for i, m in enumerate(freq.split([*self.mrope_section], dim=-1)))\n+        freq_hw = torch.stack([freq_h, freq_w], dim=-1).flatten(-2)\n+        freq_hwt = torch.cat([freq_hw, freq_t], dim=-1)\n+        return freq_hwt.repeat_interleave(2, dim=-1)\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs: Unpack[TransformersKwargs],\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+def rotate_half_text(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., 0::2]\n+    x2 = x[..., 1::2]\n+    return torch.stack((-x2, x1), dim=-1).flatten(-2)\n+\n+\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`, *optional*):\n+            Deprecated and unused.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    original_dtype = q.dtype\n+\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+\n+    q_embed = (q.float() * cos) + (rotate_half_text(q).float() * sin)\n+    k_embed = (k.float() * cos) + (rotate_half_text(k).float() * sin)\n+\n+    return q_embed.to(original_dtype), k_embed.to(original_dtype)\n+\n+\n+@use_kernelized_func(apply_rotary_pos_emb)\n+class Ernie4_5_VL_MoeTextAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: Ernie4_5_VL_MoeConfig, layer_idx: int):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.head_dim = getattr(config, \"head_dim\", config.hidden_size // config.num_attention_heads)\n+        self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n+        self.scaling = self.head_dim**-0.5\n+\n+        self.attention_dropout = 0.0\n+        self.is_causal = True\n+\n+        self.q_proj = nn.Linear(config.hidden_size, config.num_attention_heads * self.head_dim, bias=config.use_bias)\n+        self.k_proj = nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.use_bias)\n+        self.v_proj = nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.use_bias)\n+        self.o_proj = nn.Linear(config.num_attention_heads * self.head_dim, config.hidden_size, bias=config.use_bias)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_values is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_values.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+@use_kernel_forward_from_hub(\"RMSNorm\")\n+class Ernie4_5_VL_MoeRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        Ernie4_5_VL_MoeRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class Ernie4_5_VL_MoeMLP(nn.Module):\n+    def __init__(self, config, intermediate_size=None):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size if intermediate_size is None else intermediate_size\n+\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=config.use_bias)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=config.use_bias)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=config.use_bias)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, x):\n+        down_proj = self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x))\n+        return down_proj\n+\n+\n+class Ernie4_5_VL_MoeMoeStatics(nn.Module):\n+    \"\"\"\n+    Stores MoE (Mixture of Experts) statistics\n+        - Bias for the gating\n+        - Additionally, usage per expert in the original codebase\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+\n+        num_experts_groups = 1\n+        num_experts = config.moe_num_experts\n+\n+        self.e_score_correction_bias = nn.Parameter(\n+            torch.zeros(num_experts_groups, num_experts, dtype=torch.float32),\n+            requires_grad=False,\n+        )\n+\n+    def forward(self, hidden_states):\n+        # NOTE: This is a workaround to enable TP with a module that only has parameters\n+        #\n+        # Otherwise, it stays as `DTensor` when called in the \"super\" forward\n+        #   1. All other tensors are local (`torch.Tensor`)\n+        #   2. Isolate does not work on `nn.Module` which only has parameters\n+        return hidden_states + self.e_score_correction_bias.squeeze()\n+\n+\n+class Ernie4_5_VL_MoeMoeTopKRouter(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.zeros(config.moe_num_experts, config.hidden_size, dtype=torch.float32))\n+        self.moe_statics = Ernie4_5_VL_MoeMoeStatics(config)\n+        self.top_k = config.moe_k\n+        self.norm_min = config.moe_norm_min\n+\n+    def forward(self, hidden_states: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n+        device_type = (\n+            hidden_states.device.type\n+            if isinstance(hidden_states.device.type, str) and hidden_states.device.type != \"mps\"\n+            else \"cpu\"\n+        )\n+\n+        with maybe_autocast(device_type=device_type, enabled=False):  # Force float32\n+            router_logits = F.linear(hidden_states.float(), self.weight)\n+            routing_weights = F.softmax(router_logits, dim=1, dtype=torch.float)\n+            _, selected_experts = torch.topk(self.moe_statics(routing_weights), self.top_k, dim=-1)\n+            routing_weights = torch.gather(routing_weights, dim=-1, index=selected_experts)\n+            routing_weights = routing_weights / torch.clamp(\n+                routing_weights.sum(dim=-1, keepdim=True), min=self.norm_min\n+            )\n+        routing_weights = routing_weights.to(hidden_states.dtype)\n+        return router_logits, selected_experts, routing_weights\n+\n+\n+class Ernie4_5_VL_MoeMoeExperts(nn.Module):\n+    \"\"\"Collection of expert weights stored as 3D tensors.\"\"\"\n+\n+    def __init__(self, config, intermediate_size=None):\n+        super().__init__()\n+        self.num_experts = config.moe_num_experts\n+        self.hidden_dim = config.hidden_size\n+        self.intermediate_dim = config.moe_intermediate_size if intermediate_size is None else intermediate_size\n+        self.gate_up_proj = nn.Parameter(torch.empty(self.num_experts, 2 * self.intermediate_dim, self.hidden_dim))\n+        self.down_proj = nn.Parameter(torch.empty(self.num_experts, self.hidden_dim, self.intermediate_dim))\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        top_k_index: torch.Tensor,\n+        top_k_weights: torch.Tensor,\n+    ) -> torch.Tensor:\n+        final_hidden_states = torch.zeros_like(hidden_states)\n+        with torch.no_grad():\n+            expert_mask = torch.nn.functional.one_hot(top_k_index, num_classes=self.num_experts)\n+            expert_mask = expert_mask.permute(2, 1, 0)\n+            expert_hit = torch.greater(expert_mask.sum(dim=(-1, -2)), 0).nonzero()\n+\n+        for expert_idx in expert_hit:\n+            expert_idx = expert_idx[0]\n+            if expert_idx == self.num_experts:\n+                continue\n+            top_k_pos, token_idx = torch.where(expert_mask[expert_idx])\n+            current_state = hidden_states[token_idx]\n+            gate, up = nn.functional.linear(current_state, self.gate_up_proj[expert_idx]).chunk(2, dim=-1)\n+            current_hidden_states = self.act_fn(gate) * up\n+            current_hidden_states = nn.functional.linear(current_hidden_states, self.down_proj[expert_idx])\n+            current_hidden_states = current_hidden_states * top_k_weights[token_idx, top_k_pos, None]\n+            final_hidden_states.index_add_(0, token_idx, current_hidden_states.to(final_hidden_states.dtype))\n+\n+        return final_hidden_states\n+\n+\n+class Ernie4_5_VL_MoeSparseMoeBlock(nn.Module):\n+    def __init__(self, config, intermediate_size):\n+        super().__init__()\n+        self.hidden_dim = config.hidden_size\n+        self.num_experts = config.moe_num_experts\n+        self.top_k = config.moe_k\n+        self.gate = Ernie4_5_VL_MoeMoeTopKRouter(config)\n+        self.experts = Ernie4_5_VL_MoeMoeExperts(config, intermediate_size)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+    ) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:\n+        hidden_states = hidden_states.view(-1, self.hidden_dim)\n+\n+        router_logits, top_k_index, top_k_weights = self.gate(hidden_states)\n+        final_hidden_states = self.experts(hidden_states, top_k_index, top_k_weights)\n+\n+        # moe results are changed to a flattened shape to ease the modality isolated assigning of results\n+        return final_hidden_states.flatten(), router_logits.flatten()\n+\n+\n+class Ernie4_5_VL_MoeMoeBlock(nn.Module):\n+    \"\"\"\n+    Similar to `Ernie4_5_Moe` where we have modality isolated experts:\n+        - A set of text experts that are only run on text tokens\n+        - A set of vision experts that are only run on vision (image/video) tokens\n+\n+    This modality isolation is unique to the Ernie 4.5 VL Moe models.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+        self.num_experts = config.moe_num_experts\n+\n+        self.text_moe = Ernie4_5_VL_MoeSparseMoeBlock(config, intermediate_size=config.moe_intermediate_size[0])\n+        self.vision_moe = Ernie4_5_VL_MoeSparseMoeBlock(config, intermediate_size=config.moe_intermediate_size[1])\n+\n+        self.shared_experts = None\n+        if config.moe_num_shared_experts > 0:\n+            self.shared_experts = Ernie4_5_VL_MoeMLP(\n+                config, config.moe_intermediate_size[0] * config.moe_num_shared_experts\n+            )\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        moe_mm_token_type_ids: Optional[torch.IntTensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:\n+        batch_size, sequence_length, hidden_dim = hidden_states.shape\n+\n+        # (Optional) shared experts\n+        if self.shared_experts is not None:\n+            shared_output = self.shared_experts(hidden_states)\n+\n+        if moe_mm_token_type_ids is not None and moe_mm_token_type_ids.any():\n+            final_hidden_states = torch.zeros_like(hidden_states)\n+            router_logits = torch.zeros(\n+                size=(batch_size * sequence_length, self.num_experts),\n+                device=final_hidden_states.device,\n+                dtype=torch.float,\n+            )\n+\n+            # True (1 or 2) == vision, False (0) == text tokens\n+            moe_mm_token_type_ids = moe_mm_token_type_ids.bool()\n+            token_type_ids_router = moe_mm_token_type_ids.reshape(-1)[:, None].expand(-1, self.num_experts)\n+            token_type_ids_states = moe_mm_token_type_ids[..., None].expand(-1, -1, hidden_dim)\n+\n+            # Run moe on each modality and assign their results to the original token positions\n+            final_hidden_states[~token_type_ids_states], router_logits[~token_type_ids_router] = self.text_moe(\n+                hidden_states[~token_type_ids_states]\n+            )\n+            final_hidden_states[token_type_ids_states], router_logits[token_type_ids_router] = self.vision_moe(\n+                hidden_states[token_type_ids_states]\n+            )\n+        else:\n+            final_hidden_states, router_logits = self.text_moe(hidden_states)\n+            final_hidden_states = final_hidden_states.reshape(batch_size, sequence_length, hidden_dim)\n+            router_logits = router_logits.reshape(-1, self.num_experts)\n+\n+        # Add (optional) shared experts to the result\n+        if self.shared_experts is not None:\n+            final_hidden_states = final_hidden_states + shared_output\n+\n+        return final_hidden_states, router_logits\n+\n+\n+class Ernie4_5_VL_MoeDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config, layer_idx):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        self.self_attn = Ernie4_5_VL_MoeTextAttention(config, layer_idx)\n+\n+        if config.mlp_layer_types[layer_idx] == \"sparse\":\n+            self.mlp = Ernie4_5_VL_MoeMoeBlock(config)\n+        else:\n+            self.mlp = Ernie4_5_VL_MoeMLP(config)\n+\n+        self.input_layernorm = Ernie4_5_VL_MoeRMSNorm(config.hidden_size, config.rms_norm_eps)\n+        self.post_attention_layernorm = Ernie4_5_VL_MoeRMSNorm(config.hidden_size, config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        moe_mm_token_type_ids: Optional[torch.IntTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> tuple[torch.Tensor, Optional[tuple[torch.Tensor, torch.Tensor]]]:\n+        residual = hidden_states\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # Self Attention\n+        hidden_states, _ = self.self_attn(\n+            hidden_states=hidden_states,\n+            position_embeddings=position_embeddings,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = hidden_states + residual\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        if isinstance(self.mlp, Ernie4_5_VL_MoeMoeBlock):\n+            hidden_states, _ = self.mlp(hidden_states, moe_mm_token_type_ids)\n+        else:\n+            hidden_states = self.mlp(hidden_states)\n+        hidden_states = hidden_states + residual\n+\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class Ernie4_5_VL_MoePreTrainedModel(PreTrainedModel):\n+    config: Ernie4_5_VL_MoeConfig\n+    base_model_prefix = \"model\"\n+    input_modalities = (\"image\", \"video\", \"text\")\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"Ernie4_5_VL_MoeDecoderLayer\", \"Ernie4_5_VL_MoeVisionBlock\"]\n+    _skip_keys_device_placement = \"past_key_values\"\n+    _supports_flash_attn = True\n+    _supports_sdpa = True\n+    _can_compile_fullgraph = False\n+    _supports_attention_backend = True\n+\n+    _can_record_outputs = {\n+        \"router_logits\": OutputRecorder(Ernie4_5_VL_MoeMoeBlock, index=1),\n+        \"hidden_states\": Ernie4_5_VL_MoeDecoderLayer,\n+        \"attentions\": Ernie4_5_VL_MoeTextAttention,\n+    }\n+    _keep_in_fp32_modules_strict = [\"gate.weight\", \"moe_statics\"]\n+\n+    def _init_weights(self, module):\n+        super()._init_weights(module)\n+        if isinstance(module, Ernie4_5_VL_MoeMoeTopKRouter):\n+            init.zeros_(module.moe_statics.e_score_correction_bias)\n+            init.normal_(module.weight, mean=0.0, std=self.config.initializer_range)\n+        elif isinstance(module, Ernie4_5_VL_MoeMoeExperts):\n+            init.normal_(module.gate_up_proj, mean=0.0, std=self.config.initializer_range)\n+            init.normal_(module.down_proj, mean=0.0, std=self.config.initializer_range)\n+        elif isinstance(module, Ernie4_5_VL_MoeVisionRotaryEmbedding):\n+            inv_freq = 1.0 / (module.theta ** (torch.arange(0, module.dim, 2, dtype=torch.float) / module.dim))\n+            init.copy_(module.inv_freq, inv_freq)\n+\n+\n+@auto_docstring\n+class Ernie4_5_VL_MoeTextModel(Ernie4_5_VL_MoePreTrainedModel):\n+    config: Ernie4_5_VL_MoeTextConfig\n+\n+    def __init__(self, config: Ernie4_5_VL_MoeTextConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [Ernie4_5_VL_MoeDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = Ernie4_5_VL_MoeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = Ernie4_5_VL_MoeTextRotaryEmbedding(config=config)\n+        self.gradient_checkpointing = False\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @check_model_inputs\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        moe_mm_token_type_ids: Optional[torch.IntTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> MoeModelOutputWithPast:\n+        r\"\"\"\n+        moe_mm_token_type_ids (`torch.IntTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            The same as `mm_token_type_ids` while additionally considering start/end image/video tokens as respective vision tokens.\n+        \"\"\"\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache(config=self.config)\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        # the hard coded `3` is for temporal, height and width.\n+        if position_ids is None:\n+            position_ids = cache_position.view(1, 1, -1).expand(3, inputs_embeds.shape[0], -1)\n+        elif position_ids.ndim == 2:\n+            position_ids = position_ids[None, ...].expand(3, position_ids.shape[0], -1)\n+\n+        # NOTE: we need to pass text position ids for packing. Ernie 4.5 VL uses 3D positions\n+        # where each dim indicates visual spatial positions for temporal/height/width grids.\n+        # There are is only one scenario when FA2-like packed masking might be activated.\n+        # 1. User specifically passed packed `position_ids` and no attention mask.\n+        #    In this case we expect the useer to create correct position ids for all 3 grids\n+        #    and prepend text-only position ids to it. The final tensor will be [4, bs, seq-len]\n+        if position_ids.ndim == 3 and position_ids.shape[0] == 4:\n+            text_position_ids = position_ids[0]\n+            position_ids = position_ids[1:]\n+        else:\n+            # If inputs are not packed (usual 3D positions), do not prepare mask from position_ids\n+            text_position_ids = None\n+\n+        attention_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=text_position_ids,\n+        )\n+\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=attention_mask,\n+                position_ids=position_ids,\n+                moe_mm_token_type_ids=moe_mm_token_type_ids,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        return MoeModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+class Ernie4_5VLVisionMLP(nn.Module):\n+    def __init__(self, dim: int, hidden_dim: int, hidden_act: str) -> None:\n+        super().__init__()\n+        self.fc1 = nn.Linear(dim, hidden_dim)\n+        self.act = ACT2FN[hidden_act]\n+        self.fc2 = nn.Linear(hidden_dim, dim)\n+\n+    def forward(self, x) -> torch.Tensor:\n+        return self.fc2(self.act(self.fc1(x)))\n+\n+\n+class Ernie4_5_VL_MoePatchEmbed(nn.Module):\n+    def __init__(\n+        self,\n+        patch_size: int = 14,\n+        in_channels: int = 3,\n+        embed_dim: int = 1152,\n+    ) -> None:\n+        super().__init__()\n+        self.patch_size = patch_size\n+        self.in_channels = in_channels\n+        self.embed_dim = embed_dim\n+        self.proj = nn.Linear(in_channels * patch_size * patch_size, embed_dim, bias=False)\n+\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        target_dtype = self.proj.weight.dtype\n+        return self.proj(hidden_states.to(target_dtype))\n+\n+\n+class Ernie4_5_VL_MoeVisionRotaryEmbedding(nn.Module):\n+    inv_freq: torch.Tensor  # fix linting for `register_buffer`\n+\n+    def __init__(self, dim: int, theta: float = 10000.0) -> None:\n+        super().__init__()\n+        self.dim = dim\n+        self.theta = theta\n+        inv_freq = 1.0 / (theta ** (torch.arange(0, dim, 2, dtype=torch.float) / dim))\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+\n+    def forward(self, seqlen: int) -> torch.Tensor:\n+        seq = torch.arange(seqlen, device=self.inv_freq.device, dtype=self.inv_freq.dtype)\n+        freqs = torch.outer(seq, self.inv_freq)\n+        return freqs\n+\n+\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+def apply_rotary_pos_emb_vision(\n+    q: torch.Tensor, k: torch.Tensor, cos: torch.Tensor, sin: torch.Tensor\n+) -> tuple[torch.Tensor, torch.Tensor]:\n+    orig_q_dtype = q.dtype\n+    orig_k_dtype = k.dtype\n+    q, k = q.float(), k.float()\n+    cos, sin = cos.unsqueeze(-2).float(), sin.unsqueeze(-2).float()\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    q_embed = q_embed.to(orig_q_dtype)\n+    k_embed = k_embed.to(orig_k_dtype)\n+    return q_embed, k_embed\n+\n+\n+class Ernie4_5_VL_MoeVisionAttention(nn.Module):\n+    def __init__(self, config: Ernie4_5_VL_MoeVisionConfig) -> None:\n+        super().__init__()\n+        self.dim = config.hidden_size\n+        self.num_heads = config.num_heads\n+        self.head_dim = self.dim // self.num_heads\n+        self.num_key_value_groups = 1  # needed for eager attention\n+        self.qkv = nn.Linear(self.dim, self.dim * 3, bias=True)\n+        self.proj = nn.Linear(self.dim, self.dim)\n+        self.scaling = self.head_dim**-0.5\n+        self.config = config\n+        self.attention_dropout = 0.0\n+        self.is_causal = False\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cu_seqlens: torch.Tensor,\n+        rotary_pos_emb: Optional[torch.Tensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        **kwargs,\n+    ) -> torch.Tensor:\n+        seq_length = hidden_states.shape[0]\n+        query_states, key_states, value_states = (\n+            self.qkv(hidden_states).reshape(seq_length, 3, self.num_heads, -1).permute(1, 0, 2, 3).unbind(0)\n+        )\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb_vision(query_states, key_states, cos, sin)\n+\n+        query_states = query_states.transpose(0, 1).unsqueeze(0)\n+        key_states = key_states.transpose(0, 1).unsqueeze(0)\n+        value_states = value_states.transpose(0, 1).unsqueeze(0)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        if \"flash\" in self.config._attn_implementation:\n+            # Flash Attention: Use cu_seqlens for variable length attention\n+            max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max()\n+            attn_output, _ = attention_interface(\n+                self,\n+                query_states,\n+                key_states,\n+                value_states,\n+                attention_mask=None,\n+                scaling=self.scaling,\n+                dropout=0.0 if not self.training else self.attention_dropout,\n+                cu_seq_lens_q=cu_seqlens,\n+                cu_seq_lens_k=cu_seqlens,\n+                max_length_q=max_seqlen,\n+                max_length_k=max_seqlen,\n+                is_causal=False,\n+                **kwargs,\n+            )\n+        else:\n+            # Other implementations: Process each chunk separately\n+            lengths = cu_seqlens[1:] - cu_seqlens[:-1]\n+            splits = [\n+                torch.split(tensor, lengths.tolist(), dim=2) for tensor in (query_states, key_states, value_states)\n+            ]\n+\n+            attn_outputs = [\n+                attention_interface(\n+                    self,\n+                    q,\n+                    k,\n+                    v,\n+                    attention_mask=None,\n+                    scaling=self.scaling,\n+                    dropout=0.0 if not self.training else self.attention_dropout,\n+                    is_causal=False,\n+                    **kwargs,\n+                )[0]\n+                for q, k, v in zip(*splits)\n+            ]\n+            attn_output = torch.cat(attn_outputs, dim=1)\n+\n+        attn_output = attn_output.reshape(seq_length, -1).contiguous()\n+        attn_output = self.proj(attn_output)\n+        return attn_output\n+\n+\n+class Ernie4_5_VL_MoeVisionBlock(GradientCheckpointingLayer):\n+    def __init__(self, config) -> None:\n+        super().__init__()\n+\n+        self.norm1 = nn.LayerNorm(config.hidden_size, config.rms_norm_eps)\n+        self.norm2 = nn.LayerNorm(config.hidden_size, config.rms_norm_eps)\n+        self.attn = Ernie4_5_VL_MoeVisionAttention(config=config)\n+        self.mlp = Ernie4_5VLVisionMLP(\n+            dim=config.hidden_size,\n+            hidden_dim=config.intermediate_size,\n+            hidden_act=config.hidden_act,\n+        )\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cu_seqlens: torch.Tensor,\n+        rotary_pos_emb: Optional[torch.Tensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        **kwargs,\n+    ) -> torch.Tensor:\n+        hidden_states = hidden_states + self.attn(\n+            self.norm1(hidden_states),\n+            cu_seqlens=cu_seqlens,\n+            rotary_pos_emb=rotary_pos_emb,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = hidden_states + self.mlp(self.norm2(hidden_states))\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class Ernie4_5_VL_MoeVisionTransformerPretrainedModel(Ernie4_5_VL_MoePreTrainedModel):\n+    config: Ernie4_5_VL_MoeVisionConfig\n+    input_modalities = (\"image\", \"video\")\n+    _no_split_modules = [\"Ernie4_5_VL_MoeVisionBlock\"]\n+    _input_embed_layer = \"patch_embed\"\n+\n+    def __init__(self, config) -> None:\n+        super().__init__(config)\n+        self.spatial_merge_size = config.spatial_merge_size\n+\n+        self.patch_embed = Ernie4_5_VL_MoePatchEmbed(\n+            patch_size=config.patch_size,\n+            in_channels=config.in_channels,\n+            embed_dim=config.hidden_size,\n+        )\n+\n+        head_dim = config.hidden_size // config.num_heads\n+        self.rotary_pos_emb = Ernie4_5_VL_MoeVisionRotaryEmbedding(head_dim // 2)\n+\n+        self.blocks = nn.ModuleList([Ernie4_5_VL_MoeVisionBlock(config) for _ in range(config.depth)])\n+        self.gradient_checkpointing = False\n+\n+        self.ln = nn.LayerNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+        self.post_init()\n+\n+    def rot_pos_emb(self, grid_thw):\n+        pos_ids = []\n+        for t, h, w in grid_thw:\n+            hpos_ids = torch.arange(h).unsqueeze(1).expand(-1, w)\n+            hpos_ids = hpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            hpos_ids = hpos_ids.permute(0, 2, 1, 3)\n+            hpos_ids = hpos_ids.flatten()\n+\n+            wpos_ids = torch.arange(w).unsqueeze(0).expand(h, -1)\n+            wpos_ids = wpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            wpos_ids = wpos_ids.permute(0, 2, 1, 3)\n+            wpos_ids = wpos_ids.flatten()\n+            pos_ids.append(torch.stack([hpos_ids, wpos_ids], dim=-1).repeat(t, 1))\n+        pos_ids = torch.cat(pos_ids, dim=0)\n+        max_grid_size = grid_thw[:, 1:].max()\n+        rotary_pos_emb_full = self.rotary_pos_emb(max_grid_size)\n+        rotary_pos_emb = rotary_pos_emb_full[pos_ids].flatten(1)\n+        return rotary_pos_emb\n+\n+    @auto_docstring\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        grid_thw: torch.Tensor,\n+        **kwargs,\n+    ) -> torch.Tensor:\n+        r\"\"\"\n+        grid_thw (`torch.LongTensor` of shape `(num_images, 3)`):\n+            The temporal, height and width dimensions of feature shape for each image. Each row contains [t, h, w] values.\n+        \"\"\"\n+        hidden_states = self.patch_embed(hidden_states)\n+        rotary_pos_emb = self.rot_pos_emb(grid_thw)\n+        emb = torch.cat((rotary_pos_emb, rotary_pos_emb), dim=-1)\n+        position_embeddings = (emb.cos(), emb.sin())\n+\n+        cu_seqlens = torch.repeat_interleave(grid_thw[:, 1] * grid_thw[:, 2], grid_thw[:, 0]).cumsum(\n+            dim=0,\n+            # Select dtype based on the following factors:\n+            #  - FA2 requires that cu_seqlens_q must have dtype int32\n+            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n+            # See https://github.com/huggingface/transformers/pull/34852 for more information\n+            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_seqlens = F.pad(cu_seqlens, (1, 0), value=0)\n+\n+        for block in self.blocks:\n+            hidden_states = block(\n+                hidden_states,\n+                cu_seqlens=cu_seqlens,\n+                position_embeddings=position_embeddings,\n+                **kwargs,\n+            )\n+        hidden_states = self.ln(hidden_states)\n+        return hidden_states\n+\n+\n+class Ernie4_5_VL_MoeVisionMLP(nn.Module):\n+    def __init__(self, config, in_dim, out_dim):\n+        super().__init__()\n+\n+        self.fc1 = nn.Linear(in_dim, out_dim)\n+        self.act_fn = nn.GELU()\n+        self.fc2 = nn.Linear(out_dim, out_dim)\n+        self.ln = nn.LayerNorm(out_dim, eps=config.vision_config.rms_norm_eps)\n+\n+    def forward(self, hidden_states):\n+        hidden_states = self.fc1(hidden_states)\n+        hidden_states = self.act_fn(hidden_states)\n+        hidden_states = self.fc2(hidden_states)\n+        hidden_states = self.ln(hidden_states)\n+        return hidden_states\n+\n+\n+class Ernie4_5_VL_MoeVariableResolutionResamplerModel(nn.Module):\n+    def __init__(self, config: Ernie4_5_VL_MoeConfig):\n+        super().__init__()\n+        self.config = config\n+\n+        self.in_dim = config.vision_config.hidden_size\n+        self.out_dim = config.text_config.hidden_size\n+        self.spatial_merge_size = config.vision_config.spatial_merge_size\n+        self.temporal_merge_size = config.vision_config.temporal_merge_size\n+\n+        # compress 2d conv(picture) to 1d\n+        self.spatial_dim = self.in_dim * self.spatial_merge_size**2\n+        # compress 3d conv(video) to 1d\n+        self.temporal_dim = self.in_dim * self.spatial_merge_size**2 * self.temporal_merge_size\n+\n+        self.spatial_linear = Ernie4_5_VL_MoeVisionMLP(config, self.spatial_dim, self.spatial_dim)\n+        self.temporal_linear = Ernie4_5_VL_MoeVisionMLP(config, self.temporal_dim, self.spatial_dim)\n+\n+        self.mlp = nn.Linear(self.spatial_dim, self.out_dim)\n+        self.after_norm = Ernie4_5_VL_MoeRMSNorm(self.out_dim, config.text_config.rms_norm_eps)\n+\n+    def _temporal_slicing(self, hidden_states, grid_thw):\n+        \"\"\"\n+        Slices along the temporal dimension in even/odd patterns (usually if we have a video input)\n+        or duplicates along temporal dimension (usually if we have an image input).\n+\n+        Example:\n+            Video input with temporal pattern of [1, -1, 2, -2, 3, -3]\n+                > Even input [1, 2, 3], odd input [-1, -2, -3]\n+                > Reorderd via slices to [1, 2, 3, -1, -2, -3]\n+            Image input with temporal pattern [1]\n+                > Duplicate input [1], [1]\n+                > Reordered to [1, 1]\n+\n+        NOTE: This is hard-coded for `temporal_merge_size == 2` and won't work otherwise.\n+        \"\"\"\n+        # Calculating offsets on spatial dim (based on flattened tensors)\n+        grid_t, grid_hw = grid_thw[:, 0], grid_thw[:, 1:]\n+        grid_hw_after_conv = grid_hw.prod(-1) // (self.spatial_merge_size**2)\n+\n+        # Calculating offsets on batch dim (based on flattened tensors)\n+        tokens_per_img_or_vid = (grid_thw.prod(-1) // (self.spatial_merge_size**2)).flatten()\n+        batch_offsets = torch.empty(tokens_per_img_or_vid.size(), dtype=tokens_per_img_or_vid.dtype)\n+        batch_offsets[0] = 0\n+        batch_offsets[1:] = tokens_per_img_or_vid.cumsum(dim=0)[:-1]\n+\n+        first_slice_offsets = []\n+        second_slice_offsets = []\n+        for temporal_size, spatial_size, batch_offset in zip(grid_t, grid_hw_after_conv, batch_offsets):\n+            # Depending on temporal, we may interleave:\n+            #   - Images have temporal == 1 --> same offsets (duplicate \"frame\" image)\n+            #   - Videos have temporal > 1 --> different offsets (even, odd)\n+            first_offset_range = range(0, temporal_size, 2)\n+            second_offset_range = range(1 if temporal_size > 1 else 0, temporal_size, 2)\n+\n+            for temporal_offset_even, temporal_offset_odd in zip(first_offset_range, second_offset_range):\n+                first_slice_offsets.append(\n+                    torch.arange(\n+                        batch_offset + (temporal_offset_even) * spatial_size,\n+                        batch_offset + (temporal_offset_even + 1) * spatial_size,\n+                    )\n+                )\n+                second_slice_offsets.append(\n+                    torch.arange(\n+                        batch_offset + (temporal_offset_odd) * spatial_size,\n+                        batch_offset + (temporal_offset_odd + 1) * spatial_size,\n+                    )\n+                )\n+\n+        # Input: [1, -1, 2, -2, 3, -3] or [1]\n+        # Indices: [0, 2, 4] (even) or [0] (duplicate)\n+        first_slice_offsets = torch.cat(first_slice_offsets, dim=-1).to(hidden_states.device)\n+        # Indices: [1, 3, 5] (odd) or [0] (duplicate)\n+        second_slice_offsets = torch.cat(second_slice_offsets, dim=-1).to(hidden_states.device)\n+\n+        # Output: [1, 2, 3, -1, -2, -3] or [1, 1]\n+        return torch.concat(\n+            [\n+                torch.index_select(hidden_states, dim=0, index=first_slice_offsets),\n+                torch.index_select(hidden_states, dim=0, index=second_slice_offsets),\n+            ],\n+            dim=-1,\n+        )\n+\n+    def forward(self, hidden_states, grid_thw):\n+        # image spatial\n+        # reshape imitates convolution via linear projection\n+        hidden_states = hidden_states.reshape([-1, hidden_states.shape[-1] * (self.spatial_merge_size**2)])\n+        hidden_states = self.spatial_linear(hidden_states)\n+\n+        # video temporal\n+        hidden_states = self._temporal_slicing(hidden_states, grid_thw)\n+        hidden_states = self.temporal_linear(hidden_states)\n+\n+        # final mlp\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = self.after_norm(hidden_states)\n+\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class Ernie4_5_VL_MoeModel(Ernie4_5_VL_MoePreTrainedModel):\n+    base_model_prefix = \"model\"\n+    _checkpoint_conversion_mapping = {\"^norm\": \"language_model.norm\"}\n+    # Reference: fix gemma3 grad acc #37208\n+    accepts_loss_kwargs = False\n+    config: Ernie4_5_VL_MoeConfig\n+    _no_split_modules = [\"Ernie4_5_VL_MoeDecoderLayer\", \"Ernie4_5_VL_MoeVisionBlock\"]\n+\n+    def __init__(self, config: Ernie4_5_VL_MoeConfig):\n+        super().__init__(config)\n+        self.language_model = Ernie4_5_VL_MoeTextModel._from_config(config.text_config)\n+        self.rope_deltas = None  # cache rope_deltas here\n+        self.vision_tower = Ernie4_5_VL_MoeVisionTransformerPretrainedModel._from_config(config.vision_config)\n+        self.resampler_model = Ernie4_5_VL_MoeVariableResolutionResamplerModel(config)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.language_model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.language_model.set_input_embeddings(value)\n+\n+    def get_rope_index(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        mm_token_type_ids: Optional[torch.IntTensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Calculate the 3D rope index based on image and video's temporal, height and width in LLM.\n+\n+        Explanation:\n+            Each embedding sequence contains vision embedding and text embedding or just contains text embedding.\n+\n+            For pure text embedding sequence, the rotary position embedding has no difference with modern LLMs.\n+            Examples:\n+                input_ids: [T T T T T], here T is for text.\n+                temporal position_ids: [0, 1, 2, 3, 4]\n+                height position_ids: [0, 1, 2, 3, 4]\n+                width position_ids: [0, 1, 2, 3, 4]\n+\n+            For vision and text embedding sequence, we calculate 3D rotary position embedding for vision part\n+            and 1D rotary position embedding for text part.\n+            Examples:\n+                Temporal (Time): 3 patches, representing different segments of the video in time.\n+                Height: 2 patches, dividing each frame vertically.\n+                Width: 2 patches, dividing each frame horizontally.\n+                We also have some important parameters:\n+                fps (Frames Per Second): The video's frame rate, set to 1. This means one frame is processed each second.\n+                tokens_per_second: This is a crucial parameter. It dictates how many \"time-steps\" or \"temporal tokens\" are conceptually packed into a one-second interval of the video. In this case, we have 25 tokens per second. So each second of the video will be represented with 25 separate time points. It essentially defines the temporal granularity.\n+                temporal_patch_size: The number of frames that compose one temporal patch. Here, it's 2 frames.\n+                interval: The step size for the temporal position IDs, calculated as tokens_per_second * temporal_patch_size / fps. In this case, 25 * 2 / 1 = 50. This means that each temporal patch will be have a difference of 50 in the temporal position IDs.\n+                input_ids: [V V V V V V V V V V V V T T T T T], here V is for vision.\n+                vision temporal position_ids: [0, 0, 0, 0, 50, 50, 50, 50, 100, 100, 100, 100]\n+                vision height position_ids: [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]\n+                vision width position_ids: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n+                text temporal position_ids: [101, 102, 103, 104, 105]\n+                text height position_ids: [101, 102, 103, 104, 105]\n+                text width position_ids: [101, 102, 103, 104, 105]\n+                Here we calculate the text start position_ids as the max vision position_ids plus 1.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+                it.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+            mm_token_type_ids (`torch.IntTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Token type ids matching each modality to a different value in the input sequence, i.e. text (0), image (1), video (2).\n+\n+        Returns:\n+            position_ids (`torch.LongTensor` of shape `(3, batch_size, sequence_length)`)\n+            mrope_position_deltas (`torch.Tensor` of shape `(batch_size)`)\n+        \"\"\"\n+\n+        temporal_merge_size = self.config.vision_config.temporal_merge_size\n+        spatial_merge_size = self.config.vision_config.spatial_merge_size\n+\n+        mrope_position_deltas = []\n+        if input_ids is not None and (image_grid_thw is not None or video_grid_thw is not None):\n+            total_input_ids = input_ids\n+            if attention_mask is None:\n+                attention_mask = torch.ones_like(total_input_ids)\n+            position_ids = torch.ones(\n+                3,\n+                input_ids.shape[0],\n+                input_ids.shape[1],\n+                dtype=input_ids.dtype,\n+                device=input_ids.device,\n+            )\n+            image_index, video_index = 0, 0\n+            attention_mask = attention_mask.to(total_input_ids.device)\n+            for i, input_ids in enumerate(total_input_ids):\n+                # If we don't have `mm_token_type_ids`, then we have text tokens only (== 0)\n+                if mm_token_type_ids is None:\n+                    input_token_type = torch.zeros_like(input_ids)[attention_mask[i] == 1].tolist()\n+                else:\n+                    input_token_type = mm_token_type_ids[i, attention_mask[i] == 1].tolist()\n+\n+                input_type_group = []\n+                for key, group in itertools.groupby(enumerate(input_token_type), lambda x: x[1]):\n+                    group = list(group)\n+                    start_index = group[0][0]\n+                    end_index = group[-1][0] + 1\n+                    input_type_group.append((key, start_index, end_index))\n+\n+                llm_pos_ids_list = []\n+                for modality_type, start_idx, end_idx in input_type_group:\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+\n+                    # text == 0\n+                    if modality_type == 0:\n+                        text_len = end_idx - start_idx\n+                        llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                    # image == 1, video == 2\n+                    else:\n+                        grid_thw = image_grid_thw if modality_type == 1 else video_grid_thw\n+                        mm_index = image_index if modality_type == 1 else video_index\n+                        t_merge_size = 1 if modality_type == 1 else temporal_merge_size\n+\n+                        t, h, w = (\n+                            grid_thw[mm_index][0],\n+                            grid_thw[mm_index][1],\n+                            grid_thw[mm_index][2],\n+                        )\n+                        llm_grid_t, llm_grid_h, llm_grid_w = (\n+                            t.item() // t_merge_size,\n+                            h.item() // spatial_merge_size,\n+                            w.item() // spatial_merge_size,\n+                        )\n+\n+                        for t_idx in range(llm_grid_t):\n+                            t_index = torch.tensor(t_idx).view(-1, 1).expand(-1, llm_grid_h * llm_grid_w).flatten()\n+                            h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(1, -1, llm_grid_w).flatten()\n+                            w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(1, llm_grid_h, -1).flatten()\n+                            llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + st_idx)\n+\n+                        if modality_type == 1:\n+                            image_index += 1\n+                        else:\n+                            video_index += 1\n+\n+                llm_positions = torch.cat(llm_pos_ids_list, dim=1).reshape(3, -1)\n+                position_ids[..., i, attention_mask[i] == 1] = llm_positions.to(position_ids.device)\n+                mrope_position_deltas.append(llm_positions.max() + 1 - len(total_input_ids[i]))\n+            mrope_position_deltas = torch.tensor(mrope_position_deltas, device=input_ids.device).unsqueeze(1)\n+            return position_ids, mrope_position_deltas\n+        else:\n+            if attention_mask is not None:\n+                position_ids = attention_mask.long().cumsum(-1) - 1\n+                position_ids.masked_fill_(attention_mask == 0, 1)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1).to(attention_mask.device)\n+                max_position_ids = position_ids.max(0, keepdim=False)[0].max(-1, keepdim=True)[0]\n+                mrope_position_deltas = max_position_ids + 1 - attention_mask.shape[-1]\n+            else:\n+                position_ids = (\n+                    torch.arange(input_ids.shape[1], device=input_ids.device)\n+                    .view(1, 1, -1)\n+                    .expand(3, input_ids.shape[0], -1)\n+                )\n+                mrope_position_deltas = torch.zeros(\n+                    [input_ids.shape[0], 1],\n+                    device=input_ids.device,\n+                    dtype=input_ids.dtype,\n+                )\n+\n+            return position_ids, mrope_position_deltas\n+\n+    def get_video_features(\n+        self, pixel_values_videos: torch.FloatTensor, video_grid_thw: Optional[torch.LongTensor] = None\n+    ):\n+        \"\"\"\n+        Encodes videos into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values_videos (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input videos.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+        \"\"\"\n+        video_embeds = self.vision_tower(pixel_values_videos, video_grid_thw)\n+        video_embeds = self.resampler_model(video_embeds, video_grid_thw)\n+        split_sizes = (\n+            video_grid_thw.prod(-1)\n+            // self.vision_tower.spatial_merge_size**2\n+            // self.resampler_model.temporal_merge_size\n+        ).tolist()\n+        video_embeds = torch.split(video_embeds, split_sizes)\n+        return video_embeds\n+\n+    def get_image_features(self, pixel_values: torch.FloatTensor, image_grid_thw: Optional[torch.LongTensor] = None):\n+        \"\"\"\n+        Encodes images into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input images.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        image_embeds = self.vision_tower(pixel_values, image_grid_thw)\n+        image_embeds = self.resampler_model(image_embeds, image_grid_thw)\n+        split_sizes = (image_grid_thw.prod(-1) // self.vision_tower.spatial_merge_size**2).tolist()\n+        image_embeds = torch.split(image_embeds, split_sizes)\n+        return image_embeds\n+\n+    def get_placeholder_mask(\n+        self,\n+        input_ids: torch.LongTensor,\n+        inputs_embeds: torch.FloatTensor,\n+        image_features: Optional[torch.FloatTensor] = None,\n+        video_features: Optional[torch.FloatTensor] = None,\n+    ):\n+        \"\"\"\n+        Obtains multimodal placeholder mask from `input_ids` or `inputs_embeds`, and checks that the placeholder token count is\n+        equal to the length of multimodal features. If the lengths are different, an error is raised.\n+        \"\"\"\n+        if input_ids is None:\n+            special_image_mask = inputs_embeds == self.get_input_embeddings()(\n+                torch.tensor(self.config.image_token_id, dtype=torch.long, device=inputs_embeds.device)\n+            )\n+            special_image_mask = special_image_mask.all(-1)\n+            special_video_mask = inputs_embeds == self.get_input_embeddings()(\n+                torch.tensor(self.config.video_token_id, dtype=torch.long, device=inputs_embeds.device)\n+            )\n+            special_video_mask = special_video_mask.all(-1)\n+        else:\n+            special_image_mask = input_ids == self.config.image_token_id\n+            special_video_mask = input_ids == self.config.video_token_id\n+\n+        n_image_tokens = special_image_mask.sum()\n+        special_image_mask = special_image_mask.unsqueeze(-1).expand_as(inputs_embeds).to(inputs_embeds.device)\n+        if image_features is not None and inputs_embeds[special_image_mask].numel() != image_features.numel():\n+            raise ValueError(\n+                f\"Image features and image tokens do not match: tokens: {n_image_tokens}, features {image_features.shape[0]}\"\n+            )\n+\n+        n_video_tokens = special_video_mask.sum()\n+        special_video_mask = special_video_mask.unsqueeze(-1).expand_as(inputs_embeds).to(inputs_embeds.device)\n+        if video_features is not None and inputs_embeds[special_video_mask].numel() != video_features.numel():\n+            raise ValueError(\n+                f\"Videos features and video tokens do not match: tokens: {n_video_tokens}, features {video_features.shape[0]}\"\n+            )\n+\n+        return special_image_mask, special_video_mask\n+\n+    @auto_docstring\n+    @can_return_tuple\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        mm_token_type_ids: Optional[torch.IntTensor] = None,\n+        moe_mm_token_type_ids: Optional[torch.IntTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, MoeModelOutputWithPast]:\n+        r\"\"\"\n+        mm_token_type_ids (`torch.IntTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Token type ids matching each modality to a different value in the input sequence, i.e. text (0), image (1), video (2).\n+        moe_mm_token_type_ids (`torch.IntTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            The same as `mm_token_type_ids` while additionally considering start/end image/video tokens as respective vision tokens.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+        \"\"\"\n+        if inputs_embeds is None:\n+            inputs_embeds = self.get_input_embeddings()(input_ids)\n+\n+        if pixel_values is not None:\n+            image_embeds = self.get_image_features(pixel_values, image_grid_thw)\n+            image_embeds = torch.cat(image_embeds, dim=0).to(inputs_embeds.device, inputs_embeds.dtype)\n+            image_mask, _ = self.get_placeholder_mask(\n+                input_ids, inputs_embeds=inputs_embeds, image_features=image_embeds\n+            )\n+            inputs_embeds = inputs_embeds.masked_scatter(image_mask, image_embeds)\n+\n+        if pixel_values_videos is not None:\n+            video_embeds = self.get_video_features(pixel_values_videos, video_grid_thw)\n+            video_embeds = torch.cat(video_embeds, dim=0).to(inputs_embeds.device, inputs_embeds.dtype)\n+            _, video_mask = self.get_placeholder_mask(\n+                input_ids, inputs_embeds=inputs_embeds, video_features=video_embeds\n+            )\n+            inputs_embeds = inputs_embeds.masked_scatter(video_mask, video_embeds)\n+\n+        if position_ids is None:\n+            position_ids = self.get_position_ids(\n+                input_ids=input_ids,\n+                attention_mask=attention_mask,\n+                past_key_values=past_key_values,\n+                inputs_embeds=inputs_embeds,\n+                image_grid_thw=image_grid_thw,\n+                video_grid_thw=video_grid_thw,\n+                cache_position=cache_position,\n+                mm_token_type_ids=mm_token_type_ids,\n+            )\n+\n+        outputs = self.language_model(\n+            input_ids=None,\n+            position_ids=position_ids,\n+            moe_mm_token_type_ids=moe_mm_token_type_ids,\n+            attention_mask=attention_mask,\n+            use_cache=use_cache,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            return_dict=True,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        return MoeModelOutputWithPast(\n+            last_hidden_state=outputs.last_hidden_state,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            router_logits=outputs.router_logits,\n+        )\n+\n+    # TODO: Should be moved to generation loop instead in the future\n+    # Relevant PR(s): https://github.com/huggingface/transformers/pull/42088\n+    def get_position_ids(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        mm_token_type_ids: Optional[torch.IntTensor] = None,\n+    ):\n+        \"\"\"\n+        Calculating the 3D position ids with a custom mechanism / caching\n+            - First forward calculates the initial positions and the respective\n+              deltas (offset) for subsequent positions. See `get_rope_index` for\n+              more details.\n+            - Second and on (generation), uses the cache position combined with the\n+              cached deltas to determine the current position.\n+\n+        NOTE: We assume that the position ids are `None` and recalculate them here in any case.\n+        \"\"\"\n+        # Calculate RoPE index once per generation in the pre-fill stage only.\n+        # When compiling, we can't check tensor values thus we check only input length\n+        # It is safe to assume that `length!=1` means we're in pre-fill because compiled\n+        # models currently cannot do asssisted decoding\n+        prefill_compiled_stage = is_torchdynamo_compiling() and (\n+            (input_ids is not None and input_ids.shape[1] != 1)\n+            or (inputs_embeds is not None and inputs_embeds.shape[1] != 1)\n+        )\n+        prefill_noncompiled_stage = not is_torchdynamo_compiling() and (\n+            (cache_position is not None and cache_position[0] == 0)\n+            or (past_key_values is None or past_key_values.get_seq_length() == 0)\n+        )\n+        if (prefill_compiled_stage or prefill_noncompiled_stage) or self.rope_deltas is None:\n+            position_ids, rope_deltas = self.get_rope_index(\n+                input_ids,\n+                image_grid_thw,\n+                video_grid_thw,\n+                attention_mask=attention_mask,\n+                mm_token_type_ids=mm_token_type_ids,\n+            )\n+            self.rope_deltas = rope_deltas\n+        # then use the prev pre-calculated rope-deltas to get the correct position ids\n+        else:\n+            if input_ids is not None:\n+                batch_size, seq_length, device = input_ids.shape[0], 1, input_ids.device\n+            elif inputs_embeds is not None:\n+                batch_size, seq_length, device = inputs_embeds.shape[0], 1, inputs_embeds.device\n+            else:\n+                raise ValueError(\n+                    \"Cannot calculate position ids without any input to the model. \"\n+                    \"Need either `input_ids` or `inputs_embeds`!\"\n+                )\n+\n+            delta = (cache_position[0] + self.rope_deltas).to(device) if cache_position is not None else 0\n+            position_ids = torch.arange(seq_length, device=device)\n+            position_ids = position_ids.view(1, -1).expand(batch_size, -1)\n+            if cache_position is not None:  # otherwise `deltas` is an int `0`\n+                delta = delta.repeat_interleave(batch_size // delta.shape[0], dim=0)\n+            position_ids = position_ids.add(delta)\n+            position_ids = position_ids.unsqueeze(0).expand(3, -1, -1)\n+\n+        return position_ids\n+\n+\n+def load_balancing_loss_func(\n+    gate_logits: Union[torch.Tensor, tuple[torch.Tensor], None],\n+    num_experts: Optional[int] = None,\n+    top_k=2,\n+    attention_mask: Optional[torch.Tensor] = None,\n+) -> Union[torch.Tensor, int]:\n+    r\"\"\"\n+    Computes auxiliary load balancing loss as in Switch Transformer - implemented in Pytorch.\n+\n+    See Switch Transformer (https://huggingface.co/papers/2101.03961) for more details. This function implements the loss\n+    function presented in equations (4) - (6) of the paper. It aims at penalizing cases where the routing between\n+    experts is too unbalanced.\n+\n+    Args:\n+        gate_logits:\n+            Logits from the `gate`, should be a tuple of model.config.num_hidden_layers tensors of\n+            shape [batch_size X sequence_length, num_experts].\n+        num_experts:\n+            Number of experts\n+        top_k:\n+            The number of experts to route per-token, can be also interpreted as the `top-k` routing\n+            parameter.\n+        attention_mask (`torch.Tensor`, *optional*):\n+            The attention_mask used in forward function\n+            shape [batch_size X sequence_length] if not None.\n+\n+    Returns:\n+        The auxiliary loss.\n+    \"\"\"\n+    if gate_logits is None or not isinstance(gate_logits, tuple):\n+        return 0\n+\n+    if isinstance(gate_logits, tuple):\n+        compute_device = gate_logits[0].device\n+        concatenated_gate_logits = torch.cat([layer_gate.to(compute_device) for layer_gate in gate_logits], dim=0)\n+\n+    routing_weights = torch.nn.functional.softmax(concatenated_gate_logits, dim=-1)\n+\n+    _, selected_experts = torch.topk(routing_weights, top_k, dim=-1)\n+\n+    expert_mask = torch.nn.functional.one_hot(selected_experts, num_experts)\n+\n+    if attention_mask is None:\n+        # Compute the percentage of tokens routed to each experts\n+        tokens_per_expert = torch.mean(expert_mask.float(), dim=0)\n+\n+        # Compute the average probability of routing to these experts\n+        router_prob_per_expert = torch.mean(routing_weights, dim=0)\n+    else:\n+        batch_size, sequence_length = attention_mask.shape\n+        num_hidden_layers = concatenated_gate_logits.shape[0] // (batch_size * sequence_length)\n+\n+        # Compute the mask that masks all padding tokens as 0 with the same shape of expert_mask\n+        expert_attention_mask = (\n+            attention_mask[None, :, :, None, None]\n+            .expand((num_hidden_layers, batch_size, sequence_length, top_k, num_experts))\n+            .reshape(-1, top_k, num_experts)\n+            .to(compute_device)\n+        )\n+\n+        # Compute the percentage of tokens routed to each experts\n+        tokens_per_expert = torch.sum(expert_mask.float() * expert_attention_mask, dim=0) / torch.sum(\n+            expert_attention_mask, dim=0\n+        )\n+\n+        # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n+        router_per_expert_attention_mask = (\n+            attention_mask[None, :, :, None]\n+            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n+            .reshape(-1, num_experts)\n+            .to(compute_device)\n+        )\n+\n+        # Compute the average probability of routing to these experts\n+        router_prob_per_expert = torch.sum(routing_weights * router_per_expert_attention_mask, dim=0) / torch.sum(\n+            router_per_expert_attention_mask, dim=0\n+        )\n+\n+    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    return overall_loss * num_experts\n+\n+\n+class Ernie4_5_VL_MoeForConditionalGeneration(Ernie4_5_VL_MoePreTrainedModel, GenerationMixin):\n+    _checkpoint_conversion_mapping = {\"^model.norm\": \"model.language_model.norm\"}\n+    _tied_weights_keys = {\"lm_head.weight\": \"model.language_model.embed_tokens.weight\"}\n+    # Reference: fix gemma3 grad acc #37208\n+    accepts_loss_kwargs = False\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = Ernie4_5_VL_MoeModel(config)\n+        self.lm_head = nn.Linear(config.text_config.hidden_size, config.text_config.vocab_size, bias=False)\n+\n+        self.router_aux_loss_coef = config.text_config.router_aux_loss_coef\n+        self.num_experts = config.text_config.moe_num_experts\n+        self.num_experts_per_tok = config.text_config.moe_k\n+\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.model.set_input_embeddings(value)\n+\n+    def get_video_features(\n+        self, pixel_values_videos: torch.FloatTensor, video_grid_thw: Optional[torch.LongTensor] = None\n+    ):\n+        return self.model.get_video_features(pixel_values_videos, video_grid_thw)\n+\n+    def get_image_features(self, pixel_values: torch.FloatTensor, image_grid_thw: Optional[torch.LongTensor] = None):\n+        return self.model.get_image_features(pixel_values, image_grid_thw)\n+\n+    @auto_docstring\n+    @can_return_tuple\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        mm_token_type_ids: Optional[torch.IntTensor] = None,\n+        moe_mm_token_type_ids: Optional[torch.IntTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_router_logits: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, MoeCausalLMOutputWithPast]:\n+        r\"\"\"\n+        mm_token_type_ids (`torch.IntTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Token type ids matching each modality to a different value in the input sequence, i.e. text (0), image (1), video (2).\n+        moe_mm_token_type_ids (`torch.IntTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            The same as `mm_token_type_ids` while additionally considering start/end image/video tokens as respective vision tokens.\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+        \"\"\"\n+        output_router_logits = (\n+            output_router_logits if output_router_logits is not None else self.config.text_config.output_router_logits\n+        )\n+\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            mm_token_type_ids=mm_token_type_ids,\n+            moe_mm_token_type_ids=moe_mm_token_type_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_router_logits=output_router_logits,\n+            return_dict=True,\n+            pixel_values=pixel_values,\n+            pixel_values_videos=pixel_values_videos,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            rope_deltas=rope_deltas,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs.last_hidden_state\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits=logits, labels=labels, vocab_size=self.config.text_config.vocab_size)\n+\n+        aux_loss = None\n+        if output_router_logits:\n+            aux_loss = load_balancing_loss_func(\n+                outputs.router_logits,\n+                self.num_experts,\n+                self.num_experts_per_tok,\n+                attention_mask,\n+            )\n+            if labels is not None:\n+                loss += self.router_aux_loss_coef * aux_loss.to(loss.device)  # make sure to reside in the same device\n+\n+        return MoeCausalLMOutputWithPast(\n+            loss=loss,\n+            aux_loss=aux_loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            router_logits=outputs.router_logits,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        inputs_embeds=None,\n+        attention_mask=None,\n+        cache_position=None,\n+        past_key_values=None,\n+        image_grid_thw=None,\n+        video_grid_thw=None,\n+        # Intentionally ignore position ids to force custom cache logic\n+        position_ids=None,\n+        **kwargs,\n+    ):\n+        model_inputs = super().prepare_inputs_for_generation(\n+            input_ids,\n+            inputs_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            **kwargs,\n+        )\n+\n+        # Using our own caching with rope delta\n+        model_inputs[\"position_ids\"] = self.model.get_position_ids(\n+            input_ids=model_inputs.get(\"input_ids\"),\n+            attention_mask=model_inputs.get(\"attention_mask\"),\n+            past_key_values=model_inputs.get(\"past_key_values\"),\n+            inputs_embeds=model_inputs.get(\"inputs_embeds\"),\n+            image_grid_thw=model_inputs.get(\"image_grid_thw\"),\n+            video_grid_thw=model_inputs.get(\"video_grid_thw\"),\n+            cache_position=model_inputs.get(\"cache_position\"),\n+            mm_token_type_ids=model_inputs.get(\"mm_token_type_ids\"),\n+        )\n+\n+        if model_inputs[\"cache_position\"][0] != 0:\n+            model_inputs[\"pixel_values\"] = None\n+            model_inputs[\"pixel_values_videos\"] = None\n+            model_inputs[\"mm_token_type_ids\"] = None\n+            model_inputs[\"moe_mm_token_type_ids\"] = None\n+\n+        return model_inputs\n+\n+    def _get_image_nums_and_video_nums(\n+        self,\n+        input_ids: Optional[torch.LongTensor],\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Get the number of images and videos for each sample to calculate the separation length of the sample tensor.\n+        These parameters are not passed through the processor to avoid unpredictable impacts from interface modifications.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary.\n+\n+        Returns:\n+            image_nums (`torch.LongTensor` of shape `(batch_size, num_images_sample)`)\n+            video_nums (`torch.LongTensor` of shape `(batch_size, num_videos_sample)`)\n+        \"\"\"\n+\n+        if inputs_embeds is not None:\n+            is_image = (\n+                inputs_embeds\n+                == self.get_input_embeddings()(\n+                    torch.tensor(self.config.image_start_token_id, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            )[..., 0]\n+            is_video_start = (\n+                inputs_embeds\n+                == self.get_input_embeddings()(\n+                    torch.tensor(self.config.video_start_token_id, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            )[..., 0]\n+            is_video_end = (\n+                inputs_embeds\n+                == self.get_input_embeddings()(\n+                    torch.tensor(self.config.video_end_token_id, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            )[..., 0]\n+        else:\n+            is_image = input_ids == self.config.image_start_token_id\n+            is_video_start = input_ids == self.config.video_start_token_id\n+            is_video_end = input_ids == self.config.video_end_token_id\n+\n+        # Cumulative sum to track if we're inside a video span\n+        # We'll assume well-formed video tags (i.e. matching starts and ends)\n+        video_level = torch.cumsum(is_video_start.int() - is_video_end.int(), dim=1)\n+        inside_video = video_level > 0  # shape (batch_size, seq_length)\n+\n+        # Mask out image tokens that are inside video spans\n+        standalone_images = is_image & (~inside_video)\n+\n+        # Count per batch\n+        image_counts = standalone_images.sum(dim=1)\n+        video_counts = is_video_start.sum(dim=1)\n+\n+        return image_counts, video_counts\n+\n+    def _expand_inputs_for_generation(\n+        self,\n+        expand_size: int = 1,\n+        is_encoder_decoder: bool = False,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        **model_kwargs,\n+    ) -> tuple[torch.LongTensor, dict[str, Any]]:\n+        # Overwritten -- Support for expanding tensors without a batch size dimension\n+        # e.g., pixel_values, image_grid_thw, pixel_values_videos, video_grid_thw, second_per_grid_t\n+        # pixel_values.shape[0] is sum(seqlen_images for samples)\n+        # image_grid_thw.shape[0] is sum(num_images for samples)\n+\n+        if expand_size == 1:\n+            return input_ids, model_kwargs\n+\n+        visual_keys = [\"pixel_values\", \"image_grid_thw\", \"pixel_values_videos\", \"video_grid_thw\", \"second_per_grid_ts\"]\n+\n+        def _expand_dict_for_generation_visual(dict_to_expand):\n+            image_grid_thw = model_kwargs.get(\"image_grid_thw\", None)\n+            video_grid_thw = model_kwargs.get(\"video_grid_thw\", None)\n+            image_nums, video_nums = self._get_image_nums_and_video_nums(\n+                input_ids, inputs_embeds=model_kwargs.get(\"inputs_embeds\", None)\n+            )\n+\n+            def _repeat_interleave_samples(x, lengths, repeat_times):\n+                samples = torch.split(x, lengths)\n+                repeat_args = [repeat_times] + [1] * (x.dim() - 1)\n+                result = torch.cat([sample.repeat(*repeat_args) for sample in samples], dim=0)\n+                return result\n+\n+            for key in dict_to_expand:\n+                if key == \"pixel_values\":\n+                    # split images into samples\n+                    samples = torch.split(image_grid_thw, list(image_nums))\n+                    # compute the sequence length of images for each sample\n+                    lengths = [torch.prod(sample, dim=1).sum() for sample in samples]\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"image_grid_thw\":\n+                    # get the num of images for each sample\n+                    lengths = list(image_nums)\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"pixel_values_videos\":\n+                    samples = torch.split(video_grid_thw, list(video_nums))\n+                    lengths = [torch.prod(sample, dim=1).sum() for sample in samples]\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"video_grid_thw\":\n+                    lengths = list(video_nums)\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"second_per_grid_ts\":\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=list(video_nums), repeat_times=expand_size\n+                    )\n+            return dict_to_expand\n+\n+        def _expand_dict_for_generation(dict_to_expand):\n+            for key in dict_to_expand:\n+                if (\n+                    key != \"cache_position\"\n+                    and dict_to_expand[key] is not None\n+                    and isinstance(dict_to_expand[key], torch.Tensor)\n+                    and key not in visual_keys\n+                ):\n+                    dict_to_expand[key] = dict_to_expand[key].repeat_interleave(expand_size, dim=0)\n+            return dict_to_expand\n+\n+        model_kwargs = _expand_dict_for_generation_visual(model_kwargs)\n+\n+        if input_ids is not None:\n+            input_ids = input_ids.repeat_interleave(expand_size, dim=0)\n+\n+        model_kwargs = _expand_dict_for_generation(model_kwargs)\n+\n+        if is_encoder_decoder:\n+            if model_kwargs.get(\"encoder_outputs\") is None:\n+                raise ValueError(\"If `is_encoder_decoder` is True, make sure that `encoder_outputs` is defined.\")\n+            model_kwargs[\"encoder_outputs\"] = _expand_dict_for_generation(model_kwargs[\"encoder_outputs\"])\n+\n+        return input_ids, model_kwargs\n+\n+\n+__all__ = [\n+    \"Ernie4_5_VL_MoePreTrainedModel\",\n+    \"Ernie4_5_VL_MoeForConditionalGeneration\",\n+    \"Ernie4_5_VL_MoeModel\",\n+    \"Ernie4_5_VL_MoeTextModel\",\n+    \"Ernie4_5_VL_MoeVisionTransformerPretrainedModel\",\n+    \"Ernie4_5_VL_MoeVariableResolutionResamplerModel\",\n+]"
        },
        {
            "sha": "1fb51e95f7f41da00558873f0d365cec9a7da9de",
            "filename": "src/transformers/models/ernie4_5_vl_moe/modular_ernie4_5_vl_moe.py",
            "status": "added",
            "additions": 1900,
            "deletions": 0,
            "changes": 1900,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fmodular_ernie4_5_vl_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fmodular_ernie4_5_vl_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fmodular_ernie4_5_vl_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,1900 @@\n+# coding=utf-8\n+# Copyright 2025 Baidu and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch Ernie4.5-VL model.\"\"\"\n+\n+import itertools\n+from collections.abc import Callable\n+from typing import Optional, Union\n+\n+import numpy as np\n+import torch\n+import torch.nn as nn\n+import torch.nn.functional as F\n+\n+from ... import initialization as init\n+from ...cache_utils import Cache, DynamicCache\n+from ...configuration_utils import PreTrainedConfig, layer_type_validation\n+from ...generation import GenerationMixin\n+from ...image_processing_utils import BaseImageProcessor, BatchFeature\n+from ...image_processing_utils_fast import (\n+    group_images_by_shape,\n+    reorder_images,\n+)\n+from ...image_transforms import convert_to_rgb, resize, to_channel_dimension_format\n+from ...image_utils import (\n+    OPENAI_CLIP_MEAN,\n+    OPENAI_CLIP_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    SizeDict,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    is_scaled_image,\n+    make_list_of_images,\n+    to_numpy_array,\n+)\n+from ...masking_utils import create_causal_mask\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import MoeCausalLMOutputWithPast, MoeModelOutputWithPast\n+from ...modeling_rope_utils import dynamic_rope_update\n+from ...modeling_utils import PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import (\n+    TensorType,\n+    TransformersKwargs,\n+    auto_docstring,\n+    can_return_tuple,\n+    is_torchdynamo_compiling,\n+    logging,\n+)\n+from ...utils.generic import OutputRecorder, check_model_inputs, maybe_autocast\n+from ..ernie4_5_moe.configuration_ernie4_5_moe import Ernie4_5_MoeConfig\n+from ..ernie4_5_moe.modeling_ernie4_5_moe import (\n+    Ernie4_5_MoeAttention,\n+    Ernie4_5_MoeExperts,\n+    Ernie4_5_MoeMLP,\n+    Ernie4_5_MoeModel,\n+    Ernie4_5_MoeRMSNorm,\n+    Ernie4_5_MoeStatics,\n+    Ernie4_5_MoeTopKRouter,\n+)\n+from ..glm4v.image_processing_glm4v import Glm4vImageProcessor, Glm4vImageProcessorKwargs\n+from ..glm4v.image_processing_glm4v_fast import Glm4vImageProcessorFast\n+from ..glm4v.modeling_glm4v import Glm4vForConditionalGeneration\n+from ..mixtral.modeling_mixtral import load_balancing_loss_func\n+from ..qwen2_5_vl.modeling_qwen2_5_vl import (\n+    Qwen2_5_VisionPatchEmbed,\n+    Qwen2_5_VisionRotaryEmbedding,\n+    Qwen2_5_VLModel,\n+    Qwen2_5_VLPreTrainedModel,\n+    Qwen2_5_VLVisionBlock,\n+)\n+from ..qwen2_vl.configuration_qwen2_vl import Qwen2VLVisionConfig\n+from ..qwen2_vl.image_processing_qwen2_vl import smart_resize\n+from ..qwen2_vl.modeling_qwen2_vl import Qwen2VisionTransformerPretrainedModel, VisionMlp\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Ernie4_5_VL_MoeVisionConfig(Qwen2VLVisionConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of the [`Ernie4_5_VL_MoeVisionTransformerPretrainedModel`].\n+    It is used to instantiate the vision models portion of the complete Ernie4.5-VL Moe model according to the specified\n+    arguments, defining the model architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        depth (`int`, *optional*, defaults to 32):\n+            Number of layers (depth) in the model.\n+        hidden_size (`int`, *optional*, defaults to 1280):\n+            Dimensionality of the encoder layers and the pooler layer.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"quick_gelu\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler.\n+        intermediate_size (`int`, *optional*, defaults to 5120):\n+            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+        num_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        in_channels (`int`, *optional*, defaults to 3):\n+            The number of input channels.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The size (resolution) of each patch.\n+        spatial_merge_size (`int`, *optional*, defaults to 2):\n+            The size used for merging spatial dimensions.\n+        temporal_merge_size (`int`, *optional*, defaults to 2):\n+            The size used for merge along the temporal dimension.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the rms normalization layers.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+    \"\"\"\n+\n+    model_type = \"ernie4_5_vl_moe_vision\"\n+\n+    base_model_tp_plan = {\n+        \"blocks.*.attn.qkv\": \"colwise\",\n+        \"blocks.*.attn.proj\": \"rowwise\",\n+        \"blocks.*.mlp.fc1\": \"colwise\",\n+        \"blocks.*.mlp.fc2\": \"rowwise\",\n+    }\n+\n+    def __init__(\n+        self,\n+        depth=32,\n+        hidden_size=1280,\n+        hidden_act=\"quick_gelu\",\n+        intermediate_size=4 * 1280,\n+        num_heads=16,\n+        in_channels=3,\n+        patch_size=14,\n+        spatial_merge_size=2,\n+        temporal_merge_size=2,\n+        rms_norm_eps=1e-6,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            depth=depth,\n+            hidden_size=hidden_size,\n+            hidden_act=hidden_act,\n+            intermediate_size=intermediate_size,\n+            num_heads=num_heads,\n+            in_channels=in_channels,\n+            patch_size=patch_size,\n+            spatial_merge_size=spatial_merge_size,\n+            temporal_merge_size=temporal_merge_size,\n+            rms_norm_eps=rms_norm_eps,\n+            initializer_range=initializer_range,\n+            **kwargs,\n+        )\n+\n+        del self.embed_dim  # noqa: F821\n+        del self.mlp_ratio  # noqa: F821\n+        del self.temporal_patch_size  # noqa: F821\n+\n+        self.intermediate_size = intermediate_size\n+        self.temporal_merge_size = temporal_merge_size\n+        self.rms_norm_eps = rms_norm_eps\n+\n+\n+class Ernie4_5_VL_MoeTextConfig(Ernie4_5_MoeConfig, PreTrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Ernie4_5_VL_MoeTextModel`]. It is used to instantiate a\n+    the text model portion of the complete Ernie4.5-VL Moe model according to the specified arguments, defining the model architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 103424):\n+            Vocabulary size of the Ernie 4.5 VL model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Ernie4_5_VL_MoeTextModel`]\n+        hidden_size (`int`, *optional*, defaults to 2560):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 12288):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 28):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 20):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 4):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details, check out [this\n+            paper](https://huggingface.co/papers/2305.13245). If it is not specified, will default to `4`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 131072):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        use_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use a bias in any of the projections including mlp and attention for example.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `True`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_parameters (`RopeParameters`, *optional*):\n+            Dictionary containing the configuration parameters for the RoPE embeddings. The dictionaty should contain\n+            a value for `rope_theta` and optionally parameters used for scaling in case you want to use RoPE\n+            with longer `max_position_embeddings`.\n+        mlp_layer_types (`list`, *optional*):\n+            MLP (Moe vs Dense) pattern for each layer.\n+        moe_intermediate_size (`list[int]`, *optional*, defaults to `[1536, 512]`):\n+            Intermediate size of the routed experts; differs between text (first) and image (second) experts.\n+        moe_k (`int`, *optional*, defaults to 6):\n+            Number of selected experts.\n+        moe_num_experts (`int`, *optional*, defaults to 64):\n+            Number of routed experts.\n+        moe_num_shared_experts (`int`, *optional*, defaults to 2):\n+            The number of experts that are shared for all MoE forwards.\n+        moe_norm_min (`float`, *optional*, defaults to 1e-12):\n+            Minimum division value during routing normalization.\n+        output_router_logits (`bool`, *optional*, defaults to `False`):\n+            Whether or not the router logits should be returned by the model. Enabling this will also\n+            allow the model to output the auxiliary loss, including load balancing loss and router z-loss.\n+        router_aux_loss_coef (`float`, *optional*, defaults to 0.001):\n+            The aux loss factor for the total loss.\n+    \"\"\"\n+\n+    model_type = \"ernie4_5_vl_moe_text\"\n+    base_config_key = \"text_config\"\n+\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.shared_experts.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.shared_experts.up_proj\": \"colwise\",\n+        \"layers.*.mlp.shared_experts.down_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.up_proj\": \"colwise\",\n+        \"layers.*.mlp.down_proj\": \"rowwise\",\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=103424,\n+        hidden_size=2560,\n+        intermediate_size=12288,\n+        num_hidden_layers=28,\n+        num_attention_heads=20,\n+        num_key_value_heads=4,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=131072,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-5,\n+        use_cache=True,\n+        use_bias=False,\n+        tie_word_embeddings=True,\n+        rope_parameters=None,\n+        mlp_layer_types=None,\n+        moe_intermediate_size=None,\n+        moe_k=6,\n+        moe_num_experts=64,\n+        moe_num_shared_experts=2,\n+        moe_norm_min=1e-12,\n+        output_router_logits=False,\n+        router_aux_loss_coef=0.001,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.max_position_embeddings = max_position_embeddings\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.use_bias = use_bias\n+        self.rope_parameters = rope_parameters\n+\n+        # Default to MoE from the second layer and on\n+        self.mlp_layer_types = mlp_layer_types\n+        if self.mlp_layer_types is None:\n+            self.mlp_layer_types = [\"dense\"] + [\"sparse\"] * (self.num_hidden_layers - 1)\n+        layer_type_validation(self.mlp_layer_types, self.num_hidden_layers, attention=False)\n+\n+        self.moe_intermediate_size = moe_intermediate_size\n+        if self.moe_intermediate_size is None:\n+            self.moe_intermediate_size = [1536, 512]\n+        self.moe_k = moe_k\n+        self.moe_num_experts = moe_num_experts\n+        self.moe_num_shared_experts = moe_num_shared_experts\n+        self.moe_norm_min = moe_norm_min\n+        self.output_router_logits = output_router_logits\n+        self.router_aux_loss_coef = router_aux_loss_coef\n+\n+        PreTrainedConfig.__init__(\n+            tie_word_embeddings=tie_word_embeddings, ignore_keys_at_rope_validation={\"mrope_section\"}, **kwargs\n+        )\n+\n+\n+class Ernie4_5_VL_MoeConfig(PreTrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Ernie4_5_VL_MoeModel`]. It is used to instantiate a\n+    Ernie4.5-VL MoE model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of\n+    Ernie 4.5 VL 28B A3B [baidu/ERNIE-4.5-VL-28B-A3B-PT](https://huggingface.co/baidu/ERNIE-4.5-VL-28B-A3B-PT).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        text_config (`Union[PreTrainedConfig, dict]`, *optional*, defaults to `Ernie4_5_VL_MoeTextConfig`):\n+            The config object or dictionary of the text backbone.\n+        vision_config (`Union[PreTrainedConfig, dict]`,  *optional*, defaults to `Ernie4_5_VL_MoeVisionConfig`):\n+            The config object or dictionary of the vision backbone.\n+        image_start_token_id (`int`, *optional*, defaults to 101304):\n+            The image token index to encode the start of image.\n+        image_end_token_id (`int`, *optional*, defaults to 101305):\n+            The image token index to encode the end of image.\n+        image_token_id (`int`, *optional*, defaults to 100295):\n+            The image token index to encode the image prompt.\n+        video_start_token_id (`int`, *optional*, defaults to 101306):\n+            The video token index to encode the start of video.\n+        video_end_token_id (`int`, *optional*, defaults to 101307):\n+            The video token index to encode the end of video.\n+        video_token_id (`int`, *optional*, defaults to 103367):\n+            The video token index to encode the video prompt.\n+\n+    ```python\n+    >>> from transformers import Ernie4_5_VL_MoeForConditionalGeneration, Ernie4_5_VL_MoeConfig\n+\n+    >>> # Initializing a Ernie4_5_VL_Moe style configuration\n+    >>> configuration = Ernie4_5_VL_MoeConfig()\n+\n+    >>> # Initializing a model from the Ernie 4.5 VL 28B A3B configuration\n+    >>> model = Ernie4_5_VL_MoeForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"ernie4_5_vl_moe\"\n+    sub_configs = {\"vision_config\": Ernie4_5_VL_MoeVisionConfig, \"text_config\": Ernie4_5_VL_MoeTextConfig}\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        text_config=None,\n+        vision_config=None,\n+        image_start_token_id=101304,\n+        image_end_token_id=101305,\n+        image_token_id=100295,\n+        video_start_token_id=101306,\n+        video_end_token_id=101307,\n+        video_token_id=103367,\n+        **kwargs,\n+    ):\n+        if isinstance(vision_config, dict):\n+            self.vision_config = self.sub_configs[\"vision_config\"](**vision_config)\n+        elif isinstance(vision_config, Ernie4_5_VL_MoeVisionConfig):\n+            self.vision_config = vision_config\n+        elif vision_config is None:\n+            self.vision_config = self.sub_configs[\"vision_config\"]()\n+\n+        if isinstance(text_config, dict):\n+            self.text_config = self.sub_configs[\"text_config\"](**text_config)\n+        elif isinstance(text_config, Ernie4_5_VL_MoeTextConfig):\n+            self.text_config = text_config\n+        elif text_config is None:\n+            self.text_config = self.sub_configs[\"text_config\"](**kwargs)\n+\n+        self.image_start_token_id = image_start_token_id\n+        self.image_end_token_id = image_end_token_id\n+        self.image_token_id = image_token_id\n+        self.video_start_token_id = video_start_token_id\n+        self.video_end_token_id = video_end_token_id\n+        self.video_token_id = video_token_id\n+\n+        super().__init__(**kwargs)\n+\n+\n+class Ernie4_5_VL_MoeTextRotaryEmbedding(nn.Module):\n+    inv_freq: torch.Tensor  # fix linting for `register_buffer`\n+\n+    def __init__(self, config, device=None):\n+        super().__init__()\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+\n+        self.rope_type = self.config.rope_parameters[\"rope_type\"]\n+        rope_init_fn: Callable = self.compute_default_rope_parameters\n+        if self.rope_type != \"default\":\n+            raise ValueError(f\"Ernie 4.5 VL requires the `default` rope type, but found {self.rope_type} instead.\")\n+        inv_freq, self.attention_scaling = rope_init_fn(self.config, device)\n+\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = inv_freq\n+\n+        self.mrope_section = config.rope_parameters.get(\"mrope_section\", [22, 22, 20])\n+\n+    @staticmethod\n+    def compute_default_rope_parameters(\n+        config: Optional[Ernie4_5_VL_MoeTextConfig] = None,\n+        device: Optional[\"torch.device\"] = None,\n+        seq_len: Optional[int] = None,\n+    ) -> tuple[\"torch.Tensor\", float]:\n+        \"\"\"\n+        Computes the inverse frequencies according to the original RoPE implementation\n+        Args:\n+            config ([`~transformers.PreTrainedConfig`]):\n+                The model configuration.\n+            device (`torch.device`):\n+                The device to use for initialization of the inverse frequencies.\n+            seq_len (`int`, *optional*):\n+                The current sequence length. Unused for this type of RoPE.\n+        Returns:\n+            Tuple of (`torch.Tensor`, `float`), containing the inverse frequencies for the RoPE embeddings and the\n+            post-processing scaling factor applied to the computed cos/sin (unused in this type of RoPE).\n+        \"\"\"\n+        base = config.rope_parameters[\"rope_theta\"]\n+        dim = getattr(config, \"head_dim\", None) or config.hidden_size // config.num_attention_heads\n+\n+        attention_factor = 1.0  # Unused in this type of RoPE\n+\n+        # Compute the inverse frequencies\n+        inv_freq = 1.0 / (\n+            base ** (torch.arange(0, dim, 2, dtype=torch.int64).to(device=device, dtype=torch.float) / dim)\n+        )\n+\n+        # Special to ernie, we prerotate on the hw dim\n+        mrope_section = config.rope_parameters.get(\"mrope_section\", [22, 22, 20])\n+        hw_dim = mrope_section[0] + mrope_section[1]\n+        t_dim = mrope_section[2]\n+\n+        inv_freq_3d = torch.empty_like(inv_freq)\n+        # (Pre-)Rotate to avoid another rotation during the forward\n+        inv_freq_3d[:hw_dim] = torch.cat([inv_freq[:-t_dim][0::2], inv_freq[:-t_dim][1::2]])\n+        inv_freq_3d[-t_dim:] = inv_freq[-t_dim:]\n+\n+        return inv_freq_3d, attention_factor\n+\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        inv_freq_expanded = (\n+            self.inv_freq[None, None, :, None].float().expand(3, position_ids.shape[1], -1, 1).to(x.device)\n+        )\n+        position_ids_expanded = position_ids[:, :, None, :].float()  # shape (3, bs, 1, positions)\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with maybe_autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(2, 3)\n+            cos = freqs.cos() * self.attention_scaling\n+            sin = freqs.sin() * self.attention_scaling\n+\n+        sin = self.recomposition_to_3d(sin)\n+        cos = self.recomposition_to_3d(cos)\n+\n+        return cos, sin\n+\n+    def recomposition_to_3d(self, freq):\n+        freq_h, freq_w, freq_t = (m[(i + 1) % 3] for i, m in enumerate(freq.split([*self.mrope_section], dim=-1)))\n+        freq_hw = torch.stack([freq_h, freq_w], dim=-1).flatten(-2)\n+        freq_hwt = torch.cat([freq_hw, freq_t], dim=-1)\n+        return freq_hwt.repeat_interleave(2, dim=-1)\n+\n+\n+def rotate_half_text(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., 0::2]\n+    x2 = x[..., 1::2]\n+    return torch.stack((-x2, x1), dim=-1).flatten(-2)\n+\n+\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`, *optional*):\n+            Deprecated and unused.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    original_dtype = q.dtype\n+\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+\n+    q_embed = (q.float() * cos) + (rotate_half_text(q).float() * sin)\n+    k_embed = (k.float() * cos) + (rotate_half_text(k).float() * sin)\n+\n+    return q_embed.to(original_dtype), k_embed.to(original_dtype)\n+\n+\n+class Ernie4_5_VL_MoeTextAttention(Ernie4_5_MoeAttention):\n+    pass\n+\n+\n+class Ernie4_5_VL_MoeRMSNorm(Ernie4_5_MoeRMSNorm):\n+    pass\n+\n+\n+class Ernie4_5_VL_MoeMLP(Ernie4_5_MoeMLP):\n+    pass\n+\n+\n+class Ernie4_5_VL_MoeMoeStatics(Ernie4_5_MoeStatics):\n+    pass\n+\n+\n+class Ernie4_5_VL_MoeMoeTopKRouter(Ernie4_5_MoeTopKRouter):\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.moe_statics = Ernie4_5_VL_MoeMoeStatics(config)\n+\n+\n+class Ernie4_5_VL_MoeMoeExperts(Ernie4_5_MoeExperts):\n+    def __init__(self, config, intermediate_size=None):\n+        super().__init__(config)\n+        self.intermediate_dim = config.moe_intermediate_size if intermediate_size is None else intermediate_size\n+\n+\n+class Ernie4_5_VL_MoeSparseMoeBlock(nn.Module):\n+    def __init__(self, config, intermediate_size):\n+        super().__init__()\n+        self.hidden_dim = config.hidden_size\n+        self.num_experts = config.moe_num_experts\n+        self.top_k = config.moe_k\n+        self.gate = Ernie4_5_VL_MoeMoeTopKRouter(config)\n+        self.experts = Ernie4_5_VL_MoeMoeExperts(config, intermediate_size)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+    ) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:\n+        hidden_states = hidden_states.view(-1, self.hidden_dim)\n+\n+        router_logits, top_k_index, top_k_weights = self.gate(hidden_states)\n+        final_hidden_states = self.experts(hidden_states, top_k_index, top_k_weights)\n+\n+        # moe results are changed to a flattened shape to ease the modality isolated assigning of results\n+        return final_hidden_states.flatten(), router_logits.flatten()\n+\n+\n+class Ernie4_5_VL_MoeMoeBlock(nn.Module):\n+    \"\"\"\n+    Similar to `Ernie4_5_Moe` where we have modality isolated experts:\n+        - A set of text experts that are only run on text tokens\n+        - A set of vision experts that are only run on vision (image/video) tokens\n+\n+    This modality isolation is unique to the Ernie 4.5 VL Moe models.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+        self.num_experts = config.moe_num_experts\n+\n+        self.text_moe = Ernie4_5_VL_MoeSparseMoeBlock(config, intermediate_size=config.moe_intermediate_size[0])\n+        self.vision_moe = Ernie4_5_VL_MoeSparseMoeBlock(config, intermediate_size=config.moe_intermediate_size[1])\n+\n+        self.shared_experts = None\n+        if config.moe_num_shared_experts > 0:\n+            self.shared_experts = Ernie4_5_VL_MoeMLP(\n+                config, config.moe_intermediate_size[0] * config.moe_num_shared_experts\n+            )\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        moe_mm_token_type_ids: Optional[torch.IntTensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:\n+        batch_size, sequence_length, hidden_dim = hidden_states.shape\n+\n+        # (Optional) shared experts\n+        if self.shared_experts is not None:\n+            shared_output = self.shared_experts(hidden_states)\n+\n+        if moe_mm_token_type_ids is not None and moe_mm_token_type_ids.any():\n+            final_hidden_states = torch.zeros_like(hidden_states)\n+            router_logits = torch.zeros(\n+                size=(batch_size * sequence_length, self.num_experts),\n+                device=final_hidden_states.device,\n+                dtype=torch.float,\n+            )\n+\n+            # True (1 or 2) == vision, False (0) == text tokens\n+            moe_mm_token_type_ids = moe_mm_token_type_ids.bool()\n+            token_type_ids_router = moe_mm_token_type_ids.reshape(-1)[:, None].expand(-1, self.num_experts)\n+            token_type_ids_states = moe_mm_token_type_ids[..., None].expand(-1, -1, hidden_dim)\n+\n+            # Run moe on each modality and assign their results to the original token positions\n+            final_hidden_states[~token_type_ids_states], router_logits[~token_type_ids_router] = self.text_moe(\n+                hidden_states[~token_type_ids_states]\n+            )\n+            final_hidden_states[token_type_ids_states], router_logits[token_type_ids_router] = self.vision_moe(\n+                hidden_states[token_type_ids_states]\n+            )\n+        else:\n+            final_hidden_states, router_logits = self.text_moe(hidden_states)\n+            final_hidden_states = final_hidden_states.reshape(batch_size, sequence_length, hidden_dim)\n+            router_logits = router_logits.reshape(-1, self.num_experts)\n+\n+        # Add (optional) shared experts to the result\n+        if self.shared_experts is not None:\n+            final_hidden_states = final_hidden_states + shared_output\n+\n+        return final_hidden_states, router_logits\n+\n+\n+class Ernie4_5_VL_MoeDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config, layer_idx):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        self.self_attn = Ernie4_5_VL_MoeTextAttention(config, layer_idx)\n+\n+        if config.mlp_layer_types[layer_idx] == \"sparse\":\n+            self.mlp = Ernie4_5_VL_MoeMoeBlock(config)\n+        else:\n+            self.mlp = Ernie4_5_VL_MoeMLP(config)\n+\n+        self.input_layernorm = Ernie4_5_VL_MoeRMSNorm(config.hidden_size, config.rms_norm_eps)\n+        self.post_attention_layernorm = Ernie4_5_VL_MoeRMSNorm(config.hidden_size, config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.Tensor] = None,\n+        moe_mm_token_type_ids: Optional[torch.IntTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> tuple[torch.Tensor, Optional[tuple[torch.Tensor, torch.Tensor]]]:\n+        residual = hidden_states\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # Self Attention\n+        hidden_states, _ = self.self_attn(\n+            hidden_states=hidden_states,\n+            position_embeddings=position_embeddings,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = hidden_states + residual\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        if isinstance(self.mlp, Ernie4_5_VL_MoeMoeBlock):\n+            hidden_states, _ = self.mlp(hidden_states, moe_mm_token_type_ids)\n+        else:\n+            hidden_states = self.mlp(hidden_states)\n+        hidden_states = hidden_states + residual\n+\n+        return hidden_states\n+\n+\n+class Ernie4_5_VL_MoePreTrainedModel(Qwen2_5_VLPreTrainedModel):\n+    _can_compile_fullgraph = False\n+\n+    _can_record_outputs = {\n+        \"router_logits\": OutputRecorder(Ernie4_5_VL_MoeMoeBlock, index=1),\n+        \"hidden_states\": Ernie4_5_VL_MoeDecoderLayer,\n+        \"attentions\": Ernie4_5_VL_MoeTextAttention,\n+    }\n+    _keep_in_fp32_modules_strict = [\"gate.weight\", \"moe_statics\"]\n+\n+    def _init_weights(self, module):\n+        PreTrainedModel._init_weights(self, module)\n+        if isinstance(module, Ernie4_5_VL_MoeMoeTopKRouter):\n+            init.zeros_(module.moe_statics.e_score_correction_bias)\n+            init.normal_(module.weight, mean=0.0, std=self.config.initializer_range)\n+        elif isinstance(module, Ernie4_5_VL_MoeMoeExperts):\n+            init.normal_(module.gate_up_proj, mean=0.0, std=self.config.initializer_range)\n+            init.normal_(module.down_proj, mean=0.0, std=self.config.initializer_range)\n+        elif isinstance(module, Ernie4_5_VL_MoeVisionRotaryEmbedding):\n+            inv_freq = 1.0 / (module.theta ** (torch.arange(0, module.dim, 2, dtype=torch.float) / module.dim))\n+            init.copy_(module.inv_freq, inv_freq)\n+\n+\n+class Ernie4_5_VL_MoeTextModel(Ernie4_5_MoeModel):\n+    config: Ernie4_5_VL_MoeTextConfig\n+\n+    def __init__(self, config: Ernie4_5_VL_MoeTextConfig):\n+        super().__init__(config)\n+        self.rotary_emb = Ernie4_5_VL_MoeTextRotaryEmbedding(config=config)\n+\n+    @check_model_inputs\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        moe_mm_token_type_ids: Optional[torch.IntTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> MoeModelOutputWithPast:\n+        r\"\"\"\n+        moe_mm_token_type_ids (`torch.IntTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            The same as `mm_token_type_ids` while additionally considering start/end image/video tokens as respective vision tokens.\n+        \"\"\"\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache(config=self.config)\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        # the hard coded `3` is for temporal, height and width.\n+        if position_ids is None:\n+            position_ids = cache_position.view(1, 1, -1).expand(3, inputs_embeds.shape[0], -1)\n+        elif position_ids.ndim == 2:\n+            position_ids = position_ids[None, ...].expand(3, position_ids.shape[0], -1)\n+\n+        # NOTE: we need to pass text position ids for packing. Ernie 4.5 VL uses 3D positions\n+        # where each dim indicates visual spatial positions for temporal/height/width grids.\n+        # There are is only one scenario when FA2-like packed masking might be activated.\n+        # 1. User specifically passed packed `position_ids` and no attention mask.\n+        #    In this case we expect the useer to create correct position ids for all 3 grids\n+        #    and prepend text-only position ids to it. The final tensor will be [4, bs, seq-len]\n+        if position_ids.ndim == 3 and position_ids.shape[0] == 4:\n+            text_position_ids = position_ids[0]\n+            position_ids = position_ids[1:]\n+        else:\n+            # If inputs are not packed (usual 3D positions), do not prepare mask from position_ids\n+            text_position_ids = None\n+\n+        attention_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=text_position_ids,\n+        )\n+\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=attention_mask,\n+                position_ids=position_ids,\n+                moe_mm_token_type_ids=moe_mm_token_type_ids,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        return MoeModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+class Ernie4_5VLVisionMLP(VisionMlp):\n+    pass\n+\n+\n+class Ernie4_5_VL_MoePatchEmbed(Qwen2_5_VisionPatchEmbed):\n+    def __init__(\n+        self,\n+        patch_size: int = 14,\n+        in_channels: int = 3,\n+        embed_dim: int = 1152,\n+    ) -> None:\n+        super().__init__(patch_size, in_channels, embed_dim)\n+\n+        del self.temporal_patch_size\n+        del kernel_size  # noqa: F821\n+        self.proj = nn.Linear(in_channels * patch_size * patch_size, embed_dim, bias=False)\n+\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        target_dtype = self.proj.weight.dtype\n+        return self.proj(hidden_states.to(target_dtype))\n+\n+\n+class Ernie4_5_VL_MoeVisionRotaryEmbedding(Qwen2_5_VisionRotaryEmbedding):\n+    pass\n+\n+\n+class Ernie4_5_VL_MoeVisionBlock(Qwen2_5_VLVisionBlock):\n+    def __init__(self, config) -> None:\n+        super().__init__(config, None)\n+\n+        self.norm1 = nn.LayerNorm(config.hidden_size, config.rms_norm_eps)\n+        self.norm2 = nn.LayerNorm(config.hidden_size, config.rms_norm_eps)\n+        self.mlp = Ernie4_5VLVisionMLP(\n+            dim=config.hidden_size,\n+            hidden_dim=config.intermediate_size,\n+            hidden_act=config.hidden_act,\n+        )\n+\n+\n+class Ernie4_5_VL_MoeVisionTransformerPretrainedModel(Qwen2VisionTransformerPretrainedModel):\n+    def __init__(self, config) -> None:\n+        super().__init__(config)\n+\n+        del self.merger\n+\n+        self.patch_embed = Ernie4_5_VL_MoePatchEmbed(\n+            patch_size=config.patch_size,\n+            in_channels=config.in_channels,\n+            embed_dim=config.hidden_size,\n+        )\n+\n+        head_dim = config.hidden_size // config.num_heads\n+        self.rotary_pos_emb = Ernie4_5_VL_MoeVisionRotaryEmbedding(head_dim // 2)\n+\n+        self.ln = nn.LayerNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    def get_dtype(self):\n+        raise AttributeError(\"Ernie 4.5 VL Moe does not need this!\")\n+\n+    def get_device(self):\n+        raise AttributeError(\"Ernie 4.5 VL Moe does not need this!\")\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        grid_thw: torch.Tensor,\n+        **kwargs,\n+    ) -> torch.Tensor:\n+        hidden_states = self.patch_embed(hidden_states)\n+        rotary_pos_emb = self.rot_pos_emb(grid_thw)\n+        emb = torch.cat((rotary_pos_emb, rotary_pos_emb), dim=-1)\n+        position_embeddings = (emb.cos(), emb.sin())\n+\n+        cu_seqlens = torch.repeat_interleave(grid_thw[:, 1] * grid_thw[:, 2], grid_thw[:, 0]).cumsum(\n+            dim=0,\n+            # Select dtype based on the following factors:\n+            #  - FA2 requires that cu_seqlens_q must have dtype int32\n+            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n+            # See https://github.com/huggingface/transformers/pull/34852 for more information\n+            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_seqlens = F.pad(cu_seqlens, (1, 0), value=0)\n+\n+        for block in self.blocks:\n+            hidden_states = block(\n+                hidden_states,\n+                cu_seqlens=cu_seqlens,\n+                position_embeddings=position_embeddings,\n+                **kwargs,\n+            )\n+        hidden_states = self.ln(hidden_states)\n+        return hidden_states\n+\n+\n+class Ernie4_5_VL_MoeVisionMLP(nn.Module):\n+    def __init__(self, config, in_dim, out_dim):\n+        super().__init__()\n+\n+        self.fc1 = nn.Linear(in_dim, out_dim)\n+        self.act_fn = nn.GELU()\n+        self.fc2 = nn.Linear(out_dim, out_dim)\n+        self.ln = nn.LayerNorm(out_dim, eps=config.vision_config.rms_norm_eps)\n+\n+    def forward(self, hidden_states):\n+        hidden_states = self.fc1(hidden_states)\n+        hidden_states = self.act_fn(hidden_states)\n+        hidden_states = self.fc2(hidden_states)\n+        hidden_states = self.ln(hidden_states)\n+        return hidden_states\n+\n+\n+class Ernie4_5_VL_MoeVariableResolutionResamplerModel(nn.Module):\n+    def __init__(self, config: Ernie4_5_VL_MoeConfig):\n+        super().__init__()\n+        self.config = config\n+\n+        self.in_dim = config.vision_config.hidden_size\n+        self.out_dim = config.text_config.hidden_size\n+        self.spatial_merge_size = config.vision_config.spatial_merge_size\n+        self.temporal_merge_size = config.vision_config.temporal_merge_size\n+\n+        # compress 2d conv(picture) to 1d\n+        self.spatial_dim = self.in_dim * self.spatial_merge_size**2\n+        # compress 3d conv(video) to 1d\n+        self.temporal_dim = self.in_dim * self.spatial_merge_size**2 * self.temporal_merge_size\n+\n+        self.spatial_linear = Ernie4_5_VL_MoeVisionMLP(config, self.spatial_dim, self.spatial_dim)\n+        self.temporal_linear = Ernie4_5_VL_MoeVisionMLP(config, self.temporal_dim, self.spatial_dim)\n+\n+        self.mlp = nn.Linear(self.spatial_dim, self.out_dim)\n+        self.after_norm = Ernie4_5_VL_MoeRMSNorm(self.out_dim, config.text_config.rms_norm_eps)\n+\n+    def _temporal_slicing(self, hidden_states, grid_thw):\n+        \"\"\"\n+        Slices along the temporal dimension in even/odd patterns (usually if we have a video input)\n+        or duplicates along temporal dimension (usually if we have an image input).\n+\n+        Example:\n+            Video input with temporal pattern of [1, -1, 2, -2, 3, -3]\n+                > Even input [1, 2, 3], odd input [-1, -2, -3]\n+                > Reorderd via slices to [1, 2, 3, -1, -2, -3]\n+            Image input with temporal pattern [1]\n+                > Duplicate input [1], [1]\n+                > Reordered to [1, 1]\n+\n+        NOTE: This is hard-coded for `temporal_merge_size == 2` and won't work otherwise.\n+        \"\"\"\n+        # Calculating offsets on spatial dim (based on flattened tensors)\n+        grid_t, grid_hw = grid_thw[:, 0], grid_thw[:, 1:]\n+        grid_hw_after_conv = grid_hw.prod(-1) // (self.spatial_merge_size**2)\n+\n+        # Calculating offsets on batch dim (based on flattened tensors)\n+        tokens_per_img_or_vid = (grid_thw.prod(-1) // (self.spatial_merge_size**2)).flatten()\n+        batch_offsets = torch.empty(tokens_per_img_or_vid.size(), dtype=tokens_per_img_or_vid.dtype)\n+        batch_offsets[0] = 0\n+        batch_offsets[1:] = tokens_per_img_or_vid.cumsum(dim=0)[:-1]\n+\n+        first_slice_offsets = []\n+        second_slice_offsets = []\n+        for temporal_size, spatial_size, batch_offset in zip(grid_t, grid_hw_after_conv, batch_offsets):\n+            # Depending on temporal, we may interleave:\n+            #   - Images have temporal == 1 --> same offsets (duplicate \"frame\" image)\n+            #   - Videos have temporal > 1 --> different offsets (even, odd)\n+            first_offset_range = range(0, temporal_size, 2)\n+            second_offset_range = range(1 if temporal_size > 1 else 0, temporal_size, 2)\n+\n+            for temporal_offset_even, temporal_offset_odd in zip(first_offset_range, second_offset_range):\n+                first_slice_offsets.append(\n+                    torch.arange(\n+                        batch_offset + (temporal_offset_even) * spatial_size,\n+                        batch_offset + (temporal_offset_even + 1) * spatial_size,\n+                    )\n+                )\n+                second_slice_offsets.append(\n+                    torch.arange(\n+                        batch_offset + (temporal_offset_odd) * spatial_size,\n+                        batch_offset + (temporal_offset_odd + 1) * spatial_size,\n+                    )\n+                )\n+\n+        # Input: [1, -1, 2, -2, 3, -3] or [1]\n+        # Indices: [0, 2, 4] (even) or [0] (duplicate)\n+        first_slice_offsets = torch.cat(first_slice_offsets, dim=-1).to(hidden_states.device)\n+        # Indices: [1, 3, 5] (odd) or [0] (duplicate)\n+        second_slice_offsets = torch.cat(second_slice_offsets, dim=-1).to(hidden_states.device)\n+\n+        # Output: [1, 2, 3, -1, -2, -3] or [1, 1]\n+        return torch.concat(\n+            [\n+                torch.index_select(hidden_states, dim=0, index=first_slice_offsets),\n+                torch.index_select(hidden_states, dim=0, index=second_slice_offsets),\n+            ],\n+            dim=-1,\n+        )\n+\n+    def forward(self, hidden_states, grid_thw):\n+        # image spatial\n+        # reshape imitates convolution via linear projection\n+        hidden_states = hidden_states.reshape([-1, hidden_states.shape[-1] * (self.spatial_merge_size**2)])\n+        hidden_states = self.spatial_linear(hidden_states)\n+\n+        # video temporal\n+        hidden_states = self._temporal_slicing(hidden_states, grid_thw)\n+        hidden_states = self.temporal_linear(hidden_states)\n+\n+        # final mlp\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = self.after_norm(hidden_states)\n+\n+        return hidden_states\n+\n+\n+class Ernie4_5_VL_MoeModel(Qwen2_5_VLModel):\n+    _checkpoint_conversion_mapping = {\"^norm\": \"language_model.norm\"}\n+\n+    def __init__(self, config: Ernie4_5_VL_MoeConfig):\n+        super().__init__(config)\n+\n+        del self.visual\n+        self.vision_tower = Ernie4_5_VL_MoeVisionTransformerPretrainedModel._from_config(config.vision_config)\n+        self.resampler_model = Ernie4_5_VL_MoeVariableResolutionResamplerModel(config)\n+\n+    # TODO: Should be moved to generation loop instead in the future\n+    # Relevant PR(s): https://github.com/huggingface/transformers/pull/42088\n+    def get_position_ids(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        mm_token_type_ids: Optional[torch.IntTensor] = None,\n+    ):\n+        \"\"\"\n+        Calculating the 3D position ids with a custom mechanism / caching\n+            - First forward calculates the initial positions and the respective\n+              deltas (offset) for subsequent positions. See `get_rope_index` for\n+              more details.\n+            - Second and on (generation), uses the cache position combined with the\n+              cached deltas to determine the current position.\n+\n+        NOTE: We assume that the position ids are `None` and recalculate them here in any case.\n+        \"\"\"\n+        # Calculate RoPE index once per generation in the pre-fill stage only.\n+        # When compiling, we can't check tensor values thus we check only input length\n+        # It is safe to assume that `length!=1` means we're in pre-fill because compiled\n+        # models currently cannot do asssisted decoding\n+        prefill_compiled_stage = is_torchdynamo_compiling() and (\n+            (input_ids is not None and input_ids.shape[1] != 1)\n+            or (inputs_embeds is not None and inputs_embeds.shape[1] != 1)\n+        )\n+        prefill_noncompiled_stage = not is_torchdynamo_compiling() and (\n+            (cache_position is not None and cache_position[0] == 0)\n+            or (past_key_values is None or past_key_values.get_seq_length() == 0)\n+        )\n+        if (prefill_compiled_stage or prefill_noncompiled_stage) or self.rope_deltas is None:\n+            position_ids, rope_deltas = self.get_rope_index(\n+                input_ids,\n+                image_grid_thw,\n+                video_grid_thw,\n+                attention_mask=attention_mask,\n+                mm_token_type_ids=mm_token_type_ids,\n+            )\n+            self.rope_deltas = rope_deltas\n+        # then use the prev pre-calculated rope-deltas to get the correct position ids\n+        else:\n+            if input_ids is not None:\n+                batch_size, seq_length, device = input_ids.shape[0], 1, input_ids.device\n+            elif inputs_embeds is not None:\n+                batch_size, seq_length, device = inputs_embeds.shape[0], 1, inputs_embeds.device\n+            else:\n+                raise ValueError(\n+                    \"Cannot calculate position ids without any input to the model. \"\n+                    \"Need either `input_ids` or `inputs_embeds`!\"\n+                )\n+\n+            delta = (cache_position[0] + self.rope_deltas).to(device) if cache_position is not None else 0\n+            position_ids = torch.arange(seq_length, device=device)\n+            position_ids = position_ids.view(1, -1).expand(batch_size, -1)\n+            if cache_position is not None:  # otherwise `deltas` is an int `0`\n+                delta = delta.repeat_interleave(batch_size // delta.shape[0], dim=0)\n+            position_ids = position_ids.add(delta)\n+            position_ids = position_ids.unsqueeze(0).expand(3, -1, -1)\n+\n+        return position_ids\n+\n+    def get_rope_index(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        mm_token_type_ids: Optional[torch.IntTensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Calculate the 3D rope index based on image and video's temporal, height and width in LLM.\n+\n+        Explanation:\n+            Each embedding sequence contains vision embedding and text embedding or just contains text embedding.\n+\n+            For pure text embedding sequence, the rotary position embedding has no difference with modern LLMs.\n+            Examples:\n+                input_ids: [T T T T T], here T is for text.\n+                temporal position_ids: [0, 1, 2, 3, 4]\n+                height position_ids: [0, 1, 2, 3, 4]\n+                width position_ids: [0, 1, 2, 3, 4]\n+\n+            For vision and text embedding sequence, we calculate 3D rotary position embedding for vision part\n+            and 1D rotary position embedding for text part.\n+            Examples:\n+                Temporal (Time): 3 patches, representing different segments of the video in time.\n+                Height: 2 patches, dividing each frame vertically.\n+                Width: 2 patches, dividing each frame horizontally.\n+                We also have some important parameters:\n+                fps (Frames Per Second): The video's frame rate, set to 1. This means one frame is processed each second.\n+                tokens_per_second: This is a crucial parameter. It dictates how many \"time-steps\" or \"temporal tokens\" are conceptually packed into a one-second interval of the video. In this case, we have 25 tokens per second. So each second of the video will be represented with 25 separate time points. It essentially defines the temporal granularity.\n+                temporal_patch_size: The number of frames that compose one temporal patch. Here, it's 2 frames.\n+                interval: The step size for the temporal position IDs, calculated as tokens_per_second * temporal_patch_size / fps. In this case, 25 * 2 / 1 = 50. This means that each temporal patch will be have a difference of 50 in the temporal position IDs.\n+                input_ids: [V V V V V V V V V V V V T T T T T], here V is for vision.\n+                vision temporal position_ids: [0, 0, 0, 0, 50, 50, 50, 50, 100, 100, 100, 100]\n+                vision height position_ids: [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]\n+                vision width position_ids: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n+                text temporal position_ids: [101, 102, 103, 104, 105]\n+                text height position_ids: [101, 102, 103, 104, 105]\n+                text width position_ids: [101, 102, 103, 104, 105]\n+                Here we calculate the text start position_ids as the max vision position_ids plus 1.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+                it.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+            mm_token_type_ids (`torch.IntTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Token type ids matching each modality to a different value in the input sequence, i.e. text (0), image (1), video (2).\n+\n+        Returns:\n+            position_ids (`torch.LongTensor` of shape `(3, batch_size, sequence_length)`)\n+            mrope_position_deltas (`torch.Tensor` of shape `(batch_size)`)\n+        \"\"\"\n+\n+        temporal_merge_size = self.config.vision_config.temporal_merge_size\n+        spatial_merge_size = self.config.vision_config.spatial_merge_size\n+\n+        mrope_position_deltas = []\n+        if input_ids is not None and (image_grid_thw is not None or video_grid_thw is not None):\n+            total_input_ids = input_ids\n+            if attention_mask is None:\n+                attention_mask = torch.ones_like(total_input_ids)\n+            position_ids = torch.ones(\n+                3,\n+                input_ids.shape[0],\n+                input_ids.shape[1],\n+                dtype=input_ids.dtype,\n+                device=input_ids.device,\n+            )\n+            image_index, video_index = 0, 0\n+            attention_mask = attention_mask.to(total_input_ids.device)\n+            for i, input_ids in enumerate(total_input_ids):\n+                # If we don't have `mm_token_type_ids`, then we have text tokens only (== 0)\n+                if mm_token_type_ids is None:\n+                    input_token_type = torch.zeros_like(input_ids)[attention_mask[i] == 1].tolist()\n+                else:\n+                    input_token_type = mm_token_type_ids[i, attention_mask[i] == 1].tolist()\n+\n+                input_type_group = []\n+                for key, group in itertools.groupby(enumerate(input_token_type), lambda x: x[1]):\n+                    group = list(group)\n+                    start_index = group[0][0]\n+                    end_index = group[-1][0] + 1\n+                    input_type_group.append((key, start_index, end_index))\n+\n+                llm_pos_ids_list = []\n+                for modality_type, start_idx, end_idx in input_type_group:\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+\n+                    # text == 0\n+                    if modality_type == 0:\n+                        text_len = end_idx - start_idx\n+                        llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                    # image == 1, video == 2\n+                    else:\n+                        grid_thw = image_grid_thw if modality_type == 1 else video_grid_thw\n+                        mm_index = image_index if modality_type == 1 else video_index\n+                        t_merge_size = 1 if modality_type == 1 else temporal_merge_size\n+\n+                        t, h, w = (\n+                            grid_thw[mm_index][0],\n+                            grid_thw[mm_index][1],\n+                            grid_thw[mm_index][2],\n+                        )\n+                        llm_grid_t, llm_grid_h, llm_grid_w = (\n+                            t.item() // t_merge_size,\n+                            h.item() // spatial_merge_size,\n+                            w.item() // spatial_merge_size,\n+                        )\n+\n+                        for t_idx in range(llm_grid_t):\n+                            t_index = torch.tensor(t_idx).view(-1, 1).expand(-1, llm_grid_h * llm_grid_w).flatten()\n+                            h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(1, -1, llm_grid_w).flatten()\n+                            w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(1, llm_grid_h, -1).flatten()\n+                            llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + st_idx)\n+\n+                        if modality_type == 1:\n+                            image_index += 1\n+                        else:\n+                            video_index += 1\n+\n+                llm_positions = torch.cat(llm_pos_ids_list, dim=1).reshape(3, -1)\n+                position_ids[..., i, attention_mask[i] == 1] = llm_positions.to(position_ids.device)\n+                mrope_position_deltas.append(llm_positions.max() + 1 - len(total_input_ids[i]))\n+            mrope_position_deltas = torch.tensor(mrope_position_deltas, device=input_ids.device).unsqueeze(1)\n+            return position_ids, mrope_position_deltas\n+        else:\n+            if attention_mask is not None:\n+                position_ids = attention_mask.long().cumsum(-1) - 1\n+                position_ids.masked_fill_(attention_mask == 0, 1)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1).to(attention_mask.device)\n+                max_position_ids = position_ids.max(0, keepdim=False)[0].max(-1, keepdim=True)[0]\n+                mrope_position_deltas = max_position_ids + 1 - attention_mask.shape[-1]\n+            else:\n+                position_ids = (\n+                    torch.arange(input_ids.shape[1], device=input_ids.device)\n+                    .view(1, 1, -1)\n+                    .expand(3, input_ids.shape[0], -1)\n+                )\n+                mrope_position_deltas = torch.zeros(\n+                    [input_ids.shape[0], 1],\n+                    device=input_ids.device,\n+                    dtype=input_ids.dtype,\n+                )\n+\n+            return position_ids, mrope_position_deltas\n+\n+    def get_video_features(\n+        self, pixel_values_videos: torch.FloatTensor, video_grid_thw: Optional[torch.LongTensor] = None\n+    ):\n+        \"\"\"\n+        Encodes videos into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values_videos (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input videos.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+        \"\"\"\n+        video_embeds = self.vision_tower(pixel_values_videos, video_grid_thw)\n+        video_embeds = self.resampler_model(video_embeds, video_grid_thw)\n+        split_sizes = (\n+            video_grid_thw.prod(-1)\n+            // self.vision_tower.spatial_merge_size**2\n+            // self.resampler_model.temporal_merge_size\n+        ).tolist()\n+        video_embeds = torch.split(video_embeds, split_sizes)\n+        return video_embeds\n+\n+    def get_image_features(self, pixel_values: torch.FloatTensor, image_grid_thw: Optional[torch.LongTensor] = None):\n+        \"\"\"\n+        Encodes images into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input images.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        image_embeds = self.vision_tower(pixel_values, image_grid_thw)\n+        image_embeds = self.resampler_model(image_embeds, image_grid_thw)\n+        split_sizes = (image_grid_thw.prod(-1) // self.vision_tower.spatial_merge_size**2).tolist()\n+        image_embeds = torch.split(image_embeds, split_sizes)\n+        return image_embeds\n+\n+    @auto_docstring\n+    @can_return_tuple\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        mm_token_type_ids: Optional[torch.IntTensor] = None,\n+        moe_mm_token_type_ids: Optional[torch.IntTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, MoeModelOutputWithPast]:\n+        r\"\"\"\n+        mm_token_type_ids (`torch.IntTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Token type ids matching each modality to a different value in the input sequence, i.e. text (0), image (1), video (2).\n+        moe_mm_token_type_ids (`torch.IntTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            The same as `mm_token_type_ids` while additionally considering start/end image/video tokens as respective vision tokens.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+        \"\"\"\n+        if inputs_embeds is None:\n+            inputs_embeds = self.get_input_embeddings()(input_ids)\n+\n+        if pixel_values is not None:\n+            image_embeds = self.get_image_features(pixel_values, image_grid_thw)\n+            image_embeds = torch.cat(image_embeds, dim=0).to(inputs_embeds.device, inputs_embeds.dtype)\n+            image_mask, _ = self.get_placeholder_mask(\n+                input_ids, inputs_embeds=inputs_embeds, image_features=image_embeds\n+            )\n+            inputs_embeds = inputs_embeds.masked_scatter(image_mask, image_embeds)\n+\n+        if pixel_values_videos is not None:\n+            video_embeds = self.get_video_features(pixel_values_videos, video_grid_thw)\n+            video_embeds = torch.cat(video_embeds, dim=0).to(inputs_embeds.device, inputs_embeds.dtype)\n+            _, video_mask = self.get_placeholder_mask(\n+                input_ids, inputs_embeds=inputs_embeds, video_features=video_embeds\n+            )\n+            inputs_embeds = inputs_embeds.masked_scatter(video_mask, video_embeds)\n+\n+        if position_ids is None:\n+            position_ids = self.get_position_ids(\n+                input_ids=input_ids,\n+                attention_mask=attention_mask,\n+                past_key_values=past_key_values,\n+                inputs_embeds=inputs_embeds,\n+                image_grid_thw=image_grid_thw,\n+                video_grid_thw=video_grid_thw,\n+                cache_position=cache_position,\n+                mm_token_type_ids=mm_token_type_ids,\n+            )\n+\n+        outputs = self.language_model(\n+            input_ids=None,\n+            position_ids=position_ids,\n+            moe_mm_token_type_ids=moe_mm_token_type_ids,\n+            attention_mask=attention_mask,\n+            use_cache=use_cache,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            return_dict=True,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        return MoeModelOutputWithPast(\n+            last_hidden_state=outputs.last_hidden_state,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            router_logits=outputs.router_logits,\n+        )\n+\n+\n+class Ernie4_5_VL_MoeForConditionalGeneration(Glm4vForConditionalGeneration, GenerationMixin):\n+    _checkpoint_conversion_mapping = {\"^model.norm\": \"model.language_model.norm\"}\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+\n+        self.router_aux_loss_coef = config.text_config.router_aux_loss_coef\n+        self.num_experts = config.text_config.moe_num_experts\n+        self.num_experts_per_tok = config.text_config.moe_k\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        inputs_embeds=None,\n+        attention_mask=None,\n+        cache_position=None,\n+        past_key_values=None,\n+        image_grid_thw=None,\n+        video_grid_thw=None,\n+        # Intentionally ignore position ids to force custom cache logic\n+        position_ids=None,\n+        **kwargs,\n+    ):\n+        model_inputs = super().prepare_inputs_for_generation(\n+            input_ids,\n+            inputs_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            **kwargs,\n+        )\n+\n+        # Using our own caching with rope delta\n+        model_inputs[\"position_ids\"] = self.model.get_position_ids(\n+            input_ids=model_inputs.get(\"input_ids\"),\n+            attention_mask=model_inputs.get(\"attention_mask\"),\n+            past_key_values=model_inputs.get(\"past_key_values\"),\n+            inputs_embeds=model_inputs.get(\"inputs_embeds\"),\n+            image_grid_thw=model_inputs.get(\"image_grid_thw\"),\n+            video_grid_thw=model_inputs.get(\"video_grid_thw\"),\n+            cache_position=model_inputs.get(\"cache_position\"),\n+            mm_token_type_ids=model_inputs.get(\"mm_token_type_ids\"),\n+        )\n+\n+        if model_inputs[\"cache_position\"][0] != 0:\n+            model_inputs[\"pixel_values\"] = None\n+            model_inputs[\"pixel_values_videos\"] = None\n+            model_inputs[\"mm_token_type_ids\"] = None\n+            model_inputs[\"moe_mm_token_type_ids\"] = None\n+\n+        return model_inputs\n+\n+    @auto_docstring\n+    @can_return_tuple\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        mm_token_type_ids: Optional[torch.IntTensor] = None,\n+        moe_mm_token_type_ids: Optional[torch.IntTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_router_logits: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, MoeCausalLMOutputWithPast]:\n+        r\"\"\"\n+        mm_token_type_ids (`torch.IntTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Token type ids matching each modality to a different value in the input sequence, i.e. text (0), image (1), video (2).\n+        moe_mm_token_type_ids (`torch.IntTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            The same as `mm_token_type_ids` while additionally considering start/end image/video tokens as respective vision tokens.\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+        \"\"\"\n+        output_router_logits = (\n+            output_router_logits if output_router_logits is not None else self.config.text_config.output_router_logits\n+        )\n+\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            mm_token_type_ids=mm_token_type_ids,\n+            moe_mm_token_type_ids=moe_mm_token_type_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_router_logits=output_router_logits,\n+            return_dict=True,\n+            pixel_values=pixel_values,\n+            pixel_values_videos=pixel_values_videos,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            rope_deltas=rope_deltas,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs.last_hidden_state\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits=logits, labels=labels, vocab_size=self.config.text_config.vocab_size)\n+\n+        aux_loss = None\n+        if output_router_logits:\n+            aux_loss = load_balancing_loss_func(\n+                outputs.router_logits,\n+                self.num_experts,\n+                self.num_experts_per_tok,\n+                attention_mask,\n+            )\n+            if labels is not None:\n+                loss += self.router_aux_loss_coef * aux_loss.to(loss.device)  # make sure to reside in the same device\n+\n+        return MoeCausalLMOutputWithPast(\n+            loss=loss,\n+            aux_loss=aux_loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            router_logits=outputs.router_logits,\n+        )\n+\n+\n+class Ernie4_5_VL_MoeImageProcessorKwargs(Glm4vImageProcessorKwargs):\n+    r\"\"\"\n+    patch_size (`int`, *optional*, defaults to 14):\n+        The spatial patch size of the vision encoder.\n+    temporal_patch_size (`int`, *optional*):\n+        The temporal patch size of the vision encoder. Unused in the image processor, only used for videos.\n+    merge_size (`int`, *optional*, defaults to 2):\n+        The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+\n+class Ernie4_5_VL_MoeImageProcessor(Glm4vImageProcessor):\n+    r\"\"\"\n+    Constructs a Ernie 4.5 VL image processor that dynamically resizes images based on the original images.\n+\n+    Args:\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image's (height, width) dimensions.\n+        size (`dict[str, int]`, *optional*, defaults to `{\"shortest_edge\": 56 * 56, \"longest_edge\": 28 * 28 * 6177}`):\n+            Size of the image after resizing. `shortest_edge` and `longest_edge` keys must be present.\n+        resample (`PILImageResampling`, *optional*, defaults to `Resampling.BICUBIC`):\n+            Resampling filter to use when resizing the image.\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image by the specified scale `rescale_factor`.\n+        rescale_factor (`int` or `float`, *optional*, defaults to `1/255`):\n+            Scale factor to use if rescaling the image.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image.\n+        image_mean (`float` or `list[float]`, *optional*, defaults to `[0.48145466, 0.4578275, 0.40821073]`):\n+            Mean to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        image_std (`float` or `list[float]`, *optional*, defaults to `[0.26862954, 0.26130258, 0.27577711]`):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats for each channel\n+            in the image.\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spatial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*):\n+            The temporal patch size of the vision encoder. Unused in the image processor, only used for videos.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        do_resize: bool = True,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = PILImageResampling.BICUBIC,\n+        do_rescale: bool = True,\n+        rescale_factor: Union[int, float] = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        do_convert_rgb: bool = True,\n+        patch_size: int = 14,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: int = 2,\n+        **kwargs,\n+    ) -> None:\n+        BaseImageProcessor.__init__(**kwargs)\n+        if size is not None:\n+            if \"shortest_edge\" not in size or \"longest_edge\" not in size:\n+                raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+            size = {\"shortest_edge\": size[\"shortest_edge\"], \"longest_edge\": size[\"longest_edge\"]}\n+        else:\n+            size = {\"shortest_edge\": 56 * 56, \"longest_edge\": 6177 * 28 * 28}\n+        self.size = size\n+\n+        self.do_resize = do_resize\n+        self.resample = resample\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean if image_mean is not None else OPENAI_CLIP_MEAN\n+        self.image_std = image_std if image_std is not None else OPENAI_CLIP_STD\n+\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.merge_size = merge_size\n+        self.do_convert_rgb = do_convert_rgb\n+\n+    def _preprocess(\n+        self,\n+        images: ImageInput,\n+        do_resize: Optional[bool] = None,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = None,\n+        do_rescale: Optional[bool] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        do_convert_rgb: Optional[bool] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n+\n+        Args:\n+            images (`ImageInput`):\n+                Image or batch of images to preprocess. Expects pixel values ranging from 0 to 255. If pixel values range from 0 to 1, set `do_rescale=False`.\n+            vision_info (`list[Dict]`, *optional*):\n+                Optional list of dictionaries containing additional information about vision inputs.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. `shortest_edge` and `longest_edge` keys must be present.\n+            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the `PILImageResampling` enums.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Scale factor to use if rescaling the image.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `list[float]`, *optional*, defaults to `self.image_mean`):\n+                Mean to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            image_std (`float` or `list[float]`, *optional*, defaults to `self.image_std`):\n+                Standard deviation to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            patch_size (`int`, *optional*, defaults to `self.patch_size`):\n+                The spatial patch size of the vision encoder.\n+            temporal_patch_size (`int`, *optional*):\n+                The temporal patch size of the vision encoder. Unused in the image processor, only used for videos.\n+            merge_size (`int`, *optional*, defaults to `self.merge_size`):\n+                The merge size of the vision encoder to llm encoder.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            data_format (`ChannelDimension`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.   - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+        images = make_list_of_images(images)\n+\n+        if do_convert_rgb:\n+            images = [convert_to_rgb(image) for image in images]\n+\n+        # All transformations expect numpy arrays.\n+        images = [to_numpy_array(image) for image in images]\n+\n+        if do_rescale and is_scaled_image(images[0]):\n+            logger.warning_once(\n+                \"It looks like you are trying to rescale already rescaled images. If the input\"\n+                \" images have pixel values between 0 and 1, set `do_rescale=False` to avoid rescaling them again.\"\n+            )\n+        if input_data_format is None:\n+            # We assume that all images have the same channel dimension format.\n+            input_data_format = infer_channel_dimension_format(images[0])\n+\n+        height, width = get_image_size(images[0], channel_dim=input_data_format)\n+        resized_height, resized_width = height, width\n+        processed_images = []\n+        for image in images:\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    height,\n+                    width,\n+                    factor=patch_size * merge_size,\n+                    min_pixels=size[\"shortest_edge\"],\n+                    max_pixels=size[\"longest_edge\"],\n+                )\n+                image = resize(\n+                    image, size=(resized_height, resized_width), resample=resample, input_data_format=input_data_format\n+                )\n+\n+            if do_rescale:\n+                image = self.rescale(image, scale=rescale_factor, input_data_format=input_data_format)\n+\n+            if do_normalize:\n+                image = self.normalize(\n+                    image=image, mean=image_mean, std=image_std, input_data_format=input_data_format\n+                )\n+\n+            image = to_channel_dimension_format(image, data_format, input_channel_dim=input_data_format)\n+            processed_images.append(image)\n+\n+        patches = np.array(processed_images)\n+        if data_format == ChannelDimension.LAST:\n+            patches = patches.transpose([0, 3, 1, 2])\n+\n+        # Main difference to Qwen2 VL - no temporal patches\n+        channel = patches.shape[1]\n+        grid_t = patches.shape[0]\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+        patches = patches.reshape(\n+            [\n+                grid_t,\n+                channel,\n+                grid_h // merge_size,\n+                merge_size,\n+                patch_size,\n+                grid_w // merge_size,\n+                merge_size,\n+                patch_size,\n+            ]\n+        )\n+        # [grid_t, grid_h/merge, grid_w/merge, merge, merge, channel, patch, patch]\n+        patches = patches.transpose([0, 2, 5, 3, 6, 1, 4, 7])\n+        flatten_patches = patches.reshape(grid_t * grid_h * grid_w, channel * patch_size * patch_size)\n+\n+        return flatten_patches, (grid_t, grid_h, grid_w)\n+\n+    def get_number_of_image_patches(self, height: int, width: int, images_kwargs=None):\n+        \"\"\"\n+        A utility that returns number of image patches for a given image size.\n+\n+        Args:\n+            height (`int`):\n+                Height of the input image.\n+            width (`int`):\n+                Width of the input image.\n+            images_kwargs (`dict`, *optional*)\n+                Any kwargs to override defaults of the image processor.\n+        Returns:\n+            `int`: Number of image patches per image.\n+        \"\"\"\n+        min_pixels = self.size[\"shortest_edge\"]\n+        max_pixels = self.size[\"longest_edge\"]\n+        patch_size = images_kwargs.get(\"patch_size\", self.patch_size)\n+        merge_size = images_kwargs.get(\"merge_size\", self.merge_size)\n+\n+        factor = patch_size * merge_size\n+        resized_height, resized_width = smart_resize(\n+            height, width, factor, min_pixels=min_pixels, max_pixels=max_pixels\n+        )\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+        return grid_h * grid_w\n+\n+\n+class Ernie4_5_VL_MoeImageProcessorFast(Glm4vImageProcessorFast):\n+    size = {\"shortest_edge\": 56 * 56, \"longest_edge\": 28 * 28 * 6177}\n+    temporal_patch_size = None  # Unused\n+\n+    def _preprocess(\n+        self,\n+        images: list[\"torch.Tensor\"],\n+        do_resize: bool,\n+        size: SizeDict,\n+        interpolation: Optional[\"F.InterpolationMode\"],\n+        do_rescale: bool,\n+        rescale_factor: float,\n+        do_normalize: bool,\n+        image_mean: Optional[Union[float, list[float]]],\n+        image_std: Optional[Union[float, list[float]]],\n+        patch_size: int,\n+        merge_size: int,\n+        disable_grouping: Optional[bool],\n+        return_tensors: Optional[Union[str, TensorType]],\n+        **kwargs,\n+    ):\n+        # Group images by size for batched resizing\n+        grouped_images, grouped_images_index = group_images_by_shape(images, disable_grouping=disable_grouping)\n+        resized_images_grouped = {}\n+        for shape, stacked_images in grouped_images.items():\n+            height, width = stacked_images.shape[-2:]\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    height,\n+                    width,\n+                    factor=patch_size * merge_size,\n+                    min_pixels=size[\"shortest_edge\"],\n+                    max_pixels=size[\"longest_edge\"],\n+                )\n+                stacked_images = self.resize(\n+                    image=stacked_images,\n+                    size=SizeDict(height=resized_height, width=resized_width),\n+                    interpolation=interpolation,\n+                )\n+            resized_images_grouped[shape] = stacked_images\n+        resized_images = reorder_images(resized_images_grouped, grouped_images_index)\n+\n+        # Group images by size for further processing\n+        # Needed in case do_resize is False, or resize returns images with different sizes\n+        grouped_images, grouped_images_index = group_images_by_shape(resized_images, disable_grouping=disable_grouping)\n+        processed_images_grouped = {}\n+        processed_grids = {}\n+        for shape, stacked_images in grouped_images.items():\n+            resized_height, resized_width = stacked_images.shape[-2:]\n+            # Fused rescale and normalize\n+            patches = self.rescale_and_normalize(\n+                stacked_images, do_rescale, rescale_factor, do_normalize, image_mean, image_std\n+            )\n+            if patches.ndim == 4:\n+                # add a temporal dimension if we have images\n+                patches = patches.unsqueeze(1)\n+\n+            # Main difference to Qwen2 VL - no temporal patches\n+            batch_size, grid_t, channel = patches.shape[:3]\n+            grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+\n+            patches = patches.view(\n+                batch_size,\n+                grid_t,\n+                channel,\n+                grid_h // merge_size,\n+                merge_size,\n+                patch_size,\n+                grid_w // merge_size,\n+                merge_size,\n+                patch_size,\n+            )\n+            # Reorder dimensions to group grid and patch information for subsequent flattening.\n+            # [batch, grid_t, grid_h/merge, grid_w/merge, merge, merge, channel, patch, patch]\n+            patches = patches.permute(0, 1, 3, 6, 4, 7, 2, 5, 8)\n+\n+            flatten_patches = patches.reshape(\n+                batch_size,\n+                grid_t * grid_h * grid_w,\n+                channel * patch_size * patch_size,\n+            )\n+\n+            processed_images_grouped[shape] = flatten_patches\n+            processed_grids[shape] = [[grid_t, grid_h, grid_w]] * batch_size\n+\n+        processed_images = reorder_images(processed_images_grouped, grouped_images_index)\n+        processed_grids = reorder_images(processed_grids, grouped_images_index)\n+        pixel_values = torch.cat(processed_images, dim=0)\n+        image_grid_thw = torch.tensor(processed_grids)\n+\n+        return BatchFeature(\n+            data={\"pixel_values\": pixel_values, \"image_grid_thw\": image_grid_thw}, tensor_type=return_tensors\n+        )\n+\n+    def get_number_of_image_patches(self, height: int, width: int, images_kwargs=None):\n+        \"\"\"\n+        A utility that returns number of image patches for a given image size.\n+\n+        Note: Do not remove this method! It is used by vLLM to infer the number of patches and placeholders\n+        without an image input.\n+\n+        Args:\n+            height (`int`):\n+                Height of the input image.\n+            width (`int`):\n+                Width of the input image.\n+            images_kwargs (`dict`, *optional*)\n+                Any kwargs to override defaults of the image processor.\n+        Returns:\n+            `int`: Number of image patches per image.\n+        \"\"\"\n+        min_pixels = self.size[\"shortest_edge\"]\n+        max_pixels = self.size[\"longest_edge\"]\n+        patch_size = images_kwargs.get(\"patch_size\", self.patch_size)\n+        merge_size = images_kwargs.get(\"merge_size\", self.merge_size)\n+\n+        factor = patch_size * merge_size\n+        resized_height, resized_width = smart_resize(\n+            height, width, factor, min_pixels=min_pixels, max_pixels=max_pixels\n+        )\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+        return grid_h * grid_w\n+\n+\n+__all__ = [\n+    \"Ernie4_5_VL_MoeConfig\",\n+    \"Ernie4_5_VL_MoeTextConfig\",\n+    \"Ernie4_5_VL_MoeVisionConfig\",\n+    \"Ernie4_5_VL_MoePreTrainedModel\",\n+    \"Ernie4_5_VL_MoeForConditionalGeneration\",\n+    \"Ernie4_5_VL_MoeModel\",\n+    \"Ernie4_5_VL_MoeTextModel\",\n+    \"Ernie4_5_VL_MoeVisionTransformerPretrainedModel\",\n+    \"Ernie4_5_VL_MoeVariableResolutionResamplerModel\",\n+    \"Ernie4_5_VL_MoeImageProcessor\",\n+    \"Ernie4_5_VL_MoeImageProcessorFast\",\n+]"
        },
        {
            "sha": "f76a4a25750de153bc10376185eb34c5d954e12f",
            "filename": "src/transformers/models/ernie4_5_vl_moe/processing_ernie4_5_vl_moe.py",
            "status": "added",
            "additions": 251,
            "deletions": 0,
            "changes": 251,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fprocessing_ernie4_5_vl_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fprocessing_ernie4_5_vl_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fprocessing_ernie4_5_vl_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,251 @@\n+# coding=utf-8\n+# Copyright 2025 Baidu and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import os.path\n+from pathlib import Path\n+from shutil import SameFileError, copyfile\n+from typing import Optional, Union\n+\n+import numpy as np\n+\n+from ...image_processing_utils import BatchFeature\n+from ...image_utils import ImageInput\n+from ...processing_utils import MultiModalData, ProcessingKwargs, ProcessorMixin, Unpack\n+from ...tokenization_utils_base import PreTokenizedInput, TextInput\n+from ...video_utils import VideoInput\n+\n+\n+class Ernie4_5_VL_MoeProcessorKwargs(ProcessingKwargs, total=False):\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": False,\n+            \"return_token_type_ids\": False,\n+            \"return_mm_token_type_ids\": True,\n+        },\n+    }\n+\n+\n+class Ernie4_5_VL_MoeProcessor(ProcessorMixin):\n+    r\"\"\"\n+    Constructs a Ernie 4.5 VL processor which wraps a Ernie 4.5 VL image processor and a Llama tokenizer into a single processor.\n+    [`Ernie4_5_VL_MoeProcessor`] offers all the functionalities of [`Ernie4_5_VL_MoeImageProcessor`] and [`LlamaTokenizerFast`]. See the\n+    [`~Ernie4_5_VL_MoeProcessor.__call__`] and [`~Ernie4_5_VL_MoeProcessor.decode`] for more information.\n+    Args:\n+        image_processor ([`Ernie4_5_VL_MoeImageProcessor`], *optional*):\n+            The image processor is a required input.\n+        tokenizer ([`LlamaTokenizerFast`], *optional*):\n+            The tokenizer is a required input.\n+        video_processor ([`Ernie4_5_VL_MoeVideoProcessor`], *optional*):\n+            The video processor is a required input.\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    def __init__(self, image_processor=None, tokenizer=None, video_processor=None, chat_template=None, **kwargs):\n+        self.image_token = tokenizer.image_token\n+        self.image_end_token = tokenizer.image_end_token\n+        self.image_start_token = tokenizer.image_start_token\n+        self.video_token = tokenizer.video_token\n+        self.video_end_token = tokenizer.video_end_token\n+        self.video_start_token = tokenizer.video_start_token\n+\n+        self.image_token_id = tokenizer.image_token_id\n+        self.image_end_token_id = tokenizer.image_end_token_id\n+        self.image_start_token_id = tokenizer.image_start_token_id\n+        self.video_token_id = tokenizer.video_token_id\n+        self.video_end_token_id = tokenizer.video_end_token_id\n+        self.video_start_token_id = tokenizer.video_start_token_id\n+\n+        super().__init__(image_processor, tokenizer, video_processor, chat_template=chat_template)\n+\n+    def save_pretrained(self, save_directory, push_to_hub: bool = False, **kwargs):\n+        \"\"\"We additionally save a copy of the font to the `save_directory` (if we found a file there)\"\"\"\n+        os.makedirs(save_directory, exist_ok=True)\n+\n+        if os.path.isfile(self.video_processor.font):\n+            try:\n+                copyfile(self.video_processor.font, Path(save_directory, Path(self.video_processor.font).name))\n+            except SameFileError:  # already exists which we allow (copy if needed)\n+                pass\n+\n+        return super().save_pretrained(save_directory, push_to_hub, **kwargs)\n+\n+    def __call__(\n+        self,\n+        images: Optional[ImageInput] = None,\n+        text: Union[TextInput, PreTokenizedInput, list[TextInput], list[PreTokenizedInput]] = None,\n+        videos: Optional[VideoInput] = None,\n+        **kwargs: Unpack[Ernie4_5_VL_MoeProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`\n+        and `kwargs` arguments to Qwen2TokenizerFast's [`~Qwen2TokenizerFast.__call__`] if `text` is not `None` to encode\n+        the text. To prepare the vision inputs, this method forwards the `vision_infos` and `kwargs` arguments to\n+        Ernie4_5_VL_MoeImageProcessor's [`~Ernie4_5_VL_MoeImageProcessor.__call__`] if `vision_infos` is not `None`.\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `list[PIL.Image.Image]`, `list[np.ndarray]`, `list[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. Both channels-first and channels-last formats are supported.\n+            text (`str`, `list[str]`, `list[list[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            videos (`np.ndarray`, `torch.Tensor`, `list[np.ndarray]`, `list[torch.Tensor]`):\n+                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n+                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+            - **pixel_values_videos** -- Pixel values of videos to be fed to a model. Returned when `videos` is not `None`.\n+            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n+            - **video_grid_thw** -- List of video 3D grid in LLM. Returned when `videos` is not `None`.\n+            - **mm_token_type_ids** -- List of token type ids differentiating between image, video and text input.\n+              Returned when `text` is not `None`.\n+        \"\"\"\n+        output_kwargs = self._merge_kwargs(\n+            Ernie4_5_VL_MoeProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+\n+        image_inputs = videos_inputs = {}\n+        if images is not None:\n+            image_inputs = self.image_processor(images=images, **output_kwargs[\"images_kwargs\"])\n+            image_grid_thw = image_inputs[\"image_grid_thw\"]\n+\n+        if videos is not None:\n+            videos_inputs = self.video_processor(videos=videos, **output_kwargs[\"videos_kwargs\"])\n+            video_grid_thw = videos_inputs[\"video_grid_thw\"]\n+\n+        if not isinstance(text, list):\n+            text = [text]\n+\n+        text = text.copy()  # below lines change text in-place\n+\n+        if images is not None:\n+            merge_length = self.image_processor.merge_size**2\n+            index = 0\n+            for i in range(len(text)):\n+                while self.image_token in text[i]:\n+                    num_image_tokens = image_grid_thw[index].prod() // merge_length\n+                    text[i] = text[i].replace(self.image_token, \"<|placeholder|>\" * num_image_tokens, 1)\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.image_token)\n+\n+        if videos is not None:\n+            merge_length = self.video_processor.merge_size**2 * self.video_processor.temporal_patch_size\n+            index = 0\n+            for i in range(len(text)):\n+                while self.video_token in text[i]:\n+                    num_video_tokens = video_grid_thw[index].prod() // merge_length\n+                    text[i] = text[i].replace(self.video_token, \"<|placeholder|>\" * num_video_tokens, 1)\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.video_token)\n+\n+        return_tensors = output_kwargs[\"text_kwargs\"].pop(\"return_tensors\", None)\n+        return_mm_token_type_ids = output_kwargs[\"text_kwargs\"].pop(\"return_mm_token_type_ids\", False)\n+        text_inputs = self.tokenizer(text, **output_kwargs[\"text_kwargs\"], return_tensors=None)\n+        self._check_special_mm_tokens(text, text_inputs, modalities=[\"image\", \"video\"])\n+\n+        if return_mm_token_type_ids:\n+            array_ids = np.array(text_inputs[\"input_ids\"])\n+\n+            mm_token_type_ids = np.zeros_like(text_inputs[\"input_ids\"])  # text\n+            mm_token_type_ids[array_ids == self.image_token_id] = 1  # img\n+            mm_token_type_ids[array_ids == self.video_token_id] = 2  # vid\n+\n+            # moe additionally adds start/end tokens\n+            moe_mm_token_type_ids = np.copy(mm_token_type_ids)\n+            for token_id in [\n+                self.image_start_token_id,\n+                self.image_end_token_id,\n+            ]:\n+                moe_mm_token_type_ids[array_ids == token_id] = 1\n+            for token_id in [\n+                self.video_start_token_id,\n+                self.video_end_token_id,\n+            ]:\n+                moe_mm_token_type_ids[array_ids == token_id] = 2\n+\n+            # convert to base type\n+            text_inputs[\"mm_token_type_ids\"] = mm_token_type_ids.astype(int).tolist()\n+            text_inputs[\"moe_mm_token_type_ids\"] = moe_mm_token_type_ids.astype(int).tolist()\n+\n+        return BatchFeature(data={**text_inputs, **image_inputs, **videos_inputs}, tensor_type=return_tensors)\n+\n+    @property\n+    def model_input_names(self):\n+        \"\"\"Additional `mm_token_type_ids` used for modality isolated MoE\"\"\"\n+        model_input_names = super().model_input_names\n+        model_input_names.append(\"mm_token_type_ids\")\n+        model_input_names.append(\"moe_mm_token_type_ids\")\n+        return model_input_names\n+\n+    def _get_num_multimodal_tokens(self, image_sizes=None, video_sizes=None, **kwargs):\n+        \"\"\"\n+        Computes the number of placeholder tokens needed for multimodal inputs with the given sizes.\n+        Args:\n+            image_sizes (`list[list[int]]`, *optional*):\n+                The input sizes formatted as (height, width) per each image.\n+            video_sizes (`list[list[int]]`, *optional*):\n+                The input sizes formatted as (num_frames, height, width) per each video.\n+        Returns:\n+            `MultiModalData`: A `MultiModalData` object holding number of tokens per each of the provided\n+            input modalities, along with other useful data.\n+        \"\"\"\n+\n+        vision_data = {}\n+        if image_sizes is not None:\n+            images_kwargs = Ernie4_5_VL_MoeProcessorKwargs._defaults.get(\"images_kwargs\", {})\n+            images_kwargs.update(kwargs)\n+            merge_size = images_kwargs.get(\"merge_size\", None) or self.image_processor.merge_size\n+\n+            num_image_patches = [\n+                self.image_processor.get_number_of_image_patches(*image_size, images_kwargs)\n+                for image_size in image_sizes\n+            ]\n+            num_image_tokens = [(num_patches // merge_size**2) for num_patches in num_image_patches]\n+            vision_data.update({\"num_image_tokens\": num_image_tokens, \"num_image_patches\": num_image_patches})\n+\n+        if video_sizes is not None:\n+            videos_kwargs = Ernie4_5_VL_MoeProcessorKwargs._defaults.get(\"videos_kwargs\", {})\n+            videos_kwargs.update(kwargs)\n+            temporal_merge_size = (\n+                videos_kwargs.get(\"temporal_patch_size\", None) or self.video_processor.temporal_patch_size\n+            )\n+\n+            num_video_patches = [\n+                self.video_processor.get_number_of_video_patches(*video_size, videos_kwargs)\n+                for video_size in video_sizes\n+            ]\n+            num_video_tokens = [\n+                (num_patches // merge_size**2 // temporal_merge_size) for num_patches in num_video_patches\n+            ]\n+            vision_data[\"num_video_tokens\"] = num_video_tokens\n+\n+        return MultiModalData(**vision_data)\n+\n+\n+__all__ = [\"Ernie4_5_VL_MoeProcessor\"]"
        },
        {
            "sha": "d312077345e871933beec31ef571ab43e3e929f7",
            "filename": "src/transformers/models/ernie4_5_vl_moe/video_processing_ernie4_5_vl_moe.py",
            "status": "added",
            "additions": 594,
            "deletions": 0,
            "changes": 594,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fvideo_processing_ernie4_5_vl_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fvideo_processing_ernie4_5_vl_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fernie4_5_vl_moe%2Fvideo_processing_ernie4_5_vl_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,594 @@\n+# coding=utf-8\n+# Copyright 2025 Baidu and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import os.path\n+from functools import partial\n+from pathlib import Path\n+from shutil import SameFileError, copyfile\n+from typing import Any, Optional, Union\n+\n+import numpy as np\n+import torch\n+from huggingface_hub import is_offline_mode\n+from huggingface_hub.dataclasses import validate_typed_dict\n+from PIL import ImageDraw, ImageFont\n+from torchvision.transforms.functional import pil_to_tensor, to_pil_image\n+\n+from ...image_processing_utils import BatchFeature\n+from ...image_utils import (\n+    OPENAI_CLIP_MEAN,\n+    OPENAI_CLIP_STD,\n+    ChannelDimension,\n+    PILImageResampling,\n+    SizeDict,\n+    get_image_size,\n+    validate_kwargs,\n+)\n+from ...processing_utils import Unpack, VideosKwargs\n+from ...utils import (\n+    IMAGE_PROCESSOR_NAME,\n+    PROCESSOR_NAME,\n+    VIDEO_PROCESSOR_NAME,\n+    TensorType,\n+    add_start_docstrings,\n+    logging,\n+    safe_load_json_file,\n+)\n+from ...utils.hub import cached_file\n+from ...utils.import_utils import is_tracing, requires\n+from ...video_processing_utils import BASE_VIDEO_PROCESSOR_DOCSTRING, BaseVideoProcessor\n+from ...video_utils import (\n+    VideoInput,\n+    VideoMetadata,\n+    group_videos_by_shape,\n+    infer_channel_dimension_format,\n+    reorder_videos,\n+)\n+from .image_processing_ernie4_5_vl_moe import smart_resize\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Ernie4_5_VL_MoeVideoProcessorInitKwargs(VideosKwargs, total=False):\n+    patch_size: int\n+    temporal_patch_size: int\n+    merge_size: int\n+    min_frames: int\n+    max_frames: int\n+    draw_on_frames: bool\n+    font: str\n+\n+\n+@add_start_docstrings(\n+    \"Constructs a fast Ernie 4.5 VL image processor that dynamically resizes videos based on the original videos.\",\n+    BASE_VIDEO_PROCESSOR_DOCSTRING,\n+    \"\"\"\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spacial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The temporal patch size of the vision encoder.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+        min_frames (`int`, *optional*, defaults to 16):\n+            The minimum number of frames that can be sampled.\n+        max_frames (`int`, *optional*, defaults to 180):\n+            The maximum number of frames that can be sampled.\n+        draw_on_frames (`bool`, *optional*, defaults to `True`):\n+            Whether to draw timestamps on each frame or not.\n+            This does not work with `torch.compile` but resembles\n+            the performance of the original model.\n+        font (`str`, *optional*, defaults to \"Roboto-Regular.ttf\"):\n+            The associated font name for drawing on frames.\n+            Defaults to \"Roboto-Regular.ttf\" and is expected to be\n+            saved along the processor as separate file.\n+    \"\"\",\n+)\n+@requires(backends=(\"torchvision\",))\n+class Ernie4_5_VL_MoeVideoProcessor(BaseVideoProcessor):\n+    resample = PILImageResampling.BICUBIC\n+    size = {\"shortest_edge\": 299 * 28 * 28, \"longest_edge\": 1196 * 28 * 28}\n+    image_mean = OPENAI_CLIP_MEAN\n+    image_std = OPENAI_CLIP_STD\n+    do_resize = True\n+    do_rescale = True\n+    do_normalize = True\n+    do_convert_rgb = True\n+    patch_size = 14\n+    temporal_patch_size = 2\n+    merge_size = 2\n+    min_frames = 16\n+    max_frames = 180\n+    do_sample_frames = True\n+    draw_on_frames = True\n+    font = \"Roboto-Regular.ttf\"\n+    valid_kwargs = Ernie4_5_VL_MoeVideoProcessorInitKwargs\n+    model_input_names = [\"pixel_values_videos\", \"video_grid_thw\"]\n+\n+    def __init__(self, **kwargs: Unpack[Ernie4_5_VL_MoeVideoProcessorInitKwargs]):\n+        temporal_patch_size = kwargs.get(\"temporal_patch_size\", 2)\n+        if temporal_patch_size is None or temporal_patch_size != 2:\n+            raise ValueError(\"`Ernie 4.5 VL` only supports a temporal patch size of 2\")\n+\n+        size = kwargs.pop(\"size\", None)\n+        size = self.size if size is None else size\n+        if \"shortest_edge\" not in size or \"longest_edge\" not in size:\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+\n+        super().__init__(size=size, **kwargs)\n+\n+    @classmethod\n+    def get_video_processor_dict(\n+        cls, pretrained_model_name_or_path: Union[str, os.PathLike], **kwargs\n+    ) -> tuple[dict[str, Any], dict[str, Any]]:\n+        \"\"\"Overriden to additionally load the font for drawing on frames.\"\"\"\n+        cache_dir = kwargs.pop(\"cache_dir\", None)\n+        force_download = kwargs.pop(\"force_download\", False)\n+        proxies = kwargs.pop(\"proxies\", None)\n+        token = kwargs.pop(\"token\", None)\n+        local_files_only = kwargs.pop(\"local_files_only\", False)\n+        revision = kwargs.pop(\"revision\", None)\n+        subfolder = kwargs.pop(\"subfolder\", \"\")\n+\n+        from_pipeline = kwargs.pop(\"_from_pipeline\", None)\n+        from_auto_class = kwargs.pop(\"_from_auto\", False)\n+\n+        user_agent = {\"file_type\": \"video processor\", \"from_auto_class\": from_auto_class}\n+        if from_pipeline is not None:\n+            user_agent[\"using_pipeline\"] = from_pipeline\n+\n+        if is_offline_mode() and not local_files_only:\n+            logger.info(\"Offline mode: forcing local_files_only=True\")\n+            local_files_only = True\n+\n+        pretrained_model_name_or_path = str(pretrained_model_name_or_path)\n+        is_local = os.path.isdir(pretrained_model_name_or_path)\n+        if os.path.isfile(pretrained_model_name_or_path):\n+            resolved_video_processor_file = pretrained_model_name_or_path\n+            resolved_processor_file = None\n+            is_local = True\n+        else:\n+            video_processor_file = VIDEO_PROCESSOR_NAME\n+            try:\n+                # Try to load with a new config name first and if not successful try with the old file name\n+                # NOTE: we save all processor configs as nested dict in PROCESSOR_NAME from v5, which is the standard\n+                resolved_processor_file = cached_file(\n+                    pretrained_model_name_or_path,\n+                    filename=PROCESSOR_NAME,\n+                    cache_dir=cache_dir,\n+                    force_download=force_download,\n+                    proxies=proxies,\n+                    local_files_only=local_files_only,\n+                    token=token,\n+                    user_agent=user_agent,\n+                    revision=revision,\n+                    subfolder=subfolder,\n+                    _raise_exceptions_for_missing_entries=False,\n+                )\n+                resolved_video_processor_files = [\n+                    resolved_file\n+                    for filename in [video_processor_file, IMAGE_PROCESSOR_NAME]\n+                    if (\n+                        resolved_file := cached_file(\n+                            pretrained_model_name_or_path,\n+                            filename=filename,\n+                            cache_dir=cache_dir,\n+                            force_download=force_download,\n+                            proxies=proxies,\n+                            local_files_only=local_files_only,\n+                            token=token,\n+                            user_agent=user_agent,\n+                            revision=revision,\n+                            subfolder=subfolder,\n+                            _raise_exceptions_for_missing_entries=False,\n+                        )\n+                    )\n+                    is not None\n+                ]\n+                resolved_video_processor_file = (\n+                    resolved_video_processor_files[0] if resolved_video_processor_files else None\n+                )\n+            except OSError:\n+                # Raise any OS error raise by `cached_file`. It will have a helpful error message adapted to\n+                # the original exception.\n+                raise\n+            except Exception:\n+                # For any other exception, we throw a generic error.\n+                raise OSError(\n+                    f\"Can't load video processor for '{pretrained_model_name_or_path}'. If you were trying to load\"\n+                    \" it from 'https://huggingface.co/models', make sure you don't have a local directory with the\"\n+                    f\" same name. Otherwise, make sure '{pretrained_model_name_or_path}' is the correct path to a\"\n+                    f\" directory containing a {video_processor_file} file\"\n+                )\n+\n+        # Load video_processor dict. Priority goes as (nested config if found -> video processor config -> image processor config)\n+        # We are downloading both configs because almost all models have a `processor_config.json` but\n+        # not all of these are nested. We need to check if it was saved recebtly as nested or if it is legacy style\n+        video_processor_dict = None\n+        if resolved_processor_file is not None:\n+            processor_dict = safe_load_json_file(resolved_processor_file)\n+            if \"video_processor\" in processor_dict:\n+                video_processor_dict = processor_dict[\"video_processor\"]\n+\n+        if resolved_video_processor_file is not None and video_processor_dict is None:\n+            video_processor_dict = safe_load_json_file(resolved_video_processor_file)\n+\n+        if video_processor_dict is None:\n+            raise OSError(\n+                f\"Can't load video processor for '{pretrained_model_name_or_path}'. If you were trying to load\"\n+                \" it from 'https://huggingface.co/models', make sure you don't have a local directory with the\"\n+                f\" same name. Otherwise, make sure '{pretrained_model_name_or_path}' is the correct path to a\"\n+                f\" directory containing a {video_processor_file} file\"\n+            )\n+\n+        # Specific to Ernie 4.5 VL Moe, we load the font file along the json (if we draw on frames)\n+        draws_on_frames = video_processor_dict.get(\"draw_on_frames\")\n+        if (font_name := video_processor_dict.get(\"font\")) is None and draws_on_frames:\n+            raise AttributeError(\n+                \"Expected a `font` to be saved when using `draw_on_frames` in Ernie 4.5 VL Moe; found nothing.\"\n+            )\n+        if font_name is not None and draws_on_frames:\n+            video_processor_dict[\"font\"] = cached_file(\n+                pretrained_model_name_or_path,\n+                filename=font_name,\n+                cache_dir=cache_dir,\n+                force_download=force_download,\n+                proxies=proxies,\n+                local_files_only=local_files_only,\n+                token=token,\n+                user_agent=user_agent,\n+                revision=revision,\n+                subfolder=subfolder,\n+                _raise_exceptions_for_missing_entries=False,\n+            )\n+            try:\n+                ImageFont.truetype(video_processor_dict[\"font\"])\n+            except (TypeError, OSError):\n+                raise OSError(\n+                    f\"Could not find an associated font file for {video_processor_dict['font']}. \"\n+                    \"Make sure to save a font file along for Ernie 4.5 VL Moe.\"\n+                )\n+\n+        if is_local:\n+            logger.info(f\"loading configuration file {resolved_video_processor_file}\")\n+        else:\n+            logger.info(\n+                f\"loading configuration file {video_processor_file} from cache at {resolved_video_processor_file}\"\n+            )\n+\n+        return video_processor_dict, kwargs\n+\n+    def to_dict(self) -> dict[str, Any]:\n+        \"\"\"Overriden to strip the prefix of the full path for the font, e.g. `tmp/folder/font.tff` -> `font.tff`\"\"\"\n+        output = super().to_dict()\n+\n+        if os.path.isfile(output.get(\"font\")):\n+            output[\"font\"] = Path(output[\"font\"]).name\n+        elif output.get(\"draw_on_frames\"):\n+            raise ValueError(\n+                f\"The video processor dict contains an invalid path to its font: {output['font']}. \"\n+                \"Please make sure to contain a valid path or disable `draw_on_frames`.\"\n+            )\n+\n+        return output\n+\n+    def save_pretrained(self, save_directory: Union[str, os.PathLike], push_to_hub: bool = False, **kwargs):\n+        \"\"\"We additionally save a copy of the font to the `save_directory` (if we found a file there)\"\"\"\n+        os.makedirs(save_directory, exist_ok=True)\n+\n+        if os.path.isfile(self.font):\n+            try:\n+                copyfile(self.font, Path(save_directory, Path(self.font).name))\n+            except SameFileError:  # already exists which we allow (copy if needed)\n+                pass\n+\n+        return super().save_pretrained(save_directory, push_to_hub, **kwargs)\n+\n+    def _further_process_kwargs(\n+        self,\n+        size: Optional[SizeDict] = None,\n+        **kwargs,\n+    ) -> dict:\n+        \"\"\"\n+        Update kwargs that need further processing before being validated\n+        Can be overridden by subclasses to customize the processing of kwargs.\n+        \"\"\"\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+\n+        return super()._further_process_kwargs(size=size, **kwargs)\n+\n+    def sample_frames(\n+        self,\n+        metadata: VideoMetadata,\n+        min_frames: Optional[int] = None,\n+        max_frames: Optional[int] = None,\n+        num_frames: Optional[int] = None,\n+        fps: Optional[Union[int, float]] = None,\n+        **kwargs,\n+    ):\n+        if fps is not None and num_frames is not None:\n+            raise ValueError(\"`num_frames` and `fps` are mutually exclusive arguments, please use only one!\")\n+\n+        num_frames = num_frames if num_frames is not None else self.num_frames\n+        min_frames = min_frames if min_frames is not None else self.min_frames\n+        max_frames = max_frames if max_frames is not None else self.max_frames\n+        total_num_frames = metadata.total_num_frames\n+\n+        if num_frames is not None:\n+            if num_frames < min_frames or num_frames > max_frames:\n+                raise ValueError(f\"`num_frames` must be {min_frames} <= x <= {max_frames}. Got {num_frames} instead.\")\n+        else:\n+            if fps is not None and (metadata is None or metadata.fps is None):\n+                raise ValueError(\n+                    \"Asked to sample `fps` frames per second but no video metadata was provided which is required when sampling with `fps`. \"\n+                    \"Please pass in `VideoMetadata` object or use a fixed `num_frames` per input video\"\n+                )\n+            num_frames = total_num_frames / metadata.fps * fps if fps is not None else total_num_frames\n+            num_frames = min(max(num_frames, min_frames), max_frames, total_num_frames)\n+\n+        if num_frames > total_num_frames:\n+            raise ValueError(\n+                f\"Video can't be sampled. The inferred `num_frames={num_frames}` exceeds `total_num_frames={total_num_frames}`. \"\n+                \"Decrease `num_frames` or `fps` for sampling.\"\n+            )\n+\n+        indices = torch.arange(0, total_num_frames, total_num_frames / num_frames).int()\n+\n+        return indices\n+\n+    def _convert_timestamp(self, time_stamp_in_seconds):\n+        \"\"\"Convert to `time: hr:min:sec` format\"\"\"\n+        hours = time_stamp_in_seconds // 3600\n+        time_stamp_in_seconds = time_stamp_in_seconds % 3600\n+        mins = time_stamp_in_seconds // 60\n+        time_stamp_in_seconds = time_stamp_in_seconds % 60\n+        return f\"time: {int(hours):02d}:{int(mins):02d}:{time_stamp_in_seconds:05.02f}\"\n+\n+    def _render_image_with_timestamp(self, image: torch.Tensor, timestamp: str, size_factor: float = 0.1):\n+        \"\"\"Draws a black timestamp with a white border on the corner of the frame\"\"\"\n+        if self.font is None:\n+            raise AttributeError(\"To draw on frames with Ernie 4.5 VL, you need an associated font; found nothing\")\n+\n+        # FIXME: conversion `torch->PIL->torch` is inefficient ~6ms per frame\n+        # Left for optimization if anyone want to pick it up\n+        #\n+        # This can take up to ~1s in preprocessing (if default sampling is used):\n+        #   180 (frames) x 6ms = 1080ms = ~1,1s\n+        image = to_pil_image(image)\n+\n+        font_size = int(min(*image.size) * size_factor)\n+        outline_size = int(font_size * size_factor)\n+        font = ImageFont.truetype(self.font, font_size)\n+\n+        # Draw a black text with a white border\n+        draw = ImageDraw.Draw(image)\n+        draw.text(\n+            (0, 0),\n+            timestamp,\n+            font=font,\n+            fill=(0, 0, 0),\n+            stroke_width=outline_size,\n+            stroke_fill=(255, 255, 255),\n+        )\n+        return pil_to_tensor(image)\n+\n+    def _prepare_input_videos(\n+        self,\n+        videos: VideoInput,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+        device: Optional[str] = None,\n+        video_metadata: Optional[list[VideoMetadata]] = None,\n+        draw_on_frames: bool = True,\n+    ) -> list[\"torch.Tensor\"]:\n+        \"\"\"\n+        Prepare the input videos for processing.\n+        \"\"\"\n+        processed_videos = []\n+        for video, metadata in zip(videos, video_metadata):\n+            # Check for attributes that are necessary to draw timestamps on frames\n+            if draw_on_frames:\n+                if metadata is None:\n+                    raise ValueError(\"Need video metadata to process videos in Ernie 4.5 VL using `draw_on_frames`\")\n+                elif metadata.fps is None:\n+                    metadata.fps = 24\n+                    logger.warning_once(\n+                        \"Could not infer the fps of a video due to the metadata not being available, \"\n+                        \"defaulting to `24`. Please provide `video_metadata` for more accurate results.\"\n+                    )\n+\n+            # `make_batched_videos` always returns a 4D array per video\n+            if isinstance(video, np.ndarray):\n+                # not using F.to_tensor as it doesn't handle (C, H, W) numpy arrays\n+                video = torch.from_numpy(video).contiguous()\n+\n+            # Infer the channel dimension format if not provided\n+            if input_data_format is None:\n+                input_data_format = infer_channel_dimension_format(video)\n+\n+            if input_data_format == ChannelDimension.LAST:\n+                video = video.permute(0, 3, 1, 2).contiguous()\n+\n+            # specific to ernie, draws timestamps on each frame (if enabled)\n+            if draw_on_frames:\n+                if is_tracing(video):\n+                    raise RuntimeError(\n+                        \"Using `torch.compile` is not compatible with drawing on frames. \"\n+                        \"Either don't use `torch.compile` or don't draw on frames via the kwarg `draw_on_frames=False`.\"\n+                    )\n+\n+                for idx, frame in enumerate(video):\n+                    video[idx] = self._render_image_with_timestamp(\n+                        frame, self._convert_timestamp(metadata.timestamps[idx])\n+                    )\n+\n+            # last frame is copied if uneven (mitigating issues for temporal patch size)\n+            if video.shape[0] % 2 != 0:\n+                video = torch.cat((video, video[-1].detach().clone()[None, ...]), dim=0)\n+\n+            if device is not None:\n+                video = video.to(device)\n+\n+            processed_videos.append(video)\n+        return processed_videos\n+\n+    def _preprocess(\n+        self,\n+        videos: list[torch.Tensor],\n+        do_convert_rgb: bool = True,\n+        do_resize: bool = True,\n+        size: Optional[SizeDict] = None,\n+        interpolation: PILImageResampling = PILImageResampling.BICUBIC,\n+        do_rescale: bool = True,\n+        rescale_factor: float = 1 / 255.0,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        **kwargs,\n+    ):\n+        # Group videos by size for batched resizing\n+        grouped_videos, grouped_videos_index = group_videos_by_shape(videos)\n+        resized_videos_grouped = {}\n+        for shape, stacked_videos in grouped_videos.items():\n+            if do_convert_rgb:\n+                stacked_videos = self.convert_to_rgb(stacked_videos)\n+\n+            height, width = get_image_size(stacked_videos[0], channel_dim=ChannelDimension.FIRST)\n+            resized_height, resized_width = height, width\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    height,\n+                    width,\n+                    factor=patch_size * merge_size,\n+                    min_pixels=size[\"shortest_edge\"],\n+                    max_pixels=size[\"longest_edge\"],\n+                )\n+                stacked_videos = self.resize(\n+                    image=stacked_videos,\n+                    size=SizeDict(height=resized_height, width=resized_width),\n+                    interpolation=interpolation,\n+                )\n+            resized_videos_grouped[shape] = stacked_videos\n+        resized_videos = reorder_videos(resized_videos_grouped, grouped_videos_index)\n+\n+        # Group videos by size for further processing\n+        # Needed in case do_resize is False, or resize returns videos with different sizes\n+        grouped_videos, grouped_videos_index = group_videos_by_shape(resized_videos)\n+        processed_videos_grouped = {}\n+        processed_grids = {}\n+        for shape, stacked_videos in grouped_videos.items():\n+            resized_height, resized_width = get_image_size(stacked_videos[0], channel_dim=ChannelDimension.FIRST)\n+\n+            # Fused rescale and normalize\n+            stacked_videos = self.rescale_and_normalize(\n+                stacked_videos, do_rescale, rescale_factor, do_normalize, image_mean, image_std\n+            )\n+            patches = stacked_videos\n+\n+            batch_size, grid_t, channel = patches.shape[:3]\n+            grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+\n+            patches = patches.view(\n+                batch_size,\n+                grid_t,\n+                channel,\n+                grid_h // merge_size,\n+                merge_size,\n+                patch_size,\n+                grid_w // merge_size,\n+                merge_size,\n+                patch_size,\n+            )\n+            # Reorder dimensions to group grid and patch information for subsequent flattening.\n+            # [batch, grid_t, grid_h/merge, grid_w/merge, merge, merge, channel, patch, patch]\n+            patches = patches.permute(0, 1, 3, 6, 4, 7, 2, 5, 8)\n+\n+            flatten_patches = patches.reshape(\n+                batch_size,\n+                grid_t * grid_h * grid_w,\n+                channel * patch_size * patch_size,\n+            )\n+\n+            processed_videos_grouped[shape] = flatten_patches\n+            processed_grids[shape] = [[grid_t, grid_h, grid_w]] * batch_size\n+\n+        processed_videos = reorder_videos(processed_videos_grouped, grouped_videos_index)\n+        processed_grids = reorder_videos(processed_grids, grouped_videos_index)\n+        pixel_values_videos = torch.cat(processed_videos, dim=0)\n+        video_grid_thw = torch.tensor(processed_grids)\n+\n+        return BatchFeature(\n+            data={\"pixel_values_videos\": pixel_values_videos, \"video_grid_thw\": video_grid_thw},\n+            tensor_type=return_tensors,\n+        )\n+\n+    @add_start_docstrings(\n+        BASE_VIDEO_PROCESSOR_DOCSTRING,\n+    )\n+    def preprocess(\n+        self,\n+        videos: VideoInput,\n+        **kwargs: Unpack[VideosKwargs],\n+    ) -> BatchFeature:\n+        validate_kwargs(\n+            captured_kwargs=kwargs.keys(),\n+            valid_processor_keys=list(self.valid_kwargs.__annotations__.keys()) + [\"return_tensors\"],\n+        )\n+\n+        # Perform type validation on received kwargs\n+        validate_typed_dict(self.valid_kwargs, kwargs)\n+\n+        # Set default kwargs from self. This ensures that if a kwarg is not provided\n+        # by the user, it gets its default value from the instance, or is set to None.\n+        for kwarg_name in self.valid_kwargs.__annotations__:\n+            kwargs.setdefault(kwarg_name, getattr(self, kwarg_name, None))\n+\n+        input_data_format = kwargs.pop(\"input_data_format\")\n+        do_sample_frames = kwargs.pop(\"do_sample_frames\")\n+        device = kwargs.pop(\"device\")\n+        video_metadata = kwargs.pop(\"video_metadata\")\n+        draw_on_frames = kwargs.pop(\"draw_on_frames\")\n+\n+        sample_indices_fn = partial(self.sample_frames, **kwargs) if do_sample_frames else None\n+        videos, video_metadata = self._decode_and_sample_videos(\n+            videos,\n+            video_metadata=video_metadata,\n+            do_sample_frames=do_sample_frames,\n+            sample_indices_fn=sample_indices_fn,\n+        )\n+        videos = self._prepare_input_videos(\n+            videos=videos,\n+            input_data_format=input_data_format,\n+            device=device,\n+            video_metadata=video_metadata,\n+            draw_on_frames=draw_on_frames,\n+        )\n+\n+        kwargs = self._further_process_kwargs(**kwargs)\n+        self._validate_preprocess_kwargs(**kwargs)\n+\n+        # Pop kwargs that are not needed in _preprocess\n+        kwargs.pop(\"data_format\")\n+        return_metadata = kwargs.pop(\"return_metadata\")\n+\n+        preprocessed_videos = self._preprocess(videos=videos, **kwargs)\n+        if return_metadata:\n+            preprocessed_videos[\"video_metadata\"] = video_metadata\n+        return preprocessed_videos\n+\n+\n+__all__ = [\"Ernie4_5_VL_MoeVideoProcessor\"]"
        },
        {
            "sha": "479ffef6757311d1ed64febd0d2489f434f7cd7d",
            "filename": "src/transformers/models/glm46v/image_processing_glm46v.py",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fglm46v%2Fimage_processing_glm46v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fglm46v%2Fimage_processing_glm46v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm46v%2Fimage_processing_glm46v.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -354,7 +354,6 @@ def preprocess(\n             image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                 Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n                 `True`.\n-                The max pixels of the image to resize the image.\n             patch_size (`int`, *optional*, defaults to `self.patch_size`):\n                 The spatial patch size of the vision encoder.\n             temporal_patch_size (`int`, *optional*, defaults to `self.temporal_patch_size`):\n@@ -381,12 +380,9 @@ def preprocess(\n                 - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n \n         \"\"\"\n-        # Try to use config values if set, otherwise fallback to global defaults\n         size = size if size is not None else self.size\n         if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n             raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n-        elif size is None:\n-            size = {\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 15000}\n \n         do_resize = do_resize if do_resize is not None else self.do_resize\n         resample = resample if resample is not None else self.resample"
        },
        {
            "sha": "3ad98d762916fde6524f1e06224ac732a881f600",
            "filename": "src/transformers/models/glm4v/image_processing_glm4v.py",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fglm4v%2Fimage_processing_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fglm4v%2Fimage_processing_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fimage_processing_glm4v.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -353,7 +353,6 @@ def preprocess(\n             image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n                 Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n                 `True`.\n-                The max pixels of the image to resize the image.\n             patch_size (`int`, *optional*, defaults to `self.patch_size`):\n                 The spatial patch size of the vision encoder.\n             temporal_patch_size (`int`, *optional*, defaults to `self.temporal_patch_size`):\n@@ -380,12 +379,9 @@ def preprocess(\n                 - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n \n         \"\"\"\n-        # Try to use config values if set, otherwise fallback to global defaults\n         size = size if size is not None else self.size\n         if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n             raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n-        elif size is None:\n-            size = {\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 15000}\n \n         do_resize = do_resize if do_resize is not None else self.do_resize\n         resample = resample if resample is not None else self.resample"
        },
        {
            "sha": "e69b68a98123b9101b76b857b26ad225a4af0ccc",
            "filename": "src/transformers/models/glm4v/modeling_glm4v.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodeling_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodeling_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodeling_glm4v.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -315,8 +315,8 @@ def forward(\n         if self.config._attn_implementation != \"eager\":\n             attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n \n-        if self.config._attn_implementation == \"flash_attention_2\":\n-            # Flash Attention 2: Use cu_seqlens for variable length attention\n+        if \"flash\" in self.config._attn_implementation:\n+            # Flash Attention: Use cu_seqlens for variable length attention\n             max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max()\n             attn_output, _ = attention_interface(\n                 self,"
        },
        {
            "sha": "ca8b29fc3a4eadf20abb205c02f7870d3ecf029d",
            "filename": "src/transformers/models/glm4v_moe/modeling_glm4v_moe.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodeling_glm4v_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodeling_glm4v_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodeling_glm4v_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -845,8 +845,8 @@ def forward(\n         if self.config._attn_implementation != \"eager\":\n             attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n \n-        if self.config._attn_implementation == \"flash_attention_2\":\n-            # Flash Attention 2: Use cu_seqlens for variable length attention\n+        if \"flash\" in self.config._attn_implementation:\n+            # Flash Attention: Use cu_seqlens for variable length attention\n             max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max()\n             attn_output, _ = attention_interface(\n                 self,"
        },
        {
            "sha": "3d24aba9bc09d859d226dbc3c59cf53f3a430271",
            "filename": "src/transformers/models/qwen2_5_vl/modeling_qwen2_5_vl.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fmodeling_qwen2_5_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fmodeling_qwen2_5_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fmodeling_qwen2_5_vl.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -220,8 +220,8 @@ def forward(\n         if self.config._attn_implementation != \"eager\":\n             attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n \n-        if self.config._attn_implementation == \"flash_attention_2\":\n-            # Flash Attention 2: Use cu_seqlens for variable length attention\n+        if \"flash\" in self.config._attn_implementation:\n+            # Flash Attention: Use cu_seqlens for variable length attention\n             max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max()\n             attn_output, _ = attention_interface(\n                 self,"
        },
        {
            "sha": "694c09684570b9f8ae3d485e9b3c7a70441d9991",
            "filename": "src/transformers/models/qwen2_vl/modeling_qwen2_vl.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fmodeling_qwen2_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fmodeling_qwen2_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fmodeling_qwen2_vl.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -387,8 +387,8 @@ def forward(\n         if self.config._attn_implementation != \"eager\":\n             attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n \n-        if self.config._attn_implementation == \"flash_attention_2\":\n-            # Flash Attention 2: Use cu_seqlens for variable length attention\n+        if \"flash\" in self.config._attn_implementation:\n+            # Flash Attention: Use cu_seqlens for variable length attention\n             max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max()\n             attn_output, _ = attention_interface(\n                 self,"
        },
        {
            "sha": "a3c03206ddcac34e7a2d0fcc73080615030a936e",
            "filename": "src/transformers/models/qwen3_omni_moe/modeling_qwen3_omni_moe.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fmodeling_qwen3_omni_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fmodeling_qwen3_omni_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen3_omni_moe%2Fmodeling_qwen3_omni_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -907,8 +907,8 @@ def forward(\n         if self.config._attn_implementation != \"eager\":\n             attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n \n-        if self.config._attn_implementation == \"flash_attention_2\":\n-            # Flash Attention 2: Use cu_seqlens for variable length attention\n+        if \"flash\" in self.config._attn_implementation:\n+            # Flash Attention: Use cu_seqlens for variable length attention\n             max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max()\n             attn_output, _ = attention_interface(\n                 self,"
        },
        {
            "sha": "c2a9e5dfd5f0060ab1e2d04abce7ce7b9d1fc016",
            "filename": "src/transformers/models/qwen3_vl/modeling_qwen3_vl.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fqwen3_vl%2Fmodeling_qwen3_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fqwen3_vl%2Fmodeling_qwen3_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen3_vl%2Fmodeling_qwen3_vl.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -205,8 +205,8 @@ def forward(\n         if self.config._attn_implementation != \"eager\":\n             attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n \n-        if self.config._attn_implementation == \"flash_attention_2\":\n-            # Flash Attention 2: Use cu_seqlens for variable length attention\n+        if \"flash\" in self.config._attn_implementation:\n+            # Flash Attention: Use cu_seqlens for variable length attention\n             max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max()\n             attn_output, _ = attention_interface(\n                 self,"
        },
        {
            "sha": "3ca27435849a621f1f164e0632ace395bde55b65",
            "filename": "src/transformers/models/qwen3_vl_moe/modeling_qwen3_vl_moe.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fqwen3_vl_moe%2Fmodeling_qwen3_vl_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fmodels%2Fqwen3_vl_moe%2Fmodeling_qwen3_vl_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen3_vl_moe%2Fmodeling_qwen3_vl_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -539,8 +539,8 @@ def forward(\n         if self.config._attn_implementation != \"eager\":\n             attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n \n-        if self.config._attn_implementation == \"flash_attention_2\":\n-            # Flash Attention 2: Use cu_seqlens for variable length attention\n+        if \"flash\" in self.config._attn_implementation:\n+            # Flash Attention: Use cu_seqlens for variable length attention\n             max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max()\n             attn_output, _ = attention_interface(\n                 self,"
        },
        {
            "sha": "e7d1351df658d648be34777c565351474f59b57c",
            "filename": "src/transformers/tokenization_utils_tokenizers.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Ftokenization_utils_tokenizers.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Ftokenization_utils_tokenizers.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Ftokenization_utils_tokenizers.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -182,6 +182,7 @@ def convert_to_native_format(cls, trust_remote_code=False, **kwargs):\n                 local_kwargs[\"vocab\"], local_kwargs[\"merges\"] = TikTokenConverter(\n                     vocab_file=vocab_file, extra_special_tokens=local_kwargs.get(\"extra_special_tokens\")\n                 ).extract_vocab_merges_from_model(vocab_file)\n+\n             return local_kwargs\n \n         # Fallback to standard vocab/merges files if they existed!"
        },
        {
            "sha": "e2339589f5c28086c83c03deb62b8851327f6610",
            "filename": "src/transformers/video_processing_utils.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fvideo_processing_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/src%2Ftransformers%2Fvideo_processing_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fvideo_processing_utils.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -715,6 +715,7 @@ def get_video_processor_dict(\n             logger.info(\n                 f\"loading configuration file {video_processor_file} from cache at {resolved_video_processor_file}\"\n             )\n+\n         return video_processor_dict, kwargs\n \n     @classmethod"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/ernie4_5_vl_moe/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/tests%2Fmodels%2Fernie4_5_vl_moe%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/tests%2Fmodels%2Fernie4_5_vl_moe%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fernie4_5_vl_moe%2F__init__.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6"
        },
        {
            "sha": "e53576b9bad277641ed8762d3656e03574569e6f",
            "filename": "tests/models/ernie4_5_vl_moe/test_image_processing_ernie4_5_vl_moe.py",
            "status": "added",
            "additions": 346,
            "deletions": 0,
            "changes": 346,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/tests%2Fmodels%2Fernie4_5_vl_moe%2Ftest_image_processing_ernie4_5_vl_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/tests%2Fmodels%2Fernie4_5_vl_moe%2Ftest_image_processing_ernie4_5_vl_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fernie4_5_vl_moe%2Ftest_image_processing_ernie4_5_vl_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,346 @@\n+# Copyright 2025 HuggingFace Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import itertools\n+import tempfile\n+import unittest\n+\n+import numpy as np\n+\n+from transformers.image_utils import OPENAI_CLIP_MEAN, OPENAI_CLIP_STD, load_image\n+from transformers.models.ernie4_5_vl_moe.image_processing_ernie4_5_vl_moe import smart_resize\n+from transformers.testing_utils import require_torch, require_vision\n+from transformers.utils import is_torch_available, is_torchvision_available, is_vision_available\n+\n+from ...test_image_processing_common import ImageProcessingTestMixin, prepare_image_inputs\n+from ...test_processing_common import url_to_local_path\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+    from transformers import Ernie4_5_VL_MoeImageProcessor\n+\n+    if is_torchvision_available():\n+        from transformers import Ernie4_5_VL_MoeImageProcessorFast\n+\n+\n+class Ernie4_5_VL_MoeImageProcessorTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=7,\n+        num_channels=3,\n+        min_resolution=56,\n+        max_resolution=1024,\n+        size=None,\n+        do_resize=True,\n+        do_normalize=True,\n+        do_convert_rgb=True,\n+        image_mean=OPENAI_CLIP_MEAN,\n+        image_std=OPENAI_CLIP_STD,\n+        patch_size=14,\n+        merge_size=2,\n+    ):\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.min_resolution = min_resolution\n+        self.max_resolution = max_resolution\n+        if size is None:\n+            size = {\"shortest_edge\": 56 * 56, \"longest_edge\": 6177 * 28 * 28}\n+        self.size = size\n+        self.do_resize = do_resize\n+        self.do_normalize = do_normalize\n+        self.do_convert_rgb = do_convert_rgb\n+        self.image_mean = image_mean\n+        self.image_std = image_std\n+        self.patch_size = patch_size\n+        self.merge_size = merge_size\n+\n+    def prepare_image_processor_dict(self):\n+        return {\n+            \"do_resize\": self.do_resize,\n+            \"image_mean\": self.image_mean,\n+            \"image_std\": self.image_std,\n+            \"size\": self.size,\n+            \"patch_size\": self.patch_size,\n+            \"merge_size\": self.merge_size,\n+        }\n+\n+    def prepare_image_inputs(self, equal_resolution=False, numpify=False, torchify=False):\n+        images = prepare_image_inputs(\n+            batch_size=self.batch_size,\n+            num_channels=self.num_channels,\n+            min_resolution=self.min_resolution,\n+            max_resolution=self.max_resolution,\n+            equal_resolution=equal_resolution,\n+            numpify=numpify,\n+            torchify=torchify,\n+        )\n+        return [[image] for image in images]\n+\n+\n+@require_torch\n+@require_vision\n+class Ernie4_5_VL_MoeImageProcessingTest(ImageProcessingTestMixin, unittest.TestCase):\n+    image_processing_class = Ernie4_5_VL_MoeImageProcessor if is_vision_available() else None\n+    fast_image_processing_class = Ernie4_5_VL_MoeImageProcessorFast if is_torchvision_available() else None\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.image_processor_tester = Ernie4_5_VL_MoeImageProcessorTester(self)\n+\n+    @property\n+    def image_processor_dict(self):\n+        return self.image_processor_tester.prepare_image_processor_dict()\n+\n+    def test_image_processor_properties(self):\n+        for image_processing_class in self.image_processor_list:\n+            image_processing = image_processing_class(**self.image_processor_dict)\n+            self.assertTrue(hasattr(image_processing, \"do_normalize\"))\n+            self.assertTrue(hasattr(image_processing, \"image_mean\"))\n+            self.assertTrue(hasattr(image_processing, \"image_std\"))\n+            self.assertTrue(hasattr(image_processing, \"do_resize\"))\n+            self.assertTrue(hasattr(image_processing, \"size\"))\n+            self.assertTrue(hasattr(image_processing, \"do_convert_rgb\"))\n+            self.assertTrue(hasattr(image_processing, \"patch_size\"))\n+            self.assertTrue(hasattr(image_processing, \"merge_size\"))\n+\n+    def test_image_processor_from_dict_with_kwargs(self):\n+        for image_processing_class in self.image_processor_list:\n+            image_processor = image_processing_class.from_dict(self.image_processor_dict)\n+            self.assertEqual(image_processor.size[\"shortest_edge\"], 56 * 56)\n+            self.assertEqual(image_processor.size[\"longest_edge\"], 6177 * 28 * 28)\n+\n+            image_processor = image_processing_class.from_dict(\n+                self.image_processor_dict,\n+                size={\"shortest_edge\": 256 * 256, \"longest_edge\": 640 * 640},\n+            )\n+            self.assertEqual(image_processor.size[\"shortest_edge\"], 256 * 256)\n+            self.assertEqual(image_processor.size[\"longest_edge\"], 640 * 640)\n+\n+    def test_select_best_resolution(self):\n+        # Test with a final resize resolution\n+        best_resolution = smart_resize(561, 278, factor=28)\n+        self.assertEqual(best_resolution, (560, 280))\n+\n+    def test_call_pil(self):\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = image_processing_class(**self.image_processor_dict)\n+            # create random PIL images\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True)\n+            for image in image_inputs:\n+                self.assertIsInstance(image[0], Image.Image)\n+\n+            # Test not batched input\n+            process_out = image_processing(image_inputs[0], return_tensors=\"pt\")\n+            encoded_images = process_out.pixel_values\n+            image_grid_thws = process_out.image_grid_thw\n+            expected_output_image_shape = (5476, 588)\n+            expected_image_grid_thws = torch.Tensor([[1, 74, 74]])\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+            self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+            # Test batched\n+            process_out = image_processing(image_inputs, return_tensors=\"pt\")\n+            encoded_images = process_out.pixel_values\n+            image_grid_thws = process_out.image_grid_thw\n+            expected_output_image_shape = (38332, 588)\n+            expected_image_grid_thws = torch.Tensor([[1, 74, 74]] * 7)\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+            self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+    def test_call_numpy(self):\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = image_processing_class(**self.image_processor_dict)\n+            # create random numpy tensors\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True, numpify=True)\n+            for image in image_inputs:\n+                self.assertIsInstance(image[0], np.ndarray)\n+\n+            # Test not batched input\n+            process_out = image_processing(image_inputs[0], return_tensors=\"pt\")\n+            encoded_images = process_out.pixel_values\n+            image_grid_thws = process_out.image_grid_thw\n+            expected_output_image_shape = (5476, 588)\n+            expected_image_grid_thws = torch.Tensor([[1, 74, 74]])\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+            self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+            # Test batched\n+            process_out = image_processing(image_inputs, return_tensors=\"pt\")\n+            encoded_images = process_out.pixel_values\n+            image_grid_thws = process_out.image_grid_thw\n+            expected_output_image_shape = (38332, 588)\n+            expected_image_grid_thws = torch.Tensor([[1, 74, 74]] * 7)\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+            self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+    def test_call_pytorch(self):\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = image_processing_class(**self.image_processor_dict)\n+            # create random PyTorch tensors\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True, torchify=True)\n+\n+            for image in image_inputs:\n+                self.assertIsInstance(image[0], torch.Tensor)\n+\n+            # Test not batched input\n+            process_out = image_processing(image_inputs[0], return_tensors=\"pt\")\n+            encoded_images = process_out.pixel_values\n+            image_grid_thws = process_out.image_grid_thw\n+            expected_output_image_shape = (5476, 588)\n+            expected_image_grid_thws = torch.Tensor([[1, 74, 74]])\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+            self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+            # Test batched\n+            process_out = image_processing(image_inputs, return_tensors=\"pt\")\n+            encoded_images = process_out.pixel_values\n+            image_grid_thws = process_out.image_grid_thw\n+            expected_output_image_shape = (38332, 588)\n+            expected_image_grid_thws = torch.Tensor([[1, 74, 74]] * 7)\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+            self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+    @unittest.skip(reason=\"Erni4_5_VLImageProcessor doesn't treat 4 channel PIL and numpy consistently yet\")\n+    def test_call_numpy_4_channels(self):\n+        pass\n+\n+    def test_nested_input(self):\n+        for image_processing_class in self.image_processor_list:\n+            image_processing = image_processing_class(**self.image_processor_dict)\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True)\n+\n+            # Test batched as a list of images\n+            process_out = image_processing(image_inputs, return_tensors=\"pt\")\n+            encoded_images = process_out.pixel_values\n+            image_grid_thws = process_out.image_grid_thw\n+            expected_output_image_shape = (38332, 588)\n+            expected_image_grid_thws = torch.Tensor([[1, 74, 74]] * 7)\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+            self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+            # Test batched as a nested list of images, where each sublist is one batch\n+            image_inputs_nested = image_inputs[:3] + image_inputs[3:]\n+            process_out = image_processing(image_inputs_nested, return_tensors=\"pt\")\n+            encoded_images_nested = process_out.pixel_values\n+            image_grid_thws_nested = process_out.image_grid_thw\n+            expected_output_image_shape = (38332, 588)\n+            expected_image_grid_thws = torch.Tensor([[1, 74, 74]] * 7)\n+            self.assertEqual(tuple(encoded_images_nested.shape), expected_output_image_shape)\n+            self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+            # Image processor should return same pixel values, independently of ipnut format\n+            self.assertTrue((encoded_images_nested == encoded_images).all())\n+            self.assertTrue((image_grid_thws_nested == expected_image_grid_thws).all())\n+\n+    def test_custom_image_size(self):\n+        for image_processing_class in self.image_processor_list:\n+            image_processing = image_processing_class(**self.image_processor_dict)\n+            with tempfile.TemporaryDirectory() as tmpdirname:\n+                image_processing.save_pretrained(tmpdirname)\n+                image_processor_loaded = image_processing_class.from_pretrained(\n+                    tmpdirname, size={\"shortest_edge\": 28 * 28, \"longest_edge\": 56 * 56}\n+                )\n+\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True)\n+            process_out = image_processor_loaded(image_inputs, return_tensors=\"pt\")\n+            expected_output_image_shape = [112, 588]\n+            self.assertListEqual(list(process_out.pixel_values.shape), expected_output_image_shape)\n+\n+    def test_custom_pixels(self):\n+        pixel_choices = frozenset(itertools.product((100, 150, 200, 20000), (100, 150, 200, 20000)))\n+        for image_processing_class in self.image_processor_list:\n+            image_processor_dict = self.image_processor_dict.copy()\n+            for a_pixels, b_pixels in pixel_choices:\n+                image_processor_dict[\"size\"] = {\n+                    \"shortest_edge\": min(a_pixels, b_pixels),\n+                    \"longest_edge\": max(a_pixels, b_pixels),\n+                }\n+                image_processor = image_processing_class(**image_processor_dict)\n+                image_inputs = self.image_processor_tester.prepare_image_inputs()\n+                # Just checking that it doesn't raise an error\n+                image_processor(image_inputs, return_tensors=\"pt\")\n+\n+    @require_vision\n+    @require_torch\n+    def test_slow_fast_equivalence(self):\n+        dummy_image = load_image(url_to_local_path(\"http://images.cocodataset.org/val2017/000000039769.jpg\"))\n+\n+        if not self.test_slow_image_processor or not self.test_fast_image_processor:\n+            self.skipTest(reason=\"Skipping slow/fast equivalence test\")\n+\n+        if self.image_processing_class is None or self.fast_image_processing_class is None:\n+            self.skipTest(reason=\"Skipping slow/fast equivalence test as one of the image processors is not defined\")\n+\n+        image_processor_slow = self.image_processing_class(**self.image_processor_dict)\n+        image_processor_fast = self.fast_image_processing_class(**self.image_processor_dict)\n+\n+        encoding_slow = image_processor_slow(dummy_image, return_tensors=\"pt\")\n+        encoding_fast = image_processor_fast(dummy_image, return_tensors=\"pt\")\n+\n+        self._assert_slow_fast_tensors_equivalence(encoding_slow.pixel_values, encoding_fast.pixel_values)\n+        self.assertEqual(encoding_slow.image_grid_thw.dtype, encoding_fast.image_grid_thw.dtype)\n+        self._assert_slow_fast_tensors_equivalence(\n+            encoding_slow.image_grid_thw.float(), encoding_fast.image_grid_thw.float()\n+        )\n+\n+    @require_vision\n+    @require_torch\n+    def test_slow_fast_equivalence_batched(self):\n+        if not self.test_slow_image_processor or not self.test_fast_image_processor:\n+            self.skipTest(reason=\"Skipping slow/fast equivalence test\")\n+\n+        if self.image_processing_class is None or self.fast_image_processing_class is None:\n+            self.skipTest(reason=\"Skipping slow/fast equivalence test as one of the image processors is not defined\")\n+\n+        if hasattr(self.image_processor_tester, \"do_center_crop\") and self.image_processor_tester.do_center_crop:\n+            self.skipTest(\n+                reason=\"Skipping as do_center_crop is True and center_crop functions are not equivalent for fast and slow processors\"\n+            )\n+\n+        dummy_images = self.image_processor_tester.prepare_image_inputs(equal_resolution=False, torchify=True)\n+        image_processor_slow = self.image_processing_class(**self.image_processor_dict)\n+        image_processor_fast = self.fast_image_processing_class(**self.image_processor_dict)\n+\n+        encoding_slow = image_processor_slow(dummy_images, return_tensors=\"pt\")\n+        encoding_fast = image_processor_fast(dummy_images, return_tensors=\"pt\")\n+\n+        self._assert_slow_fast_tensors_equivalence(encoding_slow.pixel_values, encoding_fast.pixel_values)\n+        self.assertEqual(encoding_slow.image_grid_thw.dtype, encoding_fast.image_grid_thw.dtype)\n+        self._assert_slow_fast_tensors_equivalence(\n+            encoding_slow.image_grid_thw.float(), encoding_fast.image_grid_thw.float()\n+        )\n+\n+    def test_get_num_patches_without_images(self):\n+        for image_processing_class in self.image_processor_list:\n+            image_processing = image_processing_class(**self.image_processor_dict)\n+            num_patches = image_processing.get_number_of_image_patches(height=100, width=100, images_kwargs={})\n+            self.assertEqual(num_patches, 64)\n+\n+            num_patches = image_processing.get_number_of_image_patches(height=200, width=50, images_kwargs={})\n+            self.assertEqual(num_patches, 56)\n+\n+            num_patches = image_processing.get_number_of_image_patches(\n+                height=100, width=100, images_kwargs={\"patch_size\": 28}\n+            )\n+            self.assertEqual(num_patches, 16)"
        },
        {
            "sha": "41f6261dba2744a308e3c4c5b06809de9c6a4dc8",
            "filename": "tests/models/ernie4_5_vl_moe/test_modeling_ernie4_5_vl_moe.py",
            "status": "added",
            "additions": 737,
            "deletions": 0,
            "changes": 737,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/tests%2Fmodels%2Fernie4_5_vl_moe%2Ftest_modeling_ernie4_5_vl_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/tests%2Fmodels%2Fernie4_5_vl_moe%2Ftest_modeling_ernie4_5_vl_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fernie4_5_vl_moe%2Ftest_modeling_ernie4_5_vl_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,737 @@\n+# Copyright 2025 Baidu and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch Ernie 4.5 VL model.\"\"\"\n+\n+import unittest\n+\n+from transformers import (\n+    AutoModelForImageTextToText,\n+    AutoProcessor,\n+    Ernie4_5_VL_MoeConfig,\n+    Ernie4_5_VL_MoeForConditionalGeneration,\n+    Ernie4_5_VL_MoeModel,\n+    is_torch_available,\n+    is_vision_available,\n+)\n+from transformers.testing_utils import (\n+    cleanup,\n+    require_torch,\n+    require_torch_large_accelerator,\n+    slow,\n+    torch_device,\n+)\n+from transformers.utils import is_cv2_available\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import (\n+    ModelTesterMixin,\n+    floats_tensor,\n+    ids_tensor,\n+)\n+\n+\n+if is_cv2_available():\n+    pass\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_vision_available():\n+    pass\n+\n+\n+class Ernie4_5_VL_MoeVisionText2TextModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=3,\n+        seq_length=7,\n+        num_channels=3,\n+        ignore_index=-100,\n+        image_size=112,\n+        video_start_token_id=3,\n+        video_end_token_id=4,\n+        image_start_token_id=5,\n+        image_end_token_id=6,\n+        image_token_id=7,\n+        video_token_id=8,\n+        is_training=True,\n+        text_config=None,\n+        vision_config=None,\n+    ):\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.seq_length = seq_length\n+        self.num_channels = num_channels\n+        self.ignore_index = ignore_index\n+        self.image_size = image_size\n+        self.bos_token_id = 0\n+        self.eos_token_id = 0\n+        self.pad_token_id = 0\n+        self.video_start_token_id = video_start_token_id\n+        self.video_end_token_id = video_end_token_id\n+        self.image_start_token_id = image_start_token_id\n+        self.image_end_token_id = image_end_token_id\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.is_training = is_training\n+\n+        self.text_config = text_config\n+        if text_config is None:\n+            self.text_config = {\n+                \"vocab_size\": 99,\n+                \"hidden_size\": 16,\n+                \"intermediate_size\": 22,\n+                \"num_hidden_layers\": 2,\n+                \"num_attention_heads\": 2,\n+                \"num_key_value_heads\": 1,\n+                \"hidden_act\": \"silu\",\n+                \"max_position_embeddings\": 512,\n+                \"tie_word_embeddings\": True,\n+                \"rope_parameters\": {\"type\": \"default\", \"rope_theta\": 500_000.0, \"mrope_section\": [1, 1, 2]},\n+                \"mlp_layer_types\": [\"dense\", \"sparse\"],\n+                \"moe_intermediate_size\": [22, 22],\n+                \"moe_k\": 2,\n+                \"moe_num_experts\": 8,\n+                \"moe_num_shared_experts\": 2,\n+                \"moe_norm_min\": 1e-12,\n+            }\n+\n+        self.vision_config = vision_config\n+        if vision_config is None:\n+            self.vision_config = {\n+                \"depth\": 2,\n+                \"hidden_size\": 32,\n+                \"hidden_act\": \"silu\",\n+                \"intermediate_size\": 22,\n+                \"num_heads\": 2,\n+                \"spatial_merge_size\": 1,\n+            }\n+\n+        self.hidden_size = self.text_config[\"hidden_size\"]\n+        self.num_hidden_layers = self.text_config[\"num_hidden_layers\"]\n+        self.num_attention_heads = self.text_config[\"num_attention_heads\"]\n+        self.vocab_size = self.text_config[\"vocab_size\"]\n+\n+        self.num_image_tokens = 64\n+        self.seq_length = seq_length + self.num_image_tokens\n+\n+    def get_config(self):\n+        return Ernie4_5_VL_MoeConfig(\n+            text_config=self.text_config,\n+            vision_config=self.vision_config,\n+            image_token_id=self.image_token_id,\n+            video_token_id=self.video_token_id,\n+            video_start_token_id=self.video_start_token_id,\n+            video_end_token_id=self.video_end_token_id,\n+            image_start_token_id=self.image_start_token_id,\n+            image_end_token_id=self.image_end_token_id,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        config = self.get_config()\n+        patch_size = config.vision_config.patch_size\n+        pixel_values = floats_tensor(\n+            [self.batch_size * (self.image_size**2) // (patch_size**2), self.num_channels * (patch_size**2)]\n+        )\n+\n+        return config, pixel_values\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], self.vocab_size)\n+        attention_mask = torch.ones(input_ids.shape, dtype=torch.long, device=torch_device)\n+\n+        input_ids[input_ids == self.video_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.video_start_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_start_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.video_end_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_end_token_id] = self.pad_token_id\n+\n+        input_ids[:, 0] = self.image_start_token_id\n+        input_ids[:, 1 : 1 + self.num_image_tokens] = self.image_token_id\n+        input_ids[:, 1 + self.num_image_tokens] = self.image_end_token_id\n+\n+        patch_size = config.vision_config.patch_size\n+        patches_per_side = self.image_size // patch_size\n+\n+        inputs_dict = {\n+            \"pixel_values\": pixel_values,\n+            \"image_grid_thw\": torch.tensor(\n+                [[1, patches_per_side, patches_per_side]] * self.batch_size, device=torch_device\n+            ),\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+        }\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class Ernie4_5_VL_MoeModelTest(ModelTesterMixin, GenerationTesterMixin, unittest.TestCase):\n+    all_model_classes = (\n+        (\n+            Ernie4_5_VL_MoeModel,\n+            Ernie4_5_VL_MoeForConditionalGeneration,\n+        )\n+        if is_torch_available()\n+        else ()\n+    )\n+    model_split_percents = [0.7, 0.9]  # model too big to split at 0.5\n+    test_all_params_have_gradient = False  # e score correction bias + moe\n+    _is_composite = True\n+\n+    def setUp(self):\n+        self.model_tester = Ernie4_5_VL_MoeVisionText2TextModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Ernie4_5_VL_MoeConfig, has_text_modality=False)\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    def prepare_config_and_inputs_for_generate(self, batch_size=2):\n+        \"\"\"\n+        Same as in GLM4V, see `tests/models/glm4v/test_modeling_glm4v.py` for reference\n+        \"\"\"\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        # We don't want a few model inputs in our model input dictionary for generation tests\n+        input_keys_to_ignore = [\n+            # we don't want encoder-decoder models to start from filled decoder ids\n+            \"decoder_input_ids\",\n+            \"decoder_attention_mask\",\n+            # we'll set cache use in each test differently\n+            \"use_cache\",\n+            # ignore labels if it is in the input dict\n+            \"labels\",\n+        ]\n+\n+        # The diff from the general `prepare_config_and_inputs_for_generate` lies here\n+        patch_size = config.vision_config.patch_size\n+        filtered_image_length = batch_size * (self.model_tester.image_size**2) // (patch_size**2)\n+        filtered_inputs_dict = {\n+            k: v[:batch_size, ...] if isinstance(v, torch.Tensor) else v\n+            for k, v in inputs_dict.items()\n+            if k not in input_keys_to_ignore\n+        }\n+        filtered_inputs_dict[\"pixel_values\"] = inputs_dict[\"pixel_values\"][:filtered_image_length]\n+\n+        # It is important set `eos_token_id` to `None` to avoid early stopping (would break for length-based checks)\n+        text_gen_config = config.get_text_config(decoder=True)\n+        if text_gen_config.eos_token_id is not None and text_gen_config.pad_token_id is None:\n+            text_gen_config.pad_token_id = (\n+                text_gen_config.eos_token_id\n+                if isinstance(text_gen_config.eos_token_id, int)\n+                else text_gen_config.eos_token_id[0]\n+            )\n+        text_gen_config.eos_token_id = None\n+        text_gen_config.forced_eos_token_id = None\n+\n+        return config, filtered_inputs_dict\n+\n+    def test_inputs_embeds_matches_input_ids(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            inputs = self._prepare_for_class(inputs_dict, model_class)\n+            input_ids = inputs[\"input_ids\"]\n+            del inputs[\"input_ids\"]\n+            del inputs[\"pixel_values\"]\n+            del inputs[\"image_grid_thw\"]\n+\n+            inputs_embeds = model.get_input_embeddings()(input_ids)\n+\n+            with torch.no_grad():\n+                out_ids = model(input_ids=input_ids, **inputs)[0]\n+                out_embeds = model(inputs_embeds=inputs_embeds, **inputs)[0]\n+            torch.testing.assert_close(out_embeds, out_ids)\n+\n+    @unittest.skip(reason=\"Size mismatch\")\n+    def test_multi_gpu_data_parallel_forward(self):\n+        pass\n+\n+\n+@slow\n+@require_torch_large_accelerator(memory=64)  # Tested on A100\n+@require_torch\n+class Ernie4_5_VL_MoeIntegrationTest(unittest.TestCase):\n+    model = None\n+    model_id = \"baidu/ERNIE-4.5-VL-28B-A3B-PT\"\n+\n+    # TODO: remove revision when PR on the hub is merged\n+    def setUp(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+        self.processor = AutoProcessor.from_pretrained(self.model_id, revision=\"refs/pr/10\")\n+        self.message = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+                    {\n+                        \"type\": \"image\",\n+                        \"url\": \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/pipeline-cat-chonk.jpeg\",\n+                    },\n+                ],\n+            }\n+        ]\n+        self.message2 = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+                    {\n+                        \"type\": \"image\",\n+                        \"url\": \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/coco_sample.png\",\n+                    },\n+                ],\n+            }\n+        ]\n+\n+    def tearDown(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    def load_model(self, dtype, attn_implementation=\"sdpa\"):\n+        return AutoModelForImageTextToText.from_pretrained(\n+            self.model_id,\n+            device_map=\"auto\",\n+            dtype=dtype,\n+            attn_implementation=attn_implementation,\n+            revision=\"refs/pr/10\",\n+        )\n+\n+    def test_small_model_integration_test(self):\n+        model = self.load_model(\"auto\")\n+        inputs = self.processor.apply_chat_template(\n+            self.message, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\"\n+        )\n+        expected_input_ids = [100273, 2969, 93963, 1912, 3836, 315, 9159, 357, 501, 94009, 39082, 93919, 4, 93963, 101304, 100295, 100295]  # fmt: skip\n+        assert expected_input_ids == inputs.input_ids[0].tolist()[:17]\n+\n+        expected_pixel_slice = torch.tensor(\n+            [\n+                [-0.0988, -0.0842, -0.0842],\n+                [-0.5660, -0.5514, -0.4200],\n+                [-0.0259, -0.0259, -0.0259],\n+                [-0.1280, -0.0988, -0.2010],\n+                [-0.4638, -0.5806, -0.6974],\n+                [-1.2083, -1.2229, -1.2083],\n+            ],\n+            dtype=torch.float32,\n+            device=\"cpu\",\n+        )\n+        assert torch.allclose(expected_pixel_slice, inputs.pixel_values[:6, :3], atol=3e-3)\n+\n+        # verify generation\n+        inputs = inputs.to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        EXPECTED_DECODED_TEXT = \"The animal in the image is a lynx, not a dog. It's a wild cat species known for its distinctive ear tufts and\"\n+        self.assertEqual(\n+            self.processor.decode(output[0][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    def test_small_model_integration_test_batch(self):\n+        model = self.load_model(\"auto\")\n+        batch_messages = [self.message] * 2\n+        inputs = self.processor.apply_chat_template(\n+            batch_messages, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"The animal in the image is a lynx, not a dog. It's a wild cat species known for its distinctive ear tufts and\",\n+            \"The animal in the image is a lynx, not a dog. It's a wild cat species characterized by its distinctive ear tufts,\"\n+        ]  # fmt: skip\n+\n+        self.assertEqual(\n+            [\n+                self.processor.decode(output[0][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+                self.processor.decode(output[1][len(inputs[\"input_ids\"][1]) :], skip_special_tokens=True),\n+            ],\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    def test_small_model_integration_test_with_video(self):\n+        processor = AutoProcessor.from_pretrained(\n+            self.model_id, max_image_size={\"longest_edge\": 50176}, revision=\"refs/pr/10\"\n+        )\n+        model = self.load_model(dtype=torch.float16)\n+        questions = [\"Only use English during your responses. Describe the following video.\"]\n+        video_urls = [\"https://huggingface.co/datasets/raushan-testing-hf/videos-test/resolve/main/tiny_video.mp4\"]\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\"type\": \"text\", \"text\": question},\n+                        {\n+                            \"type\": \"video\",\n+                            \"video\": video_url,\n+                        },\n+                    ],\n+                }\n+            ]\n+            for question, video_url in zip(questions, video_urls)\n+        ]\n+        inputs = processor.apply_chat_template(\n+            messages, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\", padding=True\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        EXPECTED_DECODED_TEXT = 'A black-and-white image shows a person lying on their back on a mat in a dojo. They are dressed in a white judo gi'  # fmt: skip\n+\n+        self.assertEqual(\n+            self.processor.decode(output[0][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    def test_small_model_integration_test_expand(self):\n+        model = self.load_model(\"auto\")\n+        inputs = self.processor.apply_chat_template(\n+            self.message, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        output = model.generate(**inputs, max_new_tokens=30, do_sample=False, num_beams=2, num_return_sequences=2)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            'The animal in the image is a lynx, not a dog. It has the distinctive features of a lynx, including a short tail',\n+            'The animal in the image is a lynx, not a dog. It has the distinctive features of a lynx, such as its short'\n+        ]  # fmt: skip\n+\n+        self.assertEqual(\n+            [\n+                self.processor.decode(output[0][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+                self.processor.decode(output[1][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+            ],\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    def test_small_model_integration_test_batch_wo_image(self):\n+        model = self.load_model(\"auto\")\n+        message_wo_image = [\n+            {\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"Who are you?\"}]},\n+        ]\n+        batched_messages = [self.message, message_wo_image]\n+        inputs = self.processor.apply_chat_template(\n+            batched_messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"The animal in the image is a lynx, not a dog. It's a wild cat species known for its distinctive ear tufts and\",\n+            \"I am an AI assistant designed to help answer questions, provide information, and assist with tasks. I don't have personal experiences or a physical form\"\n+        ]  # fmt: skip\n+\n+        self.assertEqual(\n+            [\n+                self.processor.decode(output[0][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+                self.processor.decode(output[1][len(inputs[\"input_ids\"][1]) :], skip_special_tokens=True),\n+            ],\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    def test_small_model_integration_test_batch_different_resolutions(self):\n+        model = self.load_model(\"auto\")\n+        batched_messages = [self.message, self.message2]\n+        inputs = self.processor.apply_chat_template(\n+            batched_messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            'The animal in the image is a lynx, not a dog. It has the distinctive features of a lynx, such as tuft',\n+            'there are no dogs here, there are 2 cats',\n+        ]  # fmt: skip\n+\n+        self.assertEqual(\n+            [\n+                self.processor.decode(output[0][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+                self.processor.decode(output[1][len(inputs[\"input_ids\"][1]) :], skip_special_tokens=True),\n+            ],\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+\n+# Garbage output expected as it is a dummy model to be run on the CI\n+@slow\n+@require_torch\n+class Ernie4_5_VL_MoeSmallIntegrationTest(unittest.TestCase):\n+    model = None\n+    model_id = \"hf-internal-testing/Ernie-VL-Moe-Small\"\n+\n+    def setUp(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+        self.processor = AutoProcessor.from_pretrained(self.model_id)\n+        self.message = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+                    {\n+                        \"type\": \"image\",\n+                        \"url\": \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/pipeline-cat-chonk.jpeg\",\n+                    },\n+                ],\n+            }\n+        ]\n+        self.message2 = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+                    {\n+                        \"type\": \"image\",\n+                        \"url\": \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/coco_sample.png\",\n+                    },\n+                ],\n+            }\n+        ]\n+\n+    def tearDown(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    def load_model(self, dtype, attn_implementation=\"sdpa\"):\n+        return AutoModelForImageTextToText.from_pretrained(\n+            self.model_id,\n+            device_map=\"auto\",\n+            dtype=dtype,\n+            attn_implementation=attn_implementation,\n+        )\n+\n+    def test_small_model_integration_test(self):\n+        model = self.load_model(\"auto\")\n+        inputs = self.processor.apply_chat_template(\n+            self.message, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\"\n+        )\n+        expected_input_ids = [100273, 2969, 93963, 1912, 3836, 315, 9159, 357, 501, 94009, 39082, 93919, 4, 93963, 101304, 100295, 100295]  # fmt: skip\n+        assert expected_input_ids == inputs.input_ids[0].tolist()[:17]\n+\n+        expected_pixel_slice = torch.tensor(\n+            [\n+                [-0.0988, -0.0842, -0.0842],\n+                [-0.5660, -0.5514, -0.4200],\n+                [-0.0259, -0.0259, -0.0259],\n+                [-0.1280, -0.0988, -0.2010],\n+                [-0.4638, -0.5806, -0.6974],\n+                [-1.2083, -1.2229, -1.2083],\n+            ],\n+            dtype=torch.float32,\n+            device=\"cpu\",\n+        )\n+        assert torch.allclose(expected_pixel_slice, inputs.pixel_values[:6, :3], atol=3e-3)\n+\n+        # verify generation\n+        inputs = inputs.to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        EXPECTED_DECODED_TEXT = \"知道了知道了attaatta不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如\"\n+        self.assertEqual(\n+            self.processor.decode(output[0][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    def test_small_model_integration_test_batch(self):\n+        model = self.load_model(\"auto\")\n+        batch_messages = [self.message] * 2\n+        inputs = self.processor.apply_chat_template(\n+            batch_messages, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            '知道了知道了attaatta不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如',\n+            '不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊',\n+        ]  # fmt: skip\n+\n+        self.assertEqual(\n+            [\n+                self.processor.decode(output[0][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+                self.processor.decode(output[1][len(inputs[\"input_ids\"][1]) :], skip_special_tokens=True),\n+            ],\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    def test_small_model_integration_test_with_video(self):\n+        processor = AutoProcessor.from_pretrained(self.model_id, max_image_size={\"longest_edge\": 50176})\n+        model = self.load_model(dtype=torch.float16)\n+        questions = [\"Only use English during your responses. Describe the following video.\"]\n+        video_urls = [\"https://huggingface.co/datasets/raushan-testing-hf/videos-test/resolve/main/tiny_video.mp4\"]\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\"type\": \"text\", \"text\": question},\n+                        {\n+                            \"type\": \"video\",\n+                            \"video\": video_url,\n+                        },\n+                    ],\n+                }\n+            ]\n+            for question, video_url in zip(questions, video_urls)\n+        ]\n+        inputs = processor.apply_chat_template(\n+            messages, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\", padding=True\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        EXPECTED_DECODED_TEXT = 'uschuschusch载载载载载载载载载载载载载载载载载载载载载载载载载载载'  # fmt: skip\n+\n+        self.assertEqual(\n+            self.processor.decode(output[0][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    def test_small_model_integration_test_expand(self):\n+        model = self.load_model(\"auto\")\n+        inputs = self.processor.apply_chat_template(\n+            self.message, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        output = model.generate(**inputs, max_new_tokens=30, do_sample=False, num_beams=2, num_return_sequences=2)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            '不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊错的错的错的错的错的错的错的错的错的错的错的错的错的',\n+            '不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊不是啊错的错的错的错的错的错的错的错的错的错的错的错的就是这样',\n+        ]  # fmt: skip\n+\n+        self.assertEqual(\n+            [\n+                self.processor.decode(output[0][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+                self.processor.decode(output[1][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+            ],\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    def test_small_model_integration_test_batch_wo_image(self):\n+        model = self.load_model(\"auto\")\n+        message_wo_image = [\n+            {\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"Who are you?\"}]},\n+        ]\n+        batched_messages = [self.message, message_wo_image]\n+        inputs = self.processor.apply_chat_template(\n+            batched_messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            '知道了知道了attaatta不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如',\n+            '用具柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄柄',\n+        ]  # fmt: skip\n+\n+        self.assertEqual(\n+            [\n+                self.processor.decode(output[0][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+                self.processor.decode(output[1][len(inputs[\"input_ids\"][1]) :], skip_special_tokens=True),\n+            ],\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    def test_small_model_integration_test_batch_different_resolutions(self):\n+        model = self.load_model(\"auto\")\n+        batched_messages = [self.message, self.message2]\n+        inputs = self.processor.apply_chat_template(\n+            batched_messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            '知道了知道了attaatta不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如不如',\n+            '填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空填空',\n+        ]  # fmt: skip\n+\n+        self.assertEqual(\n+            [\n+                self.processor.decode(output[0][len(inputs[\"input_ids\"][0]) :], skip_special_tokens=True),\n+                self.processor.decode(output[1][len(inputs[\"input_ids\"][1]) :], skip_special_tokens=True),\n+            ],\n+            EXPECTED_DECODED_TEXT,\n+        )"
        },
        {
            "sha": "fa2ec942a63550c5c8b78d3205c3cb96ac5ee6a3",
            "filename": "tests/models/ernie4_5_vl_moe/test_processing_ernie4_5_vl_moe.py",
            "status": "added",
            "additions": 374,
            "deletions": 0,
            "changes": 374,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/tests%2Fmodels%2Fernie4_5_vl_moe%2Ftest_processing_ernie4_5_vl_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/tests%2Fmodels%2Fernie4_5_vl_moe%2Ftest_processing_ernie4_5_vl_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fernie4_5_vl_moe%2Ftest_processing_ernie4_5_vl_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,374 @@\n+# Copyright 2025 HuggingFace Inc team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import inspect\n+import shutil\n+import tempfile\n+import unittest\n+\n+import numpy as np\n+import pytest\n+\n+from transformers import AutoProcessor, LlamaTokenizerFast\n+from transformers.testing_utils import require_av, require_torch, require_torchvision, require_vision\n+from transformers.utils import is_torch_available, is_vision_available\n+\n+from ...test_processing_common import ProcessorTesterMixin\n+\n+\n+if is_vision_available():\n+    from transformers import Ernie4_5_VL_MoeImageProcessorFast, Ernie4_5_VL_MoeProcessor\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+@require_vision\n+@require_torch\n+@require_torchvision\n+class Ernie4_5_VL_MoeProcessorTest(ProcessorTesterMixin, unittest.TestCase):\n+    processor_class = Ernie4_5_VL_MoeProcessor\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.tmpdirname = tempfile.mkdtemp()\n+        processor = Ernie4_5_VL_MoeProcessor.from_pretrained(\n+            \"hf-internal-testing/Ernie-VL-Moe-Small\",\n+            patch_size=4,\n+            size={\"shortest_edge\": 28 * 28, \"longest_edge\": 56 * 56},\n+        )\n+        processor.save_pretrained(cls.tmpdirname)\n+        cls.image_token = processor.image_token\n+\n+    def get_tokenizer(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).tokenizer\n+\n+    def get_image_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).image_processor\n+\n+    def get_video_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).video_processor\n+\n+    def get_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs)\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        shutil.rmtree(cls.tmpdirname, ignore_errors=True)\n+\n+    # Copied from tests.models.llava.test_processing_llava.LlavaProcessorTest.test_get_num_vision_tokens\n+    def test_get_num_vision_tokens(self):\n+        \"Tests general functionality of the helper used internally in vLLM\"\n+\n+        processor = self.get_processor()\n+\n+        output = processor._get_num_multimodal_tokens(image_sizes=[(100, 100), (300, 100), (500, 30)])\n+        self.assertTrue(\"num_image_tokens\" in output)\n+        self.assertEqual(len(output[\"num_image_tokens\"]), 3)\n+\n+        self.assertTrue(\"num_image_patches\" in output)\n+        self.assertEqual(len(output[\"num_image_patches\"]), 3)\n+\n+    def test_save_load_pretrained_default(self):\n+        tokenizer = self.get_tokenizer()\n+        image_processor = self.get_image_processor()\n+        video_processor = self.get_video_processor()\n+\n+        processor = Ernie4_5_VL_MoeProcessor(\n+            tokenizer=tokenizer, image_processor=image_processor, video_processor=video_processor\n+        )\n+        processor.save_pretrained(self.tmpdirname)\n+        processor = Ernie4_5_VL_MoeProcessor.from_pretrained(self.tmpdirname)\n+\n+        self.assertEqual(processor.tokenizer.get_vocab(), tokenizer.get_vocab())\n+        self.assertEqual(processor.image_processor.to_json_string(), image_processor.to_json_string())\n+        self.assertIsInstance(processor.tokenizer, LlamaTokenizerFast)\n+        self.assertIsInstance(processor.image_processor, Ernie4_5_VL_MoeImageProcessorFast)\n+\n+    def test_image_processor(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+        video_processor = self.get_video_processor()\n+\n+        processor = Ernie4_5_VL_MoeProcessor(\n+            tokenizer=tokenizer, image_processor=image_processor, video_processor=video_processor\n+        )\n+\n+        image_input = self.prepare_image_inputs()\n+\n+        input_image_proc = image_processor(image_input, return_tensors=\"pt\")\n+        input_processor = processor(images=image_input, text=\"dummy\", return_tensors=\"pt\")\n+\n+        for key in input_image_proc:\n+            self.assertAlmostEqual(input_image_proc[key].sum(), input_processor[key].sum(), delta=1e-2)\n+\n+    def test_processor(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+        video_processor = self.get_video_processor()\n+\n+        processor = Ernie4_5_VL_MoeProcessor(\n+            tokenizer=tokenizer, image_processor=image_processor, video_processor=video_processor\n+        )\n+\n+        input_str = \"lower newer\"\n+        image_input = self.prepare_image_inputs()\n+        inputs = processor(text=input_str, images=image_input)\n+\n+        self.assertListEqual(\n+            list(inputs.keys()),\n+            [\n+                \"input_ids\",\n+                \"attention_mask\",\n+                \"mm_token_type_ids\",\n+                \"moe_mm_token_type_ids\",\n+                \"pixel_values\",\n+                \"image_grid_thw\",\n+            ],\n+        )\n+\n+        # test if it raises when no input is passed\n+        with pytest.raises(ValueError):\n+            processor()\n+\n+        # test if it raises when no text is passed\n+        with pytest.raises(TypeError):\n+            processor(images=image_input)\n+\n+    @require_torch\n+    @require_av\n+    def _test_apply_chat_template(\n+        self,\n+        modality: str,\n+        batch_size: int,\n+        return_tensors: str,\n+        input_name: str,\n+        processor_name: str,\n+        input_data: list[str],\n+    ):\n+        processor = self.get_processor()\n+        if processor.chat_template is None:\n+            self.skipTest(\"Processor has no chat template\")\n+\n+        if processor_name not in self.processor_class.get_attributes():\n+            self.skipTest(f\"{processor_name} attribute not present in {self.processor_class}\")\n+\n+        batch_messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [{\"type\": \"text\", \"text\": \"Describe this.\"}],\n+                },\n+            ]\n+        ] * batch_size\n+\n+        # Test that jinja can be applied\n+        formatted_prompt = processor.apply_chat_template(batch_messages, add_generation_prompt=True, tokenize=False)\n+        self.assertEqual(len(formatted_prompt), batch_size)\n+\n+        # Test that tokenizing with template and directly with `self.tokenizer` gives same output\n+        formatted_prompt_tokenized = processor.apply_chat_template(\n+            batch_messages, add_generation_prompt=True, tokenize=True, return_tensors=return_tensors\n+        )\n+        add_special_tokens = True\n+        if processor.tokenizer.bos_token is not None and formatted_prompt[0].startswith(processor.tokenizer.bos_token):\n+            add_special_tokens = False\n+        tok_output = processor.tokenizer(\n+            formatted_prompt, return_tensors=return_tensors, add_special_tokens=add_special_tokens\n+        )\n+        expected_output = tok_output.input_ids\n+        self.assertListEqual(expected_output.tolist(), formatted_prompt_tokenized.tolist())\n+\n+        # Test that kwargs passed to processor's `__call__` are actually used\n+        tokenized_prompt_100 = processor.apply_chat_template(\n+            batch_messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            padding=\"max_length\",\n+            truncation=True,\n+            return_tensors=return_tensors,\n+            max_length=100,\n+        )\n+        self.assertEqual(len(tokenized_prompt_100[0]), 100)\n+\n+        # Test that `return_dict=True` returns text related inputs in the dict\n+        out_dict_text = processor.apply_chat_template(\n+            batch_messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=return_tensors,\n+        )\n+        self.assertTrue(\n+            all(\n+                key in out_dict_text\n+                for key in [\"input_ids\", \"attention_mask\", \"mm_token_type_ids\", \"moe_mm_token_type_ids\"]\n+            )\n+        )\n+        self.assertEqual(len(out_dict_text[\"input_ids\"]), batch_size)\n+        self.assertEqual(len(out_dict_text[\"attention_mask\"]), batch_size)\n+        self.assertEqual(len(out_dict_text[\"mm_token_type_ids\"]), batch_size)\n+        self.assertEqual(len(out_dict_text[\"moe_mm_token_type_ids\"]), batch_size)\n+\n+        # Test that with modality URLs and `return_dict=True`, we get modality inputs in the dict\n+        for idx, url in enumerate(input_data[:batch_size]):\n+            batch_messages[idx][0][\"content\"] = [batch_messages[idx][0][\"content\"][0], {\"type\": modality, \"url\": url}]\n+\n+        out_dict = processor.apply_chat_template(\n+            batch_messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=return_tensors,\n+            max_frames=2,  # by default no more than 2 frames, otherwise too slow\n+        )\n+        input_name = getattr(self, input_name)\n+        self.assertTrue(input_name in out_dict)\n+        self.assertEqual(len(out_dict[\"input_ids\"]), batch_size)\n+        self.assertEqual(len(out_dict[\"attention_mask\"]), batch_size)\n+        self.assertEqual(len(out_dict[\"mm_token_type_ids\"]), batch_size)\n+        self.assertEqual(len(out_dict[\"moe_mm_token_type_ids\"]), batch_size)\n+\n+        if modality == \"video\":\n+            # qwen pixels don't scale with bs same way as other models, calculate expected video token count based on video_grid_thw\n+            expected_video_token_count = 0\n+            for thw in out_dict[\"video_grid_thw\"]:\n+                expected_video_token_count += thw[0] * thw[1] * thw[2]\n+            mm_len = expected_video_token_count\n+        else:\n+            mm_len = batch_size * 192\n+        self.assertEqual(len(out_dict[input_name]), mm_len)\n+\n+        return_tensor_to_type = {\"pt\": torch.Tensor, \"np\": np.ndarray, None: list}\n+        for k in out_dict:\n+            self.assertIsInstance(out_dict[k], return_tensor_to_type[return_tensors])\n+\n+    @require_av\n+    def test_apply_chat_template_video_frame_sampling(self):\n+        processor = self.get_processor()\n+        if processor.chat_template is None:\n+            self.skipTest(\"Processor has no chat template\")\n+\n+        signature = inspect.signature(processor.__call__)\n+        if \"videos\" not in {*signature.parameters.keys()} or (\n+            signature.parameters.get(\"videos\") is not None\n+            and signature.parameters[\"videos\"].annotation == inspect._empty\n+        ):\n+            self.skipTest(\"Processor doesn't accept videos at input\")\n+\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\"type\": \"video\"},\n+                        {\"type\": \"text\", \"text\": \"What is shown in this video?\"},\n+                    ],\n+                },\n+            ]\n+        ]\n+\n+        formatted_prompt = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=False)\n+        self.assertEqual(len(formatted_prompt), 1)\n+\n+        formatted_prompt_tokenized = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=True)\n+        expected_output = processor.tokenizer(formatted_prompt, return_tensors=None).input_ids\n+        self.assertListEqual(expected_output, formatted_prompt_tokenized)\n+\n+        out_dict = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=True, return_dict=True)\n+        self.assertListEqual(\n+            list(out_dict.keys()), [\"input_ids\", \"attention_mask\", \"mm_token_type_ids\", \"moe_mm_token_type_ids\"]\n+        )\n+\n+        # Add video URL for return dict and load with `num_frames` arg\n+        messages[0][0][\"content\"][0] = {\n+            \"type\": \"video\",\n+            \"url\": \"https://huggingface.co/datasets/raushan-testing-hf/videos-test/resolve/main/tiny_video.mp4\",\n+        }\n+        num_frames = 3\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            num_frames=num_frames,\n+            min_frames=3,  # default is 16\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 720)\n+\n+        # Load with `fps` arg\n+        fps = 1\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            fps=fps,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 2160)\n+\n+        # Load with `fps` and `num_frames` args, should raise an error\n+        with self.assertRaises(ValueError):\n+            out_dict_with_video = processor.apply_chat_template(\n+                messages,\n+                add_generation_prompt=True,\n+                tokenize=True,\n+                return_dict=True,\n+                fps=fps,\n+                num_frames=num_frames,\n+            )\n+\n+        # Load without any arg should load the whole video\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 2160)\n+\n+        # Load video as a list of frames (i.e. images). NOTE: each frame should have same size\n+        # because we assume they come from one video\n+        messages[0][0][\"content\"][0] = {\n+            \"type\": \"video\",\n+            \"url\": [\n+                \"https://www.ilankelman.org/stopsigns/australia.jpg\",\n+                \"https://www.ilankelman.org/stopsigns/australia.jpg\",\n+            ],\n+        }\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            do_sample_frames=False,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 320)\n+\n+    def test_kwargs_overrides_custom_image_processor_kwargs(self):\n+        processor = self.get_processor()\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = self.prepare_text_inputs()\n+        image_input = self.prepare_image_inputs()\n+\n+        size = {\"shortest_edge\": processor.image_processor.size[\"shortest_edge\"], \"longest_edge\": 56 * 56 * 4}\n+        inputs = processor(text=input_str, images=image_input, size=size, return_tensors=\"pt\")\n+        self.assertEqual(inputs[self.images_input_name].shape[0], 612)\n+        inputs = processor(text=input_str, images=image_input, return_tensors=\"pt\")\n+        self.assertEqual(inputs[self.images_input_name].shape[0], 100)"
        },
        {
            "sha": "f539a524e5580da9377f34d61f7cc4efab1e5f2d",
            "filename": "tests/models/ernie4_5_vl_moe/test_video_processing_ernie4_5_vl_moe.py",
            "status": "added",
            "additions": 336,
            "deletions": 0,
            "changes": 336,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/tests%2Fmodels%2Fernie4_5_vl_moe%2Ftest_video_processing_ernie4_5_vl_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/tests%2Fmodels%2Fernie4_5_vl_moe%2Ftest_video_processing_ernie4_5_vl_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fernie4_5_vl_moe%2Ftest_video_processing_ernie4_5_vl_moe.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -0,0 +1,336 @@\n+# coding=utf-8\n+# Copyright 2025 HuggingFace Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+import numpy as np\n+\n+from transformers.image_utils import IMAGENET_STANDARD_MEAN, IMAGENET_STANDARD_STD\n+from transformers.testing_utils import require_torch, require_vision\n+from transformers.utils import is_torch_available, is_torchvision_available, is_vision_available\n+\n+from ...test_video_processing_common import VideoProcessingTestMixin, prepare_video_inputs\n+\n+\n+if is_torch_available():\n+    from PIL import Image\n+\n+if is_vision_available():\n+    if is_torchvision_available():\n+        from transformers import Ernie4_5_VL_MoeVideoProcessor\n+        from transformers.models.ernie4_5_vl_moe.video_processing_ernie4_5_vl_moe import smart_resize\n+\n+\n+class Ernie4_5_VL_MoeVideoProcessingTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=5,\n+        num_frames=8,\n+        num_channels=3,\n+        min_resolution=30,\n+        max_resolution=80,\n+        temporal_patch_size=2,\n+        patch_size=14,\n+        merge_size=2,\n+        do_resize=True,\n+        size=None,\n+        do_normalize=True,\n+        image_mean=IMAGENET_STANDARD_MEAN,\n+        image_std=IMAGENET_STANDARD_STD,\n+        do_convert_rgb=True,\n+        draw_on_frames=False,\n+    ):\n+        size = size if size is not None else {\"longest_edge\": 20, \"shortest_edge\": 10}\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.num_frames = num_frames\n+        self.num_channels = num_channels\n+        self.min_resolution = min_resolution\n+        self.max_resolution = max_resolution\n+        self.do_resize = do_resize\n+        self.size = size\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean\n+        self.image_std = image_std\n+        self.do_convert_rgb = do_convert_rgb\n+        self.temporal_patch_size = temporal_patch_size\n+        self.patch_size = patch_size\n+        self.merge_size = merge_size\n+        self.draw_on_frames = draw_on_frames\n+\n+    def prepare_video_processor_dict(self):\n+        return {\n+            \"do_resize\": self.do_resize,\n+            \"size\": self.size,\n+            \"do_normalize\": self.do_normalize,\n+            \"image_mean\": self.image_mean,\n+            \"image_std\": self.image_std,\n+            \"do_convert_rgb\": self.do_convert_rgb,\n+            \"do_sample_frames\": True,\n+            \"draw_on_frames\": self.draw_on_frames,\n+        }\n+\n+    def prepare_video_metadata(self, videos):\n+        video_metadata = []\n+        for video in videos:\n+            if isinstance(video, list):\n+                num_frames = len(video)\n+            elif hasattr(video, \"shape\"):\n+                if len(video.shape) == 4:  # (T, H, W, C)\n+                    num_frames = video.shape[0]\n+                else:\n+                    num_frames = 1\n+            else:\n+                num_frames = self.num_frames\n+\n+            metadata = {\n+                \"fps\": 2,\n+                \"duration\": num_frames / 2,\n+                \"total_num_frames\": num_frames,\n+            }\n+            video_metadata.append(metadata)\n+        return video_metadata\n+\n+    def expected_output_video_shape(self, videos):\n+        grid_t = self.num_frames\n+        hidden_dim = self.num_channels * self.patch_size * self.patch_size\n+        seq_len = 0\n+        for video in videos:\n+            if isinstance(video, list) and isinstance(video[0], Image.Image):\n+                video = np.stack([np.array(frame) for frame in video])\n+            elif hasattr(video, \"shape\"):\n+                pass\n+            else:\n+                video = np.array(video)\n+\n+            if hasattr(video, \"shape\") and len(video.shape) >= 3:\n+                if len(video.shape) == 4:\n+                    _, height, width = video.shape[:3]\n+                elif len(video.shape) == 3:\n+                    height, width = video.shape[:2]\n+                else:\n+                    height, width = self.num_frames, self.min_resolution, self.min_resolution\n+            else:\n+                height, width = self.min_resolution, self.min_resolution\n+\n+            resized_height, resized_width = smart_resize(\n+                height,\n+                width,\n+                factor=self.patch_size * self.merge_size,\n+                min_pixels=self.size[\"shortest_edge\"],\n+                max_pixels=self.size[\"longest_edge\"],\n+            )\n+            grid_h, grid_w = resized_height // self.patch_size, resized_width // self.patch_size\n+            seq_len += grid_t * grid_h * grid_w\n+        return [seq_len, hidden_dim]\n+\n+    def prepare_video_inputs(self, equal_resolution=False, return_tensors=\"pil\"):\n+        videos = prepare_video_inputs(\n+            batch_size=self.batch_size,\n+            num_frames=self.num_frames,\n+            num_channels=self.num_channels,\n+            min_resolution=self.min_resolution,\n+            max_resolution=self.max_resolution,\n+            equal_resolution=equal_resolution,\n+            return_tensors=return_tensors,\n+        )\n+        return videos\n+\n+\n+@require_torch\n+@require_vision\n+class Ernie4_5_VL_MoeVideoProcessingTest(VideoProcessingTestMixin, unittest.TestCase):\n+    fast_video_processing_class = Ernie4_5_VL_MoeVideoProcessor if is_torchvision_available() else None\n+    input_name = \"pixel_values_videos\"\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.video_processor_tester = Ernie4_5_VL_MoeVideoProcessingTester(self)\n+\n+    @property\n+    def video_processor_dict(self):\n+        return self.video_processor_tester.prepare_video_processor_dict()\n+\n+    def test_video_processor_from_dict_with_kwargs(self):\n+        video_processor = self.fast_video_processing_class.from_dict(self.video_processor_dict)\n+        self.assertEqual(video_processor.size, {\"longest_edge\": 20, \"shortest_edge\": 10})\n+\n+        video_processor = self.fast_video_processing_class.from_dict(\n+            self.video_processor_dict, size={\"longest_edge\": 42, \"shortest_edge\": 42}\n+        )\n+        self.assertEqual(video_processor.size, {\"longest_edge\": 42, \"shortest_edge\": 42})\n+\n+    def test_call_pil(self):\n+        for video_processing_class in self.video_processor_list:\n+            video_processing = video_processing_class(**self.video_processor_dict)\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"pil\"\n+            )\n+\n+            for video in video_inputs:\n+                self.assertIsInstance(video[0], Image.Image)\n+\n+            video_metadata = self.video_processor_tester.prepare_video_metadata(video_inputs)\n+            encoded_videos = video_processing(\n+                video_inputs[0], video_metadata=[video_metadata[0]], return_tensors=\"pt\"\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+            encoded_videos = video_processing(video_inputs, video_metadata=video_metadata, return_tensors=\"pt\")[\n+                self.input_name\n+            ]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    def test_call_numpy(self):\n+        for video_processing_class in self.video_processor_list:\n+            video_processing = video_processing_class(**self.video_processor_dict)\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"np\"\n+            )\n+\n+            video_metadata = self.video_processor_tester.prepare_video_metadata(video_inputs)\n+            encoded_videos = video_processing(\n+                video_inputs[0], video_metadata=[video_metadata[0]], return_tensors=\"pt\"\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+            encoded_videos = video_processing(video_inputs, video_metadata=video_metadata, return_tensors=\"pt\")[\n+                self.input_name\n+            ]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    def test_call_pytorch(self):\n+        for video_processing_class in self.video_processor_list:\n+            video_processing = video_processing_class(**self.video_processor_dict)\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"pt\"\n+            )\n+            video_metadata = self.video_processor_tester.prepare_video_metadata(video_inputs)\n+            encoded_videos = video_processing(\n+                video_inputs[0], video_metadata=[video_metadata[0]], return_tensors=\"pt\"\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+            encoded_videos = video_processing(video_inputs, video_metadata=video_metadata, return_tensors=\"pt\")[\n+                self.input_name\n+            ]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    @unittest.skip(\"Skip for now, the test needs adjustment for Ernie 4.5 VL\")\n+    def test_call_numpy_4_channels(self):\n+        for video_processing_class in self.video_processor_list:\n+            # Test that can process videos which have an arbitrary number of channels\n+            # Initialize video_processing\n+            video_processor = video_processing_class(**self.video_processor_dict)\n+\n+            # create random numpy tensors\n+            self.video_processor_tester.num_channels = 4\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"np\"\n+            )\n+\n+            # Test not batched input\n+            encoded_videos = video_processor(\n+                video_inputs[0],\n+                return_tensors=\"pt\",\n+                input_data_format=\"channels_last\",\n+                image_mean=(0.0, 0.0, 0.0, 0.0),\n+                image_std=(1.0, 1.0, 1.0, 1.0),\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+            # Test batched\n+            encoded_videos = video_processor(\n+                video_inputs,\n+                return_tensors=\"pt\",\n+                input_data_format=\"channels_last\",\n+                image_mean=(0.0, 0.0, 0.0, 0.0),\n+                image_std=(1.0, 1.0, 1.0, 1.0),\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    def test_nested_input(self):\n+        \"\"\"Tests that the processor can work with nested list where each video is a list of arrays\"\"\"\n+        for video_processing_class in self.video_processor_list:\n+            video_processing = video_processing_class(**self.video_processor_dict)\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"np\"\n+            )\n+\n+            video_inputs_nested = [list(video) for video in video_inputs]\n+            video_metadata = self.video_processor_tester.prepare_video_metadata(video_inputs)\n+\n+            # Test not batched input\n+            encoded_videos = video_processing(\n+                video_inputs_nested[0], video_metadata=[video_metadata[0]], return_tensors=\"pt\"\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+            # Test batched\n+            encoded_videos = video_processing(video_inputs_nested, video_metadata=video_metadata, return_tensors=\"pt\")[\n+                self.input_name\n+            ]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    def test_call_sample_frames(self):\n+        for video_processing_class in self.video_processor_list:\n+            video_processor_dict = self.video_processor_dict.copy()\n+            video_processing = video_processing_class(**video_processor_dict)\n+\n+            prev_num_frames = self.video_processor_tester.num_frames\n+            self.video_processor_tester.num_frames = 8\n+            prev_min_resolution = getattr(self.video_processor_tester, \"min_resolution\", None)\n+            prev_max_resolution = getattr(self.video_processor_tester, \"max_resolution\", None)\n+            self.video_processor_tester.min_resolution = 56\n+            self.video_processor_tester.max_resolution = 112\n+\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False,\n+                return_tensors=\"torch\",\n+            )\n+\n+            metadata = [[{\"total_num_frames\": 8, \"fps\": 4}]]\n+            batched_metadata = metadata * len(video_inputs)\n+\n+            encoded_videos = video_processing(video_inputs[0], return_tensors=\"pt\", video_metadata=metadata)[\n+                self.input_name\n+            ]\n+            encoded_videos_batched = video_processing(\n+                video_inputs, return_tensors=\"pt\", video_metadata=batched_metadata\n+            )[self.input_name]\n+\n+            self.assertIsNotNone(encoded_videos)\n+            self.assertIsNotNone(encoded_videos_batched)\n+            self.assertEqual(len(encoded_videos.shape), 2)\n+            self.assertEqual(len(encoded_videos_batched.shape), 2)\n+\n+            # error out when sampled frames would go over total number of frames\n+            with self.assertRaises(ValueError):\n+                video_processing(video_inputs[0], num_frames=10, return_tensors=\"pt\")[self.input_name]\n+\n+            self.video_processor_tester.num_frames = prev_num_frames\n+            if prev_min_resolution is not None:\n+                self.video_processor_tester.min_resolution = prev_min_resolution\n+            if prev_max_resolution is not None:\n+                self.video_processor_tester.max_resolution = prev_max_resolution"
        },
        {
            "sha": "40936871a1fee8f2d8e091ba19e96248afea62c9",
            "filename": "tests/utils/test_core_model_loading.py",
            "status": "modified",
            "additions": 203,
            "deletions": 5,
            "changes": 208,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/tests%2Futils%2Ftest_core_model_loading.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/tests%2Futils%2Ftest_core_model_loading.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Futils%2Ftest_core_model_loading.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -22,6 +22,7 @@\n from transformers.core_model_loading import (\n     Chunk,\n     Concatenate,\n+    ErnieFuseAndSplitTextVisionExperts,\n     MergeModulelist,\n     PermuteForRope,\n     WeightConverter,\n@@ -182,16 +183,18 @@ def __init__(self):\n \n \n class DummyLayer(nn.Module):\n-    def __init__(self):\n+    def __init__(self, add_extra_moe=False):\n         super().__init__()\n         self.self_attn = DummySelfAttn()\n         self.experts = DummyExperts()\n+        if add_extra_moe:\n+            self.extra_experts = DummyExperts()\n \n \n class DummyTopModel(nn.Module):\n-    def __init__(self):\n+    def __init__(self, add_extra_moe=False):\n         super().__init__()\n-        self.layers = nn.ModuleList([DummyLayer(), DummyLayer()])\n+        self.layers = nn.ModuleList([DummyLayer(add_extra_moe), DummyLayer(add_extra_moe)])\n \n \n class DummyMLP(nn.Module):\n@@ -203,9 +206,9 @@ def __init__(self):\n class DummyRoot(nn.Module):\n     base_model_prefix = \"model\"\n \n-    def __init__(self):\n+    def __init__(self, add_extra_moe=False):\n         super().__init__()\n-        self.model = DummyTopModel()\n+        self.model = DummyTopModel(add_extra_moe)\n         self.mlp = DummyMLP()\n \n \n@@ -505,6 +508,201 @@ def __init__(self):\n         )\n         torch.testing.assert_close(dequantized_q, expected_q, rtol=1e-2, atol=1e-2)\n \n+    def test_ernie4_5_vl_moe_conversion(self):\n+        model = DummyRoot(add_extra_moe=True)\n+        model.config = PretrainedConfig()\n+\n+        raw_tensors = {\n+            \"model.layers.0.experts.0.w1.weight\": torch.tensor([[0.0, 1.0], [2.0, 3.0]]),\n+            \"model.layers.0.experts.1.w1.weight\": torch.tensor([[10.0, 11.0], [12.0, 13.0]]),\n+            \"model.layers.0.experts.2.w1.weight\": torch.tensor([[11.0, 12.0], [13.0, 14.0]]),\n+            \"model.layers.0.experts.3.w1.weight\": torch.tensor([[12.0, 13.0], [14.0, 15.0]]),\n+            \"model.layers.0.experts.0.w3.weight\": torch.tensor([[4.0, 5.0], [6.0, 7.0]]),\n+            \"model.layers.0.experts.1.w3.weight\": torch.tensor([[14.0, 15.0], [16.0, 17.0]]),\n+            \"model.layers.0.experts.2.w3.weight\": torch.tensor([[15.0, 16.0], [17.0, 18.0]]),\n+            \"model.layers.0.experts.3.w3.weight\": torch.tensor([[16.0, 17.0], [18.0, 19.0]]),\n+            \"model.layers.0.experts.0.w2.weight\": torch.tensor([[20.0, 21.0], [22.0, 23.0]]),\n+            \"model.layers.0.experts.1.w2.weight\": torch.tensor([[24.0, 25.0], [26.0, 27.0]]),\n+            \"model.layers.0.experts.2.w2.weight\": torch.tensor([[25.0, 26.0], [27.0, 28.0]]),\n+            \"model.layers.0.experts.3.w2.weight\": torch.tensor([[26.0, 27.0], [28.0, 29.0]]),\n+            \"model.layers.1.experts.0.w1.weight\": torch.tensor([[30.0, 31.0], [32.0, 33.0]]),\n+            \"model.layers.1.experts.1.w1.weight\": torch.tensor([[34.0, 35.0], [36.0, 37.0]]),\n+            \"model.layers.1.experts.2.w1.weight\": torch.tensor([[35.0, 36.0], [37.0, 38.0]]),\n+            \"model.layers.1.experts.3.w1.weight\": torch.tensor([[36.0, 37.0], [38.0, 39.0]]),\n+            \"model.layers.1.experts.0.w3.weight\": torch.tensor([[38.0, 39.0], [40.0, 41.0]]),\n+            \"model.layers.1.experts.1.w3.weight\": torch.tensor([[42.0, 43.0], [44.0, 45.0]]),\n+            \"model.layers.1.experts.2.w3.weight\": torch.tensor([[43.0, 44.0], [45.0, 46.0]]),\n+            \"model.layers.1.experts.3.w3.weight\": torch.tensor([[44.0, 45.0], [46.0, 47.0]]),\n+            \"model.layers.1.experts.0.w2.weight\": torch.tensor([[46.0, 47.0], [48.0, 49.0]]),\n+            \"model.layers.1.experts.1.w2.weight\": torch.tensor([[50.0, 51.0], [52.0, 53.0]]),\n+            \"model.layers.1.experts.2.w2.weight\": torch.tensor([[51.0, 52.0], [53.0, 54.0]]),\n+            \"model.layers.1.experts.3.w2.weight\": torch.tensor([[52.0, 53.0], [54.0, 55.0]]),\n+            \"model.layers.0.self_attn.qkv_proj.weight\": torch.tensor([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]),\n+            \"model.layers.1.self_attn.qkv_proj.weight\": torch.tensor([[7.0, 8.0], [9.0, 10.0], [11.0, 12.0]]),\n+            \"mlp.w2.weight\": torch.tensor([[60.0, 61.0], [62.0, 63.0]]),\n+        }\n+        state_dict = {k: v.clone() for k, v in raw_tensors.items()}\n+\n+        weight_mapping = [\n+            WeightConverter(\n+                [\"experts.*.w1.weight\", \"experts.*.w3.weight\"],\n+                [\"experts.gate_up_proj.weight\", \"extra_experts.gate_up_proj.weight\"],\n+                operations=[ErnieFuseAndSplitTextVisionExperts(stack_dim=0, concat_dim=1)],\n+            ),\n+            WeightConverter(\n+                \"experts.*.w2.weight\",\n+                [\"experts.down_proj.weight\", \"extra_experts.down_proj.weight\"],\n+                operations=[ErnieFuseAndSplitTextVisionExperts(stack_dim=0, concat_dim=1)],\n+            ),\n+            WeightConverter(\n+                \"self_attn.qkv_proj.weight\",\n+                [\n+                    \"self_attn.q_proj.weight\",\n+                    \"self_attn.k_proj.weight\",\n+                    \"self_attn.v_proj.weight\",\n+                ],\n+                operations=[Chunk(dim=0)],\n+            ),\n+            WeightRenaming(\"mlp.w2.weight\", \"mlp.down_proj.weight\"),\n+        ]\n+        missing, unexpected, mismatch, _, misc = convert_and_load_state_dict_in_model(\n+            model, state_dict, weight_mapping, tp_plan=None, hf_quantizer=None\n+        )\n+\n+        self.assertEqual(missing, set())\n+        self.assertEqual(unexpected, set())\n+        self.assertEqual(mismatch, set())\n+        self.assertEqual(misc, {})\n+\n+        model_state = model.state_dict()\n+\n+        def cat_gate(layer_prefix: str) -> torch.Tensor:\n+            moe_1_w1 = [\n+                raw_tensors[f\"{layer_prefix}.experts.0.w1.weight\"],\n+                raw_tensors[f\"{layer_prefix}.experts.1.w1.weight\"],\n+            ]\n+            moe_2_w1 = [\n+                raw_tensors[f\"{layer_prefix}.experts.2.w1.weight\"],\n+                raw_tensors[f\"{layer_prefix}.experts.3.w1.weight\"],\n+            ]\n+            moe_1_w3 = [\n+                raw_tensors[f\"{layer_prefix}.experts.0.w3.weight\"],\n+                raw_tensors[f\"{layer_prefix}.experts.1.w3.weight\"],\n+            ]\n+            moe_2_w3 = [\n+                raw_tensors[f\"{layer_prefix}.experts.2.w3.weight\"],\n+                raw_tensors[f\"{layer_prefix}.experts.3.w3.weight\"],\n+            ]\n+            moe_1 = torch.cat([torch.stack(moe_1_w1, dim=0), torch.stack(moe_1_w3, dim=0)], dim=1)\n+            moe_2 = torch.cat([torch.stack(moe_2_w1, dim=0), torch.stack(moe_2_w3, dim=0)], dim=1)\n+            return moe_1, moe_2\n+\n+        moe_1, moe_2 = cat_gate(\"model.layers.0\")\n+        torch.testing.assert_close(model_state[\"model.layers.0.experts.gate_up_proj.weight\"], moe_1)\n+        torch.testing.assert_close(model_state[\"model.layers.0.extra_experts.gate_up_proj.weight\"], moe_2)\n+\n+        moe_1, moe_2 = cat_gate(\"model.layers.1\")\n+        torch.testing.assert_close(model_state[\"model.layers.1.experts.gate_up_proj.weight\"], moe_1)\n+        torch.testing.assert_close(model_state[\"model.layers.1.extra_experts.gate_up_proj.weight\"], moe_2)\n+\n+        def stack_down(layer_prefix: str) -> torch.Tensor:\n+            moe_1 = torch.stack(\n+                [\n+                    raw_tensors[f\"{layer_prefix}.experts.0.w2.weight\"],\n+                    raw_tensors[f\"{layer_prefix}.experts.1.w2.weight\"],\n+                ],\n+                dim=0,\n+            )\n+            moe_2 = torch.stack(\n+                [\n+                    raw_tensors[f\"{layer_prefix}.experts.2.w2.weight\"],\n+                    raw_tensors[f\"{layer_prefix}.experts.3.w2.weight\"],\n+                ],\n+                dim=0,\n+            )\n+            return moe_1, moe_2\n+\n+        moe_1, moe_2 = stack_down(\"model.layers.0\")\n+        torch.testing.assert_close(model_state[\"model.layers.0.experts.down_proj.weight\"], moe_1)\n+        torch.testing.assert_close(model_state[\"model.layers.0.extra_experts.down_proj.weight\"], moe_2)\n+\n+        moe_1, moe_2 = stack_down(\"model.layers.1\")\n+        torch.testing.assert_close(model_state[\"model.layers.1.experts.down_proj.weight\"], moe_1)\n+        torch.testing.assert_close(model_state[\"model.layers.1.extra_experts.down_proj.weight\"], moe_2)\n+\n+    def test_ernie4_5_vl_moe_conversion_reversed(self):\n+        model = DummyRoot(add_extra_moe=True)\n+        model.config = PretrainedConfig()\n+\n+        raw_tensors = {\n+            \"model.layers.0.experts.0.w1.weight\": torch.tensor([[0.0, 1.0], [2.0, 3.0]]),\n+            \"model.layers.0.experts.1.w1.weight\": torch.tensor([[10.0, 11.0], [12.0, 13.0]]),\n+            \"model.layers.0.experts.2.w1.weight\": torch.tensor([[11.0, 12.0], [13.0, 14.0]]),\n+            \"model.layers.0.experts.3.w1.weight\": torch.tensor([[12.0, 13.0], [14.0, 15.0]]),\n+            \"model.layers.0.experts.0.w3.weight\": torch.tensor([[4.0, 5.0], [6.0, 7.0]]),\n+            \"model.layers.0.experts.1.w3.weight\": torch.tensor([[14.0, 15.0], [16.0, 17.0]]),\n+            \"model.layers.0.experts.2.w3.weight\": torch.tensor([[15.0, 16.0], [17.0, 18.0]]),\n+            \"model.layers.0.experts.3.w3.weight\": torch.tensor([[16.0, 17.0], [18.0, 19.0]]),\n+            \"model.layers.0.experts.0.w2.weight\": torch.tensor([[20.0, 21.0], [22.0, 23.0]]),\n+            \"model.layers.0.experts.1.w2.weight\": torch.tensor([[24.0, 25.0], [26.0, 27.0]]),\n+            \"model.layers.0.experts.2.w2.weight\": torch.tensor([[25.0, 26.0], [27.0, 28.0]]),\n+            \"model.layers.0.experts.3.w2.weight\": torch.tensor([[26.0, 27.0], [28.0, 29.0]]),\n+            \"model.layers.1.experts.0.w1.weight\": torch.tensor([[30.0, 31.0], [32.0, 33.0]]),\n+            \"model.layers.1.experts.1.w1.weight\": torch.tensor([[34.0, 35.0], [36.0, 37.0]]),\n+            \"model.layers.1.experts.2.w1.weight\": torch.tensor([[35.0, 36.0], [37.0, 38.0]]),\n+            \"model.layers.1.experts.3.w1.weight\": torch.tensor([[36.0, 37.0], [38.0, 39.0]]),\n+            \"model.layers.1.experts.0.w3.weight\": torch.tensor([[38.0, 39.0], [40.0, 41.0]]),\n+            \"model.layers.1.experts.1.w3.weight\": torch.tensor([[42.0, 43.0], [44.0, 45.0]]),\n+            \"model.layers.1.experts.2.w3.weight\": torch.tensor([[43.0, 44.0], [45.0, 46.0]]),\n+            \"model.layers.1.experts.3.w3.weight\": torch.tensor([[44.0, 45.0], [46.0, 47.0]]),\n+            \"model.layers.1.experts.0.w2.weight\": torch.tensor([[46.0, 47.0], [48.0, 49.0]]),\n+            \"model.layers.1.experts.1.w2.weight\": torch.tensor([[50.0, 51.0], [52.0, 53.0]]),\n+            \"model.layers.1.experts.2.w2.weight\": torch.tensor([[51.0, 52.0], [53.0, 54.0]]),\n+            \"model.layers.1.experts.3.w2.weight\": torch.tensor([[52.0, 53.0], [54.0, 55.0]]),\n+            \"model.layers.0.self_attn.qkv_proj.weight\": torch.tensor([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]),\n+            \"model.layers.1.self_attn.qkv_proj.weight\": torch.tensor([[7.0, 8.0], [9.0, 10.0], [11.0, 12.0]]),\n+            \"mlp.w2.weight\": torch.tensor([[60.0, 61.0], [62.0, 63.0]]),\n+        }\n+        state_dict = {k: v.clone() for k, v in raw_tensors.items()}\n+\n+        weight_mapping = [\n+            WeightConverter(\n+                [\"experts.*.w1.weight\", \"experts.*.w3.weight\"],\n+                [\"experts.gate_up_proj.weight\", \"extra_experts.gate_up_proj.weight\"],\n+                operations=[ErnieFuseAndSplitTextVisionExperts(stack_dim=0, concat_dim=1)],\n+            ),\n+            WeightConverter(\n+                \"experts.*.w2.weight\",\n+                [\"experts.down_proj.weight\", \"extra_experts.down_proj.weight\"],\n+                operations=[ErnieFuseAndSplitTextVisionExperts(stack_dim=0, concat_dim=1)],\n+            ),\n+            WeightConverter(\n+                \"self_attn.qkv_proj.weight\",\n+                [\n+                    \"self_attn.q_proj.weight\",\n+                    \"self_attn.k_proj.weight\",\n+                    \"self_attn.v_proj.weight\",\n+                ],\n+                operations=[Chunk(dim=0)],\n+            ),\n+            WeightRenaming(\"mlp.w2.weight\", \"mlp.down_proj.weight\"),\n+        ]\n+\n+        # Use the mapping to load\n+        missing, unexpected, mismatch, _, misc = convert_and_load_state_dict_in_model(\n+            model, state_dict, weight_mapping, tp_plan=None, hf_quantizer=None\n+        )\n+        self.assertTrue(len(missing) == 0)\n+        self.assertTrue(len(unexpected) == 0)\n+        self.assertTrue(len(mismatch) == 0)\n+        self.assertTrue(len(misc) == 0)\n+\n+        # Try to revert the mapping\n+        reversed_state_dict = revert_weight_conversion(model, model.state_dict())\n+\n+        # Make sure both saved state_dict are identical\n+        self.assertTrue(compare_state_dicts(reversed_state_dict, state_dict))\n+\n \n class TestConversionMapping(unittest.TestCase):\n     def test_register_checkpoint_conversion_mapping(self):"
        },
        {
            "sha": "e2055f0d65cdc3bef0f4037c9810710faf126d46",
            "filename": "utils/check_config_attributes.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/utils%2Fcheck_config_attributes.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/utils%2Fcheck_config_attributes.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_config_attributes.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -39,6 +39,7 @@\n     \"xLSTMConfig\": [\"add_out_norm\", \"chunkwise_kernel\", \"sequence_kernel\", \"step_kernel\"],\n     \"Ernie4_5Config\": [\"tie_word_embeddings\"],\n     \"Ernie4_5_MoeConfig\": [\"tie_word_embeddings\"],\n+    \"Ernie4_5_VL_MoeTextConfig\": [\"tie_word_embeddings\"],\n     \"Lfm2Config\": [\"full_attn_idxs\", \"tie_word_embeddings\"],\n     \"Lfm2MoeConfig\": [\"tie_word_embeddings\"],\n     # used internally during generation to provide the custom logit processors with their necessary information"
        },
        {
            "sha": "f36cda07dc51e7dae1c285acf94594b8761060b4",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/a8a22624f5598167eb82a3e0bc4228021e5440f6/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/a8a22624f5598167eb82a3e0bc4228021e5440f6/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=a8a22624f5598167eb82a3e0bc4228021e5440f6",
            "patch": "@@ -206,6 +206,7 @@\n         \"BltLocalDecoder\",  # Building part of bigger (tested) model. Tested implicitly through BLTForCausalLM.\n         \"BltGlobalTransformer\",  # Building part of bigger (tested) model. Tested implicitly through BLTForCausalLM.\n         \"Florence2VisionBackbone\",  # Building part of bigger (tested) model. Tested implicitly through Florence2ForConditionalGeneration.\n+        \"Ernie4_5_VL_MoeTextModel\",  # Building part of bigger (tested) model\n         \"PeAudioFrameLevelModel\",\n         \"PeAudioVideoModel\",\n     ]\n@@ -418,6 +419,7 @@\n     \"Qwen3OmniMoeTalkerModel\",  # Building part of a bigger model\n     \"Qwen3OmniMoeThinkerForConditionalGeneration\",  # Building part of a bigger model\n     \"Qwen3OmniMoeThinkerTextModel\",  # Building part of a bigger model\n+    \"Ernie4_5_VL_MoeTextModel\",  # Building part of a bigger model\n     \"PeAudioFrameLevelModel\",\n ]\n "
        }
    ],
    "stats": {
        "total": 8584,
        "additions": 8543,
        "deletions": 41
    }
}