{
    "author": "Rocketknight1",
    "message": "Enable some Jinja extensions and add datetime capabilities (#32684)\n\n* Add new Jinja features:\r\n\r\n- Do extension\r\n- Break/continue in loops\r\n- Call strftime to get current datetime in any format\r\n\r\n* Add new Jinja features:\r\n\r\n- Do extension\r\n- Break/continue in loops\r\n- Call strftime to get current datetime in any format\r\n\r\n* Fix strftime template\r\n\r\n* Add template strip() just to be safe\r\n\r\n* Remove the do extension to make porting easier, and also because it's the least useful\r\n\r\n* Rename test\r\n\r\n* strftime -> strftime_now\r\n\r\n* Split test\r\n\r\n* Update test to use strftime_now\r\n\r\n* Refactor everything out into chat_template_utils\r\n\r\n* Refactor everything out into chat_template_utils\r\n\r\n* Refactor everything out into chat_template_utils\r\n\r\n* Refactor everything out into chat_template_utils\r\n\r\n* Refactor everything out into chat_template_utils",
    "sha": "371b9c14863e01e880897feb93d68d72f1b0fe06",
    "files": [
        {
            "sha": "ca61fcf67642151617e0421a91f4560aeb6e988f",
            "filename": "src/transformers/tokenization_utils_base.py",
            "status": "modified",
            "additions": 3,
            "deletions": 91,
            "changes": 94,
            "blob_url": "https://github.com/huggingface/transformers/blob/371b9c14863e01e880897feb93d68d72f1b0fe06/src%2Ftransformers%2Ftokenization_utils_base.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/371b9c14863e01e880897feb93d68d72f1b0fe06/src%2Ftransformers%2Ftokenization_utils_base.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Ftokenization_utils_base.py?ref=371b9c14863e01e880897feb93d68d72f1b0fe06",
            "patch": "@@ -27,7 +27,6 @@\n from collections.abc import Mapping, Sized\n from contextlib import contextmanager\n from dataclasses import dataclass\n-from functools import lru_cache\n from inspect import isfunction\n from typing import TYPE_CHECKING, Any, Dict, List, NamedTuple, Optional, Sequence, Tuple, Union\n \n@@ -65,6 +64,7 @@\n     requires_backends,\n     to_py_obj,\n )\n+from .utils.chat_template_utils import _compile_jinja_template, _render_with_assistant_indices\n \n \n if TYPE_CHECKING:\n@@ -1791,7 +1791,7 @@ def apply_chat_template(\n             )\n \n         # Compilation function uses a cache to avoid recompiling the same template\n-        compiled_template = self._compile_jinja_template(chat_template)\n+        compiled_template = _compile_jinja_template(chat_template)\n \n         if isinstance(conversation, (list, tuple)) and (\n             isinstance(conversation[0], (list, tuple)) or hasattr(conversation[0], \"messages\")\n@@ -1831,7 +1831,7 @@ def apply_chat_template(\n                 # Indicates it's a Conversation object\n                 chat = chat.messages\n             if return_assistant_tokens_mask:\n-                rendered_chat, generation_indices = self._render_with_assistant_indices(\n+                rendered_chat, generation_indices = _render_with_assistant_indices(\n                     compiled_template=compiled_template,\n                     messages=chat,\n                     tools=tool_schemas,\n@@ -1888,94 +1888,6 @@ def apply_chat_template(\n         else:\n             return rendered\n \n-    def _render_with_assistant_indices(\n-        self, compiled_template, messages, tools, documents, add_generation_prompt, **template_kwargs\n-    ):\n-        rendered_blocks = []\n-        generation_indices = []\n-        with compiled_template.environment.activate_tracker(rendered_blocks, generation_indices):\n-            for block in compiled_template.generate(\n-                messages=messages,\n-                tools=tools,\n-                documents=documents,\n-                add_generation_prompt=add_generation_prompt,\n-                **template_kwargs,\n-            ):\n-                rendered_blocks.append(block)\n-            rendered_chat = \"\".join(rendered_blocks)\n-        return rendered_chat, generation_indices\n-\n-    @lru_cache\n-    def _compile_jinja_template(self, chat_template):\n-        try:\n-            import jinja2\n-            from jinja2 import nodes\n-            from jinja2.exceptions import TemplateError\n-            from jinja2.ext import Extension\n-            from jinja2.sandbox import ImmutableSandboxedEnvironment\n-        except ImportError:\n-            raise ImportError(\"apply_chat_template requires jinja2 to be installed.\")\n-\n-        if version.parse(jinja2.__version__) < version.parse(\"3.1.0\"):\n-            raise ImportError(\n-                \"apply_chat_template requires jinja2>=3.1.0 to be installed. Your version is \" f\"{jinja2.__version__}.\"\n-            )\n-\n-        def raise_exception(message):\n-            raise TemplateError(message)\n-\n-        def tojson(x, ensure_ascii=False, indent=None, separators=None, sort_keys=False):\n-            # We override the built-in tojson filter because Jinja's default filter escapes HTML characters\n-            # We also expose some options like custom indents and separators\n-            return json.dumps(x, ensure_ascii=ensure_ascii, indent=indent, separators=separators, sort_keys=sort_keys)\n-\n-        class AssistantTracker(Extension):\n-            # This extension is used to track the indices of assistant-generated tokens in the rendered chat\n-            tags = {\"generation\"}\n-\n-            def __init__(self, environment: ImmutableSandboxedEnvironment):\n-                # The class is only initiated by jinja.\n-                super().__init__(environment)\n-                environment.extend(activate_tracker=self.activate_tracker)\n-                self._rendered_blocks = None\n-                self._generation_indices = None\n-\n-            def parse(self, parser: jinja2.parser.Parser) -> jinja2.nodes.CallBlock:\n-                lineno = next(parser.stream).lineno\n-                body = parser.parse_statements([\"name:endgeneration\"], drop_needle=True)\n-                return nodes.CallBlock(self.call_method(\"_generation_support\"), [], [], body).set_lineno(lineno)\n-\n-            @jinja2.pass_eval_context\n-            def _generation_support(self, context: jinja2.nodes.EvalContext, caller: jinja2.runtime.Macro) -> str:\n-                rv = caller()\n-                if self.is_active():\n-                    # Only track generation indices if the tracker is active\n-                    start_index = len(\"\".join(self._rendered_blocks))\n-                    end_index = start_index + len(rv)\n-                    self._generation_indices.append((start_index, end_index))\n-                return rv\n-\n-            def is_active(self) -> bool:\n-                return self._rendered_blocks or self._generation_indices\n-\n-            @contextmanager\n-            def activate_tracker(self, rendered_blocks: List[int], generation_indices: List[int]):\n-                try:\n-                    if self.is_active():\n-                        raise ValueError(\"AssistantTracker should not be reused before closed\")\n-                    self._rendered_blocks = rendered_blocks\n-                    self._generation_indices = generation_indices\n-\n-                    yield\n-                finally:\n-                    self._rendered_blocks = None\n-                    self._generation_indices = None\n-\n-        jinja_env = ImmutableSandboxedEnvironment(trim_blocks=True, lstrip_blocks=True, extensions=[AssistantTracker])\n-        jinja_env.filters[\"tojson\"] = tojson\n-        jinja_env.globals[\"raise_exception\"] = raise_exception\n-        return jinja_env.from_string(chat_template)\n-\n     def get_chat_template(self, chat_template: Optional[str] = None, tools: Optional[List[Dict]] = None) -> str:\n         \"\"\"\n         Retrieve the chat template string used for tokenizing chat messages. This template is used"
        },
        {
            "sha": "aabaf4a36665065f4a151794bd2c9837da39accc",
            "filename": "src/transformers/utils/chat_template_utils.py",
            "status": "modified",
            "additions": 103,
            "deletions": 1,
            "changes": 104,
            "blob_url": "https://github.com/huggingface/transformers/blob/371b9c14863e01e880897feb93d68d72f1b0fe06/src%2Ftransformers%2Futils%2Fchat_template_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/371b9c14863e01e880897feb93d68d72f1b0fe06/src%2Ftransformers%2Futils%2Fchat_template_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fchat_template_utils.py?ref=371b9c14863e01e880897feb93d68d72f1b0fe06",
            "patch": "@@ -15,7 +15,22 @@\n import inspect\n import json\n import re\n-from typing import Any, Callable, Dict, Optional, Tuple, Union, get_args, get_origin, get_type_hints\n+from contextlib import contextmanager\n+from datetime import datetime\n+from functools import lru_cache\n+from typing import Any, Callable, Dict, List, Optional, Tuple, Union, get_args, get_origin, get_type_hints\n+\n+from packaging import version\n+\n+from .import_utils import is_jinja_available\n+\n+\n+if is_jinja_available():\n+    import jinja2\n+    from jinja2.ext import Extension\n+    from jinja2.sandbox import ImmutableSandboxedEnvironment\n+else:\n+    jinja2 = None\n \n \n BASIC_TYPES = (int, float, str, bool, Any, type(None), ...)\n@@ -314,3 +329,90 @@ def get_json_schema(func: Callable) -> Dict:\n     if return_dict is not None:\n         output[\"return\"] = return_dict\n     return {\"type\": \"function\", \"function\": output}\n+\n+\n+def _render_with_assistant_indices(\n+    compiled_template, messages, tools, documents, add_generation_prompt, **template_kwargs\n+):\n+    rendered_blocks = []\n+    generation_indices = []\n+    with compiled_template.environment.activate_tracker(rendered_blocks, generation_indices):\n+        for block in compiled_template.generate(\n+            messages=messages,\n+            tools=tools,\n+            documents=documents,\n+            add_generation_prompt=add_generation_prompt,\n+            **template_kwargs,\n+        ):\n+            rendered_blocks.append(block)\n+        rendered_chat = \"\".join(rendered_blocks)\n+    return rendered_chat, generation_indices\n+\n+\n+@lru_cache\n+def _compile_jinja_template(chat_template):\n+    class AssistantTracker(Extension):\n+        # This extension is used to track the indices of assistant-generated tokens in the rendered chat\n+        tags = {\"generation\"}\n+\n+        def __init__(self, environment: ImmutableSandboxedEnvironment):\n+            # The class is only initiated by jinja.\n+            super().__init__(environment)\n+            environment.extend(activate_tracker=self.activate_tracker)\n+            self._rendered_blocks = None\n+            self._generation_indices = None\n+\n+        def parse(self, parser: jinja2.parser.Parser) -> jinja2.nodes.CallBlock:\n+            lineno = next(parser.stream).lineno\n+            body = parser.parse_statements([\"name:endgeneration\"], drop_needle=True)\n+            return jinja2.nodes.CallBlock(self.call_method(\"_generation_support\"), [], [], body).set_lineno(lineno)\n+\n+        @jinja2.pass_eval_context\n+        def _generation_support(self, context: jinja2.nodes.EvalContext, caller: jinja2.runtime.Macro) -> str:\n+            rv = caller()\n+            if self.is_active():\n+                # Only track generation indices if the tracker is active\n+                start_index = len(\"\".join(self._rendered_blocks))\n+                end_index = start_index + len(rv)\n+                self._generation_indices.append((start_index, end_index))\n+            return rv\n+\n+        def is_active(self) -> bool:\n+            return self._rendered_blocks or self._generation_indices\n+\n+        @contextmanager\n+        def activate_tracker(self, rendered_blocks: List[int], generation_indices: List[int]):\n+            try:\n+                if self.is_active():\n+                    raise ValueError(\"AssistantTracker should not be reused before closed\")\n+                self._rendered_blocks = rendered_blocks\n+                self._generation_indices = generation_indices\n+\n+                yield\n+            finally:\n+                self._rendered_blocks = None\n+                self._generation_indices = None\n+\n+    if version.parse(jinja2.__version__) < version.parse(\"3.1.0\"):\n+        raise ImportError(\n+            \"apply_chat_template requires jinja2>=3.1.0 to be installed. Your version is \" f\"{jinja2.__version__}.\"\n+        )\n+\n+    def raise_exception(message):\n+        raise jinja2.exceptions.TemplateError(message)\n+\n+    def tojson(x, ensure_ascii=False, indent=None, separators=None, sort_keys=False):\n+        # We override the built-in tojson filter because Jinja's default filter escapes HTML characters\n+        # We also expose some options like custom indents and separators\n+        return json.dumps(x, ensure_ascii=ensure_ascii, indent=indent, separators=separators, sort_keys=sort_keys)\n+\n+    def strftime_now(format):\n+        return datetime.now().strftime(format)\n+\n+    jinja_env = ImmutableSandboxedEnvironment(\n+        trim_blocks=True, lstrip_blocks=True, extensions=[AssistantTracker, jinja2.ext.loopcontrols]\n+    )\n+    jinja_env.filters[\"tojson\"] = tojson\n+    jinja_env.globals[\"raise_exception\"] = raise_exception\n+    jinja_env.globals[\"strftime_now\"] = strftime_now\n+    return jinja_env.from_string(chat_template)"
        },
        {
            "sha": "f1bcfe3929be477e68b05aee15d5c596b66be2c3",
            "filename": "tests/test_tokenization_common.py",
            "status": "modified",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/huggingface/transformers/blob/371b9c14863e01e880897feb93d68d72f1b0fe06/tests%2Ftest_tokenization_common.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/371b9c14863e01e880897feb93d68d72f1b0fe06/tests%2Ftest_tokenization_common.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Ftest_tokenization_common.py?ref=371b9c14863e01e880897feb93d68d72f1b0fe06",
            "patch": "@@ -1153,6 +1153,51 @@ def test_chat_template_batched(self):\n                     dummy_conversations, chat_template=dummy_template, tokenize=True\n                 )  # Check that no error raised\n \n+    @require_jinja\n+    def test_jinja_loopcontrols(self):\n+        break_template = \"\"\"\n+        {%- for message in messages %}\n+            {{- message.role + \" \" + message.content }}\n+            {%- if loop.first %}\n+                {%- break %}\n+            {%- endif %}\n+        {%- endfor %}\"\"\".strip()\n+\n+        dummy_conversation = [\n+            {\"role\": \"system\", \"content\": \"1\"},\n+            {\"role\": \"user\", \"content\": \"2\"},\n+            {\"role\": \"assistant\", \"content\": \"3\"},\n+        ]\n+\n+        tokenizers = self.get_tokenizers()\n+        for tokenizer in tokenizers:\n+            with self.subTest(f\"{tokenizer.__class__.__name__}\"):\n+                break_output = tokenizer.apply_chat_template(\n+                    dummy_conversation, chat_template=break_template, tokenize=False\n+                )\n+                self.assertEqual(break_output, \"system 1\")  # Loop should break after first iter\n+\n+    @require_jinja\n+    def test_jinja_strftime(self):\n+        strftime_template = \"\"\"{{- strftime_now(\"%Y-%m-%d\") }}\"\"\".strip()\n+\n+        dummy_conversation = [\n+            {\"role\": \"system\", \"content\": \"1\"},\n+            {\"role\": \"user\", \"content\": \"2\"},\n+            {\"role\": \"assistant\", \"content\": \"3\"},\n+        ]\n+\n+        tokenizers = self.get_tokenizers()\n+        for tokenizer in tokenizers:\n+            with self.subTest(f\"{tokenizer.__class__.__name__}\"):\n+                strftime_output = tokenizer.apply_chat_template(\n+                    dummy_conversation, chat_template=strftime_template, tokenize=False\n+                )\n+\n+                # Assert that we get a date formatted as expected\n+                self.assertEqual(len(strftime_output), 10)\n+                self.assertEqual(len(strftime_output.split(\"-\")), 3)\n+\n     @require_jinja\n     def test_chat_template_return_assistant_tokens_mask(self):\n         dummy_template = ("
        }
    ],
    "stats": {
        "total": 243,
        "additions": 151,
        "deletions": 92
    }
}