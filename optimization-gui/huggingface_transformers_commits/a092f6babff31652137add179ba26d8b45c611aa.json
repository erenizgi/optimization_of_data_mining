{
    "author": "tanuj-rai",
    "message": "Update granite.md (#37791)\n\n* Update granite.md\n\n* Update docs/source/en/model_doc/granite.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/granite.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/granite.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* update granite.md\n\n* Update docs/source/en/model_doc/granite.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/granite.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/granite.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/granite.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/granite.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/granite.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* minor fixes\n\n---------\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>",
    "sha": "a092f6babff31652137add179ba26d8b45c611aa",
    "files": [
        {
            "sha": "0f54db1bd2ebe8f5dd56656b896d5506beccf0b0",
            "filename": "docs/source/en/model_doc/granite.md",
            "status": "modified",
            "additions": 75,
            "deletions": 31,
            "changes": 106,
            "blob_url": "https://github.com/huggingface/transformers/blob/a092f6babff31652137add179ba26d8b45c611aa/docs%2Fsource%2Fen%2Fmodel_doc%2Fgranite.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/a092f6babff31652137add179ba26d8b45c611aa/docs%2Fsource%2Fen%2Fmodel_doc%2Fgranite.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fgranite.md?ref=a092f6babff31652137add179ba26d8b45c611aa",
            "patch": "@@ -9,62 +9,106 @@ Unless required by applicable law or agreed to in writing, software distributed\n an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n specific language governing permissions and limitations under the License.\n \n-⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+⚠️ Note that this file is in Markdown but contains specific syntax for our doc-builder (similar to MDX) that may not be\n rendered properly in your Markdown viewer.\n \n -->\n \n-# Granite\n \n <div class=\"flex flex-wrap space-x-1\">\n <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n <img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n <img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n </div>\n \n-## Overview\n+# Granite\n+\n+[Granite](https://huggingface.co/papers/2408.13359) is a 3B parameter language model trained with the Power scheduler. Discovering a good learning rate for pretraining large language models is difficult because it depends on so many variables (batch size, number of training tokens, etc.) and it is expensive to perform a hyperparameter search. The Power scheduler is based on a power-law relationship between the variables and their transferability to larger models. Combining the Power scheduler with Maximum Update Parameterization (MUP) allows a model to be pretrained with one set of hyperparameters regardless of all the variables.\n+\n+You can find all the original Granite checkpoints under the [IBM-Granite](https://huggingface.co/ibm-granite) organization.\n \n-The Granite model was proposed in [Power Scheduler: A Batch Size and Token Number Agnostic Learning Rate Scheduler](https://arxiv.org/abs/2408.13359) by Yikang Shen, Matthew Stallone, Mayank Mishra, Gaoyuan Zhang, Shawn Tan, Aditya Prasad, Adriana Meza Soria, David D. Cox and Rameswar Panda.\n+> [!TIP]\n+> Click on the Granite models in the right sidebar for more examples of how to apply Granite to different language tasks.\n \n-PowerLM-3B is a 3B state-of-the-art small language model trained with the Power learning rate scheduler. It is trained on a wide range of open-source and synthetic datasets with permissive licenses. PowerLM-3B has shown promising results compared to other models in the size categories across various benchmarks, including natural language multi-choices, code generation, and math reasoning.\n+The example below demonstrates how to generate text with [`Pipeline`], [`AutoModel`, and from the command line.\n \n-The abstract from the paper is the following:\n+<hfoptions id=\"usage\">\n+<hfoption id=\"Pipeline\">\n \n-*Finding the optimal learning rate for language model pretraining is a challenging task.\n-This is not only because there is a complicated correlation between learning rate, batch size, number of training tokens, model size, and other hyperparameters but also because it is prohibitively expensive to perform a hyperparameter search for large language models with Billions or Trillions of parameters. Recent studies propose using small proxy models and small corpus to perform hyperparameter searches and transposing the optimal parameters to large models and large corpus. While the zero-shot transferability is theoretically and empirically proven for model size related hyperparameters, like depth and width, the zero-shot transfer from small corpus to large corpus is underexplored.\n-In this paper, we study the correlation between optimal learning rate, batch size, and number of training tokens for the recently proposed WSD scheduler. After thousands of small experiments, we found a power-law relationship between variables and demonstrated its transferability across model sizes. Based on the observation, we propose a new learning rate scheduler, Power scheduler, that is agnostic about the number of training tokens and batch size. The experiment shows that combining the Power scheduler with Maximum Update Parameterization (\\mup) can consistently achieve impressive performance with one set of hyperparameters regardless of the number of training tokens, batch size, model size, and even model architecture. Our 3B dense and MoE models trained with the Power scheduler achieve comparable performance as state-of-the-art small language models.\n-We [open source](https://huggingface.co/collections/ibm/power-lm-66be64ae647ddf11b9808000) these pretrained models.*\n+```python\n+import torch\n+from transformers import pipeline\n+\n+pipe = pipeline(\n+    task=\"text-generation\",\n+    model=\"ibm-granite/granite-3.3-2b-base\",\n+    torch_dtype=torch.bfloat16,\n+    device=0\n+)\n+pipe(\"Explain quantum computing in simple terms \", max_new_tokens=50)\n+```\n \n-Tips:\n+</hfoption>\n+<hfoption id=\"AutoModel\">\n \n ```python\n import torch\n from transformers import AutoModelForCausalLM, AutoTokenizer\n \n-model_path = \"ibm/PowerLM-3b\"\n-tokenizer = AutoTokenizer.from_pretrained(model_path)\n-\n-# drop device_map if running on CPU\n-model = AutoModelForCausalLM.from_pretrained(model_path, device_map=\"auto\")\n-model.eval()\n-\n-# change input text as desired\n-prompt = \"Write a code to find the maximum value in a list of numbers.\"\n-\n-# tokenize the text\n-input_tokens = tokenizer(prompt, return_tensors=\"pt\")\n-# generate output tokens\n-output = model.generate(**input_tokens, max_new_tokens=100)\n-# decode output tokens into text\n-output = tokenizer.batch_decode(output)\n-# loop over the batch to print, in this example the batch size is 1\n-for i in output:\n-    print(i)\n+tokenizer = AutoTokenizer.from_pretrained(\"ibm-granite/granite-3.3-2b-base\")\n+model = AutoModelForCausalLM.from_pretrained(\n+    \"ibm-granite/granite-3.3-2b-base\",                                          \n+    torch_dtype=torch.bfloat16, \n+    device_map=\"auto\",\n+    attn_implementation=\"sdpa\"\n+)\n+\n+inputs = tokenizer(\"Explain quantum computing in simple terms\", return_tensors=\"pt\").to(\"cuda\")\n+outputs = model.generate(**inputs, max_length=50, cache_implementation=\"static\")\n+print(tokenizer.decode(outputs[0], skip_special_tokens=True))\n ```\n+</hfoption>\n+<hfoption id=\"transformers CLI\">\n \n-This model was contributed by [mayank-mishra](https://huggingface.co/mayank-mishra).\n+```python\n+echo -e \"Explain quantum computing simply.\" | transformers-cli run --task text-generation --model ibm-granite/granite-3.3-8b-instruct --device 0\n+```\n+</hfoption>\n+</hfoptions>\n+\n+Quantization reduces the memory burden of large models by representing the weights in a lower precision. Refer to the [Quantization](../quantization/overview) overview for more available quantization backends.\n+\n+The example below uses [bitsandbytes](../quantization/bitsandbytes) to only quantize the weights to int4.\n \n+```python\n+import torch\n+from transformers import AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig\n+\n+quantization_config = BitsAndBytesConfig(load_in_4bit=True)\n+tokenizer = AutoTokenizer.from_pretrained(\"ibm-granite/granite-3.3-8b-base\")\n+model = AutoModelForCausalLM.from_pretrained(\"ibm-granite/granite-3.3-8b-base\", torch_dtype=torch.bfloat16, device_map=\"auto\", attn_implementation=\"sdpa\", quantization_config=quantization_config)\n+\n+inputs = tokenizer(\"Explain quantum computing in simple terms\", return_tensors=\"pt\").to(\"cuda\")\n+outputs = model.generate(**inputs, max_length=50, cache_implementation=\"static\")\n+print(tokenizer.decode(outputs[0], skip_special_tokens=True))\n+\n+quantization_config = BitsAndBytesConfig(load_in_4bit=True)\n+\n+tokenizer = AutoTokenizer.from_pretrained(\"\"ibm-granite/granite-3.3-2b-base\"\")\n+model = AutoModelForCausalLM.from_pretrained(\n+    \"ibm-granite/granite-3.3-2b-base\",\n+    torch_dtype=torch.bfloat16,\n+    device_map=\"auto\",\n+    attn_implementation=\"sdpa\",\n+    quantization_config=quantization_config,\n+)\n+\n+input_ids = tokenizer(\"Explain artificial intelligence to a 10 year old\", return_tensors=\"pt\").to(\"cuda\")\n+outputs = model.generate(**inputs, max_length=50, cache_implementation=\"static\")\n+print(tokenizer.decode(outputs[0], skip_special_tokens=True))\n+```\n \n+  \n ## GraniteConfig\n \n [[autodoc]] GraniteConfig"
        }
    ],
    "stats": {
        "total": 106,
        "additions": 75,
        "deletions": 31
    }
}