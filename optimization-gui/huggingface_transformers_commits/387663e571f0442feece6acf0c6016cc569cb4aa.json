{
    "author": "jiqing-feng",
    "message": "Enable gptqmodel (#35012)\n\n* gptqmodel\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* fix format\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* update readme\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* gptqmodel need use checkpoint_format (#1)\r\n\r\n* gptqmodel need use checkpoint_format\r\n\r\n* fix quantize\r\n\r\n* Update quantization_config.py\r\n\r\n* Update quantization_config.py\r\n\r\n* Update quantization_config.py\r\n\r\n---------\r\n\r\nCo-authored-by: ZX-ModelCloud <zx@modelcloud.ai>\r\nCo-authored-by: Qubitium-ModelCloud <qubitium@modelcloud.ai>\r\n\r\n* Revert quantizer_gptq.py (#2)\r\n\r\n* revert quantizer_gptq.py change\r\n\r\n* pass **kwargs\r\n\r\n* limit gptqmodel and optimum version\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* fix format\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* fix warning\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* fix version check\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* revert unrelated changes\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* enable gptqmodel tests\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* fix requires gptq\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* Fix Transformer compat (#3)\r\n\r\n* revert quantizer_gptq.py change\r\n\r\n* pass **kwargs\r\n\r\n* add meta info\r\n\r\n* cleanup\r\n\r\n* cleanup\r\n\r\n* Update quantization_config.py\r\n\r\n* hf_select_quant_linear pass checkpoint_format and meta\r\n\r\n* fix GPTQTestCUDA\r\n\r\n* Update test_gptq.py\r\n\r\n* gptqmodel.hf_select_quant_linear() now does not select ExllamaV2\r\n\r\n* cleanup\r\n\r\n* add backend\r\n\r\n* cleanup\r\n\r\n* cleanup\r\n\r\n* no need check exllama version\r\n\r\n* Update quantization_config.py\r\n\r\n* lower checkpoint_format and backend\r\n\r\n* check none\r\n\r\n* cleanup\r\n\r\n* Update quantization_config.py\r\n\r\n* fix self.use_exllama == False\r\n\r\n* spell\r\n\r\n* fix unittest\r\n\r\n* fix unittest\r\n\r\n---------\r\n\r\nCo-authored-by: LRL <lrl@lbx.dev>\r\nCo-authored-by: Qubitium-ModelCloud <qubitium@modelcloud.ai>\r\n\r\n* fix format\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* fix format again\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* update gptqmodel version (#6)\r\n\r\n* update gptqmodel version\r\n\r\n* update gptqmodel version\r\n\r\n* fix unit test (#5)\r\n\r\n* update gptqmodel version\r\n\r\n* update gptqmodel version\r\n\r\n* \"not self.use_exllama\" is not equivalent to \"self.use_exllama==False\"\r\n\r\n* fix unittest\r\n\r\n* update gptqmodel version\r\n\r\n* backend is loading_attibutes (#7)\r\n\r\n* fix format and tests\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* fix memory check\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* fix device mismatch\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* fix result check\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* Update src/transformers/quantizers/quantizer_gptq.py\r\n\r\nCo-authored-by: Marc Sun <57196510+SunMarc@users.noreply.github.com>\r\n\r\n* Update src/transformers/quantizers/quantizer_gptq.py\r\n\r\nCo-authored-by: Marc Sun <57196510+SunMarc@users.noreply.github.com>\r\n\r\n* Update src/transformers/quantizers/quantizer_gptq.py\r\n\r\nCo-authored-by: Marc Sun <57196510+SunMarc@users.noreply.github.com>\r\n\r\n* update tests\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* review: update docs (#10)\r\n\r\n* review: update docs (#12)\r\n\r\n* review: update docs\r\n\r\n* fix typo\r\n\r\n* update tests for gptqmodel\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\n\r\n* update document (#9)\r\n\r\n* update overview.md\r\n\r\n* cleanup\r\n\r\n* Update overview.md\r\n\r\n* Update overview.md\r\n\r\n* Update overview.md\r\n\r\n* update gptq.md\r\n\r\n* Update gptq.md\r\n\r\n* Update gptq.md\r\n\r\n* Update gptq.md\r\n\r\n* Update gptq.md\r\n\r\n* Update gptq.md\r\n\r\n* Update gptq.md\r\n\r\n---------\r\n\r\nCo-authored-by: Qubitium-ModelCloud <qubitium@modelcloud.ai>\r\n\r\n* typo\r\n\r\n* doc note for asymmetric quant\r\n\r\n* typo with apple silicon(e)\r\n\r\n* typo for marlin\r\n\r\n* column name revert: review\r\n\r\n* doc rocm support\r\n\r\n* Update docs/source/en/quantization/gptq.md\r\n\r\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\r\n\r\n* Update docs/source/en/quantization/gptq.md\r\n\r\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\r\n\r\n* Update docs/source/en/quantization/gptq.md\r\n\r\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\r\n\r\n* Update docs/source/en/quantization/gptq.md\r\n\r\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\r\n\r\n* Update docs/source/en/quantization/overview.md\r\n\r\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\r\n\r\n* Update docs/source/en/quantization/overview.md\r\n\r\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\r\n\r\n---------\r\n\r\nSigned-off-by: jiqing-feng <jiqing.feng@intel.com>\r\nCo-authored-by: LRL-ModelCloud <165116337+LRL-ModelCloud@users.noreply.github.com>\r\nCo-authored-by: ZX-ModelCloud <zx@modelcloud.ai>\r\nCo-authored-by: Qubitium-ModelCloud <qubitium@modelcloud.ai>\r\nCo-authored-by: ZX-ModelCloud <165115237+ZX-ModelCloud@users.noreply.github.com>\r\nCo-authored-by: LRL <lrl@lbx.dev>\r\nCo-authored-by: Marc Sun <57196510+SunMarc@users.noreply.github.com>\r\nCo-authored-by: Mohamed Mekkouri <93391238+MekkCyber@users.noreply.github.com>\r\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>",
    "sha": "387663e571f0442feece6acf0c6016cc569cb4aa",
    "files": [
        {
            "sha": "1534a977f3436ffbdf9402205da0f0bbd722e11b",
            "filename": "docs/source/en/quantization/gptq.md",
            "status": "modified",
            "additions": 46,
            "deletions": 6,
            "changes": 52,
            "blob_url": "https://github.com/huggingface/transformers/blob/387663e571f0442feece6acf0c6016cc569cb4aa/docs%2Fsource%2Fen%2Fquantization%2Fgptq.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/387663e571f0442feece6acf0c6016cc569cb4aa/docs%2Fsource%2Fen%2Fquantization%2Fgptq.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fquantization%2Fgptq.md?ref=387663e571f0442feece6acf0c6016cc569cb4aa",
            "patch": "@@ -22,15 +22,42 @@ Try GPTQ quantization with PEFT in this [notebook](https://colab.research.google\n \n </Tip>\n \n-The [AutoGPTQ](https://github.com/PanQiWei/AutoGPTQ) library implements the GPTQ algorithm, a post-training quantization technique where each row of the weight matrix is quantized independently to find a version of the weights that minimizes the error. These weights are quantized to int4, but they're restored to fp16 on the fly during inference. This can save your memory-usage by 4x because the int4 weights are dequantized in a fused kernel rather than a GPU's global memory, and you can also expect a speedup in inference because using a lower bitwidth takes less time to communicate.\n+Both [GPTQModel](https://github.com/ModelCloud/GPTQModel) and [AutoGPTQ](https://github.com/PanQiWei/AutoGPTQ) libraries implement the GPTQ algorithm, a post-training quantization technique where each row of the weight matrix is quantized independently to find a version of the weights that minimizes error. These weights are quantized to int4, stored as int32 (int4 x 8) and dequantized (restored) to fp16 on the fly during inference. This can save memory by almost 4x because the int4 weights are often dequantized in a fused kernel. You can also expect a substantial speedup in inference due to lower bandwidth requirements for lower bitwidth.\n \n-Before you begin, make sure the following libraries are installed:\n+[GPTQModel](https://github.com/ModelCloud/GPTQModel) started as a maintained fork of AutoGPTQ but has since differentiated itself with the following major differences.\n+\n+* Model support: GPTQModel continues to support all of the latest LLM models.\n+* Multimodal support: GPTQModel supports accurate quantization of Qwen 2-VL and Ovis 1.6-VL image-to-text models. \n+* Platform support: Linux, macOS (Apple Silicon), and Windows 11.\n+* Hardware support: NVIDIA CUDA, AMD ROCm, Apple Silicon M1/MPS /CPU, Intel/AMD CPU, and Intel Datacenter Max/Arc GPUs.\n+* Asymmetric support: Asymmetric quantization can potentially introduce lower quantization errors compared to symmetric quantization. However, it is not backward compatible with AutoGPTQ, and not all kernels, such as Marlin, support asymmetric quantization.\n+* IPEX kernel for Intel/AMD accelerated CPU and Intel GPU (Datacenter Max/Arc GPUs) support.\n+* Updated Marlin kernel from Neural Magic optimized for A100 (Ampere).\n+* Updated kernels with auto-padding for legacy model support and models with non-uniform in/out-features. \n+* Faster quantization, lower memory usage, and more accurate default quantization via GPTQModel quantization APIs.\n+* User and developer friendly APIs. \n+\n+\n+[AutoGPTQ](https://github.com/PanQiWei/AutoGPTQ) will likely be deprecated in the future due the lack of continued support for new models and features. \n+\n+Before you begin, make sure the following libraries are installed and updated to the latest release:\n \n ```bash\n-pip install auto-gptq\n pip install --upgrade accelerate optimum transformers\n ```\n \n+Then install either GPTQModel or AutoGPTQ.\n+\n+```bash\n+pip install gptqmodel --no-build-isolation\n+```\n+\n+or\n+\n+```bash\n+pip install auto-gptq --no-build-isolation\n+```\n+\n To quantize a model (currently only supported for text models), you need to create a [`GPTQConfig`] class and set the number of bits to quantize to, a dataset to calibrate the weights for quantization, and a tokenizer to prepare the dataset.\n \n ```py\n@@ -92,9 +119,22 @@ from transformers import AutoModelForCausalLM\n model = AutoModelForCausalLM.from_pretrained(\"{your_username}/opt-125m-gptq\", device_map=\"auto\")\n ```\n \n+## Marlin\n+\n+[Marlin](https://github.com/IST-DASLab/marlin) is a 4-bit only CUDA GPTQ kernel, highly optimized for the NVIDIA A100 GPU (Ampere) architecture. Loading, dequantization, and execution of post-dequantized weights are highly parallelized, offering a substantial inference improvement versus the original CUDA GPTQ kernel. Marlin is only available for quantized inference and does not support model quantization.\n+\n+Marlin inference can be activated with the `backend` parameter in [`GPTQConfig`].\n+\n+```py\n+\n+from transformers import AutoModelForCausalLM, GPTQConfig\n+\n+model = AutoModelForCausalLM.from_pretrained(\"{your_username}/opt-125m-gptq\", device_map=\"auto\", quantization_config=GPTQConfig(bits=4, backend=\"marlin\"))\n+```\n+\n ## ExLlama\n \n-[ExLlama](https://github.com/turboderp/exllama) is a Python/C++/CUDA implementation of the [Llama](model_doc/llama) model that is designed for faster inference with 4-bit GPTQ weights (check out these [benchmarks](https://github.com/huggingface/optimum/tree/main/tests/benchmark#gptq-benchmark)). The ExLlama kernel is activated by default when you create a [`GPTQConfig`] object. To boost inference speed even further, use the [ExLlamaV2](https://github.com/turboderp/exllamav2) kernels by configuring the `exllama_config` parameter:\n+[ExLlama](https://github.com/turboderp/exllama) is a CUDA implementation of the [Llama](model_doc/llama) model that is designed for faster inference with 4-bit GPTQ weights (check out these [benchmarks](https://github.com/huggingface/optimum/tree/main/tests/benchmark#gptq-benchmark)). The ExLlama kernel is activated by default when you create a [`GPTQConfig`] object. To boost inference speed even further, use the [ExLlamaV2](https://github.com/turboderp/exllamav2) kernels by configuring the `exllama_config` parameter:\n \n ```py\n import torch\n@@ -110,11 +150,11 @@ Only 4-bit models are supported, and we recommend deactivating the ExLlama kerne\n \n </Tip>\n \n-The ExLlama kernels are only supported when the entire model is on the GPU. If you're doing inference on a CPU with AutoGPTQ (version > 0.4.2), then you'll need to disable the ExLlama kernel. This overwrites the attributes related to the ExLlama kernels in the quantization config of the config.json file.\n+The ExLlama kernels are only supported when the entire model is on the GPU. If you're doing inference on a CPU with AutoGPTQ or GPTQModel, then you'll need to disable the ExLlama kernel. This overwrites the attributes related to the ExLlama kernels in the quantization config of the config.json file.\n \n ```py\n import torch\n from transformers import AutoModelForCausalLM, GPTQConfig\n gptq_config = GPTQConfig(bits=4, use_exllama=False)\n model = AutoModelForCausalLM.from_pretrained(\"{your_username}/opt-125m-gptq\", device_map=\"cpu\", quantization_config=gptq_config)\n-```\n\\ No newline at end of file\n+```"
        },
        {
            "sha": "dfe680832b19524f929d9e85eb2679fe3047da15",
            "filename": "docs/source/en/quantization/overview.md",
            "status": "modified",
            "additions": 37,
            "deletions": 19,
            "changes": 56,
            "blob_url": "https://github.com/huggingface/transformers/blob/387663e571f0442feece6acf0c6016cc569cb4aa/docs%2Fsource%2Fen%2Fquantization%2Foverview.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/387663e571f0442feece6acf0c6016cc569cb4aa/docs%2Fsource%2Fen%2Fquantization%2Foverview.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fquantization%2Foverview.md?ref=387663e571f0442feece6acf0c6016cc569cb4aa",
            "patch": "@@ -45,32 +45,50 @@ In short, supporting a wide range of quantization methods allows you to pick the\n \n Use the table below to help you decide which quantization method to use.\n \n-| Quantization method                 | On the fly quantization | CPU | CUDA GPU | RoCm GPU (AMD) | Metal (Apple Silicon) | Intel GPU | torch.compile() support | Number of bits | Supports fine-tuning (through PEFT) | Serializable with 游뱅 transformers | 游뱅 transformers support | Link to library                             |\n-|-------------------------------------|-------------------------|-----|----------|----------------|-----------------------|-----------|-------------------------|----------------|-------------------------------------|--------------|------------------------|---------------------------------------------|\n-| [AQLM](./aqlm)                                | 游댮                       |  游릭   |     游릭     | 游댮              | 游댮                     | 游댮         | 游릭                      | 1 / 2          | 游릭                                   | 游릭            | 游릭                      | https://github.com/Vahe1994/AQLM            |\n-| [AWQ](./awq) | 游댮                       | 游릭   | 游릭        | 游릭              | 游댮                     | 游릭         | ?                       | 4              | 游릭                                   | 游릭            | 游릭                      | https://github.com/casper-hansen/AutoAWQ    |\n-| [bitsandbytes](./bitsandbytes)     | 游릭            | 游리 *   |     游릭     | 游리 *            | 游댮 **    | 游리 *       | 游댮    (soon!)          | 4 / 8          | 游릭                                   | 游릭            | 游릭                      | https://github.com/bitsandbytes-foundation/bitsandbytes |\n-| [compressed-tensors](./compressed_tensors)                        | 游댮                       | 游릭   |     游릭     | 游릭              | 游댮                     | 游댮         | 游댮                       | 1 - 8          | 游릭                                   | 游릭            | 游릭                      | https://github.com/neuralmagic/compressed-tensors |\n-| [EETQ](./eetq)                                | 游릭                       | 游댮   | 游릭        | 游댮              | 游댮         | 游댮                     | ?                       | 8              | 游릭                                   | 游릭            | 游릭                      | https://github.com/NetEase-FuXi/EETQ        |\n-| GGUF / GGML (llama.cpp)             | 游릭                       | 游릭   | 游릭        | 游댮              | 游릭                     | 游댮         | 游댮                       | 1 - 8          | 游댮                                   | [See GGUF section](../gguf)                | [See GGUF section](../gguf)                      | https://github.com/ggerganov/llama.cpp      |\n-| [GPTQ](./gptq)                                | 游댮                       | 游댮   | 游릭        | 游릭              | 游댮                     | 游댮         | 游댮                       | 2 - 3 - 4 - 8          | 游릭                                   | 游릭            | 游릭                      | https://github.com/AutoGPTQ/AutoGPTQ        |\n-| [HIGGS](./higgs)                             | 游릭                       | 游댮    | 游릭        | 游댮              | 游댮                     | 游댮         | 游릭                       | 2 - 4          | 游댮                                   | 游릭            | 游릭                      | https://github.com/HanGuo97/flute           |       \n-| [HQQ](./hqq)                                 | 游릭                       | 游릭    | 游릭        | 游댮              | 游댮                     | 游댮         | 游릭                       | 1 - 8          | 游릭                                   | 游댮            | 游릭                      | https://github.com/mobiusml/hqq/            |\n-| [optimum-quanto](./quanto)                              | 游릭                       | 游릭   | 游릭        | 游댮              | 游릭                     | 游댮         | 游릭                       | 2 / 4 / 8      | 游댮                                   | 游댮            | 游릭                      | https://github.com/huggingface/optimum-quanto       |\n-| [FBGEMM_FP8](./fbgemm_fp8.md)                              | 游릭                       | 游댮    | 游릭        | 游댮              | 游댮                      | 游댮         | 游댮                        | 8      | 游댮                                   | 游릭            | 游릭                      | https://github.com/pytorch/FBGEMM       |\n-| [torchao](./torchao.md)                              | 游릭                       |     | 游릭        | 游댮              | partial support (int4 weight only)       | 游댮         |                       | 4 / 8      |                                   | 游릭游댮           | 游릭                      | https://github.com/pytorch/ao       |\n-| [VPTQ](./vptq)                      | 游댮                       |  游댮   |     游릭     | 游리              | 游댮      | 游댮                | 游릭                      | 1 - 8          | 游댮                                   | 游릭            | 游릭                      | https://github.com/microsoft/VPTQ            |\n+| Quantization Method                           | On the fly quantization | CPU             | CUDA GPU | ROCm GPU  | Metal (Apple Silicon)              | Intel GPU       | Torch compile() | Bits          | PEFT Fine Tuning | Serializable with 游뱅Transformers | 游뱅Transformers Support  | Link to library                             |\n+|-----------------------------------------------|----------------------|-----------------|----------|-----------|------------------------------------|-----------------|-----------------|---------------|------------------|-----------------------------|-------------------------|---------------------------------------------|\n+| [AQLM](./aqlm.md)                             | 游댮                   | 游릭              |     游릭     | 游댮        | 游댮                                 | 游댮              | 游릭              | 1/2         | 游릭               | 游릭                          | 游릭                      | https://github.com/Vahe1994/AQLM            |\n+| [AWQ](./awq.md)                               | 游댮                   | 游릭              | 游릭        | 游릭        | 游댮                                 | 游릭              | ?               | 4             | 游릭               | 游릭                          | 游릭                      | https://github.com/casper-hansen/AutoAWQ    |\n+| [bitsandbytes](./bitsandbytes.md)             | 游릭                   | 游리 <sub>1</sub> |     游릭     | 游리 <sub>1</sub> | 游댮 <sub>2</sub>                    | 游리 <sub>1</sub> | 游댮 <sub>1</sub> | 4/8         | 游릭               | 游릭                          | 游릭                      | https://github.com/bitsandbytes-foundation/bitsandbytes |\n+| [compressed-tensors](./compressed_tensors.md) | 游댮                   | 游릭              |     游릭     | 游릭        | 游댮                                 | 游댮              | 游댮              | 1/8         | 游릭               | 游릭                          | 游릭                      | https://github.com/neuralmagic/compressed-tensors |\n+| [EETQ](./eetq.md)                             | 游릭                   | 游댮              | 游릭        | 游댮        | 游댮                                 | 游댮              | ?               | 8             | 游릭               | 游릭                          | 游릭                      | https://github.com/NetEase-FuXi/EETQ        |\n+| [GGUF / GGML (llama.cpp)](../gguf.md)         | 游릭                   | 游릭              | 游릭        | 游댮        | 游릭                                 | 游댮              | 游댮              | 1/8         | 游댮               | [See Notes](../gguf.md)     | [See Notes](../gguf.md) | https://github.com/ggerganov/llama.cpp      |\n+| [GPTQModel](./gptq.md)                        | 游댮                   | 游릭 <sub>3</sub> | 游릭        | 游릭        | 游릭                                 | 游릭 <sub>4</sub> | 游댮              | 2/3/4/8 | 游릭               | 游릭                          | 游릭                      | https://github.com/ModelCloud/GPTQModel        |\n+| [AutoGPTQ](./gptq.md)                         | 游댮                   | 游댮              | 游릭        | 游릭        | 游댮                                 | 游댮              | 游댮              | 2/3/4/8 | 游릭               | 游릭                          | 游릭                      | https://github.com/AutoGPTQ/AutoGPTQ        |\n+| [HIGGS](./higgs.md)                           | 游릭                   | 游댮              | 游릭        | 游댮        | 游댮                                 | 游댮              | 游릭              | 2/4         | 游댮               | 游릭                          | 游릭                      | https://github.com/HanGuo97/flute           |       \n+| [HQQ](./hqq.md)                               | 游릭                   | 游릭              | 游릭        | 游댮        | 游댮                                 | 游댮              | 游릭              | 1/8         | 游릭               | 游댮                          | 游릭                      | https://github.com/mobiusml/hqq/            |\n+| [optimum-quanto](./quanto.md)                 | 游릭                   | 游릭              | 游릭        | 游댮        | 游릭                                 | 游댮              | 游릭              | 2/4/8     | 游댮               | 游댮                          | 游릭                      | https://github.com/huggingface/optimum-quanto       |\n+| [FBGEMM_FP8](./fbgemm_fp8.md)                 | 游릭                   | 游댮              | 游릭        | 游댮        | 游댮                                 | 游댮              | 游댮              | 8             | 游댮               | 游릭                          | 游릭                      | https://github.com/pytorch/FBGEMM       |\n+| [torchao](./torchao.md)                       | 游릭                   |                 | 游릭        | 游댮        | 游리 <sub>5</sub> | 游댮              |                 | 4/8         |                  | 游릭游댮                        | 游릭                      | https://github.com/pytorch/ao       |\n+| [VPTQ](./vptq.md)                             | 游댮                   | 游댮              |     游릭     | 游리        | 游댮                                 | 游댮              | 游릭              | 1/8         | 游댮               | 游릭                          | 游릭                      | https://github.com/microsoft/VPTQ            |\n \n <Tip>\n+  \n+**1:** bitsandbytes is being refactored to support multiple backends beyond CUDA. Currently, ROCm (AMD GPU) and Intel CPU implementations are mature, with Intel XPU in progress and Apple Silicon support expected by Q4/Q1. For installation instructions and the latest backend updates, visit [this link](https://huggingface.co/docs/bitsandbytes/main/en/installation#multi-backend). Check out [these docs](https://huggingface.co/docs/bitsandbytes/main/en/non_cuda_backends) for more details and feedback links.\n \n-\\* bitsandbytes is being refactored to support multiple backends beyond CUDA. Currently, ROCm (AMD GPU) and Intel CPU implementations are mature, with Intel XPU in progress and Apple Silicon support expected by Q4/Q1. For installation instructions and the latest backend updates, visit [this link](https://huggingface.co/docs/bitsandbytes/main/en/installation#multi-backend).\n+</Tip>\n+\n+<Tip>\n+\n+**2:** bitsandbytes is seeking contributors to help develop and lead the Apple Silicon backend. Interested? Contact them directly via their repo. Stipends may be available through sponsorships.\n+\n+</Tip>\n+\n+<Tip>\n \n-We value your feedback to help identify bugs before the full release! Check out [these docs](https://huggingface.co/docs/bitsandbytes/main/en/non_cuda_backends) for more details and feedback links.\n+**3:** GPTQModel[CPU] supports 4-bit via IPEX on Intel/AMD and full bit range via Torch on Intel/AMD/Apple Silicon.\n \n </Tip>\n \n <Tip>\n \n-\\** bitsandbytes is seeking contributors to help develop and lead the Apple Silicon backend. Interested? Contact them directly via their repo. Stipends may be available through sponsorships.\n+**4:** GPTQModel[Intel GPU] via IPEX only supports 4-bit for Intel Datacenter Max/Arc GPUs.\n+\n+</Tip>\n+\n+<Tip>\n+\n+**5:** torchao only supports int4 weight on Metal (Apple Silicon).\n+\n+</Tip>\n \n-</Tip>\n\\ No newline at end of file"
        },
        {
            "sha": "8c84c8817a442a4bc53f3707970f56e99d697769",
            "filename": "src/transformers/quantizers/quantizer_gptq.py",
            "status": "modified",
            "additions": 31,
            "deletions": 12,
            "changes": 43,
            "blob_url": "https://github.com/huggingface/transformers/blob/387663e571f0442feece6acf0c6016cc569cb4aa/src%2Ftransformers%2Fquantizers%2Fquantizer_gptq.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/387663e571f0442feece6acf0c6016cc569cb4aa/src%2Ftransformers%2Fquantizers%2Fquantizer_gptq.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fquantizers%2Fquantizer_gptq.py?ref=387663e571f0442feece6acf0c6016cc569cb4aa",
            "patch": "@@ -22,7 +22,7 @@\n if TYPE_CHECKING:\n     from ..modeling_utils import PreTrainedModel\n \n-from ..utils import is_auto_gptq_available, is_optimum_available, is_torch_available, logging\n+from ..utils import is_auto_gptq_available, is_gptqmodel_available, is_optimum_available, is_torch_available, logging\n from ..utils.quantization_config import GPTQConfig, QuantizationConfigMixin\n \n \n@@ -35,11 +35,11 @@\n class GptqHfQuantizer(HfQuantizer):\n     \"\"\"\n     Quantizer of the GPTQ method - for GPTQ the quantizer support calibration of the model through\n-    `auto_gptq` package. Quantization is done under the hood for users if they load a non-prequantized model.\n+    `auto_gptq` or `gptqmodel` package. Quantization is done under the hood for users if they load a non-prequantized model.\n     \"\"\"\n \n     requires_calibration = False\n-    required_packages = [\"optimum\", \"auto_gptq\"]\n+    required_packages = [\"optimum\", \"auto_gptq\", \"gptqmodel\"]\n     optimum_quantizer = None\n \n     def __init__(self, quantization_config: QuantizationConfigMixin, **kwargs):\n@@ -54,19 +54,30 @@ def __init__(self, quantization_config: QuantizationConfigMixin, **kwargs):\n     def validate_environment(self, *args, **kwargs):\n         if not is_optimum_available():\n             raise ImportError(\"Loading a GPTQ quantized model requires optimum (`pip install optimum`)\")\n+        if is_auto_gptq_available() and is_gptqmodel_available():\n+            logger.warning(\"Detected gptqmodel and auto-gptq, will use gptqmodel\")\n \n-        if not is_auto_gptq_available():\n-            raise ImportError(\n-                \"Loading a GPTQ quantized model requires the auto-gptq library (`pip install auto-gptq`)\"\n-            )\n-\n-        gptq_supports_cpu = version.parse(importlib.metadata.version(\"auto-gptq\")) > version.parse(\"0.4.2\")\n+        gptq_supports_cpu = (\n+            is_auto_gptq_available()\n+            and version.parse(importlib.metadata.version(\"auto-gptq\")) > version.parse(\"0.4.2\")\n+        ) or is_gptqmodel_available()\n         if not gptq_supports_cpu and not torch.cuda.is_available():\n             raise RuntimeError(\"GPU is required to quantize or run quantize model.\")\n-        elif version.parse(importlib.metadata.version(\"auto_gptq\")) < version.parse(\"0.4.2\"):\n+        elif not (is_auto_gptq_available() or is_gptqmodel_available()):\n             raise ImportError(\n-                \"You need a version of auto_gptq >= 0.4.2 to use GPTQ: `pip install --upgrade auto-gptq`\"\n+                \"Loading a GPTQ quantized model requires gptqmodel (`pip install gptqmodel`) or auto-gptq (`pip install auto-gptq`) library. \"\n             )\n+        elif is_auto_gptq_available() and version.parse(importlib.metadata.version(\"auto_gptq\")) < version.parse(\n+            \"0.4.2\"\n+        ):\n+            raise ImportError(\n+                \"You need a version of auto_gptq >= 0.4.2 to use GPTQ: `pip install --upgrade auto-gptq` or use gptqmodel by `pip install gptqmodel>=1.4.3`.\"\n+            )\n+        elif is_gptqmodel_available() and (\n+            version.parse(importlib.metadata.version(\"gptqmodel\")) < version.parse(\"1.4.3\")\n+            or version.parse(importlib.metadata.version(\"optimum\")) < version.parse(\"1.23.99\")\n+        ):\n+            raise ImportError(\"The gptqmodel version should be >= 1.4.3, optimum version should >= 1.24.0\")\n \n     def update_torch_dtype(self, torch_dtype: \"torch.dtype\") -> \"torch.dtype\":\n         if torch_dtype is None:\n@@ -76,12 +87,20 @@ def update_torch_dtype(self, torch_dtype: \"torch.dtype\") -> \"torch.dtype\":\n             logger.info(\"We suggest you to set `torch_dtype=torch.float16` for better efficiency with GPTQ.\")\n         return torch_dtype\n \n+    def update_device_map(self, device_map):\n+        if device_map is None:\n+            device_map = {\"\": torch.device(\"cpu\")}\n+        # Only with auto-gptq do not support CPU, we should move the model to cuda if available.\n+        if not is_gptqmodel_available() and device_map in (\"cpu\", {\"\": torch.device(\"cpu\")}):\n+            device_map == {\"\": 0}\n+        return device_map\n+\n     def _process_model_before_weight_loading(self, model: \"PreTrainedModel\", **kwargs):\n         if model.__class__.main_input_name != \"input_ids\":\n             raise RuntimeError(\"We can only quantize pure text model.\")\n \n         if self.pre_quantized:\n-            model = self.optimum_quantizer.convert_model(model)\n+            model = self.optimum_quantizer.convert_model(model, **kwargs)\n \n     def _process_model_after_weight_loading(self, model: \"PreTrainedModel\", **kwargs):\n         if self.pre_quantized:"
        },
        {
            "sha": "5bbf27713805566da91d991dce4b193fa4c454fa",
            "filename": "src/transformers/testing_utils.py",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/387663e571f0442feece6acf0c6016cc569cb4aa/src%2Ftransformers%2Ftesting_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/387663e571f0442feece6acf0c6016cc569cb4aa/src%2Ftransformers%2Ftesting_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Ftesting_utils.py?ref=387663e571f0442feece6acf0c6016cc569cb4aa",
            "patch": "@@ -85,6 +85,7 @@\n     is_g2p_en_available,\n     is_galore_torch_available,\n     is_gguf_available,\n+    is_gptqmodel_available,\n     is_grokadamw_available,\n     is_hadamard_available,\n     is_hqq_available,\n@@ -1207,11 +1208,13 @@ def require_tensorboard(test_case):\n     return unittest.skipUnless(is_tensorboard_available(), \"test requires tensorboard\")\n \n \n-def require_auto_gptq(test_case):\n+def require_gptq(test_case):\n     \"\"\"\n     Decorator for auto_gptq dependency\n     \"\"\"\n-    return unittest.skipUnless(is_auto_gptq_available(), \"test requires auto-gptq\")(test_case)\n+    return unittest.skipUnless(\n+        is_gptqmodel_available() or is_auto_gptq_available(), \"test requires gptqmodel or auto-gptq\"\n+    )(test_case)\n \n \n def require_hqq(test_case):"
        },
        {
            "sha": "919f9f8bde031a2a62696a1cb60bc8d37ca12fd5",
            "filename": "src/transformers/utils/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/387663e571f0442feece6acf0c6016cc569cb4aa/src%2Ftransformers%2Futils%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/387663e571f0442feece6acf0c6016cc569cb4aa/src%2Ftransformers%2Futils%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2F__init__.py?ref=387663e571f0442feece6acf0c6016cc569cb4aa",
            "patch": "@@ -147,6 +147,7 @@\n     is_g2p_en_available,\n     is_galore_torch_available,\n     is_gguf_available,\n+    is_gptqmodel_available,\n     is_grokadamw_available,\n     is_hadamard_available,\n     is_hqq_available,"
        },
        {
            "sha": "802d0ca68974a06c176eee5a3f3b748d14abdd7e",
            "filename": "src/transformers/utils/import_utils.py",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/387663e571f0442feece6acf0c6016cc569cb4aa/src%2Ftransformers%2Futils%2Fimport_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/387663e571f0442feece6acf0c6016cc569cb4aa/src%2Ftransformers%2Futils%2Fimport_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fimport_utils.py?ref=387663e571f0442feece6acf0c6016cc569cb4aa",
            "patch": "@@ -144,6 +144,7 @@ def _is_package_available(pkg_name: str, return_version: bool = False) -> Union[\n _openai_available = _is_package_available(\"openai\")\n _optimum_available = _is_package_available(\"optimum\")\n _auto_gptq_available = _is_package_available(\"auto_gptq\")\n+_gptqmodel_available = _is_package_available(\"gptqmodel\")\n # `importlib.metadata.version` doesn't work with `awq`\n _auto_awq_available = importlib.util.find_spec(\"awq\") is not None\n _quanto_available = _is_package_available(\"quanto\")\n@@ -1041,6 +1042,10 @@ def is_auto_gptq_available():\n     return _auto_gptq_available\n \n \n+def is_gptqmodel_available():\n+    return _gptqmodel_available\n+\n+\n def is_eetq_available():\n     return _eetq_available\n "
        },
        {
            "sha": "b356b3d9b0ab697702aca084dc4388b20eb4c46d",
            "filename": "src/transformers/utils/quantization_config.py",
            "status": "modified",
            "additions": 50,
            "deletions": 9,
            "changes": 59,
            "blob_url": "https://github.com/huggingface/transformers/blob/387663e571f0442feece6acf0c6016cc569cb4aa/src%2Ftransformers%2Futils%2Fquantization_config.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/387663e571f0442feece6acf0c6016cc569cb4aa/src%2Ftransformers%2Futils%2Fquantization_config.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fquantization_config.py?ref=387663e571f0442feece6acf0c6016cc569cb4aa",
            "patch": "@@ -25,7 +25,15 @@\n \n from packaging import version\n \n-from ..utils import is_auto_awq_available, is_hqq_available, is_torch_available, is_torchao_available, logging\n+from ..utils import (\n+    is_auto_awq_available,\n+    is_gptqmodel_available,\n+    is_hqq_available,\n+    is_torch_available,\n+    is_torchao_available,\n+    logging,\n+)\n+from .import_utils import is_auto_gptq_available\n \n \n if is_torch_available():\n@@ -581,8 +589,16 @@ class GPTQConfig(QuantizationConfigMixin):\n             Whether to perform sequential quantization even within a single Transformer block. Instead of quantizing\n             the entire block at once, we perform layer-wise quantization. As a result, each layer undergoes\n             quantization using inputs that have passed through the previously quantized layers.\n+        checkpoint_format (`str`, *optional*, defaults to `\"gptq\"`):\n+            GPTQ weight format. `gptq`(v1) is supported by both gptqmodel and auto-gptq. `gptq_v2` is gptqmodel only.\n+        meta (`Dict[str, any]`, *optional*):\n+            Properties, such as tooling:version, that do not directly contributes to quantization or quant inference are stored in meta.\n+            i.e. `meta.quantizer`: [\"optimum:_version_\", \"gptqmodel:_version_\"]\n+        backend (`str`, *optional*):\n+            Controls which gptq kernel to be used. Valid values for gptqmodel are `auto`, `auto_trainable` and more. For auto-gptq, only\n+            valid value is None and `auto_trainable`. Ref gptqmodel backends: https://github.com/ModelCloud/GPTQModel/blob/main/gptqmodel/utils/backend.py\n         use_cuda_fp16 (`bool`, *optional*, defaults to `False`):\n-            Whether or not to use optimized cuda kernel for fp16 model. Need to have model in fp16.\n+            Whether or not to use optimized cuda kernel for fp16 model. Need to have model in fp16. Auto-gptq only.\n         model_seqlen (`int`, *optional*):\n             The maximum sequence length that the model can take.\n         block_name_to_quantize (`str`, *optional*):\n@@ -622,6 +638,9 @@ def __init__(\n         desc_act: bool = False,\n         sym: bool = True,\n         true_sequential: bool = True,\n+        checkpoint_format: str = \"gptq\",\n+        meta: Optional[Dict[str, any]] = None,\n+        backend: Optional[str] = None,\n         use_cuda_fp16: bool = False,\n         model_seqlen: Optional[int] = None,\n         block_name_to_quantize: Optional[str] = None,\n@@ -644,6 +663,9 @@ def __init__(\n         self.desc_act = desc_act\n         self.sym = sym\n         self.true_sequential = true_sequential\n+        self.checkpoint_format = checkpoint_format.lower()\n+        self.meta = meta\n+        self.backend = backend.lower() if isinstance(backend, str) else backend\n         self.use_cuda_fp16 = use_cuda_fp16\n         self.model_seqlen = model_seqlen\n         self.block_name_to_quantize = block_name_to_quantize\n@@ -660,7 +682,14 @@ def __init__(\n \n     def get_loading_attributes(self):\n         attibutes_dict = copy.deepcopy(self.__dict__)\n-        loading_attibutes = [\"disable_exllama\", \"use_exllama\", \"exllama_config\", \"use_cuda_fp16\", \"max_input_length\"]\n+        loading_attibutes = [\n+            \"disable_exllama\",\n+            \"use_exllama\",\n+            \"exllama_config\",\n+            \"use_cuda_fp16\",\n+            \"max_input_length\",\n+            \"backend\",\n+        ]\n         loading_attibutes_dict = {i: j for i, j in attibutes_dict.items() if i in loading_attibutes}\n         return loading_attibutes_dict\n \n@@ -692,6 +721,17 @@ def post_init(self):\n                     ['wikitext2','c4','c4-new'], but we found {self.dataset}\"\"\"\n                 )\n \n+        # make sure backend is back/forward compatible with both gptqmodel (full) and auto-gptq (partial)\n+        if is_gptqmodel_available():\n+            # convert auto-gptq control into gptqmodel backend\n+            if self.backend is None:\n+                self.backend = \"auto_trainable\" if self.use_exllama is not None and not self.use_exllama else \"auto\"\n+        else:\n+            # convert gptqmodel backend `auto_trainable` into auto-gptq control\n+            if self.backend == \"auto_trainable\":\n+                self.use_exllama = False\n+\n+        # auto-gptq specific kernel control logic\n         if self.disable_exllama is None and self.use_exllama is None:\n             # New default behaviour\n             self.use_exllama = True\n@@ -725,12 +765,13 @@ def post_init(self):\n                     \"speed using exllamav2 kernel by setting `exllama_config`.\"\n                 )\n             elif self.exllama_config[\"version\"] == ExllamaVersion.TWO:\n-                optimum_version = version.parse(importlib.metadata.version(\"optimum\"))\n-                autogptq_version = version.parse(importlib.metadata.version(\"auto_gptq\"))\n-                if optimum_version <= version.parse(\"1.13.2\") or autogptq_version <= version.parse(\"0.4.2\"):\n-                    raise ValueError(\n-                        f\"You need optimum > 1.13.2 and auto-gptq > 0.4.2 . Make sure to have that version installed - detected version : optimum {optimum_version} and autogptq {autogptq_version}\"\n-                    )\n+                if is_auto_gptq_available():\n+                    optimum_version = version.parse(importlib.metadata.version(\"optimum\"))\n+                    autogptq_version = version.parse(importlib.metadata.version(\"auto_gptq\"))\n+                    if optimum_version <= version.parse(\"1.13.2\") or autogptq_version <= version.parse(\"0.4.2\"):\n+                        raise ValueError(\n+                            f\"You need optimum > 1.13.2 and auto-gptq > 0.4.2 . Make sure to have that version installed - detected version : optimum {optimum_version} and autogptq {autogptq_version}\"\n+                        )\n         if self.modules_in_block_to_quantize is not None:\n             optimum_version = version.parse(importlib.metadata.version(\"optimum\"))\n             if optimum_version < version.parse(\"1.15.0\"):"
        },
        {
            "sha": "c0056b23866338cca05c8990bf153d98744d40e9",
            "filename": "tests/quantization/gptq/test_gptq.py",
            "status": "modified",
            "additions": 89,
            "deletions": 36,
            "changes": 125,
            "blob_url": "https://github.com/huggingface/transformers/blob/387663e571f0442feece6acf0c6016cc569cb4aa/tests%2Fquantization%2Fgptq%2Ftest_gptq.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/387663e571f0442feece6acf0c6016cc569cb4aa/tests%2Fquantization%2Fgptq%2Ftest_gptq.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fquantization%2Fgptq%2Ftest_gptq.py?ref=387663e571f0442feece6acf0c6016cc569cb4aa",
            "patch": "@@ -18,16 +18,17 @@\n \n import pytest\n \n-from transformers import AutoModelForCausalLM, AutoTokenizer, GPTQConfig\n+from transformers import AutoConfig, AutoModelForCausalLM, AutoTokenizer, GPTQConfig\n from transformers.testing_utils import (\n     is_torch_available,\n     require_accelerate,\n-    require_auto_gptq,\n+    require_gptq,\n     require_optimum,\n     require_torch_gpu,\n     require_torch_multi_gpu,\n     slow,\n )\n+from transformers.utils import is_auto_gptq_available, is_gptqmodel_available, is_ipex_available\n \n \n if is_torch_available():\n@@ -76,25 +77,29 @@ def test_optimum_config(self):\n \n @slow\n @require_optimum\n-@require_auto_gptq\n-@require_torch_gpu\n+@require_gptq\n class GPTQTest(unittest.TestCase):\n     model_name = \"bigscience/bloom-560m\"\n \n     input_text = \"Hello my name is\"\n \n     EXPECTED_OUTPUTS = set()\n+    # flaky test: gptqmodel and auto-gptq are not output equivalent nor is string compare deterministic even between transformer/torch versions\n     EXPECTED_OUTPUTS.add(\"Hello my name is John and I am a professional photographer. I\")\n     EXPECTED_OUTPUTS.add(\"Hello my name is John, I am a professional photographer and I\")\n     EXPECTED_OUTPUTS.add(\"Hello my name is John, I am a student in the University of\")\n     EXPECTED_OUTPUTS.add(\"Hello my name is John and I am a very good looking man.\")\n     EXPECTED_OUTPUTS.add(\"Hello my name is Alyson, I am a student in the\")\n     EXPECTED_OUTPUTS.add(\"Hello my name is Alyson and I am a very sweet,\")\n+    EXPECTED_OUTPUTS.add(\"Hello my name is Aiden, I am a student at the University\")\n+    EXPECTED_OUTPUTS.add(\"Hello my name is Nate and I am a member of the N\")\n+    EXPECTED_OUTPUTS.add(\"Hello my name is Nellie and I am a student at the\")\n \n     # this seems a little small considering that we are doing 4bit quant but we have a small model and ww don't quantize the embeddings\n     EXPECTED_RELATIVE_DIFFERENCE = 1.664253062\n \n     bits = 4\n+    sym = True\n     group_size = 128\n     desc_act = False\n     use_exllama = False\n@@ -103,7 +108,7 @@ class GPTQTest(unittest.TestCase):\n         \"auto-gptq is an easy-to-use model quantization library with user-friendly apis, based on GPTQ algorithm.\"\n     ]\n \n-    device_map = None\n+    device_map = \"cpu\" if is_gptqmodel_available() else None\n \n     # called only once for all test in this class\n     @classmethod\n@@ -117,21 +122,23 @@ def setUpClass(cls):\n         cls.mem_fp16 = cls.model_fp16.get_memory_footprint()\n \n         cls.tokenizer = AutoTokenizer.from_pretrained(cls.model_name, use_fast=True)\n+        cls.config = AutoConfig.from_pretrained(cls.model_name)\n \n-        quantization_config = GPTQConfig(\n+        cls.quantization_config = GPTQConfig(\n             bits=cls.bits,\n             dataset=cls.dataset,\n             tokenizer=cls.tokenizer,\n             group_size=cls.group_size,\n             desc_act=cls.desc_act,\n+            sym=cls.sym,\n             use_exllama=cls.use_exllama,\n         )\n \n         cls.quantized_model = AutoModelForCausalLM.from_pretrained(\n             cls.model_name,\n             torch_dtype=torch.float16,\n             device_map=cls.device_map,\n-            quantization_config=quantization_config,\n+            quantization_config=cls.quantization_config,\n         )\n \n     def test_memory_footprint(self):\n@@ -142,15 +149,15 @@ def test_memory_footprint(self):\n \n         mem_quantized = self.quantized_model.get_memory_footprint()\n \n-        self.assertAlmostEqual(self.mem_fp16 / mem_quantized, self.EXPECTED_RELATIVE_DIFFERENCE)\n+        self.assertAlmostEqual(self.mem_fp16 / mem_quantized, self.EXPECTED_RELATIVE_DIFFERENCE, places=4)\n \n     def test_device_and_dtype_assignment(self):\n         r\"\"\"\n         Test whether trying to cast (or assigning a device to) a model after quantization will throw an error.\n         Checks also if other models are casted correctly.\n         \"\"\"\n         # This should work\n-        if self.device_map is None:\n+        if self.device_map in (None, \"cpu\"):\n             _ = self.quantized_model.to(0)\n \n         with self.assertRaises(ValueError):\n@@ -170,16 +177,36 @@ def test_quantized_layers_class(self):\n         Simple test to check if the model conversion has been done correctly by checking on\n         the class type of the linear layers of the converted models\n         \"\"\"\n-        from auto_gptq.utils.import_utils import dynamically_import_QuantLinear\n-\n-        QuantLinear = dynamically_import_QuantLinear(\n-            use_triton=False,\n-            desc_act=self.desc_act,\n-            group_size=self.group_size,\n-            bits=self.bits,\n-            disable_exllama=not self.use_exllama,\n-            disable_exllamav2=True,\n-        )\n+        if is_gptqmodel_available():\n+            from gptqmodel.utils.importer import hf_select_quant_linear\n+\n+            if hasattr(self.config, \"quantization_config\"):\n+                checkpoint_format = self.config.quantization_config.get(\"checkpoint_format\")\n+                meta = self.config.quantization_config.get(\"meta\")\n+            else:\n+                checkpoint_format = \"gptq\"\n+                meta = None\n+            QuantLinear = hf_select_quant_linear(\n+                bits=self.bits,\n+                group_size=self.group_size,\n+                desc_act=self.desc_act,\n+                sym=self.sym,\n+                device_map=self.device_map,\n+                checkpoint_format=checkpoint_format,\n+                meta=meta,\n+                backend=self.quantization_config.backend,\n+            )\n+        elif is_auto_gptq_available():\n+            from auto_gptq.utils.import_utils import dynamically_import_QuantLinear as hf_select_quant_linear\n+\n+            QuantLinear = hf_select_quant_linear(\n+                use_triton=False,\n+                desc_act=self.desc_act,\n+                group_size=self.group_size,\n+                bits=self.bits,\n+                disable_exllama=not self.use_exllama,\n+                disable_exllamav2=True,\n+            )\n         self.assertTrue(self.quantized_model.transformer.h[0].mlp.dense_4h_to_h.__class__ == QuantLinear)\n \n     def check_inference_correctness(self, model):\n@@ -192,7 +219,7 @@ def check_inference_correctness(self, model):\n         encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n \n         # Check the exactness of the results\n-        output_sequences = model.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n+        output_sequences = model.generate(input_ids=encoded_input[\"input_ids\"].to(model.device), max_new_tokens=10)\n \n         # Get the generation\n         self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n@@ -207,6 +234,8 @@ def test_generate_quality(self):\n         if self.device_map is None:\n             self.check_inference_correctness(self.quantized_model.to(0))\n         else:\n+            if self.device_map == \"cpu\" and self.quantized_model.device.type != \"cpu\":\n+                self.quantized_model.to(\"cpu\")\n             self.check_inference_correctness(self.quantized_model)\n \n     def test_serialization(self):\n@@ -215,15 +244,28 @@ def test_serialization(self):\n         \"\"\"\n         with tempfile.TemporaryDirectory() as tmpdirname:\n             self.quantized_model.save_pretrained(tmpdirname)\n-            if not self.use_exllama:\n-                quantized_model_from_saved = AutoModelForCausalLM.from_pretrained(\n-                    tmpdirname, quantization_config=GPTQConfig(use_exllama=False, bits=4)\n-                ).to(0)\n-                self.check_quantized_layers_type(quantized_model_from_saved, \"cuda-old\")\n+            if is_auto_gptq_available() and not is_gptqmodel_available():\n+                quant_type = \"cuda-old\" if not self.use_exllama else \"exllama\"\n+                if not self.use_exllama:\n+                    quantized_model_from_saved = AutoModelForCausalLM.from_pretrained(\n+                        tmpdirname, quantization_config=GPTQConfig(use_exllama=False, bits=4)\n+                    )\n+                    if self.device_map != \"cpu\":\n+                        quantized_model_from_saved = quantized_model_from_saved.to(0)\n+                else:\n+                    quantized_model_from_saved = AutoModelForCausalLM.from_pretrained(\n+                        tmpdirname, device_map=self.device_map\n+                    )\n             else:\n-                # we need to put it directly to the gpu. Otherwise, we won't be able to initialize the exllama kernel\n-                quantized_model_from_saved = AutoModelForCausalLM.from_pretrained(tmpdirname, device_map={\"\": 0})\n-                self.check_quantized_layers_type(quantized_model_from_saved, \"exllama\")\n+                if self.device_map == \"cpu\":\n+                    quant_type = \"ipex\" if is_ipex_available() else \"torch\"\n+                else:\n+                    quant_type = \"exllama\"\n+                quantized_model_from_saved = AutoModelForCausalLM.from_pretrained(\n+                    tmpdirname, device_map=self.device_map\n+                )\n+\n+            self.check_quantized_layers_type(quantized_model_from_saved, quant_type)\n             self.check_inference_correctness(quantized_model_from_saved)\n \n     @require_accelerate\n@@ -233,20 +275,26 @@ def test_serialization_big_model_inference(self):\n         \"\"\"\n         with tempfile.TemporaryDirectory() as tmpdirname:\n             self.quantized_model.save_pretrained(tmpdirname)\n-            quantized_model_from_saved = AutoModelForCausalLM.from_pretrained(tmpdirname, device_map=\"auto\")\n+            device_map = self.device_map or \"auto\"\n+            quantized_model_from_saved = AutoModelForCausalLM.from_pretrained(tmpdirname, device_map=device_map)\n             self.check_inference_correctness(quantized_model_from_saved)\n \n+\n+@require_torch_gpu\n+class GPTQTestCUDA(GPTQTest):\n+    device_map = {\"\": 0}\n+\n     def test_change_loading_attributes(self):\n         \"\"\"\n         Test the serialization of the model and the loading of the quantized weights works with another config file\n         \"\"\"\n         with tempfile.TemporaryDirectory() as tmpdirname:\n             self.quantized_model.save_pretrained(tmpdirname)\n-            if not self.use_exllama:\n+            if is_auto_gptq_available() and not is_gptqmodel_available() and not self.use_exllama:\n                 self.check_quantized_layers_type(self.quantized_model, \"cuda-old\")\n                 # we need to put it directly to the gpu. Otherwise, we won't be able to initialize the exllama kernel\n                 quantized_model_from_saved = AutoModelForCausalLM.from_pretrained(\n-                    tmpdirname, quantization_config=GPTQConfig(use_exllama=True, bits=4), device_map={\"\": 0}\n+                    tmpdirname, quantization_config=GPTQConfig(use_exllama=True, bits=4), device_map=self.device_map\n                 )\n                 self.assertEqual(quantized_model_from_saved.config.quantization_config.bits, self.bits)\n                 self.check_quantized_layers_type(quantized_model_from_saved, \"exllama\")\n@@ -255,20 +303,20 @@ def test_change_loading_attributes(self):\n \n @require_accelerate\n @require_torch_multi_gpu\n-class GPTQTestDeviceMap(GPTQTest):\n+class GPTQTestDeviceMap(GPTQTestCUDA):\n     device_map = \"auto\"\n \n \n @require_accelerate\n @require_torch_multi_gpu\n-class GPTQTestDeviceMapExllama(GPTQTest):\n+class GPTQTestDeviceMapExllama(GPTQTestCUDA):\n     device_map = \"auto\"\n     use_exllama = True\n \n \n @slow\n @require_optimum\n-@require_auto_gptq\n+@require_gptq\n @require_torch_gpu\n @require_accelerate\n class GPTQTestActOrderExllama(unittest.TestCase):\n@@ -279,6 +327,7 @@ class GPTQTestActOrderExllama(unittest.TestCase):\n     \"\"\"\n \n     EXPECTED_OUTPUTS = set()\n+    # flaky test: gptqmodel and auto-gptq are not output equivalent nor is string compare deterministic even between transformer/torch versions\n     EXPECTED_OUTPUTS.add(\"Hello, how are you ? I'm doing good, thanks for asking.\")\n     # 4bit + act_order + 128g\n     model_name = \"hf-internal-testing/TinyLlama-1.1B-Chat-v0.3-GPTQ\"\n@@ -343,7 +392,7 @@ def test_max_input_length(self):\n \n @slow\n @require_optimum\n-@require_auto_gptq\n+@require_gptq\n @require_torch_gpu\n @require_accelerate\n class GPTQTestExllamaV2(unittest.TestCase):\n@@ -354,6 +403,7 @@ class GPTQTestExllamaV2(unittest.TestCase):\n     \"\"\"\n \n     EXPECTED_OUTPUTS = set()\n+    # flaky test: gptqmodel and auto-gptq are not output equivalent nor is string compare deterministic even between transformer/torch versions\n     EXPECTED_OUTPUTS.add(\"Hello, how are you ? I'm doing good, thanks for asking.\")\n     # 4bit + act_order + 128g\n     model_name = \"hf-internal-testing/TinyLlama-1.1B-Chat-v0.3-GPTQ\"\n@@ -374,7 +424,10 @@ def setUpClass(cls):\n         cls.tokenizer = AutoTokenizer.from_pretrained(cls.model_name, use_fast=True)\n \n     def test_quantized_layers_type(self):\n-        self.assertTrue(self.quantized_model.model.layers[0].self_attn.k_proj.QUANT_TYPE == \"exllamav2\")\n+        self.assertEqual(\n+            self.quantized_model.model.layers[0].self_attn.k_proj.QUANT_TYPE,\n+            \"exllama\" if is_gptqmodel_available() else \"exllamav2\",\n+        )\n \n     def check_inference_correctness(self, model):\n         \"\"\""
        },
        {
            "sha": "053d2cf6397a17500fa32296b414802b1d67cbae",
            "filename": "tests/utils/test_cache_utils.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/387663e571f0442feece6acf0c6016cc569cb4aa/tests%2Futils%2Ftest_cache_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/387663e571f0442feece6acf0c6016cc569cb4aa/tests%2Futils%2Ftest_cache_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Futils%2Ftest_cache_utils.py?ref=387663e571f0442feece6acf0c6016cc569cb4aa",
            "patch": "@@ -21,7 +21,7 @@\n from transformers import set_seed\n from transformers.testing_utils import (\n     is_torch_available,\n-    require_auto_gptq,\n+    require_gptq,\n     require_non_xpu,\n     require_read_token,\n     require_torch,\n@@ -319,7 +319,7 @@ def test_hybrid_cache_n_sequences(self):\n         self.assertListEqual(decoded, expected_text)\n \n     @require_non_xpu\n-    @require_auto_gptq\n+    @require_gptq\n     def test_sink_cache_hard(self):\n         tokenizer = AutoTokenizer.from_pretrained(\"TheBloke/LLaMa-7B-GPTQ\")\n         model = AutoModelForCausalLM.from_pretrained(\"TheBloke/LLaMa-7B-GPTQ\", device_map=\"auto\")"
        }
    ],
    "stats": {
        "total": 352,
        "additions": 266,
        "deletions": 86
    }
}