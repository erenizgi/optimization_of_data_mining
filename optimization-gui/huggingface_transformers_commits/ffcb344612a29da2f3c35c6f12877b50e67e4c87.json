{
    "author": "zucchini-nlp",
    "message": "Lazy import torchcodec (#40526)\n\n* lazy import\n\n* parse version\n\n* omg, we need to guard version parse as well",
    "sha": "ffcb344612a29da2f3c35c6f12877b50e67e4c87",
    "files": [
        {
            "sha": "fa9a7d3d8757f6e64c92e66f9c4c77dcba6e3c36",
            "filename": "src/transformers/audio_utils.py",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/huggingface/transformers/blob/ffcb344612a29da2f3c35c6f12877b50e67e4c87/src%2Ftransformers%2Faudio_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ffcb344612a29da2f3c35c6f12877b50e67e4c87/src%2Ftransformers%2Faudio_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Faudio_utils.py?ref=ffcb344612a29da2f3c35c6f12877b50e67e4c87",
            "patch": "@@ -17,6 +17,7 @@\n \"\"\"\n \n import base64\n+import importlib\n import io\n import os\n import warnings\n@@ -25,6 +26,7 @@\n \n import numpy as np\n import requests\n+from packaging import version\n \n from .utils import (\n     is_librosa_available,\n@@ -46,8 +48,7 @@\n     import soxr\n \n if is_torchcodec_available():\n-    from torchcodec.decoders import AudioDecoder\n-\n+    TORCHCODEC_VERSION = version.parse(importlib.metadata.version(\"torchcodec\"))\n \n AudioInput = Union[np.ndarray, \"torch.Tensor\", Sequence[np.ndarray], Sequence[\"torch.Tensor\"]]  # noqa: F821\n \n@@ -71,8 +72,8 @@ def load_audio(audio: Union[str, np.ndarray], sampling_rate=16000, timeout=None)\n     if isinstance(audio, str):\n         # Try to load with `torchcodec` but do not enforce users to install it. If not found\n         # fallback to `librosa`. If using an audio-only model, most probably `torchcodec` won't be\n-        # needed.\n-        if is_torchcodec_available():\n+        # needed. Do not raise any errors if not installed or versions do not match\n+        if is_torchcodec_available() and TORCHCODEC_VERSION >= version.parse(\"0.3.0\"):\n             audio = load_audio_torchcodec(audio, sampling_rate=sampling_rate)\n         else:\n             audio = load_audio_librosa(audio, sampling_rate=sampling_rate, timeout=timeout)\n@@ -99,7 +100,9 @@ def load_audio_torchcodec(audio: Union[str, np.ndarray], sampling_rate=16000) ->\n     Returns:\n         `np.ndarray`: A numpy array representing the audio.\n     \"\"\"\n-    requires_backends(load_audio, [\"torchcodec\"])\n+    # Lazy import so that issues in torchcodec compatibility don't crash the whole library\n+    requires_backends(load_audio_torchcodec, [\"torchcodec\"])\n+    from torchcodec.decoders import AudioDecoder\n \n     # Set `num_channels` to `1` which is what most models expects and the default in librosa\n     decoder = AudioDecoder(audio, sample_rate=sampling_rate, num_channels=1)\n@@ -123,7 +126,7 @@ def load_audio_librosa(audio: Union[str, np.ndarray], sampling_rate=16000, timeo\n     Returns:\n         `np.ndarray`: A numpy array representing the audio.\n     \"\"\"\n-    requires_backends(load_audio, [\"librosa\"])\n+    requires_backends(load_audio_librosa, [\"librosa\"])\n \n     # Load audio from URL (e.g https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen2-Audio/audio/translate_to_chinese.wav)\n     if audio.startswith(\"http://\") or audio.startswith(\"https://\"):"
        }
    ],
    "stats": {
        "total": 15,
        "additions": 9,
        "deletions": 6
    }
}