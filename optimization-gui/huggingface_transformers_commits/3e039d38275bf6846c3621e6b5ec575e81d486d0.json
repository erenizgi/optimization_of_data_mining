{
    "author": "zucchini-nlp",
    "message": "Paligemma support for multi-image (#33447)\n\n* upadte\r\n\r\n* Update src/transformers/models/paligemma/processing_paligemma.py\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* update docs\r\n\r\n* better example in tests\r\n\r\n* support image tokens\r\n\r\n* read token\r\n\r\n* Update tests/models/paligemma/test_processing_paligemma.py\r\n\r\nCo-authored-by: Pablo Montalvo <39954772+molbap@users.noreply.github.com>\r\n\r\n* nit: naming\r\n\r\n* Update docs/source/en/model_doc/paligemma.md\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* conflicts after rebasing\r\n\r\n---------\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\nCo-authored-by: Pablo Montalvo <39954772+molbap@users.noreply.github.com>",
    "sha": "3e039d38275bf6846c3621e6b5ec575e81d486d0",
    "files": [
        {
            "sha": "8b88db39bd71650ae2283d8e60d2c261d10d4b39",
            "filename": "docs/source/en/model_doc/paligemma.md",
            "status": "modified",
            "additions": 35,
            "deletions": 7,
            "changes": 42,
            "blob_url": "https://github.com/huggingface/transformers/blob/3e039d38275bf6846c3621e6b5ec575e81d486d0/docs%2Fsource%2Fen%2Fmodel_doc%2Fpaligemma.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/3e039d38275bf6846c3621e6b5ec575e81d486d0/docs%2Fsource%2Fen%2Fmodel_doc%2Fpaligemma.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fpaligemma.md?ref=3e039d38275bf6846c3621e6b5ec575e81d486d0",
            "patch": "@@ -29,7 +29,20 @@ This model was contributed by [Molbap](https://huggingface.co/Molbap).\n \n ## Usage tips\n \n-Inference with PaliGemma can be performed as follows:\n+- PaliGemma is not meant for conversational use, and it works best when fine-tuning to a specific use case. Some downstream tasks on which PaliGemma can be fine-tuned include image captioning, visual question answering (VQA), object detection, referring expression segmentation and document understanding.\n+- One can use `PaliGemmaProcessor` to prepare images, text and optional labels for the model. When fine-tuning a PaliGemma model, the `suffix` argument can be passed to the processor which creates the `labels` for the model:\n+\n+```python\n+prompt = \"What is on the flower?\"\n+answer = \"a bee\"\n+inputs = processor(images=raw_image, text=prompt, suffix=answer, return_tensors=\"pt\")\n+```\n+\n+## Usage Example\n+\n+The model can accept a single or multiple images. According to the [paper](https://arxiv.org/abs/2407.07726v1), the checkpoint PaliGemma can transfer to tasks which take multiple images as input. NLVR2 is one such task, which asks one question about two images, and requires looking at both to give the correct answer. Here's an example code for single and multi image inference.\n+\n+### Single-image Inference\n \n ```python\n from transformers import AutoProcessor, PaliGemmaForConditionalGeneration\n@@ -44,16 +57,31 @@ raw_image = Image.open(requests.get(image_file, stream=True).raw)\n inputs = processor(raw_image, prompt, return_tensors=\"pt\")\n output = model.generate(**inputs, max_new_tokens=20)\n \n-print(processor.decode(output[0], skip_special_tokens=True)[len(prompt):])\n+print(processor.decode(output[0], skip_special_tokens=True)[inputs.input_ids.shape[1]: ])\n ```\n \n-- PaliGemma is not meant for conversational use, and it works best when fine-tuning to a specific use case. Some downstream tasks on which PaliGemma can be fine-tuned include image captioning, visual question answering (VQA), object detection, referring expression segmentation and document understanding.\n-- One can use `PaliGemmaProcessor` to prepare images, text and optional labels for the model. When fine-tuning a PaliGemma model, the `suffix` argument can be passed to the processor which creates the `labels` for the model:\n+### Multi-image Inference\n \n ```python\n-prompt = \"What is on the flower?\"\n-answer = \"a bee\"\n-inputs = processor(images=raw_image, text=prompt, suffix=answer, return_tensors=\"pt\")\n+model_id = \"google/paligemma-3b-ft-nlvr2-448\"  # checkpoint tuned for multiple images\n+model = PaliGemmaForConditionalGeneration.from_pretrained(model_id)\n+processor = PaliGemmaProcessor.from_pretrained(model_id)\n+\n+prompt = \"answer en Which of the two pictures shows a snowman, first or second?\"\n+stop_sign_image = Image.open(\n+    requests.get(\"https://www.ilankelman.org/stopsigns/australia.jpg\", stream=True).raw\n+)\n+snow_image = Image.open(\n+    requests.get(\n+        \"https://huggingface.co/microsoft/kosmos-2-patch14-224/resolve/main/snowman.jpg\", stream=True\n+    ).raw\n+)\n+\n+inputs = processor(images=[[snow_image, stop_sign_image]], text=prompt, return_tensors=\"pt\")\n+\n+output = model.generate(**inputs, max_new_tokens=20)\n+print(processor.decode(output[0], skip_special_tokens=True)[inputs.input_ids.shape[1]: ])\n+\n ```\n \n ## Resources"
        },
        {
            "sha": "6bc95dc2fb8c653e3a52aad34eaf0097071d5cab",
            "filename": "src/transformers/models/paligemma/processing_paligemma.py",
            "status": "modified",
            "additions": 70,
            "deletions": 21,
            "changes": 91,
            "blob_url": "https://github.com/huggingface/transformers/blob/3e039d38275bf6846c3621e6b5ec575e81d486d0/src%2Ftransformers%2Fmodels%2Fpaligemma%2Fprocessing_paligemma.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/3e039d38275bf6846c3621e6b5ec575e81d486d0/src%2Ftransformers%2Fmodels%2Fpaligemma%2Fprocessing_paligemma.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fpaligemma%2Fprocessing_paligemma.py?ref=3e039d38275bf6846c3621e6b5ec575e81d486d0",
            "patch": "@@ -77,7 +77,7 @@ def _is_str_or_image(elem):\n     return isinstance(elem, (str)) or is_image_or_image_url(elem)\n \n \n-def build_string_from_input(prompt, bos_token, image_seq_len, image_token):\n+def build_string_from_input(prompt, bos_token, image_seq_len, image_token, num_images):\n     \"\"\"\n     Builds a string from the input prompt and image tokens.\n     For example, for the call:\n@@ -94,8 +94,33 @@ def build_string_from_input(prompt, bos_token, image_seq_len, image_token):\n         bos_token (`str`): The beginning of sentence token.\n         image_seq_len (`int`): The length of the image sequence.\n         image_token (`str`): The image token.\n+        num_images (`int`): Number of images in the prompt.\n     \"\"\"\n-    return f\"{image_token * image_seq_len}{bos_token}{prompt}\\n\"\n+    return f\"{image_token * image_seq_len * num_images}{bos_token}{prompt}\\n\"\n+\n+\n+# Copied from transformers.models.llava_next.image_processing_llava_next.make_batched_images\n+def make_batched_images(images) -> List[List[ImageInput]]:\n+    \"\"\"\n+    Accepts images in list or nested list format, and makes a list of images for preprocessing.\n+\n+    Args:\n+        images (`Union[List[List[ImageInput]], List[ImageInput], ImageInput]`):\n+            The input image.\n+\n+    Returns:\n+        list: A list of images.\n+    \"\"\"\n+    if isinstance(images, (list, tuple)) and isinstance(images[0], (list, tuple)) and is_valid_image(images[0][0]):\n+        return [img for img_list in images for img in img_list]\n+\n+    elif isinstance(images, (list, tuple)) and is_valid_image(images[0]):\n+        return images\n+\n+    elif is_valid_image(images):\n+        return [images]\n+\n+    raise ValueError(f\"Could not make batched video from {images}\")\n \n \n class PaliGemmaProcessor(ProcessorMixin):\n@@ -230,29 +255,53 @@ def __call__(\n             )\n             text = \"\"\n \n-        if isinstance(text, List) and isinstance(images, List):\n-            if len(images) < len(text):\n-                raise ValueError(\n-                    f\"Received {len(images)} images for {len(text)} prompts. Each prompt should be associated with an image.\"\n-                )\n         if _is_str_or_image(text):\n             text = [text]\n         elif isinstance(text, list) and _is_str_or_image(text[0]):\n             pass\n-        if suffix is not None and _is_str_or_image(suffix):\n-            suffix = [suffix]\n-        if suffix is not None:\n-            suffix = [sfx + self.tokenizer.eos_token for sfx in suffix]\n-\n-        input_strings = [\n-            build_string_from_input(\n-                prompt=prompt,\n-                bos_token=self.tokenizer.bos_token,\n-                image_seq_len=self.image_seq_length,\n-                image_token=IMAGE_TOKEN,\n-            )\n-            for prompt in text\n-        ]\n+\n+        if text is not None and images is not None:\n+            if not any(IMAGE_TOKEN in sample for sample in text):\n+                logger.warning(\n+                    \"You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special \"\n+                    \"image tokens in the text, as many tokens as there are images per each text. It is recommended to \"\n+                    \"add `<image>` tokens in the very beginning of your text and `<bos>` token after that. For this call, we will infer how many images \"\n+                    \"each text has and add special tokens.\"\n+                )\n+\n+                if isinstance(text, List) and isinstance(images, List):\n+                    if len(images) != len(text):\n+                        raise ValueError(\n+                            f\"Received {len(images)} images for {len(text)} prompts. Each prompt should be associated with an image or list of images.\"\n+                        )\n+\n+                # make a nested list of lists to be able to iterate over the images and text below\n+                if is_valid_image(images):\n+                    images = [[images]]\n+                elif isinstance(images, list) and is_valid_image(images[0]):\n+                    images = [[image] for image in images]\n+                elif not (isinstance(images, list) and isinstance(images[0], list) and is_valid_image(images[0][0])):\n+                    raise ValueError(\"images must be an image, list of images or list of list of images\")\n+\n+                if suffix is not None and _is_str_or_image(suffix):\n+                    suffix = [suffix]\n+                if suffix is not None:\n+                    suffix = [sfx + self.tokenizer.eos_token for sfx in suffix]\n+\n+                input_strings = [\n+                    build_string_from_input(\n+                        prompt=prompt,\n+                        bos_token=self.tokenizer.bos_token,\n+                        image_seq_len=self.image_seq_length,\n+                        image_token=IMAGE_TOKEN,\n+                        num_images=len(image_list) if isinstance(image_list, list) else 1,\n+                    )\n+                    for prompt, image_list in zip(text, images)\n+                ]\n+                images = make_batched_images(images)\n+            else:\n+                text = [sample.replace(IMAGE_TOKEN, IMAGE_TOKEN * self.image_seq_length) for sample in text]\n+                input_strings = [f\"{sample}\\n\" for sample in text]\n \n         pixel_values = self.image_processor(images, **output_kwargs[\"images_kwargs\"])[\"pixel_values\"]\n "
        },
        {
            "sha": "d954fa2a0f502b4100f683fcc15464122c15703d",
            "filename": "tests/models/paligemma/test_modeling_paligemma.py",
            "status": "modified",
            "additions": 34,
            "deletions": 22,
            "changes": 56,
            "blob_url": "https://github.com/huggingface/transformers/blob/3e039d38275bf6846c3621e6b5ec575e81d486d0/tests%2Fmodels%2Fpaligemma%2Ftest_modeling_paligemma.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/3e039d38275bf6846c3621e6b5ec575e81d486d0/tests%2Fmodels%2Fpaligemma%2Ftest_modeling_paligemma.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fpaligemma%2Ftest_modeling_paligemma.py?ref=3e039d38275bf6846c3621e6b5ec575e81d486d0",
            "patch": "@@ -326,8 +326,6 @@ def tearDown(self):\n         gc.collect()\n         torch.cuda.empty_cache()\n \n-    @slow\n-    @require_read_token\n     def test_small_model_integration_test(self):\n         # Let' s make sure we test the preprocessing to replace what is used\n         model_id = \"google/paligemma-3b-pt-224\"\n@@ -349,8 +347,40 @@ def test_small_model_integration_test(self):\n             EXPECTED_DECODED_TEXT,\n         )\n \n-    @slow\n-    @require_read_token\n+    def test_small_model_integration_test_multiimage(self):\n+        model_id = \"google/paligemma-3b-ft-nlvr2-448\"  # checkpoint tuned for multiple images\n+        model = PaliGemmaForConditionalGeneration.from_pretrained(model_id)\n+        processor = PaliGemmaProcessor.from_pretrained(model_id)\n+        prompt = \"answer en There is no snowman in any of the images. Is this true or false?\"\n+        stop_sign_image = Image.open(\n+            requests.get(\"https://www.ilankelman.org/stopsigns/australia.jpg\", stream=True).raw\n+        )\n+        snow_image = Image.open(\n+            requests.get(\n+                \"https://huggingface.co/microsoft/kosmos-2-patch14-224/resolve/main/snowman.jpg\", stream=True\n+            ).raw\n+        )\n+\n+        inputs = processor(text=prompt, images=[[snow_image, snow_image]], return_tensors=\"pt\")\n+\n+        output = model.generate(**inputs, max_new_tokens=20)\n+        EXPECTED_DECODED_TEXT = \"answer en There is no snowman in any of the images. Is this true or false?\\nFalse\"\n+\n+        self.assertEqual(\n+            self.processor.decode(output[0], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+        # try another prompt with two different image this time\n+        prompt = \"answer en There is exactly one snowman. Is this true or false?\"\n+        inputs = processor(text=prompt, images=[[snow_image, stop_sign_image]], return_tensors=\"pt\")\n+        output = model.generate(**inputs, max_new_tokens=20)\n+        EXPECTED_DECODED_TEXT = \"answer en There is exactly one snowman. Is this true or false?\\nTrue\"\n+        self.assertEqual(\n+            self.processor.decode(output[0], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n     def test_small_model_integration_test_paligemma_VQA(self):\n         # Let' s make sure we test the preprocessing to replace what is used\n         model_id = \"google/paligemma-3b-pt-224\"\n@@ -370,8 +400,6 @@ def test_small_model_integration_test_paligemma_VQA(self):\n             EXPECTED_DECODED_TEXT,\n         )\n \n-    @slow\n-    @require_read_token\n     def test_small_model_integration_test_paligemma_empty_prompt(self):\n         # Let' s make sure we test the preprocessing to replace what is used\n         model_id = \"google/paligemma-3b-pt-224\"\n@@ -392,8 +420,6 @@ def test_small_model_integration_test_paligemma_empty_prompt(self):\n             EXPECTED_DECODED_TEXT,\n         )\n \n-    @slow\n-    @require_read_token\n     def test_small_model_integration_test_paligemma_batched(self):\n         # Let' s make sure we test the preprocessing to replace what is used\n         model_id = \"google/paligemma-3b-pt-224\"\n@@ -420,9 +446,6 @@ def test_small_model_integration_test_paligemma_batched(self):\n \n         self.assertEqual(self.processor.batch_decode(output, skip_special_tokens=True), EXPECTED_DECODED_TEXT)\n \n-    @slow\n-    @require_torch\n-    @require_read_token\n     def test_small_model_integration_test_paligemma_batched_bf16(self):\n         # Let' s make sure we test the preprocessing to replace what is used\n         model_id = \"google/paligemma-3b-pt-224\"\n@@ -452,9 +475,6 @@ def test_small_model_integration_test_paligemma_batched_bf16(self):\n         EXPECTED_DECODED_TEXT = [\"answer en Where is the cow standing?\\nbeach\", \"\\ncow on the beach\"]  # fmt: skip\n         self.assertEqual(self.processor.batch_decode(output, skip_special_tokens=True), EXPECTED_DECODED_TEXT)\n \n-    @slow\n-    @require_torch\n-    @require_read_token\n     def test_small_model_integration_test_paligemma_batched_f16(self):\n         # Let' s make sure we test the preprocessing to replace what is used\n         model_id = \"google/paligemma-3b-pt-224\"\n@@ -485,9 +505,6 @@ def test_small_model_integration_test_paligemma_batched_f16(self):\n         EXPECTED_DECODED_TEXT = [\"answer en Where is the cow standing?\\nbeach\", \"\\ncow on the beach\"]  # fmt: skip\n         self.assertEqual(self.processor.batch_decode(output, skip_special_tokens=True), EXPECTED_DECODED_TEXT)\n \n-    @slow\n-    @require_torch\n-    @require_read_token\n     def test_integration_detection_bug(self):\n         # this is a reproducer of https://github.com/huggingface/transformers/issues/31425 where not enough context\n         # impacted negatively segmentation generations.\n@@ -511,8 +528,6 @@ def test_integration_detection_bug(self):\n         EXPECTED_DECODED_TEXT = \"detect shoe\\n<loc0051><loc0309><loc0708><loc0646> shoe\"  # fmt: skip\n         self.assertEqual(self.processor.decode(output[0], skip_special_tokens=True), EXPECTED_DECODED_TEXT)\n \n-    @slow\n-    @require_read_token\n     def test_paligemma_index_error_bug(self):\n         # This is a reproducer of https://github.com/huggingface/transformers/pull/28032 and makes sure it does not happen anymore\n         # Please refer to that PR, or specifically https://github.com/huggingface/transformers/pull/28032#issuecomment-1860650043 for\n@@ -536,9 +551,6 @@ def test_paligemma_index_error_bug(self):\n         # Make sure that `generate` works\n         _ = model.generate(**inputs, max_new_tokens=20)\n \n-    @slow\n-    @require_torch\n-    @require_read_token\n     def test_paligemma_finetuning_with_suffixes_bf16(self):\n         # this is a supplementary test to ensure paligemma fine-tuning that relies on token_type_ids is robust to future changes\n         model_id = \"google/paligemma-3b-pt-224\""
        },
        {
            "sha": "33b31507e17df2ae26ee88357a5e3a6f84e81ab2",
            "filename": "tests/models/paligemma/test_processing_paligemma.py",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/huggingface/transformers/blob/3e039d38275bf6846c3621e6b5ec575e81d486d0/tests%2Fmodels%2Fpaligemma%2Ftest_processing_paligemma.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/3e039d38275bf6846c3621e6b5ec575e81d486d0/tests%2Fmodels%2Fpaligemma%2Ftest_processing_paligemma.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fpaligemma%2Ftest_processing_paligemma.py?ref=3e039d38275bf6846c3621e6b5ec575e81d486d0",
            "patch": "@@ -0,0 +1,84 @@\n+# Copyright 2024 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import shutil\n+import tempfile\n+import unittest\n+\n+from transformers import AutoProcessor, GemmaTokenizerFast, PaliGemmaProcessor\n+from transformers.testing_utils import require_read_token, require_vision\n+from transformers.utils import is_vision_available\n+\n+from ...test_processing_common import ProcessorTesterMixin\n+\n+\n+if is_vision_available():\n+    from transformers import SiglipImageProcessor\n+\n+\n+@require_vision\n+@require_read_token\n+class PaliGemmaProcessorTest(ProcessorTesterMixin, unittest.TestCase):\n+    processor_class = PaliGemmaProcessor\n+\n+    def setUp(self):\n+        self.tmpdirname = tempfile.mkdtemp()\n+        image_processor = SiglipImageProcessor(do_center_crop=False)\n+        tokenizer = GemmaTokenizerFast.from_pretrained(\"google/gemma-7b\")\n+        image_processor.image_seq_length = 32\n+\n+        processor = PaliGemmaProcessor(image_processor=image_processor, tokenizer=tokenizer)\n+        processor.save_pretrained(self.tmpdirname)\n+\n+    def get_tokenizer(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).tokenizer\n+\n+    def get_image_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).image_processor\n+\n+    def tearDown(self):\n+        shutil.rmtree(self.tmpdirname)\n+\n+    def test_text_with_image_tokens(self):\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        text_multi_images = \"<image><image><bos>Dummy text!\"\n+        text_single_image = \"<image><bos>Dummy text!\"\n+        text_no_image = \"Dummy text!\"\n+\n+        image = self.prepare_image_inputs()[0]\n+\n+        out_noimage = processor(text=text_no_image, images=image, return_tensors=\"np\")\n+        out_singlimage = processor(text=text_single_image, images=image, return_tensors=\"np\")\n+        for k in out_noimage:\n+            self.assertTrue(out_noimage[k].tolist() == out_singlimage[k].tolist())\n+\n+        out_multiimages = processor(text=text_multi_images, images=[image, image], return_tensors=\"np\")\n+        out_noimage = processor(text=text_no_image, images=[[image, image]], return_tensors=\"np\")\n+\n+        # We can't be sure what is users intention, whether user want \"one text + two images\" or user forgot to add the second text\n+        with self.assertRaises(ValueError):\n+            out_noimage = processor(text=text_no_image, images=[image, image], return_tensors=\"np\")\n+\n+        for k in out_noimage:\n+            self.assertTrue(out_noimage[k].tolist() == out_multiimages[k].tolist())\n+\n+        text_batched = [\"Dummy text!\", \"Dummy text!\"]\n+        text_batched_with_image = [\"<image><bos>Dummy text!\", \"<image><bos>Dummy text!\"]\n+        out_images = processor(text=text_batched_with_image, images=[image, image], return_tensors=\"np\")\n+        out_noimage_nested = processor(text=text_batched, images=[[image], [image]], return_tensors=\"np\")\n+        out_noimage = processor(text=text_batched, images=[image, image], return_tensors=\"np\")\n+        for k in out_noimage:\n+            self.assertTrue(out_noimage[k].tolist() == out_images[k].tolist() == out_noimage_nested[k].tolist())"
        }
    ],
    "stats": {
        "total": 273,
        "additions": 223,
        "deletions": 50
    }
}