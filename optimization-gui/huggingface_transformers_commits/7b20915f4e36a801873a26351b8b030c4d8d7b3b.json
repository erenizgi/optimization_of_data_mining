{
    "author": "zRzRzRzRzRzRzR",
    "message": "GLM-4.5V Model Support (#39805)\n\n* init\n\n* update\n\n* uupdate\n\n* ruff\n\n* t patch is 2 defalut not 1\n\n* draft\n\n* back\n\n* back1\n\n* update\n\n* config update\n\n* update using glm-41 format\n\n* add self.rope_scaling = config.rope_scaling\n\n* update config\n\n* update\n\n* remove the processor\n\n* update\n\n* fix tests\n\n* update\n\n* for test\n\n* update\n\n* update 2126\n\n* self.rope_scaling is missing in GLM4MOE lets add it\n\n* update\n\n* update\n\n* Update modular_glm4v_moe.py\n\n* change config\n\n* update apply_multimodal_rotary_pos_emb\n\n* format\n\n* update\n\n* Delete 3-rollout_qas_thinking_answers.py\n\n* use right name\n\n* update with place holder\n\n* update\n\n* use right rotary\n\n* Update image_processing_glm4v_fast.py\n\n* rope_config_validation needs to rewrite the entire config file in modular\n\n* update\n\n* changed name\n\n* update\n\n* Update modeling_glm4v_moe.py\n\n* _init_weights shoud be add in Glm4vMoePreTrainedModel\n\n* remove use_qk_norm\n\n* Update modular_glm4v_moe.py\n\n* remove use_qk_norm as it is not use\n\n* fix style\n\n* deprecations are not needed on new models\n\n* fix merge issues\n\n---------\n\nCo-authored-by: raushan <raushan@huggingface.co>\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>\nCo-authored-by: Arthur <arthur.zucker@gmail.com>",
    "sha": "7b20915f4e36a801873a26351b8b030c4d8d7b3b",
    "files": [
        {
            "sha": "a763c2b260687402330818b7937ff8f03eb7b153",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -1009,6 +1009,8 @@\n         title: GIT\n       - local: model_doc/glm4v\n         title: glm4v\n+      - local: model_doc/glm4v_moe\n+        title: glm4v_moe\n       - local: model_doc/got_ocr2\n         title: GOT-OCR2\n       - local: model_doc/granitevision"
        },
        {
            "sha": "6763400bf2bd7129bf1687642ff5b6b1805d16c6",
            "filename": "docs/source/en/model_doc/glm4v_moe.md",
            "status": "added",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm4v_moe.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm4v_moe.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm4v_moe.md?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -0,0 +1,64 @@\n+<!--Copyright 2025 The ZhipuAI Inc. and The HuggingFace Inc. team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+<div style=\"float: right;\">\n+    <div class=\"flex flex-wrap space-x-1\">\n+<img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+<img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+<img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">    </div>\n+</div>\n+\n+# Glm4vMoe\n+\n+## Overview\n+\n+The Glm4vMoe model was proposed in [<INSERT PAPER NAME HERE>](<INSERT PAPER LINK HERE>) by <INSERT AUTHORS HERE>.\n+<INSERT SHORT SUMMARY HERE>\n+\n+The abstract from the paper is the following:\n+\n+*<INSERT PAPER ABSTRACT HERE>*\n+\n+Tips:\n+\n+<INSERT TIPS ABOUT MODEL HERE>\n+\n+This model was contributed by [INSERT YOUR HF USERNAME HERE](https://huggingface.co/<INSERT YOUR HF USERNAME HERE>).\n+The original code can be found [here](<INSERT LINK TO GITHUB REPO HERE>).\n+\n+\n+## Glm4vMoeConfig\n+\n+[[autodoc]] Glm4vMoeConfig\n+\n+## Glm4vMoeTextConfig\n+\n+[[autodoc]] Glm4vMoeTextConfig\n+\n+## Glm4vMoeTextModel\n+\n+[[autodoc]] Glm4vMoeTextModel\n+    - forward\n+\n+## Glm4vMoeModel\n+\n+[[autodoc]] Glm4vMoeModel\n+    - forward\n+\n+## Glm4vMoeForConditionalGeneration\n+\n+[[autodoc]] Glm4vMoeForConditionalGeneration\n+    - forward"
        },
        {
            "sha": "9fedcb20c109377fe2e6eaff2668d56acdb4faf3",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -163,6 +163,8 @@\n         (\"glm4\", \"Glm4Config\"),\n         (\"glm4_moe\", \"Glm4MoeConfig\"),\n         (\"glm4v\", \"Glm4vConfig\"),\n+        (\"glm4v_moe\", \"Glm4vMoeConfig\"),\n+        (\"glm4v_moe_text\", \"Glm4vMoeTextConfig\"),\n         (\"glm4v_text\", \"Glm4vTextConfig\"),\n         (\"glpn\", \"GLPNConfig\"),\n         (\"got_ocr2\", \"GotOcr2Config\"),\n@@ -569,6 +571,8 @@\n         (\"glm4\", \"GLM4\"),\n         (\"glm4_moe\", \"Glm4MoE\"),\n         (\"glm4v\", \"GLM4V\"),\n+        (\"glm4v_moe\", \"GLM4VMOE\"),\n+        (\"glm4v_moe_text\", \"GLM4VMOE\"),\n         (\"glm4v_text\", \"GLM4V\"),\n         (\"glpn\", \"GLPN\"),\n         (\"got_ocr2\", \"GOT-OCR2\"),\n@@ -900,6 +904,7 @@\n         (\"gemma3n_text\", \"gemma3n\"),\n         (\"gemma3n_vision\", \"gemma3n\"),\n         (\"glm4v_text\", \"glm4v\"),\n+        (\"glm4v_moe_text\", \"glm4v_moe\"),\n         (\"idefics3_vision\", \"idefics3\"),\n         (\"siglip_vision_model\", \"siglip\"),\n         (\"aimv2_vision_model\", \"aimv2\"),"
        },
        {
            "sha": "42790e22fe79fb9610e6cebd76e69ae736bf250a",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -165,6 +165,8 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"glm4\", \"Glm4Model\"),\n         (\"glm4_moe\", \"Glm4MoeModel\"),\n         (\"glm4v\", \"Glm4vModel\"),\n+        (\"glm4v_moe\", \"Glm4vMoeModel\"),\n+        (\"glm4v_moe_text\", \"Glm4vMoeTextModel\"),\n         (\"glm4v_text\", \"Glm4vTextModel\"),\n         (\"glpn\", \"GLPNModel\"),\n         (\"got_ocr2\", \"GotOcr2Model\"),\n@@ -970,6 +972,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"gemma3n\", \"Gemma3nForConditionalGeneration\"),\n         (\"git\", \"GitForCausalLM\"),\n         (\"glm4v\", \"Glm4vForConditionalGeneration\"),\n+        (\"glm4v_moe\", \"Glm4vMoeForConditionalGeneration\"),\n         (\"got_ocr2\", \"GotOcr2ForConditionalGeneration\"),\n         (\"idefics\", \"IdeficsForVisionText2Text\"),\n         (\"idefics2\", \"Idefics2ForConditionalGeneration\"),"
        },
        {
            "sha": "c121247f080030aba13b378292588f78f84a5746",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -74,6 +74,7 @@\n         (\"gemma3n\", \"Gemma3nProcessor\"),\n         (\"git\", \"GitProcessor\"),\n         (\"glm4v\", \"Glm4vProcessor\"),\n+        (\"glm4v_moe\", \"Glm4vProcessor\"),\n         (\"got_ocr2\", \"GotOcr2Processor\"),\n         (\"granite_speech\", \"GraniteSpeechProcessor\"),\n         (\"grounding-dino\", \"GroundingDinoProcessor\"),"
        },
        {
            "sha": "924ec66ce1a195721d3f8e3575bee208e85eded2",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -294,6 +294,7 @@\n         (\"glm4\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"glm4_moe\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"glm4v\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n+        (\"glm4v_moe\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"gpt-sw3\", (\"GPTSw3Tokenizer\" if is_sentencepiece_available() else None, None)),\n         (\"gpt2\", (\"GPT2Tokenizer\", \"GPT2TokenizerFast\" if is_tokenizers_available() else None)),\n         (\"gpt_bigcode\", (\"GPT2Tokenizer\", \"GPT2TokenizerFast\" if is_tokenizers_available() else None)),"
        },
        {
            "sha": "d43ace23a581900fa834d35e70c0187b5919b74d",
            "filename": "src/transformers/models/glm4_moe/modeling_glm4_moe.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4_moe%2Fmodeling_glm4_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4_moe%2Fmodeling_glm4_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4_moe%2Fmodeling_glm4_moe.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -135,6 +135,7 @@ def __init__(self, config: Glm4MoeConfig, layer_idx: Optional[int] = None):\n         self.head_dim = getattr(config, \"head_dim\", config.hidden_size // config.num_attention_heads)\n         self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n         self.scaling = self.head_dim**-0.5\n+        self.rope_scaling = config.rope_scaling\n         self.attention_dropout = config.attention_dropout\n         self.is_causal = True\n "
        },
        {
            "sha": "65ea5ddd54b1652963a72633b46956a344bf8ba5",
            "filename": "src/transformers/models/glm4_moe/modular_glm4_moe.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4_moe%2Fmodular_glm4_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4_moe%2Fmodular_glm4_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4_moe%2Fmodular_glm4_moe.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -263,6 +263,7 @@ def __init__(self, config: Glm4MoeConfig, layer_idx: Optional[int] = None):\n         self.head_dim = getattr(config, \"head_dim\", config.hidden_size // config.num_attention_heads)\n         self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n         self.scaling = self.head_dim**-0.5\n+        self.rope_scaling = config.rope_scaling\n         self.attention_dropout = config.attention_dropout\n         self.is_causal = True\n "
        },
        {
            "sha": "31308a8aec3283f0c25815484d8c73d87759d0a8",
            "filename": "src/transformers/models/glm4v/configuration_glm4v.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconfiguration_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconfiguration_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconfiguration_glm4v.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -94,7 +94,7 @@ def __init__(\n         patch_size=14,\n         rms_norm_eps=1e-05,\n         spatial_merge_size=2,\n-        temporal_patch_size=1,\n+        temporal_patch_size=2,\n         out_hidden_size=4096,\n         intermediate_size=13696,\n         initializer_range=0.02,"
        },
        {
            "sha": "c2516b52b63313222fe7d543cc275a3619f03db7",
            "filename": "src/transformers/models/glm4v/image_processing_glm4v_fast.py",
            "status": "modified",
            "additions": 36,
            "deletions": 47,
            "changes": 83,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fimage_processing_glm4v_fast.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fimage_processing_glm4v_fast.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fimage_processing_glm4v_fast.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -22,8 +22,6 @@\n from ...image_processing_utils_fast import (\n     BaseImageProcessorFast,\n     DefaultFastImageProcessorKwargs,\n-    group_images_by_shape,\n-    reorder_images,\n )\n from ...image_utils import (\n     OPENAI_CLIP_MEAN,\n@@ -47,7 +45,6 @@\n if is_torch_available():\n     import torch\n \n-\n if is_torchvision_available():\n     if is_torchvision_v2_available():\n         from torchvision.transforms.v2 import functional as F\n@@ -112,48 +109,44 @@ def _preprocess(\n         Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n         \"\"\"\n \n-        # Group images by size for batched resizing\n-        grouped_images, grouped_images_index = group_images_by_shape(images, disable_grouping=disable_grouping)\n-        resized_images_grouped = {}\n-        for shape, stacked_images in grouped_images.items():\n-            height, width = stacked_images.shape[-2:]\n+        processed_images = []\n+        processed_grids = []\n+\n+        all_target_sizes = []\n+        for image in images:\n+            height, width = image.shape[-2:]\n+            resized_height, resized_width = smart_resize(\n+                num_frames=temporal_patch_size,\n+                height=height,\n+                width=width,\n+                temporal_factor=temporal_patch_size,\n+                factor=patch_size * merge_size,\n+            )\n+            all_target_sizes.append((resized_height, resized_width))\n+\n+        target_height = max([s[0] for s in all_target_sizes])\n+        target_width = max([s[1] for s in all_target_sizes])\n+\n+        for image in images:\n             if do_resize:\n-                resized_height, resized_width = smart_resize(\n-                    num_frames=temporal_patch_size,\n-                    height=height,\n-                    width=width,\n-                    temporal_factor=temporal_patch_size,\n-                    factor=patch_size * merge_size,\n-                )\n-                stacked_images = self.resize(\n-                    stacked_images,\n-                    size=SizeDict(height=resized_height, width=resized_width),\n+                image = self.resize(\n+                    image,\n+                    size=SizeDict(height=target_height, width=target_width),\n                     interpolation=interpolation,\n                 )\n-            resized_images_grouped[shape] = stacked_images\n-        resized_images = reorder_images(resized_images_grouped, grouped_images_index)\n-        # Group images by size for further processing\n-        # Needed in case do_resize is False, or resize returns images with different sizes\n-        grouped_images, grouped_images_index = group_images_by_shape(resized_images, disable_grouping=disable_grouping)\n-        processed_images_grouped = {}\n-        processed_grids = {}\n-        for shape, stacked_images in grouped_images.items():\n-            resized_height, resized_width = stacked_images.shape[-2:]\n-            # Fused rescale and normalize\n-            stacked_images = self.rescale_and_normalize(\n-                stacked_images, do_rescale, rescale_factor, do_normalize, image_mean, image_std\n-            )\n-            # add a temporal dimension\n-            patches = stacked_images.unsqueeze(1)\n-            if patches.shape[1] % temporal_patch_size != 0:\n-                repeats = patches[:, -1:].repeat(1, temporal_patch_size - 1, 1, 1, 1)\n-                patches = torch.cat([patches, repeats], dim=1)\n-            batch_size, grid_t, channel = patches.shape[:3]\n-            grid_t = grid_t // temporal_patch_size\n-            grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n \n+            image = self.rescale_and_normalize(\n+                image.unsqueeze(0), do_rescale, rescale_factor, do_normalize, image_mean, image_std\n+            ).squeeze(0)\n+\n+            patches = image.unsqueeze(0)\n+            if patches.shape[0] % temporal_patch_size != 0:\n+                repeats = patches[-1:].repeat(temporal_patch_size - (patches.shape[0] % temporal_patch_size), 1, 1, 1)\n+                patches = torch.cat([patches, repeats], dim=0)\n+            channel = patches.shape[1]\n+            grid_t = patches.shape[0] // temporal_patch_size\n+            grid_h, grid_w = target_height // patch_size, target_width // patch_size\n             patches = patches.view(\n-                batch_size,\n                 grid_t,\n                 temporal_patch_size,\n                 channel,\n@@ -164,18 +157,14 @@ def _preprocess(\n                 merge_size,\n                 patch_size,\n             )\n-            patches = patches.permute(0, 1, 4, 7, 5, 8, 3, 2, 6, 9)\n+            patches = patches.permute(0, 3, 6, 4, 7, 2, 1, 5, 8)\n             flatten_patches = patches.reshape(\n-                batch_size,\n                 grid_t * grid_h * grid_w,\n                 channel * temporal_patch_size * patch_size * patch_size,\n             )\n+            processed_images.append(flatten_patches)\n+            processed_grids.append([grid_t, grid_h, grid_w])\n \n-            processed_images_grouped[shape] = flatten_patches\n-            processed_grids[shape] = [[grid_t, grid_h, grid_w]] * batch_size\n-\n-        processed_images = reorder_images(processed_images_grouped, grouped_images_index)\n-        processed_grids = reorder_images(processed_grids, grouped_images_index)\n         pixel_values = torch.stack(processed_images, dim=0)\n         image_grid_thw = torch.tensor(processed_grids)\n "
        },
        {
            "sha": "ac46e93ffd93e033c0172f5b94288cb32bced9f2",
            "filename": "src/transformers/models/glm4v/modeling_glm4v.py",
            "status": "modified",
            "additions": 137,
            "deletions": 204,
            "changes": 341,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodeling_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodeling_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodeling_glm4v.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -39,7 +39,7 @@\n from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n from ...processing_utils import Unpack\n from ...utils import TransformersKwargs, auto_docstring, can_return_tuple, is_torchdynamo_compiling, logging\n-from ...utils.deprecation import deprecate_kwarg\n+from ...utils.generic import check_model_inputs\n from .configuration_glm4v import Glm4vConfig, Glm4vTextConfig, Glm4vVisionConfig\n \n \n@@ -399,130 +399,6 @@ def forward(\n         return hidden_states\n \n \n-@auto_docstring\n-class Glm4vPreTrainedModel(PreTrainedModel):\n-    config: Glm4vConfig\n-    base_model_prefix = \"model\"\n-    supports_gradient_checkpointing = True\n-    _no_split_modules = [\"Glm4vTextDecoderLayer\", \"Glm4vVisionBlock\"]\n-    _skip_keys_device_placement = \"past_key_values\"\n-    _supports_flash_attn = True\n-    _supports_sdpa = True\n-\n-    _can_compile_fullgraph = True\n-    _supports_attention_backend = True\n-\n-\n-class Glm4vVisionModel(Glm4vPreTrainedModel):\n-    config: Glm4vVisionConfig\n-    _no_split_modules = [\"Glm4vVisionBlock\"]\n-\n-    def __init__(self, config) -> None:\n-        super().__init__(config)\n-        self.spatial_merge_size = config.spatial_merge_size\n-        self.patch_size = config.patch_size\n-\n-        self.embeddings = Glm4vVisionEmbeddings(config)\n-        self.patch_embed = Glm4vVisionPatchEmbed(config)\n-\n-        head_dim = config.hidden_size // config.num_heads\n-        self.rotary_pos_emb = Glm4vVisionRotaryEmbedding(head_dim // 2)\n-\n-        self.blocks = nn.ModuleList([Glm4vVisionBlock(config) for _ in range(config.depth)])\n-        self.merger = Glm4vVisionPatchMerger(\n-            dim=config.out_hidden_size, context_dim=config.intermediate_size, hidden_act=config.hidden_act\n-        )\n-\n-        self.post_conv_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n-        self.downsample = nn.Conv2d(\n-            in_channels=config.hidden_size,\n-            out_channels=config.out_hidden_size,\n-            kernel_size=config.spatial_merge_size,\n-            stride=config.spatial_merge_size,\n-        )\n-        self.post_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n-\n-        self.gradient_checkpointing = False\n-        self.post_init()\n-\n-    def rot_pos_emb(self, grid_thw):\n-        pos_ids = []\n-        for t, h, w in grid_thw:\n-            hpos_ids = torch.arange(h).unsqueeze(1).expand(-1, w)\n-            hpos_ids = hpos_ids.reshape(\n-                h // self.spatial_merge_size,\n-                self.spatial_merge_size,\n-                w // self.spatial_merge_size,\n-                self.spatial_merge_size,\n-            )\n-            hpos_ids = hpos_ids.permute(0, 2, 1, 3)\n-            hpos_ids = hpos_ids.flatten()\n-\n-            wpos_ids = torch.arange(w).unsqueeze(0).expand(h, -1)\n-            wpos_ids = wpos_ids.reshape(\n-                h // self.spatial_merge_size,\n-                self.spatial_merge_size,\n-                w // self.spatial_merge_size,\n-                self.spatial_merge_size,\n-            )\n-            wpos_ids = wpos_ids.permute(0, 2, 1, 3)\n-            wpos_ids = wpos_ids.flatten()\n-            pos_ids.append(torch.stack([hpos_ids, wpos_ids], dim=-1).repeat(t, 1))\n-        pos_ids = torch.cat(pos_ids, dim=0)\n-        max_grid_size = grid_thw[:, 1:].max()\n-        rotary_pos_emb_full = self.rotary_pos_emb(max_grid_size)\n-        rotary_pos_emb = rotary_pos_emb_full[pos_ids].flatten(1)\n-        return rotary_pos_emb, pos_ids\n-\n-    def forward(self, hidden_states: torch.Tensor, grid_thw: torch.Tensor) -> torch.Tensor:\n-        \"\"\"\n-        Args:\n-            hidden_states (`torch.Tensor` of shape `(seq_len, hidden_size)`):\n-                The final hidden states of the model.\n-            grid_thw (`torch.Tensor` of shape `(num_images_or_videos, 3)`):\n-                The temporal, height and width of feature shape of each image in LLM.\n-\n-        Returns:\n-            `torch.Tensor`: hidden_states.\n-        \"\"\"\n-        hidden_states = self.patch_embed(hidden_states)\n-        hidden_states = self.post_conv_layernorm(hidden_states)\n-\n-        rotary_pos_emb, image_type_ids = self.rot_pos_emb(grid_thw)\n-        emb = torch.cat((rotary_pos_emb, rotary_pos_emb), dim=-1)\n-        position_embeddings = (emb.cos(), emb.sin())\n-\n-        cu_seqlens = torch.repeat_interleave(grid_thw[:, 1] * grid_thw[:, 2], grid_thw[:, 0]).cumsum(\n-            dim=0,\n-            # Select dtype based on the following factors:\n-            #  - FA2 requires that cu_seqlens_q must have dtype int32\n-            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n-            # See https://github.com/huggingface/transformers/pull/34852 for more information\n-            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n-        )\n-        cu_seqlens = F.pad(cu_seqlens, (1, 0), value=0)\n-        seqlens = (cu_seqlens[1:] - cu_seqlens[:-1]).tolist()\n-        hidden_states = self.embeddings(hidden_states, seqlens, grid_thw, image_type_ids[:, 0], image_type_ids[:, 1])\n-\n-        for blk in self.blocks:\n-            hidden_states = blk(\n-                hidden_states,\n-                cu_seqlens=cu_seqlens,\n-                position_embeddings=position_embeddings,\n-            )\n-\n-        hidden_states = self.post_layernorm(hidden_states)\n-\n-        hidden_states = hidden_states.view(\n-            -1, self.spatial_merge_size, self.spatial_merge_size, hidden_states.shape[-1]\n-        )\n-        hidden_states = hidden_states.permute(0, 3, 1, 2)\n-        hidden_states = self.downsample(hidden_states).view(-1, self.config.out_hidden_size)\n-\n-        hidden_states = self.merger(hidden_states)\n-        return hidden_states\n-\n-\n class Glm4vTextRotaryEmbedding(nn.Module):\n     inv_freq: torch.Tensor  # fix linting for `register_buffer`\n \n@@ -651,16 +527,13 @@ def __init__(self, config: Glm4vTextConfig, layer_idx: Optional[int] = None):\n         self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=True)\n         self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=False)\n \n-    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n     def forward(\n         self,\n         hidden_states: torch.Tensor,\n         position_embeddings: tuple[torch.Tensor, torch.Tensor],\n         attention_mask: Optional[torch.Tensor] = None,\n         position_ids: Optional[torch.LongTensor] = None,\n         past_key_values: Optional[Cache] = None,\n-        output_attentions: bool = False,\n-        use_cache: bool = False,\n         cache_position: Optional[torch.LongTensor] = None,\n         **kwargs: Unpack[FlashAttentionKwargs],\n     ) -> tuple[torch.Tensor, Optional[torch.Tensor], Optional[tuple[torch.Tensor]]]:\n@@ -700,7 +573,7 @@ def forward(\n \n         attn_output = attn_output.reshape(bsz, q_len, -1).contiguous()\n         attn_output = self.o_proj(attn_output)\n-        return attn_output, attn_weights, past_key_values\n+        return attn_output, attn_weights\n \n \n class Glm4vTextMLP(nn.Module):\n@@ -732,7 +605,6 @@ def __init__(self, config: Glm4vTextConfig, layer_idx: int):\n         self.post_self_attn_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n         self.post_mlp_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n \n-    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n     def forward(\n         self,\n         hidden_states: torch.Tensor,\n@@ -750,7 +622,7 @@ def forward(\n         hidden_states = self.input_layernorm(hidden_states)\n \n         # Self Attention\n-        hidden_states, self_attn_weights, present_key_value = self.self_attn(\n+        hidden_states, _ = self.self_attn(\n             hidden_states=hidden_states,\n             position_embeddings=position_embeddings,\n             attention_mask=attention_mask,\n@@ -772,15 +644,7 @@ def forward(\n         hidden_states = self.post_mlp_layernorm(hidden_states)\n         hidden_states = residual + hidden_states\n \n-        outputs = (hidden_states,)\n-\n-        if output_attentions:\n-            outputs += (self_attn_weights,)\n-\n-        if use_cache:\n-            outputs += (present_key_value,)\n-\n-        return outputs\n+        return hidden_states\n \n \n @dataclass\n@@ -808,6 +672,134 @@ class Glm4vModelOutputWithPast(ModelOutput):\n     rope_deltas: Optional[torch.LongTensor] = None\n \n \n+@auto_docstring\n+class Glm4vPreTrainedModel(PreTrainedModel):\n+    config: Glm4vConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"Glm4vTextDecoderLayer\", \"Glm4vVisionBlock\"]\n+    _skip_keys_device_placement = \"past_key_values\"\n+    _supports_flash_attn = True\n+    _supports_sdpa = True\n+\n+    _can_compile_fullgraph = True\n+    _supports_attention_backend = True\n+    _can_record_outputs = {\n+        \"hidden_states\": Glm4vTextDecoderLayer,\n+        \"attentions\": Glm4vTextAttention,\n+    }\n+\n+\n+class Glm4vVisionModel(Glm4vPreTrainedModel):\n+    config: Glm4vVisionConfig\n+    _no_split_modules = [\"Glm4vVisionBlock\"]\n+\n+    def __init__(self, config) -> None:\n+        super().__init__(config)\n+        self.spatial_merge_size = config.spatial_merge_size\n+        self.patch_size = config.patch_size\n+\n+        self.embeddings = Glm4vVisionEmbeddings(config)\n+        self.patch_embed = Glm4vVisionPatchEmbed(config)\n+\n+        head_dim = config.hidden_size // config.num_heads\n+        self.rotary_pos_emb = Glm4vVisionRotaryEmbedding(head_dim // 2)\n+\n+        self.blocks = nn.ModuleList([Glm4vVisionBlock(config) for _ in range(config.depth)])\n+        self.merger = Glm4vVisionPatchMerger(\n+            dim=config.out_hidden_size, context_dim=config.intermediate_size, hidden_act=config.hidden_act\n+        )\n+\n+        self.post_conv_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.downsample = nn.Conv2d(\n+            in_channels=config.hidden_size,\n+            out_channels=config.out_hidden_size,\n+            kernel_size=config.spatial_merge_size,\n+            stride=config.spatial_merge_size,\n+        )\n+        self.post_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+        self.gradient_checkpointing = False\n+        self.post_init()\n+\n+    def rot_pos_emb(self, grid_thw):\n+        pos_ids = []\n+        for t, h, w in grid_thw:\n+            hpos_ids = torch.arange(h).unsqueeze(1).expand(-1, w)\n+            hpos_ids = hpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            hpos_ids = hpos_ids.permute(0, 2, 1, 3)\n+            hpos_ids = hpos_ids.flatten()\n+\n+            wpos_ids = torch.arange(w).unsqueeze(0).expand(h, -1)\n+            wpos_ids = wpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            wpos_ids = wpos_ids.permute(0, 2, 1, 3)\n+            wpos_ids = wpos_ids.flatten()\n+            pos_ids.append(torch.stack([hpos_ids, wpos_ids], dim=-1).repeat(t, 1))\n+        pos_ids = torch.cat(pos_ids, dim=0)\n+        max_grid_size = grid_thw[:, 1:].max()\n+        rotary_pos_emb_full = self.rotary_pos_emb(max_grid_size)\n+        rotary_pos_emb = rotary_pos_emb_full[pos_ids].flatten(1)\n+        return rotary_pos_emb, pos_ids\n+\n+    def forward(self, hidden_states: torch.Tensor, grid_thw: torch.Tensor) -> torch.Tensor:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.Tensor` of shape `(seq_len, hidden_size)`):\n+                The final hidden states of the model.\n+            grid_thw (`torch.Tensor` of shape `(num_images_or_videos, 3)`):\n+                The temporal, height and width of feature shape of each image in LLM.\n+\n+        Returns:\n+            `torch.Tensor`: hidden_states.\n+        \"\"\"\n+        hidden_states = self.patch_embed(hidden_states)\n+        hidden_states = self.post_conv_layernorm(hidden_states)\n+\n+        rotary_pos_emb, image_type_ids = self.rot_pos_emb(grid_thw)\n+        emb = torch.cat((rotary_pos_emb, rotary_pos_emb), dim=-1)\n+        position_embeddings = (emb.cos(), emb.sin())\n+\n+        cu_seqlens = torch.repeat_interleave(grid_thw[:, 1] * grid_thw[:, 2], grid_thw[:, 0]).cumsum(\n+            dim=0,\n+            # Select dtype based on the following factors:\n+            #  - FA2 requires that cu_seqlens_q must have dtype int32\n+            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n+            # See https://github.com/huggingface/transformers/pull/34852 for more information\n+            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_seqlens = F.pad(cu_seqlens, (1, 0), value=0)\n+        seqlens = (cu_seqlens[1:] - cu_seqlens[:-1]).tolist()\n+        hidden_states = self.embeddings(hidden_states, seqlens, grid_thw, image_type_ids[:, 0], image_type_ids[:, 1])\n+\n+        for blk in self.blocks:\n+            hidden_states = blk(\n+                hidden_states,\n+                cu_seqlens=cu_seqlens,\n+                position_embeddings=position_embeddings,\n+            )\n+\n+        hidden_states = self.post_layernorm(hidden_states)\n+\n+        hidden_states = hidden_states.view(\n+            -1, self.spatial_merge_size, self.spatial_merge_size, hidden_states.shape[-1]\n+        )\n+        hidden_states = hidden_states.permute(0, 3, 1, 2)\n+        hidden_states = self.downsample(hidden_states).view(-1, self.config.out_hidden_size)\n+\n+        hidden_states = self.merger(hidden_states)\n+        return hidden_states\n+\n+\n @auto_docstring\n class Glm4vTextModel(Glm4vPreTrainedModel):\n     config: Glm4vTextConfig\n@@ -829,7 +821,7 @@ def __init__(self, config: Glm4vTextConfig):\n         self.post_init()\n \n     @auto_docstring\n-    @can_return_tuple\n+    @check_model_inputs\n     def forward(\n         self,\n         input_ids: Optional[torch.LongTensor] = None,\n@@ -838,27 +830,12 @@ def forward(\n         past_key_values: Optional[list[torch.FloatTensor]] = None,\n         inputs_embeds: Optional[torch.FloatTensor] = None,\n         use_cache: Optional[bool] = None,\n-        output_attentions: Optional[bool] = None,\n-        output_hidden_states: Optional[bool] = None,\n         cache_position: Optional[torch.LongTensor] = None,\n         **kwargs: Unpack[FlashAttentionKwargs],\n     ) -> Union[tuple, BaseModelOutputWithPast]:\n-        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n-        output_hidden_states = (\n-            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n-        )\n-        use_cache = use_cache if use_cache is not None else self.config.use_cache\n-\n         if (input_ids is None) ^ (inputs_embeds is not None):\n             raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n \n-        if self.gradient_checkpointing and self.training:\n-            if use_cache:\n-                logger.warning_once(\n-                    \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n-                )\n-                use_cache = False\n-\n         # torch.jit.trace() doesn't support cache objects in the output\n         if use_cache and past_key_values is None and not torch.jit.is_tracing():\n             past_key_values = DynamicCache()\n@@ -892,42 +869,23 @@ def forward(\n         # create position embeddings to be shared across the decoder layers\n         position_embeddings = self.rotary_emb(hidden_states, position_ids)\n \n-        # decoder layers\n-        all_hidden_states = () if output_hidden_states else None\n-        all_self_attns = () if output_attentions else None\n-\n         for decoder_layer in self.layers:\n-            if output_hidden_states:\n-                all_hidden_states += (hidden_states,)\n-\n             layer_outputs = decoder_layer(\n                 hidden_states,\n                 position_embeddings=position_embeddings,\n                 attention_mask=causal_mask,\n                 position_ids=position_ids,\n                 past_key_values=past_key_values,\n-                output_attentions=output_attentions,\n-                use_cache=use_cache,\n                 cache_position=cache_position,\n                 **kwargs,\n             )\n-\n-            hidden_states = layer_outputs[0]\n-\n-            if output_attentions:\n-                all_self_attns += (layer_outputs[1],)\n+            hidden_states = layer_outputs\n \n         hidden_states = self.norm(hidden_states)\n \n-        # add hidden states from the last decoder layer\n-        if output_hidden_states:\n-            all_hidden_states += (hidden_states,)\n-\n         return BaseModelOutputWithPast(\n             last_hidden_state=hidden_states,\n-            past_key_values=past_key_values if use_cache else None,\n-            hidden_states=all_hidden_states,\n-            attentions=all_self_attns,\n+            past_key_values=past_key_values,\n         )\n \n \n@@ -1210,8 +1168,9 @@ def get_placeholder_mask(\n             )\n             special_video_mask = special_video_mask.all(-1)\n         else:\n+            # GLM-4.1V and GLM-4.5V special_video_mask is special_image_mask\n             special_image_mask = input_ids == self.config.image_token_id\n-            special_video_mask = input_ids == self.config.video_token_id\n+            special_video_mask = input_ids == self.config.image_token_id\n \n         n_image_tokens = special_image_mask.sum()\n         special_image_mask = special_image_mask.unsqueeze(-1).expand_as(inputs_embeds).to(inputs_embeds.device)\n@@ -1238,9 +1197,6 @@ def forward(\n         position_ids: Optional[torch.LongTensor] = None,\n         past_key_values: Optional[list[torch.FloatTensor]] = None,\n         inputs_embeds: Optional[torch.FloatTensor] = None,\n-        use_cache: Optional[bool] = None,\n-        output_attentions: Optional[bool] = None,\n-        output_hidden_states: Optional[bool] = None,\n         pixel_values: Optional[torch.Tensor] = None,\n         pixel_values_videos: Optional[torch.FloatTensor] = None,\n         image_grid_thw: Optional[torch.LongTensor] = None,\n@@ -1257,12 +1213,6 @@ def forward(\n         rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n             The rope index difference between sequence length and multimodal rope.\n         \"\"\"\n-\n-        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n-        output_hidden_states = (\n-            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n-        )\n-\n         if (input_ids is None) ^ (inputs_embeds is not None):\n             raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n \n@@ -1333,10 +1283,6 @@ def forward(\n             attention_mask=attention_mask,\n             past_key_values=past_key_values,\n             inputs_embeds=inputs_embeds,\n-            use_cache=use_cache,\n-            output_attentions=output_attentions,\n-            output_hidden_states=output_hidden_states,\n-            return_dict=True,\n             cache_position=cache_position,\n             **kwargs,\n         )\n@@ -1430,10 +1376,6 @@ def forward(\n         past_key_values: Optional[list[torch.FloatTensor]] = None,\n         inputs_embeds: Optional[torch.FloatTensor] = None,\n         labels: Optional[torch.LongTensor] = None,\n-        use_cache: Optional[bool] = None,\n-        output_attentions: Optional[bool] = None,\n-        output_hidden_states: Optional[bool] = None,\n-        return_dict: Optional[bool] = None,\n         pixel_values: Optional[torch.Tensor] = None,\n         pixel_values_videos: Optional[torch.FloatTensor] = None,\n         image_grid_thw: Optional[torch.LongTensor] = None,\n@@ -1485,12 +1427,6 @@ def forward(\n         >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n         \"The image shows a street scene with a red stop sign in the foreground. In the background, there is a large red gate with Chinese characters ...\"\n         ```\"\"\"\n-\n-        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n-        output_hidden_states = (\n-            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n-        )\n-\n         outputs = self.model(\n             input_ids=input_ids,\n             pixel_values=pixel_values,\n@@ -1501,9 +1437,6 @@ def forward(\n             attention_mask=attention_mask,\n             past_key_values=past_key_values,\n             inputs_embeds=inputs_embeds,\n-            use_cache=use_cache,\n-            output_attentions=output_attentions,\n-            output_hidden_states=output_hidden_states,\n             cache_position=cache_position,\n             **kwargs,\n         )"
        },
        {
            "sha": "f831e5b78e961aa957866bbbd955790705532453",
            "filename": "src/transformers/models/glm4v/modular_glm4v.py",
            "status": "modified",
            "additions": 166,
            "deletions": 194,
            "changes": 360,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodular_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodular_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodular_glm4v.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -19,7 +19,6 @@\n import torch\n import torch.nn as nn\n import torch.nn.functional as F\n-import torch.utils.checkpoint\n from torch.nn import LayerNorm\n \n from ...activations import ACT2FN\n@@ -36,7 +35,7 @@\n from ...processing_utils import ImagesKwargs, Unpack\n from ...tokenization_utils_base import PreTokenizedInput, TextInput\n from ...utils import TransformersKwargs, auto_docstring, can_return_tuple, is_torchdynamo_compiling, logging\n-from ...utils.deprecation import deprecate_kwarg\n+from ...utils.generic import check_model_inputs\n from ...video_utils import VideoInput\n from ..glm4.modeling_glm4 import Glm4MLP, Glm4RMSNorm, eager_attention_forward\n from ..qwen2_5_vl.configuration_qwen2_5_vl import Qwen2_5_VLConfig\n@@ -136,7 +135,7 @@ def __init__(\n         patch_size=14,\n         rms_norm_eps=1e-05,\n         spatial_merge_size=2,\n-        temporal_patch_size=1,\n+        temporal_patch_size=2,\n         out_hidden_size=4096,\n         intermediate_size=13696,\n         initializer_range=0.02,\n@@ -523,120 +522,6 @@ def __init__(self, config) -> None:\n         self.mlp = Glm4VisionMlp(config, bias=False)\n \n \n-class Glm4vPreTrainedModel(Qwen2_5_VLPreTrainedModel):\n-    _no_split_modules = [\"Glm4vTextDecoderLayer\", \"Glm4vVisionBlock\"]\n-\n-\n-class Glm4vVisionModel(Glm4vPreTrainedModel):\n-    config: Glm4vVisionConfig\n-    _no_split_modules = [\"Glm4vVisionBlock\"]\n-\n-    def __init__(self, config) -> None:\n-        super().__init__(config)\n-        self.spatial_merge_size = config.spatial_merge_size\n-        self.patch_size = config.patch_size\n-\n-        self.embeddings = Glm4vVisionEmbeddings(config)\n-        self.patch_embed = Glm4vVisionPatchEmbed(config)\n-\n-        head_dim = config.hidden_size // config.num_heads\n-        self.rotary_pos_emb = Glm4vVisionRotaryEmbedding(head_dim // 2)\n-\n-        self.blocks = nn.ModuleList([Glm4vVisionBlock(config) for _ in range(config.depth)])\n-        self.merger = Glm4vVisionPatchMerger(\n-            dim=config.out_hidden_size, context_dim=config.intermediate_size, hidden_act=config.hidden_act\n-        )\n-\n-        self.post_conv_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n-        self.downsample = nn.Conv2d(\n-            in_channels=config.hidden_size,\n-            out_channels=config.out_hidden_size,\n-            kernel_size=config.spatial_merge_size,\n-            stride=config.spatial_merge_size,\n-        )\n-        self.post_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n-\n-        self.gradient_checkpointing = False\n-        self.post_init()\n-\n-    def rot_pos_emb(self, grid_thw):\n-        pos_ids = []\n-        for t, h, w in grid_thw:\n-            hpos_ids = torch.arange(h).unsqueeze(1).expand(-1, w)\n-            hpos_ids = hpos_ids.reshape(\n-                h // self.spatial_merge_size,\n-                self.spatial_merge_size,\n-                w // self.spatial_merge_size,\n-                self.spatial_merge_size,\n-            )\n-            hpos_ids = hpos_ids.permute(0, 2, 1, 3)\n-            hpos_ids = hpos_ids.flatten()\n-\n-            wpos_ids = torch.arange(w).unsqueeze(0).expand(h, -1)\n-            wpos_ids = wpos_ids.reshape(\n-                h // self.spatial_merge_size,\n-                self.spatial_merge_size,\n-                w // self.spatial_merge_size,\n-                self.spatial_merge_size,\n-            )\n-            wpos_ids = wpos_ids.permute(0, 2, 1, 3)\n-            wpos_ids = wpos_ids.flatten()\n-            pos_ids.append(torch.stack([hpos_ids, wpos_ids], dim=-1).repeat(t, 1))\n-        pos_ids = torch.cat(pos_ids, dim=0)\n-        max_grid_size = grid_thw[:, 1:].max()\n-        rotary_pos_emb_full = self.rotary_pos_emb(max_grid_size)\n-        rotary_pos_emb = rotary_pos_emb_full[pos_ids].flatten(1)\n-        return rotary_pos_emb, pos_ids\n-\n-    def forward(self, hidden_states: torch.Tensor, grid_thw: torch.Tensor) -> torch.Tensor:\n-        \"\"\"\n-        Args:\n-            hidden_states (`torch.Tensor` of shape `(seq_len, hidden_size)`):\n-                The final hidden states of the model.\n-            grid_thw (`torch.Tensor` of shape `(num_images_or_videos, 3)`):\n-                The temporal, height and width of feature shape of each image in LLM.\n-\n-        Returns:\n-            `torch.Tensor`: hidden_states.\n-        \"\"\"\n-        hidden_states = self.patch_embed(hidden_states)\n-        hidden_states = self.post_conv_layernorm(hidden_states)\n-\n-        rotary_pos_emb, image_type_ids = self.rot_pos_emb(grid_thw)\n-        emb = torch.cat((rotary_pos_emb, rotary_pos_emb), dim=-1)\n-        position_embeddings = (emb.cos(), emb.sin())\n-\n-        cu_seqlens = torch.repeat_interleave(grid_thw[:, 1] * grid_thw[:, 2], grid_thw[:, 0]).cumsum(\n-            dim=0,\n-            # Select dtype based on the following factors:\n-            #  - FA2 requires that cu_seqlens_q must have dtype int32\n-            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n-            # See https://github.com/huggingface/transformers/pull/34852 for more information\n-            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n-        )\n-        cu_seqlens = F.pad(cu_seqlens, (1, 0), value=0)\n-        seqlens = (cu_seqlens[1:] - cu_seqlens[:-1]).tolist()\n-        hidden_states = self.embeddings(hidden_states, seqlens, grid_thw, image_type_ids[:, 0], image_type_ids[:, 1])\n-\n-        for blk in self.blocks:\n-            hidden_states = blk(\n-                hidden_states,\n-                cu_seqlens=cu_seqlens,\n-                position_embeddings=position_embeddings,\n-            )\n-\n-        hidden_states = self.post_layernorm(hidden_states)\n-\n-        hidden_states = hidden_states.view(\n-            -1, self.spatial_merge_size, self.spatial_merge_size, hidden_states.shape[-1]\n-        )\n-        hidden_states = hidden_states.permute(0, 3, 1, 2)\n-        hidden_states = self.downsample(hidden_states).view(-1, self.config.out_hidden_size)\n-\n-        hidden_states = self.merger(hidden_states)\n-        return hidden_states\n-\n-\n class Glm4vTextRotaryEmbedding(Qwen2_5_VLRotaryEmbedding):\n     pass\n \n@@ -731,16 +616,13 @@ def __init__(self, config: Glm4vTextConfig, layer_idx: Optional[int] = None):\n         self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=True)\n         self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=False)\n \n-    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n     def forward(\n         self,\n         hidden_states: torch.Tensor,\n         position_embeddings: tuple[torch.Tensor, torch.Tensor],\n         attention_mask: Optional[torch.Tensor] = None,\n         position_ids: Optional[torch.LongTensor] = None,\n         past_key_values: Optional[Cache] = None,\n-        output_attentions: bool = False,\n-        use_cache: bool = False,\n         cache_position: Optional[torch.LongTensor] = None,\n         **kwargs: Unpack[FlashAttentionKwargs],\n     ) -> tuple[torch.Tensor, Optional[torch.Tensor], Optional[tuple[torch.Tensor]]]:\n@@ -780,7 +662,7 @@ def forward(\n \n         attn_output = attn_output.reshape(bsz, q_len, -1).contiguous()\n         attn_output = self.o_proj(attn_output)\n-        return attn_output, attn_weights, past_key_values\n+        return attn_output, attn_weights\n \n \n class Glm4vTextMLP(Glm4MLP):\n@@ -798,7 +680,6 @@ def __init__(self, config: Glm4vTextConfig, layer_idx: int):\n         self.post_self_attn_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n         self.post_mlp_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n \n-    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n     def forward(\n         self,\n         hidden_states: torch.Tensor,\n@@ -816,7 +697,7 @@ def forward(\n         hidden_states = self.input_layernorm(hidden_states)\n \n         # Self Attention\n-        hidden_states, self_attn_weights, present_key_value = self.self_attn(\n+        hidden_states, _ = self.self_attn(\n             hidden_states=hidden_states,\n             position_embeddings=position_embeddings,\n             attention_mask=attention_mask,\n@@ -838,19 +719,129 @@ def forward(\n         hidden_states = self.post_mlp_layernorm(hidden_states)\n         hidden_states = residual + hidden_states\n \n-        outputs = (hidden_states,)\n+        return hidden_states\n \n-        if output_attentions:\n-            outputs += (self_attn_weights,)\n \n-        if use_cache:\n-            outputs += (present_key_value,)\n+class Glm4vModelOutputWithPast(Qwen2_5_VLModelOutputWithPast):\n+    pass\n \n-        return outputs\n \n+class Glm4vPreTrainedModel(Qwen2_5_VLPreTrainedModel):\n+    _no_split_modules = [\"Glm4vTextDecoderLayer\", \"Glm4vVisionBlock\"]\n+    _can_record_outputs = {\n+        \"hidden_states\": Glm4vTextDecoderLayer,\n+        \"attentions\": Glm4vTextAttention,\n+    }\n \n-class Glm4vModelOutputWithPast(Qwen2_5_VLModelOutputWithPast):\n-    pass\n+\n+class Glm4vVisionModel(Glm4vPreTrainedModel):\n+    config: Glm4vVisionConfig\n+    _no_split_modules = [\"Glm4vVisionBlock\"]\n+\n+    def __init__(self, config) -> None:\n+        super().__init__(config)\n+        self.spatial_merge_size = config.spatial_merge_size\n+        self.patch_size = config.patch_size\n+\n+        self.embeddings = Glm4vVisionEmbeddings(config)\n+        self.patch_embed = Glm4vVisionPatchEmbed(config)\n+\n+        head_dim = config.hidden_size // config.num_heads\n+        self.rotary_pos_emb = Glm4vVisionRotaryEmbedding(head_dim // 2)\n+\n+        self.blocks = nn.ModuleList([Glm4vVisionBlock(config) for _ in range(config.depth)])\n+        self.merger = Glm4vVisionPatchMerger(\n+            dim=config.out_hidden_size, context_dim=config.intermediate_size, hidden_act=config.hidden_act\n+        )\n+\n+        self.post_conv_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.downsample = nn.Conv2d(\n+            in_channels=config.hidden_size,\n+            out_channels=config.out_hidden_size,\n+            kernel_size=config.spatial_merge_size,\n+            stride=config.spatial_merge_size,\n+        )\n+        self.post_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+        self.gradient_checkpointing = False\n+        self.post_init()\n+\n+    def rot_pos_emb(self, grid_thw):\n+        pos_ids = []\n+        for t, h, w in grid_thw:\n+            hpos_ids = torch.arange(h).unsqueeze(1).expand(-1, w)\n+            hpos_ids = hpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            hpos_ids = hpos_ids.permute(0, 2, 1, 3)\n+            hpos_ids = hpos_ids.flatten()\n+\n+            wpos_ids = torch.arange(w).unsqueeze(0).expand(h, -1)\n+            wpos_ids = wpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            wpos_ids = wpos_ids.permute(0, 2, 1, 3)\n+            wpos_ids = wpos_ids.flatten()\n+            pos_ids.append(torch.stack([hpos_ids, wpos_ids], dim=-1).repeat(t, 1))\n+        pos_ids = torch.cat(pos_ids, dim=0)\n+        max_grid_size = grid_thw[:, 1:].max()\n+        rotary_pos_emb_full = self.rotary_pos_emb(max_grid_size)\n+        rotary_pos_emb = rotary_pos_emb_full[pos_ids].flatten(1)\n+        return rotary_pos_emb, pos_ids\n+\n+    def forward(self, hidden_states: torch.Tensor, grid_thw: torch.Tensor) -> torch.Tensor:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.Tensor` of shape `(seq_len, hidden_size)`):\n+                The final hidden states of the model.\n+            grid_thw (`torch.Tensor` of shape `(num_images_or_videos, 3)`):\n+                The temporal, height and width of feature shape of each image in LLM.\n+\n+        Returns:\n+            `torch.Tensor`: hidden_states.\n+        \"\"\"\n+        hidden_states = self.patch_embed(hidden_states)\n+        hidden_states = self.post_conv_layernorm(hidden_states)\n+\n+        rotary_pos_emb, image_type_ids = self.rot_pos_emb(grid_thw)\n+        emb = torch.cat((rotary_pos_emb, rotary_pos_emb), dim=-1)\n+        position_embeddings = (emb.cos(), emb.sin())\n+\n+        cu_seqlens = torch.repeat_interleave(grid_thw[:, 1] * grid_thw[:, 2], grid_thw[:, 0]).cumsum(\n+            dim=0,\n+            # Select dtype based on the following factors:\n+            #  - FA2 requires that cu_seqlens_q must have dtype int32\n+            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n+            # See https://github.com/huggingface/transformers/pull/34852 for more information\n+            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_seqlens = F.pad(cu_seqlens, (1, 0), value=0)\n+        seqlens = (cu_seqlens[1:] - cu_seqlens[:-1]).tolist()\n+        hidden_states = self.embeddings(hidden_states, seqlens, grid_thw, image_type_ids[:, 0], image_type_ids[:, 1])\n+\n+        for blk in self.blocks:\n+            hidden_states = blk(\n+                hidden_states,\n+                cu_seqlens=cu_seqlens,\n+                position_embeddings=position_embeddings,\n+            )\n+\n+        hidden_states = self.post_layernorm(hidden_states)\n+\n+        hidden_states = hidden_states.view(\n+            -1, self.spatial_merge_size, self.spatial_merge_size, hidden_states.shape[-1]\n+        )\n+        hidden_states = hidden_states.permute(0, 3, 1, 2)\n+        hidden_states = self.downsample(hidden_states).view(-1, self.config.out_hidden_size)\n+\n+        hidden_states = self.merger(hidden_states)\n+        return hidden_states\n \n \n class Glm4vTextModel(Qwen2_5_VLTextModel):\n@@ -865,7 +856,7 @@ def __init__(self, config: Glm4vTextConfig):\n         del self.has_sliding_layers\n \n     @auto_docstring\n-    @can_return_tuple\n+    @check_model_inputs\n     def forward(\n         self,\n         input_ids: Optional[torch.LongTensor] = None,\n@@ -874,27 +865,12 @@ def forward(\n         past_key_values: Optional[list[torch.FloatTensor]] = None,\n         inputs_embeds: Optional[torch.FloatTensor] = None,\n         use_cache: Optional[bool] = None,\n-        output_attentions: Optional[bool] = None,\n-        output_hidden_states: Optional[bool] = None,\n         cache_position: Optional[torch.LongTensor] = None,\n         **kwargs: Unpack[FlashAttentionKwargs],\n     ) -> Union[tuple, BaseModelOutputWithPast]:\n-        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n-        output_hidden_states = (\n-            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n-        )\n-        use_cache = use_cache if use_cache is not None else self.config.use_cache\n-\n         if (input_ids is None) ^ (inputs_embeds is not None):\n             raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n \n-        if self.gradient_checkpointing and self.training:\n-            if use_cache:\n-                logger.warning_once(\n-                    \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n-                )\n-                use_cache = False\n-\n         # torch.jit.trace() doesn't support cache objects in the output\n         if use_cache and past_key_values is None and not torch.jit.is_tracing():\n             past_key_values = DynamicCache()\n@@ -928,42 +904,23 @@ def forward(\n         # create position embeddings to be shared across the decoder layers\n         position_embeddings = self.rotary_emb(hidden_states, position_ids)\n \n-        # decoder layers\n-        all_hidden_states = () if output_hidden_states else None\n-        all_self_attns = () if output_attentions else None\n-\n         for decoder_layer in self.layers:\n-            if output_hidden_states:\n-                all_hidden_states += (hidden_states,)\n-\n             layer_outputs = decoder_layer(\n                 hidden_states,\n                 position_embeddings=position_embeddings,\n                 attention_mask=causal_mask,\n                 position_ids=position_ids,\n                 past_key_values=past_key_values,\n-                output_attentions=output_attentions,\n-                use_cache=use_cache,\n                 cache_position=cache_position,\n                 **kwargs,\n             )\n-\n-            hidden_states = layer_outputs[0]\n-\n-            if output_attentions:\n-                all_self_attns += (layer_outputs[1],)\n+            hidden_states = layer_outputs\n \n         hidden_states = self.norm(hidden_states)\n \n-        # add hidden states from the last decoder layer\n-        if output_hidden_states:\n-            all_hidden_states += (hidden_states,)\n-\n         return BaseModelOutputWithPast(\n             last_hidden_state=hidden_states,\n-            past_key_values=past_key_values if use_cache else None,\n-            hidden_states=all_hidden_states,\n-            attentions=all_self_attns,\n+            past_key_values=past_key_values,\n         )\n \n \n@@ -1189,6 +1146,47 @@ def get_video_features(\n         video_embeds = torch.split(video_embeds, split_sizes)\n         return video_embeds\n \n+    def get_placeholder_mask(\n+        self,\n+        input_ids: torch.LongTensor,\n+        inputs_embeds: torch.FloatTensor,\n+        image_features: torch.FloatTensor = None,\n+        video_features: torch.FloatTensor = None,\n+    ):\n+        \"\"\"\n+        Obtains multimodal placeholdr mask from `input_ids` or `inputs_embeds`, and checks that the placeholder token count is\n+        equal to the length of multimodal features. If the lengths are different, an error is raised.\n+        \"\"\"\n+        if input_ids is None:\n+            special_image_mask = inputs_embeds == self.get_input_embeddings()(\n+                torch.tensor(self.config.image_token_id, dtype=torch.long, device=inputs_embeds.device)\n+            )\n+            special_image_mask = special_image_mask.all(-1)\n+            special_video_mask = inputs_embeds == self.get_input_embeddings()(\n+                torch.tensor(self.config.video_token_id, dtype=torch.long, device=inputs_embeds.device)\n+            )\n+            special_video_mask = special_video_mask.all(-1)\n+        else:\n+            # GLM-4.1V and GLM-4.5V special_video_mask is special_image_mask\n+            special_image_mask = input_ids == self.config.image_token_id\n+            special_video_mask = input_ids == self.config.image_token_id\n+\n+        n_image_tokens = special_image_mask.sum()\n+        special_image_mask = special_image_mask.unsqueeze(-1).expand_as(inputs_embeds).to(inputs_embeds.device)\n+        if image_features is not None and inputs_embeds[special_image_mask].numel() != image_features.numel():\n+            raise ValueError(\n+                f\"Image features and image tokens do not match: tokens: {n_image_tokens}, features {image_features.shape[0]}\"\n+            )\n+\n+        n_video_tokens = special_video_mask.sum()\n+        special_video_mask = special_video_mask.unsqueeze(-1).expand_as(inputs_embeds).to(inputs_embeds.device)\n+        if video_features is not None and inputs_embeds[special_video_mask].numel() != video_features.numel():\n+            raise ValueError(\n+                f\"Videos features and video tokens do not match: tokens: {n_video_tokens}, features {video_features.shape[0]}\"\n+            )\n+\n+        return special_image_mask, special_video_mask\n+\n     @auto_docstring\n     @can_return_tuple\n     def forward(\n@@ -1198,9 +1196,6 @@ def forward(\n         position_ids: Optional[torch.LongTensor] = None,\n         past_key_values: Optional[list[torch.FloatTensor]] = None,\n         inputs_embeds: Optional[torch.FloatTensor] = None,\n-        use_cache: Optional[bool] = None,\n-        output_attentions: Optional[bool] = None,\n-        output_hidden_states: Optional[bool] = None,\n         pixel_values: Optional[torch.Tensor] = None,\n         pixel_values_videos: Optional[torch.FloatTensor] = None,\n         image_grid_thw: Optional[torch.LongTensor] = None,\n@@ -1217,12 +1212,6 @@ def forward(\n         rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n             The rope index difference between sequence length and multimodal rope.\n         \"\"\"\n-\n-        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n-        output_hidden_states = (\n-            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n-        )\n-\n         if (input_ids is None) ^ (inputs_embeds is not None):\n             raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n \n@@ -1293,10 +1282,6 @@ def forward(\n             attention_mask=attention_mask,\n             past_key_values=past_key_values,\n             inputs_embeds=inputs_embeds,\n-            use_cache=use_cache,\n-            output_attentions=output_attentions,\n-            output_hidden_states=output_hidden_states,\n-            return_dict=True,\n             cache_position=cache_position,\n             **kwargs,\n         )\n@@ -1325,10 +1310,6 @@ def forward(\n         past_key_values: Optional[list[torch.FloatTensor]] = None,\n         inputs_embeds: Optional[torch.FloatTensor] = None,\n         labels: Optional[torch.LongTensor] = None,\n-        use_cache: Optional[bool] = None,\n-        output_attentions: Optional[bool] = None,\n-        output_hidden_states: Optional[bool] = None,\n-        return_dict: Optional[bool] = None,\n         pixel_values: Optional[torch.Tensor] = None,\n         pixel_values_videos: Optional[torch.FloatTensor] = None,\n         image_grid_thw: Optional[torch.LongTensor] = None,\n@@ -1380,12 +1361,6 @@ def forward(\n         >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n         \"The image shows a street scene with a red stop sign in the foreground. In the background, there is a large red gate with Chinese characters ...\"\n         ```\"\"\"\n-\n-        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n-        output_hidden_states = (\n-            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n-        )\n-\n         outputs = self.model(\n             input_ids=input_ids,\n             pixel_values=pixel_values,\n@@ -1396,9 +1371,6 @@ def forward(\n             attention_mask=attention_mask,\n             past_key_values=past_key_values,\n             inputs_embeds=inputs_embeds,\n-            use_cache=use_cache,\n-            output_attentions=output_attentions,\n-            output_hidden_states=output_hidden_states,\n             cache_position=cache_position,\n             **kwargs,\n         )"
        },
        {
            "sha": "f99578a4be721ecdc5bcbd157fe75f8f16384086",
            "filename": "src/transformers/models/glm4v_moe/__init__.py",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2F__init__.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -0,0 +1,27 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_glm4v_moe import *\n+    from .modeling_glm4v_moe import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "81c3bcfd2c1d2d2093483133eba5df2e71865185",
            "filename": "src/transformers/models/glm4v_moe/configuration_glm4v_moe.py",
            "status": "added",
            "additions": 388,
            "deletions": 0,
            "changes": 388,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fconfiguration_glm4v_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fconfiguration_glm4v_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fconfiguration_glm4v_moe.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -0,0 +1,388 @@\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+#           This file was automatically generated from src/transformers/models/glm4v_moe/modular_glm4v_moe.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_glm4v_moe.py file directly. One of our CI enforces this.\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+# coding=utf-8\n+# Copyright 2025 The ZhipuAI Inc. team and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from ...configuration_utils import PretrainedConfig\n+from ...modeling_rope_utils import rope_config_validation\n+\n+\n+class Glm4vMoeVisionConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vMoeVisionModel`]. It is used to instantiate an Glm4vMoeVisionModel\n+    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield\n+    a similar configuration to that of\n+    GLM-4.1V-9B-Thinking [THUDM/GLM-4.1V-9B-Thinking](https://huggingface.co/THUDM/GLM-4.1V-9B-Thinking).\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 1536):\n+            Dimensionality of the encoder layers and the pooler layer.\n+        depth (`int`, *optional*, defaults to 24):\n+            Number of layers (depth) in the model.\n+        attention_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to add a bias to the queries, keys and values.\n+        intermediate_size (`int`, *optional*, defaults to 13696):\n+            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"selu\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+            `\"relu\"`, `\"selu\"` and `\"gelu_new\"` are supported.\n+        hidden_dropout_prob (`float`, *optional*, defaults to 0.0):\n+            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            Dropout probability for attention weights.\n+        projection_dropout (`float`, *optional*, defaults to 0.0):\n+            Dropout probability for the projection layer.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        image_size (`int` or `list[int]`, *optional*, defaults to `[336, 336]`):\n+            The size (resolution) of each image.\n+        patch_size (`int`, *optional*, defaults to `14`):\n+            The size (resolution) of each patch.\n+        num_channels (`int`, *optional*, defaults to 3):\n+            The number of input channels.\n+        out_hidden_size (`int`, *optional*, defaults to 4096):\n+            The output hidden size of the vision model.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        spatial_merge_size (`int`, *optional*, defaults to 2):\n+            The size used for merging spatial dimensions.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The size used for patches along the temporal dimension.\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Glm4vMoeVisionConfig, Glm4vMoeVisionModel\n+\n+    >>> # Initializing a Glm4vMoeVisionConfig GLM-4.1V-9B style configuration\n+    >>> configuration = Glm4vMoeVisionConfig()\n+\n+    >>> # Initializing a model (with random weights) from the GLM-4.1V-9B configuration\n+    >>> model = Glm4vMoeVisionModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"glm4v_moe\"\n+    base_config_key = \"vision_config\"\n+\n+    def __init__(\n+        self,\n+        depth=24,\n+        hidden_size=1536,\n+        hidden_act=\"silu\",\n+        attention_bias=False,\n+        attention_dropout=0.0,\n+        num_heads=12,\n+        in_channels=3,\n+        image_size=336,\n+        patch_size=14,\n+        rms_norm_eps=1e-05,\n+        spatial_merge_size=2,\n+        temporal_patch_size=2,\n+        out_hidden_size=4096,\n+        intermediate_size=13696,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.depth = depth\n+        self.hidden_size = hidden_size\n+        self.hidden_act = hidden_act\n+        self.num_heads = num_heads\n+        self.in_channels = in_channels\n+        self.image_size = image_size\n+        self.patch_size = patch_size\n+        self.spatial_merge_size = spatial_merge_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.out_hidden_size = out_hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+\n+\n+class Glm4vMoeTextConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vMoeModel`]. It is used to instantiate a\n+    GLM-4.5V model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of\n+    GLM-4.5V [THUDM/GLM-4.5V](https://huggingface.co/THUDM/GLM-4.5V).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 151424):\n+            Vocabulary size of the Glm4vMoe model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Glm4vMoeModel`]\n+        hidden_size (`int`, *optional*, defaults to 4096):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 10944):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 46):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 96):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        partial_rotary_factor (`float`, *optional*, defaults to 0.5): The factor of the partial rotary position.\n+        num_key_value_heads (`int`, *optional*, defaults to 8):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `32`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 65536):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n+                    'llama3'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n+                    pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n+                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n+                    `factor` field to infer the suggested value.\n+        attention_bias (`bool`, defaults to `True`, *optional*, defaults to `True`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        moe_intermediate_size (`int`, *optional*, defaults to 1408):\n+            Intermediate size of the routed expert.\n+        num_experts_per_tok (`int`, *optional*, defaults to 8):\n+            number of experts per token.\n+        n_shared_experts (`int`, *optional*, defaults to 1):\n+            Number of shared experts.\n+        n_routed_experts (`int`, *optional*, defaults to 128):\n+            Number of routed experts.\n+        routed_scaling_factor (`float`, *optional*, defaults to 1.0):\n+            Scaling factor or routed experts.\n+        n_group (`int`, *optional*, defaults to 1):\n+            Number of groups for routed experts.\n+        topk_group (`int`, *optional*, defaults to 1):\n+            Number of selected groups for each token(for each token, ensuring the selected experts is only within `topk_group` groups).\n+        first_k_dense_replace (`int`, *optional*, defaults to 1):\n+            Number of dense layers in shallow layers(embed->dense->dense->...->dense->moe->moe...->lm_head).\n+                                                                    \\--k dense layers--/\n+        norm_topk_prob (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the topk probabilities.\n+\n+    ```python\n+    >>> from transformers import Glm4vMoeTextModel, Glm4vMoeConfig\n+\n+    >>> # Initializing a GLM-4.5V style configuration\n+    >>> configuration = Glm4vMoeConfig()\n+\n+    >>> # Initializing a model from the GLM-4.5V style configuration\n+    >>> model = Glm4vMoeTextModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"Glm4vMoe_text\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    # Default tensor parallel plan for base model `Glm4vMoe`\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_up_proj\": \"colwise_rep\",  # we need to replicate here due to the `chunk` operation\n+        \"layers.*.mlp.down_proj\": \"rowwise_rep\",  # we need to replicate here due to the `chunk` operation\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+    base_config_key = \"text_config\"\n+\n+    def __init__(\n+        self,\n+        vocab_size=151424,\n+        hidden_size=4096,\n+        intermediate_size=10944,\n+        num_hidden_layers=46,\n+        num_attention_heads=96,\n+        partial_rotary_factor=0.5,\n+        num_key_value_heads=8,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=65536,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-5,\n+        use_cache=True,\n+        tie_word_embeddings=False,\n+        rope_theta=10000.0,\n+        rope_scaling=None,\n+        attention_bias=True,\n+        attention_dropout=0.0,\n+        moe_intermediate_size=1408,\n+        num_experts_per_tok=8,\n+        n_shared_experts=1,\n+        n_routed_experts=128,\n+        routed_scaling_factor=1.0,\n+        n_group=1,\n+        topk_group=1,\n+        first_k_dense_replace=1,\n+        norm_topk_prob=True,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.partial_rotary_factor = partial_rotary_factor\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, move it to 'rope_type'.\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self, ignore_keys={\"mrope_section\"})\n+\n+        # MoE arguments\n+        self.moe_intermediate_size = moe_intermediate_size\n+        self.num_experts_per_tok = num_experts_per_tok\n+        self.n_group = n_group\n+        self.topk_group = topk_group\n+        self.n_shared_experts = n_shared_experts\n+        self.n_routed_experts = n_routed_experts\n+        self.routed_scaling_factor = routed_scaling_factor\n+        self.first_k_dense_replace = first_k_dense_replace\n+        self.norm_topk_prob = norm_topk_prob\n+\n+\n+class Glm4vMoeConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vMoeModel`]. It is used to instantiate a\n+    GLM-4.5V model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of\n+    GLM-4.5V [zai_org/GLM-4.5V](https://huggingface.co/zai_org/GLM-4.5V).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        text_config (`Union[PreTrainedConfig, dict]`, *optional*, defaults to `Glm4vMoeTextConfig`):\n+            The config object or dictionary of the text backbone.\n+        vision_config (`Union[PreTrainedConfig, dict]`,  *optional*, defaults to `Glm4vMoeVisionConfig`):\n+            The config object or dictionary of the vision backbone.\n+        image_token_id (`int`, *optional*, defaults to 151363):\n+            The image token index to encode the image prompt.\n+        video_token_id (`int`, *optional*, defaults to 151364):\n+            The video token index to encode the image prompt.\n+        image_start_token_id (`int`, *optional*, defaults to 151339):\n+            The image start token index to encode the start of image.\n+        image_end_token_id (`int`, *optional*, defaults to 151340):\n+            The image end token index to encode the end of image.\n+        video_start_token_id (`int`, *optional*, defaults to 151341):\n+            The video start token index to encode the start of video.\n+        video_end_token_id (`int`, *optional*, defaults to 151342):\n+            The video end token index to encode the end of video.\n+\n+    ```python\n+    >>> from transformers import Glm4vMoeForConditionalGeneration, Glm4vMoeConfig\n+\n+    >>> # Initializing a GLM-4.5V style configuration\n+    >>> configuration = Glm4vMoeConfig()\n+\n+    >>> # Initializing a model from the GLM-4.5V style configuration\n+    >>> model = Glm4vMoeForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"glm4v_moe\"\n+    sub_configs = {\"vision_config\": Glm4vMoeVisionConfig, \"text_config\": Glm4vMoeTextConfig}\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        text_config=None,\n+        vision_config=None,\n+        image_token_id=151363,\n+        video_token_id=151364,\n+        image_start_token_id=151339,\n+        image_end_token_id=151340,\n+        video_start_token_id=151341,\n+        video_end_token_id=151342,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        if isinstance(vision_config, dict):\n+            self.vision_config = self.sub_configs[\"vision_config\"](**vision_config)\n+        elif vision_config is None:\n+            self.vision_config = self.sub_configs[\"vision_config\"]()\n+\n+        if isinstance(text_config, dict):\n+            self.text_config = self.sub_configs[\"text_config\"](**text_config)\n+        elif text_config is None:\n+            # For BC use all kwargs to init `TextConfig`\n+            self.text_config = self.sub_configs[\"text_config\"](**kwargs)\n+\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.video_start_token_id = video_start_token_id\n+        self.video_end_token_id = video_end_token_id\n+        self.image_start_token_id = image_start_token_id\n+        self.image_end_token_id = image_end_token_id\n+\n+\n+__all__ = [\"Glm4vMoeConfig\", \"Glm4vMoeTextConfig\"]"
        },
        {
            "sha": "06a39513239e1acfea7b28187594adc5410839e9",
            "filename": "src/transformers/models/glm4v_moe/modeling_glm4v_moe.py",
            "status": "added",
            "additions": 1769,
            "deletions": 0,
            "changes": 1769,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodeling_glm4v_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodeling_glm4v_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodeling_glm4v_moe.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -0,0 +1,1769 @@\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+#           This file was automatically generated from src/transformers/models/glm4v_moe/modular_glm4v_moe.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_glm4v_moe.py file directly. One of our CI enforces this.\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+# coding=utf-8\n+# Copyright 2025 The ZhipuAI Inc. team and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import itertools\n+from dataclasses import dataclass\n+from typing import Any, Callable, Optional, Union\n+\n+import torch\n+import torch.nn as nn\n+import torch.nn.functional as F\n+from torch.nn import LayerNorm\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...integrations import use_kernel_forward_from_hub\n+from ...masking_utils import create_causal_mask\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import BaseModelOutputWithPast, ModelOutput\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS, dynamic_rope_update\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring, can_return_tuple, is_torchdynamo_compiling, logging\n+from ...utils.deprecation import deprecate_kwarg\n+from ...utils.generic import check_model_inputs\n+from .configuration_glm4v_moe import Glm4vMoeConfig, Glm4vMoeTextConfig, Glm4vMoeVisionConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+@use_kernel_forward_from_hub(\"RMSNorm\")\n+class Glm4vMoeRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        Glm4vMoeRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs: Unpack[TransformersKwargs],\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+def apply_multimodal_rotary_pos_emb(q, k, cos, sin, mrope_section, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding with Multimodal Sections to the query and key tensors (https://qwenlm.github.io/blog/qwen2-vl/).\n+\n+    Explanation:\n+        Multimodal 3D rotary position embedding is an extension to 1D rotary position embedding. The input embedding\n+        sequence contains vision (images / videos) embedding and text embedding or just contains text embedding. For\n+        vision embedding part, we apply rotary position embedding on temporal, height and width dimension separately.\n+        Here we split the channel dimension to 3 chunks for the temporal, height and width rotary position embedding.\n+        For text embedding part, we just apply 1D rotary position embedding. The three rotary position index (temporal,\n+        height and width) of text embedding is always the same, so the text embedding rotary position embedding has no\n+        difference with modern LLMs.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        mrope_section(`List(int)`):\n+            Multimodal rope section is for channel dimension of temporal, height and width in rope calculation.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    mrope_section = mrope_section * 2\n+    cos = torch.cat([m[i % 3] for i, m in enumerate(cos.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+    sin = torch.cat([m[i % 3] for i, m in enumerate(sin.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+\n+    # Keep half or full tensor for later concatenation\n+    rotary_dim = cos.shape[-1]\n+    q_rot, q_pass = q[..., :rotary_dim], q[..., rotary_dim:]\n+    k_rot, k_pass = k[..., :rotary_dim], k[..., rotary_dim:]\n+\n+    # Apply rotary embeddings on the first half or full tensor\n+    q_embed = (q_rot * cos) + (rotate_half(q_rot) * sin)\n+    k_embed = (k_rot * cos) + (rotate_half(k_rot) * sin)\n+\n+    # Concatenate back to full shape\n+    q_embed = torch.cat([q_embed, q_pass], dim=-1)\n+    k_embed = torch.cat([k_embed, k_pass], dim=-1)\n+\n+    return q_embed, k_embed\n+\n+\n+class Glm4vMoeTextAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: Glm4vMoeTextConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.head_dim = getattr(config, \"head_dim\", config.hidden_size // config.num_attention_heads)\n+        self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.attention_dropout = config.attention_dropout\n+        self.is_causal = True\n+\n+        self.q_proj = nn.Linear(\n+            config.hidden_size, config.num_attention_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.k_proj = nn.Linear(\n+            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.v_proj = nn.Linear(\n+            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.o_proj = nn.Linear(config.num_attention_heads * self.head_dim, config.hidden_size, bias=False)\n+        self.rope_scaling = config.rope_scaling\n+\n+    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_values: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor], Optional[tuple[torch.Tensor]]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape)\n+\n+        query_states = query_states.transpose(1, 2)\n+        key_states = key_states.transpose(1, 2)\n+        value_states = value_states.transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_multimodal_rotary_pos_emb(  # diff with Llama\n+            query_states, key_states, cos, sin, self.rope_scaling[\"mrope_section\"]\n+        )\n+\n+        if past_key_values is not None:\n+            # sin and cos are specific to RoPE models; position_ids needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_values.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class Glm4vMoeTextTopkRouter(nn.Module):\n+    def __init__(self, config: Glm4vMoeTextConfig):\n+        super().__init__()\n+        self.config = config\n+        self.top_k = config.num_experts_per_tok\n+        self.n_routed_experts = config.n_routed_experts\n+        self.routed_scaling_factor = config.routed_scaling_factor\n+        self.n_group = config.n_group\n+        self.topk_group = config.topk_group\n+        self.norm_topk_prob = config.norm_topk_prob\n+\n+        self.weight = nn.Parameter(torch.empty((self.n_routed_experts, config.hidden_size)))\n+        self.register_buffer(\"e_score_correction_bias\", torch.zeros((self.n_routed_experts), dtype=torch.float32))\n+\n+    @torch.no_grad()\n+    def get_topk_indices(self, scores):\n+        scores_for_choice = scores.view(-1, self.n_routed_experts) + self.e_score_correction_bias.unsqueeze(0)\n+        group_scores = (\n+            scores_for_choice.view(-1, self.n_group, self.n_routed_experts // self.n_group)\n+            .topk(2, dim=-1)[0]\n+            .sum(dim=-1)\n+        )\n+        group_idx = torch.topk(group_scores, k=self.topk_group, dim=-1, sorted=False)[1]\n+        group_mask = torch.zeros_like(group_scores)\n+        group_mask.scatter_(1, group_idx, 1)\n+        score_mask = (\n+            group_mask.unsqueeze(-1)\n+            .expand(-1, self.n_group, self.n_routed_experts // self.n_group)\n+            .reshape(-1, self.n_routed_experts)\n+        )\n+        scores_for_choice = scores_for_choice.masked_fill(~score_mask.bool(), 0.0)\n+        topk_indices = torch.topk(scores_for_choice, k=self.top_k, dim=-1, sorted=False)[1]\n+        return topk_indices\n+\n+    def forward(self, hidden_states):\n+        hidden_states = hidden_states.view(-1, self.config.hidden_size)\n+        router_logits = F.linear(hidden_states.type(torch.float32), self.weight.type(torch.float32))\n+        scores = router_logits.sigmoid()\n+        topk_indices = self.get_topk_indices(scores)\n+        topk_weights = scores.gather(1, topk_indices)\n+        if self.norm_topk_prob:\n+            denominator = topk_weights.sum(dim=-1, keepdim=True) + 1e-20\n+            topk_weights /= denominator\n+        topk_weights = topk_weights * self.routed_scaling_factor\n+        return topk_indices, topk_weights\n+\n+\n+class Glm4vMoeTextMoE(nn.Module):\n+    \"\"\"\n+    A mixed expert module containing shared experts.\n+    \"\"\"\n+\n+    def __init__(self, config: Glm4vMoeTextConfig):\n+        super().__init__()\n+        self.config = config\n+        self.experts = nn.ModuleList(\n+            [\n+                Glm4vMoeTextMLP(config, intermediate_size=config.moe_intermediate_size)\n+                for _ in range(config.n_routed_experts)\n+            ]\n+        )\n+        self.gate = Glm4vMoeTextTopkRouter(config)\n+        self.shared_experts = Glm4vMoeTextMLP(\n+            config=config, intermediate_size=config.moe_intermediate_size * config.n_shared_experts\n+        )\n+\n+    def moe(self, hidden_states: torch.Tensor, topk_indices: torch.Tensor, topk_weights: torch.Tensor):\n+        r\"\"\"\n+        CALL FOR CONTRIBUTION! I don't have time to optimise this right now, but expert weights need to be fused\n+        to not have to do a loop here (deepseek has 256 experts soooo yeah).\n+        \"\"\"\n+        final_hidden_states = torch.zeros_like(hidden_states, dtype=topk_weights.dtype)\n+        expert_mask = torch.nn.functional.one_hot(topk_indices, num_classes=len(self.experts))\n+        expert_mask = expert_mask.permute(2, 0, 1)\n+\n+        for expert_idx in range(len(self.experts)):\n+            expert = self.experts[expert_idx]\n+            mask = expert_mask[expert_idx]\n+            token_indices, weight_indices = torch.where(mask)\n+\n+            if token_indices.numel() > 0:\n+                expert_weights = topk_weights[token_indices, weight_indices]\n+                expert_input = hidden_states[token_indices]\n+                expert_output = expert(expert_input)\n+                weighted_output = expert_output * expert_weights.unsqueeze(-1)\n+                final_hidden_states.index_add_(0, token_indices, weighted_output)\n+\n+        # in original deepseek, the output of the experts are gathered once we leave this module\n+        # thus the moe module is itelsf an IsolatedParallel module\n+        # and all expert are \"local\" meaning we shard but we don't gather\n+        return final_hidden_states.type(hidden_states.dtype)\n+\n+    def forward(self, hidden_states):\n+        residuals = hidden_states\n+        orig_shape = hidden_states.shape\n+        topk_indices, topk_weights = self.gate(hidden_states)\n+        hidden_states = hidden_states.view(-1, hidden_states.shape[-1])\n+        hidden_states = self.moe(hidden_states, topk_indices, topk_weights).view(*orig_shape)\n+        hidden_states = hidden_states + self.shared_experts(residuals)\n+        return hidden_states\n+\n+\n+class Glm4vMoeTextMLP(nn.Module):\n+    def __init__(self, config, hidden_size=None, intermediate_size=None):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size if hidden_size is None else hidden_size\n+        self.intermediate_size = config.intermediate_size if intermediate_size is None else intermediate_size\n+\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=False)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, x):\n+        down_proj = self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x))\n+        return down_proj\n+\n+\n+@use_kernel_forward_from_hub(\"RMSNorm\")\n+class Glm4vMoeTextRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        Glm4vMoeTextRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class Glm4vMoeTextDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: Glm4vMoeTextConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        self.self_attn = Glm4vMoeTextAttention(config=config, layer_idx=layer_idx)\n+\n+        if layer_idx >= config.first_k_dense_replace:\n+            self.mlp = Glm4vMoeTextMoE(config)\n+        else:\n+            self.mlp = Glm4vMoeTextMLP(config)\n+\n+        self.input_layernorm = Glm4vMoeTextRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = Glm4vMoeTextRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,  # necessary, but kept here for BC\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> torch.Tensor:\n+        residual = hidden_states\n+        hidden_states = self.input_layernorm(hidden_states)\n+        # Self Attention\n+        hidden_states, _ = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class Glm4vMoePreTrainedModel(PreTrainedModel):\n+    config: Glm4vMoeConfig\n+    base_model_prefix = \"\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"Glm4vMoeTextDecoderLayer\", \"Glm4vMoeVisionBlock\"]\n+    _skip_keys_device_placement = \"past_key_values\"\n+    _supports_flash_attn = True\n+    _supports_sdpa = True\n+    _supports_flex_attn = True\n+    _can_compile_fullgraph = False\n+    _supports_attention_backend = True\n+\n+    _can_record_outputs = {\n+        \"hidden_states\": Glm4vMoeTextDecoderLayer,\n+        \"attentions\": Glm4vMoeTextAttention,\n+    }\n+\n+    def _init_weights(self, module):\n+        super()._init_weights(module)\n+        if isinstance(module, Glm4vMoeTextTopkRouter):\n+            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n+\n+\n+class Glm4vMoeisionMlp(nn.Module):\n+    def __init__(self, config, bias: bool = False):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.out_hidden_size\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=bias)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=bias)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=bias)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, hidden_state):\n+        return self.down_proj(self.act_fn(self.gate_proj(hidden_state)) * self.up_proj(hidden_state))\n+\n+\n+class Glm4vMoeVisionPatchEmbed(nn.Module):\n+    def __init__(self, config: Glm4vMoeVisionConfig) -> None:\n+        super().__init__()\n+        self.patch_size = config.patch_size\n+        self.temporal_patch_size = config.temporal_patch_size\n+        self.in_channels = config.in_channels\n+        self.embed_dim = config.hidden_size\n+\n+        kernel_size = [self.temporal_patch_size, self.patch_size, self.patch_size]\n+        self.proj = nn.Conv3d(self.in_channels, self.embed_dim, kernel_size=kernel_size, stride=kernel_size)\n+\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        target_dtype = self.proj.weight.dtype\n+        hidden_states = hidden_states.view(\n+            -1, self.in_channels, self.temporal_patch_size, self.patch_size, self.patch_size\n+        )\n+        hidden_states = self.proj(hidden_states.to(dtype=target_dtype)).view(-1, self.embed_dim)\n+        return hidden_states\n+\n+\n+class Glm4vMoeVisionRotaryEmbedding(nn.Module):\n+    inv_freq: torch.Tensor  # fix linting for `register_buffer`\n+\n+    def __init__(self, dim: int, theta: float = 10000.0) -> None:\n+        super().__init__()\n+        inv_freq = 1.0 / (theta ** (torch.arange(0, dim, 2, dtype=torch.float) / dim))\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+\n+    def forward(self, seqlen: int) -> torch.Tensor:\n+        seq = torch.arange(seqlen, device=self.inv_freq.device, dtype=self.inv_freq.dtype)\n+        freqs = torch.outer(seq, self.inv_freq)\n+        return freqs\n+\n+\n+class Glm4vMoeVisionPatchMerger(nn.Module):\n+    def __init__(self, dim: int, context_dim: int, hidden_act: str, bias: bool = False) -> None:\n+        super().__init__()\n+        self.proj = nn.Linear(dim, dim, bias=bias)\n+        self.post_projection_norm = LayerNorm(dim)\n+        self.gate_proj = nn.Linear(dim, context_dim, bias=bias)\n+        self.up_proj = nn.Linear(dim, context_dim, bias=bias)\n+        self.down_proj = nn.Linear(context_dim, dim, bias=bias)\n+        self.act1 = nn.GELU()\n+        self.act_fn = ACT2FN[hidden_act]\n+\n+    def forward(self, hidden_state: torch.Tensor) -> torch.Tensor:\n+        hidden_state = self.proj(hidden_state)\n+        hidden_state = self.act1(self.post_projection_norm(hidden_state))\n+        return self.down_proj(self.act_fn(self.gate_proj(hidden_state)) * self.up_proj(hidden_state))\n+\n+\n+class Glm4vMoeVisionEmbeddings(nn.Module):\n+    def __init__(self, config: Glm4vMoeVisionConfig):\n+        super().__init__()\n+        self.config = config\n+        self.embed_dim = config.hidden_size\n+        self.image_size = config.image_size\n+        self.patch_size = config.patch_size\n+\n+        self.num_patches = (self.image_size // self.patch_size) ** 2\n+        self.num_positions = self.num_patches\n+        self.position_embedding = nn.Embedding(self.num_positions, self.embed_dim)\n+        self.register_buffer(\"position_ids\", torch.arange(self.num_positions).expand((1, -1)), persistent=False)\n+\n+    def forward(self, embeddings, lengths, image_shapes, h_coords, w_coords) -> torch.Tensor:\n+        \"\"\"\n+        Forward pass with integrated position encoding adaptation using 2D interpolation.\n+\n+        Args:\n+            embeddings: Input embeddings tensor\n+            lengths (torch.Tensor): Sequence lengths for each image in the batch.\n+            image_shapes (torch.Tensor): Tensor of shape [batch_size, 3] representing the image shapes (t, h, w).\n+            h_coords (torch.Tensor): Tensor of shape [total_seq] representing the h coordinate for each patch.\n+            w_coords (torch.Tensor): Tensor of shape [total_seq] representing the w coordinate for each patch.\n+\n+        Returns:\n+            torch.Tensor: Embeddings with adapted position encoding added.\n+        \"\"\"\n+        # Get position embedding parameters\n+        pos_embed_weight = self.position_embedding.weight\n+        hidden_size = pos_embed_weight.shape[1]\n+        total_seq = h_coords.shape[0]\n+        device = pos_embed_weight.device\n+\n+        # Move coordinates to correct device\n+        h_coords, w_coords = h_coords.to(device), w_coords.to(device)\n+\n+        # Handle empty sequence case\n+        if total_seq == 0:\n+            adapted_pos_embed = torch.empty(0, hidden_size, device=device, dtype=pos_embed_weight.dtype)\n+        else:\n+            # Convert inputs to tensors if needed\n+            if isinstance(lengths, list):\n+                lengths = torch.tensor(lengths, device=device, dtype=torch.long)\n+            if not isinstance(image_shapes, torch.Tensor):\n+                image_shapes = torch.tensor(image_shapes, device=device, dtype=torch.long)\n+\n+            # Prepare 2D position embedding\n+            orig_size_sq = pos_embed_weight.shape[0]\n+            orig_size = int(orig_size_sq**0.5)\n+            pos_embed_2d = (\n+                pos_embed_weight.view(orig_size, orig_size, hidden_size)\n+                .permute(2, 0, 1)\n+                .unsqueeze(0)\n+                .to(device=device, dtype=torch.float32)\n+            )\n+\n+            # Calculate target dimensions for each patch\n+            target_h = torch.cat([image_shapes[i, 1].repeat(lengths[i]) for i in range(len(lengths))]).to(\n+                device=device, dtype=torch.float32\n+            )\n+            target_w = torch.cat([image_shapes[i, 2].repeat(lengths[i]) for i in range(len(lengths))]).to(\n+                device=device, dtype=torch.float32\n+            )\n+\n+            # Normalize coordinates to [-1, 1] range for grid_sample\n+            h_coords = h_coords.to(device=device, dtype=torch.float32)\n+            w_coords = w_coords.to(device=device, dtype=torch.float32)\n+            norm_w = ((w_coords + 0.5) / target_w) * 2 - 1\n+            norm_h = ((h_coords + 0.5) / target_h) * 2 - 1\n+\n+            # Create sampling grid\n+            grid = torch.stack((norm_w, norm_h), dim=-1).unsqueeze(0).unsqueeze(2)\n+\n+            # Perform bicubic interpolation\n+            interpolated_embed_fp32 = F.grid_sample(\n+                pos_embed_2d, grid, mode=\"bicubic\", align_corners=False, padding_mode=\"border\"\n+            )\n+\n+            # Reshape and convert back to original dtype\n+            adapted_pos_embed_fp32 = interpolated_embed_fp32.squeeze(0).squeeze(-1).permute(1, 0)\n+            adapted_pos_embed = adapted_pos_embed_fp32.to(pos_embed_weight.dtype).to(embeddings.device)\n+\n+        # Add adapted position encoding to embeddings\n+        embeddings = embeddings + adapted_pos_embed\n+        return embeddings\n+\n+\n+def apply_rotary_pos_emb_vision(\n+    q: torch.Tensor, k: torch.Tensor, cos: torch.Tensor, sin: torch.Tensor\n+) -> tuple[torch.Tensor, torch.Tensor]:\n+    orig_q_dtype = q.dtype\n+    orig_k_dtype = k.dtype\n+    q, k = q.float(), k.float()\n+    cos, sin = cos.unsqueeze(-2).float(), sin.unsqueeze(-2).float()\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    q_embed = q_embed.to(orig_q_dtype)\n+    k_embed = k_embed.to(orig_k_dtype)\n+    return q_embed, k_embed\n+\n+\n+class Glm4vMoeVisionAttention(nn.Module):\n+    def __init__(self, config: Glm4vMoeVisionConfig) -> None:\n+        super().__init__()\n+        self.dim = config.hidden_size\n+        self.num_heads = config.num_heads\n+        self.head_dim = self.dim // self.num_heads\n+        self.num_key_value_groups = 1  # needed for eager attention\n+        self.qkv = nn.Linear(config.hidden_size, config.hidden_size * 3, bias=config.attention_bias)\n+        self.proj = nn.Linear(config.hidden_size, config.hidden_size, bias=False)\n+        self.scaling = self.head_dim**-0.5\n+        self.config = config\n+        self.attention_dropout = config.attention_dropout\n+        self.is_causal = False\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cu_seqlens: torch.Tensor,\n+        rotary_pos_emb: Optional[torch.Tensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        **kwargs,\n+    ) -> torch.Tensor:\n+        seq_length = hidden_states.shape[0]\n+        query_states, key_states, value_states = (\n+            self.qkv(hidden_states).reshape(seq_length, 3, self.num_heads, -1).permute(1, 0, 2, 3).unbind(0)\n+        )\n+        if position_embeddings is None:\n+            logger.warning_once(\n+                \"The attention layers in this model are transitioning from computing the RoPE embeddings internally \"\n+                \"through `rotary_pos_emb` (2D tensor of RoPE theta values), to using externally computed \"\n+                \"`position_embeddings` (Tuple of tensors, containing cos and sin). In v4.54 `rotary_pos_emb` will be \"\n+                \"removed and `position_embeddings` will be mandatory.\"\n+            )\n+            emb = torch.cat((rotary_pos_emb, rotary_pos_emb), dim=-1)\n+            cos = emb.cos()\n+            sin = emb.sin()\n+        else:\n+            cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb_vision(query_states, key_states, cos, sin)\n+\n+        query_states = query_states.transpose(0, 1).unsqueeze(0)\n+        key_states = key_states.transpose(0, 1).unsqueeze(0)\n+        value_states = value_states.transpose(0, 1).unsqueeze(0)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        if self.config._attn_implementation == \"flash_attention_2\":\n+            # Flash Attention 2: Use cu_seqlens for variable length attention\n+            max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max()\n+            attn_output, _ = attention_interface(\n+                self,\n+                query_states,\n+                key_states,\n+                value_states,\n+                attention_mask=None,\n+                scaling=self.scaling,\n+                dropout=0.0 if not self.training else self.attention_dropout,\n+                cu_seq_lens_q=cu_seqlens,\n+                cu_seq_lens_k=cu_seqlens,\n+                max_length_q=max_seqlen,\n+                max_length_k=max_seqlen,\n+                is_causal=False,\n+                **kwargs,\n+            )\n+        else:\n+            # Other implementations: Process each chunk separately\n+            lengths = cu_seqlens[1:] - cu_seqlens[:-1]\n+            splits = [\n+                torch.split(tensor, lengths.tolist(), dim=2) for tensor in (query_states, key_states, value_states)\n+            ]\n+\n+            attn_outputs = [\n+                attention_interface(\n+                    self,\n+                    q,\n+                    k,\n+                    v,\n+                    attention_mask=None,\n+                    scaling=self.scaling,\n+                    dropout=0.0 if not self.training else self.attention_dropout,\n+                    is_causal=False,\n+                    **kwargs,\n+                )[0]\n+                for q, k, v in zip(*splits)\n+            ]\n+            attn_output = torch.cat(attn_outputs, dim=1)\n+\n+        attn_output = attn_output.reshape(seq_length, -1).contiguous()\n+        attn_output = self.proj(attn_output)\n+        return attn_output\n+\n+\n+class Glm4vMoeVisionBlock(GradientCheckpointingLayer):\n+    def __init__(self, config) -> None:\n+        super().__init__()\n+        self.norm1 = Glm4vMoeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.norm2 = Glm4vMoeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.attn = Glm4vMoeVisionAttention(config)\n+        self.mlp = Glm4vMoeisionMlp(config, bias=False)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cu_seqlens: torch.Tensor,\n+        rotary_pos_emb: Optional[torch.Tensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        **kwargs,\n+    ) -> torch.Tensor:\n+        hidden_states = hidden_states + self.attn(\n+            self.norm1(hidden_states),\n+            cu_seqlens=cu_seqlens,\n+            rotary_pos_emb=rotary_pos_emb,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = hidden_states + self.mlp(self.norm2(hidden_states))\n+        return hidden_states\n+\n+\n+class Glm4vMoeTextRotaryEmbedding(nn.Module):\n+    inv_freq: torch.Tensor  # fix linting for `register_buffer`\n+\n+    def __init__(self, config: Glm4vMoeTextConfig, device=None):\n+        super().__init__()\n+        # BC: \"rope_type\" was originally \"type\"\n+        if hasattr(config, \"rope_scaling\") and config.rope_scaling is not None:\n+            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n+        else:\n+            self.rope_type = \"default\"\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = self.inv_freq\n+\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        # In contrast to other models, Glm4vMoeText has different position ids for the grids\n+        # So we expand the inv_freq to shape (3, ...)\n+        inv_freq_expanded = self.inv_freq[None, None, :, None].float().expand(3, position_ids.shape[1], -1, 1)\n+        position_ids_expanded = position_ids[:, :, None, :].float()  # shape (3, bs, 1, positions)\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(2, 3)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos() * self.attention_scaling\n+            sin = emb.sin() * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+@dataclass\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    Base class for Llava outputs, with hidden states and attentions.\n+    \"\"\"\n+)\n+class Glm4vMoeModelOutputWithPast(ModelOutput):\n+    r\"\"\"\n+    past_key_values (`Cache`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+        Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+        `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+\n+        Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+        `past_key_values` input) to speed up sequential decoding.\n+    rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+        The rope index difference between sequence length and multimodal rope.\n+    \"\"\"\n+\n+    last_hidden_state: torch.FloatTensor = None\n+    past_key_values: Optional[list[torch.FloatTensor]] = None\n+    hidden_states: Optional[tuple[torch.FloatTensor]] = None\n+    attentions: Optional[tuple[torch.FloatTensor]] = None\n+    rope_deltas: Optional[torch.LongTensor] = None\n+\n+\n+class Glm4vMoeVisionModel(Glm4vMoePreTrainedModel):\n+    config: Glm4vMoeVisionConfig\n+    _no_split_modules = [\"Glm4vMoeVisionBlock\"]\n+\n+    def __init__(self, config) -> None:\n+        super().__init__(config)\n+        self.spatial_merge_size = config.spatial_merge_size\n+        self.patch_size = config.patch_size\n+\n+        self.embeddings = Glm4vMoeVisionEmbeddings(config)\n+        self.patch_embed = Glm4vMoeVisionPatchEmbed(config)\n+\n+        head_dim = config.hidden_size // config.num_heads\n+        self.rotary_pos_emb = Glm4vMoeVisionRotaryEmbedding(head_dim // 2)\n+\n+        self.blocks = nn.ModuleList([Glm4vMoeVisionBlock(config) for _ in range(config.depth)])\n+        self.merger = Glm4vMoeVisionPatchMerger(\n+            dim=config.out_hidden_size, context_dim=config.intermediate_size, hidden_act=config.hidden_act\n+        )\n+\n+        self.post_conv_layernorm = Glm4vMoeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.downsample = nn.Conv2d(\n+            in_channels=config.hidden_size,\n+            out_channels=config.out_hidden_size,\n+            kernel_size=config.spatial_merge_size,\n+            stride=config.spatial_merge_size,\n+        )\n+        self.post_layernorm = Glm4vMoeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+        self.gradient_checkpointing = False\n+        self.post_init()\n+\n+    def rot_pos_emb(self, grid_thw):\n+        pos_ids = []\n+        for t, h, w in grid_thw:\n+            hpos_ids = torch.arange(h).unsqueeze(1).expand(-1, w)\n+            hpos_ids = hpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            hpos_ids = hpos_ids.permute(0, 2, 1, 3)\n+            hpos_ids = hpos_ids.flatten()\n+\n+            wpos_ids = torch.arange(w).unsqueeze(0).expand(h, -1)\n+            wpos_ids = wpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            wpos_ids = wpos_ids.permute(0, 2, 1, 3)\n+            wpos_ids = wpos_ids.flatten()\n+            pos_ids.append(torch.stack([hpos_ids, wpos_ids], dim=-1).repeat(t, 1))\n+        pos_ids = torch.cat(pos_ids, dim=0)\n+        max_grid_size = grid_thw[:, 1:].max()\n+        rotary_pos_emb_full = self.rotary_pos_emb(max_grid_size)\n+        rotary_pos_emb = rotary_pos_emb_full[pos_ids].flatten(1)\n+        return rotary_pos_emb, pos_ids\n+\n+    def forward(self, hidden_states: torch.Tensor, grid_thw: torch.Tensor) -> torch.Tensor:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.Tensor` of shape `(seq_len, hidden_size)`):\n+                The final hidden states of the model.\n+            grid_thw (`torch.Tensor` of shape `(num_images_or_videos, 3)`):\n+                The temporal, height and width of feature shape of each image in LLM.\n+\n+        Returns:\n+            `torch.Tensor`: hidden_states.\n+        \"\"\"\n+        hidden_states = self.patch_embed(hidden_states)\n+        hidden_states = self.post_conv_layernorm(hidden_states)\n+\n+        rotary_pos_emb, image_type_ids = self.rot_pos_emb(grid_thw)\n+        emb = torch.cat((rotary_pos_emb, rotary_pos_emb), dim=-1)\n+        position_embeddings = (emb.cos(), emb.sin())\n+\n+        cu_seqlens = torch.repeat_interleave(grid_thw[:, 1] * grid_thw[:, 2], grid_thw[:, 0]).cumsum(\n+            dim=0,\n+            # Select dtype based on the following factors:\n+            #  - FA2 requires that cu_seqlens_q must have dtype int32\n+            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n+            # See https://github.com/huggingface/transformers/pull/34852 for more information\n+            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_seqlens = F.pad(cu_seqlens, (1, 0), value=0)\n+        seqlens = (cu_seqlens[1:] - cu_seqlens[:-1]).tolist()\n+        hidden_states = self.embeddings(hidden_states, seqlens, grid_thw, image_type_ids[:, 0], image_type_ids[:, 1])\n+\n+        for blk in self.blocks:\n+            hidden_states = blk(\n+                hidden_states,\n+                cu_seqlens=cu_seqlens,\n+                position_embeddings=position_embeddings,\n+            )\n+\n+        hidden_states = self.post_layernorm(hidden_states)\n+\n+        hidden_states = hidden_states.view(\n+            -1, self.spatial_merge_size, self.spatial_merge_size, hidden_states.shape[-1]\n+        )\n+        hidden_states = hidden_states.permute(0, 3, 1, 2)\n+        hidden_states = self.downsample(hidden_states).view(-1, self.config.out_hidden_size)\n+\n+        hidden_states = self.merger(hidden_states)\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class Glm4vMoeTextModel(Glm4vMoePreTrainedModel):\n+    config: Glm4vMoeTextConfig\n+\n+    def __init__(self, config: Glm4vMoeTextConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [Glm4vMoeTextDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = Glm4vMoeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = Glm4vMoeTextRotaryEmbedding(config=config)\n+\n+        self.gradient_checkpointing = False\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @auto_docstring\n+    @check_model_inputs\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Union[tuple, BaseModelOutputWithPast]:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        # torch.jit.trace() doesn't support cache objects in the output\n+        if use_cache and past_key_values is None and not torch.jit.is_tracing():\n+            past_key_values = DynamicCache()\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        # the hard coded `3` is for temporal, height and width.\n+        if position_ids is None:\n+            position_ids = cache_position.view(1, 1, -1).expand(3, inputs_embeds.shape[0], -1)\n+        elif position_ids.dim() == 2:\n+            position_ids = position_ids[None, ...].expand(3, position_ids.shape[0], -1)\n+\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=position_ids,\n+        )\n+\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        for decoder_layer in self.layers:\n+            layer_outputs = decoder_layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=causal_mask,\n+                position_ids=position_ids,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+            hidden_states = layer_outputs\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+@auto_docstring\n+class Glm4vMoeModel(Glm4vMoePreTrainedModel):\n+    base_model_prefix = \"\"\n+    _checkpoint_conversion_mapping = {}\n+    config: Glm4vMoeConfig\n+    _no_split_modules = [\"Glm4vMoeTextDecoderLayer\", \"Glm4vMoeVisionBlock\"]\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.visual = Glm4vMoeVisionModel._from_config(config.vision_config)\n+        self.language_model = Glm4vMoeTextModel._from_config(config.text_config)\n+        self.rope_deltas = None  # cache rope_deltas here\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.language_model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.language_model.set_input_embeddings(value)\n+\n+    def set_decoder(self, decoder):\n+        self.language_model = decoder\n+\n+    def get_decoder(self):\n+        return self.language_model\n+\n+    def get_rope_index(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Calculate the 3D rope index based on image and video's temporal, height and width in LLM.\n+\n+        Explanation:\n+            Each embedding sequence contains vision embedding and text embedding or just contains text embedding.\n+\n+            For pure text embedding sequence, the rotary position embedding has no difference with modern LLMs.\n+            Examples:\n+                input_ids: [T T T T T], here T is for text.\n+                temporal position_ids: [0, 1, 2, 3, 4]\n+                height position_ids: [0, 1, 2, 3, 4]\n+                width position_ids: [0, 1, 2, 3, 4]\n+\n+            For vision and text embedding sequence, we calculate 3D rotary position embedding for vision part\n+            and 1D rotary position embedding for text part.\n+            Examples:\n+                Temporal (Time): 3 patches, representing different segments of the video in time.\n+                Height: 2 patches, dividing each frame vertically.\n+                Width: 2 patches, dividing each frame horizontally.\n+                We also have some important parameters:\n+                fps (Frames Per Second): The video's frame rate, set to 1. This means one frame is processed each second.\n+                tokens_per_second: This is a crucial parameter. It dictates how many \"time-steps\" or \"temporal tokens\" are conceptually packed into a one-second interval of the video. In this case, we have 25 tokens per second. So each second of the video will be represented with 25 separate time points. It essentially defines the temporal granularity.\n+                temporal_patch_size: The number of frames that compose one temporal patch. Here, it's 2 frames.\n+                interval: The step size for the temporal position IDs, calculated as tokens_per_second * temporal_patch_size / fps. In this case, 25 * 2 / 1 = 50. This means that each temporal patch will be have a difference of 50 in the temporal position IDs.\n+                input_ids: [V V V V V V V V V V V V T T T T T], here V is for vision.\n+                vision temporal position_ids: [0, 0, 0, 0, 50, 50, 50, 50, 100, 100, 100, 100]\n+                vision height position_ids: [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]\n+                vision width position_ids: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n+                text temporal position_ids: [101, 102, 103, 104, 105]\n+                text height position_ids: [101, 102, 103, 104, 105]\n+                text width position_ids: [101, 102, 103, 104, 105]\n+                Here we calculate the text start position_ids as the max vision position_ids plus 1.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+                it.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+\n+        Returns:\n+            position_ids (`torch.LongTensor` of shape `(3, batch_size, sequence_length)`)\n+            mrope_position_deltas (`torch.Tensor` of shape `(batch_size)`)\n+        \"\"\"\n+\n+        spatial_merge_size = self.config.vision_config.spatial_merge_size\n+        image_token_id = self.config.image_token_id\n+        video_start_token_id = self.config.video_start_token_id\n+        video_end_token_id = self.config.video_end_token_id\n+\n+        mrope_position_deltas = []\n+        if input_ids is not None and (image_grid_thw is not None or video_grid_thw is not None):\n+            total_input_ids = input_ids\n+            if attention_mask is None:\n+                attention_mask = torch.ones_like(total_input_ids)\n+            position_ids = torch.ones(\n+                3,\n+                input_ids.shape[0],\n+                input_ids.shape[1],\n+                dtype=input_ids.dtype,\n+                device=input_ids.device,\n+            )\n+            image_index, video_index = 0, 0\n+            video_group_index = 0\n+            attention_mask = attention_mask.to(total_input_ids.device)\n+            for i, input_ids in enumerate(total_input_ids):\n+                input_ids = input_ids[attention_mask[i] == 1]\n+                input_tokens = input_ids.tolist()\n+\n+                input_token_type = []\n+                video_check_flg = False\n+                for token in input_tokens:\n+                    if token == video_start_token_id:\n+                        video_check_flg = True\n+                    elif token == video_end_token_id:\n+                        video_check_flg = False\n+\n+                    if token == image_token_id and not video_check_flg:\n+                        input_token_type.append(\"image\")\n+                    elif token == image_token_id and video_check_flg:\n+                        input_token_type.append(\"video\")\n+                    else:\n+                        input_token_type.append(\"text\")\n+\n+                input_type_group = []\n+                for key, group in itertools.groupby(enumerate(input_token_type), lambda x: x[1]):\n+                    group = list(group)\n+                    start_index = group[0][0]\n+                    end_index = group[-1][0] + 1\n+                    input_type_group.append((key, start_index, end_index))\n+\n+                llm_pos_ids_list = []\n+                video_frame_num = 1\n+                for modality_type, start_idx, end_idx in input_type_group:\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+\n+                    if modality_type == \"image\":\n+                        t, h, w = (\n+                            image_grid_thw[image_index][0],\n+                            image_grid_thw[image_index][1],\n+                            image_grid_thw[image_index][2],\n+                        )\n+                        llm_grid_t, llm_grid_h, llm_grid_w = (\n+                            t.item(),\n+                            h.item() // spatial_merge_size,\n+                            w.item() // spatial_merge_size,\n+                        )\n+\n+                        t_index = torch.arange(llm_grid_t).view(-1, 1).expand(-1, llm_grid_h * llm_grid_w).flatten()\n+                        h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(llm_grid_t, -1, llm_grid_w).flatten()\n+                        w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(llm_grid_t, llm_grid_h, -1).flatten()\n+                        llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + st_idx)\n+\n+                        image_index += 1\n+                        video_frame_num = 1\n+\n+                    elif modality_type == \"video\":\n+                        t, h, w = (\n+                            video_frame_num,\n+                            video_grid_thw[video_index][1],\n+                            video_grid_thw[video_index][2],\n+                        )\n+\n+                        llm_grid_t, llm_grid_h, llm_grid_w = (\n+                            t,\n+                            h.item() // spatial_merge_size,\n+                            w.item() // spatial_merge_size,\n+                        )\n+\n+                        for t_idx in range(llm_grid_t):\n+                            t_index = torch.tensor(t_idx).view(-1, 1).expand(-1, llm_grid_h * llm_grid_w).flatten()\n+\n+                            h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(1, -1, llm_grid_w).flatten()\n+                            w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(1, llm_grid_h, -1).flatten()\n+                            llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + st_idx)\n+\n+                        video_group_index += 1\n+\n+                        if video_group_index >= video_grid_thw[video_index][0]:\n+                            video_index += 1\n+                            video_group_index = 0\n+\n+                        video_frame_num += 1\n+\n+                    else:\n+                        text_len = end_idx - start_idx\n+                        llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                        video_frame_num = 1\n+\n+                llm_positions = torch.cat(llm_pos_ids_list, dim=1).reshape(3, -1)\n+                position_ids[..., i, attention_mask[i] == 1] = llm_positions.to(position_ids.device)\n+                mrope_position_deltas.append(llm_positions.max() + 1 - len(total_input_ids[i]))\n+            mrope_position_deltas = torch.tensor(mrope_position_deltas, device=input_ids.device).unsqueeze(1)\n+            return position_ids, mrope_position_deltas\n+        else:\n+            if attention_mask is not None:\n+                position_ids = attention_mask.long().cumsum(-1) - 1\n+                position_ids.masked_fill_(attention_mask == 0, 1)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1).to(attention_mask.device)\n+                max_position_ids = position_ids.max(0, keepdim=False)[0].max(-1, keepdim=True)[0]\n+                mrope_position_deltas = max_position_ids + 1 - attention_mask.shape[-1]\n+            else:\n+                position_ids = (\n+                    torch.arange(input_ids.shape[1], device=input_ids.device)\n+                    .view(1, 1, -1)\n+                    .expand(3, input_ids.shape[0], -1)\n+                )\n+                mrope_position_deltas = torch.zeros(\n+                    [input_ids.shape[0], 1],\n+                    device=input_ids.device,\n+                    dtype=input_ids.dtype,\n+                )\n+\n+            return position_ids, mrope_position_deltas\n+\n+    def get_video_features(\n+        self, pixel_values_videos: torch.FloatTensor, video_grid_thw: Optional[torch.LongTensor] = None\n+    ):\n+        \"\"\"\n+        Encodes videos into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values_videos (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input videos.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+        \"\"\"\n+        pixel_values_videos = pixel_values_videos.type(self.visual.dtype)\n+        # reshape video_grid_thw -> [b, 3] -> [1, h, w] * frames\n+        temp_frames_hw = []\n+        for t, h, w in video_grid_thw:\n+            repeated_row = torch.tensor([1, h.item(), w.item()]).unsqueeze(0).repeat(t, 1)\n+            temp_frames_hw.append(repeated_row)\n+        flattened_video_grid_thw = torch.cat(temp_frames_hw, dim=0)\n+        video_embeds = self.visual(pixel_values_videos, grid_thw=flattened_video_grid_thw)\n+        split_sizes = (video_grid_thw.prod(-1) // self.visual.spatial_merge_size**2).tolist()\n+        video_embeds = torch.split(video_embeds, split_sizes)\n+        return video_embeds\n+\n+    def get_image_features(self, pixel_values: torch.FloatTensor, image_grid_thw: Optional[torch.LongTensor] = None):\n+        \"\"\"\n+        Encodes images into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input images.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        pixel_values = pixel_values.type(self.visual.dtype)\n+        image_embeds = self.visual(pixel_values, grid_thw=image_grid_thw)\n+        split_sizes = (image_grid_thw.prod(-1) // self.visual.spatial_merge_size**2).tolist()\n+        image_embeds = torch.split(image_embeds, split_sizes)\n+        return image_embeds\n+\n+    def get_placeholder_mask(\n+        self,\n+        input_ids: torch.LongTensor,\n+        inputs_embeds: torch.FloatTensor,\n+        image_features: torch.FloatTensor = None,\n+        video_features: torch.FloatTensor = None,\n+    ):\n+        \"\"\"\n+        Obtains multimodal placeholdr mask from `input_ids` or `inputs_embeds`, and checks that the placeholder token count is\n+        equal to the length of multimodal features. If the lengths are different, an error is raised.\n+        \"\"\"\n+        if input_ids is None:\n+            special_image_mask = inputs_embeds == self.get_input_embeddings()(\n+                torch.tensor(self.config.image_token_id, dtype=torch.long, device=inputs_embeds.device)\n+            )\n+            special_image_mask = special_image_mask.all(-1)\n+            special_video_mask = inputs_embeds == self.get_input_embeddings()(\n+                torch.tensor(self.config.video_token_id, dtype=torch.long, device=inputs_embeds.device)\n+            )\n+            special_video_mask = special_video_mask.all(-1)\n+        else:\n+            # GLM-4.1V and GLM-4.5V special_video_mask is special_image_mask\n+            special_image_mask = input_ids == self.config.image_token_id\n+            special_video_mask = input_ids == self.config.image_token_id\n+\n+        n_image_tokens = special_image_mask.sum()\n+        special_image_mask = special_image_mask.unsqueeze(-1).expand_as(inputs_embeds).to(inputs_embeds.device)\n+        if image_features is not None and inputs_embeds[special_image_mask].numel() != image_features.numel():\n+            raise ValueError(\n+                f\"Image features and image tokens do not match: tokens: {n_image_tokens}, features {image_features.shape[0]}\"\n+            )\n+\n+        n_video_tokens = special_video_mask.sum()\n+        special_video_mask = special_video_mask.unsqueeze(-1).expand_as(inputs_embeds).to(inputs_embeds.device)\n+        if video_features is not None and inputs_embeds[special_video_mask].numel() != video_features.numel():\n+            raise ValueError(\n+                f\"Videos features and video tokens do not match: tokens: {n_video_tokens}, features {video_features.shape[0]}\"\n+            )\n+\n+        return special_image_mask, special_video_mask\n+\n+    @auto_docstring\n+    @can_return_tuple\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, Glm4vMoeModelOutputWithPast]:\n+        r\"\"\"\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+        \"\"\"\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.get_input_embeddings()(input_ids)\n+\n+        if pixel_values is not None:\n+            image_embeds = self.get_image_features(pixel_values, image_grid_thw)\n+            image_embeds = torch.cat(image_embeds, dim=0).to(inputs_embeds.device, inputs_embeds.dtype)\n+            image_mask, _ = self.get_placeholder_mask(input_ids, inputs_embeds, image_features=image_embeds)\n+            inputs_embeds = inputs_embeds.masked_scatter(image_mask, image_embeds)\n+\n+        if pixel_values_videos is not None:\n+            video_embeds = self.get_video_features(pixel_values_videos, video_grid_thw)\n+            video_embeds = torch.cat(video_embeds, dim=0).to(inputs_embeds.device, inputs_embeds.dtype)\n+            _, video_mask = self.get_placeholder_mask(input_ids, inputs_embeds, video_features=video_embeds)\n+            inputs_embeds = inputs_embeds.masked_scatter(video_mask, video_embeds)\n+\n+        if position_ids is None:\n+            attention_mask_tensor = (\n+                attention_mask if not isinstance(attention_mask, dict) else attention_mask[\"full_attention\"]\n+            )\n+            if attention_mask_tensor is not None and attention_mask_tensor.ndim == 4:\n+                attention_mask_tensor = torch.diagonal(attention_mask_tensor[:, 0], dim1=1, dim2=2)\n+                # Only apply conversion for floating point tensors (inverted masks)\n+                if attention_mask_tensor.dtype.is_floating_point:\n+                    attention_mask_tensor = attention_mask_tensor / torch.finfo(attention_mask_tensor.dtype).min\n+                    attention_mask_tensor = (1.0 - attention_mask_tensor).int()\n+\n+            # Calculate RoPE index once per generation in the pre-fill stage only.\n+            # When compiling, we can't check tensor values thus we check only input length\n+            # It is safe to assume that `length!=1` means we're in pre-fill because compiled\n+            # models currently cannot do asssisted decoding\n+            prefill_compiled_stage = is_torchdynamo_compiling() and (\n+                (input_ids is not None and input_ids.shape[1] != 1)\n+                or (inputs_embeds is not None and inputs_embeds.shape[1] != 1)\n+            )\n+            prefill_noncompiled_stage = not is_torchdynamo_compiling() and (\n+                (cache_position is not None and cache_position[0] == 0)\n+                or (past_key_values is None or past_key_values.get_seq_length() == 0)\n+            )\n+            if (prefill_compiled_stage or prefill_noncompiled_stage) or self.rope_deltas is None:\n+                position_ids, rope_deltas = self.get_rope_index(\n+                    input_ids,\n+                    image_grid_thw,\n+                    video_grid_thw,\n+                    attention_mask=attention_mask_tensor,\n+                )\n+                self.rope_deltas = rope_deltas\n+            # then use the prev pre-calculated rope-deltas to get the correct position ids\n+            else:\n+                batch_size, seq_length, _ = inputs_embeds.shape\n+                delta = (\n+                    (cache_position[0] + self.rope_deltas).to(inputs_embeds.device)\n+                    if cache_position is not None\n+                    else 0\n+                )\n+                position_ids = torch.arange(seq_length, device=inputs_embeds.device)\n+                position_ids = position_ids.view(1, -1).expand(batch_size, -1)\n+                if cache_position is not None:  # otherwise `deltas` is an int `0`\n+                    delta = delta.repeat_interleave(batch_size // delta.shape[0], dim=0)\n+                position_ids = position_ids.add(delta)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1)\n+\n+        outputs = self.language_model(\n+            input_ids=None,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        return Glm4vMoeModelOutputWithPast(\n+            last_hidden_state=outputs.last_hidden_state,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=self.rope_deltas,\n+        )\n+\n+\n+@dataclass\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    Base class for Glm4vMoe causal language model (or autoregressive) outputs.\n+    \"\"\"\n+)\n+class Glm4vMoeCausalLMOutputWithPast(ModelOutput):\n+    r\"\"\"\n+    loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+        Language modeling loss (for next-token prediction).\n+    logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n+        Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+    past_key_values (`Cache`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+        Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+        `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+\n+        Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+        `past_key_values` input) to speed up sequential decoding.\n+    rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+        The rope index difference between sequence length and multimodal rope.\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: Optional[torch.FloatTensor] = None\n+    past_key_values: Optional[list[torch.FloatTensor]] = None\n+    hidden_states: Optional[tuple[torch.FloatTensor]] = None\n+    attentions: Optional[tuple[torch.FloatTensor]] = None\n+    rope_deltas: Optional[torch.LongTensor] = None\n+\n+\n+class Glm4vMoeForConditionalGeneration(Glm4vMoePreTrainedModel, GenerationMixin):\n+    _checkpoint_conversion_mapping = {}\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = Glm4vMoeModel(config)\n+        self.lm_head = nn.Linear(config.text_config.hidden_size, config.text_config.vocab_size, bias=False)\n+\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.model.set_input_embeddings(value)\n+\n+    def set_decoder(self, decoder):\n+        self.model.set_decoder(decoder)\n+\n+    def get_decoder(self):\n+        return self.model.get_decoder()\n+\n+    def get_video_features(\n+        self, pixel_values_videos: torch.FloatTensor, video_grid_thw: Optional[torch.LongTensor] = None\n+    ):\n+        return self.model.get_video_features(pixel_values_videos, video_grid_thw)\n+\n+    def get_image_features(self, pixel_values: torch.FloatTensor, image_grid_thw: Optional[torch.LongTensor] = None):\n+        return self.model.get_image_features(pixel_values, image_grid_thw)\n+\n+    # Make modules available throught conditional class for BC\n+    @property\n+    def language_model(self):\n+        return self.model.language_model\n+\n+    @property\n+    def visual(self):\n+        return self.model.visual\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, Glm4vMoeCausalLMOutputWithPast]:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+\n+        Example:\n+\n+        ```python\n+        >>> from PIL import Image\n+        >>> import requests\n+        >>> from transformers import AutoProcessor, Glm4vMoeForConditionalGeneration\n+\n+        >>> model = Glm4vMoeForConditionalGeneration.from_pretrained(\"THUDM/GLM-4.1V-9B-Thinking\")\n+        >>> processor = AutoProcessor.from_pretrained(\"THUDM/GLM-4.1V-9B-Thinking\")\n+\n+        >>> messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\"},\n+                    {\"type\": \"text\", \"text\": \"What is shown in this image?\"},\n+                ],\n+            },\n+        ]\n+        >>> url = \"https://www.ilankelman.org/stopsigns/australia.jpg\"\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> text = processor.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\n+        >>> inputs = processor(text=[text], images=[image], vision_infos=[vision_infos])\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"The image shows a street scene with a red stop sign in the foreground. In the background, there is a large red gate with Chinese characters ...\"\n+        ```\"\"\"\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            pixel_values=pixel_values,\n+            pixel_values_videos=pixel_values_videos,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs[0]\n+\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits=logits, labels=labels, vocab_size=self.config.text_config.vocab_size)\n+\n+        return Glm4vMoeCausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=outputs.rope_deltas,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        attention_mask=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        position_ids=None,\n+        use_cache=True,\n+        pixel_values=None,\n+        pixel_values_videos=None,\n+        image_grid_thw=None,\n+        video_grid_thw=None,\n+        **kwargs,\n+    ):\n+        # Overwritten -- in specific circumstances we don't want to forward image inputs to the model\n+\n+        model_inputs = super().prepare_inputs_for_generation(\n+            input_ids,\n+            past_key_values=past_key_values,\n+            attention_mask=attention_mask,\n+            inputs_embeds=inputs_embeds,\n+            cache_position=cache_position,\n+            position_ids=position_ids,\n+            pixel_values=pixel_values,\n+            pixel_values_videos=pixel_values_videos,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            use_cache=use_cache,\n+            **kwargs,\n+        )\n+\n+        # GLM-4.1V position_ids are prepareed with rope_deltas in forward\n+        model_inputs[\"position_ids\"] = None\n+\n+        if cache_position[0] != 0:\n+            model_inputs[\"pixel_values\"] = None\n+            model_inputs[\"pixel_values_videos\"] = None\n+\n+        return model_inputs\n+\n+    def _get_image_nums_and_video_nums(\n+        self,\n+        input_ids: Optional[torch.LongTensor],\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Get the number of images and videos for each sample to calculate the separation length of the sample tensor.\n+        These parameters are not passed through the processor to avoid unpredictable impacts from interface modifications.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary.\n+\n+        Returns:\n+            image_nums (`torch.LongTensor` of shape `(batch_size, num_images_sample)`)\n+            video_nums (`torch.LongTensor` of shape `(batch_size, num_videos_sample)`)\n+        \"\"\"\n+\n+        if inputs_embeds is not None:\n+            is_image = (\n+                inputs_embeds\n+                == self.get_input_embeddings()(\n+                    torch.tensor(self.config.image_start_token_id, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            )[..., 0]\n+            is_video_start = (\n+                inputs_embeds\n+                == self.get_input_embeddings()(\n+                    torch.tensor(self.config.video_start_token_id, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            )[..., 0]\n+            is_video_end = (\n+                inputs_embeds\n+                == self.get_input_embeddings()(\n+                    torch.tensor(self.config.video_end_token_id, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            )[..., 0]\n+        else:\n+            is_image = input_ids == self.config.image_start_token_id\n+            is_video_start = input_ids == self.config.video_start_token_id\n+            is_video_end = input_ids == self.config.video_end_token_id\n+\n+        # Cumulative sum to track if we're inside a video span\n+        # We'll assume well-formed video tags (i.e. matching starts and ends)\n+        video_level = torch.cumsum(is_video_start.int() - is_video_end.int(), dim=1)\n+        inside_video = video_level > 0  # shape (batch_size, seq_length)\n+\n+        # Mask out image tokens that are inside video spans\n+        standalone_images = is_image & (~inside_video)\n+\n+        # Count per batch\n+        image_counts = standalone_images.sum(dim=1)\n+        video_counts = is_video_start.sum(dim=1)\n+\n+        return image_counts, video_counts\n+\n+    def _expand_inputs_for_generation(\n+        self,\n+        expand_size: int = 1,\n+        is_encoder_decoder: bool = False,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        **model_kwargs,\n+    ) -> tuple[torch.LongTensor, dict[str, Any]]:\n+        # Overwritten -- Support for expanding tensors without a batch size dimension\n+        # e.g., pixel_values, image_grid_thw, pixel_values_videos, video_grid_thw, second_per_grid_t\n+        # pixel_values.shape[0] is sum(seqlen_images for samples)\n+        # image_grid_thw.shape[0] is sum(num_images for samples)\n+\n+        if expand_size == 1:\n+            return input_ids, model_kwargs\n+\n+        visual_keys = [\"pixel_values\", \"image_grid_thw\", \"pixel_values_videos\", \"video_grid_thw\", \"second_per_grid_ts\"]\n+\n+        def _expand_dict_for_generation_visual(dict_to_expand):\n+            image_grid_thw = model_kwargs.get(\"image_grid_thw\", None)\n+            video_grid_thw = model_kwargs.get(\"video_grid_thw\", None)\n+            image_nums, video_nums = self._get_image_nums_and_video_nums(\n+                input_ids, inputs_embeds=model_kwargs.get(\"inputs_embeds\", None)\n+            )\n+\n+            def _repeat_interleave_samples(x, lengths, repeat_times):\n+                samples = torch.split(x, lengths)\n+                repeat_args = [repeat_times] + [1] * (x.dim() - 1)\n+                result = torch.cat([sample.repeat(*repeat_args) for sample in samples], dim=0)\n+                return result\n+\n+            for key in dict_to_expand:\n+                if key == \"pixel_values\":\n+                    # split images into samples\n+                    samples = torch.split(image_grid_thw, list(image_nums))\n+                    # compute the sequence length of images for each sample\n+                    lengths = [torch.prod(sample, dim=1).sum() for sample in samples]\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"image_grid_thw\":\n+                    # get the num of images for each sample\n+                    lengths = list(image_nums)\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"pixel_values_videos\":\n+                    samples = torch.split(video_grid_thw, list(video_nums))\n+                    lengths = [torch.prod(sample, dim=1).sum() for sample in samples]\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"video_grid_thw\":\n+                    lengths = list(video_nums)\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"second_per_grid_ts\":\n+                    if not isinstance(dict_to_expand[key], list):\n+                        raise TypeError(\n+                            f\"Expected value for key '{key}' to be a list, but got {type(dict_to_expand[key])} instead.\"\n+                        )\n+                    tensor = torch.tensor(dict_to_expand[key])\n+                    lengths = list(video_nums)\n+                    tensor = _repeat_interleave_samples(tensor, lengths=lengths, repeat_times=expand_size)\n+                    dict_to_expand[key] = tensor.tolist()\n+            return dict_to_expand\n+\n+        def _expand_dict_for_generation(dict_to_expand):\n+            for key in dict_to_expand:\n+                if (\n+                    key != \"cache_position\"\n+                    and dict_to_expand[key] is not None\n+                    and isinstance(dict_to_expand[key], torch.Tensor)\n+                    and key not in visual_keys\n+                ):\n+                    dict_to_expand[key] = dict_to_expand[key].repeat_interleave(expand_size, dim=0)\n+            return dict_to_expand\n+\n+        model_kwargs = _expand_dict_for_generation_visual(model_kwargs)\n+\n+        if input_ids is not None:\n+            input_ids = input_ids.repeat_interleave(expand_size, dim=0)\n+\n+        model_kwargs = _expand_dict_for_generation(model_kwargs)\n+\n+        if is_encoder_decoder:\n+            if model_kwargs.get(\"encoder_outputs\") is None:\n+                raise ValueError(\"If `is_encoder_decoder` is True, make sure that `encoder_outputs` is defined.\")\n+            model_kwargs[\"encoder_outputs\"] = _expand_dict_for_generation(model_kwargs[\"encoder_outputs\"])\n+\n+        return input_ids, model_kwargs\n+\n+\n+__all__ = [\"Glm4vMoeForConditionalGeneration\", \"Glm4vMoeModel\", \"Glm4vMoePreTrainedModel\", \"Glm4vMoeTextModel\"]"
        },
        {
            "sha": "bcc9a53c1c0c617ce9ef58ebfd8369cb6ca47004",
            "filename": "src/transformers/models/glm4v_moe/modular_glm4v_moe.py",
            "status": "added",
            "additions": 461,
            "deletions": 0,
            "changes": 461,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodular_glm4v_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodular_glm4v_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodular_glm4v_moe.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -0,0 +1,461 @@\n+# coding=utf-8\n+# Copyright 2025 The ZhipuAI Inc. team and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import Callable, Optional\n+\n+import torch\n+import torch.nn as nn\n+\n+from ...cache_utils import Cache\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_rope_utils import rope_config_validation\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS\n+from ...processing_utils import Unpack\n+from ...utils import logging\n+from ..glm4.modeling_glm4 import Glm4Attention\n+from ..glm4_moe.configuration_glm4_moe import Glm4MoeConfig\n+from ..glm4_moe.modeling_glm4_moe import (\n+    Glm4MoeDecoderLayer,\n+    Glm4MoeMLP,\n+    Glm4MoeMoE,\n+    Glm4MoePreTrainedModel,\n+    Glm4MoeRMSNorm,\n+    Glm4MoeTopkRouter,\n+    eager_attention_forward,\n+)\n+from ..glm4v.configuration_glm4v import Glm4vConfig, Glm4vVisionConfig\n+from ..glm4v.modeling_glm4v import (\n+    Glm4vForConditionalGeneration,\n+    rotate_half,\n+)\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Glm4vMoeVisionConfig(Glm4vVisionConfig):\n+    pass\n+\n+\n+class Glm4vMoeTextConfig(Glm4MoeConfig, nn.Module):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vMoeModel`]. It is used to instantiate a\n+    GLM-4.5V model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of\n+    GLM-4.5V [THUDM/GLM-4.5V](https://huggingface.co/THUDM/GLM-4.5V).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 151424):\n+            Vocabulary size of the Glm4vMoe model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Glm4vMoeModel`]\n+        hidden_size (`int`, *optional*, defaults to 4096):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 10944):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 46):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 96):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        partial_rotary_factor (`float`, *optional*, defaults to 0.5): The factor of the partial rotary position.\n+        num_key_value_heads (`int`, *optional*, defaults to 8):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `32`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 65536):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n+                    'llama3'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n+                    pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n+                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n+                    `factor` field to infer the suggested value.\n+        attention_bias (`bool`, defaults to `True`, *optional*, defaults to `True`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        moe_intermediate_size (`int`, *optional*, defaults to 1408):\n+            Intermediate size of the routed expert.\n+        num_experts_per_tok (`int`, *optional*, defaults to 8):\n+            number of experts per token.\n+        n_shared_experts (`int`, *optional*, defaults to 1):\n+            Number of shared experts.\n+        n_routed_experts (`int`, *optional*, defaults to 128):\n+            Number of routed experts.\n+        routed_scaling_factor (`float`, *optional*, defaults to 1.0):\n+            Scaling factor or routed experts.\n+        n_group (`int`, *optional*, defaults to 1):\n+            Number of groups for routed experts.\n+        topk_group (`int`, *optional*, defaults to 1):\n+            Number of selected groups for each token(for each token, ensuring the selected experts is only within `topk_group` groups).\n+        first_k_dense_replace (`int`, *optional*, defaults to 1):\n+            Number of dense layers in shallow layers(embed->dense->dense->...->dense->moe->moe...->lm_head).\n+                                                                    \\--k dense layers--/\n+        norm_topk_prob (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the topk probabilities.\n+\n+    ```python\n+    >>> from transformers import Glm4vMoeTextModel, Glm4vMoeConfig\n+\n+    >>> # Initializing a GLM-4.5V style configuration\n+    >>> configuration = Glm4vMoeConfig()\n+\n+    >>> # Initializing a model from the GLM-4.5V style configuration\n+    >>> model = Glm4vMoeTextModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"Glm4vMoe_text\"\n+    base_config_key = \"text_config\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    # Default tensor parallel plan for base model `Glm4vMoe`\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_up_proj\": \"colwise_rep\",  # we need to replicate here due to the `chunk` operation\n+        \"layers.*.mlp.down_proj\": \"rowwise_rep\",  # we need to replicate here due to the `chunk` operation\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=151424,\n+        hidden_size=4096,\n+        intermediate_size=10944,\n+        num_hidden_layers=46,\n+        num_attention_heads=96,\n+        partial_rotary_factor=0.5,\n+        num_key_value_heads=8,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=65536,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-5,\n+        use_cache=True,\n+        tie_word_embeddings=False,\n+        rope_theta=10000.0,\n+        rope_scaling=None,\n+        attention_bias=True,\n+        attention_dropout=0.0,\n+        moe_intermediate_size=1408,\n+        num_experts_per_tok=8,\n+        n_shared_experts=1,\n+        n_routed_experts=128,\n+        routed_scaling_factor=1.0,\n+        n_group=1,\n+        topk_group=1,\n+        first_k_dense_replace=1,\n+        norm_topk_prob=True,\n+        **kwargs,\n+    ):\n+        nn.Module().__init__(\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.partial_rotary_factor = partial_rotary_factor\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, move it to 'rope_type'.\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self, ignore_keys={\"mrope_section\"})\n+\n+        # MoE arguments\n+        self.moe_intermediate_size = moe_intermediate_size\n+        self.num_experts_per_tok = num_experts_per_tok\n+        self.n_group = n_group\n+        self.topk_group = topk_group\n+        self.n_shared_experts = n_shared_experts\n+        self.n_routed_experts = n_routed_experts\n+        self.routed_scaling_factor = routed_scaling_factor\n+        self.first_k_dense_replace = first_k_dense_replace\n+        self.norm_topk_prob = norm_topk_prob\n+\n+\n+class Glm4vMoeConfig(Glm4vConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vMoeModel`]. It is used to instantiate a\n+    GLM-4.5V model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of\n+    GLM-4.5V [zai_org/GLM-4.5V](https://huggingface.co/zai_org/GLM-4.5V).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        text_config (`Union[PreTrainedConfig, dict]`, *optional*, defaults to `Glm4vMoeTextConfig`):\n+            The config object or dictionary of the text backbone.\n+        vision_config (`Union[PreTrainedConfig, dict]`,  *optional*, defaults to `Glm4vMoeVisionConfig`):\n+            The config object or dictionary of the vision backbone.\n+        image_token_id (`int`, *optional*, defaults to 151363):\n+            The image token index to encode the image prompt.\n+        video_token_id (`int`, *optional*, defaults to 151364):\n+            The video token index to encode the image prompt.\n+        image_start_token_id (`int`, *optional*, defaults to 151339):\n+            The image start token index to encode the start of image.\n+        image_end_token_id (`int`, *optional*, defaults to 151340):\n+            The image end token index to encode the end of image.\n+        video_start_token_id (`int`, *optional*, defaults to 151341):\n+            The video start token index to encode the start of video.\n+        video_end_token_id (`int`, *optional*, defaults to 151342):\n+            The video end token index to encode the end of video.\n+\n+    ```python\n+    >>> from transformers import Glm4vMoeForConditionalGeneration, Glm4vMoeConfig\n+\n+    >>> # Initializing a GLM-4.5V style configuration\n+    >>> configuration = Glm4vMoeConfig()\n+\n+    >>> # Initializing a model from the GLM-4.5V style configuration\n+    >>> model = Glm4vMoeForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    def __init__(\n+        self,\n+        text_config=None,\n+        vision_config=None,\n+        image_token_id=151363,\n+        video_token_id=151364,\n+        image_start_token_id=151339,\n+        image_end_token_id=151340,\n+        video_start_token_id=151341,\n+        video_end_token_id=151342,\n+        **kwargs,\n+    ):\n+        super().__init__()\n+\n+\n+class Glm4vMoeRMSNorm(Glm4MoeRMSNorm):\n+    pass\n+\n+\n+def apply_multimodal_rotary_pos_emb(q, k, cos, sin, mrope_section, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding with Multimodal Sections to the query and key tensors (https://qwenlm.github.io/blog/qwen2-vl/).\n+\n+    Explanation:\n+        Multimodal 3D rotary position embedding is an extension to 1D rotary position embedding. The input embedding\n+        sequence contains vision (images / videos) embedding and text embedding or just contains text embedding. For\n+        vision embedding part, we apply rotary position embedding on temporal, height and width dimension separately.\n+        Here we split the channel dimension to 3 chunks for the temporal, height and width rotary position embedding.\n+        For text embedding part, we just apply 1D rotary position embedding. The three rotary position index (temporal,\n+        height and width) of text embedding is always the same, so the text embedding rotary position embedding has no\n+        difference with modern LLMs.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        mrope_section(`List(int)`):\n+            Multimodal rope section is for channel dimension of temporal, height and width in rope calculation.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    mrope_section = mrope_section * 2\n+    cos = torch.cat([m[i % 3] for i, m in enumerate(cos.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+    sin = torch.cat([m[i % 3] for i, m in enumerate(sin.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+\n+    # Keep half or full tensor for later concatenation\n+    rotary_dim = cos.shape[-1]\n+    q_rot, q_pass = q[..., :rotary_dim], q[..., rotary_dim:]\n+    k_rot, k_pass = k[..., :rotary_dim], k[..., rotary_dim:]\n+\n+    # Apply rotary embeddings on the first half or full tensor\n+    q_embed = (q_rot * cos) + (rotate_half(q_rot) * sin)\n+    k_embed = (k_rot * cos) + (rotate_half(k_rot) * sin)\n+\n+    # Concatenate back to full shape\n+    q_embed = torch.cat([q_embed, q_pass], dim=-1)\n+    k_embed = torch.cat([k_embed, k_pass], dim=-1)\n+\n+    return q_embed, k_embed\n+\n+\n+class Glm4vMoeTextAttention(Glm4Attention):\n+    def __init__(self, config: Glm4vMoeTextConfig, layer_idx: Optional[int] = None):\n+        super().__init__(config, layer_idx)\n+        self.rope_scaling = config.rope_scaling\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_values: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor], Optional[tuple[torch.Tensor]]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape)\n+\n+        query_states = query_states.transpose(1, 2)\n+        key_states = key_states.transpose(1, 2)\n+        value_states = value_states.transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_multimodal_rotary_pos_emb(  # diff with Llama\n+            query_states, key_states, cos, sin, self.rope_scaling[\"mrope_section\"]\n+        )\n+\n+        if past_key_values is not None:\n+            # sin and cos are specific to RoPE models; position_ids needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_values.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class Glm4vMoeTextTopkRouter(Glm4MoeTopkRouter, nn.Module):\n+    def __init__(self, config: Glm4vMoeTextConfig):\n+        super().__init__(config)\n+\n+\n+class Glm4vMoeTextMoE(Glm4MoeMoE):\n+    def __init__(self, config: Glm4vMoeTextConfig):\n+        super().__init__(config)\n+        self.config = config\n+        self.experts = nn.ModuleList(\n+            [\n+                Glm4vMoeTextMLP(config, intermediate_size=config.moe_intermediate_size)\n+                for _ in range(config.n_routed_experts)\n+            ]\n+        )\n+        self.gate = Glm4vMoeTextTopkRouter(config)\n+        self.shared_experts = Glm4vMoeTextMLP(\n+            config=config, intermediate_size=config.moe_intermediate_size * config.n_shared_experts\n+        )\n+\n+\n+class Glm4vMoeTextMLP(Glm4MoeMLP):\n+    pass\n+\n+\n+class Glm4vMoeTextDecoderLayer(Glm4MoeDecoderLayer):\n+    def __init__(self, config: Glm4vMoeTextConfig, layer_idx: int):\n+        super().__init__(config, layer_idx)\n+\n+\n+class Glm4vMoePreTrainedModel(Glm4MoePreTrainedModel):\n+    config: Glm4vMoeConfig\n+    base_model_prefix = \"\"\n+    _no_split_modules = [\"Glm4vMoeTextDecoderLayer\", \"Glm4vMoeVisionBlock\"]\n+    _skip_keys_device_placement = \"past_key_values\"\n+\n+    _can_record_outputs = {\n+        \"hidden_states\": Glm4vMoeTextDecoderLayer,\n+        \"attentions\": Glm4vMoeTextAttention,\n+    }\n+\n+\n+class Glm4vMoeForConditionalGeneration(Glm4vForConditionalGeneration):\n+    pass\n+\n+\n+__all__ = [\n+    \"Glm4vMoeConfig\",\n+    \"Glm4vMoeTextConfig\",\n+    \"Glm4vMoeForConditionalGeneration\",\n+    \"Glm4vMoeModel\",  # noqa: F822\n+    \"Glm4vMoePreTrainedModel\",\n+    \"Glm4vMoeTextModel\",  # noqa: F822\n+]"
        },
        {
            "sha": "59631fb37228a9d5ad35786c0fe7c05281fc84f0",
            "filename": "tests/models/glm4_moe/test_modeling_glm4_moe.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/tests%2Fmodels%2Fglm4_moe%2Ftest_modeling_glm4_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/tests%2Fmodels%2Fglm4_moe%2Ftest_modeling_glm4_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fglm4_moe%2Ftest_modeling_glm4_moe.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -107,9 +107,9 @@ def test_compile_static_cache(self):\n         ]\n \n         prompts = [\"[gMASK]<sop>hello\", \"[gMASK]<sop>tell me\"]\n-        tokenizer = AutoTokenizer.from_pretrained(\"THUDM/GLM-4.5\")\n+        tokenizer = AutoTokenizer.from_pretrained(\"zai-org/GLM-4.5\")\n         model = Glm4MoeForCausalLM.from_pretrained(\n-            \"THUDM/GLM-4.5\", device_map=torch_device, torch_dtype=torch.bfloat16\n+            \"zai-org/GLM-4.5\", device_map=torch_device, torch_dtype=torch.bfloat16\n         )\n         inputs = tokenizer(prompts, return_tensors=\"pt\", padding=True).to(model.device)\n "
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/glm4v_moe/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/tests%2Fmodels%2Fglm4v_moe%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/tests%2Fmodels%2Fglm4v_moe%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fglm4v_moe%2F__init__.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b"
        },
        {
            "sha": "ed1bd4c88c70d53e0f793fb1c84f4994a6d95d21",
            "filename": "tests/models/glm4v_moe/test_modeling_glm4v_moe.py",
            "status": "added",
            "additions": 568,
            "deletions": 0,
            "changes": 568,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/tests%2Fmodels%2Fglm4v_moe%2Ftest_modeling_glm4v_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/tests%2Fmodels%2Fglm4v_moe%2Ftest_modeling_glm4v_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fglm4v_moe%2Ftest_modeling_glm4v_moe.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -0,0 +1,568 @@\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch GLM-4.1V model.\"\"\"\n+\n+import copy\n+import gc\n+import unittest\n+\n+from transformers import (\n+    AutoProcessor,\n+    Glm4vMoeConfig,\n+    Glm4vMoeForConditionalGeneration,\n+    Glm4vMoeModel,\n+    is_torch_available,\n+)\n+from transformers.testing_utils import (\n+    require_flash_attn,\n+    require_torch,\n+    require_torch_gpu,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import (\n+    ModelTesterMixin,\n+    floats_tensor,\n+    ids_tensor,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+class Glm4vMoeVisionText2TextModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=3,\n+        seq_length=7,\n+        num_channels=3,\n+        ignore_index=-100,\n+        image_size=112,\n+        video_start_token_id=3,\n+        video_end_token_id=4,\n+        image_start_token_id=5,\n+        image_end_token_id=6,\n+        image_token_id=7,\n+        video_token_id=8,\n+        is_training=True,\n+        text_config={\n+            \"vocab_size\": 99,\n+            \"hidden_size\": 16,\n+            \"intermediate_size\": 22,\n+            \"num_hidden_layers\": 2,\n+            \"num_attention_heads\": 2,\n+            \"num_key_value_heads\": 1,\n+            \"output_channels\": 64,\n+            \"hidden_act\": \"silu\",\n+            \"max_position_embeddings\": 512,\n+            \"rope_scaling\": {\"type\": \"default\", \"mrope_section\": [1, 1]},\n+            \"rope_theta\": 10000,\n+            \"tie_word_embeddings\": True,\n+            \"bos_token_id\": 0,\n+            \"eos_token_id\": 0,\n+            \"pad_token_id\": 0,\n+            \"n_routed_experts\": 8,\n+            \"n_shared_experts\": 1,\n+            \"n_group\": 1,\n+            \"topk_group\": 1,\n+            \"num_experts_per_tok\": 8,\n+        },\n+        vision_config={\n+            \"depth\": 2,\n+            \"hidden_act\": \"silu\",\n+            \"hidden_size\": 48,\n+            \"out_hidden_size\": 16,\n+            \"intermediate_size\": 22,\n+            \"patch_size\": 14,\n+            \"spatial_merge_size\": 1,\n+            \"temporal_patch_size\": 2,\n+        },\n+    ):\n+        self.parent = parent\n+        self.ignore_index = ignore_index\n+        self.bos_token_id = text_config[\"bos_token_id\"]\n+        self.eos_token_id = text_config[\"eos_token_id\"]\n+        self.pad_token_id = text_config[\"pad_token_id\"]\n+        self.video_start_token_id = video_start_token_id\n+        self.video_end_token_id = video_end_token_id\n+        self.image_start_token_id = image_start_token_id\n+        self.image_end_token_id = image_end_token_id\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.text_config = text_config\n+        self.vision_config = vision_config\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.image_size = image_size\n+        self.is_training = is_training\n+        self.hidden_size = text_config[\"hidden_size\"]\n+        self.num_hidden_layers = text_config[\"num_hidden_layers\"]\n+        self.num_attention_heads = text_config[\"num_attention_heads\"]\n+        self.vocab_size = text_config[\"vocab_size\"]\n+        self.num_image_tokens = 64\n+        self.seq_length = seq_length + self.num_image_tokens\n+        self.n_routed_experts = text_config[\"n_routed_experts\"]\n+        self.n_shared_experts = text_config[\"n_shared_experts\"]\n+        self.num_experts_per_tok = text_config[\"num_experts_per_tok\"]\n+        self.n_group = text_config[\"n_group\"]\n+        self.topk_group = text_config[\"topk_group\"]\n+\n+    def get_config(self):\n+        return Glm4vMoeConfig(\n+            text_config=self.text_config,\n+            vision_config=self.vision_config,\n+            image_token_id=self.image_token_id,\n+            video_token_id=self.video_token_id,\n+            video_start_token_id=self.video_start_token_id,\n+            video_end_token_id=self.video_end_token_id,\n+            image_start_token_id=self.image_start_token_id,\n+            image_end_token_id=self.image_end_token_id,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        config = self.get_config()\n+        patch_size = config.vision_config.patch_size\n+        temporal_patch_size = config.vision_config.temporal_patch_size\n+        pixel_values = floats_tensor(\n+            [\n+                self.batch_size * (self.image_size**2) // (patch_size**2),\n+                self.num_channels * (patch_size**2) * temporal_patch_size,\n+            ]\n+        )\n+\n+        return config, pixel_values\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], self.vocab_size)\n+        attention_mask = torch.ones(input_ids.shape, dtype=torch.long, device=torch_device)\n+\n+        input_ids[input_ids == self.video_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.video_start_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_start_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.video_end_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_end_token_id] = self.pad_token_id\n+\n+        input_ids[:, 0] = self.image_start_token_id\n+        input_ids[:, 1 : 1 + self.num_image_tokens] = self.image_token_id\n+        input_ids[:, 1 + self.num_image_tokens] = self.image_end_token_id\n+        patch_size = config.vision_config.patch_size\n+        patches_per_side = self.image_size // patch_size\n+\n+        inputs_dict = {\n+            \"pixel_values\": pixel_values,\n+            \"image_grid_thw\": torch.tensor([[1, patches_per_side, patches_per_side]] * self.batch_size),\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+        }\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class Glm4vMoeModelTest(ModelTesterMixin, GenerationTesterMixin, unittest.TestCase):\n+    all_model_classes = (Glm4vMoeModel, Glm4vMoeForConditionalGeneration) if is_torch_available() else ()\n+    test_pruning = False\n+    test_head_masking = False\n+    test_torchscript = False\n+    model_split_percents = [0.7, 0.9]  # model too big to split at 0.5\n+    _is_composite = True\n+\n+    def setUp(self):\n+        self.model_tester = Glm4vMoeVisionText2TextModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Glm4vMoeConfig, has_text_modality=False)\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    # Glm4vMoe has images shaped as (bs*patch_len, dim) so we can't slice to batches in generate\n+    def prepare_config_and_inputs_for_generate(self, batch_size=2):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        # We don't want a few model inputs in our model input dictionary for generation tests\n+        input_keys_to_ignore = [\n+            # we don't want to mask attention heads\n+            \"head_mask\",\n+            \"decoder_head_mask\",\n+            \"cross_attn_head_mask\",\n+            # we don't want encoder-decoder models to start from filled decoder ids\n+            \"decoder_input_ids\",\n+            \"decoder_attention_mask\",\n+            # we'll set cache use in each test differently\n+            \"use_cache\",\n+            # Ignore labels if it is in the input dict\n+            \"labels\",\n+            # model-specific exceptions should overload/overwrite this function\n+        ]\n+\n+        # The diff from the general `prepare_config_and_inputs_for_generate` lies here\n+        patch_size = config.vision_config.patch_size\n+        filtered_image_length = batch_size * (self.model_tester.image_size**2) // (patch_size**2)\n+        filtered_inputs_dict = {\n+            k: v[:batch_size, ...] if isinstance(v, torch.Tensor) else v\n+            for k, v in inputs_dict.items()\n+            if k not in input_keys_to_ignore\n+        }\n+        filtered_inputs_dict[\"pixel_values\"] = inputs_dict[\"pixel_values\"][:filtered_image_length]\n+\n+        # It is important set `eos_token_id` to `None` to avoid early stopping (would break for length-based checks)\n+        text_gen_config = config.get_text_config(decoder=True)\n+        if text_gen_config.eos_token_id is not None and text_gen_config.pad_token_id is None:\n+            text_gen_config.pad_token_id = (\n+                text_gen_config.eos_token_id\n+                if isinstance(text_gen_config.eos_token_id, int)\n+                else text_gen_config.eos_token_id[0]\n+            )\n+        text_gen_config.eos_token_id = None\n+        text_gen_config.forced_eos_token_id = None\n+\n+        return config, filtered_inputs_dict\n+\n+    @unittest.skip(reason=\"No available kernels - not supported\")\n+    def test_sdpa_can_dispatch_on_flash(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Size mismatch\")\n+    def test_multi_gpu_data_parallel_forward(self):\n+        pass\n+\n+    @unittest.skip(\"GLM4's moe is not compatible `token_indices, weight_indices = torch.where(mask)`.\")\n+    def test_generate_compilation_all_outputs(self):\n+        pass\n+\n+    @unittest.skip(\"Error with compilation\")\n+    def test_generate_from_inputs_embeds_with_static_cache(self):\n+        pass\n+\n+    def test_inputs_embeds(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            inputs = copy.deepcopy(self._prepare_for_class(inputs_dict, model_class))\n+\n+            input_ids = inputs[\"input_ids\"]\n+            del inputs[\"input_ids\"]\n+            del inputs[\"pixel_values\"]\n+            del inputs[\"image_grid_thw\"]\n+\n+            wte = model.get_input_embeddings()\n+            inputs[\"inputs_embeds\"] = wte(input_ids)\n+            with torch.no_grad():\n+                model(**inputs)[0]\n+\n+    def test_inputs_embeds_matches_input_ids(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            inputs = self._prepare_for_class(inputs_dict, model_class)\n+            input_ids = inputs[\"input_ids\"]\n+            del inputs[\"input_ids\"]\n+            del inputs[\"pixel_values\"]\n+            del inputs[\"image_grid_thw\"]\n+\n+            inputs_embeds = model.get_input_embeddings()(input_ids)\n+\n+            with torch.no_grad():\n+                out_ids = model(input_ids=input_ids, **inputs)[0]\n+                out_embeds = model(inputs_embeds=inputs_embeds, **inputs)[0]\n+            torch.testing.assert_close(out_embeds, out_ids)\n+\n+\n+@require_torch\n+class Glm4vMoeIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = AutoProcessor.from_pretrained(\"zai-org/GLM-4.5V\")\n+        self.message = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"image\",\n+                        \"url\": \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/pipeline-cat-chonk.jpeg\",\n+                    },\n+                    {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+                ],\n+            }\n+        ]\n+        self.message2 = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"image\",\n+                        \"url\": \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/coco_sample.png\",\n+                    },\n+                    {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+                ],\n+            }\n+        ]\n+\n+    def tearDown(self):\n+        gc.collect()\n+        torch.cuda.empty_cache()\n+\n+    @slow\n+    def test_small_model_integration_test(self):\n+        model = Glm4vMoeForConditionalGeneration.from_pretrained(\n+            \"zai-org/GLM-4.5V\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+\n+        inputs = self.processor.apply_chat_template(\n+            self.message, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\"\n+        )\n+        expected_input_ids = [151331, 151333, 151336, 198, 151339, 151343, 151343, 151343, 151343, 151343, 151343, 151343, 151343, 151343, 151343, 151343, 151343]  # fmt: skip\n+        assert expected_input_ids == inputs.input_ids[0].tolist()[:17]\n+\n+        expected_pixel_slice = torch.tensor(\n+            [\n+                [-0.0988, -0.0842, -0.0842],\n+                [-0.5660, -0.5514, -0.4200],\n+                [-0.0259, -0.0259, -0.0259],\n+                [-0.1280, -0.0988, -0.2010],\n+                [-0.4638, -0.5806, -0.6974],\n+                [-1.2083, -1.2229, -1.2083],\n+            ],\n+            dtype=torch.float32,\n+            device=\"cpu\",\n+        )\n+        assert torch.allclose(expected_pixel_slice, inputs.pixel_values[:6, :3], atol=3e-3)\n+\n+        # verify generation\n+        inputs = inputs.to(torch_device)\n+\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        EXPECTED_DECODED_TEXT = \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture is not a dog; it's a cat. Specifically, it looks\"\n+        self.assertEqual(\n+            self.processor.decode(output[0], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_batch(self):\n+        model = Glm4vMoeForConditionalGeneration.from_pretrained(\n+            \"zai-org/GLM-4.5V\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+        batch_messages = [self.message] * 2\n+        inputs = self.processor.apply_chat_template(\n+            batch_messages, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(torch_device)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture is not a dog; it's a cat. Specifically, it looks\",\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture is not a dog; it's a cat. Specifically, it looks\"\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_with_video(self):\n+        processor = AutoProcessor.from_pretrained(\"zai-org/GLM-4.5V\", max_image_size={\"longest_edge\": 50176})\n+        model = Glm4vMoeForConditionalGeneration.from_pretrained(\n+            \"zai-org/GLM-4.5V\", torch_dtype=torch.float16, device_map=\"auto\"\n+        )\n+        questions = [\"Describe this video.\"] * 2\n+        video_urls = [\n+            \"https://huggingface.co/datasets/hf-internal-testing/fixtures_videos/resolve/main/tennis.mp4\"\n+        ] * 2\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\n+                            \"type\": \"video\",\n+                            \"video\": video_url,\n+                        },\n+                        {\"type\": \"text\", \"text\": question},\n+                    ],\n+                }\n+            ]\n+            for question, video_url in zip(questions, video_urls)\n+        ]\n+        inputs = processor.apply_chat_template(\n+            messages, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\", padding=True\n+        ).to(torch_device)\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        EXPECTED_DECODED_TEXT = [\n+            \"\\n012345Describe this video.\\n<think>Got it, let's analyze the video. First, the scene is a room with a wooden floor, maybe a traditional Japanese room with tatami\",\n+            \"\\n012345Describe this video.\\n<think>Got it, let's analyze the video. First, the scene is a room with a wooden floor, maybe a traditional Japanese room with tatami\"\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_expand(self):\n+        model = Glm4vMoeForConditionalGeneration.from_pretrained(\n+            \"zai-org/GLM-4.5V\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+        inputs = self.processor.apply_chat_template(\n+            self.message, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(torch_device)\n+\n+        output = model.generate(**inputs, max_new_tokens=30, do_sample=False, num_beams=2, num_return_sequences=2)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture doesn't look like a dog; it's actually a cat. Specifically\",\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture doesn't look like a dog; it's actually a cat, specifically\"\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_batch_wo_image(self):\n+        model = Glm4vMoeForConditionalGeneration.from_pretrained(\n+            \"zai-org/GLM-4.5V\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+        message_wo_image = [\n+            {\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"Who are you?\"}]},\n+        ]\n+        batched_messages = [self.message, message_wo_image]\n+        inputs = self.processor.apply_chat_template(\n+            batched_messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture is not a dog; it's a cat. Specifically, it looks\",\n+            '\\nWho are you?\\n<think>Got it, the user is asking \"Who are you?\" I need to respond appropriately. First, I should clarify that I\\'m an AI assistant'\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_batch_different_resolutions(self):\n+        model = Glm4vMoeForConditionalGeneration.from_pretrained(\n+            \"zai-org/GLM-4.5V\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+        batched_messages = [self.message, self.message2]\n+        inputs = self.processor.apply_chat_template(\n+            batched_messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture is not a dog; it's a cat. Specifically, it looks\",\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. Wait, the animals here are cats, not dogs. The question is about a dog, but\"\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    @require_flash_attn\n+    @require_torch_gpu\n+    def test_small_model_integration_test_batch_flashatt2(self):\n+        model = Glm4vMoeForConditionalGeneration.from_pretrained(\n+            \"zai-org/GLM-4.5V\",\n+            torch_dtype=torch.bfloat16,\n+            attn_implementation=\"flash_attention_2\",\n+            device_map=\"auto\",\n+        )\n+        batched_messages = [self.message, self.message2]\n+        inputs = self.processor.apply_chat_template(\n+            batched_messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture has a stocky build, thick fur, and a face that's\",\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. Wait, the animals here are cats, not dogs. The question is about a dog, but\"\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    @require_flash_attn\n+    @require_torch_gpu\n+    def test_small_model_integration_test_batch_wo_image_flashatt2(self):\n+        model = Glm4vMoeForConditionalGeneration.from_pretrained(\n+            \"zai-org/GLM-4.5V\",\n+            torch_dtype=torch.bfloat16,\n+            attn_implementation=\"flash_attention_2\",\n+            device_map=\"auto\",\n+        )\n+        message_wo_image = [\n+            {\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"Who are you?\"}]},\n+        ]\n+        batched_messages = [self.message, message_wo_image]\n+        inputs = self.processor.apply_chat_template(\n+            batched_messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture is not a dog; it's a cat. Specifically, it looks\",\n+            '\\nWho are you?\\n<think>Got it, let\\'s look at the question. The user is asking \"Who are you?\" which is a common question when someone meets an AI'\n+        ]  # fmt: skip\n+\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )"
        },
        {
            "sha": "2a0f068f16f7fc9584ae0610901be1fb7316c008",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/7b20915f4e36a801873a26351b8b030c4d8d7b3b/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7b20915f4e36a801873a26351b8b030c4d8d7b3b/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=7b20915f4e36a801873a26351b8b030c4d8d7b3b",
            "patch": "@@ -92,6 +92,7 @@\n     \"Phi4MultimodalAudioModel\",\n     \"Phi4MultimodalVisionModel\",\n     \"Glm4vVisionModel\",\n+    \"Glm4vMoeVisionModel\",\n     \"EvollaSaProtPreTrainedModel\",\n ]\n \n@@ -158,6 +159,7 @@\n         \"Emu3VQVAE\",  # Building part of bigger (tested) model\n         \"Emu3TextModel\",  # Building part of bigger (tested) model\n         \"Glm4vTextModel\",  # Building part of bigger (tested) model\n+        \"Glm4vMoeTextModel\",  # Building part of bigger (tested) model\n         \"Qwen2VLTextModel\",  # Building part of bigger (tested) model\n         \"Qwen2_5_VLTextModel\",  # Building part of bigger (tested) model\n         \"InternVLVisionModel\",  # Building part of bigger (tested) model"
        }
    ],
    "stats": {
        "total": 4083,
        "additions": 3635,
        "deletions": 448
    }
}