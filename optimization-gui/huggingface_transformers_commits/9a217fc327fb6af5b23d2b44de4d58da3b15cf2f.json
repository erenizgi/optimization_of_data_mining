{
    "author": "aymeric-roucher",
    "message": "Deprecate transformers.agents (#36415)",
    "sha": "9a217fc327fb6af5b23d2b44de4d58da3b15cf2f",
    "files": [
        {
            "sha": "59c99df04478447de2d632ff7082993640a609ee",
            "filename": "docs/source/en/agents.md",
            "status": "modified",
            "additions": 1,
            "deletions": 413,
            "changes": 414,
            "blob_url": "https://github.com/huggingface/transformers/blob/9a217fc327fb6af5b23d2b44de4d58da3b15cf2f/docs%2Fsource%2Fen%2Fagents.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/9a217fc327fb6af5b23d2b44de4d58da3b15cf2f/docs%2Fsource%2Fen%2Fagents.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fagents.md?ref=9a217fc327fb6af5b23d2b44de4d58da3b15cf2f",
            "patch": "@@ -15,417 +15,5 @@ rendered properly in your Markdown viewer.\n -->\n # Agents and tools\n \n-[[open-in-colab]]\n-\n-### What is an agent?\n-\n-Large Language Models (LLMs) trained to perform [causal language modeling](./tasks/language_modeling) can tackle a wide range of tasks, but they often struggle with basic tasks like logic, calculation, and search. When prompted in domains in which they do not perform well, they often fail to generate the answer we expect them to.\n-\n-One approach to overcome this weakness is to create an *agent*.\n-\n-An agent is a system that uses an LLM as its engine, and it has access to functions called *tools*.\n-\n-These *tools* are functions for performing a task, and they contain all necessary description for the agent to properly use them.\n-\n-The agent can be programmed to:\n-- devise a series of actions/tools and run them all at once,  like the [`CodeAgent`]\n-- plan and execute actions/tools one by one and wait for the outcome of each action before launching the next one, like the [`ReactJsonAgent`]\n-\n-### Types of agents\n-\n-#### Code agent\n-\n-This agent has a planning step, then generates python code to execute all its actions at once. It natively handles different input and output types for its tools, thus it is the recommended choice for multimodal tasks.\n-\n-#### React agents\n-\n-This is the go-to agent to solve reasoning tasks, since the ReAct framework ([Yao et al., 2022](https://huggingface.co/papers/2210.03629)) makes it really efficient to think on the basis of its previous observations.\n-\n-We implement two versions of ReactJsonAgent: \n-- [`ReactJsonAgent`] generates tool calls as a JSON in its output.\n-- [`ReactCodeAgent`] is a new type of ReactJsonAgent that generates its tool calls as blobs of code, which works really well for LLMs that have strong coding performance.\n-\n-> [!TIP]\n-> Read [Open-source LLMs as LangChain Agents](https://huggingface.co/blog/open-source-llms-as-agents) blog post to learn more about ReAct agents.\n-\n-<div class=\"flex justify-center\">\n-    <img\n-        class=\"block dark:hidden\"\n-        src=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/Agent_ManimCE.gif\"\n-    />\n-    <img\n-        class=\"hidden dark:block\"\n-        src=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/Agent_ManimCE.gif\"\n-    />\n-</div>\n-\n-![Framework of a React Agent](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/open-source-llms-as-agents/ReAct.png)\n-\n-For example, here is how a ReAct Code agent would work its way through the following question.\n-\n-```py3\n->>> agent.run(\n-...     \"How many more blocks (also denoted as layers) in BERT base encoder than the encoder from the architecture proposed in Attention is All You Need?\",\n-... )\n-=====New task=====\n-How many more blocks (also denoted as layers) in BERT base encoder than the encoder from the architecture proposed in Attention is All You Need?\n-====Agent is executing the code below:\n-bert_blocks = search(query=\"number of blocks in BERT base encoder\")\n-print(\"BERT blocks:\", bert_blocks)\n-====\n-Print outputs:\n-BERT blocks: twelve encoder blocks\n-\n-====Agent is executing the code below:\n-attention_layer = search(query=\"number of layers in Attention is All You Need\")\n-print(\"Attention layers:\", attention_layer)\n-====\n-Print outputs:\n-Attention layers: Encoder: The encoder is composed of a stack of N = 6 identical layers. Each layer has two sub-layers. The first is a multi-head self-attention mechanism, and the second is a simple, position- 2 Page 3 Figure 1: The Transformer - model architecture.\n-\n-====Agent is executing the code below:\n-bert_blocks = 12\n-attention_layers = 6\n-diff = bert_blocks - attention_layers\n-print(\"Difference in blocks:\", diff)\n-final_answer(diff)\n-====\n-\n-Print outputs:\n-Difference in blocks: 6\n-\n-Final answer: 6\n-```\n-\n-### How can I build an agent?\n-\n-To initialize an agent, you need these arguments:\n-\n-- an LLM to power your agent - the agent is not exactly the LLM, it‚Äôs more like the agent is a program that uses an LLM as its engine.\n-- a system prompt: what the LLM engine will be prompted with to generate its output\n-- a toolbox from which the agent pick tools to execute\n-- a parser to extract from the LLM output which tools are to call and with which arguments\n-\n-Upon initialization of the agent system, the tool attributes are used to generate a tool description, then baked into the agent‚Äôs `system_prompt` to let it know which tools it can use and why.\n-\n-To start with, please install the `agents` extras in order to install all default dependencies.\n-\n-```bash\n-pip install transformers[agents]\n-```\n-\n-Build your LLM engine by defining a `llm_engine` method which accepts a list of [messages](./chat_templating) and returns text. This callable also needs to accept a `stop` argument that indicates when to stop generating.\n-\n-```python\n-from huggingface_hub import login, InferenceClient\n-\n-login(\"<YOUR_HUGGINGFACEHUB_API_TOKEN>\")\n-\n-client = InferenceClient(model=\"meta-llama/Meta-Llama-3-70B-Instruct\")\n-\n-def llm_engine(messages, stop_sequences=[\"Task\"]) -> str:\n-    response = client.chat_completion(messages, stop=stop_sequences, max_tokens=1000)\n-    answer = response.choices[0].message.content\n-    return answer\n-```\n-\n-You could use any `llm_engine` method as long as:\n-1. it follows the [messages format](./chat_templating) (`List[Dict[str, str]]`) for its input `messages`, and it returns a `str`.\n-2. it stops generating outputs at the sequences passed in the argument `stop_sequences`\n-\n-Additionally, `llm_engine` can also take a `grammar` argument. In the case where you specify a `grammar` upon agent initialization, this argument will be passed to the calls to llm_engine, with the `grammar` that you defined upon initialization, to allow [constrained generation](https://huggingface.co/docs/text-generation-inference/conceptual/guidance) in order to force properly-formatted agent outputs.\n-\n-You will also need a `tools` argument which accepts a list of `Tools` - it can be an empty list. You can also add the default toolbox on top of your `tools` list by defining the optional argument `add_base_tools=True`.\n-\n-Now you can create an agent, like [`CodeAgent`], and run it. You can also create a [`TransformersEngine`] with a pre-initialized pipeline to run inference on your local machine using `transformers`.\n-For convenience, since agentic behaviours generally require stronger models such as `Llama-3.1-70B-Instruct` that are harder to run locally for now, we also provide the [`HfApiEngine`] class that initializes a `huggingface_hub.InferenceClient` under the hood. \n-\n-```python\n-from transformers import CodeAgent, HfApiEngine\n-\n-llm_engine = HfApiEngine(model=\"meta-llama/Meta-Llama-3-70B-Instruct\")\n-agent = CodeAgent(tools=[], llm_engine=llm_engine, add_base_tools=True)\n-\n-agent.run(\n-    \"Could you translate this sentence from French, say it out loud and return the audio.\",\n-    sentence=\"O√π est la boulangerie la plus proche?\",\n-)\n-```\n-\n-This will be handy in case of emergency baguette need!\n-You can even leave the argument `llm_engine` undefined, and an [`HfApiEngine`] will be created by default.\n-\n-```python\n-from transformers import CodeAgent\n-\n-agent = CodeAgent(tools=[], add_base_tools=True)\n-\n-agent.run(\n-    \"Could you translate this sentence from French, say it out loud and give me the audio.\",\n-    sentence=\"O√π est la boulangerie la plus proche?\",\n-)\n-```\n-\n-Note that we used an additional `sentence` argument: you can pass text as additional arguments to the model.\n-\n-You can also use this to indicate the path to local or remote files for the model to use:\n-\n-```py\n-from transformers import ReactCodeAgent\n-\n-agent = ReactCodeAgent(tools=[], llm_engine=llm_engine, add_base_tools=True)\n-\n-agent.run(\"Why does Mike not know many people in New York?\", audio=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/recording.mp3\")\n-```\n-\n-\n-The prompt and output parser were automatically defined, but you can easily inspect them by calling the `system_prompt_template` on your agent.\n-\n-```python\n-print(agent.system_prompt_template)\n-```\n-\n-It's important to explain as clearly as possible the task you want to perform.\n-Every [`~Agent.run`] operation is independent, and since an agent is powered by an LLM, minor variations in your prompt might yield completely different results.\n-You can also run an agent consecutively for different tasks: each time the attributes `agent.task` and `agent.logs` will be re-initialized.\n-\n-\n-#### Code execution\n-\n-A Python interpreter executes the code on a set of inputs passed along with your tools.\n-This should be safe because the only functions that can be called are the tools you provided (especially if it's only tools by Hugging Face) and the print function, so you're already limited in what can be executed.\n-\n-The Python interpreter also doesn't allow imports by default outside of a safe list, so all the most obvious attacks shouldn't be an issue.\n-You can still authorize additional imports by passing the authorized modules as a list of strings in argument `additional_authorized_imports` upon initialization of your [`ReactCodeAgent`] or [`CodeAgent`]:\n-\n-```py\n->>> from transformers import ReactCodeAgent\n-\n->>> agent = ReactCodeAgent(tools=[], additional_authorized_imports=['requests', 'bs4'])\n->>> agent.run(\"Could you get me the title of the page at url 'https://huggingface.co/blog'?\")\n-\n-(...)\n-'Hugging Face ‚Äì Blog'\n-```\n-\n-The execution will stop at any code trying to perform an illegal operation or if there is a regular Python error with the code generated by the agent.\n-\n-> [!WARNING]\n-> The LLM can generate arbitrary code that will then be executed: do not add any unsafe imports!\n-\n-### The system prompt\n-\n-An agent, or rather the LLM that drives the agent, generates an output based on the system prompt. The system prompt can be customized and tailored to the intended task. For example, check the system prompt for the [`ReactCodeAgent`] (below version is slightly simplified).\n-\n-```text\n-You will be given a task to solve as best you can.\n-You have access to the following tools:\n-<<tool_descriptions>>\n-\n-To solve the task, you must plan forward to proceed in a series of steps, in a cycle of 'Thought:', 'Code:', and 'Observation:' sequences.\n-\n-At each step, in the 'Thought:' sequence, you should first explain your reasoning towards solving the task, then the tools that you want to use.\n-Then in the 'Code:' sequence, you should write the code in simple Python. The code sequence must end with '/End code' sequence.\n-During each intermediate step, you can use 'print()' to save whatever important information you will then need.\n-These print outputs will then be available in the 'Observation:' field, for using this information as input for the next step.\n-\n-In the end you have to return a final answer using the `final_answer` tool.\n-\n-Here are a few examples using notional tools:\n----\n-{examples}\n-\n-Above example were using notional tools that might not exist for you. You only have acces to those tools:\n-<<tool_names>>\n-You also can perform computations in the python code you generate.\n-\n-Always provide a 'Thought:' and a 'Code:\\n```py' sequence ending with '```<end_code>' sequence. You MUST provide at least the 'Code:' sequence to move forward.\n-\n-Remember to not perform too many operations in a single code block! You should split the task into intermediate code blocks.\n-Print results at the end of each step to save the intermediate results. Then use final_answer() to return the final result.\n-\n-Remember to make sure that variables you use are all defined.\n-\n-Now Begin!\n-```\n-\n-The system prompt includes:\n-- An *introduction* that explains how the agent should behave and what tools are.\n-- A description of all the tools that is defined by a `<<tool_descriptions>>` token that is dynamically replaced at runtime with the tools defined/chosen by the user.\n-    - The tool description comes from the tool attributes, `name`, `description`, `inputs` and `output_type`,  and a simple `jinja2` template that you can refine.\n-- The expected output format.\n-\n-You could improve the system prompt, for example, by adding an explanation of the output format.\n-\n-For maximum flexibility, you can overwrite the whole system prompt template by passing your custom prompt as an argument to the `system_prompt` parameter.\n-\n-```python\n-from transformers import ReactJsonAgent\n-from transformers.agents import PythonInterpreterTool\n-\n-agent = ReactJsonAgent(tools=[PythonInterpreterTool()], system_prompt=\"{your_custom_prompt}\")\n-```\n-\n > [!WARNING]\n-> Please make sure to define the `<<tool_descriptions>>` string somewhere in the `template` so the agent is aware \n-of the available tools.\n-\n-\n-### Inspecting an agent run\n-\n-Here are a few useful attributes to inspect what happened after a run:\n-- `agent.logs` stores the fine-grained logs of the agent. At every step of the agent's run, everything gets stored in a dictionary that then is appended to `agent.logs`.\n-- Running `agent.write_inner_memory_from_logs()` creates an inner memory of the agent's logs for the LLM to view, as a list of chat messages. This method goes over each step of the log and only stores what it's interested in as a message: for instance, it will save the system prompt and task in separate messages, then for each step it will store the LLM output as a message, and the tool call output as another message. Use this if you want a higher-level view of what has happened - but not every log will be transcripted by this method.\n-\n-## Tools\n-\n-A tool is an atomic function to be used by an agent.\n-\n-You can for instance check the [`PythonInterpreterTool`]: it has a name, a description, input descriptions, an output type, and a `__call__` method to perform the action.\n-\n-When the agent is initialized, the tool attributes are used to generate a tool description which is baked into the agent's system prompt. This lets the agent know which tools it can use and why.\n-\n-### Default toolbox\n-\n-Transformers comes with a default toolbox for empowering agents, that you can add to your agent upon initialization with argument `add_base_tools = True`:\n-\n-- **Document question answering**: given a document (such as a PDF) in image format, answer a question on this document ([Donut](./model_doc/donut))\n-- **Image question answering**: given an image, answer a question on this image ([VILT](./model_doc/vilt))\n-- **Speech to text**: given an audio recording of a person talking, transcribe the speech into text ([Whisper](./model_doc/whisper))\n-- **Text to speech**: convert text to speech ([SpeechT5](./model_doc/speecht5))\n-- **Translation**: translates a given sentence from source language to target language.\n-- **DuckDuckGo search***: performs a web search using DuckDuckGo browser.\n-- **Python code interpreter**: runs your the LLM generated Python code in a secure environment. This tool will only be added to [`ReactJsonAgent`] if you initialize it with `add_base_tools=True`, since code-based agent can already natively execute Python code\n-\n-\n-You can manually use a tool by calling the [`load_tool`] function and a task to perform.\n-\n-\n-```python\n-from transformers import load_tool\n-\n-tool = load_tool(\"text-to-speech\")\n-audio = tool(\"This is a text to speech tool\")\n-```\n-\n-\n-### Create a new tool\n-\n-You can create your own tool for use cases not covered by the default tools from Hugging Face.\n-For example, let's create a tool that returns the most downloaded model for a given task from the Hub.\n-\n-You'll start with the code below.\n-\n-```python\n-from huggingface_hub import list_models\n-\n-task = \"text-classification\"\n-\n-model = next(iter(list_models(filter=task, sort=\"downloads\", direction=-1)))\n-print(model.id)\n-```\n-\n-This code can quickly be converted into a tool, just by wrapping it in a function and adding the `tool` decorator:\n-\n-\n-```py\n-from transformers import tool\n-\n-@tool\n-def model_download_tool(task: str) -> str:\n-    \"\"\"\n-    This is a tool that returns the most downloaded model of a given task on the Hugging Face Hub.\n-    It returns the name of the checkpoint.\n-\n-    Args:\n-        task: The task for which\n-    \"\"\"\n-    model = next(iter(list_models(filter=\"text-classification\", sort=\"downloads\", direction=-1)))\n-    return model.id\n-```\n-\n-The function needs:\n-- A clear name. The name usually describes what the tool does. Since the code returns the model with the most downloads for a task, let's put `model_download_tool`.\n-- Type hints on both inputs and output\n-- A description, that includes an 'Args:' part where each argument is described (without a type indication this time, it will be pulled from the type hint).\n-All these will be automatically baked into the agent's system prompt upon initialization: so strive to make them as clear as possible!\n-\n-> [!TIP]\n-> This definition format is the same as tool schemas used in `apply_chat_template`, the only difference is the added `tool` decorator: read more on our tool use API [here](https://huggingface.co/blog/unified-tool-use#passing-tools-to-a-chat-template).\n-\n-Then you can directly initialize your agent:\n-```py\n-from transformers import CodeAgent\n-agent = CodeAgent(tools=[model_download_tool], llm_engine=llm_engine)\n-agent.run(\n-    \"Can you give me the name of the model that has the most downloads in the 'text-to-video' task on the Hugging Face Hub?\"\n-)\n-```\n-\n-You get the following:\n-```text\n-======== New task ========\n-Can you give me the name of the model that has the most downloads in the 'text-to-video' task on the Hugging Face Hub?\n-==== Agent is executing the code below:\n-most_downloaded_model = model_download_tool(task=\"text-to-video\")\n-print(f\"The most downloaded model for the 'text-to-video' task is {most_downloaded_model}.\")\n-====\n-```\n-\n-And the output:\n-`\"The most downloaded model for the 'text-to-video' task is ByteDance/AnimateDiff-Lightning.\"`\n-\n-### Manage your agent's toolbox\n-\n-If you have already initialized an agent, it is inconvenient to reinitialize it from scratch with a tool you want to use. With Transformers, you can manage an agent's toolbox by adding or replacing a tool.\n-\n-Let's add the `model_download_tool` to an existing agent initialized with only the default toolbox.\n-\n-```python\n-from transformers import CodeAgent\n-\n-agent = CodeAgent(tools=[], llm_engine=llm_engine, add_base_tools=True)\n-agent.toolbox.add_tool(model_download_tool)\n-```\n-Now we can leverage both the new tool and the previous text-to-speech tool:\n-\n-```python\n-agent.run(\n-    \"Can you read out loud the name of the model that has the most downloads in the 'text-to-video' task on the Hugging Face Hub and return the audio?\"\n-)\n-```\n-\n-\n-| **Audio**                                                                                                                                            |\n-|------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| <audio controls><source src=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/damo.wav\" type=\"audio/wav\"/> |\n-\n-\n-> [!WARNING]\n-> Beware when adding tools to an agent that already works well because it can bias selection towards your tool or select another tool other than the one already defined.\n-\n-\n-Use the `agent.toolbox.update_tool()` method to replace an existing tool in the agent's toolbox.\n-This is useful if your new tool is a one-to-one replacement of the existing tool because the agent already knows how to perform that specific task.\n-Just make sure the new tool follows the same API as the replaced tool or adapt the system prompt template to ensure all examples using the replaced tool are updated.\n-\n-\n-### Use a collection of tools\n-\n-You can leverage tool collections by using the ToolCollection object, with the slug of the collection you want to use.\n-Then pass them as a list to initialize you agent, and start using them!\n-\n-```py\n-from transformers import ToolCollection, ReactCodeAgent\n-\n-image_tool_collection = ToolCollection(collection_slug=\"huggingface-tools/diffusion-tools-6630bb19a942c2306a2cdb6f\")\n-agent = ReactCodeAgent(tools=[*image_tool_collection.tools], add_base_tools=True)\n-\n-agent.run(\"Please draw me a picture of rivers and lakes.\")\n-```\n-\n-To speed up the start, tools are loaded only if called by the agent.\n-\n-This gets you this image:\n-\n-<img src=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/rivers_and_lakes.png\">\n+> This subpackage will soon be deprecated, since it has ben spun off into [smolagents](https://huggingface.co/docs/smolagents/index). Smolagents has extended functionality, and a similar API.\n\\ No newline at end of file"
        },
        {
            "sha": "d08bf33b1755eb05a3c11da4f10c0b708c5bec89",
            "filename": "docs/source/en/agents_advanced.md",
            "status": "modified",
            "additions": 1,
            "deletions": 243,
            "changes": 244,
            "blob_url": "https://github.com/huggingface/transformers/blob/9a217fc327fb6af5b23d2b44de4d58da3b15cf2f/docs%2Fsource%2Fen%2Fagents_advanced.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/9a217fc327fb6af5b23d2b44de4d58da3b15cf2f/docs%2Fsource%2Fen%2Fagents_advanced.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fagents_advanced.md?ref=9a217fc327fb6af5b23d2b44de4d58da3b15cf2f",
            "patch": "@@ -15,247 +15,5 @@ rendered properly in your Markdown viewer.\n -->\n # Agents, supercharged - Multi-agents, External tools, and more\n \n-[[open-in-colab]]\n-\n-### What is an agent?\n-\n-> [!TIP]\n-> If you're new to `transformers.agents`, make sure to first read the main [agents documentation](./agents).\n-\n-In this page we're going to highlight several advanced uses of `transformers.agents`.\n-\n-## Multi-agents\n-\n-Multi-agent has been introduced in Microsoft's framework [Autogen](https://huggingface.co/papers/2308.08155).\n-It simply means having several agents working together to solve your task instead of only one.\n-It empirically yields better performance on most benchmarks. The reason for this better performance is conceptually simple: for many tasks, rather than using a do-it-all system, you would prefer to specialize units on sub-tasks. Here, having agents with separate tool sets and memories allows to achieve efficient specialization.\n-\n-You can easily build hierarchical multi-agent systems with `transformers.agents`.\n-\n-To do so, encapsulate the agent in a [`ManagedAgent`] object. This object needs arguments `agent`, `name`, and a `description`, which will then be embedded in the manager agent's system prompt to let it know how to call this managed agent, as we also do for tools.\n-\n-Here's an example of making an agent that managed a specific web search agent using our [`DuckDuckGoSearchTool`]:\n-\n-```py\n-from transformers.agents import ReactCodeAgent, HfApiEngine, DuckDuckGoSearchTool, ManagedAgent\n-\n-llm_engine = HfApiEngine()\n-\n-web_agent = ReactCodeAgent(tools=[DuckDuckGoSearchTool()], llm_engine=llm_engine)\n-\n-managed_web_agent = ManagedAgent(\n-    agent=web_agent,\n-    name=\"web_search\",\n-    description=\"Runs web searches for you. Give it your query as an argument.\"\n-)\n-\n-manager_agent = ReactCodeAgent(\n-    tools=[], llm_engine=llm_engine, managed_agents=[managed_web_agent]\n-)\n-\n-manager_agent.run(\"Who is the CEO of Hugging Face?\")\n-```\n-\n-> [!TIP]\n-> For an in-depth example of an efficient multi-agent implementation, see [how we pushed our multi-agent system to the top of the GAIA leaderboard](https://huggingface.co/blog/beating-gaia).\n-\n-\n-## Advanced tool usage\n-\n-### Directly define a tool by subclassing Tool, and share it to the Hub\n-\n-Let's take again the tool example from main documentation, for which we had implemented a `tool` decorator.\n-\n-If you need to add variation, like custom attributes for your tool, you can build your tool following the fine-grained method: building a class that inherits from the [`Tool`] superclass.\n-\n-The custom tool needs:\n-- An attribute `name`, which corresponds to the name of the tool itself. The name usually describes what the tool does. Since the code returns the model with the most downloads for a task, let's name it `model_download_counter`.\n-- An attribute `description` is used to populate the agent's system prompt.\n-- An `inputs` attribute, which is a dictionary with keys `\"type\"` and `\"description\"`. It contains information that helps the Python interpreter make educated choices about the input.\n-- An `output_type` attribute, which specifies the output type.\n-- A `forward` method which contains the inference code to be executed.\n-\n-The types for both `inputs` and `output_type` should be amongst [Pydantic formats](https://docs.pydantic.dev/latest/concepts/json_schema/#generating-json-schema).\n-\n-```python\n-from transformers import Tool\n-from huggingface_hub import list_models\n-\n-class HFModelDownloadsTool(Tool):\n-    name = \"model_download_counter\"\n-    description = \"\"\"\n-    This is a tool that returns the most downloaded model of a given task on the Hugging Face Hub.\n-    It returns the name of the checkpoint.\"\"\"\n-\n-    inputs = {\n-        \"task\": {\n-            \"type\": \"string\",\n-            \"description\": \"the task category (such as text-classification, depth-estimation, etc)\",\n-        }\n-    }\n-    output_type = \"string\"\n-\n-    def forward(self, task: str):\n-        model = next(iter(list_models(filter=task, sort=\"downloads\", direction=-1)))\n-        return model.id\n-```\n-\n-Now that the custom `HfModelDownloadsTool` class is ready, you can save it to a file named `model_downloads.py` and import it for use.\n-\n-\n-```python\n-from model_downloads import HFModelDownloadsTool\n-\n-tool = HFModelDownloadsTool()\n-```\n-\n-You can also share your custom tool to the Hub by calling [`~Tool.push_to_hub`] on the tool. Make sure you've created a repository for it on the Hub and are using a token with read access.\n-\n-```python\n-tool.push_to_hub(\"{your_username}/hf-model-downloads\")\n-```\n-\n-Load the tool with the [`~Tool.load_tool`] function and pass it to the `tools` parameter in your agent.\n-\n-```python\n-from transformers import load_tool, CodeAgent\n-\n-model_download_tool = load_tool(\"m-ric/hf-model-downloads\")\n-```\n-\n-### Import a Space as a tool üöÄ\n-\n-You can directly import a Space from the Hub as a tool using the [`Tool.from_space`] method!\n-\n-You only need to provide the id of the Space on the Hub, its name, and a description that will help you agent understand what the tool does. Under the hood, this will use [`gradio-client`](https://pypi.org/project/gradio-client/) library to call the Space.\n-\n-For instance, let's import the [FLUX.1-dev](https://huggingface.co/black-forest-labs/FLUX.1-dev) Space from the Hub and use it to generate an image.\n-\n-```\n-from transformers import Tool\n-\n-image_generation_tool = Tool.from_space(\n-    \"black-forest-labs/FLUX.1-dev\",\n-    name=\"image_generator\",\n-    description=\"Generate an image from a prompt\")\n-\n-image_generation_tool(\"A sunny beach\")\n-```\n-And voil√†, here's your image! üèñÔ∏è\n-\n-<img src=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/sunny_beach.webp\">\n-\n-Then you can use this tool just like any other tool.  For example, let's improve the prompt  `a rabbit wearing a space suit` and generate an image of it.\n-\n-```python\n-from transformers import ReactCodeAgent\n-\n-agent = ReactCodeAgent(tools=[image_generation_tool])\n-\n-agent.run(\n-    \"Improve this prompt, then generate an image of it.\", prompt='A rabbit wearing a space suit'\n-)\n-```\n-\n-```text\n-=== Agent thoughts:\n-improved_prompt could be \"A bright blue space suit wearing rabbit, on the surface of the moon, under a bright orange sunset, with the Earth visible in the background\"\n-\n-Now that I have improved the prompt, I can use the image generator tool to generate an image based on this prompt.\n-=== Agent is executing the code below:\n-image = image_generator(prompt=\"A bright blue space suit wearing rabbit, on the surface of the moon, under a bright orange sunset, with the Earth visible in the background\")\n-final_answer(image)\n-```\n-\n-<img src=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/rabbit_spacesuit_flux.webp\">\n-\n-How cool is this? ü§©\n-\n-### Use gradio-tools\n-\n-[gradio-tools](https://github.com/freddyaboulton/gradio-tools) is a powerful library that allows using Hugging\n-Face Spaces as tools. It supports many existing Spaces as well as custom Spaces.\n-\n-Transformers supports `gradio_tools` with the [`Tool.from_gradio`] method. For example, let's use the [`StableDiffusionPromptGeneratorTool`](https://github.com/freddyaboulton/gradio-tools/blob/main/gradio_tools/tools/prompt_generator.py) from `gradio-tools` toolkit for improving prompts to generate better images.\n-\n-Import and instantiate the tool, then pass it to the `Tool.from_gradio` method:\n-\n-```python\n-from gradio_tools import StableDiffusionPromptGeneratorTool\n-from transformers import Tool, load_tool, CodeAgent\n-\n-gradio_prompt_generator_tool = StableDiffusionPromptGeneratorTool()\n-prompt_generator_tool = Tool.from_gradio(gradio_prompt_generator_tool)\n-```\n-\n > [!WARNING]\n-> gradio-tools require *textual* inputs and outputs even when working with different modalities like image and audio objects. Image and audio inputs and outputs are currently incompatible.\n-\n-### Use LangChain tools\n-\n-We love Langchain and think it has a very compelling suite of tools.\n-To import a tool from LangChain, use the `from_langchain()` method.\n-\n-Here is how you can use it to recreate the intro's search result using a LangChain web search tool.\n-This tool will need `pip install google-search-results` to work properly.\n-```python\n-from langchain.agents import load_tools\n-from transformers import Tool, ReactCodeAgent\n-\n-search_tool = Tool.from_langchain(load_tools([\"serpapi\"])[0])\n-\n-agent = ReactCodeAgent(tools=[search_tool])\n-\n-agent.run(\"How many more blocks (also denoted as layers) are in BERT base encoder compared to the encoder from the architecture proposed in Attention is All You Need?\")\n-```\n-\n-## Display your agent run in a cool Gradio interface\n-\n-You can leverage `gradio.Chatbot` to display your agent's thoughts using `stream_to_gradio`, here is an example:\n-\n-```py\n-import gradio as gr\n-from transformers import (\n-    load_tool,\n-    ReactCodeAgent,\n-    HfApiEngine,\n-    stream_to_gradio,\n-)\n-\n-# Import tool from Hub\n-image_generation_tool = load_tool(\"m-ric/text-to-image\")\n-\n-llm_engine = HfApiEngine(\"meta-llama/Meta-Llama-3-70B-Instruct\")\n-\n-# Initialize the agent with the image generation tool\n-agent = ReactCodeAgent(tools=[image_generation_tool], llm_engine=llm_engine)\n-\n-\n-def interact_with_agent(task):\n-    messages = []\n-    messages.append(gr.ChatMessage(role=\"user\", content=task))\n-    yield messages\n-    for msg in stream_to_gradio(agent, task):\n-        messages.append(msg)\n-        yield messages + [\n-            gr.ChatMessage(role=\"assistant\", content=\"‚è≥ Task not finished yet!\")\n-        ]\n-    yield messages\n-\n-\n-with gr.Blocks() as demo:\n-    text_input = gr.Textbox(lines=1, label=\"Chat Message\", value=\"Make me a picture of the Statue of Liberty.\")\n-    submit = gr.Button(\"Run illustrator agent!\")\n-    chatbot = gr.Chatbot(\n-        label=\"Agent\",\n-        type=\"messages\",\n-        avatar_images=(\n-            None,\n-            \"https://em-content.zobj.net/source/twitter/53/robot-face_1f916.png\",\n-        ),\n-    )\n-    submit.click(interact_with_agent, [text_input], [chatbot])\n-\n-if __name__ == \"__main__\":\n-    demo.launch()\n-```\n+> This subpackage will soon be deprecated, since it has ben spun off into [smolagents](https://huggingface.co/docs/smolagents/index). Smolagents has extended functionality, and a similar API.\n\\ No newline at end of file"
        },
        {
            "sha": "f28d3d913cf0b909df1ed94b0ac756436d80f8bd",
            "filename": "src/transformers/agents/agents.py",
            "status": "modified",
            "additions": 15,
            "deletions": 1,
            "changes": 16,
            "blob_url": "https://github.com/huggingface/transformers/blob/9a217fc327fb6af5b23d2b44de4d58da3b15cf2f/src%2Ftransformers%2Fagents%2Fagents.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9a217fc327fb6af5b23d2b44de4d58da3b15cf2f/src%2Ftransformers%2Fagents%2Fagents.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fagents%2Fagents.py?ref=9a217fc327fb6af5b23d2b44de4d58da3b15cf2f",
            "patch": "@@ -20,6 +20,8 @@\n import time\n from typing import Any, Callable, Dict, List, Optional, Tuple, Union\n \n+from huggingface_hub.utils._deprecation import _deprecate_method\n+\n from .. import is_torch_available\n from ..utils import logging as transformers_logging\n from ..utils.import_utils import is_pygments_available\n@@ -110,7 +112,7 @@ def parse_json_blob(json_blob: str) -> Dict[str, str]:\n         raise ValueError(\n             f\"The JSON blob you used is invalid due to the following error: {e}.\\n\"\n             f\"JSON blob was: {json_blob}, decoding failed on that specific part of the blob:\\n\"\n-            f\"'{json_blob[place-4:place+5]}'.\"\n+            f\"'{json_blob[place - 4 : place + 5]}'.\"\n         )\n     except Exception as e:\n         raise ValueError(f\"Error in parsing the JSON blob: {e}\")\n@@ -720,6 +722,10 @@ class ReactAgent(Agent):\n     The action will be parsed from the LLM output: it consists in calls to tools from the toolbox, with arguments chosen by the LLM engine.\n     \"\"\"\n \n+    @_deprecate_method(\n+        version=\"4.51.0\",\n+        message=\"Switch to smolagents instead, with the same functionalities and similar API (https://huggingface.co/docs/smolagents/index)\",\n+    )\n     def __init__(\n         self,\n         tools: List[Tool],\n@@ -774,6 +780,10 @@ def provide_final_answer(self, task) -> str:\n         except Exception as e:\n             return f\"Error in generating final llm output: {e}.\"\n \n+    @_deprecate_method(\n+        version=\"4.51.0\",\n+        message=\"Switch to smolagents instead, with the same functionalities and similar API (https://huggingface.co/docs/smolagents/index)\",\n+    )\n     def run(self, task: str, stream: bool = False, reset: bool = True, **kwargs):\n         \"\"\"\n         Runs the agent for the given task.\n@@ -1225,6 +1235,10 @@ def step(self, log_entry: Dict[str, Any]):\n \n \n class ManagedAgent:\n+    @_deprecate_method(\n+        version=\"4.51.0\",\n+        message=\"Switch to smolagents instead, with the same functionalities and similar API (https://huggingface.co/docs/smolagents/index)\",\n+    )\n     def __init__(self, agent, name, description, additional_prompting=None, provide_run_summary=False):\n         self.agent = agent\n         self.name = name"
        },
        {
            "sha": "832f77a4ebe72597543a52be8b38e63508bab310",
            "filename": "src/transformers/agents/image_question_answering.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/9a217fc327fb6af5b23d2b44de4d58da3b15cf2f/src%2Ftransformers%2Fagents%2Fimage_question_answering.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9a217fc327fb6af5b23d2b44de4d58da3b15cf2f/src%2Ftransformers%2Fagents%2Fimage_question_answering.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fagents%2Fimage_question_answering.py?ref=9a217fc327fb6af5b23d2b44de4d58da3b15cf2f",
            "patch": "@@ -26,8 +26,7 @@\n class ImageQuestionAnsweringTool(PipelineTool):\n     default_checkpoint = \"dandelin/vilt-b32-finetuned-vqa\"\n     description = (\n-        \"This is a tool that answers a question about an image. It \"\n-        \"returns a text that is the answer to the question.\"\n+        \"This is a tool that answers a question about an image. It returns a text that is the answer to the question.\"\n     )\n     name = \"image_qa\"\n     pre_processor_class = AutoProcessor"
        },
        {
            "sha": "49c96b95797144b683779a47ef4722593e093a38",
            "filename": "src/transformers/agents/llm_engine.py",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/9a217fc327fb6af5b23d2b44de4d58da3b15cf2f/src%2Ftransformers%2Fagents%2Fllm_engine.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9a217fc327fb6af5b23d2b44de4d58da3b15cf2f/src%2Ftransformers%2Fagents%2Fllm_engine.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fagents%2Fllm_engine.py?ref=9a217fc327fb6af5b23d2b44de4d58da3b15cf2f",
            "patch": "@@ -19,6 +19,7 @@\n from typing import Dict, List, Optional\n \n from huggingface_hub import InferenceClient\n+from huggingface_hub.utils._deprecation import _deprecate_method\n \n from .. import AutoTokenizer\n from ..pipelines.base import Pipeline\n@@ -73,6 +74,10 @@ def get_clean_message_list(message_list: List[Dict[str, str]], role_conversions:\n \n \n class HfEngine:\n+    @_deprecate_method(\n+        version=\"4.51.0\",\n+        message=\"Switch to smolagents instead, with the same functionalities and similar API (https://huggingface.co/docs/smolagents/index)\",\n+    )\n     def __init__(self, model_id: Optional[str] = None):\n         self.last_input_token_count = None\n         self.last_output_token_count = None"
        },
        {
            "sha": "acea6e7700f271caeac895b60b4993b549671815",
            "filename": "src/transformers/agents/tools.py",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/huggingface/transformers/blob/9a217fc327fb6af5b23d2b44de4d58da3b15cf2f/src%2Ftransformers%2Fagents%2Ftools.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/9a217fc327fb6af5b23d2b44de4d58da3b15cf2f/src%2Ftransformers%2Fagents%2Ftools.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fagents%2Ftools.py?ref=9a217fc327fb6af5b23d2b44de4d58da3b15cf2f",
            "patch": "@@ -28,6 +28,7 @@\n \n from huggingface_hub import create_repo, get_collection, hf_hub_download, metadata_update, upload_folder\n from huggingface_hub.utils import RepositoryNotFoundError, build_hf_headers, get_session\n+from huggingface_hub.utils._deprecation import _deprecate_method\n from packaging import version\n \n from ..dynamic_module_utils import (\n@@ -132,9 +133,17 @@ class Tool:\n     inputs: Dict[str, Dict[str, Union[str, type]]]\n     output_type: type\n \n+    @_deprecate_method(\n+        version=\"4.51.0\",\n+        message=\"Switch to smolagents instead, with the same functionalities and similar API (https://huggingface.co/docs/smolagents/index)\",\n+    )\n     def __init__(self, *args, **kwargs):\n         self.is_initialized = False\n \n+    @_deprecate_method(\n+        version=\"4.51.0\",\n+        message=\"Switch to smolagents instead, with the same functionalities and similar API (https://huggingface.co/docs/smolagents/index)\",\n+    )\n     def __init_subclass__(cls, **kwargs):\n         super().__init_subclass__(**kwargs)\n         validate_after_init(cls, do_validate_forward=False)"
        }
    ],
    "stats": {
        "total": 691,
        "additions": 32,
        "deletions": 659
    }
}