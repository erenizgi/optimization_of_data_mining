{
    "author": "ArthurZucker",
    "message": "Add GPT OSS model from OpenAI  (#39923)\n\n* fix\n\n* nice\n\n* where i am at\n\n* Bro this works\n\n* Update src/transformers/integrations/tensor_parallel.py\n\n* cleanups\n\n* yups that was breaking\n\n* Update src/transformers/models/openai_moe/modeling_openai_moe.py\n\n* gather on experts and not mlp\n\n* add changes for latest convert branch\n\n* adds options to get output_router_logits from config\n\n* bring chat temlate + special tokens back into the script.\n\n* initial commmit\n\n* update\n\n* working with shards\n\n* add model.safetensors.index.json\n\n* fix\n\n* fix\n\n* mxfp4 flag\n\n* rm print\n\n* Fix PAD/EOS/BOS (#18)\n\n* fix pad/eos/bos\n\n* base model maybe one day\n\n* add some doc\n\n* special tokens based on harmony.\n\n* add in tokenizer config as well.\n\n* prepare for rebase with main\n\n* Fix for initialize_tensor_parallelism  now returning 4-tuple\n\n```\r\n[rank0]:   File \"/fsx/edward/work/openai-tsm-examples/examples/generate.py\", line 17, in <module>\r\n[rank0]:     model = AutoModelForCausalLM.from_pretrained(\r\n[rank0]:             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n[rank0]:   File \"/fsx/edward/work/new-model-addition-openai/src/transformers/models/auto/auto_factory.py\", line 600, in from_pretrained\r\n[rank0]:     return model_class.from_pretrained(\r\n[rank0]:            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n[rank0]:   File \"/fsx/edward/work/new-model-addition-openai/src/transformers/modeling_utils.py\", line 316, in _wrapper\r\n[rank0]:     return func(*args, **kwargs)\r\n[rank0]:            ^^^^^^^^^^^^^^^^^^^^^\r\n[rank0]:   File \"/fsx/edward/work/new-model-addition-openai/src/transformers/modeling_utils.py\", line 4748, in from_pretrained\r\n[rank0]:     tp_plan, device_map, device_mesh = initialize_tensor_parallelism(tp_plan, tp_size=None)\r\n[rank0]:     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n[rank0]: ValueError: too many values to unpack (expected 3)\r\n```\n\n* mxfp4\n\n* mxfp4 draft\n\n* fix\n\n* fix import\n\n* draft\n\n* draft impl\n\n* finally working !\n\n* simplify\n\n* add import\n\n* working version\n\n* consider blocks and scales\n\n* device mesh fix\n\n* initial commit\n\n* add working dequant + quant logic\n\n* update\n\n* non nan, gibberish output\n\n* working EP + quantization finally !\n\n* start cleaning\n\n* remove reversing process\n\n* style\n\n* some cleaning\n\n* initial commmit\n\n* more cleaning\n\n* more cleaning\n\n* simplify\n\n* more cleaning\n\n* rm duplicated function\n\n* changing tp_plan\n\n* update tp plan check\n\n* add loading attribute\n\n* dequantizing logic\n\n* use subfunctions\n\n* import cleaning\n\n* update_param_name\n\n* adds clamped swiglu\n\n* add clamping to training path\n\n* simplify dequant logic\n\n* update\n\n* Bad merge\n\n* more simplifications & tests\n\n* fix !\n\n* fix registering custom attention\n\n* fix order\n\n* fixes\n\n* some test nits\n\n* nits\n\n* nit\n\n* fix\n\n* Clamp sink logits\n\n* Clean\n\n* Soft-max trick\n\n* Clean up\n\n* p\n\n* fix deepspeed\n\n* update both modeling and modular for cleanup\n\n* contiguous\n\n* update tests\n\n* fix top_k router call\n\n* revert renaming\n\n* test nits\n\n* small fixes for EP\n\n* fix path for our local tests\n\n* update as I should not have broken that!\n\n* fix the loss of mixtral\n\n* revert part of the changes related to router_scores, kernel probably no ready for that!\n\n* deleting a small nit\n\n* update arch\n\n* fix post processing\n\n* update\n\n* running version but not expected output\n\n* moving to cuda\n\n* initial commit\n\n* revert\n\n* erroring when loading on cpu\n\n* updates\n\n* del blocks, scales\n\n* fix\n\n* style\n\n* rm comm\n\n* comment\n\n* add comment\n\n* style\n\n* remove duplicated lines\n\n* Fix minor issue with weight_map conversion script\n\n* fix sampling params\n\n* rename to final name\n\n* upate pre-final version of template\n\n* Update src/transformers/models/gpt_oss/convert_gpt_oss_weights_to_hf.py\n\n* fix batched inference\n\n* serve fixes\n\n* swizzle !\n\n* update final chat template by Matt.\n\n* fix responses; pin oai\n\n* sinplify\n\n* Thanks Matt for his tireless efforts!\n\nCo-authored-by: Rocketknight1 <Rocketknight1@users.noreply.github.com>\n\n* Update src/transformers/models/gpt_oss/convert_gpt_oss_weights_to_hf.py\n\nCo-authored-by: Matt <Rocketknight1@users.noreply.github.com>\n\n* fix\n\n* Use ROCm kernels from HUB\n\n* Make kernel modes explicit\n\n* update final chat template by Matt. x2\n\n* Thanks Matt for his tireless efforts!\n\nCo-authored-by: Rocketknight1 <Rocketknight1@users.noreply.github.com>\n\n* Fix installation\n\n* Update setup.py\n\nCo-authored-by: Ákos Hadnagy <akos.hadnagy@gmail.com>\n\n* allow no content\n\n* fix: update message handling in write_tokenizer function\n\n* Fix template logic for user message role\n\n* last nits for CB and flash_paged!\n\n* there was one bad merge\n\n* fix CB (hardcode for now, its just using kv groups instead)\n\n* fix\n\n* better fix for device_map\n\n* minor device fix\n\n* Fix flash paged\n\n* updates\n\n* Revert \"remove dtensors, not explicit (#39840)\"\n\nThis reverts commit 6dfd561d9cd722dfc09f702355518c6d09b9b4e3.\n\n* update\n\n* Revert \"remove dtensors, not explicit (#39840)\"\n\nThis reverts commit 6dfd561d9cd722dfc09f702355518c6d09b9b4e3.\n\n* fix merge\n\n* fix\n\n* Fix line break when custom model indentity\n\n* nits testing\n\n* to locals first and pass sliding window to flash paged\n\n* register modes for MegaBlocksMoeMlp\n\n* add integration test in fixtures -> now update the tests to use it!\n\n* update integration tests\n\n* initial fix\n\n* style and update tests\n\n* fix\n\n* chore(gpt oss): remove mlp_bias from configuration\n\nIt was just a leftover.\n\n* stats\n\n* Integration tests\n\n* whoops\n\n* Shouldn't move model\n\n* Ensure assistant messages without thinking always go to \"final\" channel\n\n* More checks to ensure expected format\n\n* Add pad_token_id to model configuration in write_model function (#51)\n\n* Add oai fix fast tests (#59)\n\n* Fix some fast tests\n\n* Force some updates\n\n* Remove unnecessary fixes\n\n* Update src/transformers/models/gpt_oss/convert_gpt_oss_weights_to_hf.py\n\nCo-authored-by: Quentin Gallouédec <45557362+qgallouedec@users.noreply.github.com>\n\n* Update src/transformers/models/gpt_oss/convert_gpt_oss_weights_to_hf.py\n\nCo-authored-by: Quentin Gallouédec <45557362+qgallouedec@users.noreply.github.com>\n\n* Update src/transformers/models/gpt_oss/convert_gpt_oss_weights_to_hf.py\n\n* reasoning -> Reasoning\n\n* Add additional integration tests\n\n* fixup\n\n* Slight fixes\n\n* align chat template with harmony\n\n* simplify\n\n* Add comment\n\n* torch testing assert close\n\n* torch testing assert close\n\n* torch testing assert close\n\n* torch testing assert close\n\n* torch testing assert close\n\n* torch testing assert close\n\n* Revert fixup\n\n* skip 2 test remove todo\n\n* merge\n\n* padding side should be left for integration tests\n\n* fix modular wrt to changes made to modeling\n\n* style\n\n* isort\n\n* fix opies for the loss\n\n* mmmm\n\n---------\n\nCo-authored-by: Quentin Gallouédec <gallouedec.quentin@gmail.com>\nCo-authored-by: Quentin Gallouédec <45557362+qgallouedec@users.noreply.github.com>\nCo-authored-by: Marc Sun <marc@huggingface.co>\nCo-authored-by: edbeeching <edbeeching@gmail.com>\nCo-authored-by: Vaibhavs10 <vaibhavs10@gmail.com>\nCo-authored-by: MekkCyber <mekk.cyber@gmail.com>\nCo-authored-by: Marc Sun <57196510+SunMarc@users.noreply.github.com>\nCo-authored-by: Edward Beeching <edbeeching@users.noreply.github.com>\nCo-authored-by: Mohamed Mekkouri <93391238+MekkCyber@users.noreply.github.com>\nCo-authored-by: Lewis Tunstall <lewis.c.tunstall@gmail.com>\nCo-authored-by: Zhuohan Li <zhuohan@openai.com>\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\nCo-authored-by: joao@huggingface.co <joao@ip-10-53-88-32.ec2.internal>\nCo-authored-by: Rocketknight1 <Rocketknight1@users.noreply.github.com>\nCo-authored-by: Joao Gante <joaofranciscocardosogante@gmail.com>\nCo-authored-by: Akos Hadnagy <akos@ahadnagy.com>\nCo-authored-by: Ákos Hadnagy <akos.hadnagy@gmail.com>\nCo-authored-by: Alvaro Moran <alvaro.moran@huggingface.co>\nCo-authored-by: Lysandre <hi@lysand.re>\nCo-authored-by: Matt <rocketknight1@gmail.com>",
    "sha": "7c38d8fc23146e732d4098760bdcb27d7d12c90c",
    "files": [
        {
            "sha": "996029b00b89964fa5c52dc4b8be5e8458a137a5",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -617,6 +617,8 @@\n         title: OLMoE\n       - local: model_doc/open-llama\n         title: Open-Llama\n+      - local: model_doc/openai_moe\n+        title: OpenAIMoe\n       - local: model_doc/opt\n         title: OPT\n       - local: model_doc/pegasus"
        },
        {
            "sha": "2c0b39013dc4c90216804fbc93da15fd17038dd5",
            "filename": "docs/source/en/model_doc/openai_moe.md",
            "status": "added",
            "additions": 58,
            "deletions": 0,
            "changes": 58,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/docs%2Fsource%2Fen%2Fmodel_doc%2Fopenai_moe.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/docs%2Fsource%2Fen%2Fmodel_doc%2Fopenai_moe.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fopenai_moe.md?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -0,0 +1,58 @@\n+<!--Copyright 2025 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+<div style=\"float: right;\">\n+    <div class=\"flex flex-wrap space-x-1\">\n+        <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+        <img alt=\"Flax\" src=\"https://img.shields.io/badge/Flax-29a79b.svg?style=flat&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAMAAAANxBKoAAAC7lBMVEUAAADg5vYHPVgAoJH+/v76+v39/f9JbLP///9+AIgAnY3///+mcqzt8fXy9fgkXa3Ax9709fr+///9/f8qXq49qp5AaLGMwrv8/P0eW60VWawxYq8yqJzG2dytt9Wyu9elzci519Lf3O3S2efY3OrY0+Xp7PT///////+dqNCexMc6Z7AGpJeGvbenstPZ5ejQ1OfJzOLa7ejh4+/r8fT29vpccbklWK8PVa0AS6ghW63O498vYa+lsdKz1NDRt9Kw1c672tbD3tnAxt7R6OHp5vDe7OrDyuDn6vLl6/EAQKak0MgATakkppo3ZK/Bz9y8w9yzu9jey97axdvHzeG21NHH4trTwthKZrVGZLSUSpuPQJiGAI+GAI8SWKydycLL4d7f2OTi1+S9xNzL0ePT6OLGzeEAo5U0qJw/aLEAo5JFa7JBabEAp5Y4qZ2QxLyKmsm3kL2xoMOehrRNb7RIbbOZgrGre68AUqwAqZqNN5aKJ5N/lMq+qsd8kMa4pcWzh7muhLMEV69juq2kbKqgUaOTR5uMMZWLLZSGAI5VAIdEAH+ovNDHuNCnxcy3qcaYx8K8msGplrx+wLahjbYdXrV6vbMvYK9DrZ8QrZ8tqJuFms+Sos6sw8ecy8RffsNVeMCvmb43aLltv7Q4Y7EZWK4QWa1gt6meZKUdr6GOAZVeA4xPAISyveLUwtivxtKTpNJ2jcqfvcltiMiwwcfAoMVxhL+Kx7xjdrqTe60tsaNQs6KaRKACrJ6UTZwkqpqTL5pkHY4AloSgsd2ptNXPvNOOncuxxsqFl8lmg8apt8FJcr9EbryGxLqlkrkrY7dRa7ZGZLQ5t6iXUZ6PPpgVpZeJCJFKAIGareTa0+KJod3H0deY2M+esM25usmYu8d2zsJOdcBVvrCLbqcAOaaHaKQAMaScWqKBXqCXMJ2RHpiLF5NmJZAdAHN2kta11dKu1M+DkcZLdb+Mcql3TppyRJdzQ5ZtNZNlIY+DF4+voCOQAAAAZ3RSTlMABAT+MEEJ/RH+/TP+Zlv+pUo6Ifz8+fco/fz6+evr39S9nJmOilQaF/7+/f38+smmoYp6b1T+/v7++vj189zU0tDJxsGzsrKSfv34+Pf27dDOysG9t6+n/vv6+vr59uzr1tG+tZ6Qg9Ym3QAABR5JREFUSMeNlVVUG1EQhpcuxEspXqS0SKEtxQp1d3d332STTRpIQhIISQgJhODu7lAoDoUCpe7u7u7+1puGpqnCPOyZvffbOXPm/PsP9JfQgyCC+tmTABTOcbxDz/heENS7/1F+9nhvkHePG0wNDLbGWwdXL+rbLWvpmZHXD8+gMfBjTh+aSe6Gnn7lwQIOTR0c8wfX3PWgv7avbdKwf/ZoBp1Gp/PvuvXW3vw5ib7emnTW4OR+3D4jB9vjNJ/7gNvfWWeH/TO/JyYrsiKCRjVEZA3UB+96kON+DxOQ/NLE8PE5iUYgIXjFnCOlxEQMaSGVxjg4gxOnEycGz8bptuNjVx08LscIgrzH3umcn+KKtiBIyvzOO2O99aAdR8cF19oZalnCtvREUw79tCd5sow1g1UKM6kXqUx4T8wsi3sTjJ3yzDmmhenLXLpo8u45eG5y4Vvbk6kkC4LLtJMowkSQxmk4ggVJEG+7c6QpHT8vvW9X7/o7+3ELmiJi2mEzZJiz8cT6TBlanBk70cB5GGIGC1gRDdZ00yADLW1FL6gqhtvNXNG5S9gdSrk4M1qu7JAsmYshzDS4peoMrU/gT7qQdqYGZaYhxZmVbGJAm/CS/HloWyhRUlknQ9KYcExTwS80d3VNOxUZJpITYyspl0LbhArhpZCD9cRWEQuhYkNGMHToQ/2Cs6swJlb39CsllxdXX6IUKh/H5jbnSsPKjgmoaFQ1f8wRLR0UnGE/RcDEjj2jXG1WVTwUs8+zxfcrVO+vSsuOpVKxCfYZiQ0/aPKuxQbQ8lIz+DClxC8u+snlcJ7Yr1z1JPqUH0V+GDXbOwAib931Y4Imaq0NTIXPXY+N5L18GJ37SVWu+hwXff8l72Ds9XuwYIBaXPq6Shm4l+Vl/5QiOlV+uTk6YR9PxKsI9xNJny31ygK1e+nIRC1N97EGkFPI+jCpiHe5PCEy7oWqWSwRrpOvhFzcbTWMbm3ZJAOn1rUKpYIt/lDhW/5RHHteeWFN60qo98YJuoq1nK3uW5AabyspC1BcIEpOhft+SZAShYoLSvnmSfnYADUERP5jJn2h5XtsgCRuhYQqAvwTwn33+YWEKUI72HX5AtfSAZDe8F2DtPPm77afhl0EkthzuCQU0BWApgQIH9+KB0JhopMM7bJrdTRoleM2JAVNMyPF+wdoaz+XJpGoVAQ7WXUkcV7gT3oUZyi/ISIJAVKhgNp+4b4veCFhYVJw4locdSjZCp9cPUhLF9EZ3KKzURepMEtCDPP3VcWFx4UIiZIklIpFNfHpdEafIF2aRmOcrUmjohbT2WUllbmRvgfbythbQO3222fpDJoufaQPncYYuqoGtUEsCJZL6/3PR5b4syeSjZMQG/T2maGANlXT2v8S4AULWaUkCxfLyW8iW4kdka+nEMjxpL2NCwsYNBp+Q61PF43zyDg9Bm9+3NNySn78jMZUUkumqE4Gp7JmFOdP1vc8PpRrzj9+wPinCy8K1PiJ4aYbnTYpCCbDkBSbzhu2QJ1Gd82t8jI8TH51+OzvXoWbnXUOBkNW+0mWFwGcGOUVpU81/n3TOHb5oMt2FgYGjzau0Nif0Ss7Q3XB33hjjQHjHA5E5aOyIQc8CBrLdQSs3j92VG+3nNEjbkbdbBr9zm04ruvw37vh0QKOdeGIkckc80fX3KH/h7PT4BOjgCty8VZ5ux1MoO5Cf5naca2LAsEgehI+drX8o/0Nu+W0m6K/I9gGPd/dfx/EN/wN62AhsBWuAAAAAElFTkSuQmCC\n+        \">\n+        <img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+        <img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+    </div>\n+</div>\n+\n+# OpenAIMoE\n+\n+## Overview\n+\n+The OpenAIMoE model was proposed in [<INSERT PAPER NAME HERE>](<INSERT PAPER LINK HERE>) by <INSERT AUTHORS HERE>.\n+<INSERT SHORT SUMMARY HERE>\n+\n+The abstract from the paper is the following:\n+\n+*<INSERT PAPER ABSTRACT HERE>*\n+\n+Tips:\n+\n+<INSERT TIPS ABOUT MODEL HERE>\n+\n+This model was contributed by [INSERT YOUR HF USERNAME HERE](https://huggingface.co/<INSERT YOUR HF USERNAME HERE>).\n+The original code can be found [here](<INSERT LINK TO GITHUB REPO HERE>).\n+\n+\n+## OpenAIMoeConfig\n+\n+[[autodoc]] OpenAIMoeConfig\n+\n+## OpenAIMoeModel\n+\n+[[autodoc]] OpenAIMoeModel\n+    - forward\n+\n+## OpenAIMoeForCausalLM\n+\n+[[autodoc]] OpenAIMoeForCausalLM\n+    - forward"
        },
        {
            "sha": "920e2adbbef8da758695faf18d59fe879c347152",
            "filename": "setup.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/setup.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/setup.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/setup.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -128,7 +128,7 @@\n     # Keras pin - this is to make sure Keras 3 doesn't destroy us. Remove or change when we have proper support.\n     \"keras>2.9,<2.16\",\n     \"keras-nlp>=0.3.1,<0.14.0\",  # keras-nlp 0.14 doesn't support keras 2, see pin on keras.\n-    \"kernels>=0.6.1,<0.7\",\n+    \"kernels>=0.6.1,<=0.9\",\n     \"librosa\",\n     \"natten>=0.14.6,<0.15.0\",\n     \"nltk<=3.8.1\",\n@@ -137,7 +137,7 @@\n     \"onnxconverter-common\",\n     \"onnxruntime-tools>=1.4.2\",\n     \"onnxruntime>=1.4.0\",\n-    \"openai\",\n+    \"openai>=1.98.0\",\n     \"opencv-python\",\n     \"optimum-benchmark>=0.3.0\",\n     \"optuna\","
        },
        {
            "sha": "f929e4af9eb3010c93aeede8f2e6fa9e6d51eefc",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -277,6 +277,7 @@\n         \"GPTQConfig\",\n         \"HiggsConfig\",\n         \"HqqConfig\",\n+        \"Mxfp4Config\",\n         \"QuantoConfig\",\n         \"QuarkConfig\",\n         \"FPQuantConfig\","
        },
        {
            "sha": "c3f9bc2838b5eff2f238cbb8e08094515b0acdf3",
            "filename": "src/transformers/commands/serving.py",
            "status": "modified",
            "additions": 69,
            "deletions": 3,
            "changes": 72,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fcommands%2Fserving.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fcommands%2Fserving.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fcommands%2Fserving.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -909,7 +909,16 @@ def generate_chat_completion(self, req: dict) -> Generator[str, None, None]:\n         inputs = inputs.to(model.device)\n         request_id = req.get(\"request_id\", \"req_0\")\n \n-        generation_streamer = TextIteratorStreamer(processor, skip_special_tokens=True, skip_prompt=True)\n+        # Temporary hack for GPTOSS 1: don't filter special tokens\n+        skip_special_tokens = True\n+        if \"gptoss\" in model.config.architectures[0].lower():\n+            skip_special_tokens = False\n+\n+        generation_streamer = TextIteratorStreamer(\n+            processor,\n+            skip_special_tokens=skip_special_tokens,\n+            skip_prompt=True,\n+        )\n         generation_config = create_generation_config_from_req(req, model_generation_config=model.generation_config)\n \n         last_kv_cache = None\n@@ -925,12 +934,21 @@ def generate_chat_completion(self, req: dict) -> Generator[str, None, None]:\n         }\n \n         def stream_chat_completion(streamer, _request_id):\n+            # Temporary hack for GPTOS 2: filter out the CoT tokens. Full solution here implies defining new output\n+            # classes and piping the reasoning trace into a new field\n+            filter_cot = False\n+            cot_trace_end = None\n+            if \"gptoss\" in model.config.architectures[0].lower():\n+                filter_cot = True\n+                cot_trace_end = \"<|channel|>final<|message|>\"\n+\n             # Thin wrapper to save the KV cache after generation\n             def generate_with_cache(**kwargs):\n                 generate_output = model.generate(**kwargs)\n                 self.last_kv_cache = generate_output.past_key_values\n \n             thread = Thread(target=generate_with_cache, kwargs=generation_kwargs)\n+            results = \"\"\n \n             try:\n                 thread.start()\n@@ -941,6 +959,20 @@ def generate_with_cache(**kwargs):\n                 yield self.build_chat_completion_chunk(request_id, role=\"assistant\", model=model_id_and_revision)\n \n                 for result in streamer:\n+                    # Temporary hack for GPTOS 3: don't emit the final \"<|return|>\"\n+                    if \"gptoss\" in model.config.architectures[0].lower():\n+                        if result.endswith(\"<|return|>\"):\n+                            result = result[: -len(\"<|return|>\")]\n+                    results += result\n+\n+                    # (related to temporary hack 2)\n+                    if filter_cot:\n+                        if cot_trace_end in results:  # end of reasoning trace observed -> stop filtering\n+                            filter_cot = False\n+                            continue\n+                        else:\n+                            continue\n+\n                     # ====== TOOL CALL LOGIC ======\n                     if tool_model_family is not None:\n                         # Start of a tool call: reset state variables, set `inside_tool_call`\n@@ -1064,7 +1096,16 @@ def generate_response(self, req: dict) -> Generator[str, None, None]:\n         inputs = inputs.to(model.device)\n         request_id = req.get(\"previous_response_id\", \"req_0\")\n \n-        generation_streamer = TextIteratorStreamer(processor, skip_special_tokens=True, skip_prompt=True)\n+        # Temporary hack for GPTOSS 1: don't filter special tokens\n+        skip_special_tokens = True\n+        if \"gptoss\" in model.config.architectures[0].lower():\n+            skip_special_tokens = False\n+\n+        generation_streamer = TextIteratorStreamer(\n+            processor,\n+            skip_special_tokens=skip_special_tokens,\n+            skip_prompt=True,\n+        )\n         generation_config = create_generation_config_from_req(req, model_generation_config=model.generation_config)\n \n         last_kv_cache = None\n@@ -1081,6 +1122,14 @@ def generate_response(self, req: dict) -> Generator[str, None, None]:\n         }\n \n         def stream_response(streamer, _request_id):\n+            # Temporary hack for GPTOS 2: filter out the CoT tokens. Full solution here implies defining new output\n+            # classes and piping the reasoning trace into a new field\n+            filter_cot = False\n+            cot_trace_end = None\n+            if \"gptoss\" in model.config.architectures[0].lower():\n+                filter_cot = True\n+                cot_trace_end = \"<|channel|>final<|message|>\"\n+\n             # Thin wrapper to save the KV cache after generation\n             def generate_with_cache(**kwargs):\n                 generate_output = model.generate(**kwargs)\n@@ -1167,14 +1216,29 @@ def generate_with_cache(**kwargs):\n                 # Stream the actual generated text\n                 results = \"\"\n                 for result in streamer:\n+                    # Temporary hack for GPTOS 3: don't emit the final \"<|return|>\"\n+                    if \"gptoss\" in model.config.architectures[0].lower():\n+                        if result.endswith(\"<|return|>\"):\n+                            result = result[: -len(\"<|return|>\")]\n                     results += result\n+\n+                    # (related to temporary hack 2)\n+                    if filter_cot:\n+                        if cot_trace_end in results:  # end of reasoning trace observed -> stop filtering\n+                            filter_cot = False\n+                            results = \"\"  # reset the results -> results will now track the final response\n+                            continue\n+                        else:\n+                            continue\n+\n                     response_output_text_delta = ResponseTextDeltaEvent(\n                         type=\"response.output_text.delta\",\n                         item_id=f\"msg_{request_id}\",\n                         sequence_number=sequence_number,\n                         output_index=output_index,\n                         content_index=content_index,\n                         delta=result,\n+                        logprobs=[{\"token\": \"\", \"logprob\": 99.9}],  # TODO: add actual logprobs\n                     )\n                     sequence_number += 1\n                     yield self.build_response_event(response_output_text_delta)\n@@ -1187,6 +1251,7 @@ def generate_with_cache(**kwargs):\n                     output_index=output_index,\n                     content_index=0,\n                     text=results,\n+                    logprobs=[{\"token\": \"\", \"logprob\": 99.9}],  # TODO: add actual logprobs\n                 )\n                 sequence_number += 1\n                 yield self.build_response_event(response_output_text_done)\n@@ -1446,9 +1511,10 @@ def _load_model_and_data_processor(self, model_id_and_revision: str):\n             \"attn_implementation\": args.attn_implementation,\n             \"torch_dtype\": torch_dtype,\n             \"device_map\": \"auto\",\n-            \"quantization_config\": quantization_config,\n             \"trust_remote_code\": args.trust_remote_code,\n         }\n+        if quantization_config is not None:\n+            model_kwargs[\"quantization_config\"] = quantization_config\n \n         config = AutoConfig.from_pretrained(model_id, **model_kwargs)\n         architecture = getattr(transformers, config.architectures[0])"
        },
        {
            "sha": "758b4c59023914cc8cda948aceedaace0b6d7d21",
            "filename": "src/transformers/dependency_versions_table.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fdependency_versions_table.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fdependency_versions_table.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fdependency_versions_table.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -34,7 +34,7 @@\n     \"kenlm\": \"kenlm\",\n     \"keras\": \"keras>2.9,<2.16\",\n     \"keras-nlp\": \"keras-nlp>=0.3.1,<0.14.0\",\n-    \"kernels\": \"kernels>=0.6.1,<0.7\",\n+    \"kernels\": \"kernels>=0.6.1,<=0.9\",\n     \"librosa\": \"librosa\",\n     \"natten\": \"natten>=0.14.6,<0.15.0\",\n     \"nltk\": \"nltk<=3.8.1\",\n@@ -43,7 +43,7 @@\n     \"onnxconverter-common\": \"onnxconverter-common\",\n     \"onnxruntime-tools\": \"onnxruntime-tools>=1.4.2\",\n     \"onnxruntime\": \"onnxruntime>=1.4.0\",\n-    \"openai\": \"openai\",\n+    \"openai\": \"openai>=1.98.0\",\n     \"opencv-python\": \"opencv-python\",\n     \"optimum-benchmark\": \"optimum-benchmark>=0.3.0\",\n     \"optuna\": \"optuna\","
        },
        {
            "sha": "57e57c959c26b5bafa3a2c5cdd2d96e83c54dbe5",
            "filename": "src/transformers/generation/continuous_batching.py",
            "status": "modified",
            "additions": 23,
            "deletions": 14,
            "changes": 37,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fgeneration%2Fcontinuous_batching.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fgeneration%2Fcontinuous_batching.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Fcontinuous_batching.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -182,27 +182,29 @@ def __init__(\n                     f\"Number of key value heads {num_key_value_heads} must be divisible by tensor parallel size {tp_size}.\"\n                 )\n             # If the model is using tensor parallelism, we need to adjust the number of heads accordingly.\n-            self.num_key_value_heads //= tp_size\n+            # self.num_key_value_heads //= tp_size\n \n         self.head_dim = (\n             config.head_dim if hasattr(config, \"head_dim\") else config.hidden_size // config.num_attention_heads\n         )\n         self.num_hidden_layers = config.num_hidden_layers\n \n         # Calculate optimal block size and number if not provided\n-        num_blocks = getattr(generation_config, \"num_blocks\", None)\n+        num_blocks = getattr(generation_config, \"num_blocks\", 1024)\n         block_size = getattr(generation_config, \"block_size\", 32)\n         max_memory_percent = getattr(generation_config, \"max_memory\", 0.9)\n-        num_blocks, max_batch_tokens = compute_optimal_blocks(\n-            generation_config.max_new_tokens,\n-            block_size=block_size,\n-            head_dim=self.head_dim,\n-            num_layers=self.num_hidden_layers,\n-            num_heads=self.num_key_value_heads,\n-            max_memory_percent=max_memory_percent,\n-            dtype=dtype,\n-            num_blocks=num_blocks,\n-        )\n+        max_batch_tokens = getattr(generation_config, \"max_batch_tokens\", 256)\n+        if num_blocks is None or max_batch_tokens is None:\n+            num_blocks, max_batch_tokens = compute_optimal_blocks(\n+                generation_config.max_new_tokens,\n+                block_size=block_size,\n+                head_dim=self.head_dim,\n+                num_layers=self.num_hidden_layers,\n+                num_heads=self.num_key_value_heads,\n+                max_memory_percent=max_memory_percent,\n+                dtype=dtype,\n+                num_blocks=num_blocks,\n+            )\n         logger.warning(\n             f\"Using calculated num_blocks={num_blocks}, block_size={block_size}, max concurrent requests {max_batch_tokens}\"\n         )\n@@ -960,7 +962,14 @@ def _build_tensors(\n \n     @traced\n     def _sync(self):\n-        return self.output_ids.tolist()[0]  # should be the only synch we do\n+        if self.output_ids is not None:\n+            try:\n+                out = self.output_ids.tolist()[0]  # should be the only synch we do\n+            except Exception:\n+                out = [0, 1]\n+        else:\n+            out = [0, 0]\n+        return out\n \n     @traced\n     def _maybe_send_output(self, state: RequestState, token: int):\n@@ -1250,7 +1259,7 @@ def _run_generation_loop(self):\n                 self.model.device,\n                 self.model.dtype,\n                 num_requests=len(self.input_queue.queue),\n-                tp_size=getattr(self.model, \"tp_size\"),\n+                tp_size=getattr(self.model, \"_tp_size\", 8),  # TODO quantized converted don't set this\n             )\n \n             scheduler = None"
        },
        {
            "sha": "390db81867fd06796fd3e54f51d33c1401ce4fc1",
            "filename": "src/transformers/integrations/__init__.py",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fintegrations%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fintegrations%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fintegrations%2F__init__.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -119,6 +119,14 @@\n         \"run_hp_search_sigopt\",\n         \"run_hp_search_wandb\",\n     ],\n+    \"mxfp4\": [\n+        \"Mxfp4GptOssExperts\",\n+        \"convert_moe_packed_tensors\",\n+        \"dequantize\",\n+        \"load_and_swizzle_mxfp4\",\n+        \"quantize_to_mxfp4\",\n+        \"replace_with_mxfp4_linear\",\n+    ],\n     \"peft\": [\"PeftAdapterMixin\"],\n     \"quanto\": [\"replace_with_quanto_layers\"],\n     \"spqr\": [\"replace_with_spqr_linear\"],\n@@ -255,6 +263,13 @@\n         run_hp_search_sigopt,\n         run_hp_search_wandb,\n     )\n+    from .mxfp4 import (\n+        Mxfp4GptOssExperts,\n+        dequantize,\n+        load_and_swizzle_mxfp4,\n+        quantize_to_mxfp4,\n+        replace_with_mxfp4_linear,\n+    )\n     from .peft import PeftAdapterMixin\n     from .quanto import replace_with_quanto_layers\n     from .spqr import replace_with_spqr_linear"
        },
        {
            "sha": "096e3fdf95222bc64b2a6d08edfbfc8c97c3d7be",
            "filename": "src/transformers/integrations/flash_paged.py",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fintegrations%2Fflash_paged.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fintegrations%2Fflash_paged.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fintegrations%2Fflash_paged.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -50,8 +50,10 @@ def paged_attention_forward(\n     \"\"\"\n     k, v = cache.update(k, v, module.layer_idx, cumulative_seqlens_k=cumulative_seqlens_k, **kwargs)\n \n+    sliding_window = (-1, -1) if not getattr(module, \"sliding_window\", False) else (module.sliding_window, 0)\n     if implementation is not None:\n         flash_attn_varlen_func = implementation.flash_attn_varlen_func\n+    custom_kwargs = {\"s_aux\": kwargs.get(\"s_aux\")}\n     attn_output = flash_attn_varlen_func(\n         q.transpose(1, 2).squeeze(0).contiguous(),\n         k.transpose(1, 2).squeeze(0).contiguous(),\n@@ -62,9 +64,9 @@ def paged_attention_forward(\n         max_seqlen_k,\n         softmax_scale=module.scaling,\n         causal=True,  # kind of a must, it automatically aligns the mask for q < k\n-        window_size=(-1, -1),  # -1 means infinite context window\n+        window_size=sliding_window,  # -1 means infinite context window\n         # block_table=block_tables, -> torch.Tensor\n-        # **kwargs,\n+        **custom_kwargs,\n     )\n     if isinstance(attn_output, tuple):\n         attn_output = attn_output[0]"
        },
        {
            "sha": "31d3b3b14d6d8b8ba81de2eaa12e9f10b577d1d2",
            "filename": "src/transformers/integrations/flex_attention.py",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fintegrations%2Fflex_attention.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fintegrations%2Fflex_attention.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fintegrations%2Fflex_attention.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -198,8 +198,8 @@ def default_mask_mod(batch_idx, head_idx, q_idx, kv_idx):\n         mask_mod_maybe_combined = causal_mask_mod if attention_chunk_size is None else chunk_causal_mask_mod\n \n     if offsets is not None:\n-        q_offset = offsets[0]\n-        kv_offset = offsets[1]\n+        q_offset = offsets[0].to(device)\n+        kv_offset = offsets[1].to(device)\n \n         def mask_mod(batch_idx, head_idx, q_idx, kv_idx):\n             offset_q = q_idx + q_offset\n@@ -241,6 +241,7 @@ def flex_attention_forward(\n     scaling: Optional[float] = None,\n     softcap: Optional[float] = None,\n     head_mask: Optional[torch.Tensor] = None,\n+    s_aux: Optional[torch.Tensor] = None,\n     **kwargs,\n ) -> tuple[torch.Tensor, torch.Tensor]:\n     if head_mask is not None:\n@@ -271,6 +272,12 @@ def score_mod(score, batch_idx, head_idx, q_idx, kv_idx):\n             score = score + score_mask[batch_idx][0][q_idx][kv_idx]\n         if head_mask is not None:\n             score = score + head_mask[batch_idx][head_idx][0][0]\n+        if s_aux is not None:\n+            logits_max = torch.max(score, dim=-1, keepdim=True).values\n+            sinks = torch.exp(s_aux - logits_max)\n+            unnormalized_scores = torch.exp(score - logits_max)\n+            normalizer = unnormalized_scores.sum(dim=-1, keepdim=True) + sinks\n+            score = unnormalized_scores / normalizer\n         return score\n \n     enable_gqa = True"
        },
        {
            "sha": "ad5e08d8da4db901e458f64dd18059e4632ecc71",
            "filename": "src/transformers/integrations/hub_kernels.py",
            "status": "modified",
            "additions": 25,
            "deletions": 5,
            "changes": 30,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fintegrations%2Fhub_kernels.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fintegrations%2Fhub_kernels.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fintegrations%2Fhub_kernels.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -18,6 +18,7 @@\n     from kernels import (\n         Device,\n         LayerRepository,\n+        Mode,\n         register_kernel_mapping,\n         replace_kernel_forward_from_hub,\n         use_kernel_forward_from_hub,\n@@ -44,7 +45,14 @@\n                 repo_id=\"kernels-community/liger_kernels\",\n                 layer_name=\"LigerRMSNorm\",\n                 # revision=\"pure-layer-test\",\n-            )\n+            ),\n+            \"rocm\": {\n+                Mode.INFERENCE: LayerRepository(\n+                    repo_id=\"kernels-community/liger_kernels\",\n+                    layer_name=\"LigerRMSNorm\",\n+                    # revision=\"pure-layer-test\",\n+                )\n+            },\n         },\n         \"MLP\": {\n             \"cuda\": LayerRepository(\n@@ -53,10 +61,22 @@\n             )\n         },\n         \"MegaBlocksMoeMLP\": {\n-            \"cuda\": LayerRepository(\n-                repo_id=\"kernels-community/megablocks\",\n-                layer_name=\"MegaBlocksMoeMLP\",\n-            )\n+            \"cuda\": {\n+                Mode.TRAINING: LayerRepository(\n+                    repo_id=\"kernels-community/megablocks\",\n+                    layer_name=\"MegaBlocksMoeMLP\",\n+                ),\n+                Mode.INFERENCE: LayerRepository(\n+                    repo_id=\"kernels-community/megablocks\",\n+                    layer_name=\"MegaBlocksMoeMLP\",\n+                ),\n+            },\n+            \"rocm\": {\n+                Mode.INFERENCE: LayerRepository(\n+                    repo_id=\"ahadnagy/megablocks\",\n+                    layer_name=\"MegaBlocksMoeMLP\",\n+                )\n+            },\n         },\n     }\n "
        },
        {
            "sha": "86517671b5f30d402027584990079acebab20a18",
            "filename": "src/transformers/integrations/mxfp4.py",
            "status": "added",
            "additions": 470,
            "deletions": 0,
            "changes": 470,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fintegrations%2Fmxfp4.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fintegrations%2Fmxfp4.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fintegrations%2Fmxfp4.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -0,0 +1,470 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from ..utils import is_accelerate_available, is_torch_available, logging\n+\n+\n+if is_torch_available():\n+    import torch\n+    from torch import nn\n+\n+if is_accelerate_available():\n+    from accelerate import init_empty_weights\n+\n+import re\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+FP4_VALUES = [\n+    +0.0,\n+    +0.5,\n+    +1.0,\n+    +1.5,\n+    +2.0,\n+    +3.0,\n+    +4.0,\n+    +6.0,\n+    -0.0,\n+    -0.5,\n+    -1.0,\n+    -1.5,\n+    -2.0,\n+    -3.0,\n+    -4.0,\n+    -6.0,\n+]\n+\n+\n+# Copied from GPT_OSS repo and vllm\n+def quantize_to_mxfp4(w):\n+    from triton_kernels.numerics_details.mxfp import downcast_to_mxfp\n+\n+    w, w_scale = downcast_to_mxfp(w.to(torch.bfloat16), torch.uint8, axis=1)\n+    w, w_scale = swizzle_mxfp4(w, w_scale)\n+    return w, w_scale\n+\n+\n+def swizzle_mxfp4(w, w_scale):\n+    from triton_kernels.tensor import FP4, convert_layout, wrap_torch_tensor\n+    from triton_kernels.tensor_details import layout\n+    from triton_kernels.tensor_details.layout import StridedLayout\n+\n+    value_layout, value_layout_opts = layout.make_default_matmul_mxfp4_w_layout(mx_axis=1)\n+    w = convert_layout(wrap_torch_tensor(w, dtype=FP4), value_layout, **value_layout_opts)\n+    # TODO : add that when we are actually sure that it works on B200\n+    # if torch.cuda.get_device_capability()[0] == 10:\n+    #     constraints = {\n+    #         \"is_persistent\": True,\n+    #         \"epilogue_subtile\": 1,\n+    #     }\n+    #     opt_flags.update_opt_flags_constraints(constraints)\n+    # # transpose the tensor so that the quantization axis is on dim1\n+\n+    # TODO: there is still an issue with the scales on hopper\n+    # scale_layout, scale_layout_opts = layout.make_default_matmul_mxfp4_w_scale_layout(mx_axis=1, num_warps=8)\n+    # w_scale = convert_layout(wrap_torch_tensor(w_scale), scale_layout, **scale_layout_opts)\n+    w_scale = convert_layout(wrap_torch_tensor(w_scale), StridedLayout)\n+    return w, w_scale\n+\n+\n+# Copied from GPT_OSS repo\n+# TODO: Add absolute link when the repo is public\n+def convert_moe_packed_tensors(\n+    blocks,\n+    scales,\n+    *,\n+    dtype: torch.dtype = torch.bfloat16,\n+    rows_per_chunk: int = 32768 * 1024,\n+) -> torch.Tensor:\n+    import math\n+\n+    # Check if blocks and scales are on CPU, and move to GPU if so\n+    if not blocks.is_cuda and torch.cuda.is_available():\n+        blocks = blocks.cuda()\n+        scales = scales.cuda()\n+\n+    scales = scales.to(torch.int32) - 127\n+\n+    assert blocks.shape[:-1] == scales.shape, f\"{blocks.shape=} does not match {scales.shape=}\"\n+\n+    lut = torch.tensor(FP4_VALUES, dtype=dtype, device=blocks.device)\n+\n+    *prefix_shape, G, B = blocks.shape\n+    rows_total = math.prod(prefix_shape) * G\n+\n+    blocks = blocks.reshape(rows_total, B)\n+    scales = scales.reshape(rows_total, 1)\n+\n+    out = torch.empty(rows_total, B * 2, dtype=dtype, device=blocks.device)\n+\n+    for r0 in range(0, rows_total, rows_per_chunk):\n+        r1 = min(r0 + rows_per_chunk, rows_total)\n+\n+        blk = blocks[r0:r1]\n+        exp = scales[r0:r1]\n+\n+        # nibble indices -> int64\n+        idx_lo = (blk & 0x0F).to(torch.long)\n+        idx_hi = (blk >> 4).to(torch.long)\n+\n+        sub = out[r0:r1]\n+        sub[:, 0::2] = lut[idx_lo]\n+        sub[:, 1::2] = lut[idx_hi]\n+\n+        torch.ldexp(sub, exp, out=sub)\n+        del idx_lo, idx_hi, blk, exp, sub\n+\n+    out = out.reshape(*prefix_shape, G, B * 2).view(*prefix_shape, G * B * 2)\n+\n+    # TODO: Delete after making sure this is not necessary! since we go back to cpu in the end in create_quantized_param using .to(target_device)\n+    # Move back to CPU if needed\n+    # if need_to_move_back:\n+    #     out = out.cpu()\n+    del blocks, scales, lut\n+    return out\n+\n+\n+class Mxfp4GptOssExperts(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+\n+        self.num_experts = config.num_local_experts\n+        self.intermediate_size = config.intermediate_size\n+        self.hidden_size = config.hidden_size\n+\n+        self.gate_up_proj_blocks = nn.Parameter(\n+            torch.zeros(self.num_experts, 2 * self.intermediate_size, self.hidden_size // 32, 16, dtype=torch.uint8),\n+            requires_grad=False,\n+        )\n+        self.gate_up_proj_scales = nn.Parameter(\n+            torch.zeros(self.num_experts, 2 * self.intermediate_size, self.hidden_size // 32, dtype=torch.uint8),\n+            requires_grad=False,\n+        )\n+        self.gate_up_proj_bias = nn.Parameter(\n+            torch.zeros(self.num_experts, 2 * self.intermediate_size, dtype=torch.float32), requires_grad=False\n+        )\n+\n+        self.down_proj_blocks = nn.Parameter(\n+            torch.zeros((self.num_experts, self.hidden_size, self.intermediate_size // 32, 16), dtype=torch.uint8),\n+            requires_grad=False,\n+        )\n+        self.down_proj_scales = nn.Parameter(\n+            torch.zeros(self.num_experts, self.hidden_size, self.intermediate_size // 32, dtype=torch.uint8),\n+            requires_grad=False,\n+        )\n+        self.down_proj_bias = nn.Parameter(\n+            torch.zeros(self.num_experts, self.hidden_size, dtype=torch.float32), requires_grad=False\n+        )\n+        self.alpha = 1.702\n+\n+        self.gate_up_proj_precision_config = None\n+        self.down_proj_precision_config = None\n+\n+    def forward(self, hidden_states: torch.Tensor, routing_data, gather_idx, scatter_idx) -> torch.Tensor:\n+        from triton_kernels.matmul_ogs import FnSpecs, FusedActivation, matmul_ogs\n+        from triton_kernels.swiglu import swiglu_fn\n+\n+        with torch.cuda.device(hidden_states.device):\n+            act = FusedActivation(FnSpecs(\"swiglu\", swiglu_fn, (\"alpha\", \"limit\")), (self.alpha, None), 2)\n+\n+            intermediate_cache1 = matmul_ogs(\n+                hidden_states,\n+                self.gate_up_proj,\n+                self.gate_up_proj_bias.to(torch.float32),\n+                routing_data,\n+                gather_indx=gather_idx,\n+                precision_config=self.gate_up_proj_precision_config,\n+                gammas=None,\n+                fused_activation=act,\n+            )\n+\n+            intermediate_cache3 = matmul_ogs(\n+                intermediate_cache1,\n+                self.down_proj,\n+                self.down_proj_bias.to(torch.float32),\n+                routing_data,\n+                scatter_indx=scatter_idx,\n+                precision_config=self.down_proj_precision_config,\n+                gammas=routing_data.gate_scal,\n+            )\n+\n+        return intermediate_cache3\n+\n+\n+# Adapted from GPT_OSS repo\n+# TODO: Add absolute link when the repo is public\n+def routing_torch_dist(\n+    logits,\n+    n_expts_act,\n+):\n+    import os\n+\n+    from triton_kernels.routing import GatherIndx, RoutingData, ScatterIndx, compute_expt_data_torch\n+\n+    with torch.cuda.device(logits.device):\n+        world_size = torch.distributed.get_world_size()\n+        rank = int(os.environ.get(\"LOCAL_RANK\", 0))\n+        replace_value = -1\n+\n+        n_tokens = logits.shape[0]\n+        n_expts_tot = logits.shape[1]\n+\n+        n_local_experts = n_expts_tot // world_size\n+        local_expert_start = rank * n_local_experts\n+        local_expert_end = (rank + 1) * n_local_experts\n+\n+        n_gates_pad = n_tokens * n_expts_act\n+\n+        def topk(vals, k):\n+            tk_indx = torch.argsort(-vals, dim=1, stable=True)[:, :k]\n+            tk_indx = tk_indx.long()\n+            tk_val = torch.take_along_dim(vals, tk_indx, dim=1)\n+            return tk_val, tk_indx.int()\n+\n+        expt_scal, expt_indx = topk(logits, n_expts_act)\n+        expt_scal = torch.softmax(expt_scal, dim=-1)\n+        expt_indx, sort_indices = torch.sort(expt_indx, dim=1)\n+        expt_scal = torch.gather(expt_scal, 1, sort_indices)\n+\n+        # Flatten and mask for local experts\n+        expt_scal = expt_scal.reshape(-1)\n+\n+        hist = torch.histc(expt_indx, bins=n_expts_tot, max=n_expts_tot - 1)[local_expert_start:local_expert_end]\n+\n+        expt_indx = expt_indx.view(-1).to(torch.int32)\n+\n+        # we use a large value to replace the indices that are not in the local expert range\n+        var = 1000\n+        expt_indx = torch.where(expt_indx < local_expert_start, var, expt_indx)\n+        topk_indx = torch.argsort(expt_indx, stable=True).to(torch.int32)\n+        gate_indx = torch.argsort(topk_indx).to(torch.int32)\n+        expt_indx = torch.where(expt_indx < local_expert_end, expt_indx, replace_value)\n+        expt_indx = torch.where(local_expert_start <= expt_indx, expt_indx, replace_value)\n+\n+        gate_indx = torch.where(expt_indx == replace_value, replace_value, gate_indx)\n+        gate_scal = expt_scal[topk_indx]\n+\n+        topk_indx = torch.where(gate_indx[topk_indx] == replace_value, replace_value, topk_indx)\n+\n+        # # Routing metadata for local expert computation\n+        gather_indx = GatherIndx(src_indx=topk_indx.int(), dst_indx=gate_indx.int())\n+        scatter_indx = ScatterIndx(src_indx=gate_indx.int(), dst_indx=topk_indx.int())\n+\n+        expt_data = compute_expt_data_torch(hist, n_local_experts, n_gates_pad)\n+\n+        hitted_experts = n_expts_act\n+    return RoutingData(gate_scal, hist, n_local_experts, hitted_experts, expt_data), gather_indx, scatter_indx\n+\n+\n+def mlp_forward(self, hidden_states):\n+    import torch.distributed as dist\n+\n+    if dist.is_available() and dist.is_initialized():\n+        routing = routing_torch_dist\n+    else:\n+        from triton_kernels.routing import routing\n+\n+        routing = routing\n+    batch_size = hidden_states.shape[0]\n+    hidden_states = hidden_states.reshape(-1, self.router.hidden_dim)\n+    router_logits = nn.functional.linear(hidden_states, self.router.weight, self.router.bias)\n+    routing_data, gather_idx, scatter_idx = routing(router_logits, self.router.top_k)\n+    routed_out = self.experts(hidden_states, routing_data, gather_idx, scatter_idx)\n+    routed_out = routed_out.reshape(batch_size, -1, self.router.hidden_dim)\n+    return routed_out, router_logits\n+\n+\n+def should_convert_module(current_key_name, patterns):\n+    current_key_name_str = \".\".join(current_key_name)\n+    if not any(\n+        re.match(f\"{key}\\\\.\", current_key_name_str) or re.match(f\"{key}\", current_key_name_str) for key in patterns\n+    ):\n+        return True\n+    return False\n+\n+\n+def dequantize(module, param_name, param_value, target_device, dq_param_name, **kwargs):\n+    from ..integrations.tensor_parallel import shard_and_distribute_module\n+\n+    model = kwargs.get(\"model\", None)\n+    empty_param = kwargs.get(\"empty_param\", None)\n+    casting_dtype = kwargs.get(\"casting_dtype\", None)\n+    to_contiguous = kwargs.get(\"to_contiguous\", None)\n+    rank = kwargs.get(\"rank\", None)\n+    device_mesh = kwargs.get(\"device_mesh\", None)\n+\n+    for proj in [\"gate_up_proj\", \"down_proj\"]:\n+        if proj in param_name:\n+            if device_mesh is not None:\n+                param_value = shard_and_distribute_module(\n+                    model,\n+                    param_value,\n+                    empty_param,\n+                    dq_param_name,\n+                    casting_dtype,\n+                    to_contiguous,\n+                    rank,\n+                    device_mesh,\n+                    set_param=False,\n+                )\n+            blocks_attr = f\"{proj}_blocks\"\n+            scales_attr = f\"{proj}_scales\"\n+            setattr(module, param_name.rsplit(\".\", 1)[1], param_value)\n+            if hasattr(module, blocks_attr) and hasattr(module, scales_attr):\n+                dequantized = convert_moe_packed_tensors(getattr(module, blocks_attr), getattr(module, scales_attr))\n+                dequantized = dequantized.transpose(1, 2).contiguous().to(target_device)\n+                # TODO: this is perhaps necessary since if target_device is cpu, and the param was on gpu\n+                if target_device == \"cpu\" and torch.cuda.is_available():\n+                    torch.cuda.empty_cache()\n+                setattr(module, proj, torch.nn.Parameter(dequantized))\n+                delattr(module, blocks_attr)\n+                delattr(module, scales_attr)\n+\n+\n+def load_and_swizzle_mxfp4(module, param_name, param_value, target_device, **kwargs):\n+    from triton_kernels.matmul_ogs import FlexCtx, InFlexData, PrecisionConfig\n+\n+    from ..integrations.tensor_parallel import shard_and_distribute_module\n+\n+    model = kwargs.get(\"model\", None)\n+    empty_param = kwargs.get(\"empty_param\", None)\n+    casting_dtype = kwargs.get(\"casting_dtype\", None)\n+    to_contiguous = kwargs.get(\"to_contiguous\", None)\n+    rank = kwargs.get(\"rank\", None)\n+    device_mesh = kwargs.get(\"device_mesh\", None)\n+\n+    for proj in [\"gate_up_proj\", \"down_proj\"]:\n+        if proj in param_name:\n+            if device_mesh is not None:\n+                shard_and_distribute_module(\n+                    model, param_value, empty_param, param_name, casting_dtype, to_contiguous, rank, device_mesh\n+                )\n+            else:\n+                setattr(module, param_name.rsplit(\".\", 1)[1], torch.nn.Parameter(param_value, requires_grad=False))\n+            blocks_attr = f\"{proj}_blocks\"\n+            scales_attr = f\"{proj}_scales\"\n+            blocks = getattr(module, blocks_attr)\n+            scales = getattr(module, scales_attr)\n+            # Check if both blocks and scales both not on on meta device\n+            if blocks.device.type != \"meta\" and scales.device.type != \"meta\":\n+                # need it for ep\n+                local_experts = blocks.size(0)\n+                if proj == \"gate_up_proj\":\n+                    blocks = blocks.view(local_experts, module.intermediate_size * 2, -1)\n+                else:\n+                    blocks = blocks.view(local_experts, -1, module.intermediate_size // 2)\n+                # TODO: we need to have the weights on cuda, refactor later\n+                if getattr(target_device, \"type\", target_device) == \"cpu\":\n+                    target_device = \"cuda\"\n+                # TODO: check why we still do move the tensors despite the context manager\n+                blocks = blocks.to(target_device)\n+                scales = scales.to(target_device)\n+                with torch.cuda.device(target_device):\n+                    triton_weight_tensor, weight_scale = swizzle_mxfp4(\n+                        blocks.transpose(-2, -1), scales.transpose(-2, -1)\n+                    )\n+\n+                # need to overwrite the shapes for the kernels\n+                if proj == \"gate_up_proj\":\n+                    triton_weight_tensor.shape = torch.Size(\n+                        [local_experts, module.hidden_size, module.intermediate_size * 2]\n+                    )\n+                else:\n+                    triton_weight_tensor.shape = torch.Size(\n+                        [local_experts, module.intermediate_size, module.hidden_size]\n+                    )\n+\n+                # triton_weight_tensor is what needs to be passed in oai kernels. It stores the data, the shapes and any more objects. It is like a subtensor\n+                setattr(module, proj, triton_weight_tensor)\n+                setattr(\n+                    module,\n+                    f\"{proj}_precision_config\",\n+                    PrecisionConfig(weight_scale=weight_scale, flex_ctx=FlexCtx(rhs_data=InFlexData())),\n+                )\n+\n+                # delete blocks and scales\n+                delattr(module, scales_attr)\n+                delattr(module, blocks_attr)\n+                # setattr(module, blocks_attr, torch.nn.Parameter(triton_weight_tensor.storage.data, requires_grad=False))\n+                del blocks\n+\n+\n+def _replace_with_mxfp4_linear(\n+    model,\n+    modules_to_not_convert=None,\n+    current_key_name=None,\n+    quantization_config=None,\n+    has_been_replaced=False,\n+    config=None,\n+):\n+    if current_key_name is None:\n+        current_key_name = []\n+\n+    for name, module in model.named_children():\n+        current_key_name.append(name)\n+        if not should_convert_module(current_key_name, modules_to_not_convert):\n+            current_key_name.pop(-1)\n+            continue\n+        if module.__class__.__name__ == \"GptOssExperts\" and not quantization_config.dequantize:\n+            with init_empty_weights():\n+                model._modules[name] = Mxfp4GptOssExperts(config)\n+                has_been_replaced = True\n+        if module.__class__.__name__ == \"GptOssMLP\" and not quantization_config.dequantize:\n+            from types import MethodType\n+\n+            module.forward = MethodType(mlp_forward, module)\n+        if len(list(module.children())) > 0:\n+            _, has_been_replaced = _replace_with_mxfp4_linear(\n+                module,\n+                modules_to_not_convert,\n+                current_key_name,\n+                quantization_config,\n+                has_been_replaced=has_been_replaced,\n+                config=config,\n+            )\n+        current_key_name.pop(-1)\n+    return model, has_been_replaced\n+\n+\n+def replace_with_mxfp4_linear(\n+    model,\n+    modules_to_not_convert=None,\n+    current_key_name=None,\n+    quantization_config=None,\n+    config=None,\n+):\n+    if quantization_config.dequantize:\n+        return model\n+\n+    modules_to_not_convert = [\"lm_head\"] if modules_to_not_convert is None else modules_to_not_convert\n+\n+    if quantization_config.modules_to_not_convert is not None:\n+        modules_to_not_convert.extend(quantization_config.modules_to_not_convert)\n+    modules_to_not_convert = list(set(modules_to_not_convert))\n+    model, has_been_replaced = _replace_with_mxfp4_linear(\n+        model,\n+        modules_to_not_convert,\n+        current_key_name,\n+        quantization_config,\n+        config=config,\n+    )\n+    if not has_been_replaced:\n+        logger.warning(\n+            \"You are loading your model using mixed-precision FP4 quantization but no linear modules were found in your model.\"\n+            \" Please double check your model architecture, or submit an issue on github if you think this is\"\n+            \" a bug.\"\n+        )\n+\n+    return model"
        },
        {
            "sha": "ff429b9dc744d94dc48c19113c0260a13eeb1947",
            "filename": "src/transformers/integrations/tensor_parallel.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fintegrations%2Ftensor_parallel.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fintegrations%2Ftensor_parallel.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fintegrations%2Ftensor_parallel.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -657,7 +657,7 @@ def partition_tensor(self, param, empty_param, param_type, param_casting_dtype,\n     @staticmethod\n     def _prepare_input_fn(input_layouts, desired_input_layouts, mod, inputs, device_mesh):\n         if hasattr(mod, \"bias\") and mod.bias is not None:\n-            mod._bias = mod.bias\n+            mod._bias = mod.bias.to_local()\n             mod.bias = None\n \n         input_tensor = inputs[0]\n@@ -997,7 +997,7 @@ def add_tensor_parallel_hooks_to_module(\n \n \n def shard_and_distribute_module(\n-    model, param, empty_param, parameter_name, param_casting_dtype, is_contiguous, rank, device_mesh\n+    model, param, empty_param, parameter_name, param_casting_dtype, is_contiguous, rank, device_mesh, set_param=True\n ):  # TODO: rename to shard_and_distribute_param\n     r\"\"\"\n     This function is called in `from_pretrained` when loading a model's checkpoints."
        },
        {
            "sha": "9015729175614fb1b0336ad0a2ffb99813cb4fa3",
            "filename": "src/transformers/masking_utils.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmasking_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmasking_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmasking_utils.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -48,7 +48,7 @@ def and_masks(*mask_functions: list[Callable]) -> Callable:\n     def and_mask(batch_idx, head_idx, q_idx, kv_idx):\n         result = q_idx.new_ones((), dtype=torch.bool)\n         for mask in mask_functions:\n-            result = result & mask(batch_idx, head_idx, q_idx, kv_idx)\n+            result = result & mask(batch_idx, head_idx, q_idx, kv_idx).to(result.device)\n         return result\n \n     return and_mask\n@@ -62,7 +62,7 @@ def or_masks(*mask_functions: list[Callable]) -> Callable:\n     def or_mask(batch_idx, head_idx, q_idx, kv_idx):\n         result = q_idx.new_zeros((), dtype=torch.bool)\n         for mask in mask_functions:\n-            result = result | mask(batch_idx, head_idx, q_idx, kv_idx)\n+            result = result | mask(batch_idx, head_idx, q_idx, kv_idx).to(result.device)\n         return result\n \n     return or_mask"
        },
        {
            "sha": "bfab3470397118d18bfcd16188e350092137f6c7",
            "filename": "src/transformers/modeling_flash_attention_utils.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodeling_flash_attention_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodeling_flash_attention_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodeling_flash_attention_utils.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -389,7 +389,8 @@ def _flash_attention_forward(\n         flash_kwargs[\"deterministic\"] = det\n     if softcap is not None:\n         flash_kwargs[\"softcap\"] = softcap\n-\n+    if \"s_aux\" in kwargs:\n+        flash_kwargs[\"s_aux\"] = kwargs.get(\"s_aux\")\n     query_states, key_states, value_states = fa_peft_integration_check(\n         query_states, key_states, value_states, target_dtype\n     )"
        },
        {
            "sha": "04b2f5ccccfe8c8e28418084156534910d539879",
            "filename": "src/transformers/modeling_rope_utils.py",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodeling_rope_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodeling_rope_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodeling_rope_utils.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -252,10 +252,13 @@ def find_correction_dim(num_rotations, dim, base, max_position_embeddings):\n         \"\"\"Inverse dimension formula to find the dimension based on the number of rotations\"\"\"\n         return (dim * math.log(max_position_embeddings / (num_rotations * 2 * math.pi))) / (2 * math.log(base))\n \n-    def find_correction_range(low_rot, high_rot, dim, base, max_position_embeddings):\n+    def find_correction_range(low_rot, high_rot, dim, base, max_position_embeddings, truncate):\n         \"\"\"Find dimension range bounds based on rotations\"\"\"\n-        low = math.floor(find_correction_dim(low_rot, dim, base, max_position_embeddings))\n-        high = math.ceil(find_correction_dim(high_rot, dim, base, max_position_embeddings))\n+        low = find_correction_dim(low_rot, dim, base, max_position_embeddings)\n+        high = find_correction_dim(high_rot, dim, base, max_position_embeddings)\n+        if truncate:\n+            low = low = math.floor(low)\n+            high = math.ceil(high)\n         return max(low, 0), min(high, dim - 1)\n \n     def linear_ramp_factor(min, max, dim):\n@@ -272,7 +275,8 @@ def linear_ramp_factor(min, max, dim):\n     inv_freq_extrapolation = 1.0 / pos_freqs\n     inv_freq_interpolation = 1.0 / (factor * pos_freqs)\n \n-    low, high = find_correction_range(beta_fast, beta_slow, dim, base, original_max_position_embeddings)\n+    truncate = config.rope_scaling.get(\"truncate\", True)\n+    low, high = find_correction_range(beta_fast, beta_slow, dim, base, original_max_position_embeddings, truncate)\n \n     # Get n-dimensional rotational scaling corrected for extrapolation\n     inv_freq_extrapolation_factor = 1 - linear_ramp_factor(low, high, dim // 2).to(device=device, dtype=torch.float)\n@@ -465,6 +469,7 @@ def _validate_yarn_parameters(config: PretrainedConfig, ignore_keys: Optional[se\n         \"original_max_position_embeddings\",\n         \"mscale\",\n         \"mscale_all_dim\",\n+        \"truncate\",\n     }\n     received_keys = set(rope_scaling.keys())\n     _check_received_keys(rope_type, received_keys, required_keys, optional_keys, ignore_keys=ignore_keys)"
        },
        {
            "sha": "0eab1cbab9d8356bd89a78c7386f6ae99b91c37d",
            "filename": "src/transformers/modeling_utils.py",
            "status": "modified",
            "additions": 80,
            "deletions": 26,
            "changes": 106,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodeling_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodeling_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodeling_utils.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -51,6 +51,7 @@\n     from torchao.quantization import Int4WeightOnlyConfig\n \n from .configuration_utils import PretrainedConfig\n+from .distributed import DistributedConfig\n from .dynamic_module_utils import custom_object_save\n from .generation import CompileConfig, GenerationConfig\n from .integrations import PeftAdapterMixin, deepspeed_config, is_deepspeed_zero3_enabled\n@@ -709,6 +710,7 @@ def _infer_parameter_dtype(\n         if hf_quantizer is not None and hf_quantizer.quantization_config.quant_method in {\n             QuantizationMethod.HQQ,\n             QuantizationMethod.QUARK,\n+            QuantizationMethod.MXFP4,\n         }:\n             return True, None\n         else:\n@@ -778,17 +780,15 @@ def _load_state_dict_into_meta_model(\n         file_pointer = safe_open(shard_file, framework=\"pt\", device=tensor_device)\n \n     for param_name, empty_param in state_dict.items():\n-        if param_name not in expected_keys:\n+        if param_name not in expected_keys:  # when loading from ckpt, we skip param if doesnt exist in modeling\n             continue\n-\n         # we need to use serialized_param_name as file pointer is untouched\n         if is_meta_state_dict:\n             # This is the name of the parameter as it appears on disk file\n             serialized_param_name = reverse_renaming_mapping[param_name]\n             param = file_pointer.get_slice(serialized_param_name)\n         else:\n             param = empty_param.to(tensor_device)  # It is actually not empty!\n-\n         to_contiguous, casting_dtype = _infer_parameter_dtype(\n             model,\n             param_name,\n@@ -797,17 +797,47 @@ def _load_state_dict_into_meta_model(\n             hf_quantizer,\n         )\n \n-        if device_mesh is not None:  # In this case, the param is already on the correct device!\n-            shard_and_distribute_module(\n-                model,\n-                param,\n-                empty_param,\n-                param_name,\n-                casting_dtype,\n-                to_contiguous,\n-                device_mesh.get_local_rank(),\n-                device_mesh,\n-            )\n+        if device_mesh is not None:\n+            if (\n+                not is_quantized\n+                or (not hf_quantizer.requires_parameters_quantization)\n+                or (\n+                    not hf_quantizer.check_quantized_param(\n+                        model,\n+                        param,\n+                        param_name,\n+                        state_dict,\n+                        device_map=device_map,\n+                    )\n+                )\n+            ):  # In this case, the param is already on the correct device!\n+                shard_and_distribute_module(\n+                    model,\n+                    param,\n+                    empty_param,\n+                    param_name,\n+                    casting_dtype,\n+                    to_contiguous,\n+                    device_mesh.get_local_rank(),\n+                    device_mesh,\n+                )\n+            else:  # we have a device mesh but the param needs to be quantized, so we shard inside create_quantized_param:\n+                sharding_kwargs = {\n+                    \"empty_param\": empty_param,\n+                    \"casting_dtype\": casting_dtype,\n+                    \"to_contiguous\": to_contiguous,\n+                    \"rank\": device_mesh.get_local_rank(),\n+                    \"device_mesh\": device_mesh,\n+                }\n+                hf_quantizer.create_quantized_param(\n+                    model,\n+                    param,\n+                    param_name,\n+                    device_mesh.get_local_rank(),\n+                    state_dict,\n+                    unexpected_keys,\n+                    **sharding_kwargs,\n+                )\n         else:\n             param = param[...]\n             if casting_dtype is not None:\n@@ -852,17 +882,24 @@ def _load_state_dict_into_meta_model(\n                 hf_quantizer.create_quantized_param(\n                     model, param, param_name, param_device, state_dict, unexpected_keys\n                 )\n+\n                 # For quantized modules with FSDP/DeepSpeed Stage 3, we need to quantize the parameter on the GPU\n                 # and then cast it to CPU to avoid excessive memory usage on each GPU\n                 # in comparison to the sharded model across GPUs.\n                 if is_fsdp_enabled() or is_deepspeed_zero3_enabled():\n+                    param_name = hf_quantizer.update_param_name(param_name)\n                     module, param_type = get_module_from_name(model, param_name)\n                     value = getattr(module, param_type)\n+                    # special case for GptOssForCausalLM, we wait for the param to be leave the meta device before casting it to cpu\n+                    if model.__class__.__name__ == \"GptOssForCausalLM\" and value.device.type == \"meta\":\n+                        continue\n                     param_to = \"cpu\"\n                     if is_fsdp_enabled() and not is_local_dist_rank_0():\n                         param_to = \"meta\"\n                     val_kwargs = {}\n-                    if hasattr(module, \"weight\") and module.weight.__class__.__name__ == \"Int8Params\":\n+                    if (hasattr(module, \"weight\") and module.weight.__class__.__name__ == \"Int8Params\") or (\n+                        value.dtype == torch.uint8 or value.dtype == torch.int8\n+                    ):\n                         val_kwargs[\"requires_grad\"] = False\n                     value = type(value)(value.data.to(param_to), **val_kwargs, **value.__dict__)\n                     setattr(module, param_type, value)\n@@ -4578,7 +4615,6 @@ def from_pretrained(\n         load_in_8bit = kwargs.pop(\"load_in_8bit\", False)\n         load_in_4bit = kwargs.pop(\"load_in_4bit\", False)\n         quantization_config = kwargs.pop(\"quantization_config\", None)\n-        distributed_config = kwargs.pop(\"distributed_config\", None)\n         subfolder = kwargs.pop(\"subfolder\", \"\")\n         commit_hash = kwargs.pop(\"_commit_hash\", None)\n         variant = kwargs.pop(\"variant\", None)\n@@ -4588,6 +4624,7 @@ def from_pretrained(\n         gguf_file = kwargs.pop(\"gguf_file\", None)\n         tp_plan = kwargs.pop(\"tp_plan\", None)\n         tp_size = kwargs.pop(\"tp_size\", None)\n+        distributed_config: DistributedConfig = kwargs.pop(\"distributed_config\", None)\n         device_mesh = kwargs.pop(\"device_mesh\", None)\n         trust_remote_code = kwargs.pop(\"trust_remote_code\", None)\n         use_kernels = kwargs.pop(\"use_kernels\", False)\n@@ -4851,10 +4888,9 @@ def from_pretrained(\n             config = hf_quantizer.update_tp_plan(config)\n \n             # In order to ensure popular quantization methods are supported. Can be disable with `disable_telemetry`\n-            if hasattr(hf_quantizer.quantization_config.quant_method, \"value\"):\n-                user_agent[\"quant\"] = hf_quantizer.quantization_config.quant_method.value\n-            else:\n-                user_agent[\"quant\"] = hf_quantizer.quantization_config.quant_method\n+            if not getattr(hf_quantizer.quantization_config, \"dequantize\", False):\n+                quant_method = hf_quantizer.quantization_config.quant_method\n+                user_agent[\"quant\"] = getattr(quant_method, \"value\", quant_method)\n \n         if gguf_file is not None and hf_quantizer is not None:\n             raise ValueError(\n@@ -4949,9 +4985,6 @@ def from_pretrained(\n             # Let's make sure we don't run the init function of buffer modules\n             model = cls(config, *model_args, **model_kwargs)\n \n-        if _torch_distributed_available and device_mesh is not None:\n-            model = distribute_model(model, distributed_config, device_mesh, tp_size)\n-\n         # Make sure to tie the weights correctly\n         model.tie_weights()\n \n@@ -4980,7 +5013,11 @@ def from_pretrained(\n \n         if hf_quantizer is not None:\n             hf_quantizer.preprocess_model(\n-                model=model, device_map=device_map, keep_in_fp32_modules=model._keep_in_fp32_modules, config=config\n+                model=model,\n+                device_map=device_map,\n+                keep_in_fp32_modules=model._keep_in_fp32_modules,\n+                config=config,\n+                use_kernels=use_kernels,\n             )\n             # We store the original dtype for quantized models as we cannot easily retrieve it\n             # once the weights have been quantized\n@@ -4997,6 +5034,9 @@ def _assign_original_dtype(module):\n             config._pre_quantization_dtype = original_dtype\n             _assign_original_dtype(model)\n \n+        if _torch_distributed_available and device_mesh is not None:\n+            model = distribute_model(model, distributed_config, device_mesh, tp_size)\n+\n         # Prepare the full device map\n         if device_map is not None:\n             device_map = _get_device_map(model, device_map, max_memory, hf_quantizer, torch_dtype, keep_in_fp32_regex)\n@@ -5043,6 +5083,11 @@ def _assign_original_dtype(module):\n \n         # check if using kernels\n         if use_kernels:\n+            if not is_kernels_available():\n+                raise ValueError(\n+                    \"Kernels are not available. To use kernels, please install kernels using `pip install kernels`\"\n+                )\n+\n             from kernels import Device, kernelize\n \n             kernelize(model, device=Device(type=model.device.type))\n@@ -5116,8 +5161,8 @@ def _assign_original_dtype(module):\n                 dispatch_model(model, **device_map_kwargs)\n \n         if hf_quantizer is not None:\n-            hf_quantizer.postprocess_model(model, config=config)\n             model.hf_quantizer = hf_quantizer\n+            hf_quantizer.postprocess_model(model, config=config)\n \n         if _adapter_model_path is not None:\n             adapter_kwargs[\"key_mapping\"] = key_mapping\n@@ -6029,7 +6074,16 @@ def caching_allocator_warmup(model: PreTrainedModel, expanded_device_map: dict,\n         if param_name in tied_param_names:\n             continue\n \n-        param = model.get_parameter_or_buffer(param_name)\n+        # For example in the case of MXFP4 quantization, we need to update the param name to the original param name\n+        # because the checkpoint contains blocks, and scales, but since we are dequantizing, we need to use the original param name\n+        if hf_quantizer is not None:\n+            param_name = hf_quantizer.update_param_name(param_name)\n+\n+        try:\n+            param = model.get_parameter_or_buffer(param_name)\n+        except AttributeError:\n+            raise AttributeError(f\"Parameter {param_name} not found in model\")\n+\n         # The dtype of different parameters may be different with composite models or `keep_in_fp32_modules`\n         param_byte_count = param.numel() * param.element_size()\n "
        },
        {
            "sha": "704c4950895ade44bdce213e840e21b8317cba09",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -140,6 +140,7 @@\n     from .gpt_neo import *\n     from .gpt_neox import *\n     from .gpt_neox_japanese import *\n+    from .gpt_oss import *\n     from .gpt_sw3 import *\n     from .gptj import *\n     from .granite import *"
        },
        {
            "sha": "15d10c7566185a66a5a088c1486446b916b863b3",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -172,6 +172,7 @@\n         (\"gpt_neo\", \"GPTNeoConfig\"),\n         (\"gpt_neox\", \"GPTNeoXConfig\"),\n         (\"gpt_neox_japanese\", \"GPTNeoXJapaneseConfig\"),\n+        (\"gpt_oss\", \"GptOssConfig\"),\n         (\"gptj\", \"GPTJConfig\"),\n         (\"gptsan-japanese\", \"GPTSanJapaneseConfig\"),\n         (\"granite\", \"GraniteConfig\"),\n@@ -577,6 +578,7 @@\n         (\"gpt_neo\", \"GPT Neo\"),\n         (\"gpt_neox\", \"GPT NeoX\"),\n         (\"gpt_neox_japanese\", \"GPT NeoX Japanese\"),\n+        (\"gpt_oss\", \"GptOss\"),\n         (\"gptj\", \"GPT-J\"),\n         (\"gptsan-japanese\", \"GPTSAN-japanese\"),\n         (\"granite\", \"Granite\"),"
        },
        {
            "sha": "5554de103cbba8dbac73bcc0608e47fdbfed5597",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -174,6 +174,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"gpt_neo\", \"GPTNeoModel\"),\n         (\"gpt_neox\", \"GPTNeoXModel\"),\n         (\"gpt_neox_japanese\", \"GPTNeoXJapaneseModel\"),\n+        (\"gpt_oss\", \"GptOssModel\"),\n         (\"gptj\", \"GPTJModel\"),\n         (\"gptsan-japanese\", \"GPTSanJapaneseForConditionalGeneration\"),\n         (\"granite\", \"GraniteModel\"),\n@@ -642,6 +643,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"gpt_neo\", \"GPTNeoForCausalLM\"),\n         (\"gpt_neox\", \"GPTNeoXForCausalLM\"),\n         (\"gpt_neox_japanese\", \"GPTNeoXJapaneseForCausalLM\"),\n+        (\"gpt_oss\", \"GptOssForCausalLM\"),\n         (\"gptj\", \"GPTJForCausalLM\"),\n         (\"granite\", \"GraniteForCausalLM\"),\n         (\"granitemoe\", \"GraniteMoeForCausalLM\"),"
        },
        {
            "sha": "232221782f787fdbb9c00bce11fd677034e8c2e8",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -300,6 +300,7 @@\n         (\"gpt_neo\", (\"GPT2Tokenizer\", \"GPT2TokenizerFast\" if is_tokenizers_available() else None)),\n         (\"gpt_neox\", (None, \"GPTNeoXTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"gpt_neox_japanese\", (\"GPTNeoXJapaneseTokenizer\", None)),\n+        (\"gpt_oss\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"gptj\", (\"GPT2Tokenizer\", \"GPT2TokenizerFast\" if is_tokenizers_available() else None)),\n         (\"gptsan-japanese\", (\"GPTSanJapaneseTokenizer\", None)),\n         (\"granite\", (\"GPT2Tokenizer\", None)),"
        },
        {
            "sha": "19e12e75ef8f46a09244a1a0541bec8097ba3a94",
            "filename": "src/transformers/models/gpt_oss/__init__.py",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgpt_oss%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgpt_oss%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgpt_oss%2F__init__.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -0,0 +1,27 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_gpt_oss import *\n+    from .modeling_gpt_oss import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "0a120e7ec9701146060ebe4c59683d1125865297",
            "filename": "src/transformers/models/gpt_oss/configuration_gpt_oss.py",
            "status": "added",
            "additions": 118,
            "deletions": 0,
            "changes": 118,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgpt_oss%2Fconfiguration_gpt_oss.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgpt_oss%2Fconfiguration_gpt_oss.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgpt_oss%2Fconfiguration_gpt_oss.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -0,0 +1,118 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"openai model configuration\"\"\"\n+\n+from ...configuration_utils import PretrainedConfig, layer_type_validation\n+from ...modeling_rope_utils import rope_config_validation\n+\n+\n+class GptOssConfig(PretrainedConfig):\n+    r\"\"\"\n+    This will yield a configuration to that of the BERT\n+    [google-bert/bert-base-uncased](https://huggingface.co/google-bert/bert-base-uncased) architecture.\n+\n+    \"\"\"\n+\n+    model_type = \"gpt_oss\"\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.self_attn.sinks\": \"local_rowwise\",\n+        \"layers.*.mlp.experts\": \"gather\",\n+        \"layers.*.mlp.router\": \"ep_router\",\n+        \"layers.*.mlp.experts.gate_up_proj\": \"grouped_gemm\",\n+        \"layers.*.mlp.experts.gate_up_proj_bias\": \"grouped_gemm\",\n+        \"layers.*.mlp.experts.down_proj\": \"grouped_gemm\",\n+        \"layers.*.mlp.experts.down_proj_bias\": \"grouped_gemm\",\n+    }\n+\n+    def __init__(\n+        self,\n+        num_hidden_layers: int = 36,\n+        num_local_experts: int = 128,\n+        vocab_size: int = 201088,\n+        hidden_size: int = 2880,\n+        intermediate_size: int = 2880,\n+        head_dim: int = 64,\n+        num_attention_heads: int = 64,\n+        num_key_value_heads: int = 8,\n+        sliding_window: int = 128,\n+        rope_theta: float = 150000.0,\n+        tie_word_embeddings=False,\n+        hidden_act: str = \"silu\",\n+        initializer_range: float = 0.02,\n+        max_position_embeddings=131072,\n+        rms_norm_eps: float = 1e-5,\n+        rope_scaling={\"rope_type\": \"yarn\", \"factor\": 32.0, \"beta_fast\": 32.0, \"beta_slow\": 1.0, \"truncate\": False},\n+        attention_dropout: float = 0.0,\n+        num_experts_per_tok=4,\n+        router_aux_loss_coef: float = 0.9,\n+        output_router_logits=False,\n+        use_cache=True,\n+        layer_types=None,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.num_local_experts = num_local_experts\n+        self.sliding_window = sliding_window\n+        self.num_experts_per_tok = num_experts_per_tok\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.attention_dropout = attention_dropout\n+        self.head_dim = head_dim if head_dim is not None else self.hidden_size // self.num_attention_heads\n+        self.layer_types = layer_types\n+        if self.layer_types is None:\n+            self.layer_types = [\n+                \"sliding_attention\" if bool((i + 1) % 2) else \"full_attention\" for i in range(self.num_hidden_layers)\n+            ]\n+        layer_type_validation(self.layer_types)\n+\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, copy it it to 'rope_type'.\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self)\n+\n+        self.attention_bias = True\n+        self.max_position_embeddings = max_position_embeddings\n+        self.router_aux_loss_coef = router_aux_loss_coef\n+        self.output_router_logits = output_router_logits\n+        self.use_cache = use_cache\n+        super().__init__(\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+\n+\n+__all__ = [\"GptOssConfig\"]"
        },
        {
            "sha": "34bcba3b2515ad81e7fc35058ac3dd436c5107b3",
            "filename": "src/transformers/models/gpt_oss/convert_gpt_oss_weights_to_hf.py",
            "status": "added",
            "additions": 820,
            "deletions": 0,
            "changes": 820,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgpt_oss%2Fconvert_gpt_oss_weights_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgpt_oss%2Fconvert_gpt_oss_weights_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgpt_oss%2Fconvert_gpt_oss_weights_to_hf.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -0,0 +1,820 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import argparse\n+import gc\n+import json\n+import os\n+from pathlib import Path\n+from typing import Optional\n+\n+import regex as re\n+import tiktoken\n+import torch\n+from safetensors.torch import load_file as safe_load\n+\n+from transformers import (\n+    GenerationConfig,\n+    GptOssConfig,\n+    GptOssForCausalLM,\n+    PreTrainedTokenizerFast,\n+)\n+from transformers.convert_slow_tokenizer import TikTokenConverter\n+\n+\n+# fmt: off\n+# If a weight needs to be split in two or more keys, use `|` to indicate it. ex:\n+# r\"layers.(\\d+).attention.wqkv.weight\": r\"layers.\\1.self_attn.q|k|v|_proj.weight\"\n+ORIGINAL_TO_CONVERTED_KEY_MAPPING = {\n+    r\"norm.weight\":                 r\"norm.weight\",\n+    r\"\\nnorm.scale\":                 r\"\\nnorm.weight\",\n+    r\"unembedding.weight\":          r\"lm_head.weight\",\n+    r\"embedding\":                   r\"embed_tokens\",\n+    # special key, wqkv needs to be split afterwards\n+    r\"block.(\\d+).attn.qkv\":        r\"layers.\\1.self_attn.qkv_proj\",\n+    r\"block.(\\d+).attn.out\":        r\"layers.\\1.self_attn.o_proj\",\n+    r\"block.(\\d+).attn.sinks\":      r\"layers.\\1.self_attn.sinks\",\n+    r\"block.(\\d+).attn.norm.scale\":       r\"layers.\\1.input_layernorm.weight\",\n+\n+    r\"block.(\\d+).mlp.mlp1_weight\": r\"layers.\\1.mlp.experts.gate_up_proj\",\n+    r\"block.(\\d+).mlp.mlp1_bias\":   r\"layers.\\1.mlp.experts.gate_up_proj_bias\",\n+    r\"block.(\\d+).mlp.mlp2_weight\": r\"layers.\\1.mlp.experts.down_proj\",\n+    r\"block.(\\d+).mlp.mlp2_bias\":   r\"layers.\\1.mlp.experts.down_proj_bias\",\n+    r\"block.(\\d+).mlp.norm.scale\":        r\"layers.\\1.post_attention_layernorm.weight\",\n+    r\"block.(\\d+).mlp.gate\":        r\"layers.\\1.mlp.router\",\n+}\n+# fmt: on\n+\n+\n+def convert_old_keys_to_new_keys(state_dict_keys: Optional[dict] = None):\n+    \"\"\"\n+    This function should be applied only once, on the concatenated keys to efficiently rename using\n+    the key mappings.\n+    \"\"\"\n+    output_dict = {}\n+    if state_dict_keys is not None:\n+        old_text = \"\\n\".join(state_dict_keys)\n+        new_text = old_text\n+        for pattern, replacement in ORIGINAL_TO_CONVERTED_KEY_MAPPING.items():\n+            if replacement is None:\n+                new_text = re.sub(pattern, \"\", new_text)  # an empty line\n+                continue\n+            new_text = re.sub(pattern, replacement, new_text)\n+        output_dict = dict(zip(old_text.split(\"\\n\"), new_text.split(\"\\n\")))\n+    return output_dict\n+\n+\n+FP4_VALUES = [\n+    +0.0,\n+    +0.5,\n+    +1.0,\n+    +1.5,\n+    +2.0,\n+    +3.0,\n+    +4.0,\n+    +6.0,\n+    -0.0,\n+    -0.5,\n+    -1.0,\n+    -1.5,\n+    -2.0,\n+    -3.0,\n+    -4.0,\n+    -6.0,\n+]\n+\n+\n+def convert_moe_packed_tensors(\n+    blocks,\n+    scales,\n+    *,\n+    dtype: torch.dtype = torch.bfloat16,\n+    rows_per_chunk: int = 32768 * 1024,\n+) -> torch.Tensor:\n+    import math\n+\n+    scales = scales.to(torch.int32) - 127\n+\n+    assert blocks.shape[:-1] == scales.shape, f\"{blocks.shape=} does not match {scales.shape=}\"\n+\n+    lut = torch.tensor(FP4_VALUES, dtype=dtype, device=blocks.device)\n+\n+    *prefix_shape, G, B = blocks.shape\n+    rows_total = math.prod(prefix_shape) * G\n+\n+    blocks = blocks.reshape(rows_total, B)\n+    scales = scales.reshape(rows_total, 1)\n+\n+    out = torch.empty(rows_total, B * 2, dtype=dtype, device=blocks.device)\n+\n+    for r0 in range(0, rows_total, rows_per_chunk):\n+        r1 = min(r0 + rows_per_chunk, rows_total)\n+\n+        blk = blocks[r0:r1]\n+        exp = scales[r0:r1]\n+\n+        # nibble indices -> int64\n+        idx_lo = (blk & 0x0F).to(torch.long)\n+        idx_hi = (blk >> 4).to(torch.long)\n+\n+        sub = out[r0:r1]\n+        sub[:, 0::2] = lut[idx_lo]\n+        sub[:, 1::2] = lut[idx_hi]\n+\n+        torch.ldexp(sub, exp, out=sub)\n+        del idx_lo, idx_hi, blk, exp\n+\n+    out = out.reshape(*prefix_shape, G, B * 2).view(*prefix_shape, G * B * 2)\n+    # to match for now existing implementation\n+    return out.to(torch.float8_e5m2)\n+\n+\n+def write_model(\n+    model_path,\n+    input_base_path,\n+    safe_serialization=True,\n+    instruct=False,\n+    mxfp4=False,\n+):\n+    os.makedirs(model_path, exist_ok=True)\n+    eos_token_id = 199999 if not instruct else 200002\n+    pad_token_id = 199999\n+\n+    original_config = json.loads((Path(input_base_path) / \"config.json\").read_text())\n+\n+    num_local_experts = original_config.pop(\"num_experts\")\n+    rope_scaling = {\n+        \"beta_fast\": float(original_config.pop(\"rope_ntk_beta\")),\n+        \"beta_slow\": float(original_config.pop(\"rope_ntk_alpha\")),\n+        \"factor\": float(original_config.pop(\"rope_scaling_factor\")),\n+        \"rope_type\": \"yarn\",\n+        \"truncate\": False,\n+        \"original_max_position_embeddings\": 4096,\n+    }\n+\n+    config = GptOssConfig(\n+        num_local_experts=num_local_experts,\n+        rope_scaling=rope_scaling,\n+        eos_token_id=eos_token_id,\n+        pad_token_id=pad_token_id,\n+        **original_config,\n+    )\n+\n+    print(f\"Fetching all parameters from the checkpoint at {input_base_path}...\")\n+    final_ = {}\n+    for file in list(os.listdir(input_base_path)):\n+        if file.endswith(\".safetensors\"):\n+            final_.update(safe_load(os.path.join(input_base_path, file)))\n+\n+    print(\"Converting ..\")\n+    all_keys = final_.keys()\n+    new_keys = convert_old_keys_to_new_keys(all_keys)\n+\n+    state_dict = {}\n+    for key in all_keys:\n+        # Post-process the current_parameter.\n+        new_key = new_keys.get(key, key)\n+        if \"lm_head\" not in new_key:\n+            new_key = \"model.\" + new_key\n+        print(f\"Processing key: {key} -> {new_key}\")\n+        if re.search(\"qkv_proj\", new_key):\n+            q_len = config.head_dim * config.num_attention_heads\n+            k_len = config.head_dim * config.num_key_value_heads\n+            q, k, v = (\n+                final_[key][:q_len, ...],\n+                final_[key][q_len : k_len + q_len, ...],\n+                final_[key][k_len + q_len :, ...],\n+            )\n+            q_key = re.sub(r\"qkv_proj\", \"q_proj\", new_key)\n+            k_key = re.sub(r\"qkv_proj\", \"k_proj\", new_key)\n+            v_key = re.sub(r\"qkv_proj\", \"v_proj\", new_key)\n+            state_dict[q_key] = q.contiguous().to(torch.bfloat16)\n+            state_dict[k_key] = k.contiguous().to(torch.bfloat16)\n+            state_dict[v_key] = v.contiguous().to(torch.bfloat16)\n+        elif re.search(\"gate_up_proj|down_proj\", new_key) and \"bias\" not in new_key:\n+            if not mxfp4:\n+                if \"scales\" in new_key:\n+                    continue\n+                elif \"blocks\" in new_key:\n+                    # deal with packed weights\n+                    blocks = final_[key]\n+                    scales = final_[key.replace(\"blocks\", \"scales\")]\n+                    new_key = new_key.replace(\".blocks\", \"\")\n+                    unpacked_tensors = convert_moe_packed_tensors(blocks, scales, dtype=torch.bfloat16)\n+                    unpacked_tensors = unpacked_tensors.permute(0, 2, 1).contiguous()  # einsum in orignal, I use bmm\n+                    state_dict[new_key] = unpacked_tensors\n+                else:\n+                    raise (f\"Unidentified {key}, please double check the state dict\")\n+            else:\n+                if \"scales\" in new_key:\n+                    new_key = new_key.replace(\".scales\", \"_scales\")\n+                    state_dict[new_key] = final_[key].contiguous()\n+                elif \"blocks\" in new_key:\n+                    new_key = new_key.replace(\".blocks\", \"_blocks\")\n+                    state_dict[new_key] = final_[key].contiguous()\n+                else:\n+                    raise (f\"Unidentified {key}, please double check the state dict\")\n+        else:\n+            weight = final_[key]\n+            if not re.search(\"norm\", new_key):\n+                weight = weight.to(torch.bfloat16)  # norms are the only ones in float32\n+            state_dict[new_key] = weight\n+\n+    del final_\n+    gc.collect()\n+\n+    if not mxfp4:\n+        print(\"Loading the checkpoint in a GptOss model for unpacked format\")\n+        with torch.device(\"meta\"):\n+            model = GptOssForCausalLM(config)\n+        model.load_state_dict(state_dict, strict=True, assign=True)\n+        print(\"Checkpoint loaded successfully.\")\n+        del config._name_or_path\n+\n+        print(\"Saving the model\")\n+        model.save_pretrained(model_path, safe_serialization=safe_serialization)\n+        del state_dict, model\n+\n+    else:\n+        print(\"Saving the checkpoint in mxfp4 format\")\n+        config.quantization_config = {\n+            \"quant_method\": \"mxfp4\",\n+            \"modules_to_not_convert\": [\n+                \"model.layers.*.self_attn\",\n+                \"model.layers.*.mlp.router\",\n+                \"model.embed_tokens\",\n+                \"lm_head\",\n+            ],\n+        }\n+        # required as we don't save the model with save_pretrained\n+        config.architectures = [\"GptOssForCausalLM\"]\n+        config.save_pretrained(model_path)\n+        save_sharded_model(state_dict, model_path)\n+        del state_dict\n+\n+    gc.collect()\n+    print(\"Reloading the model to check if it's saved correctly.\")\n+    GptOssForCausalLM.from_pretrained(model_path, torch_dtype=torch.bfloat16, device_map=\"auto\")\n+    print(\"Model reloaded successfully.\")\n+\n+    # generation config\n+    if instruct:\n+        print(\"Saving generation config...\")\n+        generation_config = GenerationConfig(\n+            bos_token_id=199998,  # <|startoftext|>\n+            do_sample=True,\n+            eos_token_id=[200002, 199999],  # <|return|>, <|endoftext|>\n+            pad_token_id=199999,  # <|endoftext|>\n+            temperature=1.0,\n+            top_p=1.0,\n+        )\n+        generation_config.save_pretrained(model_path)\n+\n+\n+def save_sharded_model(state_dict, model_path):\n+    from safetensors.torch import save_file\n+\n+    max_shard_size = 4800000000  # 4.8 GB\n+    os.makedirs(model_path, exist_ok=True)\n+    shard_size_counter = 0\n+    shard_id = 0\n+    shard_state_dict = {}\n+    total_sharded_dict = {}\n+    safetensors_index = {}\n+    safetensors_index[\"metadata\"] = {\"total_size\": 0}\n+    safetensors_index[\"weight_map\"] = {}\n+    for key in state_dict.keys():\n+        size = state_dict[key].numel() * state_dict[key].element_size()\n+        if shard_size_counter + size > max_shard_size:\n+            total_sharded_dict[shard_id] = shard_state_dict\n+            shard_id += 1\n+            shard_size_counter = 0\n+            shard_state_dict = {}\n+        shard_state_dict[key] = state_dict[key]\n+        shard_size_counter += size\n+        safetensors_index[\"metadata\"][\"total_size\"] += size\n+        safetensors_index[\"weight_map\"][key] = shard_id\n+    total_sharded_dict[shard_id] = shard_state_dict\n+    num_shards = len(total_sharded_dict) - 1\n+    for shard_id, shard_state_dict in total_sharded_dict.items():\n+        save_file(shard_state_dict, os.path.join(model_path, f\"model-{shard_id:05d}-of-{num_shards:05d}.safetensors\"))\n+    create_safetensors_index(safetensors_index, num_shards, model_path)\n+\n+\n+def create_safetensors_index(safetensors_index, num_shards, model_path):\n+    for key in safetensors_index[\"weight_map\"].keys():\n+        shard_id = safetensors_index[\"weight_map\"][key]\n+        safetensors_index[\"weight_map\"][key] = f\"model-{shard_id:05d}-of-{num_shards:05d}.safetensors\"\n+    with open(os.path.join(model_path, \"model.safetensors.index.json\"), \"w\") as f:\n+        json.dump(safetensors_index, f)\n+\n+\n+# Copied from transformers.models.gpt2.tokenization_gpt2.bytes_to_unicode\n+def bytes_to_unicode():\n+    \"\"\"\n+    Returns list of utf-8 byte and a mapping to unicode strings. We specifically avoids mapping to whitespace/control\n+    characters the bpe code barfs on.\n+\n+    The reversible bpe codes work on unicode strings. This means you need a large # of unicode characters in your vocab\n+    if you want to avoid UNKs. When you're at something like a 10B token dataset you end up needing around 5K for\n+    decent coverage. This is a significant percentage of your normal, say, 32K bpe vocab. To avoid that, we want lookup\n+    tables between utf-8 bytes and unicode strings.\n+    \"\"\"\n+    bs = (\n+        list(range(ord(\"!\"), ord(\"~\") + 1)) + list(range(ord(\"¡\"), ord(\"¬\") + 1)) + list(range(ord(\"®\"), ord(\"ÿ\") + 1))\n+    )\n+    cs = bs[:]\n+    n = 0\n+    for b in range(2**8):\n+        if b not in bs:\n+            bs.append(b)\n+            cs.append(2**8 + n)\n+            n += 1\n+    cs = [chr(n) for n in cs]\n+    return dict(zip(bs, cs))\n+\n+\n+class GptOssConverter(TikTokenConverter):\n+    def extract_vocab_merges_from_model(self, tiktoken_url: str):\n+        tokenizer = tiktoken.get_encoding(tiktoken_url)\n+        self.pattern = tokenizer._pat_str\n+        bpe_ranks = tokenizer._mergeable_ranks\n+        byte_encoder = bytes_to_unicode()\n+\n+        def token_bytes_to_string(b):\n+            return \"\".join([byte_encoder[ord(char)] for char in b.decode(\"latin-1\")])\n+\n+        merges = []\n+        vocab = {}\n+        for token, rank in bpe_ranks.items():\n+            vocab[token_bytes_to_string(token)] = rank\n+            if len(token) == 1:\n+                continue\n+            local = []\n+            for index in range(1, len(token)):\n+                piece_l, piece_r = token[:index], token[index:]\n+                if piece_l in bpe_ranks and piece_r in bpe_ranks and (piece_l + piece_r) in bpe_ranks:\n+                    local.append((piece_l, piece_r, rank))\n+            local = sorted(local, key=lambda x: (bpe_ranks[x[0]], bpe_ranks[x[1]]), reverse=False)\n+            merges.extend(local)\n+        merges = sorted(merges, key=lambda val: val[2], reverse=False)\n+        merges = [(token_bytes_to_string(val[0]), token_bytes_to_string(val[1])) for val in merges]\n+        return vocab, merges\n+\n+    def __init__(\n+        self,\n+        vocab_file,\n+        model_max_length: int,\n+        chat_template: Optional[str] = None,\n+        **kwargs,\n+    ):\n+        super().__init__(vocab_file, pattern=None)\n+\n+        # TODO 1st donwload the vocabfile!!!\n+        tokenizer = tiktoken.get_encoding(vocab_file)\n+        self.additional_special_tokens = {}\n+        # Complete list of Harmony special tokens as per o200k_harmony spec\n+        special_tokens_map = {\n+            \"<|startoftext|>\": 199998,\n+            \"<|endoftext|>\": 199999,\n+            \"<|return|>\": 200002,\n+            \"<|constrain|>\": 200003,\n+            \"<|channel|>\": 200005,\n+            \"<|start|>\": 200006,\n+            \"<|end|>\": 200007,\n+            \"<|message|>\": 200008,\n+            \"<|call|>\": 200012,\n+            \"<|endofprompt|>\": 200018,\n+        }\n+\n+        # Add the remaining reserved slots while skipping IDs already present above.\n+        used_ids = set(special_tokens_map.values())\n+        for k in range(199999, 200018):\n+            if k in used_ids:\n+                continue\n+            special_tokens_map.setdefault(f\"<|reserved_{k}|>\", k)\n+\n+        # Keep only token strings (sorted by ID) for TikTokenConverter.\n+        self.additional_special_tokens = [tok for tok, _ in sorted(special_tokens_map.items(), key=lambda x: x[1])]\n+        tokenizer = self.converted()\n+        if chat_template is not None:\n+            kwargs[\"chat_template\"] = chat_template\n+        self.tokenizer = PreTrainedTokenizerFast(\n+            tokenizer_object=tokenizer,\n+            bos_token=\"<|startoftext|>\",\n+            eos_token=\"<|return|>\" if chat_template else \"<|endoftext|>\",\n+            pad_token=\"<|endoftext|>\",\n+            model_input_names=[\"input_ids\", \"attention_mask\"],\n+            model_max_length=model_max_length,\n+            **kwargs,\n+        )\n+\n+\n+def write_tokenizer(tokenizer_path: str, save_dir: str, instruct: bool = False):\n+    # Updated Harmony chat template\n+    chat_template = \"\"\"{#-\n+  In addition to the normal inputs of `messages` and `tools`, this template also accepts the\n+  following kwargs:\n+  - \"builtin_tools\": A list, can contain \"browser\" and/or \"python\".\n+  - \"model_identity\": A string that optionally describes the model identity.\n+  - \"reasoning_effort\": A string that describes the reasoning effort, defaults to \"medium\".\n+ #}\n+\n+{#- Tool Definition Rendering ============================================== #}\n+{%- macro render_typescript_type(param_spec, required_params, is_nullable=false) -%}\n+    {%- if param_spec.type == \"array\" -%}\n+        {%- if param_spec['items'] -%}\n+            {%- if param_spec['items']['type'] == \"string\" -%}\n+                {{- \"string[]\" }}\n+            {%- elif param_spec['items']['type'] == \"number\" -%}\n+                {{- \"number[]\" }}\n+            {%- elif param_spec['items']['type'] == \"integer\" -%}\n+                {{- \"number[]\" }}\n+            {%- elif param_spec['items']['type'] == \"boolean\" -%}\n+                {{- \"boolean[]\" }}\n+            {%- else -%}\n+                {%- set inner_type = render_typescript_type(param_spec['items'], required_params) -%}\n+                {%- if inner_type == \"object | object\" or inner_type|length > 50 -%}\n+                    {{- \"any[]\" }}\n+                {%- else -%}\n+                    {{- inner_type + \"[]\" }}\n+                {%- endif -%}\n+            {%- endif -%}\n+            {%- if param_spec.nullable -%}\n+                {{- \" | null\" }}\n+            {%- endif -%}\n+        {%- else -%}\n+            {{- \"any[]\" }}\n+            {%- if param_spec.nullable -%}\n+                {{- \" | null\" }}\n+            {%- endif -%}\n+        {%- endif -%}\n+    {%- elif param_spec.type is defined and param_spec.type is iterable and param_spec.type is not string and param_spec.type is not mapping and param_spec.type[0] is defined -%}\n+        {#- Handle array of types like [\"object\", \"object\"] from Union[dict, list] #}\n+        {%- if param_spec.type | length > 1 -%}\n+            {{- param_spec.type | join(\" | \") }}\n+        {%- else -%}\n+            {{- param_spec.type[0] }}\n+        {%- endif -%}\n+    {%- elif param_spec.oneOf -%}\n+        {#- Handle oneOf schemas - check for complex unions and fallback to any #}\n+        {%- set has_object_variants = false -%}\n+        {%- for variant in param_spec.oneOf -%}\n+            {%- if variant.type == \"object\" -%}\n+                {%- set has_object_variants = true -%}\n+            {%- endif -%}\n+        {%- endfor -%}\n+        {%- if has_object_variants and param_spec.oneOf|length > 1 -%}\n+            {{- \"any\" }}\n+        {%- else -%}\n+            {%- for variant in param_spec.oneOf -%}\n+                {{- render_typescript_type(variant, required_params) -}}\n+                {%- if variant.description %}\n+                    {{- \"// \" + variant.description }}\n+                {%- endif -%}\n+                {%- if variant.default is defined %}\n+                    {{ \"// default: \" + variant.default|tojson }}\n+                {%- endif -%}\n+                {%- if not loop.last %}\n+                    {{- \" | \" }}\n+                {% endif -%}\n+            {%- endfor -%}\n+        {%- endif -%}\n+    {%- elif param_spec.type == \"string\" -%}\n+        {%- if param_spec.enum -%}\n+            {{- '\"' + param_spec.enum|join('\" | \"') + '\"' -}}\n+        {%- else -%}\n+            {{- \"string\" }}\n+            {%- if param_spec.nullable %}\n+                {{- \" | null\" }}\n+            {%- endif -%}\n+        {%- endif -%}\n+    {%- elif param_spec.type == \"number\" -%}\n+        {{- \"number\" }}\n+    {%- elif param_spec.type == \"integer\" -%}\n+        {{- \"number\" }}\n+    {%- elif param_spec.type == \"boolean\" -%}\n+        {{- \"boolean\" }}\n+\n+    {%- elif param_spec.type == \"object\" -%}\n+        {%- if param_spec.properties -%}\n+            {{- \"{\\n\" }}\n+            {%- for prop_name, prop_spec in param_spec.properties.items() -%}\n+                {{- prop_name -}}\n+                {%- if prop_name not in (param_spec.required or []) -%}\n+                    {{- \"?\" }}\n+                {%- endif -%}\n+                {{- \": \" }}\n+                {{ render_typescript_type(prop_spec, param_spec.required or []) }}\n+                {%- if not loop.last -%}\n+                    {{-\", \" }}\n+                {%- endif -%}\n+            {%- endfor -%}\n+            {{- \"}\" }}\n+        {%- else -%}\n+            {{- \"object\" }}\n+        {%- endif -%}\n+    {%- else -%}\n+        {{- \"any\" }}\n+    {%- endif -%}\n+{%- endmacro -%}\n+\n+{%- macro render_tool_namespace(namespace_name, tools) -%}\n+    {{- \"## \" + namespace_name + \"\\n\\n\" }}\n+    {{- \"namespace \" + namespace_name + \" {\\n\\n\" }}\n+    {%- for tool in tools %}\n+        {%- set tool = tool.function %}\n+        {{- \"// \" + tool.description + \"\\n\" }}\n+        {{- \"type \"+ tool.name + \" = \" }}\n+        {%- if tool.parameters and tool.parameters.properties %}\n+            {{- \"(_: {\\n\" }}\n+            {%- for param_name, param_spec in tool.parameters.properties.items() %}\n+                {%- if param_spec.description %}\n+                    {{- \"// \" + param_spec.description + \"\\n\" }}\n+                {%- endif %}\n+                {{- param_name }}\n+                {%- if param_name not in (tool.parameters.required or []) -%}\n+                    {{- \"?\" }}\n+                {%- endif -%}\n+                {{- \": \" }}\n+                {{- render_typescript_type(param_spec, tool.parameters.required or []) }}\n+                {%- if param_spec.default is defined -%}\n+                    {%- if param_spec.enum %}\n+                        {{- \", // default: \" + param_spec.default }}\n+                    {%- elif param_spec.oneOf %}\n+                        {{- \"// default: \" + param_spec.default }}\n+                    {%- else %}\n+                        {{- \", // default: \" + param_spec.default|tojson }}\n+                    {%- endif -%}\n+                {%- endif -%}\n+                {%- if not loop.last %}\n+                    {{- \",\\n\" }}\n+                {%- else %}\n+                    {{- \"\\n\" }}\n+                {%- endif -%}\n+            {%- endfor %}\n+            {{- \"}) => any;\\n\\n\" }}\n+        {%- else -%}\n+            {{- \"() => any;\\n\\n\" }}\n+        {%- endif -%}\n+    {%- endfor %}\n+    {{- \"} // namespace \" + namespace_name }}\n+{%- endmacro -%}\n+\n+{%- macro render_builtin_tools(browser_tool, python_tool) -%}\n+    {%- if browser_tool %}\n+        {{- \"## browser\\n\\n\" }}\n+        {{- \"// Tool for browsing.\\n\" }}\n+        {{- \"// The `cursor` appears in brackets before each browsing display: `[{cursor}]`.\\n\" }}\n+        {{- \"// Cite information from the tool using the following format:\\n\" }}\n+        {{- \"// `【{cursor}†L{line_start}(-L{line_end})?】`, for example: `【6†L9-L11】` or `【8†L3】`.\\n\" }}\n+        {{- \"// Do not quote more than 10 words directly from the tool output.\\n\" }}\n+        {{- \"// sources=web (default: web)\\n\" }}\n+        {{- \"namespace browser {\\n\\n\" }}\n+        {{- \"// Searches for information related to `query` and displays `topn` results.\\n\" }}\n+        {{- \"type search = (_: {\\n\" }}\n+        {{- \"query: string,\\n\" }}\n+        {{- \"topn?: number, // default: 10\\n\" }}\n+        {{- \"source?: string,\\n\" }}\n+        {{- \"}) => any;\\n\\n\" }}\n+        {{- \"// Opens the link `id` from the page indicated by `cursor` starting at line number `loc`, showing `num_lines` lines.\\n\" }}\n+        {{- \"// Valid link ids are displayed with the formatting: `【{id}†.*】`.\\n\" }}\n+        {{- \"// If `cursor` is not provided, the most recent page is implied.\\n\" }}\n+        {{- \"// If `id` is a string, it is treated as a fully qualified URL associated with `source`.\\n\" }}\n+        {{- \"// If `loc` is not provided, the viewport will be positioned at the beginning of the document or centered on the most relevant passage, if available.\\n\" }}\n+        {{- \"// Use this function without `id` to scroll to a new location of an opened page.\\n\" }}\n+        {{- \"type open = (_: {\\n\" }}\n+        {{- \"id?: number | string, // default: -1\\n\" }}\n+        {{- \"cursor?: number, // default: -1\\n\" }}\n+        {{- \"loc?: number, // default: -1\\n\" }}\n+        {{- \"num_lines?: number, // default: -1\\n\" }}\n+        {{- \"view_source?: boolean, // default: false\\n\" }}\n+        {{- \"source?: string,\\n\" }}\n+        {{- \"}) => any;\\n\\n\" }}\n+        {{- \"// Finds exact matches of `pattern` in the current page, or the page given by `cursor`.\\n\" }}\n+        {{- \"type find = (_: {\\n\" }}\n+        {{- \"pattern: string,\\n\" }}\n+        {{- \"cursor?: number, // default: -1\\n\" }}\n+        {{- \"}) => any;\\n\\n\" }}\n+        {{- \"} // namespace browser\\n\\n\" }}\n+    {%- endif -%}\n+\n+    {%- if python_tool %}\n+        {{- \"## python\\n\\n\" }}\n+        {{- \"Use this tool to execute Python code in your chain of thought. The code will not be shown to the user. This tool should be used for internal reasoning, but not for code that is intended to be visible to the user (e.g. when creating plots, tables, or files).\\n\\n\" }}\n+        {{- \"When you send a message containing Python code to python, it will be executed in a stateful Jupyter notebook environment. python will respond with the output of the execution or time out after 120.0 seconds. The drive at '/mnt/data' can be used to save and persist user files. Internet access for this session is UNKNOWN. Depends on the cluster.\\n\\n\" }}\n+    {%- endif -%}\n+{%- endmacro -%}\n+\n+{#- System Message Construction ============================================ #}\n+{%- macro build_system_message() -%}\n+    {%- if model_identity is not defined %}\n+        {%- set model_identity = \"You are ChatGPT, a large language model trained by OpenAI.\" %}\n+    {%- endif %}\n+    {{- model_identity + \"\\n\" }}\n+    {{- \"Knowledge cutoff: 2024-06\\n\" }}\n+    {{- \"Current date: \" + strftime_now(\"%Y-%m-%d\") + \"\\n\\n\" }}\n+    {%- if reasoning_effort is not defined %}\n+        {%- set reasoning_effort = \"medium\" %}\n+    {%- endif %}\n+    {{- \"Reasoning: \" + reasoning_effort + \"\\n\\n\" }}\n+    {%- if builtin_tools %}\n+        {{- \"# Tools\\n\\n\" }}\n+        {%- set available_builtin_tools = namespace(browser=false, python=false) %}\n+        {%- for tool in builtin_tools %}\n+            {%- if tool == \"browser\" %}\n+                {%- set available_builtin_tools.browser = true %}\n+            {%- elif tool == \"python\" %}\n+                {%- set available_builtin_tools.python = true %}\n+            {%- endif %}\n+        {%- endfor %}\n+        {{- render_builtin_tools(available_builtin_tools.browser, available_builtin_tools.python) }}\n+    {%- endif -%}\n+    {{- \"# Valid channels: analysis, commentary, final. Channel must be included for every message.\" }}\n+    {%- if tools -%}\n+        {{- \"\\nCalls to these tools must go to the commentary channel: 'functions'.\" }}\n+    {%- endif -%}\n+{%- endmacro -%}\n+\n+{#- Main Template Logic ================================================= #}\n+{#- Set defaults #}\n+\n+{#- Render system message #}\n+{{- \"<|start|>system<|message|>\" }}\n+{{- build_system_message() }}\n+{{- \"<|end|>\" }}\n+\n+{#- Extract developer message #}\n+{%- if messages[0].role == \"developer\" or messages[0].role == \"system\" %}\n+    {%- set developer_message = messages[0].content %}\n+    {%- set loop_messages = messages[1:] %}\n+{%- else %}\n+    {%- set developer_message = \"\" %}\n+    {%- set loop_messages = messages %}\n+{%- endif %}\n+\n+{#- Render developer message #}\n+{%- if developer_message or tools %}\n+    {{- \"<|start|>developer<|message|>\" }}\n+    {%- if developer_message %}\n+        {{- \"# Instructions\\n\\n\" }}\n+        {{- developer_message }}\n+    {%- endif %}\n+    {%- if tools -%}\n+        {{- \"\\n\\n\" }}\n+        {{- \"# Tools\\n\\n\" }}\n+        {{- render_tool_namespace(\"functions\", tools) }}\n+    {%- endif -%}\n+    {{- \"<|end|>\" }}\n+{%- endif %}\n+\n+{#- Render messages #}\n+{%- set last_tool_call = namespace(name=none) %}\n+{%- for message in loop_messages -%}\n+    {#- At this point only assistant/user/tool messages should remain #}\n+    {%- if message.role == 'assistant' -%}\n+        {#- Checks to ensure the messages are being passed in the format we expect #}\n+        {%- if \"content\" in message %}\n+            {%- if \"<|channel|>analysis<|message|>\" in message.content or \"<|channel|>final<|message|>\" in message.content %}\n+                {{- raise_exception(\"You have passed a message containing <|channel|> tags in the content field. Instead of doing this, you should pass analysis messages (the string between '<|message|>' and '<|end|>') in the 'thinking' field, and final messages (the string between '<|message|>' and '<|end|>') in the 'content' field.\") }}\n+            {%- endif %}\n+        {%- endif %}\n+        {%- if \"thinking\" in message %}\n+            {%- if \"<|channel|>analysis<|message|>\" in message.thinking or \"<|channel|>final<|message|>\" in message.thinking %}\n+                {{- raise_exception(\"You have passed a message containing <|channel|> tags in the thinking field. Instead of doing this, you should pass analysis messages (the string between '<|message|>' and '<|end|>') in the 'thinking' field, and final messages (the string between '<|message|>' and '<|end|>') in the 'content' field.\") }}\n+            {%- endif %}\n+        {%- endif %}\n+        {%- if \"tool_calls\" in message %}\n+            {#- We assume max 1 tool call per message, and so we infer the tool call name #}\n+            {#- in \"tool\" messages from the most recent assistant tool call name #}\n+            {%- set tool_call = message.tool_calls[0] %}\n+            {%- if tool_call.function %}\n+                {%- set tool_call = tool_call.function %}\n+            {%- endif %}\n+            {%- if message.content and message.thinking %}\n+                {{- raise_exception(\"Cannot pass both content and thinking in an assistant message with tool calls! Put the analysis message in one or the other, but not both.\") }}\n+            {%- elif message.content %}\n+                {{- \"<|start|>assistant<|channel|>analysis<|message|>\" + message.content + \"<|end|>\" }}\n+            {%- elif message.thinking %}\n+                {{- \"<|start|>assistant<|channel|>analysis<|message|>\" + message.thinking + \"<|end|>\" }}\n+            {%- endif %}\n+            {{- \"<|start|>assistant to=\" }}\n+            {{- \"functions.\" + tool_call.name + \"<|channel|>commentary \" }}\n+            {{- (tool_call.content_type if tool_call.content_type is defined else \"json\") + \"<|message|>\" }}\n+            {{- tool_call.arguments|tojson }}\n+            {{- \"<|call|>\" }}\n+            {%- set last_tool_call.name = tool_call.name %}\n+        {%- elif loop.last and not add_generation_prompt %}\n+            {#- Only render the CoT if the final turn is an assistant turn and add_generation_prompt is false #}\n+            {#- This is a situation that should only occur in training, never in inference. #}\n+            {%- if \"thinking\" in message %}\n+                {{- \"<|start|>assistant<|channel|>analysis<|message|>\" + message.thinking + \"<|end|>\" }}\n+            {%- endif %}\n+            {#- <|return|> indicates the end of generation, but <|end|> does not #}\n+            {#- <|return|> should never be an input to the model, but we include it as the final token #}\n+            {#- when training, so the model learns to emit it. #}\n+            {{- \"<|start|>assistant<|channel|>final<|message|>\" + message.content + \"<|return|>\" }}\n+        {%- else %}\n+            {#- CoT is dropped during all previous turns, so we never render it for inference #}\n+            {{- \"<|start|>assistant<|channel|>final<|message|>\" + message.content + \"<|end|>\" }}\n+            {%- set last_tool_call.name = none %}\n+        {%- endif %}\n+    {%- elif message.role == 'tool' -%}\n+        {%- if last_tool_call.name is none %}\n+            {{- raise_exception(\"Message has tool role, but there was no previous assistant message with a tool call!\") }}\n+        {%- endif %}\n+        {{- \"<|start|>functions.\" + last_tool_call.name }}\n+        {{- \" to=assistant<|channel|>commentary<|message|>\" + message.content|tojson + \"<|end|>\" }}\n+    {%- elif message.role == 'user' -%}\n+        {{- \"<|start|>user<|message|>\" + message.content + \"<|end|>\" }}\n+    {%- endif -%}\n+{%- endfor -%}\n+\n+{#- Generation prompt #}\n+{%- if add_generation_prompt -%}\n+<|start|>assistant\n+{%- endif -%}\"\"\"\n+\n+    converter = GptOssConverter(\n+        vocab_file=tokenizer_path,\n+        model_max_length=None,\n+        chat_template=chat_template if instruct else None,\n+    )\n+    tokenizer = converter.tokenizer\n+    tokenizer.save_pretrained(save_dir)\n+\n+    if instruct:\n+        print(\"Saving chat template...\")\n+        chat_template_path = os.path.join(save_dir, \"chat_template.json\")\n+        with open(chat_template_path, \"w\") as f:\n+            json.dump({\"chat_template\": chat_template}, f, indent=2)\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\n+        \"--input_dir\",\n+        default=\"/fsx/mohamed/oai-hf/tests/120b\",\n+        help=\"Location of LLaMA weights, which contains tokenizer.model and model folders\",\n+    )\n+    parser.add_argument(\n+        \"--output_dir\",\n+        default=\"/fsx/mohamed/oai-hf/tests/120b_converted_packed\",\n+        help=\"Location to write HF model and tokenizer\",\n+    )\n+    parser.add_argument(\n+        \"--safe_serialization\", default=True, type=bool, help=\"Whether or not to save using `safetensors`.\"\n+    )\n+    parser.add_argument(\n+        \"--special_tokens\",\n+        default=None,\n+        type=list[str],\n+        help=\"The list of special tokens that should be added to the \",\n+    )\n+\n+    parser.add_argument(\n+        \"--instruct\",\n+        action=\"store_true\",\n+        help=\"Whether the model is an instruct model\",\n+    )\n+\n+    # Only specify this if you want to use the model with mxfp4 quantization\n+    # It means the model will be unpacked, and quantized using mxfp4 during inference if all the triton requirements are satisfied (triton >= 3.4.0)\n+    # Else we have a fallback to the full precision model (bfloat16)\n+    # If not specified, the model will be unpacked during conversion, and will be in fp8/bfloat16 during inference\n+    # Note: mxfp4 should bring an important speedup in inference time with blackwell gpus\n+    parser.add_argument(\n+        \"--mxfp4\",\n+        action=\"store_true\",\n+        help=\"Whether to use the original model with mxfp4 quantization or default to the full precision model.\",\n+    )\n+\n+    args = parser.parse_args()\n+    write_model(\n+        model_path=args.output_dir,\n+        input_base_path=args.input_dir,\n+        safe_serialization=args.safe_serialization,\n+        instruct=args.instruct,\n+        mxfp4=args.mxfp4,\n+    )\n+\n+    write_tokenizer(\n+        tokenizer_path=\"o200k_base\",\n+        save_dir=args.output_dir,\n+        instruct=args.instruct,\n+    )\n+\n+\n+if __name__ == \"__main__\":\n+    main()"
        },
        {
            "sha": "2077f7372c9d14fdc390a5513d1175c024b1aecd",
            "filename": "src/transformers/models/gpt_oss/modeling_gpt_oss.py",
            "status": "added",
            "additions": 701,
            "deletions": 0,
            "changes": 701,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgpt_oss%2Fmodeling_gpt_oss.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgpt_oss%2Fmodeling_gpt_oss.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgpt_oss%2Fmodeling_gpt_oss.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -0,0 +1,701 @@\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+#           This file was automatically generated from src/transformers/models/gpt_oss/modular_gpt_oss.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_gpt_oss.py file directly. One of our CI enforces this.\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import Callable, Optional, Union\n+\n+import torch\n+from torch import nn\n+from torch.nn import functional as F\n+\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...integrations.hub_kernels import use_kernel_forward_from_hub\n+from ...masking_utils import create_causal_mask, create_sliding_window_causal_mask\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import MoeCausalLMOutputWithPast, MoeModelOutputWithPast\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS, dynamic_rope_update\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring, can_return_tuple\n+from ...utils.generic import OutputRecorder, check_model_inputs\n+from .configuration_gpt_oss import GptOssConfig\n+\n+\n+@use_kernel_forward_from_hub(\"RMSNorm\")\n+class GptOssRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        GptOssRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return (self.weight * hidden_states).to(input_dtype)  # main diff with Llama\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class GptOssExperts(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.intermediate_size = config.intermediate_size\n+        self.num_experts = config.num_local_experts\n+        self.hidden_size = config.hidden_size\n+        self.expert_dim = self.intermediate_size\n+        self.gate_up_proj = nn.Parameter(torch.empty(self.num_experts, self.hidden_size, 2 * self.expert_dim))\n+        self.gate_up_proj_bias = nn.Parameter(torch.empty(self.num_experts, 2 * self.expert_dim))\n+        self.down_proj = nn.Parameter(torch.empty((self.num_experts, self.expert_dim, self.hidden_size)))\n+        self.down_proj_bias = nn.Parameter(torch.empty(self.num_experts, self.hidden_size))\n+        self.alpha = 1.702\n+        self.limit = 7.0\n+\n+    def forward(self, hidden_states: torch.Tensor, router_indices=None, routing_weights=None) -> torch.Tensor:\n+        \"\"\"\n+        When training is is more efficient to just loop over the experts and compute the output for each expert\n+        as otherwise the memory would explode.\n+\n+        For inference we can sacrifice some memory and compute the output for all experts at once. By repeating the inputs.\n+\n+        Args:\n+            hidden_states (torch.Tensor): (batch_size, seq_len, hidden_size)\n+            selected_experts (torch.Tensor): (batch_size * token_num, top_k)\n+            routing_weights (torch.Tensor): (batch_size * token_num, num_experts)\n+        Returns:\n+            torch.Tensor\n+        \"\"\"\n+        batch_size = hidden_states.shape[0]\n+        hidden_states = hidden_states.reshape(-1, self.hidden_size)  # (num_tokens, hidden_size)\n+        num_experts = routing_weights.shape[1]\n+        if self.training:\n+            next_states = torch.zeros_like(hidden_states, dtype=hidden_states.dtype, device=hidden_states.device)\n+            with torch.no_grad():\n+                expert_mask = torch.nn.functional.one_hot(router_indices, num_classes=num_experts)\n+                expert_mask = expert_mask.permute(2, 1, 0)\n+                # we sum on the top_k and on the sequence lenght to get which experts\n+                # are hit this time around\n+                expert_hitted = torch.greater(expert_mask.sum(dim=(-1, -2)), 0).nonzero()\n+            for expert_idx in expert_hitted[:]:\n+                with torch.no_grad():\n+                    _, token_idx = torch.where(expert_mask[expert_idx[0]])\n+                current_state = hidden_states[token_idx]\n+                gate_up = current_state @ self.gate_up_proj[expert_idx] + self.gate_up_proj_bias[expert_idx]\n+                gate, up = gate_up[..., ::2], gate_up[..., 1::2]\n+                gate = gate.clamp(min=None, max=self.limit)\n+                up = up.clamp(min=-self.limit, max=self.limit)\n+                glu = gate * torch.sigmoid(gate * self.alpha)\n+                gated_output = (up + 1) * glu\n+                out = gated_output @ self.down_proj[expert_idx] + self.down_proj_bias[expert_idx]\n+                weighted_output = out[0] * routing_weights[token_idx, expert_idx, None]\n+                next_states.index_add_(0, token_idx, weighted_output.to(hidden_states.dtype))\n+            next_states = next_states.view(batch_size, -1, self.hidden_size)\n+        else:\n+            hidden_states = hidden_states.repeat(num_experts, 1)\n+            hidden_states = hidden_states.view(num_experts, -1, self.hidden_size)\n+            gate_up = torch.bmm(hidden_states, self.gate_up_proj) + self.gate_up_proj_bias[..., None, :]\n+            gate, up = gate_up[..., ::2], gate_up[..., 1::2]\n+            gate = gate.clamp(min=None, max=self.limit)\n+            up = up.clamp(min=-self.limit, max=self.limit)\n+            glu = gate * torch.sigmoid(gate * self.alpha)\n+            next_states = torch.bmm(((up + 1) * glu), self.down_proj)\n+            next_states = next_states + self.down_proj_bias[..., None, :]\n+            next_states = next_states.view(num_experts, batch_size, -1, self.hidden_size)\n+            next_states = next_states * routing_weights.transpose(0, 1).view(num_experts, batch_size, -1)[..., None]\n+            next_states = next_states.sum(dim=0)\n+        return next_states\n+\n+\n+class GptOssTopKRouter(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.top_k = config.num_experts_per_tok\n+        self.num_experts = config.num_local_experts\n+        self.hidden_dim = config.hidden_size\n+        self.weight = nn.Parameter(torch.empty(self.num_experts, self.hidden_dim))\n+        self.bias = nn.Parameter(torch.empty(self.num_experts))\n+\n+    def forward(self, hidden_states):\n+        hidden_states = hidden_states.reshape(-1, self.hidden_dim)\n+        router_logits = F.linear(hidden_states, self.weight, self.bias)  # (seq_len, num_experts)\n+        router_top_value, router_indices = torch.topk(router_logits, self.top_k, dim=-1)  # (seq_len, top_k)\n+        router_top_value = torch.nn.functional.softmax(router_top_value, dim=1, dtype=router_top_value.dtype)\n+        router_scores = torch.zeros_like(router_logits).scatter_(1, router_indices, router_top_value)\n+        return router_scores, router_indices\n+\n+\n+@use_kernel_forward_from_hub(\"MegaBlocksMoeMLP\")\n+class GptOssMLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.router = GptOssTopKRouter(config)\n+        self.experts = GptOssExperts(config)\n+\n+    def forward(self, hidden_states):\n+        router_scores, router_indices = self.router(hidden_states)  # (num_experts, seq_len)\n+        routed_out = self.experts(hidden_states, router_indices=router_indices, routing_weights=router_scores)\n+        return routed_out, router_scores\n+\n+\n+class GptOssRotaryEmbedding(nn.Module):\n+    def __init__(self, config: GptOssConfig, device=None):\n+        super().__init__()\n+        # BC: \"rope_type\" was originally \"type\"\n+        if hasattr(config, \"rope_scaling\") and isinstance(config.rope_scaling, dict):\n+            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n+        else:\n+            self.rope_type = \"default\"\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = self.inv_freq\n+\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1).to(x.device)\n+        position_ids_expanded = position_ids[:, None, :].float()\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(1, 2)\n+            emb = freqs\n+            cos = emb.cos() * self.attention_scaling\n+            sin = emb.sin() * self.attention_scaling\n+\n+        return cos.to(x.dtype), sin.to(x.dtype)\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def _apply_rotary_emb(\n+    x: torch.Tensor,\n+    cos: torch.Tensor,\n+    sin: torch.Tensor,\n+) -> torch.Tensor:\n+    first_half, second_half = torch.chunk(x, 2, dim=-1)\n+    first_ = first_half * cos - second_half * sin\n+    second_ = second_half * cos + first_half * sin\n+    return torch.cat((first_, second_), dim=-1)\n+\n+\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+    q_embed = _apply_rotary_emb(q, cos, sin)\n+    k_embed = _apply_rotary_emb(k, cos, sin)\n+    return q_embed, k_embed\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs,\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    sinks = module.sinks.reshape(1, -1, 1, 1).expand(query.shape[0], -1, query.shape[-2], -1)\n+    combined_logits = torch.cat([attn_weights, sinks], dim=-1)\n+\n+    # This was not in the original implementation and slightly affect results; it prevents overflow in BF16/FP16\n+    # when training with bsz>1 we clamp max values.\n+\n+    combined_logits = combined_logits - combined_logits.max(dim=-1, keepdim=True).values\n+    probs = F.softmax(combined_logits, dim=-1, dtype=combined_logits.dtype)\n+    scores = probs[..., :-1]  # we drop the sink here\n+    attn_weights = nn.functional.dropout(scores, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+    return attn_output, attn_weights\n+\n+\n+class GptOssAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: GptOssConfig, layer_idx: int):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.head_dim = getattr(config, \"head_dim\", config.hidden_size // config.num_attention_heads)\n+        self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.attention_dropout = config.attention_dropout\n+        self.is_causal = True\n+        self.q_proj = nn.Linear(\n+            config.hidden_size, config.num_attention_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.k_proj = nn.Linear(\n+            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.v_proj = nn.Linear(\n+            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.o_proj = nn.Linear(\n+            config.num_attention_heads * self.head_dim, config.hidden_size, bias=config.attention_bias\n+        )\n+        self.sliding_window = config.sliding_window if config.layer_types[layer_idx] == \"sliding_attention\" else None\n+        self.sinks = nn.Parameter(torch.empty(config.num_attention_heads))\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            cache_kwargs = {\"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            sliding_window=self.sliding_window,\n+            s_aux=self.sinks,  # diff with Llama\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class GptOssDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: GptOssConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+        self.self_attn = GptOssAttention(config=config, layer_idx=layer_idx)\n+        self.mlp = GptOssMLP(config)\n+        self.input_layernorm = GptOssRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = GptOssRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.attention_type = config.layer_types[layer_idx]\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,  # necessary, but kept here for BC\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor]:\n+        residual = hidden_states\n+        hidden_states = self.input_layernorm(hidden_states)\n+        # Self Attention\n+        hidden_states, _ = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states, _ = self.mlp(hidden_states)  # diff with llama: router scores\n+        hidden_states = residual + hidden_states\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class GptOssPreTrainedModel(PreTrainedModel):\n+    config: GptOssConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"GptOssDecoderLayer\"]\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _supports_flash_attn = True\n+    _supports_sdpa = False\n+    _supports_flex_attn = True\n+\n+    _can_compile_fullgraph = True\n+    _supports_attention_backend = True\n+    _can_record_outputs = {\n+        \"router_logits\": OutputRecorder(GptOssTopKRouter, index=0),\n+        \"hidden_states\": GptOssDecoderLayer,\n+        \"attentions\": GptOssAttention,\n+    }\n+    _keep_in_fp32_modules = [\"post_attention_layernorm\", \"input_layernorm\", \"norm\"]\n+    _supports_flash_attention = False\n+    _supports_flex_attention = False\n+\n+    def _init_weights(self, module):\n+        std = self.config.initializer_range\n+        if isinstance(module, nn.Linear):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Parameter):\n+            module.data.normal_(mean=0.0, std=std)\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+        elif isinstance(module, GptOssRMSNorm):\n+            module.weight.data.fill_(1.0)\n+        elif isinstance(module, GptOssExperts):\n+            module.gate_up_proj.data.normal_(mean=0.0, std=std)\n+            module.gate_up_proj_bias.data.zero_()\n+            module.down_proj.data.normal_(mean=0.0, std=std)\n+            module.down_proj_bias.data.zero_()\n+        elif isinstance(module, GptOssAttention):\n+            module.sinks.data.normal_(mean=0.0, std=std)\n+        elif isinstance(module, GptOssTopKRouter):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            module.bias.data.normal_(mean=0.0, std=std)\n+\n+\n+@auto_docstring\n+class GptOssModel(GptOssPreTrainedModel):\n+    _no_split_modules = [\"GptOssDecoderLayer\"]\n+\n+    def __init__(self, config: GptOssConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [GptOssDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = GptOssRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = GptOssRotaryEmbedding(config=config)\n+        self.gradient_checkpointing = False\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @check_model_inputs\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> MoeModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache()\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        # It may already have been prepared by e.g. `generate`\n+        if not isinstance(causal_mask_mapping := attention_mask, dict):\n+            mask_kwargs = {\n+                \"config\": self.config,\n+                \"input_embeds\": inputs_embeds,\n+                \"attention_mask\": attention_mask,\n+                \"cache_position\": cache_position,\n+                \"past_key_values\": past_key_values,\n+            }\n+            causal_mask_mapping = {\n+                \"full_attention\": create_causal_mask(**mask_kwargs),\n+                \"sliding_attention\": create_sliding_window_causal_mask(**mask_kwargs),\n+            }\n+\n+        hidden_states = inputs_embeds\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        for decoder_layer in self.layers:\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask_mapping[decoder_layer.attention_type],\n+                position_ids=position_ids,\n+                past_key_value=past_key_values,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                position_embeddings=position_embeddings,\n+                **kwargs,\n+            )\n+        hidden_states = self.norm(hidden_states)\n+        return MoeModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+def load_balancing_loss_func(\n+    gate_logits: Union[torch.Tensor, tuple[torch.Tensor], None],\n+    num_experts: Optional[int] = None,\n+    top_k=2,\n+    attention_mask: Optional[torch.Tensor] = None,\n+) -> Union[torch.Tensor, int]:\n+    r\"\"\"\n+    Computes auxiliary load balancing loss as in Switch Transformer - implemented in Pytorch.\n+\n+    See Switch Transformer (https://huggingface.co/papers/2101.03961) for more details. This function implements the loss\n+    function presented in equations (4) - (6) of the paper. It aims at penalizing cases where the routing between\n+    experts is too unbalanced.\n+\n+    Args:\n+        gate_logits:\n+            Logits from the `gate`, should be a tuple of model.config.num_hidden_layers tensors of\n+            shape [batch_size X sequence_length, num_experts].\n+        num_experts:\n+            Number of experts\n+        top_k:\n+            The number of experts to route per-token, can be also interpreted as the `top-k` routing\n+            parameter.\n+        attention_mask (`torch.Tensor`, *optional*):\n+            The attention_mask used in forward function\n+            shape [batch_size X sequence_length] if not None.\n+\n+    Returns:\n+        The auxiliary loss.\n+    \"\"\"\n+    if gate_logits is None or not isinstance(gate_logits, tuple):\n+        return 0\n+\n+    if isinstance(gate_logits, tuple):\n+        compute_device = gate_logits[0].device\n+        concatenated_gate_logits = torch.cat([layer_gate.to(compute_device) for layer_gate in gate_logits], dim=0)\n+\n+    routing_weights = torch.nn.functional.softmax(concatenated_gate_logits, dim=-1)\n+\n+    _, selected_experts = torch.topk(routing_weights, top_k, dim=-1)\n+\n+    expert_mask = torch.nn.functional.one_hot(selected_experts, num_experts)\n+\n+    if attention_mask is None:\n+        # Compute the percentage of tokens routed to each experts\n+        tokens_per_expert = torch.mean(expert_mask.float(), dim=0)\n+\n+        # Compute the average probability of routing to these experts\n+        router_prob_per_expert = torch.mean(routing_weights, dim=0)\n+    else:\n+        batch_size, sequence_length = attention_mask.shape\n+        num_hidden_layers = concatenated_gate_logits.shape[0] // (batch_size * sequence_length)\n+\n+        # Compute the mask that masks all padding tokens as 0 with the same shape of expert_mask\n+        expert_attention_mask = (\n+            attention_mask[None, :, :, None, None]\n+            .expand((num_hidden_layers, batch_size, sequence_length, top_k, num_experts))\n+            .reshape(-1, top_k, num_experts)\n+            .to(compute_device)\n+        )\n+\n+        # Compute the percentage of tokens routed to each experts\n+        tokens_per_expert = torch.sum(expert_mask.float() * expert_attention_mask, dim=0) / torch.sum(\n+            expert_attention_mask, dim=0\n+        )\n+\n+        # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n+        router_per_expert_attention_mask = (\n+            attention_mask[None, :, :, None]\n+            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n+            .reshape(-1, num_experts)\n+            .to(compute_device)\n+        )\n+\n+        # Compute the average probability of routing to these experts\n+        router_prob_per_expert = torch.sum(routing_weights * router_per_expert_attention_mask, dim=0) / torch.sum(\n+            router_per_expert_attention_mask, dim=0\n+        )\n+\n+    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    return overall_loss * num_experts\n+\n+\n+@auto_docstring\n+class GptOssForCausalLM(GptOssPreTrainedModel, GenerationMixin):\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+    _tp_plan = {\"lm_head\": \"colwise_rep\"}\n+    _pp_plan = {\"lm_head\": ([\"hidden_states\"], [\"logits\"])}\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = GptOssModel(config)\n+        self.vocab_size = config.vocab_size\n+        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n+        self.router_aux_loss_coef = config.router_aux_loss_coef\n+        self.num_experts = config.num_local_experts\n+        self.num_experts_per_tok = config.num_experts_per_tok\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def set_decoder(self, decoder):\n+        self.model = decoder\n+\n+    def get_decoder(self):\n+        return self.model\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_router_logits: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> MoeCausalLMOutputWithPast:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, GptOssForCausalLM\n+\n+        >>> model = GptOssForCausalLM.from_pretrained(\"mistralai/GptOss-8x7B-v0.1\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"mistralai/GptOss-8x7B-v0.1\")\n+\n+        >>> prompt = \"Hey, are you conscious? Can you talk to me?\"\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"Hey, are you conscious? Can you talk to me?\\nI'm not conscious, but I can talk to you.\"\n+        ```\"\"\"\n+\n+        output_router_logits = (\n+            output_router_logits if output_router_logits is not None else self.config.output_router_logits\n+        )\n+\n+        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n+        outputs: MoeModelOutputWithPast = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_router_logits=output_router_logits,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs.last_hidden_state\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits, labels, self.vocab_size, **kwargs)\n+\n+        aux_loss = None\n+        if output_router_logits:\n+            aux_loss = load_balancing_loss_func(\n+                outputs.router_logits,\n+                self.num_experts,\n+                self.num_experts_per_tok,\n+                attention_mask,\n+            )\n+            if labels is not None:\n+                loss += self.router_aux_loss_coef * aux_loss.to(loss.device)  # make sure to reside in the same device\n+\n+        return MoeCausalLMOutputWithPast(\n+            loss=loss,\n+            aux_loss=aux_loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            router_logits=outputs.router_logits,\n+        )\n+\n+\n+__all__ = [\"GptOssForCausalLM\", \"GptOssModel\", \"GptOssPreTrainedModel\"]"
        },
        {
            "sha": "9b4eb578b73bcef975c40ff79e37e25807efce7a",
            "filename": "src/transformers/models/gpt_oss/modular_gpt_oss.py",
            "status": "added",
            "additions": 447,
            "deletions": 0,
            "changes": 447,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgpt_oss%2Fmodular_gpt_oss.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgpt_oss%2Fmodular_gpt_oss.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgpt_oss%2Fmodular_gpt_oss.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -0,0 +1,447 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import Callable, Optional\n+\n+import torch\n+from torch import nn\n+from torch.nn import functional as F\n+\n+from ...cache_utils import Cache, DynamicCache\n+from ...integrations.hub_kernels import use_kernel_forward_from_hub\n+from ...masking_utils import create_causal_mask, create_sliding_window_causal_mask\n+from ...modeling_outputs import (\n+    MoeModelOutputWithPast,\n+)\n+from ...modeling_rope_utils import dynamic_rope_update\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS\n+from ...processing_utils import Unpack\n+from ...utils import (\n+    TransformersKwargs,\n+    auto_docstring,\n+    logging,\n+)\n+from ...utils.generic import OutputRecorder, check_model_inputs\n+from ..llama.modeling_llama import (\n+    LlamaDecoderLayer,\n+    LlamaPreTrainedModel,\n+    LlamaRMSNorm,\n+    LlamaRotaryEmbedding,\n+    repeat_kv,\n+)\n+from ..mixtral.modeling_mixtral import MixtralForCausalLM, MixtralModel\n+from ..qwen2.modeling_qwen2 import Qwen2Attention\n+from .configuration_gpt_oss import GptOssConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class GptOssRMSNorm(LlamaRMSNorm):\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return (self.weight * hidden_states).to(input_dtype)  # main diff with Llama\n+\n+\n+class GptOssExperts(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.intermediate_size = config.intermediate_size\n+        self.num_experts = config.num_local_experts\n+        self.hidden_size = config.hidden_size\n+        self.expert_dim = self.intermediate_size\n+        self.gate_up_proj = nn.Parameter(torch.empty(self.num_experts, self.hidden_size, 2 * self.expert_dim))\n+        self.gate_up_proj_bias = nn.Parameter(torch.empty(self.num_experts, 2 * self.expert_dim))\n+        self.down_proj = nn.Parameter(torch.empty((self.num_experts, self.expert_dim, self.hidden_size)))\n+        self.down_proj_bias = nn.Parameter(torch.empty(self.num_experts, self.hidden_size))\n+        self.alpha = 1.702\n+        self.limit = 7.0\n+\n+    def forward(self, hidden_states: torch.Tensor, router_indices=None, routing_weights=None) -> torch.Tensor:\n+        \"\"\"\n+        When training is is more efficient to just loop over the experts and compute the output for each expert\n+        as otherwise the memory would explode.\n+\n+        For inference we can sacrifice some memory and compute the output for all experts at once. By repeating the inputs.\n+\n+        Args:\n+            hidden_states (torch.Tensor): (batch_size, seq_len, hidden_size)\n+            selected_experts (torch.Tensor): (batch_size * token_num, top_k)\n+            routing_weights (torch.Tensor): (batch_size * token_num, num_experts)\n+        Returns:\n+            torch.Tensor\n+        \"\"\"\n+        batch_size = hidden_states.shape[0]\n+        hidden_states = hidden_states.reshape(-1, self.hidden_size)  # (num_tokens, hidden_size)\n+        num_experts = routing_weights.shape[1]\n+        if self.training:\n+            next_states = torch.zeros_like(hidden_states, dtype=hidden_states.dtype, device=hidden_states.device)\n+            with torch.no_grad():\n+                expert_mask = torch.nn.functional.one_hot(router_indices, num_classes=num_experts)\n+                expert_mask = expert_mask.permute(2, 1, 0)\n+                # we sum on the top_k and on the sequence lenght to get which experts\n+                # are hit this time around\n+                expert_hitted = torch.greater(expert_mask.sum(dim=(-1, -2)), 0).nonzero()\n+            for expert_idx in expert_hitted[:]:\n+                with torch.no_grad():\n+                    _, token_idx = torch.where(expert_mask[expert_idx[0]])\n+                current_state = hidden_states[token_idx]\n+                gate_up = current_state @ self.gate_up_proj[expert_idx] + self.gate_up_proj_bias[expert_idx]\n+                gate, up = gate_up[..., ::2], gate_up[..., 1::2]\n+                gate = gate.clamp(min=None, max=self.limit)\n+                up = up.clamp(min=-self.limit, max=self.limit)\n+                glu = gate * torch.sigmoid(gate * self.alpha)\n+                gated_output = (up + 1) * glu\n+                out = gated_output @ self.down_proj[expert_idx] + self.down_proj_bias[expert_idx]\n+                weighted_output = out[0] * routing_weights[token_idx, expert_idx, None]\n+                next_states.index_add_(0, token_idx, weighted_output.to(hidden_states.dtype))\n+            next_states = next_states.view(batch_size, -1, self.hidden_size)\n+        else:\n+            hidden_states = hidden_states.repeat(num_experts, 1)\n+            hidden_states = hidden_states.view(num_experts, -1, self.hidden_size)\n+            gate_up = torch.bmm(hidden_states, self.gate_up_proj) + self.gate_up_proj_bias[..., None, :]\n+            gate, up = gate_up[..., ::2], gate_up[..., 1::2]\n+            gate = gate.clamp(min=None, max=self.limit)\n+            up = up.clamp(min=-self.limit, max=self.limit)\n+            glu = gate * torch.sigmoid(gate * self.alpha)\n+            next_states = torch.bmm(((up + 1) * glu), self.down_proj)\n+            next_states = next_states + self.down_proj_bias[..., None, :]\n+            next_states = next_states.view(num_experts, batch_size, -1, self.hidden_size)\n+            next_states = next_states * routing_weights.transpose(0, 1).view(num_experts, batch_size, -1)[..., None]\n+            next_states = next_states.sum(dim=0)\n+        return next_states\n+\n+\n+class GptOssTopKRouter(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.top_k = config.num_experts_per_tok\n+        self.num_experts = config.num_local_experts\n+        self.hidden_dim = config.hidden_size\n+        self.weight = nn.Parameter(torch.empty(self.num_experts, self.hidden_dim))\n+        self.bias = nn.Parameter(torch.empty(self.num_experts))\n+\n+    def forward(self, hidden_states):\n+        hidden_states = hidden_states.reshape(-1, self.hidden_dim)\n+        router_logits = F.linear(hidden_states, self.weight, self.bias)  # (seq_len, num_experts)\n+        router_top_value, router_indices = torch.topk(router_logits, self.top_k, dim=-1)  # (seq_len, top_k)\n+        router_top_value = torch.nn.functional.softmax(router_top_value, dim=1, dtype=router_top_value.dtype)\n+        router_scores = torch.zeros_like(router_logits).scatter_(1, router_indices, router_top_value)\n+        return router_scores, router_indices\n+\n+\n+@use_kernel_forward_from_hub(\"MegaBlocksMoeMLP\")\n+class GptOssMLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.router = GptOssTopKRouter(config)\n+        self.experts = GptOssExperts(config)\n+\n+    def forward(self, hidden_states):\n+        router_scores, router_indices = self.router(hidden_states)  # (num_experts, seq_len)\n+        routed_out = self.experts(hidden_states, router_indices=router_indices, routing_weights=router_scores)\n+        return routed_out, router_scores\n+\n+\n+class GptOssRotaryEmbedding(LlamaRotaryEmbedding):\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1).to(x.device)\n+        position_ids_expanded = position_ids[:, None, :].float()\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(1, 2)\n+            emb = freqs\n+            cos = emb.cos() * self.attention_scaling\n+            sin = emb.sin() * self.attention_scaling\n+\n+        return cos.to(x.dtype), sin.to(x.dtype)\n+\n+\n+def _apply_rotary_emb(\n+    x: torch.Tensor,\n+    cos: torch.Tensor,\n+    sin: torch.Tensor,\n+) -> torch.Tensor:\n+    first_half, second_half = torch.chunk(x, 2, dim=-1)\n+    first_ = first_half * cos - second_half * sin\n+    second_ = second_half * cos + first_half * sin\n+    return torch.cat((first_, second_), dim=-1)\n+\n+\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+    q_embed = _apply_rotary_emb(q, cos, sin)\n+    k_embed = _apply_rotary_emb(k, cos, sin)\n+    return q_embed, k_embed\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs,\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    sinks = module.sinks.reshape(1, -1, 1, 1).expand(query.shape[0], -1, query.shape[-2], -1)\n+    combined_logits = torch.cat([attn_weights, sinks], dim=-1)\n+\n+    # This was not in the original implementation and slightly affect results; it prevents overflow in BF16/FP16\n+    # when training with bsz>1 we clamp max values.\n+\n+    combined_logits = combined_logits - combined_logits.max(dim=-1, keepdim=True).values\n+    probs = F.softmax(combined_logits, dim=-1, dtype=combined_logits.dtype)\n+    scores = probs[..., :-1]  # we drop the sink here\n+    attn_weights = nn.functional.dropout(scores, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+    return attn_output, attn_weights\n+\n+\n+class GptOssAttention(Qwen2Attention):\n+    def __init__(self, config: GptOssConfig, layer_idx: int):\n+        super().__init__(config, layer_idx)\n+        self.q_proj = nn.Linear(\n+            config.hidden_size, config.num_attention_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.k_proj = nn.Linear(\n+            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.v_proj = nn.Linear(\n+            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.o_proj = nn.Linear(\n+            config.num_attention_heads * self.head_dim, config.hidden_size, bias=config.attention_bias\n+        )\n+        self.sinks = nn.Parameter(torch.empty(config.num_attention_heads))\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            cache_kwargs = {\"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            sliding_window=self.sliding_window,\n+            s_aux=self.sinks,  # diff with Llama\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class GptOssDecoderLayer(LlamaDecoderLayer):\n+    def __init__(self, config: GptOssConfig, layer_idx: int):\n+        super().__init__(config, layer_idx)\n+        self.hidden_size = config.hidden_size\n+        self.self_attn = GptOssAttention(config=config, layer_idx=layer_idx)\n+        self.mlp = GptOssMLP(config)\n+        self.input_layernorm = GptOssRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = GptOssRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.attention_type = config.layer_types[layer_idx]\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,  # necessary, but kept here for BC\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor]:\n+        residual = hidden_states\n+        hidden_states = self.input_layernorm(hidden_states)\n+        # Self Attention\n+        hidden_states, _ = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states, _ = self.mlp(hidden_states)  # diff with llama: router scores\n+        hidden_states = residual + hidden_states\n+        return hidden_states\n+\n+\n+class GptOssPreTrainedModel(LlamaPreTrainedModel):\n+    _keep_in_fp32_modules = [\"post_attention_layernorm\", \"input_layernorm\", \"norm\"]\n+    _supports_sdpa = False\n+    _supports_flash_attention = False\n+    _supports_flex_attention = False\n+    _can_record_outputs = {\n+        \"router_logits\": OutputRecorder(GptOssTopKRouter, index=0),\n+        \"hidden_states\": GptOssDecoderLayer,\n+        \"attentions\": GptOssAttention,\n+    }\n+\n+    def _init_weights(self, module):\n+        std = self.config.initializer_range\n+        if isinstance(module, nn.Linear):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Parameter):\n+            module.data.normal_(mean=0.0, std=std)\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+        elif isinstance(module, GptOssRMSNorm):\n+            module.weight.data.fill_(1.0)\n+        elif isinstance(module, GptOssExperts):\n+            module.gate_up_proj.data.normal_(mean=0.0, std=std)\n+            module.gate_up_proj_bias.data.zero_()\n+            module.down_proj.data.normal_(mean=0.0, std=std)\n+            module.down_proj_bias.data.zero_()\n+        elif isinstance(module, GptOssAttention):\n+            module.sinks.data.normal_(mean=0.0, std=std)\n+        elif isinstance(module, GptOssTopKRouter):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            module.bias.data.normal_(mean=0.0, std=std)\n+\n+\n+class GptOssModel(MixtralModel):\n+    _no_split_modules = [\"GptOssDecoderLayer\"]\n+\n+    @check_model_inputs\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> MoeModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache()\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        # It may already have been prepared by e.g. `generate`\n+        if not isinstance(causal_mask_mapping := attention_mask, dict):\n+            mask_kwargs = {\n+                \"config\": self.config,\n+                \"input_embeds\": inputs_embeds,\n+                \"attention_mask\": attention_mask,\n+                \"cache_position\": cache_position,\n+                \"past_key_values\": past_key_values,\n+            }\n+            causal_mask_mapping = {\n+                \"full_attention\": create_causal_mask(**mask_kwargs),\n+                \"sliding_attention\": create_sliding_window_causal_mask(**mask_kwargs),\n+            }\n+\n+        hidden_states = inputs_embeds\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        for decoder_layer in self.layers:\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask_mapping[decoder_layer.attention_type],\n+                position_ids=position_ids,\n+                past_key_value=past_key_values,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                position_embeddings=position_embeddings,\n+                **kwargs,\n+            )\n+        hidden_states = self.norm(hidden_states)\n+        return MoeModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+class GptOssForCausalLM(MixtralForCausalLM):\n+    pass\n+\n+\n+__all__ = [\n+    \"GptOssForCausalLM\",\n+    \"GptOssModel\",\n+    \"GptOssPreTrainedModel\",\n+]"
        },
        {
            "sha": "96fc1ca3373ca5550fbaaf2be21a02ba60ac83b8",
            "filename": "src/transformers/models/granitemoe/modeling_granitemoe.py",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgranitemoe%2Fmodeling_granitemoe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgranitemoe%2Fmodeling_granitemoe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgranitemoe%2Fmodeling_granitemoe.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -109,8 +109,8 @@ def load_balancing_loss_func(\n         # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n         router_per_expert_attention_mask = (\n             attention_mask[None, :, :, None]\n-            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n-            .reshape(-1, num_experts)\n+            .expand((num_hidden_layers, batch_size, sequence_length, routing_weights.shape[1]))\n+            .reshape(-1, routing_weights.shape[1])\n             .to(compute_device)\n         )\n \n@@ -119,7 +119,10 @@ def load_balancing_loss_func(\n             router_per_expert_attention_mask, dim=0\n         )\n \n-    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    rank = routing_weights.shape[1] * int(routing_weights.device.index)\n+    overall_loss = torch.sum(\n+        tokens_per_expert[:, rank : rank + routing_weights.shape[1]] * router_prob_per_expert.unsqueeze(0)\n+    )\n     return overall_loss * num_experts\n \n "
        },
        {
            "sha": "c727d40f448ba2b88cdad8dac52eaffc7b5a94cc",
            "filename": "src/transformers/models/granitemoehybrid/modeling_granitemoehybrid.py",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgranitemoehybrid%2Fmodeling_granitemoehybrid.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgranitemoehybrid%2Fmodeling_granitemoehybrid.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgranitemoehybrid%2Fmodeling_granitemoehybrid.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -1637,8 +1637,8 @@ def load_balancing_loss_func(\n         # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n         router_per_expert_attention_mask = (\n             attention_mask[None, :, :, None]\n-            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n-            .reshape(-1, num_experts)\n+            .expand((num_hidden_layers, batch_size, sequence_length, routing_weights.shape[1]))\n+            .reshape(-1, routing_weights.shape[1])\n             .to(compute_device)\n         )\n \n@@ -1647,7 +1647,10 @@ def load_balancing_loss_func(\n             router_per_expert_attention_mask, dim=0\n         )\n \n-    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    rank = routing_weights.shape[1] * int(routing_weights.device.index)\n+    overall_loss = torch.sum(\n+        tokens_per_expert[:, rank : rank + routing_weights.shape[1]] * router_prob_per_expert.unsqueeze(0)\n+    )\n     return overall_loss * num_experts\n \n "
        },
        {
            "sha": "f2f5d7d6f0f122a0a5926b23902c68ae897cc69c",
            "filename": "src/transformers/models/granitemoeshared/modeling_granitemoeshared.py",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgranitemoeshared%2Fmodeling_granitemoeshared.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fgranitemoeshared%2Fmodeling_granitemoeshared.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgranitemoeshared%2Fmodeling_granitemoeshared.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -908,8 +908,8 @@ def load_balancing_loss_func(\n         # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n         router_per_expert_attention_mask = (\n             attention_mask[None, :, :, None]\n-            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n-            .reshape(-1, num_experts)\n+            .expand((num_hidden_layers, batch_size, sequence_length, routing_weights.shape[1]))\n+            .reshape(-1, routing_weights.shape[1])\n             .to(compute_device)\n         )\n \n@@ -918,7 +918,10 @@ def load_balancing_loss_func(\n             router_per_expert_attention_mask, dim=0\n         )\n \n-    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    rank = routing_weights.shape[1] * int(routing_weights.device.index)\n+    overall_loss = torch.sum(\n+        tokens_per_expert[:, rank : rank + routing_weights.shape[1]] * router_prob_per_expert.unsqueeze(0)\n+    )\n     return overall_loss * num_experts\n \n "
        },
        {
            "sha": "191e82e8e8528af995c30f1c170128fffdca00e0",
            "filename": "src/transformers/models/jamba/modeling_jamba.py",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fjamba%2Fmodeling_jamba.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fjamba%2Fmodeling_jamba.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fjamba%2Fmodeling_jamba.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -138,8 +138,8 @@ def load_balancing_loss_func(\n         # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n         router_per_expert_attention_mask = (\n             attention_mask[None, :, :, None]\n-            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n-            .reshape(-1, num_experts)\n+            .expand((num_hidden_layers, batch_size, sequence_length, routing_weights.shape[1]))\n+            .reshape(-1, routing_weights.shape[1])\n             .to(compute_device)\n         )\n \n@@ -148,7 +148,10 @@ def load_balancing_loss_func(\n             router_per_expert_attention_mask, dim=0\n         )\n \n-    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    rank = routing_weights.shape[1] * int(routing_weights.device.index)\n+    overall_loss = torch.sum(\n+        tokens_per_expert[:, rank : rank + routing_weights.shape[1]] * router_prob_per_expert.unsqueeze(0)\n+    )\n     return overall_loss * num_experts\n \n "
        },
        {
            "sha": "99788594414225a65f2b8e4779239cf58563ab7b",
            "filename": "src/transformers/models/jetmoe/modeling_jetmoe.py",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fjetmoe%2Fmodeling_jetmoe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fjetmoe%2Fmodeling_jetmoe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fjetmoe%2Fmodeling_jetmoe.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -119,8 +119,8 @@ def load_balancing_loss_func(\n         # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n         router_per_expert_attention_mask = (\n             attention_mask[None, :, :, None]\n-            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n-            .reshape(-1, num_experts)\n+            .expand((num_hidden_layers, batch_size, sequence_length, routing_weights.shape[1]))\n+            .reshape(-1, routing_weights.shape[1])\n             .to(compute_device)\n         )\n \n@@ -129,7 +129,10 @@ def load_balancing_loss_func(\n             router_per_expert_attention_mask, dim=0\n         )\n \n-    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    rank = routing_weights.shape[1] * int(routing_weights.device.index)\n+    overall_loss = torch.sum(\n+        tokens_per_expert[:, rank : rank + routing_weights.shape[1]] * router_prob_per_expert.unsqueeze(0)\n+    )\n     return overall_loss * num_experts\n \n "
        },
        {
            "sha": "c9540e33af4c9fc5a2ab3db55e58008806c70143",
            "filename": "src/transformers/models/olmoe/modeling_olmoe.py",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Folmoe%2Fmodeling_olmoe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Folmoe%2Fmodeling_olmoe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Folmoe%2Fmodeling_olmoe.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -108,8 +108,8 @@ def load_balancing_loss_func(\n         # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n         router_per_expert_attention_mask = (\n             attention_mask[None, :, :, None]\n-            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n-            .reshape(-1, num_experts)\n+            .expand((num_hidden_layers, batch_size, sequence_length, routing_weights.shape[1]))\n+            .reshape(-1, routing_weights.shape[1])\n             .to(compute_device)\n         )\n \n@@ -118,7 +118,10 @@ def load_balancing_loss_func(\n             router_per_expert_attention_mask, dim=0\n         )\n \n-    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    rank = routing_weights.shape[1] * int(routing_weights.device.index)\n+    overall_loss = torch.sum(\n+        tokens_per_expert[:, rank : rank + routing_weights.shape[1]] * router_prob_per_expert.unsqueeze(0)\n+    )\n     return overall_loss * num_experts\n \n "
        },
        {
            "sha": "a4735a04ac247e90ed670084dd97405d3098baa3",
            "filename": "src/transformers/models/phimoe/modeling_phimoe.py",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fphimoe%2Fmodeling_phimoe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fphimoe%2Fmodeling_phimoe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fphimoe%2Fmodeling_phimoe.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -124,8 +124,8 @@ def load_balancing_loss_func(\n         # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n         router_per_expert_attention_mask = (\n             attention_mask[None, :, :, None]\n-            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n-            .reshape(-1, num_experts)\n+            .expand((num_hidden_layers, batch_size, sequence_length, routing_weights.shape[1]))\n+            .reshape(-1, routing_weights.shape[1])\n             .to(compute_device)\n         )\n \n@@ -134,7 +134,10 @@ def load_balancing_loss_func(\n             router_per_expert_attention_mask, dim=0\n         )\n \n-    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    rank = routing_weights.shape[1] * int(routing_weights.device.index)\n+    overall_loss = torch.sum(\n+        tokens_per_expert[:, rank : rank + routing_weights.shape[1]] * router_prob_per_expert.unsqueeze(0)\n+    )\n     return overall_loss * num_experts\n \n "
        },
        {
            "sha": "a9cc23b37e22d6a5e3e5dc8928ca3ea106aef98a",
            "filename": "src/transformers/models/qwen2_moe/modeling_qwen2_moe.py",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fqwen2_moe%2Fmodeling_qwen2_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fmodels%2Fqwen2_moe%2Fmodeling_qwen2_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_moe%2Fmodeling_qwen2_moe.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -128,8 +128,8 @@ def load_balancing_loss_func(\n         # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n         router_per_expert_attention_mask = (\n             attention_mask[None, :, :, None]\n-            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n-            .reshape(-1, num_experts)\n+            .expand((num_hidden_layers, batch_size, sequence_length, routing_weights.shape[1]))\n+            .reshape(-1, routing_weights.shape[1])\n             .to(compute_device)\n         )\n \n@@ -138,7 +138,10 @@ def load_balancing_loss_func(\n             router_per_expert_attention_mask, dim=0\n         )\n \n-    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    rank = routing_weights.shape[1] * int(routing_weights.device.index)\n+    overall_loss = torch.sum(\n+        tokens_per_expert[:, rank : rank + routing_weights.shape[1]] * router_prob_per_expert.unsqueeze(0)\n+    )\n     return overall_loss * num_experts\n \n "
        },
        {
            "sha": "49051f442695ed77937a98de68dcd189b1e12244",
            "filename": "src/transformers/quantizers/auto.py",
            "status": "modified",
            "additions": 10,
            "deletions": 3,
            "changes": 13,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fquantizers%2Fauto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fquantizers%2Fauto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fquantizers%2Fauto.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -31,6 +31,7 @@\n     GPTQConfig,\n     HiggsConfig,\n     HqqConfig,\n+    Mxfp4Config,\n     QuantizationConfigMixin,\n     QuantizationMethod,\n     QuantoConfig,\n@@ -54,6 +55,7 @@\n from .quantizer_gptq import GptqHfQuantizer\n from .quantizer_higgs import HiggsHfQuantizer\n from .quantizer_hqq import HqqHfQuantizer\n+from .quantizer_mxfp4 import Mxfp4HfQuantizer\n from .quantizer_quanto import QuantoHfQuantizer\n from .quantizer_quark import QuarkHfQuantizer\n from .quantizer_spqr import SpQRHfQuantizer\n@@ -81,6 +83,7 @@\n     \"spqr\": SpQRHfQuantizer,\n     \"fp8\": FineGrainedFP8HfQuantizer,\n     \"auto-round\": AutoRoundQuantizer,\n+    \"mxfp4\": Mxfp4HfQuantizer,\n }\n \n AUTO_QUANTIZATION_CONFIG_MAPPING = {\n@@ -103,6 +106,7 @@\n     \"spqr\": SpQRConfig,\n     \"fp8\": FineGrainedFP8Config,\n     \"auto-round\": AutoRoundConfig,\n+    \"mxfp4\": Mxfp4Config,\n }\n \n logger = logging.get_logger(__name__)\n@@ -211,7 +215,8 @@ def merge_quantization_configs(\n \n         if (\n             isinstance(\n-                quantization_config, (GPTQConfig, AwqConfig, AutoRoundConfig, FbgemmFp8Config, CompressedTensorsConfig)\n+                quantization_config,\n+                (GPTQConfig, AwqConfig, AutoRoundConfig, FbgemmFp8Config, CompressedTensorsConfig, Mxfp4Config),\n             )\n             and quantization_config_from_args is not None\n         ):\n@@ -222,9 +227,11 @@ def merge_quantization_configs(\n \n             warning_msg += f\"However, loading attributes (e.g. {list(loading_attr_dict.keys())}) will be overwritten with the one you passed to `from_pretrained`. The rest will be ignored.\"\n \n-        if warning_msg != \"\":\n+        if warning_msg != \"\" and not isinstance(quantization_config, Mxfp4Config):\n             warnings.warn(warning_msg)\n-\n+        else:\n+            # in the case of mxfp4, we don't want to print the warning message, bit confusing for users\n+            logger.info(warning_msg)\n         return quantization_config\n \n     @staticmethod"
        },
        {
            "sha": "4efa60a6e48df9bcbe8d30acce405b4c1136a22e",
            "filename": "src/transformers/quantizers/base.py",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fquantizers%2Fbase.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fquantizers%2Fbase.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fquantizers%2Fbase.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -237,6 +237,20 @@ def postprocess_model(self, model: \"PreTrainedModel\", **kwargs):\n         \"\"\"\n         return self._process_model_after_weight_loading(model, **kwargs)\n \n+    def remove_quantization_config(self, model):\n+        \"\"\"\n+        Remove the quantization config from the model.\n+        \"\"\"\n+        if hasattr(model, \"hf_quantizer\"):\n+            del model.hf_quantizer\n+        if hasattr(model.config, \"quantization_config\"):\n+            del model.config.quantization_config\n+        if hasattr(model.config, \"_pre_quantization_dtype\"):\n+            del model.config._pre_quantization_dtype\n+        if hasattr(model, \"quantization_method\"):\n+            del model.quantization_method\n+        model.is_quantized = False\n+\n     def dequantize(self, model):\n         \"\"\"\n         Potentially dequantize the model to retrieve the original model, with some loss in accuracy / performance.\n@@ -269,6 +283,12 @@ def _dequantize(self, model):\n             f\"{self.quantization_config.quant_method} has no implementation of `dequantize`, please raise an issue on GitHub.\"\n         )\n \n+    def update_param_name(self, param_name: str) -> str:\n+        \"\"\"\n+        Override this method if you want to adjust the `param_name`.\n+        \"\"\"\n+        return param_name\n+\n     @staticmethod\n     def get_modules_to_not_convert(\n         model: \"PreTrainedModel\","
        },
        {
            "sha": "061ca072f02929a713e428a9679bd218974071a1",
            "filename": "src/transformers/quantizers/quantizer_mxfp4.py",
            "status": "added",
            "additions": 331,
            "deletions": 0,
            "changes": 331,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fquantizers%2Fquantizer_mxfp4.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Fquantizers%2Fquantizer_mxfp4.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fquantizers%2Fquantizer_mxfp4.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -0,0 +1,331 @@\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING, Any, Optional\n+\n+from .base import HfQuantizer\n+\n+\n+if TYPE_CHECKING:\n+    from ..modeling_utils import PreTrainedModel\n+\n+from ..utils import (\n+    is_accelerate_available,\n+    is_torch_available,\n+    is_triton_available,\n+    is_triton_kernels_availalble,\n+    logging,\n+)\n+from .quantizers_utils import get_module_from_name\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Mxfp4HfQuantizer(HfQuantizer):\n+    \"\"\"\n+    FP4 quantization using fbgemm kernels\n+    \"\"\"\n+\n+    requires_parameters_quantization = True\n+    # to remove if we decide to allow quantizing weights with this method\n+    requires_calibration = False\n+\n+    required_packages = [\"accelerate\"]\n+\n+    def __init__(self, quantization_config, **kwargs):\n+        super().__init__(quantization_config, **kwargs)\n+        self.quantization_config = quantization_config\n+\n+    def validate_environment(self, *args, **kwargs):\n+        if not is_torch_available():\n+            raise ImportError(\n+                \"Using mxfp4 quantization requires torch\"\n+                \"Please install the latest version of torch ( pip install --upgrade torch )\"\n+            )\n+        if not torch.cuda.is_available():\n+            raise RuntimeError(\"Using MXFP4 quantized models requires a GPU\")\n+\n+        if not is_accelerate_available():\n+            raise ImportError(\"Using mxfp4 requires Accelerate: `pip install accelerate`\")\n+\n+        if self.quantization_config.dequantize:\n+            return\n+\n+        compute_capability = torch.cuda.get_device_capability()\n+        major, minor = compute_capability\n+\n+        if not is_triton_available(\"3.4.0\") or not is_triton_kernels_availalble():\n+            if self.pre_quantized and not self.quantization_config.dequantize:\n+                logger.warning_once(\n+                    \"MXFP4 quantization requires triton >= 3.4.0 and triton_kernels installed, we will default to dequantizing the model to bf16\"\n+                )\n+                self.quantization_config.dequantize = True\n+                return\n+            else:\n+                # we can't quantize the model in this case so we raise an error\n+                raise ValueError(\"MXFP4 quantization requires triton >= 3.4.0 and triton_kernels installed\")\n+\n+        if major < 9:\n+            raise ValueError(\n+                \"MXFP4 quantized models is only supported on GPUs with compute capability >= 9.0 (e.g H100, or B100)\"\n+            )\n+\n+        device_map = kwargs.get(\"device_map\", None)\n+        if device_map is None:\n+            logger.warning_once(\n+                \"You have loaded an FP4 model on CPU and have a CUDA device available, make sure to set \"\n+                \"your model on a GPU device in order to run your model. To remove this warning, pass device_map = 'cuda'. \"\n+            )\n+        elif device_map is not None:\n+            if (\n+                not self.pre_quantized\n+                and isinstance(device_map, dict)\n+                and (\"cpu\" in device_map.values() or \"disk\" in device_map.values())\n+            ):\n+                raise ValueError(\n+                    \"You are attempting to load an FP4 model with a device_map that contains a CPU or disk device.\"\n+                    \"This is not supported when the model is quantized on the fly. \"\n+                    \"Please use a quantized checkpoint or remove the CPU or disk device from the device_map.\"\n+                )\n+\n+    def update_torch_dtype(self, torch_dtype: \"torch.dtype\") -> \"torch.dtype\":\n+        if torch_dtype is None:\n+            torch_dtype = torch.bfloat16\n+            logger.info(\n+                \"Overriding torch_dtype=%s with `torch_dtype=torch.bfloat16` due to \"\n+                \"requirements of `fbgemm-gpu` to enable model loading in fp4. \"\n+                \"Pass your own torch_dtype to specify the dtype of the remaining non-linear layers or pass\"\n+                \" torch_dtype=torch.bfloat16 to remove this warning.\",\n+                torch_dtype,\n+            )\n+        return torch_dtype\n+\n+    def check_quantized_param(\n+        self,\n+        model: \"PreTrainedModel\",\n+        param_value: \"torch.Tensor\",\n+        param_name: str,\n+        state_dict: dict[str, Any],\n+        **kwargs,\n+    ):\n+        from ..integrations import Mxfp4GptOssExperts\n+        from ..models.gpt_oss.modeling_gpt_oss import GptOssExperts\n+\n+        # if we are dequantizing, the model doesn't have scales, and blocks only params like gate_up_proj and down_proj so we need to handle this case differently\n+        if self.quantization_config.dequantize and (\"blocks\" in param_name or \"scales\" in param_name):\n+            module, tensor_name = get_module_from_name(model, param_name[: -len(\"_blocks\")])\n+        else:\n+            module, tensor_name = get_module_from_name(model, param_name)\n+\n+        if isinstance(module, Mxfp4GptOssExperts) or (\n+            isinstance(module, GptOssExperts) and self.quantization_config.dequantize\n+        ):\n+            if tensor_name in [\"down_proj_bias\", \"gate_up_proj_bias\"]:\n+                return False\n+            return True\n+        return False\n+\n+    def create_quantized_param(\n+        self,\n+        model: \"PreTrainedModel\",\n+        param_value: \"torch.Tensor\",\n+        param_name: str,\n+        target_device: \"torch.device\",\n+        state_dict: dict[str, Any],\n+        unexpected_keys: Optional[list[str]] = None,\n+        **kwargs,\n+    ):\n+        if is_triton_kernels_availalble() and is_triton_available(\"3.4.0\"):\n+            from triton_kernels.matmul_ogs import FlexCtx, InFlexData, PrecisionConfig\n+\n+        from ..integrations import Mxfp4GptOssExperts, dequantize, load_and_swizzle_mxfp4, quantize_to_mxfp4\n+        from ..models.gpt_oss.modeling_gpt_oss import GptOssExperts\n+\n+        if not self.pre_quantized:\n+            module, _ = get_module_from_name(model, param_name)\n+            with torch.cuda.device(target_device):\n+                if isinstance(module, Mxfp4GptOssExperts):\n+                    if \"gate_up_proj\" in param_name:\n+                        right_pad = module.gate_up_proj_right_pad\n+                        bottom_pad = module.gate_up_proj_bottom_pad\n+                        loaded_weight = torch.nn.functional.pad(\n+                            param_value, (0, right_pad, 0, bottom_pad, 0, 0), mode=\"constant\", value=0\n+                        )\n+                        triton_weight_tensor, weight_scale = quantize_to_mxfp4(loaded_weight)\n+                        module.gate_up_proj_precision_config = PrecisionConfig(\n+                            weight_scale=weight_scale, flex_ctx=FlexCtx(rhs_data=InFlexData())\n+                        )\n+                        module.gate_up_proj = triton_weight_tensor\n+                        module.gate_up_proj_blocks = torch.nn.Parameter(\n+                            triton_weight_tensor.storage.data, requires_grad=False\n+                        )\n+                    elif \"down_proj\" in param_name:\n+                        right_pad = module.down_proj_right_pad\n+                        bottom_pad = module.down_proj_bottom_pad\n+                        loaded_weight = torch.nn.functional.pad(\n+                            param_value, (0, right_pad, 0, bottom_pad, 0, 0), mode=\"constant\", value=0\n+                        ).to(target_device)\n+                        triton_weight_tensor, weight_scale = quantize_to_mxfp4(loaded_weight)\n+                        module.down_proj_precision_config = PrecisionConfig(\n+                            weight_scale=weight_scale, flex_ctx=FlexCtx(rhs_data=InFlexData())\n+                        )\n+                        module.down_proj = triton_weight_tensor\n+                        module.down_proj_blocks = torch.nn.Parameter(\n+                            triton_weight_tensor.storage.data, requires_grad=False\n+                        )\n+\n+        # we take this path if already quantized but not in a compatible way\n+        # The params going here are either gate_up_proj_blocks, or down_proj_blocks, or gate_up_proj_scales, or down_proj_scales\n+        else:\n+            empty_param = kwargs.get(\"empty_param\", None)\n+            casting_dtype = kwargs.get(\"casting_dtype\", None)\n+            to_contiguous = kwargs.get(\"to_contiguous\", None)\n+            rank = kwargs.get(\"rank\", None)\n+            device_mesh = kwargs.get(\"device_mesh\", None)\n+            if (\"blocks\" in param_name or \"scales\" in param_name) and self.quantization_config.dequantize:\n+                # blocks and scales have the same length that's this works for both\n+                module, _ = get_module_from_name(model, param_name[: -len(\"_blocks\")])\n+            else:\n+                module, _ = get_module_from_name(model, param_name)\n+\n+            shard_kwargs = {\n+                \"empty_param\": empty_param,\n+                \"casting_dtype\": casting_dtype,\n+                \"to_contiguous\": to_contiguous,\n+                \"rank\": rank,\n+                \"device_mesh\": device_mesh,\n+                \"model\": model,\n+            }\n+\n+            if isinstance(module, Mxfp4GptOssExperts) or (\n+                isinstance(module, GptOssExperts) and self.quantization_config.dequantize\n+            ):\n+                if self.quantization_config.dequantize:\n+                    # dq_param_name is the name of the parameter without the blocks or scales suffix, it's used in this case since we don't switch linears\n+                    # so we only have the original param name\n+                    dq_param_name = param_name[: -len(\"_blocks\")]\n+                    dequantize(module, param_name, param_value, target_device, dq_param_name, **shard_kwargs)\n+                else:\n+                    load_and_swizzle_mxfp4(\n+                        module,\n+                        param_name,\n+                        param_value,\n+                        target_device,\n+                        **shard_kwargs,\n+                    )\n+\n+    def _process_model_after_weight_loading(self, model: \"PreTrainedModel\", **kwargs):\n+        # we are not really dequantizing, we are just removing everthing related to quantization here\n+        if self.quantization_config.dequantize:\n+            self.remove_quantization_config(model)\n+        # clean cache due to triton ops\n+        if torch.cuda.is_available():\n+            torch.cuda.empty_cache()\n+\n+    def update_expected_keys(self, model: \"PreTrainedModel\", expected_keys: list[str], checkpoint_keys: list[str]):\n+        # Replace expected_keys for experts' gate_up_proj and down_proj with their _blocks and _scales variants\n+        new_expected_keys = []\n+        for key in expected_keys:\n+            if key.endswith(\".mlp.experts.gate_up_proj\"):\n+                base = key[: -len(\"gate_up_proj\")]\n+                new_expected_keys.append(base + \"gate_up_proj_blocks\")\n+                new_expected_keys.append(base + \"gate_up_proj_scales\")\n+            elif key.endswith(\".mlp.experts.down_proj\"):\n+                base = key[: -len(\"down_proj\")]\n+                new_expected_keys.append(base + \"down_proj_blocks\")\n+                new_expected_keys.append(base + \"down_proj_scales\")\n+            else:\n+                new_expected_keys.append(key)\n+        return new_expected_keys\n+\n+    def _process_model_before_weight_loading(\n+        self,\n+        model: \"PreTrainedModel\",\n+        keep_in_fp32_modules: Optional[list[str]] = None,\n+        **kwargs,\n+    ):\n+        from ..integrations import replace_with_mxfp4_linear\n+\n+        self.modules_to_not_convert = self.get_modules_to_not_convert(\n+            model, self.quantization_config.modules_to_not_convert, keep_in_fp32_modules\n+        )\n+\n+        use_kernels = kwargs.get(\"use_kernels\", False)\n+        # if we are using kernels, we can't use the quantized model, since the forward pass is different and needs special handling\n+        if use_kernels:\n+            logger.warning_once(\n+                \"You are using full precision kernels, we will dequantize the model to bf16. \"\n+                \"To use the quantized model with quantization kernels, please set use_kernels=False\"\n+            )\n+            self.quantization_config.dequantize = True\n+\n+        config = model.config\n+        model = replace_with_mxfp4_linear(\n+            model,\n+            modules_to_not_convert=self.modules_to_not_convert,\n+            quantization_config=self.quantization_config,\n+            config=config,\n+        )\n+\n+        model.config.quantization_config = self.quantization_config\n+\n+    def update_missing_keys(self, model, missing_keys: list[str], prefix: str) -> list[str]:\n+        from ..integrations import Mxfp4GptOssExperts\n+\n+        not_missing_keys = []\n+        for name, module in model.named_modules():\n+            if isinstance(module, Mxfp4GptOssExperts):\n+                for missing in missing_keys:\n+                    if (\n+                        (name in missing or name in f\"{prefix}.{missing}\")\n+                        and not missing.endswith(\".weight\")\n+                        and not missing.endswith(\".bias\")\n+                    ):\n+                        not_missing_keys.append(missing)\n+        return [k for k in missing_keys if k not in not_missing_keys]\n+\n+    def update_tp_plan(self, config):\n+        if \"GptOssConfig\" in config.__class__.__name__:\n+            if getattr(config, \"base_model_tp_plan\", None) is not None:\n+                config.base_model_tp_plan.update(\n+                    {\n+                        \"layers.*.mlp.experts.gate_up_proj_blocks\": \"grouped_gemm\",\n+                        \"layers.*.mlp.experts.gate_up_proj_scales\": \"grouped_gemm\",\n+                        \"layers.*.mlp.experts.down_proj_blocks\": \"grouped_gemm\",\n+                        \"layers.*.mlp.experts.down_proj_scales\": \"grouped_gemm\",\n+                    }\n+                )\n+        return config\n+\n+    def update_param_name(self, param_name: str) -> str:\n+        if self.quantization_config.dequantize:\n+            if \"_blocks\" in param_name:\n+                return param_name.replace(\"_blocks\", \"\")\n+            elif \"_scales\" in param_name:\n+                return param_name.replace(\"_scales\", \"\")\n+        return param_name\n+\n+    def is_serializable(self, safe_serialization=None):\n+        logger.warning_once(\"MXFP4 quantization is not serializable using safetensors for now\")\n+        return False\n+\n+    @property\n+    def is_trainable(self) -> bool:\n+        logger.warning_once(\n+            \"MXFP4 quantization don't support training, please consider dequantizing the model first by passing quantization_config=Mxfp4Config(dequantize=True) to .from_pretrained()\"\n+        )\n+        return False"
        },
        {
            "sha": "7eb8b3c46eb7eafc92084ff18f3f357e05971d52",
            "filename": "src/transformers/testing_utils.py",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Ftesting_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Ftesting_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Ftesting_utils.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -66,6 +66,7 @@\n from .utils import (\n     ACCELERATE_MIN_VERSION,\n     GGUF_MIN_VERSION,\n+    TRITON_MIN_VERSION,\n     is_accelerate_available,\n     is_apex_available,\n     is_apollo_torch_available,\n@@ -168,6 +169,8 @@\n     is_torchcodec_available,\n     is_torchdynamo_available,\n     is_torchvision_available,\n+    is_triton_available,\n+    is_triton_kernels_availalble,\n     is_vision_available,\n     is_vptq_available,\n     strtobool,\n@@ -455,6 +458,26 @@ def require_accelerate(test_case, min_version: str = ACCELERATE_MIN_VERSION):\n     )(test_case)\n \n \n+def require_triton(min_version: str = TRITON_MIN_VERSION):\n+    \"\"\"\n+    Decorator marking a test that requires triton. These tests are skipped when triton isn't installed.\n+    \"\"\"\n+\n+    def decorator(test_case):\n+        return unittest.skipUnless(is_triton_available(min_version), f\"test requires triton version >= {min_version}\")(\n+            test_case\n+        )\n+\n+    return decorator\n+\n+\n+def require_triton_kernels(test_case):\n+    \"\"\"\n+    Decorator marking a test that requires triton_kernels. These tests are skipped when triton_kernels isn't installed.\n+    \"\"\"\n+    return unittest.skipUnless(is_triton_kernels_availalble(), \"test requires triton_kernels\")(test_case)\n+\n+\n def require_gguf(test_case, min_version: str = GGUF_MIN_VERSION):\n     \"\"\"\n     Decorator marking a test that requires ggguf. These tests are skipped when gguf isn't installed."
        },
        {
            "sha": "f53914baa5dc2bbb6f88340ef4e248ca2f6c3ed8",
            "filename": "src/transformers/utils/__init__.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Futils%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Futils%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2F__init__.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -117,6 +117,7 @@\n     ENV_VARS_TRUE_VALUES,\n     GGUF_MIN_VERSION,\n     TORCH_FX_REQUIRED_VERSION,\n+    TRITON_MIN_VERSION,\n     USE_JAX,\n     USE_TF,\n     USE_TORCH,\n@@ -268,6 +269,8 @@\n     is_torchvision_available,\n     is_torchvision_v2_available,\n     is_training_run_on_sagemaker,\n+    is_triton_available,\n+    is_triton_kernels_availalble,\n     is_uroman_available,\n     is_vision_available,\n     is_vptq_available,"
        },
        {
            "sha": "be2e0f956a572cac01a0e167e14ba857141a1374",
            "filename": "src/transformers/utils/generic.py",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Futils%2Fgeneric.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Futils%2Fgeneric.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fgeneric.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -1044,7 +1044,10 @@ def wrapped_forward(*args, **kwargs):\n                 if not isinstance(output, tuple):\n                     collected_outputs[key] += (output,)\n                 elif output[index] is not None:\n-                    collected_outputs[key] += (output[index],)\n+                    if key not in collected_outputs:\n+                        collected_outputs[key] = (output[index],)\n+                    else:\n+                        collected_outputs[key] += (output[index],)\n                 return output\n \n             return wrapped_forward"
        },
        {
            "sha": "a858c94c69580e9fd20aefc66afefe3e1081a93c",
            "filename": "src/transformers/utils/import_utils.py",
            "status": "modified",
            "additions": 16,
            "deletions": 5,
            "changes": 21,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Futils%2Fimport_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Futils%2Fimport_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fimport_utils.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -76,6 +76,11 @@ def _is_package_available(pkg_name: str, return_version: bool = False) -> Union[\n                     package_version = importlib.metadata.version(\"amd-quark\")\n                 except Exception:\n                     package_exists = False\n+            elif pkg_name == \"triton\":\n+                try:\n+                    package_version = importlib.metadata.version(\"pytorch-triton\")\n+                except Exception:\n+                    package_exists = False\n             else:\n                 # For packages other than \"torch\", don't attempt the fallback and set as not available\n                 package_exists = False\n@@ -111,6 +116,7 @@ def _is_package_available(pkg_name: str, return_version: bool = False) -> Union[\n VPTQ_MIN_VERSION = \"0.0.4\"\n TORCHAO_MIN_VERSION = \"0.4.0\"\n AUTOROUND_MIN_VERSION = \"0.5.0\"\n+TRITON_MIN_VERSION = \"1.0.0\"\n \n _accelerate_available, _accelerate_version = _is_package_available(\"accelerate\", return_version=True)\n _apex_available = _is_package_available(\"apex\")\n@@ -226,12 +232,13 @@ def _is_package_available(pkg_name: str, return_version: bool = False) -> Union[\n _tiktoken_available = _is_package_available(\"tiktoken\")\n _blobfile_available = _is_package_available(\"blobfile\")\n _liger_kernel_available = _is_package_available(\"liger_kernel\")\n-_triton_available = _is_package_available(\"triton\")\n _spqr_available = _is_package_available(\"spqr_quant\")\n _rich_available = _is_package_available(\"rich\")\n _kernels_available = _is_package_available(\"kernels\")\n _matplotlib_available = _is_package_available(\"matplotlib\")\n _mistral_common_available = _is_package_available(\"mistral_common\")\n+_triton_available, _triton_version = _is_package_available(\"triton\", return_version=True)\n+_triton_kernels_available = _is_package_available(\"triton_kernels\")\n \n _torch_version = \"N/A\"\n _torch_available = False\n@@ -412,6 +419,14 @@ def is_torch_deterministic():\n     return False\n \n \n+def is_triton_available(min_version: str = TRITON_MIN_VERSION):\n+    return _triton_available and version.parse(_triton_version) >= version.parse(min_version)\n+\n+\n+def is_triton_kernels_availalble():\n+    return _triton_kernels_available\n+\n+\n def is_hadamard_available():\n     return _hadamard_available\n \n@@ -1590,10 +1605,6 @@ def is_liger_kernel_available():\n     return version.parse(importlib.metadata.version(\"liger_kernel\")) >= version.parse(\"0.3.0\")\n \n \n-def is_triton_available():\n-    return _triton_available\n-\n-\n def is_rich_available():\n     return _rich_available\n "
        },
        {
            "sha": "ea807b9c51a90ad35f1adaf0a48c4ff551d8e778",
            "filename": "src/transformers/utils/quantization_config.py",
            "status": "modified",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Futils%2Fquantization_config.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/src%2Ftransformers%2Futils%2Fquantization_config.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fquantization_config.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -65,6 +65,7 @@ class QuantizationMethod(str, Enum):\n     QUARK = \"quark\"\n     FPQUANT = \"fp_quant\"\n     AUTOROUND = \"auto-round\"\n+    MXFP4 = \"mxfp4\"\n \n \n class AWQLinearVersion(str, Enum):\n@@ -2048,3 +2049,31 @@ def __init__(\n                 self.json_export_config = JsonExporterConfig()\n \n         self.quant_method = QuantizationMethod.QUARK\n+\n+\n+@dataclass\n+class Mxfp4Config(QuantizationConfigMixin):\n+    \"\"\"\n+    This is a wrapper class about all possible attributes and features that you can play with a model that has been\n+    loaded using mxfp4 quantization.\n+\n+    Args:\n+        modules_to_not_convert (`list`, *optional*, default to `None`):\n+            The list of modules to not quantize, useful for quantizing models that explicitly require to have\n+            some modules left in their original precision.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        modules_to_not_convert: Optional[list] = None,\n+        dequantize: bool = False,\n+        **kwargs,\n+    ):\n+        self.quant_method = QuantizationMethod.MXFP4\n+        self.modules_to_not_convert = modules_to_not_convert\n+        self.dequantize = dequantize\n+\n+    def get_loading_attributes(self):\n+        return {\n+            \"dequantize\": self.dequantize,\n+        }"
        },
        {
            "sha": "99b19b0ee7e0418ff883329e70f359b12b8935a3",
            "filename": "tests/fixtures/gpt_oss/integration_tests.json",
            "status": "added",
            "additions": 346,
            "deletions": 0,
            "changes": 346,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/tests%2Ffixtures%2Fgpt_oss%2Fintegration_tests.json",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/tests%2Ffixtures%2Fgpt_oss%2Fintegration_tests.json",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Ffixtures%2Fgpt_oss%2Fintegration_tests.json?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -0,0 +1,346 @@\n+[\n+  {\n+    \"quantized\": true,\n+    \"model\": \"120b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I am a language model, and I can help you too!\\n\\nSure! Here\",\n+      \"How are you? Tell me the name of the president of the United\\n\\nHello! As of my last update in November 2023, the President of the\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"120b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I am a language model, and I can help you too!\\n\\nSure! Here\",\n+      \"How are you? Tell me the name of the president of the United\\n\\nHello! As of my last update in November 2023, the President of the\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"120b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \"Did not work\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"120b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \"Did not work\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"120b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I am a language model, and I can help you too!\\n\\nSure! Here\",\n+      \"How are you? Tell me the name of the president of the United\\n\\nHello! As of my last update in November 2023, the President of the\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"120b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I am a language model, and I can help you too!\\n\\nSure! Here\",\n+      \"How are you? Tell me the name of the president of the United\\n\\nHello! As of my last update in November 2023, the President of the\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"120b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \"Did not work\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"120b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \"Did not work\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"20b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I love you, and I love you too.\\n\\nIt sounds like you're looking for\",\n+      \"How are you? Tell me the name of the president of the United States.\\\" The assistant should respond with the name of the president. The user is asking for\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"20b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I love you, and I love you too.\\n\\nIt sounds like you're looking for\",\n+      \"How are you? Tell me the name of the president of the United States.\\\" The assistant should respond with the name of the president. The user is asking for\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"20b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \"Did not work\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"20b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \"Did not work\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"20b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I love you, and I love you too.\\n\\nIt sounds like you're expressing a\",\n+      \"How are you? Tell me the name of the president of the United States.\\\" The assistant should respond with the name of the president. The user is asking for\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"20b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I love you, and I love you too.\\n\\nIt sounds like you're expressing a\",\n+      \"How are you? Tell me the name of the president of the United States.\\\" The assistant should respond with the name of the president. The user is asking for\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"20b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \"Did not work\"\n+    ]\n+  },\n+  {\n+    \"quantized\": true,\n+    \"model\": \"20b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \"Did not work\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"120b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue,\\nI am a language model, not a human being.\\n```\\n\\nThis poem is a\",\n+      \"How are you? Tell me the name of the president of the United Kingdom?\\n\\nThe United Kingdom does not have a president. The head of state is the\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"120b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I am a language model trained by OpenAI.\\n\\nI am a large language model\",\n+      \"How are you? Tell me the name of the president of the United\\n\\nHello! I'm an AI language model, so I don't have feelings, but I'm here\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"120b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue,\\nI am a language model, not a human being.\\n```\\n\\nThis poem is a\",\n+      \"How are you? Tell me the name of the president of the United Kingdom?\\n\\nThe United Kingdom does not have a president. The head of state is the\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"120b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I am a language model trained by OpenAI.\\n\\nI am a large language model\",\n+      \"How are you? Tell me the name of the president of the United\\n\\nHello! I'm an AI language model, so I don't have feelings, but I'm here\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"120b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue,\\nI am a language model, not a human being.\\n```\\n\\nThis poem is a\",\n+      \"How are you? Tell me the name of the president of the United States?\\n\\nAs an AI language model, I do not have personal feelings or emotions,\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"120b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I am a language model, and I can help you with your request.\\n\\nSure\",\n+      \"How are you? Tell me the name of the president of the United\\n\\nHello! I'm an AI language model, so I don't have feelings, but I'm here\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"120b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue,\\nI am a language model, not a human being.\\n```\\n\\nThis poem is a\",\n+      \"How are you? Tell me the name of the president of the United States?\\n\\nAs an AI language model, I do not have personal feelings or emotions,\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"120b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I am a language model, and I can help you with your request.\\n\\nSure\",\n+      \"How are you? Tell me the name of the president of the United\\n\\nHello! I'm an AI language model, so I don't have feelings, but I'm here\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"20b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I love you, and I love you too!\\n\\nRoses are red, vio\",\n+      \"How are you? Tell me the name of the president of the United States.\\\" The assistant should respond with the name of the president. The user is asking for\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"20b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue\\\" (makes sense). But the phrase \\\"the answer is 3\\\" is not a\",\n+      \"How are you? Tell me the name of the president of the United States.\\\" The answer to that is \\\"Joe Biden.\\\" The user is asking for the name\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"20b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I love you, and I love you too!\\n\\nRoses are red, vio\",\n+      \"How are you? Tell me the name of the president of the United States.\\\" The assistant should respond with the name of the president. The user is asking for\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"20b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"ft-hf-o-c/vllm-flash-attn3\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue\\\" (makes sense). But the phrase \\\"the answer is 3\\\" is not a\",\n+      \"How are you? Tell me the name of the president of the United States.\\\" The answer to that is \\\"Joe Biden.\\\" The user is asking for the name\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"20b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I love you, and I love you too!\\n\\nRoses are red, vio\",\n+      \"How are you? Tell me the name of the president of the United States.\\\" The assistant should respond with the name of the president. The user is asking for\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"20b\",\n+    \"kernels\": false,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue.\\\" -> from which we can derive a rule: if we have a red object that is\",\n+      \"How are you? Tell me the name of the president of the United States.\\n\\nI am an AI language model and I do not have a personal life or\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"20b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"eval\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue, I love you, and I love you too!\\n\\nRoses are red, vio\",\n+      \"How are you? Tell me the name of the president of the United States.\\\" The assistant should respond with the name of the president. The user is asking for\"\n+    ]\n+  },\n+  {\n+    \"quantized\": false,\n+    \"model\": \"20b\",\n+    \"kernels\": true,\n+    \"attn_impl\": \"eager\",\n+    \"mode\": \"train\",\n+    \"outputs\": [\n+      \".....Roses are red, violets are blue.\\\" -> from which we can derive a rule: if we have a red object that is\",\n+      \"How are you? Tell me the name of the president of the United States.\\n\\nI am an AI language model and I do not have a personal life or\"\n+    ]\n+  }\n+]"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/gpt_oss/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/tests%2Fmodels%2Fgpt_oss%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/tests%2Fmodels%2Fgpt_oss%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgpt_oss%2F__init__.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c"
        },
        {
            "sha": "ab978b9c9bc53acd326d9f420a79a8d0ce36a741",
            "filename": "tests/models/gpt_oss/test_modeling_gpt_oss.py",
            "status": "added",
            "additions": 523,
            "deletions": 0,
            "changes": 523,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/tests%2Fmodels%2Fgpt_oss%2Ftest_modeling_gpt_oss.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/tests%2Fmodels%2Fgpt_oss%2Ftest_modeling_gpt_oss.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgpt_oss%2Ftest_modeling_gpt_oss.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -0,0 +1,523 @@\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch GptOss model.\"\"\"\n+\n+import inspect\n+import json\n+import os\n+import subprocess\n+import tempfile\n+import unittest\n+from pathlib import Path\n+\n+import pytest\n+from parameterized import parameterized\n+\n+from transformers import (\n+    AutoModelForCausalLM,\n+    AutoTokenizer,\n+    GptOssConfig,\n+    is_torch_available,\n+)\n+from transformers.testing_utils import (\n+    cleanup,\n+    require_read_token,\n+    require_torch,\n+    require_torch_accelerator,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...causal_lm_tester import CausalLMModelTest, CausalLMModelTester\n+from ...test_configuration_common import ConfigTester\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import (\n+        GptOssForCausalLM,\n+        GptOssModel,\n+    )\n+\n+    NUM_GPUS = torch.cuda.device_count()\n+\n+\n+class GptOssModelTester(CausalLMModelTester):\n+    if is_torch_available():\n+        config_class = GptOssConfig\n+        base_model_class = GptOssModel\n+        causal_lm_class = GptOssForCausalLM\n+\n+    pipeline_model_mapping = (\n+        {\n+            \"feature-extraction\": GptOssModel,\n+            \"text-generation\": GptOssForCausalLM,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+\n+\n+@require_torch\n+class GptOssModelTest(CausalLMModelTest, unittest.TestCase):\n+    all_model_classes = (GptOssModel, GptOssForCausalLM) if is_torch_available() else ()\n+    pipeline_model_mapping = (\n+        {\n+            \"feature-extraction\": GptOssModel,\n+            \"text-generation\": GptOssForCausalLM,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+\n+    test_headmasking = False\n+    test_pruning = False\n+    _is_stateful = True\n+    model_split_percents = [0.5, 0.6]\n+    model_tester_class = GptOssModelTester\n+\n+    def setUp(self):\n+        self.model_tester = GptOssModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=GptOssConfig, hidden_size=37)\n+\n+    @unittest.skip(\"Failing because of unique cache (HybridCache)\")\n+    def test_model_outputs_equivalence(self, **kwargs):\n+        pass\n+\n+    @unittest.skip(\"GptOss's forcefully disables sdpa due to Sink\")\n+    def test_sdpa_can_dispatch_non_composite_models(self):\n+        pass\n+\n+    @unittest.skip(\"GptOss's eager attn/sdpa attn outputs are expected to be different\")\n+    def test_eager_matches_sdpa_generate(self):\n+        pass\n+\n+    @parameterized.expand([(\"random\",), (\"same\",)])\n+    @pytest.mark.generate\n+    @unittest.skip(\"GptOss has HybridCache which is not compatible with assisted decoding\")\n+    def test_assisted_decoding_matches_greedy_search(self, assistant_type):\n+        pass\n+\n+    @unittest.skip(\"GptOss has HybridCache which is not compatible with assisted decoding\")\n+    def test_prompt_lookup_decoding_matches_greedy_search(self, assistant_type):\n+        pass\n+\n+    @pytest.mark.generate\n+    @unittest.skip(\"GptOss has HybridCache which is not compatible with assisted decoding\")\n+    def test_assisted_decoding_sample(self):\n+        pass\n+\n+    @unittest.skip(\"GptOss has HybridCache which is not compatible with dola decoding\")\n+    def test_dola_decoding_sample(self):\n+        pass\n+\n+    @unittest.skip(\"GptOss has HybridCache and doesn't support continue from past kv\")\n+    def test_generate_continue_from_past_key_values(self):\n+        pass\n+\n+    @unittest.skip(\"GptOss has HybridCache and doesn't support contrastive generation\")\n+    def test_contrastive_generate(self):\n+        pass\n+\n+    @unittest.skip(\"GptOss has HybridCache and doesn't support contrastive generation\")\n+    def test_contrastive_generate_dict_outputs_use_cache(self):\n+        pass\n+\n+    @unittest.skip(\"GptOss has HybridCache and doesn't support contrastive generation\")\n+    def test_contrastive_generate_low_memory(self):\n+        pass\n+\n+    @unittest.skip(\"GptOss has HybridCache and doesn't support StaticCache. Though it could, it shouldn't support.\")\n+    def test_generate_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(\"GptOss has HybridCache and doesn't support StaticCache. Though it could, it shouldn't support.\")\n+    def test_generate_from_inputs_embeds_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(\"GptOss has HybridCache and doesn't support StaticCache. Though it could, it shouldn't support.\")\n+    def test_generate_continue_from_inputs_embeds(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"HybridCache can't be gathered because it is not iterable. Adding a simple iter and dumping `distributed_iterator`\"\n+        \" as in Dynamic Cache doesn't work. NOTE: @gante all cache objects would need better compatibility with multi gpu setting\"\n+    )\n+    def test_multi_gpu_data_parallel_forward(self):\n+        pass\n+\n+    @unittest.skip(\"GptOss has HybridCache which auto-compiles. Compile and FA2 don't work together.\")\n+    def test_eager_matches_fa2_generate(self):\n+        pass\n+\n+    @unittest.skip(\"GptOss eager/FA2 attention outputs are expected to be different\")\n+    def test_flash_attn_2_equivalence(self):\n+        pass\n+\n+    @unittest.skip(\"Most probably because of the MOE, the moe and router does not ignore padding tokens\")\n+    def test_eager_padding_matches_padding_free_with_position_ids(self):\n+        pass\n+\n+    @unittest.skip(\"GptOss does not support flex officially\")\n+    def test_flex_attention_with_grads(self):\n+        pass\n+\n+\n+RESULTS_PATH = Path(__file__).parent.parent.parent / \"fixtures/gpt_oss/integration_tests.json\"\n+\n+\n+# ------------------------\n+# Worker function for distributed torchrun\n+# ------------------------\n+def distributed_worker(quantized, model_size, kernels, attn_impl, mode):\n+    \"\"\"This is the function that will be executed by torchrun workers.\"\"\"\n+    import os\n+\n+    from transformers import AutoModelForCausalLM, AutoTokenizer\n+    from transformers.testing_utils import torch_device\n+\n+    input_text = [\n+        \"Roses are red, violets\",\n+        \"How are you? Tell me the name of the president of\",\n+    ]\n+\n+    # Convert args\n+    quantized = quantized.lower() == \"true\"\n+    kernels = kernels.lower() == \"true\"\n+\n+    # Distributed model loading\n+    model_id = f\"/fsx/vb/new-oai/gpt-oss-{model_size}-trfs\"\n+    model = AutoModelForCausalLM.from_pretrained(\n+        model_id,\n+        torch_dtype=\"auto\",\n+        tp_plan=\"auto\",  # distributed inference\n+        use_kernels=kernels,\n+    ).to(torch_device)\n+    model.set_attn_implementation(attn_impl)\n+    tokenizer = AutoTokenizer.from_pretrained(model_id, padding_side=\"left\")\n+\n+    # Inference\n+    inputs = tokenizer(input_text, return_tensors=\"pt\", padding=True).to(torch_device)\n+    output = model.generate(**inputs, max_new_tokens=20, do_sample=False)\n+    output_texts = tokenizer.batch_decode(output, skip_special_tokens=False)\n+\n+    # Only rank 0 writes results\n+    if int(os.environ.get(\"RANK\", \"0\")) == 0:\n+        result_entry = {\n+            \"quantized\": quantized,\n+            \"model\": model_size,\n+            \"kernels\": kernels,\n+            \"attn_impl\": attn_impl,\n+            \"mode\": mode,\n+            \"outputs\": output_texts,\n+        }\n+\n+        if os.path.exists(RESULTS_PATH):\n+            with open(RESULTS_PATH, \"r\") as f:\n+                results = json.load(f)\n+        else:\n+            results = []\n+        results.append(result_entry)\n+\n+        with open(RESULTS_PATH, \"w\") as f:\n+            json.dump(results, f, indent=2)\n+\n+\n+@slow\n+@require_torch_accelerator\n+class GptOssIntegrationTest(unittest.TestCase):\n+    input_text = [\n+        \"Roses are red, violets\",\n+        \"How are you? Tell me the name of the president of\",\n+    ]\n+\n+    def setUp(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    def tearDown(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    # ------------------------\n+    # Non-distributed inference\n+    # ------------------------\n+    @staticmethod\n+    def load_and_forward(model_id, attn_implementation, input_text, **pretrained_kwargs):\n+        model = AutoModelForCausalLM.from_pretrained(\n+            model_id,\n+            torch_dtype=torch.bfloat16,\n+            device_map=\"auto\",\n+            attn_implementation=attn_implementation,\n+            **pretrained_kwargs,\n+        )\n+        tokenizer = AutoTokenizer.from_pretrained(model_id, padding_side=\"left\")\n+\n+        inputs = tokenizer(input_text, return_tensors=\"pt\", padding=True).to(model.device)\n+        output = model.generate(**inputs, max_new_tokens=20, do_sample=False)\n+        output_text = tokenizer.batch_decode(output, skip_special_tokens=False)\n+        return output_text\n+\n+    # ------------------------\n+    # Distributed inference using inspect\n+    # ------------------------\n+    @staticmethod\n+    def run_distributed_test(quantized, model, kernels, attn_impl, mode):\n+        \"\"\"Launch torchrun using a temporary worker file generated from inspect.getsource().\"\"\"\n+        import textwrap\n+\n+        # Extract worker function source dynamically\n+        worker_src = inspect.getsource(distributed_worker)\n+\n+        # Create a temp file that calls the worker\n+        script_code = f\"\"\"\n+import sys\n+import json\n+\n+RESULTS_PATH = \"{RESULTS_PATH}\"\n+\n+{worker_src}\n+\n+if __name__ == \"__main__\":\n+    distributed_worker(\"{quantized}\", \"{model}\", \"{kernels}\", \"{attn_impl}\", \"{mode}\")\n+\"\"\"\n+        # Dedent for proper formatting\n+        script_code = textwrap.dedent(script_code)\n+\n+        # Write to temp file\n+        with tempfile.NamedTemporaryFile(\"w\", suffix=\"_worker.py\", delete=False) as tmp:\n+            tmp.write(script_code)\n+            tmp_path = tmp.name\n+\n+        # Launch torchrun\n+        cmd = [\n+            \"torchrun\",\n+            f\"--nproc_per_node={NUM_GPUS}\",\n+            tmp_path,\n+        ]\n+        subprocess.run(cmd, check=True)\n+\n+        # Cleanup\n+        os.remove(tmp_path)\n+\n+    # ------------------------\n+    # Shared parameterization\n+    # ------------------------\n+    PARAMETERS = [\n+        (False, \"120b\", False, \"eager\", \"eval\"),\n+        (False, \"120b\", False, \"eager\", \"train\"),\n+        (False, \"120b\", False, \"ft-hf-o-c/vllm-flash-attn3\", \"eval\"),\n+        (False, \"120b\", False, \"ft-hf-o-c/vllm-flash-attn3\", \"train\"),\n+        (False, \"120b\", True, \"eager\", \"eval\"),\n+        (False, \"120b\", True, \"eager\", \"train\"),\n+        (False, \"120b\", True, \"ft-hf-o-c/vllm-flash-attn3\", \"eval\"),\n+        (False, \"120b\", True, \"ft-hf-o-c/vllm-flash-attn3\", \"train\"),\n+        (True, \"120b\", False, \"eager\", \"eval\"),\n+        (True, \"120b\", False, \"eager\", \"train\"),\n+        (True, \"120b\", False, \"ft-hf-o-c/vllm-flash-attn3\", \"eval\"),\n+        (True, \"120b\", False, \"ft-hf-o-c/vllm-flash-attn3\", \"train\"),\n+        (True, \"120b\", True, \"eager\", \"eval\"),\n+        (True, \"120b\", True, \"eager\", \"train\"),\n+        (True, \"120b\", True, \"ft-hf-o-c/vllm-flash-attn3\", \"eval\"),\n+        (True, \"120b\", True, \"ft-hf-o-c/vllm-flash-attn3\", \"train\"),\n+        (False, \"20b\", False, \"eager\", \"eval\"),\n+        (False, \"20b\", False, \"eager\", \"train\"),\n+        (False, \"20b\", False, \"ft-hf-o-c/vllm-flash-attn3\", \"eval\"),\n+        (False, \"20b\", False, \"ft-hf-o-c/vllm-flash-attn3\", \"train\"),\n+        (False, \"20b\", True, \"eager\", \"eval\"),\n+        (False, \"20b\", True, \"eager\", \"train\"),\n+        (False, \"20b\", True, \"ft-hf-o-c/vllm-flash-attn3\", \"eval\"),\n+        (False, \"20b\", True, \"ft-hf-o-c/vllm-flash-attn3\", \"train\"),\n+        (True, \"20b\", False, \"eager\", \"eval\"),\n+        (True, \"20b\", False, \"eager\", \"train\"),\n+        (True, \"20b\", False, \"ft-hf-o-c/vllm-flash-attn3\", \"eval\"),\n+        (True, \"20b\", False, \"ft-hf-o-c/vllm-flash-attn3\", \"train\"),\n+        (True, \"20b\", True, \"eager\", \"eval\"),\n+        (True, \"20b\", True, \"eager\", \"train\"),\n+        (True, \"20b\", True, \"ft-hf-o-c/vllm-flash-attn3\", \"eval\"),\n+        (True, \"20b\", True, \"ft-hf-o-c/vllm-flash-attn3\", \"train\"),\n+    ]\n+\n+    # ------------------------\n+    # Non-distributed test\n+    # ------------------------\n+    @parameterized.expand(PARAMETERS)\n+    @require_read_token\n+    def test_model_outputs(self, quantized, model, kernels, attn_impl, mode):\n+        model_id = f\"/fsx/vb/new-oai/gpt-oss-{model}-trfs\"\n+        output_texts = self.load_and_forward(\n+            model_id,\n+            attn_impl,\n+            self.input_text,\n+            use_kernels=kernels,\n+        )\n+\n+        result_entry = {\n+            \"quantized\": quantized,\n+            \"model\": model,\n+            \"kernels\": kernels,\n+            \"attn_impl\": attn_impl,\n+            \"mode\": mode,\n+            \"outputs\": output_texts,\n+        }\n+\n+        if os.path.exists(RESULTS_PATH):\n+            with open(RESULTS_PATH, \"r\") as f:\n+                results = json.load(f)\n+        else:\n+            results = []\n+        results.append(result_entry)\n+        with open(RESULTS_PATH, \"w\") as f:\n+            json.dump(results, f, indent=2)\n+\n+        self.assertIsInstance(output_texts, list)\n+        self.assertTrue(all(isinstance(x, str) for x in output_texts))\n+\n+    # ------------------------\n+    # Distributed test\n+    # ------------------------\n+    @parameterized.expand(PARAMETERS)\n+    @require_read_token\n+    def test_model_outputs_distributed(self, quantized, model, kernels, attn_impl, mode):\n+        self.run_distributed_test(quantized, model, kernels, attn_impl, mode)\n+\n+    def test_model_matches_original_20b(self):\n+        input_text = \"Roses are red, violets\"\n+\n+        original_output = \"Roses are red, violets are blue, I love you, and I love you too.\"\n+        original_logprobs = torch.tensor(\n+            [\n+                -0.037353515625,\n+                -0.08154296875,\n+                -1.21875,\n+                -1.953125,\n+                -2.234375,\n+                -0.96875,\n+                -1.546875,\n+                -1.640625,\n+                -0.93359375,\n+                -1.609375,\n+                -1.625,\n+                -0.85546875,\n+                -1.7265625,\n+                -0.7421875,\n+                -2.078125,\n+                -0.006561279296875,\n+                -0.10498046875,\n+                -0.1767578125,\n+                -0.1240234375,\n+                -0.099609375,\n+            ]\n+        )\n+\n+        model_id = \"/fsx/vb/new-oai/gpt-oss-20b-trfs\"\n+\n+        model = AutoModelForCausalLM.from_pretrained(\n+            model_id,\n+            torch_dtype=torch.bfloat16,\n+            device_map=\"auto\",\n+            attn_implementation=\"eager\",\n+        )\n+        tokenizer = AutoTokenizer.from_pretrained(model_id)\n+        tokens = tokenizer(input_text)[\"input_ids\"]\n+\n+        num_generated_tokens = 0\n+        with torch.no_grad():\n+            for i in range(12):\n+                tensors = torch.as_tensor(tokens, dtype=torch.int32, device=model.device).unsqueeze(0)\n+                logits = model(tensors).logits[0]\n+\n+                predicted_token = torch.argmax(logits[-1, :], dim=-1).item()\n+                logprobs = torch.log_softmax(logits[-1, :], dim=-1)\n+                selected_logprobs = logprobs[predicted_token]\n+\n+                tokens.append(predicted_token)\n+                num_generated_tokens += 1\n+                decoded_token = tokenizer.decode([predicted_token])\n+                logprob_differences = selected_logprobs - original_logprobs[i]\n+\n+                print(\n+                    f\"Generated token: {repr(decoded_token)}, logprob: {selected_logprobs}, logprob differences: {logprob_differences}\"\n+                )\n+                torch.testing.assert_close(\n+                    selected_logprobs.cpu().to(original_logprobs.dtype), original_logprobs[i], atol=1e-1, rtol=1e-1\n+                )\n+\n+        decoded_string = tokenizer.decode(tokens)\n+        self.assertTrue(original_output.startswith(decoded_string))\n+\n+    def test_model_matches_original_120b(self):\n+        input_text = \"Roses are red, violets\"\n+\n+        original_output = \"\"\"Roses are red, violets are blue,\n+I am a language model, not a human being\"\"\"\n+        original_logprobs = torch.tensor(\n+            [\n+                -0.90234375,\n+                -0.66015625,\n+                -1.546875,\n+                -2.703125,\n+                -2.078125,\n+                -1.21875,\n+                -2.484375,\n+                -0.031982421875,\n+                -0.84765625,\n+                -1.890625,\n+                -0.1923828125,\n+                -2.046875,\n+                -1.65625,\n+                -1.3515625,\n+                -1.1640625,\n+                -0.3671875,\n+                -1.9921875,\n+                -1.5390625,\n+                -1.46875,\n+                -0.85546875,\n+            ]\n+        )\n+\n+        model_id = \"/fsx/vb/new-oai/gpt-oss-120b-trfs\"\n+\n+        model = AutoModelForCausalLM.from_pretrained(\n+            model_id,\n+            torch_dtype=torch.bfloat16,\n+            device_map=\"auto\",\n+            attn_implementation=\"eager\",\n+        )\n+        tokenizer = AutoTokenizer.from_pretrained(model_id)\n+        tokens = tokenizer(input_text)[\"input_ids\"]\n+\n+        num_generated_tokens = 0\n+        with torch.no_grad():\n+            for i in range(12):\n+                tensors = torch.as_tensor(tokens, dtype=torch.int32, device=model.device).unsqueeze(0)\n+                logits = model(tensors).logits[0]\n+\n+                predicted_token = torch.argmax(logits[-1, :], dim=-1).item()\n+                logprobs = torch.log_softmax(logits[-1, :], dim=-1)\n+                selected_logprobs = logprobs[predicted_token]\n+\n+                tokens.append(predicted_token)\n+                num_generated_tokens += 1\n+                decoded_token = tokenizer.decode([predicted_token])\n+                logprob_differences = selected_logprobs - original_logprobs[i]\n+\n+                print(\n+                    f\"Generated token: {repr(decoded_token)}, logprob: {selected_logprobs}, logprob differences: {logprob_differences}\"\n+                )\n+                torch.testing.assert_close(\n+                    selected_logprobs.cpu().to(original_logprobs.dtype), original_logprobs[i], atol=1e-1, rtol=1e-1\n+                )\n+\n+        decoded_string = tokenizer.decode(tokens)\n+        self.assertTrue(original_output.startswith(decoded_string))"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/quantization/mxfp4/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/tests%2Fquantization%2Fmxfp4%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/tests%2Fquantization%2Fmxfp4%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fquantization%2Fmxfp4%2F__init__.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c"
        },
        {
            "sha": "2194c2d3219e3f92a9a0615c766fbaf3c963b9f7",
            "filename": "tests/quantization/mxfp4/test_mxfp4.py",
            "status": "added",
            "additions": 420,
            "deletions": 0,
            "changes": 420,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/tests%2Fquantization%2Fmxfp4%2Ftest_mxfp4.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/tests%2Fquantization%2Fmxfp4%2Ftest_mxfp4.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fquantization%2Fmxfp4%2Ftest_mxfp4.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -0,0 +1,420 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import gc\n+import unittest\n+from unittest.mock import patch\n+\n+from transformers import AutoTokenizer, GptOssForCausalLM, Mxfp4Config\n+from transformers.testing_utils import (\n+    require_torch,\n+    require_torch_gpu,\n+    require_torch_large_gpu,\n+    require_triton,\n+    require_triton_kernels,\n+    slow,\n+)\n+from transformers.utils import (\n+    is_torch_available,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+class Mxfp4ConfigTest(unittest.TestCase):\n+    def test_basic_config_creation(self):\n+        \"\"\"Test basic configuration creation with default values\"\"\"\n+        config = Mxfp4Config()\n+        self.assertEqual(config.quant_method.value, \"mxfp4\")\n+        self.assertIsNone(config.modules_to_not_convert)\n+        self.assertFalse(config.dequantize)\n+\n+    def test_config_with_modules_to_not_convert(self):\n+        \"\"\"Test configuration with modules to not convert\"\"\"\n+        modules = [\"model.layers.*.self_attn\", \"lm_head\"]\n+        config = Mxfp4Config(modules_to_not_convert=modules)\n+        self.assertEqual(config.modules_to_not_convert, modules)\n+\n+    def test_config_with_dequantize(self):\n+        \"\"\"Test configuration with dequantize enabled\"\"\"\n+        config = Mxfp4Config(dequantize=True)\n+        self.assertTrue(config.dequantize)\n+\n+    def test_get_loading_attributes(self):\n+        \"\"\"Test get_loading_attributes method\"\"\"\n+        config = Mxfp4Config(dequantize=True)\n+        attrs = config.get_loading_attributes()\n+        self.assertEqual(attrs, {\"dequantize\": True})\n+\n+    def test_to_dict(self):\n+        \"\"\"Test configuration serialization to dict\"\"\"\n+        config = Mxfp4Config(modules_to_not_convert=[\"lm_head\"], dequantize=True)\n+        config_dict = config.to_dict()\n+        self.assertEqual(config_dict[\"quant_method\"], \"mxfp4\")\n+        self.assertEqual(config_dict[\"modules_to_not_convert\"], [\"lm_head\"])\n+        self.assertTrue(config_dict[\"dequantize\"])\n+\n+    def test_from_dict(self):\n+        \"\"\"Test configuration creation from dict\"\"\"\n+        config_dict = {\"quant_method\": \"mxfp4\", \"modules_to_not_convert\": [\"lm_head\"], \"dequantize\": True}\n+        config = Mxfp4Config.from_dict(config_dict)\n+        self.assertEqual(config.modules_to_not_convert, [\"lm_head\"])\n+        self.assertTrue(config.dequantize)\n+\n+\n+class Mxfp4QuantizerTest(unittest.TestCase):\n+    \"\"\"Test the Mxfp4HfQuantizer class\"\"\"\n+\n+    def setUp(self):\n+        gc.collect()\n+        if torch.cuda.is_available():\n+            torch.cuda.empty_cache()\n+\n+    def test_quantizer_validation_no_torch(self):\n+        \"\"\"Test quantizer validation when torch is not available\"\"\"\n+        with patch(\"transformers.quantizers.quantizer_mxfp4.is_torch_available\", return_value=False):\n+            from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+            config = Mxfp4Config()\n+            quantizer = Mxfp4HfQuantizer(config)\n+\n+            with self.assertRaises(ImportError):\n+                quantizer.validate_environment()\n+\n+    def test_quantizer_validation_no_cuda(self):\n+        \"\"\"Test quantizer validation when CUDA is not available\"\"\"\n+        with patch(\"torch.cuda.is_available\", return_value=False):\n+            from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+            config = Mxfp4Config()\n+            quantizer = Mxfp4HfQuantizer(config)\n+\n+            with self.assertRaises(RuntimeError):\n+                quantizer.validate_environment()\n+\n+    def test_quantizer_validation_low_compute_capability(self):\n+        \"\"\"Test quantizer validation with low compute capability\"\"\"\n+        with patch(\"torch.cuda.get_device_capability\", return_value=(8, 0)):\n+            from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+            config = Mxfp4Config()\n+            quantizer = Mxfp4HfQuantizer(config)\n+\n+            with self.assertRaises(ValueError):\n+                quantizer.validate_environment()\n+\n+    def test_quantizer_validation_low_compute_capability_with_dequantize(self):\n+        \"\"\"Test quantizer validation with low compute capability but dequantize enabled\"\"\"\n+        with patch(\"torch.cuda.get_device_capability\", return_value=(8, 0)):\n+            from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+            config = Mxfp4Config(dequantize=True)\n+            quantizer = Mxfp4HfQuantizer(config)\n+\n+            # Should not raise error with dequantize=True\n+            try:\n+                quantizer.validate_environment()\n+            except ValueError as e:\n+                if \"compute capability\" in str(e):\n+                    self.fail(\"Should not raise compute capability error when dequantize=True\")\n+\n+    def test_quantizer_validation_missing_triton(self):\n+        \"\"\"Test quantizer validation when triton is not available\"\"\"\n+        with (\n+            patch(\"transformers.quantizers.quantizer_mxfp4.is_triton_available\", return_value=False),\n+            patch(\"transformers.quantizers.quantizer_mxfp4.is_triton_kernels_availalble\", return_value=False),\n+        ):\n+            from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+            config = Mxfp4Config()\n+            quantizer = Mxfp4HfQuantizer(config)\n+            quantizer.pre_quantized = False\n+            with self.assertRaises(ValueError):\n+                quantizer.validate_environment()\n+\n+    def test_quantizer_validation_missing_triton_pre_quantized_no_dequantize(self):\n+        \"\"\"Test quantizer validation when triton is not available but model is pre-quantized and dequantize is False\"\"\"\n+        with (\n+            patch(\"transformers.quantizers.quantizer_mxfp4.is_triton_available\", return_value=False),\n+            patch(\"transformers.quantizers.quantizer_mxfp4.is_triton_kernels_availalble\", return_value=False),\n+        ):\n+            from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+            config = Mxfp4Config()\n+            quantizer = Mxfp4HfQuantizer(config)\n+            quantizer.pre_quantized = True\n+\n+            # Should automatically set dequantize=True and warn\n+            quantizer.validate_environment()\n+            self.assertTrue(quantizer.quantization_config.dequantize)\n+\n+    def test_update_torch_dtype(self):\n+        \"\"\"Test torch dtype updating\"\"\"\n+        from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+        config = Mxfp4Config()\n+        quantizer = Mxfp4HfQuantizer(config)\n+\n+        # Should default to bfloat16\n+        result_dtype = quantizer.update_torch_dtype(None)\n+        self.assertEqual(result_dtype, torch.bfloat16)\n+\n+        # Should preserve existing dtype\n+        result_dtype = quantizer.update_torch_dtype(torch.float32)\n+        self.assertEqual(result_dtype, torch.float32)\n+\n+    def test_update_expected_keys(self):\n+        \"\"\"Test expected keys updating for quantized models\"\"\"\n+        from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+        config = Mxfp4Config()\n+        quantizer = Mxfp4HfQuantizer(config)\n+\n+        expected_keys = [\n+            \"model.layers.0.mlp.experts.gate_up_proj\",\n+            \"model.layers.0.mlp.experts.down_proj\",\n+            \"model.embed_tokens.weight\",\n+        ]\n+\n+        updated_keys = quantizer.update_expected_keys(None, expected_keys, [])\n+\n+        expected_updated = [\n+            \"model.layers.0.mlp.experts.gate_up_proj_blocks\",\n+            \"model.layers.0.mlp.experts.gate_up_proj_scales\",\n+            \"model.layers.0.mlp.experts.down_proj_blocks\",\n+            \"model.layers.0.mlp.experts.down_proj_scales\",\n+            \"model.embed_tokens.weight\",\n+        ]\n+\n+        self.assertEqual(set(updated_keys), set(expected_updated))\n+\n+    def test_update_param_name_dequantize(self):\n+        \"\"\"Test parameter name updating when dequantizing\"\"\"\n+        from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+        config = Mxfp4Config(dequantize=True)\n+        quantizer = Mxfp4HfQuantizer(config)\n+\n+        # Should remove _blocks suffix\n+        param_name = \"model.layers.0.mlp.experts.gate_up_proj_blocks\"\n+        updated_name = quantizer.update_param_name(param_name)\n+        self.assertEqual(updated_name, \"model.layers.0.mlp.experts.gate_up_proj\")\n+\n+        # Should remove _scales suffix\n+        param_name = \"model.layers.0.mlp.experts.down_proj_scales\"\n+        updated_name = quantizer.update_param_name(param_name)\n+        self.assertEqual(updated_name, \"model.layers.0.mlp.experts.down_proj\")\n+\n+        # Should not change other names\n+        param_name = \"model.embed_tokens.weight\"\n+        updated_name = quantizer.update_param_name(param_name)\n+        self.assertEqual(updated_name, \"model.embed_tokens.weight\")\n+\n+    def test_update_param_name_no_dequantize(self):\n+        \"\"\"Test parameter name updating when not dequantizing\"\"\"\n+        from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+        config = Mxfp4Config(dequantize=False)\n+        quantizer = Mxfp4HfQuantizer(config)\n+\n+        param_name = \"model.layers.0.mlp.experts.gate_up_proj_blocks\"\n+        updated_name = quantizer.update_param_name(param_name)\n+        self.assertEqual(updated_name, param_name)\n+\n+    def test_is_serializable(self):\n+        \"\"\"Test serialization capability\"\"\"\n+        from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+        config = Mxfp4Config()\n+        quantizer = Mxfp4HfQuantizer(config)\n+\n+        # MXFP4 is not serializable with safetensors\n+        self.assertFalse(quantizer.is_serializable())\n+\n+    def test_is_trainable(self):\n+        \"\"\"Test trainability\"\"\"\n+        from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+        config = Mxfp4Config()\n+        quantizer = Mxfp4HfQuantizer(config)\n+\n+        # MXFP4 is not trainable\n+        self.assertFalse(quantizer.is_trainable)\n+\n+\n+class Mxfp4IntegrationTest(unittest.TestCase):\n+    \"\"\"Test mxfp4 integration functions\"\"\"\n+\n+    def test_should_convert_module(self):\n+        \"\"\"Test module conversion decision logic\"\"\"\n+        from transformers.integrations.mxfp4 import should_convert_module\n+\n+        # Should convert by default\n+        self.assertTrue(should_convert_module([\"model\", \"layers\", \"0\", \"mlp\"], []))\n+\n+        # Should not convert if in exclusion list\n+        patterns = [\"model.layers.*.self_attn\", \"lm_head\"]\n+        self.assertFalse(should_convert_module([\"model\", \"layers\", \"0\", \"self_attn\"], patterns))\n+        self.assertFalse(should_convert_module([\"lm_head\"], patterns))\n+\n+        # Should convert if not in exclusion list\n+        self.assertTrue(should_convert_module([\"model\", \"layers\", \"0\", \"mlp\", \"experts\"], patterns))\n+\n+    @require_torch\n+    def test_convert_moe_packed_tensors(self):\n+        \"\"\"Test unpacking of quantized tensors\"\"\"\n+        from transformers.integrations.mxfp4 import convert_moe_packed_tensors\n+\n+        # Create dummy packed tensors\n+        blocks = torch.randint(0, 255, (2, 4, 8), dtype=torch.uint8)\n+        scales = torch.randint(100, 150, (2, 4), dtype=torch.uint8)\n+\n+        result = convert_moe_packed_tensors(blocks, scales, dtype=torch.bfloat16)\n+\n+        # Check output shape - should be [2, 4, 16] (8 * 2 for unpacking)\n+        self.assertEqual(result.shape, (2, 4 * 16))\n+        self.assertEqual(result.dtype, torch.bfloat16)\n+\n+    @require_triton(min_version=\"3.4.0\")\n+    @require_triton_kernels\n+    @require_torch_gpu\n+    @require_torch\n+    def test_quantize_to_mxfp4(self):\n+        \"\"\"Test quantization function\"\"\"\n+        from transformers.integrations.mxfp4 import quantize_to_mxfp4\n+\n+        # Create dummy weight tensor\n+        w = torch.randn(32, 64, 128, dtype=torch.bfloat16, device=torch.device(\"cuda\"))\n+\n+        quantized_w, flex_data, mx_ctx = quantize_to_mxfp4(w, None, None)\n+\n+        # Check that shapes are reasonable\n+        self.assertEqual(quantized_w.dtype, torch.uint8)\n+        self.assertIsNotNone(flex_data)\n+        self.assertIsNotNone(mx_ctx)\n+\n+\n+@require_torch\n+@require_torch_large_gpu\n+@slow\n+class Mxfp4ModelTest(unittest.TestCase):\n+    \"\"\"Test mxfp4 with actual models (requires specific model and hardware)\"\"\"\n+\n+    # These should be paths to real OpenAI MoE models for proper testing\n+    model_name_packed = \"/fsx/mohamed/oai-hf/tests/20b_converted_packed\"  # TODO: Use real packed quantized model\n+\n+    input_text = \"Once upon a time\"\n+\n+    # Expected outputs for generation tests\n+    EXPECTED_OUTPUTS = set()\n+    EXPECTED_OUTPUTS.add(\"Once upon a time, in a small village, there lived a young\")\n+\n+    def setUp(self):\n+        gc.collect()\n+        if torch.cuda.is_available():\n+            torch.cuda.empty_cache()\n+\n+    def tearDown(self):\n+        gc.collect()\n+        if torch.cuda.is_available():\n+            torch.cuda.empty_cache()\n+\n+    def check_inference_correctness_quantized(self, model, tokenizer):\n+        # Check that inference pass works on the model\n+        encoded_input = tokenizer(self.input_text, return_tensors=\"pt\").to(model.device)\n+\n+        # Set pad token if not set\n+        if tokenizer.pad_token is None:\n+            tokenizer.pad_token = tokenizer.eos_token\n+\n+        with torch.no_grad():\n+            output_sequences = model.generate(\n+                **encoded_input,\n+                max_new_tokens=10,\n+                do_sample=False,\n+                pad_token_id=tokenizer.eos_token_id,\n+                use_cache=False,\n+            )\n+\n+        generated_text = tokenizer.decode(output_sequences[0], skip_special_tokens=True)\n+\n+        self.assertIn(generated_text, self.EXPECTED_OUTPUTS)\n+\n+    def test_gpt_oss_model_loading_quantized_with_device_map(self):\n+        \"\"\"Test loading OpenAI MoE model with mxfp4 quantization and device_map\"\"\"\n+\n+        quantization_config = Mxfp4Config(dequantize=False)\n+\n+        # Test that config is properly set up\n+        self.assertFalse(quantization_config.dequantize)\n+\n+        model = GptOssForCausalLM.from_pretrained(\n+            self.model_name_packed,\n+            quantization_config=quantization_config,\n+            torch_dtype=torch.bfloat16,\n+            device_map=\"auto\",\n+        )\n+        tokenizer = AutoTokenizer.from_pretrained(self.model_name_packed)\n+        self.check_inference_correctness_quantized(model, tokenizer)\n+\n+    def test_gpt_oss_model_loading_dequantized_with_device_map(self):\n+        \"\"\"Test loading OpenAI MoE model with mxfp4 dequantization and device_map\"\"\"\n+\n+        quantization_config = Mxfp4Config(dequantize=True)\n+\n+        # Test that config is properly set up\n+        self.assertTrue(quantization_config.dequantize)\n+\n+        model = GptOssForCausalLM.from_pretrained(\n+            self.model_name_packed,\n+            quantization_config=quantization_config,\n+            torch_dtype=torch.bfloat16,\n+            device_map=\"auto\",\n+        )\n+        tokenizer = AutoTokenizer.from_pretrained(self.model_name_packed)\n+        self.check_inference_correctness_quantized(model, tokenizer)\n+\n+    def test_model_device_map_validation(self):\n+        \"\"\"Test device map validation\"\"\"\n+        from transformers.quantizers.quantizer_mxfp4 import Mxfp4HfQuantizer\n+\n+        config = Mxfp4Config()\n+        quantizer = Mxfp4HfQuantizer(config)\n+        quantizer.pre_quantized = False\n+\n+        # Test with CPU in device map (should raise error for non-pre-quantized)\n+        with self.assertRaises(ValueError):\n+            quantizer.validate_environment(device_map={\"\": \"cpu\"})\n+\n+    def test_memory_footprint_comparison(self):\n+        \"\"\"Test memory footprint differences between quantized and unquantized models\"\"\"\n+\n+        # Expected: quantized < dequantized < unquantized memory usage\n+        quantization_config = Mxfp4Config(dequantize=True)\n+        quantized_model = GptOssForCausalLM.from_pretrained(\n+            self.model_name_packed,\n+            torch_dtype=torch.bfloat16,\n+            device_map=\"auto\",\n+        )\n+        dequantized_model = GptOssForCausalLM.from_pretrained(\n+            self.model_name_packed,\n+            torch_dtype=torch.bfloat16,\n+            device_map=\"auto\",\n+            quantization_config=quantization_config,\n+        )\n+        quantized_mem = quantized_model.get_memory_footprint()\n+        dequantized_mem = dequantized_model.get_memory_footprint()\n+        self.assertLess(quantized_mem, dequantized_mem)"
        },
        {
            "sha": "23ba44958dcbd0645353d4242c413c051e24917c",
            "filename": "utils/check_docstrings.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/7c38d8fc23146e732d4098760bdcb27d7d12c90c/utils%2Fcheck_docstrings.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7c38d8fc23146e732d4098760bdcb27d7d12c90c/utils%2Fcheck_docstrings.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_docstrings.py?ref=7c38d8fc23146e732d4098760bdcb27d7d12c90c",
            "patch": "@@ -79,6 +79,7 @@\n # docstrings instead. If formatting should be ignored for the docstring, you can put a comment # no-format on the\n # line before the docstring.\n OBJECTS_TO_IGNORE = [\n+    \"Mxfp4Config\",\n     \"Exaone4Config\",\n     \"SmolLM3Config\",\n     \"Gemma3nVisionConfig\","
        }
    ],
    "stats": {
        "total": 4766,
        "additions": 4668,
        "deletions": 98
    }
}