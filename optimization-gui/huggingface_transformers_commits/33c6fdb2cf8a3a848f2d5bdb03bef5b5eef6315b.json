{
    "author": "princepride",
    "message": "Update VITS model card (#37335)\n\n* Update VITS model card\n\n* Update docs/source/en/model_doc/vits.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/vits.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/vits.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/vits.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update vits.md\n\n---------\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>",
    "sha": "33c6fdb2cf8a3a848f2d5bdb03bef5b5eef6315b",
    "files": [
        {
            "sha": "7a829b36ba802568117a82d9a6df650be7bf334c",
            "filename": "docs/source/en/model_doc/vits.md",
            "status": "modified",
            "additions": 91,
            "deletions": 119,
            "changes": 210,
            "blob_url": "https://github.com/huggingface/transformers/blob/33c6fdb2cf8a3a848f2d5bdb03bef5b5eef6315b/docs%2Fsource%2Fen%2Fmodel_doc%2Fvits.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/33c6fdb2cf8a3a848f2d5bdb03bef5b5eef6315b/docs%2Fsource%2Fen%2Fmodel_doc%2Fvits.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fvits.md?ref=33c6fdb2cf8a3a848f2d5bdb03bef5b5eef6315b",
            "patch": "@@ -7,168 +7,139 @@ http://www.apache.org/licenses/LICENSE-2.0\n \n Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n-specific language governing permissions and limitations under the License.\n--->\n+specific language governing permissions and limitations under the License.-->\n \n-# VITS\n-\n-<div class=\"flex flex-wrap space-x-1\">\n-<img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+<div style=\"float: right;\">\n+    <div class=\"flex flex-wrap space-x-1\">\n+        <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+    </div>\n </div>\n \n-## Overview\n-\n-The VITS model was proposed in [Conditional Variational Autoencoder with Adversarial Learning for End-to-End Text-to-Speech](https://arxiv.org/abs/2106.06103) by Jaehyeon Kim, Jungil Kong, Juhee Son.\n-\n-VITS (**V**ariational **I**nference with adversarial learning for end-to-end **T**ext-to-**S**peech) is an end-to-end \n-speech synthesis model that predicts a speech waveform conditional on an input text sequence. It is a conditional variational \n-autoencoder (VAE) comprised of a posterior encoder, decoder, and conditional prior.\n-\n-A set of spectrogram-based acoustic features are predicted by the flow-based module, which is formed of a Transformer-based\n-text encoder and multiple coupling layers. The spectrogram is decoded using a stack of transposed convolutional layers,\n-much in the same style as the HiFi-GAN vocoder. Motivated by the one-to-many nature of the TTS problem, where the same text \n-input can be spoken in multiple ways, the model also includes a stochastic duration predictor, which allows the model to \n-synthesise speech with different rhythms from the same input text. \n-\n-The model is trained end-to-end with a combination of losses derived from variational lower bound and adversarial training. \n-To improve the expressiveness of the model, normalizing flows are applied to the conditional prior distribution. During \n-inference, the text encodings are up-sampled based on the duration prediction module, and then mapped into the \n-waveform using a cascade of the flow module and HiFi-GAN decoder. Due to the stochastic nature of the duration predictor,\n-the model is non-deterministic, and thus requires a fixed seed to generate the same speech waveform.\n-\n-The abstract from the paper is the following:\n+# VITS\n \n-*Several recent end-to-end text-to-speech (TTS) models enabling single-stage training and parallel sampling have been proposed, but their sample quality does not match that of two-stage TTS systems. In this work, we present a parallel end-to-end TTS method that generates more natural sounding audio than current two-stage models. Our method adopts variational inference augmented with normalizing flows and an adversarial training process, which improves the expressive power of generative modeling. We also propose a stochastic duration predictor to synthesize speech with diverse rhythms from input text. With the uncertainty modeling over latent variables and the stochastic duration predictor, our method expresses the natural one-to-many relationship in which a text input can be spoken in multiple ways with different pitches and rhythms. A subjective human evaluation (mean opinion score, or MOS) on the LJ Speech, a single speaker dataset, shows that our method outperforms the best publicly available TTS systems and achieves a MOS comparable to ground truth.*\n+[VITS (Variational Inference with adversarial learning for end-to-end Text-to-Speech)](https://hf.co/papers/2106.06103) is a end-to-end speech synthesis model, simplifying the traditional two-stage text-to-speech (TTS) systems. It's unique because it directly synthesizes speech from text using variational inference, adversarial learning, and normalizing flows to produce natural and expressive speech with diverse rhythms and intonations.\n \n-This model can also be used with TTS checkpoints from [Massively Multilingual Speech (MMS)](https://arxiv.org/abs/2305.13516) \n-as these checkpoints use the same architecture and a slightly modified tokenizer.\n+You can find all the original VITS checkpoints under the [AI at Meta](https://huggingface.co/facebook?search_models=mms-tts) organization.\n \n-This model was contributed by [Matthijs](https://huggingface.co/Matthijs) and [sanchit-gandhi](https://huggingface.co/sanchit-gandhi). The original code can be found [here](https://github.com/jaywalnut310/vits).\n+> [!TIP]\n+> Click on the VITS models in the right sidebar for more examples of how to apply VITS.\n \n-## Usage examples\n+The example below demonstrates how to generate text based on an image with [`Pipeline`] or the [`AutoModel`] class.\n \n-Both the VITS and MMS-TTS checkpoints can be used with the same API. Since the flow-based model is non-deterministic, it \n-is good practice to set a seed to ensure reproducibility of the outputs. For languages with a Roman alphabet, \n-such as English or French, the tokenizer can be used directly to pre-process the text inputs. The following code example \n-runs a forward pass using the MMS-TTS English checkpoint:\n+<hfoptions id=\"usage\">\n+<hfoption id=\"Pipeline\">\n \n ```python\n import torch\n-from transformers import VitsTokenizer, VitsModel, set_seed\n+from transformers import pipeline, set_seed\n+from scipy.io.wavfile import write\n \n-tokenizer = VitsTokenizer.from_pretrained(\"facebook/mms-tts-eng\")\n-model = VitsModel.from_pretrained(\"facebook/mms-tts-eng\")\n+set_seed(555)\n \n-inputs = tokenizer(text=\"Hello - my dog is cute\", return_tensors=\"pt\")\n+pipe = pipeline(\n+    task=\"text-to-speech\",\n+    model=\"facebook/mms-tts-eng\",\n+    torch_dtype=torch.float16,\n+    device=0\n+)\n \n-set_seed(555)  # make deterministic\n+speech = pipe(\"Hello, my dog is cute\")\n \n-with torch.no_grad():\n-   outputs = model(**inputs)\n+# Extract audio data and sampling rate\n+audio_data = speech[\"audio\"]\n+sampling_rate = speech[\"sampling_rate\"]\n \n-waveform = outputs.waveform[0]\n+# Save as WAV file\n+write(\"hello.wav\", sampling_rate, audio_data.squeeze())\n ```\n \n-The resulting waveform can be saved as a `.wav` file:\n+</hfoption>\n+<hfoption id=\"AutoModel\">\n \n ```python\n+import torch\n import scipy\n+from IPython.display import Audio\n+from transformers import AutoTokenizer, VitsModel, set_seed\n \n-scipy.io.wavfile.write(\"techno.wav\", rate=model.config.sampling_rate, data=waveform)\n-```\n+tokenizer = AutoTokenizer.from_pretrained(\"facebook/mms-tts-eng\")\n+model = VitsModel.from_pretrained(\"facebook/mms-tts-eng\", torch_dtype=torch.float16).to(\"cuda\")\n+inputs = tokenizer(\"Hello, my dog is cute\", return_tensors=\"pt\").to(\"cuda\")\n \n-Or displayed in a Jupyter Notebook / Google Colab:\n+set_seed(555)\n \n-```python\n-from IPython.display import Audio\n+with torch.no_grad():\n+    outputs = model(**inputs)\n+\n+waveform = outputs.waveform[0]\n+scipy.io.wavfile.write(\"hello.wav\", rate=model.config.sampling_rate, data=waveform)\n \n+# display in Colab notebook\n Audio(waveform, rate=model.config.sampling_rate)\n ```\n \n-For certain languages with a non-Roman alphabet, such as Arabic, Mandarin or Hindi, the [`uroman`](https://github.com/isi-nlp/uroman) \n-perl package is required to pre-process the text inputs to the Roman alphabet.\n+</hfoption>\n+</hfoptions>\n \n-You can check whether you require the `uroman` package for your language by inspecting the `is_uroman` attribute of \n-the pre-trained `tokenizer`:\n+## Notes\n \n-```python\n-from transformers import VitsTokenizer\n+- Set a seed for reproducibility because VITS synthesizes speech non-deterministically.\n+- For languages with non-Roman alphabets (Korean, Arabic, etc.), install the [uroman](https://github.com/isi-nlp/uroman) package to preprocess the text inputs to the Roman alphabet. You can check if the tokenizer requires uroman as shown below.\n \n-tokenizer = VitsTokenizer.from_pretrained(\"facebook/mms-tts-eng\")\n-print(tokenizer.is_uroman)\n-```\n-If the is_uroman attribute is `True`, the tokenizer will automatically apply the `uroman` package to your text inputs, but you need to install uroman if not already installed using:  \n-```\n-pip install --upgrade uroman\n-```\n-Note: Python version required to use `uroman` as python package should be >= `3.10`. \n-You can use the tokenizer as usual without any additional preprocessing steps:\n-```python\n-import torch\n-from transformers import VitsTokenizer, VitsModel, set_seed\n-import os\n-import subprocess\n-\n-tokenizer = VitsTokenizer.from_pretrained(\"facebook/mms-tts-kor\")\n-model = VitsModel.from_pretrained(\"facebook/mms-tts-kor\")\n-text = \"이봐 무슨 일이야\"\n-inputs = tokenizer(text=text, return_tensors=\"pt\")\n-\n-set_seed(555)  # make deterministic\n-with torch.no_grad():\n-   outputs = model(inputs[\"input_ids\"])\n+   ```py\n+   # pip install -U uroman\n+   from transformers import VitsTokenizer\n \n-waveform = outputs.waveform[0]\n-```\n-If you don't want to upgrade to python >= `3.10`, then you can use the `uroman` perl package to pre-process the text inputs to the Roman alphabet.\n-To do this, first clone the uroman repository to your local machine and set the bash variable `UROMAN` to the local path:\n+   tokenizer = VitsTokenizer.from_pretrained(\"facebook/mms-tts-eng\")\n+   print(tokenizer.is_uroman)\n+   ```\n \n+   If your language requires uroman, the tokenizer automatically applies it to the text inputs. Python >= 3.10 doesn't require any additional preprocessing steps. For Python < 3.10, follow the steps below.\n \n-```bash\n-git clone https://github.com/isi-nlp/uroman.git\n-cd uroman\n-export UROMAN=$(pwd)\n-```\n+   ```bash\n+   git clone https://github.com/isi-nlp/uroman.git\n+   cd uroman\n+   export UROMAN=$(pwd)\n+   ```\n \n-You can then pre-process the text input using the following code snippet. You can either rely on using the bash variable \n-`UROMAN` to point to the uroman repository, or you can pass the uroman directory as an argument to the `uromanize` function:\n+   Create a function to preprocess the inputs. You can either use the bash variable `UROMAN` or pass the directory path directly to the function.\n \n-```python\n-import torch\n-from transformers import VitsTokenizer, VitsModel, set_seed\n-import os\n-import subprocess\n+   ```py\n+   import torch\n+   from transformers import VitsTokenizer, VitsModel, set_seed\n+   import os\n+   import subprocess\n \n-tokenizer = VitsTokenizer.from_pretrained(\"facebook/mms-tts-kor\")\n-model = VitsModel.from_pretrained(\"facebook/mms-tts-kor\")\n+   tokenizer = VitsTokenizer.from_pretrained(\"facebook/mms-tts-kor\")\n+   model = VitsModel.from_pretrained(\"facebook/mms-tts-kor\")\n \n-def uromanize(input_string, uroman_path):\n-    \"\"\"Convert non-Roman strings to Roman using the `uroman` perl package.\"\"\"\n-    script_path = os.path.join(uroman_path, \"bin\", \"uroman.pl\")\n+   def uromanize(input_string, uroman_path):\n+       \"\"\"Convert non-Roman strings to Roman using the `uroman` perl package.\"\"\"\n+       script_path = os.path.join(uroman_path, \"bin\", \"uroman.pl\")\n \n-    command = [\"perl\", script_path]\n+       command = [\"perl\", script_path]\n \n-    process = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n-    # Execute the perl command\n-    stdout, stderr = process.communicate(input=input_string.encode())\n+       process = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+       # Execute the perl command\n+       stdout, stderr = process.communicate(input=input_string.encode())\n \n-    if process.returncode != 0:\n-        raise ValueError(f\"Error {process.returncode}: {stderr.decode()}\")\n+       if process.returncode != 0:\n+           raise ValueError(f\"Error {process.returncode}: {stderr.decode()}\")\n \n-    # Return the output as a string and skip the new-line character at the end\n-    return stdout.decode()[:-1]\n+       # Return the output as a string and skip the new-line character at the end\n+       return stdout.decode()[:-1]\n \n-text = \"이봐 무슨 일이야\"\n-uromanized_text = uromanize(text, uroman_path=os.environ[\"UROMAN\"])\n+   text = \"이봐 무슨 일이야\"\n+   uromanized_text = uromanize(text, uroman_path=os.environ[\"UROMAN\"])\n \n-inputs = tokenizer(text=uromanized_text, return_tensors=\"pt\")\n+   inputs = tokenizer(text=uromanized_text, return_tensors=\"pt\")\n \n-set_seed(555)  # make deterministic\n-with torch.no_grad():\n-   outputs = model(inputs[\"input_ids\"])\n+   set_seed(555)  # make deterministic\n+   with torch.no_grad():\n+      outputs = model(inputs[\"input_ids\"])\n \n-waveform = outputs.waveform[0]\n-```\n+   waveform = outputs.waveform[0]\n+   ```\n \n ## VitsConfig\n \n@@ -177,10 +148,11 @@ waveform = outputs.waveform[0]\n ## VitsTokenizer\n \n [[autodoc]] VitsTokenizer\n-    - __call__\n-    - save_vocabulary\n+- __call__\n+- save_vocabulary\n \n ## VitsModel\n \n [[autodoc]] VitsModel\n-    - forward\n+- forward\n+"
        }
    ],
    "stats": {
        "total": 210,
        "additions": 91,
        "deletions": 119
    }
}