{
    "author": "sbucaille",
    "message": "docs: update LightGlue docs (#39407)\n\n* docs: update LightGlue docs\n\n* Apply suggestions from code review\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n---------\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>",
    "sha": "1bc9ac5107ff32c0115bd0b269924455be79db64",
    "files": [
        {
            "sha": "821d435cf4efaba1b6c46301e8358bb75fd49e8b",
            "filename": "docs/source/en/model_doc/lightglue.md",
            "status": "modified",
            "additions": 81,
            "deletions": 43,
            "changes": 124,
            "blob_url": "https://github.com/huggingface/transformers/blob/1bc9ac5107ff32c0115bd0b269924455be79db64/docs%2Fsource%2Fen%2Fmodel_doc%2Flightglue.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1bc9ac5107ff32c0115bd0b269924455be79db64/docs%2Fsource%2Fen%2Fmodel_doc%2Flightglue.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Flightglue.md?ref=1bc9ac5107ff32c0115bd0b269924455be79db64",
            "patch": "@@ -10,37 +10,31 @@ specific language governing permissions and limitations under the License.\n ⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n rendered properly in your Markdown viewer.\n \n-\n -->\n \n-# LightGlue\n+<div style=\"float: right;\">\n+    <div class=\"flex flex-wrap space-x-1\">\n+        <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\" >\n+    </div>\n+</div>\n \n-## Overview\n+# LightGlue\n \n-The LightGlue model was proposed in [LightGlue: Local Feature Matching at Light Speed](https://arxiv.org/abs/2306.13643)\n-by Philipp Lindenberger, Paul-Edouard Sarlin and Marc Pollefeys.\n+[LightGlue](https://arxiv.org/abs/2306.13643) is a deep neural network that learns to match local features across images. It revisits multiple design decisions of SuperGlue and derives simple but effective improvements. Cumulatively, these improvements make LightGlue more efficient - in terms of both memory and computation, more accurate, and much easier to train. Similar to [SuperGlue](https://huggingface.co/magic-leap-community/superglue_outdoor), this model consists of matching two sets of local features extracted from two images, with the goal of being faster than SuperGlue. Paired with the [SuperPoint model](https://huggingface.co/magic-leap-community/superpoint), it can be used to match two images and estimate the pose between them.\n \n-Similar to [SuperGlue](https://huggingface.co/magic-leap-community/superglue_outdoor), this model consists of matching\n-two sets of local features extracted from two images, its goal is to be faster than SuperGlue. Paired with the \n-[SuperPoint model](https://huggingface.co/magic-leap-community/superpoint), it can be used to match two images and \n-estimate the pose between them. This model is useful for tasks such as image matching, homography estimation, etc.\n+You can find all the original LightGlue checkpoints under the [ETH-CVG](https://huggingface.co/ETH-CVG) organization.\n \n-The abstract from the paper is the following:\n+> [!TIP]\n+> This model was contributed by [stevenbucaille](https://huggingface.co/stevenbucaille).\n+>\n+> Click on the LightGlue models in the right sidebar for more examples of how to apply LightGlue to different computer vision tasks.\n \n-*We introduce LightGlue, a deep neural network that learns to match local features across images. We revisit multiple\n-design decisions of SuperGlue, the state of the art in sparse matching, and derive simple but effective improvements. \n-Cumulatively, they make LightGlue more efficient - in terms of both memory and computation, more accurate, and much\n-easier to train. One key property is that LightGlue is adaptive to the difficulty of the problem: the inference is much\n-faster on image pairs that are intuitively easy to match, for example because of a larger visual overlap or limited\n-appearance change. This opens up exciting prospects for deploying deep matchers in latency-sensitive applications like\n-3D reconstruction. The code and trained models are publicly available at this [https URL](https://github.com/cvg/LightGlue)*\n+The example below demonstrates how to match keypoints between two images with the [`AutoModel`] class.\n \n-## How to use\n+<hfoptions id=\"usage\">\n+<hfoption id=\"AutoModel\">\n \n-Here is a quick example of using the model. Since this model is an image matching model, it requires pairs of images to be matched. \n-The raw outputs contain the list of keypoints detected by the keypoint detector as well as the list of matches with their corresponding \n-matching scores.\n-```python\n+```py\n from transformers import AutoImageProcessor, AutoModel\n import torch\n from PIL import Image\n@@ -59,31 +53,70 @@ model = AutoModel.from_pretrained(\"ETH-CVG/lightglue_superpoint\")\n inputs = processor(images, return_tensors=\"pt\")\n with torch.no_grad():\n     outputs = model(**inputs)\n-```\n \n-You can use the `post_process_keypoint_matching` method from the `LightGlueImageProcessor` to get the keypoints and matches in a readable format:\n-```python\n+# Post-process to get keypoints and matches\n image_sizes = [[(image.height, image.width) for image in images]]\n-outputs = processor.post_process_keypoint_matching(outputs, image_sizes, threshold=0.2)\n-for i, output in enumerate(outputs):\n-    print(\"For the image pair\", i)\n-    for keypoint0, keypoint1, matching_score in zip(\n-            output[\"keypoints0\"], output[\"keypoints1\"], output[\"matching_scores\"]\n-    ):\n-        print(\n-            f\"Keypoint at coordinate {keypoint0.numpy()} in the first image matches with keypoint at coordinate {keypoint1.numpy()} in the second image with a score of {matching_score}.\"\n-        )\n+processed_outputs = processor.post_process_keypoint_matching(outputs, image_sizes, threshold=0.2)\n ```\n \n-You can visualize the matches between the images by providing the original images as well as the outputs to this method:\n-```python\n-processor.plot_keypoint_matching(images, outputs)\n-```\n-\n-![image/png](https://cdn-uploads.huggingface.co/production/uploads/632885ba1558dac67c440aa8/duPp09ty8NRZlMZS18ccP.png)\n-\n-This model was contributed by [stevenbucaille](https://huggingface.co/stevenbucaille).\n-The original code can be found [here](https://github.com/cvg/LightGlue).\n+</hfoption>\n+</hfoptions>\n+\n+## Notes\n+\n+- LightGlue is adaptive to the task difficulty. Inference is much faster on image pairs that are intuitively easy to match, for example, because of a larger visual overlap or limited appearance change.\n+\n+    ```py\n+    from transformers import AutoImageProcessor, AutoModel\n+    import torch\n+    from PIL import Image\n+    import requests\n+    \n+    processor = AutoImageProcessor.from_pretrained(\"ETH-CVG/lightglue_superpoint\")\n+    model = AutoModel.from_pretrained(\"ETH-CVG/lightglue_superpoint\")\n+    \n+    # LightGlue requires pairs of images\n+    images = [image1, image2]\n+    inputs = processor(images, return_tensors=\"pt\")\n+    outputs = model(**inputs)\n+    \n+    # Extract matching information\n+    keypoints0 = outputs.keypoints0  # Keypoints in first image\n+    keypoints1 = outputs.keypoints1  # Keypoints in second image\n+    matches = outputs.matches        # Matching indices\n+    matching_scores = outputs.matching_scores  # Confidence scores\n+    ```\n+\n+- The model outputs matching indices, keypoints, and confidence scores for each match, similar to SuperGlue but with improved efficiency.\n+- For better visualization and analysis, use the [`LightGlueImageProcessor.post_process_keypoint_matching`] method to get matches in a more readable format.\n+\n+    ```py\n+    # Process outputs for visualization\n+    image_sizes = [[(image.height, image.width) for image in images]]\n+    processed_outputs = processor.post_process_keypoint_matching(outputs, image_sizes, threshold=0.2)\n+    \n+    for i, output in enumerate(processed_outputs):\n+        print(f\"For the image pair {i}\")\n+        for keypoint0, keypoint1, matching_score in zip(\n+                output[\"keypoints0\"], output[\"keypoints1\"], output[\"matching_scores\"]\n+        ):\n+            print(f\"Keypoint at {keypoint0.numpy()} matches with keypoint at {keypoint1.numpy()} with score {matching_score}\")\n+    ```\n+\n+- Visualize the matches between the images using the built-in plotting functionality.\n+\n+    ```py\n+    # Easy visualization using the built-in plotting method\n+    processor.plot_keypoint_matching(images, processed_outputs)\n+    ```\n+\n+<div class=\"flex justify-center\">\n+    <img src=\"https://cdn-uploads.huggingface.co/production/uploads/632885ba1558dac67c440aa8/duPp09ty8NRZlMZS18ccP.png\">\n+</div>\n+\n+## Resources\n+\n+- Refer to the [original LightGlue repository](https://github.com/cvg/LightGlue) for more examples and implementation details.\n \n ## LightGlueConfig\n \n@@ -97,8 +130,13 @@ The original code can be found [here](https://github.com/cvg/LightGlue).\n - post_process_keypoint_matching\n - plot_keypoint_matching\n \n+<frameworkcontent>\n+<pt>\n ## LightGlueForKeypointMatching\n \n [[autodoc]] LightGlueForKeypointMatching\n \n - forward\n+\n+</pt>\n+</frameworkcontent>"
        }
    ],
    "stats": {
        "total": 124,
        "additions": 81,
        "deletions": 43
    }
}