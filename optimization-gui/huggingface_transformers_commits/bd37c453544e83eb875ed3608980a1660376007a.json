{
    "author": "yonigozlan",
    "message": "Add EdgeTAM (#39800)\n\n* initial comment\n\n* test\n\n* initial conversion for outline\n\n* intermediate commit for configuration\n\n* chore:init files for sam2\n\n* adding arbitary undefined config\n\n* check\n\n* add vision\n\n* make style\n\n* init sam2 base model\n\n* Fix imports\n\n* Linting\n\n* chore:sam to sam2 classes\n\n* Linting\n\n* Add sam2 to models.__init__\n\n* chore:match prompt encoder with sam2 code\n\n* chore:prepare kwargs for mask decoder\n\n* Add image/video predictors\n\n* Add CUDA kernel\n\n* Add output classes\n\n* linting\n\n* Add logging info\n\n* tmp commit\n\n* docs for sam2\n\n* enable image processing\n\n* check difference of original SAM2\n- difference is the order of ToTensor()\n- please see https://pytorch.org/vision/main/_modules/torchvision/transforms/functional.html#resize\n\n* enable promptencoder of sam2\n\n* fix promprencoder\n\n* Confirmed that PromptEncoder is exactly same (Be aware of bfloat16 and float32 difference)\n\n* Confirmed that ImageEncoder is exactly same (Be aware the linting of init)\n\n* Confirmed that MaskDecoder is exactly same (TO DO: lint variable name)\n\n* SamModel is now available (Need more chore for name)\n\n* make fix-copies\n\n* make style\n\n* make CI happy\n\n* Refactor VisionEncoder and PostioinEmbedding\n\n* TO DO : fix the image_embeddings and sparse_embeddings part\n\n* pure image inference done\n\n* reusable features fix and make style\n\n* styling\n\n* refactor memoryattention\n\n* tmp\n\n* tmp\n\n* refactor memoryencoder\nTO DO : convert and inference the video pipeline\n\n* TO DO : fix the image_encoder shape\n\n* conversion finish\nTO DO: need to check video inference\n\n* make style\n\n* remove video model\n\n* lint\n\n* change\n\n* python utils/check_docstringspy --check_all\n\n* python utils/check_config_attributes.py\n\n* remove copies for sam2promptencoder due to configuration\n\n* change __init__.py\n\n* remove tensorflow version\n\n* fix that to not use direct comparison\n\n* make style\n\n* add missing import\n\n* fix image_embedding_size\n\n* refactor Sam2 Attention\n\n* add fully working video inference (refactoring todo)\n\n* clarify _prepare_memory_conditioned_features\n\n* simplify modeling code, remove unused paths\n\n* use one model\n\n* use auto_docstring\n\n* refactor rope embeddings\n\n* nit\n\n* not using multimask when several points given\n\n* add all sam2.1\n\n* add video tmp\n\n* add Sam2VideoSessionState + fast image proc + video proc\n\n* remove init_states from model\n\n* fix batch inference\n\n* add image integration tests\n\n* uniformize modeling code with other sam models and use modular\n\n* pass vision tests an most model tests\n\n* All tests passing\n\n* add offloading inference state and video to cpu\n\n* fix inference from image embedding and existing mask\n\n* fix multi_boxes mask inference\n\n* Fix batch images + batch boxes inference\n\n* improve processing for image inference\n\n* add support for mask generation pipeline\n\n* add support for get_connected_components post processing in mask generation\n\n* add fast image processor sam, image processor tests and use modular for sam2 image processor\n\n* fix mistake in sam after #39120\n\n* fix init weights\n\n* refactor convert\n\n* add integration tests for video + other improvements\n\n* add needed missing docstrings\n\n* Improve docstrings and\n\n* improve inference speed by avoiding cuda sync\n\n* add test\n\n* skip test for vision_model\n\n* minor fix for vision_model\n\n* fix vision_model by adding sam2model and change the torch dependencies\n\n* remove patch_size\n\n* remove image_embedding_size\n\n* fix patch_size\n\n* fix test\n\n* make style\n\n* Separate hieradet and vision encoder in sam2\n\n* fixup\n\n* review changes part 1\n\n* remove MemoryEncoderConfig and MemoryAttentionConfig\n\n* pass q_stride instead of q_pool module\n\n* add inference on streamed videos\n\n* explicitely process streamed frames\n\n* nit\n\n* Improve docstrings in Sam2Model\n\n* update sam2 modeling with better gestion of inference state and cache, and separate Sam2Model and Sam2VideoModel\n\n* improve video inference api\n\n* change inference_state to inference_session\n\n* use modular for Sam2Model\n\n* fix convert sam2 hf\n\n* modular\n\n* Update src/transformers/models/sam2/video_processing_sam2.py\n\nCo-authored-by: Pavel Iakubovskii <qubvel@gmail.com>\n\n* fix minor config\n\n* fix attention loading error\n\n* update modeling tests to use hub checkpoints\n\n* Use CI A10 runner for integration tests values + higher tolerance for video integration tests\n\n* PR review part 1\n\n* fix doc\n\n* nit improvements\n\n* enforce one input format for points, labels and boxes\n\n* nit\n\n* last few nits from PR review\n\n* fix style\n\n* fix the input type\n\n* fix docs\n\n* add sam2 model as conversion script\n\n* improve sam2 doc\n\n* add rough necessarry changes\n\n* first working edgetam\n\n* fix issue with object pointers\n\n* Use modular as much as possible\n\n* nit fixes + optimization\n\n* refactor spatial perceiver\n\n* cleanup after merge\n\n* add working edgetam\n\n* improve perceiver resampler code\n\n* simplify/unify rope attention logic\n\n* Improve comments in apply_rotary_pos_emb_2d\n\n* add working tests\n\n* fix test timmwrapper\n\n* add docs\n\n* make fixup\n\n* nits\n\n* fix modular\n\n* fix modular\n\n* PR review part 1\n\n* split apply_rotary_pos_emb_2d\n\n* add granularity to _prepare_memory_conditioned_features\n\n* add dates to doc\n\n* add separate mlp for memory attention\n\n* Fix memory on wrong device\n\n* store processed frames in dict\n\n* update checkpoints in tests\n\n* update dates\n\n---------\n\nCo-authored-by: sangbumchoi <danielsejong55@gmail.com>\nCo-authored-by: RUFFY-369 <prakarshkaushik369@gmail.com>\nCo-authored-by: Sangbum Daniel Choi <34004152+SangbumChoi@users.noreply.github.com>\nCo-authored-by: Haitham Khedr <haithamkhedr@meta.com>\nCo-authored-by: sangbum choi <sangbumchoi@sangbumui-MacBookAir.local>\nCo-authored-by: Pavel Iakubovskii <qubvel@gmail.com>",
    "sha": "bd37c453544e83eb875ed3608980a1660376007a",
    "files": [
        {
            "sha": "2bc2222dd24b16dbfbade00f2b818e8e5daacc29",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -1033,6 +1033,10 @@\n         title: DePlot\n       - local: model_doc/donut\n         title: Donut\n+      - local: model_doc/edgetam\n+        title: EdgeTAM\n+      - local: model_doc/edgetam_video\n+        title: EdgeTamVideo\n       - local: model_doc/emu3\n         title: Emu3\n       - local: model_doc/evolla"
        },
        {
            "sha": "780ccb3f70b3be54454377876aa5bd60cff33662",
            "filename": "docs/source/en/model_doc/edgetam.md",
            "status": "added",
            "additions": 331,
            "deletions": 0,
            "changes": 331,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/docs%2Fsource%2Fen%2Fmodel_doc%2Fedgetam.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/docs%2Fsource%2Fen%2Fmodel_doc%2Fedgetam.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fedgetam.md?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,331 @@\n+<!--Copyright 2025 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+*This model was released on 2025-01-13 and added to Hugging Face Transformers on 2025-09-29.*\n+<div style=\"float: right;\">\n+    <div class=\"flex flex-wrap space-x-1\">\n+        <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+        <img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+        <img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+    </div>\n+</div>\n+\n+# EdgeTAM\n+\n+## Overview\n+\n+The EdgeTAM model was proposed in [EdgeTAM: On-Device Track Anything Model](https://huggingface.co/papers/2501.07256) Chong Zhou, Chenchen Zhu, Yunyang Xiong, Saksham Suri, Fanyi Xiao, Lemeng Wu, Raghuraman Krishnamoorthi, Bo Dai, Chen Change Loy, Vikas Chandra, Bilge Soran.\n+\n+EdgeTAM is an efficient adaptation of SAM 2 that introduces a 2D Spatial Perceiver architecture to optimize memory attention mechanisms for real-time video segmentation on mobile devices.\n+\n+The abstract from the paper is the following:\n+\n+*On top of Segment Anything Model (SAM), SAM 2 further extends its capability from image to video inputs through a memory bank mechanism and obtains a remarkable performance compared with previous methods, making it a foundation model for video segmentation task. In this paper, we aim at making SAM 2 much more efficient so that it even runs on mobile devices while maintaining a comparable performance. Despite several works optimizing SAM for better efficiency, we find they are not sufficient for SAM 2 because they all focus on compressing the image encoder, while our benchmark shows that the newly introduced memory attention blocks are also the latency bottleneck. Given this observation, we propose EdgeTAM, which leverages a novel 2D Spatial Perceiver to reduce the computational cost. In particular, the proposed 2D Spatial Perceiver encodes the densely stored frame-level memories with a lightweight Transformer that contains a fixed set of learnable queries. Given that video segmentation is a dense prediction task, we find preserving the spatial structure of the memories is essential so that the queries are split into global-level and patch-level groups. We also propose a distillation pipeline that further improves the performance without inference overhead. As a result, EdgeTAM achieves 87.7, 70.0, 72.3, and 71.7 J&F on DAVIS 2017, MOSE, SA-V val, and SA-V test, while running at 16 FPS on iPhone 15 Pro Max.*\n+\n+This model was contributed by [yonigozlan](https://huggingface.co/yonigozlan).\n+The original code can be found [here](https://github.com/facebookresearch/EdgeTAM).\n+\n+## Usage example\n+\n+### Automatic Mask Generation with Pipeline\n+\n+EdgeTAM can be used for automatic mask generation to segment all objects in an image using the `mask-generation` pipeline:\n+\n+```python\n+>>> from transformers import pipeline\n+\n+>>> generator = pipeline(\"mask-generation\", model=\"yonigozlan/edgetam-1\", device=0)\n+>>> image_url = \"https://huggingface.co/datasets/hf-internal-testing/sam2-fixtures/resolve/main/truck.jpg\"\n+>>> outputs = generator(image_url, points_per_batch=64)\n+\n+>>> len(outputs[\"masks\"])  # Number of masks generated\n+39\n+```\n+\n+### Basic Image Segmentation\n+\n+#### Single Point Click\n+\n+You can segment objects by providing a single point click on the object you want to segment:\n+\n+```python\n+>>> from transformers import Sam2Processor, EdgeTamModel, infer_device\n+>>> import torch\n+>>> from PIL import Image\n+>>> import requests\n+\n+>>> device = infer_device()\n+\n+>>> model = EdgeTamModel.from_pretrained(\"yonigozlan/edgetam-1\").to(device)\n+>>> processor = Sam2Processor.from_pretrained(\"yonigozlan/edgetam-1\")\n+\n+>>> image_url = \"https://huggingface.co/datasets/hf-internal-testing/sam2-fixtures/resolve/main/truck.jpg\"\n+>>> raw_image = Image.open(requests.get(image_url, stream=True).raw).convert(\"RGB\")\n+\n+>>> input_points = [[[[500, 375]]]]  # Single point click, 4 dimensions (image_dim, object_dim, point_per_object_dim, coordinates)\n+>>> input_labels = [[[1]]]  # 1 for positive click, 0 for negative click, 3 dimensions (image_dim, object_dim, point_label)\n+\n+>>> inputs = processor(images=raw_image, input_points=input_points, input_labels=input_labels, return_tensors=\"pt\").to(model.device)\n+\n+>>> with torch.no_grad():\n+...     outputs = model(**inputs)\n+\n+>>> masks = processor.post_process_masks(outputs.pred_masks.cpu(), inputs[\"original_sizes\"])[0]\n+\n+>>> # The model outputs multiple mask predictions ranked by quality score\n+>>> print(f\"Generated {masks.shape[1]} masks with shape {masks.shape}\")\n+Generated 3 masks with shape torch.Size([1, 3, 1200, 1800])\n+>>> print(f\"IoU scores: {outputs.iou_scores.squeeze()}\")\n+IoU scores: tensor([0.0463, 0.4859, 0.7616], device='cuda:0')\n+```\n+\n+#### Multiple Points for Refinement\n+\n+You can provide multiple points to refine the segmentation:\n+\n+```python\n+>>> # Add both positive and negative points to refine the mask\n+>>> input_points = [[[[500, 375], [1125, 625]]]]  # Multiple points for refinement\n+>>> input_labels = [[[1, 1]]]  # Both positive clicks\n+\n+>>> inputs = processor(images=raw_image, input_points=input_points, input_labels=input_labels, return_tensors=\"pt\").to(device)\n+\n+>>> with torch.no_grad():\n+...     outputs = model(**inputs)\n+\n+>>> masks = processor.post_process_masks(outputs.pred_masks.cpu(), inputs[\"original_sizes\"])[0]\n+>>> print(f\"IoU scores: {outputs.iou_scores.squeeze()}\")\n+IoU scores: tensor([0.8362, 0.6900, 0.2120], device='cuda:0')\n+```\n+\n+#### Bounding Box Input\n+\n+EdgeTAM also supports bounding box inputs for segmentation:\n+\n+```python\n+>>> # Define bounding box as [x_min, y_min, x_max, y_max]\n+>>> input_boxes = [[[75, 275, 1725, 850]]]\n+\n+>>> inputs = processor(images=raw_image, input_boxes=input_boxes, return_tensors=\"pt\").to(device)\n+\n+>>> with torch.no_grad():\n+...     outputs = model(**inputs)\n+\n+>>> masks = processor.post_process_masks(outputs.pred_masks.cpu(), inputs[\"original_sizes\"])[0]\n+>>> print(f\"IoU scores: {outputs.iou_scores.squeeze()}\")\n+IoU scores: tensor([0.9301, 0.9348, 0.6605], device='cuda:0')\n+```\n+\n+#### Multiple Objects Segmentation\n+\n+You can segment multiple objects simultaneously:\n+\n+```python\n+>>> # Define points for two different objects\n+>>> input_points = [[[[500, 375]], [[650, 750]]]]  # Points for two objects in same image\n+>>> input_labels = [[[1], [1]]]  # Positive clicks for both objects\n+\n+>>> inputs = processor(images=raw_image, input_points=input_points, input_labels=input_labels, return_tensors=\"pt\").to(device)\n+\n+>>> with torch.no_grad():\n+...     outputs = model(**inputs, multimask_output=False)\n+\n+>>> # Each object gets its own mask\n+>>> masks = processor.post_process_masks(outputs.pred_masks.cpu(), inputs[\"original_sizes\"])[0]\n+>>> print(f\"Generated masks for {masks.shape[0]} objects\")\n+Generated masks for 2 objects\n+>>> print(f\"IoU scores: {outputs.iou_scores.squeeze()}\")\n+IoU scores: tensor([0.7616, 0.9465], device='cuda:0')\n+```\n+\n+### Batch Inference\n+\n+#### Batched Images\n+\n+Process multiple images simultaneously for improved efficiency:\n+\n+```python\n+>>> from transformers import Sam2Processor, EdgeTamModel, infer_device\n+>>> import torch\n+>>> from PIL import Image\n+>>> import requests\n+\n+>>> device = infer_device()\n+\n+>>> model = EdgeTamModel.from_pretrained(\"yonigozlan/edgetam-1\").to(device)\n+>>> processor = Sam2Processor.from_pretrained(\"yonigozlan/edgetam-1\")\n+\n+>>> # Load multiple images\n+>>> image_urls = [\n+...     \"https://huggingface.co/datasets/hf-internal-testing/sam2-fixtures/resolve/main/truck.jpg\",\n+...     \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/model_doc/dog-sam.png\"\n+... ]\n+>>> raw_images = [Image.open(requests.get(url, stream=True).raw).convert(\"RGB\") for url in image_urls]\n+\n+>>> # Single point per image\n+>>> input_points = [[[[500, 375]]], [[[770, 200]]]]  # One point for each image\n+>>> input_labels = [[[1]], [[1]]]  # Positive clicks for both images\n+\n+>>> inputs = processor(images=raw_images, input_points=input_points, input_labels=input_labels, return_tensors=\"pt\").to(model.device)\n+\n+>>> with torch.no_grad():\n+...     outputs = model(**inputs, multimask_output=False)\n+\n+>>> # Post-process masks for each image\n+>>> all_masks = processor.post_process_masks(outputs.pred_masks.cpu(), inputs[\"original_sizes\"])\n+>>> print(f\"Processed {len(all_masks)} images, each with {all_masks[0].shape[0]} objects\")\n+Processed 2 images, each with 1 objects\n+>>> print(f\"IoU scores: {outputs.iou_scores.squeeze()}\")\n+IoU scores: tensor([0.7618, 0.7999], device='cuda:0')\n+```\n+\n+#### Batched Objects per Image\n+\n+Segment multiple objects within each image using batch inference:\n+\n+```python\n+>>> # Multiple objects per image - different numbers of objects per image\n+>>> input_points = [\n+...     [[[500, 375]], [[650, 750]]],  # Truck image: 2 objects\n+...     [[[770, 200]]]  # Dog image: 1 object\n+... ]\n+>>> input_labels = [\n+...     [[1], [1]],  # Truck image: positive clicks for both objects\n+...     [[1]]  # Dog image: positive click for the object\n+... ]\n+\n+>>> inputs = processor(images=raw_images, input_points=input_points, input_labels=input_labels, return_tensors=\"pt\").to(device)\n+\n+>>> with torch.no_grad():\n+...     outputs = model(**inputs, multimask_output=False)\n+\n+>>> all_masks = processor.post_process_masks(outputs.pred_masks.cpu(), inputs[\"original_sizes\"])\n+```\n+\n+#### Batched Images with Batched Objects and Multiple Points\n+\n+Handle complex batch scenarios with multiple points per object:\n+\n+```python\n+>>> # Add groceries image for more complex example\n+>>> groceries_url = \"https://huggingface.co/datasets/hf-internal-testing/sam2-fixtures/resolve/main/groceries.jpg\"\n+>>> groceries_image = Image.open(requests.get(groceries_url, stream=True).raw).convert(\"RGB\")\n+>>> raw_images = [raw_images[0], groceries_image]  # Use truck and groceries images\n+\n+>>> # Complex batching: multiple images, multiple objects, multiple points per object\n+>>> input_points = [\n+...     [[[500, 375]], [[650, 750]]],  # Truck image: 2 objects with 1 point each\n+...     [[[400, 300]], [[630, 300], [550, 300]]]  # Groceries image: obj1 has 1 point, obj2 has 2 points\n+... ]\n+>>> input_labels = [\n+...     [[1], [1]],  # Truck image: positive clicks\n+...     [[1], [1, 1]]  # Groceries image: positive clicks for refinement\n+... ]\n+\n+>>> inputs = processor(images=raw_images, input_points=input_points, input_labels=input_labels, return_tensors=\"pt\").to(device)\n+\n+>>> with torch.no_grad():\n+...     outputs = model(**inputs, multimask_output=False)\n+\n+>>> all_masks = processor.post_process_masks(outputs.pred_masks.cpu(), inputs[\"original_sizes\"])\n+```\n+\n+#### Batched Bounding Boxes\n+\n+Process multiple images with bounding box inputs:\n+\n+```python\n+>>> # Multiple bounding boxes per image (using truck and groceries images)\n+>>> input_boxes = [\n+...     [[75, 275, 1725, 850], [425, 600, 700, 875], [1375, 550, 1650, 800], [1240, 675, 1400, 750]],  # Truck image: 4 boxes\n+...     [[450, 170, 520, 350], [350, 190, 450, 350], [500, 170, 580, 350], [580, 170, 640, 350]]  # Groceries image: 4 boxes\n+... ]\n+\n+>>> # Update images for this example\n+>>> raw_images = [raw_images[0], groceries_image]  # truck and groceries\n+\n+>>> inputs = processor(images=raw_images, input_boxes=input_boxes, return_tensors=\"pt\").to(device)\n+\n+>>> with torch.no_grad():\n+...     outputs = model(**inputs, multimask_output=False)\n+\n+>>> all_masks = processor.post_process_masks(outputs.pred_masks.cpu(), inputs[\"original_sizes\"])\n+>>> print(f\"Processed {len(input_boxes)} images with {len(input_boxes[0])} and {len(input_boxes[1])} boxes respectively\")\n+Processed 2 images with 4 and 4 boxes respectively\n+>>> print(f\"IoU scores: {outputs.iou_scores.squeeze()}\")\n+IoU scores: tensor([0.9301, 0.9348, 0.6605, 0.9465], device='cuda:0')\n+```\n+\n+### Using Previous Masks as Input\n+\n+EdgeTAM can use masks from previous predictions as input to refine segmentation:\n+\n+```python\n+>>> # Get initial segmentation\n+>>> input_points = [[[[500, 375]]]]\n+>>> input_labels = [[[1]]]\n+>>> inputs = processor(images=raw_image, input_points=input_points, input_labels=input_labels, return_tensors=\"pt\").to(device)\n+\n+>>> with torch.no_grad():\n+...     outputs = model(**inputs)\n+\n+>>> # Use the best mask as input for refinement\n+>>> mask_input = outputs.pred_masks[:, :, torch.argmax(outputs.iou_scores.squeeze())]\n+\n+>>> # Add additional points with the mask input\n+>>> new_input_points = [[[[500, 375], [450, 300]]]]\n+>>> new_input_labels = [[[1, 1]]]\n+>>> inputs = processor(\n+...     input_points=new_input_points,\n+...     input_labels=new_input_labels,\n+...     original_sizes=inputs[\"original_sizes\"],\n+...     return_tensors=\"pt\",\n+... ).to(device)\n+\n+>>> with torch.no_grad():\n+...     refined_outputs = model(\n+...         **inputs,\n+...         input_masks=mask_input,\n+...         image_embeddings=outputs.image_embeddings,\n+...         multimask_output=False,\n+...     )\n+```\n+\n+\n+## EdgeTamConfig\n+\n+[[autodoc]] EdgeTamConfig\n+\n+## EdgeTamVisionConfig\n+\n+[[autodoc]] EdgeTamVisionConfig\n+\n+## EdgeTamMaskDecoderConfig\n+\n+[[autodoc]] EdgeTamMaskDecoderConfig\n+\n+## EdgeTamPromptEncoderConfig\n+\n+[[autodoc]] EdgeTamPromptEncoderConfig\n+\n+## EdgeTamVisionModel\n+\n+[[autodoc]] EdgeTamVisionModel\n+    - forward\n+\n+## EdgeTamModel\n+\n+[[autodoc]] EdgeTamModel\n+    - forward"
        },
        {
            "sha": "381bace4dbe032bd8267053bb3d4e194ce989cea",
            "filename": "docs/source/en/model_doc/edgetam_video.md",
            "status": "added",
            "additions": 297,
            "deletions": 0,
            "changes": 297,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/docs%2Fsource%2Fen%2Fmodel_doc%2Fedgetam_video.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/docs%2Fsource%2Fen%2Fmodel_doc%2Fedgetam_video.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fedgetam_video.md?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,297 @@\n+<!--Copyright 2025 the HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be rendered properly in your Markdown viewer.\n+\n+-->\n+*This model was released on 2025-01-13 and added to Hugging Face Transformers on 2025-09-29.*\n+\n+\n+<div style=\"float: right;\">\n+    <div class=\"flex flex-wrap space-x-1\">\n+        <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+        <img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+        <img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+    </div>\n+</div>\n+\n+# EdgeTAMVideo\n+\n+## Overview\n+\n+The EdgeTAM model was proposed in [EdgeTAM: On-Device Track Anything Model](https://huggingface.co/papers/2501.07256) Chong Zhou, Chenchen Zhu, Yunyang Xiong, Saksham Suri, Fanyi Xiao, Lemeng Wu, Raghuraman Krishnamoorthi, Bo Dai, Chen Change Loy, Vikas Chandra, Bilge Soran.\n+\n+EdgeTAM is an efficient adaptation of SAM 2 that introduces a 2D Spatial Perceiver architecture to optimize memory attention mechanisms for real-time video segmentation on mobile devices.\n+\n+The abstract from the paper is the following:\n+\n+*On top of Segment Anything Model (SAM), SAM 2 further extends its capability from image to video inputs through a memory bank mechanism and obtains a remarkable performance compared with previous methods, making it a foundation model for video segmentation task. In this paper, we aim at making SAM 2 much more efficient so that it even runs on mobile devices while maintaining a comparable performance. Despite several works optimizing SAM for better efficiency, we find they are not sufficient for SAM 2 because they all focus on compressing the image encoder, while our benchmark shows that the newly introduced memory attention blocks are also the latency bottleneck. Given this observation, we propose EdgeTAM, which leverages a novel 2D Spatial Perceiver to reduce the computational cost. In particular, the proposed 2D Spatial Perceiver encodes the densely stored frame-level memories with a lightweight Transformer that contains a fixed set of learnable queries. Given that video segmentation is a dense prediction task, we find preserving the spatial structure of the memories is essential so that the queries are split into global-level and patch-level groups. We also propose a distillation pipeline that further improves the performance without inference overhead. As a result, EdgeTAM achieves 87.7, 70.0, 72.3, and 71.7 J&F on DAVIS 2017, MOSE, SA-V val, and SA-V test, while running at 16 FPS on iPhone 15 Pro Max.*\n+\n+This model was contributed by [yonigozlan](https://huggingface.co/yonigozlan).\n+The original code can be found [here](https://github.com/facebookresearch/EdgeTAM).\n+\n+## Usage example\n+\n+### Video Segmentation and Tracking\n+\n+EdgeTAM Video's key strength is its ability to track objects across video frames efficiently on mobile devices. Here's how to use it for video segmentation:\n+\n+#### Basic Video Tracking\n+\n+```python\n+>>> from transformers import EdgeTamVideoModel, Sam2VideoProcessor, infer_device\n+>>> import torch\n+\n+>>> device = infer_device()\n+>>> model = EdgeTamVideoModel.from_pretrained(\"yonigozlan/edgetam-video-1\").to(device, dtype=torch.bfloat16)\n+>>> processor = Sam2VideoProcessor.from_pretrained(\"yonigozlan/edgetam-video-1\")\n+\n+>>> # Load video frames (example assumes you have a list of PIL Images)\n+>>> # video_frames = [Image.open(f\"frame_{i:05d}.jpg\") for i in range(num_frames)]\n+\n+>>> # For this example, we'll use the video loading utility\n+>>> from transformers.video_utils import load_video\n+>>> video_url = \"https://huggingface.co/datasets/hf-internal-testing/sam2-fixtures/resolve/main/bedroom.mp4\"\n+>>> video_frames, _ = load_video(video_url)\n+\n+>>> # Initialize video inference session\n+>>> inference_session = processor.init_video_session(\n+...     video=video_frames,\n+...     inference_device=device,\n+...     dtype=torch.bfloat16,\n+... )\n+\n+>>> # Add click on first frame to select object\n+>>> ann_frame_idx = 0\n+>>> ann_obj_id = 1\n+>>> points = [[[[210, 350]]]]\n+>>> labels = [[[1]]]\n+\n+>>> processor.add_inputs_to_inference_session(\n+...     inference_session=inference_session,\n+...     frame_idx=ann_frame_idx,\n+...     obj_ids=ann_obj_id,\n+...     input_points=points,\n+...     input_labels=labels,\n+... )\n+\n+>>> # Segment the object on the first frame\n+>>> outputs = model(\n+...     inference_session=inference_session,\n+...     frame_idx=ann_frame_idx,\n+... )\n+>>> video_res_masks = processor.post_process_masks(\n+...     [outputs.pred_masks], original_sizes=[[inference_session.video_height, inference_session.video_width]], binarize=False\n+... )[0]\n+>>> print(f\"Segmentation shape: {video_res_masks.shape}\")\n+Segmentation shape: torch.Size([1, 1, 540, 960])\n+\n+>>> # Propagate through the entire video\n+>>> video_segments = {}\n+>>> for sam2_video_output in model.propagate_in_video_iterator(inference_session):\n+...     video_res_masks = processor.post_process_masks(\n+...         [sam2_video_output.pred_masks], original_sizes=[[inference_session.video_height, inference_session.video_width]], binarize=False\n+...     )[0]\n+...     video_segments[sam2_video_output.frame_idx] = video_res_masks\n+\n+>>> print(f\"Tracked object through {len(video_segments)} frames\")\n+Tracked object through 200 frames\n+```\n+\n+#### Multi-Object Video Tracking\n+\n+Track multiple objects simultaneously across video frames:\n+\n+```python\n+>>> # Reset for new tracking session\n+>>> inference_session.reset_inference_session()\n+\n+>>> # Add multiple objects on the first frame\n+>>> ann_frame_idx = 0\n+>>> obj_ids = [2, 3]\n+>>> input_points = [[[[200, 300]], [[400, 150]]]]  # Points for two objects (batched)\n+>>> input_labels = [[[1], [1]]]\n+\n+>>> processor.add_inputs_to_inference_session(\n+...     inference_session=inference_session,\n+...     frame_idx=ann_frame_idx,\n+...     obj_ids=obj_ids,\n+...     input_points=input_points,\n+...     input_labels=input_labels,\n+... )\n+\n+>>> # Get masks for both objects on first frame\n+>>> outputs = model(\n+...     inference_session=inference_session,\n+...     frame_idx=ann_frame_idx,\n+... )\n+\n+>>> # Propagate both objects through video\n+>>> video_segments = {}\n+>>> for sam2_video_output in model.propagate_in_video_iterator(inference_session):\n+...     video_res_masks = processor.post_process_masks(\n+...         [sam2_video_output.pred_masks], original_sizes=[[inference_session.video_height, inference_session.video_width]], binarize=False\n+...     )[0]\n+...     video_segments[sam2_video_output.frame_idx] = {\n+...         obj_id: video_res_masks[i]\n+...         for i, obj_id in enumerate(inference_session.obj_ids)\n+...     }\n+\n+>>> print(f\"Tracked {len(inference_session.obj_ids)} objects through {len(video_segments)} frames\")\n+Tracked 2 objects through 200 frames\n+```\n+\n+#### Refining Video Segmentation\n+\n+You can add additional clicks on any frame to refine the tracking:\n+\n+```python\n+>>> # Add refinement click on a later frame\n+>>> refine_frame_idx = 50\n+>>> ann_obj_id = 2  # Refining first object\n+>>> points = [[[[220, 280]]]]  # Additional point\n+>>> labels = [[[1]]]  # Positive click\n+\n+>>> processor.add_inputs_to_inference_session(\n+...     inference_session=inference_session,\n+...     frame_idx=refine_frame_idx,\n+...     obj_ids=ann_obj_id,\n+...     input_points=points,\n+...     input_labels=labels,\n+... )\n+\n+>>> # Re-propagate with the additional information\n+>>> video_segments = {}\n+>>> for sam2_video_output in model.propagate_in_video_iterator(inference_session):\n+...     video_res_masks = processor.post_process_masks(\n+...         [sam2_video_output.pred_masks], original_sizes=[[inference_session.video_height, inference_session.video_width]], binarize=False\n+...     )[0]\n+...     video_segments[sam2_video_output.frame_idx] = video_res_masks\n+```\n+\n+### Streaming Video Inference\n+\n+For real-time applications, EdgeTAM Video supports processing video frames as they arrive:\n+\n+```python\n+>>> # Initialize session for streaming\n+>>> inference_session = processor.init_video_session(\n+...     inference_device=device,\n+...     dtype=torch.bfloat16,\n+... )\n+\n+>>> # Process frames one by one\n+>>> for frame_idx, frame in enumerate(video_frames[:10]):  # Process first 10 frames\n+...     inputs = processor(images=frame, device=device, return_tensors=\"pt\")\n+...\n+...     if frame_idx == 0:\n+...         # Add point input on first frame\n+...         processor.add_inputs_to_inference_session(\n+...             inference_session=inference_session,\n+...             frame_idx=0,\n+...             obj_ids=1,\n+...             input_points=[[[[210, 350], [250, 220]]]],\n+...             input_labels=[[[1, 1]]],\n+...             original_size=inputs.original_sizes[0], # need to be provided when using streaming video inference\n+...         )\n+...\n+...     # Process current frame\n+...     sam2_video_output = model(inference_session=inference_session, frame=inputs.pixel_values[0])\n+...\n+...     video_res_masks = processor.post_process_masks(\n+...         [sam2_video_output.pred_masks], original_sizes=inputs.original_sizes, binarize=False\n+...     )[0]\n+...     print(f\"Frame {frame_idx}: mask shape {video_res_masks.shape}\")\n+\n+Frame 0: mask shape torch.Size([1, 1, 540, 960])\n+...\n+```\n+\n+#### Video Batch Processing for Multiple Objects\n+\n+Track multiple objects simultaneously in video by adding them all at once:\n+\n+```python\n+>>> # Initialize video session\n+>>> inference_session = processor.init_video_session(\n+...     video=video_frames,\n+...     inference_device=device,\n+...     dtype=torch.bfloat16,\n+... )\n+\n+>>> # Add multiple objects on the first frame using batch processing\n+>>> ann_frame_idx = 0\n+>>> obj_ids = [2, 3]  # Track two different objects\n+>>> input_points = [\n+...     [[[200, 300], [230, 250], [275, 175]], [[400, 150]]]\n+... ]  # Object 2: 3 points (2 positive, 1 negative); Object 3: 1 point\n+>>> input_labels = [\n+...     [[1, 1, 0], [1]]\n+... ]  # Object 2: positive, positive, negative; Object 3: positive\n+\n+>>> processor.add_inputs_to_inference_session(\n+...     inference_session=inference_session,\n+...     frame_idx=ann_frame_idx,\n+...     obj_ids=obj_ids,\n+...     input_points=input_points,\n+...     input_labels=input_labels,\n+... )\n+\n+>>> # Get masks for all objects on the first frame\n+>>> outputs = model(\n+...     inference_session=inference_session,\n+...     frame_idx=ann_frame_idx,\n+... )\n+>>> video_res_masks = processor.post_process_masks(\n+...     [outputs.pred_masks], original_sizes=[[inference_session.video_height, inference_session.video_width]], binarize=False\n+... )[0]\n+>>> print(f\"Generated masks for {video_res_masks.shape[0]} objects\")\n+Generated masks for 2 objects\n+\n+>>> # Propagate all objects through the video\n+>>> video_segments = {}\n+>>> for sam2_video_output in model.propagate_in_video_iterator(inference_session):\n+...     video_res_masks = processor.post_process_masks(\n+...         [sam2_video_output.pred_masks], original_sizes=[[inference_session.video_height, inference_session.video_width]], binarize=False\n+...     )[0]\n+...     video_segments[sam2_video_output.frame_idx] = {\n+...         obj_id: video_res_masks[i]\n+...         for i, obj_id in enumerate(inference_session.obj_ids)\n+...     }\n+\n+>>> print(f\"Tracked {len(inference_session.obj_ids)} objects through {len(video_segments)} frames\")\n+Tracked 2 objects through 200 frames\n+```\n+\n+## EdgeTamVideoMaskDecoderConfig\n+\n+[[autodoc]] EdgeTamVideoMaskDecoderConfig\n+\n+## EdgeTamVideoPromptEncoderConfig\n+\n+[[autodoc]] EdgeTamVideoPromptEncoderConfig\n+\n+## EdgeTamVideoConfig\n+\n+[[autodoc]] EdgeTamVideoConfig\n+\n+## EdgeTamVideoInferenceSession\n+\n+[[autodoc]] EdgeTamVideoInferenceSession\n+\n+## EdgeTamVideoModel\n+\n+[[autodoc]] EdgeTamVideoModel\n+    - forward"
        },
        {
            "sha": "33c8c7e96aee301600ee8c1356e2b5217e05f971",
            "filename": "docs/source/en/model_doc/qwen3_vl.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen3_vl.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen3_vl.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen3_vl.md?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -13,7 +13,7 @@ specific language governing permissions and limitations under the License.\n rendered properly in your Markdown viewer.\n \n -->\n-*This model was released on 2025-02-19 and added to Hugging Face Transformers on 2025-09-15.*\n+*This model was released on 2025-09-23 and added to Hugging Face Transformers on 2025-09-15.*\n \n <div style=\"float: right;\">\n     <div class=\"flex flex-wrap space-x-1\">"
        },
        {
            "sha": "c721f24a506d6b9b361b04f40297f993ec2a96e1",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -108,6 +108,8 @@\n     from .dots1 import *\n     from .dpr import *\n     from .dpt import *\n+    from .edgetam import *\n+    from .edgetam_video import *\n     from .efficientloftr import *\n     from .efficientnet import *\n     from .electra import *"
        },
        {
            "sha": "f6a12e7cef986fb837abbfee0cc81b64b7148b50",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -127,6 +127,9 @@\n         (\"dots1\", \"Dots1Config\"),\n         (\"dpr\", \"DPRConfig\"),\n         (\"dpt\", \"DPTConfig\"),\n+        (\"edgetam\", \"EdgeTamConfig\"),\n+        (\"edgetam_video\", \"EdgeTamVideoConfig\"),\n+        (\"edgetam_vision_model\", \"EdgeTamVisionConfig\"),\n         (\"efficientformer\", \"EfficientFormerConfig\"),\n         (\"efficientloftr\", \"EfficientLoFTRConfig\"),\n         (\"efficientnet\", \"EfficientNetConfig\"),\n@@ -563,6 +566,9 @@\n         (\"dots1\", \"dots1\"),\n         (\"dpr\", \"DPR\"),\n         (\"dpt\", \"DPT\"),\n+        (\"edgetam\", \"EdgeTAM\"),\n+        (\"edgetam_video\", \"EdgeTamVideo\"),\n+        (\"edgetam_vision_model\", \"EdgeTamVisionModel\"),\n         (\"efficientformer\", \"EfficientFormer\"),\n         (\"efficientloftr\", \"EfficientLoFTR\"),\n         (\"efficientnet\", \"EfficientNet\"),\n@@ -983,6 +989,7 @@\n         (\"qwen3_vl_moe_text\", \"qwen3_vl_moe\"),\n         (\"sam_vision_model\", \"sam\"),\n         (\"sam2_vision_model\", \"sam2\"),\n+        (\"edgetam_vision_model\", \"edgetam\"),\n         (\"sam2_hiera_det_model\", \"sam2\"),\n         (\"sam_hq_vision_model\", \"sam_hq\"),\n         (\"llama4_text\", \"llama4\"),"
        },
        {
            "sha": "a272735af207dd49c3a0444187d0ae3e882415b9",
            "filename": "src/transformers/models/auto/image_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -91,6 +91,7 @@\n             (\"dinov3_vit\", (None, \"DINOv3ViTImageProcessorFast\")),\n             (\"donut-swin\", (\"DonutImageProcessor\", \"DonutImageProcessorFast\")),\n             (\"dpt\", (\"DPTImageProcessor\", \"DPTImageProcessorFast\")),\n+            (\"edgetam\", (None, \"Sam2ImageProcessorFast\")),\n             (\"efficientformer\", (\"EfficientFormerImageProcessor\", None)),\n             (\"efficientloftr\", (\"EfficientLoFTRImageProcessor\", \"EfficientLoFTRImageProcessorFast\")),\n             (\"efficientnet\", (\"EfficientNetImageProcessor\", \"EfficientNetImageProcessorFast\")),"
        },
        {
            "sha": "298834bebe9303b90a325d48f4be6ab732bfe051",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -131,6 +131,9 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"dots1\", \"Dots1Model\"),\n         (\"dpr\", \"DPRQuestionEncoder\"),\n         (\"dpt\", \"DPTModel\"),\n+        (\"edgetam\", \"EdgeTamModel\"),\n+        (\"edgetam_video\", \"EdgeTamVideoModel\"),\n+        (\"edgetam_vision_model\", \"EdgeTamVisionModel\"),\n         (\"efficientformer\", \"EfficientFormerModel\"),\n         (\"efficientloftr\", \"EfficientLoFTRModel\"),\n         (\"efficientnet\", \"EfficientNetModel\"),\n@@ -1709,6 +1712,8 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n \n MODEL_FOR_MASK_GENERATION_MAPPING_NAMES = OrderedDict(\n     [\n+        (\"edgetam\", \"EdgeTamModel\"),\n+        (\"edgetam_video\", \"EdgeTamModel\"),\n         (\"sam\", \"SamModel\"),\n         (\"sam2\", \"Sam2Model\"),\n         (\"sam2_video\", \"Sam2Model\"),"
        },
        {
            "sha": "11862a5896b94be7d1d247f022026bf64088987d",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -66,6 +66,7 @@\n         (\"deepseek_vl\", \"DeepseekVLProcessor\"),\n         (\"deepseek_vl_hybrid\", \"DeepseekVLHybridProcessor\"),\n         (\"dia\", \"DiaProcessor\"),\n+        (\"edgetam\", \"Sam2Processor\"),\n         (\"emu3\", \"Emu3Processor\"),\n         (\"evolla\", \"EvollaProcessor\"),\n         (\"flava\", \"FlavaProcessor\"),"
        },
        {
            "sha": "d9c1a55fc5bcd2fe4b083ffbac0633ad09076565",
            "filename": "src/transformers/models/edgetam/__init__.py",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fedgetam%2F__init__.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,27 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_edgetam import *\n+    from .modeling_edgetam import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "07ccee36e93209cff330ae037bc7324ac686e3c3",
            "filename": "src/transformers/models/edgetam/configuration_edgetam.py",
            "status": "added",
            "additions": 332,
            "deletions": 0,
            "changes": 332,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam%2Fconfiguration_edgetam.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam%2Fconfiguration_edgetam.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fedgetam%2Fconfiguration_edgetam.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,332 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/edgetam/modular_edgetam.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_edgetam.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 The Meta AI Authors and The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from ...configuration_utils import PretrainedConfig\n+from ..auto import CONFIG_MAPPING, AutoConfig\n+\n+\n+class EdgeTamVisionConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`EdgeTamVisionModel`]. It is used to instantiate a SAM\n+    vision encoder according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    defaults will yield a similar configuration to that of SAM 2.1 Hiera-tiny\n+    [facebook/EdgeTAM](https://huggingface.co/facebook/EdgeTAM) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        backbone_config (`Union[dict, \"PretrainedConfig\"]`, *optional*):\n+            Configuration for the vision backbone. This is used to instantiate the backbone using\n+            `AutoModel.from_config`.\n+        backbone_channel_list (`List[int]`, *optional*, defaults to `[384, 192, 96, 48]`):\n+            The list of channel dimensions for the backbone.\n+        backbone_feature_sizes (`List[List[int]]`, *optional*, defaults to `[[256, 256], [128, 128], [64, 64]]`):\n+            The spatial sizes of the feature maps from the backbone.\n+        fpn_hidden_size (`int`, *optional*, defaults to 256):\n+            The hidden dimension of the FPN.\n+        fpn_kernel_size (`int`, *optional*, defaults to 1):\n+            The kernel size for the convolutions in the neck.\n+        fpn_stride (`int`, *optional*, defaults to 1):\n+            The stride for the convolutions in the neck.\n+        fpn_padding (`int`, *optional*, defaults to 0):\n+            The padding for the convolutions in the neck.\n+        fpn_top_down_levels (`List[int]`, *optional*, defaults to `[2, 3]`):\n+            The levels for the top-down FPN connections.\n+        num_feature_levels (`int`, *optional*, defaults to 3):\n+            The number of feature levels from the FPN to use.\n+        hidden_act (`str`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function in the neck.\n+        layer_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon for the layer normalization.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+\n+    \"\"\"\n+\n+    base_config_key = \"vision_config\"\n+    model_type = \"edgetam_vision_model\"\n+    sub_configs = {\n+        \"backbone_config\": AutoConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        backbone_config=None,\n+        backbone_channel_list=None,\n+        backbone_feature_sizes=None,\n+        fpn_hidden_size=256,\n+        fpn_kernel_size=1,\n+        fpn_stride=1,\n+        fpn_padding=0,\n+        fpn_top_down_levels=None,\n+        num_feature_levels=3,\n+        hidden_act=\"gelu\",\n+        layer_norm_eps=1e-6,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        backbone_channel_list = [384, 192, 96, 48] if backbone_channel_list is None else backbone_channel_list\n+        backbone_feature_sizes = (\n+            [[256, 256], [128, 128], [64, 64]] if backbone_feature_sizes is None else backbone_feature_sizes\n+        )\n+        fpn_top_down_levels = [2, 3] if fpn_top_down_levels is None else fpn_top_down_levels\n+\n+        if isinstance(backbone_config, dict):\n+            backbone_config[\"model_type\"] = backbone_config.get(\"model_type\", \"timm_wrapper\")\n+            backbone_config = CONFIG_MAPPING[backbone_config[\"model_type\"]](**backbone_config)\n+        elif isinstance(backbone_config, AutoConfig):\n+            backbone_config = backbone_config\n+        elif backbone_config is None:\n+            backbone_config = AutoConfig.from_pretrained(\n+                \"timm/repvit_m1.dist_in1k\",\n+                model_args={\"in_chans\": 3, \"features_only\": True, \"out_indices\": [0, 1, 2, 3]},\n+            )\n+\n+        self.backbone_config = backbone_config\n+\n+        # Neck\n+        self.backbone_channel_list = backbone_channel_list\n+        self.backbone_feature_sizes = backbone_feature_sizes\n+        self.fpn_hidden_size = fpn_hidden_size\n+        self.fpn_kernel_size = fpn_kernel_size\n+        self.fpn_stride = fpn_stride\n+        self.fpn_padding = fpn_padding\n+        self.fpn_top_down_levels = fpn_top_down_levels\n+        self.num_feature_levels = num_feature_levels\n+\n+        self.hidden_act = hidden_act\n+        self.layer_norm_eps = layer_norm_eps\n+        self.initializer_range = initializer_range\n+\n+\n+class EdgeTamPromptEncoderConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`EdgeTamPromptEncoder`]. The [`EdgeTamPromptEncoder`]\n+    module is used to encode the input 2D points and bounding boxes.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 256):\n+            Dimensionality of the hidden states.\n+        image_size (`int`, *optional*, defaults to 1024):\n+            The expected output resolution of the image.\n+        patch_size (`int`, *optional*, defaults to 16):\n+            The size (resolution) of each patch.\n+        mask_input_channels (`int`, *optional*, defaults to 16):\n+            The number of channels to be fed to the `MaskDecoder` module.\n+        num_point_embeddings (`int`, *optional*, defaults to 4):\n+            The number of point embeddings to be used.\n+        hidden_act (`str`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function in the encoder and pooler.\n+        layer_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the layer normalization layers.\n+        scale (`float`, *optional*, defaults to 1):\n+            The scale factor for the prompt encoder.\n+    \"\"\"\n+\n+    base_config_key = \"prompt_encoder_config\"\n+\n+    def __init__(\n+        self,\n+        hidden_size=256,\n+        image_size=1024,\n+        patch_size=16,\n+        mask_input_channels=16,\n+        num_point_embeddings=4,\n+        hidden_act=\"gelu\",\n+        layer_norm_eps=1e-6,\n+        scale=1,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        self.hidden_size = hidden_size\n+        self.image_size = image_size\n+        self.patch_size = patch_size\n+        self.mask_input_channels = mask_input_channels\n+        self.num_point_embeddings = num_point_embeddings\n+        self.hidden_act = hidden_act\n+        self.layer_norm_eps = layer_norm_eps\n+        self.scale = scale\n+\n+\n+class EdgeTamMaskDecoderConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`EdgeTamMaskDecoder`]. It is used to instantiate a EDGETAM\n+    memory encoder according to the specified arguments, defining the model architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 256):\n+            Dimensionality of the hidden states.\n+        hidden_act (`str`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function in the EDGETAM mask decoder.\n+        mlp_dim (`int`, *optional*, defaults to 2048):\n+            The dimension of the MLP in the two-way transformer.\n+        num_hidden_layers (`int`, *optional*, defaults to 2):\n+            The number of hidden layers in the two-way transformer.\n+        num_attention_heads (`int`, *optional*, defaults to 8):\n+            The number of attention heads in the two-way transformer.\n+        attention_downsample_rate (`int`, *optional*, defaults to 2):\n+            The downsample rate for the attention layers.\n+        num_multimask_outputs (`int`, *optional*, defaults to 3):\n+            The number of multimask outputs.\n+        iou_head_depth (`int`, *optional*, defaults to 3):\n+            The depth of the IoU head.\n+        iou_head_hidden_dim (`int`, *optional*, defaults to 256):\n+            The hidden dimension of the IoU head.\n+        dynamic_multimask_via_stability (`bool`, *optional*, defaults to `True`):\n+            Whether to use dynamic multimask via stability.\n+        dynamic_multimask_stability_delta (`float`, *optional*, defaults to 0.05):\n+            The stability delta for the dynamic multimask.\n+        dynamic_multimask_stability_thresh (`float`, *optional*, defaults to 0.98):\n+            The stability threshold for the dynamic multimask.\n+\n+    \"\"\"\n+\n+    base_config_key = \"mask_decoder_config\"\n+\n+    def __init__(\n+        self,\n+        hidden_size=256,\n+        hidden_act=\"gelu\",\n+        mlp_dim=2048,\n+        num_hidden_layers=2,\n+        num_attention_heads=8,\n+        attention_downsample_rate=2,\n+        num_multimask_outputs=3,\n+        iou_head_depth=3,\n+        iou_head_hidden_dim=256,\n+        dynamic_multimask_via_stability=True,\n+        dynamic_multimask_stability_delta=0.05,\n+        dynamic_multimask_stability_thresh=0.98,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.hidden_size = hidden_size\n+        self.num_multimask_outputs = num_multimask_outputs\n+        self.hidden_act = hidden_act\n+        self.iou_head_depth = iou_head_depth\n+        self.iou_head_hidden_dim = iou_head_hidden_dim\n+        self.dynamic_multimask_via_stability = dynamic_multimask_via_stability\n+        self.dynamic_multimask_stability_delta = dynamic_multimask_stability_delta\n+        self.dynamic_multimask_stability_thresh = dynamic_multimask_stability_thresh\n+\n+        # TwoWayTransformer configuration\n+        self.num_hidden_layers = num_hidden_layers\n+        self.hidden_size = hidden_size\n+        self.num_attention_heads = num_attention_heads\n+        self.mlp_dim = mlp_dim\n+        self.attention_downsample_rate = attention_downsample_rate\n+\n+\n+class EdgeTamConfig(PretrainedConfig):\n+    r\"\"\"\n+    [`EdgeTamConfig`] is the configuration class to store the configuration of a [`EdgeTamModel`]. It is used to instantiate a\n+    EDGETAM model according to the specified arguments, defining the memory attention, memory encoder, and image encoder\n+    configs. Instantiating a configuration defaults will yield a similar configuration to that of the SAM 2.1 Hiera-tiny\n+    [facebook/edgetam.1-hiera-tiny](https://huggingface.co/facebook/edgetam.1-hiera-tiny) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vision_config (Union[`dict`, `EdgeTamVisionConfig`], *optional*):\n+            Dictionary of configuration options used to initialize [`EdgeTamVisionConfig`].\n+        prompt_encoder_config (Union[`dict`, `EdgeTamPromptEncoderConfig`], *optional*):\n+            Dictionary of configuration options used to initialize [`EdgeTamPromptEncoderConfig`].\n+        mask_decoder_config (Union[`dict`, `EdgeTamMaskDecoderConfig`], *optional*):\n+            Dictionary of configuration options used to initialize [`EdgeTamMaskDecoderConfig`].\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            Standard deviation for parameter initialization.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import (\n+    ...     EdgeTamVisionConfig,\n+    ...     EdgeTamPromptEncoderConfig,\n+    ...     EdgeTamMaskDecoderConfig,\n+    ...     EdgeTamModel,\n+    ... )\n+\n+    >>> # Initializing a EdgeTamConfig with `\"facebook/edgetam.1_hiera_tiny\"` style configuration\n+    >>> configuration = EdgeTamconfig()\n+\n+    >>> # Initializing a EdgeTamModel (with random weights) from the `\"facebook/edgetam.1_hiera_tiny\"` style configuration\n+    >>> model = EdgeTamModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+\n+    >>> # We can also initialize a EdgeTamConfig from a EdgeTamVisionConfig, EdgeTamPromptEncoderConfig, and EdgeTamMaskDecoderConfig\n+\n+    >>> # Initializing EDGETAM vision encoder, memory attention, and memory encoder configurations\n+    >>> vision_config = EdgeTamVisionConfig()\n+    >>> prompt_encoder_config = EdgeTamPromptEncoderConfig()\n+    >>> mask_decoder_config = EdgeTamMaskDecoderConfig()\n+\n+    >>> config = EdgeTamConfig(vision_config, prompt_encoder_config, mask_decoder_config)\n+    ```\"\"\"\n+\n+    model_type = \"edgetam\"\n+    sub_configs = {\n+        \"vision_config\": AutoConfig,\n+        \"prompt_encoder_config\": EdgeTamPromptEncoderConfig,\n+        \"mask_decoder_config\": EdgeTamMaskDecoderConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        vision_config=None,\n+        prompt_encoder_config=None,\n+        mask_decoder_config=None,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        vision_config = vision_config if vision_config is not None else {}\n+        prompt_encoder_config = prompt_encoder_config if prompt_encoder_config is not None else {}\n+        mask_decoder_config = mask_decoder_config if mask_decoder_config is not None else {}\n+\n+        if isinstance(vision_config, dict):\n+            vision_config[\"model_type\"] = vision_config.get(\"model_type\", \"edgetam_vision_model\")\n+            vision_config = CONFIG_MAPPING[vision_config[\"model_type\"]](**vision_config)\n+        if isinstance(prompt_encoder_config, EdgeTamPromptEncoderConfig):\n+            prompt_encoder_config = prompt_encoder_config.to_dict()\n+        if isinstance(mask_decoder_config, EdgeTamMaskDecoderConfig):\n+            mask_decoder_config = mask_decoder_config.to_dict()\n+\n+        self.vision_config = vision_config\n+        self.prompt_encoder_config = EdgeTamPromptEncoderConfig(**prompt_encoder_config)\n+        self.mask_decoder_config = EdgeTamMaskDecoderConfig(**mask_decoder_config)\n+\n+        self.initializer_range = initializer_range\n+\n+\n+__all__ = [\"EdgeTamConfig\", \"EdgeTamVisionConfig\", \"EdgeTamPromptEncoderConfig\", \"EdgeTamMaskDecoderConfig\"]"
        },
        {
            "sha": "382bc1559ec4cf2943193dc677353237087d449c",
            "filename": "src/transformers/models/edgetam/convert_edgetam_to_hf.py",
            "status": "added",
            "additions": 280,
            "deletions": 0,
            "changes": 280,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam%2Fconvert_edgetam_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam%2Fconvert_edgetam_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fedgetam%2Fconvert_edgetam_to_hf.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,280 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"\n+Convert SAM checkpoints from the original repository.\n+\n+URL: https://github.com/facebookresearch/segment-anything-2.\n+\"\"\"\n+\n+import argparse\n+import re\n+\n+import numpy as np\n+import requests\n+import torch\n+from huggingface_hub import hf_hub_download\n+from PIL import Image\n+\n+from transformers import (\n+    EdgeTamConfig,\n+    EdgeTamMaskDecoderConfig,\n+    EdgeTamModel,\n+    EdgeTamPromptEncoderConfig,\n+    EdgeTamVisionConfig,\n+    Sam2ImageProcessorFast,\n+    Sam2Processor,\n+    TimmWrapperConfig,\n+)\n+\n+\n+def get_config(model_name):\n+    backbone_config = TimmWrapperConfig.from_pretrained(\n+        \"timm/repvit_m1.dist_in1k\",\n+        model_args={\"in_chans\": 3, \"features_only\": True, \"out_indices\": (0, 1, 2, 3)},\n+    )\n+    vision_config = EdgeTamVisionConfig(backbone_config=backbone_config)\n+\n+    prompt_encoder_config = EdgeTamPromptEncoderConfig()\n+    mask_decoder_config = EdgeTamMaskDecoderConfig()\n+    enable_temporal_pos_encoding_for_object_pointers = False\n+    project_temporal_pos_encoding_in_object_pointers = False\n+    enable_occlusion_spatial_embedding = False\n+\n+    config = EdgeTamConfig(\n+        vision_config=vision_config,\n+        prompt_encoder_config=prompt_encoder_config,\n+        mask_decoder_config=mask_decoder_config,\n+        enable_temporal_pos_encoding_for_object_pointers=enable_temporal_pos_encoding_for_object_pointers,\n+        project_temporal_pos_encoding_in_object_pointers=project_temporal_pos_encoding_in_object_pointers,\n+        enable_occlusion_spatial_embedding=enable_occlusion_spatial_embedding,\n+    )\n+\n+    return config\n+\n+\n+KEYS_TO_MODIFY_MAPPING = {\n+    \"iou_prediction_head.layers.0\": \"iou_prediction_head.proj_in\",\n+    \"iou_prediction_head.layers.1\": \"iou_prediction_head.layers.0\",\n+    \"iou_prediction_head.layers.2\": \"iou_prediction_head.proj_out\",\n+    \"mask_decoder.output_upscaling.0\": \"mask_decoder.upscale_conv1\",\n+    \"mask_decoder.output_upscaling.1\": \"mask_decoder.upscale_layer_norm\",\n+    \"mask_decoder.output_upscaling.3\": \"mask_decoder.upscale_conv2\",\n+    \"mask_downscaling.0\": \"mask_embed.conv1\",\n+    \"mask_downscaling.1\": \"mask_embed.layer_norm1\",\n+    \"mask_downscaling.3\": \"mask_embed.conv2\",\n+    \"mask_downscaling.4\": \"mask_embed.layer_norm2\",\n+    \"mask_downscaling.6\": \"mask_embed.conv3\",\n+    \"dwconv\": \"depthwise_conv\",\n+    \"pwconv\": \"pointwise_conv\",\n+    \"fuser\": \"memory_fuser\",\n+    \"point_embeddings\": \"point_embed\",\n+    \"pe_layer.positional_encoding_gaussian_matrix\": \"shared_embedding.positional_embedding\",\n+    \"obj_ptr_tpos_proj\": \"temporal_positional_encoding_projection_layer\",\n+    \"no_obj_embed_spatial\": \"occlusion_spatial_embedding_parameter\",\n+    \"sam_prompt_encoder\": \"prompt_encoder\",\n+    \"sam_mask_decoder\": \"mask_decoder\",\n+    \"maskmem_tpos_enc\": \"memory_temporal_positional_encoding\",\n+    \"gamma\": \"scale\",\n+    \"image_encoder.neck\": \"vision_encoder.neck\",\n+    \"image_encoder\": \"vision_encoder.backbone\",\n+    \"neck.0\": \"neck.conv1\",\n+    \"neck.1\": \"neck.layer_norm1\",\n+    \"neck.2\": \"neck.conv2\",\n+    \"neck.3\": \"neck.layer_norm2\",\n+    \"pix_feat_proj\": \"feature_projection\",\n+    \"patch_embed.proj\": \"patch_embed.projection\",\n+    \"no_mem_embed\": \"no_memory_embedding\",\n+    \"no_mem_pos_enc\": \"no_memory_positional_encoding\",\n+    \"obj_ptr\": \"object_pointer\",\n+    \".norm\": \".layer_norm\",\n+    \"trunk.\": \"\",\n+    \"out_proj\": \"o_proj\",\n+    \"body.\": \"timm_model.\",\n+    \"ff.0\": \"feed_forward.layer_norm\",\n+    \"ff.1\": \"feed_forward.linear1\",\n+    \"ff.3\": \"feed_forward.linear2\",\n+}\n+\n+\n+def replace_keys(state_dict):\n+    model_state_dict = {}\n+    output_hypernetworks_mlps_pattern = r\".*.output_hypernetworks_mlps.(\\d+).layers.(\\d+).*\"\n+    output_mask_decoder_mlps_pattern = r\"mask_decoder.transformer.layers.(\\d+).mlp.layers.(\\d+).*\"\n+    output_mask_decoder_score_head_pattern = r\"mask_decoder.pred_obj_score_head.layers.(\\d+).*\"\n+    output_vision_encoder_mlps_pattern = r\"vision_encoder.backbone.blocks.(\\d+).mlp.layers.(\\d+).*\"\n+    output_vision_encoder_neck_pattern = r\"vision_encoder.neck.convs.(\\d+).conv\"\n+    output_memory_encoder_projection_pattern = r\"memory_encoder.o_proj.*\"\n+    output_object_pointer_proj_pattern = r\"object_pointer_proj.layers.(\\d+).*\"\n+    for key, value in state_dict.items():\n+        for key_to_modify, new_key in KEYS_TO_MODIFY_MAPPING.items():\n+            if key_to_modify in key:\n+                key = key.replace(key_to_modify, new_key)\n+\n+        # vision_encoder.blocks.0.mlp.layers.1.weight -> vision_encoder.blocks.0.mlp.proj_out.weight\n+        if re.match(output_vision_encoder_mlps_pattern, key):\n+            layer_nb = int(re.match(output_vision_encoder_mlps_pattern, key).group(2))\n+            if layer_nb == 0:\n+                key = key.replace(\"layers.0\", \"proj_in\")\n+            elif layer_nb == 1:\n+                key = key.replace(\"layers.1\", \"proj_out\")\n+\n+        # mask_decoder.transformer.layers.0.mlp.layers.1.weight -> mask_decoder.transformer.layers.1.mlp.proj_out.weight\n+        if re.match(output_mask_decoder_mlps_pattern, key):\n+            layer_nb = int(re.match(output_mask_decoder_mlps_pattern, key).group(2))\n+            if layer_nb == 0:\n+                key = key.replace(\"mlp.layers.0\", \"mlp.proj_in\")\n+            elif layer_nb == 1:\n+                key = key.replace(\"mlp.layers.1\", \"mlp.proj_out\")\n+\n+        # mask_decoder.pred_obj_score_head.layers.1.weight -> mask_decoder.pred_obj_score_head.proj_in.weight\n+        if re.match(output_mask_decoder_score_head_pattern, key):\n+            layer_nb = int(re.match(output_mask_decoder_score_head_pattern, key).group(1))\n+            if layer_nb == 0:\n+                key = key.replace(\"layers.0\", \"proj_in\")\n+            elif layer_nb == 1:\n+                key = key.replace(\"layers.1\", \"layers.0\")\n+            elif layer_nb == 2:\n+                key = key.replace(\"layers.2\", \"proj_out\")\n+\n+        if re.match(output_hypernetworks_mlps_pattern, key):\n+            layer_nb = int(re.match(output_hypernetworks_mlps_pattern, key).group(2))\n+            if layer_nb == 0:\n+                key = key.replace(\"layers.0\", \"proj_in\")\n+            elif layer_nb == 1:\n+                key = key.replace(\"layers.1\", \"layers.0\")\n+            elif layer_nb == 2:\n+                key = key.replace(\"layers.2\", \"proj_out\")\n+\n+        # vision_encoder.neck.convs.1.conv.bias -> vision_encoder.neck.convs.1.bias\n+        if re.match(output_vision_encoder_neck_pattern, key):\n+            key = key.replace(\".conv.\", \".\")\n+\n+        # memory_encoder.o_proj.weight -> memory_encoder.projection.weight\n+        if re.match(output_memory_encoder_projection_pattern, key):\n+            key = key.replace(\".o_proj.\", \".projection.\")\n+\n+        if re.match(output_object_pointer_proj_pattern, key):\n+            layer_nb = int(re.match(output_object_pointer_proj_pattern, key).group(1))\n+            if layer_nb == 0:\n+                key = key.replace(\"layers.0\", \"proj_in\")\n+            elif layer_nb == 1:\n+                key = key.replace(\"layers.1\", \"layers.0\")\n+            elif layer_nb == 2:\n+                key = key.replace(\"layers.2\", \"proj_out\")\n+\n+                key = key.replace(\"layers.2\", \"proj_out\")\n+\n+        model_state_dict[key] = value\n+\n+    model_state_dict[\"shared_image_embedding.positional_embedding\"] = model_state_dict[\n+        \"prompt_encoder.shared_embedding.positional_embedding\"\n+    ]\n+    model_state_dict[\"prompt_encoder.point_embed.weight\"] = torch.cat(\n+        [model_state_dict.pop(f\"prompt_encoder.point_embed.{i}.weight\") for i in range(4)],\n+        dim=0,\n+    )\n+\n+    return model_state_dict\n+\n+\n+def convert_edgetam_checkpoint(model_name, checkpoint_path, pytorch_dump_folder, push_to_hub, run_sanity_check):\n+    config = get_config(model_name)\n+\n+    state_dict = torch.load(checkpoint_path, map_location=\"cpu\")[\"model\"]\n+    state_dict = replace_keys(state_dict)\n+\n+    image_processor = Sam2ImageProcessorFast()\n+    processor = Sam2Processor(image_processor=image_processor)\n+    hf_model = EdgeTamModel(config)\n+    hf_model.eval()\n+\n+    device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n+\n+    missing_keys, unexpected_keys = hf_model.load_state_dict(state_dict, strict=False)\n+    hf_model = hf_model.to(device)\n+    for pattern in EdgeTamModel._keys_to_ignore_on_load_unexpected:\n+        unexpected_keys = [k for k in unexpected_keys if re.search(pattern, k) is None]\n+    if missing_keys or unexpected_keys:\n+        print(\"Missing keys:\", missing_keys)\n+        print(\"Unexpected keys:\", unexpected_keys)\n+        raise ValueError(\"Missing or unexpected keys in the state dict\")\n+\n+    if run_sanity_check:\n+        img_url = \"https://huggingface.co/ybelkada/segment-anything/resolve/main/assets/car.png\"\n+        raw_image = Image.open(requests.get(img_url, stream=True).raw).convert(\"RGB\")\n+\n+        input_points = [[[[1000, 600]]]]\n+        input_labels = [[[1]]]\n+\n+        inputs = processor(\n+            images=np.array(raw_image), input_points=input_points, input_labels=input_labels, return_tensors=\"pt\"\n+        ).to(device)\n+\n+        with torch.no_grad():\n+            output = hf_model(**inputs)\n+        scores = output.iou_scores.squeeze()\n+\n+        assert torch.allclose(scores, torch.tensor([0.0356, 0.2141, 0.9707]).cuda(), atol=1e-3)\n+\n+    if pytorch_dump_folder is not None:\n+        processor.save_pretrained(pytorch_dump_folder)\n+        hf_model.save_pretrained(pytorch_dump_folder)\n+\n+    if push_to_hub:\n+        repo_id = f\"yonigozlan/{pytorch_dump_folder.split('/')[-1]}\"\n+        processor.push_to_hub(repo_id)\n+        hf_model.push_to_hub(repo_id)\n+\n+\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser()\n+    choices = [\"EdgeTAM\"]\n+    parser.add_argument(\n+        \"--model_name\",\n+        default=\"EdgeTAM\",\n+        choices=choices,\n+        type=str,\n+        help=\"Name of the original model to convert\",\n+    )\n+    parser.add_argument(\n+        \"--checkpoint_path\",\n+        type=str,\n+        required=False,\n+        help=\"Path to the original checkpoint\",\n+    )\n+    parser.add_argument(\"--pytorch_dump_folder_path\", default=\"\", type=str, help=\"Path to the output PyTorch model.\")\n+    parser.add_argument(\n+        \"--push_to_hub\",\n+        action=\"store_true\",\n+        help=\"Whether to push the model and processor to the hub after converting\",\n+    )\n+    parser.add_argument(\n+        \"--run_sanity_check\",\n+        action=\"store_true\",\n+        help=\"Whether to run the sanity check after converting\",\n+    )\n+\n+    args = parser.parse_args()\n+\n+    hf_model_name = args.model_name.replace(\"_\", \"-\")\n+    checkpoint_path = (\n+        hf_hub_download(f\"facebook/{hf_model_name}\", f\"{args.model_name.lower()}.pt\")\n+        if args.checkpoint_path is None\n+        else args.checkpoint_path\n+    )\n+\n+    convert_edgetam_checkpoint(\n+        args.model_name, checkpoint_path, args.pytorch_dump_folder_path, args.push_to_hub, args.run_sanity_check\n+    )"
        },
        {
            "sha": "d7e3ee6009cf31d642af72a40f966d35cf11e367",
            "filename": "src/transformers/models/edgetam/modeling_edgetam.py",
            "status": "added",
            "additions": 1252,
            "deletions": 0,
            "changes": 1252,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam%2Fmodeling_edgetam.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam%2Fmodeling_edgetam.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fedgetam%2Fmodeling_edgetam.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,1252 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/edgetam/modular_edgetam.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_edgetam.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 The Meta AI Authors and The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import math\n+from dataclasses import dataclass\n+from typing import Callable, Optional, Union\n+\n+import numpy as np\n+import torch\n+import torch.nn as nn\n+import torch.nn.functional as F\n+from torch import Tensor\n+\n+from transformers.utils.generic import OutputRecorder, TransformersKwargs, check_model_inputs\n+\n+from ...activations import ACT2FN\n+from ...modeling_outputs import BaseModelOutput\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...pytorch_utils import compile_compatible_method_lru_cache\n+from ...utils import ModelOutput, auto_docstring\n+from ..auto import AutoModel\n+from .configuration_edgetam import (\n+    EdgeTamConfig,\n+    EdgeTamMaskDecoderConfig,\n+    EdgeTamPromptEncoderConfig,\n+    EdgeTamVisionConfig,\n+)\n+\n+\n+# fix this in modular\n+if True:\n+    from transformers.models.timm_wrapper.modeling_timm_wrapper import TimmWrapperModel\n+\n+\n+class EdgeTamLayerNorm(nn.LayerNorm):\n+    r\"\"\"LayerNorm that supports two data formats: channels_last (default) or channels_first.\n+    The ordering of the dimensions in the inputs. channels_last corresponds to inputs with shape (batch_size, height,\n+    width, channels) while channels_first corresponds to inputs with shape (batch_size, channels, height, width).\n+    \"\"\"\n+\n+    def __init__(self, normalized_shape, *, eps=1e-6, data_format=\"channels_last\", **kwargs):\n+        super().__init__(normalized_shape, eps=eps, **kwargs)\n+        if data_format not in [\"channels_last\", \"channels_first\"]:\n+            raise NotImplementedError(f\"Unsupported data format: {data_format}\")\n+        self.data_format = data_format\n+\n+    def forward(self, features: torch.Tensor) -> torch.Tensor:\n+        \"\"\"\n+        Args:\n+            features: Tensor of shape (batch_size, channels, height, width) OR (batch_size, height, width, channels)\n+        \"\"\"\n+        if self.data_format == \"channels_first\":\n+            features = features.permute(0, 2, 3, 1)\n+            features = super().forward(features)\n+            features = features.permute(0, 3, 1, 2)\n+        else:\n+            features = super().forward(features)\n+        return features\n+\n+\n+@dataclass\n+@auto_docstring(custom_intro=\"Base class for the vision encoder's outputs.\")\n+class EdgeTamVisionEncoderOutput(ModelOutput):\n+    r\"\"\"\n+    last_hidden_state (`torch.FloatTensor` of shape `(batch_size, height, width, hidden_size)`):\n+        Sequence of hidden-states at the output of the last layer of the model.\n+    fpn_hidden_states (`tuple(torch.FloatTensor)`):\n+        Tuple of `torch.FloatTensor` (one for each feature level, from high to low resolution) of shape\n+        `(batch_size, hidden_size, height, width)`. Feature maps from the Feature Pyramid Network neck.\n+    fpn_position_encoding (`tuple(torch.FloatTensor)`):\n+        Tuple of `torch.FloatTensor` (one for each feature level, from high to low resolution) of shape\n+        `(batch_size, hidden_size, height, width)`. Positional encodings corresponding to the `fpn_hidden_states`.\n+    hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+        Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+        one for the output of each stage) of shape `(batch_size, height, width, hidden_size)`. Hidden-states of the\n+        model at the output of each stage.\n+    attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+        Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+        sequence_length)`. Attentions weights after the attention softmax, used to compute the weighted average in\n+        the self-attention heads.\n+    \"\"\"\n+\n+    last_hidden_state: Optional[torch.FloatTensor] = None\n+    fpn_hidden_states: Optional[torch.FloatTensor] = None\n+    fpn_position_encoding: Optional[torch.FloatTensor] = None\n+    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = None\n+    attentions: Optional[tuple[torch.FloatTensor, ...]] = None\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs,\n+):\n+    attn_weights = torch.matmul(query, key.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        attn_weights = attn_weights + attention_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+class EdgeTamAttention(nn.Module):\n+    \"\"\"\n+    EDGETAM's attention layer that allows for downscaling the size of the embedding after projection to queries, keys, and\n+    values.\n+    \"\"\"\n+\n+    def __init__(self, config, downsample_rate=None):\n+        super().__init__()\n+        downsample_rate = config.attention_downsample_rate if downsample_rate is None else downsample_rate\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.internal_dim = config.hidden_size // downsample_rate\n+        self.num_attention_heads = config.num_attention_heads\n+        self.head_dim = self.internal_dim // config.num_attention_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.is_causal = False\n+\n+        self.q_proj = nn.Linear(self.hidden_size, self.internal_dim)\n+        self.k_proj = nn.Linear(self.hidden_size, self.internal_dim)\n+        self.v_proj = nn.Linear(self.hidden_size, self.internal_dim)\n+        self.o_proj = nn.Linear(self.internal_dim, self.hidden_size)\n+\n+    def forward(\n+        self,\n+        query: torch.Tensor,\n+        key: torch.Tensor,\n+        value: torch.Tensor,\n+        attention_similarity: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        # Input projections\n+        batch_size, point_batch_size = query.shape[:2]\n+        new_shape = (batch_size * point_batch_size, -1, self.num_attention_heads, self.head_dim)\n+\n+        query = self.q_proj(query).view(*new_shape).transpose(1, 2)\n+        key = self.k_proj(key).view(*new_shape).transpose(1, 2)\n+        value = self.v_proj(value).view(*new_shape).transpose(1, 2)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query,\n+            key,\n+            value,\n+            attention_mask=attention_similarity,\n+            dropout=0.0,\n+            scaling=self.scaling,\n+            is_causal=self.is_causal,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(\n+            batch_size, point_batch_size, -1, self.num_attention_heads * self.head_dim\n+        ).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+\n+        return attn_output, attn_weights\n+\n+\n+class EdgeTamTwoWayAttentionBlock(nn.Module):\n+    def __init__(self, config: EdgeTamMaskDecoderConfig, skip_first_layer_pe: bool = False):\n+        \"\"\"\n+        A transformer block with four layers:\n+            (1) self-attention of sparse inputs (2) cross attention of sparse inputs -> dense inputs (3) mlp block on\n+            sparse inputs (4) cross attention of dense inputs -> sparse inputs\n+\n+        Arguments:\n+            config (`EdgeTamMaskDecoderConfig`):\n+                The configuration file used to instantiate the block\n+            attention_downsample_rate (*optionalk*, int, defaults to 2):\n+                The downsample ratio of the block used to reduce the inner dim of the attention.\n+            skip_first_layer_pe (*optional*, bool, defaults to `False`):\n+                Whether or not to skip the addition of the query_point_embedding on the first layer.\n+        \"\"\"\n+        super().__init__()\n+        self.self_attn = EdgeTamAttention(config, downsample_rate=1)\n+        self.layer_norm1 = nn.LayerNorm(config.hidden_size)\n+\n+        self.cross_attn_token_to_image = EdgeTamAttention(config)\n+        self.layer_norm2 = nn.LayerNorm(config.hidden_size)\n+\n+        self.mlp = EdgeTamFeedForward(\n+            config.hidden_size, config.mlp_dim, config.hidden_size, num_layers=config.num_hidden_layers\n+        )\n+        self.layer_norm3 = nn.LayerNorm(config.hidden_size)\n+\n+        self.layer_norm4 = nn.LayerNorm(config.hidden_size)\n+        self.cross_attn_image_to_token = EdgeTamAttention(config)\n+\n+        self.skip_first_layer_pe = skip_first_layer_pe\n+\n+    def forward(\n+        self,\n+        queries: Tensor,\n+        keys: Tensor,\n+        query_point_embedding: Tensor,\n+        key_point_embedding: Tensor,\n+        attention_similarity: Tensor,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ):\n+        # Self attention block\n+        if self.skip_first_layer_pe:\n+            queries, _ = self.self_attn(query=queries, key=queries, value=queries)\n+        else:\n+            query = queries + query_point_embedding\n+            attn_out, _ = self.self_attn(query=query, key=query, value=queries)\n+            queries = queries + attn_out\n+        queries = self.layer_norm1(queries)\n+\n+        # Cross attention block, tokens attending to image embedding\n+        query = queries + query_point_embedding\n+        key = keys + key_point_embedding\n+\n+        attn_out, _ = self.cross_attn_token_to_image(\n+            query=query, key=key, value=keys, attention_similarity=attention_similarity\n+        )\n+        queries = queries + attn_out\n+\n+        queries = self.layer_norm2(queries)\n+\n+        # MLP block\n+        mlp_out = self.mlp(queries)\n+        queries = queries + mlp_out\n+        queries = self.layer_norm3(queries)\n+\n+        # Cross attention block, image embedding attending to tokens\n+        query = queries + query_point_embedding\n+        key = keys + key_point_embedding\n+\n+        attn_out, _ = self.cross_attn_image_to_token(query=key, key=query, value=queries)\n+        keys = keys + attn_out\n+\n+        keys = self.layer_norm4(keys)\n+        return queries, keys, attn_out\n+\n+\n+class EdgeTamFeedForward(nn.Module):\n+    def __init__(\n+        self,\n+        input_dim: int,\n+        hidden_dim: int,\n+        output_dim: int,\n+        num_layers: int,\n+        activation: str = \"relu\",\n+        sigmoid_output: bool = False,\n+    ):\n+        super().__init__()\n+        self.num_layers = num_layers\n+        self.activation = ACT2FN[activation]\n+        self.proj_in = nn.Linear(input_dim, hidden_dim)\n+        self.proj_out = nn.Linear(hidden_dim, output_dim)\n+        self.layers = nn.ModuleList([nn.Linear(hidden_dim, hidden_dim) for _ in range(num_layers - 2)])\n+        self.sigmoid_output = sigmoid_output\n+\n+    def forward(self, hidden_states):\n+        hidden_states = self.proj_in(hidden_states)\n+        hidden_states = self.activation(hidden_states)\n+        for layer in self.layers:\n+            hidden_states = self.activation(layer(hidden_states))\n+\n+        hidden_states = self.proj_out(hidden_states)\n+        if self.sigmoid_output:\n+            hidden_states = F.sigmoid(hidden_states)\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class EdgeTamPreTrainedModel(PreTrainedModel):\n+    config_class = EdgeTamConfig\n+    base_model_prefix = \"edgetam\"\n+    main_input_name = \"pixel_values\"\n+    _supports_sdpa = True\n+    _supports_flash_attn_2 = True\n+    _supports_attention_backend = True\n+\n+    def _init_weights(self, module):\n+        std = self.config.initializer_range\n+        if isinstance(module, (nn.Linear, nn.Conv2d, nn.ConvTranspose2d)):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+        elif isinstance(module, (nn.LayerNorm, EdgeTamLayerNorm)):\n+            module.weight.data.fill_(1.0)\n+            module.bias.data.zero_()\n+        if isinstance(module, EdgeTamModel):\n+            if module.no_memory_embedding is not None:\n+                module.no_memory_embedding.data.zero_()\n+\n+\n+# copied and adapted from original implementation, also practically equal to DetrSinePositionEmbedding\n+class EdgeTamSinePositionEmbedding(nn.Module):\n+    \"\"\"\n+    This is a more standard version of the position embedding, very similar to the one used by the Attention is all you\n+    need paper, generalized to work on images.\n+    \"\"\"\n+\n+    def __init__(\n+        self, num_pos_feats: int = 64, temperature: int = 10000, normalize: bool = False, scale: Optional[float] = None\n+    ):\n+        super().__init__()\n+        if scale is not None and normalize is False:\n+            raise ValueError(\"normalize should be True if scale is passed\")\n+        self.num_pos_feats = num_pos_feats\n+        self.temperature = temperature\n+        self.normalize = normalize\n+        self.scale = 2 * math.pi if scale is None else scale\n+\n+    @compile_compatible_method_lru_cache(maxsize=1)\n+    def forward(\n+        self,\n+        shape: torch.Size,\n+        device: Union[torch.device, str],\n+        dtype: torch.dtype,\n+        mask: Optional[Tensor] = None,\n+    ) -> Tensor:\n+        if mask is None:\n+            mask = torch.zeros((shape[0], shape[2], shape[3]), device=device, dtype=torch.bool)\n+        not_mask = (~mask).to(dtype)\n+        y_embed = not_mask.cumsum(1)\n+        x_embed = not_mask.cumsum(2)\n+        if self.normalize:\n+            eps = 1e-6\n+            y_embed = y_embed / (y_embed[:, -1:, :] + eps) * self.scale\n+            x_embed = x_embed / (x_embed[:, :, -1:] + eps) * self.scale\n+\n+        dim_t = torch.arange(self.num_pos_feats, dtype=torch.int64, device=device).to(dtype)\n+        dim_t = self.temperature ** (2 * torch.div(dim_t, 2, rounding_mode=\"floor\") / self.num_pos_feats)\n+\n+        pos_x = x_embed[:, :, :, None] / dim_t\n+        pos_y = y_embed[:, :, :, None] / dim_t\n+        pos_x = torch.stack((pos_x[:, :, :, 0::2].sin(), pos_x[:, :, :, 1::2].cos()), dim=4).flatten(3)\n+        pos_y = torch.stack((pos_y[:, :, :, 0::2].sin(), pos_y[:, :, :, 1::2].cos()), dim=4).flatten(3)\n+        pos = torch.cat((pos_y, pos_x), dim=3).permute(0, 3, 1, 2)\n+        return pos\n+\n+\n+class EdgeTamVisionNeck(nn.Module):\n+    def __init__(self, config: EdgeTamVisionConfig):\n+        super().__init__()\n+        self.config = config\n+\n+        self.position_encoding = EdgeTamSinePositionEmbedding(\n+            num_pos_feats=config.fpn_hidden_size // 2, normalize=True\n+        )\n+        self.convs = nn.ModuleList()\n+        for in_channels in config.backbone_channel_list:\n+            self.convs.append(\n+                nn.Conv2d(\n+                    in_channels=in_channels,\n+                    out_channels=config.fpn_hidden_size,\n+                    kernel_size=config.fpn_kernel_size,\n+                    stride=config.fpn_stride,\n+                    padding=config.fpn_padding,\n+                ),\n+            )\n+        self.fpn_top_down_levels = config.fpn_top_down_levels\n+\n+    def forward(self, hidden_states: torch.Tensor) -> tuple[tuple[torch.Tensor, ...], tuple[torch.Tensor, ...]]:\n+        fpn_hidden_states = ()\n+        fpn_position_encoding = ()\n+\n+        # forward in top-down order (from low to high resolution)\n+        n = len(self.convs) - 1\n+        for i in range(n, -1, -1):\n+            lateral_features = hidden_states[i].permute(0, 3, 1, 2)\n+            lateral_features = self.convs[n - i](lateral_features)\n+            if i not in self.fpn_top_down_levels or i == n:\n+                prev_features = lateral_features\n+            else:\n+                top_down_features = F.interpolate(\n+                    prev_features.to(dtype=torch.float32),\n+                    scale_factor=2.0,\n+                    mode=\"nearest\",\n+                    align_corners=None,\n+                    antialias=False,\n+                ).to(lateral_features.dtype)\n+                prev_features = lateral_features + top_down_features\n+\n+            prev_position_encoding = self.position_encoding(\n+                prev_features.shape, prev_features.device, prev_features.dtype\n+            ).to(prev_features.dtype)\n+\n+            fpn_hidden_states += (prev_features,)\n+            fpn_position_encoding += (prev_position_encoding,)\n+\n+        return fpn_hidden_states, fpn_position_encoding\n+\n+\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    The vision model from EdgeTAM without any head or projection on top.\n+    \"\"\"\n+)\n+class EdgeTamVisionModel(EdgeTamPreTrainedModel):\n+    config_class = EdgeTamVisionConfig\n+    main_input_name = \"pixel_values\"\n+    _can_record_outputs = {\"hidden_states\": TimmWrapperModel, \"attentions\": TimmWrapperModel}\n+\n+    def __init__(self, config: EdgeTamVisionConfig):\n+        super().__init__(config)\n+        self.config = config\n+\n+        self.backbone = AutoModel.from_config(config.backbone_config)\n+\n+        self.neck = EdgeTamVisionNeck(config)\n+        self.num_feature_levels = config.num_feature_levels\n+\n+        self.post_init()\n+\n+    @check_model_inputs\n+    def forward(\n+        self,\n+        pixel_values: Optional[torch.FloatTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, EdgeTamVisionEncoderOutput]:\n+        if pixel_values is None:\n+            raise ValueError(\"You have to specify pixel_values\")\n+\n+        # Forward through backbone\n+        backbone_output = self.backbone(pixel_values)\n+        intermediate_hidden_states = backbone_output.last_hidden_state\n+        intermediate_hidden_states = [hidden_state.permute(0, 2, 3, 1) for hidden_state in intermediate_hidden_states]\n+\n+        fpn_hidden_states, fpn_position_encoding = self.neck(intermediate_hidden_states)\n+        # Select last `num_feature_levels` feature levels from FPN and reverse order to get features from high to low resolution\n+        fpn_hidden_states = fpn_hidden_states[-self.num_feature_levels :][::-1]\n+        fpn_position_encoding = fpn_position_encoding[-self.num_feature_levels :][::-1]\n+\n+        return EdgeTamVisionEncoderOutput(\n+            last_hidden_state=intermediate_hidden_states[-1],\n+            fpn_hidden_states=fpn_hidden_states,\n+            fpn_position_encoding=fpn_position_encoding,\n+        )\n+\n+\n+@dataclass\n+@auto_docstring(custom_intro=\"Base class for the EdgeTam model's output.\")\n+class EdgeTamImageSegmentationOutput(ModelOutput):\n+    r\"\"\"\n+    iou_scores (`torch.FloatTensor` of shape `(batch_size, point_batch_size, num_masks)`):\n+        The Intersection over Union (IoU) scores of the predicted masks.\n+    pred_masks (`torch.FloatTensor` of shape `(batch_size, point_batch_size, num_masks, height, width)`):\n+        The predicted low-resolution masks. This is an alias for `low_res_masks`. These masks need to be post-processed\n+        by the processor to be brought to the original image size.\n+    object_score_logits (`torch.FloatTensor` of shape `(batch_size, point_batch_size, 1)`):\n+        Logits for the object score, indicating if an object is present.\n+    image_embeddings (`tuple(torch.FloatTensor)`):\n+        The features from the FPN, which are used by the mask decoder. This is a tuple of `torch.FloatTensor` where each\n+        tensor has shape `(batch_size, channels, height, width)`.\n+    vision_hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True`):\n+        Tuple of `torch.FloatTensor` (one for the output of each stage) of shape `(batch_size, height, width, hidden_size)`.\n+        Hidden-states of the vision model at the output of each stage.\n+    vision_attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True`):\n+        Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length, sequence_length)`.\n+        Attentions weights of the vision model.\n+    mask_decoder_attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True`):\n+        Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length, sequence_length)`.\n+        Attentions weights of the mask decoder.\n+    \"\"\"\n+\n+    iou_scores: Optional[torch.FloatTensor] = None\n+    pred_masks: Optional[torch.FloatTensor] = None\n+    object_score_logits: Optional[torch.FloatTensor] = None\n+    image_embeddings: tuple[torch.FloatTensor, ...] = None\n+    vision_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = None\n+    vision_attentions: Optional[tuple[torch.FloatTensor, ...]] = None\n+    mask_decoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = None\n+\n+\n+class EdgeTamPositionalEmbedding(nn.Module):\n+    def __init__(self, config: EdgeTamPromptEncoderConfig):\n+        super().__init__()\n+        self.scale = config.scale\n+        positional_embedding = self.scale * torch.randn((2, config.hidden_size // 2))\n+        self.register_buffer(\"positional_embedding\", positional_embedding)\n+\n+    def forward(self, input_coords, input_shape=None):\n+        \"\"\"Positionally encode points that are normalized to [0,1].\"\"\"\n+        coordinates = input_coords.clone()\n+\n+        if input_shape is not None:\n+            coordinates[:, :, :, 0] = coordinates[:, :, :, 0] / input_shape[1]\n+            coordinates[:, :, :, 1] = coordinates[:, :, :, 1] / input_shape[0]\n+        coordinates.to(torch.float32)\n+\n+        # assuming coords are in [0, 1]^2 square and have d_1 x ... x d_n x 2 shape\n+        coordinates = 2 * coordinates - 1\n+        coordinates = coordinates.to(self.positional_embedding.dtype)\n+        coordinates = coordinates @ self.positional_embedding\n+        coordinates = 2 * np.pi * coordinates\n+        # outputs d_1 x ... x d_n x channel shape\n+        return torch.cat([torch.sin(coordinates), torch.cos(coordinates)], dim=-1)\n+\n+\n+class EdgeTamMaskEmbedding(nn.Module):\n+    def __init__(self, config: EdgeTamPromptEncoderConfig):\n+        super().__init__()\n+        self.mask_input_channels = config.mask_input_channels // 4\n+        self.activation = ACT2FN[config.hidden_act]\n+        self.conv1 = nn.Conv2d(1, self.mask_input_channels, kernel_size=2, stride=2)\n+        self.conv2 = nn.Conv2d(self.mask_input_channels, config.mask_input_channels, kernel_size=2, stride=2)\n+        self.conv3 = nn.Conv2d(config.mask_input_channels, config.hidden_size, kernel_size=1)\n+        self.layer_norm1 = EdgeTamLayerNorm(\n+            self.mask_input_channels, eps=config.layer_norm_eps, data_format=\"channels_first\"\n+        )\n+        self.layer_norm2 = EdgeTamLayerNorm(\n+            self.mask_input_channels * 4, eps=config.layer_norm_eps, data_format=\"channels_first\"\n+        )\n+\n+    def forward(self, masks):\n+        hidden_states = self.conv1(masks)\n+        hidden_states = self.layer_norm1(hidden_states)\n+        hidden_states = self.activation(hidden_states)\n+\n+        hidden_states = self.conv2(hidden_states)\n+        hidden_states = self.layer_norm2(hidden_states)\n+        hidden_states = self.activation(hidden_states)\n+        dense_embeddings = self.conv3(hidden_states)\n+        return dense_embeddings\n+\n+\n+class EdgeTamPromptEncoder(nn.Module):\n+    def __init__(self, config: EdgeTamPromptEncoderConfig):\n+        super().__init__()\n+        self.shared_embedding = EdgeTamPositionalEmbedding(config)\n+        self.mask_embed = EdgeTamMaskEmbedding(config)\n+        self.no_mask_embed = nn.Embedding(1, config.hidden_size)\n+\n+        self.image_embedding_size = (config.image_size // config.patch_size, config.image_size // config.patch_size)\n+        self.mask_input_size = (4 * config.image_size // config.patch_size, 4 * config.image_size // config.patch_size)\n+        self.input_image_size = config.image_size\n+\n+        self.point_embed = nn.Embedding(config.num_point_embeddings, config.hidden_size)\n+        self.hidden_size = config.hidden_size\n+        self.not_a_point_embed = nn.Embedding(1, config.hidden_size)\n+\n+    def _embed_points(self, points: torch.Tensor, labels: torch.Tensor, pad: bool) -> torch.Tensor:\n+        \"\"\"Embeds point prompts.\"\"\"\n+        points = points + 0.5  # Shift to center of pixel\n+        if pad:\n+            points = torch.nn.functional.pad(points, (0, 0, 0, 1), mode=\"constant\", value=0)\n+            labels = torch.nn.functional.pad(labels, (0, 1), mode=\"constant\", value=-1)\n+        input_shape = (self.input_image_size, self.input_image_size)\n+        point_embedding = self.shared_embedding(points, input_shape)\n+\n+        # torch.where and expanding the labels tensor is required by the ONNX export\n+        point_embedding = torch.where(labels[..., None] == -1, self.not_a_point_embed.weight, point_embedding)\n+\n+        # This is required for the ONNX export. The dtype, device need to be explicitly\n+        # specified as otherwise torch.onnx.export interprets as double\n+        point_embedding = torch.where(\n+            labels[..., None] != -10,\n+            point_embedding,\n+            torch.zeros_like(point_embedding),\n+        )\n+\n+        # Add point embeddings for labels >= 0\n+        point_embedding = point_embedding + self.point_embed(labels.clamp(min=0)) * (labels >= 0).unsqueeze(-1)\n+\n+        return point_embedding\n+\n+    def _embed_boxes(self, boxes: torch.Tensor) -> torch.Tensor:\n+        \"\"\"Embeds box prompts.\"\"\"\n+        boxes += 0.5  # Shift to center of pixel\n+        coords = boxes.view(*boxes.shape[:2], 2, 2)\n+        # add padding point for consistency with the original implementation\n+        coords = torch.nn.functional.pad(coords, (0, 0, 0, 1), mode=\"constant\", value=0)\n+        corner_embedding = self.shared_embedding(coords, (self.input_image_size, self.input_image_size))\n+        corner_embedding[:, :, 0, :] += self.point_embed.weight[2]\n+        corner_embedding[:, :, 1, :] += self.point_embed.weight[3]\n+        corner_embedding[:, :, 2, :] = self.not_a_point_embed.weight.expand_as(corner_embedding[:, :, 2, :])\n+        return corner_embedding\n+\n+    def forward(\n+        self,\n+        input_points: Optional[tuple[torch.Tensor, torch.Tensor]],\n+        input_labels: Optional[torch.Tensor],\n+        input_boxes: Optional[torch.Tensor],\n+        input_masks: Optional[torch.Tensor],\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Embeds different types of prompts, returning both sparse and dense embeddings.\n+\n+        Args:\n+            points (`torch.Tensor`, *optional*):\n+                point coordinates and labels to embed.\n+            boxes (`torch.Tensor`, *optional*):\n+                boxes to embed\n+            masks (`torch.Tensor`, *optional*):\n+                masks to embed\n+        \"\"\"\n+        sparse_embeddings = None\n+        batch_size = 1\n+        if input_points is not None:\n+            batch_size = input_points.shape[0]\n+            if input_labels is None:\n+                raise ValueError(\"If points are provided, labels must also be provided.\")\n+            point_embeddings = self._embed_points(input_points, input_labels, pad=(input_boxes is None))\n+            sparse_embeddings = point_embeddings\n+        if input_boxes is not None:\n+            batch_size = input_boxes.shape[0]\n+            box_embeddings = self._embed_boxes(input_boxes)\n+            if sparse_embeddings is None:\n+                sparse_embeddings = box_embeddings\n+            else:\n+                sparse_embeddings = torch.cat([sparse_embeddings, box_embeddings], dim=2)\n+        if input_masks is not None:\n+            dense_embeddings = self.mask_embed(input_masks)\n+        else:\n+            dense_embeddings = self.no_mask_embed.weight.reshape(1, -1, 1, 1).expand(\n+                batch_size, -1, self.image_embedding_size[0], self.image_embedding_size[1]\n+            )\n+\n+        return sparse_embeddings, dense_embeddings\n+\n+\n+class EdgeTamTwoWayTransformer(nn.Module):\n+    def __init__(self, config: EdgeTamMaskDecoderConfig):\n+        super().__init__()\n+        self.config = config\n+\n+        self.num_hidden_layers = config.num_hidden_layers\n+        self.layers = nn.ModuleList()\n+\n+        for i in range(self.num_hidden_layers):\n+            self.layers.append(EdgeTamTwoWayAttentionBlock(config, skip_first_layer_pe=(i == 0)))\n+\n+        self.final_attn_token_to_image = EdgeTamAttention(config)\n+        self.layer_norm_final_attn = nn.LayerNorm(config.hidden_size)\n+\n+    def forward(\n+        self,\n+        point_embeddings: Tensor,\n+        image_embeddings: Tensor,\n+        image_positional_embeddings: Tensor,\n+        attention_similarity: Tensor,\n+        target_embedding=None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, BaseModelOutput]:\n+        if image_embeddings is None:\n+            raise ValueError(\"You have to specify an image_embedding\")\n+\n+        image_embeddings = image_embeddings.flatten(2).permute(0, 2, 1).unsqueeze(1)\n+        image_positional_embeddings = image_positional_embeddings.flatten(2).permute(0, 2, 1).unsqueeze(1)\n+\n+        # Prepare queries\n+        queries = point_embeddings\n+        keys = image_embeddings\n+\n+        # Apply transformer blocks and final layernorm\n+        for layer in self.layers:\n+            if target_embedding is not None:\n+                queries += target_embedding\n+\n+            queries, keys, _ = layer(\n+                queries=queries,\n+                keys=keys,\n+                query_point_embedding=point_embeddings,\n+                key_point_embedding=image_positional_embeddings,\n+                attention_similarity=attention_similarity,\n+                **kwargs,\n+            )\n+        # Apply the final attention layer from the points to the image\n+        query = queries + point_embeddings\n+        key = keys + image_positional_embeddings\n+\n+        attn_out, _ = self.final_attn_token_to_image(query=query, key=key, value=keys)\n+\n+        queries = queries + attn_out\n+        queries = self.layer_norm_final_attn(queries)\n+        return queries, keys\n+\n+\n+class EdgeTamMaskDecoder(nn.Module):\n+    def __init__(self, config: EdgeTamMaskDecoderConfig):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+\n+        self.num_multimask_outputs = config.num_multimask_outputs\n+        self.num_mask_tokens = config.num_multimask_outputs + 1\n+\n+        self.iou_token = nn.Embedding(1, self.hidden_size)\n+        self.mask_tokens = nn.Embedding(self.num_mask_tokens, self.hidden_size)\n+\n+        self.transformer = EdgeTamTwoWayTransformer(config)\n+\n+        # should we create a new class for this?\n+        self.upscale_conv1 = nn.ConvTranspose2d(self.hidden_size, self.hidden_size // 4, kernel_size=2, stride=2)\n+        self.upscale_conv2 = nn.ConvTranspose2d(self.hidden_size // 4, self.hidden_size // 8, kernel_size=2, stride=2)\n+        self.upscale_layer_norm = EdgeTamLayerNorm(self.hidden_size // 4, data_format=\"channels_first\")\n+        self.activation = nn.GELU()\n+\n+        mlps_list = []\n+        for _ in range(self.num_mask_tokens):\n+            mlps_list += [EdgeTamFeedForward(self.hidden_size, self.hidden_size, self.hidden_size // 8, 3)]\n+        self.output_hypernetworks_mlps = nn.ModuleList(mlps_list)\n+        self.iou_prediction_head = EdgeTamFeedForward(\n+            self.hidden_size,\n+            config.iou_head_hidden_dim,\n+            self.num_mask_tokens,\n+            config.iou_head_depth,\n+            sigmoid_output=True,\n+        )\n+\n+        self.conv_s0 = nn.Conv2d(config.hidden_size, config.hidden_size // 8, kernel_size=1, stride=1)\n+        self.conv_s1 = nn.Conv2d(config.hidden_size, config.hidden_size // 4, kernel_size=1, stride=1)\n+\n+        self.obj_score_token = nn.Embedding(1, self.hidden_size)\n+        self.pred_obj_score_head = EdgeTamFeedForward(self.hidden_size, self.hidden_size, 1, 3)\n+\n+        self.dynamic_multimask_via_stability = config.dynamic_multimask_via_stability\n+        self.dynamic_multimask_stability_delta = config.dynamic_multimask_stability_delta\n+        self.dynamic_multimask_stability_thresh = config.dynamic_multimask_stability_thresh\n+\n+    def forward(\n+        self,\n+        image_embeddings: torch.Tensor,\n+        image_positional_embeddings: torch.Tensor,\n+        sparse_prompt_embeddings: torch.Tensor,\n+        dense_prompt_embeddings: torch.Tensor,\n+        multimask_output: bool,\n+        high_resolution_features: list[torch.Tensor],\n+        attention_similarity: Optional[torch.Tensor] = None,\n+        target_embedding: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Predict masks given image and prompt embeddings.\n+\n+        Args:\n+            image_embeddings (`torch.Tensor`):\n+                The embeddings from the image encoder.\n+            image_positional_embeddings (`torch.Tensor`):\n+                Positional encoding with the shape of image_embeddings.\n+            sparse_prompt_embeddings (`torch.Tensor`):\n+                The embeddings of the points and boxes.\n+            dense_prompt_embeddings (`torch.Tensor`):\n+                The embeddings of the mask inputs.\n+            multimask_output (`bool`):\n+                Whether to return multiple masks or a single mask.\n+            high_resolution_features (`list[torch.Tensor]`, *optional*):\n+                The high-resolution features from the vision encoder.\n+            attention_similarity (`torch.Tensor`, *optional*):\n+                The attention similarity tensor.\n+            target_embedding (`torch.Tensor`, *optional*):\n+                The target embedding.\n+        \"\"\"\n+        batch_size, num_channels, height, width = image_embeddings.shape\n+        point_batch_size = sparse_prompt_embeddings.shape[1]\n+        # Concatenate output tokens\n+        output_tokens = torch.cat(\n+            [\n+                self.obj_score_token.weight,\n+                self.iou_token.weight,\n+                self.mask_tokens.weight,\n+            ],\n+            dim=0,\n+        )\n+        output_tokens = output_tokens.repeat(batch_size, point_batch_size, 1, 1)\n+\n+        if sparse_prompt_embeddings.shape[0] != 0:\n+            tokens = torch.cat((output_tokens, sparse_prompt_embeddings), dim=2)\n+        else:\n+            tokens = output_tokens\n+        point_embeddings = tokens.to(self.iou_token.weight.dtype)\n+\n+        # Expand per-image data in batch direction to be per-mask\n+        image_embeddings = image_embeddings + dense_prompt_embeddings\n+        image_embeddings = image_embeddings.repeat_interleave(point_batch_size, dim=0)\n+        image_positional_embeddings = image_positional_embeddings.repeat_interleave(point_batch_size, 0)\n+        # Run the transformer\n+        point_embeddings, image_embeddings = self.transformer(\n+            point_embeddings=point_embeddings,\n+            image_embeddings=image_embeddings,\n+            image_positional_embeddings=image_positional_embeddings,\n+            attention_similarity=attention_similarity,\n+            target_embedding=target_embedding,\n+            **kwargs,\n+        )\n+        iou_token_out = point_embeddings[:, :, 1, :]\n+        mask_tokens_out = point_embeddings[:, :, 2 : (2 + self.num_mask_tokens), :]\n+\n+        # Upscale mask embeddings and predict masks using the mask tokens\n+        image_embeddings = image_embeddings.transpose(2, 3).view(\n+            batch_size * point_batch_size, num_channels, height, width\n+        )\n+\n+        feat_s0, feat_s1 = high_resolution_features\n+        feat_s0 = feat_s0.repeat_interleave(point_batch_size, dim=0)\n+        feat_s1 = feat_s1.repeat_interleave(point_batch_size, dim=0)\n+        upscaled_embedding = self.upscale_conv1(image_embeddings) + feat_s1\n+        upscaled_embedding = self.activation(self.upscale_layer_norm(upscaled_embedding))\n+        upscaled_embedding = self.activation(self.upscale_conv2(upscaled_embedding) + feat_s0)\n+\n+        hyper_in_list: list[torch.Tensor] = []\n+        for i in range(self.num_mask_tokens):\n+            current_mlp = self.output_hypernetworks_mlps[i]\n+            hyper_in_list += [current_mlp(mask_tokens_out[:, :, i, :])]\n+        hyper_in = torch.stack(hyper_in_list, dim=2)\n+\n+        _, num_channels, height, width = upscaled_embedding.shape\n+        upscaled_embedding = upscaled_embedding.view(batch_size, point_batch_size, num_channels, height * width)\n+        masks = (hyper_in @ upscaled_embedding).view(batch_size, point_batch_size, -1, height, width)\n+\n+        # Generate mask quality predictions\n+        iou_pred = self.iou_prediction_head(iou_token_out)\n+        object_score_logits = self.pred_obj_score_head(point_embeddings[:, :, 0, :])\n+\n+        # Select the correct mask or masks for output\n+        if multimask_output:\n+            mask_slice = slice(1, None)\n+            masks = masks[:, :, mask_slice, :, :]\n+            iou_pred = iou_pred[:, :, mask_slice]\n+        elif self.dynamic_multimask_via_stability and not self.training:\n+            mask_slice = slice(0, 1)\n+            masks, iou_pred = self._dynamic_multimask_via_stability(masks, iou_pred)\n+        else:\n+            mask_slice = slice(0, 1)\n+            masks = masks[:, :, mask_slice, :, :]\n+            iou_pred = iou_pred[:, :, mask_slice]\n+\n+        sam_tokens_out = mask_tokens_out[:, :, mask_slice]  # [b, 3, c] shape\n+\n+        return masks, iou_pred, sam_tokens_out, object_score_logits\n+\n+    def _get_stability_scores(self, mask_logits):\n+        \"\"\"\n+        Compute stability scores of the mask logits based on the IoU between upper and\n+        lower thresholds.\n+        \"\"\"\n+        mask_logits = mask_logits.flatten(-2)\n+        stability_delta = self.dynamic_multimask_stability_delta\n+        area_i = torch.sum(mask_logits > stability_delta, dim=-1).float()\n+        area_u = torch.sum(mask_logits > -stability_delta, dim=-1).float()\n+        stability_scores = torch.where(area_u > 0, area_i / area_u, 1.0)\n+        return stability_scores\n+\n+    def _dynamic_multimask_via_stability(self, all_mask_logits, all_iou_scores):\n+        \"\"\"\n+        When outputting a single mask, if the stability score from the current single-mask\n+        output (based on output token 0) falls below a threshold, we instead select from\n+        multi-mask outputs (based on output token 1~3) the mask with the highest predicted\n+        IoU score. This is intended to ensure a valid mask for both clicking and tracking.\n+        \"\"\"\n+        # The best mask from multimask output tokens (1~3)\n+        multimask_logits = all_mask_logits[:, :, 1:, :, :]\n+        multimask_iou_scores = all_iou_scores[:, :, 1:]\n+        best_scores_inds = torch.argmax(multimask_iou_scores, dim=-1)  # [B, P]\n+        best_scores_inds_expanded = best_scores_inds.unsqueeze(-1).unsqueeze(-1).unsqueeze(-1)\n+        best_scores_inds_expanded = best_scores_inds_expanded.expand(\n+            -1, -1, 1, multimask_logits.size(-2), multimask_logits.size(-1)\n+        )\n+        best_multimask_logits = torch.gather(multimask_logits, 2, best_scores_inds_expanded)  # [B, P, 1, H, W]\n+        best_multimask_iou_scores = torch.gather(multimask_iou_scores, 2, best_scores_inds.unsqueeze(-1))  # [B, P, 1]\n+\n+        # The mask from singlemask output token 0 and its stability score\n+        singlemask_logits = all_mask_logits[:, :, 0:1, :, :]\n+        singlemask_iou_scores = all_iou_scores[:, :, 0:1]\n+        stability_scores = self._get_stability_scores(singlemask_logits)\n+        is_stable = stability_scores >= self.dynamic_multimask_stability_thresh\n+\n+        # Dynamically fall back to best multimask output upon low stability scores.\n+        mask_logits_out = torch.where(\n+            is_stable[..., None, None].expand_as(singlemask_logits),\n+            singlemask_logits,\n+            best_multimask_logits,\n+        )\n+        iou_scores_out = torch.where(\n+            is_stable.expand_as(singlemask_iou_scores),\n+            singlemask_iou_scores,\n+            best_multimask_iou_scores,\n+        )\n+        return mask_logits_out, iou_scores_out\n+\n+\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    Segment Anything Model 2 (SAM 2) for generating segmentation masks, given an input image and\n+    input points and labels, boxes, or masks.\n+    \"\"\"\n+)\n+class EdgeTamModel(EdgeTamPreTrainedModel):\n+    _tied_weights_keys = [\"prompt_encoder.shared_embedding.positional_embedding\"]\n+    # need to be ignored, as it's a buffer and will not be correctly detected as tied weight\n+    _keys_to_ignore_on_load_missing = [\"prompt_encoder.shared_embedding.positional_embedding\"]\n+    _can_record_outputs = {\"mask_decoder_attentions\": OutputRecorder(EdgeTamTwoWayAttentionBlock, index=2)}\n+    _keys_to_ignore_on_load_unexpected = [\n+        r\"^memory_.*\",\n+        r\"^mask_downsample.*\",\n+        r\"spatial_perceiver.*\",\n+        r\"^object_pointer_proj.*\",\n+        r\"^temporal_positional_encoding_projection_layer.*\",\n+        \"no_memory_positional_encoding\",\n+        \"no_object_pointer\",\n+        \"occlusion_spatial_embedding_parameter\",\n+    ]\n+\n+    def __init__(self, config: EdgeTamConfig):\n+        super().__init__(config)\n+        self.shared_image_embedding = EdgeTamPositionalEmbedding(config.prompt_encoder_config)\n+        self.vision_encoder = AutoModel.from_config(config.vision_config)\n+        self.prompt_encoder = EdgeTamPromptEncoder(config.prompt_encoder_config)\n+        # The module using it is not a PreTrainedModel subclass so we need this\n+        config.mask_decoder_config._attn_implementation = config._attn_implementation\n+        self.mask_decoder = EdgeTamMaskDecoder(config.mask_decoder_config)\n+\n+        self.num_feature_levels = config.vision_config.num_feature_levels\n+        self.backbone_feature_sizes = config.vision_config.backbone_feature_sizes\n+        # a single token to indicate no memory embedding from previous frames\n+        self.hidden_dim = config.vision_config.fpn_hidden_size\n+        self.no_memory_embedding = torch.nn.Parameter(torch.zeros(1, 1, self.hidden_dim))\n+\n+        self.post_init()\n+\n+    def _tie_weights(self):\n+        self.prompt_encoder.shared_embedding.positional_embedding.data = (\n+            self.shared_image_embedding.positional_embedding.data\n+        )\n+\n+    def get_image_wide_positional_embeddings(self) -> torch.Tensor:\n+        size = self.prompt_encoder.image_embedding_size\n+        target_device = self.shared_image_embedding.positional_embedding.device\n+        target_dtype = self.shared_image_embedding.positional_embedding.dtype\n+        grid = torch.ones(size, device=target_device, dtype=target_dtype)\n+        y_embed = grid.cumsum(dim=0) - 0.5\n+        x_embed = grid.cumsum(dim=1) - 0.5\n+        y_embed = y_embed / size[0]\n+        x_embed = x_embed / size[1]\n+\n+        positional_embedding = self.shared_image_embedding(torch.stack([x_embed, y_embed], dim=-1))\n+        return positional_embedding.permute(2, 0, 1).unsqueeze(0)  # channel x height x width\n+\n+    @torch.no_grad()\n+    def get_image_embeddings(\n+        self,\n+        pixel_values: torch.FloatTensor,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> list[torch.Tensor]:\n+        r\"\"\"\n+        Returns the image embeddings by passing the pixel values through the vision encoder.\n+\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, height, width)`):\n+                Input pixel values\n+        \"\"\"\n+        batch_size = pixel_values.shape[0]\n+        feature_maps, _, _, _ = self.get_image_features(pixel_values, **kwargs)\n+\n+        # add no memory embedding to the last feature map\n+        feature_maps[-1] = feature_maps[-1] + self.no_memory_embedding\n+\n+        # reshape feature maps to the same shape as the backbone feature sizes\n+        image_embeddings = [\n+            feat.permute(1, 2, 0).view(batch_size, -1, *feat_size)\n+            for feat, feat_size in zip(feature_maps, self.backbone_feature_sizes)\n+        ]\n+\n+        return image_embeddings\n+\n+    @torch.no_grad()\n+    def get_prompt_embeddings(\n+        self,\n+        input_points: Optional[torch.FloatTensor] = None,\n+        input_labels: Optional[torch.LongTensor] = None,\n+        input_boxes: Optional[torch.FloatTensor] = None,\n+        input_masks: Optional[torch.LongTensor] = None,\n+    ):\n+        r\"\"\"\n+        Returns the prompt embeddings by passing the input points, labels, boxes and masks through the prompt encoder.\n+\n+        Args:\n+            input_points (`torch.FloatTensor` of shape `(batch_size, point_batch_size, num_points_per_image, 2)`):\n+                Optional input points for the prompt encoder. The padding of the point is automatically done by the\n+                processor. `point_batch_size` refers to the number of masks that we want the model to predict per\n+                point. The model will output `point_batch_size` times 3 masks in total.\n+            input_labels (`torch.LongTensor` of shape `(batch_size, point_batch_size, num_points_per_image)`):\n+                Optional input labels for the prompt encoder. The padding of the labels is automatically done by the\n+                processor, or can be fed by the user.\n+            input_boxes (`torch.FloatTensor` of shape `(batch_size, num_boxes_per_image, 4)`):\n+                Optional input boxes for the prompt encoder. The padding of the boxes is automatically done by the\n+                processor. users can also pass manually the input boxes.\n+            input_masks (`torch.LongTensor` of shape `(batch_size, image_size, image_size)`):\n+                Optional input masks for the prompt encoder.\n+        \"\"\"\n+        prompt_output = self.prompt_encoder(\n+            input_points=input_points,\n+            input_labels=input_labels,\n+            input_boxes=input_boxes,\n+            input_masks=input_masks,\n+        )\n+        return prompt_output\n+\n+    @check_model_inputs\n+    @auto_docstring\n+    def forward(\n+        self,\n+        pixel_values: Optional[torch.FloatTensor] = None,\n+        input_points: Optional[torch.FloatTensor] = None,\n+        input_labels: Optional[torch.LongTensor] = None,\n+        input_boxes: Optional[torch.FloatTensor] = None,\n+        input_masks: Optional[torch.LongTensor] = None,\n+        image_embeddings: Optional[torch.FloatTensor] = None,\n+        multimask_output: bool = True,\n+        attention_similarity: Optional[torch.FloatTensor] = None,\n+        target_embedding: Optional[torch.FloatTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> EdgeTamImageSegmentationOutput:\n+        r\"\"\"\n+        input_points (`torch.FloatTensor` of shape `(batch_size, num_points, 2)`):\n+            Input 2D spatial points, this is used by the prompt encoder to encode the prompt. Generally yields to much\n+            better results. The points can be obtained by passing a list of list of list to the processor that will\n+            create corresponding `torch` tensors of dimension 4. The first dimension is the image batch size, the\n+            second dimension is the point batch size (i.e. how many segmentation masks do we want the model to predict\n+            per input point), the third dimension is the number of points per segmentation mask (it is possible to pass\n+            multiple points for a single mask), and the last dimension is the x (vertical) and y (horizontal)\n+            coordinates of the point. If a different number of points is passed either for each image, or for each\n+            mask, the processor will create \"PAD\" points that will correspond to the (0, 0) coordinate, and the\n+            computation of the embedding will be skipped for these points using the labels.\n+        input_labels (`torch.LongTensor` of shape `(batch_size, point_batch_size, num_points)`):\n+            Input labels for the points, this is used by the prompt encoder to encode the prompt. According to the\n+            official implementation, there are 3 types of labels\n+\n+            - `1`: the point is a point that contains the object of interest\n+            - `0`: the point is a point that does not contain the object of interest\n+            - `-1`: the point corresponds to the background\n+\n+            We added the label:\n+\n+            - `-10`: the point is a padding point, thus should be ignored by the prompt encoder\n+\n+            The padding labels should be automatically done by the processor.\n+        input_boxes (`torch.FloatTensor` of shape `(batch_size, num_boxes, 4)`):\n+            Input boxes for the points, this is used by the prompt encoder to encode the prompt. Generally yields to\n+            much better generated masks. The boxes can be obtained by passing a list of list of list to the processor,\n+            that will generate a `torch` tensor, with each dimension corresponding respectively to the image batch\n+            size, the number of boxes per image and the coordinates of the top left and bottom right point of the box.\n+            In the order (`x1`, `y1`, `x2`, `y2`):\n+\n+            - `x1`: the x coordinate of the top left point of the input box\n+            - `y1`: the y coordinate of the top left point of the input box\n+            - `x2`: the x coordinate of the bottom right point of the input box\n+            - `y2`: the y coordinate of the bottom right point of the input box\n+        input_masks (`torch.FloatTensor` of shape `(batch_size, image_size, image_size)`):\n+            SAM model also accepts segmentation masks as input. The mask will be embedded by the prompt encoder to\n+            generate a corresponding embedding, that will be fed later on to the mask decoder. These masks needs to be\n+            manually fed by the user, and they need to be of shape (`batch_size`, `image_size`, `image_size`).\n+        image_embeddings (`torch.FloatTensor` of shape `(batch_size, output_channels, window_size, window_size)`):\n+            Image embeddings, this is used by the mask decoder to generate masks and iou scores. For more memory\n+            efficient computation, users can first retrieve the image embeddings using the `get_image_embeddings`\n+            method, and then feed them to the `forward` method instead of feeding the `pixel_values`.\n+        multimask_output (`bool`, *optional*):\n+            In the original implementation and paper, the model always outputs 3 masks per image (or per point / per\n+            bounding box if relevant). However, it is possible to just output a single mask, that corresponds to the\n+            \"best\" mask, by specifying `multimask_output=False`.\n+        attention_similarity (`torch.FloatTensor`, *optional*):\n+            Attention similarity tensor, to be provided to the mask decoder for target-guided attention in case the\n+            model is used for personalization as introduced in [PerSAM](https://huggingface.co/papers/2305.03048).\n+        target_embedding (`torch.FloatTensor`, *optional*):\n+            Embedding of the target concept, to be provided to the mask decoder for target-semantic prompting in case\n+            the model is used for personalization as introduced in [PerSAM](https://huggingface.co/papers/2305.03048).\n+\n+        Example:\n+\n+        ```python\n+        >>> from PIL import Image\n+        >>> import requests\n+        >>> from transformers import AutoModel, AutoProcessor\n+\n+        >>> model = AutoModel.from_pretrained(\"danelcsb/edgetam.1_hiera_tiny\")\n+        >>> processor = AutoProcessor.from_pretrained(\"danelcsb/edgetam.1_hiera_tiny\")\n+\n+        >>> img_url = \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/model_doc/sam-car.png\"\n+        >>> raw_image = Image.open(requests.get(img_url, stream=True).raw).convert(\"RGB\")\n+        >>> input_points = [[[400, 650]]]  # 2D location of a window on the car\n+        >>> inputs = processor(images=raw_image, input_points=input_points, return_tensors=\"pt\")\n+\n+        >>> # Get segmentation mask\n+        >>> outputs = model(**inputs)\n+\n+        >>> # Postprocess masks\n+        >>> masks = processor.post_process_masks(\n+        ...     outputs.pred_masks, inputs[\"original_sizes\"], inputs[\"reshaped_input_sizes\"]\n+        ... )\n+        ```\n+        \"\"\"\n+        if not ((pixel_values is None) ^ (image_embeddings is None)):\n+            raise ValueError(\"Exactly one of pixel_values or image_embeddings must be provided.\")\n+        if input_points is not None and input_boxes is not None:\n+            if input_points.shape[1] != input_boxes.shape[1]:\n+                raise ValueError(\n+                    f\"You should provide as many bounding boxes as input points per box. Got {input_points.shape[1]} and {input_boxes.shape[1]}.\"\n+                )\n+\n+        image_positional_embeddings = self.get_image_wide_positional_embeddings()\n+        # repeat with batch size\n+        batch_size = pixel_values.shape[0] if pixel_values is not None else image_embeddings[-1].shape[0]\n+        image_positional_embeddings = image_positional_embeddings.repeat(batch_size, 1, 1, 1)\n+\n+        vision_attentions = None\n+        vision_hidden_states = None\n+\n+        if pixel_values is not None:\n+            feature_maps, _, vision_hidden_states, vision_attentions = self.get_image_features(\n+                pixel_values,\n+                **kwargs,\n+            )\n+\n+            # add no memory embedding to the last feature map\n+            feature_maps[-1] = feature_maps[-1] + self.no_memory_embedding\n+\n+            # reshape feature maps to the same shape as the backbone feature sizes\n+            image_embeddings = [\n+                feat.permute(1, 2, 0).view(batch_size, -1, *feat_size)\n+                for feat, feat_size in zip(feature_maps, self.backbone_feature_sizes)\n+            ]\n+\n+        if input_points is not None and input_labels is None:\n+            input_labels = torch.ones_like(input_points[:, :, :, 0], dtype=torch.int, device=input_points.device)\n+\n+        if input_points is None and input_boxes is None:\n+            # If no points are provide, pad with an empty point (with label -1)\n+            input_points = torch.zeros(\n+                batch_size, 1, 1, 2, dtype=image_embeddings[-1].dtype, device=image_embeddings[-1].device\n+            )\n+            input_labels = -torch.ones(batch_size, 1, 1, dtype=torch.int32, device=image_embeddings[-1].device)\n+\n+        if input_masks is not None:\n+            # If mask_inputs is provided, downsize it into low-res mask input if needed\n+            # and feed it as a dense mask prompt into the SAM mask encoder\n+            if input_masks.shape[-2:] != self.prompt_encoder.mask_input_size:\n+                input_masks = F.interpolate(\n+                    input_masks.float(),\n+                    size=self.prompt_encoder.mask_input_size,\n+                    align_corners=False,\n+                    mode=\"bilinear\",\n+                    antialias=True,  # use antialias for downsampling\n+                ).to(input_masks.dtype)\n+\n+        sparse_embeddings, dense_embeddings = self.prompt_encoder(\n+            input_points=input_points,\n+            input_labels=input_labels,\n+            input_boxes=input_boxes,\n+            input_masks=input_masks,\n+        )\n+        low_res_multimasks, iou_scores, _, object_score_logits = self.mask_decoder(\n+            image_embeddings=image_embeddings[-1],\n+            image_positional_embeddings=image_positional_embeddings,\n+            sparse_prompt_embeddings=sparse_embeddings,\n+            dense_prompt_embeddings=dense_embeddings,\n+            multimask_output=multimask_output,\n+            high_resolution_features=image_embeddings[:-1],\n+            attention_similarity=attention_similarity,\n+            target_embedding=target_embedding,\n+            **kwargs,\n+        )\n+\n+        return EdgeTamImageSegmentationOutput(\n+            iou_scores=iou_scores,\n+            pred_masks=low_res_multimasks,\n+            object_score_logits=object_score_logits,\n+            image_embeddings=image_embeddings,\n+            vision_hidden_states=vision_hidden_states,\n+            vision_attentions=vision_attentions,\n+        )\n+\n+    def get_image_features(\n+        self,\n+        pixel_values: torch.FloatTensor,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[\n+        list[torch.Tensor],\n+        list[torch.Tensor],\n+        Optional[tuple[torch.FloatTensor, ...]],\n+        Optional[tuple[torch.FloatTensor, ...]],\n+    ]:\n+        r\"\"\"\n+        Extract and preprocess image features using the vision encoder.\n+\n+        Args:\n+            pixel_values (`torch.FloatTensor`):\n+                Input pixel values of shape `(batch_size, num_channels, height, width)`.\n+\n+        Returns:\n+            `tuple`: A tuple containing:\n+                - feature_maps (`list[torch.Tensor]`): List of feature maps from different levels.\n+                - feature_maps_position_embeddings (`list[torch.Tensor]`): List of positional embeddings for each feature level.\n+                - vision_hidden_states (`tuple[torch.FloatTensor]`, *optional*): Hidden states from the vision encoder.\n+                - vision_attentions (`tuple[torch.FloatTensor]`, *optional*): Attention weights from the vision encoder.\n+        \"\"\"\n+        vision_outputs: EdgeTamVisionEncoderOutput = self.vision_encoder(\n+            pixel_values,\n+            **kwargs,\n+        )\n+\n+        feature_maps = vision_outputs.fpn_hidden_states\n+        feature_maps_position_embeddings = vision_outputs.fpn_position_encoding\n+\n+        # precompute projected level 0 and level 1 features in SAM decoder\n+        # to avoid running it again on every SAM click\n+        feature_maps = list(feature_maps)\n+        feature_maps[0] = self.mask_decoder.conv_s0(feature_maps[0])\n+        feature_maps[1] = self.mask_decoder.conv_s1(feature_maps[1])\n+\n+        # flatten NxCxHxW to HWxNxC\n+        feature_maps = [feature_map.flatten(2).permute(2, 0, 1) for feature_map in feature_maps]\n+        feature_maps_position_embeddings = [\n+            feature_map_position_embedding.flatten(2).permute(2, 0, 1)\n+            for feature_map_position_embedding in feature_maps_position_embeddings\n+        ]\n+\n+        return feature_maps, feature_maps_position_embeddings, vision_outputs.hidden_states, vision_outputs.attentions\n+\n+\n+__all__ = [\"EdgeTamModel\", \"EdgeTamVisionModel\", \"EdgeTamPreTrainedModel\"]"
        },
        {
            "sha": "e26d58d96b812e56e0befdcef05de612c5cdce41",
            "filename": "src/transformers/models/edgetam/modular_edgetam.py",
            "status": "added",
            "additions": 261,
            "deletions": 0,
            "changes": 261,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam%2Fmodular_edgetam.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam%2Fmodular_edgetam.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fedgetam%2Fmodular_edgetam.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,261 @@\n+# coding=utf-8\n+# Copyright 2025 The Meta AI Authors and The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch SAM 2 model.\"\"\"\n+\n+from typing import Optional, Union\n+\n+import torch\n+import torch.nn as nn\n+import torch.utils.checkpoint\n+\n+from transformers.models.sam2.configuration_sam2 import Sam2Config, Sam2MaskDecoderConfig, Sam2PromptEncoderConfig\n+from transformers.models.sam2.modeling_sam2 import (\n+    Sam2Attention,\n+    Sam2FeedForward,\n+    Sam2LayerNorm,\n+    Sam2Model,\n+    Sam2PreTrainedModel,\n+    Sam2TwoWayAttentionBlock,\n+    Sam2VisionEncoderOutput,\n+    Sam2VisionModel,\n+)\n+from transformers.utils.generic import TransformersKwargs, check_model_inputs\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...processing_utils import Unpack\n+from ...utils import (\n+    auto_docstring,\n+)\n+from ..auto import CONFIG_MAPPING, AutoConfig\n+\n+\n+# fix this in modular\n+if True:\n+    from transformers.models.timm_wrapper.modeling_timm_wrapper import TimmWrapperModel\n+\n+\n+class EdgeTamVisionConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`EdgeTamVisionModel`]. It is used to instantiate a SAM\n+    vision encoder according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    defaults will yield a similar configuration to that of SAM 2.1 Hiera-tiny\n+    [facebook/EdgeTAM](https://huggingface.co/facebook/EdgeTAM) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        backbone_config (`Union[dict, \"PretrainedConfig\"]`, *optional*):\n+            Configuration for the vision backbone. This is used to instantiate the backbone using\n+            `AutoModel.from_config`.\n+        backbone_channel_list (`List[int]`, *optional*, defaults to `[384, 192, 96, 48]`):\n+            The list of channel dimensions for the backbone.\n+        backbone_feature_sizes (`List[List[int]]`, *optional*, defaults to `[[256, 256], [128, 128], [64, 64]]`):\n+            The spatial sizes of the feature maps from the backbone.\n+        fpn_hidden_size (`int`, *optional*, defaults to 256):\n+            The hidden dimension of the FPN.\n+        fpn_kernel_size (`int`, *optional*, defaults to 1):\n+            The kernel size for the convolutions in the neck.\n+        fpn_stride (`int`, *optional*, defaults to 1):\n+            The stride for the convolutions in the neck.\n+        fpn_padding (`int`, *optional*, defaults to 0):\n+            The padding for the convolutions in the neck.\n+        fpn_top_down_levels (`List[int]`, *optional*, defaults to `[2, 3]`):\n+            The levels for the top-down FPN connections.\n+        num_feature_levels (`int`, *optional*, defaults to 3):\n+            The number of feature levels from the FPN to use.\n+        hidden_act (`str`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function in the neck.\n+        layer_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon for the layer normalization.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+\n+    \"\"\"\n+\n+    base_config_key = \"vision_config\"\n+    model_type = \"edgetam_vision_model\"\n+    sub_configs = {\n+        \"backbone_config\": AutoConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        backbone_config=None,\n+        backbone_channel_list=None,\n+        backbone_feature_sizes=None,\n+        fpn_hidden_size=256,\n+        fpn_kernel_size=1,\n+        fpn_stride=1,\n+        fpn_padding=0,\n+        fpn_top_down_levels=None,\n+        num_feature_levels=3,\n+        hidden_act=\"gelu\",\n+        layer_norm_eps=1e-6,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        backbone_channel_list = [384, 192, 96, 48] if backbone_channel_list is None else backbone_channel_list\n+        backbone_feature_sizes = (\n+            [[256, 256], [128, 128], [64, 64]] if backbone_feature_sizes is None else backbone_feature_sizes\n+        )\n+        fpn_top_down_levels = [2, 3] if fpn_top_down_levels is None else fpn_top_down_levels\n+\n+        if isinstance(backbone_config, dict):\n+            backbone_config[\"model_type\"] = backbone_config.get(\"model_type\", \"timm_wrapper\")\n+            backbone_config = CONFIG_MAPPING[backbone_config[\"model_type\"]](**backbone_config)\n+        elif isinstance(backbone_config, AutoConfig):\n+            backbone_config = backbone_config\n+        elif backbone_config is None:\n+            backbone_config = AutoConfig.from_pretrained(\n+                \"timm/repvit_m1.dist_in1k\",\n+                model_args={\"in_chans\": 3, \"features_only\": True, \"out_indices\": [0, 1, 2, 3]},\n+            )\n+\n+        self.backbone_config = backbone_config\n+\n+        # Neck\n+        self.backbone_channel_list = backbone_channel_list\n+        self.backbone_feature_sizes = backbone_feature_sizes\n+        self.fpn_hidden_size = fpn_hidden_size\n+        self.fpn_kernel_size = fpn_kernel_size\n+        self.fpn_stride = fpn_stride\n+        self.fpn_padding = fpn_padding\n+        self.fpn_top_down_levels = fpn_top_down_levels\n+        self.num_feature_levels = num_feature_levels\n+\n+        self.hidden_act = hidden_act\n+        self.layer_norm_eps = layer_norm_eps\n+        self.initializer_range = initializer_range\n+\n+\n+class EdgeTamPromptEncoderConfig(Sam2PromptEncoderConfig):\n+    pass\n+\n+\n+class EdgeTamMaskDecoderConfig(Sam2MaskDecoderConfig):\n+    pass\n+\n+\n+class EdgeTamConfig(Sam2Config):\n+    pass\n+\n+\n+class EdgeTamLayerNorm(Sam2LayerNorm):\n+    pass\n+\n+\n+class EdgeTamVisionEncoderOutput(Sam2VisionEncoderOutput):\n+    pass\n+\n+\n+class EdgeTamAttention(Sam2Attention):\n+    pass\n+\n+\n+class EdgeTamTwoWayAttentionBlock(Sam2TwoWayAttentionBlock):\n+    pass\n+\n+\n+class EdgeTamFeedForward(Sam2FeedForward):\n+    pass\n+\n+\n+@auto_docstring\n+class EdgeTamPreTrainedModel(Sam2PreTrainedModel):\n+    def _init_weights(self, module):\n+        std = self.config.initializer_range\n+        if isinstance(module, (nn.Linear, nn.Conv2d, nn.ConvTranspose2d)):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+        elif isinstance(module, (nn.LayerNorm, EdgeTamLayerNorm)):\n+            module.weight.data.fill_(1.0)\n+            module.bias.data.zero_()\n+        if isinstance(module, EdgeTamModel):\n+            if module.no_memory_embedding is not None:\n+                module.no_memory_embedding.data.zero_()\n+\n+\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    The vision model from EdgeTAM without any head or projection on top.\n+    \"\"\"\n+)\n+class EdgeTamVisionModel(Sam2VisionModel):\n+    config_class = EdgeTamVisionConfig\n+    main_input_name = \"pixel_values\"\n+    _can_record_outputs = {\"hidden_states\": TimmWrapperModel, \"attentions\": TimmWrapperModel}\n+\n+    def get_input_embeddings(self):\n+        raise NotImplementedError(\"Can't get input embeddings from timm wrapper model\")\n+\n+    @check_model_inputs\n+    def forward(\n+        self,\n+        pixel_values: Optional[torch.FloatTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, EdgeTamVisionEncoderOutput]:\n+        if pixel_values is None:\n+            raise ValueError(\"You have to specify pixel_values\")\n+\n+        # Forward through backbone\n+        backbone_output = self.backbone(pixel_values)\n+        intermediate_hidden_states = backbone_output.last_hidden_state\n+        intermediate_hidden_states = [hidden_state.permute(0, 2, 3, 1) for hidden_state in intermediate_hidden_states]\n+\n+        fpn_hidden_states, fpn_position_encoding = self.neck(intermediate_hidden_states)\n+        # Select last `num_feature_levels` feature levels from FPN and reverse order to get features from high to low resolution\n+        fpn_hidden_states = fpn_hidden_states[-self.num_feature_levels :][::-1]\n+        fpn_position_encoding = fpn_position_encoding[-self.num_feature_levels :][::-1]\n+\n+        return EdgeTamVisionEncoderOutput(\n+            last_hidden_state=intermediate_hidden_states[-1],\n+            fpn_hidden_states=fpn_hidden_states,\n+            fpn_position_encoding=fpn_position_encoding,\n+        )\n+\n+\n+class EdgeTamModel(Sam2Model):\n+    _keys_to_ignore_on_load_unexpected = [\n+        r\"^memory_.*\",\n+        r\"^mask_downsample.*\",\n+        r\"spatial_perceiver.*\",\n+        r\"^object_pointer_proj.*\",\n+        r\"^temporal_positional_encoding_projection_layer.*\",\n+        \"no_memory_positional_encoding\",\n+        \"no_object_pointer\",\n+        \"occlusion_spatial_embedding_parameter\",\n+    ]\n+\n+    def get_input_embeddings(self):\n+        raise NotImplementedError(\"Can't get input embeddings from timm wrapper model\")\n+\n+\n+__all__ = [\n+    \"EdgeTamModel\",\n+    \"EdgeTamVisionModel\",\n+    \"EdgeTamPreTrainedModel\",\n+    \"EdgeTamConfig\",\n+    \"EdgeTamVisionConfig\",\n+    \"EdgeTamPromptEncoderConfig\",\n+    \"EdgeTamMaskDecoderConfig\",\n+]"
        },
        {
            "sha": "669dd64ec3044b4689c8a15bfd55ff0749675820",
            "filename": "src/transformers/models/edgetam_video/__init__.py",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam_video%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam_video%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fedgetam_video%2F__init__.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,29 @@\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_edgetam_video import *\n+    from .modeling_edgetam_video import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "954864397dcbe63c1d95bb5c60586b5fbedcaabc",
            "filename": "src/transformers/models/edgetam_video/configuration_edgetam_video.py",
            "status": "added",
            "additions": 435,
            "deletions": 0,
            "changes": 435,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam_video%2Fconfiguration_edgetam_video.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam_video%2Fconfiguration_edgetam_video.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fedgetam_video%2Fconfiguration_edgetam_video.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,435 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/edgetam_video/modular_edgetam_video.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_edgetam_video.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from ...configuration_utils import PretrainedConfig\n+from ..auto import CONFIG_MAPPING, AutoConfig\n+\n+\n+class EdgeTamVideoPromptEncoderConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`EdgeTamVideoPromptEncoder`]. The [`EdgeTamVideoPromptEncoder`]\n+    module is used to encode the input 2D points and bounding boxes.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 256):\n+            Dimensionality of the hidden states.\n+        image_size (`int`, *optional*, defaults to 1024):\n+            The expected output resolution of the image.\n+        patch_size (`int`, *optional*, defaults to 16):\n+            The size (resolution) of each patch.\n+        mask_input_channels (`int`, *optional*, defaults to 16):\n+            The number of channels to be fed to the `MaskDecoder` module.\n+        num_point_embeddings (`int`, *optional*, defaults to 4):\n+            The number of point embeddings to be used.\n+        hidden_act (`str`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function in the encoder and pooler.\n+        layer_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the layer normalization layers.\n+        scale (`float`, *optional*, defaults to 1):\n+            The scale factor for the prompt encoder.\n+    \"\"\"\n+\n+    base_config_key = \"prompt_encoder_config\"\n+\n+    def __init__(\n+        self,\n+        hidden_size=256,\n+        image_size=1024,\n+        patch_size=16,\n+        mask_input_channels=16,\n+        num_point_embeddings=4,\n+        hidden_act=\"gelu\",\n+        layer_norm_eps=1e-6,\n+        scale=1,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        self.hidden_size = hidden_size\n+        self.image_size = image_size\n+        self.patch_size = patch_size\n+        self.mask_input_channels = mask_input_channels\n+        self.num_point_embeddings = num_point_embeddings\n+        self.hidden_act = hidden_act\n+        self.layer_norm_eps = layer_norm_eps\n+        self.scale = scale\n+\n+\n+class EdgeTamVideoMaskDecoderConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`EdgeTamVideoMaskDecoder`]. It is used to instantiate a EDGETAM_VIDEO\n+    memory encoder according to the specified arguments, defining the model architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 256):\n+            Dimensionality of the hidden states.\n+        hidden_act (`str`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function in the EDGETAM_VIDEO mask decoder.\n+        mlp_dim (`int`, *optional*, defaults to 2048):\n+            The dimension of the MLP in the two-way transformer.\n+        num_hidden_layers (`int`, *optional*, defaults to 2):\n+            The number of hidden layers in the two-way transformer.\n+        num_attention_heads (`int`, *optional*, defaults to 8):\n+            The number of attention heads in the two-way transformer.\n+        attention_downsample_rate (`int`, *optional*, defaults to 2):\n+            The downsample rate for the attention layers.\n+        num_multimask_outputs (`int`, *optional*, defaults to 3):\n+            The number of multimask outputs.\n+        iou_head_depth (`int`, *optional*, defaults to 3):\n+            The depth of the IoU head.\n+        iou_head_hidden_dim (`int`, *optional*, defaults to 256):\n+            The hidden dimension of the IoU head.\n+        dynamic_multimask_via_stability (`bool`, *optional*, defaults to `True`):\n+            Whether to use dynamic multimask via stability.\n+        dynamic_multimask_stability_delta (`float`, *optional*, defaults to 0.05):\n+            The stability delta for the dynamic multimask.\n+        dynamic_multimask_stability_thresh (`float`, *optional*, defaults to 0.98):\n+            The stability threshold for the dynamic multimask.\n+\n+    \"\"\"\n+\n+    base_config_key = \"mask_decoder_config\"\n+\n+    def __init__(\n+        self,\n+        hidden_size=256,\n+        hidden_act=\"gelu\",\n+        mlp_dim=2048,\n+        num_hidden_layers=2,\n+        num_attention_heads=8,\n+        attention_downsample_rate=2,\n+        num_multimask_outputs=3,\n+        iou_head_depth=3,\n+        iou_head_hidden_dim=256,\n+        dynamic_multimask_via_stability=True,\n+        dynamic_multimask_stability_delta=0.05,\n+        dynamic_multimask_stability_thresh=0.98,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.hidden_size = hidden_size\n+        self.num_multimask_outputs = num_multimask_outputs\n+        self.hidden_act = hidden_act\n+        self.iou_head_depth = iou_head_depth\n+        self.iou_head_hidden_dim = iou_head_hidden_dim\n+        self.dynamic_multimask_via_stability = dynamic_multimask_via_stability\n+        self.dynamic_multimask_stability_delta = dynamic_multimask_stability_delta\n+        self.dynamic_multimask_stability_thresh = dynamic_multimask_stability_thresh\n+\n+        # TwoWayTransformer configuration\n+        self.num_hidden_layers = num_hidden_layers\n+        self.hidden_size = hidden_size\n+        self.num_attention_heads = num_attention_heads\n+        self.mlp_dim = mlp_dim\n+        self.attention_downsample_rate = attention_downsample_rate\n+\n+\n+class EdgeTamVideoConfig(PretrainedConfig):\n+    r\"\"\"\n+    [`EdgeTamVideoConfig`] is the configuration class to store the configuration of a [`EdgeTamVideoModel`]. It is used to instantiate a\n+    EDGETAM model according to the specified arguments, defining the memory attention, memory encoder, and image encoder\n+    configs. Instantiating a configuration defaults will yield a similar configuration to that of the SAM 2.1 Hiera-tiny\n+    [facebook/EdgeTAM](https://huggingface.co/facebook/EdgeTAM) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vision_config (Union[`dict`, `EdgeTamVideoVisionConfig`], *optional*):\n+            Dictionary of configuration options used to initialize [`EdgeTamVideoVisionConfig`].\n+        prompt_encoder_config (Union[`dict`, `EdgeTamVideoPromptEncoderConfig`], *optional*):\n+            Dictionary of configuration options used to initialize [`EdgeTamVideoPromptEncoderConfig`].\n+        mask_decoder_config (Union[`dict`, `EdgeTamVideoMaskDecoderConfig`], *optional*):\n+            Dictionary of configuration options used to initialize [`EdgeTamMaskDecoderConfig`].\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            Standard deviation for parameter initialization.\n+        num_maskmem (`int`, *optional*, defaults to 7):\n+            The number of memory slots for the mask memory.\n+        image_size (`int`, *optional*, defaults to 1024):\n+            The size of the input images.\n+        sigmoid_scale_for_mem_enc (`float`, *optional*, defaults to 20.0):\n+            Scale factor for the sigmoid function in the memory encoder.\n+        sigmoid_bias_for_mem_enc (`float`, *optional*, defaults to -10.0):\n+            Bias for the sigmoid function in the memory encoder.\n+        enable_occlusion_spatial_embedding (`bool`, *optional*, defaults to `True`):\n+            Whether to enable spatial embedding for occlusions.\n+        multimask_output_in_sam (`bool`, *optional*, defaults to `True`):\n+            Whether to output multiple masks from the SAM head.\n+        multimask_min_pt_num (`int`, *optional*, defaults to 0):\n+            The minimum number of points to trigger multimask output.\n+        multimask_max_pt_num (`int`, *optional*, defaults to 1):\n+            The maximum number of points to trigger multimask output.\n+        multimask_output_for_tracking (`bool`, *optional*, defaults to `True`):\n+            Whether to use multimask output for tracking.\n+        max_object_pointers_in_encoder (`int`, *optional*, defaults to 16):\n+            The maximum number of object pointers in the encoder.\n+        enable_temporal_pos_encoding_for_object_pointers (`bool`, *optional*, defaults to `True`):\n+            Whether to enable temporal positional encoding for object pointers.\n+        memory_attention_hidden_size (`int`, *optional*, defaults to 256):\n+            Dimensionality of the memory attention hidden states.\n+        memory_attention_num_layers (`int`, *optional*, defaults to 2):\n+            The number of layers in the memory attention module.\n+        memory_attention_num_attention_heads (`int`, *optional*, defaults to 1):\n+            Number of attention heads for each attention layer in the memory attention.\n+        memory_attention_downsample_rate (`int`, *optional*, defaults to 1):\n+            The downsample rate for the attention layers.\n+        memory_attention_mlp_hidden_size (`int`, *optional*, defaults to 2048):\n+            The dimension of the feedforward network in the memory attention module.\n+        memory_attention_mlp_hidden_act (`str`, *optional*, defaults to `\"relu\"`):\n+            The non-linear activation function in the feedforward network in the memory attention module.\n+        memory_attention_dropout (`float`, *optional*, defaults to 0.1):\n+            The dropout rate for the memory attention module.\n+        memory_attention_rope_theta (`float`, *optional*, defaults to 10000):\n+            The Rope theta parameter.\n+        memory_attention_rope_feat_sizes (`Tuple[int, int]`, *optional*, defaults to `[64, 64]`):\n+            The feature sizes for the Rope positional encoding.\n+        memory_attention_rope_k_sizes (`List[int]`, *optional*, defaults to `[16, 16]`):\n+            The key feature sizes for the RoPE positional encoding in memory attention.\n+        memory_attention_rope_dropout (`float`, *optional*, defaults to 0.1):\n+            The dropout rate for the Rope positional encoding.\n+        perceiver_resampler_num_latents (`int`, *optional*, defaults to 256):\n+            The number of 1D latent tokens in the perceiver resampler.\n+        perceiver_resampler_num_latents_2d (`int`, *optional*, defaults to 256):\n+            The number of 2D latent tokens in the perceiver resampler.\n+        perceiver_resampler_hidden_size (`int`, *optional*, defaults to 64):\n+            The hidden size of the perceiver resampler.\n+        perceiver_resampler_mlp_intermediate_size (`int`, *optional*, defaults to 256):\n+            The intermediate size of the feedforward network in the perceiver resampler.\n+        perceiver_resampler_num_attention_heads (`int`, *optional*, defaults to 1):\n+            The number of attention heads in the perceiver resampler.\n+        perceiver_resampler_attention_head_dim (`int`, *optional*, defaults to 64):\n+            The dimension of each attention head in the perceiver resampler.\n+        perceiver_resampler_num_layers (`int`, *optional*, defaults to 2):\n+            The number of layers in the perceiver resampler.\n+        perceiver_resampler_hidden_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout rate for the hidden layers in the perceiver resampler.\n+        perceiver_resampler_attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout rate for the attention layers in the perceiver resampler.\n+        memory_encoder_hidden_size (`int`, *optional*, defaults to 256):\n+            Dimensionality of the memory encoder hidden states.\n+        memory_encoder_output_channels (`int`, *optional*, defaults to 64):\n+            The number of output channels for the memory encoder.\n+        mask_downsampler_embed_dim (`int`, *optional*, defaults to 256):\n+            The dimension of the mask downsampler embedding.\n+        memory_fuser_intermediate_dim (`int`, *optional*, defaults to 1024):\n+            The intermediate dimension of the memory fuser feedforward network.\n+        mask_downsampler_kernel_size (`int`, *optional*, defaults to 3):\n+            The kernel size for the mask downsampler.\n+        mask_downsampler_stride (`int`, *optional*, defaults to 2):\n+            The stride for the mask downsampler.\n+        mask_downsampler_padding (`int`, *optional*, defaults to 1):\n+            The padding for the mask downsampler.\n+        mask_downsampler_total_stride (`int`, *optional*, defaults to 16):\n+            The total stride for the mask downsampler.\n+        mask_downsampler_hidden_act (`str`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function in the mask downsampler.\n+        memory_fuser_num_layers (`int`, *optional*, defaults to 2):\n+            The number of layers in the memory fuser.\n+        memory_fuser_embed_dim (`int`, *optional*, defaults to 256):\n+            The dimension of the memory fuser embedding.\n+        memory_fuser_kernel_size (`int`, *optional*, defaults to 7):\n+            The kernel size for the memory fuser.\n+        memory_fuser_padding (`int`, *optional*, defaults to 3):\n+            The padding for the memory fuser.\n+        memory_fuser_layer_scale_init_value (`float`, *optional*, defaults to 1e-06):\n+            The initial value for the layer scale in the memory fuser.\n+        memory_fuser_hidden_act (`str`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function in the memory fuser.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import (\n+    ...     EdgeTamVisionConfig,\n+    ...     EdgeTamVideoPromptEncoderConfig,\n+    ...     EdgeTamVideoMaskDecoderConfig,\n+    ...     EdgeTamVideoModel,\n+    ...     EdgeTamVideoConfig,\n+    ... )\n+\n+    >>> # Initializing a EdgeTamVideoConfig with `\"facebook/edgetam.1_hiera_tiny\"` style configuration\n+    >>> configuration = EdgeTamVideoConfig()\n+\n+    >>> # Initializing a EdgeTamVideoModel (with random weights) from the `\"facebook/edgetam.1_hiera_tiny\"` style configuration\n+    >>> model = EdgeTamVideoModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+\n+    >>> # We can also initialize a EdgeTamConfig from a EdgeTamVisionConfig, EdgeTamPromptEncoderConfig, and EdgeTamMaskDecoderConfig\n+\n+    >>> # Initializing EDGETAM vision encoder, memory attention, and memory encoder configurations\n+    >>> vision_config = EdgeTamVisionConfig()\n+    >>> prompt_encoder_config = EdgeTamVideoPromptEncoderConfig()\n+    >>> mask_decoder_config = EdgeTamVideoMaskDecoderConfig()\n+\n+    >>> config = EdgeTamVideoConfig(vision_config, prompt_encoder_config, mask_decoder_config)\n+    ```\"\"\"\n+\n+    model_type = \"edgetam_video\"\n+    sub_configs = {\n+        \"vision_config\": AutoConfig,\n+        \"prompt_encoder_config\": EdgeTamVideoPromptEncoderConfig,\n+        \"mask_decoder_config\": EdgeTamVideoMaskDecoderConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        vision_config=None,\n+        prompt_encoder_config=None,\n+        mask_decoder_config=None,\n+        initializer_range=0.02,\n+        num_maskmem=7,\n+        image_size=1024,\n+        sigmoid_scale_for_mem_enc=20.0,\n+        sigmoid_bias_for_mem_enc=-10.0,\n+        enable_occlusion_spatial_embedding=True,\n+        multimask_output_in_sam=True,\n+        multimask_min_pt_num=0,\n+        multimask_max_pt_num=1,\n+        multimask_output_for_tracking=True,\n+        max_object_pointers_in_encoder=16,\n+        enable_temporal_pos_encoding_for_object_pointers=True,\n+        # memory attention\n+        memory_attention_hidden_size=256,\n+        memory_attention_num_layers=2,\n+        memory_attention_num_attention_heads=1,\n+        memory_attention_downsample_rate=1,\n+        memory_attention_mlp_hidden_size=2048,\n+        memory_attention_mlp_hidden_act=\"relu\",\n+        memory_attention_dropout=0.1,\n+        memory_attention_rope_theta=10000,\n+        memory_attention_rope_feat_sizes=None,\n+        memory_attention_rope_k_sizes=None,\n+        memory_attention_rope_dropout=0.1,\n+        # spatial perceiver resampler\n+        perceiver_resampler_num_latents=256,\n+        perceiver_resampler_num_latents_2d=256,\n+        perceiver_resampler_hidden_size=64,\n+        perceiver_resampler_mlp_intermediate_size=256,\n+        perceiver_resampler_num_attention_heads=1,\n+        perceiver_resampler_attention_head_dim=64,\n+        perceiver_resampler_num_layers=2,\n+        perceiver_resampler_hidden_dropout=0.0,\n+        perceiver_resampler_attention_dropout=0.0,\n+        # memory encoder\n+        memory_encoder_hidden_size=256,\n+        memory_encoder_output_channels=64,\n+        mask_downsampler_embed_dim=256,\n+        memory_fuser_intermediate_dim=1024,\n+        mask_downsampler_kernel_size=3,\n+        mask_downsampler_stride=2,\n+        mask_downsampler_padding=1,\n+        mask_downsampler_total_stride=16,\n+        mask_downsampler_hidden_act=\"gelu\",\n+        memory_fuser_num_layers=2,\n+        memory_fuser_embed_dim=256,\n+        memory_fuser_kernel_size=7,\n+        memory_fuser_padding=3,\n+        memory_fuser_layer_scale_init_value=1e-6,\n+        memory_fuser_hidden_act=\"gelu\",\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        vision_config = vision_config if vision_config is not None else {}\n+        prompt_encoder_config = prompt_encoder_config if prompt_encoder_config is not None else {}\n+        mask_decoder_config = mask_decoder_config if mask_decoder_config is not None else {}\n+        memory_attention_rope_feat_sizes = (\n+            [64, 64] if memory_attention_rope_feat_sizes is None else memory_attention_rope_feat_sizes\n+        )\n+        memory_attention_rope_k_sizes = (\n+            [16, 16] if memory_attention_rope_k_sizes is None else memory_attention_rope_k_sizes\n+        )\n+\n+        if isinstance(vision_config, dict):\n+            vision_config[\"model_type\"] = vision_config.get(\"model_type\", \"sam2_vision_model\")\n+            vision_config = CONFIG_MAPPING[vision_config[\"model_type\"]](**vision_config)\n+        if isinstance(prompt_encoder_config, EdgeTamVideoPromptEncoderConfig):\n+            prompt_encoder_config = prompt_encoder_config.to_dict()\n+        if isinstance(mask_decoder_config, EdgeTamVideoMaskDecoderConfig):\n+            mask_decoder_config = mask_decoder_config.to_dict()\n+\n+        self.vision_config = vision_config\n+        self.prompt_encoder_config = EdgeTamVideoPromptEncoderConfig(**prompt_encoder_config)\n+        self.mask_decoder_config = EdgeTamVideoMaskDecoderConfig(**mask_decoder_config)\n+\n+        self.initializer_range = initializer_range\n+        self.num_maskmem = num_maskmem  # default 1 input frame + 6 previous frames\n+        self.image_size = image_size\n+        self.sigmoid_scale_for_mem_enc = sigmoid_scale_for_mem_enc  # scale factor for mask sigmoid prob\n+        self.sigmoid_bias_for_mem_enc = sigmoid_bias_for_mem_enc  # bias factor for mask sigmoid prob\n+        self.enable_occlusion_spatial_embedding = enable_occlusion_spatial_embedding\n+        self.multimask_output_in_sam = multimask_output_in_sam\n+        self.multimask_min_pt_num = multimask_min_pt_num\n+        self.multimask_max_pt_num = multimask_max_pt_num\n+        self.multimask_output_for_tracking = multimask_output_for_tracking\n+        self.max_object_pointers_in_encoder = max_object_pointers_in_encoder\n+        self.enable_temporal_pos_encoding_for_object_pointers = enable_temporal_pos_encoding_for_object_pointers\n+\n+        # memory attention\n+        self.memory_attention_hidden_size = memory_attention_hidden_size\n+        self.memory_attention_num_layers = memory_attention_num_layers\n+        self.memory_attention_num_attention_heads = memory_attention_num_attention_heads\n+        self.memory_attention_downsample_rate = memory_attention_downsample_rate\n+        self.memory_attention_mlp_hidden_size = memory_attention_mlp_hidden_size\n+        self.memory_attention_mlp_hidden_act = memory_attention_mlp_hidden_act\n+        self.memory_attention_dropout = memory_attention_dropout\n+        self.memory_attention_rope_theta = memory_attention_rope_theta\n+        self.memory_attention_rope_feat_sizes = memory_attention_rope_feat_sizes\n+        self.memory_attention_rope_k_sizes = memory_attention_rope_k_sizes\n+        self.memory_attention_rope_dropout = memory_attention_rope_dropout\n+\n+        # spatial perceiver resampler\n+        self.perceiver_resampler_num_latents = perceiver_resampler_num_latents\n+        self.perceiver_resampler_num_latents_2d = perceiver_resampler_num_latents_2d\n+        self.perceiver_resampler_hidden_size = perceiver_resampler_hidden_size\n+        self.perceiver_resampler_mlp_intermediate_size = perceiver_resampler_mlp_intermediate_size\n+        self.perceiver_resampler_attention_head_dim = perceiver_resampler_attention_head_dim\n+        self.perceiver_resampler_num_attention_heads = perceiver_resampler_num_attention_heads\n+        self.perceiver_resampler_num_layers = perceiver_resampler_num_layers\n+        self.perceiver_resampler_hidden_dropout = perceiver_resampler_hidden_dropout\n+        self.perceiver_resampler_attention_dropout = perceiver_resampler_attention_dropout\n+\n+        # memory encoder\n+        self.memory_encoder_hidden_size = memory_encoder_hidden_size\n+        self.memory_encoder_output_channels = memory_encoder_output_channels\n+        self.mask_downsampler_embed_dim = mask_downsampler_embed_dim\n+        self.mask_downsampler_kernel_size = mask_downsampler_kernel_size\n+        self.mask_downsampler_stride = mask_downsampler_stride\n+        self.mask_downsampler_padding = mask_downsampler_padding\n+        self.mask_downsampler_total_stride = mask_downsampler_total_stride\n+        self.mask_downsampler_hidden_act = mask_downsampler_hidden_act\n+        self.memory_fuser_num_layers = memory_fuser_num_layers\n+        self.memory_fuser_embed_dim = memory_fuser_embed_dim\n+        self.memory_fuser_intermediate_dim = memory_fuser_intermediate_dim\n+        self.memory_fuser_kernel_size = memory_fuser_kernel_size\n+        self.memory_fuser_padding = memory_fuser_padding\n+        self.memory_fuser_layer_scale_init_value = memory_fuser_layer_scale_init_value\n+        self.memory_fuser_hidden_act = memory_fuser_hidden_act\n+\n+\n+__all__ = [\"EdgeTamVideoMaskDecoderConfig\", \"EdgeTamVideoPromptEncoderConfig\", \"EdgeTamVideoConfig\"]"
        },
        {
            "sha": "6290bef5e1c850d65a4b0bbc3096e17cc90db0bb",
            "filename": "src/transformers/models/edgetam_video/convert_edgetam_video_to_hf.py",
            "status": "added",
            "additions": 320,
            "deletions": 0,
            "changes": 320,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam_video%2Fconvert_edgetam_video_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam_video%2Fconvert_edgetam_video_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fedgetam_video%2Fconvert_edgetam_video_to_hf.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,320 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"\n+Convert SAM checkpoints from the original repository.\n+\n+URL: https://github.com/facebookresearch/segment-anything-2.\n+\"\"\"\n+\n+import argparse\n+import re\n+\n+import numpy as np\n+import requests\n+import torch\n+from huggingface_hub import hf_hub_download\n+from PIL import Image\n+\n+from transformers import (\n+    EdgeTamVideoConfig,\n+    EdgeTamVideoMaskDecoderConfig,\n+    EdgeTamVideoModel,\n+    EdgeTamVideoPromptEncoderConfig,\n+    EdgeTamVisionConfig,\n+    Sam2ImageProcessorFast,\n+    Sam2VideoProcessor,\n+    Sam2VideoVideoProcessor,\n+    TimmWrapperConfig,\n+)\n+\n+\n+def get_config(model_name):\n+    backbone_config = TimmWrapperConfig.from_pretrained(\n+        \"timm/repvit_m1.dist_in1k\",\n+        model_args={\"in_chans\": 3, \"features_only\": True, \"out_indices\": (0, 1, 2, 3)},\n+    )\n+    vision_config = EdgeTamVisionConfig(backbone_config=backbone_config)\n+\n+    prompt_encoder_config = EdgeTamVideoPromptEncoderConfig()\n+    mask_decoder_config = EdgeTamVideoMaskDecoderConfig()\n+    enable_temporal_pos_encoding_for_object_pointers = False\n+    enable_occlusion_spatial_embedding = False\n+\n+    config = EdgeTamVideoConfig(\n+        vision_config=vision_config,\n+        prompt_encoder_config=prompt_encoder_config,\n+        mask_decoder_config=mask_decoder_config,\n+        enable_temporal_pos_encoding_for_object_pointers=enable_temporal_pos_encoding_for_object_pointers,\n+        enable_occlusion_spatial_embedding=enable_occlusion_spatial_embedding,\n+    )\n+\n+    return config\n+\n+\n+KEYS_TO_MODIFY_MAPPING = {\n+    \"iou_prediction_head.layers.0\": \"iou_prediction_head.proj_in\",\n+    \"iou_prediction_head.layers.1\": \"iou_prediction_head.layers.0\",\n+    \"iou_prediction_head.layers.2\": \"iou_prediction_head.proj_out\",\n+    \"mask_decoder.output_upscaling.0\": \"mask_decoder.upscale_conv1\",\n+    \"mask_decoder.output_upscaling.1\": \"mask_decoder.upscale_layer_norm\",\n+    \"mask_decoder.output_upscaling.3\": \"mask_decoder.upscale_conv2\",\n+    \"mask_downscaling.0\": \"mask_embed.conv1\",\n+    \"mask_downscaling.1\": \"mask_embed.layer_norm1\",\n+    \"mask_downscaling.3\": \"mask_embed.conv2\",\n+    \"mask_downscaling.4\": \"mask_embed.layer_norm2\",\n+    \"mask_downscaling.6\": \"mask_embed.conv3\",\n+    \"dwconv\": \"depthwise_conv\",\n+    \"pwconv\": \"pointwise_conv\",\n+    \"fuser\": \"memory_fuser\",\n+    \"point_embeddings\": \"point_embed\",\n+    \"pe_layer.positional_encoding_gaussian_matrix\": \"shared_embedding.positional_embedding\",\n+    \"obj_ptr_tpos_proj\": \"temporal_positional_encoding_projection_layer\",\n+    \"no_obj_embed_spatial\": \"occlusion_spatial_embedding_parameter\",\n+    \"sam_prompt_encoder\": \"prompt_encoder\",\n+    \"sam_mask_decoder\": \"mask_decoder\",\n+    \"maskmem_tpos_enc\": \"memory_temporal_positional_encoding\",\n+    \"gamma\": \"scale\",\n+    \"image_encoder.neck\": \"vision_encoder.neck\",\n+    \"image_encoder\": \"vision_encoder.backbone\",\n+    \"neck.0\": \"neck.conv1\",\n+    \"neck.1\": \"neck.layer_norm1\",\n+    \"neck.2\": \"neck.conv2\",\n+    \"neck.3\": \"neck.layer_norm2\",\n+    \"pix_feat_proj\": \"feature_projection\",\n+    \"patch_embed.proj\": \"patch_embed.projection\",\n+    \"no_mem_embed\": \"no_memory_embedding\",\n+    \"no_mem_pos_enc\": \"no_memory_positional_encoding\",\n+    \"obj_ptr\": \"object_pointer\",\n+    \".norm\": \".layer_norm\",\n+    \"trunk.\": \"\",\n+    \"out_proj\": \"o_proj\",\n+    \"body.\": \"timm_model.\",\n+    \"ff.0\": \"mlp.layer_norm\",\n+    \"ff.1\": \"mlp.up_proj\",\n+    \"ff.3\": \"mlp.down_proj\",\n+}\n+\n+\n+def replace_keys(state_dict):\n+    model_state_dict = {}\n+    output_hypernetworks_mlps_pattern = r\".*.output_hypernetworks_mlps.(\\d+).layers.(\\d+).*\"\n+    output_mask_decoder_mlps_pattern = r\"mask_decoder.transformer.layers.(\\d+).mlp.layers.(\\d+).*\"\n+    output_mask_decoder_score_head_pattern = r\"mask_decoder.pred_obj_score_head.layers.(\\d+).*\"\n+    output_vision_encoder_mlps_pattern = r\"vision_encoder.backbone.blocks.(\\d+).mlp.layers.(\\d+).*\"\n+    output_vision_encoder_neck_pattern = r\"vision_encoder.neck.convs.(\\d+).conv\"\n+    output_memory_encoder_projection_pattern = r\"memory_encoder.o_proj.*\"\n+    memory_attention_pattern = r\"memory_attention.*\"\n+    output_object_pointer_proj_pattern = r\"object_pointer_proj.layers.(\\d+).*\"\n+    output_memory_encoder_mask_downsampler_pattern = r\"memory_encoder.mask_downsampler.encoder.(\\d+).*\"\n+    perceiver_resampler_patterns = {\n+        r\"spatial_perceiver.latents\": r\"spatial_perceiver.latents_1d\",\n+        r\"spatial_perceiver.latents_1d_2d\": r\"spatial_perceiver.latents_2d\",\n+        r\"spatial_perceiver.layers.(\\d+).attn.layer_norm_x\": r\"spatial_perceiver.layers.\\1.layer_norm_input\",\n+        r\"spatial_perceiver.layers.(\\d+).attn.layer_norm_latents\": r\"spatial_perceiver.layers.\\1.layer_norm_latents\",\n+        r\"spatial_perceiver.layers.(\\d+).self_attn.layer_norm\": r\"spatial_perceiver.layers.\\1.layer_norm_self\",\n+        r\"spatial_perceiver.layers.(\\d+).attn.to_q\": r\"spatial_perceiver.layers.\\1.cross_attention.q_proj\",\n+        r\"spatial_perceiver.layers.(\\d+).attn.to_kv\": r\"spatial_perceiver.layers.\\1.cross_attention.kv_proj_combined\",\n+        r\"spatial_perceiver.layers.(\\d+).attn.to_out\": r\"spatial_perceiver.layers.\\1.cross_attention.o_proj\",\n+        r\"spatial_perceiver.layers.(\\d+).self_attn.to_q\": r\"spatial_perceiver.layers.\\1.self_attention.q_proj\",\n+        r\"spatial_perceiver.layers.(\\d+).self_attn.to_kv\": r\"spatial_perceiver.layers.\\1.self_attention.kv_proj_combined\",\n+        r\"spatial_perceiver.layers.(\\d+).self_attn.to_out\": r\"spatial_perceiver.layers.\\1.self_attention.o_proj\",\n+        r\"spatial_perceiver.layers.(\\d+).attn\": r\"spatial_perceiver.layers.\\1.cross_attention\",\n+        r\"spatial_perceiver.layers.(\\d+).self_attn\": r\"spatial_perceiver.layers.\\1.self_attention\",\n+    }\n+\n+    for key, value in state_dict.items():\n+        for key_to_modify, new_key in KEYS_TO_MODIFY_MAPPING.items():\n+            if key_to_modify in key:\n+                key = key.replace(key_to_modify, new_key)\n+\n+        for pattern, replacement in perceiver_resampler_patterns.items():\n+            if re.match(pattern, key):\n+                key = re.sub(pattern, replacement, key)\n+\n+        # vision_encoder.blocks.0.mlp.layers.1.weight -> vision_encoder.blocks.0.mlp.proj_out.weight\n+        if re.match(output_vision_encoder_mlps_pattern, key):\n+            layer_nb = int(re.match(output_vision_encoder_mlps_pattern, key).group(2))\n+            if layer_nb == 0:\n+                key = key.replace(\"layers.0\", \"proj_in\")\n+            elif layer_nb == 1:\n+                key = key.replace(\"layers.1\", \"proj_out\")\n+\n+        if re.match(memory_attention_pattern, key):\n+            key = key.replace(\"linear1\", \"mlp.up_proj\")\n+            key = key.replace(\"linear2\", \"mlp.down_proj\")\n+\n+        # mask_decoder.transformer.layers.0.mlp.layers.1.weight -> mask_decoder.transformer.layers.1.mlp.proj_out.weight\n+        if re.match(output_mask_decoder_mlps_pattern, key):\n+            layer_nb = int(re.match(output_mask_decoder_mlps_pattern, key).group(2))\n+            if layer_nb == 0:\n+                key = key.replace(\"mlp.layers.0\", \"mlp.proj_in\")\n+            elif layer_nb == 1:\n+                key = key.replace(\"mlp.layers.1\", \"mlp.proj_out\")\n+\n+        # mask_decoder.pred_obj_score_head.layers.1.weight -> mask_decoder.pred_obj_score_head.proj_in.weight\n+        if re.match(output_mask_decoder_score_head_pattern, key):\n+            layer_nb = int(re.match(output_mask_decoder_score_head_pattern, key).group(1))\n+            if layer_nb == 0:\n+                key = key.replace(\"layers.0\", \"proj_in\")\n+            elif layer_nb == 1:\n+                key = key.replace(\"layers.1\", \"layers.0\")\n+            elif layer_nb == 2:\n+                key = key.replace(\"layers.2\", \"proj_out\")\n+\n+        if re.match(output_hypernetworks_mlps_pattern, key):\n+            layer_nb = int(re.match(output_hypernetworks_mlps_pattern, key).group(2))\n+            if layer_nb == 0:\n+                key = key.replace(\"layers.0\", \"proj_in\")\n+            elif layer_nb == 1:\n+                key = key.replace(\"layers.1\", \"layers.0\")\n+            elif layer_nb == 2:\n+                key = key.replace(\"layers.2\", \"proj_out\")\n+\n+        # vision_encoder.neck.convs.1.conv.bias -> vision_encoder.neck.convs.1.bias\n+        if re.match(output_vision_encoder_neck_pattern, key):\n+            key = key.replace(\".conv.\", \".\")\n+\n+        # memory_encoder.o_proj.weight -> memory_encoder.projection.weight\n+        if re.match(output_memory_encoder_projection_pattern, key):\n+            key = key.replace(\".o_proj.\", \".projection.\")\n+\n+        if re.match(output_object_pointer_proj_pattern, key):\n+            layer_nb = int(re.match(output_object_pointer_proj_pattern, key).group(1))\n+            if layer_nb == 0:\n+                key = key.replace(\"layers.0\", \"proj_in\")\n+            elif layer_nb == 1:\n+                key = key.replace(\"layers.1\", \"layers.0\")\n+            elif layer_nb == 2:\n+                key = key.replace(\"layers.2\", \"proj_out\")\n+\n+                key = key.replace(\"layers.2\", \"proj_out\")\n+\n+        if re.match(output_memory_encoder_mask_downsampler_pattern, key):\n+            layer_nb = int(re.match(output_memory_encoder_mask_downsampler_pattern, key).group(1))\n+            if layer_nb == 12:\n+                key = key.replace(f\"encoder.{layer_nb}\", \"final_conv\")\n+            elif layer_nb % 3 == 0:\n+                key = key.replace(f\"encoder.{layer_nb}\", f\"layers.{layer_nb // 3}.conv\")\n+            elif layer_nb % 3 == 1:\n+                key = key.replace(f\"encoder.{layer_nb}\", f\"layers.{layer_nb // 3}.layer_norm\")\n+        if \"kv_proj_combined\" in key:\n+            # Split the weight tensor in half along dimension 0 (output dimension)\n+            k_weight, v_weight = torch.chunk(value, 2, dim=0)\n+            # Create the k_proj and v_proj keys\n+            k_key = key.replace(\"kv_proj_combined\", \"k_proj\")\n+            v_key = key.replace(\"kv_proj_combined\", \"v_proj\")\n+            model_state_dict[k_key] = k_weight\n+            model_state_dict[v_key] = v_weight\n+            continue\n+\n+        model_state_dict[key] = value\n+\n+    model_state_dict[\"shared_image_embedding.positional_embedding\"] = model_state_dict[\n+        \"prompt_encoder.shared_embedding.positional_embedding\"\n+    ]\n+    model_state_dict[\"prompt_encoder.point_embed.weight\"] = torch.cat(\n+        [model_state_dict.pop(f\"prompt_encoder.point_embed.{i}.weight\") for i in range(4)],\n+        dim=0,\n+    )\n+\n+    return model_state_dict\n+\n+\n+def convert_edgetam_checkpoint(model_name, checkpoint_path, pytorch_dump_folder, push_to_hub, run_sanity_check):\n+    config = get_config(model_name)\n+\n+    state_dict = torch.load(checkpoint_path, map_location=\"cpu\")[\"model\"]\n+    state_dict = replace_keys(state_dict)\n+\n+    image_processor = Sam2ImageProcessorFast()\n+    video_processor = Sam2VideoVideoProcessor()\n+    processor = Sam2VideoProcessor(image_processor=image_processor, video_processor=video_processor)\n+    hf_model = EdgeTamVideoModel(config)\n+    hf_model.eval()\n+\n+    device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n+\n+    missing_keys, unexpected_keys = hf_model.load_state_dict(state_dict, strict=True)\n+    hf_model = hf_model.to(device)\n+    print(\"Missing keys:\", missing_keys)\n+    print(\"Unexpected keys:\", unexpected_keys)\n+\n+    if run_sanity_check:\n+        img_url = \"https://huggingface.co/ybelkada/segment-anything/resolve/main/assets/car.png\"\n+        raw_image = Image.open(requests.get(img_url, stream=True).raw).convert(\"RGB\")\n+\n+        input_points = [[[[1000, 600]]]]\n+        input_labels = [[[1]]]\n+\n+        inputs = processor(\n+            images=np.array(raw_image), input_points=input_points, input_labels=input_labels, return_tensors=\"pt\"\n+        ).to(device)\n+\n+        with torch.no_grad():\n+            output = hf_model._single_frame_forward(**inputs)\n+        scores = output.iou_scores.squeeze()\n+\n+        assert torch.allclose(scores, torch.tensor([0.0356, 0.2141, 0.9707]).cuda(), atol=1e-3)\n+\n+    if pytorch_dump_folder is not None:\n+        processor.save_pretrained(pytorch_dump_folder)\n+        hf_model.save_pretrained(pytorch_dump_folder)\n+\n+    if push_to_hub:\n+        repo_id = f\"yonigozlan/{pytorch_dump_folder.split('/')[-1]}\"\n+        processor.push_to_hub(repo_id)\n+        hf_model.push_to_hub(repo_id)\n+\n+\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser()\n+    choices = [\"EdgeTAM\"]\n+    parser.add_argument(\n+        \"--model_name\",\n+        default=\"EdgeTAM\",\n+        choices=choices,\n+        type=str,\n+        help=\"Name of the original model to convert\",\n+    )\n+    parser.add_argument(\n+        \"--checkpoint_path\",\n+        type=str,\n+        required=False,\n+        help=\"Path to the original checkpoint\",\n+    )\n+    parser.add_argument(\"--pytorch_dump_folder_path\", default=\"\", type=str, help=\"Path to the output PyTorch model.\")\n+    parser.add_argument(\n+        \"--push_to_hub\",\n+        action=\"store_true\",\n+        help=\"Whether to push the model and processor to the hub after converting\",\n+    )\n+    parser.add_argument(\n+        \"--run_sanity_check\",\n+        action=\"store_true\",\n+        help=\"Whether to run the sanity check after converting\",\n+    )\n+\n+    args = parser.parse_args()\n+\n+    hf_model_name = args.model_name.replace(\"_\", \"-\")\n+    checkpoint_path = (\n+        hf_hub_download(f\"facebook/{hf_model_name}\", f\"{args.model_name.lower()}.pt\")\n+        if args.checkpoint_path is None\n+        else args.checkpoint_path\n+    )\n+\n+    convert_edgetam_checkpoint(\n+        args.model_name, checkpoint_path, args.pytorch_dump_folder_path, args.push_to_hub, args.run_sanity_check\n+    )"
        },
        {
            "sha": "3ba7ab4ebf2f18d2eacdb2cf1222d0dd8fb19fb6",
            "filename": "src/transformers/models/edgetam_video/modeling_edgetam_video.py",
            "status": "added",
            "additions": 3062,
            "deletions": 0,
            "changes": 3062,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam_video%2Fmodeling_edgetam_video.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam_video%2Fmodeling_edgetam_video.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fedgetam_video%2Fmodeling_edgetam_video.py?ref=bd37c453544e83eb875ed3608980a1660376007a"
        },
        {
            "sha": "b520cd5a756bb18b99fb29dccce72a3d8fd47a64",
            "filename": "src/transformers/models/edgetam_video/modular_edgetam_video.py",
            "status": "added",
            "additions": 1243,
            "deletions": 0,
            "changes": 1243,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam_video%2Fmodular_edgetam_video.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fedgetam_video%2Fmodular_edgetam_video.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fedgetam_video%2Fmodular_edgetam_video.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,1243 @@\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import math\n+from typing import Callable, Optional\n+\n+import torch\n+import torch.nn as nn\n+import torch.utils.checkpoint\n+from torch import Tensor\n+\n+from transformers.models.sam2.modeling_sam2 import (\n+    eager_attention_forward,\n+    window_partition,\n+)\n+from transformers.utils.generic import OutputRecorder\n+\n+from ...activations import ACT2FN\n+from ...configuration_utils import PretrainedConfig\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS\n+from ...processing_utils import Unpack\n+from ...pytorch_utils import compile_compatible_method_lru_cache\n+from ...utils import (\n+    auto_docstring,\n+)\n+from ..auto import CONFIG_MAPPING, AutoConfig\n+from ..sam2_video.configuration_sam2_video import (\n+    Sam2VideoConfig,\n+    Sam2VideoMaskDecoderConfig,\n+    Sam2VideoPromptEncoderConfig,\n+)\n+from ..sam2_video.modeling_sam2_video import (\n+    Sam2VideoAttention,\n+    Sam2VideoFeedForward,\n+    Sam2VideoInferenceSession,\n+    Sam2VideoLayerNorm,\n+    Sam2VideoMemoryAttention,\n+    Sam2VideoMemoryEncoder,\n+    Sam2VideoMemoryFuserCXBlock,\n+    Sam2VideoModel,\n+    Sam2VideoPositionEmbeddingSine,\n+    Sam2VideoPreTrainedModel,\n+    Sam2VideoTwoWayAttentionBlock,\n+    Sam2VideoVisionEncoderOutput,\n+    Sam2VideoVisionRotaryEmbedding,\n+    rotate_pairwise,\n+)\n+\n+\n+class EdgeTamVideoPromptEncoderConfig(Sam2VideoPromptEncoderConfig):\n+    pass\n+\n+\n+class EdgeTamVideoMaskDecoderConfig(Sam2VideoMaskDecoderConfig):\n+    pass\n+\n+\n+class EdgeTamVideoConfig(Sam2VideoConfig):\n+    r\"\"\"\n+    [`EdgeTamVideoConfig`] is the configuration class to store the configuration of a [`EdgeTamVideoModel`]. It is used to instantiate a\n+    EDGETAM model according to the specified arguments, defining the memory attention, memory encoder, and image encoder\n+    configs. Instantiating a configuration defaults will yield a similar configuration to that of the SAM 2.1 Hiera-tiny\n+    [facebook/EdgeTAM](https://huggingface.co/facebook/EdgeTAM) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vision_config (Union[`dict`, `EdgeTamVideoVisionConfig`], *optional*):\n+            Dictionary of configuration options used to initialize [`EdgeTamVideoVisionConfig`].\n+        prompt_encoder_config (Union[`dict`, `EdgeTamVideoPromptEncoderConfig`], *optional*):\n+            Dictionary of configuration options used to initialize [`EdgeTamVideoPromptEncoderConfig`].\n+        mask_decoder_config (Union[`dict`, `EdgeTamVideoMaskDecoderConfig`], *optional*):\n+            Dictionary of configuration options used to initialize [`EdgeTamMaskDecoderConfig`].\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            Standard deviation for parameter initialization.\n+        num_maskmem (`int`, *optional*, defaults to 7):\n+            The number of memory slots for the mask memory.\n+        image_size (`int`, *optional*, defaults to 1024):\n+            The size of the input images.\n+        sigmoid_scale_for_mem_enc (`float`, *optional*, defaults to 20.0):\n+            Scale factor for the sigmoid function in the memory encoder.\n+        sigmoid_bias_for_mem_enc (`float`, *optional*, defaults to -10.0):\n+            Bias for the sigmoid function in the memory encoder.\n+        enable_occlusion_spatial_embedding (`bool`, *optional*, defaults to `True`):\n+            Whether to enable spatial embedding for occlusions.\n+        multimask_output_in_sam (`bool`, *optional*, defaults to `True`):\n+            Whether to output multiple masks from the SAM head.\n+        multimask_min_pt_num (`int`, *optional*, defaults to 0):\n+            The minimum number of points to trigger multimask output.\n+        multimask_max_pt_num (`int`, *optional*, defaults to 1):\n+            The maximum number of points to trigger multimask output.\n+        multimask_output_for_tracking (`bool`, *optional*, defaults to `True`):\n+            Whether to use multimask output for tracking.\n+        max_object_pointers_in_encoder (`int`, *optional*, defaults to 16):\n+            The maximum number of object pointers in the encoder.\n+        enable_temporal_pos_encoding_for_object_pointers (`bool`, *optional*, defaults to `True`):\n+            Whether to enable temporal positional encoding for object pointers.\n+        memory_attention_hidden_size (`int`, *optional*, defaults to 256):\n+            Dimensionality of the memory attention hidden states.\n+        memory_attention_num_layers (`int`, *optional*, defaults to 2):\n+            The number of layers in the memory attention module.\n+        memory_attention_num_attention_heads (`int`, *optional*, defaults to 1):\n+            Number of attention heads for each attention layer in the memory attention.\n+        memory_attention_downsample_rate (`int`, *optional*, defaults to 1):\n+            The downsample rate for the attention layers.\n+        memory_attention_mlp_hidden_size (`int`, *optional*, defaults to 2048):\n+            The dimension of the feedforward network in the memory attention module.\n+        memory_attention_mlp_hidden_act (`str`, *optional*, defaults to `\"relu\"`):\n+            The non-linear activation function in the feedforward network in the memory attention module.\n+        memory_attention_dropout (`float`, *optional*, defaults to 0.1):\n+            The dropout rate for the memory attention module.\n+        memory_attention_rope_theta (`float`, *optional*, defaults to 10000):\n+            The Rope theta parameter.\n+        memory_attention_rope_feat_sizes (`Tuple[int, int]`, *optional*, defaults to `[64, 64]`):\n+            The feature sizes for the Rope positional encoding.\n+        memory_attention_rope_k_sizes (`List[int]`, *optional*, defaults to `[16, 16]`):\n+            The key feature sizes for the RoPE positional encoding in memory attention.\n+        memory_attention_rope_dropout (`float`, *optional*, defaults to 0.1):\n+            The dropout rate for the Rope positional encoding.\n+        perceiver_resampler_num_latents (`int`, *optional*, defaults to 256):\n+            The number of 1D latent tokens in the perceiver resampler.\n+        perceiver_resampler_num_latents_2d (`int`, *optional*, defaults to 256):\n+            The number of 2D latent tokens in the perceiver resampler.\n+        perceiver_resampler_hidden_size (`int`, *optional*, defaults to 64):\n+            The hidden size of the perceiver resampler.\n+        perceiver_resampler_mlp_intermediate_size (`int`, *optional*, defaults to 256):\n+            The intermediate size of the feedforward network in the perceiver resampler.\n+        perceiver_resampler_num_attention_heads (`int`, *optional*, defaults to 1):\n+            The number of attention heads in the perceiver resampler.\n+        perceiver_resampler_attention_head_dim (`int`, *optional*, defaults to 64):\n+            The dimension of each attention head in the perceiver resampler.\n+        perceiver_resampler_num_layers (`int`, *optional*, defaults to 2):\n+            The number of layers in the perceiver resampler.\n+        perceiver_resampler_hidden_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout rate for the hidden layers in the perceiver resampler.\n+        perceiver_resampler_attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout rate for the attention layers in the perceiver resampler.\n+        memory_encoder_hidden_size (`int`, *optional*, defaults to 256):\n+            Dimensionality of the memory encoder hidden states.\n+        memory_encoder_output_channels (`int`, *optional*, defaults to 64):\n+            The number of output channels for the memory encoder.\n+        mask_downsampler_embed_dim (`int`, *optional*, defaults to 256):\n+            The dimension of the mask downsampler embedding.\n+        memory_fuser_intermediate_dim (`int`, *optional*, defaults to 1024):\n+            The intermediate dimension of the memory fuser feedforward network.\n+        mask_downsampler_kernel_size (`int`, *optional*, defaults to 3):\n+            The kernel size for the mask downsampler.\n+        mask_downsampler_stride (`int`, *optional*, defaults to 2):\n+            The stride for the mask downsampler.\n+        mask_downsampler_padding (`int`, *optional*, defaults to 1):\n+            The padding for the mask downsampler.\n+        mask_downsampler_total_stride (`int`, *optional*, defaults to 16):\n+            The total stride for the mask downsampler.\n+        mask_downsampler_hidden_act (`str`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function in the mask downsampler.\n+        memory_fuser_num_layers (`int`, *optional*, defaults to 2):\n+            The number of layers in the memory fuser.\n+        memory_fuser_embed_dim (`int`, *optional*, defaults to 256):\n+            The dimension of the memory fuser embedding.\n+        memory_fuser_kernel_size (`int`, *optional*, defaults to 7):\n+            The kernel size for the memory fuser.\n+        memory_fuser_padding (`int`, *optional*, defaults to 3):\n+            The padding for the memory fuser.\n+        memory_fuser_layer_scale_init_value (`float`, *optional*, defaults to 1e-06):\n+            The initial value for the layer scale in the memory fuser.\n+        memory_fuser_hidden_act (`str`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function in the memory fuser.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import (\n+    ...     EdgeTamVisionConfig,\n+    ...     EdgeTamVideoPromptEncoderConfig,\n+    ...     EdgeTamVideoMaskDecoderConfig,\n+    ...     EdgeTamVideoModel,\n+    ...     EdgeTamVideoConfig,\n+    ... )\n+\n+    >>> # Initializing a EdgeTamVideoConfig with `\"facebook/edgetam.1_hiera_tiny\"` style configuration\n+    >>> configuration = EdgeTamVideoConfig()\n+\n+    >>> # Initializing a EdgeTamVideoModel (with random weights) from the `\"facebook/edgetam.1_hiera_tiny\"` style configuration\n+    >>> model = EdgeTamVideoModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+\n+    >>> # We can also initialize a EdgeTamConfig from a EdgeTamVisionConfig, EdgeTamPromptEncoderConfig, and EdgeTamMaskDecoderConfig\n+\n+    >>> # Initializing EDGETAM vision encoder, memory attention, and memory encoder configurations\n+    >>> vision_config = EdgeTamVisionConfig()\n+    >>> prompt_encoder_config = EdgeTamVideoPromptEncoderConfig()\n+    >>> mask_decoder_config = EdgeTamVideoMaskDecoderConfig()\n+\n+    >>> config = EdgeTamVideoConfig(vision_config, prompt_encoder_config, mask_decoder_config)\n+    ```\"\"\"\n+\n+    model_type = \"edgetam_video\"\n+    sub_configs = {\n+        \"vision_config\": AutoConfig,\n+        \"prompt_encoder_config\": EdgeTamVideoPromptEncoderConfig,\n+        \"mask_decoder_config\": EdgeTamVideoMaskDecoderConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        vision_config=None,\n+        prompt_encoder_config=None,\n+        mask_decoder_config=None,\n+        initializer_range=0.02,\n+        num_maskmem=7,\n+        image_size=1024,\n+        sigmoid_scale_for_mem_enc=20.0,\n+        sigmoid_bias_for_mem_enc=-10.0,\n+        enable_occlusion_spatial_embedding=True,\n+        multimask_output_in_sam=True,\n+        multimask_min_pt_num=0,\n+        multimask_max_pt_num=1,\n+        multimask_output_for_tracking=True,\n+        max_object_pointers_in_encoder=16,\n+        enable_temporal_pos_encoding_for_object_pointers=True,\n+        # memory attention\n+        memory_attention_hidden_size=256,\n+        memory_attention_num_layers=2,\n+        memory_attention_num_attention_heads=1,\n+        memory_attention_downsample_rate=1,\n+        memory_attention_mlp_hidden_size=2048,\n+        memory_attention_mlp_hidden_act=\"relu\",\n+        memory_attention_dropout=0.1,\n+        memory_attention_rope_theta=10000,\n+        memory_attention_rope_feat_sizes=None,\n+        memory_attention_rope_k_sizes=None,\n+        memory_attention_rope_dropout=0.1,\n+        # spatial perceiver resampler\n+        perceiver_resampler_num_latents=256,\n+        perceiver_resampler_num_latents_2d=256,\n+        perceiver_resampler_hidden_size=64,\n+        perceiver_resampler_mlp_intermediate_size=256,\n+        perceiver_resampler_num_attention_heads=1,\n+        perceiver_resampler_attention_head_dim=64,\n+        perceiver_resampler_num_layers=2,\n+        perceiver_resampler_hidden_dropout=0.0,\n+        perceiver_resampler_attention_dropout=0.0,\n+        # memory encoder\n+        memory_encoder_hidden_size=256,\n+        memory_encoder_output_channels=64,\n+        mask_downsampler_embed_dim=256,\n+        memory_fuser_intermediate_dim=1024,\n+        mask_downsampler_kernel_size=3,\n+        mask_downsampler_stride=2,\n+        mask_downsampler_padding=1,\n+        mask_downsampler_total_stride=16,\n+        mask_downsampler_hidden_act=\"gelu\",\n+        memory_fuser_num_layers=2,\n+        memory_fuser_embed_dim=256,\n+        memory_fuser_kernel_size=7,\n+        memory_fuser_padding=3,\n+        memory_fuser_layer_scale_init_value=1e-6,\n+        memory_fuser_hidden_act=\"gelu\",\n+        **kwargs,\n+    ):\n+        PretrainedConfig.__init__(**kwargs)\n+        vision_config = vision_config if vision_config is not None else {}\n+        prompt_encoder_config = prompt_encoder_config if prompt_encoder_config is not None else {}\n+        mask_decoder_config = mask_decoder_config if mask_decoder_config is not None else {}\n+        memory_attention_rope_feat_sizes = (\n+            [64, 64] if memory_attention_rope_feat_sizes is None else memory_attention_rope_feat_sizes\n+        )\n+        memory_attention_rope_k_sizes = (\n+            [16, 16] if memory_attention_rope_k_sizes is None else memory_attention_rope_k_sizes\n+        )\n+\n+        if isinstance(vision_config, dict):\n+            vision_config[\"model_type\"] = vision_config.get(\"model_type\", \"sam2_vision_model\")\n+            vision_config = CONFIG_MAPPING[vision_config[\"model_type\"]](**vision_config)\n+        if isinstance(prompt_encoder_config, EdgeTamVideoPromptEncoderConfig):\n+            prompt_encoder_config = prompt_encoder_config.to_dict()\n+        if isinstance(mask_decoder_config, EdgeTamVideoMaskDecoderConfig):\n+            mask_decoder_config = mask_decoder_config.to_dict()\n+\n+        self.vision_config = vision_config\n+        self.prompt_encoder_config = EdgeTamVideoPromptEncoderConfig(**prompt_encoder_config)\n+        self.mask_decoder_config = EdgeTamVideoMaskDecoderConfig(**mask_decoder_config)\n+\n+        self.initializer_range = initializer_range\n+        self.num_maskmem = num_maskmem  # default 1 input frame + 6 previous frames\n+        self.image_size = image_size\n+        self.sigmoid_scale_for_mem_enc = sigmoid_scale_for_mem_enc  # scale factor for mask sigmoid prob\n+        self.sigmoid_bias_for_mem_enc = sigmoid_bias_for_mem_enc  # bias factor for mask sigmoid prob\n+        self.enable_occlusion_spatial_embedding = enable_occlusion_spatial_embedding\n+        self.multimask_output_in_sam = multimask_output_in_sam\n+        self.multimask_min_pt_num = multimask_min_pt_num\n+        self.multimask_max_pt_num = multimask_max_pt_num\n+        self.multimask_output_for_tracking = multimask_output_for_tracking\n+        self.max_object_pointers_in_encoder = max_object_pointers_in_encoder\n+        self.enable_temporal_pos_encoding_for_object_pointers = enable_temporal_pos_encoding_for_object_pointers\n+\n+        # memory attention\n+        self.memory_attention_hidden_size = memory_attention_hidden_size\n+        self.memory_attention_num_layers = memory_attention_num_layers\n+        self.memory_attention_num_attention_heads = memory_attention_num_attention_heads\n+        self.memory_attention_downsample_rate = memory_attention_downsample_rate\n+        self.memory_attention_mlp_hidden_size = memory_attention_mlp_hidden_size\n+        self.memory_attention_mlp_hidden_act = memory_attention_mlp_hidden_act\n+        self.memory_attention_dropout = memory_attention_dropout\n+        self.memory_attention_rope_theta = memory_attention_rope_theta\n+        self.memory_attention_rope_feat_sizes = memory_attention_rope_feat_sizes\n+        self.memory_attention_rope_k_sizes = memory_attention_rope_k_sizes\n+        self.memory_attention_rope_dropout = memory_attention_rope_dropout\n+\n+        # spatial perceiver resampler\n+        self.perceiver_resampler_num_latents = perceiver_resampler_num_latents\n+        self.perceiver_resampler_num_latents_2d = perceiver_resampler_num_latents_2d\n+        self.perceiver_resampler_hidden_size = perceiver_resampler_hidden_size\n+        self.perceiver_resampler_mlp_intermediate_size = perceiver_resampler_mlp_intermediate_size\n+        self.perceiver_resampler_attention_head_dim = perceiver_resampler_attention_head_dim\n+        self.perceiver_resampler_num_attention_heads = perceiver_resampler_num_attention_heads\n+        self.perceiver_resampler_num_layers = perceiver_resampler_num_layers\n+        self.perceiver_resampler_hidden_dropout = perceiver_resampler_hidden_dropout\n+        self.perceiver_resampler_attention_dropout = perceiver_resampler_attention_dropout\n+\n+        # memory encoder\n+        self.memory_encoder_hidden_size = memory_encoder_hidden_size\n+        self.memory_encoder_output_channels = memory_encoder_output_channels\n+        self.mask_downsampler_embed_dim = mask_downsampler_embed_dim\n+        self.mask_downsampler_kernel_size = mask_downsampler_kernel_size\n+        self.mask_downsampler_stride = mask_downsampler_stride\n+        self.mask_downsampler_padding = mask_downsampler_padding\n+        self.mask_downsampler_total_stride = mask_downsampler_total_stride\n+        self.mask_downsampler_hidden_act = mask_downsampler_hidden_act\n+        self.memory_fuser_num_layers = memory_fuser_num_layers\n+        self.memory_fuser_embed_dim = memory_fuser_embed_dim\n+        self.memory_fuser_intermediate_dim = memory_fuser_intermediate_dim\n+        self.memory_fuser_kernel_size = memory_fuser_kernel_size\n+        self.memory_fuser_padding = memory_fuser_padding\n+        self.memory_fuser_layer_scale_init_value = memory_fuser_layer_scale_init_value\n+        self.memory_fuser_hidden_act = memory_fuser_hidden_act\n+\n+\n+class EdgeTamVideoLayerNorm(Sam2VideoLayerNorm):\n+    pass\n+\n+\n+class EdgeTamVideoMemoryFuserCXBlock(Sam2VideoMemoryFuserCXBlock):\n+    pass\n+\n+\n+class EdgeTamVideoVisionEncoderOutput(Sam2VideoVisionEncoderOutput):\n+    pass\n+\n+\n+class EdgeTamVideoVisionRotaryEmbedding(Sam2VideoVisionRotaryEmbedding):\n+    def __init__(self, config: EdgeTamVideoConfig, end_x: Optional[int] = None, end_y: Optional[int] = None):\n+        nn.Module.__init__()\n+        dim = config.memory_attention_hidden_size // (\n+            config.memory_attention_downsample_rate * config.memory_attention_num_attention_heads\n+        )\n+        # Ensure even dimension for proper axial splitting\n+        if dim % 4 != 0:\n+            raise ValueError(\"Dimension must be divisible by 4 for axial RoPE\")\n+        end_x, end_y = config.memory_attention_rope_feat_sizes if end_x is None else (end_x, end_y)\n+        freqs = 1.0 / (config.memory_attention_rope_theta ** (torch.arange(0, dim, 4)[: (dim // 4)].float() / dim))\n+\n+        # Generate 2D position indices for axial rotary embedding\n+        flattened_indices = torch.arange(end_x * end_y, dtype=torch.long)\n+        x_positions = flattened_indices % end_x\n+        y_positions = torch.div(flattened_indices, end_x, rounding_mode=\"floor\")\n+        freqs_x = torch.outer(x_positions, freqs).float()\n+        freqs_y = torch.outer(y_positions, freqs).float()\n+        inv_freq = torch.cat([freqs_x, freqs_y], dim=-1)\n+        inv_freq = inv_freq.repeat_interleave(2, dim=-1)\n+        # directly register the cos and sin embeddings as we have a fixed feature shape\n+        self.register_buffer(\"rope_embeddings_cos\", inv_freq.cos(), persistent=False)\n+        self.register_buffer(\"rope_embeddings_sin\", inv_freq.sin(), persistent=False)\n+\n+\n+class EdgeTamVideoAttention(Sam2VideoAttention):\n+    pass\n+\n+\n+def apply_rotary_pos_emb_2d_self_attn(\n+    q: torch.Tensor,\n+    k: torch.Tensor,\n+    cos: torch.Tensor,\n+    sin: torch.Tensor,\n+) -> tuple[torch.Tensor, torch.Tensor]:\n+    \"\"\"\n+    Apply rotary position embedding to query and key tensors for self-attention.\n+\n+    Args:\n+        q: Query tensor of shape (..., seq_len, head_dim)\n+        k: Key tensor of shape (..., seq_len, head_dim)\n+        cos: Cosine position embedding of shape (seq_len, head_dim)\n+        sin: Sine position embedding of shape (seq_len, head_dim)\n+\n+    Returns:\n+        Rotated (q, k) tensors\n+    \"\"\"\n+    # Apply RoPE to queries\n+    q_embed = q.float()  # force upscale to float32 as in the original implementation\n+    q_embed = (q_embed * cos) + (rotate_pairwise(q_embed) * sin)\n+\n+    # Apply RoPE to keys (same embeddings as queries for self-attention)\n+    k_embed = k.float()  # force upscale to float32 as in the original implementation\n+    k_embed = (k_embed * cos) + (rotate_pairwise(k_embed) * sin)\n+\n+    return q_embed.type_as(q), k_embed.type_as(k)\n+\n+\n+def apply_rotary_pos_emb_2d_cross_attn(\n+    q: torch.Tensor,\n+    k: torch.Tensor,\n+    cos: torch.Tensor,\n+    sin: torch.Tensor,\n+    cos_k: torch.Tensor,\n+    sin_k: torch.Tensor,\n+    num_k_exclude_rope: int = 0,\n+    repeat_freqs_k: int = 1,\n+) -> tuple[torch.Tensor, torch.Tensor]:\n+    \"\"\"\n+    Apply rotary position embedding to query and key tensors for cross-attention.\n+\n+    Args:\n+        q: Query tensor of shape (..., seq_len, head_dim)\n+        k: Key tensor of shape (..., seq_len, head_dim)\n+        cos: Cosine position embedding of shape (seq_len, head_dim)\n+        sin: Sine position embedding of shape (seq_len, head_dim)\n+        cos_k: Cosine position embedding for keys of shape (seq_len, head_dim)\n+        sin_k: Sine position embedding for keys of shape (seq_len, head_dim)\n+        num_k_exclude_rope: Number of tokens at end of k to exclude from RoPE (e.g., object pointer tokens)\n+        repeat_freqs_k: Frequency repetition for keys in cross-attention (e.g., for spatial memory tokens)\n+\n+    Returns:\n+        Rotated (q, k) tensors\n+    \"\"\"\n+    # Apply RoPE to queries (always straightforward)\n+    q_embed = q.float()\n+    q_embed = (q_embed * cos) + (rotate_pairwise(q_embed) * sin)\n+\n+    # Split keys: RoPE tokens and excluded tokens (e.g., object pointers)\n+    num_total_k_tokens = k.shape[-2]\n+    k_for_rope = k[..., : num_total_k_tokens - num_k_exclude_rope, :]\n+    k_excluded = k[..., num_total_k_tokens - num_k_exclude_rope :, :]\n+\n+    # Early return if no keys need RoPE\n+    if k_for_rope.shape[-2] == 0:\n+        return q_embed.type_as(q), k_excluded\n+\n+    batch_size, num_heads, k_seq_len, channels_per_head = k_for_rope.shape\n+\n+    # Handle temporal/spatial token structure for memory\n+    # Keys have temporal + spatial structure, only spatial tokens get RoPE\n+    tokens_per_group = k_seq_len // repeat_freqs_k\n+    spatial_tokens = cos_k.shape[-2]\n+    temporal_tokens = tokens_per_group - spatial_tokens\n+\n+    # Reshape and separate temporal/spatial tokens\n+    k_grouped = k_for_rope.view(batch_size, num_heads, repeat_freqs_k, tokens_per_group, channels_per_head)\n+    k_temporal = k_grouped[..., :temporal_tokens, :].reshape(batch_size, num_heads, -1, channels_per_head)\n+    k_spatial = k_grouped[..., temporal_tokens:, :].reshape(batch_size, num_heads, -1, channels_per_head)\n+\n+    # Only apply RoPE to spatial tokens\n+    k_rope_input = k_spatial\n+\n+    # Prepare position embeddings for repeated groups\n+    if repeat_freqs_k > 1:\n+        cos_k = cos_k.repeat(1, 1, repeat_freqs_k, 1)\n+        sin_k = sin_k.repeat(1, 1, repeat_freqs_k, 1)\n+\n+    # Apply RoPE to spatial tokens\n+    k_spatial_embed = k_rope_input.float()\n+    k_spatial_embed = (k_spatial_embed * cos_k) + (rotate_pairwise(k_spatial_embed) * sin_k)\n+\n+    # Reconstruct: temporal + spatial tokens back to original structure\n+    k_spatial_reshaped = k_spatial_embed.view(batch_size, num_heads, repeat_freqs_k, -1, channels_per_head)\n+    k_temporal_reshaped = k_temporal.view(batch_size, num_heads, repeat_freqs_k, -1, channels_per_head)\n+    k_final = torch.cat([k_temporal_reshaped, k_spatial_reshaped], dim=3)\n+    k_final = k_final.view(batch_size, num_heads, k_seq_len, channels_per_head)\n+\n+    # Combine RoPE-processed keys with excluded tokens\n+    k_embed = torch.cat([k_final.type_as(k), k_excluded], dim=-2)\n+    return q_embed.type_as(q), k_embed\n+\n+\n+class EdgeTamVideoRoPESelfAttention(nn.Module):\n+    \"\"\"Self-attention with rotary position encoding.\"\"\"\n+\n+    def __init__(self, config: EdgeTamVideoConfig):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.memory_attention_hidden_size\n+        self.internal_dim = self.hidden_size // config.memory_attention_downsample_rate\n+        self.num_attention_heads = config.memory_attention_num_attention_heads\n+        self.head_dim = self.internal_dim // config.memory_attention_num_attention_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.is_causal = False\n+\n+        self.q_proj = nn.Linear(self.hidden_size, self.internal_dim)\n+        self.k_proj = nn.Linear(self.hidden_size, self.internal_dim)\n+        self.v_proj = nn.Linear(self.hidden_size, self.internal_dim)\n+        self.o_proj = nn.Linear(self.internal_dim, self.hidden_size)\n+        self.dropout_p = config.memory_attention_rope_dropout\n+\n+    def forward(\n+        self,\n+        query: torch.Tensor,\n+        key: torch.Tensor,\n+        value: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Tensor:\n+        # Input projections\n+        batch_size, point_batch_size = query.shape[:2]\n+        new_shape = (batch_size * point_batch_size, -1, self.num_attention_heads, self.head_dim)\n+\n+        query = self.q_proj(query).view(*new_shape).transpose(1, 2)\n+        key = self.k_proj(key).view(*new_shape).transpose(1, 2)\n+        value = self.v_proj(value).view(*new_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        # Apply rotary position encoding for self-attention\n+        query, key = apply_rotary_pos_emb_2d_self_attn(query, key, cos=cos, sin=sin)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query,\n+            key,\n+            value,\n+            attention_mask=None,\n+            dropout=0.0 if not self.training else self.dropout_p,\n+            scaling=self.scaling,\n+            is_causal=self.is_causal,\n+            **kwargs,\n+        )\n+        attn_output = attn_output.reshape(\n+            batch_size, point_batch_size, -1, self.num_attention_heads * self.head_dim\n+        ).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class EdgeTamVideoRoPECrossAttention(nn.Module):\n+    \"\"\"Cross-attention with rotary position encoding.\"\"\"\n+\n+    def __init__(self, config: EdgeTamVideoConfig, kv_in_dim: int):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.memory_attention_hidden_size\n+        self.internal_dim = self.hidden_size // config.memory_attention_downsample_rate\n+        self.num_attention_heads = config.memory_attention_num_attention_heads\n+        self.head_dim = self.internal_dim // config.memory_attention_num_attention_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.is_causal = False\n+\n+        self.kv_in_dim = kv_in_dim\n+\n+        self.q_proj = nn.Linear(self.hidden_size, self.internal_dim)\n+        self.k_proj = nn.Linear(self.kv_in_dim, self.internal_dim)\n+        self.v_proj = nn.Linear(self.kv_in_dim, self.internal_dim)\n+        self.o_proj = nn.Linear(self.internal_dim, self.hidden_size)\n+        self.dropout_p = config.memory_attention_rope_dropout\n+\n+    def forward(\n+        self,\n+        query: torch.Tensor,\n+        key: torch.Tensor,\n+        value: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        position_embeddings_k: tuple[torch.Tensor, torch.Tensor],\n+        num_k_exclude_rope: int = 0,\n+        rope_k_repeat: int = 0,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Tensor:\n+        # Input projections\n+        batch_size, point_batch_size = query.shape[:2]\n+        new_shape = (batch_size * point_batch_size, -1, self.num_attention_heads, self.head_dim)\n+\n+        query = self.q_proj(query).view(*new_shape).transpose(1, 2)\n+        key = self.k_proj(key).view(*new_shape).transpose(1, 2)\n+        value = self.v_proj(value).view(*new_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        cos_k, sin_k = position_embeddings_k\n+        # Apply rotary position encoding for cross-attention\n+        query, key = apply_rotary_pos_emb_2d_cross_attn(\n+            query,\n+            key,\n+            cos=cos,\n+            sin=sin,\n+            cos_k=cos_k,\n+            sin_k=sin_k,\n+            repeat_freqs_k=rope_k_repeat,\n+            num_k_exclude_rope=num_k_exclude_rope,\n+        )\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query,\n+            key,\n+            value,\n+            attention_mask=None,\n+            dropout=0.0 if not self.training else self.dropout_p,\n+            scaling=self.scaling,\n+            is_causal=self.is_causal,\n+            **kwargs,\n+        )\n+        attn_output = attn_output.reshape(\n+            batch_size, point_batch_size, -1, self.num_attention_heads * self.head_dim\n+        ).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class EdgeTamVideoTwoWayAttentionBlock(Sam2VideoTwoWayAttentionBlock):\n+    pass\n+\n+\n+class EdgeTamVideoPositionEmbeddingSine(Sam2VideoPositionEmbeddingSine):\n+    # maxsize=2 because we need to cache the forward method for both memory encoder and perceiver resampler\n+    @compile_compatible_method_lru_cache(maxsize=2)\n+    def forward(self, **super_kwargs):\n+        return super().forward(**super_kwargs)\n+\n+\n+class EdgeTamVideoMemoryEncoder(Sam2VideoMemoryEncoder):\n+    pass\n+\n+\n+class EdgeTamVideoFeedForward(Sam2VideoFeedForward):\n+    pass\n+\n+\n+class EdgeTamVideoPreTrainedModel(Sam2VideoPreTrainedModel):\n+    pass\n+\n+\n+class EdgeTamVideoInferenceSession(Sam2VideoInferenceSession):\n+    pass\n+\n+\n+class EdgeTamVideoMemoryAttentionMLP(nn.Module):\n+    def __init__(self, config: EdgeTamVideoConfig):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.memory_attention_hidden_size\n+        self.intermediate_size = config.memory_attention_mlp_hidden_size\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size)\n+        self.dropout = nn.Dropout(config.memory_attention_dropout)\n+        self.act_fn = ACT2FN[config.memory_attention_mlp_hidden_act]\n+\n+    def forward(self, x):\n+        return self.down_proj(self.dropout(self.act_fn(self.up_proj(x))))\n+\n+\n+class EdgeTamVideoMemoryAttentionLayer(nn.Module):\n+    def __init__(self, config: EdgeTamVideoConfig):\n+        super().__init__()\n+        hidden_size = config.memory_attention_hidden_size\n+        self.self_attn = EdgeTamVideoRoPESelfAttention(config)\n+        self.cross_attn_image = EdgeTamVideoRoPECrossAttention(config, kv_in_dim=64)\n+\n+        # MLP module\n+        self.mlp = EdgeTamVideoMemoryAttentionMLP(config)\n+\n+        self.layer_norm1 = nn.LayerNorm(hidden_size)\n+        self.layer_norm2 = nn.LayerNorm(hidden_size)\n+        self.layer_norm3 = nn.LayerNorm(hidden_size)\n+        self.dropout1 = nn.Dropout(config.memory_attention_dropout)\n+        self.dropout2 = nn.Dropout(config.memory_attention_dropout)\n+        self.dropout3 = nn.Dropout(config.memory_attention_dropout)\n+\n+    def forward(\n+        self,\n+        queries: Tensor,\n+        keys: Tensor,\n+        key_point_embedding: Tensor,\n+        rope_position_embeddings: tuple[Tensor, Tensor],\n+        rope_position_embeddings_k: Optional[tuple[Tensor, Tensor]] = None,\n+        num_k_exclude_rope: int = 0,\n+        rope_k_repeat: int = 0,\n+    ) -> torch.Tensor:\n+        # Self-Attention\n+        query = self.layer_norm1(queries)\n+        query, _ = self.self_attn(query=query, key=query, value=query, position_embeddings=rope_position_embeddings)\n+        queries = queries + self.dropout1(query)\n+\n+        # Cross-Attention\n+        query = self.layer_norm2(queries)\n+        query, _ = self.cross_attn_image(\n+            query=query,\n+            key=keys + key_point_embedding,\n+            value=keys,\n+            position_embeddings=rope_position_embeddings,\n+            position_embeddings_k=rope_position_embeddings_k,\n+            num_k_exclude_rope=num_k_exclude_rope,\n+            rope_k_repeat=rope_k_repeat,\n+        )\n+        queries = queries + self.dropout2(query)\n+        # MLP\n+        query = self.layer_norm3(queries)\n+        query = self.mlp(query)\n+        queries = queries + self.dropout3(query)\n+        return queries\n+\n+\n+class EdgeTamVideoMemoryAttention(Sam2VideoMemoryAttention):\n+    def __init__(self, config: EdgeTamVideoConfig):\n+        super().__init__()\n+        self.rotary_emb_k = EdgeTamVideoVisionRotaryEmbedding(\n+            config, end_x=config.memory_attention_rope_k_sizes[0], end_y=config.memory_attention_rope_k_sizes[1]\n+        )\n+\n+    def forward(\n+        self,\n+        current_vision_features: torch.Tensor,\n+        memory: torch.Tensor,\n+        current_vision_position_embeddings: Optional[Tensor] = None,\n+        memory_posision_embeddings: Optional[Tensor] = None,\n+        num_object_pointer_tokens: int = 0,\n+        num_spatial_memory_tokens: int = -1,\n+    ):\n+        \"\"\"\n+        Args:\n+            current_vision_features (`torch.FloatTensor`):\n+                The current vision features used for self-attention.\n+            memory (`torch.FloatTensor`):\n+                The memory features used for cross-attention.\n+            current_vision_position_embeddings (`torch.FloatTensor`, *optional*):\n+                The position embeddings for the current vision features.\n+            memory_posision_embeddings (`torch.FloatTensor`, *optional*):\n+                The position embeddings for the memory features.\n+            num_object_pointer_tokens (`int`, *optional*, defaults to 0):\n+                The number of object pointer tokens.\n+        \"\"\"\n+        output = current_vision_features\n+        if current_vision_position_embeddings is not None:\n+            output = output + 0.1 * current_vision_position_embeddings\n+\n+        # Convert to batch first\n+        output = output.transpose(0, 1)\n+        memory = memory.transpose(0, 1).unsqueeze(1)\n+        memory_posision_embeddings = memory_posision_embeddings.transpose(0, 1).unsqueeze(1)\n+        rope_position_embeddings = self.rotary_emb()\n+        rope_position_embeddings_k = self.rotary_emb_k()\n+        for layer in self.layers:\n+            output = layer(\n+                queries=output.unsqueeze(1) if output.ndim == 3 else output,\n+                keys=memory,\n+                key_point_embedding=memory_posision_embeddings,\n+                rope_position_embeddings=rope_position_embeddings,\n+                rope_position_embeddings_k=rope_position_embeddings_k,\n+                num_k_exclude_rope=num_object_pointer_tokens,\n+                rope_k_repeat=num_spatial_memory_tokens,\n+            )\n+\n+        normed_output = self.layer_norm(output)\n+\n+        # Convert back to seq first\n+        normed_output = normed_output.transpose(0, 1)\n+\n+        return normed_output\n+\n+\n+class EdgeTamVideoPerceiverMLP(nn.Module):\n+    def __init__(self, config: EdgeTamVideoConfig):\n+        super().__init__()\n+        self.hidden_size = config.perceiver_resampler_hidden_size\n+        self.intermediate_size = config.perceiver_resampler_mlp_intermediate_size\n+\n+        self.layer_norm = nn.LayerNorm(self.hidden_size)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=False)\n+        self.act_fn = nn.GELU()\n+\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        hidden_states = self.layer_norm(hidden_states)\n+        hidden_states = self.down_proj(self.act_fn(self.up_proj(hidden_states)))\n+        return hidden_states\n+\n+\n+class EdgeTamVideoPerceiverAttention(nn.Module):\n+    def __init__(self, config: EdgeTamVideoConfig):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.perceiver_resampler_hidden_size\n+        self.num_attention_heads = config.perceiver_resampler_num_attention_heads\n+        self.head_dim = config.perceiver_resampler_attention_head_dim\n+        self.attention_dropout = config.perceiver_resampler_attention_dropout\n+\n+        self.inner_dim = self.head_dim * self.num_attention_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.is_causal = False\n+\n+        self.q_proj = nn.Linear(self.hidden_size, self.inner_dim, bias=False)\n+        self.k_proj = nn.Linear(self.hidden_size, self.inner_dim, bias=False)\n+        self.v_proj = nn.Linear(self.hidden_size, self.inner_dim, bias=False)\n+        self.o_proj = nn.Linear(self.inner_dim, self.hidden_size, bias=False)\n+\n+    def forward(\n+        self,\n+        query: torch.Tensor,\n+        key: torch.Tensor,\n+        value: torch.Tensor,\n+        positional_encoding: Optional[torch.Tensor] = None,\n+        **kwargs,\n+    ) -> torch.Tensor:\n+        # Project queries, keys, and values\n+        query = self.q_proj(query)\n+        key = self.k_proj(key)\n+        value = self.v_proj(value)\n+\n+        # Reshape for multi-head attention\n+        batch_size, seq_len_q = query.shape[:2]\n+        query = query.view(batch_size, seq_len_q, self.num_attention_heads, self.head_dim).transpose(1, 2)\n+        seq_len_kv = key.shape[1]\n+        key = key.view(batch_size, seq_len_kv, self.num_attention_heads, self.head_dim).transpose(1, 2)\n+        value = value.view(batch_size, seq_len_kv, self.num_attention_heads, self.head_dim).transpose(1, 2)\n+\n+        # Add positional encoding if provided\n+        if positional_encoding is not None:\n+            pos_encoding = positional_encoding.view(\n+                batch_size, seq_len_kv, self.num_attention_heads, self.head_dim\n+            ).transpose(1, 2)\n+            key = key + pos_encoding\n+            value = value + pos_encoding\n+\n+        # Apply attention\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, _ = attention_interface(\n+            self,\n+            query,\n+            key,\n+            value,\n+            attention_mask=None,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            is_causal=self.is_causal,\n+            **kwargs,\n+        )\n+\n+        # Reshape output\n+        attn_output = attn_output.transpose(1, 2).contiguous().view(batch_size, seq_len_q, self.inner_dim)\n+        return self.o_proj(attn_output)\n+\n+\n+class EdgeTamVideoPerceiverEncoderLayer(nn.Module):\n+    def __init__(self, config: EdgeTamVideoConfig):\n+        super().__init__()\n+\n+        self.cross_attention = EdgeTamVideoPerceiverAttention(config)\n+        self.mlp = EdgeTamVideoPerceiverMLP(config)\n+        self.dropout = nn.Dropout(config.perceiver_resampler_hidden_dropout)\n+\n+        self.self_attention = EdgeTamVideoPerceiverAttention(config)\n+        self.self_mlp = EdgeTamVideoPerceiverMLP(config)\n+\n+        # Layer norms moved from attention classes to here\n+        self.layer_norm_input = nn.LayerNorm(config.perceiver_resampler_hidden_size)\n+        self.layer_norm_latents = nn.LayerNorm(config.perceiver_resampler_hidden_size)\n+        self.layer_norm_self = nn.LayerNorm(config.perceiver_resampler_hidden_size)\n+\n+    def forward(\n+        self,\n+        latents: torch.Tensor,\n+        input_features: torch.Tensor,\n+        positional_encoding: Optional[torch.Tensor] = None,\n+    ) -> torch.Tensor:\n+        # Cross attention with layer norms\n+        normalized_latents = self.layer_norm_latents(latents)\n+        normalized_input = self.layer_norm_input(input_features)\n+        cross_attention_output = self.cross_attention(\n+            query=normalized_latents,\n+            key=normalized_input,\n+            value=normalized_input,\n+            positional_encoding=positional_encoding,\n+        )\n+        latents = latents + self.dropout(cross_attention_output)\n+\n+        mlp_output = self.mlp(latents)\n+        latents = latents + mlp_output\n+\n+        # Self attention with layer norm\n+        normalized_latents_self = self.layer_norm_self(latents)\n+        self_attention_output = self.self_attention(\n+            query=normalized_latents_self, key=normalized_latents_self, value=normalized_latents_self\n+        )\n+        latents = latents + self_attention_output\n+\n+        self_mlp_output = self.self_mlp(latents)\n+        latents = latents + self_mlp_output\n+\n+        return latents\n+\n+\n+class EdgeTamVideoPerceiverResampler(nn.Module):\n+    def __init__(self, config: EdgeTamVideoConfig):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.perceiver_resampler_hidden_size\n+        self.num_latents_1d = config.perceiver_resampler_num_latents\n+        self.num_latents_2d = config.perceiver_resampler_num_latents_2d\n+        self.num_layers = config.perceiver_resampler_num_layers\n+\n+        if self.num_latents_1d > 0:\n+            self.latents_1d = nn.Parameter(torch.randn(self.num_latents_1d, self.hidden_size))\n+        if self.num_latents_2d > 0:\n+            self.latents_2d = nn.Parameter(torch.randn(self.num_latents_2d, self.hidden_size))\n+\n+        self.positional_encoding = EdgeTamVideoPositionEmbeddingSine(\n+            num_pos_feats=self.hidden_size // 2, normalize=True\n+        )\n+\n+        self.layers = nn.ModuleList([EdgeTamVideoPerceiverEncoderLayer(config) for _ in range(self.num_layers)])\n+\n+        self.layer_norm = nn.LayerNorm(self.hidden_size)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        positional_encoding: Optional[torch.Tensor] = None,\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor]]:\n+        output_latents = []\n+        output_positional_encodings = []\n+\n+        if self.num_latents_1d > 0:\n+            latents_1d, pos_1d = self._forward_1d(hidden_states, positional_encoding)\n+            output_latents.append(latents_1d)\n+            output_positional_encodings.append(pos_1d)\n+\n+        if self.num_latents_2d > 0:\n+            latents_2d, pos_2d = self._forward_2d(hidden_states)\n+            output_latents.append(latents_2d)\n+            output_positional_encodings.append(pos_2d)\n+\n+        combined_latents = torch.cat(output_latents, dim=1)\n+\n+        combined_positional_encoding = None\n+        if positional_encoding is not None and output_positional_encodings:\n+            combined_positional_encoding = torch.cat(output_positional_encodings, dim=1)\n+\n+        return combined_latents, combined_positional_encoding\n+\n+    def _forward_1d(\n+        self,\n+        hidden_states: torch.Tensor,\n+        positional_encoding: Optional[torch.Tensor] = None,\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor]]:\n+        batch_size = hidden_states.shape[0]\n+\n+        latents = self.latents_1d.unsqueeze(0).expand(batch_size, -1, -1)\n+        flattened_features = hidden_states.permute(0, 2, 3, 1).flatten(1, 2)\n+\n+        positional_features = None\n+        if positional_encoding is not None:\n+            positional_features = positional_encoding.permute(0, 2, 3, 1).flatten(1, 2)\n+\n+        for layer in self.layers:\n+            latents = layer(latents, flattened_features, positional_features)\n+\n+        latents = self.layer_norm(latents)\n+\n+        output_positional_encoding = None\n+        if positional_encoding is not None:\n+            output_positional_encoding = torch.zeros_like(latents)\n+\n+        return latents, output_positional_encoding\n+\n+    def _forward_2d(self, hidden_states: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n+        batch_size, channels, height, width = hidden_states.shape\n+\n+        latents_2d = self.latents_2d.unsqueeze(0).expand(batch_size, -1, -1).view(-1, 1, channels)\n+\n+        num_windows_per_dim = int(math.sqrt(self.num_latents_2d))\n+        window_size = height // num_windows_per_dim\n+\n+        windowed_input = hidden_states.permute(0, 2, 3, 1)\n+        windowed_features, _ = window_partition(windowed_input, window_size)\n+        windowed_features = windowed_features.flatten(1, 2)\n+\n+        for layer in self.layers:\n+            latents_2d = layer(latents_2d, windowed_features, positional_encoding=None)\n+\n+        latents_2d = latents_2d.view(batch_size, num_windows_per_dim, num_windows_per_dim, channels).permute(\n+            0, 3, 1, 2\n+        )\n+\n+        positional_encoding_2d = self.positional_encoding(latents_2d.shape, latents_2d.device, latents_2d.dtype).to(\n+            dtype=hidden_states.dtype\n+        )\n+        positional_encoding_2d = positional_encoding_2d.permute(0, 2, 3, 1).flatten(1, 2)\n+\n+        latents_2d = latents_2d.permute(0, 2, 3, 1).flatten(1, 2)\n+        latents_2d = self.layer_norm(latents_2d)\n+\n+        return latents_2d, positional_encoding_2d\n+\n+\n+@auto_docstring\n+class EdgeTamVideoModel(Sam2VideoModel):\n+    _tied_weights_keys = [\"prompt_encoder.shared_embedding.positional_embedding\"]\n+    # need to be ignored, as it's a buffer and will not be correctly detected as tied weight\n+    _keys_to_ignore_on_load_missing = [\"prompt_encoder.shared_embedding.positional_embedding\"]\n+    _keys_to_ignore_on_load_unexpected = []\n+    _can_record_outputs = {\"mask_decoder_attentions\": OutputRecorder(EdgeTamVideoTwoWayAttentionBlock, index=2)}\n+\n+    def __init__(self, config: EdgeTamVideoConfig):\n+        super().__init__(config)\n+        self.spatial_perceiver = EdgeTamVideoPerceiverResampler(config)\n+\n+        self.post_init()\n+\n+    def _build_memory_attention_inputs(\n+        self,\n+        temporal_positions_and_previous_outputs: list[tuple[int, dict]],\n+        device: torch.device,\n+    ) -> tuple[list[torch.Tensor], list[torch.Tensor]]:\n+        \"\"\"\n+        Concatenate memory features and positional embeddings from previous frames.\n+\n+        Returns:\n+            Tuple of (memories_to_concatenate, memory_positional_embeddings_to_concatenate).\n+        \"\"\"\n+        memories_to_concatenate = []\n+        memory_positional_embeddings_to_concatenate = []\n+\n+        for relative_temporal_offset, prev_output_data in temporal_positions_and_previous_outputs:\n+            if prev_output_data is None:\n+                continue  # Skip if no output data for this temporal position (e.g., padding frames)\n+\n+            # Load memory features (potentially from CPU to GPU)\n+            # Features are flattened: (Batch, Channels, H, W) -> (H*W, Batch, Channels)\n+            memory_features = prev_output_data[\"maskmem_features\"].to(device, non_blocking=True)\n+            memories_to_concatenate.append(memory_features.permute(1, 0, 2))\n+\n+            # Spatial positional encoding (potentially from CPU to GPU)\n+            spatial_memory_pos_embed = prev_output_data[\"maskmem_pos_enc\"].to(device, non_blocking=True)\n+            spatial_memory_pos_embed = spatial_memory_pos_embed.squeeze(1).permute(1, 0, 2)\n+\n+            # Add temporal positional encoding\n+            # self.memory_temporal_positional_encoding shape: (NumMaskMem, 1, 1, MemDim)\n+            combined_memory_pos_embed = (\n+                spatial_memory_pos_embed + self.memory_temporal_positional_encoding[relative_temporal_offset - 1]\n+            )\n+            memory_positional_embeddings_to_concatenate.append(combined_memory_pos_embed)\n+\n+        return memories_to_concatenate, memory_positional_embeddings_to_concatenate\n+\n+    def _prepare_memory_conditioned_features(\n+        self,\n+        inference_session: EdgeTamVideoInferenceSession,\n+        frame_idx: int,\n+        obj_idx: int,\n+        is_initial_conditioning_frame: bool,\n+        current_vision_features: list[torch.Tensor],\n+        current_vision_positional_embeddings: list[torch.Tensor],\n+        num_total_frames: int,\n+        track_in_reverse_time: bool = False,\n+        streaming: bool = False,\n+    ) -> torch.Tensor:\n+        \"\"\"\n+        Fuse current frame's visual features with memory from previous frames for enhanced object tracking.\n+\n+        This method conditions the current frame's visual features on temporal memory from previous frames,\n+        enabling consistent object tracking across video sequences. For initial conditioning frames, it uses\n+        no-memory embeddings. For subsequent frames, it retrieves and integrates memory features from both\n+        conditioning frames (user interactions) and non-conditioning frames (tracked results) via cross-attention.\n+\n+        Args:\n+            inference_session (`EdgeTamVideoInferenceSession`):\n+                The video inference session object.\n+            frame_idx (`int`):\n+                Index of the current frame being processed.\n+            obj_idx (`int`):\n+                Index of the object being processed.\n+            is_initial_conditioning_frame (`bool`):\n+                Whether this is an initial conditioning frame with user inputs (True) or a subsequent\n+                tracking frame (False).\n+            current_vision_features (`torch.Tensor`):\n+                Highest-level vision features of shape `(seq_len, batch_size, channels)`.\n+            current_vision_positional_embeddings (`torch.Tensor`):\n+                Positional embedding tensors corresponding to the highest-level vision features.\n+            num_total_frames (`int`):\n+                Total number of frames in the video sequence.\n+            track_in_reverse_time (`bool`, *optional*, defaults to `False`):\n+                Whether tracking is performed in reverse temporal order.\n+            streaming (`bool`, *optional*, defaults to `False`):\n+                Whether this is streaming inference mode.\n+\n+        Returns:\n+            `torch.Tensor`: Memory-conditioned feature tensor of shape `(batch_size, channels, height, width)`\n+                suitable for input to the SAM decoder.\n+        \"\"\"\n+        # Get dimensions from the highest-level (lowest-resolution) feature map\n+        batch_size = current_vision_features.size(1)\n+        num_channels = self.hidden_dim\n+        height, width = self.backbone_feature_sizes[-1]\n+        device = current_vision_features.device\n+\n+        # If memory is disabled (e.g., for single image SAM), return current features directly.\n+        if self.num_maskmem == 0:\n+            # Permute (SeqLen, Batch, Channels) -> (Batch, Channels, SeqLen) then view as (Batch, Channels, Height, Width)\n+            # Assuming SeqLen = Height * Width for the last feature map\n+            current_feature_map = current_vision_features.permute(1, 2, 0).view(\n+                batch_size, num_channels, height, width\n+            )\n+            return current_feature_map\n+\n+        # Step 1: Handle initial conditioning frames\n+        if is_initial_conditioning_frame:\n+            # For initial conditioning frames, no prior memory is used directly in this block.\n+            # If configured, directly add a learnable \"no memory\" embedding.\n+            # current_vision_features has shape (SeqLen, Batch, Channels)\n+            conditioned_feature_map_flat = current_vision_features + self.no_memory_embedding\n+            # Reshape to (Batch, Channels, Height, Width)\n+            conditioned_feature_map = conditioned_feature_map_flat.permute(1, 2, 0).view(\n+                batch_size, num_channels, height, width\n+            )\n+            return conditioned_feature_map\n+\n+        # Step 2: Get memory frames and concatenate their features\n+        temporal_positions_and_previous_outputs = self._gather_memory_frame_outputs(\n+            inference_session, obj_idx, frame_idx, track_in_reverse_time\n+        )\n+\n+        memories_to_concatenate, memory_positional_embeddings_to_concatenate = self._build_memory_attention_inputs(\n+            temporal_positions_and_previous_outputs, device\n+        )\n+        num_spatial_memory_tokens = len(memories_to_concatenate)\n+\n+        # Step 3: Get and process object pointers\n+        temporal_offsets, pointer_tokens, max_object_pointers_to_use = self._get_object_pointers(\n+            inference_session, obj_idx, frame_idx, num_total_frames, device, track_in_reverse_time, streaming\n+        )\n+\n+        num_object_pointer_tokens = 0\n+        if pointer_tokens:\n+            object_pointers, object_pointers_pos_embed = self._process_object_pointers(\n+                temporal_offsets, pointer_tokens, max_object_pointers_to_use, batch_size, num_channels, device\n+            )\n+\n+            if object_pointers is not None:\n+                memories_to_concatenate.append(object_pointers)\n+                memory_positional_embeddings_to_concatenate.append(object_pointers_pos_embed)\n+                num_object_pointer_tokens = object_pointers.shape[0]\n+\n+        # Step 4: Concatenate all retrieved memories and their positional embeddings\n+        combined_memory = torch.cat(memories_to_concatenate, dim=0)\n+        combined_memory_positional_embeddings = torch.cat(memory_positional_embeddings_to_concatenate, dim=0)\n+\n+        # Step 5: Forward through the memory attention mechanism\n+        conditioned_feature_map_flat = self.memory_attention(\n+            current_vision_features=current_vision_features,\n+            current_vision_position_embeddings=current_vision_positional_embeddings,\n+            memory=combined_memory,\n+            memory_posision_embeddings=combined_memory_positional_embeddings,  # Corrected typo from API\n+            num_object_pointer_tokens=num_object_pointer_tokens,\n+            num_spatial_memory_tokens=num_spatial_memory_tokens,\n+        )\n+\n+        # Reshape from (Batch, H*W, Channels) to (Batch, Channels, Height, Width)\n+        conditioned_feature_map = (\n+            conditioned_feature_map_flat.squeeze(1).permute(0, 2, 1).view(batch_size, num_channels, height, width)\n+        )\n+        return conditioned_feature_map\n+\n+    def _encode_new_memory(\n+        self,\n+        current_vision_feats: torch.Tensor,\n+        pred_masks_high_res: torch.Tensor,\n+        object_score_logits: torch.Tensor,\n+        is_mask_from_pts: bool,\n+    ) -> tuple[torch.Tensor, list[torch.Tensor]]:\n+        \"\"\"Encode the current image and its prediction into a memory feature.\"\"\"\n+        batch_size = current_vision_feats.size(1)  # batch size on this frame\n+        channels = self.hidden_dim\n+        height, width = self.backbone_feature_sizes[-1]  # top-level (lowest-resolution) feature size\n+        # top-level feature, (HW)BC => BCHW\n+        pix_feat = current_vision_feats.permute(1, 2, 0).view(batch_size, channels, height, width)\n+        if is_mask_from_pts and not self.training:\n+            # binarize the mask logits\n+            mask_for_mem = (pred_masks_high_res > 0).to(pred_masks_high_res.dtype)\n+        else:\n+            # apply sigmoid on the raw mask logits to turn them into range (0, 1)\n+            mask_for_mem = torch.sigmoid(pred_masks_high_res)\n+        # apply scale and bias terms to the sigmoid probabilities\n+        mask_for_mem = mask_for_mem * self.config.sigmoid_scale_for_mem_enc\n+        mask_for_mem = mask_for_mem + self.config.sigmoid_bias_for_mem_enc\n+\n+        maskmem_features, maskmem_pos_enc = self.memory_encoder(\n+            pix_feat,\n+            mask_for_mem,\n+        )\n+        # add a no-object embedding to the spatial memory to indicate that the frame\n+        # is predicted to be occluded (i.e. no object is appearing in the frame)\n+        if self.occlusion_spatial_embedding_parameter is not None:\n+            is_obj_appearing = (object_score_logits > 0).float()\n+            maskmem_features += (1 - is_obj_appearing[..., None]) * self.occlusion_spatial_embedding_parameter[\n+                ..., None, None\n+            ].expand(*maskmem_features.shape)\n+\n+        maskmem_pos_enc = maskmem_pos_enc.to(pred_masks_high_res.dtype)\n+        maskmem_features, maskmem_pos_enc = self.spatial_perceiver(maskmem_features, maskmem_pos_enc)\n+        maskmem_features = maskmem_features.to(pred_masks_high_res.dtype)\n+        maskmem_pos_enc = maskmem_pos_enc.to(pred_masks_high_res.dtype)\n+\n+        return maskmem_features, maskmem_pos_enc\n+\n+\n+__all__ = [\n+    \"EdgeTamVideoMaskDecoderConfig\",\n+    \"EdgeTamVideoPromptEncoderConfig\",\n+    \"EdgeTamVideoConfig\",\n+    \"EdgeTamVideoModel\",\n+    \"EdgeTamVideoInferenceSession\",\n+    \"EdgeTamVideoPreTrainedModel\",\n+]"
        },
        {
            "sha": "47b5b47d363034d4daf39065f2c778cb453799be",
            "filename": "src/transformers/models/gemma3n/configuration_gemma3n.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fconfiguration_gemma3n.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fconfiguration_gemma3n.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3n%2Fconfiguration_gemma3n.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -551,8 +551,8 @@ def from_dict(cls, config_dict: dict[str, Any], **kwargs):\n \n     def to_dict(self) -> dict[str, Any]:\n         output = super().to_dict()\n-        output[\"num_classes\"] = self.num_labels\n-        output[\"label_names\"] = list(self.id2label.values())\n+        output.setdefault(\"num_classes\", self.num_labels)\n+        output.setdefault(\"label_names\", list(self.id2label.values()))\n         output.pop(\"id2label\", None)\n         output.pop(\"label2id\", None)\n         return output"
        },
        {
            "sha": "e14583181d38abfff63209160ab2a6eb5219a05f",
            "filename": "src/transformers/models/sam2/configuration_sam2.py",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fsam2%2Fconfiguration_sam2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fsam2%2Fconfiguration_sam2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fsam2%2Fconfiguration_sam2.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -379,8 +379,6 @@ class Sam2Config(PretrainedConfig):\n             Dictionary of configuration options used to initialize [`Sam2MaskDecoderConfig`].\n         initializer_range (`float`, *optional*, defaults to 0.02):\n             Standard deviation for parameter initialization.\n-        kwargs (*optional*):\n-            Dictionary of keyword arguments.\n \n     Example:\n "
        },
        {
            "sha": "cc2ee0c7c61286e4f6b6e36df519d4415cdb83c6",
            "filename": "src/transformers/models/sam2_video/convert_sam2_video_to_hf.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fsam2_video%2Fconvert_sam2_video_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fsam2_video%2Fconvert_sam2_video_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fsam2_video%2Fconvert_sam2_video_to_hf.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -190,7 +190,7 @@ def replace_keys(state_dict, config):\n         if re.match(output_vision_encoder_neck_pattern, key):\n             key = key.replace(\".conv.\", \".\")\n \n-        # memory_encoder.out_proj.weight -> memory_encoder.projection.weight\n+        # memory_encoder.o_proj.weight -> memory_encoder.projection.weight\n         if re.match(output_memory_encoder_projection_pattern, key):\n             key = key.replace(\".o_proj.\", \".projection.\")\n "
        },
        {
            "sha": "caa07d1f63b5ec1586a11ebc26524ae1deb91095",
            "filename": "src/transformers/models/sam2_video/modeling_sam2_video.py",
            "status": "modified",
            "additions": 230,
            "deletions": 137,
            "changes": 367,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fsam2_video%2Fmodeling_sam2_video.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fsam2_video%2Fmodeling_sam2_video.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fsam2_video%2Fmodeling_sam2_video.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -134,8 +134,10 @@ def __init__(\n         dtype: Union[torch.dtype, str] = \"float32\",\n         max_vision_features_cache_size: int = 1,\n     ):\n-        # store as a list to avoid double memory allocation with torch.cat when adding new frames\n-        self.processed_frames = list(video.to(video_storage_device, dtype=dtype)) if video is not None else None\n+        # store as a dictionary to avoid double memory allocation with torch.cat when adding new frames\n+        self.processed_frames = (\n+            dict(enumerate(video.to(video_storage_device, dtype=dtype))) if video is not None else None\n+        )\n         self.video_height = video_height\n         self.video_width = video_width\n \n@@ -293,18 +295,21 @@ def get_output(\n         return value\n \n     # Video frame management\n-    def add_new_frame(self, pixel_values: torch.Tensor) -> int:\n+    def add_new_frame(self, pixel_values: torch.Tensor, frame_idx: Optional[int] = None) -> int:\n         \"\"\"Add new frame with automatic device placement.\"\"\"\n         pixel_values = pixel_values.to(self.video_storage_device, dtype=self.dtype, non_blocking=True)\n         if pixel_values.dim() == 4:\n             pixel_values = pixel_values.squeeze(0)\n \n+        if frame_idx is None:\n+            frame_idx = len(self.processed_frames) if self.processed_frames is not None else 0\n+\n         if self.processed_frames is None:\n-            self.processed_frames = [pixel_values]\n+            self.processed_frames = {frame_idx: pixel_values}\n         else:\n-            self.processed_frames.append(pixel_values)\n+            self.processed_frames[frame_idx] = pixel_values\n \n-        return self.num_frames - 1\n+        return frame_idx\n \n     def get_frame(self, frame_idx: int) -> torch.Tensor:\n         \"\"\"Get frame from video.\"\"\"\n@@ -1714,7 +1719,7 @@ def forward(\n             Whether to propagate in reverse.\n         \"\"\"\n         if frame is not None:\n-            frame_idx = inference_session.add_new_frame(frame)\n+            frame_idx = inference_session.add_new_frame(frame, frame_idx)\n \n         if frame is not None and inference_session.get_obj_num() == 0:\n             raise ValueError(\"No objects are provided for tracking; please add inputs first.\")\n@@ -2097,6 +2102,195 @@ def _use_mask_as_output(\n             image_embeddings=high_res_features + [backbone_features],\n         )\n \n+    def _gather_memory_frame_outputs(\n+        self,\n+        inference_session: Sam2VideoInferenceSession,\n+        obj_idx: int,\n+        frame_idx: int,\n+        track_in_reverse_time: bool = False,\n+    ) -> list[tuple[int, dict]]:\n+        \"\"\"\n+        Get memory frames from conditioning and non-conditioning outputs.\n+\n+        Returns:\n+            List of (relative_temporal_offset, output_data) tuples.\n+        \"\"\"\n+        temporal_positions_and_previous_outputs = []\n+\n+        # Add conditioning frame outputs (no limit here, as is the case in the original checkpoints)\n+        conditioning_outputs = inference_session.output_dict_per_obj[obj_idx][\"cond_frame_outputs\"]\n+        if not conditioning_outputs:\n+            raise ValueError(\n+                \"maskmem_features in conditioning outputs cannot be empty when not is_initial_conditioning_frame\"\n+            )\n+\n+        # Store (temporal_position, output_data) tuples\n+        temporal_positions_and_previous_outputs = [(0, out) for out in conditioning_outputs.values()]\n+\n+        # Add non-conditioning memory frames (up to self.num_maskmem - 1)\n+        # These are typically frames tracked by the model without direct user input.\n+        # Frames are selected with a stride, prioritizing the most recent ones. Here we only support stride = 1 for simplicity.\n+        for relative_temporal_offset in range(self.num_maskmem - 1, 0, -1):\n+            # relative_temporal_offset: how many frames before (or after if reversing) the current frame\n+            if not track_in_reverse_time:\n+                previous_frame_idx = frame_idx - relative_temporal_offset\n+            else:\n+                previous_frame_idx = frame_idx + relative_temporal_offset\n+\n+            # check if the output is already stored without using get_output to avoid unnecessary memory transfers between CPU and GPU\n+            output_data = inference_session.output_dict_per_obj[obj_idx][\"non_cond_frame_outputs\"].get(\n+                previous_frame_idx, None\n+            )\n+\n+            temporal_positions_and_previous_outputs.append((relative_temporal_offset, output_data))\n+\n+        return temporal_positions_and_previous_outputs\n+\n+    def _build_memory_attention_inputs(\n+        self,\n+        temporal_positions_and_previous_outputs: list[tuple[int, dict]],\n+        device: torch.device,\n+    ) -> tuple[list[torch.Tensor], list[torch.Tensor]]:\n+        \"\"\"\n+        Concatenate memory features and positional embeddings from previous frames.\n+\n+        Returns:\n+            Tuple of (memories_to_concatenate, memory_positional_embeddings_to_concatenate).\n+        \"\"\"\n+        memories_to_concatenate = []\n+        memory_positional_embeddings_to_concatenate = []\n+\n+        for relative_temporal_offset, prev_output_data in temporal_positions_and_previous_outputs:\n+            if prev_output_data is None:\n+                continue  # Skip if no output data for this temporal position (e.g., padding frames)\n+\n+            # Load memory features (potentially from CPU to GPU)\n+            # Features are flattened: (Batch, Channels, H, W) -> (H*W, Batch, Channels)\n+            memory_features = prev_output_data[\"maskmem_features\"].to(device, non_blocking=True)\n+            memories_to_concatenate.append(memory_features)\n+\n+            # Spatial positional encoding (potentially from CPU to GPU)\n+            spatial_memory_pos_embed = prev_output_data[\"maskmem_pos_enc\"].to(device, non_blocking=True)\n+\n+            # Add temporal positional encoding\n+            # self.memory_temporal_positional_encoding shape: (NumMaskMem, 1, 1, MemDim)\n+            combined_memory_pos_embed = (\n+                spatial_memory_pos_embed + self.memory_temporal_positional_encoding[relative_temporal_offset - 1]\n+            )\n+            memory_positional_embeddings_to_concatenate.append(combined_memory_pos_embed)\n+\n+        return memories_to_concatenate, memory_positional_embeddings_to_concatenate\n+\n+    def _get_object_pointers(\n+        self,\n+        inference_session: Sam2VideoInferenceSession,\n+        obj_idx: int,\n+        frame_idx: int,\n+        num_total_frames: int,\n+        device: torch.device,\n+        track_in_reverse_time: bool = False,\n+        streaming: bool = False,\n+    ) -> tuple[list[int], list[torch.Tensor], int]:\n+        \"\"\"\n+        Get object pointers and their positional embeddings from past frames.\n+\n+        Returns:\n+            Tuple of (temporal_offsets, pointer_tokens, max_object_pointers_to_use).\n+        \"\"\"\n+        temporal_position_sign_multiplier = -1 if track_in_reverse_time else 1\n+\n+        # Determine max object pointers to use\n+        if streaming:\n+            max_object_pointers_to_use = self.config.max_object_pointers_in_encoder\n+        else:\n+            max_object_pointers_to_use = min(num_total_frames, self.config.max_object_pointers_in_encoder)\n+\n+        temporal_offsets: list[int] = []\n+        pointer_tokens: list[torch.Tensor] = []\n+\n+        # Add object pointers from selected conditioning frames\n+        # Optionally, only include pointers from past frames during evaluation\n+        conditioning_outputs = inference_session.output_dict_per_obj[obj_idx][\"cond_frame_outputs\"]\n+        eligible_conditioning_outputs = conditioning_outputs\n+        if not self.training:\n+            eligible_conditioning_outputs = {\n+                temporal_idx: out\n+                for temporal_idx, out in conditioning_outputs.items()\n+                if (temporal_idx >= frame_idx if track_in_reverse_time else temporal_idx <= frame_idx)\n+            }\n+\n+        for temporal_idx, out_data in eligible_conditioning_outputs.items():\n+            temporal_difference = (frame_idx - temporal_idx) * temporal_position_sign_multiplier\n+            temporal_offsets.append(temporal_difference)\n+            pointer_tokens.append(out_data[\"object_pointer\"].to(device))\n+\n+        # Add object pointers from non-conditioning frames (up to max_object_pointers_to_use - 1)\n+        for t_diff_offset in range(1, max_object_pointers_to_use):\n+            ref_frame_idx = frame_idx + t_diff_offset if track_in_reverse_time else frame_idx - t_diff_offset\n+            if ref_frame_idx < 0 or (\n+                not streaming and num_total_frames is not None and ref_frame_idx >= num_total_frames\n+            ):\n+                break  # Stop if frame index is out of bounds\n+\n+            # check if the output is already stored without using get_output to avoid unnecessary memory transfers between CPU and GPU\n+            out_data = inference_session.output_dict_per_obj[obj_idx][\"non_cond_frame_outputs\"].get(\n+                ref_frame_idx, None\n+            )\n+            if out_data is not None:\n+                temporal_offsets.append(t_diff_offset)\n+                pointer_tokens.append(out_data[\"object_pointer\"].to(device))\n+\n+        return temporal_offsets, pointer_tokens, max_object_pointers_to_use\n+\n+    def _process_object_pointers(\n+        self,\n+        temporal_offsets: list[int],\n+        pointer_tokens: list[torch.Tensor],\n+        max_object_pointers_to_use: int,\n+        batch_size: int,\n+        num_channels: int,\n+        device: torch.device,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Process object pointers and compute their positional embeddings.\n+\n+        Returns:\n+            Tuple of (object_pointers, object_pointers_pos_embed).\n+        \"\"\"\n+        if not pointer_tokens:\n+            return None, None\n+\n+        # Stack object pointers: List of (Batch, Channels) -> (SeqLen_ptr, Batch, Channels)\n+        object_pointers = torch.stack(pointer_tokens, dim=0)\n+\n+        if self.config.enable_temporal_pos_encoding_for_object_pointers:\n+            max_temporal_diff = float(max_object_pointers_to_use - 1)\n+            # Determine dimensionality for temporal positional encoding of pointers\n+            pointer_tpos_dim = num_channels\n+\n+            # Normalize temporal differences before sine PE calculation\n+            normalized_temporal_diffs = (\n+                torch.tensor(temporal_offsets, device=device, dtype=torch.float32) / max_temporal_diff\n+            )\n+            sine_pe = get_1d_sine_pe(normalized_temporal_diffs, dim=pointer_tpos_dim).to(object_pointers.dtype)\n+            projected_sine_pe = self.temporal_positional_encoding_projection_layer(sine_pe)\n+            object_pointers_pos_embed = projected_sine_pe.unsqueeze(1).expand(-1, batch_size, self.mem_dim)\n+        else:\n+            object_pointers_pos_embed = object_pointers.new_zeros(\n+                len(temporal_offsets), batch_size, self.mem_dim, dtype=object_pointers.dtype\n+            )\n+\n+        if self.mem_dim < num_channels:\n+            # If memory dimension is smaller, reshape/split pointers and repeat positional encoding\n+            num_splits = num_channels // self.mem_dim\n+            object_pointers = object_pointers.reshape(-1, batch_size, num_splits, self.mem_dim)\n+            object_pointers = object_pointers.permute(0, 2, 1, 3).flatten(\n+                0, 1\n+            )  # (SeqLen_ptr*num_splits, Batch, MemDim)\n+            object_pointers_pos_embed = object_pointers_pos_embed.repeat_interleave(num_splits, dim=0)\n+\n+        return object_pointers, object_pointers_pos_embed\n+\n     def _prepare_memory_conditioned_features(\n         self,\n         inference_session: Sam2VideoInferenceSession,\n@@ -2157,135 +2351,9 @@ def _prepare_memory_conditioned_features(\n             )\n             return current_feature_map\n \n-        num_object_pointer_tokens = 0\n-        temporal_position_sign_multiplier = -1 if track_in_reverse_time else 1\n-\n-        # Step 1: Condition the visual features of the current frame on previous memories\n-        if not is_initial_conditioning_frame:\n-            # Retrieve memories encoded from previous frames\n-            memories_to_concatenate = []\n-            memory_positional_embeddings_to_concatenate = []\n-\n-            # Ensure there are conditioning frame outputs to process\n-            conditioning_outputs = inference_session.output_dict_per_obj[obj_idx][\"cond_frame_outputs\"]\n-            if not conditioning_outputs:\n-                raise ValueError(\n-                    \"maskmem_features in conditioning outputs cannot be empty when not is_initial_conditioning_frame\"\n-                )\n-\n-            # Select a maximum number of temporally closest conditioning frames for cross-attention (no limit here, as is the case in the original checkpoints)\n-            # Store (temporal_position, output_data) tuples\n-            temporal_positions_and_previous_outputs = [(0, out) for out in conditioning_outputs.values()]\n-\n-            # Add non-conditioning memory frames (up to self.num_maskmem - 1)\n-            # These are typically frames tracked by the model without direct user input.\n-            # Frames are selected with a stride, prioritizing the most recent ones. Here we only support stride = 1 for simplicity.\n-            for relative_temporal_offset in range(self.num_maskmem - 1, 0, -1):\n-                # relative_temporal_offset: how many frames before (or after if reversing) the current frame\n-                if not track_in_reverse_time:\n-                    previous_frame_idx = frame_idx - relative_temporal_offset\n-                else:\n-                    previous_frame_idx = frame_idx + relative_temporal_offset\n-\n-                # check if the output is already stored without using get_output to avoid unnecessary memory transfers between CPU and GPU\n-                output_data = inference_session.output_dict_per_obj[obj_idx][\"non_cond_frame_outputs\"].get(\n-                    previous_frame_idx, None\n-                )\n-\n-                temporal_positions_and_previous_outputs.append((relative_temporal_offset, output_data))\n-\n-            for relative_temporal_offset, prev_output_data in temporal_positions_and_previous_outputs:\n-                if prev_output_data is None:\n-                    continue  # Skip if no output data for this temporal position (e.g., padding frames)\n-\n-                # Load memory features (potentially from CPU to GPU)\n-                # Features are flattened: (Batch, Channels, H, W) -> (H*W, Batch, Channels)\n-                memory_features = prev_output_data[\"maskmem_features\"].to(device, non_blocking=True)\n-                memories_to_concatenate.append(memory_features)\n-\n-                # Spatial positional encoding (potentially from CPU to GPU)\n-                spatial_memory_pos_embed = prev_output_data[\"maskmem_pos_enc\"].to(device, non_blocking=True)\n-\n-                # Add temporal positional encoding\n-                # self.memory_temporal_positional_encoding shape: (NumMaskMem, 1, 1, MemDim)\n-                combined_memory_pos_embed = (\n-                    spatial_memory_pos_embed + self.memory_temporal_positional_encoding[relative_temporal_offset - 1]\n-                )\n-                memory_positional_embeddings_to_concatenate.append(combined_memory_pos_embed)\n-\n-            # Construct the list of past object pointers to be used in attention\n-            if streaming:\n-                max_object_pointers_to_use = self.config.max_object_pointers_in_encoder\n-            else:\n-                max_object_pointers_to_use = min(num_total_frames, self.config.max_object_pointers_in_encoder)\n-            temporal_diff_and_pointers = []\n-\n-            # Add object pointers from selected conditioning frames\n-            # Optionally, only include pointers from past frames during evaluation\n-            eligible_conditioning_outputs = conditioning_outputs\n-            if not self.training:\n-                eligible_conditioning_outputs = {\n-                    temporal_idx: out\n-                    for temporal_idx, out in conditioning_outputs.items()\n-                    if (temporal_idx >= frame_idx if track_in_reverse_time else temporal_idx <= frame_idx)\n-                }\n-\n-            for temporal_idx, out_data in eligible_conditioning_outputs.items():\n-                temporal_difference = (frame_idx - temporal_idx) * temporal_position_sign_multiplier\n-                temporal_diff_and_pointers.append((temporal_difference, out_data[\"object_pointer\"]))\n-\n-            # Add object pointers from non-conditioning frames (up to max_object_pointers_to_use - 1)\n-            for t_diff_offset in range(1, max_object_pointers_to_use):\n-                ref_frame_idx = frame_idx + t_diff_offset if track_in_reverse_time else frame_idx - t_diff_offset\n-                if ref_frame_idx < 0 or (\n-                    not streaming and num_total_frames is not None and ref_frame_idx >= num_total_frames\n-                ):\n-                    break  # Stop if frame index is out of bounds\n-\n-                # check if the output is already stored without using get_output to avoid unnecessary memory transfers between CPU and GPU\n-                out_data = inference_session.output_dict_per_obj[obj_idx][\"non_cond_frame_outputs\"].get(\n-                    ref_frame_idx, None\n-                )\n-                if out_data is not None:\n-                    temporal_diff_and_pointers.append((t_diff_offset, out_data[\"object_pointer\"]))\n-\n-            if temporal_diff_and_pointers:\n-                temporal_differences, object_pointers_list = zip(*temporal_diff_and_pointers)\n-                # Stack object pointers: List of (Batch, Channels) -> (SeqLen_ptr, Batch, Channels)\n-                object_pointers = torch.stack(object_pointers_list, dim=0)\n-\n-                if self.config.enable_temporal_pos_encoding_for_object_pointers:\n-                    max_temporal_diff = float(max_object_pointers_to_use - 1)\n-                    # Determine dimensionality for temporal positional encoding of pointers\n-                    pointer_tpos_dim = num_channels\n-\n-                    # Normalize temporal differences before sine PE calculation\n-                    normalized_temporal_diffs = (\n-                        torch.tensor(temporal_differences, device=device, dtype=torch.float32) / max_temporal_diff\n-                    )\n-                    sine_pe = get_1d_sine_pe(normalized_temporal_diffs, dim=pointer_tpos_dim).to(object_pointers.dtype)\n-                    projected_sine_pe = self.temporal_positional_encoding_projection_layer(sine_pe)\n-                    object_pointers_pos_embed = projected_sine_pe.unsqueeze(1).expand(-1, batch_size, self.mem_dim)\n-                else:\n-                    object_pointers_pos_embed = object_pointers.new_zeros(\n-                        len(temporal_differences), batch_size, self.mem_dim, dtype=object_pointers.dtype\n-                    )\n-\n-                if self.mem_dim < num_channels:\n-                    # If memory dimension is smaller, reshape/split pointers and repeat positional encoding\n-                    num_splits = num_channels // self.mem_dim\n-                    object_pointers = object_pointers.reshape(-1, batch_size, num_splits, self.mem_dim)\n-                    object_pointers = object_pointers.permute(0, 2, 1, 3).flatten(\n-                        0, 1\n-                    )  # (SeqLen_ptr*num_splits, Batch, MemDim)\n-                    object_pointers_pos_embed = object_pointers_pos_embed.repeat_interleave(num_splits, dim=0)\n-\n-                memories_to_concatenate.append(object_pointers)\n-                memory_positional_embeddings_to_concatenate.append(object_pointers_pos_embed)\n-                num_object_pointer_tokens = object_pointers.shape[0]\n-        else:\n+        # Step 1: Handle initial conditioning frames\n+        if is_initial_conditioning_frame:\n             # For initial conditioning frames, no prior memory is used directly in this block.\n-            # The model might handle this with a special token or mechanism.\n             # If configured, directly add a learnable \"no memory\" embedding.\n             # current_vision_features has shape (SeqLen, Batch, Channels)\n             conditioned_feature_map_flat = current_vision_features + self.no_memory_embedding\n@@ -2295,11 +2363,36 @@ def _prepare_memory_conditioned_features(\n             )\n             return conditioned_feature_map\n \n-        # Step 2: Concatenate all retrieved memories and their positional embeddings.\n+        # Step 2: Get memory frames and concatenate their features\n+        temporal_positions_and_previous_outputs = self._gather_memory_frame_outputs(\n+            inference_session, obj_idx, frame_idx, track_in_reverse_time\n+        )\n+\n+        memories_to_concatenate, memory_positional_embeddings_to_concatenate = self._build_memory_attention_inputs(\n+            temporal_positions_and_previous_outputs, device\n+        )\n+\n+        # Step 3: Get and process object pointers\n+        temporal_offsets, pointer_tokens, max_object_pointers_to_use = self._get_object_pointers(\n+            inference_session, obj_idx, frame_idx, num_total_frames, device, track_in_reverse_time, streaming\n+        )\n+\n+        num_object_pointer_tokens = 0\n+        if pointer_tokens:\n+            object_pointers, object_pointers_pos_embed = self._process_object_pointers(\n+                temporal_offsets, pointer_tokens, max_object_pointers_to_use, batch_size, num_channels, device\n+            )\n+\n+            if object_pointers is not None:\n+                memories_to_concatenate.append(object_pointers)\n+                memory_positional_embeddings_to_concatenate.append(object_pointers_pos_embed)\n+                num_object_pointer_tokens = object_pointers.shape[0]\n+\n+        # Step 4: Concatenate all retrieved memories and their positional embeddings\n         combined_memory = torch.cat(memories_to_concatenate, dim=0)\n         combined_memory_positional_embeddings = torch.cat(memory_positional_embeddings_to_concatenate, dim=0)\n \n-        # Step 3: Forward through the memory attention mechanism.\n+        # Step 5: Forward through the memory attention mechanism\n         conditioned_feature_map_flat = self.memory_attention(\n             current_vision_features=current_vision_features,\n             current_vision_position_embeddings=current_vision_positional_embeddings,"
        },
        {
            "sha": "fa0d6c21d5e69ef6aac7218c4d674ea755a3f3fb",
            "filename": "src/transformers/models/sam2_video/modular_sam2_video.py",
            "status": "modified",
            "additions": 230,
            "deletions": 137,
            "changes": 367,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fsam2_video%2Fmodular_sam2_video.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Fsam2_video%2Fmodular_sam2_video.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fsam2_video%2Fmodular_sam2_video.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -403,8 +403,10 @@ def __init__(\n         dtype: Union[torch.dtype, str] = \"float32\",\n         max_vision_features_cache_size: int = 1,\n     ):\n-        # store as a list to avoid double memory allocation with torch.cat when adding new frames\n-        self.processed_frames = list(video.to(video_storage_device, dtype=dtype)) if video is not None else None\n+        # store as a dictionary to avoid double memory allocation with torch.cat when adding new frames\n+        self.processed_frames = (\n+            dict(enumerate(video.to(video_storage_device, dtype=dtype))) if video is not None else None\n+        )\n         self.video_height = video_height\n         self.video_width = video_width\n \n@@ -562,18 +564,21 @@ def get_output(\n         return value\n \n     # Video frame management\n-    def add_new_frame(self, pixel_values: torch.Tensor) -> int:\n+    def add_new_frame(self, pixel_values: torch.Tensor, frame_idx: Optional[int] = None) -> int:\n         \"\"\"Add new frame with automatic device placement.\"\"\"\n         pixel_values = pixel_values.to(self.video_storage_device, dtype=self.dtype, non_blocking=True)\n         if pixel_values.dim() == 4:\n             pixel_values = pixel_values.squeeze(0)\n \n+        if frame_idx is None:\n+            frame_idx = len(self.processed_frames) if self.processed_frames is not None else 0\n+\n         if self.processed_frames is None:\n-            self.processed_frames = [pixel_values]\n+            self.processed_frames = {frame_idx: pixel_values}\n         else:\n-            self.processed_frames.append(pixel_values)\n+            self.processed_frames[frame_idx] = pixel_values\n \n-        return self.num_frames - 1\n+        return frame_idx\n \n     def get_frame(self, frame_idx: int) -> torch.Tensor:\n         \"\"\"Get frame from video.\"\"\"\n@@ -1799,6 +1804,195 @@ def _use_mask_as_output(\n             image_embeddings=high_res_features + [backbone_features],\n         )\n \n+    def _gather_memory_frame_outputs(\n+        self,\n+        inference_session: Sam2VideoInferenceSession,\n+        obj_idx: int,\n+        frame_idx: int,\n+        track_in_reverse_time: bool = False,\n+    ) -> list[tuple[int, dict]]:\n+        \"\"\"\n+        Get memory frames from conditioning and non-conditioning outputs.\n+\n+        Returns:\n+            List of (relative_temporal_offset, output_data) tuples.\n+        \"\"\"\n+        temporal_positions_and_previous_outputs = []\n+\n+        # Add conditioning frame outputs (no limit here, as is the case in the original checkpoints)\n+        conditioning_outputs = inference_session.output_dict_per_obj[obj_idx][\"cond_frame_outputs\"]\n+        if not conditioning_outputs:\n+            raise ValueError(\n+                \"maskmem_features in conditioning outputs cannot be empty when not is_initial_conditioning_frame\"\n+            )\n+\n+        # Store (temporal_position, output_data) tuples\n+        temporal_positions_and_previous_outputs = [(0, out) for out in conditioning_outputs.values()]\n+\n+        # Add non-conditioning memory frames (up to self.num_maskmem - 1)\n+        # These are typically frames tracked by the model without direct user input.\n+        # Frames are selected with a stride, prioritizing the most recent ones. Here we only support stride = 1 for simplicity.\n+        for relative_temporal_offset in range(self.num_maskmem - 1, 0, -1):\n+            # relative_temporal_offset: how many frames before (or after if reversing) the current frame\n+            if not track_in_reverse_time:\n+                previous_frame_idx = frame_idx - relative_temporal_offset\n+            else:\n+                previous_frame_idx = frame_idx + relative_temporal_offset\n+\n+            # check if the output is already stored without using get_output to avoid unnecessary memory transfers between CPU and GPU\n+            output_data = inference_session.output_dict_per_obj[obj_idx][\"non_cond_frame_outputs\"].get(\n+                previous_frame_idx, None\n+            )\n+\n+            temporal_positions_and_previous_outputs.append((relative_temporal_offset, output_data))\n+\n+        return temporal_positions_and_previous_outputs\n+\n+    def _build_memory_attention_inputs(\n+        self,\n+        temporal_positions_and_previous_outputs: list[tuple[int, dict]],\n+        device: torch.device,\n+    ) -> tuple[list[torch.Tensor], list[torch.Tensor]]:\n+        \"\"\"\n+        Concatenate memory features and positional embeddings from previous frames.\n+\n+        Returns:\n+            Tuple of (memories_to_concatenate, memory_positional_embeddings_to_concatenate).\n+        \"\"\"\n+        memories_to_concatenate = []\n+        memory_positional_embeddings_to_concatenate = []\n+\n+        for relative_temporal_offset, prev_output_data in temporal_positions_and_previous_outputs:\n+            if prev_output_data is None:\n+                continue  # Skip if no output data for this temporal position (e.g., padding frames)\n+\n+            # Load memory features (potentially from CPU to GPU)\n+            # Features are flattened: (Batch, Channels, H, W) -> (H*W, Batch, Channels)\n+            memory_features = prev_output_data[\"maskmem_features\"].to(device, non_blocking=True)\n+            memories_to_concatenate.append(memory_features)\n+\n+            # Spatial positional encoding (potentially from CPU to GPU)\n+            spatial_memory_pos_embed = prev_output_data[\"maskmem_pos_enc\"].to(device, non_blocking=True)\n+\n+            # Add temporal positional encoding\n+            # self.memory_temporal_positional_encoding shape: (NumMaskMem, 1, 1, MemDim)\n+            combined_memory_pos_embed = (\n+                spatial_memory_pos_embed + self.memory_temporal_positional_encoding[relative_temporal_offset - 1]\n+            )\n+            memory_positional_embeddings_to_concatenate.append(combined_memory_pos_embed)\n+\n+        return memories_to_concatenate, memory_positional_embeddings_to_concatenate\n+\n+    def _get_object_pointers(\n+        self,\n+        inference_session: Sam2VideoInferenceSession,\n+        obj_idx: int,\n+        frame_idx: int,\n+        num_total_frames: int,\n+        device: torch.device,\n+        track_in_reverse_time: bool = False,\n+        streaming: bool = False,\n+    ) -> tuple[list[int], list[torch.Tensor], int]:\n+        \"\"\"\n+        Get object pointers and their positional embeddings from past frames.\n+\n+        Returns:\n+            Tuple of (temporal_offsets, pointer_tokens, max_object_pointers_to_use).\n+        \"\"\"\n+        temporal_position_sign_multiplier = -1 if track_in_reverse_time else 1\n+\n+        # Determine max object pointers to use\n+        if streaming:\n+            max_object_pointers_to_use = self.config.max_object_pointers_in_encoder\n+        else:\n+            max_object_pointers_to_use = min(num_total_frames, self.config.max_object_pointers_in_encoder)\n+\n+        temporal_offsets: list[int] = []\n+        pointer_tokens: list[torch.Tensor] = []\n+\n+        # Add object pointers from selected conditioning frames\n+        # Optionally, only include pointers from past frames during evaluation\n+        conditioning_outputs = inference_session.output_dict_per_obj[obj_idx][\"cond_frame_outputs\"]\n+        eligible_conditioning_outputs = conditioning_outputs\n+        if not self.training:\n+            eligible_conditioning_outputs = {\n+                temporal_idx: out\n+                for temporal_idx, out in conditioning_outputs.items()\n+                if (temporal_idx >= frame_idx if track_in_reverse_time else temporal_idx <= frame_idx)\n+            }\n+\n+        for temporal_idx, out_data in eligible_conditioning_outputs.items():\n+            temporal_difference = (frame_idx - temporal_idx) * temporal_position_sign_multiplier\n+            temporal_offsets.append(temporal_difference)\n+            pointer_tokens.append(out_data[\"object_pointer\"].to(device))\n+\n+        # Add object pointers from non-conditioning frames (up to max_object_pointers_to_use - 1)\n+        for t_diff_offset in range(1, max_object_pointers_to_use):\n+            ref_frame_idx = frame_idx + t_diff_offset if track_in_reverse_time else frame_idx - t_diff_offset\n+            if ref_frame_idx < 0 or (\n+                not streaming and num_total_frames is not None and ref_frame_idx >= num_total_frames\n+            ):\n+                break  # Stop if frame index is out of bounds\n+\n+            # check if the output is already stored without using get_output to avoid unnecessary memory transfers between CPU and GPU\n+            out_data = inference_session.output_dict_per_obj[obj_idx][\"non_cond_frame_outputs\"].get(\n+                ref_frame_idx, None\n+            )\n+            if out_data is not None:\n+                temporal_offsets.append(t_diff_offset)\n+                pointer_tokens.append(out_data[\"object_pointer\"].to(device))\n+\n+        return temporal_offsets, pointer_tokens, max_object_pointers_to_use\n+\n+    def _process_object_pointers(\n+        self,\n+        temporal_offsets: list[int],\n+        pointer_tokens: list[torch.Tensor],\n+        max_object_pointers_to_use: int,\n+        batch_size: int,\n+        num_channels: int,\n+        device: torch.device,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Process object pointers and compute their positional embeddings.\n+\n+        Returns:\n+            Tuple of (object_pointers, object_pointers_pos_embed).\n+        \"\"\"\n+        if not pointer_tokens:\n+            return None, None\n+\n+        # Stack object pointers: List of (Batch, Channels) -> (SeqLen_ptr, Batch, Channels)\n+        object_pointers = torch.stack(pointer_tokens, dim=0)\n+\n+        if self.config.enable_temporal_pos_encoding_for_object_pointers:\n+            max_temporal_diff = float(max_object_pointers_to_use - 1)\n+            # Determine dimensionality for temporal positional encoding of pointers\n+            pointer_tpos_dim = num_channels\n+\n+            # Normalize temporal differences before sine PE calculation\n+            normalized_temporal_diffs = (\n+                torch.tensor(temporal_offsets, device=device, dtype=torch.float32) / max_temporal_diff\n+            )\n+            sine_pe = get_1d_sine_pe(normalized_temporal_diffs, dim=pointer_tpos_dim).to(object_pointers.dtype)\n+            projected_sine_pe = self.temporal_positional_encoding_projection_layer(sine_pe)\n+            object_pointers_pos_embed = projected_sine_pe.unsqueeze(1).expand(-1, batch_size, self.mem_dim)\n+        else:\n+            object_pointers_pos_embed = object_pointers.new_zeros(\n+                len(temporal_offsets), batch_size, self.mem_dim, dtype=object_pointers.dtype\n+            )\n+\n+        if self.mem_dim < num_channels:\n+            # If memory dimension is smaller, reshape/split pointers and repeat positional encoding\n+            num_splits = num_channels // self.mem_dim\n+            object_pointers = object_pointers.reshape(-1, batch_size, num_splits, self.mem_dim)\n+            object_pointers = object_pointers.permute(0, 2, 1, 3).flatten(\n+                0, 1\n+            )  # (SeqLen_ptr*num_splits, Batch, MemDim)\n+            object_pointers_pos_embed = object_pointers_pos_embed.repeat_interleave(num_splits, dim=0)\n+\n+        return object_pointers, object_pointers_pos_embed\n+\n     def _prepare_memory_conditioned_features(\n         self,\n         inference_session: Sam2VideoInferenceSession,\n@@ -1859,135 +2053,9 @@ def _prepare_memory_conditioned_features(\n             )\n             return current_feature_map\n \n-        num_object_pointer_tokens = 0\n-        temporal_position_sign_multiplier = -1 if track_in_reverse_time else 1\n-\n-        # Step 1: Condition the visual features of the current frame on previous memories\n-        if not is_initial_conditioning_frame:\n-            # Retrieve memories encoded from previous frames\n-            memories_to_concatenate = []\n-            memory_positional_embeddings_to_concatenate = []\n-\n-            # Ensure there are conditioning frame outputs to process\n-            conditioning_outputs = inference_session.output_dict_per_obj[obj_idx][\"cond_frame_outputs\"]\n-            if not conditioning_outputs:\n-                raise ValueError(\n-                    \"maskmem_features in conditioning outputs cannot be empty when not is_initial_conditioning_frame\"\n-                )\n-\n-            # Select a maximum number of temporally closest conditioning frames for cross-attention (no limit here, as is the case in the original checkpoints)\n-            # Store (temporal_position, output_data) tuples\n-            temporal_positions_and_previous_outputs = [(0, out) for out in conditioning_outputs.values()]\n-\n-            # Add non-conditioning memory frames (up to self.num_maskmem - 1)\n-            # These are typically frames tracked by the model without direct user input.\n-            # Frames are selected with a stride, prioritizing the most recent ones. Here we only support stride = 1 for simplicity.\n-            for relative_temporal_offset in range(self.num_maskmem - 1, 0, -1):\n-                # relative_temporal_offset: how many frames before (or after if reversing) the current frame\n-                if not track_in_reverse_time:\n-                    previous_frame_idx = frame_idx - relative_temporal_offset\n-                else:\n-                    previous_frame_idx = frame_idx + relative_temporal_offset\n-\n-                # check if the output is already stored without using get_output to avoid unnecessary memory transfers between CPU and GPU\n-                output_data = inference_session.output_dict_per_obj[obj_idx][\"non_cond_frame_outputs\"].get(\n-                    previous_frame_idx, None\n-                )\n-\n-                temporal_positions_and_previous_outputs.append((relative_temporal_offset, output_data))\n-\n-            for relative_temporal_offset, prev_output_data in temporal_positions_and_previous_outputs:\n-                if prev_output_data is None:\n-                    continue  # Skip if no output data for this temporal position (e.g., padding frames)\n-\n-                # Load memory features (potentially from CPU to GPU)\n-                # Features are flattened: (Batch, Channels, H, W) -> (H*W, Batch, Channels)\n-                memory_features = prev_output_data[\"maskmem_features\"].to(device, non_blocking=True)\n-                memories_to_concatenate.append(memory_features)\n-\n-                # Spatial positional encoding (potentially from CPU to GPU)\n-                spatial_memory_pos_embed = prev_output_data[\"maskmem_pos_enc\"].to(device, non_blocking=True)\n-\n-                # Add temporal positional encoding\n-                # self.memory_temporal_positional_encoding shape: (NumMaskMem, 1, 1, MemDim)\n-                combined_memory_pos_embed = (\n-                    spatial_memory_pos_embed + self.memory_temporal_positional_encoding[relative_temporal_offset - 1]\n-                )\n-                memory_positional_embeddings_to_concatenate.append(combined_memory_pos_embed)\n-\n-            # Construct the list of past object pointers to be used in attention\n-            if streaming:\n-                max_object_pointers_to_use = self.config.max_object_pointers_in_encoder\n-            else:\n-                max_object_pointers_to_use = min(num_total_frames, self.config.max_object_pointers_in_encoder)\n-            temporal_diff_and_pointers = []\n-\n-            # Add object pointers from selected conditioning frames\n-            # Optionally, only include pointers from past frames during evaluation\n-            eligible_conditioning_outputs = conditioning_outputs\n-            if not self.training:\n-                eligible_conditioning_outputs = {\n-                    temporal_idx: out\n-                    for temporal_idx, out in conditioning_outputs.items()\n-                    if (temporal_idx >= frame_idx if track_in_reverse_time else temporal_idx <= frame_idx)\n-                }\n-\n-            for temporal_idx, out_data in eligible_conditioning_outputs.items():\n-                temporal_difference = (frame_idx - temporal_idx) * temporal_position_sign_multiplier\n-                temporal_diff_and_pointers.append((temporal_difference, out_data[\"object_pointer\"]))\n-\n-            # Add object pointers from non-conditioning frames (up to max_object_pointers_to_use - 1)\n-            for t_diff_offset in range(1, max_object_pointers_to_use):\n-                ref_frame_idx = frame_idx + t_diff_offset if track_in_reverse_time else frame_idx - t_diff_offset\n-                if ref_frame_idx < 0 or (\n-                    not streaming and num_total_frames is not None and ref_frame_idx >= num_total_frames\n-                ):\n-                    break  # Stop if frame index is out of bounds\n-\n-                # check if the output is already stored without using get_output to avoid unnecessary memory transfers between CPU and GPU\n-                out_data = inference_session.output_dict_per_obj[obj_idx][\"non_cond_frame_outputs\"].get(\n-                    ref_frame_idx, None\n-                )\n-                if out_data is not None:\n-                    temporal_diff_and_pointers.append((t_diff_offset, out_data[\"object_pointer\"]))\n-\n-            if temporal_diff_and_pointers:\n-                temporal_differences, object_pointers_list = zip(*temporal_diff_and_pointers)\n-                # Stack object pointers: List of (Batch, Channels) -> (SeqLen_ptr, Batch, Channels)\n-                object_pointers = torch.stack(object_pointers_list, dim=0)\n-\n-                if self.config.enable_temporal_pos_encoding_for_object_pointers:\n-                    max_temporal_diff = float(max_object_pointers_to_use - 1)\n-                    # Determine dimensionality for temporal positional encoding of pointers\n-                    pointer_tpos_dim = num_channels\n-\n-                    # Normalize temporal differences before sine PE calculation\n-                    normalized_temporal_diffs = (\n-                        torch.tensor(temporal_differences, device=device, dtype=torch.float32) / max_temporal_diff\n-                    )\n-                    sine_pe = get_1d_sine_pe(normalized_temporal_diffs, dim=pointer_tpos_dim).to(object_pointers.dtype)\n-                    projected_sine_pe = self.temporal_positional_encoding_projection_layer(sine_pe)\n-                    object_pointers_pos_embed = projected_sine_pe.unsqueeze(1).expand(-1, batch_size, self.mem_dim)\n-                else:\n-                    object_pointers_pos_embed = object_pointers.new_zeros(\n-                        len(temporal_differences), batch_size, self.mem_dim, dtype=object_pointers.dtype\n-                    )\n-\n-                if self.mem_dim < num_channels:\n-                    # If memory dimension is smaller, reshape/split pointers and repeat positional encoding\n-                    num_splits = num_channels // self.mem_dim\n-                    object_pointers = object_pointers.reshape(-1, batch_size, num_splits, self.mem_dim)\n-                    object_pointers = object_pointers.permute(0, 2, 1, 3).flatten(\n-                        0, 1\n-                    )  # (SeqLen_ptr*num_splits, Batch, MemDim)\n-                    object_pointers_pos_embed = object_pointers_pos_embed.repeat_interleave(num_splits, dim=0)\n-\n-                memories_to_concatenate.append(object_pointers)\n-                memory_positional_embeddings_to_concatenate.append(object_pointers_pos_embed)\n-                num_object_pointer_tokens = object_pointers.shape[0]\n-        else:\n+        # Step 1: Handle initial conditioning frames\n+        if is_initial_conditioning_frame:\n             # For initial conditioning frames, no prior memory is used directly in this block.\n-            # The model might handle this with a special token or mechanism.\n             # If configured, directly add a learnable \"no memory\" embedding.\n             # current_vision_features has shape (SeqLen, Batch, Channels)\n             conditioned_feature_map_flat = current_vision_features + self.no_memory_embedding\n@@ -1997,11 +2065,36 @@ def _prepare_memory_conditioned_features(\n             )\n             return conditioned_feature_map\n \n-        # Step 2: Concatenate all retrieved memories and their positional embeddings.\n+        # Step 2: Get memory frames and concatenate their features\n+        temporal_positions_and_previous_outputs = self._gather_memory_frame_outputs(\n+            inference_session, obj_idx, frame_idx, track_in_reverse_time\n+        )\n+\n+        memories_to_concatenate, memory_positional_embeddings_to_concatenate = self._build_memory_attention_inputs(\n+            temporal_positions_and_previous_outputs, device\n+        )\n+\n+        # Step 3: Get and process object pointers\n+        temporal_offsets, pointer_tokens, max_object_pointers_to_use = self._get_object_pointers(\n+            inference_session, obj_idx, frame_idx, num_total_frames, device, track_in_reverse_time, streaming\n+        )\n+\n+        num_object_pointer_tokens = 0\n+        if pointer_tokens:\n+            object_pointers, object_pointers_pos_embed = self._process_object_pointers(\n+                temporal_offsets, pointer_tokens, max_object_pointers_to_use, batch_size, num_channels, device\n+            )\n+\n+            if object_pointers is not None:\n+                memories_to_concatenate.append(object_pointers)\n+                memory_positional_embeddings_to_concatenate.append(object_pointers_pos_embed)\n+                num_object_pointer_tokens = object_pointers.shape[0]\n+\n+        # Step 4: Concatenate all retrieved memories and their positional embeddings\n         combined_memory = torch.cat(memories_to_concatenate, dim=0)\n         combined_memory_positional_embeddings = torch.cat(memory_positional_embeddings_to_concatenate, dim=0)\n \n-        # Step 3: Forward through the memory attention mechanism.\n+        # Step 5: Forward through the memory attention mechanism\n         conditioned_feature_map_flat = self.memory_attention(\n             current_vision_features=current_vision_features,\n             current_vision_position_embeddings=current_vision_positional_embeddings,\n@@ -2211,7 +2304,7 @@ def forward(\n             Whether to propagate in reverse.\n         \"\"\"\n         if frame is not None:\n-            frame_idx = inference_session.add_new_frame(frame)\n+            frame_idx = inference_session.add_new_frame(frame, frame_idx)\n \n         if frame is not None and inference_session.get_obj_num() == 0:\n             raise ValueError(\"No objects are provided for tracking; please add inputs first.\")"
        },
        {
            "sha": "34e640ade8bfc9724a2c9df3257d77ee8bb4b0ea",
            "filename": "src/transformers/models/timm_wrapper/configuration_timm_wrapper.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Ftimm_wrapper%2Fconfiguration_timm_wrapper.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Ftimm_wrapper%2Fconfiguration_timm_wrapper.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Ftimm_wrapper%2Fconfiguration_timm_wrapper.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -121,8 +121,8 @@ def from_dict(cls, config_dict: dict[str, Any], **kwargs):\n \n     def to_dict(self) -> dict[str, Any]:\n         output = super().to_dict()\n-        output[\"num_classes\"] = self.num_labels\n-        output[\"label_names\"] = list(self.id2label.values())\n+        output.setdefault(\"num_classes\", self.num_labels)\n+        output.setdefault(\"label_names\", list(self.id2label.values()))\n         output.pop(\"id2label\", None)\n         output.pop(\"label2id\", None)\n         return output"
        },
        {
            "sha": "d388ff05297ff1c01e7f9c1fe3353763088e51a6",
            "filename": "src/transformers/models/timm_wrapper/modeling_timm_wrapper.py",
            "status": "modified",
            "additions": 19,
            "deletions": 13,
            "changes": 32,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Ftimm_wrapper%2Fmodeling_timm_wrapper.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/src%2Ftransformers%2Fmodels%2Ftimm_wrapper%2Fmodeling_timm_wrapper.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Ftimm_wrapper%2Fmodeling_timm_wrapper.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -160,6 +160,7 @@ def __init__(self, config: TimmWrapperConfig):\n         super().__init__(config)\n         # using num_classes=0 to avoid creating classification head\n         extra_init_kwargs = config.model_args or {}\n+        self.features_only = extra_init_kwargs.get(\"features_only\", False)\n         self.timm_model = _create_timm_model_with_error_handling(config, num_classes=0, **extra_init_kwargs)\n         self.post_init()\n \n@@ -233,20 +234,25 @@ def forward(\n \n         pixel_values = pixel_values.to(self.device, self.dtype)\n \n-        if output_hidden_states:\n-            # to enable hidden states selection\n-            if isinstance(output_hidden_states, (list, tuple)):\n-                kwargs[\"indices\"] = output_hidden_states\n-            last_hidden_state, hidden_states = self.timm_model.forward_intermediates(pixel_values, **kwargs)\n-        else:\n-            last_hidden_state = self.timm_model.forward_features(pixel_values, **kwargs)\n-            hidden_states = None\n-\n-        if do_pooling:\n-            # classification head is not created, applying pooling only\n-            pooler_output = self.timm_model.forward_head(last_hidden_state)\n-        else:\n+        if self.features_only:\n+            last_hidden_state = self.timm_model.forward(pixel_values, **kwargs)\n+            hidden_states = last_hidden_state if output_hidden_states else None\n             pooler_output = None\n+        else:\n+            if output_hidden_states:\n+                # to enable hidden states selection\n+                if isinstance(output_hidden_states, (list, tuple)):\n+                    kwargs[\"indices\"] = output_hidden_states\n+                last_hidden_state, hidden_states = self.timm_model.forward_intermediates(pixel_values, **kwargs)\n+            else:\n+                last_hidden_state = self.timm_model.forward_features(pixel_values, **kwargs)\n+                hidden_states = None\n+\n+            if do_pooling:\n+                # classification head is not created, applying pooling only\n+                pooler_output = self.timm_model.forward_head(last_hidden_state)\n+            else:\n+                pooler_output = None\n \n         if not return_dict:\n             outputs = (last_hidden_state, pooler_output, hidden_states)"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/edgetam/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/tests%2Fmodels%2Fedgetam%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/tests%2Fmodels%2Fedgetam%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fedgetam%2F__init__.py?ref=bd37c453544e83eb875ed3608980a1660376007a"
        },
        {
            "sha": "701642a43d416e608b3f16da9a7f31c95348d7d9",
            "filename": "tests/models/edgetam/test_modeling_edgetam.py",
            "status": "added",
            "additions": 734,
            "deletions": 0,
            "changes": 734,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/tests%2Fmodels%2Fedgetam%2Ftest_modeling_edgetam.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/tests%2Fmodels%2Fedgetam%2Ftest_modeling_edgetam.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fedgetam%2Ftest_modeling_edgetam.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,734 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch EDGETAM model.\"\"\"\n+\n+import gc\n+import tempfile\n+import unittest\n+\n+import requests\n+\n+from transformers import (\n+    EdgeTamConfig,\n+    EdgeTamMaskDecoderConfig,\n+    EdgeTamPromptEncoderConfig,\n+    EdgeTamVisionConfig,\n+    Sam2Processor,\n+    pipeline,\n+)\n+from transformers.testing_utils import (\n+    backend_empty_cache,\n+    require_torch,\n+    slow,\n+    torch_device,\n+)\n+from transformers.utils import is_torch_available, is_vision_available\n+from transformers.video_utils import load_video\n+\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import ModelTesterMixin, floats_tensor\n+from ...test_pipeline_mixin import PipelineTesterMixin\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import AutoConfig, EdgeTamModel, Sam2Processor\n+\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+class EdgeTamPromptEncoderTester:\n+    def __init__(\n+        self,\n+        hidden_size=32,\n+        input_image_size=128,\n+        patch_size=16,\n+        mask_input_channels=8,\n+        num_point_embeddings=4,\n+        hidden_act=\"gelu\",\n+    ):\n+        self.hidden_size = hidden_size\n+        self.input_image_size = input_image_size\n+        self.patch_size = patch_size\n+        self.mask_input_channels = mask_input_channels\n+        self.num_point_embeddings = num_point_embeddings\n+        self.hidden_act = hidden_act\n+\n+    def get_config(self):\n+        return EdgeTamPromptEncoderConfig(\n+            image_size=self.input_image_size,\n+            patch_size=self.patch_size,\n+            mask_input_channels=self.mask_input_channels,\n+            hidden_size=self.hidden_size,\n+            num_point_embeddings=self.num_point_embeddings,\n+            hidden_act=self.hidden_act,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        dummy_points = floats_tensor([self.batch_size, 3, 2])\n+        config = self.get_config()\n+\n+        return config, dummy_points\n+\n+\n+class EdgeTamMaskDecoderTester:\n+    def __init__(\n+        self,\n+        hidden_size=32,\n+        hidden_act=\"relu\",\n+        mlp_dim=64,\n+        num_hidden_layers=2,\n+        num_attention_heads=4,\n+        attention_downsample_rate=2,\n+        num_multimask_outputs=3,\n+        iou_head_depth=3,\n+        iou_head_hidden_dim=32,\n+    ):\n+        self.hidden_size = hidden_size\n+        self.hidden_act = hidden_act\n+        self.mlp_dim = mlp_dim\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.attention_downsample_rate = attention_downsample_rate\n+        self.num_multimask_outputs = num_multimask_outputs\n+        self.iou_head_depth = iou_head_depth\n+        self.iou_head_hidden_dim = iou_head_hidden_dim\n+\n+    def get_config(self):\n+        return EdgeTamMaskDecoderConfig(\n+            hidden_size=self.hidden_size,\n+            hidden_act=self.hidden_act,\n+            mlp_dim=self.mlp_dim,\n+            num_hidden_layers=self.num_hidden_layers,\n+            num_attention_heads=self.num_attention_heads,\n+            attention_downsample_rate=self.attention_downsample_rate,\n+            num_multimask_outputs=self.num_multimask_outputs,\n+            iou_head_depth=self.iou_head_depth,\n+            iou_head_hidden_dim=self.iou_head_hidden_dim,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        config = self.get_config()\n+\n+        dummy_inputs = {\n+            \"image_embedding\": floats_tensor([self.batch_size, self.hidden_size]),\n+        }\n+\n+        return config, dummy_inputs\n+\n+\n+class EdgeTamModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        num_channels=3,\n+        image_size=128,\n+        hidden_size=12,\n+        patch_kernel_size=7,\n+        patch_stride=4,\n+        patch_padding=3,\n+        dim_mul=2.0,\n+        backbone_channel_list=[96, 48, 24, 12],\n+        backbone_feature_sizes=[[32, 32], [16, 16], [8, 8]],\n+        fpn_hidden_size=32,\n+        memory_encoder_hidden_size=32,\n+        batch_size=2,\n+        is_training=False,\n+    ):\n+        self.parent = parent\n+        self.image_size = image_size\n+        self.hidden_size = hidden_size\n+        self.patch_kernel_size = patch_kernel_size\n+        self.patch_stride = patch_stride\n+        self.patch_padding = patch_padding\n+        self.dim_mul = dim_mul\n+        self.backbone_channel_list = backbone_channel_list\n+        self.backbone_feature_sizes = backbone_feature_sizes\n+        self.fpn_hidden_size = fpn_hidden_size\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.is_training = is_training\n+        self.memory_encoder_hidden_size = memory_encoder_hidden_size\n+\n+        self.prompt_encoder_tester = EdgeTamPromptEncoderTester()\n+        self.mask_decoder_tester = EdgeTamMaskDecoderTester()\n+\n+    def prepare_config_and_inputs(self):\n+        pixel_values = floats_tensor([self.batch_size, self.num_channels, self.image_size, self.image_size])\n+        config = self.get_config()\n+\n+        return config, pixel_values\n+\n+    def get_config(self):\n+        vision_config = EdgeTamVisionConfig(\n+            backbone_config=AutoConfig.from_pretrained(\n+                \"timm/repvit_m1.dist_in1k\",\n+                model_args={\n+                    \"in_chans\": 3,\n+                    \"features_only\": True,\n+                    \"out_indices\": (0, 1, 2, 3),\n+                    \"embed_dim\": self.backbone_channel_list[::-1],\n+                },\n+            ),\n+            backbone_channel_list=self.backbone_channel_list,\n+            backbone_feature_sizes=self.backbone_feature_sizes,\n+            fpn_hidden_size=self.fpn_hidden_size,\n+        )\n+\n+        prompt_encoder_config = self.prompt_encoder_tester.get_config()\n+\n+        mask_decoder_config = self.mask_decoder_tester.get_config()\n+\n+        return EdgeTamConfig(\n+            vision_config=vision_config,\n+            prompt_encoder_config=prompt_encoder_config,\n+            mask_decoder_config=mask_decoder_config,\n+            memory_attention_hidden_size=self.hidden_size,\n+            memory_encoder_hidden_size=self.memory_encoder_hidden_size,\n+            image_size=self.image_size,\n+            mask_downsampler_embed_dim=32,\n+            memory_fuser_embed_dim=32,\n+            memory_attention_num_layers=1,\n+            memory_attention_feed_forward_hidden_size=32,\n+        )\n+\n+    def create_and_check_model(self, config, pixel_values):\n+        model = EdgeTamModel(config=config)\n+        model.to(torch_device)\n+        model.eval()\n+        with torch.no_grad():\n+            result = model(pixel_values)\n+        self.parent.assertEqual(result.iou_scores.shape, (self.batch_size, 1, 3))\n+        self.parent.assertEqual(result.pred_masks.shape[:3], (self.batch_size, 1, 3))\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        inputs_dict = {\"pixel_values\": pixel_values}\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class EdgeTamModelTest(ModelTesterMixin, PipelineTesterMixin, unittest.TestCase):\n+    \"\"\"\n+    Here we also overwrite some of the tests of test_modeling_common.py, as SAM's vision encoder does not use input_ids, inputs_embeds,\n+    attention_mask and seq_length.\n+    \"\"\"\n+\n+    all_model_classes = (EdgeTamModel,) if is_torch_available() else ()\n+    pipeline_model_mapping = (\n+        {\"feature-extraction\": EdgeTamModel, \"mask-generation\": EdgeTamModel} if is_torch_available() else {}\n+    )\n+    fx_compatible = False\n+    test_pruning = False\n+    test_resize_embeddings = False\n+    test_head_masking = False\n+    test_torchscript = False\n+    _is_composite = True\n+\n+    def setUp(self):\n+        self.model_tester = EdgeTamModelTester(self)\n+        common_properties = [\"initializer_range\"]\n+        self.config_tester = ConfigTester(\n+            self, config_class=EdgeTamConfig, has_text_modality=False, common_properties=common_properties\n+        )\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    @unittest.skip(reason=\"Timm model does not use inputs_embeds\")\n+    def test_inputs_embeds(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Can't get or set embeddings for Timm model\")\n+    def test_model_get_set_embeddings(self):\n+        pass\n+\n+    def test_model(self):\n+        config_and_inputs = self.model_tester.prepare_config_and_inputs()\n+        self.model_tester.create_and_check_model(*config_and_inputs)\n+\n+    # Override as EdgeTamModel doesn't have hidden states\n+    def flash_attn_inference_equivalence(self, attn_implementation: str, padding_side: str):\n+        r\"\"\"\n+        Tests the equivalence between the eager and flash attention implementations.\n+        This test is only for inference and runs with `torch_dtype=torch.bfloat16`.\n+        \"\"\"\n+        if not self.has_attentions:\n+            self.skipTest(reason=\"Model architecture does not support attentions\")\n+\n+        for model_class in self.all_model_classes:\n+            if (attn_implementation == \"flash_attention_2\" and not model_class._supports_flash_attn_2) or (\n+                attn_implementation == \"flash_attention_3\" and not model_class._supports_flash_attn_3\n+            ):\n+                self.skipTest(f\"{model_class.__name__} does not support {attn_implementation}\")\n+\n+            config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+            model = model_class(config)\n+\n+            with tempfile.TemporaryDirectory() as tmpdirname:\n+                model.save_pretrained(tmpdirname)\n+                model_fa = model_class.from_pretrained(\n+                    tmpdirname, torch_dtype=torch.bfloat16, attn_implementation=attn_implementation\n+                )\n+                model_fa.to(torch_device)\n+\n+                model = model_class.from_pretrained(tmpdirname, torch_dtype=torch.bfloat16)\n+                model.to(torch_device)\n+\n+                dummy_input = inputs_dict[model.main_input_name][:1]\n+                if dummy_input.dtype in [torch.float32, torch.float16]:\n+                    dummy_input = dummy_input.to(torch.bfloat16)\n+\n+                dummy_attention_mask = inputs_dict.get(\"attention_mask\", None)\n+\n+                if dummy_attention_mask is not None:\n+                    dummy_attention_mask = dummy_attention_mask[:1]\n+                    if padding_side == \"left\":\n+                        dummy_attention_mask[:, 1:] = 1\n+                        dummy_attention_mask[:, :1] = 0\n+                    else:\n+                        dummy_attention_mask[:, :-1] = 1\n+                        dummy_attention_mask[:, -1:] = 0\n+                if model.config.is_encoder_decoder:\n+                    decoder_input_ids = inputs_dict.get(\"decoder_input_ids\", dummy_input)[:1]\n+\n+                    outputs = model(dummy_input, decoder_input_ids=decoder_input_ids, output_hidden_states=True)\n+                    outputs_fa = model_fa(dummy_input, decoder_input_ids=decoder_input_ids, output_hidden_states=True)\n+                else:\n+                    outputs = model(dummy_input, output_hidden_states=True)\n+                    outputs_fa = model_fa(dummy_input, output_hidden_states=True)\n+\n+                logits = outputs.vision_hidden_states[-1]\n+                logits_fa = outputs_fa.vision_hidden_states[-1]\n+\n+                assert torch.allclose(logits_fa, logits, atol=4e-2, rtol=4e-2)\n+\n+                if model.config.is_encoder_decoder:\n+                    other_inputs = {\n+                        \"decoder_input_ids\": decoder_input_ids,\n+                        \"decoder_attention_mask\": dummy_attention_mask,\n+                        \"output_hidden_states\": True,\n+                    }\n+                    if dummy_attention_mask is not None:\n+                        other_inputs[\"attention_mask\"] = dummy_attention_mask\n+\n+                    outputs = model(dummy_input, **other_inputs)\n+                    outputs_fa = model_fa(dummy_input, **other_inputs)\n+                else:\n+                    other_inputs = {\n+                        \"output_hidden_states\": True,\n+                    }\n+                    if dummy_attention_mask is not None:\n+                        other_inputs[\"attention_mask\"] = dummy_attention_mask\n+\n+                    outputs = model(dummy_input, **other_inputs)\n+                    outputs_fa = model_fa(dummy_input, **other_inputs)\n+\n+                logits = outputs.vision_hidden_states[-1]\n+                logits_fa = outputs_fa.vision_hidden_states[-1]\n+\n+                if padding_side == \"left\":\n+                    assert torch.allclose(logits_fa[1:], logits[1:], atol=4e-2, rtol=4e-2)\n+\n+                    # check with inference + dropout\n+                    model.train()\n+                    _ = model_fa(dummy_input, **other_inputs)\n+                else:\n+                    assert torch.allclose(logits_fa[:-1], logits[:-1], atol=4e-2, rtol=4e-2)\n+\n+    # Override as diffence slightly higher than the threshold\n+    # def test_batching_equivalence(self, atol=5e-4, rtol=5e-4):\n+    #     super().test_batching_equivalence(atol=atol, rtol=rtol)\n+\n+    @unittest.skip(reason=\"TimmWrapperModel does not support an attention implementation\")\n+    def test_can_set_attention_dynamically_composite_model(self):\n+        pass\n+\n+    @unittest.skip(reason=\"vision_hidden_states from TimmWrapperModel\")\n+    def test_hidden_states_output(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Timm weights cannot be fully constructed in _init_weights\")\n+    def test_can_init_all_missing_weights(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Timm weights cannot be fully constructed in _init_weights\")\n+    def test_initialization(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"TIMM's attention implementation is self configured and won't raise ValueError on global attention implementation.\"\n+    )\n+    def test_flash_attn_2_can_dispatch_composite_models(self):\n+        pass\n+\n+    @unittest.skip(\"TimmWrapperModel cannot be tested with meta device\")\n+    def test_can_be_initialized_on_meta(self):\n+        pass\n+\n+    @unittest.skip(\"TimmWrapperModel cannot be tested with meta device\")\n+    def test_can_load_with_meta_device_context_manager(self):\n+        pass\n+\n+    ## Skip flash attention releated tests below\n+    ## correct configuration:\n+    ## from_pretrained(model_id, attn_implementation={\"text_config\": \"flash_attention_2\", \"vision_config\": \"eager\"}\n+    @unittest.skip(\"Flash attn test is not configured correctly as we need to configure vision/timm model to 'eager'.\")\n+    def test_eager_matches_fa2_generate(self):\n+        pass\n+\n+    @unittest.skip(\"Flash attn test is not configured correctly as we need to configure vision/timm model to 'eager'.\")\n+    def test_flash_attn_2_fp32_ln(self):\n+        pass\n+\n+    @unittest.skip(\"Flash attn test is not configured correctly as we need to configure vision/timm model to 'eager'.\")\n+    def test_flash_attn_2_from_config(self):\n+        pass\n+\n+    @unittest.skip(\"SDPA test is not configured correctly as we need to configure vision/timm model to 'eager'.\")\n+    def test_eager_matches_sdpa_generate_with_dynamic_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Flash attn test is not configured correctly as we need to configure vision/timm model to 'eager'.\")\n+    def test_flash_attn_2_inference_equivalence_right_padding(self):\n+        pass\n+\n+    @unittest.skip(\"SDPA test is not configured correctly as we need to configure vision/timm model to 'eager'.\")\n+    def test_eager_matches_sdpa_generate(self):\n+        pass\n+\n+    @unittest.skip(\"Flash attn test is not configured correctly as we need to configure vision/timm model to 'eager'.\")\n+    def test_flash_attn_2_inference_equivalence(self):\n+        pass\n+\n+    @unittest.skip(\"EdgeTAM does not have language_model, vision_tower, multi_modal_projector.\")\n+    def test_sdpa_can_dispatch_composite_models(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot set `output_attentions` for timm models.\")\n+    def test_attention_outputs(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot set `output_attentions` for timm models.\")\n+    def test_retain_grad_hidden_states_attentions(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot set `output_attentions` for timm models.\")\n+    def test_generate_compilation_all_outputs(self):\n+        pass\n+\n+    @slow\n+    def test_model_from_pretrained(self):\n+        model_name = \"yonigozlan/EdgeTAM-hf\"\n+        model = EdgeTamModel.from_pretrained(model_name)\n+        self.assertIsNotNone(model)\n+\n+    def test_sdpa_can_compile_dynamic(self):\n+        self.skipTest(reason=\"EDGETAM model can't be compiled dynamic yet\")\n+\n+\n+def prepare_image():\n+    img_url = \"https://huggingface.co/datasets/hf-internal-testing/sam2-fixtures/resolve/main/truck.jpg\"\n+    raw_image = Image.open(requests.get(img_url, stream=True).raw).convert(\"RGB\")\n+    return raw_image\n+\n+\n+def prepare_groceries_image():\n+    img_url = \"https://huggingface.co/datasets/hf-internal-testing/sam2-fixtures/resolve/main/groceries.jpg\"\n+    raw_image = Image.open(requests.get(img_url, stream=True).raw).convert(\"RGB\")\n+    return raw_image\n+\n+\n+def prepare_dog_img():\n+    img_url = \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/model_doc/dog-sam.png\"\n+    raw_image = Image.open(requests.get(img_url, stream=True).raw).convert(\"RGB\")\n+    return raw_image\n+\n+\n+def prepare_video():\n+    video_url = \"https://huggingface.co/datasets/hf-internal-testing/sam2-fixtures/resolve/main/bedroom.mp4\"\n+    raw_video, _ = load_video(video_url)\n+    return raw_video\n+\n+\n+@slow\n+class EdgeTamModelIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        super().setUp()\n+        self.model = EdgeTamModel.from_pretrained(\"yonigozlan/EdgeTAM-hf\").to(torch.float32)\n+        self.processor = Sam2Processor.from_pretrained(\"yonigozlan/EdgeTAM-hf\")\n+        self.model.to(torch_device)\n+        self.model.eval()\n+\n+    def tearDown(self):\n+        super().tearDown()\n+        # clean-up as much as possible GPU memory occupied by PyTorch\n+        gc.collect()\n+        backend_empty_cache(torch_device)\n+\n+    def test_inference_mask_generation_one_point_multimask(self):\n+        raw_image = prepare_image()\n+        input_points = [[[[500, 375]]]]\n+        input_labels = [[[1]]]\n+\n+        inputs = self.processor(\n+            images=raw_image, input_points=input_points, input_labels=input_labels, return_tensors=\"pt\"\n+        ).to(torch_device)\n+\n+        with torch.no_grad():\n+            outputs = self.model(**inputs)\n+        self.assertEqual(outputs.iou_scores.shape, (1, 1, 3))\n+        self.assertEqual(outputs.pred_masks.shape, (1, 1, 3, 256, 256))\n+        sorted_indices = torch.argsort(outputs.iou_scores.squeeze(), descending=True)\n+        scores = outputs.iou_scores.squeeze()[sorted_indices]\n+        masks_logits = outputs.pred_masks.squeeze()[sorted_indices][0, :3, :3]\n+        torch.testing.assert_close(\n+            scores, torch.tensor([0.7621, 0.4859, 0.0461]).to(torch_device), atol=1e-4, rtol=1e-4\n+        )\n+        torch.testing.assert_close(\n+            masks_logits,\n+            torch.tensor(\n+                [[-19.5483, -22.3549, -26.0962], [-18.1821, -23.4761, -24.2262], [-20.3549, -24.5518, -22.7232]]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+    def test_inference_mask_generation_one_point_no_multimask(self):\n+        raw_image = prepare_image()\n+        input_points = [[[[500, 375]]]]\n+        input_labels = [[[1]]]\n+\n+        inputs = self.processor(\n+            images=raw_image, input_points=input_points, input_labels=input_labels, return_tensors=\"pt\"\n+        ).to(torch_device)\n+\n+        with torch.no_grad():\n+            outputs = self.model(**inputs, multimask_output=False)\n+        self.assertEqual(outputs.iou_scores.shape, (1, 1, 1))\n+        self.assertEqual(outputs.pred_masks.shape, (1, 1, 1, 256, 256))\n+        scores = outputs.iou_scores.squeeze((0, 1))\n+        masks_logits = outputs.pred_masks.squeeze((0, 1))[0, :3, :3]\n+        torch.testing.assert_close(scores, torch.tensor([0.7621]).to(torch_device), atol=1e-4, rtol=1e-4)\n+        torch.testing.assert_close(\n+            masks_logits,\n+            torch.tensor(\n+                [[-19.5483, -22.3549, -26.0962], [-18.1821, -23.4761, -24.2262], [-20.3549, -24.5518, -22.7232]]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+    def test_inference_mask_generation_batched_images_multi_points(self):\n+        raw_image1 = prepare_image()\n+        raw_image2 = prepare_dog_img()\n+        input_points = [[[[500, 375]]], [[[770, 200], [730, 120]]]]\n+        input_labels = [[[1]], [[1, 0]]]\n+\n+        inputs = self.processor(\n+            images=[raw_image1, raw_image2], input_points=input_points, input_labels=input_labels, return_tensors=\"pt\"\n+        ).to(torch_device)\n+\n+        with torch.no_grad():\n+            outputs = self.model(**inputs)\n+        self.assertEqual(outputs.iou_scores.shape, (2, 1, 3))\n+        self.assertEqual(outputs.pred_masks.shape, (2, 1, 3, 256, 256))\n+\n+        sorted_indices = torch.argsort(outputs.iou_scores[0].squeeze(), descending=True)\n+        scores1 = outputs.iou_scores[0].squeeze()[sorted_indices]\n+        masks_logits1 = outputs.pred_masks[0].squeeze()[sorted_indices][0, :3, :3]\n+        sorted_indices = torch.argsort(outputs.iou_scores[1].squeeze(), descending=True)\n+        scores2 = outputs.iou_scores[1].squeeze()[sorted_indices]\n+        masks_logits2 = outputs.pred_masks[1].squeeze()[sorted_indices][0, :3, :3]\n+        torch.testing.assert_close(\n+            scores1, torch.tensor([0.7490, 0.4685, 0.0463]).to(torch_device), atol=1e-4, rtol=1e-4\n+        )\n+        torch.testing.assert_close(\n+            masks_logits1,\n+            torch.tensor(\n+                [[-19.1423, -21.6488, -25.6816], [-17.8018, -22.6512, -23.5699], [-19.9140, -23.6919, -22.3147]]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+        torch.testing.assert_close(\n+            scores2, torch.tensor([0.7225, 0.6515, 0.6350]).to(torch_device), atol=1e-4, rtol=1e-4\n+        )\n+        torch.testing.assert_close(\n+            masks_logits2,\n+            torch.tensor([[-8.8259, -7.7961, -9.3665], [-8.2648, -8.7771, -9.1390], [-9.5951, -8.3995, -9.0599]]).to(\n+                torch_device\n+            ),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+    def test_inference_mask_generation_batched_images_batched_points_multi_points(self):\n+        raw_image1 = prepare_image()\n+        raw_image2 = prepare_groceries_image()\n+        input_points = [[[[500, 375]], [[650, 750]]], [[[400, 300]], [[630, 300], [550, 300]]]]\n+        input_labels = [[[1], [1]], [[1], [1, 1]]]\n+        inputs = self.processor(\n+            images=[raw_image1, raw_image2], input_points=input_points, input_labels=input_labels, return_tensors=\"pt\"\n+        ).to(torch_device)\n+        with torch.no_grad():\n+            outputs = self.model(**inputs, multimask_output=False)\n+        self.assertEqual(outputs.iou_scores.shape, (2, 2, 1))\n+        self.assertEqual(outputs.pred_masks.shape, (2, 2, 1, 256, 256))\n+        torch.testing.assert_close(\n+            outputs.iou_scores,\n+            torch.tensor([[[0.7490], [0.9397]], [[0.7952], [0.8723]]]).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+        torch.testing.assert_close(\n+            outputs.pred_masks[:, :, :, :2, :2],\n+            torch.tensor(\n+                [\n+                    [[[[-19.1423, -21.6488], [-17.8018, -22.6512]]], [[[-7.1591, -9.8201], [-7.4133, -9.2781]]]],\n+                    [[[[-16.7645, -15.2790], [-16.1805, -16.2937]]], [[[-8.5934, -8.4215], [-8.1873, -8.3722]]]],\n+                ]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+    def test_inference_batched_images_batched_boxes(self):\n+        raw_image1 = prepare_image()\n+        raw_image2 = prepare_groceries_image()\n+        input_boxes = [\n+            [[75, 275, 1725, 850], [425, 600, 700, 875], [1375, 550, 1650, 800], [1240, 675, 1400, 750]],\n+            [[450, 170, 520, 350], [350, 190, 450, 350], [500, 170, 580, 350], [580, 170, 640, 350]],\n+        ]\n+        inputs = self.processor(images=[raw_image1, raw_image2], input_boxes=input_boxes, return_tensors=\"pt\").to(\n+            torch_device\n+        )\n+        with torch.no_grad():\n+            outputs = self.model(**inputs, multimask_output=False)\n+        self.assertEqual(outputs.iou_scores.shape, (2, 4, 1))\n+        self.assertEqual(outputs.pred_masks.shape, (2, 4, 1, 256, 256))\n+        torch.testing.assert_close(\n+            outputs.iou_scores,\n+            torch.tensor([[[0.9773], [0.9415], [0.9683], [0.8792]], [[0.9721], [0.9852], [0.9812], [0.9760]]]).to(\n+                torch_device\n+            ),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+        torch.testing.assert_close(\n+            outputs.pred_masks[:, :, :, :2, :2],\n+            torch.tensor(\n+                [\n+                    [\n+                        [[[-12.6412, -12.0553], [-11.8415, -13.1696]]],\n+                        [[[-16.0378, -19.9641], [-15.4939, -19.0260]]],\n+                        [[[-18.8254, -23.6185], [-17.7889, -23.2116]]],\n+                        [[[-25.7024, -29.8722], [-22.9264, -30.0557]]],\n+                    ],\n+                    [\n+                        [[[-19.0264, -17.0396], [-16.9458, -16.3287]]],\n+                        [[[-20.9671, -19.2132], [-18.5827, -18.0511]]],\n+                        [[[-22.4642, -19.7389], [-19.4541, -19.4717]]],\n+                        [[[-21.9226, -18.6297], [-18.9272, -18.8151]]],\n+                    ],\n+                ]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+    def test_inference_mask_generation_from_existing_points_and_mask(self):\n+        raw_image = prepare_image()\n+        input_points = [[[[500, 375]]]]\n+        input_labels = [[[1]]]\n+        original_inputs = self.processor(\n+            images=raw_image, input_points=input_points, input_labels=input_labels, return_tensors=\"pt\"\n+        ).to(torch_device)\n+        with torch.no_grad():\n+            outputs = self.model(**original_inputs)\n+\n+        # best mask to use as input for new points\n+        mask_input = outputs.pred_masks[:, :, torch.argmax(outputs.iou_scores)]\n+\n+        new_input_points = [[[[500, 375], [1125, 625]]]]\n+        new_input_labels = [[[1, 1]]]\n+        inputs = self.processor(\n+            input_points=new_input_points,\n+            input_labels=new_input_labels,\n+            original_sizes=original_inputs[\"original_sizes\"],\n+            return_tensors=\"pt\",\n+        ).to(torch_device)\n+        with torch.no_grad():\n+            outputs = self.model(\n+                **inputs,\n+                input_masks=mask_input,\n+                image_embeddings=outputs.image_embeddings,\n+                multimask_output=False,\n+            )\n+\n+        self.assertEqual(outputs.iou_scores.shape, (1, 1, 1))\n+        self.assertEqual(outputs.pred_masks.shape, (1, 1, 1, 256, 256))\n+        scores = outputs.iou_scores.squeeze((0, 1))\n+        masks_logits = outputs.pred_masks.squeeze((0, 1))[0, :3, :3]\n+        torch.testing.assert_close(scores, torch.tensor([0.9431]).to(torch_device), atol=1e-4, rtol=1e-4)\n+        torch.testing.assert_close(\n+            masks_logits,\n+            torch.tensor([[-4.1968, -4.9034, -6.0680], [-4.4053, -5.1200, -5.8580], [-4.3920, -5.5096, -5.8166]]).to(\n+                torch_device\n+            ),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+        # with negative point\n+        new_input_points = [[[[500, 375], [1125, 625]]]]\n+        new_input_labels = [[[1, 0]]]\n+        inputs = self.processor(\n+            input_points=new_input_points,\n+            input_labels=new_input_labels,\n+            original_sizes=original_inputs[\"original_sizes\"],\n+            return_tensors=\"pt\",\n+        ).to(torch_device)\n+        with torch.no_grad():\n+            outputs = self.model(\n+                **inputs,\n+                input_masks=mask_input,\n+                image_embeddings=outputs.image_embeddings,\n+                multimask_output=False,\n+            )\n+        self.assertEqual(outputs.iou_scores.shape, (1, 1, 1))\n+        self.assertEqual(outputs.pred_masks.shape, (1, 1, 1, 256, 256))\n+        scores = outputs.iou_scores.squeeze((0, 1))\n+        masks_logits = outputs.pred_masks.squeeze((0, 1))[0, :3, :3]\n+        torch.testing.assert_close(scores, torch.tensor([0.9695]).to(torch_device), atol=1e-4, rtol=1e-4)\n+        torch.testing.assert_close(\n+            masks_logits,\n+            torch.tensor(\n+                [[-14.3212, -15.4295, -17.4482], [-13.2246, -15.9468, -17.1341], [-15.1678, -16.4498, -14.7385]]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+    def test_dummy_pipeline_generation(self):\n+        generator = pipeline(\"mask-generation\", model=\"yonigozlan/EdgeTAM-hf\", device=torch_device)\n+        raw_image = prepare_image()\n+\n+        _ = generator(raw_image, points_per_batch=64)"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/edgetam_video/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/tests%2Fmodels%2Fedgetam_video%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/tests%2Fmodels%2Fedgetam_video%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fedgetam_video%2F__init__.py?ref=bd37c453544e83eb875ed3608980a1660376007a"
        },
        {
            "sha": "a2ad383351d25d9e74def96c0b6e56a2b61c83cf",
            "filename": "tests/models/edgetam_video/test_modeling_edgetam_video.py",
            "status": "added",
            "additions": 507,
            "deletions": 0,
            "changes": 507,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/tests%2Fmodels%2Fedgetam_video%2Ftest_modeling_edgetam_video.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/tests%2Fmodels%2Fedgetam_video%2Ftest_modeling_edgetam_video.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fedgetam_video%2Ftest_modeling_edgetam_video.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -0,0 +1,507 @@\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch SAM2 model.\"\"\"\n+\n+import gc\n+import unittest\n+\n+import requests\n+\n+from transformers.testing_utils import (\n+    backend_empty_cache,\n+    slow,\n+    torch_device,\n+)\n+from transformers.utils import is_torch_available, is_vision_available\n+from transformers.video_utils import load_video\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import EdgeTamVideoModel, Sam2VideoProcessor\n+\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+def prepare_image():\n+    img_url = \"https://huggingface.co/datasets/hf-internal-testing/sam2-fixtures/resolve/main/truck.jpg\"\n+    raw_image = Image.open(requests.get(img_url, stream=True).raw).convert(\"RGB\")\n+    return raw_image\n+\n+\n+def prepare_groceries_image():\n+    img_url = \"https://huggingface.co/datasets/hf-internal-testing/sam2-fixtures/resolve/main/groceries.jpg\"\n+    raw_image = Image.open(requests.get(img_url, stream=True).raw).convert(\"RGB\")\n+    return raw_image\n+\n+\n+def prepare_dog_img():\n+    img_url = \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/model_doc/dog-sam.png\"\n+    raw_image = Image.open(requests.get(img_url, stream=True).raw).convert(\"RGB\")\n+    return raw_image\n+\n+\n+def prepare_video():\n+    video_url = \"https://huggingface.co/datasets/hf-internal-testing/sam2-fixtures/resolve/main/bedroom.mp4\"\n+    raw_video, _ = load_video(video_url)\n+    return raw_video\n+\n+\n+@slow\n+class EdgeTamVideoModelIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        super().setUp()\n+        self.video_model = EdgeTamVideoModel.from_pretrained(\"yonigozlan/EdgeTAM-hf\").to(torch.float32)\n+        self.processor = Sam2VideoProcessor.from_pretrained(\"yonigozlan/EdgeTAM-hf\")\n+        self.video_model.to(torch_device)\n+        self.video_model.eval()\n+\n+    def tearDown(self):\n+        super().tearDown()\n+        # clean-up as much as possible GPU memory occupied by PyTorch\n+        gc.collect()\n+        backend_empty_cache(torch_device)\n+\n+    def test_inference_mask_generation_video_one_point(self):\n+        raw_video = prepare_video()\n+        inference_session = self.processor.init_video_session(video=raw_video, inference_device=torch_device)\n+        ann_frame_idx = 0  # the frame index we interact with\n+        ann_obj_id = 1  # give a unique id to each object we interact with (it can be any integers)\n+\n+        self.processor.add_inputs_to_inference_session(\n+            inference_session=inference_session,\n+            frame_idx=ann_frame_idx,\n+            obj_ids=ann_obj_id,\n+            input_points=[[[[210, 350]]]],\n+            input_labels=[[[1]]],\n+        )\n+        outputs = self.video_model(inference_session=inference_session, frame_idx=ann_frame_idx)\n+        low_res_masks = outputs.pred_masks\n+        self.assertEqual(low_res_masks.shape, (1, 1, 256, 256))\n+        video_res_masks = self.processor.post_process_masks([low_res_masks], [raw_video.shape[-3:-1]], binarize=False)[\n+            0\n+        ]\n+        self.assertEqual(video_res_masks.shape, (1, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        torch.testing.assert_close(\n+            video_res_masks[0, 0, :3, :3],\n+            torch.tensor(\n+                [[-28.3880, -28.3880, -27.9277], [-27.5260, -27.5260, -27.2455], [-25.5902, -25.5902, -25.7136]]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+        # test propagate in video frames\n+        frames = []\n+        for sam2_video_output in self.video_model.propagate_in_video_iterator(\n+            inference_session=inference_session,\n+            max_frame_num_to_track=2,\n+        ):\n+            video_res_masks = self.processor.post_process_masks(\n+                [sam2_video_output.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+            )[0]\n+            frames.append(video_res_masks)\n+        frames = torch.stack(frames, dim=0)\n+        self.assertEqual(frames.shape, (3, 1, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        torch.testing.assert_close(\n+            frames[:3, :, :, :2, :2],\n+            torch.tensor(\n+                [\n+                    [[[[-28.3880, -28.3880], [-27.5260, -27.5260]]]],\n+                    [[[[-15.3350, -15.3350], [-15.0002, -15.0002]]]],\n+                    [[[[-14.8729, -14.8729], [-14.6724, -14.6724]]]],\n+                ],\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+    def test_inference_mask_generation_video_one_point_propagate_in_video_directly(self):\n+        raw_video = prepare_video()\n+        inference_session = self.processor.init_video_session(video=raw_video, inference_device=torch_device)\n+        ann_frame_idx = 0  # the frame index we interact with\n+        ann_obj_id = 1  # give a unique id to each object we interact with (it can be any integers)\n+\n+        self.processor.add_inputs_to_inference_session(\n+            inference_session=inference_session,\n+            frame_idx=ann_frame_idx,\n+            obj_ids=ann_obj_id,\n+            input_points=[[[[210, 350]]]],\n+            input_labels=[[[1]]],\n+        )\n+        # test propagate in video frames\n+        frames = []\n+        for sam2_video_output in self.video_model.propagate_in_video_iterator(\n+            inference_session=inference_session,\n+            start_frame_idx=ann_frame_idx,\n+            max_frame_num_to_track=2,\n+        ):\n+            video_res_masks = self.processor.post_process_masks(\n+                [sam2_video_output.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+            )[0]\n+            frames.append(video_res_masks)\n+        frames = torch.stack(frames, dim=0)\n+        self.assertEqual(frames.shape, (3, 1, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        print(f\"VIDEO_TEST2 - ACTUAL frames[:3, :, :, :2, :2]: {frames[:3, :, :, :2, :2]}\")\n+        torch.testing.assert_close(\n+            frames[:3, :, :, :2, :2],\n+            torch.tensor(\n+                [\n+                    [[[[-28.3880, -28.3880], [-27.5260, -27.5260]]]],\n+                    [[[[-15.3350, -15.3350], [-15.0002, -15.0002]]]],\n+                    [[[[-14.8729, -14.8729], [-14.6724, -14.6724]]]],\n+                ]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+    def test_inference_mask_generation_video_multi_points(self):\n+        raw_video = prepare_video()\n+        inference_session = self.processor.init_video_session(video=raw_video, inference_device=torch_device)\n+        ann_frame_idx = 0  # the frame index we interact with\n+        ann_obj_id = 1  # give a unique id to each object we interact with (it can be any integers)\n+\n+        self.processor.add_inputs_to_inference_session(\n+            inference_session=inference_session,\n+            frame_idx=ann_frame_idx,\n+            obj_ids=ann_obj_id,\n+            input_points=[[[[210, 350], [250, 220]]]],\n+            input_labels=[[[1, 1]]],\n+        )\n+        outputs = self.video_model(inference_session=inference_session, frame_idx=ann_frame_idx)\n+        low_res_masks = outputs.pred_masks\n+        video_res_masks = self.processor.post_process_masks(\n+            [outputs.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+        )[0]\n+        self.assertEqual(low_res_masks.shape, (1, 1, 256, 256))\n+        self.assertEqual(video_res_masks.shape, (1, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        torch.testing.assert_close(\n+            video_res_masks[0, 0, :3, :3],\n+            torch.tensor(\n+                [[-17.3081, -17.3081, -16.9805], [-16.8430, -16.8430, -16.6766], [-15.7986, -15.7986, -15.9941]]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+        # test propagate in video frames\n+        frames = []\n+        for sam2_video_output in self.video_model.propagate_in_video_iterator(\n+            inference_session=inference_session,\n+            start_frame_idx=ann_frame_idx,\n+            max_frame_num_to_track=2,\n+        ):\n+            video_res_masks = self.processor.post_process_masks(\n+                [sam2_video_output.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+            )[0]\n+            frames.append(video_res_masks)\n+        frames = torch.stack(frames, dim=0)\n+        self.assertEqual(frames.shape, (3, 1, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        # higher tolerance due to errors propagating from frame to frame\n+        torch.testing.assert_close(\n+            frames[:3, :, :, :2, :2],\n+            torch.tensor(\n+                [\n+                    [[[[-17.3081, -17.3081], [-16.8430, -16.8430]]]],\n+                    [[[[-14.9302, -14.9302], [-14.8802, -14.8802]]]],\n+                    [[[[-14.4372, -14.4372], [-14.3697, -14.3697]]]],\n+                ]\n+            ).to(torch_device),\n+            atol=1e-2,\n+            rtol=1e-2,\n+        )\n+\n+    def test_inference_mask_generation_video_one_bb(self):\n+        raw_video = prepare_video()\n+        inference_session = self.processor.init_video_session(video=raw_video, inference_device=torch_device)\n+        ann_frame_idx = 0  # the frame index we interact with\n+        ann_obj_id = 1  # give a unique id to each object we interact with (it can be any integers)\n+\n+        self.processor.add_inputs_to_inference_session(\n+            inference_session=inference_session,\n+            frame_idx=ann_frame_idx,\n+            obj_ids=ann_obj_id,\n+            input_boxes=[[[300, 0, 500, 400]]],\n+        )\n+        outputs = self.video_model(inference_session=inference_session, frame_idx=ann_frame_idx)\n+        low_res_masks = outputs.pred_masks\n+        video_res_masks = self.processor.post_process_masks(\n+            [outputs.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+        )[0]\n+        self.assertEqual(low_res_masks.shape, (1, 1, 256, 256))\n+        self.assertEqual(video_res_masks.shape, (1, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        torch.testing.assert_close(\n+            video_res_masks[0, 0, :3, :3],\n+            torch.tensor(\n+                [[-17.3245, -17.3245, -16.9231], [-16.8773, -16.8773, -16.6082], [-15.8731, -15.8731, -15.9011]]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+        # test propagate in video frames\n+        frames = []\n+        for sam2_video_output in self.video_model.propagate_in_video_iterator(\n+            inference_session=inference_session,\n+            start_frame_idx=ann_frame_idx,\n+            max_frame_num_to_track=2,\n+        ):\n+            video_res_masks = self.processor.post_process_masks(\n+                [sam2_video_output.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+            )[0]\n+            frames.append(video_res_masks)\n+        frames = torch.stack(frames, dim=0)\n+        self.assertEqual(frames.shape, (3, 1, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        # higher tolerance due to errors propagating from frame to frame\n+        torch.testing.assert_close(\n+            frames[:3, :, :, :2, :2],\n+            torch.tensor(\n+                [\n+                    [[[[-17.3245, -17.3245], [-16.8773, -16.8773]]]],\n+                    [[[[-16.2826, -16.2826], [-15.9087, -15.9087]]]],\n+                    [[[[-15.8716, -15.8716], [-15.3992, -15.3992]]]],\n+                ]\n+            ).to(torch_device),\n+            atol=1e-2,\n+            rtol=1e-2,\n+        )\n+\n+    def test_inference_mask_generation_video_one_point_one_bb(self):\n+        raw_video = prepare_video()\n+        inference_session = self.processor.init_video_session(video=raw_video, inference_device=torch_device)\n+        ann_frame_idx = 0  # the frame index we interact with\n+        ann_obj_id = 1  # give a unique id to each object we interact with (it can be any integers)\n+\n+        self.processor.add_inputs_to_inference_session(\n+            inference_session=inference_session,\n+            frame_idx=ann_frame_idx,\n+            obj_ids=ann_obj_id,\n+            input_boxes=[[[300, 0, 500, 400]]],\n+            input_points=[[[[460, 60]]]],\n+            input_labels=[[[1]]],\n+        )\n+        outputs = self.video_model(inference_session=inference_session, frame_idx=ann_frame_idx)\n+        low_res_masks = outputs.pred_masks\n+        video_res_masks = self.processor.post_process_masks(\n+            [outputs.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+        )[0]\n+        self.assertEqual(low_res_masks.shape, (1, 1, 256, 256))\n+        self.assertEqual(video_res_masks.shape, (1, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        torch.testing.assert_close(\n+            video_res_masks[0, 0, :3, :3],\n+            torch.tensor(\n+                [[-13.9780, -13.9780, -13.7824], [-13.7642, -13.7642, -13.6000], [-13.2842, -13.2842, -13.1904]]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+        # test propagate in video frames\n+        frames = []\n+        for sam2_video_output in self.video_model.propagate_in_video_iterator(\n+            inference_session=inference_session,\n+            start_frame_idx=ann_frame_idx,\n+            max_frame_num_to_track=2,\n+        ):\n+            video_res_masks = self.processor.post_process_masks(\n+                [sam2_video_output.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+            )[0]\n+            frames.append(video_res_masks)\n+        frames = torch.stack(frames, dim=0)\n+        self.assertEqual(frames.shape, (3, 1, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        # higher tolerance due to errors propagating from frame to frame\n+        torch.testing.assert_close(\n+            frames[:3, :, :, :2, :2],\n+            torch.tensor(\n+                [\n+                    [[[[-13.9780, -13.9780], [-13.7642, -13.7642]]]],\n+                    [[[[-16.0142, -16.0142], [-15.5600, -15.5600]]]],\n+                    [[[[-16.7568, -16.7568], [-16.2460, -16.2460]]]],\n+                ]\n+            ).to(torch_device),\n+            atol=1e-2,\n+            rtol=1e-2,\n+        )\n+\n+    def test_inference_mask_generation_video_multi_objects_multi_points(self):\n+        raw_video = prepare_video()\n+        inference_session = self.processor.init_video_session(video=raw_video, inference_device=torch_device)\n+        ann_frame_idx = 0  # the frame index we interact with\n+        ann_obj_ids = [2, 3]  # give a unique id to each object we interact with (it can be any integers)\n+\n+        self.processor.add_inputs_to_inference_session(\n+            inference_session=inference_session,\n+            frame_idx=ann_frame_idx,\n+            obj_ids=ann_obj_ids,\n+            input_points=[[[[200, 300], [230, 250], [275, 175]], [[400, 150]]]],\n+            input_labels=[[[1, 1, 0], [1]]],\n+        )\n+        outputs = self.video_model(inference_session=inference_session, frame_idx=ann_frame_idx)\n+        low_res_masks = outputs.pred_masks\n+        video_res_masks = self.processor.post_process_masks(\n+            [outputs.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+        )[0]\n+        self.assertEqual(low_res_masks.shape, (2, 1, 256, 256))\n+        self.assertEqual(video_res_masks.shape, (2, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        torch.testing.assert_close(\n+            video_res_masks[:, 0, :2, :2],  # first object\n+            torch.tensor(\n+                [[[-12.6233, -12.6233], [-12.1809, -12.1809]], [[-13.4556, -13.4556], [-12.9549, -12.9549]]]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+        # test propagate in video frames\n+        frames = []\n+        for sam2_video_output in self.video_model.propagate_in_video_iterator(\n+            inference_session=inference_session,\n+            start_frame_idx=ann_frame_idx,\n+            max_frame_num_to_track=2,\n+        ):\n+            video_res_masks = self.processor.post_process_masks(\n+                [sam2_video_output.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+            )[0]\n+            frames.append(video_res_masks)\n+        frames = torch.stack(frames, dim=0)\n+        self.assertEqual(frames.shape, (3, 2, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        torch.testing.assert_close(\n+            frames[:3, :, :, :2, :2],\n+            torch.tensor(\n+                [\n+                    [[[[-12.6233, -12.6233], [-12.1809, -12.1809]]], [[[-13.4556, -13.4556], [-12.9549, -12.9549]]]],\n+                    [[[[-12.5589, -12.5589], [-12.4450, -12.4450]]], [[[-12.2181, -12.2181], [-12.0188, -12.0188]]]],\n+                    [[[[-15.3170, -15.3170], [-15.0254, -15.0254]]], [[[-11.4912, -11.4912], [-11.3171, -11.3171]]]],\n+                ]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+    def test_inference_propagate_video_from_mask_input(self):\n+        raw_video = prepare_video()\n+        inference_session = self.processor.init_video_session(video=raw_video, inference_device=torch_device)\n+        ann_frame_idx = 0  # the frame index we interact with\n+        ann_obj_id = 1  # give a unique id to each object we interact with (it can be any integers)\n+\n+        # get input_mask\n+        self.processor.add_inputs_to_inference_session(\n+            inference_session=inference_session,\n+            frame_idx=ann_frame_idx,\n+            obj_ids=ann_obj_id,\n+            input_points=[[[[210, 350], [250, 220]]]],\n+            input_labels=[[[1, 1]]],\n+        )\n+        sam2_video_output = self.video_model(inference_session=inference_session, frame_idx=ann_frame_idx)\n+\n+        # set mask as input\n+        self.processor.add_inputs_to_inference_session(\n+            inference_session=inference_session,\n+            frame_idx=ann_frame_idx,\n+            obj_ids=ann_obj_id,\n+            input_masks=self.processor.post_process_masks(\n+                [sam2_video_output.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+            )[0],\n+        )\n+        sam2_video_output = self.video_model(inference_session=inference_session, frame_idx=ann_frame_idx)\n+        low_res_masks = sam2_video_output.pred_masks\n+        self.assertEqual(low_res_masks.shape, (1, 1, 256, 256))\n+        video_res_masks = self.processor.post_process_masks(\n+            [sam2_video_output.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+        )[0]\n+        self.assertEqual(video_res_masks.shape, (1, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        torch.testing.assert_close(\n+            video_res_masks[0, 0, :3, :3],\n+            torch.tensor(\n+                [[-10.0000, -10.0000, -10.0000], [-10.0000, -10.0000, -10.0000], [-10.0000, -10.0000, -10.0000]]\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+        # test propagate in video frames\n+        frames = []\n+        for sam2_video_output in self.video_model.propagate_in_video_iterator(\n+            inference_session=inference_session,\n+            start_frame_idx=ann_frame_idx,\n+            max_frame_num_to_track=2,\n+        ):\n+            video_res_masks = self.processor.post_process_masks(\n+                [sam2_video_output.pred_masks], [raw_video.shape[-3:-1]], binarize=False\n+            )[0]\n+            frames.append(video_res_masks)\n+        frames = torch.stack(frames, dim=0)\n+        self.assertEqual(frames.shape, (3, 1, 1, raw_video.shape[-3], raw_video.shape[-2]))\n+        torch.testing.assert_close(\n+            frames[:3, :, :, :2, :2],\n+            torch.tensor(\n+                [\n+                    [[[[-10.0000, -10.0000], [-10.0000, -10.0000]]]],\n+                    [[[[-17.4083, -17.4083], [-17.2256, -17.2256]]]],\n+                    [[[[-13.8533, -13.8533], [-13.7759, -13.7759]]]],\n+                ],\n+            ).to(torch_device),\n+            atol=1e-4,\n+            rtol=1e-4,\n+        )\n+\n+    def test_inference_propagate_on_streamed_video(self):\n+        raw_video = prepare_video()\n+\n+        inference_session = self.processor.init_video_session(inference_device=torch_device)\n+        video_res_masks = []\n+        max_frame_num_to_track = 3\n+        for frame_idx, frame in enumerate(raw_video):\n+            if frame_idx >= max_frame_num_to_track:\n+                break\n+            inputs = self.processor(images=frame, device=torch_device, return_tensors=\"pt\")\n+            if frame_idx == 0:\n+                self.processor.add_inputs_to_inference_session(\n+                    inference_session,\n+                    frame_idx=0,\n+                    obj_ids=1,\n+                    input_points=[[[[210, 350], [250, 220]]]],\n+                    input_labels=[[[1, 1]]],\n+                    original_size=inputs.original_sizes[0],\n+                )\n+            sam2_video_output = self.video_model(inference_session=inference_session, frame=inputs.pixel_values[0])\n+            video_res_masks.append(\n+                self.processor.post_process_masks(\n+                    [sam2_video_output.pred_masks], inputs.original_sizes, binarize=False\n+                )[0]\n+            )\n+\n+        video_res_masks = torch.stack(video_res_masks, dim=0)\n+        self.assertEqual(\n+            video_res_masks.shape, (max_frame_num_to_track, 1, 1, raw_video.shape[-3], raw_video.shape[-2])\n+        )\n+        # higher tolerance due to errors propagating from frame to frame\n+        print(f\"VIDEO_TEST8 - ACTUAL video_res_masks[:3, :, :, :2, :2]: {video_res_masks[:3, :, :, :2, :2]}\")\n+        torch.testing.assert_close(\n+            video_res_masks[:3, :, :, :2, :2],\n+            torch.tensor(\n+                [\n+                    [[[[-17.3081, -17.3081], [-16.8430, -16.8430]]]],\n+                    [[[[-14.9302, -14.9302], [-14.8802, -14.8802]]]],\n+                    [[[[-14.4372, -14.4372], [-14.3697, -14.3697]]]],\n+                ]\n+            ).to(torch_device),\n+            atol=1e-2,\n+            rtol=1e-2,\n+        )"
        },
        {
            "sha": "dcacd3920a7a70d71000c7aacfa4f5a3d8f287fc",
            "filename": "tests/models/sam2/test_modeling_sam2.py",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/tests%2Fmodels%2Fsam2%2Ftest_modeling_sam2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/tests%2Fmodels%2Fsam2%2Ftest_modeling_sam2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fsam2%2Ftest_modeling_sam2.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -558,7 +558,6 @@ def test_attention_outputs(self):\n             )\n \n     # Override as Sam2Model has different sub-modules\n-\n     def test_sdpa_can_dispatch_composite_models(self):\n         \"\"\"\n         Tests if composite models dispatch correctly on SDPA/eager when requested so when loading the model."
        },
        {
            "sha": "2df8d17d6fad6871a9b6071a4cc8f5c52b72c116",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/bd37c453544e83eb875ed3608980a1660376007a/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/bd37c453544e83eb875ed3608980a1660376007a/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=bd37c453544e83eb875ed3608980a1660376007a",
            "patch": "@@ -140,7 +140,9 @@\n         \"BarkCausalModel\",  # Building part of bigger (tested) model.\n         \"BarkModel\",  # Does not have a forward signature - generation tested with integration tests.\n         \"Sam2HieraDetModel\",  # Building part of bigger (tested) model.\n-        \"Sam2VideoModel\",  # inherit from Sam2Model (tested).\n+        \"Sam2VideoModel\",  # Partly tested in Sam2Model, not regular model.\n+        \"EdgeTamVisionModel\",  # Building part of bigger (tested) model.\n+        \"EdgeTamVideoModel\",  # Partly tested in EdgeTamModel, not regular model.\n         \"SeamlessM4TTextToUnitModel\",  # Building part of bigger (tested) model.\n         \"SeamlessM4TCodeHifiGan\",  # Building part of bigger (tested) model.\n         \"SeamlessM4TTextToUnitForConditionalGeneration\",  # Building part of bigger (tested) model.\n@@ -208,6 +210,7 @@\n     \"models/shieldgemma2/test_modeling_shieldgemma2.py\",\n     \"models/llama4/test_modeling_llama4.py\",\n     \"models/sam2_video/test_modeling_sam2_video.py\",\n+    \"models/edgetam_video/test_modeling_edgetam_video.py\",\n ]\n \n # Update this list for models that are not in any of the auto MODEL_XXX_MAPPING. Being in this list is an exception and\n@@ -256,6 +259,8 @@\n     \"SamModel\",\n     \"Sam2Model\",\n     \"Sam2VideoModel\",\n+    \"EdgeTamModel\",\n+    \"EdgeTamVideoModel\",\n     \"SamHQModel\",\n     \"DPTForDepthEstimation\",\n     \"DecisionTransformerGPT2Model\","
        }
    ],
    "stats": {
        "total": 9918,
        "additions": 9621,
        "deletions": 297
    }
}