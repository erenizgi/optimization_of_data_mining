{
    "author": "orionw",
    "message": "Add ModernBERT Decoder Models - ModernBERT, but trained with CLM! (#38967)\n\n* working locally; need to style and test\n\n* added docs and initial tests; need to debug and flesh out\n\n* fixed tests\n\n* working long context; batches\n\n* working fa2 and eager\n\n* update tests\n\n* add missing confnigs\n\n* remove default autoset\n\n* fix spacing\n\n* fix most tests\n\n* fixed tests\n\n* fix to init\n\n* refactor to match new transformers updates\n\n* remove static cache option\n\n* fa2 fix\n\n* fix docs\n\n* in progress\n\n* working on tests\n\n* fixed issue with attn outputs\n\n* remove debug\n\n* fix local config attr\n\n* update doc string\n\n* fix docstring\n\n* add docs to toc\n\n* correct typo in toc\n\n* add new updates from main w.r.t. ModernBERT RoPE\n\n* fix local param\n\n---------\n\nCo-authored-by: oweller2 <oweller2@dsailogin.mgmt.ai.cluster>\nCo-authored-by: oweller2 <oweller2@l07.mgmt.ai.cluster>\nCo-authored-by: oweller2 <oweller2@n02.mgmt.ai.cluster>\nCo-authored-by: oweller2 <oweller2@l08.mgmt.ai.cluster>\nCo-authored-by: oweller2 <oweller2@l01.mgmt.ai.cluster>\nCo-authored-by: oweller2 <oweller2@l02.mgmt.ai.cluster>",
    "sha": "0e4b7938d0e965362973797f47ad2b85f605a96a",
    "files": [
        {
            "sha": "733db0924003f964480812a030a5b9ec3c242709",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=0e4b7938d0e965362973797f47ad2b85f605a96a",
            "patch": "@@ -563,6 +563,8 @@\n         title: MobileBERT\n       - local: model_doc/modernbert\n         title: ModernBert\n+      - local: model_doc/modernbert-decoder\n+        title: ModernBERTDecoder\n       - local: model_doc/mpnet\n         title: MPNet\n       - local: model_doc/mpt"
        },
        {
            "sha": "23b45977b3808aadfa2f28e40d30641d35126b44",
            "filename": "docs/source/en/model_doc/modernbert-decoder.md",
            "status": "added",
            "additions": 155,
            "deletions": 0,
            "changes": 155,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/docs%2Fsource%2Fen%2Fmodel_doc%2Fmodernbert-decoder.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/docs%2Fsource%2Fen%2Fmodel_doc%2Fmodernbert-decoder.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fmodernbert-decoder.md?ref=0e4b7938d0e965362973797f47ad2b85f605a96a",
            "patch": "@@ -0,0 +1,155 @@\n+<!--Copyright 2024 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+<div style=\"float: right;\">\n+  <div class=\"flex flex-wrap space-x-1\">\n+    <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+    <img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+    <img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+  </div>\n+</div>\n+\n+# ModernBERT Decoder\n+\n+ModernBERT Decoder is the same architecture as [ModernBERT](https://huggingface.co/papers/2412.13663) but trained from scratch with a causal language modeling (CLM) objective. This allows for using the same architecture for comparing encoders and decoders. This is the decoder architecture implementation of ModernBERT, designed for autoregressive text generation tasks.\n+\n+Like the encoder version, ModernBERT Decoder incorporates modern architectural improvements such as rotary positional embeddings to support sequences of up to 8192 tokens, unpadding to avoid wasting compute on padding tokens, GeGLU layers, and alternating attention patterns. However, it uses causal (unidirectional) attention to enable autoregressive generation.\n+\n+> [!TIP]\n+> Click on the ModernBERT Decoder models in the right sidebar for more examples of how to apply ModernBERT Decoder to different text generation tasks.\n+\n+The example below demonstrates how to use ModernBERT Decoder for text generation with [`Pipeline`], [`AutoModel`], and from the command line.\n+\n+<hfoptions id=\"usage\">\n+<hfoption id=\"Pipeline\">\n+\n+```py\n+import torch\n+from transformers import pipeline\n+\n+generator = pipeline(\n+    task=\"text-generation\",\n+    model=\"blab-jhu/test-32m-dec\",\n+    torch_dtype=torch.float16,\n+    device=0\n+)\n+generator(\"The future of artificial intelligence is\", max_length=50, num_return_sequences=1)\n+\n+# For sequence classification\n+classifier = pipeline(\n+    task=\"text-classification\",\n+    model=\"blab-jhu/test-32m-dec\",\n+    torch_dtype=torch.float16,\n+    device=0\n+)\n+classifier(\"This movie is really great!\")\n+```\n+\n+</hfoption>\n+<hfoption id=\"AutoModel\">\n+\n+```py\n+import torch\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+tokenizer = AutoTokenizer.from_pretrained(\"blab-jhu/test-32m-dec\")\n+model = AutoModelForCausalLM.from_pretrained(\n+    \"blab-jhu/test-32m-dec\",\n+    torch_dtype=torch.float16,\n+    device_map=\"auto\",\n+)\n+\n+prompt = \"The future of artificial intelligence is\"\n+inputs = tokenizer(prompt, return_tensors=\"pt\").to(\"cuda\")\n+\n+with torch.no_grad():\n+    outputs = model.generate(\n+        **inputs,\n+        max_length=50,\n+        num_return_sequences=1,\n+        temperature=0.7,\n+        do_sample=True,\n+        pad_token_id=tokenizer.eos_token_id\n+    )\n+\n+generated_text = tokenizer.decode(outputs[0], skip_special_tokens=True)\n+print(f\"Generated text: {generated_text}\")\n+\n+# For sequence classification\n+from transformers import AutoModelForSequenceClassification\n+\n+classifier_model = AutoModelForSequenceClassification.from_pretrained(\n+    \"blab-jhu/test-32m-dec\",\n+    torch_dtype=torch.float16,\n+    device_map=\"auto\",\n+    num_labels=2\n+)\n+\n+text = \"This movie is really great!\"\n+inputs = tokenizer(text, return_tensors=\"pt\").to(\"cuda\")\n+\n+with torch.no_grad():\n+    outputs = classifier_model(**inputs)\n+    predictions = torch.nn.functional.softmax(outputs.logits, dim=-1)\n+    predicted_class = torch.argmax(predictions, dim=-1)\n+\n+print(f\"Predicted class: {predicted_class.item()}\")\n+print(f\"Prediction probabilities: {predictions}\")\n+```\n+\n+</hfoption>\n+<hfoption id=\"transformers CLI\">\n+\n+```bash\n+echo \"The future of artificial intelligence is\" | transformers run --task text-generation --model your-username/modernbert-decoder-base --device 0\n+```\n+\n+</hfoption>\n+</hfoptions>\n+\n+## ModernBertDecoderConfig\n+\n+[[autodoc]] ModernBertDecoderConfig\n+\n+<frameworkcontent>\n+<pt>\n+\n+## ModernBertDecoderModel\n+\n+[[autodoc]] ModernBertDecoderModel\n+    - forward\n+\n+## ModernBertDecoderForCausalLM\n+\n+[[autodoc]] ModernBertDecoderForCausalLM\n+    - forward\n+\n+## ModernBertDecoderForSequenceClassification\n+\n+[[autodoc]] ModernBertDecoderForSequenceClassification\n+    - forward\n+\n+### Usage tips\n+\n+The ModernBertDecoder model can be fine-tuned for various text generation tasks using the HuggingFace Transformers library. It supports efficient inference with features like:\n+\n+- **Causal attention**: Ensures autoregressive generation by masking future tokens\n+- **Sliding window attention**: Alternates between local and global attention patterns for efficiency\n+- **Rotary positional embeddings**: Enables handling of longer sequences up to 8000 tokens\n+- **FlashAttention support**: Optimized attention computation for faster training and inference\n+\n+</pt>\n+</frameworkcontent>"
        },
        {
            "sha": "4dcc2150ec5c26e51b6212149d0b94f8a85ef329",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=0e4b7938d0e965362973797f47ad2b85f605a96a",
            "patch": "@@ -207,6 +207,7 @@\n     from .mobilevit import *\n     from .mobilevitv2 import *\n     from .modernbert import *\n+    from .modernbert_decoder import *\n     from .moonshine import *\n     from .moshi import *\n     from .mpnet import *"
        },
        {
            "sha": "e3bd2b253f0162f47d43278223a734c8ecc2be16",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=0e4b7938d0e965362973797f47ad2b85f605a96a",
            "patch": "@@ -241,6 +241,7 @@\n         (\"mobilevit\", \"MobileViTConfig\"),\n         (\"mobilevitv2\", \"MobileViTV2Config\"),\n         (\"modernbert\", \"ModernBertConfig\"),\n+        (\"modernbert-decoder\", \"ModernBertDecoderConfig\"),\n         (\"moonshine\", \"MoonshineConfig\"),\n         (\"moshi\", \"MoshiConfig\"),\n         (\"mpnet\", \"MPNetConfig\"),\n@@ -642,6 +643,7 @@\n         (\"mobilevit\", \"MobileViT\"),\n         (\"mobilevitv2\", \"MobileViTV2\"),\n         (\"modernbert\", \"ModernBERT\"),\n+        (\"modernbert-decoder\", \"ModernBertDecoder\"),\n         (\"moonshine\", \"Moonshine\"),\n         (\"moshi\", \"Moshi\"),\n         (\"mpnet\", \"MPNet\"),"
        },
        {
            "sha": "dcf80c3d9fbff6f8ee55191b754223ca4252b494",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=0e4b7938d0e965362973797f47ad2b85f605a96a",
            "patch": "@@ -230,6 +230,7 @@\n         (\"mobilevit\", \"MobileViTModel\"),\n         (\"mobilevitv2\", \"MobileViTV2Model\"),\n         (\"modernbert\", \"ModernBertModel\"),\n+        (\"modernbert-decoder\", \"ModernBertDecoderModel\"),\n         (\"moonshine\", \"MoonshineModel\"),\n         (\"moshi\", \"MoshiModel\"),\n         (\"mpnet\", \"MPNetModel\"),\n@@ -631,6 +632,7 @@\n         (\"mistral\", \"MistralForCausalLM\"),\n         (\"mixtral\", \"MixtralForCausalLM\"),\n         (\"mllama\", \"MllamaForCausalLM\"),\n+        (\"modernbert-decoder\", \"ModernBertDecoderForCausalLM\"),\n         (\"moshi\", \"MoshiForCausalLM\"),\n         (\"mpt\", \"MptForCausalLM\"),\n         (\"musicgen\", \"MusicgenForCausalLM\"),\n@@ -1158,6 +1160,7 @@\n         (\"mixtral\", \"MixtralForSequenceClassification\"),\n         (\"mobilebert\", \"MobileBertForSequenceClassification\"),\n         (\"modernbert\", \"ModernBertForSequenceClassification\"),\n+        (\"modernbert-decoder\", \"ModernBertDecoderForSequenceClassification\"),\n         (\"mpnet\", \"MPNetForSequenceClassification\"),\n         (\"mpt\", \"MptForSequenceClassification\"),\n         (\"mra\", \"MraForSequenceClassification\"),"
        },
        {
            "sha": "8f29efca0bf52a68509d3b58ad3ca456f216a042",
            "filename": "src/transformers/models/modernbert_decoder/__init__.py",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2Fmodernbert_decoder%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2Fmodernbert_decoder%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmodernbert_decoder%2F__init__.py?ref=0e4b7938d0e965362973797f47ad2b85f605a96a",
            "patch": "@@ -0,0 +1,27 @@\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_modernbert_decoder import *\n+    from .modeling_modernbert_decoder import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "6a065a53dfc4b27d1f82cd0385c0c67636018c63",
            "filename": "src/transformers/models/modernbert_decoder/configuration_modernbert_decoder.py",
            "status": "added",
            "additions": 208,
            "deletions": 0,
            "changes": 208,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2Fmodernbert_decoder%2Fconfiguration_modernbert_decoder.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2Fmodernbert_decoder%2Fconfiguration_modernbert_decoder.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmodernbert_decoder%2Fconfiguration_modernbert_decoder.py?ref=0e4b7938d0e965362973797f47ad2b85f605a96a",
            "patch": "@@ -0,0 +1,208 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/modernbert_decoder/modular_modernbert_decoder.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_modernbert_decoder.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# Copyright 2025 Johns Hopkins University, LightOn, and the HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from ...configuration_utils import PretrainedConfig\n+\n+\n+class ModernBertDecoderConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`ModernBertDecoderModel`]. It is used to instantiate a ModernBert\n+    decoder model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n+    defaults will yield a similar configuration to that of the ModernBERT-base decoder.\n+    e.g. [blab-jhu/test-32m-dec](https://huggingface.co/blab-jhu/test-32m-dec)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 50368):\n+            Vocabulary size of the ModernBert decoder model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`ModernBertDecoderModel`]\n+        hidden_size (`int`, *optional*, defaults to 768):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 1152):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 22):\n+            Number of hidden layers in the Transformer decoder.\n+        num_attention_heads (`int`, *optional*, defaults to 12):\n+            Number of attention heads for each attention layer in the Transformer decoder.\n+        hidden_activation (`str` or `function`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function (function or string) in the decoder. Will default to `\"gelu\"`\n+            if not specified.\n+        max_position_embeddings (`int`, *optional*, defaults to 8192):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        initializer_cutoff_factor (`float`, *optional*, defaults to 2.0):\n+            The cutoff factor for the truncated_normal_initializer for initializing all weight matrices.\n+        norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        norm_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use bias in the normalization layers.\n+        pad_token_id (`int`, *optional*, defaults to 50283):\n+            Padding token id.\n+        eos_token_id (`int`, *optional*, defaults to 50282):\n+            End of stream token id.\n+        bos_token_id (`int`, *optional*, defaults to 50281):\n+            Beginning of stream token id.\n+        cls_token_id (`int`, *optional*, defaults to 50281):\n+            Classification token id.\n+        sep_token_id (`int`, *optional*, defaults to 50282):\n+            Separation token id.\n+        global_rope_theta (`float`, *optional*, defaults to 160000.0):\n+            The base period of the global RoPE embeddings.\n+        attention_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        embedding_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the embeddings.\n+        mlp_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use bias in the MLP layers.\n+        mlp_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the MLP layers.\n+        decoder_bias (`bool`, *optional*, defaults to `True`):\n+            Whether to use bias in the decoder layers.\n+        classifier_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the classifier.\n+        classifier_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use bias in the classifier.\n+        classifier_activation (`str`, *optional*, defaults to `\"gelu\"`):\n+            The activation function for the classifier.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        local_attention (`int`, *optional*, defaults to 128):\n+            The sliding window size for local attention. Only used for layers that use local attention. Note that for\n+            the decoder to match ModernBERT this is actually half of the sliding window size, so 128 => 64.\n+        global_attn_every_n_layers (`int`, *optional*, defaults to 3):\n+            Every `global_attn_every_n_layers` layers will use global attention instead of local attention.\n+        local_rope_theta (`float`, *optional*, defaults to 160000.0):\n+            The base period of the local RoPE embeddings. If not specified, defaults to 160000.0\n+        layer_types (`list`, *optional*):\n+            List of layer types, one for each layer. If not specified, will be automatically generated based on\n+            `global_attn_every_n_layers`. Should contain \"full_attention\" or \"sliding_attention\".\n+\n+    Examples:\n+\n+    ```python\n+    >>> from transformers import ModernBertDecoderModel, ModernBertDecoderConfig\n+\n+    >>> # Initializing a ModernBert decoder style configuration\n+    >>> configuration = ModernBertDecoderConfig()\n+\n+    >>> # Initializing a model from the modernbert-base decoder style configuration\n+    >>> model = ModernBertDecoderModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"modernbert-decoder\"\n+    attribute_map = {\"rope_theta\": \"global_rope_theta\"}\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        vocab_size=50368,\n+        hidden_size=768,\n+        intermediate_size=1152,\n+        num_hidden_layers=22,\n+        num_attention_heads=12,\n+        hidden_activation=\"gelu\",\n+        max_position_embeddings=8192,\n+        initializer_range=0.02,\n+        initializer_cutoff_factor=2.0,\n+        norm_eps=1e-5,\n+        norm_bias=False,\n+        pad_token_id=50283,\n+        eos_token_id=50282,\n+        bos_token_id=50281,\n+        cls_token_id=50281,\n+        sep_token_id=50282,\n+        global_rope_theta=160000.0,\n+        attention_bias=False,\n+        attention_dropout=0.0,\n+        embedding_dropout=0.0,\n+        mlp_bias=False,\n+        mlp_dropout=0.0,\n+        decoder_bias=True,\n+        classifier_dropout=0.0,\n+        classifier_bias=False,\n+        classifier_activation=\"gelu\",\n+        use_cache=True,\n+        local_attention=128,\n+        global_attn_every_n_layers=3,\n+        local_rope_theta=160000.0,\n+        layer_types=None,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            cls_token_id=cls_token_id,\n+            sep_token_id=sep_token_id,\n+            **kwargs,\n+        )\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.initializer_range = initializer_range\n+        self.initializer_cutoff_factor = initializer_cutoff_factor\n+        self.norm_eps = norm_eps\n+        self.norm_bias = norm_bias\n+        self.global_rope_theta = global_rope_theta\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+        self.hidden_activation = hidden_activation\n+        self.embedding_dropout = embedding_dropout\n+        self.mlp_bias = mlp_bias\n+        self.mlp_dropout = mlp_dropout\n+        self.decoder_bias = decoder_bias\n+        self.classifier_dropout = classifier_dropout\n+        self.classifier_bias = classifier_bias\n+        self.classifier_activation = classifier_activation\n+        self.use_cache = use_cache\n+        self.global_attn_every_n_layers = global_attn_every_n_layers\n+        self.local_rope_theta = local_rope_theta\n+        # for consistency with ModernBert\n+        self.reference_compile = False\n+\n+        # Set up layer_types for standardized layer type detection\n+        self.layer_types = layer_types\n+        if self.layer_types is None:\n+            # Create layer_types based on the alternating pattern\n+            self.layer_types = []\n+            for layer_id in range(num_hidden_layers):\n+                if layer_id % global_attn_every_n_layers != 0:\n+                    self.layer_types.append(\"sliding_attention\")\n+                else:\n+                    self.layer_types.append(\"full_attention\")\n+\n+        # NOTE: sliding window numbers matches ModernBERT but is only half of it\n+        self.sliding_window = local_attention // 2 if local_attention else -1\n+\n+\n+__all__ = [\"ModernBertDecoderConfig\"]"
        },
        {
            "sha": "a997f40e916a8ca154656783ae63ac7fbaaf7fce",
            "filename": "src/transformers/models/modernbert_decoder/modeling_modernbert_decoder.py",
            "status": "added",
            "additions": 616,
            "deletions": 0,
            "changes": 616,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2Fmodernbert_decoder%2Fmodeling_modernbert_decoder.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2Fmodernbert_decoder%2Fmodeling_modernbert_decoder.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmodernbert_decoder%2Fmodeling_modernbert_decoder.py?ref=0e4b7938d0e965362973797f47ad2b85f605a96a",
            "patch": "@@ -0,0 +1,616 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/modernbert_decoder/modular_modernbert_decoder.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_modernbert_decoder.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# Copyright 2025 Johns Hopkins University, LightOn, and the HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import math\n+from collections.abc import Callable\n+from typing import Optional, Union\n+\n+import torch\n+from torch import nn\n+from torch.nn import BCEWithLogitsLoss, CrossEntropyLoss, MSELoss\n+\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...masking_utils import create_causal_mask, create_sliding_window_causal_mask\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import BaseModelOutputWithPast, CausalLMOutputWithPast, SequenceClassifierOutputWithPast\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS\n+from ...models.modernbert.modeling_modernbert import (\n+    ModernBertEmbeddings,\n+    ModernBertMLP,\n+    ModernBertPredictionHead,\n+    ModernBertPreTrainedModel,\n+    ModernBertRotaryEmbedding,\n+    apply_rotary_pos_emb,\n+)\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring, can_return_tuple, logging\n+from ...utils.generic import check_model_inputs\n+from .configuration_modernbert_decoder import ModernBertDecoderConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+def eager_attention_forward(\n+    module: \"ModernBertDecoderAttention\",\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    dropout: float = 0.0,\n+    scaling: Optional[float] = None,\n+    sliding_window: Optional[int] = None,\n+    **kwargs,\n+) -> tuple[torch.Tensor, Optional[torch.Tensor]]:\n+    \"\"\"A simple eager attention implementation for ModernBERT decoder.\"\"\"\n+    if scaling is None:\n+        scaling = module.head_dim**-0.5\n+\n+    # Compute attention scores\n+    attn_weights = torch.matmul(query, key.transpose(2, 3)) * scaling\n+\n+    # Use the pre-computed attention mask\n+    causal_mask = attention_mask[:, :, :, : key.shape[-2]]\n+    attn_weights = attn_weights + causal_mask\n+\n+    # upcast attention to fp32\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+    return attn_output, attn_weights\n+\n+\n+class ModernBertDecoderAttention(nn.Module):\n+    \"\"\"Performs causal multi-headed self attention for ModernBERT decoder.\n+\n+    It supports both local attention (sliding window) and global attention patterns.\n+    \"\"\"\n+\n+    def __init__(self, config: ModernBertDecoderConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+        self.is_sliding = config.layer_types[layer_idx] == \"sliding_attention\"\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.head_dim = config.hidden_size // config.num_attention_heads\n+        self.num_heads = config.num_attention_heads\n+        self.all_head_size = self.head_dim * self.num_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.attention_dropout = self.config.attention_dropout\n+        self.is_causal = True\n+\n+        if config.hidden_size % config.num_attention_heads != 0:\n+            raise ValueError(\n+                f\"The hidden size ({config.hidden_size}) is not a multiple of the number of attention heads ({config.num_attention_heads})\"\n+            )\n+\n+        # NOTE: this is different than ModernBERT (separated QKV) so be sure to adapt to this\n+        self.q_proj = nn.Linear(self.config.hidden_size, self.all_head_size, bias=self.config.attention_bias)\n+        self.k_proj = nn.Linear(self.config.hidden_size, self.all_head_size, bias=self.config.attention_bias)\n+        self.v_proj = nn.Linear(self.config.hidden_size, self.all_head_size, bias=self.config.attention_bias)\n+\n+        self.Wo = nn.Linear(config.hidden_size, config.hidden_size, bias=config.attention_bias)\n+        self.out_drop = nn.Dropout(config.attention_dropout)\n+\n+        self.sliding_window = config.sliding_window if config.layer_types[layer_idx] == \"sliding_attention\" else None\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=self.attention_dropout if self.training else 0.0,\n+            scaling=self.scaling,\n+            sliding_window=self.sliding_window,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.out_drop(self.Wo(attn_output))\n+        return attn_output, attn_weights\n+\n+\n+class ModernBertDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: ModernBertDecoderConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.attention_type = config.layer_types[layer_idx]\n+        self.attn_norm = (\n+            nn.LayerNorm(config.hidden_size, eps=config.norm_eps, bias=config.norm_bias)\n+            if layer_idx != 0\n+            else nn.Identity()\n+        )\n+        self.attn = ModernBertDecoderAttention(config=config, layer_idx=layer_idx)\n+        self.mlp_norm = nn.LayerNorm(config.hidden_size, eps=config.norm_eps, bias=config.norm_bias)\n+        self.mlp = ModernBertMLP(config)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings_global: torch.Tensor,\n+        position_embeddings_local: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> tuple[torch.FloatTensor, Optional[tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        residual = hidden_states\n+        hidden_states = self.attn_norm(hidden_states)\n+\n+        # apply global RoPE to non-sliding layer only\n+        if self.attn.is_sliding:\n+            position_embeddings = position_embeddings_local\n+        else:\n+            position_embeddings = position_embeddings_global\n+\n+        # Self Attention\n+        attn_outputs = self.attn(\n+            hidden_states=hidden_states,\n+            position_embeddings=position_embeddings,\n+            attention_mask=attention_mask,\n+            past_key_value=past_key_value,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = attn_outputs[0]\n+\n+        # Add residual connection\n+        hidden_states = residual + hidden_states\n+\n+        # MLP\n+        residual = hidden_states\n+        hidden_states = self.mlp_norm(hidden_states)\n+        mlp_output = self.mlp(hidden_states)\n+        hidden_states = residual + mlp_output\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class ModernBertDecoderPreTrainedModel(ModernBertPreTrainedModel):\n+    config_class = ModernBertDecoderConfig\n+    base_model_prefix = \"model\"\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _no_split_modules = [\"ModernBertDecoderLayer\"]\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = False\n+    _supports_gradient_checkpointing = True\n+    _supports_cache_class = True\n+    _supports_quantized_cache = True\n+    _supports_static_cache = False\n+    _supports_attention_backend = True\n+    _can_record_outputs = {\n+        \"hidden_states\": ModernBertDecoderLayer,\n+        \"attentions\": ModernBertDecoderAttention,\n+    }\n+\n+    def _init_weights(self, module: nn.Module):\n+        cutoff_factor = self.config.initializer_cutoff_factor\n+        if cutoff_factor is None:\n+            cutoff_factor = 3\n+\n+        def init_weight(module: nn.Module, std: float):\n+            nn.init.trunc_normal_(\n+                module.weight,\n+                mean=0.0,\n+                std=std,\n+                a=-cutoff_factor * std,\n+                b=cutoff_factor * std,\n+            )\n+\n+            if isinstance(module, nn.Linear):\n+                if module.bias is not None:\n+                    nn.init.zeros_(module.bias)\n+\n+        stds = {\n+            \"in\": self.config.initializer_range,\n+            \"out\": self.config.initializer_range / math.sqrt(2.0 * self.config.num_hidden_layers),\n+            \"embedding\": self.config.initializer_range,\n+            \"final_out\": self.config.hidden_size**-0.5,\n+        }\n+\n+        if isinstance(module, ModernBertEmbeddings):\n+            init_weight(module.tok_embeddings, stds[\"embedding\"])\n+        elif isinstance(module, ModernBertMLP):\n+            init_weight(module.Wi, stds[\"in\"])\n+            init_weight(module.Wo, stds[\"out\"])\n+        elif isinstance(module, ModernBertDecoderAttention):\n+            init_weight(module.q_proj, stds[\"in\"])\n+            init_weight(module.k_proj, stds[\"in\"])\n+            init_weight(module.v_proj, stds[\"in\"])\n+            init_weight(module.Wo, stds[\"out\"])\n+        elif isinstance(module, ModernBertPredictionHead):\n+            init_weight(module.dense, stds[\"out\"])\n+        elif isinstance(module, ModernBertDecoderForSequenceClassification):\n+            init_weight(module.classifier, stds[\"final_out\"])\n+        elif isinstance(module, ModernBertDecoderForCausalLM):\n+            init_weight(module.decoder, stds[\"out\"])\n+        elif isinstance(module, nn.LayerNorm):\n+            module.weight.data.fill_(1.0)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+\n+\n+@auto_docstring\n+class ModernBertDecoderModel(ModernBertDecoderPreTrainedModel):\n+    def __init__(self, config: ModernBertDecoderConfig):\n+        super().__init__(config)\n+        self.config = config\n+        self.embeddings = ModernBertEmbeddings(config)\n+        self.layers = nn.ModuleList(\n+            [ModernBertDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.final_norm = nn.LayerNorm(config.hidden_size, eps=config.norm_eps, bias=config.norm_bias)\n+        self.gradient_checkpointing = False\n+\n+        self.global_rotary_emb = ModernBertRotaryEmbedding(config=config)\n+        self.local_rotary_emb = ModernBertRotaryEmbedding(config=config)\n+\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.embeddings.tok_embeddings\n+\n+    def set_input_embeddings(self, value):\n+        self.embeddings.tok_embeddings = value\n+\n+    @check_model_inputs\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> Union[tuple[torch.Tensor, ...], BaseModelOutputWithPast]:\n+        if (input_ids is None) == (inputs_embeds is None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if input_ids is not None:\n+            self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n+            batch_size, seq_length = input_ids.shape[:2]\n+        else:\n+            batch_size, seq_length = inputs_embeds.shape[:2]\n+\n+        # Handle past_key_values and cache setup\n+        if use_cache and past_key_values is None and not self.training:\n+            past_key_values = DynamicCache()\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens,\n+                past_seen_tokens + seq_length,\n+                device=input_ids.device if input_ids is not None else inputs_embeds.device,\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0).expand(batch_size, -1)\n+\n+        # Calculate embeddings\n+        hidden_states = self.embeddings(input_ids=input_ids, inputs_embeds=inputs_embeds)\n+\n+        # It may already have been prepared by e.g. `generate`\n+        if not isinstance(causal_mask_mapping := attention_mask, dict):\n+            # Prepare mask arguments\n+            mask_kwargs = {\n+                \"config\": self.config,\n+                \"input_embeds\": hidden_states,\n+                \"attention_mask\": attention_mask,\n+                \"cache_position\": cache_position,\n+                \"past_key_values\": past_key_values,\n+                \"position_ids\": position_ids,\n+            }\n+\n+            causal_mask_mapping = {\n+                \"full_attention\": create_causal_mask(**mask_kwargs),\n+                \"sliding_attention\": create_sliding_window_causal_mask(**mask_kwargs),\n+            }\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings_global = self.global_rotary_emb(hidden_states, position_ids)\n+        position_embeddings_local = self.local_rotary_emb(hidden_states, position_ids)\n+\n+        for idx, decoder_layer in enumerate(self.layers):\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                position_embeddings_global=position_embeddings_global,\n+                position_embeddings_local=position_embeddings_local,\n+                attention_mask=causal_mask_mapping[decoder_layer.attention_type],\n+                past_key_value=past_key_values,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+\n+        hidden_states = self.final_norm(hidden_states)\n+\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    The ModernBert Decoder Model with a language modeling head on top for causal language modeling (CLM).\n+    \"\"\"\n+)\n+class ModernBertDecoderForCausalLM(ModernBertDecoderPreTrainedModel, GenerationMixin):\n+    _tied_weights_keys = [\"decoder.weight\"]\n+\n+    def __init__(self, config: ModernBertDecoderConfig):\n+        super().__init__(config)\n+        self.config = config\n+        self.model = ModernBertDecoderModel(config)\n+        self.lm_head = ModernBertPredictionHead(config)\n+        self.decoder = nn.Linear(config.hidden_size, config.vocab_size, bias=config.decoder_bias)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_output_embeddings(self):\n+        return self.decoder\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.decoder = new_embeddings\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        **kwargs,\n+    ) -> Union[tuple, CausalLMOutputWithPast]:\n+        r\"\"\"\n+        Args:\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+        Returns:\n+            [`~modeling_outputs.CausalLMOutputWithPast`]\n+            comprising various elements depending on the configuration and inputs.\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, ModernBertDecoderForCausalLM\n+\n+        >>> model = ModernBertDecoderForCausalLM.from_pretrained(\"blab-jhu/test-32m-dec\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"blab-jhu/test-32m-dec\")\n+\n+        >>> prompt = \"The capital of France is\"\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=1)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"The capital of France is Paris\"\n+        ```\n+        \"\"\"\n+        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs[0]\n+        logits = self.decoder(self.lm_head(hidden_states))\n+\n+        loss = None\n+        if labels is not None:\n+            # Shift so that tokens < n predict n\n+            shift_logits = logits[..., :-1, :].contiguous()\n+            shift_labels = labels[..., 1:].contiguous()\n+            # Flatten the tokens\n+            loss_fct = CrossEntropyLoss()\n+            shift_logits = shift_logits.view(-1, self.config.vocab_size)\n+            shift_labels = shift_labels.view(-1)\n+            # Enable model parallelism\n+            shift_labels = shift_labels.to(shift_logits.device)\n+            loss = loss_fct(shift_logits, shift_labels)\n+\n+        return CausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+    @staticmethod\n+    def _reorder_cache(past_key_values, beam_idx):\n+        reordered_past = ()\n+        for layer_past in past_key_values:\n+            reordered_past += (\n+                tuple(past_state.index_select(0, beam_idx.to(past_state.device)) for past_state in layer_past),\n+            )\n+        return reordered_past\n+\n+\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    The ModernBert Decoder Model with a sequence classification head on top (linear layer).\n+\n+    [`ModernBertDecoderForSequenceClassification`] uses the last token in order to do the classification, as other causal models\n+    (e.g. GPT-1, GPT-2) do.\n+\n+    Since it does classification on the last token, it requires to know the position of the last token. If a\n+    `pad_token_id` is defined in the configuration, it finds the last token that is not a padding token in each row. If\n+    no `pad_token_id` is defined, it simply takes the last value in each row of the batch. Since it cannot guess the\n+    padding tokens when `inputs_embeds` are passed instead of `input_ids`, it does the same (take the last value in\n+    each row of the batch).\n+    \"\"\"\n+)\n+class ModernBertDecoderForSequenceClassification(ModernBertDecoderPreTrainedModel):\n+    def __init__(self, config: ModernBertDecoderConfig):\n+        super().__init__(config)\n+        self.num_labels = config.num_labels\n+        self.model = ModernBertDecoderModel(config)\n+\n+        self.head = ModernBertPredictionHead(config)\n+        self.classifier = nn.Linear(config.hidden_size, config.num_labels, bias=config.classifier_bias)\n+        self.drop = torch.nn.Dropout(config.classifier_dropout)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @can_return_tuple\n+    @auto_docstring(checkpoint=\"blab-jhu/test-32m-dec\")\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        **kwargs,\n+    ) -> Union[tuple, SequenceClassifierOutputWithPast]:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n+            Labels for computing the sequence classification/regression loss. Indices should be in `[0, ...,\n+            config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If\n+            `config.num_labels > 1` a classification loss is computed (Cross-Entropy).\n+        \"\"\"\n+        transformer_outputs = self.model(\n+            input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            **kwargs,\n+        )\n+        hidden_states = transformer_outputs[0]\n+        hidden_states = self.drop(self.head(hidden_states))\n+        logits = self.classifier(hidden_states)\n+\n+        if input_ids is not None:\n+            batch_size, sequence_length = input_ids.shape[:2]\n+        else:\n+            batch_size, sequence_length = inputs_embeds.shape[:2]\n+\n+        if self.config.pad_token_id is None and batch_size != 1:\n+            raise ValueError(\"Cannot handle batch sizes > 1 if no padding token is defined.\")\n+        if self.config.pad_token_id is None:\n+            last_non_pad_token = -1\n+        elif input_ids is not None:\n+            # To handle both left- and right- padding, we take the rightmost token that is not equal to pad_token_id\n+            non_pad_mask = (input_ids != self.config.pad_token_id).to(logits.device, torch.int32)\n+            token_indices = torch.arange(input_ids.shape[-1], device=logits.device, dtype=torch.int32)\n+            last_non_pad_token = (token_indices * non_pad_mask).argmax(-1)\n+        else:\n+            last_non_pad_token = -1\n+            logger.warning_once(\n+                f\"{self.__class__.__name__} will not detect padding tokens in `inputs_embeds`. Results may be \"\n+                \"unexpected if using padding tokens in conjunction with `inputs_embeds.`\"\n+            )\n+\n+        pooled_logits = logits[torch.arange(batch_size, device=logits.device), last_non_pad_token]\n+\n+        loss = None\n+        if labels is not None:\n+            if self.config.problem_type is None:\n+                if self.num_labels == 1:\n+                    self.config.problem_type = \"regression\"\n+                elif self.num_labels > 1 and (labels.dtype == torch.long or labels.dtype == torch.int):\n+                    self.config.problem_type = \"single_label_classification\"\n+                else:\n+                    self.config.problem_type = \"multi_label_classification\"\n+\n+            if self.config.problem_type == \"regression\":\n+                loss_fct = MSELoss()\n+                if self.num_labels == 1:\n+                    loss = loss_fct(pooled_logits.squeeze(), labels.squeeze())\n+                else:\n+                    loss = loss_fct(pooled_logits, labels)\n+            elif self.config.problem_type == \"single_label_classification\":\n+                loss_fct = CrossEntropyLoss()\n+                loss = loss_fct(pooled_logits.view(-1, self.num_labels), labels.view(-1))\n+            elif self.config.problem_type == \"multi_label_classification\":\n+                loss_fct = BCEWithLogitsLoss()\n+                loss = loss_fct(pooled_logits, labels)\n+\n+        return SequenceClassifierOutputWithPast(\n+            loss=loss,\n+            logits=pooled_logits,\n+            past_key_values=transformer_outputs.past_key_values,\n+            hidden_states=transformer_outputs.hidden_states,\n+            attentions=transformer_outputs.attentions,\n+        )\n+\n+\n+__all__ = [\n+    \"ModernBertDecoderModel\",\n+    \"ModernBertDecoderPreTrainedModel\",\n+    \"ModernBertDecoderForCausalLM\",\n+    \"ModernBertDecoderForSequenceClassification\",\n+]"
        },
        {
            "sha": "46a3674af00cb8627937a7611151019b43ca555e",
            "filename": "src/transformers/models/modernbert_decoder/modular_modernbert_decoder.py",
            "status": "added",
            "additions": 794,
            "deletions": 0,
            "changes": 794,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2Fmodernbert_decoder%2Fmodular_modernbert_decoder.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/src%2Ftransformers%2Fmodels%2Fmodernbert_decoder%2Fmodular_modernbert_decoder.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmodernbert_decoder%2Fmodular_modernbert_decoder.py?ref=0e4b7938d0e965362973797f47ad2b85f605a96a",
            "patch": "@@ -0,0 +1,794 @@\n+# Copyright 2025 Johns Hopkins University, LightOn, and the HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import math\n+from collections.abc import Callable\n+from typing import Optional, Union\n+\n+import torch\n+from torch import nn\n+from torch.nn import BCEWithLogitsLoss, CrossEntropyLoss, MSELoss\n+\n+from ...cache_utils import Cache, DynamicCache\n+from ...configuration_utils import PretrainedConfig\n+from ...generation import GenerationMixin\n+from ...masking_utils import create_causal_mask, create_sliding_window_causal_mask\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import BaseModelOutputWithPast, CausalLMOutputWithPast, SequenceClassifierOutputWithPast\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS\n+from ...models.modernbert.modeling_modernbert import (\n+    ModernBertEmbeddings,\n+    ModernBertMLP,\n+    ModernBertPredictionHead,\n+    ModernBertPreTrainedModel,\n+    ModernBertRotaryEmbedding,\n+    apply_rotary_pos_emb,\n+)\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring, can_return_tuple, logging\n+from ...utils.generic import check_model_inputs\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class ModernBertDecoderConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`ModernBertDecoderModel`]. It is used to instantiate a ModernBert\n+    decoder model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n+    defaults will yield a similar configuration to that of the ModernBERT-base decoder.\n+    e.g. [blab-jhu/test-32m-dec](https://huggingface.co/blab-jhu/test-32m-dec)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 50368):\n+            Vocabulary size of the ModernBert decoder model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`ModernBertDecoderModel`]\n+        hidden_size (`int`, *optional*, defaults to 768):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 1152):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 22):\n+            Number of hidden layers in the Transformer decoder.\n+        num_attention_heads (`int`, *optional*, defaults to 12):\n+            Number of attention heads for each attention layer in the Transformer decoder.\n+        hidden_activation (`str` or `function`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function (function or string) in the decoder. Will default to `\"gelu\"`\n+            if not specified.\n+        max_position_embeddings (`int`, *optional*, defaults to 8192):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        initializer_cutoff_factor (`float`, *optional*, defaults to 2.0):\n+            The cutoff factor for the truncated_normal_initializer for initializing all weight matrices.\n+        norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        norm_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use bias in the normalization layers.\n+        pad_token_id (`int`, *optional*, defaults to 50283):\n+            Padding token id.\n+        eos_token_id (`int`, *optional*, defaults to 50282):\n+            End of stream token id.\n+        bos_token_id (`int`, *optional*, defaults to 50281):\n+            Beginning of stream token id.\n+        cls_token_id (`int`, *optional*, defaults to 50281):\n+            Classification token id.\n+        sep_token_id (`int`, *optional*, defaults to 50282):\n+            Separation token id.\n+        global_rope_theta (`float`, *optional*, defaults to 160000.0):\n+            The base period of the global RoPE embeddings.\n+        attention_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        embedding_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the embeddings.\n+        mlp_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use bias in the MLP layers.\n+        mlp_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the MLP layers.\n+        decoder_bias (`bool`, *optional*, defaults to `True`):\n+            Whether to use bias in the decoder layers.\n+        classifier_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the classifier.\n+        classifier_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use bias in the classifier.\n+        classifier_activation (`str`, *optional*, defaults to `\"gelu\"`):\n+            The activation function for the classifier.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        local_attention (`int`, *optional*, defaults to 128):\n+            The sliding window size for local attention. Only used for layers that use local attention. Note that for\n+            the decoder to match ModernBERT this is actually half of the sliding window size, so 128 => 64.\n+        global_attn_every_n_layers (`int`, *optional*, defaults to 3):\n+            Every `global_attn_every_n_layers` layers will use global attention instead of local attention.\n+        local_rope_theta (`float`, *optional*, defaults to 160000.0):\n+            The base period of the local RoPE embeddings. If not specified, defaults to 160000.0\n+        layer_types (`list`, *optional*):\n+            List of layer types, one for each layer. If not specified, will be automatically generated based on\n+            `global_attn_every_n_layers`. Should contain \"full_attention\" or \"sliding_attention\".\n+\n+    Examples:\n+\n+    ```python\n+    >>> from transformers import ModernBertDecoderModel, ModernBertDecoderConfig\n+\n+    >>> # Initializing a ModernBert decoder style configuration\n+    >>> configuration = ModernBertDecoderConfig()\n+\n+    >>> # Initializing a model from the modernbert-base decoder style configuration\n+    >>> model = ModernBertDecoderModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"modernbert-decoder\"\n+    attribute_map = {\"rope_theta\": \"global_rope_theta\"}\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        vocab_size=50368,\n+        hidden_size=768,\n+        intermediate_size=1152,\n+        num_hidden_layers=22,\n+        num_attention_heads=12,\n+        hidden_activation=\"gelu\",\n+        max_position_embeddings=8192,\n+        initializer_range=0.02,\n+        initializer_cutoff_factor=2.0,\n+        norm_eps=1e-5,\n+        norm_bias=False,\n+        pad_token_id=50283,\n+        eos_token_id=50282,\n+        bos_token_id=50281,\n+        cls_token_id=50281,\n+        sep_token_id=50282,\n+        global_rope_theta=160000.0,\n+        attention_bias=False,\n+        attention_dropout=0.0,\n+        embedding_dropout=0.0,\n+        mlp_bias=False,\n+        mlp_dropout=0.0,\n+        decoder_bias=True,\n+        classifier_dropout=0.0,\n+        classifier_bias=False,\n+        classifier_activation=\"gelu\",\n+        use_cache=True,\n+        local_attention=128,\n+        global_attn_every_n_layers=3,\n+        local_rope_theta=160000.0,\n+        layer_types=None,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            cls_token_id=cls_token_id,\n+            sep_token_id=sep_token_id,\n+            **kwargs,\n+        )\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.initializer_range = initializer_range\n+        self.initializer_cutoff_factor = initializer_cutoff_factor\n+        self.norm_eps = norm_eps\n+        self.norm_bias = norm_bias\n+        self.global_rope_theta = global_rope_theta\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+        self.hidden_activation = hidden_activation\n+        self.embedding_dropout = embedding_dropout\n+        self.mlp_bias = mlp_bias\n+        self.mlp_dropout = mlp_dropout\n+        self.decoder_bias = decoder_bias\n+        self.classifier_dropout = classifier_dropout\n+        self.classifier_bias = classifier_bias\n+        self.classifier_activation = classifier_activation\n+        self.use_cache = use_cache\n+        self.global_attn_every_n_layers = global_attn_every_n_layers\n+        self.local_rope_theta = local_rope_theta\n+        # for consistency with ModernBert\n+        self.reference_compile = False\n+\n+        # Set up layer_types for standardized layer type detection\n+        self.layer_types = layer_types\n+        if self.layer_types is None:\n+            # Create layer_types based on the alternating pattern\n+            self.layer_types = []\n+            for layer_id in range(num_hidden_layers):\n+                if layer_id % global_attn_every_n_layers != 0:\n+                    self.layer_types.append(\"sliding_attention\")\n+                else:\n+                    self.layer_types.append(\"full_attention\")\n+\n+        # NOTE: sliding window numbers matches ModernBERT but is only half of it\n+        self.sliding_window = local_attention // 2 if local_attention else -1\n+\n+\n+def eager_attention_forward(\n+    module: \"ModernBertDecoderAttention\",\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    dropout: float = 0.0,\n+    scaling: Optional[float] = None,\n+    sliding_window: Optional[int] = None,\n+    **kwargs,\n+) -> tuple[torch.Tensor, Optional[torch.Tensor]]:\n+    \"\"\"A simple eager attention implementation for ModernBERT decoder.\"\"\"\n+    if scaling is None:\n+        scaling = module.head_dim**-0.5\n+\n+    # Compute attention scores\n+    attn_weights = torch.matmul(query, key.transpose(2, 3)) * scaling\n+\n+    # Use the pre-computed attention mask\n+    causal_mask = attention_mask[:, :, :, : key.shape[-2]]\n+    attn_weights = attn_weights + causal_mask\n+\n+    # upcast attention to fp32\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+    return attn_output, attn_weights\n+\n+\n+class ModernBertDecoderAttention(nn.Module):\n+    \"\"\"Performs causal multi-headed self attention for ModernBERT decoder.\n+\n+    It supports both local attention (sliding window) and global attention patterns.\n+    \"\"\"\n+\n+    def __init__(self, config: ModernBertDecoderConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+        self.is_sliding = config.layer_types[layer_idx] == \"sliding_attention\"\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.head_dim = config.hidden_size // config.num_attention_heads\n+        self.num_heads = config.num_attention_heads\n+        self.all_head_size = self.head_dim * self.num_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.attention_dropout = self.config.attention_dropout\n+        self.is_causal = True\n+\n+        if config.hidden_size % config.num_attention_heads != 0:\n+            raise ValueError(\n+                f\"The hidden size ({config.hidden_size}) is not a multiple of the number of attention heads ({config.num_attention_heads})\"\n+            )\n+\n+        # NOTE: this is different than ModernBERT (separated QKV) so be sure to adapt to this\n+        self.q_proj = nn.Linear(self.config.hidden_size, self.all_head_size, bias=self.config.attention_bias)\n+        self.k_proj = nn.Linear(self.config.hidden_size, self.all_head_size, bias=self.config.attention_bias)\n+        self.v_proj = nn.Linear(self.config.hidden_size, self.all_head_size, bias=self.config.attention_bias)\n+\n+        self.Wo = nn.Linear(config.hidden_size, config.hidden_size, bias=config.attention_bias)\n+        self.out_drop = nn.Dropout(config.attention_dropout)\n+\n+        self.sliding_window = config.sliding_window if config.layer_types[layer_idx] == \"sliding_attention\" else None\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=self.attention_dropout if self.training else 0.0,\n+            scaling=self.scaling,\n+            sliding_window=self.sliding_window,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.out_drop(self.Wo(attn_output))\n+        return attn_output, attn_weights\n+\n+\n+class ModernBertDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: ModernBertDecoderConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.attention_type = config.layer_types[layer_idx]\n+        self.attn_norm = (\n+            nn.LayerNorm(config.hidden_size, eps=config.norm_eps, bias=config.norm_bias)\n+            if layer_idx != 0\n+            else nn.Identity()\n+        )\n+        self.attn = ModernBertDecoderAttention(config=config, layer_idx=layer_idx)\n+        self.mlp_norm = nn.LayerNorm(config.hidden_size, eps=config.norm_eps, bias=config.norm_bias)\n+        self.mlp = ModernBertMLP(config)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings_global: torch.Tensor,\n+        position_embeddings_local: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> tuple[torch.FloatTensor, Optional[tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        residual = hidden_states\n+        hidden_states = self.attn_norm(hidden_states)\n+\n+        # apply global RoPE to non-sliding layer only\n+        if self.attn.is_sliding:\n+            position_embeddings = position_embeddings_local\n+        else:\n+            position_embeddings = position_embeddings_global\n+\n+        # Self Attention\n+        attn_outputs = self.attn(\n+            hidden_states=hidden_states,\n+            position_embeddings=position_embeddings,\n+            attention_mask=attention_mask,\n+            past_key_value=past_key_value,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = attn_outputs[0]\n+\n+        # Add residual connection\n+        hidden_states = residual + hidden_states\n+\n+        # MLP\n+        residual = hidden_states\n+        hidden_states = self.mlp_norm(hidden_states)\n+        mlp_output = self.mlp(hidden_states)\n+        hidden_states = residual + mlp_output\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class ModernBertDecoderPreTrainedModel(ModernBertPreTrainedModel):\n+    config_class = ModernBertDecoderConfig\n+    base_model_prefix = \"model\"\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _no_split_modules = [\"ModernBertDecoderLayer\"]\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = False\n+    _supports_gradient_checkpointing = True\n+    _supports_cache_class = True\n+    _supports_quantized_cache = True\n+    _supports_static_cache = False\n+    _supports_attention_backend = True\n+    _can_record_outputs = {\n+        \"hidden_states\": ModernBertDecoderLayer,\n+        \"attentions\": ModernBertDecoderAttention,\n+    }\n+\n+    def _init_weights(self, module: nn.Module):\n+        cutoff_factor = self.config.initializer_cutoff_factor\n+        if cutoff_factor is None:\n+            cutoff_factor = 3\n+\n+        def init_weight(module: nn.Module, std: float):\n+            nn.init.trunc_normal_(\n+                module.weight,\n+                mean=0.0,\n+                std=std,\n+                a=-cutoff_factor * std,\n+                b=cutoff_factor * std,\n+            )\n+\n+            if isinstance(module, nn.Linear):\n+                if module.bias is not None:\n+                    nn.init.zeros_(module.bias)\n+\n+        stds = {\n+            \"in\": self.config.initializer_range,\n+            \"out\": self.config.initializer_range / math.sqrt(2.0 * self.config.num_hidden_layers),\n+            \"embedding\": self.config.initializer_range,\n+            \"final_out\": self.config.hidden_size**-0.5,\n+        }\n+\n+        if isinstance(module, ModernBertEmbeddings):\n+            init_weight(module.tok_embeddings, stds[\"embedding\"])\n+        elif isinstance(module, ModernBertMLP):\n+            init_weight(module.Wi, stds[\"in\"])\n+            init_weight(module.Wo, stds[\"out\"])\n+        elif isinstance(module, ModernBertDecoderAttention):\n+            init_weight(module.q_proj, stds[\"in\"])\n+            init_weight(module.k_proj, stds[\"in\"])\n+            init_weight(module.v_proj, stds[\"in\"])\n+            init_weight(module.Wo, stds[\"out\"])\n+        elif isinstance(module, ModernBertPredictionHead):\n+            init_weight(module.dense, stds[\"out\"])\n+        elif isinstance(module, ModernBertDecoderForSequenceClassification):\n+            init_weight(module.classifier, stds[\"final_out\"])\n+        elif isinstance(module, ModernBertDecoderForCausalLM):\n+            init_weight(module.decoder, stds[\"out\"])\n+        elif isinstance(module, nn.LayerNorm):\n+            module.weight.data.fill_(1.0)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+\n+\n+@auto_docstring\n+class ModernBertDecoderModel(ModernBertDecoderPreTrainedModel):\n+    def __init__(self, config: ModernBertDecoderConfig):\n+        super().__init__(config)\n+        self.config = config\n+        self.embeddings = ModernBertEmbeddings(config)\n+        self.layers = nn.ModuleList(\n+            [ModernBertDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.final_norm = nn.LayerNorm(config.hidden_size, eps=config.norm_eps, bias=config.norm_bias)\n+        self.gradient_checkpointing = False\n+\n+        self.global_rotary_emb = ModernBertRotaryEmbedding(config=config)\n+        self.local_rotary_emb = ModernBertRotaryEmbedding(config=config)\n+\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.embeddings.tok_embeddings\n+\n+    def set_input_embeddings(self, value):\n+        self.embeddings.tok_embeddings = value\n+\n+    @check_model_inputs\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> Union[tuple[torch.Tensor, ...], BaseModelOutputWithPast]:\n+        if (input_ids is None) == (inputs_embeds is None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if input_ids is not None:\n+            self.warn_if_padding_and_no_attention_mask(input_ids, attention_mask)\n+            batch_size, seq_length = input_ids.shape[:2]\n+        else:\n+            batch_size, seq_length = inputs_embeds.shape[:2]\n+\n+        # Handle past_key_values and cache setup\n+        if use_cache and past_key_values is None and not self.training:\n+            past_key_values = DynamicCache()\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens,\n+                past_seen_tokens + seq_length,\n+                device=input_ids.device if input_ids is not None else inputs_embeds.device,\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0).expand(batch_size, -1)\n+\n+        # Calculate embeddings\n+        hidden_states = self.embeddings(input_ids=input_ids, inputs_embeds=inputs_embeds)\n+\n+        # It may already have been prepared by e.g. `generate`\n+        if not isinstance(causal_mask_mapping := attention_mask, dict):\n+            # Prepare mask arguments\n+            mask_kwargs = {\n+                \"config\": self.config,\n+                \"input_embeds\": hidden_states,\n+                \"attention_mask\": attention_mask,\n+                \"cache_position\": cache_position,\n+                \"past_key_values\": past_key_values,\n+                \"position_ids\": position_ids,\n+            }\n+\n+            causal_mask_mapping = {\n+                \"full_attention\": create_causal_mask(**mask_kwargs),\n+                \"sliding_attention\": create_sliding_window_causal_mask(**mask_kwargs),\n+            }\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings_global = self.global_rotary_emb(hidden_states, position_ids)\n+        position_embeddings_local = self.local_rotary_emb(hidden_states, position_ids)\n+\n+        for idx, decoder_layer in enumerate(self.layers):\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                position_embeddings_global=position_embeddings_global,\n+                position_embeddings_local=position_embeddings_local,\n+                attention_mask=causal_mask_mapping[decoder_layer.attention_type],\n+                past_key_value=past_key_values,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+\n+        hidden_states = self.final_norm(hidden_states)\n+\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    The ModernBert Decoder Model with a language modeling head on top for causal language modeling (CLM).\n+    \"\"\"\n+)\n+class ModernBertDecoderForCausalLM(ModernBertDecoderPreTrainedModel, GenerationMixin):\n+    _tied_weights_keys = [\"decoder.weight\"]\n+\n+    def __init__(self, config: ModernBertDecoderConfig):\n+        super().__init__(config)\n+        self.config = config\n+        self.model = ModernBertDecoderModel(config)\n+        self.lm_head = ModernBertPredictionHead(config)\n+        self.decoder = nn.Linear(config.hidden_size, config.vocab_size, bias=config.decoder_bias)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_output_embeddings(self):\n+        return self.decoder\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.decoder = new_embeddings\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        **kwargs,\n+    ) -> Union[tuple, CausalLMOutputWithPast]:\n+        r\"\"\"\n+        Args:\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+        Returns:\n+            [`~modeling_outputs.CausalLMOutputWithPast`]\n+            comprising various elements depending on the configuration and inputs.\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, ModernBertDecoderForCausalLM\n+\n+        >>> model = ModernBertDecoderForCausalLM.from_pretrained(\"blab-jhu/test-32m-dec\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"blab-jhu/test-32m-dec\")\n+\n+        >>> prompt = \"The capital of France is\"\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=1)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"The capital of France is Paris\"\n+        ```\n+        \"\"\"\n+        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs[0]\n+        logits = self.decoder(self.lm_head(hidden_states))\n+\n+        loss = None\n+        if labels is not None:\n+            # Shift so that tokens < n predict n\n+            shift_logits = logits[..., :-1, :].contiguous()\n+            shift_labels = labels[..., 1:].contiguous()\n+            # Flatten the tokens\n+            loss_fct = CrossEntropyLoss()\n+            shift_logits = shift_logits.view(-1, self.config.vocab_size)\n+            shift_labels = shift_labels.view(-1)\n+            # Enable model parallelism\n+            shift_labels = shift_labels.to(shift_logits.device)\n+            loss = loss_fct(shift_logits, shift_labels)\n+\n+        return CausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+    @staticmethod\n+    def _reorder_cache(past_key_values, beam_idx):\n+        reordered_past = ()\n+        for layer_past in past_key_values:\n+            reordered_past += (\n+                tuple(past_state.index_select(0, beam_idx.to(past_state.device)) for past_state in layer_past),\n+            )\n+        return reordered_past\n+\n+\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    The ModernBert Decoder Model with a sequence classification head on top (linear layer).\n+\n+    [`ModernBertDecoderForSequenceClassification`] uses the last token in order to do the classification, as other causal models\n+    (e.g. GPT-1, GPT-2) do.\n+\n+    Since it does classification on the last token, it requires to know the position of the last token. If a\n+    `pad_token_id` is defined in the configuration, it finds the last token that is not a padding token in each row. If\n+    no `pad_token_id` is defined, it simply takes the last value in each row of the batch. Since it cannot guess the\n+    padding tokens when `inputs_embeds` are passed instead of `input_ids`, it does the same (take the last value in\n+    each row of the batch).\n+    \"\"\"\n+)\n+class ModernBertDecoderForSequenceClassification(ModernBertDecoderPreTrainedModel):\n+    def __init__(self, config: ModernBertDecoderConfig):\n+        super().__init__(config)\n+        self.num_labels = config.num_labels\n+        self.model = ModernBertDecoderModel(config)\n+\n+        self.head = ModernBertPredictionHead(config)\n+        self.classifier = nn.Linear(config.hidden_size, config.num_labels, bias=config.classifier_bias)\n+        self.drop = torch.nn.Dropout(config.classifier_dropout)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @can_return_tuple\n+    @auto_docstring(checkpoint=\"blab-jhu/test-32m-dec\")\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        **kwargs,\n+    ) -> Union[tuple, SequenceClassifierOutputWithPast]:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n+            Labels for computing the sequence classification/regression loss. Indices should be in `[0, ...,\n+            config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If\n+            `config.num_labels > 1` a classification loss is computed (Cross-Entropy).\n+        \"\"\"\n+        transformer_outputs = self.model(\n+            input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            **kwargs,\n+        )\n+        hidden_states = transformer_outputs[0]\n+        hidden_states = self.drop(self.head(hidden_states))\n+        logits = self.classifier(hidden_states)\n+\n+        if input_ids is not None:\n+            batch_size, sequence_length = input_ids.shape[:2]\n+        else:\n+            batch_size, sequence_length = inputs_embeds.shape[:2]\n+\n+        if self.config.pad_token_id is None and batch_size != 1:\n+            raise ValueError(\"Cannot handle batch sizes > 1 if no padding token is defined.\")\n+        if self.config.pad_token_id is None:\n+            last_non_pad_token = -1\n+        elif input_ids is not None:\n+            # To handle both left- and right- padding, we take the rightmost token that is not equal to pad_token_id\n+            non_pad_mask = (input_ids != self.config.pad_token_id).to(logits.device, torch.int32)\n+            token_indices = torch.arange(input_ids.shape[-1], device=logits.device, dtype=torch.int32)\n+            last_non_pad_token = (token_indices * non_pad_mask).argmax(-1)\n+        else:\n+            last_non_pad_token = -1\n+            logger.warning_once(\n+                f\"{self.__class__.__name__} will not detect padding tokens in `inputs_embeds`. Results may be \"\n+                \"unexpected if using padding tokens in conjunction with `inputs_embeds.`\"\n+            )\n+\n+        pooled_logits = logits[torch.arange(batch_size, device=logits.device), last_non_pad_token]\n+\n+        loss = None\n+        if labels is not None:\n+            if self.config.problem_type is None:\n+                if self.num_labels == 1:\n+                    self.config.problem_type = \"regression\"\n+                elif self.num_labels > 1 and (labels.dtype == torch.long or labels.dtype == torch.int):\n+                    self.config.problem_type = \"single_label_classification\"\n+                else:\n+                    self.config.problem_type = \"multi_label_classification\"\n+\n+            if self.config.problem_type == \"regression\":\n+                loss_fct = MSELoss()\n+                if self.num_labels == 1:\n+                    loss = loss_fct(pooled_logits.squeeze(), labels.squeeze())\n+                else:\n+                    loss = loss_fct(pooled_logits, labels)\n+            elif self.config.problem_type == \"single_label_classification\":\n+                loss_fct = CrossEntropyLoss()\n+                loss = loss_fct(pooled_logits.view(-1, self.num_labels), labels.view(-1))\n+            elif self.config.problem_type == \"multi_label_classification\":\n+                loss_fct = BCEWithLogitsLoss()\n+                loss = loss_fct(pooled_logits, labels)\n+\n+        return SequenceClassifierOutputWithPast(\n+            loss=loss,\n+            logits=pooled_logits,\n+            past_key_values=transformer_outputs.past_key_values,\n+            hidden_states=transformer_outputs.hidden_states,\n+            attentions=transformer_outputs.attentions,\n+        )\n+\n+\n+__all__ = [\n+    \"ModernBertDecoderConfig\",\n+    \"ModernBertDecoderModel\",\n+    \"ModernBertDecoderPreTrainedModel\",\n+    \"ModernBertDecoderForCausalLM\",\n+    \"ModernBertDecoderForSequenceClassification\",\n+]"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/modernbert_decoder/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/tests%2Fmodels%2Fmodernbert_decoder%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/tests%2Fmodels%2Fmodernbert_decoder%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmodernbert_decoder%2F__init__.py?ref=0e4b7938d0e965362973797f47ad2b85f605a96a"
        },
        {
            "sha": "8483d224a6ce75e585b10914da5b1ff533ca8a1d",
            "filename": "tests/models/modernbert_decoder/test_modeling_modernbert_decoder.py",
            "status": "added",
            "additions": 197,
            "deletions": 0,
            "changes": 197,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/tests%2Fmodels%2Fmodernbert_decoder%2Ftest_modeling_modernbert_decoder.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/tests%2Fmodels%2Fmodernbert_decoder%2Ftest_modeling_modernbert_decoder.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmodernbert_decoder%2Ftest_modeling_modernbert_decoder.py?ref=0e4b7938d0e965362973797f47ad2b85f605a96a",
            "patch": "@@ -0,0 +1,197 @@\n+# Copyright 2020 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import unittest\n+\n+from packaging import version\n+\n+from transformers import AutoTokenizer, ModernBertDecoderConfig, is_torch_available\n+from transformers.testing_utils import (\n+    require_torch,\n+    slow,\n+)\n+\n+from ...causal_lm_tester import CausalLMModelTest, CausalLMModelTester\n+from ...test_modeling_common import _config_zero_init\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import (\n+        ModernBertDecoderForCausalLM,\n+        ModernBertDecoderForSequenceClassification,\n+        ModernBertDecoderModel,\n+    )\n+\n+\n+class ModernBertDecoderModelTester(CausalLMModelTester):\n+    config_class = ModernBertDecoderConfig\n+    if is_torch_available():\n+        base_model_class = ModernBertDecoderModel\n+        causal_lm_class = ModernBertDecoderForCausalLM\n+\n+\n+@require_torch\n+class ModernBertDecoderModelTest(CausalLMModelTest, unittest.TestCase):\n+    all_model_classes = (\n+        (ModernBertDecoderModel, ModernBertDecoderForCausalLM, ModernBertDecoderForSequenceClassification)\n+        if is_torch_available()\n+        else ()\n+    )\n+    pipeline_model_mapping = (\n+        {\n+            \"feature-extraction\": ModernBertDecoderModel,\n+            \"text-generation\": ModernBertDecoderForCausalLM,\n+            \"text-classification\": ModernBertDecoderForSequenceClassification,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+\n+    test_head_masking = False\n+    test_pruning = False\n+    model_tester_class = ModernBertDecoderModelTester\n+\n+    def test_initialization(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        configs_no_init = _config_zero_init(config)\n+        for model_class in self.all_model_classes:\n+            model = model_class(config=configs_no_init)\n+            for name, param in model.named_parameters():\n+                # The classifier.weight from ModernBertDecoderForSequenceClassification\n+                # is initialized without `initializer_range`, so it's not set to ~0 via the _config_zero_init\n+                if param.requires_grad and not (\n+                    name == \"classifier.weight\" and model_class in [ModernBertDecoderForSequenceClassification]\n+                ):\n+                    data = torch.flatten(param.data)\n+                    n_elements = torch.numel(data)\n+                    # skip 2.5% of elements on each side to avoid issues caused by `nn.init.trunc_normal_` described in\n+                    # https://github.com/huggingface/transformers/pull/27906#issuecomment-1846951332\n+                    n_elements_to_skip_on_each_side = int(n_elements * 0.025)\n+                    data_to_check = torch.sort(data).values\n+                    if n_elements_to_skip_on_each_side > 0:\n+                        data_to_check = data_to_check[n_elements_to_skip_on_each_side:-n_elements_to_skip_on_each_side]\n+                    self.assertIn(\n+                        ((data_to_check.mean() * 1e9).round() / 1e9).item(),\n+                        [0.0, 1.0],\n+                        msg=f\"Parameter {name} of model {model_class} seems not properly initialized\",\n+                    )\n+\n+\n+@slow\n+@require_torch\n+class ModernBertDecoderIntegrationTest(unittest.TestCase):\n+    def test_inference_causal_lm(self):\n+        if version.parse(torch.__version__) < version.parse(\"2.4.0\"):\n+            self.skipTest(reason=\"This test requires torch >= 2.4 to run.\")\n+\n+        model = ModernBertDecoderForCausalLM.from_pretrained(\"blab-jhu/test-32m-dec\", attn_implementation=\"eager\")\n+        tokenizer = AutoTokenizer.from_pretrained(\"blab-jhu/test-32m-dec\")\n+\n+        inputs = tokenizer(\"Paris is the capital of\", return_tensors=\"pt\")\n+        with torch.no_grad():\n+            output = model(**inputs)[0]\n+        expected_shape = torch.Size((1, 6, model.config.vocab_size))\n+        self.assertEqual(output.shape, expected_shape)\n+\n+        # compare the actual values for a slice.\n+        expected_slice = torch.tensor(\n+            [[[-8.0183, -7.1578, -0.4453], [-6.2909, -6.1557, 4.9063], [-6.7689, -5.8068, 6.1078]]]\n+        )\n+        torch.testing.assert_close(output[:, :3, :3], expected_slice, rtol=1e-4, atol=1e-4)\n+\n+    def test_inference_no_head(self):\n+        if version.parse(torch.__version__) < version.parse(\"2.4.0\"):\n+            self.skipTest(reason=\"This test requires torch >= 2.4 to run.\")\n+\n+        model = ModernBertDecoderModel.from_pretrained(\"blab-jhu/test-32m-dec\", attn_implementation=\"eager\")\n+        tokenizer = AutoTokenizer.from_pretrained(\"blab-jhu/test-32m-dec\")\n+\n+        inputs = tokenizer(\"Paris is the capital of\", return_tensors=\"pt\")\n+        with torch.no_grad():\n+            output = model(**inputs)[0]\n+        expected_shape = torch.Size((1, 6, model.config.hidden_size))\n+        self.assertEqual(output.shape, expected_shape)\n+\n+        # compare the actual values for a slice.\n+        expected_slice = torch.tensor(\n+            [[[-0.0306, -0.0115, 0.0007], [-0.2485, -0.1381, 0.0872], [0.3133, -0.1777, 0.1667]]]\n+        )\n+        torch.testing.assert_close(output[:, :3, :3], expected_slice, rtol=1e-4, atol=1e-4)\n+\n+    def test_generation(self):\n+        if version.parse(torch.__version__) < version.parse(\"2.4.0\"):\n+            self.skipTest(reason=\"This test requires torch >= 2.4 to run.\")\n+\n+        model = ModernBertDecoderForCausalLM.from_pretrained(\"blab-jhu/test-32m-dec\", attn_implementation=\"eager\")\n+        tokenizer = AutoTokenizer.from_pretrained(\"blab-jhu/test-32m-dec\")\n+\n+        inputs = tokenizer(\"The weather today is\", return_tensors=\"pt\")\n+        outputs = model.generate(**inputs, max_new_tokens=10, do_sample=False)\n+        output_text = tokenizer.batch_decode(outputs, skip_special_tokens=True)\n+\n+        # Check that we got some reasonable output\n+        self.assertEqual(len(output_text), 1)\n+        self.assertTrue(len(output_text[0]) > len(\"The weather today is\"))\n+\n+    def test_sliding_window_long_context(self):\n+        \"\"\"\n+        Test that ModernBertDecoder works with sliding window attention for longer sequences.\n+        \"\"\"\n+        if version.parse(torch.__version__) < version.parse(\"2.4.0\"):\n+            self.skipTest(reason=\"This test requires torch >= 2.4 to run.\")\n+\n+        model = ModernBertDecoderForCausalLM.from_pretrained(\"blab-jhu/test-32m-dec\", attn_implementation=\"eager\")\n+        tokenizer = AutoTokenizer.from_pretrained(\"blab-jhu/test-32m-dec\")\n+\n+        # Create a longer input to test sliding window attention\n+        long_input = \"This is a test. \" * 50  # Repeat to make it longer\n+        inputs = tokenizer(long_input, return_tensors=\"pt\", truncation=True, max_length=512)\n+\n+        outputs = model.generate(**inputs, max_new_tokens=20, do_sample=False)\n+\n+        # Check that generation worked with longer context\n+        self.assertEqual(outputs.shape[0], 1)\n+        self.assertGreater(outputs.shape[1], inputs[\"input_ids\"].shape[1])\n+\n+    def test_sequence_classification(self):\n+        \"\"\"\n+        Test that ModernBertDecoderForSequenceClassification works correctly.\n+        \"\"\"\n+        if version.parse(torch.__version__) < version.parse(\"2.4.0\"):\n+            self.skipTest(reason=\"This test requires torch >= 2.4 to run.\")\n+\n+        model = ModernBertDecoderForSequenceClassification.from_pretrained(\n+            \"blab-jhu/test-32m-dec\", num_labels=2, attn_implementation=\"eager\"\n+        )\n+        tokenizer = AutoTokenizer.from_pretrained(\"blab-jhu/test-32m-dec\")\n+\n+        # Test with sample input\n+        inputs = tokenizer(\"This is a positive example.\", return_tensors=\"pt\")\n+\n+        with torch.no_grad():\n+            outputs = model(**inputs)\n+\n+        # Check output shape\n+        expected_shape = (1, 2)  # batch_size=1, num_labels=2\n+        self.assertEqual(outputs.logits.shape, expected_shape)\n+\n+        # Test with labels\n+        labels = torch.tensor([1])\n+        outputs_with_loss = model(**inputs, labels=labels)\n+\n+        # Check that loss is computed\n+        self.assertIsNotNone(outputs_with_loss.loss)\n+        self.assertTrue(isinstance(outputs_with_loss.loss.item(), float))"
        },
        {
            "sha": "5c8d0d88d4bb272590aa2d6cc2a576103cb0db70",
            "filename": "tests/test_modeling_common.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/tests%2Ftest_modeling_common.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/tests%2Ftest_modeling_common.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Ftest_modeling_common.py?ref=0e4b7938d0e965362973797f47ad2b85f605a96a",
            "patch": "@@ -3323,6 +3323,8 @@ def test_mismatched_shapes_have_properly_initialized_weights(self):\n                 \"ModernBertForTokenClassification\",\n                 \"TimmWrapperForImageClassification\",\n                 \"ModernBertForQuestionAnswering\",\n+                \"ModernBertDecoderForSequenceClassification\",\n+                \"ModernBertDecoderForCausalLM\",\n             ]\n             special_param_names = [\n                 r\"^bit\\.\","
        },
        {
            "sha": "2307b962044f4e5e9545005145bf497ed1a5bdbd",
            "filename": "utils/check_config_attributes.py",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e4b7938d0e965362973797f47ad2b85f605a96a/utils%2Fcheck_config_attributes.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e4b7938d0e965362973797f47ad2b85f605a96a/utils%2Fcheck_config_attributes.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_config_attributes.py?ref=0e4b7938d0e965362973797f47ad2b85f605a96a",
            "patch": "@@ -277,6 +277,19 @@\n         \"attention_chunk_size\",\n     ],\n     \"Llama4VisionConfig\": [\"multi_modal_projector_bias\", \"norm_eps\"],\n+    \"ModernBertDecoderConfig\": [\n+        \"embedding_dropout\",\n+        \"hidden_activation\",\n+        \"initializer_cutoff_factor\",\n+        \"intermediate_size\",\n+        \"max_position_embeddings\",\n+        \"mlp_bias\",\n+        \"mlp_dropout\",\n+        \"classifier_activation\",\n+        \"global_attn_every_n_layers\",\n+        \"local_attention\",\n+        \"local_rope_theta\",\n+    ],\n     # position_embedding_type not used and deprecated. Should be deleted in v4.55\n     \"LayoutLMConfig\": [\"position_embedding_type\"],\n     \"MarkupLMConfig\": [\"position_embedding_type\"],"
        }
    ],
    "stats": {
        "total": 2020,
        "additions": 2020,
        "deletions": 0
    }
}