{
    "author": "ylacombe",
    "message": "Codec integration (#33565)\n\n* clean mimi commit\r\n\r\n* some nits suggestions from Arthur\r\n\r\n* make fixup\r\n\r\n* rename repo id + change readme\r\n\r\n* Update docs/source/en/model_doc/mimi.md\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* add flaky flag to batching equivalence due to audio_codes failing sometimes\r\n\r\n---------\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>",
    "sha": "5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
    "files": [
        {
            "sha": "59f0ff48d22a75dc59e9f95e3f45168ad5f9fa0c",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -722,6 +722,8 @@\n         title: Hubert\n       - local: model_doc/mctct\n         title: MCTCT\n+      - local: model_doc/mimi\n+        title: Mimi\n       - local: model_doc/mms\n         title: MMS\n       - local: model_doc/musicgen"
        },
        {
            "sha": "cc5d7990929aa42a5b2dadab25b5e2b00a3e0c6f",
            "filename": "docs/source/en/index.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/docs%2Fsource%2Fen%2Findex.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/docs%2Fsource%2Fen%2Findex.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Findex.md?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -210,6 +210,7 @@ Flax), PyTorch, and/or TensorFlow.\n |                 [Megatron-BERT](model_doc/megatron-bert)                 |       ‚úÖ        |         ‚ùå         |      ‚ùå      |\n |                 [Megatron-GPT2](model_doc/megatron_gpt2)                 |       ‚úÖ        |         ‚úÖ         |      ‚úÖ      |\n |                       [MGP-STR](model_doc/mgp-str)                       |       ‚úÖ        |         ‚ùå         |      ‚ùå      |\n+|                          [Mimi](model_doc/mimi)                          |       ‚úÖ        |         ‚ùå         |      ‚ùå      |\n |                       [Mistral](model_doc/mistral)                       |       ‚úÖ        |         ‚úÖ         |      ‚úÖ      |\n |                       [Mixtral](model_doc/mixtral)                       |       ‚úÖ        |         ‚ùå         |      ‚ùå      |\n |                         [mLUKE](model_doc/mluke)                         |       ‚úÖ        |         ‚ùå         |      ‚ùå      |"
        },
        {
            "sha": "486d18363349498d9ac7153f726ba9c6c8e4306e",
            "filename": "docs/source/en/model_doc/mimi.md",
            "status": "added",
            "additions": 69,
            "deletions": 0,
            "changes": 69,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/docs%2Fsource%2Fen%2Fmodel_doc%2Fmimi.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/docs%2Fsource%2Fen%2Fmodel_doc%2Fmimi.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fmimi.md?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -0,0 +1,69 @@\n+<!--Copyright 2024 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+‚ö†Ô∏è Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# Mimi\n+\n+## Overview\n+\n+The Mimi model was proposed in [Moshi: a speech-text foundation model for real-time dialogue](https://kyutai.org/Moshi.pdf) by Alexandre D√©fossez, Laurent Mazar√©, Manu Orsini, Am√©lie Royer, Patrick P√©rez, Herv√© J√©gou, Edouard Grave and Neil Zeghidour. Mimi is a high-fidelity audio codec model developed by the Kyutai team, that combines semantic and acoustic information into audio tokens running at 12Hz and a bitrate of 1.1kbps. In other words, it can be used to map audio waveforms into ‚Äúaudio tokens‚Äù, known as ‚Äúcodebooks‚Äù.\n+\n+The abstract from the paper is the following:\n+\n+*We introduce Moshi, a speech-text foundation model and full-duplex spoken dialogue framework. Current systems for spoken dialogue rely on pipelines of independent components, namely voice activity detection, speech recognition, textual dialogue and text-to-speech. Such frameworks cannot emulate the experience of real conversations. First, their complexity induces a latency of several seconds between interactions. Second, text being the intermediate modality for dialogue, non-linguistic information that modifies meaning‚Äî such as emotion or non-speech sounds‚Äî is lost in the interaction. Finally, they rely on a segmentation into speaker turns, which does not take into account overlapping speech, interruptions and interjections. Moshi solves these independent issues altogether by casting spoken dialogue as speech-to-speech generation. Starting from a text language model backbone, Moshi generates speech as tokens from the residual quantizer of a neural audio codec, while modeling separately its own speech and that of the user into parallel streams. This allows for the removal of explicit speaker turns, and the modeling of arbitrary conversational dynamics. We moreover extend the hierarchical semantic-to-acoustic token generation of previous work to first predict time-aligned text tokens as a prefix to audio tokens. Not only this ‚ÄúInner Monologue‚Äù method significantly improves the linguistic quality of generated speech, but we also illustrate how it can provide streaming speech recognition and text-to-speech. Our resulting model is the first real-time full-duplex spoken large language model, with a theoretical latency of 160ms, 200ms in practice, and is available at github.com/kyutai-labs/moshi.* \n+\n+Its architecture is based on [Encodec](model_doc/encodec) with several major differences:\n+* it uses a much lower frame-rate.\n+* it uses additional transformers for encoding and decoding for better latent contextualization\n+* it uses a different quantization scheme: one codebook is dedicated to semantic projection.\n+\n+## Usage example \n+\n+Here is a quick example of how to encode and decode an audio using this model:\n+\n+```python \n+>>> from datasets import load_dataset, Audio\n+>>> from transformers import MimiModel, AutoFeatureExtractor\n+>>> librispeech_dummy = load_dataset(\"hf-internal-testing/librispeech_asr_dummy\", \"clean\", split=\"validation\")\n+\n+>>> # load model and feature extractor\n+>>> model = MimiModel.from_pretrained(\"kyutai/mimi\")\n+>>> feature_extractor = AutoFeatureExtractor.from_pretrained(\"kyutai/mimi\")\n+\n+>>> # load audio sample\n+>>> librispeech_dummy = librispeech_dummy.cast_column(\"audio\", Audio(sampling_rate=feature_extractor.sampling_rate))\n+>>> audio_sample = librispeech_dummy[-1][\"audio\"][\"array\"]\n+>>> inputs = feature_extractor(raw_audio=audio_sample, sampling_rate=feature_extractor.sampling_rate, return_tensors=\"pt\")\n+\n+>>> encoder_outputs = model.encode(inputs[\"input_values\"], inputs[\"padding_mask\"])\n+>>> audio_values = model.decode(encoder_outputs.audio_codes, inputs[\"padding_mask\"])[0]\n+>>> # or the equivalent with a forward pass\n+>>> audio_values = model(inputs[\"input_values\"], inputs[\"padding_mask\"]).audio_values\n+```\n+\n+This model was contributed by [Yoach Lacombe (ylacombe)](https://huggingface.co/ylacombe).\n+The original code can be found [here](https://github.com/kyutai-labs/moshi).\n+\n+\n+## MimiConfig\n+\n+[[autodoc]] MimiConfig\n+\n+## MimiModel\n+\n+[[autodoc]] MimiModel\n+    - decode\n+    - encode\n+    - forward"
        },
        {
            "sha": "4c220dd0f1483c213068421efa4c69cd77b552ad",
            "filename": "docs/source/en/perf_infer_gpu_one.md",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -61,6 +61,7 @@ FlashAttention-2 is currently supported for the following architectures:\n * [Llava-NeXT](https://huggingface.co/docs/transformers/model_doc/llava_next)\n * [Llava-NeXT-Video](https://huggingface.co/docs/transformers/model_doc/llava_next_video)\n * [LLaVA-Onevision](https://huggingface.co/docs/transformers/model_doc/llava_onevision)\n+* [Mimi](https://huggingface.co/docs/transformers/model_doc/mimi)\n * [VipLlava](https://huggingface.co/docs/transformers/model_doc/vipllava)\n * [VideoLlava](https://huggingface.co/docs/transformers/model_doc/video_llava)\n * [M2M100](https://huggingface.co/docs/transformers/model_doc/m2m_100)\n@@ -228,6 +229,7 @@ For now, Transformers supports SDPA inference and training for the following arc\n * [Jamba](https://huggingface.co/docs/transformers/model_doc/jamba#transformers.JambaModel)\n * [Llama](https://huggingface.co/docs/transformers/model_doc/llama#transformers.LlamaModel)\n * [LLaVA-Onevision](https://huggingface.co/docs/transformers/model_doc/llava_onevision)\n+* [Mimi](https://huggingface.co/docs/transformers/model_doc/mimi)\n * [Mistral](https://huggingface.co/docs/transformers/model_doc/mistral#transformers.MistralModel)\n * [Mixtral](https://huggingface.co/docs/transformers/model_doc/mixtral#transformers.MixtralModel)\n * [Musicgen](https://huggingface.co/docs/transformers/model_doc/musicgen#transformers.MusicgenModel)"
        },
        {
            "sha": "aa13a97fe461507fc35273256eb20a7fd6c17618",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -573,6 +573,7 @@\n         \"MgpstrProcessor\",\n         \"MgpstrTokenizer\",\n     ],\n+    \"models.mimi\": [\"MimiConfig\"],\n     \"models.mistral\": [\"MistralConfig\"],\n     \"models.mixtral\": [\"MixtralConfig\"],\n     \"models.mluke\": [],\n@@ -2666,6 +2667,12 @@\n             \"MgpstrPreTrainedModel\",\n         ]\n     )\n+    _import_structure[\"models.mimi\"].extend(\n+        [\n+            \"MimiModel\",\n+            \"MimiPreTrainedModel\",\n+        ]\n+    )\n     _import_structure[\"models.mistral\"].extend(\n         [\n             \"MistralForCausalLM\",\n@@ -5345,6 +5352,9 @@\n         MgpstrProcessor,\n         MgpstrTokenizer,\n     )\n+    from .models.mimi import (\n+        MimiConfig,\n+    )\n     from .models.mistral import MistralConfig\n     from .models.mixtral import MixtralConfig\n     from .models.mobilebert import (\n@@ -7212,6 +7222,10 @@\n             MgpstrModel,\n             MgpstrPreTrainedModel,\n         )\n+        from .models.mimi import (\n+            MimiModel,\n+            MimiPreTrainedModel,\n+        )\n         from .models.mistral import (\n             MistralForCausalLM,\n             MistralForSequenceClassification,"
        },
        {
            "sha": "5b5d1e7902bd6781301e14594c0d5221de8d6d78",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -149,6 +149,7 @@\n     megatron_bert,\n     megatron_gpt2,\n     mgp_str,\n+    mimi,\n     mistral,\n     mixtral,\n     mluke,"
        },
        {
            "sha": "5a6ec14e78cd4396dd2f2fffb83723a5cedac8b8",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -167,6 +167,7 @@\n         (\"mega\", \"MegaConfig\"),\n         (\"megatron-bert\", \"MegatronBertConfig\"),\n         (\"mgp-str\", \"MgpstrConfig\"),\n+        (\"mimi\", \"MimiConfig\"),\n         (\"mistral\", \"MistralConfig\"),\n         (\"mixtral\", \"MixtralConfig\"),\n         (\"mobilebert\", \"MobileBertConfig\"),\n@@ -468,6 +469,7 @@\n         (\"megatron-bert\", \"Megatron-BERT\"),\n         (\"megatron_gpt2\", \"Megatron-GPT2\"),\n         (\"mgp-str\", \"MGP-STR\"),\n+        (\"mimi\", \"Mimi\"),\n         (\"mistral\", \"Mistral\"),\n         (\"mixtral\", \"Mixtral\"),\n         (\"mluke\", \"mLUKE\"),"
        },
        {
            "sha": "dca0c08aa9095787632001b90712ee7735993572",
            "filename": "src/transformers/models/auto/feature_extraction_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fauto%2Ffeature_extraction_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fauto%2Ffeature_extraction_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ffeature_extraction_auto.py?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -69,6 +69,7 @@\n         (\"levit\", \"LevitFeatureExtractor\"),\n         (\"maskformer\", \"MaskFormerFeatureExtractor\"),\n         (\"mctct\", \"MCTCTFeatureExtractor\"),\n+        (\"mimi\", \"EncodecFeatureExtractor\"),\n         (\"mobilenet_v1\", \"MobileNetV1FeatureExtractor\"),\n         (\"mobilenet_v2\", \"MobileNetV2FeatureExtractor\"),\n         (\"mobilevit\", \"MobileViTFeatureExtractor\"),"
        },
        {
            "sha": "2bc71f07970aeec23bf5cef8c9aabab5b55e79fe",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -158,6 +158,7 @@\n         (\"mega\", \"MegaModel\"),\n         (\"megatron-bert\", \"MegatronBertModel\"),\n         (\"mgp-str\", \"MgpstrForSceneTextRecognition\"),\n+        (\"mimi\", \"MimiModel\"),\n         (\"mistral\", \"MistralModel\"),\n         (\"mixtral\", \"MixtralModel\"),\n         (\"mobilebert\", \"MobileBertModel\"),"
        },
        {
            "sha": "43b2bec6caa5b3ba65075b0f271cfe8bff66b954",
            "filename": "src/transformers/models/mimi/__init__.py",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fmimi%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fmimi%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmimi%2F__init__.py?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -0,0 +1,57 @@\n+# Copyright 2024 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import (\n+    OptionalDependencyNotAvailable,\n+    _LazyModule,\n+    is_torch_available,\n+)\n+\n+\n+_import_structure = {\n+    \"configuration_mimi\": [\"MimiConfig\"],\n+}\n+\n+try:\n+    if not is_torch_available():\n+        raise OptionalDependencyNotAvailable()\n+except OptionalDependencyNotAvailable:\n+    pass\n+else:\n+    _import_structure[\"modeling_mimi\"] = [\n+        \"MimiModel\",\n+        \"MimiPreTrainedModel\",\n+    ]\n+\n+if TYPE_CHECKING:\n+    from .configuration_mimi import (\n+        MimiConfig,\n+    )\n+\n+    try:\n+        if not is_torch_available():\n+            raise OptionalDependencyNotAvailable()\n+    except OptionalDependencyNotAvailable:\n+        pass\n+    else:\n+        from .modeling_mimi import (\n+            MimiModel,\n+            MimiPreTrainedModel,\n+        )\n+\n+else:\n+    import sys\n+\n+    sys.modules[__name__] = _LazyModule(__name__, globals()[\"__file__\"], _import_structure, module_spec=__spec__)"
        },
        {
            "sha": "5564b1a54ba63b83c90138611771c8be32c3f49e",
            "filename": "src/transformers/models/mimi/configuration_mimi.py",
            "status": "added",
            "additions": 234,
            "deletions": 0,
            "changes": 234,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fmimi%2Fconfiguration_mimi.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fmimi%2Fconfiguration_mimi.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmimi%2Fconfiguration_mimi.py?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -0,0 +1,234 @@\n+# coding=utf-8\n+# Copyright 2024 Meta Platforms, Inc. and affiliates, and the HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Mimi model configuration\"\"\"\n+\n+import math\n+\n+import numpy as np\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...utils import logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class MimiConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of an [`MimiModel`]. It is used to instantiate a\n+    Mimi model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of the\n+    [kyutai/mimi](https://huggingface.co/kyutai/mimi) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        sampling_rate (`int`, *optional*, defaults to 24000):\n+            The sampling rate at which the audio waveform should be digitalized expressed in hertz (Hz).\n+        frame_rate (`float`, *optional*, defaults to 12.5):\n+            Framerate of the model.\n+        audio_channels (`int`, *optional*, defaults to 1):\n+            Number of channels in the audio data. Either 1 for mono or 2 for stereo.\n+        hidden_size (`int`, *optional*, defaults to 512):\n+            Intermediate representation dimension.\n+        num_filters (`int`, *optional*, defaults to 64):\n+            Number of convolution kernels of first `MimiConv1d` down sampling layer.\n+        num_residual_layers (`int`,  *optional*, defaults to 1):\n+            Number of residual layers.\n+        upsampling_ratios (`Sequence[int]`, *optional*):\n+            Kernel size and stride ratios. The encoder uses downsampling ratios instead of upsampling ratios, hence it\n+            will use the ratios in the reverse order to the ones specified here that must match the decoder order.\n+            If not specified, will defaults to `[8, 6, 5, 4]`\n+        kernel_size (`int`, *optional*, defaults to 7):\n+            Kernel size for the initial convolution.\n+        last_kernel_size (`int`, *optional*, defaults to 3):\n+            Kernel size for the last convolution layer.\n+        residual_kernel_size (`int`, *optional*, defaults to 3):\n+            Kernel size for the residual layers.\n+        dilation_growth_rate (`int`, *optional*, defaults to 2):\n+            How much to increase the dilation with each layer.\n+        use_causal_conv (`bool`, *optional*, defaults to `True`):\n+            Whether to use fully causal convolution.\n+        pad_mode (`str`, *optional*, defaults to `\"constant\"`):\n+            Padding mode for the convolutions.\n+        compress (`int`, *optional*, defaults to 2):\n+            Reduced dimensionality in residual branches.\n+        trim_right_ratio (`float`, *optional*, defaults to 1.0):\n+            Ratio for trimming at the right of the transposed convolution under the `use_causal_conv = True` setup. If\n+            equal to 1.0, it means that all the trimming is done at the right.\n+        codebook_size (`int`, *optional*, defaults to 2048):\n+            Number of discret codes in each codebooks.\n+        codebook_dim (`int`, *optional*, defaults to 256):\n+            Dimension of the unquantized codebook vectors. If not defined, uses `hidden_size`.\n+        num_quantizers (`int`, *optional*, defaults to 32):\n+            Number of quantizer channels, or codebooks, in the quantizer.\n+        use_conv_shortcut (`bool`, *optional*, defaults to `False`):\n+            Whether to use a convolutional layer as the 'skip' connection in the `MimiResnetBlock` block. If False,\n+            an identity function will be used, giving a generic residual connection.\n+        vector_quantization_hidden_dimension (`int`, *optional*, defaults to 256):\n+            Intermediate representation dimension in the residual vector quantization space.\n+        num_semantic_quantizers (`int`, *optional*, defaults to 1):\n+            Number of semantic quantizer channels, or codebooks, in the semantic quantizer. Must be lower than `num_quantizers`.\n+        upsample_groups (`int`, *optional*, defaults to 512):\n+            If `frame_rate!=encodec_frame_rate`, indicates the number of groups used in the upsampling operation to go from one rate to another.\n+        num_hidden_layers (`int`, *optional*, defaults to 8):\n+            Number of hidden layers in the Transformer models.\n+        intermediate_size (`int`, *optional*, defaults to 2048):\n+            Dimension of the MLP representations.\n+        num_attention_heads (`int`, *optional*, defaults to 8):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 8):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `8`.\n+        head_dim (`int`, *optional*, defaults to `hidden_size // num_attention_heads`):\n+            The attention head dimension.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 8000):\n+            The maximum sequence length that this model might ever be used with. Mimi's sliding window attention\n+            allows sequence of up to 8000 tokens.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the LayerNorm normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `False`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings.\n+        sliding_window (`int`, *optional*, defaults to 250):\n+            Sliding window attention window size. If not specified, will default to `250`.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        layer_scale_initial_scale (`float`, *optional*, defaults to 0.01):\n+            Initiale scale of the residual rescaling operation done in the Transformer models.\n+        attention_bias (`bool`, defaults to `False`, *optional*, defaults to `False`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+    Example:\n+\n+    ```python\n+    >>> from transformers import MimiModel, MimiConfig\n+\n+    >>> # Initializing a \"kyutai/mimi\" style configuration\n+    >>> configuration = MimiConfig()\n+\n+    >>> # Initializing a model (with random weights) from the \"kyutai/mimi\" style configuration\n+    >>> model = MimiModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"mimi\"\n+\n+    def __init__(\n+        self,\n+        sampling_rate=24_000,\n+        frame_rate=12.5,\n+        audio_channels=1,\n+        hidden_size=512,\n+        num_filters=64,\n+        num_residual_layers=1,\n+        upsampling_ratios=None,\n+        kernel_size=7,\n+        last_kernel_size=3,\n+        residual_kernel_size=3,\n+        dilation_growth_rate=2,\n+        use_causal_conv=True,\n+        pad_mode=\"constant\",\n+        compress=2,\n+        trim_right_ratio=1.0,\n+        codebook_size=2048,\n+        codebook_dim=256,\n+        num_quantizers=32,\n+        use_conv_shortcut=False,\n+        vector_quantization_hidden_dimension=256,\n+        num_semantic_quantizers=1,\n+        upsample_groups=512,\n+        num_hidden_layers=8,\n+        intermediate_size=2048,\n+        num_attention_heads=8,\n+        num_key_value_heads=8,\n+        head_dim=None,\n+        hidden_act=\"gelu\",\n+        max_position_embeddings=8000,\n+        initializer_range=0.02,\n+        norm_eps=1e-5,\n+        use_cache=False,\n+        rope_theta=10000.0,\n+        sliding_window=250,\n+        attention_dropout=0.0,\n+        layer_scale_initial_scale=0.01,\n+        attention_bias=False,\n+        **kwargs,\n+    ):\n+        self.sampling_rate = sampling_rate\n+        self.frame_rate = frame_rate\n+        self.audio_channels = audio_channels\n+        self.hidden_size = hidden_size\n+        self.num_filters = num_filters\n+        self.num_residual_layers = num_residual_layers\n+        self.upsampling_ratios = upsampling_ratios if upsampling_ratios else [8, 6, 5, 4]\n+        self.kernel_size = kernel_size\n+        self.last_kernel_size = last_kernel_size\n+        self.residual_kernel_size = residual_kernel_size\n+        self.dilation_growth_rate = dilation_growth_rate\n+        self.use_causal_conv = use_causal_conv\n+        self.pad_mode = pad_mode\n+        self.compress = compress\n+        self.trim_right_ratio = trim_right_ratio\n+        self.codebook_size = codebook_size\n+        self.codebook_dim = codebook_dim if codebook_dim is not None else hidden_size\n+        self.num_quantizers = num_quantizers\n+        self.use_conv_shortcut = use_conv_shortcut\n+        self.vector_quantization_hidden_dimension = vector_quantization_hidden_dimension\n+        self.upsample_groups = upsample_groups\n+        self.num_hidden_layers = num_hidden_layers\n+        self.intermediate_size = intermediate_size\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.max_position_embeddings = max_position_embeddings\n+        self.initializer_range = initializer_range\n+        self.norm_eps = norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.sliding_window = sliding_window\n+        self.attention_dropout = attention_dropout\n+        self.head_dim = head_dim or hidden_size // num_attention_heads\n+        self.layer_scale_initial_scale = layer_scale_initial_scale\n+        self.attention_bias = attention_bias\n+\n+        if num_semantic_quantizers >= self.num_quantizers:\n+            raise ValueError(\n+                f\"The number of semantic quantizers should be lower than the total number of quantizers {self.num_quantizers}, but is currently {num_semantic_quantizers}.\"\n+            )\n+        self.num_semantic_quantizers = num_semantic_quantizers\n+        super().__init__(**kwargs)\n+\n+    @property\n+    def encodec_frame_rate(self) -> int:\n+        hop_length = np.prod(self.upsampling_ratios)\n+        return math.ceil(self.sampling_rate / hop_length)\n+\n+    @property\n+    def num_codebooks(self) -> int:\n+        # alias to num_quantizers\n+        return self.num_quantizers"
        },
        {
            "sha": "c617fa036c5d47ff2c72ece9e8614873aa5edbb2",
            "filename": "src/transformers/models/mimi/convert_mimi_checkpoint_to_pytorch.py",
            "status": "added",
            "additions": 198,
            "deletions": 0,
            "changes": 198,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fmimi%2Fconvert_mimi_checkpoint_to_pytorch.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fmimi%2Fconvert_mimi_checkpoint_to_pytorch.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmimi%2Fconvert_mimi_checkpoint_to_pytorch.py?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -0,0 +1,198 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Convert Mimi checkpoints.\"\"\"\n+\n+import argparse\n+\n+import safetensors\n+import torch\n+\n+from transformers import (\n+    EncodecFeatureExtractor,\n+    MimiConfig,\n+    MimiModel,\n+    logging,\n+)\n+\n+\n+logging.set_verbosity_info()\n+logger = logging.get_logger(\"transformers.models.mimi\")\n+\n+\n+def assert_param_count(model_1, model_2):\n+    count_1 = sum(p[1].numel() for p in model_1.named_parameters() if \"final_proj\" not in p[0])\n+    count_2 = sum(p[1].numel() for p in model_2.named_parameters() if \"final_proj\" not in p[0])\n+    assert count_1 == count_2, f\"{model_1.__class__}: {count_1} != {model_2.__class__}: {count_2}\"\n+\n+\n+def param_count(model):\n+    return sum(p[1].numel() for p in model.named_parameters() if \"final_proj\" not in p[0])\n+\n+\n+def _grab_best_device(use_gpu=True):\n+    if torch.cuda.device_count() > 0 and use_gpu:\n+        device = \"cuda\"\n+    else:\n+        device = \"cpu\"\n+    return torch.device(device)\n+\n+\n+convert_list = [\n+    # GENERAL\n+    (\"conv.conv.conv\", \"conv\"),\n+    (\"convtr.convtr.convtr\", \"conv\"),\n+    (\"conv.conv\", \"conv\"),\n+    (\"convtr.convtr\", \"conv\"),\n+    # QUANTIZER\n+    (\"quantizer.rvq_first.vq\", \"quantizer.semantic_residual_vector_quantizer\"),\n+    (\"quantizer.rvq_first\", \"quantizer.semantic_residual_vector_quantizer\"),\n+    (\"quantizer.rvq_rest.vq\", \"quantizer.acoustic_residual_vector_quantizer\"),\n+    (\"quantizer.rvq_rest\", \"quantizer.acoustic_residual_vector_quantizer\"),\n+    (\"_codebook\", \"codebook\"),\n+    (\"_initialized\", \"initialized\"),\n+    (\"embedding_sum\", \"embed_sum\"),\n+    # ENCODER PART\n+    (\"encoder.model\", \"encoder.layers\"),\n+    (\"decoder.model\", \"decoder.layers\"),\n+    # TRANSFORMERS PART\n+    (\"encoder_transformer.transformer\", \"encoder_transformer\"),\n+    (\"decoder_transformer.transformer\", \"decoder_transformer\"),\n+    (\"linear1\", \"mlp.fc1\"),\n+    (\"linear2\", \"mlp.fc2\"),\n+    (\"self_attn.out_proj\", \"self_attn.o_proj\"),\n+    (\"norm1\", \"input_layernorm\"),\n+    (\"norm2\", \"post_attention_layernorm\"),\n+    (\"layer_scale_1\", \"self_attn_layer_scale\"),\n+    (\"layer_scale_2\", \"mlp_layer_scale\"),\n+]\n+\n+\n+def _convert_model(\n+    state_dict,\n+    hf_model,\n+    convert_list,\n+    device,\n+    config,\n+    unwanted_prefix=None,\n+):\n+    hidden_size = config.hidden_size\n+    head_dim = config.head_dim\n+    num_heads = int(config.hidden_size // config.head_dim)\n+    num_key_value_heads = config.num_key_value_heads\n+    key_value_head_dim = config.num_key_value_heads * head_dim\n+\n+    # permute for sliced rotary\n+    def permute(w, n_heads, dim1=hidden_size, dim2=hidden_size):\n+        return w.view(n_heads, dim1 // n_heads // 2, 2, dim2).transpose(1, 2).reshape(dim1, dim2)\n+\n+    for k, v in list(state_dict.items()):\n+        new_k = k if unwanted_prefix is None else k[len(unwanted_prefix) :]\n+        for old_layer_name, new_layer_name in convert_list:\n+            if old_layer_name in new_k:\n+                new_k = new_k.replace(old_layer_name, new_layer_name)\n+\n+        if \"in_proj_weight\" in new_k:\n+            # split qkv into query key and value\n+            mixed_qkv = state_dict.pop(k)\n+            qkv_dim = mixed_qkv.size(0) // 3\n+\n+            query_layer = mixed_qkv[:qkv_dim]\n+            key_layer = mixed_qkv[qkv_dim : qkv_dim * 2]\n+            value_layer = mixed_qkv[qkv_dim * 2 :]\n+\n+            state_dict[new_k.replace(\"in_proj_weight\", \"q_proj.weight\")] = permute(query_layer, num_heads)\n+            state_dict[new_k.replace(\"in_proj_weight\", \"k_proj.weight\")] = permute(\n+                key_layer, num_key_value_heads, dim1=key_value_head_dim\n+            )\n+            state_dict[new_k.replace(\"in_proj_weight\", \"v_proj.weight\")] = value_layer\n+        else:\n+            state_dict[new_k] = state_dict.pop(k)\n+\n+    extra_keys = set(state_dict.keys()) - set(hf_model.state_dict().keys())\n+    missing_keys = set(hf_model.state_dict().keys()) - set(state_dict.keys())\n+    if len(extra_keys) != 0:\n+        raise ValueError(f\"extra keys found: {extra_keys}\")\n+    if len(missing_keys) != 0:\n+        raise ValueError(f\"missing keys: {missing_keys}\")\n+    hf_model.load_state_dict(state_dict, strict=True)\n+    n_params = param_count(hf_model)\n+\n+    logger.info(f\"model loaded: {round(n_params/1e6,1)}M params\")\n+\n+    hf_model.eval()\n+    hf_model.to(device)\n+    del state_dict\n+\n+    return hf_model\n+\n+\n+@torch.no_grad()\n+def convert_checkpoint(\n+    checkpoint_path,\n+    pytorch_dump_folder_path,\n+    config_path=None,\n+    repo_id=None,\n+):\n+    \"\"\"\n+    Copy/paste/tweak model's weights to transformers design.\n+    \"\"\"\n+    device = _grab_best_device()\n+\n+    if config_path is not None:\n+        config = MimiConfig.from_pretrained(config_path)\n+    else:\n+        config = MimiConfig()\n+\n+    model = MimiModel(config)\n+\n+    feature_extractor = EncodecFeatureExtractor(\n+        feature_size=config.audio_channels,\n+        sampling_rate=config.sampling_rate,\n+    )\n+    feature_extractor.save_pretrained(pytorch_dump_folder_path)\n+\n+    original_checkpoint = safetensors.torch.load_file(checkpoint_path)\n+    if \"best_state\" in original_checkpoint:\n+        # we might have a training state saved, in which case discard the yaml results and just retain the weights\n+        original_checkpoint = original_checkpoint[\"best_state\"]\n+\n+    model = _convert_model(original_checkpoint, model, convert_list, device, config)\n+\n+    model.save_pretrained(pytorch_dump_folder_path)\n+\n+    if repo_id:\n+        print(\"Pushing to the hub...\")\n+        feature_extractor.push_to_hub(repo_id)\n+        model.push_to_hub(repo_id)\n+\n+\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\"--checkpoint_path\", required=True, default=None, type=str, help=\"Path to original checkpoint\")\n+    parser.add_argument(\"--config_path\", default=None, type=str, help=\"Path to hf config.json of model to convert\")\n+    parser.add_argument(\n+        \"--pytorch_dump_folder_path\", required=True, default=None, type=str, help=\"Path to the output PyTorch model.\"\n+    )\n+    parser.add_argument(\n+        \"--push_to_hub\", default=None, type=str, help=\"Where to upload the converted model on the ü§ó hub.\"\n+    )\n+\n+    args = parser.parse_args()\n+    convert_checkpoint(\n+        args.checkpoint_path,\n+        args.pytorch_dump_folder_path,\n+        args.config_path,\n+        args.push_to_hub,\n+    )"
        },
        {
            "sha": "db36250b3d89df30c5a6928fa9204a1999f8f57e",
            "filename": "src/transformers/models/mimi/modeling_mimi.py",
            "status": "added",
            "additions": 1722,
            "deletions": 0,
            "changes": 1722,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fmimi%2Fmodeling_mimi.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Fmodels%2Fmimi%2Fmodeling_mimi.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmimi%2Fmodeling_mimi.py?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -0,0 +1,1722 @@\n+# coding=utf-8\n+# Copyright 2024 Kyutai, and the HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch Mimi model.\"\"\"\n+\n+import math\n+from dataclasses import dataclass\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+import torch.utils.checkpoint\n+from torch import nn\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache, StaticCache\n+from ...modeling_attn_mask_utils import AttentionMaskConverter\n+from ...modeling_outputs import BaseModelOutputWithPast\n+from ...modeling_utils import PreTrainedModel\n+from ...utils import (\n+    ModelOutput,\n+    add_start_docstrings,\n+    add_start_docstrings_to_model_forward,\n+    is_flash_attn_2_available,\n+    is_flash_attn_greater_or_equal_2_10,\n+    logging,\n+    replace_return_docstrings,\n+)\n+from .configuration_mimi import MimiConfig\n+\n+\n+if is_flash_attn_2_available():\n+    from ...modeling_flash_attention_utils import _flash_attention_forward\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+# General docstring\n+_CONFIG_FOR_DOC = \"MimiConfig\"\n+\n+\n+# Copied from transformers.models.llama.modeling_llama._prepare_4d_causal_attention_mask_with_cache_position\n+def _prepare_4d_causal_attention_mask_with_cache_position(\n+    attention_mask: torch.Tensor,\n+    sequence_length: int,\n+    target_length: int,\n+    dtype: torch.dtype,\n+    device: torch.device,\n+    min_dtype: float,\n+    cache_position: torch.Tensor,\n+    batch_size: int,\n+):\n+    \"\"\"\n+    Creates a causal 4D mask of shape `(batch_size, 1, query_length, key_value_length)` from a 2D mask of shape\n+    `(batch_size, key_value_length)`, or if the input `attention_mask` is already 4D, do nothing.\n+\n+    Args:\n+        attention_mask (`torch.Tensor`):\n+            A 2D attention mask of shape `(batch_size, key_value_length)` or a 4D attention mask of shape `(batch_size, 1, query_length, key_value_length)`.\n+        sequence_length (`int`):\n+            The sequence length being processed.\n+        target_length (`int`):\n+            The target length: when generating with static cache, the mask should be as long as the static cache, to account for the 0 padding, the part of the cache that is not filled yet.\n+        dtype (`torch.dtype`):\n+            The dtype to use for the 4D attention mask.\n+        device (`torch.device`):\n+            The device to plcae the 4D attention mask on.\n+        min_dtype (`float`):\n+            The minimum value representable with the dtype `dtype`.\n+        cache_position (`torch.Tensor`):\n+            Indices depicting the position of the input sequence tokens in the sequence.\n+        batch_size (`torch.Tensor`):\n+            Batch size.\n+    \"\"\"\n+    if attention_mask is not None and attention_mask.dim() == 4:\n+        # In this case we assume that the mask comes already in inverted form and requires no inversion or slicing.\n+        causal_mask = attention_mask\n+    else:\n+        causal_mask = torch.full((sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device)\n+        if sequence_length != 1:\n+            causal_mask = torch.triu(causal_mask, diagonal=1)\n+        causal_mask *= torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n+        causal_mask = causal_mask[None, None, :, :].expand(batch_size, 1, -1, -1)\n+        if attention_mask is not None:\n+            causal_mask = causal_mask.clone()  # copy to contiguous memory for in-place edit\n+            mask_length = attention_mask.shape[-1]\n+            padding_mask = causal_mask[:, :, :, :mask_length] + attention_mask[:, None, None, :]\n+            padding_mask = padding_mask == 0\n+            causal_mask[:, :, :, :mask_length] = causal_mask[:, :, :, :mask_length].masked_fill(\n+                padding_mask, min_dtype\n+            )\n+\n+    return causal_mask\n+\n+\n+@dataclass\n+class MimiOutput(ModelOutput):\n+    \"\"\"\n+    Args:\n+        audio_codes (`torch.LongTensor`  of shape `(batch_size, num_quantizers, codes_length)`, *optional*):\n+            Discret code embeddings computed using `model.encode`.\n+        audio_values (`torch.FloatTensor` of shape `(batch_size, sequence_length)`, *optional*)\n+            Decoded audio values, obtained using the decoder part of Mimi.\n+        encoder_past_key_values (`Cache`, *optional*):\n+            Pre-computed hidden-states (key and values in the self-attention blocks) that can be used to speed up sequential decoding of the encoder transformer.\n+            This typically consists in the `past_key_values` returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n+\n+            The model will output the same cache format that is fed as input.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `audio_values` or `audio_codes (those that don't\n+            have their past key value states given to this model).\n+        decoder_past_key_values (`Cache`, *optional*):\n+            Pre-computed hidden-states (key and values in the self-attention blocks) that can be used to speed up sequential decoding of the decoder transformer.\n+            This typically consists in the `past_key_values` returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n+\n+            The model will output the same cache format that is fed as input.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `audio_values` or `audio_codes (those that don't\n+            have their past key value states given to this model).\n+    \"\"\"\n+\n+    audio_codes: torch.LongTensor = None\n+    audio_values: torch.FloatTensor = None\n+    encoder_past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None\n+    decoder_past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None\n+\n+\n+@dataclass\n+class MimiEncoderOutput(ModelOutput):\n+    \"\"\"\n+    Args:\n+        audio_codes (`torch.LongTensor`  of shape `(batch_size, num_quantizers, codes_length)`, *optional*):\n+            Discret code embeddings computed using `model.encode`.\n+        encoder_past_key_values (`Cache`, *optional*):\n+            Pre-computed hidden-states (key and values in the self-attention blocks) that can be used to speed up sequential decoding of the encoder transformer.\n+            This typically consists in the `past_key_values` returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n+\n+            The model will output the same cache format that is fed as input.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `audio_values` or `audio_codes (those that don't\n+            have their past key value states given to this model).\n+    \"\"\"\n+\n+    audio_codes: torch.LongTensor = None\n+    encoder_past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None\n+\n+\n+@dataclass\n+class MimiDecoderOutput(ModelOutput):\n+    \"\"\"\n+    Args:\n+        audio_values (`torch.FloatTensor`  of shape `(batch_size, segment_length)`, *optional*):\n+            Decoded audio values, obtained using the decoder part of Mimi.\n+        decoder_past_key_values (`Cache`, *optional*):\n+            Pre-computed hidden-states (key and values in the self-attention blocks) that can be used to speed up sequential decoding of the decoder transformer.\n+            This typically consists in the `past_key_values` returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n+\n+            The model will output the same cache format that is fed as input.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `audio_values` or `audio_codes (those that don't\n+            have their past key value states given to this model).\n+    \"\"\"\n+\n+    audio_values: torch.FloatTensor = None\n+    decoder_past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None\n+\n+\n+class MimiConv1d(nn.Module):\n+    \"\"\"Conv1d with asymmetric or causal padding and normalization.\"\"\"\n+\n+    def __init__(\n+        self,\n+        config,\n+        in_channels: int,\n+        out_channels: int,\n+        kernel_size: int,\n+        stride: int = 1,\n+        dilation: int = 1,\n+        groups: int = 1,\n+        pad_mode=None,\n+        bias: bool = True,\n+    ):\n+        super().__init__()\n+        self.causal = config.use_causal_conv\n+        self.pad_mode = config.pad_mode if pad_mode is None else pad_mode\n+\n+        # warn user on unusual setup between dilation and stride\n+        if stride > 1 and dilation > 1:\n+            logger.warning(\n+                \"MimiConv1d has been initialized with stride > 1 and dilation > 1\"\n+                f\" (kernel_size={kernel_size} stride={stride}, dilation={dilation}).\"\n+            )\n+\n+        self.conv = nn.Conv1d(\n+            in_channels, out_channels, kernel_size, stride, dilation=dilation, groups=groups, bias=bias\n+        )\n+\n+        kernel_size = self.conv.kernel_size[0]\n+        stride = torch.tensor(self.conv.stride[0], dtype=torch.int64)\n+        dilation = self.conv.dilation[0]\n+\n+        # Effective kernel size with dilations.\n+        kernel_size = torch.tensor((kernel_size - 1) * dilation + 1, dtype=torch.int64)\n+\n+        self.register_buffer(\"stride\", stride, persistent=False)\n+        self.register_buffer(\"kernel_size\", kernel_size, persistent=False)\n+        self.register_buffer(\"padding_total\", torch.tensor(kernel_size - stride, dtype=torch.int64), persistent=False)\n+\n+        # Asymmetric padding required for odd strides\n+        self.padding_right = self.padding_total // 2\n+        self.padding_left = self.padding_total - self.padding_right\n+\n+    def apply_weight_norm(self):\n+        weight_norm = nn.utils.weight_norm\n+        if hasattr(nn.utils.parametrizations, \"weight_norm\"):\n+            weight_norm = nn.utils.parametrizations.weight_norm\n+\n+        weight_norm(self.conv)\n+\n+    def remove_weight_norm(self):\n+        nn.utils.remove_weight_norm(self.conv)\n+\n+    # Copied from transformers.models.encodec.modeling_encodec.EncodecConv1d._get_extra_padding_for_conv1d\n+    def _get_extra_padding_for_conv1d(\n+        self,\n+        hidden_states: torch.Tensor,\n+    ) -> torch.Tensor:\n+        \"\"\"See `pad_for_conv1d`.\"\"\"\n+        length = hidden_states.shape[-1]\n+        n_frames = (length - self.kernel_size + self.padding_total) / self.stride + 1\n+        n_frames = torch.ceil(n_frames).to(torch.int64) - 1\n+        ideal_length = n_frames * self.stride + self.kernel_size - self.padding_total\n+\n+        return ideal_length - length\n+\n+    @staticmethod\n+    # Copied from transformers.models.encodec.modeling_encodec.EncodecConv1d._pad1d\n+    def _pad1d(hidden_states: torch.Tensor, paddings: Tuple[int, int], mode: str = \"zero\", value: float = 0.0):\n+        \"\"\"Tiny wrapper around torch.nn.functional.pad, just to allow for reflect padding on small input.\n+        If this is the case, we insert extra 0 padding to the right before the reflection happens.\n+        \"\"\"\n+        length = hidden_states.shape[-1]\n+        padding_left, padding_right = paddings\n+        if not mode == \"reflect\":\n+            return nn.functional.pad(hidden_states, paddings, mode, value)\n+\n+        max_pad = max(padding_left, padding_right)\n+        extra_pad = 0\n+        if length <= max_pad:\n+            extra_pad = max_pad - length + 1\n+            hidden_states = nn.functional.pad(hidden_states, (0, extra_pad))\n+        padded = nn.functional.pad(hidden_states, paddings, mode, value)\n+        end = padded.shape[-1] - extra_pad\n+        return padded[..., :end]\n+\n+    def forward(self, hidden_states):\n+        extra_padding = self._get_extra_padding_for_conv1d(hidden_states)\n+\n+        if self.causal:\n+            # Left padding for causal\n+            hidden_states = self._pad1d(hidden_states, (self.padding_total, extra_padding), mode=self.pad_mode)\n+        else:\n+            hidden_states = self._pad1d(\n+                hidden_states, (self.padding_left, self.padding_right + extra_padding), mode=self.pad_mode\n+            )\n+\n+        hidden_states = self.conv(hidden_states)\n+        return hidden_states\n+\n+\n+class MimiConvTranspose1d(nn.Module):\n+    \"\"\"ConvTranspose1d with asymmetric or causal padding and normalization.\"\"\"\n+\n+    def __init__(\n+        self,\n+        config,\n+        in_channels: int,\n+        out_channels: int,\n+        kernel_size: int,\n+        stride: int = 1,\n+        groups: int = 1,\n+        bias=True,\n+    ):\n+        super().__init__()\n+        self.causal = config.use_causal_conv\n+        self.trim_right_ratio = config.trim_right_ratio\n+        self.conv = nn.ConvTranspose1d(in_channels, out_channels, kernel_size, stride, groups=groups, bias=bias)\n+\n+        if not (self.causal or self.trim_right_ratio == 1.0):\n+            raise ValueError(\"`trim_right_ratio` != 1.0 only makes sense for causal convolutions\")\n+\n+        kernel_size = self.conv.kernel_size[0]\n+        stride = self.conv.stride[0]\n+        padding_total = kernel_size - stride\n+\n+        # We will only trim fixed padding. Extra padding from `pad_for_conv1d` would be\n+        # removed at the very end, when keeping only the right length for the output,\n+        # as removing it here would require also passing the length at the matching layer\n+        # in the encoder.\n+        if self.causal:\n+            # Trim the padding on the right according to the specified ratio\n+            # if trim_right_ratio = 1.0, trim everything from right\n+            self.padding_right = math.ceil(padding_total * self.trim_right_ratio)\n+        else:\n+            # Asymmetric padding required for odd strides\n+            self.padding_right = padding_total // 2\n+\n+        self.padding_left = padding_total - self.padding_right\n+\n+    def apply_weight_norm(self):\n+        weight_norm = nn.utils.weight_norm\n+        if hasattr(nn.utils.parametrizations, \"weight_norm\"):\n+            weight_norm = nn.utils.parametrizations.weight_norm\n+\n+        weight_norm(self.conv)\n+\n+    def remove_weight_norm(self):\n+        nn.utils.remove_weight_norm(self.conv)\n+\n+    def forward(self, hidden_states):\n+        hidden_states = self.conv(hidden_states)\n+\n+        # unpad\n+        end = hidden_states.shape[-1] - self.padding_right\n+        hidden_states = hidden_states[..., self.padding_left : end]\n+        return hidden_states\n+\n+\n+# Copied from transformers.models.encodec.modeling_encodec.EncodecResnetBlock with Encodec->Mimi,EnCodec->Mimi\n+class MimiResnetBlock(nn.Module):\n+    \"\"\"\n+    Residual block from SEANet model as used by Mimi.\n+    \"\"\"\n+\n+    def __init__(self, config: MimiConfig, dim: int, dilations: List[int]):\n+        super().__init__()\n+        kernel_sizes = (config.residual_kernel_size, 1)\n+        if len(kernel_sizes) != len(dilations):\n+            raise ValueError(\"Number of kernel sizes should match number of dilations\")\n+\n+        hidden = dim // config.compress\n+        block = []\n+        for i, (kernel_size, dilation) in enumerate(zip(kernel_sizes, dilations)):\n+            in_chs = dim if i == 0 else hidden\n+            out_chs = dim if i == len(kernel_sizes) - 1 else hidden\n+            block += [nn.ELU()]\n+            block += [MimiConv1d(config, in_chs, out_chs, kernel_size, dilation=dilation)]\n+        self.block = nn.ModuleList(block)\n+\n+        if config.use_conv_shortcut:\n+            self.shortcut = MimiConv1d(config, dim, dim, kernel_size=1)\n+        else:\n+            self.shortcut = nn.Identity()\n+\n+    def forward(self, hidden_states):\n+        residual = hidden_states\n+        for layer in self.block:\n+            hidden_states = layer(hidden_states)\n+\n+        return self.shortcut(residual) + hidden_states\n+\n+\n+class MimiEncoder(nn.Module):\n+    \"\"\"SEANet encoder as used by Mimi.\"\"\"\n+\n+    def __init__(self, config: MimiConfig):\n+        super().__init__()\n+        model = [MimiConv1d(config, config.audio_channels, config.num_filters, config.kernel_size)]\n+        scaling = 1\n+\n+        # Downsample to raw audio scale\n+        for ratio in reversed(config.upsampling_ratios):\n+            current_scale = scaling * config.num_filters\n+            # Add residual layers\n+            for j in range(config.num_residual_layers):\n+                model += [MimiResnetBlock(config, current_scale, [config.dilation_growth_rate**j, 1])]\n+            # Add downsampling layers\n+            model += [nn.ELU()]\n+            model += [MimiConv1d(config, current_scale, current_scale * 2, kernel_size=ratio * 2, stride=ratio)]\n+            scaling *= 2\n+\n+        model += [nn.ELU()]\n+        model += [MimiConv1d(config, scaling * config.num_filters, config.hidden_size, config.last_kernel_size)]\n+\n+        self.layers = nn.ModuleList(model)\n+\n+    # Copied from transformers.models.encodec.modeling_encodec.EncodecEncoder.forward\n+    def forward(self, hidden_states):\n+        for layer in self.layers:\n+            hidden_states = layer(hidden_states)\n+        return hidden_states\n+\n+\n+class MimiLayerScale(nn.Module):\n+    \"\"\"Layer scale from [Touvron et al 2021] (https://arxiv.org/pdf/2103.17239.pdf).\n+    This rescales diagonally the residual outputs close to 0, with a learnt scale.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+        channels = config.hidden_size\n+        initial_scale = config.layer_scale_initial_scale\n+        self.scale = nn.Parameter(torch.full((channels,), initial_scale, requires_grad=True))\n+\n+    def forward(self, x: torch.Tensor):\n+        return self.scale * x\n+\n+\n+# Copied from transformers.models.mistral.modeling_mistral.MistralRotaryEmbedding with Mistral->Mimi\n+class MimiRotaryEmbedding(nn.Module):\n+    def __init__(self, dim, max_position_embeddings=2048, base=10000, device=None):\n+        super().__init__()\n+\n+        self.dim = dim\n+        self.max_position_embeddings = max_position_embeddings\n+        self.base = base\n+        inv_freq = 1.0 / (self.base ** (torch.arange(0, self.dim, 2, dtype=torch.int64).float().to(device) / self.dim))\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+\n+    @torch.no_grad()\n+    # copied from transformers.models.llama.modeling_llama.LlamaRotaryEmbedding.forward\n+    # TODO(joao): add me back asap :)\n+    def forward(self, x, position_ids):\n+        # x: [bs, num_attention_heads, seq_len, head_size]\n+        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1)\n+        position_ids_expanded = position_ids[:, None, :].float()\n+        # Force float32 since bfloat16 loses precision on long contexts\n+        # See https://github.com/huggingface/transformers/pull/29285\n+        device_type = x.device.type\n+        device_type = device_type if isinstance(device_type, str) and device_type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(1, 2)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos()\n+            sin = emb.sin()\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+# Copied from transformers.models.llama.modeling_llama.rotate_half\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+# Copied from transformers.models.llama.modeling_llama.apply_rotary_pos_emb\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`, *optional*):\n+            Deprecated and unused.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    return q_embed, k_embed\n+\n+\n+class MimiMLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.config = config\n+        self.activation_fn = ACT2FN[config.hidden_act]\n+        self.fc1 = nn.Linear(config.hidden_size, config.intermediate_size, bias=False)\n+        self.fc2 = nn.Linear(config.intermediate_size, config.hidden_size, bias=False)\n+\n+    # Copied from transformers.models.clip.modeling_clip.CLIPMLP.forward\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        hidden_states = self.fc1(hidden_states)\n+        hidden_states = self.activation_fn(hidden_states)\n+        hidden_states = self.fc2(hidden_states)\n+        return hidden_states\n+\n+\n+# Copied from transformers.models.llama.modeling_llama.repeat_kv\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+# Copied from transformers.models.gemma.modeling_gemma.GemmaAttention with Gemma->Mimi\n+class MimiAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: MimiConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        if layer_idx is None:\n+            logger.warning_once(\n+                f\"Instantiating {self.__class__.__name__} without passing a `layer_idx` is not recommended and will \"\n+                \"lead to errors during the forward call if caching is used. Please make sure to provide a `layer_idx` \"\n+                \"when creating this class.\"\n+            )\n+\n+        self.attention_dropout = config.attention_dropout\n+        self.hidden_size = config.hidden_size\n+        self.num_heads = config.num_attention_heads\n+        self.head_dim = config.head_dim\n+        self.num_key_value_heads = config.num_key_value_heads\n+        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n+        self.max_position_embeddings = config.max_position_embeddings\n+        self.rope_theta = config.rope_theta\n+        self.is_causal = True\n+        self.scaling = 1 / math.sqrt(config.head_dim)\n+\n+        if self.hidden_size % self.num_heads != 0:\n+            raise ValueError(\n+                f\"hidden_size must be divisible by num_heads (got `hidden_size`: {self.hidden_size}\"\n+                f\" and `num_heads`: {self.num_heads}).\"\n+            )\n+\n+        self.q_proj = nn.Linear(self.hidden_size, self.num_heads * self.head_dim, bias=config.attention_bias)\n+        self.k_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=config.attention_bias)\n+        self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=config.attention_bias)\n+        self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=config.attention_bias)\n+        self.rotary_emb = MimiRotaryEmbedding(\n+            self.head_dim,\n+            max_position_embeddings=self.max_position_embeddings,\n+            base=self.rope_theta,\n+        )\n+        self.sliding_window = config.sliding_window  # Ignore copy\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+\n+        cos, sin = self.rotary_emb(value_states, position_ids)\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        key_states = repeat_kv(key_states, self.num_key_value_groups)\n+        value_states = repeat_kv(value_states, self.num_key_value_groups)\n+\n+        attn_weights = torch.matmul(query_states, key_states.transpose(2, 3)) * self.scaling\n+\n+        if attention_mask is not None:  # no matter the length, we just slice it\n+            causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+            attn_weights = attn_weights + causal_mask\n+\n+        # upcast attention to fp32\n+        attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query_states.dtype)\n+        attn_weights = nn.functional.dropout(attn_weights, p=self.attention_dropout, training=self.training)\n+        attn_output = torch.matmul(attn_weights, value_states)\n+\n+        if attn_output.size() != (bsz, self.num_heads, q_len, self.head_dim):\n+            raise ValueError(\n+                f\"`attn_output` should be of size {(bsz, self.num_heads, q_len, self.head_dim)}, but is\"\n+                f\" {attn_output.size()}\"\n+            )\n+\n+        attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+        attn_output = attn_output.view(bsz, q_len, -1)\n+        attn_output = self.o_proj(attn_output)\n+\n+        if not output_attentions:\n+            attn_weights = None\n+\n+        return attn_output, attn_weights, past_key_value\n+\n+\n+# Copied from transformers.models.gemma.modeling_gemma.GemmaFlashAttention2 with Gemma->Mimi\n+class MimiFlashAttention2(MimiAttention):\n+    \"\"\"\n+    Mimi flash attention module. This module inherits from `MimiAttention` as the weights of the module stays\n+    untouched. The only required change would be on the forward pass where it needs to correctly call the public API of\n+    flash attention and deal with padding tokens in case the input contains any of them.\n+    \"\"\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        # TODO: Should be removed once Flash Attention for RoCm is bumped to 2.1.\n+        # flash_attn<2.1 generates top-left aligned causal mask, while what is needed here is bottom-right alignement, that was made default for flash_attn>=2.1. This attribute is used to handle this difference. Reference: https://github.com/Dao-AILab/flash-attention/releases/tag/v2.1.0.\n+        # Beware that with flash_attn<2.1, using q_seqlen != k_seqlen (except for the case q_seqlen == 1) produces a wrong mask (top-left).\n+        self._flash_attn_uses_top_left_mask = not is_flash_attn_greater_or_equal_2_10()\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.LongTensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        if isinstance(past_key_value, StaticCache):\n+            raise ValueError(\n+                \"`static` cache implementation is not compatible with `attn_implementation==flash_attention_2` \"\n+                \"make sure to use `sdpa` in the mean time, and open an issue at https://github.com/huggingface/transformers\"\n+            )\n+\n+        output_attentions = False\n+\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        # Flash attention requires the input to have the shape\n+        # batch_size x seq_length x head_dim x hidden_dim\n+        # therefore we just need to keep the original shape\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+\n+        cos, sin = self.rotary_emb(value_states, position_ids)\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        # TODO: These transpose are quite inefficient but Flash Attention requires the layout [batch_size, sequence_length, num_heads, head_dim]. We would need to refactor the KV cache\n+        # to be able to avoid many of these transpose/reshape/view.\n+        query_states = query_states.transpose(1, 2)\n+        key_states = key_states.transpose(1, 2)\n+        value_states = value_states.transpose(1, 2)\n+\n+        dropout_rate = self.attention_dropout if self.training else 0.0\n+\n+        # In PEFT, usually we cast the layer norms in float32 for training stability reasons\n+        # therefore the input hidden states gets silently casted in float32. Hence, we need\n+        # cast them back in the correct dtype just to be sure everything works as expected.\n+        # This might slowdown training & inference so it is recommended to not cast the LayerNorms\n+        # in fp32. (MimiRMSNorm handles it correctly)\n+\n+        input_dtype = query_states.dtype\n+        if input_dtype == torch.float32:\n+            if torch.is_autocast_enabled():\n+                target_dtype = torch.get_autocast_gpu_dtype()\n+            # Handle the case where the model is quantized\n+            elif hasattr(self.config, \"_pre_quantization_dtype\"):\n+                target_dtype = self.config._pre_quantization_dtype\n+            else:\n+                target_dtype = self.q_proj.weight.dtype\n+\n+            logger.warning_once(\n+                f\"The input hidden states seems to be silently casted in float32, this might be related to\"\n+                f\" the fact you have upcasted embedding or layer norm layers in float32. We will cast back the input in\"\n+                f\" {target_dtype}.\"\n+            )\n+\n+            query_states = query_states.to(target_dtype)\n+            key_states = key_states.to(target_dtype)\n+            value_states = value_states.to(target_dtype)\n+\n+        attn_output = _flash_attention_forward(\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            q_len,\n+            position_ids=position_ids,\n+            dropout=dropout_rate,\n+            sliding_window=getattr(self, \"sliding_window\", None),\n+            is_causal=self.is_causal,\n+            use_top_left_mask=self._flash_attn_uses_top_left_mask,\n+        )\n+\n+        attn_output = attn_output.reshape(bsz, q_len, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+\n+        if not output_attentions:\n+            attn_weights = None\n+\n+        return attn_output, attn_weights, past_key_value\n+\n+\n+# Copied from transformers.models.gemma.modeling_gemma.GemmaSdpaAttention with Gemma->Mimi\n+class MimiSdpaAttention(MimiAttention):\n+    \"\"\"\n+    Mimi attention module using torch.nn.functional.scaled_dot_product_attention. This module inherits from\n+    `MimiAttention` as the weights of the module stays untouched. The only changes are on the forward pass to adapt to\n+    SDPA API.\n+    \"\"\"\n+\n+    # Adapted from MimiAttention.forward\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        if output_attentions:\n+            # TODO: Improve this warning with e.g. `model.config.attn_implementation = \"manual\"` once this is implemented.\n+            logger.warning_once(\n+                \"MimiModel is using MimiSdpaAttention, but `torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. Falling back to the manual attention implementation, \"\n+                'but specifying the manual implementation will be required from Transformers version v5.0.0 onwards. This warning can be removed using the argument `attn_implementation=\"eager\"` when loading the model.'\n+            )\n+            return super().forward(\n+                hidden_states=hidden_states,\n+                attention_mask=attention_mask,\n+                position_ids=position_ids,\n+                past_key_value=past_key_value,\n+                output_attentions=output_attentions,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+            )\n+\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+\n+        cos, sin = self.rotary_emb(value_states, position_ids)\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        key_states = repeat_kv(key_states, self.num_key_value_groups)\n+        value_states = repeat_kv(value_states, self.num_key_value_groups)\n+\n+        causal_mask = attention_mask\n+        if attention_mask is not None:\n+            causal_mask = causal_mask[:, :, :, : key_states.shape[-2]]\n+\n+        # SDPA with memory-efficient backend is currently (torch==2.1.2) bugged with non-contiguous inputs with custom attn_mask,\n+        # Reference: https://github.com/pytorch/pytorch/issues/112577.\n+        if query_states.device.type == \"cuda\" and causal_mask is not None:\n+            query_states = query_states.contiguous()\n+            key_states = key_states.contiguous()\n+            value_states = value_states.contiguous()\n+\n+        # We dispatch to SDPA's Flash Attention or Efficient kernels via this `is_causal` if statement instead of an inline conditional assignment\n+        # in SDPA to support both torch.compile's dynamic shapes and full graph options. An inline conditional prevents dynamic shapes from compiling.\n+        is_causal = True if causal_mask is None and q_len > 1 else False\n+\n+        attn_output = torch.nn.functional.scaled_dot_product_attention(\n+            query_states,\n+            key_states,\n+            value_states,\n+            attn_mask=causal_mask,\n+            dropout_p=self.attention_dropout if self.training else 0.0,\n+            is_causal=is_causal,\n+        )\n+\n+        attn_output = attn_output.transpose(1, 2).contiguous()\n+        attn_output = attn_output.view(bsz, q_len, -1)\n+\n+        attn_output = self.o_proj(attn_output)\n+\n+        return attn_output, None, past_key_value\n+\n+\n+MIMI_ATTENTION_CLASSES = {\n+    \"eager\": MimiAttention,\n+    \"flash_attention_2\": MimiFlashAttention2,\n+    \"sdpa\": MimiSdpaAttention,\n+}\n+\n+\n+class MimiTransformerLayer(nn.Module):\n+    def __init__(self, config: MimiConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        self.self_attn = MIMI_ATTENTION_CLASSES[config._attn_implementation](config=config, layer_idx=layer_idx)\n+\n+        self.mlp = MimiMLP(config)\n+        self.input_layernorm = nn.LayerNorm(config.hidden_size, eps=config.norm_eps)\n+        self.post_attention_layernorm = nn.LayerNorm(config.hidden_size, eps=config.norm_eps)\n+        self.self_attn_layer_scale = MimiLayerScale(config)\n+        self.mlp_layer_scale = MimiLayerScale(config)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: Optional[bool] = False,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> Tuple[torch.FloatTensor, Optional[Tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.FloatTensor`): input to the layer of shape `(batch, seq_len, embed_dim)`\n+            attention_mask (`torch.FloatTensor`, *optional*):\n+                attention mask of size `(batch_size, sequence_length)` if flash attention is used or `(batch_size, 1,\n+                query_sequence_length, key_sequence_length)` if default attention is used.\n+            output_attentions (`bool`, *optional*):\n+                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n+                returned tensors for more detail.\n+            use_cache (`bool`, *optional*):\n+                If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding\n+                (see `past_key_values`).\n+            past_key_value (`Tuple(torch.FloatTensor)`, *optional*): cached past key and value projection states\n+            cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n+                Indices depicting the position of the input sequence tokens in the sequence\n+            kwargs (`dict`, *optional*):\n+                Arbitrary kwargs to be ignored, used for FSDP and other methods that injects code\n+                into the model\n+        \"\"\"\n+        residual = hidden_states\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # Self Attention\n+        hidden_states, self_attn_weights, present_key_value = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = residual + self.self_attn_layer_scale(hidden_states)\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + self.mlp_layer_scale(hidden_states)\n+\n+        outputs = (hidden_states,)\n+\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        if use_cache:\n+            outputs += (present_key_value,)\n+\n+        return outputs\n+\n+\n+class MimiTransformerModel(nn.Module):\n+    \"\"\"\n+    Transformer decoder consisting of *config.num_hidden_layers* layers. Each layer is a [`MimiTransformerLayer`]\n+\n+    Args:\n+        config: MimiConfig\n+    \"\"\"\n+\n+    def __init__(self, config: MimiConfig):\n+        super().__init__()\n+\n+        self.layers = nn.ModuleList(\n+            [MimiTransformerLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self._attn_implementation = config._attn_implementation\n+\n+        self.gradient_checkpointing = False\n+        self.config = config\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+    ) -> Union[Tuple, BaseModelOutputWithPast]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n+                Embedded representation that will be contextualized by the model\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+\n+                [What are attention masks?](../glossary#attention-mask)\n+\n+                Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+                [`PreTrainedTokenizer.__call__`] for details.\n+\n+                If `past_key_values` is used, optionally only the last `decoder_input_ids` have to be input (see\n+                `past_key_values`).\n+\n+                If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n+                and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n+                information on the default strategy.\n+\n+                - 1 indicates the head is **not masked**,\n+                - 0 indicates the head is **masked**.\n+            position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n+                config.n_positions - 1]`.\n+\n+                [What are position IDs?](../glossary#position-ids)\n+            past_key_values (`Cache` or `tuple(tuple(torch.FloatTensor))`, *optional*):\n+                Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n+                blocks) that can be used to speed up sequential decoding. This typically consists in the `past_key_values`\n+                returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n+\n+                Two formats are allowed:\n+                - a [`~cache_utils.Cache`] instance;\n+                - Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of\n+                shape `(batch_size, num_heads, sequence_length, embed_size_per_head)`). This is also known as the legacy\n+                cache format.\n+\n+                The model will output the same cache format that is fed as input. If no `past_key_values` are passed, the\n+                legacy cache format will be returned.\n+\n+                If `past_key_values` are used, the user can optionally input only the last `input_ids` (those that don't\n+                have their past key value states given to this model) of shape `(batch_size, 1)` instead of all `input_ids`\n+                of shape `(batch_size, sequence_length)`.\n+            use_cache (`bool`, *optional*):\n+                If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n+                `past_key_values`).\n+            output_attentions (`bool`, *optional*):\n+                Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+                tensors for more detail.\n+            output_hidden_states (`bool`, *optional*):\n+                Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+                more detail.\n+            return_dict (`bool`, *optional*):\n+                Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+        \"\"\"\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        if self.gradient_checkpointing and self.training and use_cache:\n+            logger.warning_once(\n+                \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`.\"\n+            )\n+            use_cache = False\n+\n+        if use_cache and past_key_values is None and not self.training:\n+            past_key_values = DynamicCache.from_legacy_cache(past_key_values)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + hidden_states.shape[1], device=hidden_states.device\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        causal_mask = None\n+        if attention_mask is not None:\n+            causal_mask = self._update_causal_mask(\n+                attention_mask, hidden_states, cache_position, past_key_values, output_attentions\n+            )\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+        next_decoder_cache = None\n+\n+        for decoder_layer in self.layers:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            if self.gradient_checkpointing and self.training:\n+                layer_outputs = self._gradient_checkpointing_func(\n+                    decoder_layer.__call__,\n+                    hidden_states,\n+                    causal_mask,\n+                    position_ids,\n+                    past_key_values,\n+                    output_attentions,\n+                    use_cache,\n+                    cache_position,\n+                )\n+            else:\n+                layer_outputs = decoder_layer(\n+                    hidden_states,\n+                    attention_mask=causal_mask,\n+                    position_ids=position_ids,\n+                    past_key_value=past_key_values,\n+                    output_attentions=output_attentions,\n+                    use_cache=use_cache,\n+                    cache_position=cache_position,\n+                )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if use_cache:\n+                next_decoder_cache = layer_outputs[2 if output_attentions else 1]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+        # add hidden states from the last decoder layer\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        next_cache = next_decoder_cache if use_cache else None\n+\n+        if not return_dict:\n+            return tuple(v for v in [hidden_states, next_cache, all_hidden_states, all_self_attns] if v is not None)\n+\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=next_cache,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+        )\n+\n+    # Copied from transformers.models.gemma.modeling_gemma.GemmaModel._update_causal_mask\n+    def _update_causal_mask(\n+        self,\n+        attention_mask: torch.Tensor,\n+        input_tensor: torch.Tensor,\n+        cache_position: torch.Tensor,\n+        past_key_values: Cache,\n+        output_attentions: bool,\n+    ):\n+        if self.config._attn_implementation == \"flash_attention_2\":\n+            if attention_mask is not None and 0.0 in attention_mask:\n+                return attention_mask\n+            return None\n+\n+        # For SDPA, when possible, we will rely on its `is_causal` argument instead of its `attn_mask` argument, in\n+        # order to dispatch on Flash Attention 2. This feature is not compatible with static cache, as SDPA will fail\n+        # to infer the attention mask.\n+        past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+        using_static_cache = isinstance(past_key_values, StaticCache)\n+\n+        # When output attentions is True, sdpa implementation's forward method calls the eager implementation's forward\n+        if self.config._attn_implementation == \"sdpa\" and not using_static_cache and not output_attentions:\n+            if AttentionMaskConverter._ignore_causal_mask_sdpa(\n+                attention_mask,\n+                inputs_embeds=input_tensor,\n+                past_key_values_length=past_seen_tokens,\n+                is_training=self.training,\n+            ):\n+                return None\n+\n+        dtype, device = input_tensor.dtype, input_tensor.device\n+        min_dtype = torch.finfo(dtype).min\n+        sequence_length = input_tensor.shape[1]\n+        if using_static_cache:\n+            target_length = past_key_values.get_max_length()\n+        else:\n+            target_length = (\n+                attention_mask.shape[-1]\n+                if isinstance(attention_mask, torch.Tensor)\n+                else past_seen_tokens + sequence_length + 1\n+            )\n+\n+        # In case the provided `attention` mask is 2D, we generate a causal mask here (4D).\n+        causal_mask = _prepare_4d_causal_attention_mask_with_cache_position(\n+            attention_mask,\n+            sequence_length=sequence_length,\n+            target_length=target_length,\n+            dtype=dtype,\n+            device=device,\n+            min_dtype=min_dtype,\n+            cache_position=cache_position,\n+            batch_size=input_tensor.shape[0],\n+        )\n+        if (\n+            self.config._attn_implementation == \"sdpa\"\n+            and attention_mask is not None\n+            and attention_mask.device.type == \"cuda\"\n+            and not output_attentions\n+        ):\n+            # Attend to all tokens in fully masked rows in the causal_mask, for example the relevant first rows when\n+            # using left padding. This is required by F.scaled_dot_product_attention memory-efficient attention path.\n+            # Details: https://github.com/pytorch/pytorch/issues/110213\n+            causal_mask = AttentionMaskConverter._unmask_unattended(causal_mask, min_dtype)\n+\n+        return causal_mask\n+\n+\n+class MimiDecoder(nn.Module):\n+    \"\"\"SEANet decoder as used by Mimi.\"\"\"\n+\n+    def __init__(self, config: MimiConfig):\n+        super().__init__()\n+        scaling = int(2 ** len(config.upsampling_ratios))\n+        model = [MimiConv1d(config, config.hidden_size, scaling * config.num_filters, config.kernel_size)]\n+\n+        # Upsample to raw audio scale\n+        for ratio in config.upsampling_ratios:\n+            current_scale = scaling * config.num_filters\n+            # Add upsampling layers\n+            model += [nn.ELU()]\n+            model += [\n+                MimiConvTranspose1d(config, current_scale, current_scale // 2, kernel_size=ratio * 2, stride=ratio)\n+            ]\n+            # Add residual layers\n+            for j in range(config.num_residual_layers):\n+                model += [MimiResnetBlock(config, current_scale // 2, (config.dilation_growth_rate**j, 1))]\n+            scaling //= 2\n+\n+        # Add final layers\n+        model += [nn.ELU()]\n+        model += [MimiConv1d(config, config.num_filters, config.audio_channels, config.last_kernel_size)]\n+        self.layers = nn.ModuleList(model)\n+\n+    # Copied from transformers.models.encodec.modeling_encodec.EncodecDecoder.forward\n+    def forward(self, hidden_states):\n+        for layer in self.layers:\n+            hidden_states = layer(hidden_states)\n+        return hidden_states\n+\n+\n+class MimiEuclideanCodebook(nn.Module):\n+    \"\"\"Codebook with Euclidean distance.\"\"\"\n+\n+    def __init__(self, config: MimiConfig, epsilon: float = 1e-5):\n+        super().__init__()\n+        embed = torch.zeros(config.codebook_size, config.codebook_dim)\n+\n+        self.codebook_size = config.codebook_size\n+\n+        self.register_buffer(\"initialized\", torch.Tensor([True]))\n+        self.register_buffer(\"cluster_usage\", torch.ones(config.codebook_size))\n+        self.register_buffer(\"embed_sum\", embed)\n+        self._embed = None\n+        self.epsilon = epsilon\n+\n+    @property\n+    def embed(self) -> torch.Tensor:\n+        if self._embed is None:\n+            self._embed = self.embed_sum / self.cluster_usage.clamp(min=self.epsilon)[:, None]\n+        return self._embed\n+\n+    def quantize(self, hidden_states):\n+        # Projects each vector in `hidden_states` over the nearest centroid and return its index.\n+        # `hidden_states` should be `[N, D]` with `N` the number of input vectors and `D` the dimension.\n+        dists = torch.cdist(hidden_states[None], self.embed[None], p=2)[0]\n+        embed_ind = dists.argmin(dim=-1)\n+        return embed_ind\n+\n+    # Copied from transformers.models.encodec.modeling_encodec.EncodecEuclideanCodebook.encode\n+    def encode(self, hidden_states):\n+        shape = hidden_states.shape\n+        # pre-process\n+        hidden_states = hidden_states.reshape((-1, shape[-1]))\n+        # quantize\n+        embed_ind = self.quantize(hidden_states)\n+        # post-process\n+        embed_ind = embed_ind.view(*shape[:-1])\n+        return embed_ind\n+\n+    # Copied from transformers.models.encodec.modeling_encodec.EncodecEuclideanCodebook.decode\n+    def decode(self, embed_ind):\n+        quantize = nn.functional.embedding(embed_ind, self.embed)\n+        return quantize\n+\n+\n+# Copied from transformers.models.encodec.modeling_encodec.EncodecVectorQuantization with Encodec->Mimi\n+class MimiVectorQuantization(nn.Module):\n+    \"\"\"\n+    Vector quantization implementation. Currently supports only euclidean distance.\n+    \"\"\"\n+\n+    def __init__(self, config: MimiConfig):\n+        super().__init__()\n+        self.codebook = MimiEuclideanCodebook(config)\n+\n+    def encode(self, hidden_states):\n+        hidden_states = hidden_states.permute(0, 2, 1)\n+        embed_in = self.codebook.encode(hidden_states)\n+        return embed_in\n+\n+    def decode(self, embed_ind):\n+        quantize = self.codebook.decode(embed_ind)\n+        quantize = quantize.permute(0, 2, 1)\n+        return quantize\n+\n+\n+class MimiResidualVectorQuantizer(nn.Module):\n+    \"\"\"Residual Vector Quantizer.\"\"\"\n+\n+    def __init__(self, config: MimiConfig, num_quantizers: int = None):\n+        super().__init__()\n+        self.codebook_size = config.codebook_size\n+        self.frame_rate = config.frame_rate\n+        self.num_quantizers = num_quantizers if num_quantizers is not None else config.num_quantizers\n+        self.layers = nn.ModuleList([MimiVectorQuantization(config) for _ in range(self.num_quantizers)])\n+\n+        self.input_proj = None\n+        self.output_proj = None\n+        if config.vector_quantization_hidden_dimension != config.hidden_size:\n+            self.input_proj = torch.nn.Conv1d(\n+                config.hidden_size, config.vector_quantization_hidden_dimension, 1, bias=False\n+            )\n+            self.output_proj = torch.nn.Conv1d(\n+                config.vector_quantization_hidden_dimension, config.hidden_size, 1, bias=False\n+            )\n+\n+    def encode(self, embeddings: torch.Tensor, num_quantizers: Optional[int] = None) -> torch.Tensor:\n+        \"\"\"\n+        Encode a given input tensor with the specified frame rate at the given number of quantizers / codebooks. The RVQ encode method sets\n+        the appropriate number of quantizers to use and returns indices for each quantizer.\n+        \"\"\"\n+        if self.input_proj is not None:\n+            embeddings = self.input_proj(embeddings)\n+\n+        num_quantizers = num_quantizers if num_quantizers is not None else self.num_quantizers\n+\n+        residual = embeddings\n+        all_indices = []\n+        for layer in self.layers[:num_quantizers]:\n+            indices = layer.encode(residual)\n+            quantized = layer.decode(indices)\n+            residual = residual - quantized\n+            all_indices.append(indices)\n+        out_indices = torch.stack(all_indices)\n+        return out_indices\n+\n+    def decode(self, codes: torch.Tensor) -> torch.Tensor:\n+        \"\"\"Decode the given codes of shape [B, K, T] to the quantized representation.\"\"\"\n+        quantized_out = torch.tensor(0.0, device=codes.device)\n+        codes = codes.transpose(0, 1)\n+        for i, indices in enumerate(codes):\n+            layer = self.layers[i]\n+            quantized = layer.decode(indices)\n+            quantized_out = quantized_out + quantized\n+\n+        if self.output_proj is not None:\n+            quantized_out = self.output_proj(quantized_out)\n+        return quantized_out\n+\n+\n+class MimiSplitResidualVectorQuantizer(nn.Module):\n+    \"\"\"Split Residual Vector Quantizer.\"\"\"\n+\n+    def __init__(self, config: MimiConfig):\n+        super().__init__()\n+        self.codebook_size = config.codebook_size\n+        self.frame_rate = config.frame_rate\n+        self.max_num_quantizers = config.num_quantizers\n+\n+        self.num_semantic_quantizers = config.num_semantic_quantizers\n+        self.num_acoustic_quantizers = config.num_quantizers - config.num_semantic_quantizers\n+\n+        self.semantic_residual_vector_quantizer = MimiResidualVectorQuantizer(config, self.num_semantic_quantizers)\n+        self.acoustic_residual_vector_quantizer = MimiResidualVectorQuantizer(config, self.num_acoustic_quantizers)\n+\n+    def encode(self, embeddings: torch.Tensor, num_quantizers: Optional[float] = None) -> torch.Tensor:\n+        \"\"\"\n+        Encode a given input tensor with the specified frame rate at the given number of quantizers / codebooks. The RVQ encode method sets\n+        the appropriate number of quantizers to use and returns indices for each quantizer.\n+        \"\"\"\n+\n+        num_quantizers = self.max_num_quantizers if num_quantizers is None else num_quantizers\n+\n+        if num_quantizers > self.max_num_quantizers:\n+            raise ValueError(\n+                f\"The number of quantizers (i.e codebooks) asked should be lower than the total number of quantizers {self.max_num_quantizers}, but is currently {num_quantizers}.\"\n+            )\n+\n+        if num_quantizers < self.num_semantic_quantizers:\n+            raise ValueError(\n+                f\"The number of quantizers (i.e codebooks) asked should be higher than the number of semantic quantizers {self.num_semantic_quantizers}, but is currently {num_quantizers}.\"\n+            )\n+\n+        # codes is [K, B, T], with T frames, K nb of codebooks.\n+        codes = self.semantic_residual_vector_quantizer.encode(embeddings)\n+\n+        if num_quantizers > self.num_semantic_quantizers:\n+            acoustic_codes = self.acoustic_residual_vector_quantizer.encode(\n+                embeddings, num_quantizers=num_quantizers - self.num_semantic_quantizers\n+            )\n+            codes = torch.cat([codes, acoustic_codes], dim=0)\n+\n+        return codes\n+\n+    def decode(self, codes: torch.Tensor) -> torch.Tensor:\n+        \"\"\"Decode the given codes to the quantized representation.\"\"\"\n+\n+        # The first num_semantic_quantizers codebooks are decoded using the semantic RVQ\n+        quantized_out = self.semantic_residual_vector_quantizer.decode(codes[:, : self.num_semantic_quantizers])\n+\n+        # The rest of the codebooks are decoded using the acoustic RVQ\n+        if codes.shape[1] > self.num_semantic_quantizers:\n+            quantized_out += self.acoustic_residual_vector_quantizer.decode(codes[:, self.num_semantic_quantizers :])\n+        return quantized_out\n+\n+\n+class MimiPreTrainedModel(PreTrainedModel):\n+    \"\"\"\n+    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n+    models.\n+    \"\"\"\n+\n+    config_class = MimiConfig\n+    base_model_prefix = \"mimi\"\n+    main_input_name = \"input_values\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"MimiDecoderLayer\"]\n+    _skip_keys_device_placement = \"past_key_values\"\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = True\n+    _supports_cache_class = True\n+    _supports_static_cache = True\n+\n+    # Copied from transformers.models.encodec.modeling_encodec.EncodecPreTrainedModel._init_weights\n+    def _init_weights(self, module):\n+        \"\"\"Initialize the weights\"\"\"\n+        if isinstance(module, nn.Linear):\n+            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, (nn.LayerNorm, nn.GroupNorm)):\n+            module.bias.data.zero_()\n+            module.weight.data.fill_(1.0)\n+        elif isinstance(module, nn.Conv1d):\n+            nn.init.kaiming_normal_(module.weight)\n+            if module.bias is not None:\n+                k = math.sqrt(module.groups / (module.in_channels * module.kernel_size[0]))\n+                nn.init.uniform_(module.bias, a=-k, b=k)\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+        elif isinstance(module, nn.LSTM):\n+            for name, param in module.named_parameters():\n+                if \"weight\" in name:\n+                    nn.init.xavier_uniform_(param)\n+                elif \"bias\" in name:\n+                    nn.init.constant_(param, 0.0)\n+\n+\n+MIMI_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`MimiConfig`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+MIMI_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        input_values (`torch.FloatTensor` of shape `(batch_size, channels, sequence_length)`, *optional*):\n+            Raw audio input converted to Float.\n+        padding_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Indicates which inputs are to be ignored due to padding, where elements are either 1 for *not masked* or 0\n+            for *masked*.\n+        num_quantizers (`int`, *optional*):\n+            Number of quantizers (i.e codebooks) to use. By default, all quantizers are used.\n+        audio_codes (`torch.LongTensor`  of shape `(batch_size, num_quantizers, codes_length)`, *optional*):\n+            Discret code embeddings computed using `model.encode`.\n+        encoder_past_key_values (`Cache`, *optional*):\n+            Pre-computed hidden-states (key and values in the self-attention blocks) that can be used to speed up sequential decoding of the encoder transformer.\n+            This typically consists in the `past_key_values` returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n+\n+            The model will output the same cache format that is fed as input.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `audio_values` or `audio_codes (those that don't\n+            have their past key value states given to this model).\n+        decoder_past_key_values (`Cache`, *optional*):\n+            Pre-computed hidden-states (key and values in the self-attention blocks) that can be used to speed up sequential decoding of the decoder transformer.\n+            This typically consists in the `past_key_values` returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n+\n+            The model will output the same cache format that is fed as input.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `audio_values` or `audio_codes (those that don't\n+            have their past key value states given to this model).\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The Mimi neural audio codec model.\",\n+    MIMI_START_DOCSTRING,\n+)\n+class MimiModel(MimiPreTrainedModel):\n+    def __init__(self, config: MimiConfig):\n+        super().__init__(config)\n+        self.config = config\n+\n+        self.encoder = MimiEncoder(config)\n+        self.encoder_transformer = MimiTransformerModel(config)\n+\n+        self.downsample = None\n+        self.upsample = None\n+        if config.frame_rate != config.encodec_frame_rate:\n+            self.downsample = MimiConv1d(\n+                config,\n+                config.hidden_size,\n+                config.hidden_size,\n+                kernel_size=2 * int(config.encodec_frame_rate / config.frame_rate),\n+                stride=2,\n+                bias=False,\n+                pad_mode=\"replicate\",\n+            )\n+\n+            self.upsample = MimiConvTranspose1d(\n+                config,\n+                config.hidden_size,\n+                config.hidden_size,\n+                kernel_size=2 * int(config.encodec_frame_rate / config.frame_rate),\n+                stride=2,\n+                bias=False,\n+                groups=config.upsample_groups,\n+            )\n+\n+        self.decoder_transformer = MimiTransformerModel(config)\n+        self.decoder = MimiDecoder(config)\n+\n+        self.quantizer = MimiSplitResidualVectorQuantizer(config)\n+\n+        self.bits_per_codebook = int(math.log2(self.config.codebook_size))\n+        if 2**self.bits_per_codebook != self.config.codebook_size:\n+            raise ValueError(\"The codebook_size must be a power of 2.\")\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_encoder(self):\n+        return self.encoder\n+\n+    def get_decoder(self):\n+        return self.decoder\n+\n+    def _encode_frame(\n+        self,\n+        input_values: torch.Tensor,\n+        num_quantizers: int,\n+        padding_mask: int,\n+        past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor]]:\n+        \"\"\"\n+        Encodes the given input using the underlying VQVAE. The padding mask is required to compute the correct scale.\n+        \"\"\"\n+        embeddings = self.encoder(input_values)\n+        encoder_outputs = self.encoder_transformer(\n+            embeddings.transpose(1, 2), past_key_values=past_key_values, return_dict=return_dict\n+        )\n+        if return_dict:\n+            past_key_values = encoder_outputs.get(\"past_key_values\")\n+        elif len(encoder_outputs) > 1:\n+            past_key_values = encoder_outputs[1]\n+        embeddings = encoder_outputs[0].transpose(1, 2)\n+        embeddings = self.downsample(embeddings)\n+\n+        codes = self.quantizer.encode(embeddings, num_quantizers)\n+        codes = codes.transpose(0, 1)\n+        return codes, past_key_values\n+\n+    def encode(\n+        self,\n+        input_values: torch.Tensor,\n+        padding_mask: torch.Tensor = None,\n+        num_quantizers: Optional[float] = None,\n+        encoder_past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Union[Tuple[torch.Tensor, Optional[torch.Tensor]], MimiEncoderOutput]:\n+        \"\"\"\n+        Encodes the input audio waveform into discrete codes.\n+\n+        Args:\n+            input_values (`torch.Tensor` of shape `(batch_size, channels, sequence_length)`):\n+                Float values of the input audio waveform.\n+            padding_mask (`torch.Tensor` of shape `(batch_size, channels, sequence_length)`):\n+                Indicates which inputs are to be ignored due to padding, where elements are either 1 for *not masked* or 0\n+                for *masked*.\n+            num_quantizers (`int`, *optional*):\n+                Number of quantizers (i.e codebooks) to use. By default, all quantizers are used.\n+            encoder_past_key_values (`Cache`, *optional*):\n+                Pre-computed hidden-states (key and values in the self-attention blocks) that can be used to speed up sequential decoding of the encoder transformer.\n+                This typically consists in the `past_key_values` returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n+\n+                The model will output the same cache format that is fed as input.\n+\n+                If `past_key_values` are used, the user can optionally input only the last `audio_values` or `audio_codes (those that don't\n+                have their past key value states given to this model).\n+            return_dict (`bool`, *optional*):\n+                Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+\n+        Returns:\n+            `codebook` of shape `[batch_size, num_codebooks, frames]`, the discrete encoded codes for the input audio waveform.\n+        \"\"\"\n+        return_dict = return_dict if return_dict is not None else self.config.return_dict\n+\n+        num_quantizers = self.config.num_quantizers if num_quantizers is None else num_quantizers\n+\n+        if num_quantizers > self.config.num_quantizers:\n+            raise ValueError(\n+                f\"The number of quantizers (i.e codebooks) asked should be lower than the total number of quantizers {self.config.num_quantizers}, but is currently {num_quantizers}.\"\n+            )\n+\n+        _, channels, input_length = input_values.shape\n+\n+        if channels < 1 or channels > 2:\n+            raise ValueError(f\"Number of audio channels must be 1 or 2, but got {channels}\")\n+\n+        if padding_mask is None:\n+            padding_mask = torch.ones_like(input_values).bool()\n+\n+        encoded_frames, encoder_past_key_values = self._encode_frame(\n+            input_values,\n+            num_quantizers,\n+            padding_mask.bool(),\n+            past_key_values=encoder_past_key_values,\n+            return_dict=return_dict,\n+        )\n+\n+        if not return_dict:\n+            return (\n+                encoded_frames,\n+                encoder_past_key_values,\n+            )\n+\n+        return MimiEncoderOutput(encoded_frames, encoder_past_key_values)\n+\n+    def _decode_frame(\n+        self,\n+        codes: torch.Tensor,\n+        past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> torch.Tensor:\n+        embeddings = self.quantizer.decode(codes)\n+\n+        embeddings = self.upsample(embeddings)\n+        decoder_outputs = self.decoder_transformer(\n+            embeddings.transpose(1, 2), past_key_values=past_key_values, return_dict=return_dict\n+        )\n+        if return_dict:\n+            past_key_values = decoder_outputs.get(\"past_key_values\")\n+        elif len(decoder_outputs) > 1:\n+            past_key_values = decoder_outputs[1]\n+        embeddings = decoder_outputs[0].transpose(1, 2)\n+        outputs = self.decoder(embeddings)\n+        return outputs, past_key_values\n+\n+    def decode(\n+        self,\n+        audio_codes: torch.Tensor,\n+        padding_mask: Optional[torch.Tensor] = None,\n+        decoder_past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Union[Tuple[torch.Tensor, torch.Tensor], MimiDecoderOutput]:\n+        \"\"\"\n+        Decodes the given frames into an output audio waveform.\n+\n+        Note that the output might be a bit bigger than the input. In that case, any extra steps at the end can be\n+        trimmed.\n+\n+        Args:\n+            audio_codes (`torch.LongTensor`  of shape `(batch_size, num_quantizers, codes_length)`, *optional*):\n+                Discret code embeddings computed using `model.encode`.\n+            padding_mask (`torch.Tensor` of shape `(batch_size, channels, sequence_length)`):\n+                Indicates which inputs are to be ignored due to padding, where elements are either 1 for *not masked* or 0\n+                for *masked*.\n+            decoder_past_key_values (`Cache`, *optional*):\n+                Pre-computed hidden-states (key and values in the self-attention blocks) that can be used to speed up sequential decoding of the decoder transformer.\n+                This typically consists in the `past_key_values` returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n+\n+                The model will output the same cache format that is fed as input.\n+\n+                If `past_key_values` are used, the user can optionally input only the last `audio_values` or `audio_codes (those that don't\n+                have their past key value states given to this model).\n+            return_dict (`bool`, *optional*):\n+                Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+\n+        \"\"\"\n+        return_dict = return_dict if return_dict is not None else self.config.return_dict\n+\n+        audio_values, decoder_past_key_values = self._decode_frame(\n+            audio_codes, past_key_values=decoder_past_key_values, return_dict=return_dict\n+        )\n+\n+        # truncate based on padding mask\n+        if padding_mask is not None and padding_mask.shape[-1] < audio_values.shape[-1]:\n+            audio_values = audio_values[..., : padding_mask.shape[-1]]\n+\n+        if not return_dict:\n+            return (\n+                audio_values,\n+                decoder_past_key_values,\n+            )\n+        return MimiDecoderOutput(audio_values, decoder_past_key_values)\n+\n+    @add_start_docstrings_to_model_forward(MIMI_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=MimiOutput, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_values: torch.Tensor,\n+        padding_mask: Optional[torch.Tensor] = None,\n+        num_quantizers: Optional[int] = None,\n+        audio_codes: Optional[torch.Tensor] = None,\n+        encoder_past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None,\n+        decoder_past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Union[Tuple[torch.Tensor, torch.Tensor], MimiOutput]:\n+        r\"\"\"\n+        Returns:\n+\n+        Examples:\n+\n+        ```python\n+        >>> from datasets import load_dataset\n+        >>> from transformers import AutoFeatureExtractor, MimiModel\n+\n+        >>> dataset = load_dataset(\"hf-internal-testing/ashraq-esc50-1-dog-example\")\n+        >>> audio_sample = dataset[\"train\"][\"audio\"][0][\"array\"]\n+\n+        >>> model_id = \"kyutai/mimi\"\n+        >>> model = MimiModel.from_pretrained(model_id)\n+        >>> feature_extractor = AutoFeatureExtractor.from_pretrained(model_id)\n+\n+        >>> inputs = feature_extractor(raw_audio=audio_sample, return_tensors=\"pt\")\n+\n+        >>> outputs = model(**inputs)\n+        >>> audio_codes = outputs.audio_codes\n+        >>> audio_values = outputs.audio_values\n+        ```\"\"\"\n+        return_dict = return_dict if return_dict is not None else self.config.return_dict\n+\n+        if padding_mask is None:\n+            padding_mask = torch.ones_like(input_values).bool()\n+\n+        if audio_codes is None:\n+            encoder_outputs = self.encode(\n+                input_values, padding_mask, num_quantizers, encoder_past_key_values, return_dict=return_dict\n+            )\n+            audio_codes = encoder_outputs[0]\n+            if return_dict:\n+                encoder_past_key_values = encoder_outputs.get(\"past_key_values\")\n+            elif len(encoder_outputs) > 1:\n+                encoder_past_key_values = encoder_outputs[1]\n+\n+        decoder_outputs = self.decode(audio_codes, padding_mask, decoder_past_key_values, return_dict=return_dict)\n+        audio_values = decoder_outputs[0]\n+        if return_dict:\n+            decoder_past_key_values = decoder_outputs.get(\"past_key_values\")\n+        elif len(decoder_outputs) > 1:\n+            decoder_past_key_values = decoder_outputs[1]\n+\n+        if not return_dict:\n+            return (audio_codes, audio_values, encoder_past_key_values, decoder_past_key_values)\n+\n+        return MimiOutput(\n+            audio_codes=audio_codes,\n+            audio_values=audio_values,\n+            encoder_past_key_values=encoder_past_key_values,\n+            decoder_past_key_values=decoder_past_key_values,\n+        )"
        },
        {
            "sha": "5f8ae6b5fbffacb0558bfe29b6527887d52f4059",
            "filename": "src/transformers/utils/dummy_pt_objects.py",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -5840,6 +5840,20 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torch\"])\n \n \n+class MimiModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class MimiPreTrainedModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n class MistralForCausalLM(metaclass=DummyObject):\n     _backends = [\"torch\"]\n "
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/mimi/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/tests%2Fmodels%2Fmimi%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/tests%2Fmodels%2Fmimi%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmimi%2F__init__.py?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7"
        },
        {
            "sha": "dd0f77421be728d2d137038c98479fe439f0e267",
            "filename": "tests/models/mimi/test_modeling_mimi.py",
            "status": "added",
            "additions": 890,
            "deletions": 0,
            "changes": 890,
            "blob_url": "https://github.com/huggingface/transformers/blob/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/tests%2Fmodels%2Fmimi%2Ftest_modeling_mimi.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/5af7d41e49bbfc8319f462eb45253dcb3863dfb7/tests%2Fmodels%2Fmimi%2Ftest_modeling_mimi.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmimi%2Ftest_modeling_mimi.py?ref=5af7d41e49bbfc8319f462eb45253dcb3863dfb7",
            "patch": "@@ -0,0 +1,890 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch Mimi model.\"\"\"\n+\n+import inspect\n+import os\n+import tempfile\n+import unittest\n+\n+import numpy as np\n+from datasets import Audio, load_dataset\n+from packaging import version\n+from parameterized import parameterized\n+from pytest import mark\n+\n+from transformers import AutoFeatureExtractor, MimiConfig\n+from transformers.testing_utils import (\n+    is_flaky,\n+    is_torch_available,\n+    require_flash_attn,\n+    require_torch,\n+    require_torch_gpu,\n+    require_torch_sdpa,\n+    slow,\n+    torch_device,\n+)\n+from transformers.utils import (\n+    is_torch_bf16_available_on_device,\n+    is_torch_fp16_available_on_device,\n+)\n+\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import ModelTesterMixin, _config_zero_init, floats_tensor, ids_tensor\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import MimiModel\n+\n+\n+# Copied from transformers.tests.encodec.test_modeling_encodec.prepare_inputs_dict\n+def prepare_inputs_dict(\n+    config,\n+    input_ids=None,\n+    input_values=None,\n+    decoder_input_ids=None,\n+    attention_mask=None,\n+    decoder_attention_mask=None,\n+    head_mask=None,\n+    decoder_head_mask=None,\n+    cross_attn_head_mask=None,\n+):\n+    if input_ids is not None:\n+        encoder_dict = {\"input_ids\": input_ids}\n+    else:\n+        encoder_dict = {\"input_values\": input_values}\n+\n+    decoder_dict = {\"decoder_input_ids\": decoder_input_ids} if decoder_input_ids is not None else {}\n+\n+    return {**encoder_dict, **decoder_dict}\n+\n+\n+@require_torch\n+class MimiModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=5,\n+        num_channels=1,\n+        is_training=False,\n+        intermediate_size=40,\n+        hidden_size=32,\n+        num_filters=8,\n+        num_residual_layers=1,\n+        upsampling_ratios=[8, 4],\n+        codebook_size=64,\n+        vector_quantization_hidden_dimension=64,\n+        codebook_dim=64,\n+        upsample_groups=32,\n+        num_hidden_layers=2,\n+        num_attention_heads=2,\n+        num_key_value_heads=2,\n+        sliding_window=4,\n+        use_cache=False,\n+    ):\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.is_training = is_training\n+        self.intermediate_size = intermediate_size\n+        self.hidden_size = hidden_size\n+        self.num_filters = num_filters\n+        self.num_residual_layers = num_residual_layers\n+        self.upsampling_ratios = upsampling_ratios\n+        self.codebook_size = codebook_size\n+        self.vector_quantization_hidden_dimension = vector_quantization_hidden_dimension\n+        self.codebook_dim = codebook_dim\n+        self.upsample_groups = upsample_groups\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads\n+        self.sliding_window = sliding_window\n+        self.use_cache = use_cache\n+\n+    def prepare_config_and_inputs(self):\n+        input_values = floats_tensor([self.batch_size, self.num_channels, self.intermediate_size], scale=1.0)\n+        config = self.get_config()\n+        inputs_dict = {\"input_values\": input_values}\n+        return config, inputs_dict\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config, inputs_dict = self.prepare_config_and_inputs()\n+        return config, inputs_dict\n+\n+    def prepare_config_and_inputs_for_model_class(self, model_class):\n+        config, inputs_dict = self.prepare_config_and_inputs()\n+        inputs_dict[\"audio_codes\"] = ids_tensor([self.batch_size, 1, self.num_channels], self.codebook_size).type(\n+            torch.int32\n+        )\n+\n+        return config, inputs_dict\n+\n+    def get_config(self):\n+        return MimiConfig(\n+            audio_channels=self.num_channels,\n+            chunk_in_sec=None,\n+            hidden_size=self.hidden_size,\n+            num_filters=self.num_filters,\n+            num_residual_layers=self.num_residual_layers,\n+            upsampling_ratios=self.upsampling_ratios,\n+            codebook_size=self.codebook_size,\n+            vector_quantization_hidden_dimension=self.vector_quantization_hidden_dimension,\n+            upsample_groups=self.upsample_groups,\n+            num_hidden_layers=self.num_hidden_layers,\n+            num_attention_heads=self.num_attention_heads,\n+            num_key_value_heads=self.num_key_value_heads,\n+            sliding_window=self.sliding_window,\n+            codebook_dim=self.codebook_dim,\n+            use_cache=self.use_cache,\n+        )\n+\n+    def create_and_check_model_forward(self, config, inputs_dict):\n+        model = MimiModel(config=config).to(torch_device).eval()\n+\n+        input_values = inputs_dict[\"input_values\"]\n+        result = model(input_values)\n+        self.parent.assertEqual(\n+            result.audio_values.shape, (self.batch_size, self.num_channels, self.intermediate_size)\n+        )\n+\n+\n+@require_torch\n+class MimiModelTest(ModelTesterMixin, unittest.TestCase):\n+    all_model_classes = (MimiModel,) if is_torch_available() else ()\n+    is_encoder_decoder = True\n+    test_pruning = False\n+    test_headmasking = False\n+    test_resize_embeddings = False\n+    test_torchscript = False\n+    input_name = \"input_values\"\n+\n+    def _prepare_for_class(self, inputs_dict, model_class, return_labels=False):\n+        # model does support returning hidden states\n+        inputs_dict = super()._prepare_for_class(inputs_dict, model_class, return_labels=return_labels)\n+        if \"output_attentions\" in inputs_dict:\n+            inputs_dict.pop(\"output_attentions\")\n+        if \"output_hidden_states\" in inputs_dict:\n+            inputs_dict.pop(\"output_hidden_states\")\n+        return inputs_dict\n+\n+    def setUp(self):\n+        self.model_tester = MimiModelTester(self)\n+        self.config_tester = ConfigTester(\n+            self, config_class=MimiConfig, hidden_size=37, common_properties=[], has_text_modality=False\n+        )\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    def test_model_forward(self):\n+        config_and_inputs = self.model_tester.prepare_config_and_inputs()\n+        self.model_tester.create_and_check_model_forward(*config_and_inputs)\n+\n+    def test_forward_signature(self):\n+        config, _ = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            signature = inspect.signature(model.forward)\n+            # signature.parameters is an OrderedDict => so arg_names order is deterministic\n+            arg_names = [*signature.parameters.keys()]\n+\n+            expected_arg_names = [\"input_values\", \"padding_mask\", \"num_quantizers\"]\n+            self.assertListEqual(arg_names[: len(expected_arg_names)], expected_arg_names)\n+\n+    @unittest.skip(reason=\"The MimiModel does not have `inputs_embeds` logics\")\n+    def test_inputs_embeds(self):\n+        pass\n+\n+    @unittest.skip(reason=\"The MimiModel does not have `inputs_embeds` logics\")\n+    def test_model_get_set_embeddings(self):\n+        pass\n+\n+    @unittest.skip(reason=\"The MimiModel does not have the usual `attention` logic\")\n+    def test_retain_grad_hidden_states_attentions(self):\n+        pass\n+\n+    @unittest.skip(reason=\"The MimiModel does not have the usual `attention` logic\")\n+    def test_torchscript_output_attentions(self):\n+        pass\n+\n+    @unittest.skip(reason=\"The MimiModel does not have the usual `hidden_states` logic\")\n+    def test_torchscript_output_hidden_state(self):\n+        pass\n+\n+    # Copied from transformers.tests.encodec.test_modeling_encodec.MimiModelTest._create_and_check_torchscript\n+    def _create_and_check_torchscript(self, config, inputs_dict):\n+        if not self.test_torchscript:\n+            self.skipTest(reason=\"test_torchscript is set to False\")\n+\n+        configs_no_init = _config_zero_init(config)  # To be sure we have no Nan\n+        configs_no_init.torchscript = True\n+        configs_no_init.return_dict = False\n+        for model_class in self.all_model_classes:\n+            model = model_class(config=configs_no_init)\n+            model.to(torch_device)\n+            model.eval()\n+            inputs = self._prepare_for_class(inputs_dict, model_class)\n+\n+            main_input_name = model_class.main_input_name\n+\n+            try:\n+                main_input = inputs[main_input_name]\n+                model(main_input)\n+                traced_model = torch.jit.trace(model, main_input)\n+            except RuntimeError:\n+                self.fail(\"Couldn't trace module.\")\n+\n+            with tempfile.TemporaryDirectory() as tmp_dir_name:\n+                pt_file_name = os.path.join(tmp_dir_name, \"traced_model.pt\")\n+\n+                try:\n+                    torch.jit.save(traced_model, pt_file_name)\n+                except Exception:\n+                    self.fail(\"Couldn't save module.\")\n+\n+                try:\n+                    loaded_model = torch.jit.load(pt_file_name)\n+                except Exception:\n+                    self.fail(\"Couldn't load module.\")\n+\n+            model.to(torch_device)\n+            model.eval()\n+\n+            loaded_model.to(torch_device)\n+            loaded_model.eval()\n+\n+            model_state_dict = model.state_dict()\n+            loaded_model_state_dict = loaded_model.state_dict()\n+\n+            non_persistent_buffers = {}\n+            for key in loaded_model_state_dict.keys():\n+                if key not in model_state_dict.keys():\n+                    non_persistent_buffers[key] = loaded_model_state_dict[key]\n+\n+            loaded_model_state_dict = {\n+                key: value for key, value in loaded_model_state_dict.items() if key not in non_persistent_buffers\n+            }\n+\n+            self.assertEqual(set(model_state_dict.keys()), set(loaded_model_state_dict.keys()))\n+\n+            model_buffers = list(model.buffers())\n+            for non_persistent_buffer in non_persistent_buffers.values():\n+                found_buffer = False\n+                for i, model_buffer in enumerate(model_buffers):\n+                    if torch.equal(non_persistent_buffer, model_buffer):\n+                        found_buffer = True\n+                        break\n+\n+                self.assertTrue(found_buffer)\n+                model_buffers.pop(i)\n+\n+            model_buffers = list(model.buffers())\n+            for non_persistent_buffer in non_persistent_buffers.values():\n+                found_buffer = False\n+                for i, model_buffer in enumerate(model_buffers):\n+                    if torch.equal(non_persistent_buffer, model_buffer):\n+                        found_buffer = True\n+                        break\n+\n+                self.assertTrue(found_buffer)\n+                model_buffers.pop(i)\n+\n+            models_equal = True\n+            for layer_name, p1 in model_state_dict.items():\n+                if layer_name in loaded_model_state_dict:\n+                    p2 = loaded_model_state_dict[layer_name]\n+                    if p1.data.ne(p2.data).sum() > 0:\n+                        models_equal = False\n+\n+            self.assertTrue(models_equal)\n+\n+            # Avoid memory leak. Without this, each call increase RAM usage by ~20MB.\n+            # (Even with this call, there are still memory leak by ~0.04MB)\n+            self.clear_torch_jit_class_registry()\n+\n+    @unittest.skip(reason=\"The MimiModel does not have the usual `attention` logic\")\n+    def test_attention_outputs(self):\n+        pass\n+\n+    @unittest.skip(reason=\"The MimiModel does not have the usual `hidden_states` logic\")\n+    def test_hidden_states_output(self):\n+        pass\n+\n+    # Copied from transformers.tests.encodec.test_modeling_encodec.MimiModelTest.test_determinism\n+    def test_determinism(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        def check_determinism(first, second):\n+            # outputs are not tensors but list (since each sequence don't have the same frame_length)\n+            out_1 = first.cpu().numpy()\n+            out_2 = second.cpu().numpy()\n+            out_1 = out_1[~np.isnan(out_1)]\n+            out_2 = out_2[~np.isnan(out_2)]\n+            max_diff = np.amax(np.abs(out_1 - out_2))\n+            self.assertLessEqual(max_diff, 1e-5)\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+            with torch.no_grad():\n+                first = model(**self._prepare_for_class(inputs_dict, model_class))[0]\n+                second = model(**self._prepare_for_class(inputs_dict, model_class))[0]\n+\n+            if isinstance(first, tuple) and isinstance(second, tuple):\n+                for tensor1, tensor2 in zip(first, second):\n+                    check_determinism(tensor1, tensor2)\n+            else:\n+                check_determinism(first, second)\n+\n+    # Copied from transformers.tests.encodec.test_modeling_encodec.MimiModelTest.test_model_outputs_equivalence\n+    def test_model_outputs_equivalence(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        def set_nan_tensor_to_zero(t):\n+            t[t != t] = 0\n+            return t\n+\n+        def check_equivalence(model, tuple_inputs, dict_inputs, additional_kwargs={}):\n+            with torch.no_grad():\n+                tuple_output = model(**tuple_inputs, return_dict=False, **additional_kwargs)\n+                dict_output = model(**dict_inputs, return_dict=True, **additional_kwargs)\n+\n+                self.assertTrue(isinstance(tuple_output, tuple))\n+                self.assertTrue(isinstance(dict_output, dict))\n+\n+                for tuple_value, dict_value in zip(tuple_output, dict_output.values()):\n+                    self.assertTrue(\n+                        torch.allclose(\n+                            set_nan_tensor_to_zero(tuple_value), set_nan_tensor_to_zero(dict_value), atol=1e-5\n+                        ),\n+                        msg=(\n+                            \"Tuple and dict output are not equal. Difference:\"\n+                            f\" {torch.max(torch.abs(tuple_value - dict_value))}. Tuple has `nan`:\"\n+                            f\" {torch.isnan(tuple_value).any()} and `inf`: {torch.isinf(tuple_value)}. Dict has\"\n+                            f\" `nan`: {torch.isnan(dict_value).any()} and `inf`: {torch.isinf(dict_value)}.\"\n+                        ),\n+                    )\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            tuple_inputs = self._prepare_for_class(inputs_dict, model_class)\n+            dict_inputs = self._prepare_for_class(inputs_dict, model_class)\n+            check_equivalence(model, tuple_inputs, dict_inputs)\n+\n+    def test_initialization(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        configs_no_init = _config_zero_init(config)\n+        for model_class in self.all_model_classes:\n+            model = model_class(config=configs_no_init)\n+            for name, param in model.named_parameters():\n+                uniform_init_parms = [\"conv\", \"input_proj\", \"output_proj\"]\n+                if param.requires_grad:\n+                    if any(x in name for x in uniform_init_parms):\n+                        self.assertTrue(\n+                            -1.0 <= ((param.data.mean() * 1e9).round() / 1e9).item() <= 1.0,\n+                            msg=f\"Parameter {name} of model {model_class} seems not properly initialized\",\n+                        )\n+\n+    # Copied from transformers.tests.encodec.test_modeling_encodec.MimiModelTest.test_identity_shortcut\n+    def test_identity_shortcut(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs()\n+        config.use_conv_shortcut = False\n+        self.model_tester.create_and_check_model_forward(config, inputs_dict)\n+\n+    @parameterized.expand([(\"float16\",), (\"bfloat16\",), (\"float32\",)])\n+    @require_torch_sdpa\n+    @slow\n+    def test_eager_matches_sdpa_inference(self, torch_dtype: str):\n+        if not self.has_attentions:\n+            self.skipTest(reason=\"Model architecture does not support attentions\")\n+\n+        if not self.all_model_classes[0]._supports_sdpa:\n+            self.skipTest(f\"{self.all_model_classes[0].__name__} does not support SDPA\")\n+\n+        if torch_dtype == \"float16\" and not is_torch_fp16_available_on_device(torch_device):\n+            self.skipTest(f\"float16 not supported on {torch_device} (on the specific device currently used)\")\n+\n+        if torch_dtype == \"bfloat16\" and not is_torch_bf16_available_on_device(torch_device):\n+            self.skipTest(\n+                f\"bfloat16 not supported on {torch_device} (on the specific device currently used, e.g. Nvidia T4 GPU)\"\n+            )\n+\n+        # Not sure whether it's fine to put torch.XXX in a decorator if torch is not available so hacking it here instead.\n+        if torch_dtype == \"float16\":\n+            torch_dtype = torch.float16\n+        elif torch_dtype == \"bfloat16\":\n+            torch_dtype = torch.bfloat16\n+        elif torch_dtype == \"float32\":\n+            torch_dtype = torch.float32\n+\n+        atols = {\n+            (\"cpu\", False, torch.float32): 1e-6,\n+            (\"cpu\", False, torch.bfloat16): 1e-2,\n+            (\"cpu\", True, torch.float32): 1e-6,\n+            (\"cpu\", True, torch.bfloat16): 1e-2,\n+            (\"cuda\", False, torch.float32): 1e-6,\n+            (\"cuda\", False, torch.bfloat16): 1e-2,\n+            (\"cuda\", False, torch.float16): 5e-3,\n+            (\"cuda\", True, torch.float32): 1e-6,\n+            (\"cuda\", True, torch.bfloat16): 1e-2,\n+            (\"cuda\", True, torch.float16): 5e-3,\n+        }\n+        rtols = {\n+            (\"cpu\", False, torch.float32): 1e-4,\n+            (\"cpu\", False, torch.bfloat16): 1e-2,\n+            (\"cpu\", True, torch.float32): 1e-4,\n+            (\"cpu\", True, torch.bfloat16): 1e-2,\n+            (\"cuda\", False, torch.float32): 1e-4,\n+            (\"cuda\", False, torch.bfloat16): 1e-2,\n+            (\"cuda\", False, torch.float16): 5e-3,\n+            (\"cuda\", True, torch.float32): 1e-4,\n+            (\"cuda\", True, torch.bfloat16): 3e-2,\n+            (\"cuda\", True, torch.float16): 5e-3,\n+        }\n+\n+        def get_mean_reldiff(failcase, x, ref, atol, rtol):\n+            return f\"{failcase}: mean relative difference: {((x - ref).abs() / (ref.abs() + 1e-12)).mean():.3e}, torch atol = {atol}, torch rtol = {rtol}\"\n+\n+        for model_class in self.all_model_classes:\n+            config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+            model = model_class(config)\n+            # FIXME: we deactivate boolean mask for models using \"use_mask_token\" in their constructors.\n+            # These models support masking only in the case `use_mask_token=True`. Otherwise they cannot consume an input mask.\n+            # This means that the class needs to be instantiated much later, after `use_mask` is set, which means a significant refactor of the code.\n+            # However masking there is not done at any layers that matters (i.e self-attention), therefore we can safely deactivate it.\n+            deactivate_mask = \"use_mask_token\" in inspect.signature(model_class).parameters\n+\n+            is_encoder_decoder = model.config.is_encoder_decoder\n+\n+            with tempfile.TemporaryDirectory() as tmpdirname:\n+                model.save_pretrained(tmpdirname)\n+                model_sdpa = model_class.from_pretrained(tmpdirname, torch_dtype=torch_dtype)\n+                model_sdpa = model_sdpa.eval().to(torch_device)\n+\n+                self.assertTrue(model_sdpa.config._attn_implementation == \"sdpa\")\n+\n+                model_eager = model_class.from_pretrained(\n+                    tmpdirname,\n+                    torch_dtype=torch_dtype,\n+                    attn_implementation=\"eager\",\n+                )\n+                model_eager = model_eager.eval().to(torch_device)\n+\n+                self.assertTrue(model_eager.config._attn_implementation == \"eager\")\n+\n+                for name, submodule in model_eager.named_modules():\n+                    class_name = submodule.__class__.__name__\n+                    if \"SdpaAttention\" in class_name or \"SdpaSelfAttention\" in class_name:\n+                        raise ValueError(\"The eager model should not have SDPA attention layers\")\n+\n+                has_sdpa = False\n+                for name, submodule in model_sdpa.named_modules():\n+                    class_name = submodule.__class__.__name__\n+                    if \"SdpaAttention\" in class_name or \"SdpaSelfAttention\" in class_name:\n+                        has_sdpa = True\n+                        break\n+                if not has_sdpa and model_sdpa.config.model_type != \"falcon\":\n+                    raise ValueError(\"The SDPA model should have SDPA attention layers\")\n+\n+                # We use these for loops instead of parameterized.expand just for the interest of avoiding loading/saving 16 times the model,\n+                # but it would be nicer to have an efficient way to use parameterized.expand\n+                fail_cases = []\n+                for padding_side in [\"left\", \"right\"]:\n+                    for use_mask in [False, True]:\n+                        for output_attentions in [True, False]:\n+                            can_output_attn = \"output_attentions\" in inspect.signature(model_sdpa.forward).parameters\n+                            if not (self.has_attentions and can_output_attn) and output_attentions:\n+                                continue\n+                            for batch_size in [1, 5]:\n+                                dummy_input = inputs_dict[model.main_input_name]\n+\n+                                if dummy_input.dtype in [torch.float32, torch.bfloat16, torch.float16]:\n+                                    dummy_input = dummy_input.to(torch_dtype)\n+\n+                                dummy_input = dummy_input[:batch_size]\n+                                if dummy_input.shape[0] != batch_size:\n+                                    if dummy_input.dtype in [torch.float32, torch.bfloat16, torch.float16]:\n+                                        extension = torch.rand(\n+                                            batch_size - dummy_input.shape[0],\n+                                            *dummy_input.shape[1:],\n+                                            dtype=torch_dtype,\n+                                            device=torch_device,\n+                                        )\n+                                        dummy_input = torch.cat((dummy_input, extension), dim=0).to(torch_device)\n+                                    else:\n+                                        extension = torch.randint(\n+                                            high=5,\n+                                            size=(batch_size - dummy_input.shape[0], *dummy_input.shape[1:]),\n+                                            dtype=dummy_input.dtype,\n+                                            device=torch_device,\n+                                        )\n+                                        dummy_input = torch.cat((dummy_input, extension), dim=0).to(torch_device)\n+\n+                                if not use_mask:\n+                                    dummy_attention_mask = None\n+                                else:\n+                                    dummy_attention_mask = inputs_dict.get(\"attention_mask\", None)\n+                                    if dummy_attention_mask is None:\n+                                        if is_encoder_decoder:\n+                                            seqlen = inputs_dict.get(\"decoder_input_ids\", dummy_input).shape[-1]\n+                                        else:\n+                                            seqlen = dummy_input.shape[-1]\n+                                        dummy_attention_mask = (\n+                                            torch.ones(batch_size, seqlen).to(torch.int64).to(torch_device)\n+                                        )\n+\n+                                    dummy_attention_mask = dummy_attention_mask[:batch_size]\n+                                    if dummy_attention_mask.shape[0] != batch_size:\n+                                        extension = torch.ones(\n+                                            batch_size - dummy_attention_mask.shape[0],\n+                                            *dummy_attention_mask.shape[1:],\n+                                            dtype=dummy_attention_mask.dtype,\n+                                            device=torch_device,\n+                                        )\n+                                        dummy_attention_mask = torch.cat((dummy_attention_mask, extension), dim=0)\n+                                        dummy_attention_mask = dummy_attention_mask.to(torch_device)\n+\n+                                    dummy_attention_mask[:] = 1\n+                                    if padding_side == \"left\":\n+                                        dummy_attention_mask[-1, :-1] = 1\n+                                        dummy_attention_mask[-1, -4:] = 0\n+                                    elif padding_side == \"right\":\n+                                        dummy_attention_mask[-1, 1:] = 1\n+                                        dummy_attention_mask[-1, :3] = 0\n+\n+                                for enable_kernels in [False, True]:\n+                                    failcase = f\"padding_side={padding_side}, use_mask={use_mask}, batch_size={batch_size}, enable_kernels={enable_kernels}\"\n+                                    if is_encoder_decoder:\n+                                        decoder_input_ids = inputs_dict.get(\"decoder_input_ids\", dummy_input)[\n+                                            :batch_size\n+                                        ]\n+                                        if decoder_input_ids.shape[0] != batch_size:\n+                                            extension = torch.ones(\n+                                                batch_size - decoder_input_ids.shape[0],\n+                                                *decoder_input_ids.shape[1:],\n+                                                dtype=decoder_input_ids.dtype,\n+                                                device=torch_device,\n+                                            )\n+                                            decoder_input_ids = torch.cat((decoder_input_ids, extension), dim=0)\n+                                            decoder_input_ids = decoder_input_ids.to(torch_device)\n+\n+                                        # TODO: never an `attention_mask` arg here?\n+                                        processed_inputs = {\n+                                            model.main_input_name: dummy_input,\n+                                            \"decoder_input_ids\": decoder_input_ids,\n+                                            \"decoder_attention_mask\": dummy_attention_mask,\n+                                            \"output_hidden_states\": True,\n+                                        }\n+                                    else:\n+                                        processed_inputs = {\n+                                            model.main_input_name: dummy_input,\n+                                            \"output_hidden_states\": True,\n+                                        }\n+\n+                                        # Otherwise fails for e.g. WhisperEncoderModel\n+                                        if \"attention_mask\" in inspect.signature(model_eager.forward).parameters:\n+                                            processed_inputs[\"attention_mask\"] = dummy_attention_mask\n+\n+                                        if (\n+                                            self.has_attentions\n+                                            and \"output_attentions\" in inspect.signature(model_sdpa.forward).parameters\n+                                        ):\n+                                            processed_inputs[\"output_attentions\"] = output_attentions\n+                                    if not deactivate_mask and (\n+                                        \"bool_masked_pos\" in inspect.signature(model_eager.forward).parameters\n+                                    ):\n+                                        dummy_mask = torch.ones((self.model_tester.num_masks,))\n+\n+                                        # In case of additional token (like class) we define a custom `mask_length`\n+                                        if hasattr(self.model_tester, \"mask_length\"):\n+                                            mask_length = self.model_tester.mask_length - dummy_mask.size(0)\n+                                        else:\n+                                            mask_length = self.model_tester.seq_length - dummy_mask.size(0)\n+                                        dummy_mask = torch.cat([dummy_mask, torch.zeros(mask_length)])\n+                                        dummy_bool_masked_pos = dummy_mask.expand(batch_size, -1).bool()\n+                                        processed_inputs[\"bool_masked_pos\"] = dummy_bool_masked_pos.to(torch_device)\n+\n+                                    if \"noise\" in inspect.signature(model_eager.forward).parameters:\n+                                        np.random.seed(2)\n+                                        num_patches = int(\n+                                            (self.model_tester.image_size // self.model_tester.patch_size) ** 2\n+                                        )\n+                                        noise = np.random.uniform(size=(batch_size, num_patches))\n+                                        processed_inputs[\"noise\"] = torch.from_numpy(noise)\n+\n+                                    # TODO: test gradients as well (& for FA2 as well!)\n+                                    with torch.no_grad():\n+                                        with torch.backends.cuda.sdp_kernel(\n+                                            enable_flash=enable_kernels,\n+                                            enable_math=True,\n+                                            enable_mem_efficient=enable_kernels,\n+                                        ):\n+                                            prepared_inputs = self._prepare_for_class(processed_inputs, model_class)\n+                                            outputs_eager = model_eager(**prepared_inputs)\n+                                            outputs_sdpa = model_sdpa(**prepared_inputs)\n+\n+                                    # Ignore copy\n+                                    logits_eager = outputs_eager.audio_values\n+                                    # Ignore copy\n+                                    logits_sdpa = outputs_sdpa.audio_values\n+\n+                                    if torch_device in [\"cpu\", \"cuda\"]:\n+                                        atol = atols[torch_device, enable_kernels, torch_dtype]\n+                                        rtol = rtols[torch_device, enable_kernels, torch_dtype]\n+                                    else:\n+                                        atol = 1e-7\n+                                        rtol = 1e-4\n+\n+                                    # Masked tokens output slightly deviates - we don't mind that.\n+                                    if use_mask:\n+                                        if padding_side == \"left\":\n+                                            sub_sdpa = logits_sdpa[:-1]\n+                                            sub_eager = logits_eager[:-1]\n+                                            if not torch.allclose(sub_sdpa, sub_eager, atol=atol, rtol=rtol):\n+                                                fail_cases.append(\n+                                                    get_mean_reldiff(failcase, sub_sdpa, sub_eager, atol, rtol)\n+                                                )\n+\n+                                            sub_sdpa = logits_sdpa[-1, :-4]\n+                                            sub_eager = logits_eager[-1, :-4]\n+                                            if not torch.allclose(sub_sdpa, sub_eager, atol=atol, rtol=rtol):\n+                                                fail_cases.append(\n+                                                    get_mean_reldiff(failcase, sub_sdpa, sub_eager, atol, rtol)\n+                                                )\n+\n+                                            # Testing the padding tokens is not really meaningful but anyway\n+                                            # sub_sdpa = logits_sdpa[-1, -4:]\n+                                            # sub_eager = logits_eager[-1, -4:]\n+                                            # if not torch.allclose(sub_sdpa, sub_eager, atol=atol, rtol=rtol):\n+                                            #     fail_cases.append(get_mean_reldiff(failcase, sub_sdpa, sub_eager, 4e-2, 4e-2))\n+                                        elif padding_side == \"right\":\n+                                            sub_sdpa = logits_sdpa[:-1]\n+                                            sub_eager = logits_eager[:-1]\n+                                            if not torch.allclose(sub_sdpa, sub_eager, atol=atol, rtol=rtol):\n+                                                fail_cases.append(\n+                                                    get_mean_reldiff(failcase, sub_sdpa, sub_eager, atol, rtol)\n+                                                )\n+\n+                                            sub_sdpa = logits_sdpa[-1, 3:]\n+                                            sub_eager = logits_eager[-1, 3:]\n+                                            if not torch.allclose(sub_sdpa, sub_eager, atol=atol, rtol=rtol):\n+                                                fail_cases.append(\n+                                                    get_mean_reldiff(failcase, sub_sdpa, sub_eager, atol, rtol)\n+                                                )\n+\n+                                            # Testing the padding tokens is not really meaningful but anyway\n+                                            # sub_sdpa = logits_sdpa[-1, :3]\n+                                            # sub_eager = logits_eager[-1, :3]\n+                                            # if not torch.allclose(sub_sdpa, sub_eager, atol=atol, rtol=rtol):\n+                                            #     fail_cases.append(get_mean_reldiff(failcase, sub_sdpa, sub_eager, 4e-2, 4e-2))\n+\n+                                    else:\n+                                        if not torch.allclose(logits_sdpa, logits_eager, atol=atol, rtol=rtol):\n+                                            fail_cases.append(\n+                                                get_mean_reldiff(failcase, logits_sdpa, logits_eager, atol, rtol)\n+                                            )\n+\n+                self.assertTrue(len(fail_cases) == 0, \"\\n\".join(fail_cases))\n+\n+    @require_flash_attn\n+    @require_torch_gpu\n+    @mark.flash_attn_test\n+    @slow\n+    @is_flaky()\n+    def test_flash_attn_2_inference_equivalence(self):\n+        for model_class in self.all_model_classes:\n+            config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+            model = model_class(config)\n+\n+            with tempfile.TemporaryDirectory() as tmpdirname:\n+                model.save_pretrained(tmpdirname)\n+                model_fa = model_class.from_pretrained(\n+                    tmpdirname, torch_dtype=torch.bfloat16, attn_implementation=\"flash_attention_2\"\n+                )\n+                model_fa.to(torch_device)\n+\n+                model = model_class.from_pretrained(tmpdirname, torch_dtype=torch.bfloat16)\n+                model.to(torch_device)\n+\n+                dummy_input = inputs_dict[model.main_input_name][:1]\n+                if dummy_input.dtype in [torch.float32, torch.float16]:\n+                    dummy_input = dummy_input.to(torch.bfloat16)\n+\n+                outputs = model(dummy_input)\n+                outputs_fa = model_fa(dummy_input)\n+\n+                logits = outputs[1]\n+                logits_fa = outputs_fa[1]\n+\n+                assert torch.allclose(logits_fa, logits, atol=4e-2, rtol=4e-2)\n+\n+    @unittest.skip(reason=\"The MimiModel does not support right padding\")\n+    def test_flash_attn_2_inference_equivalence_right_padding(self):\n+        pass\n+\n+    @unittest.skip(reason=\"The MimiModel does not have support dynamic compile yet\")\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n+    # For now, Let's focus only on GPU for `torch.compile`\n+    @slow\n+    @require_torch_gpu\n+    def test_torch_compile(self):\n+        if version.parse(torch.__version__) < version.parse(\"2.3\"):\n+            self.skipTest(reason=\"This test requires torch >= 2.3 to run.\")\n+\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        n_iter = 3\n+        for model_class in self.all_model_classes:\n+            model = model_class(config).to(torch_device)\n+            model.forward = torch.compile(model.forward)\n+            for i in range(n_iter):\n+                _ = model(inputs_dict[\"input_values\"].to(torch_device))\n+\n+    @is_flaky()\n+    def test_batching_equivalence(self):\n+        super().test_batching_equivalence()\n+\n+\n+# Copied from transformers.tests.encodec.test_modeling_encodec.normalize\n+def normalize(arr):\n+    norm = np.linalg.norm(arr)\n+    normalized_arr = arr / norm\n+    return normalized_arr\n+\n+\n+# Copied from transformers.tests.encodec.test_modeling_encodec.compute_rmse\n+def compute_rmse(arr1, arr2):\n+    arr1_normalized = normalize(arr1)\n+    arr2_normalized = normalize(arr2)\n+    return np.sqrt(((arr1_normalized - arr2_normalized) ** 2).mean())\n+\n+\n+@slow\n+@require_torch\n+class MimiIntegrationTest(unittest.TestCase):\n+    def test_integration_using_cache_decode(self):\n+        expected_rmse = {\n+            \"8\": 0.0018785292,\n+            \"32\": 0.0012330565,\n+        }\n+\n+        librispeech_dummy = load_dataset(\"hf-internal-testing/librispeech_asr_dummy\", \"clean\", split=\"validation\")\n+        model_id = \"kyutai/mimi\"\n+\n+        model = MimiModel.from_pretrained(model_id, use_cache=True).to(torch_device)\n+        processor = AutoFeatureExtractor.from_pretrained(model_id)\n+\n+        librispeech_dummy = librispeech_dummy.cast_column(\"audio\", Audio(sampling_rate=processor.sampling_rate))\n+        audio_sample = librispeech_dummy[-1][\"audio\"][\"array\"]\n+\n+        inputs = processor(\n+            raw_audio=audio_sample,\n+            sampling_rate=processor.sampling_rate,\n+            return_tensors=\"pt\",\n+        ).to(torch_device)\n+\n+        for num_codebooks, expected_rmse in expected_rmse.items():\n+            with torch.no_grad():\n+                # use max bandwith for best possible reconstruction\n+                encoder_outputs = model.encode(inputs[\"input_values\"], num_quantizers=int(num_codebooks))\n+\n+                audio_codes = encoder_outputs[0]\n+\n+                decoder_outputs_first_part = model.decode(audio_codes[:, :, : audio_codes.shape[2] // 2])\n+                decoder_outputs_second_part = model.decode(\n+                    audio_codes[:, :, audio_codes.shape[2] // 2 :],\n+                    decoder_past_key_values=decoder_outputs_first_part.decoder_past_key_values,\n+                )\n+\n+                audio_output_entire_context = model.decode(audio_codes)[0]\n+                audio_output_concat_context = torch.cat(\n+                    [decoder_outputs_first_part[0], decoder_outputs_second_part[0]], dim=2\n+                )\n+\n+            # make sure audios are more or less equal\n+            # the RMSE of two random gaussian noise vectors with ~N(0, 1) is around 1.0\n+            rmse = compute_rmse(\n+                audio_output_concat_context.squeeze().cpu().numpy(),\n+                audio_output_entire_context.squeeze().cpu().numpy(),\n+            )\n+            self.assertTrue(rmse < 1e-3)\n+\n+    def test_integration(self):\n+        expected_rmses = {\n+            \"8\": 0.0018785292,\n+            \"32\": 0.0012330565,\n+        }\n+        expected_codesums = {\n+            \"8\": 430423,\n+            \"32\": 1803071,\n+        }\n+        librispeech_dummy = load_dataset(\"hf-internal-testing/librispeech_asr_dummy\", \"clean\", split=\"validation\")\n+        model_id = \"kyutai/mimi\"\n+\n+        processor = AutoFeatureExtractor.from_pretrained(model_id)\n+\n+        librispeech_dummy = librispeech_dummy.cast_column(\"audio\", Audio(sampling_rate=processor.sampling_rate))\n+        audio_sample = librispeech_dummy[-1][\"audio\"][\"array\"]\n+\n+        inputs = processor(\n+            raw_audio=audio_sample,\n+            sampling_rate=processor.sampling_rate,\n+            return_tensors=\"pt\",\n+        ).to(torch_device)\n+\n+        for use_cache in [False, True]:\n+            model = MimiModel.from_pretrained(model_id, use_cache=use_cache).to(torch_device)\n+            for num_codebooks, expected_rmse in expected_rmses.items():\n+                with torch.no_grad():\n+                    # use max bandwith for best possible reconstruction\n+                    encoder_outputs = model.encode(inputs[\"input_values\"], num_quantizers=int(num_codebooks))\n+\n+                    audio_code_sums = encoder_outputs[0].sum().cpu().item()\n+\n+                    # make sure audio encoded codes are correct\n+                    # assert relative difference less than a threshold, because `audio_code_sums` varies a bit\n+                    # depending on torch version\n+                    self.assertTrue(\n+                        np.abs(audio_code_sums - expected_codesums[num_codebooks]) <= (3e-3 * audio_code_sums)\n+                    )\n+\n+                    input_values_dec = model.decode(encoder_outputs[0], padding_mask=inputs[\"padding_mask\"])[0]\n+                    input_values_enc_dec = model(\n+                        inputs[\"input_values\"], inputs[\"padding_mask\"], num_quantizers=int(num_codebooks)\n+                    )[1]\n+\n+                # make sure forward and decode gives same result\n+                self.assertTrue(torch.allclose(input_values_dec, input_values_enc_dec))\n+\n+                # make sure shape matches\n+                self.assertTrue(inputs[\"input_values\"].shape == input_values_enc_dec.shape)\n+\n+                arr = inputs[\"input_values\"][0].cpu().numpy()\n+                arr_enc_dec = input_values_enc_dec[0].cpu().numpy()\n+\n+                # make sure audios are more or less equal\n+                # the RMSE of two random gaussian noise vectors with ~N(0, 1) is around 1.0\n+                rmse = compute_rmse(arr, arr_enc_dec)\n+                self.assertTrue(np.abs(rmse - expected_rmse) < 1e-5)"
        }
    ],
    "stats": {
        "total": 3208,
        "additions": 3208,
        "deletions": 0
    }
}