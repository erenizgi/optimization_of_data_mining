{
    "author": "apoorvkh",
    "message": "Adding `optimizer_cls_and_kwargs` to `Trainer.__init__` (#34358)\n\n* Adding `optimizer_cls_and_kwargs` to `Trainer.__init__`\r\n\r\n* formatting\r\n\r\n* make fix-copies docstring\r\n\r\n* added more docs for optimizer_cls_and_kwargs\r\n\r\n* add docs for Trainer(optimizer_cls_and_kwargs)\r\n\r\n* reverting anchor names",
    "sha": "e9ad46049411624bb1b6e830fbc1138991c0135e",
    "files": [
        {
            "sha": "7bee3472892727ebde5cefa25e6bed6975bb2bc4",
            "filename": "docs/source/en/trainer.md",
            "status": "modified",
            "additions": 67,
            "deletions": 39,
            "changes": 106,
            "blob_url": "https://github.com/huggingface/transformers/blob/e9ad46049411624bb1b6e830fbc1138991c0135e/docs%2Fsource%2Fen%2Ftrainer.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/e9ad46049411624bb1b6e830fbc1138991c0135e/docs%2Fsource%2Fen%2Ftrainer.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Ftrainer.md?ref=e9ad46049411624bb1b6e830fbc1138991c0135e",
            "patch": "@@ -252,7 +252,70 @@ trainer = Trainer(..., args=training_args)\n \n NEFTune is disabled after training to restore the original embedding layer to avoid any unexpected behavior.\n \n-## GaLore\n+## Liger Kernel\n+\n+[Liger-Kernel](https://github.com/linkedin/Liger-Kernel) Kernel is a collection of Triton kernels developed by Linkedin designed specifically for LLM training. We have implemented Hugging Face Compatible RMSNorm, RoPE, SwiGLU, CrossEntropy, FusedLinearCrossEntropy, and more to come. It can effectively increase multi-GPU training throughput by 20% and reduces memory usage by 60%. The kernel works out of the box with flash attention, PyTorch FSDP, and Microsoft DeepSpeed.\n+\n+<Tip>\n+Gain +20% throughput and reduce memory usage by 60% on LLaMA 3-8B model training. Achieve longer context lengths and larger batch sizes. It’s also useful if you want to scale up your model to multi-head training or large vocabulary sizes. Unleash multi-head training (medusa) and more. See details and examples in [Liger](https://github.com/linkedin/Liger-Kernel/tree/main/examples)\n+</Tip>\n+\n+First make sure to install Liger official repository:\n+```bash\n+pip install liger-kernel\n+```\n+\n+You should pass `use_liger_kernel=True` to apply liger kernel on your model, for example:\n+\n+```py\n+from transformers import TrainingArguments\n+\n+training_args = TrainingArguments(\n+    output_dir=\"your-model\",\n+    learning_rate=2e-5,\n+    per_device_train_batch_size=16,\n+    per_device_eval_batch_size=16,\n+    num_train_epochs=2,\n+    weight_decay=0.01,\n+    eval_strategy=\"epoch\",\n+    save_strategy=\"epoch\",\n+    load_best_model_at_end=True,\n+    push_to_hub=True,\n+    use_liger_kernel=True\n+)\n+```\n+\n+The kernel supports the Llama, Gemma, Mistral, and Mixtral model architectures. The most up-to-date list of supported models can be found [here](https://github.com/linkedin/Liger-Kernel). When `use_liger_kernel` is set to `True`, the corresponding layers in the original model will be patched with Liger's efficient implementation, so you don't need to do anything extra other than setting the argument value.\n+\n+\n+## Optimizers\n+\n+You can choose a built-in optimizer for training using:\n+\n+```python\n+from transformers import TrainingArguments\n+training_args = TrainingArguments(..., optim=\"adamw_torch\")\n+```\n+\n+See [`OptimizerNames`](https://github.com/huggingface/transformers/blob/main/src/transformers/training_args.py) for a full list of choices. We include advanced examples in the sections below.\n+\n+You can also use an arbitrary PyTorch optimizer via:\n+\n+```python\n+import torch\n+\n+optimizer_cls = torch.optim.AdamW\n+optimizer_kwargs = {\n+    \"lr\": 4e-3,\n+    \"betas\": (0.9, 0.999),\n+    \"weight_decay\": 0.05,\n+}\n+\n+from transformers import Trainer\n+trainer = Trainer(..., optimizer_cls_and_kwargs=(optimizer_cls, optimizer_kwargs))\n+```\n+\n+### GaLore\n \n Gradient Low-Rank Projection (GaLore) is a memory-efficient low-rank training strategy that allows full-parameter learning but is more memory-efficient than common low-rank adaptation methods, such as LoRA.\n \n@@ -382,42 +445,7 @@ trainer.train()\n \n Note layerwise optimization is a bit experimental and does not support DDP (Distributed Data Parallel), thus you can run the training script only on a single GPU. Please see [this appropriate section](https://github.com/jiaweizzhao/GaLore?tab=readme-ov-file#train-7b-model-with-a-single-gpu-with-24gb-memory) for more details. Other features such as gradient clipping, DeepSpeed, etc might not be supported out of the box. Please [raise an issue on GitHub](https://github.com/huggingface/transformers/issues) if you encounter such issue.\n \n-## Liger Kernel\n-\n-[Liger-Kernel](https://github.com/linkedin/Liger-Kernel) Kernel is a collection of Triton kernels developed by Linkedin designed specifically for LLM training. We have implemented Hugging Face Compatible RMSNorm, RoPE, SwiGLU, CrossEntropy, FusedLinearCrossEntropy, and more to come. It can effectively increase multi-GPU training throughput by 20% and reduces memory usage by 60%. The kernel works out of the box with flash attention, PyTorch FSDP, and Microsoft DeepSpeed.\n-\n-<Tip>\n-Gain +20% throughput and reduce memory usage by 60% on LLaMA 3-8B model training. Achieve longer context lengths and larger batch sizes. It’s also useful if you want to scale up your model to multi-head training or large vocabulary sizes. Unleash multi-head training (medusa) and more. See details and examples in [Liger](https://github.com/linkedin/Liger-Kernel/tree/main/examples)\n-</Tip>\n-\n-First make sure to install Liger official repository:\n-```bash\n-pip install liger-kernel\n-```\n-\n-You should pass `use_liger_kernel=True` to apply liger kernel on your model, for example:\n-\n-```py\n-from transformers import TrainingArguments\n-\n-training_args = TrainingArguments(\n-    output_dir=\"your-model\",\n-    learning_rate=2e-5,\n-    per_device_train_batch_size=16,\n-    per_device_eval_batch_size=16,\n-    num_train_epochs=2,\n-    weight_decay=0.01,\n-    eval_strategy=\"epoch\",\n-    save_strategy=\"epoch\",\n-    load_best_model_at_end=True,\n-    push_to_hub=True,\n-    use_liger_kernel=True\n-)\n-```\n-\n-The kernel supports the Llama, Gemma, Mistral, and Mixtral model architectures. The most up-to-date list of supported models can be found [here](https://github.com/linkedin/Liger-Kernel). When `use_liger_kernel` is set to `True`, the corresponding layers in the original model will be patched with Liger's efficient implementation, so you don't need to do anything extra other than setting the argument value.\n-\n-## LOMO optimizer\n+### LOMO optimizer\n \n The LOMO optimizers have been introduced in [Full Parameter Fine-Tuning for Large Language Models with Limited Resources](https://hf.co/papers/2306.09782) and [AdaLomo: Low-memory Optimization with Adaptive Learning Rate](https://hf.co/papers/2310.10195).\n They both consist of an efficient full-parameter fine-tuning method. These optimizers fuse the gradient computation and the parameter update in one step to reduce memory usage. Supported optimizers for LOMO are `\"lomo\"` and `\"adalomo\"`. First either install LOMO from pypi `pip install lomo-optim` or install it from source with `pip install git+https://github.com/OpenLMLab/LOMO.git`.\n@@ -467,7 +495,7 @@ trainer = trl.SFTTrainer(\n trainer.train()\n ```\n \n-## GrokAdamW optimizer\n+### GrokAdamW optimizer\n \n The GrokAdamW optimizer is designed to enhance training performance and stability, particularly for models that benefit from grokking signal functions. To use GrokAdamW, first install the optimizer package with `pip install grokadamw`.\n \n@@ -518,7 +546,7 @@ trainer.train()\n \n This script demonstrates how to fine-tune the `google/gemma-2b` model on the IMDB dataset using the GrokAdamW optimizer. The `TrainingArguments` are configured to use GrokAdamW, and the dataset is passed to the `Trainer` for training.\n \n-## Schedule Free Optimizer\n+### Schedule Free Optimizer\n \n The Schedule Free optimizers have been introduced in [The Road Less Scheduled](https://hf.co/papers/2405.15682).\n Schedule-Free learning replaces the momentum of the base optimizer with a combination of averaging and interpolation, to completely remove the need to anneal the learning rate with a traditional schedule."
        },
        {
            "sha": "e2ae622e2b6bf3b55197324de038809119d260a3",
            "filename": "src/transformers/trainer.py",
            "status": "modified",
            "additions": 15,
            "deletions": 3,
            "changes": 18,
            "blob_url": "https://github.com/huggingface/transformers/blob/e9ad46049411624bb1b6e830fbc1138991c0135e/src%2Ftransformers%2Ftrainer.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e9ad46049411624bb1b6e830fbc1138991c0135e/src%2Ftransformers%2Ftrainer.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Ftrainer.py?ref=e9ad46049411624bb1b6e830fbc1138991c0135e",
            "patch": "@@ -34,7 +34,7 @@\n import warnings\n from collections.abc import Mapping\n from pathlib import Path\n-from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Union\n+from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Tuple, Type, Union\n \n \n # Integrations must be imported before ML frameworks:\n@@ -358,6 +358,11 @@ class Trainer:\n         optimizers (`Tuple[torch.optim.Optimizer, torch.optim.lr_scheduler.LambdaLR]`, *optional*, defaults to `(None, None)`):\n             A tuple containing the optimizer and the scheduler to use. Will default to an instance of [`AdamW`] on your\n             model and a scheduler given by [`get_linear_schedule_with_warmup`] controlled by `args`.\n+        optimizer_cls_and_kwargs (`Tuple[Type[torch.optim.Optimizer], Dict[str, Any]]`, *optional*):\n+            A tuple containing the optimizer class and keyword arguments to use.\n+            Overrides `optim` and `optim_args` in `args`. Incompatible with the `optimizers` argument.\n+\n+            Unlike `optimizers`, this argument avoids the need to place model parameters on the correct devices before initializing the Trainer.\n         preprocess_logits_for_metrics (`Callable[[torch.Tensor, torch.Tensor], torch.Tensor]`, *optional*):\n             A function that preprocess the logits right before caching them at each evaluation step. Must take two\n             tensors, the logits and the labels, and return the logits once processed as desired. The modifications made\n@@ -401,7 +406,8 @@ def __init__(\n         compute_loss_func: Optional[Callable] = None,\n         compute_metrics: Optional[Callable[[EvalPrediction], Dict]] = None,\n         callbacks: Optional[List[TrainerCallback]] = None,\n-        optimizers: Tuple[torch.optim.Optimizer, torch.optim.lr_scheduler.LambdaLR] = (None, None),\n+        optimizers: Tuple[Optional[torch.optim.Optimizer], Optional[torch.optim.lr_scheduler.LambdaLR]] = (None, None),\n+        optimizer_cls_and_kwargs: Optional[Tuple[Type[torch.optim.Optimizer], Dict[str, Any]]] = None,\n         preprocess_logits_for_metrics: Optional[Callable[[torch.Tensor, torch.Tensor], torch.Tensor]] = None,\n     ):\n         if args is None:\n@@ -603,6 +609,9 @@ def __init__(\n         self.compute_metrics = compute_metrics\n         self.preprocess_logits_for_metrics = preprocess_logits_for_metrics\n         self.optimizer, self.lr_scheduler = optimizers\n+        self.optimizer_cls_and_kwargs = optimizer_cls_and_kwargs\n+        if self.optimizer_cls_and_kwargs is not None and self.optimizer is not None:\n+            raise RuntimeError(\"Passing both `optimizers` and `optimizer_cls_and_kwargs` arguments is incompatible.\")\n         if model_init is not None and (self.optimizer is not None or self.lr_scheduler is not None):\n             raise RuntimeError(\n                 \"Passing a `model_init` is incompatible with providing the `optimizers` argument. \"\n@@ -1171,7 +1180,10 @@ def create_optimizer(self):\n                 },\n             ]\n \n-            optimizer_cls, optimizer_kwargs = self.get_optimizer_cls_and_kwargs(self.args, opt_model)\n+            if self.optimizer_cls_and_kwargs is not None:\n+                optimizer_cls, optimizer_kwargs = self.optimizer_cls_and_kwargs\n+            else:\n+                optimizer_cls, optimizer_kwargs = self.get_optimizer_cls_and_kwargs(self.args, opt_model)\n \n             # Overwrite `params` in case it's created by `get_optimizer_cls_and_kwargs`\n             # e.g. for GaLore optimizer."
        }
    ],
    "stats": {
        "total": 124,
        "additions": 82,
        "deletions": 42
    }
}