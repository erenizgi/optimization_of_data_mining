{
    "author": "Muennighoff",
    "message": "Add OLMoE (#32406)\n\n* Add OLMoE\r\n\r\n* Add OLMoE\r\n\r\n* Updates\r\n\r\n* Make norm optional; add keys\r\n\r\n* Add output\r\n\r\n* Add\r\n\r\n* Fix dtype\r\n\r\n* Fix eos config\r\n\r\n* Update\r\n\r\n* Add OLMoE\r\n\r\n* Fix OLMoE path\r\n\r\n* Format\r\n\r\n* Format\r\n\r\n* Rmv copy statement\r\n\r\n* Rmv copy statement\r\n\r\n* Format\r\n\r\n* Add copies\r\n\r\n* Cp rotary\r\n\r\n* Fix aming\r\n\r\n* Fix naming\r\n\r\n* Update RoPE integration; num_logits_to_keep; Add copy statements\r\n\r\n* Add eps to config\r\n\r\n* Format\r\n\r\n* Add aux loss\r\n\r\n* Adapt router_aux_loss_coef\r\n\r\n* Update md\r\n\r\n* Adapt\r\n\r\n* adapt tests",
    "sha": "ecd61c62862f925a18b4f063dc17fcaf01826e25",
    "files": [
        {
            "sha": "da6dc9ee527374dbe737a1478d38d03438af8d4b",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -490,6 +490,8 @@\n         title: Nyströmformer\n       - local: model_doc/olmo\n         title: OLMo\n+      - local: model_doc/olmoe\n+        title: OLMoE\n       - local: model_doc/open-llama\n         title: Open-Llama\n       - local: model_doc/opt"
        },
        {
            "sha": "5a16472cfd0e6b98b30a378dd6c0eebdc85421a3",
            "filename": "docs/source/en/index.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/docs%2Fsource%2Fen%2Findex.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/docs%2Fsource%2Fen%2Findex.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Findex.md?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -233,6 +233,7 @@ Flax), PyTorch, and/or TensorFlow.\n |                        [Nougat](model_doc/nougat)                        |       ✅        |         ✅         |      ✅      |\n |                 [Nyströmformer](model_doc/nystromformer)                 |       ✅        |         ❌         |      ❌      |\n |                          [OLMo](model_doc/olmo)                          |       ✅        |         ❌         |      ❌      |\n+|                         [OLMoE](model_doc/olmoe)                         |       ✅        |         ❌         |      ❌      |\n |                     [OneFormer](model_doc/oneformer)                     |       ✅        |         ❌         |      ❌      |\n |                    [OpenAI GPT](model_doc/openai-gpt)                    |       ✅        |         ✅         |      ❌      |\n |                      [OpenAI GPT-2](model_doc/gpt2)                      |       ✅        |         ✅         |      ✅      |"
        },
        {
            "sha": "16c1ded60d83cf324f75b9d3a57e38644d6666fa",
            "filename": "docs/source/en/model_doc/olmoe.md",
            "status": "added",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/docs%2Fsource%2Fen%2Fmodel_doc%2Folmoe.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/docs%2Fsource%2Fen%2Fmodel_doc%2Folmoe.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Folmoe.md?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -0,0 +1,45 @@\n+<!--\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# OLMoE\n+\n+## Overview\n+\n+The OLMoE model was proposed in [OLMoE: Open Mixture-of-Experts Language Models](TODO) by Niklas Muennighoff, Luca Soldaini, Dirk Groeneveld, Kyle Lo, Jacob Morrison, Sewon Min, Weijia Shi, Pete Walsh, Oyvind Tafjord, Nathan Lambert, Yuling Gu, Shane Arora, Akshita Bhagia, Dustin Schwenk, David Wadden, Alexander Wettig, Binyuan Hui, Tim Dettmers, Douwe Kiela, Ali Farhadi, Noah A. Smith, Pang Wei Koh, Amanpreet Singh, Hannaneh Hajishirzi.\n+\n+OLMoE is a series of **O**pen **L**anguage **Mo**dels using sparse **M**ixture-**o**f-**E**xperts designed to enable the science of language models. We release all code, checkpoints, logs, and details involved in training these models.\n+\n+The abstract from the paper is the following:\n+\n+*We introduce OLMoE, a fully open, state-of-the-art language model leveraging sparse Mixture-of-Experts (MoE). OLMoE-1B-7B has 7 billion (B) parameters but uses only 1B per input token. We pretrain it on 5 trillion tokens and further adapt it to create OLMoE-1B-7B-Instruct. Our models outperform all available models with similar active parameters, even surpassing larger ones like Llama2-13B-Chat and DeepSeekMoE-16B. We present various experiments on MoE training, analyze routing in our model showing high specialization, and open-source all aspects of our work: model weights, training data, code, and logs.*\n+\n+This model was contributed by [Muennighoff](https://hf.co/Muennighoff).\n+The original code can be found [here](https://github.com/allenai/OLMoE).\n+\n+\n+## OlmoeConfig\n+\n+[[autodoc]] OlmoeConfig\n+\n+## OlmoeModel\n+\n+[[autodoc]] OlmoeModel\n+    - forward\n+\n+## OlmoeForCausalLM\n+\n+[[autodoc]] OlmoeForCausalLM\n+    - forward"
        },
        {
            "sha": "508886f33c6690ccb0f2542fa6d015b60de93cbf",
            "filename": "docs/source/en/perf_infer_gpu_one.md",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -71,6 +71,7 @@ FlashAttention-2 is currently supported for the following architectures:\n * [Nemotron](https://huggingface.co/docs/transformers/model_doc/nemotron)\n * [NLLB](https://huggingface.co/docs/transformers/model_doc/nllb)\n * [OLMo](https://huggingface.co/docs/transformers/model_doc/olmo#transformers.OlmoModel)\n+* [OLMoE](https://huggingface.co/docs/transformers/model_doc/olmoe#transformers.OlmoeModel)\n * [OPT](https://huggingface.co/docs/transformers/model_doc/opt#transformers.OPTModel)\n * [Phi](https://huggingface.co/docs/transformers/model_doc/phi#transformers.PhiModel)\n * [Phi3](https://huggingface.co/docs/transformers/model_doc/phi3#transformers.Phi3Model)\n@@ -230,6 +231,7 @@ For now, Transformers supports SDPA inference and training for the following arc\n * [Musicgen](https://huggingface.co/docs/transformers/model_doc/musicgen#transformers.MusicgenModel)\n * [MusicGen Melody](https://huggingface.co/docs/transformers/model_doc/musicgen_melody#transformers.MusicgenMelodyModel)\n * [OLMo](https://huggingface.co/docs/transformers/model_doc/olmo#transformers.OlmoModel)\n+* [OLMoE](https://huggingface.co/docs/transformers/model_doc/olmoe#transformers.OlmoeModel)\n * [PaliGemma](https://huggingface.co/docs/transformers/model_doc/paligemma#transformers.PaliGemmaForConditionalGeneration)\n * [Phi](https://huggingface.co/docs/transformers/model_doc/phi#transformers.PhiModel)\n * [Phi3](https://huggingface.co/docs/transformers/model_doc/phi3#transformers.Phi3Model)"
        },
        {
            "sha": "bb84b5cb27d415c2b397ba95d7732fe09d6e9184",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -603,6 +603,7 @@\n     \"models.nougat\": [\"NougatProcessor\"],\n     \"models.nystromformer\": [\"NystromformerConfig\"],\n     \"models.olmo\": [\"OlmoConfig\"],\n+    \"models.olmoe\": [\"OlmoeConfig\"],\n     \"models.oneformer\": [\n         \"OneFormerConfig\",\n         \"OneFormerProcessor\",\n@@ -2828,6 +2829,13 @@\n             \"OlmoPreTrainedModel\",\n         ]\n     )\n+    _import_structure[\"models.olmoe\"].extend(\n+        [\n+            \"OlmoeForCausalLM\",\n+            \"OlmoeModel\",\n+            \"OlmoePreTrainedModel\",\n+        ]\n+    )\n     _import_structure[\"models.oneformer\"].extend(\n         [\n             \"OneFormerForUniversalSegmentation\",\n@@ -5380,6 +5388,7 @@\n         NystromformerConfig,\n     )\n     from .models.olmo import OlmoConfig\n+    from .models.olmoe import OlmoeConfig\n     from .models.oneformer import (\n         OneFormerConfig,\n         OneFormerProcessor,\n@@ -7339,6 +7348,11 @@\n             OlmoModel,\n             OlmoPreTrainedModel,\n         )\n+        from .models.olmoe import (\n+            OlmoeForCausalLM,\n+            OlmoeModel,\n+            OlmoePreTrainedModel,\n+        )\n         from .models.oneformer import (\n             OneFormerForUniversalSegmentation,\n             OneFormerModel,"
        },
        {
            "sha": "8146d18bca4766fb19638ad8b74230aaf29f0eab",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -169,6 +169,7 @@\n     nougat,\n     nystromformer,\n     olmo,\n+    olmoe,\n     oneformer,\n     openai,\n     opt,"
        },
        {
            "sha": "4dd553491a499e3a8c00fac65981e435cecbdd16",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -187,6 +187,7 @@\n         (\"nougat\", \"VisionEncoderDecoderConfig\"),\n         (\"nystromformer\", \"NystromformerConfig\"),\n         (\"olmo\", \"OlmoConfig\"),\n+        (\"olmoe\", \"OlmoeConfig\"),\n         (\"oneformer\", \"OneFormerConfig\"),\n         (\"open-llama\", \"OpenLlamaConfig\"),\n         (\"openai-gpt\", \"OpenAIGPTConfig\"),\n@@ -488,6 +489,7 @@\n         (\"nougat\", \"Nougat\"),\n         (\"nystromformer\", \"Nyströmformer\"),\n         (\"olmo\", \"OLMo\"),\n+        (\"olmoe\", \"OLMoE\"),\n         (\"oneformer\", \"OneFormer\"),\n         (\"open-llama\", \"OpenLlama\"),\n         (\"openai-gpt\", \"OpenAI GPT\"),"
        },
        {
            "sha": "334ff3820c63edc899bce3ada9872f50cc586a8c",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -178,6 +178,7 @@\n         (\"nllb-moe\", \"NllbMoeModel\"),\n         (\"nystromformer\", \"NystromformerModel\"),\n         (\"olmo\", \"OlmoModel\"),\n+        (\"olmoe\", \"OlmoeModel\"),\n         (\"oneformer\", \"OneFormerModel\"),\n         (\"open-llama\", \"OpenLlamaModel\"),\n         (\"openai-gpt\", \"OpenAIGPTModel\"),\n@@ -498,6 +499,7 @@\n         (\"mvp\", \"MvpForCausalLM\"),\n         (\"nemotron\", \"NemotronForCausalLM\"),\n         (\"olmo\", \"OlmoForCausalLM\"),\n+        (\"olmoe\", \"OlmoeForCausalLM\"),\n         (\"open-llama\", \"OpenLlamaForCausalLM\"),\n         (\"openai-gpt\", \"OpenAIGPTLMHeadModel\"),\n         (\"opt\", \"OPTForCausalLM\"),"
        },
        {
            "sha": "fe6778182650f3ce809a03462df6e00930f88d1f",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -342,6 +342,7 @@\n                 ),\n             ),\n             (\"olmo\", (None, \"GPTNeoXTokenizerFast\" if is_tokenizers_available() else None)),\n+            (\"olmoe\", (None, \"GPTNeoXTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"oneformer\", (\"CLIPTokenizer\", \"CLIPTokenizerFast\" if is_tokenizers_available() else None)),\n             (\n                 \"openai-gpt\","
        },
        {
            "sha": "633fc4468026704a1b356258df830c60d0e5845d",
            "filename": "src/transformers/models/olmoe/__init__.py",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Folmoe%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Folmoe%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Folmoe%2F__init__.py?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -0,0 +1,55 @@\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import (\n+    OptionalDependencyNotAvailable,\n+    _LazyModule,\n+    is_torch_available,\n+)\n+\n+\n+_import_structure = {\n+    \"configuration_olmoe\": [\"OlmoeConfig\"],\n+}\n+\n+try:\n+    if not is_torch_available():\n+        raise OptionalDependencyNotAvailable()\n+except OptionalDependencyNotAvailable:\n+    pass\n+else:\n+    _import_structure[\"modeling_olmoe\"] = [\n+        \"OlmoeForCausalLM\",\n+        \"OlmoeModel\",\n+        \"OlmoePreTrainedModel\",\n+    ]\n+\n+if TYPE_CHECKING:\n+    from .configuration_olmoe import OlmoeConfig\n+\n+    try:\n+        if not is_torch_available():\n+            raise OptionalDependencyNotAvailable()\n+    except OptionalDependencyNotAvailable:\n+        pass\n+    else:\n+        from .modeling_olmoe import (\n+            OlmoeForCausalLM,\n+            OlmoeModel,\n+            OlmoePreTrainedModel,\n+        )\n+\n+else:\n+    import sys\n+\n+    sys.modules[__name__] = _LazyModule(__name__, globals()[\"__file__\"], _import_structure, module_spec=__spec__)"
        },
        {
            "sha": "434d633bec6613638130524ee3f78043df838348",
            "filename": "src/transformers/models/olmoe/configuration_olmoe.py",
            "status": "added",
            "additions": 179,
            "deletions": 0,
            "changes": 179,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Folmoe%2Fconfiguration_olmoe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Folmoe%2Fconfiguration_olmoe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Folmoe%2Fconfiguration_olmoe.py?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -0,0 +1,179 @@\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"OLMoE model configuration\"\"\"\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...modeling_rope_utils import rope_config_validation\n+\n+\n+class OlmoeConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`OlmoeModel`]. It is used to instantiate an OLMoE\n+    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n+    defaults will yield a similar configuration to that of the [allenai/OLMoE-1B-7B-0824](https://huggingface.co/allenai/OLMoE-1B-7B-0824).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 50304):\n+            Vocabulary size of the OLMoE model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`OlmoeModel`]\n+        hidden_size (`int`, *optional*, defaults to 2048):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 2048):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 16):\n+            Number of hidden layers in the Transformer decoder.\n+        num_attention_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer in the Transformer decoder.\n+        num_key_value_heads (`int`, *optional*):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to\n+            `num_attention_heads`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 4096):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        pad_token_id (`int`, *optional*, defaults to 1):\n+            Padding token id.\n+        bos_token_id (`int`, *optional*):\n+            Beginning of stream token id.\n+        eos_token_id (`int`, *optional*, defaults to 50279):\n+            End of stream token id.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether to tie weight embeddings\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. Currently supports two scaling\n+            strategies: linear and dynamic. Their scaling factor must be a float greater than 1. The expected format is\n+            `{\"type\": strategy name, \"factor\": scaling factor}`. When using this flag, don't update\n+            `max_position_embeddings` to the expected new maximum. See the following thread for more information on how\n+            these scaling strategies behave:\n+            https://www.reddit.com/r/LocalLLaMA/comments/14mrgpr/dynamically_scaled_rope_further_increases/. This is an\n+            experimental feature, subject to breaking API changes in future versions.\n+        attention_bias (`bool`, defaults to `False`, *optional*, defaults to `False`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        clip_qkv (`float`, *optional*):\n+            If not `None`, elements of query, key and value attention states are clipped so that their\n+            absolute value does not exceed this value.\n+        num_experts_per_tok (`int`, *optional*, defaults to 8):\n+            Number of selected experts.\n+        num_experts (`int`, *optional*, defaults to 64):\n+            Number of routed experts.\n+        output_router_logits (`bool`, *optional*, defaults to `False`):\n+            Whether or not the router logits should be returned by the model. Enabeling this will also\n+            allow the model to output the auxiliary loss, including load balancing loss and router z-loss.\n+        router_aux_loss_coef (`float`, *optional*, defaults to 0.01):\n+            The aux loss factor for the total loss.\n+        norm_topk_prob (`bool`, *optional*, defaults to `False`):\n+            Whether to normalize the topk probabilities.\n+\n+    ```python\n+    >>> from transformers import OlmoeModel, OlmoeConfig\n+\n+    >>> # Initializing a OLMoE 7B A1B style configuration\n+    >>> configuration = OlmoeConfig()\n+\n+    >>> # Initializing a model from the OLMoE 7B A1B style configuration\n+    >>> model = OlmoeModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"olmoe\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        vocab_size=50304,\n+        hidden_size=2048,\n+        intermediate_size=2048,\n+        num_hidden_layers=16,\n+        num_attention_heads=16,\n+        num_key_value_heads=None,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=4096,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-05,\n+        use_cache=True,\n+        pad_token_id=1,\n+        bos_token_id=None,\n+        eos_token_id=50279,\n+        tie_word_embeddings=False,\n+        rope_theta=10000.0,\n+        rope_scaling=None,\n+        attention_bias=False,\n+        attention_dropout=0.0,\n+        clip_qkv=None,\n+        num_experts_per_tok=8,\n+        num_experts=64,\n+        output_router_logits=False,\n+        router_aux_loss_coef=0.01,\n+        norm_topk_prob=False,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+        self.clip_qkv = clip_qkv\n+        self.num_experts_per_tok = num_experts_per_tok\n+        self.num_experts = num_experts\n+        self.output_router_logits = output_router_logits\n+        self.router_aux_loss_coef = router_aux_loss_coef\n+        self.norm_topk_prob = norm_topk_prob\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, move it to 'rope_type'.\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self)\n+\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )"
        },
        {
            "sha": "a14cd50a0e740427489d12020fddc29ed26d5b0f",
            "filename": "src/transformers/models/olmoe/convert_olmoe_weights_to_hf.py",
            "status": "added",
            "additions": 281,
            "deletions": 0,
            "changes": 281,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Folmoe%2Fconvert_olmoe_weights_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Folmoe%2Fconvert_olmoe_weights_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Folmoe%2Fconvert_olmoe_weights_to_hf.py?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -0,0 +1,281 @@\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"\n+Example for running:\n+0. Cp ckpts to local\n+aws s3 cp --recursive s3://ai2-llm/checkpoints/OLMoE/olmoe-8x1b-newhp-newds-final-annealFrom1200000/step23842 /data/niklas/llm/checkpoints/olmoe-8x1b-newhp-newds-final-annealFrom1200000_step23842\n+1. Unshard your OLMoE checkpoint using https://github.com/allenai/OLMo/blob/7d63fe09d23cf23714da5aa633a44a90180195da/scripts/unshard.py\n+python OLMo/scripts/unshard.py /data/niklas/llm/checkpoints/23485/step954000 /data/niklas/llm/checkpoints/1b-954000-unsharded --model-only\n+python OLMo/scripts/unshard.py /data/niklas/llm/checkpoints/23485/step954000 /data/niklas/llm/checkpoints/1b-954000-unsharded --model-only\n+python OLMo/scripts/unshard.py /data/niklas/llm/checkpoints/olmoe-8x1b-newhp-newds-final-annealFrom1200000_step23842 /data/niklas/llm/checkpoints/olmoe-8x1b-newhp-newds-final-annealFrom1200000_step23842-unsharded --model-only\n+2. Convert to transformers\n+rm -rf olmoe; mkdir olmoe; python /data/niklas/transformers/src/transformers/models/olmoe/convert_olmoe_weights_to_hf.py --input_dir /data/niklas/llm/checkpoints/olmoe-8x1b-newhp-newds-final-annealFrom1200000_step23842-unsharded --tokenizer_json_path /data/niklas/llm/checkpoints/olmoe-step1200000-unsharded/tokenizer.json --output_dir olmoe\n+3. Load model via:\n+```\n+from transformers import OlmoeForCausalLM, AutoTokenizer\n+import torch\n+model = OlmoeForCausalLM.from_pretrained(\"../transformers/olmoe\", torch_dtype=torch.bfloat16).cuda()\n+model = OlmoeForCausalLM.from_pretrained(\"../transformers/olmoe\").cuda()\n+tokenizer = AutoTokenizer.from_pretrained(\"../transformers/olmoe\")\n+inputs = tokenizer(\"Bitcoin is\", return_tensors=\"pt\")\n+inputs = {k: v.cuda() for k, v in inputs.items()}\n+out = model.generate(**inputs, max_length=64)\n+print(tokenizer.decode(out[0]))\n+# > # Bitcoin is a digital currency that is created and held electronically. No one controls it. Bitcoins aren’t printed, like dollars or euros – they’re produced by people and businesses running computers all around the world, using software that solves mathematical\n+# Or quick sanity check:\n+o = model(torch.tensor([[0, 1]]).cuda())\n+# If the checkpoint is not converted to BF16 but kept in FP32:\n+# > # Bitcoin is a digital currency that is not controlled by any central authority. It is a peer-to-peer payment system that allows users to send and receive payments from anywhere in the world. Bitcoin is also known as a cryptocurrency because it uses cryptography to secure transactions and prevent fraud.\n+```\n+\n+Note: you need to be able to host the whole model in RAM to execute this script (even if the biggest versions\n+come in several checkpoints they each contain a part of each weight of the model, so we need to load them all in RAM).\n+\n+Compare with OLMo codebase:\n+```\n+from olmo.model import OLMo\n+import torch\n+model = OLMo.from_checkpoint(\"/data/niklas/llm/checkpoints/olmoe-step1200000-unsharded-pt\")\n+model = model.cuda()\n+model = model.to(torch.bfloat16)\n+from transformers import AutoTokenizer\n+tokenizer = AutoTokenizer.from_pretrained(\"../transformers/olmoe\")\n+inputs = tokenizer(\"Bitcoin is\", return_tensors=\"pt\")\n+inputs = {k: v.cuda() for k, v in inputs.items()}\n+out = model.generate(**inputs)\n+print(tokenizer.decode(out[0][0][0]))\n+# Bitcoin is a digital currency that is created and held electronically. No one controls it. Bitcoins aren’t printed, like dollars or euros – they’re produced by people and businesses running computers all around the world, using software that solves mathematical problems. It’s the first example of a growing category of money\n+# Or quick sanity check:\n+o = model(torch.tensor([[0, 1]]).cuda())\n+```\n+\"\"\"\n+\n+import argparse\n+import gc\n+import json\n+import os\n+import shutil\n+from pathlib import Path\n+\n+import torch\n+import yaml\n+from tokenizers import Tokenizer\n+\n+from transformers import OlmoeConfig, OlmoeForCausalLM\n+from transformers.models.gpt_neox.tokenization_gpt_neox_fast import GPTNeoXTokenizerFast\n+\n+\n+def compute_intermediate_size(n, ffn_dim_multiplier=1, multiple_of=256):\n+    return multiple_of * ((int(ffn_dim_multiplier * int(8 * n / 3)) + multiple_of - 1) // multiple_of)\n+\n+\n+def read_json(path):\n+    with open(path, \"r\") as f:\n+        return json.load(f)\n+\n+\n+def write_json(text, path):\n+    with open(path, \"w\") as f:\n+        json.dump(text, f)\n+\n+\n+def write_model(model_path, input_base_path, tokenizer_path=None, safe_serialization=True, fix_eos_token_id=True):\n+    os.makedirs(model_path, exist_ok=True)\n+    tmp_model_path = os.path.join(model_path, \"tmp\")\n+    os.makedirs(tmp_model_path, exist_ok=True)\n+\n+    config_path = Path(input_base_path) / \"config.yaml\"\n+    olmoe_config = yaml.safe_load(config_path.read_text())[\"model\"]\n+\n+    if fix_eos_token_id:\n+        olmoe_config[\"eos_token_id\"] = 50279\n+\n+    n_layers = olmoe_config[\"n_layers\"]\n+    n_heads = olmoe_config[\"n_heads\"]\n+    dim = olmoe_config[\"d_model\"]\n+    dims_per_head = dim // n_heads\n+    base = 10000.0\n+    inv_freq = 1.0 / (base ** (torch.arange(0, dims_per_head, 2).float() / dims_per_head))\n+    max_position_embeddings = olmoe_config[\"max_sequence_length\"]\n+\n+    vocab_size = olmoe_config.get(\"embedding_size\", olmoe_config[\"vocab_size\"])\n+\n+    if olmoe_config.get(\"n_kv_heads\", None) is not None:\n+        num_key_value_heads = olmoe_config[\"n_kv_heads\"]  # for GQA / MQA\n+    elif olmoe_config[\"multi_query_attention\"]:  # compatibility with other checkpoints\n+        num_key_value_heads = 1\n+    else:\n+        num_key_value_heads = n_heads\n+\n+    print(f\"Fetching all parameters from the checkpoint at {input_base_path}.\")\n+\n+    # Not sharded\n+    loaded = torch.load(os.path.join(input_base_path, \"model.pt\"), map_location=\"cpu\")\n+\n+    param_count = 0\n+    index_dict = {\"weight_map\": {}}\n+    for layer_i in range(n_layers):\n+        filename = f\"pytorch_model-{layer_i + 1}-of-{n_layers + 1}.bin\"\n+        fused_dims = [dim, dims_per_head * num_key_value_heads, dims_per_head * num_key_value_heads]\n+        q_proj_weight, k_proj_weight, v_proj_weight = torch.split(\n+            loaded[f\"transformer.blocks.{layer_i}.att_proj.weight\"], fused_dims, dim=0\n+        )\n+        state_dict = {\n+            f\"model.layers.{layer_i}.self_attn.q_proj.weight\": q_proj_weight,\n+            f\"model.layers.{layer_i}.self_attn.k_proj.weight\": k_proj_weight,\n+            f\"model.layers.{layer_i}.self_attn.v_proj.weight\": v_proj_weight,\n+            f\"model.layers.{layer_i}.self_attn.o_proj.weight\": loaded[f\"transformer.blocks.{layer_i}.attn_out.weight\"],\n+            f\"model.layers.{layer_i}.self_attn.q_norm.weight\": loaded[f\"transformer.blocks.{layer_i}.q_norm.weight\"],\n+            f\"model.layers.{layer_i}.self_attn.k_norm.weight\": loaded[f\"transformer.blocks.{layer_i}.k_norm.weight\"],\n+            f\"model.layers.{layer_i}.mlp.gate.weight\": loaded[f\"transformer.blocks.{layer_i}.ffn.router.layer.weight\"],\n+            f\"model.layers.{layer_i}.input_layernorm.weight\": loaded[f\"transformer.blocks.{layer_i}.attn_norm.weight\"],\n+            f\"model.layers.{layer_i}.post_attention_layernorm.weight\": loaded[\n+                f\"transformer.blocks.{layer_i}.ff_norm.weight\"\n+            ],\n+        }\n+\n+        num_experts = loaded[f\"transformer.blocks.{layer_i}.ffn.router.layer.weight\"].shape[0]\n+        dim_per_expert = loaded[f\"transformer.blocks.{layer_i}.ffn.experts.mlp.w1\"].shape[0] // num_experts\n+        for expert_i in range(num_experts):\n+            state_dict[f\"model.layers.{layer_i}.mlp.experts.{expert_i}.gate_proj.weight\"] = loaded[\n+                f\"transformer.blocks.{layer_i}.ffn.experts.mlp.w1\"\n+            ][dim_per_expert * expert_i : dim_per_expert * (expert_i + 1), :]\n+            state_dict[f\"model.layers.{layer_i}.mlp.experts.{expert_i}.up_proj.weight\"] = loaded[\n+                f\"transformer.blocks.{layer_i}.ffn.experts.mlp.v1\"\n+            ][dim_per_expert * expert_i : dim_per_expert * (expert_i + 1), :]\n+            state_dict[f\"model.layers.{layer_i}.mlp.experts.{expert_i}.down_proj.weight\"] = loaded[\n+                f\"transformer.blocks.{layer_i}.ffn.experts.mlp.w2\"\n+            ][dim_per_expert * expert_i : dim_per_expert * (expert_i + 1), :].T.contiguous()\n+\n+        state_dict[f\"model.layers.{layer_i}.self_attn.rotary_emb.inv_freq\"] = inv_freq\n+\n+        for k, v in state_dict.items():\n+            index_dict[\"weight_map\"][k] = filename\n+            param_count += v.numel()\n+        torch.save(state_dict, os.path.join(tmp_model_path, filename))\n+\n+    filename = f\"pytorch_model-{n_layers + 1}-of-{n_layers + 1}.bin\"\n+\n+    # Unsharded\n+    state_dict = {\n+        \"model.embed_tokens.weight\": loaded[\"transformer.wte.weight\"],\n+        \"lm_head.weight\": loaded[\"transformer.ff_out.weight\"],\n+        \"model.norm.weight\": loaded[\"transformer.ln_f.weight\"],\n+    }\n+\n+    for k, v in state_dict.items():\n+        index_dict[\"weight_map\"][k] = filename\n+        param_count += v.numel()\n+    torch.save(state_dict, os.path.join(tmp_model_path, filename))\n+\n+    # Write configs\n+    index_dict[\"metadata\"] = {\"total_size\": param_count * 2}\n+    write_json(index_dict, os.path.join(tmp_model_path, \"pytorch_model.bin.index.json\"))\n+\n+    config = OlmoeConfig(\n+        vocab_size=vocab_size,\n+        hidden_size=dim,\n+        intermediate_size=dim_per_expert,\n+        num_hidden_layers=n_layers,\n+        num_attention_heads=n_heads,\n+        num_key_value_heads=num_key_value_heads,\n+        max_position_embeddings=max_position_embeddings,\n+        pad_token_id=olmoe_config[\"pad_token_id\"],\n+        bos_token_id=None,\n+        eos_token_id=olmoe_config[\"eos_token_id\"],\n+        tie_word_embeddings=olmoe_config[\"weight_tying\"],\n+        rope_theta=base,\n+        clip_qkv=olmoe_config.get(\"clip_qkv\"),\n+    )\n+    config.save_pretrained(tmp_model_path)\n+\n+    # Make space so we can load the model properly now.\n+    del state_dict\n+    del loaded\n+    gc.collect()\n+\n+    if tokenizer_path is not None:\n+        _write_tokenizer(model_path, config, tokenizer_path, fix_eos_token_id)\n+\n+    print(\"Loading the checkpoint in a OLMoE model.\")\n+    model = OlmoeForCausalLM.from_pretrained(tmp_model_path, torch_dtype=torch.bfloat16)\n+    # Avoid saving this as part of the config.\n+    del model.config._name_or_path\n+    print(\"Saving in the Transformers format.\")\n+    model.save_pretrained(model_path, safe_serialization=safe_serialization)\n+    shutil.rmtree(tmp_model_path)\n+\n+\n+def _write_tokenizer(\n+    output_path: Path, config: OlmoeConfig, input_tokenizer_path: Path, fix_eos_token_id: bool = True\n+) -> None:\n+    print(f\"Saving a {GPTNeoXTokenizerFast.__name__} to {output_path}.\")\n+\n+    base_tokenizer = Tokenizer.from_file(str(input_tokenizer_path))\n+\n+    eos_token_id = config.eos_token_id if config.eos_token_id is not None else base_tokenizer.get_vocab_size() - 1\n+    pad_token_id = config.pad_token_id if config.pad_token_id is not None else eos_token_id\n+\n+    if fix_eos_token_id and eos_token_id == 0:\n+        # Fixing a bug in OLMo where eos token id was incorrectly set\n+        print(\"Changing eos_token_id from 0 to 50279.\")\n+        eos_token_id = 50279\n+\n+    tokenizer = GPTNeoXTokenizerFast(\n+        tokenizer_object=base_tokenizer,\n+        eos_token=base_tokenizer.decode([eos_token_id], skip_special_tokens=False),\n+        pad_token=base_tokenizer.decode([pad_token_id], skip_special_tokens=False),\n+        unk_token=None,\n+        bos_token=None,\n+    )\n+\n+    tokenizer.save_pretrained(output_path)\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\n+        \"--input_dir\",\n+        required=True,\n+        help=\"Location of OLMoE weights, which contains config.yaml and model.pt.\",\n+    )\n+    parser.add_argument(\n+        \"--tokenizer_json_path\",\n+        default=None,\n+        help=\"Location of OLMoE tokenizer json file.\",\n+    )\n+    parser.add_argument(\n+        \"--output_dir\",\n+        required=True,\n+        help=\"Location to write HF model and tokenizer\",\n+    )\n+    parser.add_argument(\n+        \"--no_fix_eos_token_id\",\n+        action=\"store_false\",\n+        dest=\"fix_eos_token_id\",\n+        help=\"If set, does not change eos token id from 0 to 50279 if it is 0. Changing 0 to 50279 is a bug fix, so use this option with care.\",\n+    )\n+    parser.add_argument(\n+        \"--safe_serialization\", type=bool, default=True, help=\"Whether or not to save using `safetensors`.\"\n+    )\n+    args = parser.parse_args()\n+    write_model(\n+        model_path=args.output_dir,\n+        input_base_path=args.input_dir,\n+        safe_serialization=args.safe_serialization,\n+        tokenizer_path=args.tokenizer_json_path,\n+        fix_eos_token_id=args.fix_eos_token_id,\n+    )\n+\n+\n+if __name__ == \"__main__\":\n+    main()"
        },
        {
            "sha": "80a2d1a2865916fb5fde0fba6395d44c0c3b2c0c",
            "filename": "src/transformers/models/olmoe/modeling_olmoe.py",
            "status": "added",
            "additions": 1394,
            "deletions": 0,
            "changes": 1394,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Folmoe%2Fmodeling_olmoe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Fmodels%2Folmoe%2Fmodeling_olmoe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Folmoe%2Fmodeling_olmoe.py?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -0,0 +1,1394 @@\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch OLMoE model.\"\"\"\n+\n+import math\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+import torch.nn.functional as F\n+import torch.utils.checkpoint\n+from torch import nn\n+from torch.nn import CrossEntropyLoss\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache, StaticCache\n+from ...modeling_attn_mask_utils import AttentionMaskConverter\n+from ...modeling_outputs import (\n+    MoeCausalLMOutputWithPast,\n+    MoeModelOutputWithPast,\n+)\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS\n+from ...modeling_utils import PreTrainedModel\n+from ...pytorch_utils import ALL_LAYERNORM_LAYERS\n+from ...utils import (\n+    add_start_docstrings,\n+    add_start_docstrings_to_model_forward,\n+    is_flash_attn_2_available,\n+    is_flash_attn_greater_or_equal_2_10,\n+    logging,\n+    replace_return_docstrings,\n+)\n+from .configuration_olmoe import OlmoeConfig\n+\n+\n+if is_flash_attn_2_available():\n+    from ...modeling_flash_attention_utils import _flash_attention_forward\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+_CONFIG_FOR_DOC = \"OlmoeConfig\"\n+\n+\n+# Copied from transformers.models.llama.modeling_llama._prepare_4d_causal_attention_mask_with_cache_position\n+def _prepare_4d_causal_attention_mask_with_cache_position(\n+    attention_mask: torch.Tensor,\n+    sequence_length: int,\n+    target_length: int,\n+    dtype: torch.dtype,\n+    device: torch.device,\n+    min_dtype: float,\n+    cache_position: torch.Tensor,\n+    batch_size: int,\n+):\n+    \"\"\"\n+    Creates a causal 4D mask of shape `(batch_size, 1, query_length, key_value_length)` from a 2D mask of shape\n+    `(batch_size, key_value_length)`, or if the input `attention_mask` is already 4D, do nothing.\n+\n+    Args:\n+        attention_mask (`torch.Tensor`):\n+            A 2D attention mask of shape `(batch_size, key_value_length)` or a 4D attention mask of shape `(batch_size, 1, query_length, key_value_length)`.\n+        sequence_length (`int`):\n+            The sequence length being processed.\n+        target_length (`int`):\n+            The target length: when generating with static cache, the mask should be as long as the static cache, to account for the 0 padding, the part of the cache that is not filled yet.\n+        dtype (`torch.dtype`):\n+            The dtype to use for the 4D attention mask.\n+        device (`torch.device`):\n+            The device to plcae the 4D attention mask on.\n+        min_dtype (`float`):\n+            The minimum value representable with the dtype `dtype`.\n+        cache_position (`torch.Tensor`):\n+            Indices depicting the position of the input sequence tokens in the sequence.\n+        batch_size (`torch.Tensor`):\n+            Batch size.\n+    \"\"\"\n+    if attention_mask is not None and attention_mask.dim() == 4:\n+        # In this case we assume that the mask comes already in inverted form and requires no inversion or slicing.\n+        causal_mask = attention_mask\n+    else:\n+        causal_mask = torch.full((sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device)\n+        if sequence_length != 1:\n+            causal_mask = torch.triu(causal_mask, diagonal=1)\n+        causal_mask *= torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n+        causal_mask = causal_mask[None, None, :, :].expand(batch_size, 1, -1, -1)\n+        if attention_mask is not None:\n+            causal_mask = causal_mask.clone()  # copy to contiguous memory for in-place edit\n+            mask_length = attention_mask.shape[-1]\n+            padding_mask = causal_mask[:, :, :, :mask_length] + attention_mask[:, None, None, :]\n+            padding_mask = padding_mask == 0\n+            causal_mask[:, :, :, :mask_length] = causal_mask[:, :, :, :mask_length].masked_fill(\n+                padding_mask, min_dtype\n+            )\n+\n+    return causal_mask\n+\n+\n+# Copied from transformers.models.mixtral.modeling_mixtral.load_balancing_loss_func\n+def load_balancing_loss_func(\n+    gate_logits: torch.Tensor, num_experts: torch.Tensor = None, top_k=2, attention_mask: Optional[torch.Tensor] = None\n+) -> float:\n+    r\"\"\"\n+    Computes auxiliary load balancing loss as in Switch Transformer - implemented in Pytorch.\n+\n+    See Switch Transformer (https://arxiv.org/abs/2101.03961) for more details. This function implements the loss\n+    function presented in equations (4) - (6) of the paper. It aims at penalizing cases where the routing between\n+    experts is too unbalanced.\n+\n+    Args:\n+        gate_logits (Union[`torch.Tensor`, Tuple[torch.Tensor]):\n+            Logits from the `gate`, should be a tuple of model.config.num_hidden_layers tensors of\n+            shape [batch_size X sequence_length, num_experts].\n+        attention_mask (`torch.Tensor`, *optional*):\n+            The attention_mask used in forward function\n+            shape [batch_size X sequence_length] if not None.\n+        num_experts (`int`, *optional*):\n+            Number of experts\n+\n+    Returns:\n+        The auxiliary loss.\n+    \"\"\"\n+    if gate_logits is None or not isinstance(gate_logits, tuple):\n+        return 0\n+\n+    if isinstance(gate_logits, tuple):\n+        compute_device = gate_logits[0].device\n+        concatenated_gate_logits = torch.cat([layer_gate.to(compute_device) for layer_gate in gate_logits], dim=0)\n+\n+    routing_weights = torch.nn.functional.softmax(concatenated_gate_logits, dim=-1)\n+\n+    _, selected_experts = torch.topk(routing_weights, top_k, dim=-1)\n+\n+    expert_mask = torch.nn.functional.one_hot(selected_experts, num_experts)\n+\n+    if attention_mask is None:\n+        # Compute the percentage of tokens routed to each experts\n+        tokens_per_expert = torch.mean(expert_mask.float(), dim=0)\n+\n+        # Compute the average probability of routing to these experts\n+        router_prob_per_expert = torch.mean(routing_weights, dim=0)\n+    else:\n+        batch_size, sequence_length = attention_mask.shape\n+        num_hidden_layers = concatenated_gate_logits.shape[0] // (batch_size * sequence_length)\n+\n+        # Compute the mask that masks all padding tokens as 0 with the same shape of expert_mask\n+        expert_attention_mask = (\n+            attention_mask[None, :, :, None, None]\n+            .expand((num_hidden_layers, batch_size, sequence_length, top_k, num_experts))\n+            .reshape(-1, top_k, num_experts)\n+            .to(compute_device)\n+        )\n+\n+        # Compute the percentage of tokens routed to each experts\n+        tokens_per_expert = torch.sum(expert_mask.float() * expert_attention_mask, dim=0) / torch.sum(\n+            expert_attention_mask, dim=0\n+        )\n+\n+        # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n+        router_per_expert_attention_mask = (\n+            attention_mask[None, :, :, None]\n+            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n+            .reshape(-1, num_experts)\n+            .to(compute_device)\n+        )\n+\n+        # Compute the average probability of routing to these experts\n+        router_prob_per_expert = torch.sum(routing_weights * router_per_expert_attention_mask, dim=0) / torch.sum(\n+            router_per_expert_attention_mask, dim=0\n+        )\n+\n+    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    return overall_loss * num_experts\n+\n+\n+class OlmoeRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-5):\n+        \"\"\"\n+        OlmoeRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+ALL_LAYERNORM_LAYERS.append(OlmoeRMSNorm)\n+\n+\n+# Copied from transformers.models.llama.modeling_llama.LlamaRotaryEmbedding with Llama->Olmoe\n+class OlmoeRotaryEmbedding(nn.Module):\n+    def __init__(\n+        self,\n+        dim=None,\n+        max_position_embeddings=2048,\n+        base=10000,\n+        device=None,\n+        scaling_factor=1.0,\n+        rope_type=\"default\",\n+        config: Optional[OlmoeConfig] = None,\n+    ):\n+        super().__init__()\n+        # TODO (joao): remove the `if` below, only used for BC\n+        self.rope_kwargs = {}\n+        if config is None:\n+            logger.warning_once(\n+                \"`OlmoeRotaryEmbedding` can now be fully parameterized by passing the model config through the \"\n+                \"`config` argument. All other arguments will be removed in v4.45\"\n+            )\n+            self.rope_kwargs = {\n+                \"rope_type\": rope_type,\n+                \"factor\": scaling_factor,\n+                \"dim\": dim,\n+                \"base\": base,\n+                \"max_position_embeddings\": max_position_embeddings,\n+            }\n+            self.rope_type = rope_type\n+            self.max_seq_len_cached = max_position_embeddings\n+            self.original_max_seq_len = max_position_embeddings\n+        else:\n+            # BC: \"rope_type\" was originally \"type\"\n+            if config.rope_scaling is not None:\n+                self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n+            else:\n+                self.rope_type = \"default\"\n+            self.max_seq_len_cached = config.max_position_embeddings\n+            self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device, **self.rope_kwargs)\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = self.inv_freq\n+\n+    def _dynamic_frequency_update(self, position_ids, device):\n+        \"\"\"\n+        dynamic RoPE layers should recompute `inv_freq` in the following situations:\n+        1 - growing beyond the cached sequence length (allow scaling)\n+        2 - the current sequence length is in the original scale (avoid losing precision with small sequences)\n+        \"\"\"\n+        seq_len = torch.max(position_ids) + 1\n+        if seq_len > self.max_seq_len_cached:  # growth\n+            inv_freq, self.attention_scaling = self.rope_init_fn(\n+                self.config, device, seq_len=seq_len, **self.rope_kwargs\n+            )\n+            self.register_buffer(\"inv_freq\", inv_freq, persistent=False)  # TODO joao: may break with compilation\n+            self.max_seq_len_cached = seq_len\n+\n+        if seq_len < self.original_max_seq_len and self.max_seq_len_cached > self.original_max_seq_len:  # reset\n+            self.register_buffer(\"inv_freq\", self.original_inv_freq, persistent=False)\n+            self.max_seq_len_cached = self.original_max_seq_len\n+\n+    @torch.no_grad()\n+    def forward(self, x, position_ids):\n+        if \"dynamic\" in self.rope_type:\n+            self._dynamic_frequency_update(position_ids, device=x.device)\n+\n+        # Core RoPE block\n+        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1)\n+        position_ids_expanded = position_ids[:, None, :].float()\n+        # Force float32 (see https://github.com/huggingface/transformers/pull/29285)\n+        device_type = x.device.type\n+        device_type = device_type if isinstance(device_type, str) and device_type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(1, 2)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos()\n+            sin = emb.sin()\n+\n+        # Advanced RoPE types (e.g. yarn) apply a post-processing scaling factor, equivalent to scaling attention\n+        cos = cos * self.attention_scaling\n+        sin = sin * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+# Copied from transformers.models.llama.modeling_llama.rotate_half\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+# Copied from transformers.models.llama.modeling_llama.apply_rotary_pos_emb\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`, *optional*):\n+            Deprecated and unused.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    return q_embed, k_embed\n+\n+\n+# Copied from transformers.models.olmo.modeling_olmo.OlmoMLP with Olmo->Olmoe\n+class OlmoeMLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=False)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, x):\n+        return self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x))\n+\n+\n+# Copied from transformers.models.llama.modeling_llama.repeat_kv\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+class OlmoeAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: OlmoeConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        if layer_idx is None:\n+            logger.warning_once(\n+                f\"Instantiating {self.__class__.__name__} without passing a `layer_idx` is not recommended and will \"\n+                \"lead to errors during the forward call if caching is used. Please make sure to provide a `layer_idx` \"\n+                \"when creating this class.\"\n+            )\n+\n+        self.attention_dropout = config.attention_dropout\n+        self.hidden_size = config.hidden_size\n+        self.num_heads = config.num_attention_heads\n+        self.head_dim = self.hidden_size // self.num_heads\n+        self.num_key_value_heads = config.num_key_value_heads\n+        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n+        self.max_position_embeddings = config.max_position_embeddings\n+        self.rope_theta = config.rope_theta\n+        self.is_causal = True\n+\n+        if (self.head_dim * self.num_heads) != self.hidden_size:\n+            raise ValueError(\n+                f\"hidden_size must be divisible by num_heads (got `hidden_size`: {self.hidden_size}\"\n+                f\" and `num_heads`: {self.num_heads}).\"\n+            )\n+\n+        self.q_proj = nn.Linear(self.hidden_size, self.num_heads * self.head_dim, bias=config.attention_bias)\n+        self.k_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=config.attention_bias)\n+        self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=config.attention_bias)\n+        self.o_proj = nn.Linear(self.hidden_size, self.hidden_size, bias=config.attention_bias)\n+        self.q_norm = OlmoeRMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+        self.k_norm = OlmoeRMSNorm(\n+            (self.hidden_size // self.num_heads) * self.num_key_value_heads, eps=config.rms_norm_eps\n+        )\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,\n+        **kwargs,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_norm(self.q_proj(hidden_states))\n+        key_states = self.k_norm(self.k_proj(hidden_states))\n+        value_states = self.v_proj(hidden_states)\n+\n+        if self.config.clip_qkv is not None:\n+            query_states.clamp_(min=-self.config.clip_qkv, max=self.config.clip_qkv)\n+            key_states.clamp_(min=-self.config.clip_qkv, max=self.config.clip_qkv)\n+            value_states.clamp_(min=-self.config.clip_qkv, max=self.config.clip_qkv)\n+\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        key_states = repeat_kv(key_states, self.num_key_value_groups)\n+        value_states = repeat_kv(value_states, self.num_key_value_groups)\n+\n+        attn_weights = torch.matmul(query_states, key_states.transpose(2, 3)) / math.sqrt(self.head_dim)\n+\n+        if attention_mask is not None:  # no matter the length, we just slice it\n+            causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+            attn_weights = attn_weights + causal_mask\n+\n+        # upcast attention to fp32\n+        attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query_states.dtype)\n+        attn_weights = nn.functional.dropout(attn_weights, p=self.attention_dropout, training=self.training)\n+        attn_output = torch.matmul(attn_weights, value_states)\n+\n+        if attn_output.size() != (bsz, self.num_heads, q_len, self.head_dim):\n+            raise ValueError(\n+                f\"`attn_output` should be of size {(bsz, self.num_heads, q_len, self.head_dim)}, but is\"\n+                f\" {attn_output.size()}\"\n+            )\n+\n+        attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+        attn_output = attn_output.reshape(bsz, q_len, self.hidden_size)\n+\n+        attn_output = self.o_proj(attn_output)\n+\n+        if not output_attentions:\n+            attn_weights = None\n+\n+        return attn_output, attn_weights, past_key_value\n+\n+\n+class OlmoeFlashAttention2(OlmoeAttention):\n+    \"\"\"\n+    OLMoE flash attention module. This module inherits from `OlmoeAttention` as the weights of the module stays\n+    untouched. The only required change would be on the forward pass where it needs to correctly call the public API of\n+    flash attention and deal with padding tokens in case the input contains any of them.\n+    \"\"\"\n+\n+    # Copied from transformers.models.llama.modeling_llama.LlamaFlashAttention2.__init__\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        # TODO: Should be removed once Flash Attention for RoCm is bumped to 2.1.\n+        # flash_attn<2.1 generates top-left aligned causal mask, while what is needed here is bottom-right alignement, that was made default for flash_attn>=2.1. This attribute is used to handle this difference. Reference: https://github.com/Dao-AILab/flash-attention/releases/tag/v2.1.0.\n+        # Beware that with flash_attn<2.1, using q_seqlen != k_seqlen (except for the case q_seqlen == 1) produces a wrong mask (top-left).\n+        self._flash_attn_uses_top_left_mask = not is_flash_attn_greater_or_equal_2_10()\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.LongTensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,\n+        **kwargs,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        output_attentions = False\n+\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_norm(self.q_proj(hidden_states))\n+        key_states = self.k_norm(self.k_proj(hidden_states))\n+        value_states = self.v_proj(hidden_states)\n+        if self.config.clip_qkv is not None:\n+            query_states.clamp_(min=-self.config.clip_qkv, max=self.config.clip_qkv)\n+            key_states.clamp_(min=-self.config.clip_qkv, max=self.config.clip_qkv)\n+            value_states.clamp_(min=-self.config.clip_qkv, max=self.config.clip_qkv)\n+\n+        # Flash attention requires the input to have the shape\n+        # batch_size x seq_length x head_dim x hidden_dim\n+        # therefore we just need to keep the original shape\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        # TODO: These transpose are quite inefficient but Flash Attention requires the layout [batch_size, sequence_length, num_heads, head_dim]. We would need to refactor the KV cache\n+        # to be able to avoid many of these transpose/reshape/view.\n+        query_states = query_states.transpose(1, 2)\n+        key_states = key_states.transpose(1, 2)\n+        value_states = value_states.transpose(1, 2)\n+\n+        dropout_rate = self.attention_dropout if self.training else 0.0\n+\n+        # In PEFT, usually we cast the layer norms in float32 for training stability reasons\n+        # therefore the input hidden states gets silently casted in float32. Hence, we need\n+        # cast them back in the correct dtype just to be sure everything works as expected.\n+        # This might slowdown training & inference so it is recommended to not cast the LayerNorms\n+        # in fp32. (OlmoeRMSNorm handles it correctly)\n+\n+        input_dtype = query_states.dtype\n+        if input_dtype == torch.float32:\n+            if torch.is_autocast_enabled():\n+                target_dtype = torch.get_autocast_gpu_dtype()\n+            # Handle the case where the model is quantized\n+            elif hasattr(self.config, \"_pre_quantization_dtype\"):\n+                target_dtype = self.config._pre_quantization_dtype\n+            else:\n+                target_dtype = self.q_proj.weight.dtype\n+\n+            logger.warning_once(\n+                f\"The input hidden states seems to be silently casted in float32, this might be related to\"\n+                f\" the fact you have upcasted embedding or layer norm layers in float32. We will cast back the input in\"\n+                f\" {target_dtype}.\"\n+            )\n+\n+            query_states = query_states.to(target_dtype)\n+            key_states = key_states.to(target_dtype)\n+            value_states = value_states.to(target_dtype)\n+\n+        attn_output = _flash_attention_forward(\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            q_len,\n+            dropout=dropout_rate,\n+            use_top_left_mask=self._flash_attn_uses_top_left_mask,\n+            is_causal=self.is_causal,\n+        )\n+\n+        attn_output = attn_output.reshape(bsz, q_len, self.hidden_size).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+\n+        if not output_attentions:\n+            attn_weights = None\n+\n+        return attn_output, attn_weights, past_key_value\n+\n+\n+class OlmoeSdpaAttention(OlmoeAttention):\n+    \"\"\"\n+    OLMoE attention module using torch.nn.functional.scaled_dot_product_attention. This module inherits from\n+    `OlmoeAttention` as the weights of the module stays untouched. The only changes are on the forward pass to adapt to\n+    SDPA API.\n+    \"\"\"\n+\n+    # Adapted from OlmoeAttention.forward\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        if output_attentions:\n+            # TODO: Improve this warning with e.g. `model.config.attn_implementation = \"manual\"` once this is implemented.\n+            logger.warning_once(\n+                \"OlmoeModel is using OlmoeSdpaAttention, but `torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. Falling back to the manual attention implementation, \"\n+                'but specifying the manual implementation will be required from Transformers version v5.0.0 onwards. This warning can be removed using the argument `attn_implementation=\"eager\"` when loading the model.'\n+            )\n+            return super().forward(\n+                hidden_states=hidden_states,\n+                attention_mask=attention_mask,\n+                position_ids=position_ids,\n+                past_key_value=past_key_value,\n+                output_attentions=output_attentions,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                position_embeddings=position_embeddings,\n+            )\n+\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_norm(self.q_proj(hidden_states))\n+        key_states = self.k_norm(self.k_proj(hidden_states))\n+        value_states = self.v_proj(hidden_states)\n+\n+        if self.config.clip_qkv is not None:\n+            query_states.clamp_(min=-self.config.clip_qkv, max=self.config.clip_qkv)\n+            key_states.clamp_(min=-self.config.clip_qkv, max=self.config.clip_qkv)\n+            value_states.clamp_(min=-self.config.clip_qkv, max=self.config.clip_qkv)\n+\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        key_states = repeat_kv(key_states, self.num_key_value_groups)\n+        value_states = repeat_kv(value_states, self.num_key_value_groups)\n+\n+        causal_mask = attention_mask\n+        # if attention_mask is not None and cache_position is not None:\n+        if attention_mask is not None:\n+            causal_mask = causal_mask[:, :, :, : key_states.shape[-2]]\n+\n+        # SDPA with memory-efficient backend is currently (torch==2.1.2) bugged with non-contiguous inputs with custom attn_mask,\n+        # Reference: https://github.com/pytorch/pytorch/issues/112577.\n+        if query_states.device.type == \"cuda\" and causal_mask is not None:\n+            query_states = query_states.contiguous()\n+            key_states = key_states.contiguous()\n+            value_states = value_states.contiguous()\n+\n+        # We dispatch to SDPA's Flash Attention or Efficient kernels via this `is_causal` if statement instead of an inline conditional assignment\n+        # in SDPA to support both torch.compile's dynamic shapes and full graph options. An inline conditional prevents dynamic shapes from compiling.\n+        is_causal = True if causal_mask is None and q_len > 1 else False\n+\n+        attn_output = torch.nn.functional.scaled_dot_product_attention(\n+            query_states,\n+            key_states,\n+            value_states,\n+            attn_mask=causal_mask,\n+            dropout_p=self.attention_dropout if self.training else 0.0,\n+            is_causal=is_causal,\n+        )\n+\n+        attn_output = attn_output.transpose(1, 2).contiguous()\n+        attn_output = attn_output.view(bsz, q_len, self.hidden_size)\n+\n+        attn_output = self.o_proj(attn_output)\n+\n+        return attn_output, None, past_key_value\n+\n+\n+OLMOE_ATTENTION_CLASSES = {\n+    \"eager\": OlmoeAttention,\n+    \"flash_attention_2\": OlmoeFlashAttention2,\n+    \"sdpa\": OlmoeSdpaAttention,\n+}\n+\n+\n+class OlmoeSparseMoeBlock(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.num_experts = config.num_experts\n+        self.top_k = config.num_experts_per_tok\n+        self.norm_topk_prob = config.norm_topk_prob\n+        self.gate = nn.Linear(config.hidden_size, self.num_experts, bias=False)\n+        self.experts = nn.ModuleList([OlmoeMLP(config) for _ in range(self.num_experts)])\n+\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        batch_size, sequence_length, hidden_dim = hidden_states.shape\n+        hidden_states = hidden_states.view(-1, hidden_dim)\n+        # router_logits: (batch * sequence_length, n_experts)\n+        router_logits = self.gate(hidden_states)\n+\n+        routing_weights = F.softmax(router_logits, dim=1, dtype=torch.float)\n+        routing_weights, selected_experts = torch.topk(routing_weights, self.top_k, dim=-1)\n+        if self.norm_topk_prob:\n+            routing_weights /= routing_weights.sum(dim=-1, keepdim=True)\n+        # we cast back to the input dtype\n+        routing_weights = routing_weights.to(hidden_states.dtype)\n+\n+        final_hidden_states = torch.zeros(\n+            (batch_size * sequence_length, hidden_dim), dtype=hidden_states.dtype, device=hidden_states.device\n+        )\n+\n+        # One hot encode the selected experts to create an expert mask\n+        # this will be used to easily index which expert is going to be selected\n+        expert_mask = torch.nn.functional.one_hot(selected_experts, num_classes=self.num_experts).permute(2, 1, 0)\n+\n+        # Loop over all available experts in the model and perform the computation on each expert\n+        for expert_idx in range(self.num_experts):\n+            expert_layer = self.experts[expert_idx]\n+            idx, top_x = torch.where(expert_mask[expert_idx])\n+\n+            # Index the correct hidden states and compute the expert hidden state for\n+            # the current expert. We need to make sure to multiply the output hidden\n+            # states by `routing_weights` on the corresponding tokens (top-1 and top-2)\n+            current_state = hidden_states[None, top_x].reshape(-1, hidden_dim)\n+            current_hidden_states = expert_layer(current_state) * routing_weights[top_x, idx, None]\n+\n+            # However `index_add_` only support torch tensors for indexing so we'll use\n+            # the `top_x` tensor here.\n+            final_hidden_states.index_add_(0, top_x, current_hidden_states.to(hidden_states.dtype))\n+        final_hidden_states = final_hidden_states.reshape(batch_size, sequence_length, hidden_dim)\n+        return final_hidden_states, router_logits\n+\n+\n+class OlmoeDecoderLayer(nn.Module):\n+    def __init__(self, config: OlmoeConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        self.self_attn = OLMOE_ATTENTION_CLASSES[config._attn_implementation](config=config, layer_idx=layer_idx)\n+\n+        self.mlp = OlmoeSparseMoeBlock(config)\n+        self.input_layernorm = OlmoeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = OlmoeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: Optional[bool] = False,\n+        output_router_logits: Optional[bool] = False,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,\n+        **kwargs,\n+    ) -> Tuple[torch.FloatTensor, Optional[Tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.FloatTensor`): input to the layer of shape `(batch, seq_len, embed_dim)`\n+            attention_mask (`torch.FloatTensor`, *optional*):\n+                attention mask of size `(batch_size, sequence_length)` if flash attention is used or `(batch_size, 1,\n+                query_sequence_length, key_sequence_length)` if default attention is used.\n+            output_attentions (`bool`, *optional*):\n+                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n+                returned tensors for more detail.\n+            output_router_logits (`bool`, *optional*):\n+                Whether or not to return the logits of all the routers. They are useful for computing the router loss,\n+                and should not be returned during inference.\n+            use_cache (`bool`, *optional*):\n+                If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding\n+                (see `past_key_values`).\n+            past_key_value (`Tuple(torch.FloatTensor)`, *optional*): cached past key and value projection states\n+            cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n+                Indices depicting the position of the input sequence tokens in the sequence\n+            position_embeddings (`Tuple[torch.FloatTensor, torch.FloatTensor]`, *optional*):\n+                Tuple containing the cosine and sine positional embeddings of shape `(batch_size, seq_len, head_dim)`,\n+                with `head_dim` being the embedding dimension of each attention head.\n+            kwargs (`dict`, *optional*):\n+                Arbitrary kwargs to be ignored, used for FSDP and other methods that injects code\n+                into the model\n+        \"\"\"\n+        residual = hidden_states\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # Self Attention\n+        hidden_states, self_attn_weights, present_key_value = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states, router_logits = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        outputs = (hidden_states,)\n+\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        if use_cache:\n+            outputs += (present_key_value,)\n+\n+        if output_router_logits:\n+            outputs += (router_logits,)\n+\n+        return outputs\n+\n+\n+OLMOE_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`OlmoeConfig`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare Olmoe Model outputting raw hidden-states without any specific head on top.\",\n+    OLMOE_START_DOCSTRING,\n+)\n+# Copied from transformers.models.llama.modeling_llama.LlamaPreTrainedModel with Llama->Olmoe\n+class OlmoePreTrainedModel(PreTrainedModel):\n+    config_class = OlmoeConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"OlmoeDecoderLayer\"]\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = True\n+    _supports_cache_class = True\n+    _supports_quantized_cache = True\n+    _supports_static_cache = True\n+\n+    def _init_weights(self, module):\n+        std = self.config.initializer_range\n+        if isinstance(module, nn.Linear):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+\n+\n+OLMOE_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+            it.\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            [What are input IDs?](../glossary#input-ids)\n+        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+            - 1 for tokens that are **not masked**,\n+            - 0 for tokens that are **masked**.\n+\n+            [What are attention masks?](../glossary#attention-mask)\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            If `past_key_values` is used, optionally only the last `input_ids` have to be input (see\n+            `past_key_values`).\n+\n+            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n+            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n+            information on the default strategy.\n+\n+            - 1 indicates the head is **not masked**,\n+            - 0 indicates the head is **masked**.\n+        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n+            config.n_positions - 1]`.\n+\n+            [What are position IDs?](../glossary#position-ids)\n+        past_key_values (`Cache` or `tuple(tuple(torch.FloatTensor))`, *optional*):\n+            Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n+            blocks) that can be used to speed up sequential decoding. This typically consists in the `past_key_values`\n+            returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n+\n+            Two formats are allowed:\n+            - a [`~cache_utils.Cache`] instance;\n+            - Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of\n+            shape `(batch_size, num_heads, sequence_length, embed_size_per_head)`). This is also known as the legacy\n+            cache format.\n+\n+            The model will output the same cache format that is fed as input. If no `past_key_values` are passed, the\n+            legacy cache format will be returned.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `input_ids` (those that don't\n+            have their past key value states given to this model) of shape `(batch_size, 1)` instead of all `input_ids`\n+            of shape `(batch_size, sequence_length)`.\n+        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n+            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n+            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n+            model's internal embedding lookup matrix.\n+        use_cache (`bool`, *optional*):\n+            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n+            `past_key_values`).\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+        output_router_logits (`bool`, *optional*):\n+            Whether or not to return the logits of all the routers. They are useful for computing the router loss, and\n+            should not be returned during inference.\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+        cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n+            Indices depicting the position of the input sequence tokens in the sequence. Contrarily to `position_ids`,\n+            this tensor is not affected by padding. It is used to update the cache in the correct position and to infer\n+            the complete sequence length.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare Olmoe Model outputting raw hidden-states without any specific head on top.\",\n+    OLMOE_START_DOCSTRING,\n+)\n+# Copied from transformers.models.llama.modeling_llama.LlamaModel with Llama->Olmoe\n+class OlmoeModel(OlmoePreTrainedModel):\n+    \"\"\"\n+    Transformer decoder consisting of *config.num_hidden_layers* layers. Each layer is a [`OlmoeDecoderLayer`]\n+\n+    Args:\n+        config: OlmoeConfig\n+    \"\"\"\n+\n+    def __init__(self, config: OlmoeConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [OlmoeDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = OlmoeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = OlmoeRotaryEmbedding(config=config)\n+        self.gradient_checkpointing = False\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.embed_tokens = value\n+\n+    @add_start_docstrings_to_model_forward(OLMOE_INPUTS_DOCSTRING)\n+    # Ignore copy\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        output_router_logits: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+    ) -> Union[Tuple, MoeModelOutputWithPast]:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_router_logits = (\n+            output_router_logits if output_router_logits is not None else self.config.output_router_logits\n+        )\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\n+                \"You cannot specify both input_ids and inputs_embeds at the same time, and must specify either one\"\n+            )\n+\n+        if self.gradient_checkpointing and self.training and use_cache:\n+            logger.warning_once(\n+                \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`.\"\n+            )\n+            use_cache = False\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        return_legacy_cache = False\n+        if use_cache and not isinstance(past_key_values, Cache):  # kept for BC (non `Cache` `past_key_values` inputs)\n+            return_legacy_cache = True\n+            past_key_values = DynamicCache.from_legacy_cache(past_key_values)\n+            logger.warning_once(\n+                \"We detected that you are passing `past_key_values` as a tuple and this is deprecated and will be removed in v4.43. \"\n+                \"Please use an appropriate `Cache` class (https://huggingface.co/docs/transformers/v4.41.3/en/internal/generation_utils#transformers.Cache)\"\n+            )\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        causal_mask = self._update_causal_mask(\n+            attention_mask, inputs_embeds, cache_position, past_key_values, output_attentions\n+        )\n+\n+        # embed positions\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+        all_router_logits = () if output_router_logits else None\n+        next_decoder_cache = None\n+\n+        for decoder_layer in self.layers:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            if self.gradient_checkpointing and self.training:\n+                layer_outputs = self._gradient_checkpointing_func(\n+                    decoder_layer.__call__,\n+                    hidden_states,\n+                    causal_mask,\n+                    position_ids,\n+                    past_key_values,\n+                    output_attentions,\n+                    output_router_logits,\n+                    use_cache,\n+                    cache_position,\n+                    position_embeddings,\n+                )\n+            else:\n+                layer_outputs = decoder_layer(\n+                    hidden_states,\n+                    attention_mask=causal_mask,\n+                    position_ids=position_ids,\n+                    past_key_value=past_key_values,\n+                    output_attentions=output_attentions,\n+                    output_router_logits=output_router_logits,\n+                    use_cache=use_cache,\n+                    cache_position=cache_position,\n+                    position_embeddings=position_embeddings,\n+                )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if use_cache:\n+                next_decoder_cache = layer_outputs[2 if output_attentions else 1]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+            if output_router_logits and layer_outputs[-1] is not None:\n+                all_router_logits += (layer_outputs[-1],)\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        # add hidden states from the last decoder layer\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        next_cache = next_decoder_cache if use_cache else None\n+        if return_legacy_cache:\n+            next_cache = next_cache.to_legacy_cache()\n+\n+        if not return_dict:\n+            return tuple(v for v in [hidden_states, next_cache, all_hidden_states, all_self_attns] if v is not None)\n+        return MoeModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=next_cache,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+            router_logits=all_router_logits,\n+        )\n+\n+    def _update_causal_mask(\n+        self,\n+        attention_mask: torch.Tensor,\n+        input_tensor: torch.Tensor,\n+        cache_position: torch.Tensor,\n+        past_key_values: Cache,\n+        output_attentions: bool,\n+    ):\n+        if self.config._attn_implementation == \"flash_attention_2\":\n+            if attention_mask is not None and 0.0 in attention_mask:\n+                return attention_mask\n+            return None\n+\n+        # For SDPA, when possible, we will rely on its `is_causal` argument instead of its `attn_mask` argument, in\n+        # order to dispatch on Flash Attention 2. This feature is not compatible with static cache, as SDPA will fail\n+        # to infer the attention mask.\n+        past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+        using_static_cache = isinstance(past_key_values, StaticCache)\n+\n+        # When output attentions is True, sdpa implementation's forward method calls the eager implementation's forward\n+        if self.config._attn_implementation == \"sdpa\" and not using_static_cache and not output_attentions:\n+            if AttentionMaskConverter._ignore_causal_mask_sdpa(\n+                attention_mask,\n+                inputs_embeds=input_tensor,\n+                past_key_values_length=past_seen_tokens,\n+                is_training=self.training,\n+            ):\n+                return None\n+\n+        dtype, device = input_tensor.dtype, input_tensor.device\n+        min_dtype = torch.finfo(dtype).min\n+        sequence_length = input_tensor.shape[1]\n+        if using_static_cache:\n+            target_length = past_key_values.get_max_length()\n+        else:\n+            target_length = (\n+                attention_mask.shape[-1]\n+                if isinstance(attention_mask, torch.Tensor)\n+                else past_seen_tokens + sequence_length + 1\n+            )\n+\n+        # In case the provided `attention` mask is 2D, we generate a causal mask here (4D).\n+        causal_mask = _prepare_4d_causal_attention_mask_with_cache_position(\n+            attention_mask,\n+            sequence_length=sequence_length,\n+            target_length=target_length,\n+            dtype=dtype,\n+            device=device,\n+            min_dtype=min_dtype,\n+            cache_position=cache_position,\n+            batch_size=input_tensor.shape[0],\n+        )\n+\n+        if (\n+            self.config._attn_implementation == \"sdpa\"\n+            and attention_mask is not None\n+            and attention_mask.device.type == \"cuda\"\n+            and not output_attentions\n+        ):\n+            # Attend to all tokens in fully masked rows in the causal_mask, for example the relevant first rows when\n+            # using left padding. This is required by F.scaled_dot_product_attention memory-efficient attention path.\n+            # Details: https://github.com/pytorch/pytorch/issues/110213\n+            causal_mask = AttentionMaskConverter._unmask_unattended(causal_mask, min_dtype)\n+\n+        return causal_mask\n+\n+\n+class OlmoeForCausalLM(OlmoePreTrainedModel):\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = OlmoeModel(config)\n+        self.vocab_size = config.vocab_size\n+        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n+\n+        self.router_aux_loss_coef = config.router_aux_loss_coef\n+        self.num_experts = config.num_experts\n+        self.num_experts_per_tok = config.num_experts_per_tok\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    def get_output_embeddings(self):\n+        return self.lm_head\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.lm_head = new_embeddings\n+\n+    def set_decoder(self, decoder):\n+        self.model = decoder\n+\n+    def get_decoder(self):\n+        return self.model\n+\n+    @add_start_docstrings_to_model_forward(OLMOE_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=MoeCausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        output_router_logits: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        num_logits_to_keep: int = 0,\n+    ) -> Union[Tuple, MoeCausalLMOutputWithPast]:\n+        r\"\"\"\n+        Args:\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+            num_logits_to_keep (`int`, *optional*):\n+                Calculate logits for the last `num_logits_to_keep` tokens. If `0`, calculate logits for all\n+                `input_ids` (special case). Only last token logits are needed for generation, and calculating them only for that\n+                token can save memory, which becomes pretty significant for long sequences or large vocabulary size.\n+\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, OlmoeForCausalLM\n+\n+        >>> model = OlmoeForCausalLM.from_pretrained(\"allenai/OLMoE-1B-7B-0824\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"allenai/OLMoE-1B-7B-0824\")\n+\n+        >>> prompt = \"Hey, are you conscious? Can you talk to me?\"\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        'Hey, are you conscious? Can you talk to me?\\nI’m not sure if you’re conscious of this, but I’m'\n+        ```\n+        \"\"\"\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_router_logits = (\n+            output_router_logits if output_router_logits is not None else self.config.output_router_logits\n+        )\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            output_router_logits=output_router_logits,\n+            return_dict=return_dict,\n+            cache_position=cache_position,\n+        )\n+\n+        hidden_states = outputs[0]\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        logits = self.lm_head(hidden_states[:, -num_logits_to_keep:, :])\n+\n+        loss = None\n+        if labels is not None:\n+            # Upcast to float if we need to compute the loss to avoid potential precision issues\n+            logits = logits.float()\n+            # Shift so that tokens < n predict n\n+            shift_logits = logits[..., :-1, :].contiguous()\n+            shift_labels = labels[..., 1:].contiguous()\n+            # Flatten the tokens\n+            loss_fct = CrossEntropyLoss()\n+            shift_logits = shift_logits.view(-1, self.config.vocab_size)\n+            shift_labels = shift_labels.view(-1)\n+            # Enable model parallelism\n+            shift_labels = shift_labels.to(shift_logits.device)\n+            loss = loss_fct(shift_logits, shift_labels)\n+\n+        aux_loss = None\n+        if output_router_logits:\n+            aux_loss = load_balancing_loss_func(\n+                outputs.router_logits if return_dict else outputs[-1],\n+                self.num_experts,\n+                self.num_experts_per_tok,\n+                attention_mask,\n+            )\n+            if labels is not None:\n+                loss += self.router_aux_loss_coef * aux_loss.to(loss.device)  # make sure to reside in the same device\n+\n+        if not return_dict:\n+            output = (logits,) + outputs[1:]\n+            if output_router_logits:\n+                output = (aux_loss,) + output\n+            return (loss,) + output if loss is not None else output\n+\n+        return MoeCausalLMOutputWithPast(\n+            loss=loss,\n+            aux_loss=aux_loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            router_logits=outputs.router_logits,\n+        )\n+\n+    # Copied from transformers.models.olmo.modeling_olmo.OlmoForCausalLM.prepare_inputs_for_generation\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        attention_mask=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        position_ids=None,\n+        use_cache=True,\n+        num_logits_to_keep=0,\n+        **kwargs,\n+    ):\n+        # If we have cache: let's slice `input_ids` through `cache_position`, to keep only the unprocessed tokens\n+        # Exception 1: when passing input_embeds, input_ids may be missing entries\n+        # Exception 2: some generation methods do special slicing of input_ids, so we don't need to do it here\n+        if past_key_values is not None:\n+            if inputs_embeds is not None:  # Exception 1\n+                input_ids = input_ids[:, -cache_position.shape[0] :]\n+            elif input_ids.shape[1] != cache_position.shape[0]:  # Default case (the \"else\", a no op, is Exception 2)\n+                input_ids = input_ids[:, cache_position]\n+\n+        if attention_mask is not None and position_ids is None:\n+            # create position_ids on the fly for batch generation\n+            position_ids = attention_mask.long().cumsum(-1) - 1\n+            position_ids.masked_fill_(attention_mask == 0, 1)\n+            if past_key_values:\n+                position_ids = position_ids[:, -input_ids.shape[1] :]\n+\n+                # This `clone` call is needed to avoid recapturing cuda graphs with `torch.compile`'s  `mode=\"reduce-overhead`, as otherwise the input `position_ids` would have various stride during the decoding. Here, simply using `.contiguous()` is not sufficient as in the batch size = 1 case, `position_ids` is already contiguous but with varying stride which retriggers a capture.\n+                position_ids = position_ids.clone(memory_format=torch.contiguous_format)\n+\n+        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n+        if inputs_embeds is not None and cache_position[0] == 0:\n+            model_inputs = {\"inputs_embeds\": inputs_embeds, \"input_ids\": None}\n+        else:\n+            # The clone here is for the same reason as for `position_ids`.\n+            model_inputs = {\"input_ids\": input_ids.clone(memory_format=torch.contiguous_format), \"inputs_embeds\": None}\n+\n+        if isinstance(past_key_values, StaticCache) and attention_mask.ndim == 2:\n+            if model_inputs[\"inputs_embeds\"] is not None:\n+                batch_size, sequence_length, _ = model_inputs[\"inputs_embeds\"].shape\n+                device = model_inputs[\"inputs_embeds\"].device\n+            else:\n+                batch_size, sequence_length = model_inputs[\"input_ids\"].shape\n+                device = model_inputs[\"input_ids\"].device\n+\n+            dtype = self.lm_head.weight.dtype\n+            min_dtype = torch.finfo(dtype).min\n+\n+            attention_mask = _prepare_4d_causal_attention_mask_with_cache_position(\n+                attention_mask,\n+                sequence_length=sequence_length,\n+                target_length=past_key_values.get_max_length(),\n+                dtype=dtype,\n+                device=device,\n+                min_dtype=min_dtype,\n+                cache_position=cache_position,\n+                batch_size=batch_size,\n+            )\n+\n+        model_inputs.update(\n+            {\n+                \"position_ids\": position_ids,\n+                \"cache_position\": cache_position,\n+                \"past_key_values\": past_key_values,\n+                \"use_cache\": use_cache,\n+                \"attention_mask\": attention_mask,\n+                \"num_logits_to_keep\": num_logits_to_keep,\n+            }\n+        )\n+        return model_inputs"
        },
        {
            "sha": "edd8d87e7ddc8e0f1b303711efc860e8e12661d8",
            "filename": "src/transformers/utils/dummy_pt_objects.py",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -6590,6 +6590,27 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torch\"])\n \n \n+class OlmoeForCausalLM(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class OlmoeModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class OlmoePreTrainedModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n class OneFormerForUniversalSegmentation(metaclass=DummyObject):\n     _backends = [\"torch\"]\n "
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/olmoe/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/tests%2Fmodels%2Folmoe%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/tests%2Fmodels%2Folmoe%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Folmoe%2F__init__.py?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25"
        },
        {
            "sha": "1ce231e0373152e5c353ec622bfa43353c58d646",
            "filename": "tests/models/olmoe/test_modeling_olmoe.py",
            "status": "added",
            "additions": 442,
            "deletions": 0,
            "changes": 442,
            "blob_url": "https://github.com/huggingface/transformers/blob/ecd61c62862f925a18b4f063dc17fcaf01826e25/tests%2Fmodels%2Folmoe%2Ftest_modeling_olmoe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ecd61c62862f925a18b4f063dc17fcaf01826e25/tests%2Fmodels%2Folmoe%2Ftest_modeling_olmoe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Folmoe%2Ftest_modeling_olmoe.py?ref=ecd61c62862f925a18b4f063dc17fcaf01826e25",
            "patch": "@@ -0,0 +1,442 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch OLMoE model.\"\"\"\n+\n+import unittest\n+\n+from parameterized import parameterized\n+\n+from transformers import OlmoeConfig, is_torch_available, set_seed\n+from transformers.models.auto.tokenization_auto import AutoTokenizer\n+from transformers.models.gpt_neox.tokenization_gpt_neox_fast import GPTNeoXTokenizerFast\n+from transformers.testing_utils import (\n+    is_flaky,\n+    require_tokenizers,\n+    require_torch,\n+    require_torch_sdpa,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import ModelTesterMixin, ids_tensor\n+from ...test_pipeline_mixin import PipelineTesterMixin\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import (\n+        OlmoeForCausalLM,\n+        OlmoeModel,\n+    )\n+\n+\n+class OlmoeModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=13,\n+        seq_length=7,\n+        is_training=True,\n+        use_input_mask=True,\n+        use_token_type_ids=False,\n+        use_labels=True,\n+        vocab_size=99,\n+        hidden_size=32,\n+        num_hidden_layers=2,\n+        num_attention_heads=4,\n+        hidden_act=\"silu\",\n+        hidden_dropout_prob=0.1,\n+        attention_probs_dropout_prob=0.1,\n+        max_position_embeddings=512,\n+        type_vocab_size=16,\n+        type_sequence_label_size=2,\n+        initializer_range=0.02,\n+        num_labels=3,\n+        num_choices=4,\n+        pad_token_id=0,\n+        scope=None,\n+        num_experts_per_tok=2,\n+        num_experts=8,\n+        norm_topk_prob=False,\n+        output_router_logits=False,\n+        router_aux_loss_coef=0.001,\n+        intermediate_size=12,\n+    ):\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.seq_length = seq_length\n+        self.is_training = is_training\n+        self.use_input_mask = use_input_mask\n+        self.use_token_type_ids = use_token_type_ids\n+        self.use_labels = use_labels\n+        self.vocab_size = vocab_size\n+        self.hidden_size = hidden_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.intermediate_size = intermediate_size\n+        self.hidden_act = hidden_act\n+        self.hidden_dropout_prob = hidden_dropout_prob\n+        self.attention_probs_dropout_prob = attention_probs_dropout_prob\n+        self.max_position_embeddings = max_position_embeddings\n+        self.type_vocab_size = type_vocab_size\n+        self.type_sequence_label_size = type_sequence_label_size\n+        self.initializer_range = initializer_range\n+        self.num_labels = num_labels\n+        self.num_choices = num_choices\n+        self.pad_token_id = pad_token_id\n+        self.scope = scope\n+        self.num_experts_per_tok = num_experts_per_tok\n+        self.num_experts = num_experts\n+        self.norm_topk_prob = norm_topk_prob\n+        self.output_router_logits = output_router_logits\n+        self.router_aux_loss_coef = router_aux_loss_coef\n+\n+    def prepare_config_and_inputs(self):\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], self.vocab_size)\n+\n+        input_mask = None\n+        if self.use_input_mask:\n+            input_mask = torch.tril(torch.ones(self.batch_size, self.seq_length)).to(torch_device)\n+\n+        token_type_ids = None\n+        if self.use_token_type_ids:\n+            token_type_ids = ids_tensor([self.batch_size, self.seq_length], self.type_vocab_size)\n+\n+        sequence_labels = None\n+        token_labels = None\n+        choice_labels = None\n+        if self.use_labels:\n+            sequence_labels = ids_tensor([self.batch_size], self.type_sequence_label_size)\n+            token_labels = ids_tensor([self.batch_size, self.seq_length], self.num_labels)\n+            choice_labels = ids_tensor([self.batch_size], self.num_choices)\n+\n+        config = self.get_config()\n+\n+        return config, input_ids, token_type_ids, input_mask, sequence_labels, token_labels, choice_labels\n+\n+    def get_config(self):\n+        return OlmoeConfig(\n+            vocab_size=self.vocab_size,\n+            hidden_size=self.hidden_size,\n+            num_hidden_layers=self.num_hidden_layers,\n+            num_attention_heads=self.num_attention_heads,\n+            intermediate_size=self.intermediate_size,\n+            hidden_act=self.hidden_act,\n+            hidden_dropout_prob=self.hidden_dropout_prob,\n+            attention_probs_dropout_prob=self.attention_probs_dropout_prob,\n+            max_position_embeddings=self.max_position_embeddings,\n+            type_vocab_size=self.type_vocab_size,\n+            is_decoder=False,\n+            initializer_range=self.initializer_range,\n+            pad_token_id=self.pad_token_id,\n+            num_experts_per_tok=self.num_experts_per_tok,\n+            num_experts=self.num_experts,\n+            norm_topk_prob=self.norm_topk_prob,\n+            output_router_logits=self.output_router_logits,\n+            router_aux_loss_coef=self.router_aux_loss_coef,\n+        )\n+\n+    def create_and_check_model(\n+        self, config, input_ids, token_type_ids, input_mask, sequence_labels, token_labels, choice_labels\n+    ):\n+        model = OlmoeModel(config=config)\n+        model.to(torch_device)\n+        model.eval()\n+        result = model(input_ids, attention_mask=input_mask)\n+        result = model(input_ids)\n+        self.parent.assertEqual(result.last_hidden_state.shape, (self.batch_size, self.seq_length, self.hidden_size))\n+\n+    def create_and_check_model_as_decoder(\n+        self,\n+        config,\n+        input_ids,\n+        token_type_ids,\n+        input_mask,\n+        sequence_labels,\n+        token_labels,\n+        choice_labels,\n+        encoder_hidden_states,\n+        encoder_attention_mask,\n+    ):\n+        config.add_cross_attention = True\n+        model = OlmoeModel(config)\n+        model.to(torch_device)\n+        model.eval()\n+        result = model(\n+            input_ids,\n+            attention_mask=input_mask,\n+            encoder_hidden_states=encoder_hidden_states,\n+            encoder_attention_mask=encoder_attention_mask,\n+        )\n+        result = model(\n+            input_ids,\n+            attention_mask=input_mask,\n+            encoder_hidden_states=encoder_hidden_states,\n+        )\n+        result = model(input_ids, attention_mask=input_mask)\n+        self.parent.assertEqual(result.last_hidden_state.shape, (self.batch_size, self.seq_length, self.hidden_size))\n+\n+    def create_and_check_for_causal_lm(\n+        self,\n+        config,\n+        input_ids,\n+        token_type_ids,\n+        input_mask,\n+        sequence_labels,\n+        token_labels,\n+        choice_labels,\n+        encoder_hidden_states,\n+        encoder_attention_mask,\n+    ):\n+        model = OlmoeForCausalLM(config=config)\n+        model.to(torch_device)\n+        model.eval()\n+        result = model(input_ids, attention_mask=input_mask, labels=token_labels)\n+        self.parent.assertEqual(result.logits.shape, (self.batch_size, self.seq_length, self.vocab_size))\n+\n+    def create_and_check_decoder_model_past_large_inputs(\n+        self,\n+        config,\n+        input_ids,\n+        token_type_ids,\n+        input_mask,\n+        sequence_labels,\n+        token_labels,\n+        choice_labels,\n+        encoder_hidden_states,\n+        encoder_attention_mask,\n+    ):\n+        config.is_decoder = True\n+        config.add_cross_attention = True\n+        model = OlmoeForCausalLM(config=config)\n+        model.to(torch_device)\n+        model.eval()\n+\n+        # first forward pass\n+        outputs = model(\n+            input_ids,\n+            attention_mask=input_mask,\n+            encoder_hidden_states=encoder_hidden_states,\n+            encoder_attention_mask=encoder_attention_mask,\n+            use_cache=True,\n+        )\n+        past_key_values = outputs.past_key_values\n+\n+        # create hypothetical multiple next token and extent to next_input_ids\n+        next_tokens = ids_tensor((self.batch_size, 3), config.vocab_size)\n+        next_mask = ids_tensor((self.batch_size, 3), vocab_size=2)\n+\n+        # append to next input_ids and\n+        next_input_ids = torch.cat([input_ids, next_tokens], dim=-1)\n+        next_attention_mask = torch.cat([input_mask, next_mask], dim=-1)\n+\n+        output_from_no_past = model(\n+            next_input_ids,\n+            attention_mask=next_attention_mask,\n+            encoder_hidden_states=encoder_hidden_states,\n+            encoder_attention_mask=encoder_attention_mask,\n+            output_hidden_states=True,\n+        )[\"hidden_states\"][0]\n+        output_from_past = model(\n+            next_tokens,\n+            attention_mask=next_attention_mask,\n+            encoder_hidden_states=encoder_hidden_states,\n+            encoder_attention_mask=encoder_attention_mask,\n+            past_key_values=past_key_values,\n+            output_hidden_states=True,\n+        )[\"hidden_states\"][0]\n+\n+        # select random slice\n+        random_slice_idx = ids_tensor((1,), output_from_past.shape[-1]).item()\n+        output_from_no_past_slice = output_from_no_past[:, -3:, random_slice_idx].detach()\n+        output_from_past_slice = output_from_past[:, :, random_slice_idx].detach()\n+\n+        self.parent.assertTrue(output_from_past_slice.shape[1] == next_tokens.shape[1])\n+\n+        # test that outputs are equal for slice\n+        self.parent.assertTrue(torch.allclose(output_from_past_slice, output_from_no_past_slice, atol=1e-3))\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        (\n+            config,\n+            input_ids,\n+            token_type_ids,\n+            input_mask,\n+            sequence_labels,\n+            token_labels,\n+            choice_labels,\n+        ) = config_and_inputs\n+        inputs_dict = {\"input_ids\": input_ids, \"attention_mask\": input_mask}\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class OlmoeModelTest(ModelTesterMixin, GenerationTesterMixin, PipelineTesterMixin, unittest.TestCase):\n+    all_model_classes = (OlmoeModel, OlmoeForCausalLM) if is_torch_available() else ()\n+    all_generative_model_classes = (OlmoeForCausalLM,) if is_torch_available() else ()\n+    pipeline_model_mapping = (\n+        {\n+            \"feature-extraction\": OlmoeModel,\n+            \"text-generation\": OlmoeForCausalLM,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+    test_pruning = False\n+    fx_compatible = False\n+\n+    # Need to use `0.8` instead of `0.9` for `test_cpu_offload`\n+    # This is because we are hitting edge cases with the causal_mask buffer\n+    model_split_percents = [0.5, 0.7, 0.8]\n+\n+    def setUp(self):\n+        self.model_tester = OlmoeModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=OlmoeConfig, hidden_size=37)\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    def test_model(self):\n+        config_and_inputs = self.model_tester.prepare_config_and_inputs()\n+        self.model_tester.create_and_check_model(*config_and_inputs)\n+\n+    @unittest.skip(reason=\"OLMoE does not support head pruning.\")\n+    def test_headmasking(self):\n+        pass\n+\n+    def test_model_various_embeddings(self):\n+        config_and_inputs = self.model_tester.prepare_config_and_inputs()\n+        for type in [\"absolute\", \"relative_key\", \"relative_key_query\"]:\n+            config_and_inputs[0].position_embedding_type = type\n+            self.model_tester.create_and_check_model(*config_and_inputs)\n+\n+    @unittest.skip(reason=\"OLMoE buffers include complex numbers, which breaks this test\")\n+    def test_save_load_fast_init_from_base(self):\n+        pass\n+\n+    # TODO: @Fxmarty\n+    @is_flaky(max_attempts=3, description=\"flaky on some models.\")\n+    @require_torch_sdpa\n+    @slow\n+    def test_eager_matches_sdpa_generate(self):\n+        super().test_eager_matches_sdpa_generate()\n+\n+    @parameterized.expand([(\"linear\",), (\"dynamic\",)])\n+    def test_model_rope_scaling(self, scaling_type):\n+        config, _ = self.model_tester.prepare_config_and_inputs_for_common()\n+        short_input = ids_tensor([1, 10], config.vocab_size)\n+        long_input = ids_tensor([1, int(config.max_position_embeddings * 1.5)], config.vocab_size)\n+\n+        set_seed(42)  # Fixed seed at init time so the two models get the same random weights\n+        original_model = OlmoeModel(config)\n+        original_model.to(torch_device)\n+        original_model.eval()\n+        original_short_output = original_model(short_input).last_hidden_state\n+        original_long_output = original_model(long_input).last_hidden_state\n+\n+        set_seed(42)  # Fixed seed at init time so the two models get the same random weights\n+        config.rope_scaling = {\"type\": scaling_type, \"factor\": 10.0}\n+        scaled_model = OlmoeModel(config)\n+        scaled_model.to(torch_device)\n+        scaled_model.eval()\n+        scaled_short_output = scaled_model(short_input).last_hidden_state\n+        scaled_long_output = scaled_model(long_input).last_hidden_state\n+\n+        # Dynamic scaling does not change the RoPE embeddings until it receives an input longer than the original\n+        # maximum sequence length, so the outputs for the short input should match.\n+        if scaling_type == \"dynamic\":\n+            self.assertTrue(torch.allclose(original_short_output, scaled_short_output, atol=1e-5))\n+        else:\n+            self.assertFalse(torch.allclose(original_short_output, scaled_short_output, atol=1e-5))\n+\n+        # The output should be different for long inputs\n+        self.assertFalse(torch.allclose(original_long_output, scaled_long_output, atol=1e-5))\n+\n+\n+@require_torch\n+class OlmoeIntegrationTest(unittest.TestCase):\n+    @slow\n+    def test_model_7b_logits(self):\n+        input_ids = [[1, 306, 4658, 278, 6593, 310, 2834, 338]]\n+        model = OlmoeForCausalLM.from_pretrained(\"allenai/OLMoE-1B-7B-0924\", device_map=\"auto\")\n+        out = model(torch.tensor(input_ids)).logits\n+        # Expected mean on dim = -1\n+        EXPECTED_MEAN = torch.tensor([[-1.3814, -3.4450, -2.2990, -1.9542, -2.4387, -2.7941, -2.9312, -2.8309]])\n+        torch.testing.assert_close(out.mean(-1), EXPECTED_MEAN, atol=1e-2, rtol=1e-2)\n+        # slicing logits[0, 0, 0:30]\n+        EXPECTED_SLICE = torch.tensor([-2.3874, -2.4076, -2.4995, 4.2278, 1.4004, -0.0252, 0.4189, -2.7560, 0.3531, 1.6678, -0.7941, -1.1818, -0.2920, 0.7131, -1.4173, 1.6723, 0.5406, 0.1345, -0.1800, 0.2304, 1.2791, 0.7489, 0.6341, -0.0151, -1.3693, -1.2532, -2.3921, 0.7376, 1.6876, 0.5483])  # fmt: skip\n+        torch.testing.assert_close(out[0, 0, :30], EXPECTED_SLICE, atol=1e-2, rtol=1e-2)\n+\n+    @slow\n+    def test_model_7b_greedy_generation(self):\n+        EXPECTED_TEXT_COMPLETION = \"\"\"Simply put, the theory of relativity states that \\nthe speed of light is the same for all observers, no matter \\nhow fast they are moving.  This is a very counter-intuitive \\nconcept, and it took Einstein a long time to come up with \\nthe theory.  The theory of relativity is based on two \\npostulates\"\"\"\n+        prompt = \"Simply put, the theory of relativity states that \"\n+        tokenizer = AutoTokenizer.from_pretrained(\"allenai/OLMoE-1B-7B-0924\", device_map=\"auto\")\n+        input_ids = tokenizer.encode(prompt, return_tensors=\"pt\")\n+        model = OlmoeForCausalLM.from_pretrained(\"allenai/OLMoE-1B-7B-0924\", device_map=\"auto\")\n+\n+        # greedy generation outputs\n+        generated_ids = model.generate(input_ids, max_new_tokens=64, top_p=None, temperature=1, do_sample=False)\n+        text = tokenizer.decode(generated_ids[0], skip_special_tokens=True)\n+        self.assertEqual(EXPECTED_TEXT_COMPLETION, text)\n+\n+    @require_tokenizers\n+    def test_fast_special_tokens(self):\n+        fast_tokenizer = GPTNeoXTokenizerFast.from_pretrained(\"allenai/OLMoE-1B-7B-0924\")\n+\n+        original_add_eos_token = fast_tokenizer.add_eos_token\n+\n+        fast_tokenizer.add_eos_token = False\n+        fast = fast_tokenizer.encode(\"A sample test\")\n+        self.assertEqual(fast, [34, 3410, 1071])\n+\n+        fast_tokenizer.add_eos_token = True\n+        fast = fast_tokenizer.encode(\"A sample test\")\n+        self.assertEqual(fast, [34, 3410, 1071, 50279])\n+\n+        fast_tokenizer.add_eos_token = original_add_eos_token\n+\n+    @require_tokenizers\n+    def test_simple_encode_decode(self):\n+        rust_tokenizer = GPTNeoXTokenizerFast.from_pretrained(\"allenai/OLMoE-1B-7B-0924\")\n+\n+        self.assertEqual(rust_tokenizer.encode(\"This is a test\"), [1552, 310, 247, 1071])\n+        self.assertEqual(rust_tokenizer.decode([1552, 310, 247, 1071], skip_special_tokens=True), \"This is a test\")\n+\n+        # bytefallback showcase\n+        self.assertEqual(rust_tokenizer.encode(\"生活的真谛是\"), [20025, 46549, 5225, 48561, 33656, 238, 12105])  # fmt: skip\n+        self.assertEqual(\n+            rust_tokenizer.decode([20025, 46549, 5225, 48561, 33656, 238, 12105], skip_special_tokens=True),\n+            \"生活的真谛是\",\n+        )\n+\n+        # Inner spaces showcase\n+        self.assertEqual(rust_tokenizer.encode(\"Hi  Hello\"), [12764, 50276, 12092])\n+        self.assertEqual(rust_tokenizer.decode([12764, 50276, 12092], skip_special_tokens=True), \"Hi  Hello\")\n+\n+        self.assertEqual(rust_tokenizer.encode(\"Hi   Hello\"), [12764, 50275, 12092])\n+        self.assertEqual(rust_tokenizer.decode([12764, 50275, 12092], skip_special_tokens=True), \"Hi   Hello\")\n+\n+        self.assertEqual(rust_tokenizer.encode(\"\"), [])\n+\n+        self.assertEqual(rust_tokenizer.encode(\" \"), [209])\n+\n+        self.assertEqual(rust_tokenizer.encode(\"  \"), [50276])\n+\n+        self.assertEqual(rust_tokenizer.encode(\" Hello\"), [24387])"
        }
    ],
    "stats": {
        "total": 2442,
        "additions": 2442,
        "deletions": 0
    }
}