{
    "author": "geetu040",
    "message": "Add support for MiniMax's MiniMax-Text-01 (#35831)\n\n* end-to-end architecture\n\n* lightning-attn: refactor, clean, optimize\n\n* put minimax_text_01 in other files\n\n* use latest __init__ standards and auto-generate modular\n\n* support attention_mask for lightning-attn\n\n* Revert \"use latest __init__ standards and auto-generate modular\"\n\nThis reverts commit d8d3c409d89e335c98a8cd36f47304a76eac7493.\n\n* fix modular conversion\n\n* pass both attention masks instead of tuple\n\n* formatting\n\n* Updated Dynamic Cache\n\n* created MiniMaxText01Cache\n\n* fix hardcoded slope_rate\n\n* update attn_type_list in config\n\n* fix lightning when use_cache=False\n\n* copy tests from mixtral\n\n* (checkpoint) all tests pass for normal attention\n\n* fix all unittests\n\n* fix import sorting\n\n* fix consistency and formatting tests\n\n* fix config\n\n* update tests, since changes in main\n\n* fix seq_len error\n\n* create dummy docs\n\n* fix checkpoint\n\n* add checkpoint in config docstring\n\n* run modular_conversion\n\n* update docs\n\n* fix checkpoint path and update tests\n\n* fix ruff\n\n* remove repeated expected_slice\n\n* update docs\n\n* rename \"minimax-text-01\" to \"minimax\"\n\n* inherit config from mixtral\n\n* remove from docs in other languages\n\n* undo files that should be untouched\n\n* move minimax to end in conversation docs\n\n* use MiniMaxForCausalLM as it is\n\n* ruff fixes\n\n* run modular\n\n* fix docstring example in causallm\n\n* refactor attention loop and decay factors\n\n* refactor config in modular\n\n* run modular\n\n* refactor cache\n\n* rename static_cache to linear_cache\n\n* make positional embeddings necessary\n\n* remove unnecessary layernorms declarations\n\n* fix import in tests\n\n* refactor attention in next tokens\n\n* remove outdated code\n\n* formatting and modular\n\n* update tests\n\n* rename layernorm alpha/beta factors\n\n* register decay factors as buffers\n\n* remove unused declarations of decay factors\n\n* update config for alpha/beta factors\n\n* run modular\n\n* remove head_dim in tests\n\n* remove minimax from fx.py\n\n* remove stuff that is not really needed\n\n* update __init__\n\n* update qkv torch.split\n\nCo-authored-by: Cyril Vallez <cyril.vallez@gmail.com>\n\n* fix qkv torch.split\n\n* quality fixes\n\n* remove mistakenly added dummy\n\n* purge unused ModelTester code\n\n* fix-copies\n\n* run fix-copies\n\n* fix head_dim\n\n* write cache formatting tests\n\n* remove postnorm\n\n* avoid contiguous in attention current states\n\n* update expected_slice\n\n* add generation test for integration\n\n* fix dtype in generation test\n\n* update authors\n\n* update with changes in main\n\n* update graident checkpointing and minor fixes\n\n* fix mutable attn_type_list\n\n* rename: attn_type -> layer_type\n\n* update for layer_types\n\n* update integration tests\n\n* update checkpoint\n\n* clean overview in docs\n\n---------\n\nCo-authored-by: Shakib-IO <shakib.khan17@northsouth.edu>\nCo-authored-by: Cyril Vallez <cyril.vallez@gmail.com>",
    "sha": "55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
    "files": [
        {
            "sha": "12e4224070f4ea94ddab0e89d0a4abe5043915bf",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -555,6 +555,8 @@\n         title: MegatronBERT\n       - local: model_doc/megatron_gpt2\n         title: MegatronGPT2\n+      - local: model_doc/minimax\n+        title: MiniMax\n       - local: model_doc/mistral\n         title: Mistral\n       - local: model_doc/mixtral"
        },
        {
            "sha": "a8c5ee1b23632a19b6aaf08da50a3b4df0b856b0",
            "filename": "docs/source/en/model_doc/minimax.md",
            "status": "added",
            "additions": 189,
            "deletions": 0,
            "changes": 189,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/docs%2Fsource%2Fen%2Fmodel_doc%2Fminimax.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/docs%2Fsource%2Fen%2Fmodel_doc%2Fminimax.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fminimax.md?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -0,0 +1,189 @@\n+<!--Copyright 2025 MiniMaxAI and The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# MiniMax\n+\n+## Overview\n+\n+The DepthPro model was proposed in [MiniMax-01: Scaling Foundation Models with Lightning Attention](https://arxiv.org/abs/2501.08313) by MiniMax, Aonian Li, Bangwei Gong, Bo Yang, Boji Shan, Chang Liu, Cheng Zhu, Chunhao Zhang, Congchao Guo, Da Chen, Dong Li, Enwei Jiao, Gengxin Li, Guojun Zhang, Haohai Sun, Houze Dong, Jiadai Zhu, Jiaqi Zhuang, Jiayuan Song, Jin Zhu, Jingtao Han, Jingyang Li, Junbin Xie, Junhao Xu, Junjie Yan, Kaishun Zhang, Kecheng Xiao, Kexi Kang, Le Han, Leyang Wang, Lianfei Yu, Liheng Feng, Lin Zheng, Linbo Chai, Long Xing, Meizhi Ju, Mingyuan Chi, Mozhi Zhang, Peikai Huang, Pengcheng Niu, Pengfei Li, Pengyu Zhao, Qi Yang, Qidi Xu, Qiexiang Wang, Qin Wang, Qiuhui Li, Ruitao Leng, Shengmin Shi, Shuqi Yu, Sichen Li, Songquan Zhu, Tao Huang, Tianrun Liang, Weigao Sun, Weixuan Sun, Weiyu Cheng, Wenkai Li, Xiangjun Song, Xiao Su, Xiaodong Han, Xinjie Zhang, Xinzhu Hou, Xu Min, Xun Zou, Xuyang Shen, Yan Gong, Yingjie Zhu, Yipeng Zhou, Yiran Zhong, Yongyi Hu, Yuanxiang Fan, Yue Yu, Yufeng Yang, Yuhao Li, Yunan Huang, Yunji Li, Yunpeng Huang, Yunzhi Xu, Yuxin Mao, Zehan Li, Zekang Li, Zewei Tao, Zewen Ying, Zhaoyang Cong, Zhen Qin, Zhenhua Fan, Zhihang Yu, Zhuo Jiang, Zijia Wu.\n+\n+The abstract from the paper is the following:\n+\n+*We introduce MiniMax-01 series, including MiniMax-Text-01 and MiniMax-VL-01, which are comparable to top-tier models while offering superior capabilities in processing longer contexts. The core lies in lightning attention and its efficient scaling. To maximize computational capacity, we integrate it with Mixture of Experts (MoE), creating a model with 32 experts and 456 billion total parameters, of which 45.9 billion are activated for each token. We develop an optimized parallel strategy and highly efficient computation-communication overlap techniques for MoE and lightning attention. This approach enables us to conduct efficient training and inference on models with hundreds of billions of parameters across contexts spanning millions of tokens. The context window of MiniMax-Text-01 can reach up to 1 million tokens during training and extrapolate to 4 million tokens during inference at an affordable cost. Our vision-language model, MiniMax-VL-01 is built through continued training with 512 billion vision-language tokens. Experiments on both standard and in-house benchmarks show that our models match the performance of state-of-the-art models like GPT-4o and Claude-3.5-Sonnet while offering 20-32 times longer context window.*\n+\n+### Architectural details\n+\n+MiniMax is a powerful language model with 456 billion total parameters, of which 45.9 billion are activated per token. To better unlock the long context capabilities of the model, MiniMax adopts a hybrid architecture that combines Lightning Attention, Softmax Attention and Mixture-of-Experts (MoE). Leveraging advanced parallel strategies and innovative compute-communication overlap methodsâ€”such as Linear Attention Sequence Parallelism Plus (LASP+), varlen ring attention, Expert Tensor Parallel (ETP), etc., MiniMax's training context length is extended to 1 million tokens, and it can handle a context of up to 4 million tokens during the inference. On various academic benchmarks, MiniMax also demonstrates the performance of a top-tier model.\n+\n+The architecture of MiniMax is briefly described as follows:\n+\n+- Total Parameters: 456B\n+- Activated Parameters per Token: 45.9B\n+- Number Layers: 80\n+- Hybrid Attention: a softmax attention is positioned after every 7 lightning attention.\n+    - Number of attention heads: 64\n+    - Attention head dimension: 128\n+- Mixture of Experts:\n+    - Number of experts: 32\n+    - Expert hidden dimension: 9216\n+    - Top-2 routing strategy\n+- Positional Encoding: Rotary Position Embedding (RoPE) applied to half of the attention head dimension with a base frequency of 10,000,000\n+- Hidden Size: 6144\n+- Vocab Size: 200,064\n+\n+For more details refer to the [release blog post](https://www.minimaxi.com/en/news/minimax-01-series-2).\n+\n+### License\n+\n+`MiniMax` is released under the MINIMAX MODEL LICENSE AGREEMENT.\n+\n+## Usage tips\n+\n+The pre-trained model can be used as follows:\n+\n+```python\n+>>> from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+>>> model = AutoModelForCausalLM.from_pretrained(\"MiniMaxAI/MiniMax-Text-01-hf\", device_map=\"auto\")\n+>>> tokenizer = AutoTokenizer.from_pretrained(\"MiniMaxAI/MiniMax-Text-01-hf\")\n+\n+>>> messages = [\n+...     {\"role\": \"user\", \"content\": \"What is your favourite condiment?\"},\n+...     {\"role\": \"assistant\", \"content\": \"Well, I'm quite partial to a good squeeze of fresh lemon juice. It adds just the right amount of zesty flavour to whatever I'm cooking up in the kitchen!\"},\n+...     {\"role\": \"user\", \"content\": \"Do you have mayonnaise recipes?\"}\n+... ]\n+\n+>>> model_inputs = tokenizer.apply_chat_template(messages, return_tensors=\"pt\").to(\"cuda\")\n+\n+>>> generated_ids = model.generate(model_inputs, max_new_tokens=100, do_sample=True)\n+>>> tokenizer.batch_decode(generated_ids)[0]\n+\"Mayonnaise can be made as follows: (...)\"\n+```\n+\n+As can be seen, the instruction-tuned model requires a [chat template](../chat_templating) to be applied to make sure the inputs are prepared in the right format.\n+\n+## Speeding up MiniMax by using Flash Attention\n+\n+The code snippets above showcase inference without any optimization tricks. However, one can drastically speed up the model by leveraging [Flash Attention](../perf_train_gpu_one#flash-attention-2), which is a faster implementation of the attention mechanism used inside the model.\n+\n+First, make sure to install the latest version of Flash Attention 2 to include the sliding window attention feature.\n+\n+```bash\n+pip install -U flash-attn --no-build-isolation\n+```\n+\n+Make also sure that you have a hardware that is compatible with Flash-Attention 2. Read more about it in the official documentation of the [flash attention repository](https://github.com/Dao-AILab/flash-attention). Make also sure to load your model in half-precision (e.g. `torch.float16`)\n+\n+To load and run a model using Flash Attention-2, refer to the snippet below:\n+\n+```python\n+>>> import torch\n+>>> from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+>>> model = AutoModelForCausalLM.from_pretrained(\"MiniMaxAI/MiniMax-Text-01-hf\", torch_dtype=torch.float16, attn_implementation=\"flash_attention_2\", device_map=\"auto\")\n+>>> tokenizer = AutoTokenizer.from_pretrained(\"MiniMaxAI/MiniMax-Text-01-hf\")\n+\n+>>> prompt = \"My favourite condiment is\"\n+\n+>>> model_inputs = tokenizer([prompt], return_tensors=\"pt\").to(\"cuda\")\n+>>> model.to(device)\n+\n+>>> generated_ids = model.generate(**model_inputs, max_new_tokens=100, do_sample=True)\n+>>> tokenizer.batch_decode(generated_ids)[0]\n+\"The expected output\"\n+```\n+\n+### Sliding window Attention\n+\n+The current implementation supports the sliding window attention mechanism and memory efficient cache management. \n+To enable sliding window attention, just make sure to have a `flash-attn` version that is compatible with sliding window attention (`>=2.3.0`). \n+\n+The Flash Attention-2 model uses also a more memory efficient cache slicing mechanism - as recommended per the official implementation of Mistral model that use rolling cache mechanism we keep the cache size fixed (`self.config.sliding_window`), support batched generation only for `padding_side=\"left\"` and use the absolute position of the current token to compute the positional embedding.\n+\n+## Shrinking down MiniMax using quantization\n+\n+As the MiniMax model has 456 billion parameters, that would require about 912GB of GPU RAM in half precision (float16), since each parameter is stored in 2 bytes. However, one can shrink down the size of the model using [quantization](../quantization.md). If the model is quantized to 4 bits (or half a byte per parameter), about 228 GB of RAM is required.\n+\n+Quantizing a model is as simple as passing a `quantization_config` to the model. Below, we'll leverage the bitsandbytes quantization library (but refer to [this page](../quantization.md) for alternative quantization methods):\n+\n+```python\n+>>> import torch\n+>>> from transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig\n+\n+>>> # specify how to quantize the model\n+>>> quantization_config = BitsAndBytesConfig(\n+...         load_in_4bit=True,\n+...         bnb_4bit_quant_type=\"nf4\",\n+...         bnb_4bit_compute_dtype=\"torch.float16\",\n+... )\n+\n+>>> model = AutoModelForCausalLM.from_pretrained(\"MiniMaxAI/MiniMax-Text-01-hf\", quantization_config=True, device_map=\"auto\")\n+>>> tokenizer = AutoTokenizer.from_pretrained(\"MiniMaxAI/MiniMax-Text-01-hf\")\n+\n+>>> prompt = \"My favourite condiment is\"\n+\n+>>> messages = [\n+...     {\"role\": \"user\", \"content\": \"What is your favourite condiment?\"},\n+...     {\"role\": \"assistant\", \"content\": \"Well, I'm quite partial to a good squeeze of fresh lemon juice. It adds just the right amount of zesty flavour to whatever I'm cooking up in the kitchen!\"},\n+...     {\"role\": \"user\", \"content\": \"Do you have mayonnaise recipes?\"}\n+... ]\n+\n+>>> model_inputs = tokenizer.apply_chat_template(messages, return_tensors=\"pt\").to(\"cuda\")\n+\n+>>> generated_ids = model.generate(model_inputs, max_new_tokens=100, do_sample=True)\n+>>> tokenizer.batch_decode(generated_ids)[0]\n+\"The expected output\"\n+```\n+\n+This model was contributed by [geetu040](https://github.com/geetu040).\n+The original code can be found [here](https://huggingface.co/MiniMaxAI/MiniMax-Text-01-hf/blob/main/modeling_minimax.py).\n+\n+## Resources\n+\n+A list of official Hugging Face and community (indicated by ðŸŒŽ) resources to help you get started with MiniMax. If you're interested in submitting a resource to be included here, please feel free to open a Pull Request and we'll review it! The resource should ideally demonstrate something new instead of duplicating an existing resource.\n+\n+<PipelineTag pipeline=\"text-generation\"/>\n+\n+- The [Alignment Handbook](https://github.com/huggingface/alignment-handbook) by Hugging Face includes scripts and recipes to perform supervised fine-tuning (SFT) and direct preference optimization with Mistral-7B. This includes scripts for full fine-tuning, QLoRa on a single GPU as well as multi-GPU fine-tuning.\n+- [Causal language modeling task guide](../tasks/language_modeling)\n+\n+## MiniMaxConfig\n+\n+[[autodoc]] MiniMaxConfig\n+\n+## MiniMaxModel\n+\n+[[autodoc]] MiniMaxModel\n+    - forward\n+\n+## MiniMaxForCausalLM\n+\n+[[autodoc]] MiniMaxForCausalLM\n+    - forward\n+\n+## MiniMaxForSequenceClassification\n+\n+[[autodoc]] MiniMaxForSequenceClassification\n+    - forward\n+\n+## MiniMaxForTokenClassification\n+\n+[[autodoc]] MiniMaxForTokenClassification\n+    - forward\n+\n+## MiniMaxForQuestionAnswering\n+[[autodoc]] MiniMaxForQuestionAnswering\n+    - forward"
        },
        {
            "sha": "74bf8cca4888017300603b4ed37a29d0948717fc",
            "filename": "src/transformers/configuration_utils.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fconfiguration_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fconfiguration_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fconfiguration_utils.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -1218,6 +1218,7 @@ def recursive_diff_dict(dict_a, dict_b, config_obj=None):\n     \"full_attention\",\n     \"sliding_attention\",\n     \"chunked_attention\",\n+    \"linear_attention\",  # used in minimax\n )\n \n "
        },
        {
            "sha": "4a549fc215583caacd0a3bcd3af5a0db2d503d69",
            "filename": "src/transformers/generation/utils.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fgeneration%2Futils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fgeneration%2Futils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Futils.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -1976,6 +1976,7 @@ def _supports_default_dynamic_cache(self) -> bool:\n             and \"jamba\" not in self.__class__.__name__.lower()\n             and \"zamba\" not in self.__class__.__name__.lower()\n             and \"bamba\" not in self.__class__.__name__.lower()\n+            and \"minimax\" not in self.__class__.__name__.lower()\n         )\n \n     def _prepare_cache_for_generation("
        },
        {
            "sha": "fd4b889fd37d4b057040c4c19c81f6a41207ecb3",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -185,6 +185,7 @@\n     from .megatron_gpt2 import *\n     from .mgp_str import *\n     from .mimi import *\n+    from .minimax import *\n     from .mistral import *\n     from .mistral3 import *\n     from .mixtral import *"
        },
        {
            "sha": "b6ee50917052deb83a61d1baf1a0cc7b36f8bfed",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -211,6 +211,7 @@\n         (\"megatron-bert\", \"MegatronBertConfig\"),\n         (\"mgp-str\", \"MgpstrConfig\"),\n         (\"mimi\", \"MimiConfig\"),\n+        (\"minimax\", \"MiniMaxConfig\"),\n         (\"mistral\", \"MistralConfig\"),\n         (\"mistral3\", \"Mistral3Config\"),\n         (\"mixtral\", \"MixtralConfig\"),\n@@ -586,6 +587,7 @@\n         (\"megatron_gpt2\", \"Megatron-GPT2\"),\n         (\"mgp-str\", \"MGP-STR\"),\n         (\"mimi\", \"Mimi\"),\n+        (\"minimax\", \"MiniMax\"),\n         (\"mistral\", \"Mistral\"),\n         (\"mistral3\", \"Mistral3\"),\n         (\"mixtral\", \"Mixtral\"),"
        },
        {
            "sha": "e28e978ca8d33ab1b16eff269ba0349c6909926d",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -201,6 +201,7 @@\n         (\"megatron-bert\", \"MegatronBertModel\"),\n         (\"mgp-str\", \"MgpstrForSceneTextRecognition\"),\n         (\"mimi\", \"MimiModel\"),\n+        (\"minimax\", \"MiniMaxModel\"),\n         (\"mistral\", \"MistralModel\"),\n         (\"mistral3\", \"Mistral3Model\"),\n         (\"mixtral\", \"MixtralModel\"),\n@@ -594,6 +595,7 @@\n         (\"mbart\", \"MBartForCausalLM\"),\n         (\"mega\", \"MegaForCausalLM\"),\n         (\"megatron-bert\", \"MegatronBertForCausalLM\"),\n+        (\"minimax\", \"MiniMaxForCausalLM\"),\n         (\"mistral\", \"MistralForCausalLM\"),\n         (\"mixtral\", \"MixtralForCausalLM\"),\n         (\"mllama\", \"MllamaForCausalLM\"),\n@@ -1106,6 +1108,7 @@\n         (\"mbart\", \"MBartForSequenceClassification\"),\n         (\"mega\", \"MegaForSequenceClassification\"),\n         (\"megatron-bert\", \"MegatronBertForSequenceClassification\"),\n+        (\"minimax\", \"MiniMaxForSequenceClassification\"),\n         (\"mistral\", \"MistralForSequenceClassification\"),\n         (\"mixtral\", \"MixtralForSequenceClassification\"),\n         (\"mobilebert\", \"MobileBertForSequenceClassification\"),\n@@ -1197,6 +1200,7 @@\n         (\"mbart\", \"MBartForQuestionAnswering\"),\n         (\"mega\", \"MegaForQuestionAnswering\"),\n         (\"megatron-bert\", \"MegatronBertForQuestionAnswering\"),\n+        (\"minimax\", \"MiniMaxForQuestionAnswering\"),\n         (\"mistral\", \"MistralForQuestionAnswering\"),\n         (\"mixtral\", \"MixtralForQuestionAnswering\"),\n         (\"mobilebert\", \"MobileBertForQuestionAnswering\"),\n@@ -1303,6 +1307,7 @@\n         (\"markuplm\", \"MarkupLMForTokenClassification\"),\n         (\"mega\", \"MegaForTokenClassification\"),\n         (\"megatron-bert\", \"MegatronBertForTokenClassification\"),\n+        (\"minimax\", \"MiniMaxForTokenClassification\"),\n         (\"mistral\", \"MistralForTokenClassification\"),\n         (\"mixtral\", \"MixtralForTokenClassification\"),\n         (\"mobilebert\", \"MobileBertForTokenClassification\"),"
        },
        {
            "sha": "cba0e2e1cde30b4e32f49723695cd0969e1a5904",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -342,6 +342,13 @@\n         (\"mega\", (\"RobertaTokenizer\", \"RobertaTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"megatron-bert\", (\"BertTokenizer\", \"BertTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"mgp-str\", (\"MgpstrTokenizer\", None)),\n+        (\n+            \"minimax\",\n+            (\n+                \"GPT2Tokenizer\" if is_sentencepiece_available() else None,\n+                \"GPT2TokenizerFast\" if is_tokenizers_available() else None,\n+            ),\n+        ),\n         (\n             \"mistral\",\n             ("
        },
        {
            "sha": "91834eb6a2246ff1a5790116c94f3b0b4a559725",
            "filename": "src/transformers/models/minimax/__init__.py",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fminimax%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fminimax%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fminimax%2F__init__.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -0,0 +1,29 @@\n+# coding=utf-8\n+# Copyright 2025 MiniMaxAI and HuggingFace Inc. teams. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_minimax import *\n+    from .modeling_minimax import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "c0d8611af5c08786d95b18144eceb4f4a019bc4f",
            "filename": "src/transformers/models/minimax/configuration_minimax.py",
            "status": "added",
            "additions": 230,
            "deletions": 0,
            "changes": 230,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fminimax%2Fconfiguration_minimax.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fminimax%2Fconfiguration_minimax.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fminimax%2Fconfiguration_minimax.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -0,0 +1,230 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/minimax/modular_minimax.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_minimax.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 MiniMaxAI and HuggingFace Inc. teams. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from ...configuration_utils import PretrainedConfig, layer_type_validation\n+\n+\n+class MiniMaxConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`MiniMaxModel`]. It is used to instantiate an\n+    MiniMax model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of the MiniMax.\n+\n+    [MiniMaxAI/MiniMax-Text-01-hf](https://huggingface.co/MiniMaxAI/MiniMax-Text-01-hf)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 32000):\n+            Vocabulary size of the MiniMax model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`MiniMaxModel`]\n+        hidden_size (`int`, *optional*, defaults to 4096):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 14336):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 32):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 32):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 8):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `8`.\n+        head_dim (`int`, *optional*, defaults to `hidden_size // num_attention_heads`):\n+            The attention head dimension.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to `4096*32`):\n+            The maximum sequence length that this model might ever be used with. MiniMax's sliding window attention\n+            allows sequence of up to 4096*32 tokens.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        pad_token_id (`int`, *optional*):\n+            The id of the padding token.\n+        bos_token_id (`int`, *optional*, defaults to 1):\n+            The id of the \"beginning-of-sequence\" token.\n+        eos_token_id (`int`, *optional*, defaults to 2):\n+            The id of the \"end-of-sequence\" token.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_theta (`float`, *optional*, defaults to 1000000.0):\n+            The base period of the RoPE embeddings.\n+        sliding_window (`int`, *optional*):\n+            Sliding window attention window size. If not specified, will default to `4096`.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        num_experts_per_tok (`int`, *optional*, defaults to 2):\n+            The number of experts to route per-token, can be also interpreted as the `top-k` routing\n+            parameter\n+        num_local_experts (`int`, *optional*, defaults to 8):\n+            Number of experts per Sparse MLP layer.\n+        output_router_logits (`bool`, *optional*, defaults to `False`):\n+            Whether or not the router logits should be returned by the model. Enabeling this will also\n+            allow the model to output the auxiliary loss. See [here]() for more details\n+        router_aux_loss_coef (`float`, *optional*, defaults to 0.001):\n+            The aux loss factor for the total loss.\n+        router_jitter_noise (`float`, *optional*, defaults to 0.0):\n+            Amount of noise to add to the router.\n+        layer_types (`list`, *optional*):\n+            Attention pattern for each layer.\n+        block_size (`int`, *optional*, defaults to 256):\n+            The length of each attention block, determining how queries, keys, and values\n+            are grouped and processed for intra- and inter-block attention.\n+        full_attn_alpha_factor (`float`, *optional*, defaults to 1):\n+            Weight for residual value in residual connection after normal attention.\n+        full_attn_beta_factor (`float`, *optional*, defaults to 1):\n+            Weight for hidden state value in residual connection after normal attention.\n+        linear_attn_alpha_factor (`float`, *optional*, defaults to 1):\n+            Weight for residual value in residual connection after lightning attention.\n+        linear_attn_beta_factor (`float`, *optional*, defaults to 1):\n+            Weight for hidden state value in residual connection after lightning attention.\n+        mlp_alpha_factor (`float`, *optional*, defaults to 1):\n+            Weight for residual value in residual connection after MLP.\n+        mlp_beta_factor (`float`, *optional*, defaults to 1):\n+            Weight for hidden state value in residual connection after MLP.\n+\n+    ```python\n+    >>> from transformers import MiniMaxModel, MiniMaxConfig\n+\n+    >>> # Initializing a MiniMax style configuration\n+    >>> configuration = MiniMaxConfig()\n+\n+    >>> # Initializing a model from the MiniMax style configuration\n+    >>> model = MiniMaxModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"minimax\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.block_sparse_moe.gate\": \"colwise_rep\",  # we need to replicate here to correctly route experts\n+        \"layers.*.block_sparse_moe.experts.*.w1\": \"colwise\",\n+        \"layers.*.block_sparse_moe.experts.*.w2\": \"rowwise\",\n+        \"layers.*.block_sparse_moe.experts.*.w3\": \"colwise\",\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=32000,\n+        hidden_size=4096,\n+        intermediate_size=14336,\n+        num_hidden_layers=32,\n+        num_attention_heads=32,\n+        num_key_value_heads=8,\n+        head_dim=None,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=4096 * 32,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-5,\n+        use_cache=True,\n+        pad_token_id=None,\n+        bos_token_id=1,\n+        eos_token_id=2,\n+        tie_word_embeddings=False,\n+        rope_theta=1e6,\n+        sliding_window=None,\n+        attention_dropout=0.0,\n+        num_experts_per_tok=2,\n+        num_local_experts=8,\n+        output_router_logits=False,\n+        router_aux_loss_coef=0.001,\n+        router_jitter_noise=0.0,\n+        layer_types=None,\n+        block_size=256,\n+        full_attn_alpha_factor=1,\n+        full_attn_beta_factor=1,\n+        linear_attn_alpha_factor=1,\n+        linear_attn_beta_factor=1,\n+        mlp_alpha_factor=1,\n+        mlp_beta_factor=1,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.sliding_window = sliding_window\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.attention_dropout = attention_dropout\n+        self.head_dim = head_dim\n+\n+        self.num_experts_per_tok = num_experts_per_tok\n+        self.num_local_experts = num_local_experts\n+        self.output_router_logits = output_router_logits\n+        self.router_aux_loss_coef = router_aux_loss_coef\n+        self.router_jitter_noise = router_jitter_noise\n+        self.layer_types = layer_types\n+        self.block_size = block_size\n+        self.full_attn_alpha_factor = full_attn_alpha_factor\n+        self.full_attn_beta_factor = full_attn_beta_factor\n+        self.linear_attn_alpha_factor = linear_attn_alpha_factor\n+        self.linear_attn_beta_factor = linear_attn_beta_factor\n+        self.mlp_alpha_factor = mlp_alpha_factor\n+        self.mlp_beta_factor = mlp_beta_factor\n+\n+        if self.layer_types is None:\n+            self.layer_types = [\n+                \"full_attention\" if bool((i + 1) % 2) else \"linear_attention\" for i in range(self.num_hidden_layers)\n+            ]\n+        layer_type_validation(self.layer_types)\n+\n+\n+__all__ = [\"MiniMaxConfig\"]"
        },
        {
            "sha": "18d2e4df7d9c5f2a38c8d285e0c909d5fcdfcff7",
            "filename": "src/transformers/models/minimax/modeling_minimax.py",
            "status": "added",
            "additions": 1259,
            "deletions": 0,
            "changes": 1259,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fminimax%2Fmodeling_minimax.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fminimax%2Fmodeling_minimax.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fminimax%2Fmodeling_minimax.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -0,0 +1,1259 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/minimax/modular_minimax.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_minimax.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 MiniMaxAI and HuggingFace Inc. teams. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import Callable, List, Optional, Tuple, Union\n+\n+import torch\n+import torch.nn.functional as F\n+from torch import nn\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...integrations import use_kernel_forward_from_hub\n+from ...masking_utils import create_causal_mask, create_sliding_window_causal_mask\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_outputs import (\n+    BaseModelOutputWithPast,\n+    MoeCausalLMOutputWithPast,\n+    MoeModelOutputWithPast,\n+    QuestionAnsweringModelOutput,\n+    SequenceClassifierOutputWithPast,\n+    TokenClassifierOutput,\n+)\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS, dynamic_rope_update\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import LossKwargs, auto_docstring, can_return_tuple, logging\n+from .configuration_minimax import MiniMaxConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+@use_kernel_forward_from_hub(\"RMSNorm\")\n+class MiniMaxRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        MiniMaxRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class MiniMaxCache(DynamicCache):\n+    def __init__(self):\n+        super().__init__()\n+        self.linear_cache: List[torch.Tensor] = []\n+\n+    def set_linear_cache(self, layer_idx, linear_cache):\n+        # There may be skipped layers, fill them with empty lists\n+        for _ in range(len(self.linear_cache), layer_idx + 1):\n+            self.linear_cache.append([])\n+        self.linear_cache[layer_idx] = linear_cache\n+\n+    def get_linear_cache(self, layer_idx: int):\n+        if layer_idx < len(self):\n+            return self.linear_cache[layer_idx]\n+        return None\n+\n+    def __len__(self):\n+        return max(super().__len__(), len(self.linear_cache))\n+\n+    def __getitem__(self, layer_idx: int):\n+        if layer_idx < len(self.linear_cache) and self.linear_cache[layer_idx] != []:\n+            return (self.linear_cache[layer_idx],)\n+        return super().__getitem__(layer_idx)\n+\n+    def __iter__(self):\n+        for layer_idx in range(len(self)):\n+            yield self[layer_idx]\n+\n+    def batch_repeat_interleave(self, repeats: int):\n+        for layer_idx in range(len(self)):\n+            if self.linear_cache[layer_idx] != []:\n+                self.linear_cache[layer_idx] = self.linear_cache[layer_idx].repeat_interleave(repeats, dim=0)\n+            else:\n+                self.key_cache[layer_idx] = self.key_cache[layer_idx].repeat_interleave(repeats, dim=0)\n+                self.value_cache[layer_idx] = self.value_cache[layer_idx].repeat_interleave(repeats, dim=0)\n+\n+    def batch_select_indices(self, indices: torch.Tensor):\n+        for layer_idx in range(len(self)):\n+            if self.linear_cache[layer_idx] != []:\n+                self.linear_cache[layer_idx] = self.linear_cache[layer_idx][indices, ...]\n+            else:\n+                self.key_cache[layer_idx] = self.key_cache[layer_idx][indices, ...]\n+                self.value_cache[layer_idx] = self.value_cache[layer_idx][indices, ...]\n+\n+    def crop(self, max_length: int):\n+        raise RuntimeError(\"MiniMaxCache doesnot support `crop` method\")\n+\n+\n+class MiniMaxLightningAttention(nn.Module):\n+    def __init__(self, config: MiniMaxConfig, layer_idx: int):\n+        super().__init__()\n+        self.layer_idx = layer_idx\n+        self.head_dim = getattr(config, \"head_dim\", None) or config.hidden_size // config.num_attention_heads\n+        self.num_attention_heads = config.num_attention_heads\n+        self.num_hidden_layers = config.num_hidden_layers\n+        self.block_size = config.block_size\n+\n+        self.act_fn = ACT2FN[config.hidden_act]\n+        self.norm = MiniMaxRMSNorm(self.head_dim * self.num_attention_heads)\n+        self.qkv_proj = nn.Linear(config.hidden_size, self.num_attention_heads * self.head_dim * 3, bias=False)\n+        self.out_proj = nn.Linear(self.num_attention_heads * self.head_dim, config.hidden_size, bias=False)\n+        self.output_gate = nn.Linear(config.hidden_size, self.num_attention_heads * self.head_dim, bias=False)\n+\n+        slope_rate = self.get_slope_rate()\n+        query_decay, key_decay, diagonal_decay = self.decay_factors(slope_rate)\n+\n+        self.register_buffer(\"slope_rate\", slope_rate)\n+        self.register_buffer(\"query_decay\", query_decay)\n+        self.register_buffer(\"key_decay\", key_decay)\n+        self.register_buffer(\"diagonal_decay\", diagonal_decay)\n+\n+    def get_slope_rate(self):\n+        base = 1 / (2 ** (8 / self.num_attention_heads))\n+        exponent = torch.arange(self.num_attention_heads) + 1\n+        factor = 1 - self.layer_idx / (self.num_hidden_layers - 1 + 1e-5) + 1e-5\n+\n+        rate = base**exponent\n+        rate = rate * factor\n+        rate = rate[:, None, None]\n+\n+        return rate\n+\n+    def decay_factors(self, slope_rate):\n+        block_size_range = torch.arange(self.block_size) + 1\n+\n+        query_decay = torch.exp(-slope_rate * block_size_range[:, None])\n+        key_decay = torch.exp(-slope_rate * (self.block_size - block_size_range[:, None]))\n+\n+        diagonal_decay = block_size_range[:, None] - block_size_range[None, :]\n+        diagonal_decay = diagonal_decay[None, None, :, :]\n+        diagonal_decay = slope_rate * diagonal_decay\n+        diagonal_decay = torch.where(diagonal_decay >= 0, -diagonal_decay, float(\"-inf\"))\n+        diagonal_decay = torch.exp(diagonal_decay)\n+\n+        return query_decay, key_decay, diagonal_decay\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: Tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        batch_size, seq_len, hidden_size = hidden_states.shape\n+        num_blocks = (seq_len + self.block_size - 1) // self.block_size\n+\n+        qkv_states = self.act_fn(self.qkv_proj(hidden_states))\n+        qkv_states = qkv_states.reshape(batch_size, seq_len, self.num_attention_heads, 3 * self.head_dim)\n+\n+        query_states, key_states, value_states = torch.split(qkv_states, self.head_dim, dim=3)\n+\n+        query_states = query_states.transpose(1, 2)\n+        key_states = key_states.transpose(1, 2)\n+        value_states = value_states.transpose(1, 2)\n+\n+        # calculated (K.T @ V) and saved as cache\n+        attn_weights_inter = None\n+        if past_key_value is not None:\n+            attn_weights_inter = past_key_value.get_linear_cache(self.layer_idx)\n+\n+        if attn_weights_inter is None:\n+            attn_weights_inter = torch.zeros(batch_size, self.num_attention_heads, self.head_dim, self.head_dim).to(\n+                value_states\n+            )\n+\n+            # apply attention_mask\n+            if attention_mask is not None:\n+                attention_mask = attention_mask.to(dtype=torch.bool)  # Ensure it's a boolean tensor\n+                value_states = value_states.masked_fill(~attention_mask.unsqueeze(1).unsqueeze(-1), 0)\n+\n+            attn_output = []\n+            for i in range(num_blocks):\n+                start_idx = i * self.block_size\n+                end_idx = min(start_idx + self.block_size, seq_len)\n+                current_block_size = end_idx - start_idx\n+\n+                current_query_states = query_states[:, :, start_idx:end_idx]\n+                current_key_states = key_states[:, :, start_idx:end_idx]\n+                current_value_states = value_states[:, :, start_idx:end_idx]\n+\n+                current_query_decay = self.query_decay[:, :current_block_size]\n+                current_key_decay = self.key_decay[:, -current_block_size:]\n+                current_diagonal_decay = self.diagonal_decay[:, :, :current_block_size, :current_block_size]\n+                block_decay = torch.exp(-self.slope_rate * current_block_size)\n+\n+                # intra: ( Q @ K.T ) @ V -> QK * V\n+                attn_weights_intra = torch.matmul(current_query_states, current_key_states.transpose(-1, -2))\n+                attn_output_intra = torch.matmul(attn_weights_intra * current_diagonal_decay, current_value_states)\n+\n+                # inter: Q @ ( K.T @ V ) -> Q * KV\n+                attn_output_inter = torch.matmul(current_query_states * current_query_decay, attn_weights_inter)\n+\n+                # final attention output\n+                current_attn_output = attn_output_inter + attn_output_intra\n+                attn_output.append(current_attn_output)\n+\n+                # cacluate attn_weights_inter for next block or cache\n+                next_attn_weights_inter = torch.matmul(\n+                    (current_key_states * current_key_decay).transpose(-1, -2), current_value_states\n+                )\n+                attn_weights_inter = attn_weights_inter * block_decay + next_attn_weights_inter\n+\n+        else:\n+            ratio = torch.exp(-self.slope_rate)\n+            attn_output = []\n+            for i in range(seq_len):\n+                current_query_states = query_states[:, :, i : i + 1]\n+                current_key_states = key_states[:, :, i : i + 1]\n+                current_value_states = value_states[:, :, i : i + 1]\n+\n+                current_attn_weights_inter = torch.matmul(current_key_states.transpose(-1, -2), current_value_states)\n+                attn_weights_inter = ratio * attn_weights_inter + current_attn_weights_inter\n+                current_attn_output = torch.matmul(current_query_states, attn_weights_inter)\n+\n+                attn_output.append(current_attn_output)\n+\n+        # concatenate attention outputs over all blocks\n+        attn_output = torch.cat(attn_output, dim=-2)\n+\n+        # final output projection\n+        attn_output = attn_output.transpose(1, 2)\n+        attn_output = attn_output.reshape(batch_size, seq_len, self.num_attention_heads * self.head_dim)\n+        attn_output = self.norm(attn_output)\n+        attn_output = F.sigmoid(self.output_gate(hidden_states)) * attn_output\n+        attn_output = self.out_proj(attn_output)\n+\n+        # update cache\n+        if past_key_value is not None:\n+            past_key_value.set_linear_cache(self.layer_idx, attn_weights_inter)\n+\n+        return attn_output, attn_weights_inter\n+\n+\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`, *optional*):\n+            Deprecated and unused.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    return q_embed, k_embed\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs,\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+class MiniMaxAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: MiniMaxConfig, layer_idx: int):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.head_dim = getattr(config, \"head_dim\", None) or config.hidden_size // config.num_attention_heads\n+        self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.attention_dropout = config.attention_dropout\n+        self.is_causal = True\n+        self.q_proj = nn.Linear(config.hidden_size, config.num_attention_heads * self.head_dim, bias=False)\n+        self.k_proj = nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=False)\n+        self.v_proj = nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=False)\n+        self.o_proj = nn.Linear(config.num_attention_heads * self.head_dim, config.hidden_size, bias=False)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: Tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            sliding_window=getattr(self.config, \"sliding_window\", None),  # main diff with Llama\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class MiniMaxBlockSparseTop2MLP(nn.Module):\n+    def __init__(self, config: MiniMaxConfig):\n+        super().__init__()\n+        self.ffn_dim = config.intermediate_size\n+        self.hidden_dim = config.hidden_size\n+\n+        self.w1 = nn.Linear(self.hidden_dim, self.ffn_dim, bias=False)\n+        self.w2 = nn.Linear(self.ffn_dim, self.hidden_dim, bias=False)\n+        self.w3 = nn.Linear(self.hidden_dim, self.ffn_dim, bias=False)\n+\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, hidden_states):\n+        current_hidden_states = self.act_fn(self.w1(hidden_states)) * self.w3(hidden_states)\n+        current_hidden_states = self.w2(current_hidden_states)\n+        return current_hidden_states\n+\n+\n+class MiniMaxSparseMoeBlock(nn.Module):\n+    \"\"\"\n+    This implementation is\n+    strictly equivalent to standard MoE with full capacity (no\n+    dropped tokens). It's faster since it formulates MoE operations\n+    in terms of block-sparse operations to accommodate imbalanced\n+    assignments of tokens to experts, whereas standard MoE either\n+    (1) drop tokens at the cost of reduced performance or (2) set\n+    capacity factor to number of experts and thus waste computation\n+    and memory on padding.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+        self.hidden_dim = config.hidden_size\n+        self.ffn_dim = config.intermediate_size\n+        self.num_experts = config.num_local_experts\n+        self.top_k = config.num_experts_per_tok\n+\n+        # gating\n+        self.gate = nn.Linear(self.hidden_dim, self.num_experts, bias=False)\n+\n+        self.experts = nn.ModuleList([MiniMaxBlockSparseTop2MLP(config) for _ in range(self.num_experts)])\n+\n+        # Jitter parameters\n+        self.jitter_noise = config.router_jitter_noise\n+\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        \"\"\" \"\"\"\n+        batch_size, sequence_length, hidden_dim = hidden_states.shape\n+        if self.training and self.jitter_noise > 0:\n+            hidden_states *= torch.empty_like(hidden_states).uniform_(1.0 - self.jitter_noise, 1.0 + self.jitter_noise)\n+        hidden_states = hidden_states.view(-1, hidden_dim)\n+        # router_logits: (batch * sequence_length, n_experts)\n+        router_logits = self.gate(hidden_states)\n+\n+        routing_weights = F.softmax(router_logits, dim=1, dtype=torch.float)\n+        routing_weights, selected_experts = torch.topk(routing_weights, self.top_k, dim=-1)\n+        routing_weights /= routing_weights.sum(dim=-1, keepdim=True)\n+        # we cast back to the input dtype\n+        routing_weights = routing_weights.to(hidden_states.dtype)\n+\n+        final_hidden_states = torch.zeros(\n+            (batch_size * sequence_length, hidden_dim), dtype=hidden_states.dtype, device=hidden_states.device\n+        )\n+\n+        # One hot encode the selected experts to create an expert mask\n+        # this will be used to easily index which expert is going to be sollicitated\n+        expert_mask = torch.nn.functional.one_hot(selected_experts, num_classes=self.num_experts).permute(2, 1, 0)\n+\n+        expert_hitted = (expert_mask.sum(dim=(-1, -2)) > 0).nonzero(as_tuple=True)[0].tolist()\n+        for expert_idx in expert_hitted:\n+            expert_layer = self.experts[expert_idx]\n+            idx, top_x = torch.where(expert_mask[expert_idx])\n+            # Index the correct hidden states and compute the expert hidden state for\n+            # the current expert. We need to make sure to multiply the output hidden\n+            # states by `routing_weights` on the corresponding tokens (top-1 and top-2)\n+            current_state = hidden_states[None, top_x].reshape(-1, hidden_dim)\n+            current_hidden_states = expert_layer(current_state) * routing_weights[top_x, idx, None]\n+\n+            # However `index_add_` only support torch tensors for indexing so we'll use\n+            # the `top_x` tensor here.\n+            final_hidden_states.index_add_(0, top_x, current_hidden_states.to(hidden_states.dtype))\n+        final_hidden_states = final_hidden_states.reshape(batch_size, sequence_length, hidden_dim)\n+        return final_hidden_states, router_logits\n+\n+\n+class MiniMaxDecoderLayer(nn.Module):\n+    def __init__(self, config: MiniMaxConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        self.self_attn = MiniMaxAttention(config, layer_idx)\n+\n+        self.block_sparse_moe = MiniMaxSparseMoeBlock(config)\n+        self.input_layernorm = MiniMaxRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = MiniMaxRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+        self.layer_idx = layer_idx\n+        self.layer_type = config.layer_types[layer_idx]\n+        self.mlp_alpha_factor = config.mlp_alpha_factor\n+        self.mlp_beta_factor = config.mlp_beta_factor\n+\n+        if self.layer_type == \"linear_attention\":\n+            self.self_attn = MiniMaxLightningAttention(config, layer_idx)\n+            self.attn_alpha_factor = config.linear_attn_alpha_factor\n+            self.attn_beta_factor = config.linear_attn_beta_factor\n+        else:\n+            self.self_attn = MiniMaxAttention(config, layer_idx)\n+            self.attn_alpha_factor = config.full_attn_alpha_factor\n+            self.attn_beta_factor = config.full_attn_beta_factor\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: Tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Tuple[torch.Tensor]] = None,\n+        output_attentions: Optional[bool] = False,\n+        output_router_logits: Optional[bool] = False,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Tuple[torch.FloatTensor, Optional[Tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.FloatTensor`): input to the layer of shape `(batch, seq_len, embed_dim)`\n+            position_embeddings (`Tuple[torch.FloatTensor, torch.FloatTensor]`):\n+                Tuple containing the cosine and sine positional embeddings of shape `(batch_size, seq_len, head_dim)`,\n+                with `head_dim` being the embedding dimension of each attention head.\n+            attention_mask (`torch.Tensor`, *optional*): attention mask of size\n+                `(batch, sequence_length)` where padding elements are indicated by 0.\n+            past_key_value (`Tuple(torch.FloatTensor)`, *optional*): cached past key and value projection states\n+            output_attentions (`bool`, *optional*):\n+                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n+                returned tensors for more detail.\n+            output_router_logits (`bool`, *optional*):\n+                Whether or not to return the logits of all the routers. They are useful for computing the router loss, and\n+                should not be returned during inference.\n+            use_cache (`bool`, *optional*):\n+                If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding\n+                (see `past_key_values`).\n+            cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n+                Indices depicting the position of the input sequence tokens in the sequence.\n+            kwargs (`dict`, *optional*):\n+                Arbitrary kwargs to be ignored, used for FSDP and other methods that injects code\n+                into the model\n+        \"\"\"\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+        residual = hidden_states\n+\n+        # Self Attention\n+        hidden_states, self_attn_weights = self.self_attn(\n+            hidden_states=hidden_states,\n+            position_embeddings=position_embeddings,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = residual * self.attn_alpha_factor + hidden_states * self.attn_beta_factor\n+\n+        # Fully Connected\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        residual = hidden_states\n+        hidden_states, router_logits = self.block_sparse_moe(hidden_states)\n+        hidden_states = residual * self.mlp_alpha_factor + hidden_states * self.mlp_beta_factor\n+\n+        outputs = (hidden_states,)\n+\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        if output_router_logits:\n+            outputs += (router_logits,)\n+\n+        return outputs\n+\n+\n+@auto_docstring\n+class MiniMaxPreTrainedModel(PreTrainedModel):\n+    config_class = MiniMaxConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"MiniMaxDecoderLayer\"]\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = True\n+    _supports_flex_attn = True\n+    _supports_cache_class = True  # Note: only supports MiniMaxCache\n+    _supports_quantized_cache = False\n+    _supports_static_cache = False\n+    _supports_attention_backend = True\n+\n+    def _init_weights(self, module):\n+        std = self.config.initializer_range\n+        if isinstance(module, nn.Linear):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+        elif isinstance(module, MiniMaxRMSNorm):\n+            module.weight.data.fill_(1.0)\n+\n+\n+class MiniMaxRotaryEmbedding(nn.Module):\n+    def __init__(self, config: MiniMaxConfig, device=None):\n+        super().__init__()\n+        # BC: \"rope_type\" was originally \"type\"\n+        if hasattr(config, \"rope_scaling\") and config.rope_scaling is not None:\n+            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n+        else:\n+            self.rope_type = \"default\"\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = self.inv_freq\n+\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1).to(x.device)\n+        position_ids_expanded = position_ids[:, None, :].float()\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(1, 2)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos() * self.attention_scaling\n+            sin = emb.sin() * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+@auto_docstring\n+class MiniMaxModel(MiniMaxPreTrainedModel):\n+    def __init__(self, config: MiniMaxConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [MiniMaxDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = MiniMaxRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = MiniMaxRotaryEmbedding(config=config)\n+        self.gradient_checkpointing = False\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.embed_tokens = value\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        output_router_logits: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **flash_attn_kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> MoeModelOutputWithPast:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_router_logits = (\n+            output_router_logits if output_router_logits is not None else self.config.output_router_logits\n+        )\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if self.gradient_checkpointing and self.training:\n+            if use_cache:\n+                logger.warning_once(\n+                    \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n+                )\n+                use_cache = False\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = MiniMaxCache()\n+        elif use_cache and not isinstance(past_key_values, MiniMaxCache):\n+            raise ValueError(\n+                f\"MiniMax uses cache of its own and is not compatible with `past_key_values` of type {type(past_key_values)}.\"\n+            )\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        mask_function = create_causal_mask if self.config.sliding_window is None else create_sliding_window_causal_mask\n+        causal_mask = mask_function(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+        )\n+\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+        all_router_logits = () if output_router_logits else None\n+\n+        for decoder_layer in self.layers:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            if decoder_layer.layer_type == \"full_attention\":\n+                input_attention_mask = causal_mask\n+            else:\n+                # lightning attention uses original attention_mask, and uses it only for the first step\n+                input_attention_mask = attention_mask\n+\n+            layer_outputs = decoder_layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=input_attention_mask,\n+                position_ids=position_ids,\n+                past_key_value=past_key_values,\n+                output_attentions=output_attentions,\n+                output_router_logits=output_router_logits,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                **flash_attn_kwargs,\n+            )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+            if output_router_logits:\n+                all_router_logits += (layer_outputs[-1],)\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        # add hidden states from the last decoder layer\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        return MoeModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+            router_logits=all_router_logits,\n+        )\n+\n+\n+class KwargsForCausalLM(FlashAttentionKwargs, LossKwargs): ...\n+\n+\n+def load_balancing_loss_func(\n+    gate_logits: Union[torch.Tensor, Tuple[torch.Tensor], None],\n+    num_experts: Optional[int] = None,\n+    top_k=2,\n+    attention_mask: Optional[torch.Tensor] = None,\n+) -> Union[torch.Tensor, int]:\n+    r\"\"\"\n+    Computes auxiliary load balancing loss as in Switch Transformer - implemented in Pytorch.\n+\n+    See Switch Transformer (https://arxiv.org/abs/2101.03961) for more details. This function implements the loss\n+    function presented in equations (4) - (6) of the paper. It aims at penalizing cases where the routing between\n+    experts is too unbalanced.\n+\n+    Args:\n+        gate_logits:\n+            Logits from the `gate`, should be a tuple of model.config.num_hidden_layers tensors of\n+            shape [batch_size X sequence_length, num_experts].\n+        num_experts:\n+            Number of experts\n+        top_k:\n+            The number of experts to route per-token, can be also interpreted as the `top-k` routing\n+            parameter.\n+        attention_mask (`torch.Tensor`, *optional*):\n+            The attention_mask used in forward function\n+            shape [batch_size X sequence_length] if not None.\n+\n+    Returns:\n+        The auxiliary loss.\n+    \"\"\"\n+    if gate_logits is None or not isinstance(gate_logits, tuple):\n+        return 0\n+\n+    if isinstance(gate_logits, tuple):\n+        compute_device = gate_logits[0].device\n+        concatenated_gate_logits = torch.cat([layer_gate.to(compute_device) for layer_gate in gate_logits], dim=0)\n+\n+    routing_weights = torch.nn.functional.softmax(concatenated_gate_logits, dim=-1)\n+\n+    _, selected_experts = torch.topk(routing_weights, top_k, dim=-1)\n+\n+    expert_mask = torch.nn.functional.one_hot(selected_experts, num_experts)\n+\n+    if attention_mask is None:\n+        # Compute the percentage of tokens routed to each experts\n+        tokens_per_expert = torch.mean(expert_mask.float(), dim=0)\n+\n+        # Compute the average probability of routing to these experts\n+        router_prob_per_expert = torch.mean(routing_weights, dim=0)\n+    else:\n+        batch_size, sequence_length = attention_mask.shape\n+        num_hidden_layers = concatenated_gate_logits.shape[0] // (batch_size * sequence_length)\n+\n+        # Compute the mask that masks all padding tokens as 0 with the same shape of expert_mask\n+        expert_attention_mask = (\n+            attention_mask[None, :, :, None, None]\n+            .expand((num_hidden_layers, batch_size, sequence_length, top_k, num_experts))\n+            .reshape(-1, top_k, num_experts)\n+            .to(compute_device)\n+        )\n+\n+        # Compute the percentage of tokens routed to each experts\n+        tokens_per_expert = torch.sum(expert_mask.float() * expert_attention_mask, dim=0) / torch.sum(\n+            expert_attention_mask, dim=0\n+        )\n+\n+        # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n+        router_per_expert_attention_mask = (\n+            attention_mask[None, :, :, None]\n+            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n+            .reshape(-1, num_experts)\n+            .to(compute_device)\n+        )\n+\n+        # Compute the average probability of routing to these experts\n+        router_prob_per_expert = torch.sum(routing_weights * router_per_expert_attention_mask, dim=0) / torch.sum(\n+            router_per_expert_attention_mask, dim=0\n+        )\n+\n+    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    return overall_loss * num_experts\n+\n+\n+@auto_docstring\n+class MiniMaxForCausalLM(MiniMaxPreTrainedModel, GenerationMixin):\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+    _tp_plan = {\"lm_head\": \"colwise_rep\"}\n+    _pp_plan = {\"lm_head\": ([\"hidden_states\"], [\"logits\"])}\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = MiniMaxModel(config)\n+        self.vocab_size = config.vocab_size\n+        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n+        self.router_aux_loss_coef = config.router_aux_loss_coef\n+        self.num_experts = config.num_local_experts\n+        self.num_experts_per_tok = config.num_experts_per_tok\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    def get_output_embeddings(self):\n+        return self.lm_head\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.lm_head = new_embeddings\n+\n+    def set_decoder(self, decoder):\n+        self.model = decoder\n+\n+    def get_decoder(self):\n+        return self.model\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        output_router_logits: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[KwargsForCausalLM],\n+    ) -> MoeCausalLMOutputWithPast:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, MiniMaxForCausalLM\n+\n+        >>> model = MiniMaxForCausalLM.from_pretrained(\"MiniMaxAI/MiniMax-Text-01-hf\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"MiniMaxAI/MiniMax-Text-01-hf\")\n+\n+        >>> prompt = \"Hey, are you conscious? Can you talk to me?\"\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"Hey, are you conscious? Can you talk to me?\\nI'm not conscious, but I can talk to you.\"\n+        ```\"\"\"\n+\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_router_logits = (\n+            output_router_logits if output_router_logits is not None else self.config.output_router_logits\n+        )\n+\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+\n+        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n+        outputs: MoeModelOutputWithPast = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            output_router_logits=output_router_logits,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs.last_hidden_state\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits, labels, self.vocab_size, **kwargs)\n+\n+        aux_loss = None\n+        if output_router_logits:\n+            aux_loss = load_balancing_loss_func(\n+                outputs.router_logits,\n+                self.num_experts,\n+                self.num_experts_per_tok,\n+                attention_mask,\n+            )\n+            if labels is not None:\n+                loss += self.router_aux_loss_coef * aux_loss.to(loss.device)  # make sure to reside in the same device\n+\n+        return MoeCausalLMOutputWithPast(\n+            loss=loss,\n+            aux_loss=aux_loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            router_logits=outputs.router_logits,\n+        )\n+\n+\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    The MiniMax Model transformer with a sequence classification head on top (linear layer).\n+\n+    [`MiniMaxForSequenceClassification`] uses the last token in order to do the classification, as other causal models\n+    (e.g. GPT-2) do.\n+\n+    Since it does classification on the last token, it requires to know the position of the last token. If a\n+    `pad_token_id` is defined in the configuration, it finds the last token that is not a padding token in each row. If\n+    no `pad_token_id` is defined, it simply takes the last value in each row of the batch. Since it cannot guess the\n+    padding tokens when `inputs_embeds` are passed instead of `input_ids`, it does the same (take the last value in\n+    each row of the batch).\n+    \"\"\"\n+)\n+class MiniMaxForSequenceClassification(MiniMaxPreTrainedModel):\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.num_labels = config.num_labels\n+        self.model = MiniMaxModel(config)\n+        self.score = nn.Linear(config.hidden_size, self.num_labels, bias=False)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+    ) -> SequenceClassifierOutputWithPast:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n+            Labels for computing the sequence classification/regression loss. Indices should be in `[0, ...,\n+            config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If\n+            `config.num_labels > 1` a classification loss is computed (Cross-Entropy).\n+        \"\"\"\n+\n+        transformer_outputs: BaseModelOutputWithPast = self.model(\n+            input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+        )\n+        hidden_states = transformer_outputs.last_hidden_state\n+        logits = self.score(hidden_states)\n+\n+        if input_ids is not None:\n+            batch_size = input_ids.shape[0]\n+        else:\n+            batch_size = inputs_embeds.shape[0]\n+\n+        if self.config.pad_token_id is None and batch_size != 1:\n+            raise ValueError(\"Cannot handle batch sizes > 1 if no padding token is defined.\")\n+        if self.config.pad_token_id is None:\n+            last_non_pad_token = -1\n+        elif input_ids is not None:\n+            # To handle both left- and right- padding, we take the rightmost token that is not equal to pad_token_id\n+            non_pad_mask = (input_ids != self.config.pad_token_id).to(logits.device, torch.int32)\n+            token_indices = torch.arange(input_ids.shape[-1], device=logits.device, dtype=torch.int32)\n+            last_non_pad_token = (token_indices * non_pad_mask).argmax(-1)\n+        else:\n+            last_non_pad_token = -1\n+            logger.warning_once(\n+                f\"{self.__class__.__name__} will not detect padding tokens in `inputs_embeds`. Results may be \"\n+                \"unexpected if using padding tokens in conjunction with `inputs_embeds.`\"\n+            )\n+\n+        pooled_logits = logits[torch.arange(batch_size, device=logits.device), last_non_pad_token]\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits=logits, labels=labels, pooled_logits=pooled_logits, config=self.config)\n+\n+        return SequenceClassifierOutputWithPast(\n+            loss=loss,\n+            logits=pooled_logits,\n+            past_key_values=transformer_outputs.past_key_values,\n+            hidden_states=transformer_outputs.hidden_states,\n+            attentions=transformer_outputs.attentions,\n+        )\n+\n+\n+@auto_docstring\n+class MiniMaxForTokenClassification(MiniMaxPreTrainedModel):\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.num_labels = config.num_labels\n+        self.model = MiniMaxModel(config)\n+        if getattr(config, \"classifier_dropout\", None) is not None:\n+            classifier_dropout = config.classifier_dropout\n+        elif getattr(config, \"hidden_dropout\", None) is not None:\n+            classifier_dropout = config.hidden_dropout\n+        else:\n+            classifier_dropout = 0.1\n+        self.dropout = nn.Dropout(classifier_dropout)\n+        self.score = nn.Linear(config.hidden_size, config.num_labels)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+    ) -> TokenClassifierOutput:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n+            Labels for computing the sequence classification/regression loss. Indices should be in `[0, ...,\n+            config.num_labels - 1]`. If `config.num_labels == 1` a regression loss is computed (Mean-Square loss), If\n+            `config.num_labels > 1` a classification loss is computed (Cross-Entropy).\n+        \"\"\"\n+\n+        outputs: BaseModelOutputWithPast = self.model(\n+            input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+        )\n+        sequence_output = outputs.last_hidden_state\n+        sequence_output = self.dropout(sequence_output)\n+        logits = self.score(sequence_output)\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits, labels, self.config)\n+\n+        return TokenClassifierOutput(\n+            loss=loss,\n+            logits=logits,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+\n+@auto_docstring\n+class MiniMaxForQuestionAnswering(MiniMaxPreTrainedModel):\n+    base_model_prefix = \"model\"\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.qa_outputs = nn.Linear(config.hidden_size, 2)\n+        self.model = MiniMaxModel(config)  # diff with Llama: transformer->model\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Union[Cache, List[torch.FloatTensor]]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        start_positions: Optional[torch.LongTensor] = None,\n+        end_positions: Optional[torch.LongTensor] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        **kwargs,\n+    ) -> QuestionAnsweringModelOutput:\n+        r\"\"\"\n+        start_positions (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n+            Labels for position (index) of the start of the labelled span for computing the token classification loss.\n+            Positions are clamped to the length of the sequence (`sequence_length`). Position outside of the sequence\n+            are not taken into account for computing the loss.\n+        end_positions (`torch.LongTensor` of shape `(batch_size,)`, *optional*):\n+            Labels for position (index) of the end of the labelled span for computing the token classification loss.\n+            Positions are clamped to the length of the sequence (`sequence_length`). Position outside of the sequence\n+            are not taken into account for computing the loss.\n+        \"\"\"\n+\n+        outputs: BaseModelOutputWithPast = self.model(\n+            input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+        )\n+\n+        sequence_output = outputs.last_hidden_state\n+\n+        logits = self.qa_outputs(sequence_output)\n+        start_logits, end_logits = logits.split(1, dim=-1)\n+        start_logits = start_logits.squeeze(-1).contiguous()\n+        end_logits = end_logits.squeeze(-1).contiguous()\n+\n+        loss = None\n+        if start_positions is not None and end_positions is not None:\n+            loss = self.loss_function(start_logits, end_logits, start_positions, end_positions, **kwargs)\n+\n+        return QuestionAnsweringModelOutput(\n+            loss=loss,\n+            start_logits=start_logits,\n+            end_logits=end_logits,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+\n+__all__ = [\n+    \"MiniMaxPreTrainedModel\",\n+    \"MiniMaxModel\",\n+    \"MiniMaxForCausalLM\",\n+    \"MiniMaxForSequenceClassification\",\n+    \"MiniMaxForTokenClassification\",\n+    \"MiniMaxForQuestionAnswering\",\n+]"
        },
        {
            "sha": "9a44d66656393bef99b8f045db1622cfc4a18389",
            "filename": "src/transformers/models/minimax/modular_minimax.py",
            "status": "added",
            "additions": 644,
            "deletions": 0,
            "changes": 644,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fminimax%2Fmodular_minimax.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/src%2Ftransformers%2Fmodels%2Fminimax%2Fmodular_minimax.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fminimax%2Fmodular_minimax.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -0,0 +1,644 @@\n+# coding=utf-8\n+# Copyright 2025 MiniMaxAI and HuggingFace Inc. teams. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch MiniMax model.\"\"\"\n+\n+from typing import List, Optional, Tuple\n+\n+import torch\n+import torch.nn.functional as F\n+from torch import nn\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache\n+from ...configuration_utils import layer_type_validation\n+from ...masking_utils import create_causal_mask, create_sliding_window_causal_mask\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import MoeModelOutputWithPast\n+from ...processing_utils import Unpack\n+from ...utils import logging\n+from ..mixtral.configuration_mixtral import MixtralConfig\n+from ..mixtral.modeling_mixtral import (\n+    MixtralAttention,\n+    MixtralDecoderLayer,\n+    MixtralForCausalLM,\n+    MixtralForQuestionAnswering,\n+    MixtralForSequenceClassification,\n+    MixtralForTokenClassification,\n+    MixtralModel,\n+    MixtralPreTrainedModel,\n+    MixtralRMSNorm,\n+)\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class MiniMaxConfig(MixtralConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`MiniMaxModel`]. It is used to instantiate an\n+    MiniMax model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of the MiniMax.\n+\n+    [MiniMaxAI/MiniMax-Text-01-hf](https://huggingface.co/MiniMaxAI/MiniMax-Text-01-hf)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 32000):\n+            Vocabulary size of the MiniMax model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`MiniMaxModel`]\n+        hidden_size (`int`, *optional*, defaults to 4096):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 14336):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 32):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 32):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 8):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `8`.\n+        head_dim (`int`, *optional*, defaults to `hidden_size // num_attention_heads`):\n+            The attention head dimension.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to `4096*32`):\n+            The maximum sequence length that this model might ever be used with. MiniMax's sliding window attention\n+            allows sequence of up to 4096*32 tokens.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        pad_token_id (`int`, *optional*):\n+            The id of the padding token.\n+        bos_token_id (`int`, *optional*, defaults to 1):\n+            The id of the \"beginning-of-sequence\" token.\n+        eos_token_id (`int`, *optional*, defaults to 2):\n+            The id of the \"end-of-sequence\" token.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_theta (`float`, *optional*, defaults to 1000000.0):\n+            The base period of the RoPE embeddings.\n+        sliding_window (`int`, *optional*):\n+            Sliding window attention window size. If not specified, will default to `4096`.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        num_experts_per_tok (`int`, *optional*, defaults to 2):\n+            The number of experts to route per-token, can be also interpreted as the `top-k` routing\n+            parameter\n+        num_local_experts (`int`, *optional*, defaults to 8):\n+            Number of experts per Sparse MLP layer.\n+        output_router_logits (`bool`, *optional*, defaults to `False`):\n+            Whether or not the router logits should be returned by the model. Enabeling this will also\n+            allow the model to output the auxiliary loss. See [here]() for more details\n+        router_aux_loss_coef (`float`, *optional*, defaults to 0.001):\n+            The aux loss factor for the total loss.\n+        router_jitter_noise (`float`, *optional*, defaults to 0.0):\n+            Amount of noise to add to the router.\n+        layer_types (`list`, *optional*):\n+            Attention pattern for each layer.\n+        block_size (`int`, *optional*, defaults to 256):\n+            The length of each attention block, determining how queries, keys, and values\n+            are grouped and processed for intra- and inter-block attention.\n+        full_attn_alpha_factor (`float`, *optional*, defaults to 1):\n+            Weight for residual value in residual connection after normal attention.\n+        full_attn_beta_factor (`float`, *optional*, defaults to 1):\n+            Weight for hidden state value in residual connection after normal attention.\n+        linear_attn_alpha_factor (`float`, *optional*, defaults to 1):\n+            Weight for residual value in residual connection after lightning attention.\n+        linear_attn_beta_factor (`float`, *optional*, defaults to 1):\n+            Weight for hidden state value in residual connection after lightning attention.\n+        mlp_alpha_factor (`float`, *optional*, defaults to 1):\n+            Weight for residual value in residual connection after MLP.\n+        mlp_beta_factor (`float`, *optional*, defaults to 1):\n+            Weight for hidden state value in residual connection after MLP.\n+\n+    ```python\n+    >>> from transformers import MiniMaxModel, MiniMaxConfig\n+\n+    >>> # Initializing a MiniMax style configuration\n+    >>> configuration = MiniMaxConfig()\n+\n+    >>> # Initializing a model from the MiniMax style configuration\n+    >>> model = MiniMaxModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    def __init__(\n+        self,\n+        layer_types=None,\n+        block_size=256,\n+        full_attn_alpha_factor=1,\n+        full_attn_beta_factor=1,\n+        linear_attn_alpha_factor=1,\n+        linear_attn_beta_factor=1,\n+        mlp_alpha_factor=1,\n+        mlp_beta_factor=1,\n+        **super_kwargs,\n+    ):\n+        super().__init__(**super_kwargs)\n+        self.layer_types = layer_types\n+        self.block_size = block_size\n+        self.full_attn_alpha_factor = full_attn_alpha_factor\n+        self.full_attn_beta_factor = full_attn_beta_factor\n+        self.linear_attn_alpha_factor = linear_attn_alpha_factor\n+        self.linear_attn_beta_factor = linear_attn_beta_factor\n+        self.mlp_alpha_factor = mlp_alpha_factor\n+        self.mlp_beta_factor = mlp_beta_factor\n+\n+        if self.layer_types is None:\n+            self.layer_types = [\n+                \"full_attention\" if bool((i + 1) % 2) else \"linear_attention\" for i in range(self.num_hidden_layers)\n+            ]\n+        layer_type_validation(self.layer_types)\n+\n+\n+class MiniMaxRMSNorm(MixtralRMSNorm):\n+    pass\n+\n+\n+class MiniMaxCache(DynamicCache):\n+    def __init__(self):\n+        super().__init__()\n+        self.linear_cache: List[torch.Tensor] = []\n+\n+    def set_linear_cache(self, layer_idx, linear_cache):\n+        # There may be skipped layers, fill them with empty lists\n+        for _ in range(len(self.linear_cache), layer_idx + 1):\n+            self.linear_cache.append([])\n+        self.linear_cache[layer_idx] = linear_cache\n+\n+    def get_linear_cache(self, layer_idx: int):\n+        if layer_idx < len(self):\n+            return self.linear_cache[layer_idx]\n+        return None\n+\n+    def __len__(self):\n+        return max(super().__len__(), len(self.linear_cache))\n+\n+    def __getitem__(self, layer_idx: int):\n+        if layer_idx < len(self.linear_cache) and self.linear_cache[layer_idx] != []:\n+            return (self.linear_cache[layer_idx],)\n+        return super().__getitem__(layer_idx)\n+\n+    def __iter__(self):\n+        for layer_idx in range(len(self)):\n+            yield self[layer_idx]\n+\n+    def batch_repeat_interleave(self, repeats: int):\n+        for layer_idx in range(len(self)):\n+            if self.linear_cache[layer_idx] != []:\n+                self.linear_cache[layer_idx] = self.linear_cache[layer_idx].repeat_interleave(repeats, dim=0)\n+            else:\n+                self.key_cache[layer_idx] = self.key_cache[layer_idx].repeat_interleave(repeats, dim=0)\n+                self.value_cache[layer_idx] = self.value_cache[layer_idx].repeat_interleave(repeats, dim=0)\n+\n+    def batch_select_indices(self, indices: torch.Tensor):\n+        for layer_idx in range(len(self)):\n+            if self.linear_cache[layer_idx] != []:\n+                self.linear_cache[layer_idx] = self.linear_cache[layer_idx][indices, ...]\n+            else:\n+                self.key_cache[layer_idx] = self.key_cache[layer_idx][indices, ...]\n+                self.value_cache[layer_idx] = self.value_cache[layer_idx][indices, ...]\n+\n+    def crop(self, max_length: int):\n+        raise RuntimeError(\"MiniMaxCache doesnot support `crop` method\")\n+\n+\n+class MiniMaxLightningAttention(nn.Module):\n+    def __init__(self, config: MiniMaxConfig, layer_idx: int):\n+        super().__init__()\n+        self.layer_idx = layer_idx\n+        self.head_dim = getattr(config, \"head_dim\", None) or config.hidden_size // config.num_attention_heads\n+        self.num_attention_heads = config.num_attention_heads\n+        self.num_hidden_layers = config.num_hidden_layers\n+        self.block_size = config.block_size\n+\n+        self.act_fn = ACT2FN[config.hidden_act]\n+        self.norm = MiniMaxRMSNorm(self.head_dim * self.num_attention_heads)\n+        self.qkv_proj = nn.Linear(config.hidden_size, self.num_attention_heads * self.head_dim * 3, bias=False)\n+        self.out_proj = nn.Linear(self.num_attention_heads * self.head_dim, config.hidden_size, bias=False)\n+        self.output_gate = nn.Linear(config.hidden_size, self.num_attention_heads * self.head_dim, bias=False)\n+\n+        slope_rate = self.get_slope_rate()\n+        query_decay, key_decay, diagonal_decay = self.decay_factors(slope_rate)\n+\n+        self.register_buffer(\"slope_rate\", slope_rate)\n+        self.register_buffer(\"query_decay\", query_decay)\n+        self.register_buffer(\"key_decay\", key_decay)\n+        self.register_buffer(\"diagonal_decay\", diagonal_decay)\n+\n+    def get_slope_rate(self):\n+        base = 1 / (2 ** (8 / self.num_attention_heads))\n+        exponent = torch.arange(self.num_attention_heads) + 1\n+        factor = 1 - self.layer_idx / (self.num_hidden_layers - 1 + 1e-5) + 1e-5\n+\n+        rate = base**exponent\n+        rate = rate * factor\n+        rate = rate[:, None, None]\n+\n+        return rate\n+\n+    def decay_factors(self, slope_rate):\n+        block_size_range = torch.arange(self.block_size) + 1\n+\n+        query_decay = torch.exp(-slope_rate * block_size_range[:, None])\n+        key_decay = torch.exp(-slope_rate * (self.block_size - block_size_range[:, None]))\n+\n+        diagonal_decay = block_size_range[:, None] - block_size_range[None, :]\n+        diagonal_decay = diagonal_decay[None, None, :, :]\n+        diagonal_decay = slope_rate * diagonal_decay\n+        diagonal_decay = torch.where(diagonal_decay >= 0, -diagonal_decay, float(\"-inf\"))\n+        diagonal_decay = torch.exp(diagonal_decay)\n+\n+        return query_decay, key_decay, diagonal_decay\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: Tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        batch_size, seq_len, hidden_size = hidden_states.shape\n+        num_blocks = (seq_len + self.block_size - 1) // self.block_size\n+\n+        qkv_states = self.act_fn(self.qkv_proj(hidden_states))\n+        qkv_states = qkv_states.reshape(batch_size, seq_len, self.num_attention_heads, 3 * self.head_dim)\n+\n+        query_states, key_states, value_states = torch.split(qkv_states, self.head_dim, dim=3)\n+\n+        query_states = query_states.transpose(1, 2)\n+        key_states = key_states.transpose(1, 2)\n+        value_states = value_states.transpose(1, 2)\n+\n+        # calculated (K.T @ V) and saved as cache\n+        attn_weights_inter = None\n+        if past_key_value is not None:\n+            attn_weights_inter = past_key_value.get_linear_cache(self.layer_idx)\n+\n+        if attn_weights_inter is None:\n+            attn_weights_inter = torch.zeros(batch_size, self.num_attention_heads, self.head_dim, self.head_dim).to(\n+                value_states\n+            )\n+\n+            # apply attention_mask\n+            if attention_mask is not None:\n+                attention_mask = attention_mask.to(dtype=torch.bool)  # Ensure it's a boolean tensor\n+                value_states = value_states.masked_fill(~attention_mask.unsqueeze(1).unsqueeze(-1), 0)\n+\n+            attn_output = []\n+            for i in range(num_blocks):\n+                start_idx = i * self.block_size\n+                end_idx = min(start_idx + self.block_size, seq_len)\n+                current_block_size = end_idx - start_idx\n+\n+                current_query_states = query_states[:, :, start_idx:end_idx]\n+                current_key_states = key_states[:, :, start_idx:end_idx]\n+                current_value_states = value_states[:, :, start_idx:end_idx]\n+\n+                current_query_decay = self.query_decay[:, :current_block_size]\n+                current_key_decay = self.key_decay[:, -current_block_size:]\n+                current_diagonal_decay = self.diagonal_decay[:, :, :current_block_size, :current_block_size]\n+                block_decay = torch.exp(-self.slope_rate * current_block_size)\n+\n+                # intra: ( Q @ K.T ) @ V -> QK * V\n+                attn_weights_intra = torch.matmul(current_query_states, current_key_states.transpose(-1, -2))\n+                attn_output_intra = torch.matmul(attn_weights_intra * current_diagonal_decay, current_value_states)\n+\n+                # inter: Q @ ( K.T @ V ) -> Q * KV\n+                attn_output_inter = torch.matmul(current_query_states * current_query_decay, attn_weights_inter)\n+\n+                # final attention output\n+                current_attn_output = attn_output_inter + attn_output_intra\n+                attn_output.append(current_attn_output)\n+\n+                # cacluate attn_weights_inter for next block or cache\n+                next_attn_weights_inter = torch.matmul(\n+                    (current_key_states * current_key_decay).transpose(-1, -2), current_value_states\n+                )\n+                attn_weights_inter = attn_weights_inter * block_decay + next_attn_weights_inter\n+\n+        else:\n+            ratio = torch.exp(-self.slope_rate)\n+            attn_output = []\n+            for i in range(seq_len):\n+                current_query_states = query_states[:, :, i : i + 1]\n+                current_key_states = key_states[:, :, i : i + 1]\n+                current_value_states = value_states[:, :, i : i + 1]\n+\n+                current_attn_weights_inter = torch.matmul(current_key_states.transpose(-1, -2), current_value_states)\n+                attn_weights_inter = ratio * attn_weights_inter + current_attn_weights_inter\n+                current_attn_output = torch.matmul(current_query_states, attn_weights_inter)\n+\n+                attn_output.append(current_attn_output)\n+\n+        # concatenate attention outputs over all blocks\n+        attn_output = torch.cat(attn_output, dim=-2)\n+\n+        # final output projection\n+        attn_output = attn_output.transpose(1, 2)\n+        attn_output = attn_output.reshape(batch_size, seq_len, self.num_attention_heads * self.head_dim)\n+        attn_output = self.norm(attn_output)\n+        attn_output = F.sigmoid(self.output_gate(hidden_states)) * attn_output\n+        attn_output = self.out_proj(attn_output)\n+\n+        # update cache\n+        if past_key_value is not None:\n+            past_key_value.set_linear_cache(self.layer_idx, attn_weights_inter)\n+\n+        return attn_output, attn_weights_inter\n+\n+\n+class MiniMaxAttention(MixtralAttention):\n+    pass\n+\n+\n+class MiniMaxDecoderLayer(MixtralDecoderLayer, GradientCheckpointingLayer):\n+    def __init__(self, config: MiniMaxConfig, layer_idx: int):\n+        super().__init__(config, layer_idx)\n+\n+        self.layer_idx = layer_idx\n+        self.layer_type = config.layer_types[layer_idx]\n+        self.mlp_alpha_factor = config.mlp_alpha_factor\n+        self.mlp_beta_factor = config.mlp_beta_factor\n+\n+        if self.layer_type == \"linear_attention\":\n+            self.self_attn = MiniMaxLightningAttention(config, layer_idx)\n+            self.attn_alpha_factor = config.linear_attn_alpha_factor\n+            self.attn_beta_factor = config.linear_attn_beta_factor\n+        else:\n+            self.self_attn = MiniMaxAttention(config, layer_idx)\n+            self.attn_alpha_factor = config.full_attn_alpha_factor\n+            self.attn_beta_factor = config.full_attn_beta_factor\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: Tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Tuple[torch.Tensor]] = None,\n+        output_attentions: Optional[bool] = False,\n+        output_router_logits: Optional[bool] = False,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Tuple[torch.FloatTensor, Optional[Tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.FloatTensor`): input to the layer of shape `(batch, seq_len, embed_dim)`\n+            position_embeddings (`Tuple[torch.FloatTensor, torch.FloatTensor]`):\n+                Tuple containing the cosine and sine positional embeddings of shape `(batch_size, seq_len, head_dim)`,\n+                with `head_dim` being the embedding dimension of each attention head.\n+            attention_mask (`torch.Tensor`, *optional*): attention mask of size\n+                `(batch, sequence_length)` where padding elements are indicated by 0.\n+            past_key_value (`Tuple(torch.FloatTensor)`, *optional*): cached past key and value projection states\n+            output_attentions (`bool`, *optional*):\n+                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n+                returned tensors for more detail.\n+            output_router_logits (`bool`, *optional*):\n+                Whether or not to return the logits of all the routers. They are useful for computing the router loss, and\n+                should not be returned during inference.\n+            use_cache (`bool`, *optional*):\n+                If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding\n+                (see `past_key_values`).\n+            cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n+                Indices depicting the position of the input sequence tokens in the sequence.\n+            kwargs (`dict`, *optional*):\n+                Arbitrary kwargs to be ignored, used for FSDP and other methods that injects code\n+                into the model\n+        \"\"\"\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+        residual = hidden_states\n+\n+        # Self Attention\n+        hidden_states, self_attn_weights = self.self_attn(\n+            hidden_states=hidden_states,\n+            position_embeddings=position_embeddings,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = residual * self.attn_alpha_factor + hidden_states * self.attn_beta_factor\n+\n+        # Fully Connected\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        residual = hidden_states\n+        hidden_states, router_logits = self.block_sparse_moe(hidden_states)\n+        hidden_states = residual * self.mlp_alpha_factor + hidden_states * self.mlp_beta_factor\n+\n+        outputs = (hidden_states,)\n+\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        if output_router_logits:\n+            outputs += (router_logits,)\n+\n+        return outputs\n+\n+\n+class MiniMaxPreTrainedModel(MixtralPreTrainedModel):\n+    _supports_cache_class = True  # Note: only supports MiniMaxCache\n+    _supports_static_cache = False\n+    _supports_quantized_cache = False\n+\n+\n+class MiniMaxModel(MixtralModel):\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        output_router_logits: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **flash_attn_kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> MoeModelOutputWithPast:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_router_logits = (\n+            output_router_logits if output_router_logits is not None else self.config.output_router_logits\n+        )\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if self.gradient_checkpointing and self.training:\n+            if use_cache:\n+                logger.warning_once(\n+                    \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n+                )\n+                use_cache = False\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = MiniMaxCache()\n+        elif use_cache and not isinstance(past_key_values, MiniMaxCache):\n+            raise ValueError(\n+                f\"MiniMax uses cache of its own and is not compatible with `past_key_values` of type {type(past_key_values)}.\"\n+            )\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        mask_function = create_causal_mask if self.config.sliding_window is None else create_sliding_window_causal_mask\n+        causal_mask = mask_function(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+        )\n+\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+        all_router_logits = () if output_router_logits else None\n+\n+        for decoder_layer in self.layers:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            if decoder_layer.layer_type == \"full_attention\":\n+                input_attention_mask = causal_mask\n+            else:\n+                # lightning attention uses original attention_mask, and uses it only for the first step\n+                input_attention_mask = attention_mask\n+\n+            layer_outputs = decoder_layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=input_attention_mask,\n+                position_ids=position_ids,\n+                past_key_value=past_key_values,\n+                output_attentions=output_attentions,\n+                output_router_logits=output_router_logits,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                **flash_attn_kwargs,\n+            )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+            if output_router_logits:\n+                all_router_logits += (layer_outputs[-1],)\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        # add hidden states from the last decoder layer\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        return MoeModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+            router_logits=all_router_logits,\n+        )\n+\n+\n+class MiniMaxForCausalLM(MixtralForCausalLM):\n+    def forward(self, **super_kwargs):\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, MiniMaxForCausalLM\n+\n+        >>> model = MiniMaxForCausalLM.from_pretrained(\"MiniMaxAI/MiniMax-Text-01-hf\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"MiniMaxAI/MiniMax-Text-01-hf\")\n+\n+        >>> prompt = \"Hey, are you conscious? Can you talk to me?\"\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"Hey, are you conscious? Can you talk to me?\\nI'm not conscious, but I can talk to you.\"\n+        ```\"\"\"\n+        return super().forward(**super_kwargs)\n+\n+\n+class MiniMaxForSequenceClassification(MixtralForSequenceClassification):\n+    pass\n+\n+\n+class MiniMaxForTokenClassification(MixtralForTokenClassification):\n+    pass\n+\n+\n+class MiniMaxForQuestionAnswering(MixtralForQuestionAnswering):\n+    pass\n+\n+\n+__all__ = [\n+    \"MiniMaxConfig\",\n+    \"MiniMaxPreTrainedModel\",\n+    \"MiniMaxModel\",\n+    \"MiniMaxForCausalLM\",\n+    \"MiniMaxForSequenceClassification\",\n+    \"MiniMaxForTokenClassification\",\n+    \"MiniMaxForQuestionAnswering\",\n+]"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/minimax/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/tests%2Fmodels%2Fminimax%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/tests%2Fmodels%2Fminimax%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fminimax%2F__init__.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd"
        },
        {
            "sha": "2d03b01f73623fd08a59ac9c9d9912fe4a7fb221",
            "filename": "tests/models/minimax/test_modeling_minimax.py",
            "status": "added",
            "additions": 279,
            "deletions": 0,
            "changes": 279,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/tests%2Fmodels%2Fminimax%2Ftest_modeling_minimax.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/tests%2Fmodels%2Fminimax%2Ftest_modeling_minimax.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fminimax%2Ftest_modeling_minimax.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -0,0 +1,279 @@\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch MiniMax model.\"\"\"\n+\n+import unittest\n+\n+import pytest\n+\n+from transformers import MiniMaxConfig, is_torch_available\n+from transformers.cache_utils import Cache\n+from transformers.testing_utils import (\n+    require_flash_attn,\n+    require_torch,\n+    require_torch_accelerator,\n+    require_torch_gpu,\n+    slow,\n+    torch_device,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import (\n+        MiniMaxForCausalLM,\n+        MiniMaxForQuestionAnswering,\n+        MiniMaxForSequenceClassification,\n+        MiniMaxForTokenClassification,\n+        MiniMaxModel,\n+    )\n+\n+from ...causal_lm_tester import CausalLMModelTest, CausalLMModelTester\n+\n+\n+class MiniMaxModelTester(CausalLMModelTester):\n+    config_class = MiniMaxConfig\n+    if is_torch_available():\n+        base_model_class = MiniMaxModel\n+        causal_lm_class = MiniMaxForCausalLM\n+        sequence_class = MiniMaxForSequenceClassification\n+        token_class = MiniMaxForTokenClassification\n+        question_answering_class = MiniMaxForQuestionAnswering\n+\n+    def __init__(self, parent, layer_types=None, block_size=3):\n+        super().__init__(parent)\n+        self.layer_types = layer_types\n+        self.block_size = block_size\n+\n+\n+@require_torch\n+class MiniMaxModelTest(CausalLMModelTest, unittest.TestCase):\n+    all_model_classes = (\n+        (\n+            MiniMaxModel,\n+            MiniMaxForCausalLM,\n+            MiniMaxForSequenceClassification,\n+            MiniMaxForTokenClassification,\n+            MiniMaxForQuestionAnswering,\n+        )\n+        if is_torch_available()\n+        else ()\n+    )\n+    pipeline_model_mapping = (\n+        {\n+            \"feature-extraction\": MiniMaxModel,\n+            \"text-classification\": MiniMaxForSequenceClassification,\n+            \"token-classification\": MiniMaxForTokenClassification,\n+            \"text-generation\": MiniMaxForCausalLM,\n+            \"question-answering\": MiniMaxForQuestionAnswering,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+\n+    test_headmasking = False\n+    test_pruning = False\n+    model_tester_class = MiniMaxModelTester\n+\n+    # TODO (ydshieh): Check this. See https://app.circleci.com/pipelines/github/huggingface/transformers/79245/workflows/9490ef58-79c2-410d-8f51-e3495156cf9c/jobs/1012146\n+    def is_pipeline_test_to_skip(\n+        self,\n+        pipeline_test_case_name,\n+        config_class,\n+        model_architecture,\n+        tokenizer_name,\n+        image_processor_name,\n+        feature_extractor_name,\n+        processor_name,\n+    ):\n+        return True\n+\n+    @require_flash_attn\n+    @require_torch_gpu\n+    @pytest.mark.flash_attn_test\n+    @slow\n+    def test_flash_attn_2_inference_equivalence_right_padding(self):\n+        self.skipTest(reason=\"MiniMax flash attention does not support right padding\")\n+\n+    def test_load_balancing_loss(self):\n+        r\"\"\"\n+        Let's make sure we can actually compute the loss and do a backward on it.\n+        \"\"\"\n+        config, input_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+        config.num_labels = 3\n+        config.num_local_experts = 8\n+        config.output_router_logits = True\n+        input_ids = input_dict[\"input_ids\"]\n+        attention_mask = input_ids.ne(1).to(torch_device)\n+        model = MiniMaxForCausalLM(config)\n+        model.to(torch_device)\n+        model.eval()\n+        result = model(input_ids, attention_mask=attention_mask)\n+        self.assertEqual(result.router_logits[0].shape, (91, config.num_local_experts))\n+        torch.testing.assert_close(result.aux_loss.cpu(), torch.tensor(2, dtype=torch.float32), rtol=1e-2, atol=1e-2)\n+\n+        # First, we make sure that adding padding tokens doesn't change the loss\n+        # loss(input_ids, attention_mask=None) == loss(input_ids + padding, attention_mask=attention_mask_with_padding)\n+        pad_length = 1000\n+        # Add padding tokens (assume that pad_token_id=1) to input_ids\n+        padding_block = torch.ones(input_ids.shape[0], pad_length, dtype=torch.int32).to(torch_device)\n+        padded_input_ids = torch.cat((padding_block, input_ids), dim=1)  # this is to simulate padding to the left\n+        padded_attention_mask = padded_input_ids.ne(1).to(torch_device)\n+\n+        padded_result = model(padded_input_ids, attention_mask=padded_attention_mask)\n+        torch.testing.assert_close(result.aux_loss.cpu(), padded_result.aux_loss.cpu(), rtol=1e-4, atol=1e-4)\n+\n+        # We make sure that the loss of including padding tokens != the loss without padding tokens\n+        # if attention_mask=None --> we don't exclude padding tokens\n+        include_padding_result = model(padded_input_ids, attention_mask=None)\n+\n+        # This is to mimic torch.testing.assert_not_close\n+        self.assertNotAlmostEqual(include_padding_result.aux_loss.item(), result.aux_loss.item())\n+\n+    def _check_attentions_for_generate(\n+        self, batch_size, attentions, prompt_length, output_length, config, decoder_past_key_values\n+    ):\n+        self.assertIsInstance(attentions, tuple)\n+        self.assertListEqual(\n+            [isinstance(iter_attentions, tuple) for iter_attentions in attentions], [True] * len(attentions)\n+        )\n+        self.assertEqual(len(attentions), (output_length - prompt_length))\n+        use_cache = decoder_past_key_values is not None\n+\n+        for generated_length, iter_attentions in enumerate(attentions):\n+            # regardless of using cache, the first forward pass will have the full prompt as input\n+            if use_cache and generated_length > 0:\n+                model_input_length = 1\n+            else:\n+                model_input_length = prompt_length + generated_length\n+\n+            expected_shape = (\n+                batch_size,\n+                config.num_attention_heads,\n+                model_input_length,\n+                prompt_length + generated_length,\n+            )\n+            for layer_idx, layer_attention in enumerate(iter_attentions):\n+                if config.layer_types[layer_idx] == \"full_attention\":\n+                    self.assertEqual(layer_attention.shape, expected_shape)\n+\n+    def _check_past_key_values_for_generate(self, batch_size, decoder_past_key_values, cache_length, config):\n+        self.assertIsInstance(decoder_past_key_values, (tuple, Cache))\n+\n+        # (batch, head, seq_length, head_features)\n+        key_value_cache_expected_shape = (\n+            batch_size,\n+            config.num_key_value_heads,\n+            cache_length,\n+            config.hidden_size // config.num_attention_heads,\n+        )\n+        # (batch, head, head_features, head_features)\n+        linear_cache_expected_shape = (\n+            batch_size,\n+            config.num_attention_heads,\n+            config.hidden_size // config.num_attention_heads,\n+            config.hidden_size // config.num_attention_heads,\n+        )\n+\n+        for layer_idx in range(config.num_hidden_layers):\n+            if config.layer_types[layer_idx] == \"full_attention\":\n+                self.assertEqual(decoder_past_key_values[layer_idx][0].shape, key_value_cache_expected_shape)\n+                self.assertEqual(decoder_past_key_values[layer_idx][1].shape, key_value_cache_expected_shape)\n+            else:\n+                self.assertEqual(decoder_past_key_values[layer_idx][0].shape, linear_cache_expected_shape)\n+\n+    @pytest.mark.generate\n+    def test_past_key_values_format(self, custom_all_cache_shapes=None):\n+        \"\"\"\n+        Test that the KV cache is formatted correctly.\n+        \"\"\"\n+        for model_class in self.all_generative_model_classes:\n+            config, inputs = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+            model = model_class(config).to(torch_device)\n+            model = model.eval()\n+            if \"use_cache\" not in inputs:\n+                inputs[\"use_cache\"] = True\n+            outputs = model(**inputs)\n+\n+            past_kv = outputs[\"past_key_values\"]\n+\n+            batch_size, seq_length = inputs[\"input_ids\"].shape\n+            self._check_past_key_values_for_generate(batch_size, past_kv, seq_length, config)\n+\n+    @unittest.skip(reason=\"MiniMaxCache doesnot support `crop()` method\")\n+    def test_prompt_lookup_decoding_matches_greedy_search(self):\n+        pass\n+\n+    @unittest.skip(reason=\"MiniMaxCache doesnot support `crop()` method\")\n+    def test_contrastive_generate_low_memory(self):\n+        pass\n+\n+    @unittest.skip(reason=\"MiniMaxCache doesnot support `crop()` method\")\n+    def test_assisted_decoding_sample(self):\n+        pass\n+\n+    @unittest.skip(reason=\"MiniMaxCache doesnot support `crop()` method\")\n+    def test_assisted_decoding_matches_greedy_search_0_random(self):\n+        pass\n+\n+    @unittest.skip(reason=\"MiniMaxCache doesnot support `crop()` method\")\n+    def test_assisted_decoding_matches_greedy_search_1_same(self):\n+        pass\n+\n+    @unittest.skip(reason=\"MiniMaxCache doesnot support `crop()` method\")\n+    def test_contrastive_generate_dict_outputs_use_cache(self):\n+        pass\n+\n+\n+@require_torch\n+@require_torch_accelerator\n+@slow\n+class MiniMaxIntegrationTest(unittest.TestCase):\n+    def test_small_model_logits(self):\n+        model_id = \"geetu040/MiniMax-tiny\"\n+        dummy_input = torch.LongTensor([[0, 1, 0], [0, 1, 0]]).to(torch_device)\n+\n+        model = MiniMaxForCausalLM.from_pretrained(model_id, torch_dtype=torch.bfloat16, low_cpu_mem_usage=True).to(\n+            torch_device\n+        )\n+        expected_slice = torch.tensor(\n+            [[1.0312, -0.5156, -0.3262], [-0.1152, 0.4336, 0.2412], [1.2188, -0.5898, -0.0381]]\n+        ).to(torch_device)\n+\n+        with torch.no_grad():\n+            logits = model(dummy_input).logits\n+\n+        logits = logits.float()\n+\n+        torch.testing.assert_close(logits[0, :3, :3], expected_slice, atol=1e-3, rtol=1e-3)\n+        torch.testing.assert_close(logits[1, :3, :3], expected_slice, atol=1e-3, rtol=1e-3)\n+\n+    def test_small_model_generation(self):\n+        model_id = \"geetu040/MiniMax-tiny\"\n+        dummy_input = torch.LongTensor([[0, 1, 0], [0, 1, 0]]).to(torch_device)\n+\n+        model = MiniMaxForCausalLM.from_pretrained(model_id, torch_dtype=torch.bfloat16, low_cpu_mem_usage=True).to(\n+            torch_device\n+        )\n+        expected_slice = (\n+            torch.tensor([[0, 1, 0, 933, 307, 3102, 2457, 1208], [0, 1, 0, 933, 307, 3102, 2457, 1208]])\n+            .to(torch.int64)\n+            .to(torch_device)\n+        )\n+\n+        outputs = model.generate(dummy_input, max_new_tokens=5, do_sample=False)\n+\n+        torch.testing.assert_close(outputs, expected_slice, atol=1e-3, rtol=1e-3)"
        },
        {
            "sha": "9011f341007141ab86bcd268feaa9116e23ce825",
            "filename": "tests/test_modeling_common.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/tests%2Ftest_modeling_common.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/55736eea9939620b62e0f6660d1dd4f3e9e12ebd/tests%2Ftest_modeling_common.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Ftest_modeling_common.py?ref=55736eea9939620b62e0f6660d1dd4f3e9e12ebd",
            "patch": "@@ -3946,7 +3946,7 @@ def test_sdpa_matches_eager_sliding_window(self):\n         if not self.has_attentions:\n             self.skipTest(reason=\"Model architecture does not support attentions\")\n \n-        WINDOW_ATTENTION_MODELS = [\"mistral\", \"mixtral\", \"qwen2\", \"qwen_moe\", \"starcoder2\"]\n+        WINDOW_ATTENTION_MODELS = [\"mistral\", \"mixtral\", \"minimax\", \"qwen2\", \"qwen_moe\", \"starcoder2\"]\n \n         if len(self.all_generative_model_classes) == 0:\n             self.skipTest(f\"No generative model classes for {self.__class__.__name__}\")"
        }
    ],
    "stats": {
        "total": 2651,
        "additions": 2650,
        "deletions": 1
    }
}