{
    "author": "zRzRzRzRzRzRzR",
    "message": "GLM-4.1V Model support (#38431)\n\n* 20250508 Model Architecture\n\n* Update modeling_glm4v.py\n\n* Update modeling_glm4v.py\n\n* Update modeling_glm4v.py\n\n* update 1447\n\n* 0526\n\n* update\n\n* format\n\n* problem\n\n* update\n\n* update with only image embed diff\n\n* Final\n\n* upload\n\n* update\n\n* 1\n\n* upload with ruff\n\n* update\n\n* update\n\n* work\n\n* 1\n\n* 1\n\n* update with new note\n\n* 2\n\n* Update convert_glm4v_mgt_weights_to_hf.py\n\n* Update tokenization_auto.py\n\n* update with new format\n\n* remove rmsnrom\n\n* draft with videos\n\n* draft\n\n* update\n\n* update\n\n* fix for review problem\n\n* try to remove min_pixel\n\n* update\n\n* for test\n\n* remove timestamps\n\n* remove item\n\n* update with remove\n\n* change\n\n* update 2200\n\n* update\n\n* Delete app.py\n\n* format\n\n* update\n\n* Update test_video_processing_glm4v.py\n\n* 1\n\n* 2\n\n* use new name\n\n* Update test_video_processing_glm4v.py\n\n* remove docs\n\n* change\n\n* update for image processors update\n\n* 2108\n\n* 2128\n\n* Update modular_glm4v.py\n\n* 1\n\n* update some\n\n* update\n\n* rename\n\n* 1\n\n* remove tests output\n\n* 2\n\n* add configuration\n\n* update\n\n* Update test_video_processing_glm4v.py\n\n* fix simple forward tests\n\n* update with modular\n\n* 1\n\n* fix more tests\n\n* fix generation test\n\n* fix beam search and init\n\n* modular changed\n\n* fix beam search in case of single-image/video. Fails if multiple visuals per text\n\n* update processor\n\n* update test\n\n* pass\n\n* fix beam search\n\n* update\n\n* param correct\n\n* Update convert_glm4v_mgt_weights_to_hf.py\n\n* 1\n\n* Update test_modeling_glm4v.py\n\n* 4\n\n* 2\n\n* 2123 video process\n\n* 2\n\n* revert\n\n* 1\n\n* 2\n\n* revert processing\n\n* update preprocesor\n\n* changed\n\n* 1\n\n* update\n\n* update\n\n* 6\n\n* update\n\n* update\n\n* update\n\n* Delete tmp.txt\n\n* config\n\n* Update video_processing_glm4v.py\n\n* apply modular correctly\n\n* move functions\n\n* fix order\n\n* update the longest_edge\n\n* style\n\n* simplify a lot\n\n* fix random order of classes\n\n* skip integration tests\n\n* correctly fix the tests\n\n* fix TP plan\n\n---------\n\nCo-authored-by: raushan <raushan@huggingface.co>\nCo-authored-by: Cyril Vallez <cyril.vallez@huggingface.co>\nCo-authored-by: Cyril Vallez <cyril.vallez@gmail.com>",
    "sha": "af9870265e817e57541d90c1797cb68959eb7b1e",
    "files": [
        {
            "sha": "1e6b01759ff546ada7b0fbe71d8ab0307fd1bfc8",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -955,6 +955,8 @@\n         title: Gemma3\n       - local: model_doc/git\n         title: GIT\n+      - local: model_doc/glm4v\n+        title: glm4v\n       - local: model_doc/got_ocr2\n         title: GOT-OCR2\n       - local: model_doc/granitevision"
        },
        {
            "sha": "d18a10e9b20bf4c68c81f8c698d846b13931cdef",
            "filename": "docs/source/en/model_doc/glm4v.md",
            "status": "added",
            "additions": 180,
            "deletions": 0,
            "changes": 180,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm4v.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm4v.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm4v.md?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -0,0 +1,180 @@\n+<!--Copyright 2025 The ZhipuAI Inc. and The HuggingFace Inc. team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+<div style=\"float: right;\">\n+    <div class=\"flex flex-wrap space-x-1\">\n+<img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+<img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+<img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">    </div>\n+</div>\n+\n+# GLM-4.1V\n+\n+The example below demonstrates how to generate text based on an image with [`Pipeline`] or the [`AutoModel`] class.\n+\n+<hfoptions id=\"usage\">\n+<hfoption id=\"Pipeline\">\n+\n+```py\n+import torch\n+from transformers import pipeline\n+pipe = pipeline(\n+    task=\"image-text-to-text\",\n+    model=\"THUDM/GLM-4.1V-9B-Thinking\",\n+    device=0,\n+    torch_dtype=torch.bfloat16\n+)\n+messages = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\n+                \"type\": \"image\",\n+                \"url\": \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/pipeline-cat-chonk.jpeg\",\n+            },\n+            { \"type\": \"text\", \"text\": \"Describe this image.\"},\n+        ]\n+    }\n+]\n+pipe(text=messages,max_new_tokens=20, return_full_text=False)\n+```\n+</hfoption>\n+<hfoption id=\"AutoModel\">\n+\n+```py\n+import torch\n+from transformers import Glm4vForConditionalGeneration, AutoProcessor\n+\n+model = Glm4vForConditionalGeneration.from_pretrained(\n+    \"THUDM/GLM-4.1V-9B-Thinking\",\n+    torch_dtype=torch.bfloat16,\n+    device_map=\"auto\",\n+    attn_implementation=\"sdpa\"\n+)\n+processor = AutoProcessor.from_pretrained(\"THUDM/GLM-4.1V-9B-Thinking\")\n+messages = [\n+    {\n+        \"role\":\"user\",\n+        \"content\":[\n+            {\n+                \"type\":\"image\",\n+                \"url\": \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/pipeline-cat-chonk.jpeg\"\n+            },\n+            {\n+                \"type\":\"text\",\n+                \"text\":\"Describe this image.\"\n+            }\n+        ]\n+    }\n+\n+]\n+\n+inputs = processor.apply_chat_template(\n+    messages,\n+    add_generation_prompt=True,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\"\n+).to(\"cuda\")\n+\n+generated_ids = model.generate(**inputs, max_new_tokens=128)\n+generated_ids_trimmed = [\n+            out_ids[len(in_ids) :] for in_ids, out_ids in zip(inputs.input_ids, generated_ids)\n+]\n+output_text = processor.batch_decode(\n+       generated_ids_trimmed, skip_special_tokens=True, clean_up_tokenization_spaces=False\n+)\n+print(output_text)\n+```\n+</hfoption>\n+</hfoptions>\n+\n+Using GLM-4.1V with video input is similar to using it with image input.\n+The model can process video data and generate text based on the content of the video.\n+\n+```python\n+from transformers import AutoProcessor, Glm4vForConditionalGeneration\n+import torch\n+\n+processor = AutoProcessor.from_pretrained(\"THUDM/GLM-4.1V-9B-Thinking\")\n+model = Glm4vForConditionalGeneration.from_pretrained(\n+    pretrained_model_name_or_path=\"THUDM/GLM-4.1V-9B-Thinking\",\n+    torch_dtype=torch.bfloat16,\n+    device_map=\"cuda:0\"\n+)\n+\n+messages = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\n+                \"type\": \"video\",\n+                \"url\": \"https://test-videos.co.uk/vids/bigbuckbunny/mp4/h264/720/Big_Buck_Bunny_720_10s_10MB.mp4\",\n+            },\n+            {\n+                \"type\": \"text\",\n+                \"text\": \"discribe this video\",\n+            },\n+        ],\n+    }\n+]\n+inputs = processor.apply_chat_template(messages, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\", padding=True).to(\"cuda:0\")\n+generated_ids = model.generate(**inputs, max_new_tokens=1024, do_sample=True, temperature=1.0)\n+output_text = processor.decode(generated_ids[0][inputs[\"input_ids\"].shape[1] :], skip_special_tokens=True)\n+print(output_text)\n+```\n+\n+## Glm4vConfig\n+\n+[[autodoc]] Glm4vConfig\n+\n+## Glm4vTextConfig\n+\n+[[autodoc]] Glm4vTextConfig\n+\n+## Glm4vImageProcessor\n+\n+[[autodoc]] Glm4vImageProcessor\n+    - preprocess\n+\n+## Glm4vVideoProcessor\n+\n+[[autodoc]] Glm4vVideoProcessor\n+    - preprocess\n+\n+## Glm4vImageProcessorFast\n+\n+[[autodoc]] Glm4vImageProcessorFast\n+    - preprocess\n+\n+## Glm4vProcessor\n+\n+[[autodoc]] Glm4vProcessor\n+\n+## Glm4vTextModel\n+\n+[[autodoc]] Glm4vTextModel\n+    - forward\n+\n+## Glm4vModel\n+\n+[[autodoc]] Glm4vModel\n+    - forward\n+\n+## Glm4vForConditionalGeneration\n+\n+[[autodoc]] Glm4vForConditionalGeneration\n+    - forward"
        },
        {
            "sha": "3812712bedf18f458a1279f2336303314a7210a3",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -141,6 +141,8 @@\n         (\"git\", \"GitConfig\"),\n         (\"glm\", \"GlmConfig\"),\n         (\"glm4\", \"Glm4Config\"),\n+        (\"glm4v\", \"Glm4vConfig\"),\n+        (\"glm4v_text\", \"Glm4vTextConfig\"),\n         (\"glpn\", \"GLPNConfig\"),\n         (\"got_ocr2\", \"GotOcr2Config\"),\n         (\"gpt-sw3\", \"GPT2Config\"),\n@@ -512,7 +514,9 @@\n         (\"gemma3_text\", \"Gemma3ForCausalLM\"),\n         (\"git\", \"GIT\"),\n         (\"glm\", \"GLM\"),\n-        (\"glm4\", \"glm4\"),\n+        (\"glm4\", \"GLM4\"),\n+        (\"glm4v\", \"GLM4V\"),\n+        (\"glm4v_text\", \"GLM4V\"),\n         (\"glpn\", \"GLPN\"),\n         (\"got_ocr2\", \"GOT-OCR2\"),\n         (\"gpt-sw3\", \"GPT-Sw3\"),\n@@ -827,6 +831,7 @@\n         (\"clip_text_model\", \"clip\"),\n         (\"aria_text\", \"aria\"),\n         (\"gemma3_text\", \"gemma3\"),\n+        (\"glm4v_text\", \"glm4v\"),\n         (\"idefics3_vision\", \"idefics3\"),\n         (\"siglip_vision_model\", \"siglip\"),\n         (\"smolvlm_vision\", \"smolvlm\"),"
        },
        {
            "sha": "b99dd365f57cc6ecbb20187b0e1c047742b95754",
            "filename": "src/transformers/models/auto/image_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -89,6 +89,7 @@\n             (\"fuyu\", (\"FuyuImageProcessor\",)),\n             (\"gemma3\", (\"Gemma3ImageProcessor\", \"Gemma3ImageProcessorFast\")),\n             (\"git\", (\"CLIPImageProcessor\", \"CLIPImageProcessorFast\")),\n+            (\"glm4v\", (\"Glm4vImageProcessor\", \"Glm4vImageProcessorFast\")),\n             (\"glpn\", (\"GLPNImageProcessor\",)),\n             (\"got_ocr2\", (\"GotOcr2ImageProcessor\", \"GotOcr2ImageProcessorFast\")),\n             (\"grounding-dino\", (\"GroundingDinoImageProcessor\", \"GroundingDinoImageProcessorFast\")),"
        },
        {
            "sha": "f2ccf21f58e8e088c1ddd84830e51006d37bd005",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -133,6 +133,8 @@\n         (\"git\", \"GitModel\"),\n         (\"glm\", \"GlmModel\"),\n         (\"glm4\", \"Glm4Model\"),\n+        (\"glm4v\", \"Glm4vModel\"),\n+        (\"glm4v_text\", \"Glm4vTextModel\"),\n         (\"glpn\", \"GLPNModel\"),\n         (\"got_ocr2\", \"GotOcr2Model\"),\n         (\"gpt-sw3\", \"GPT2Model\"),\n@@ -896,6 +898,7 @@\n         (\"fuyu\", \"FuyuForCausalLM\"),\n         (\"gemma3\", \"Gemma3ForConditionalGeneration\"),\n         (\"git\", \"GitForCausalLM\"),\n+        (\"glm4v\", \"Glm4vForConditionalGeneration\"),\n         (\"got_ocr2\", \"GotOcr2ForConditionalGeneration\"),\n         (\"idefics\", \"IdeficsForVisionText2Text\"),\n         (\"idefics2\", \"Idefics2ForConditionalGeneration\"),"
        },
        {
            "sha": "a6bd873b88f408a3b2c56462a4871fabbe72821b",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -66,6 +66,7 @@\n         (\"fuyu\", \"FuyuProcessor\"),\n         (\"gemma3\", \"Gemma3Processor\"),\n         (\"git\", \"GitProcessor\"),\n+        (\"glm4v\", \"Glm4vProcessor\"),\n         (\"got_ocr2\", \"GotOcr2Processor\"),\n         (\"granite_speech\", \"GraniteSpeechProcessor\"),\n         (\"grounding-dino\", \"GroundingDinoProcessor\"),"
        },
        {
            "sha": "4112d111e1ee2e8a9700db7f8002df1e7b252eeb",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -238,6 +238,7 @@\n         (\"git\", (\"BertTokenizer\", \"BertTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"glm\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"glm4\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n+        (\"glm4v\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"gpt-sw3\", (\"GPTSw3Tokenizer\" if is_sentencepiece_available() else None, None)),\n         (\"gpt2\", (\"GPT2Tokenizer\", \"GPT2TokenizerFast\" if is_tokenizers_available() else None)),\n         (\"gpt_bigcode\", (\"GPT2Tokenizer\", \"GPT2TokenizerFast\" if is_tokenizers_available() else None)),"
        },
        {
            "sha": "2bd2d86719b0cd9f2247ca0b969bdd6d42819619",
            "filename": "src/transformers/models/auto/video_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fauto%2Fvideo_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fauto%2Fvideo_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fvideo_processing_auto.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -46,6 +46,7 @@\n else:\n     VIDEO_PROCESSOR_MAPPING_NAMES = OrderedDict(\n         [\n+            (\"glm4v\", \"Glm4vVideoProcessor\"),\n             (\"instructblip\", \"InstructBlipVideoVideoProcessor\"),\n             (\"instructblipvideo\", \"InstructBlipVideoVideoProcessor\"),\n             (\"internvl\", \"InternVLVideoProcessor\"),"
        },
        {
            "sha": "4216c137fbe200d424bf9283b0da2f6e60c2817c",
            "filename": "src/transformers/models/glm4v/__init__.py",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2F__init__.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -0,0 +1,28 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_glm4v import *\n+    from .modeling_glm4v import *\n+    from .processing_glm4v import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "a644e8bdbcbbf3e1d0a6f5ddb7e785436496d983",
            "filename": "src/transformers/models/glm4v/configuration_glm4v.py",
            "status": "added",
            "additions": 354,
            "deletions": 0,
            "changes": 354,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconfiguration_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconfiguration_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconfiguration_glm4v.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -0,0 +1,354 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/glm4v/modular_glm4v.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_glm4v.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 The ZhipuAI Inc. team and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...modeling_rope_utils import rope_config_validation\n+\n+\n+class Glm4vVisionConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vVisionModel`]. It is used to instantiate an Glm4vVisionModel\n+    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield\n+    a similar configuration to that of\n+    GLM-4.1V-9B-Thinking [THUDM/GLM-4.1V-9B-Thinking](https://huggingface.co/THUDM/GLM-4.1V-9B-Thinking).\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 1536):\n+            Dimensionality of the encoder layers and the pooler layer.\n+        depth (`int`, *optional*, defaults to 24):\n+            Number of layers (depth) in the model.\n+        attention_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to add a bias to the queries, keys and values.\n+        intermediate_size (`int`, *optional*, defaults to 13696):\n+            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"selu\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+            `\"relu\"`, `\"selu\"` and `\"gelu_new\"` are supported.\n+        hidden_dropout_prob (`float`, *optional*, defaults to 0.0):\n+            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            Dropout probability for attention weights.\n+        projection_dropout (`float`, *optional*, defaults to 0.0):\n+            Dropout probability for the projection layer.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        image_size (`int` or `list[int]`, *optional*, defaults to `[336, 336]`):\n+            The size (resolution) of each image.\n+        patch_size (`int`, *optional*, defaults to `14`):\n+            The size (resolution) of each patch.\n+        num_channels (`int`, *optional*, defaults to 3):\n+            The number of input channels.\n+        out_hidden_size (`int`, *optional*, defaults to 4096):\n+            The output hidden size of the vision model.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        spatial_merge_size (`int`, *optional*, defaults to 2):\n+            The size used for merging spatial dimensions.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The size used for patches along the temporal dimension.\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Glm4vVisionConfig, Glm4vVisionModel\n+\n+    >>> # Initializing a Glm4vVisionConfig GLM-4.1V-9B style configuration\n+    >>> configuration = Glm4vVisionConfig()\n+\n+    >>> # Initializing a model (with random weights) from the GLM-4.1V-9B configuration\n+    >>> model = Glm4vVisionModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"glm4v\"\n+    base_config_key = \"vision_config\"\n+\n+    def __init__(\n+        self,\n+        depth=24,\n+        hidden_size=1536,\n+        hidden_act=\"silu\",\n+        attention_bias=False,\n+        attention_dropout=0.0,\n+        num_heads=12,\n+        in_channels=3,\n+        image_size=336,\n+        patch_size=14,\n+        rms_norm_eps=1e-05,\n+        spatial_merge_size=2,\n+        temporal_patch_size=1,\n+        out_hidden_size=4096,\n+        intermediate_size=13696,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.depth = depth\n+        self.hidden_size = hidden_size\n+        self.hidden_act = hidden_act\n+        self.num_heads = num_heads\n+        self.in_channels = in_channels\n+        self.image_size = image_size\n+        self.patch_size = patch_size\n+        self.spatial_merge_size = spatial_merge_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.out_hidden_size = out_hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+\n+\n+class Glm4vTextConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vModel`]. It is used to instantiate a\n+    GLM-4.1V model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of\n+    GLM-4.1V-9B-Thinking [THUDM/GLM-4.1V-9B-Thinking](https://huggingface.co/THUDM/GLM-4.1V-9B-Thinking).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 151552):\n+            Vocabulary size of the Glm4v model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Glm4vModel`]\n+        hidden_size (`int`, *optional*, defaults to 4096):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 13696):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 40):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 32):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 2):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `32`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 32768):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n+                    'llama3'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n+                    pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n+                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n+                    `factor` field to infer the suggested value.\n+        image_token_id (`int`, *optional*):\n+            Token index used as placeholder for image embeddings.\n+        video_token_id (`int`, *optional*):\n+            Token index used as placeholder for video embeddings.\n+\n+    ```python\n+    >>> from transformers import Glm4vTextModel, Glm4vConfig\n+\n+    >>> # Initializing a GLM-4.1V style configuration\n+    >>> configuration = Glm4vConfig()\n+\n+    >>> # Initializing a model from the GLM-4.1V style configuration\n+    >>> model = Glm4vTextModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"glm4v_text\"\n+    base_config_key = \"text_config\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    # Default tensor parallel plan for base model `Glm4v`\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_up_proj\": \"colwise_rep\",  # we need to replicate here due to the `chunk` operation\n+        \"layers.*.mlp.down_proj\": \"rowwise_rep\",  # we need to replicate here due to the `chunk` operation\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=151552,\n+        hidden_size=4096,\n+        intermediate_size=13696,\n+        num_hidden_layers=40,\n+        num_attention_heads=32,\n+        num_key_value_heads=2,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=32768,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-05,\n+        use_cache=True,\n+        tie_word_embeddings=False,\n+        rope_theta=10000.0,\n+        attention_dropout=0.0,\n+        rope_scaling=None,\n+        image_token_id=None,\n+        video_token_id=None,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.attention_dropout = attention_dropout\n+        self.rope_scaling = rope_scaling\n+\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, move it to 'rope_type'.\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self, ignore_keys={\"mrope_section\"})\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+\n+        super().__init__(tie_word_embeddings=tie_word_embeddings, **kwargs)\n+\n+\n+class Glm4vConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vModel`]. It is used to instantiate a\n+    GLM-4.1V model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of\n+    GLM-4.1V-9B-Thinking [THUDM/GLM-4.1V-9B-Thinking](https://huggingface.co/THUDM/GLM-4.1V-9B-Thinking).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        text_config (`Union[PreTrainedConfig, dict]`, *optional*, defaults to `Glm4vTextConfig`):\n+            The config object or dictionary of the text backbone.\n+        vision_config (`Union[PreTrainedConfig, dict]`,  *optional*, defaults to `Glm4vVisionConfig`):\n+            The config object or dictionary of the vision backbone.\n+        image_token_id (`int`, *optional*, defaults to 151343):\n+            The image token index to encode the image prompt.\n+        video_token_id (`int`, *optional*, defaults to 151344):\n+            The video token index to encode the image prompt.\n+        image_start_token_id (`int`, *optional*, defaults to 151339):\n+            The image start token index to encode the start of image.\n+        image_end_token_id (`int`, *optional*, defaults to 151340):\n+            The image end token index to encode the end of image.\n+        video_start_token_id (`int`, *optional*, defaults to 151341):\n+            The video start token index to encode the start of video.\n+        video_end_token_id (`int`, *optional*, defaults to 151342):\n+            The video end token index to encode the end of video.\n+\n+    ```python\n+    >>> from transformers import Glm4vForConditionalGeneration, Glm4vConfig\n+\n+    >>> # Initializing a GLM-4.1V style configuration\n+    >>> configuration = Glm4vConfig()\n+\n+    >>> # Initializing a model from the GLM-4.1V style configuration\n+    >>> model = Glm4vForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"glm4v\"\n+    sub_configs = {\"vision_config\": Glm4vVisionConfig, \"text_config\": Glm4vTextConfig}\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        text_config=None,\n+        vision_config=None,\n+        image_token_id=151343,\n+        video_token_id=151344,\n+        image_start_token_id=151339,\n+        image_end_token_id=151340,\n+        video_start_token_id=151341,\n+        video_end_token_id=151342,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        if isinstance(vision_config, dict):\n+            self.vision_config = self.sub_configs[\"vision_config\"](**vision_config)\n+        elif vision_config is None:\n+            self.vision_config = self.sub_configs[\"vision_config\"]()\n+\n+        if isinstance(text_config, dict):\n+            self.text_config = self.sub_configs[\"text_config\"](**text_config)\n+        elif text_config is None:\n+            # For BC use all kwargs to init `TextConfig`\n+            self.text_config = self.sub_configs[\"text_config\"](**kwargs)\n+\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.video_start_token_id = video_start_token_id\n+        self.video_end_token_id = video_end_token_id\n+        self.image_start_token_id = image_start_token_id\n+        self.image_end_token_id = image_end_token_id\n+\n+\n+__all__ = [\"Glm4vConfig\", \"Glm4vTextConfig\"]"
        },
        {
            "sha": "a1e09375dc11688c90b0bcf93b57d2b4a427f2d3",
            "filename": "src/transformers/models/glm4v/convert_glm4v_mgt_weights_to_hf.py",
            "status": "added",
            "additions": 645,
            "deletions": 0,
            "changes": 645,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconvert_glm4v_mgt_weights_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconvert_glm4v_mgt_weights_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconvert_glm4v_mgt_weights_to_hf.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -0,0 +1,645 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import argparse\n+import json\n+import os\n+import pickle\n+import re\n+from pathlib import Path\n+from typing import Callable, Optional\n+\n+import torch\n+from safetensors.torch import save_file\n+\n+\n+# Avoid Using Megatron Lib\n+class UnpicklerWrapper(pickle.Unpickler):\n+    def find_class(self, mod_name, name):\n+        class DummyClass:\n+            def __init__(self, *args, **kwargs):\n+                pass\n+\n+        if mod_name.startswith(\"megatron\") or mod_name.startswith(\"glm\") or mod_name.startswith(\"__main__\"):\n+            return DummyClass\n+        return super().find_class(mod_name, name)\n+\n+\n+pickle.Unpickler = UnpicklerWrapper\n+\n+\n+def dict_access_multi(a_dict, keys):\n+    if len(keys) == 0:\n+        return a_dict\n+    return dict_access_multi(a_dict[keys[0]], keys[1:])\n+\n+\n+def merge_qkv(\n+    sd_list,\n+    original_tp,\n+    num_attention_heads,\n+    multi_query_group_num,\n+    attention_dim,\n+    multi_query_attention,\n+    interleaved_qkv,\n+):\n+    if not multi_query_attention and interleaved_qkv:\n+        return torch.cat(sd_list, dim=0)\n+    q, k, v = [], [], []\n+    for sd in sd_list:\n+        if multi_query_attention:\n+            q_, k_, v_ = sd.split(\n+                [\n+                    num_attention_heads * attention_dim // original_tp,\n+                    multi_query_group_num * attention_dim // original_tp,\n+                    multi_query_group_num * attention_dim // original_tp,\n+                ],\n+                dim=0,\n+            )\n+        else:\n+            q_, k_, v_ = sd.chunk(dim=0, chunks=3)\n+        q.append(q_.clone())\n+        k.append(k_.clone())\n+        v.append(v_.clone())\n+    q = torch.cat(q, dim=0)\n+    k = torch.cat(k, dim=0)\n+    v = torch.cat(v, dim=0)\n+    if not interleaved_qkv:\n+        rotary_dim = attention_dim // 2\n+        half_rot = rotary_dim // 2\n+        perm_rot = torch.empty(rotary_dim, dtype=torch.long)\n+        perm_rot[0::2] = torch.arange(0, half_rot)\n+        perm_rot[1::2] = torch.arange(half_rot, rotary_dim)\n+        if q.dim() == 2:\n+            qh = q.view(num_attention_heads, attention_dim, -1)\n+            kh = k.view(multi_query_group_num, attention_dim, -1)\n+            qh[:, :rotary_dim, :] = qh[:, perm_rot, :]\n+            kh[:, :rotary_dim, :] = kh[:, perm_rot, :]\n+            q = qh.reshape(-1, q.size(-1))\n+            k = kh.reshape(-1, k.size(-1))\n+        else:\n+            qh = q.view(num_attention_heads, attention_dim)\n+            kh = k.view(multi_query_group_num, attention_dim)\n+            qh[:, :rotary_dim] = qh[:, perm_rot]\n+            kh[:, :rotary_dim] = kh[:, perm_rot]\n+            q = qh.reshape(-1)\n+            k = kh.reshape(-1)\n+    return q, k, v\n+\n+\n+def merge_glu(sd_list):\n+    return torch.cat(\n+        [sd.chunk(dim=0, chunks=2)[0].clone() for sd in sd_list]\n+        + [sd.chunk(dim=0, chunks=2)[1].clone() for sd in sd_list],\n+        dim=0,\n+    )\n+\n+\n+def merge_glu_vit(sd_list, original_tp=None):\n+    gate_proj = torch.cat([sd.chunk(dim=0, chunks=2)[0].clone() for sd in sd_list], dim=0)\n+    up_proj = torch.cat([sd.chunk(dim=0, chunks=2)[1].clone() for sd in sd_list], dim=0)\n+    return gate_proj, up_proj\n+\n+\n+def split_glu(sd, cnt, idx):\n+    return torch.cat(\n+        (\n+            sd.chunk(dim=0, chunks=2)[0].chunk(cnt, dim=0)[idx].clone(),\n+            sd.chunk(dim=0, chunks=2)[1].chunk(cnt, dim=0)[idx].clone(),\n+        ),\n+        dim=0,\n+    )\n+\n+\n+def merge_qkv_vit(sd_list, original_tp=None):\n+    q, k, v = [], [], []\n+    for sd in sd_list:\n+        q_, k_, v_ = sd.chunk(dim=0, chunks=3)\n+        q.append(q_.clone().contiguous())\n+        k.append(k_.clone().contiguous())\n+        v.append(v_.clone().contiguous())\n+    q = torch.cat(q, dim=0)\n+    k = torch.cat(k, dim=0)\n+    v = torch.cat(v, dim=0)\n+    combined = torch.cat([q, k, v], dim=0)\n+    return combined\n+\n+\n+def merge_tensors_vit(\n+    tp_sd: list[dict],\n+    keys: list[str],\n+    original_tp: int,\n+    target_tp: int,\n+    slice_dim: Optional[int] = None,\n+    merge_fn: Optional[Callable] = None,\n+):\n+    cnt = original_tp // target_tp\n+    sd_list = [dict_access_multi(tp_sd[i], keys) for i in range(cnt)]\n+    if slice_dim is not None:\n+        return torch.cat(sd_list, dim=slice_dim)\n+    assert merge_fn is not None\n+    return merge_fn(sd_list, original_tp)\n+\n+\n+def merge_tensors(\n+    tp_sd,\n+    keys,\n+    original_tp,\n+    target_tp,\n+    current_tp,\n+    slice_dim=None,\n+    merge_fn=None,\n+):\n+    cnt = original_tp // target_tp\n+    offset = cnt * current_tp\n+    sd_list = [dict_access_multi(tp_sd[i + offset], keys) for i in range(cnt)]\n+    if slice_dim is not None:\n+        return torch.cat(sd_list, dim=slice_dim)\n+    assert merge_fn is not None\n+    return merge_fn(sd_list)\n+\n+\n+def save_sharded_model(state_dict, output_path, max_shard_size_gb=5, num_layers=40, vision_num_layers=24):\n+    os.makedirs(output_path, exist_ok=True)\n+\n+    layered_dict = {}\n+    for layer_idx in range(num_layers):\n+        layer_key = f\"layer_{layer_idx}\"\n+        layered_dict[layer_key] = {}\n+\n+        for key, value in state_dict.items():\n+            if f\"model.language_model.layers.{layer_idx}.\" in key:\n+                layered_dict[layer_key][key] = value\n+\n+    for layer_idx in range(vision_num_layers):\n+        layer_key = f\"visual_layer_{layer_idx}\"\n+        layered_dict[layer_key] = {}\n+\n+        for key, value in state_dict.items():\n+            if f\"model.visual.blocks.{layer_idx}.\" in key:\n+                layered_dict[layer_key][key] = value\n+\n+    layered_dict[\"others\"] = {}\n+    for key, value in state_dict.items():\n+        if not any(f\"model.language_model.layers.{i}.\" in key for i in range(num_layers)) and not any(\n+            f\"model.visual.blocks.{i}.\" in key for i in range(vision_num_layers)\n+        ):\n+            layered_dict[\"others\"][key] = value\n+\n+    # Determine layer ordering\n+    layer_order = []\n+    for i in range(40):\n+        layer_order.append(f\"layer_{i}\")\n+    for i in range(24):\n+        layer_order.append(f\"visual_layer_{i}\")\n+    layer_order.append(\"others\")\n+\n+    # Calculate sizes and create shards by layer\n+    param_sizes = {}\n+    shards = []\n+    current_shard = {}\n+    current_shard_size = 0\n+    max_shard_size_bytes = max_shard_size_gb * 1024 * 1024 * 1024\n+\n+    for layer_key in layer_order:\n+        layer_weights = layered_dict[layer_key]\n+        layer_size = sum(param.numel() * param.element_size() for param in layer_weights.values())\n+        if current_shard_size + layer_size > max_shard_size_bytes and current_shard:\n+            shards.append(current_shard)\n+            current_shard = {}\n+            current_shard_size = 0\n+        for param_name, param in layer_weights.items():\n+            current_shard[param_name] = param\n+            current_shard_size += param.numel() * param.element_size()\n+            param_sizes[param_name] = param.numel() * param.element_size()\n+    if current_shard:\n+        shards.append(current_shard)\n+    index_dict = {\"metadata\": {\"total_size\": sum(param_sizes.values())}, \"weight_map\": {}}\n+\n+    for i, shard in enumerate(shards):\n+        shard_filename = f\"model-{i + 1:05d}-of-{len(shards):05d}.safetensors\"\n+        shard_path = os.path.join(output_path, shard_filename)\n+\n+        for param_name in shard.keys():\n+            index_dict[\"weight_map\"][param_name] = shard_filename\n+\n+        save_file(shard, shard_path, metadata={\"format\": \"pt\"})\n+        print(f\"Saved shard {i + 1}/{len(shards)}: {shard_filename}\")\n+        print(f\"  Shard size: {sum(p.numel() * p.element_size() for p in shard.values()) / (1024**3):.2f} GB\")\n+        print(f\"  Keys in shard: {len(shard)}\")\n+\n+    index_path = os.path.join(output_path, \"model.safetensors.index.json\")\n+    with open(index_path, \"w\") as f:\n+        json.dump(index_dict, f, indent=2)\n+\n+    return len(shards)\n+\n+\n+def merge_tp_weights(model_path, output_path, vllm_config_path=None):\n+    tp_size = 0\n+    for item in Path(model_path).iterdir():\n+        if item.is_dir():\n+            match = re.match(r\"mp_rank_(\\d{2})\", item.name)\n+            if match:\n+                tp = int(match.group(1))\n+                tp_size = max(tp_size, tp + 1)\n+\n+    print(f\"Detected tensor parallel degree TP={tp_size}\")\n+\n+    if tp_size <= 1:\n+        print(\"Model is already at TP=1, no need to merge\")\n+        return\n+\n+    print(f\"Loading vLLM configuration file: {vllm_config_path}\")\n+    with open(vllm_config_path, \"r\") as f:\n+        model_config = json.load(f)\n+        num_layers = model_config.get(\"num_layers\", 40)\n+        vision_num_layers = model_config.get(\"vision_config\", {}).get(\"num_hidden_layers\", 24)\n+        num_heads = model_config.get(\"num_attention_heads\", 32)\n+        num_kv_heads = model_config.get(\"num_query_groups\", 2)\n+        hidden_size = model_config.get(\"hidden_size\", 4096)\n+        head_dim = model_config.get(\"attention_dim\", hidden_size // num_heads)\n+\n+    print(\n+        f\"Model parameters: num_layers={num_layers}, vision_num_layers={vision_num_layers}, \"\n+        f\"num_heads={num_heads}, multi_query_group_num={num_kv_heads}, hidden_size={hidden_size}\"\n+    )\n+\n+    weights = []\n+    for tp_rank in range(tp_size):\n+        print(f\"Loading TP shard {tp_rank}...\")\n+        weight_path = Path(model_path) / f\"mp_rank_{tp_rank:02d}\" / \"model_optim_rng.pt\"\n+        sd = torch.load(weight_path, map_location=\"cpu\", pickle_module=pickle)\n+\n+        for k in list(sd.keys()):\n+            if \"_extra_state\" in k or \"dummy_parameter\" in k:\n+                sd.pop(k)\n+\n+        if \"model\" in sd:\n+            weights.append(sd[\"model\"])\n+        else:\n+            raise ValueError(f\"'model' key not found in {weight_path}\")\n+\n+    if not weights:\n+        raise ValueError(\"No valid weight files found\")\n+\n+    print(\"Merging tensor parallel weights...\")\n+    original_pp_enabled = os.path.exists(Path(model_path) / \"mp_rank_00_000\")\n+    original_tp, original_pp = tp_size, 1\n+    target_tp = 1\n+    print(f\"TP and PP INFO: original_tp: {original_tp}, original_pp:{original_pp}, target_tp: {target_tp}\")\n+    mgt_sd = [\n+        [\n+            torch.load(\n+                Path(model_path)\n+                / (f\"mp_rank_{j:02d}_{i:03d}\" if original_pp_enabled else f\"mp_rank_{j:02d}\")\n+                / \"model_optim_rng.pt\",\n+                map_location=\"cpu\",\n+                pickle_module=pickle,\n+            )\n+            for j in range(original_tp)\n+        ]\n+        for i in range(original_pp)\n+    ]\n+\n+    interleaved_qkv = False\n+    multi_query_attention = True\n+    num_attention_heads = num_heads\n+    multi_query_group_num = num_kv_heads\n+    attention_dim = head_dim\n+    complete_state_dict = {}\n+    keys = [\"model\"]\n+    rank = 0\n+\n+    # LLM\n+    for pp in range(original_pp):\n+        layer_i = 0\n+        mgt_encoder_tp_0 = dict_access_multi(mgt_sd[pp][rank], keys)\n+\n+        while f\"decoder.layers.{layer_i}.self_attention.linear_qkv.layer_norm_weight\" in mgt_encoder_tp_0:\n+            complete_state_dict.update(\n+                {\n+                    f\"model.language_model.layers.{layer_i}.input_layernorm.weight\": mgt_encoder_tp_0[\n+                        f\"decoder.layers.{layer_i}.self_attention.linear_qkv.layer_norm_weight\"\n+                    ],\n+                    f\"model.language_model.layers.{layer_i}.post_attention_layernorm.weight\": mgt_encoder_tp_0[\n+                        f\"decoder.layers.{layer_i}.mlp.linear_fc1.layer_norm_weight\"\n+                    ],\n+                    f\"model.language_model.layers.{layer_i}.post_self_attn_layernorm.weight\": mgt_encoder_tp_0[\n+                        f\"decoder.layers.{layer_i}.post_self_attn_layernorm.weight\"\n+                    ],\n+                    f\"model.language_model.layers.{layer_i}.post_mlp_layernorm.weight\": mgt_encoder_tp_0[\n+                        f\"decoder.layers.{layer_i}.post_mlp_layernorm.weight\"\n+                    ],\n+                }\n+            )\n+\n+            q, k, v = merge_tensors(\n+                tp_sd=mgt_sd[pp],\n+                keys=keys + [f\"decoder.layers.{layer_i}.self_attention.linear_qkv.weight\"],\n+                original_tp=original_tp,\n+                target_tp=target_tp,\n+                current_tp=0,\n+                merge_fn=lambda sd_list: merge_qkv(\n+                    sd_list,\n+                    original_tp,\n+                    num_attention_heads,\n+                    multi_query_group_num,\n+                    attention_dim,\n+                    multi_query_attention,\n+                    interleaved_qkv,\n+                ),\n+            )\n+\n+            complete_state_dict[f\"model.language_model.layers.{layer_i}.self_attn.q_proj.weight\"] = q.clone()\n+            complete_state_dict[f\"model.language_model.layers.{layer_i}.self_attn.k_proj.weight\"] = k.clone()\n+            complete_state_dict[f\"model.language_model.layers.{layer_i}.self_attn.v_proj.weight\"] = v.clone()\n+\n+            if f\"decoder.layers.{layer_i}.self_attention.linear_qkv.bias\" in mgt_encoder_tp_0:\n+                q_bias, k_bias, v_bias = merge_tensors(\n+                    tp_sd=mgt_sd[pp],\n+                    keys=keys + [f\"decoder.layers.{layer_i}.self_attention.linear_qkv.bias\"],\n+                    original_tp=original_tp,\n+                    target_tp=target_tp,\n+                    current_tp=0,\n+                    merge_fn=lambda sd_list: merge_qkv(\n+                        sd_list,\n+                        original_tp,\n+                        num_attention_heads,\n+                        multi_query_group_num,\n+                        attention_dim,\n+                        multi_query_attention,\n+                        interleaved_qkv,\n+                    ),\n+                )\n+                complete_state_dict[f\"model.language_model.layers.{layer_i}.self_attn.q_proj.bias\"] = q_bias.clone()\n+                complete_state_dict[f\"model.language_model.layers.{layer_i}.self_attn.k_proj.bias\"] = k_bias.clone()\n+                complete_state_dict[f\"model.language_model.layers.{layer_i}.self_attn.v_proj.bias\"] = v_bias.clone()\n+\n+            o_proj = merge_tensors(\n+                tp_sd=mgt_sd[pp],\n+                keys=keys + [f\"decoder.layers.{layer_i}.self_attention.linear_proj.weight\"],\n+                original_tp=original_tp,\n+                target_tp=target_tp,\n+                current_tp=0,\n+                slice_dim=1,\n+            )\n+            complete_state_dict[f\"model.language_model.layers.{layer_i}.self_attn.o_proj.weight\"] = o_proj.clone()\n+\n+            # MLP - Use gate_up_proj\n+            complete_state_dict[f\"model.language_model.layers.{layer_i}.mlp.gate_up_proj.weight\"] = merge_tensors(\n+                tp_sd=mgt_sd[pp],\n+                keys=keys + [f\"decoder.layers.{layer_i}.mlp.linear_fc1.weight\"],\n+                original_tp=original_tp,\n+                target_tp=target_tp,\n+                current_tp=0,\n+                merge_fn=merge_glu,\n+            ).clone()\n+            complete_state_dict[f\"model.language_model.layers.{layer_i}.mlp.down_proj.weight\"] = merge_tensors(\n+                tp_sd=mgt_sd[pp],\n+                keys=keys + [f\"decoder.layers.{layer_i}.mlp.linear_fc2.weight\"],\n+                original_tp=original_tp,\n+                target_tp=target_tp,\n+                current_tp=0,\n+                slice_dim=1,\n+            )\n+            layer_i += 1\n+\n+    # Embedd Model, LM Head, and Norm\n+    embed_tokens = merge_tensors(\n+        tp_sd=mgt_sd[0],\n+        keys=[\"model\", \"embedding.word_embeddings.weight\"],\n+        original_tp=original_tp,\n+        target_tp=target_tp,\n+        current_tp=0,\n+        slice_dim=0,\n+    )\n+    complete_state_dict[\"model.language_model.embed_tokens.weight\"] = embed_tokens.clone()\n+    lm_head = merge_tensors(\n+        tp_sd=mgt_sd[-1],\n+        keys=[\"model\", \"output_layer.weight\"],\n+        original_tp=original_tp,\n+        target_tp=target_tp,\n+        current_tp=0,\n+        slice_dim=0,\n+    )\n+    complete_state_dict[\"lm_head.weight\"] = lm_head.clone()\n+    complete_state_dict[\"model.language_model.norm.weight\"] = mgt_sd[-1][rank][\"model\"][\n+        \"decoder.final_layernorm.weight\"\n+    ].clone()\n+    mgt_encoder_tp_0 = dict_access_multi(mgt_sd[0][0], keys)\n+\n+    # VLM\n+    for layer_i in range(vision_num_layers):\n+        complete_state_dict[f\"model.visual.blocks.{layer_i}.norm1.weight\"] = mgt_encoder_tp_0[\n+            f\"vision_model.transformer.layers.{layer_i}.input_layernorm.weight\"\n+        ]\n+        complete_state_dict[f\"model.visual.blocks.{layer_i}.norm2.weight\"] = mgt_encoder_tp_0[\n+            f\"vision_model.transformer.layers.{layer_i}.pre_mlp_layernorm.weight\"\n+        ]\n+\n+        qkv_weight = merge_tensors_vit(\n+            tp_sd=mgt_sd[0],\n+            keys=keys + [f\"vision_model.transformer.layers.{layer_i}.self_attention.linear_qkv.weight\"],\n+            original_tp=original_tp,\n+            target_tp=target_tp,\n+            merge_fn=merge_qkv_vit,\n+        )\n+        complete_state_dict[f\"model.visual.blocks.{layer_i}.attn.qkv.weight\"] = qkv_weight.clone()\n+\n+        proj_weight = merge_tensors_vit(\n+            tp_sd=mgt_sd[0],\n+            keys=keys + [f\"vision_model.transformer.layers.{layer_i}.self_attention.linear_proj.weight\"],\n+            original_tp=original_tp,\n+            target_tp=target_tp,\n+            slice_dim=1,\n+        )\n+        complete_state_dict[f\"model.visual.blocks.{layer_i}.attn.proj.weight\"] = proj_weight.clone()\n+\n+        gate_proj_weight, up_proj_weight = merge_tensors_vit(\n+            tp_sd=mgt_sd[0],\n+            keys=keys + [f\"vision_model.transformer.layers.{layer_i}.mlp.linear_fc1.weight\"],\n+            original_tp=original_tp,\n+            target_tp=target_tp,\n+            merge_fn=lambda sd_list, original_tp: merge_glu_vit(sd_list, original_tp),\n+        )\n+        complete_state_dict[f\"model.visual.blocks.{layer_i}.mlp.gate_proj.weight\"] = gate_proj_weight.clone()\n+        complete_state_dict[f\"model.visual.blocks.{layer_i}.mlp.up_proj.weight\"] = up_proj_weight.clone()\n+\n+        down_proj_weight = merge_tensors_vit(\n+            tp_sd=mgt_sd[0],\n+            keys=keys + [f\"vision_model.transformer.layers.{layer_i}.mlp.linear_fc2.weight\"],\n+            original_tp=original_tp,\n+            target_tp=target_tp,\n+            slice_dim=1,\n+        )\n+        complete_state_dict[f\"model.visual.blocks.{layer_i}.mlp.down_proj.weight\"] = down_proj_weight.clone()\n+\n+    complete_state_dict[\"model.visual.downsample.weight\"] = (\n+        mgt_sd[0][0][\"model\"][\"vision_model.downsample.weight\"].clone().contiguous()\n+    )\n+    complete_state_dict[\"model.visual.downsample.bias\"] = (\n+        mgt_sd[0][0][\"model\"][\"vision_model.downsample.bias\"].clone().contiguous()\n+    )\n+\n+    # Merger\n+    gate_proj, up_proj = merge_tensors_vit(\n+        tp_sd=mgt_sd[0],\n+        keys=keys + [\"vision_projection.encoder.linear_fc1.weight\"],\n+        original_tp=original_tp,\n+        target_tp=target_tp,\n+        merge_fn=merge_glu_vit,\n+    )\n+\n+    down_proj = merge_tensors_vit(\n+        tp_sd=mgt_sd[0],\n+        keys=keys + [\"vision_projection.encoder.linear_fc2.weight\"],\n+        original_tp=original_tp,\n+        target_tp=target_tp,\n+        slice_dim=1,\n+    )\n+    proj = merge_tensors_vit(\n+        tp_sd=mgt_sd[0],\n+        keys=keys + [\"vision_projection.encoder.linear_fc_extra.weight\"],\n+        original_tp=original_tp,\n+        target_tp=target_tp,\n+        slice_dim=0,\n+    )\n+\n+    complete_state_dict[\"model.visual.merger.gate_proj.weight\"] = gate_proj.clone().contiguous()\n+    complete_state_dict[\"model.visual.merger.up_proj.weight\"] = up_proj.clone().contiguous()\n+    complete_state_dict[\"model.visual.merger.down_proj.weight\"] = down_proj.clone().contiguous()\n+    complete_state_dict[\"model.visual.merger.proj.weight\"] = proj.clone().contiguous()\n+\n+    complete_state_dict[\"model.visual.merger.post_projection_norm.weight\"] = (\n+        mgt_sd[0][0][\"model\"][\"vision_projection.encoder.layer_norm.weight\"].clone().contiguous()\n+    )\n+    complete_state_dict[\"model.visual.merger.post_projection_norm.bias\"] = (\n+        mgt_sd[0][0][\"model\"][\"vision_projection.encoder.layer_norm.bias\"].clone().contiguous()\n+    )\n+    complete_state_dict[\"model.visual.embeddings.position_embedding.weight\"] = (\n+        mgt_sd[0][0][\"model\"][\"vision_model.position_embeddings.weight\"].clone().contiguous()\n+    )\n+    complete_state_dict[\"model.visual.patch_embed.proj.weight\"] = (\n+        mgt_sd[0][0][\"model\"][\"vision_model.conv3d.weight\"].clone().contiguous()\n+    )\n+    complete_state_dict[\"model.visual.patch_embed.proj.bias\"] = (\n+        mgt_sd[0][0][\"model\"][\"vision_model.conv3d.bias\"].clone().contiguous()\n+    )\n+\n+    # Check for additional vision model norm layers mentioned in the expected output\n+    if \"vision_model.post_conv_layernorm.weight\" in mgt_encoder_tp_0:\n+        complete_state_dict[\"model.visual.post_conv_layernorm.weight\"] = (\n+            mgt_sd[0][0][\"model\"][\"vision_model.post_conv_layernorm.weight\"].clone().contiguous()\n+        )\n+\n+    if \"vision_model.post_layernorm.weight\" in mgt_encoder_tp_0:\n+        complete_state_dict[\"model.visual.post_layernorm.weight\"] = (\n+            mgt_sd[0][0][\"model\"][\"vision_model.post_layernorm.weight\"].clone().contiguous()\n+        )\n+\n+    print(f\"Total keys in state dict: {len(complete_state_dict)}\")\n+\n+    for key, value in complete_state_dict.items():\n+        if isinstance(value, torch.Tensor):\n+            complete_state_dict[key] = value.to(torch.bfloat16)\n+    print(\"Converted all tensors to bfloat16\")\n+    # Save Model weight\n+    save_sharded_model(\n+        complete_state_dict,\n+        output_path=output_path,\n+        max_shard_size_gb=5,\n+        num_layers=num_layers,\n+        vision_num_layers=vision_num_layers,\n+    )\n+\n+    hf_config = {\n+        \"architectures\": [\"Glm4vForConditionalGeneration\"],\n+        \"model_type\": \"glm4v\",\n+        \"attention_bias\": model_config.get(\"add_qkv_bias\", True),\n+        \"attention_dropout\": 0.0,\n+        \"pad_token_id\": model_config.get(\"pad_token_id\", 151329),\n+        \"eos_token_id\": model_config.get(\"eos_token_id\", [151329, 151336, 151338]),\n+        \"image_start_token_id\": model_config.get(\"image_start_token_id\", 151339),\n+        \"image_end_token_id\": model_config.get(\"image_end_token_id\", 151340),\n+        \"video_start_token_id\": model_config.get(\"video_start_token_id\", 151341),\n+        \"video_end_token_id\": model_config.get(\"video_end_token_id\", 151342),\n+        \"image_token_id\": model_config.get(\"image_token_id\", 151343),\n+        \"video_token_id\": model_config.get(\"video_token_id\", 151344),\n+        \"hidden_act\": model_config.get(\"hidden_act\", \"silu\"),\n+        \"hidden_size\": model_config.get(\"hidden_size\", 4096),\n+        \"initializer_range\": 0.02,\n+        \"intermediate_size\": model_config.get(\"ffn_hidden_size\", 13696),\n+        \"max_position_embeddings\": model_config.get(\"seq_length\", 32768),\n+        \"num_attention_heads\": model_config.get(\"num_attention_heads\", 32),\n+        \"num_hidden_layers\": model_config.get(\"num_layers\", 40),\n+        \"num_key_value_heads\": model_config.get(\"multi_query_group_num\", 2),\n+        \"rms_norm_eps\": model_config.get(\"layernorm_epsilon\", 1e-05),\n+        \"rope_theta\": model_config.get(\"rotary_base\", 10000.0),\n+        \"tie_word_embeddings\": False,\n+        \"torch_dtype\": model_config.get(\"torch_dtype\", \"bfloat16\"),\n+        \"transformers_version\": \"4.53.0dev\",\n+        \"use_cache\": model_config.get(\"use_cache\", True),\n+        \"vocab_size\": model_config.get(\"vocab_size\", 151552),\n+        \"partial_rotary_factor\": 0.5,\n+    }\n+\n+    if \"vision_config\" in model_config:\n+        vision_config = {\n+            \"hidden_size\": model_config[\"vision_config\"].get(\"hidden_size\", 1536),\n+            \"depth\": model_config[\"vision_config\"].get(\"num_layers\", 24),\n+            \"num_heads\": model_config[\"vision_config\"].get(\"num_attention_heads\", 12),\n+            \"attention_bias\": model_config[\"vision_config\"].get(\"attention_bias\", False),\n+            \"intermediate_size\": model_config.get(\"ffn_hidden_size\", 13696),\n+            \"hidden_act\": model_config[\"vision_config\"].get(\"hidden_act\", \"silu\"),\n+            \"hidden_dropout_prob\": model_config[\"vision_config\"].get(\"hidden_dropout_prob\", 0.0),\n+            \"initializer_range\": 0.02,\n+            \"image_size\": model_config[\"vision_config\"].get(\"image_size\", 336),\n+            \"patch_size\": model_config[\"vision_config\"].get(\"patch_size\", 14),\n+            \"out_hidden_size\": model_config.get(\"hidden_size\", 4096),\n+            \"rms_norm_eps\": model_config[\"vision_config\"].get(\"layernorm_epsilon\", 1e-05),\n+            \"spatial_merge_size\": model_config[\"vision_config\"].get(\"downsample_ratio\", 2),\n+            \"temporal_patch_size\": model_config[\"vision_config\"].get(\"t_patch\", 2),\n+        }\n+        hf_config[\"vision_config\"] = vision_config\n+\n+    if \"rope_scaling\" in model_config:\n+        hf_config[\"rope_scaling\"] = model_config[\"rope_scaling\"]\n+\n+    config_path = os.path.join(output_path, \"config.json\")\n+    with open(config_path, \"w\") as f:\n+        json.dump(hf_config, f, indent=2)\n+\n+    print(f\"Conversion complete! Model saved to {output_path}\")\n+\n+\n+def parse_args():\n+    parser = argparse.ArgumentParser(description=\"Convert Megatron model to HuggingFace format\")\n+    parser.add_argument(\n+        \"--model_path\",\n+        type=str,\n+        required=True,\n+        help=\"Path to Megatron model directory\",\n+    )\n+    parser.add_argument(\"--output_path\", type=str, required=True, help=\"Output path for HuggingFace model directory\")\n+    parser.add_argument(\n+        \"--config_path\", type=str, help=\"Path to vLLM configuration file for creating HuggingFace config\"\n+    )\n+    return parser.parse_args()\n+\n+\n+if __name__ == \"__main__\":\n+    args = parse_args()\n+    merge_tp_weights(args.model_path, args.output_path, args.config_path)"
        },
        {
            "sha": "bcb55ead4aa93748a40bb92be27f49018a15572b",
            "filename": "src/transformers/models/glm4v/image_processing_glm4v.py",
            "status": "added",
            "additions": 467,
            "deletions": 0,
            "changes": 467,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fimage_processing_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fimage_processing_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fimage_processing_glm4v.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -0,0 +1,467 @@\n+# coding=utf-8\n+# Copyright 2025 The ZhipuAI Inc. team and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Image processor class for GLM-4.1V.\"\"\"\n+\n+import math\n+from typing import Optional, Union\n+\n+import numpy as np\n+\n+from ...image_processing_utils import BaseImageProcessor, BatchFeature\n+from ...image_transforms import (\n+    convert_to_rgb,\n+    resize,\n+    to_channel_dimension_format,\n+)\n+from ...image_utils import (\n+    OPENAI_CLIP_MEAN,\n+    OPENAI_CLIP_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    is_scaled_image,\n+    make_flat_list_of_images,\n+    make_list_of_images,\n+    to_numpy_array,\n+    valid_images,\n+    validate_preprocess_arguments,\n+)\n+from ...utils import TensorType, logging\n+from ...video_utils import VideoInput\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+def smart_resize(\n+    num_frames: int,\n+    height: int,\n+    width: int,\n+    temporal_factor: int = 2,\n+    factor: int = 28,\n+    min_pixels: int = 112 * 112,\n+    max_pixels: int = 14 * 14 * 2 * 2 * 2 * 6144,\n+):\n+    if num_frames < temporal_factor:\n+        raise ValueError(f\"t:{num_frames} must be larger than temporal_factor:{temporal_factor}\")\n+    if height < factor or width < factor:\n+        raise ValueError(f\"height:{height} or width:{width} must be larger than factor:{factor}\")\n+    elif max(height, width) / min(height, width) > 200:\n+        raise ValueError(\n+            f\"absolute aspect ratio must be smaller than 200, got {max(height, width) / min(height, width)}\"\n+        )\n+    h_bar = round(height / factor) * factor\n+    w_bar = round(width / factor) * factor\n+    t_bar = round(num_frames / temporal_factor) * temporal_factor\n+\n+    if t_bar * h_bar * w_bar > max_pixels:\n+        beta = math.sqrt((num_frames * height * width) / max_pixels)\n+        h_bar = math.floor(height / beta / factor) * factor\n+        w_bar = math.floor(width / beta / factor) * factor\n+    elif t_bar * h_bar * w_bar < min_pixels:\n+        beta = math.sqrt(min_pixels / (num_frames * height * width))\n+        h_bar = math.ceil(height * beta / factor) * factor\n+        w_bar = math.ceil(width * beta / factor) * factor\n+\n+    return h_bar, w_bar\n+\n+\n+class Glm4vImageProcessor(BaseImageProcessor):\n+    r\"\"\"\n+    Constructs a GLM-4V image processor that dynamically resizes images based on the original images.\n+\n+    Args:\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image's (height, width) dimensions.\n+        size (`Dict[str, int]` *optional*, defaults to `{\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 15000}`):\n+            Size of the image's `(height, width)` dimensions after resizing. Can be overridden by the `size` parameter\n+            in the `preprocess` method. Available options are:\n+                - `{\"height\": int, \"width\": int}`: The image will be resized to the exact size `(height, width)`.\n+                    Do NOT keep the aspect ratio.\n+                - `{\"shortest_edge\": int, \"longest_edge\": int}`: The image will be resized to a maximum size respecting\n+                    the aspect ratio and keeping the shortest edge less or equal to `shortest_edge` and the longest edge\n+                    less or equal to `longest_edge`.\n+                - `{\"max_height\": int, \"max_width\": int}`: The image will be resized to the maximum size respecting the\n+                    aspect ratio and keeping the height less or equal to `max_height` and the width less or equal to\n+                    `max_width`.\n+        resample (`PILImageResampling`, *optional*, defaults to `Resampling.BICUBIC`):\n+            Resampling filter to use when resizing the image.\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image by the specified scale `rescale_factor`.\n+        rescale_factor (`int` or `float`, *optional*, defaults to `1/255`):\n+            Scale factor to use if rescaling the image.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image.\n+        image_mean (`float` or `List[float]`, *optional*, defaults to `[0.48145466, 0.4578275, 0.40821073]`):\n+            Mean to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        image_std (`float` or `List[float]`, *optional*, defaults to `[0.26862954, 0.26130258, 0.27577711]`):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spatial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The temporal patch size of the vision encoder.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    model_input_names = [\"pixel_values\", \"image_grid_thw\"]\n+\n+    def __init__(\n+        self,\n+        do_resize: bool = True,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = PILImageResampling.BICUBIC,\n+        do_rescale: bool = True,\n+        rescale_factor: Union[int, float] = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        do_convert_rgb: bool = True,\n+        patch_size: int = 14,\n+        temporal_patch_size: int = 2,\n+        merge_size: int = 2,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+        else:\n+            size = {\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 15000}\n+        self.size = size\n+\n+        self.do_resize = do_resize\n+        self.resample = resample\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean if image_mean is not None else OPENAI_CLIP_MEAN\n+        self.image_std = image_std if image_std is not None else OPENAI_CLIP_STD\n+\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.merge_size = merge_size\n+        self.do_convert_rgb = do_convert_rgb\n+\n+    def _preprocess(\n+        self,\n+        images: Union[ImageInput, VideoInput],\n+        do_resize: Optional[bool] = None,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = None,\n+        do_rescale: Optional[bool] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        do_convert_rgb: Optional[bool] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n+\n+        Args:\n+            images (`ImageInput`):\n+                Image or batch of images to preprocess. Expects pixel values ranging from 0 to 255. If pixel values range from 0 to 1, set `do_rescale=False`.\n+            vision_info (`List[Dict]`, *optional*):\n+                Optional list of dictionaries containing additional information about vision inputs.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. `shortest_edge` and `longest_edge` keys must be present.\n+            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the `PILImageResampling` enums.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Scale factor to use if rescaling the image.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Mean to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Standard deviation to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            patch_size (`int`, *optional*, defaults to `self.patch_size`):\n+                The spatial patch size of the vision encoder.\n+            temporal_patch_size (`int`, *optional*, defaults to `self.temporal_patch_size`):\n+                The temporal patch size of the vision encoder.\n+            merge_size (`int`, *optional*, defaults to `self.merge_size`):\n+                The merge size of the vision encoder to llm encoder.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            data_format (`ChannelDimension`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.   - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+        images = make_list_of_images(images)\n+\n+        if do_convert_rgb:\n+            images = [convert_to_rgb(image) for image in images]\n+\n+        # All transformations expect numpy arrays.\n+        images = [to_numpy_array(image) for image in images]\n+\n+        if do_rescale and is_scaled_image(images[0]):\n+            logger.warning_once(\n+                \"It looks like you are trying to rescale already rescaled images. If the input\"\n+                \" images have pixel values between 0 and 1, set `do_rescale=False` to avoid rescaling them again.\"\n+            )\n+        if input_data_format is None:\n+            # We assume that all images have the same channel dimension format.\n+            input_data_format = infer_channel_dimension_format(images[0])\n+\n+        height, width = get_image_size(images[0], channel_dim=input_data_format)\n+        resized_height, resized_width = height, width\n+        processed_images = []\n+        for image in images:\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    num_frames=temporal_patch_size,\n+                    height=height,\n+                    width=width,\n+                    temporal_factor=temporal_patch_size,\n+                    factor=patch_size * merge_size,\n+                )\n+                image = resize(\n+                    image, size=(resized_height, resized_width), resample=resample, input_data_format=input_data_format\n+                )\n+\n+            if do_rescale:\n+                image = self.rescale(image, scale=rescale_factor, input_data_format=input_data_format)\n+\n+            if do_normalize:\n+                image = self.normalize(\n+                    image=image, mean=image_mean, std=image_std, input_data_format=input_data_format\n+                )\n+\n+            image = to_channel_dimension_format(image, data_format, input_channel_dim=input_data_format)\n+            processed_images.append(image)\n+\n+        patches = np.array(processed_images)\n+        if data_format == ChannelDimension.LAST:\n+            patches = patches.transpose(0, 3, 1, 2)\n+        if patches.shape[0] % temporal_patch_size != 0:\n+            repeats = np.repeat(\n+                patches[-1][np.newaxis], temporal_patch_size - (patches.shape[0] % temporal_patch_size), axis=0\n+            )\n+            patches = np.concatenate([patches, repeats], axis=0)\n+        channel = patches.shape[1]\n+        grid_t = patches.shape[0] // temporal_patch_size\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+        patches = patches.reshape(\n+            grid_t,\n+            temporal_patch_size,\n+            channel,\n+            grid_h // merge_size,\n+            merge_size,\n+            patch_size,\n+            grid_w // merge_size,\n+            merge_size,\n+            patch_size,\n+        )\n+        patches = patches.transpose(0, 3, 6, 4, 7, 2, 1, 5, 8)\n+        flatten_patches = patches.reshape(\n+            grid_t * grid_h * grid_w, channel * temporal_patch_size * patch_size * patch_size\n+        )\n+\n+        return flatten_patches, (grid_t, grid_h, grid_w)\n+\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        videos: VideoInput = None,\n+        do_resize: Optional[bool] = None,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = None,\n+        do_rescale: Optional[bool] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        do_convert_rgb: Optional[bool] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Args:\n+            images (`ImageInput`):\n+                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n+                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n+            videos (`VideoInput`):\n+                Video to preprocess. Expects a single or batch of videos with pixel values ranging from 0 to 255. If\n+                passing in videos with pixel values between 0 and 1, set `do_rescale=False`.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n+                the longest edge resized to keep the input aspect ratio.\n+            resample (`int`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n+                has an effect if `do_resize` is set to `True`.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n+                `True`.\n+                The max pixels of the image to resize the image.\n+            patch_size (`int`, *optional*, defaults to `self.patch_size`):\n+                The spatial patch size of the vision encoder.\n+            temporal_patch_size (`int`, *optional*, defaults to `self.temporal_patch_size`):\n+                The temporal patch size of the vision encoder.\n+            merge_size (`int`, *optional*, defaults to `self.merge_size`):\n+                The merge size of the vision encoder to llm encoder.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                - Unset: Return a list of `np.ndarray`.\n+                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n+                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n+            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n+                from the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+\n+        \"\"\"\n+\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+        else:\n+            size = {\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 15000}\n+\n+        do_resize = do_resize if do_resize is not None else self.do_resize\n+\n+        resample = resample if resample is not None else self.resample\n+        do_rescale = do_rescale if do_rescale is not None else self.do_rescale\n+        rescale_factor = rescale_factor if rescale_factor is not None else self.rescale_factor\n+        do_normalize = do_normalize if do_normalize is not None else self.do_normalize\n+        image_mean = image_mean if image_mean is not None else self.image_mean\n+        image_std = image_std if image_std is not None else self.image_std\n+        patch_size = patch_size if patch_size is not None else self.patch_size\n+        temporal_patch_size = temporal_patch_size if temporal_patch_size is not None else self.temporal_patch_size\n+        merge_size = merge_size if merge_size is not None else self.merge_size\n+        do_convert_rgb = do_convert_rgb if do_convert_rgb is not None else self.do_convert_rgb\n+\n+        if images is not None:\n+            images = make_flat_list_of_images(images)\n+\n+        if images is not None and not valid_images(images):\n+            raise ValueError(\n+                \"Invalid image type. Must be of type PIL.Image.Image, numpy.ndarray, \"\n+                \"torch.Tensor, tf.Tensor or jax.ndarray.\"\n+            )\n+\n+        validate_preprocess_arguments(\n+            rescale_factor=rescale_factor,\n+            do_normalize=do_normalize,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            do_resize=do_resize,\n+            size=size,\n+            resample=resample,\n+        )\n+\n+        data = {}\n+        if images is not None:\n+            pixel_values, vision_grid_thws = [], []\n+            for image in images:\n+                patches, image_grid_thw = self._preprocess(\n+                    image,\n+                    do_resize=do_resize,\n+                    size=size,\n+                    resample=resample,\n+                    do_rescale=do_rescale,\n+                    rescale_factor=rescale_factor,\n+                    do_normalize=do_normalize,\n+                    image_mean=image_mean,\n+                    image_std=image_std,\n+                    patch_size=patch_size,\n+                    temporal_patch_size=temporal_patch_size,\n+                    merge_size=merge_size,\n+                    data_format=data_format,\n+                    do_convert_rgb=do_convert_rgb,\n+                    input_data_format=input_data_format,\n+                )\n+                pixel_values.extend(patches)\n+                vision_grid_thws.append(image_grid_thw)\n+            pixel_values = np.array(pixel_values)\n+            vision_grid_thws = np.array(vision_grid_thws)\n+            data.update({\"pixel_values\": pixel_values, \"image_grid_thw\": vision_grid_thws})\n+\n+        return BatchFeature(data=data, tensor_type=return_tensors)\n+\n+    def get_number_of_image_patches(self, height: int, width: int, images_kwargs=None):\n+        \"\"\"\n+        A utility that returns number of image patches for a given image size.\n+\n+        Args:\n+            height (`int`):\n+                Height of the input image.\n+            width (`int`):\n+                Width of the input image.\n+            images_kwargs (`dict`, *optional*)\n+                Any kwargs to override defaults of the image processor.\n+        Returns:\n+            `int`: Number of image patches per image.\n+        \"\"\"\n+        patch_size = images_kwargs.get(\"patch_size\", None) or self.patch_size\n+        merge_size = images_kwargs.get(\"merge_size\", None) or self.merge_size\n+\n+        factor = patch_size * merge_size\n+        resized_height, resized_width = smart_resize(\n+            t=self.temporal_patch_size,\n+            height=height,\n+            width=width,\n+            factor=factor,\n+            t_factor=self.temporal_patch_size,\n+        )\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+        return grid_h * grid_w\n+\n+\n+__all__ = [\"Glm4vImageProcessor\"]"
        },
        {
            "sha": "1f3a76e3c4ff426679a0c244bfbb3460f3e1f825",
            "filename": "src/transformers/models/glm4v/image_processing_glm4v_fast.py",
            "status": "added",
            "additions": 364,
            "deletions": 0,
            "changes": 364,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fimage_processing_glm4v_fast.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fimage_processing_glm4v_fast.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fimage_processing_glm4v_fast.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -0,0 +1,364 @@\n+# coding=utf-8\n+# Copyright 2025 The ZhipuAI Inc. team and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Fast Image processor class for GLM-4.1V.\"\"\"\n+\n+from typing import Optional, Union\n+\n+from ...image_processing_utils import (\n+    BatchFeature,\n+)\n+from ...image_processing_utils_fast import (\n+    BaseImageProcessorFast,\n+    DefaultFastImageProcessorKwargs,\n+    group_images_by_shape,\n+    reorder_images,\n+)\n+from ...image_utils import (\n+    OPENAI_CLIP_MEAN,\n+    OPENAI_CLIP_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    SizeDict,\n+    get_image_size,\n+    make_flat_list_of_images,\n+    valid_images,\n+)\n+from ...processing_utils import Unpack\n+from ...utils import (\n+    TensorType,\n+    auto_docstring,\n+    is_torch_available,\n+    is_torchvision_available,\n+    is_torchvision_v2_available,\n+    logging,\n+)\n+from ...video_utils import VideoInput\n+from .image_processing_glm4v import smart_resize\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+if is_torchvision_available():\n+    from ...image_utils import pil_torch_interpolation_mapping\n+\n+    if is_torchvision_v2_available():\n+        from torchvision.transforms.v2 import functional as F\n+    else:\n+        from torchvision.transforms import functional as F\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Glm4vFastImageProcessorKwargs(DefaultFastImageProcessorKwargs):\n+    \"\"\"\n+    patch_size (`int`, *optional*, defaults to 14):\n+        The spatial patch size of the vision encoder.\n+    temporal_patch_size (`int`, *optional*, defaults to 2):\n+        The temporal patch size of the vision encoder.\n+    merge_size (`int`, *optional*, defaults to 2):\n+        The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    patch_size: Optional[int]\n+    temporal_patch_size: Optional[int]\n+    merge_size: Optional[int]\n+\n+\n+@auto_docstring\n+class Glm4vImageProcessorFast(BaseImageProcessorFast):\n+    do_resize = True\n+    resample = PILImageResampling.BICUBIC\n+    size = {\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 15000}\n+    do_rescale = True\n+    do_normalize = True\n+    image_mean = OPENAI_CLIP_MEAN\n+    image_std = OPENAI_CLIP_STD\n+    do_convert_rgb = True\n+    patch_size = 14\n+    temporal_patch_size = 2\n+    merge_size = 2\n+    valid_kwargs = Glm4vFastImageProcessorKwargs\n+    model_input_names = [\"pixel_values\", \"image_grid_thw\"]\n+\n+    def __init__(self, **kwargs: Unpack[Glm4vFastImageProcessorKwargs]):\n+        size = kwargs.pop(\"size\", None)\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+        else:\n+            size = self.size\n+\n+        super().__init__(size=size, **kwargs)\n+\n+    def _preprocess(\n+        self,\n+        images: list[\"torch.Tensor\"],\n+        do_resize: bool,\n+        size: SizeDict,\n+        interpolation: Optional[\"F.InterpolationMode\"],\n+        do_rescale: bool,\n+        rescale_factor: float,\n+        do_normalize: bool,\n+        image_mean: Optional[Union[float, list[float]]],\n+        image_std: Optional[Union[float, list[float]]],\n+        patch_size: int,\n+        temporal_patch_size: int,\n+        merge_size: int,\n+        do_convert_rgb: bool,\n+        input_data_format: Optional[Union[str, ChannelDimension]],\n+        device: Optional[Union[str, torch.device]],\n+    ):\n+        \"\"\"\n+        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n+\n+        Args:\n+            images (`ImageInput`):\n+                Image or batch of images to preprocess. Expects pixel values ranging from 0 to 255. If pixel values range from 0 to 1, set `do_rescale=False`.\n+            vision_info (`List[Dict]`, *optional*):\n+                Optional list of dictionaries containing additional information about vision inputs.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. `shortest_edge` and `longest_edge` keys must be present.\n+            interpolation (`InterpolationMode`):\n+                Resampling filter to use if resizing the image.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Scale factor to use if rescaling the image.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Mean to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Standard deviation to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            patch_size (`int`, *optional*, defaults to `self.patch_size`):\n+                The spatial patch size of the vision encoder.\n+            temporal_patch_size (`int`, *optional*, defaults to `self.temporal_patch_size`):\n+                The temporal patch size of the vision encoder.\n+            merge_size (`int`, *optional*, defaults to `self.merge_size`):\n+                The merge size of the vision encoder to llm encoder.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.   - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+            device (`torch.device`, *optional*):\n+                The device to process the images on. If unset, the device is inferred from the input images.\n+        \"\"\"\n+        images = self._prepare_input_images(\n+            images=images,\n+            do_convert_rgb=do_convert_rgb,\n+            input_data_format=input_data_format,\n+            device=device,\n+        )\n+\n+        height, width = get_image_size(images[0], channel_dim=ChannelDimension.FIRST)\n+        resized_height, resized_width = height, width\n+\n+        # Group images by size for batched resizing\n+        grouped_images, grouped_images_index = group_images_by_shape(images)\n+        resized_images_grouped = {}\n+        for shape, stacked_images in grouped_images.items():\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    num_frames=temporal_patch_size,\n+                    height=height,\n+                    width=width,\n+                    temporal_factor=temporal_patch_size,\n+                    factor=patch_size * merge_size,\n+                )\n+                stacked_images = F.resize(\n+                    stacked_images, size=(resized_height, resized_width), interpolation=interpolation\n+                )\n+            resized_images_grouped[shape] = stacked_images\n+        resized_images = reorder_images(resized_images_grouped, grouped_images_index)\n+        # Group images by size for further processing\n+        # Needed in case do_resize is False, or resize returns images with different sizes\n+        grouped_images, grouped_images_index = group_images_by_shape(resized_images)\n+        processed_images_grouped = {}\n+        for shape, stacked_images in grouped_images.items():\n+            # Fused rescale and normalize\n+            stacked_images = self.rescale_and_normalize(\n+                stacked_images, do_rescale, rescale_factor, do_normalize, image_mean, image_std\n+            )\n+            processed_images_grouped[shape] = stacked_images\n+\n+        processed_images = reorder_images(processed_images_grouped, grouped_images_index)\n+        patches = torch.stack(processed_images, dim=0)\n+        if patches.shape[0] % temporal_patch_size != 0:\n+            repeats = patches[-1].unsqueeze(0).repeat(temporal_patch_size - 1, 1, 1, 1)\n+            patches = torch.cat([patches, repeats], dim=0)\n+\n+        channel = patches.shape[1]\n+        grid_t = patches.shape[0] // temporal_patch_size\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+\n+        patches = patches.view(\n+            grid_t,\n+            temporal_patch_size,\n+            channel,\n+            grid_h // merge_size,\n+            merge_size,\n+            patch_size,\n+            grid_w // merge_size,\n+            merge_size,\n+            patch_size,\n+        )\n+        patches = patches.permute(0, 3, 6, 4, 7, 2, 1, 5, 8)\n+        flatten_patches = patches.reshape(\n+            grid_t * grid_h * grid_w, channel * temporal_patch_size * patch_size * patch_size\n+        )\n+\n+        return flatten_patches, (grid_t, grid_h, grid_w)\n+\n+    @auto_docstring\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        videos: VideoInput = None,\n+        do_resize: Optional[bool] = None,\n+        size: Optional[dict[str, int]] = None,\n+        resample: Optional[Union[\"PILImageResampling\", \"F.InterpolationMode\"]] = None,\n+        do_rescale: Optional[bool] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        do_convert_rgb: Optional[bool] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+        device: Optional[\"torch.device\"] = None,\n+        **kwargs,\n+    ):\n+        r\"\"\"\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spatial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The temporal patch size of the vision encoder.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+        \"\"\"\n+\n+        do_resize = do_resize if do_resize is not None else self.do_resize\n+        size = size if size is not None else self.size\n+        resample = resample if resample is not None else self.resample\n+        do_rescale = do_rescale if do_rescale is not None else self.do_rescale\n+        rescale_factor = rescale_factor if rescale_factor is not None else self.rescale_factor\n+        do_normalize = do_normalize if do_normalize is not None else self.do_normalize\n+        image_mean = image_mean if image_mean is not None else self.image_mean\n+        image_std = image_std if image_std is not None else self.image_std\n+        patch_size = patch_size if patch_size is not None else self.patch_size\n+        temporal_patch_size = temporal_patch_size if temporal_patch_size is not None else self.temporal_patch_size\n+        merge_size = merge_size if merge_size is not None else self.merge_size\n+        do_convert_rgb = do_convert_rgb if do_convert_rgb is not None else self.do_convert_rgb\n+\n+        # Make hashable for cache\n+        size = SizeDict(**size) if size is not None else None\n+        image_mean = tuple(image_mean) if image_mean is not None else None\n+        image_std = tuple(image_std) if image_std is not None else None\n+\n+        self._validate_preprocess_kwargs(\n+            do_rescale=do_rescale,\n+            rescale_factor=rescale_factor,\n+            do_normalize=do_normalize,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            do_resize=do_resize,\n+            size=size,\n+            resample=resample,\n+            return_tensors=return_tensors,\n+            data_format=data_format,\n+        )\n+        interpolation = (\n+            pil_torch_interpolation_mapping[resample] if isinstance(resample, (PILImageResampling, int)) else resample\n+        )\n+\n+        if images is not None:\n+            images = make_flat_list_of_images(images)\n+\n+        if images is not None and not valid_images(images):\n+            raise ValueError(\n+                \"Invalid image type. Must be of type PIL.Image.Image, numpy.ndarray, \"\n+                \"torch.Tensor, tf.Tensor or jax.ndarray.\"\n+            )\n+\n+        data = {}\n+        if images is not None:\n+            pixel_values, vision_grid_thws = [], []\n+            for image in images:\n+                patches, image_grid_thw = self._preprocess(\n+                    image,\n+                    do_resize=do_resize,\n+                    size=size,\n+                    interpolation=interpolation,\n+                    do_rescale=do_rescale,\n+                    rescale_factor=rescale_factor,\n+                    do_normalize=do_normalize,\n+                    image_mean=image_mean,\n+                    image_std=image_std,\n+                    patch_size=patch_size,\n+                    temporal_patch_size=temporal_patch_size,\n+                    merge_size=merge_size,\n+                    do_convert_rgb=do_convert_rgb,\n+                    input_data_format=input_data_format,\n+                    device=device,\n+                )\n+                pixel_values.extend(patches)\n+                vision_grid_thws.append(image_grid_thw)\n+            pixel_values = torch.stack(pixel_values)\n+            vision_grid_thws = torch.tensor(vision_grid_thws)\n+            data.update({\"pixel_values\": pixel_values, \"image_grid_thw\": vision_grid_thws})\n+\n+        return BatchFeature(data=data, tensor_type=return_tensors)\n+\n+    def get_number_of_image_patches(self, height: int, width: int, images_kwargs=None):\n+        \"\"\"\n+        A utility that returns number of image patches for a given image size.\n+\n+        Args:\n+            height (`int`):\n+                Height of the input image.\n+            width (`int`):\n+                Width of the input image.\n+            images_kwargs (`dict`, *optional*)\n+                Any kwargs to override defaults of the image processor.\n+        Returns:\n+            `int`: Number of image patches per image.\n+        \"\"\"\n+        patch_size = images_kwargs.get(\"patch_size\", None) or self.patch_size\n+        merge_size = images_kwargs.get(\"merge_size\", None) or self.merge_size\n+\n+        factor = patch_size * merge_size\n+        resized_height, resized_width = smart_resize(\n+            t=self.temporal_patch_size,\n+            height=height,\n+            width=width,\n+            factor=factor,\n+            t_factor=self.temporal_patch_size,\n+        )\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+        return grid_h * grid_w\n+\n+\n+__all__ = [\"Glm4vImageProcessorFast\"]"
        },
        {
            "sha": "91f4e1351c3e305ef482e2776015a9d7e4d61138",
            "filename": "src/transformers/models/glm4v/modeling_glm4v.py",
            "status": "added",
            "additions": 1667,
            "deletions": 0,
            "changes": 1667,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodeling_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodeling_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodeling_glm4v.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -0,0 +1,1667 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/glm4v/modular_glm4v.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_glm4v.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 The ZhipuAI Inc. team and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import itertools\n+from dataclasses import dataclass\n+from typing import Any, Callable, Optional, Union\n+\n+import torch\n+import torch.nn as nn\n+import torch.nn.functional as F\n+from torch.nn import LayerNorm\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...integrations import use_kernel_forward_from_hub\n+from ...masking_utils import create_causal_mask\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import BaseModelOutputWithPast, ModelOutput\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS, dynamic_rope_update\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import LossKwargs, auto_docstring, can_return_tuple, is_torchdynamo_compiling, logging\n+from .configuration_glm4v import Glm4vConfig, Glm4vTextConfig, Glm4vVisionConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+@use_kernel_forward_from_hub(\"RMSNorm\")\n+class Glm4vRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        Glm4vRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class Glm4VisionMlp(nn.Module):\n+    def __init__(self, config, bias: bool = False):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.out_hidden_size\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=bias)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=bias)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=bias)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, hidden_state):\n+        return self.down_proj(self.act_fn(self.gate_proj(hidden_state)) * self.up_proj(hidden_state))\n+\n+\n+class Glm4vVisionPatchEmbed(nn.Module):\n+    def __init__(self, config: Glm4vVisionConfig) -> None:\n+        super().__init__()\n+        self.patch_size = config.patch_size\n+        self.temporal_patch_size = config.temporal_patch_size\n+        self.in_channels = config.in_channels\n+        self.embed_dim = config.hidden_size\n+\n+        kernel_size = [self.temporal_patch_size, self.patch_size, self.patch_size]\n+        self.proj = nn.Conv3d(self.in_channels, self.embed_dim, kernel_size=kernel_size, stride=kernel_size)\n+\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        target_dtype = self.proj.weight.dtype\n+        hidden_states = hidden_states.view(\n+            -1, self.in_channels, self.temporal_patch_size, self.patch_size, self.patch_size\n+        )\n+        hidden_states = self.proj(hidden_states.to(dtype=target_dtype)).view(-1, self.embed_dim)\n+        return hidden_states\n+\n+\n+class Glm4vVisionRotaryEmbedding(nn.Module):\n+    def __init__(self, dim: int, theta: float = 10000.0) -> None:\n+        super().__init__()\n+        inv_freq = 1.0 / (theta ** (torch.arange(0, dim, 2, dtype=torch.float) / dim))\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+\n+    def forward(self, seqlen: int) -> torch.Tensor:\n+        seq = torch.arange(seqlen, device=self.inv_freq.device, dtype=self.inv_freq.dtype)\n+        freqs = torch.outer(seq, self.inv_freq)\n+        return freqs\n+\n+\n+class Glm4vVisionPatchMerger(nn.Module):\n+    def __init__(self, dim: int, context_dim: int, hidden_act: str, bias: bool = False) -> None:\n+        super().__init__()\n+        self.proj = nn.Linear(dim, dim, bias=bias)\n+        self.post_projection_norm = LayerNorm(dim)\n+        self.gate_proj = nn.Linear(dim, context_dim, bias=bias)\n+        self.up_proj = nn.Linear(dim, context_dim, bias=bias)\n+        self.down_proj = nn.Linear(context_dim, dim, bias=bias)\n+        self.act1 = nn.GELU()\n+        self.act_fn = ACT2FN[hidden_act]\n+\n+    def forward(self, hidden_state: torch.Tensor) -> torch.Tensor:\n+        hidden_state = self.proj(hidden_state)\n+        hidden_state = self.act1(self.post_projection_norm(hidden_state))\n+        return self.down_proj(self.act_fn(self.gate_proj(hidden_state)) * self.up_proj(hidden_state))\n+\n+\n+class Glm4vVisionEmbeddings(nn.Module):\n+    def __init__(self, config: Glm4vVisionConfig):\n+        super().__init__()\n+        self.config = config\n+        self.embed_dim = config.hidden_size\n+        self.image_size = config.image_size\n+        self.patch_size = config.patch_size\n+\n+        self.num_patches = (self.image_size // self.patch_size) ** 2\n+        self.num_positions = self.num_patches\n+        self.position_embedding = nn.Embedding(self.num_positions, self.embed_dim)\n+        self.register_buffer(\"position_ids\", torch.arange(self.num_positions).expand((1, -1)), persistent=False)\n+\n+    def forward(self, embeddings, lengths, image_shapes, h_coords, w_coords) -> torch.Tensor:\n+        \"\"\"\n+        Forward pass with integrated position encoding adaptation using 2D interpolation.\n+\n+        Args:\n+            embeddings: Input embeddings tensor\n+            lengths (torch.Tensor): Sequence lengths for each image in the batch.\n+            image_shapes (torch.Tensor): Tensor of shape [batch_size, 3] representing the image shapes (t, h, w).\n+            h_coords (torch.Tensor): Tensor of shape [total_seq] representing the h coordinate for each patch.\n+            w_coords (torch.Tensor): Tensor of shape [total_seq] representing the w coordinate for each patch.\n+\n+        Returns:\n+            torch.Tensor: Embeddings with adapted position encoding added.\n+        \"\"\"\n+        # Get position embedding parameters\n+        pos_embed_weight = self.position_embedding.weight\n+        hidden_size = pos_embed_weight.shape[1]\n+        total_seq = h_coords.shape[0]\n+        device = pos_embed_weight.device\n+\n+        # Move coordinates to correct device\n+        h_coords, w_coords = h_coords.to(device), w_coords.to(device)\n+\n+        # Handle empty sequence case\n+        if total_seq == 0:\n+            adapted_pos_embed = torch.empty(0, hidden_size, device=device, dtype=pos_embed_weight.dtype)\n+        else:\n+            # Convert inputs to tensors if needed\n+            if isinstance(lengths, list):\n+                lengths = torch.tensor(lengths, device=device, dtype=torch.long)\n+            if not isinstance(image_shapes, torch.Tensor):\n+                image_shapes = torch.tensor(image_shapes, device=device, dtype=torch.long)\n+\n+            # Prepare 2D position embedding\n+            orig_size_sq = pos_embed_weight.shape[0]\n+            orig_size = int(orig_size_sq**0.5)\n+            pos_embed_2d = (\n+                pos_embed_weight.view(orig_size, orig_size, hidden_size)\n+                .permute(2, 0, 1)\n+                .unsqueeze(0)\n+                .to(device=device, dtype=torch.float32)\n+            )\n+\n+            # Calculate target dimensions for each patch\n+            target_h = torch.cat([image_shapes[i, 1].repeat(lengths[i]) for i in range(len(lengths))]).to(\n+                device=device, dtype=torch.float32\n+            )\n+            target_w = torch.cat([image_shapes[i, 2].repeat(lengths[i]) for i in range(len(lengths))]).to(\n+                device=device, dtype=torch.float32\n+            )\n+\n+            # Normalize coordinates to [-1, 1] range for grid_sample\n+            h_coords = h_coords.to(device=device, dtype=torch.float32)\n+            w_coords = w_coords.to(device=device, dtype=torch.float32)\n+            norm_w = ((w_coords + 0.5) / target_w) * 2 - 1\n+            norm_h = ((h_coords + 0.5) / target_h) * 2 - 1\n+\n+            # Create sampling grid\n+            grid = torch.stack((norm_w, norm_h), dim=-1).unsqueeze(0).unsqueeze(2)\n+\n+            # Perform bicubic interpolation\n+            interpolated_embed_fp32 = F.grid_sample(\n+                pos_embed_2d, grid, mode=\"bicubic\", align_corners=False, padding_mode=\"border\"\n+            )\n+\n+            # Reshape and convert back to original dtype\n+            adapted_pos_embed_fp32 = interpolated_embed_fp32.squeeze(0).squeeze(-1).permute(1, 0)\n+            adapted_pos_embed = adapted_pos_embed_fp32.to(pos_embed_weight.dtype).to(embeddings.device)\n+\n+        # Add adapted position encoding to embeddings\n+        embeddings = embeddings + adapted_pos_embed\n+        return embeddings\n+\n+\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+def apply_rotary_pos_emb_vision(\n+    q: torch.Tensor, k: torch.Tensor, cos: torch.Tensor, sin: torch.Tensor\n+) -> tuple[torch.Tensor, torch.Tensor]:\n+    orig_q_dtype = q.dtype\n+    orig_k_dtype = k.dtype\n+    q, k = q.float(), k.float()\n+    cos, sin = cos.unsqueeze(-2).float(), sin.unsqueeze(-2).float()\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    q_embed = q_embed.to(orig_q_dtype)\n+    k_embed = k_embed.to(orig_k_dtype)\n+    return q_embed, k_embed\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs,\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+class Glm4vVisionAttention(nn.Module):\n+    def __init__(self, config: Glm4vVisionConfig) -> None:\n+        super().__init__()\n+        self.config = config\n+        self.num_heads = config.num_heads\n+        self.head_dim = config.hidden_size // self.num_heads\n+        self.num_key_value_groups = 1\n+        self.scale = self.head_dim**-0.5\n+        self.attention_dropout = config.attention_dropout\n+        self.qkv = nn.Linear(config.hidden_size, config.hidden_size * 3, bias=config.attention_bias)\n+        self.proj = nn.Linear(config.hidden_size, config.hidden_size, bias=False)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cu_seqlens: torch.Tensor,\n+        rotary_pos_emb: Optional[torch.Tensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> torch.Tensor:\n+        seq_length = hidden_states.shape[0]\n+        query_states, key_states, value_states = (\n+            self.qkv(hidden_states).reshape(seq_length, 3, self.num_heads, -1).permute(1, 0, 2, 3).unbind(0)\n+        )\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb_vision(query_states, key_states, cos, sin)\n+\n+        query_states = query_states.transpose(0, 1).unsqueeze(0)\n+        key_states = key_states.transpose(0, 1).unsqueeze(0)\n+        value_states = value_states.transpose(0, 1).unsqueeze(0)\n+\n+        attention_mask = torch.zeros([1, 1, seq_length, seq_length], device=query_states.device, dtype=torch.bool)\n+        for i in range(1, len(cu_seqlens)):\n+            attention_mask[..., cu_seqlens[i - 1] : cu_seqlens[i], cu_seqlens[i - 1] : cu_seqlens[i]] = True\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, _ = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scale,\n+            is_causal=False,\n+            **kwargs,\n+        )\n+        attn_output = attn_output.squeeze(0)\n+        attn_output = attn_output.reshape(seq_length, -1).contiguous()\n+        attn_output = self.proj(attn_output)\n+        return attn_output\n+\n+\n+class Glm4vVisionBlock(GradientCheckpointingLayer):\n+    def __init__(self, config) -> None:\n+        super().__init__()\n+        self.norm1 = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.norm2 = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.attn = Glm4vVisionAttention(config)\n+        self.mlp = Glm4VisionMlp(config, bias=False)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cu_seqlens: torch.Tensor,\n+        rotary_pos_emb: Optional[torch.Tensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        **kwargs,\n+    ) -> torch.Tensor:\n+        hidden_states = hidden_states + self.attn(\n+            self.norm1(hidden_states),\n+            cu_seqlens=cu_seqlens,\n+            rotary_pos_emb=rotary_pos_emb,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = hidden_states + self.mlp(self.norm2(hidden_states))\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class Glm4vPreTrainedModel(PreTrainedModel):\n+    config_class = Glm4vConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"Glm4vTextDecoderLayer\", \"Glm4vVisionBlock\"]\n+    _skip_keys_device_placement = \"past_key_values\"\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = True\n+    _supports_cache_class = True\n+    _supports_static_cache = True\n+    _supports_attention_backend = True\n+\n+    def _init_weights(self, module):\n+        std = self.config.get_text_config().initializer_range\n+        if isinstance(module, (nn.Linear, nn.Conv2d, nn.Conv3d)):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+        elif isinstance(module, Glm4vRMSNorm):\n+            module.weight.data.fill_(1.0)\n+        elif isinstance(module, nn.LayerNorm):\n+            module.weight.data.fill_(1.0)\n+            module.bias.data.zero_()\n+\n+\n+class Glm4vVisionModel(Glm4vPreTrainedModel):\n+    config_class = Glm4vVisionConfig\n+    _no_split_modules = [\"Glm4vVisionBlock\"]\n+\n+    def __init__(self, config) -> None:\n+        super().__init__(config)\n+        self.spatial_merge_size = config.spatial_merge_size\n+        self.patch_size = config.patch_size\n+\n+        self.embeddings = Glm4vVisionEmbeddings(config)\n+        self.patch_embed = Glm4vVisionPatchEmbed(config)\n+\n+        head_dim = config.hidden_size // config.num_heads\n+        self.rotary_pos_emb = Glm4vVisionRotaryEmbedding(head_dim // 2)\n+\n+        self.blocks = nn.ModuleList([Glm4vVisionBlock(config) for _ in range(config.depth)])\n+        self.merger = Glm4vVisionPatchMerger(\n+            dim=config.out_hidden_size, context_dim=config.intermediate_size, hidden_act=config.hidden_act\n+        )\n+\n+        self.post_conv_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.downsample = nn.Conv2d(\n+            in_channels=config.hidden_size,\n+            out_channels=config.out_hidden_size,\n+            kernel_size=config.spatial_merge_size,\n+            stride=config.spatial_merge_size,\n+        )\n+        self.post_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+        self.gradient_checkpointing = False\n+        self.post_init()\n+\n+    def rot_pos_emb(self, grid_thw):\n+        pos_ids = []\n+        for t, h, w in grid_thw:\n+            hpos_ids = torch.arange(h).unsqueeze(1).expand(-1, w)\n+            hpos_ids = hpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            hpos_ids = hpos_ids.permute(0, 2, 1, 3)\n+            hpos_ids = hpos_ids.flatten()\n+\n+            wpos_ids = torch.arange(w).unsqueeze(0).expand(h, -1)\n+            wpos_ids = wpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            wpos_ids = wpos_ids.permute(0, 2, 1, 3)\n+            wpos_ids = wpos_ids.flatten()\n+            pos_ids.append(torch.stack([hpos_ids, wpos_ids], dim=-1).repeat(t, 1))\n+        pos_ids = torch.cat(pos_ids, dim=0)\n+        max_grid_size = grid_thw[:, 1:].max()\n+        rotary_pos_emb_full = self.rotary_pos_emb(max_grid_size)\n+        rotary_pos_emb = rotary_pos_emb_full[pos_ids].flatten(1)\n+        return rotary_pos_emb, pos_ids\n+\n+    def forward(self, hidden_states: torch.Tensor, grid_thw: torch.Tensor) -> torch.Tensor:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.Tensor` of shape `(seq_len, hidden_size)`):\n+                The final hidden states of the model.\n+            grid_thw (`torch.Tensor` of shape `(num_images_or_videos, 3)`):\n+                The temporal, height and width of feature shape of each image in LLM.\n+\n+        Returns:\n+            `torch.Tensor`: hidden_states.\n+        \"\"\"\n+        hidden_states = self.patch_embed(hidden_states)\n+        hidden_states = self.post_conv_layernorm(hidden_states)\n+\n+        rotary_pos_emb, image_type_ids = self.rot_pos_emb(grid_thw)\n+        emb = torch.cat((rotary_pos_emb, rotary_pos_emb), dim=-1)\n+        position_embeddings = (emb.cos(), emb.sin())\n+\n+        cu_seqlens = torch.repeat_interleave(grid_thw[:, 1] * grid_thw[:, 2], grid_thw[:, 0]).cumsum(\n+            dim=0,\n+            # Select dtype based on the following factors:\n+            #  - FA2 requires that cu_seqlens_q must have dtype int32\n+            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n+            # See https://github.com/huggingface/transformers/pull/34852 for more information\n+            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_seqlens = F.pad(cu_seqlens, (1, 0), value=0)\n+        seqlens = (cu_seqlens[1:] - cu_seqlens[:-1]).tolist()\n+        hidden_states = self.embeddings(hidden_states, seqlens, grid_thw, image_type_ids[:, 0], image_type_ids[:, 1])\n+\n+        for blk in self.blocks:\n+            if self.gradient_checkpointing and self.training:\n+                hidden_states = self._gradient_checkpointing_func(\n+                    blk.__call__, hidden_states, cu_seqlens, None, position_embeddings\n+                )\n+            else:\n+                hidden_states = blk(hidden_states, cu_seqlens=cu_seqlens, position_embeddings=position_embeddings)\n+\n+        hidden_states = self.post_layernorm(hidden_states)\n+\n+        hidden_states = hidden_states.view(\n+            -1, self.spatial_merge_size, self.spatial_merge_size, hidden_states.shape[-1]\n+        )\n+        hidden_states = hidden_states.permute(0, 3, 1, 2)\n+        hidden_states = self.downsample(hidden_states).view(-1, self.config.out_hidden_size)\n+\n+        hidden_states = self.merger(hidden_states)\n+        return hidden_states\n+\n+\n+class Glm4vTextRotaryEmbedding(nn.Module):\n+    def __init__(self, config: Glm4vTextConfig, device=None):\n+        super().__init__()\n+        # BC: \"rope_type\" was originally \"type\"\n+        if hasattr(config, \"rope_scaling\") and config.rope_scaling is not None:\n+            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n+        else:\n+            self.rope_type = \"default\"\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = self.inv_freq\n+\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        # In contrast to other models, Glm4vText has different position ids for the grids\n+        # So we expand the inv_freq to shape (3, ...)\n+        inv_freq_expanded = self.inv_freq[None, None, :, None].float().expand(3, position_ids.shape[1], -1, 1)\n+        position_ids_expanded = position_ids[:, :, None, :].float()  # shape (3, bs, 1, positions)\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(2, 3)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos() * self.attention_scaling\n+            sin = emb.sin() * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+def rotate_half_llm(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., 0::2]\n+    x2 = x[..., 1::2]\n+    return torch.stack((-x2, x1), dim=-1).flatten(-2)\n+\n+\n+def apply_multimodal_rotary_pos_emb(q, k, cos, sin, mrope_section, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding with Multimodal Sections to the query and key tensors (https://qwenlm.github.io/blog/qwen2-vl/).\n+\n+    Explanation:\n+        Multimodal 3D rotary position embedding is an extension to 1D rotary position embedding. The input embedding\n+        sequence contains vision (images / videos) embedding and text embedding or just contains text embedding. For\n+        vision embedding part, we apply rotary position embedding on temporal, height and width dimension separately.\n+        Here we split the channel dimension to 3 chunks for the temporal, height and width rotary position embedding.\n+        For text embedding part, we just apply 1D rotary position embedding. The three rotary position index (temporal,\n+        height and width) of text embedding is always the same, so the text embedding rotary position embedding has no\n+        difference with modern LLMs.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        mrope_section(`List(int)`):\n+            Multimodal rope section is for channel dimension of temporal, height and width in rope calculation.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    mrope_section = mrope_section * 2\n+    cos = torch.cat([m[i % 3] for i, m in enumerate(cos.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+    sin = torch.cat([m[i % 3] for i, m in enumerate(sin.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+\n+    # Interleave them instead of usual shape\n+    cos = cos[..., : cos.shape[-1] // 2].repeat_interleave(2, dim=-1)\n+    sin = sin[..., : sin.shape[-1] // 2].repeat_interleave(2, dim=-1)\n+\n+    # Keep half or full tensor for later concatenation\n+    rotary_dim = cos.shape[-1]\n+    q_rot, q_pass = q[..., :rotary_dim], q[..., rotary_dim:]\n+    k_rot, k_pass = k[..., :rotary_dim], k[..., rotary_dim:]\n+\n+    # Apply rotary embeddings on the first half or full tensor\n+    q_embed = (q_rot * cos) + (rotate_half_llm(q_rot) * sin)\n+    k_embed = (k_rot * cos) + (rotate_half_llm(k_rot) * sin)\n+\n+    # Concatenate back to full shape\n+    q_embed = torch.cat([q_embed, q_pass], dim=-1)\n+    k_embed = torch.cat([k_embed, k_pass], dim=-1)\n+\n+    return q_embed, k_embed\n+\n+\n+class Glm4vTextAttention(nn.Module):\n+    \"\"\"\n+    Multi-headed attention from 'Attention Is All You Need' paper.\n+    and \"Generating Long Sequences with Sparse Transformers\".\n+    \"\"\"\n+\n+    def __init__(self, config: Glm4vTextConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+\n+        self.hidden_size = config.hidden_size\n+        self.num_heads = config.num_attention_heads\n+        self.head_dim = self.hidden_size // self.num_heads\n+        self.num_key_value_heads = config.num_key_value_heads\n+        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n+        self.is_causal = True\n+        self.attention_dropout = config.attention_dropout\n+        self.rope_scaling = config.rope_scaling\n+        self.scaling = self.head_dim**-0.5\n+\n+        self.q_proj = nn.Linear(self.hidden_size, self.num_heads * self.head_dim, bias=True)\n+        self.k_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=True)\n+        self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=True)\n+        self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=False)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor], Optional[tuple[torch.Tensor]]]:\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_multimodal_rotary_pos_emb(  # diff with Llama\n+            query_states, key_states, cos, sin, self.rope_scaling[\"mrope_section\"]\n+        )\n+\n+        if past_key_value is not None:\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}  # Specific to RoPE models\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(bsz, q_len, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights, past_key_value\n+\n+\n+class Glm4vTextMLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+\n+        self.config = config\n+        self.gate_up_proj = nn.Linear(config.hidden_size, 2 * config.intermediate_size, bias=False)\n+        self.down_proj = nn.Linear(config.intermediate_size, config.hidden_size, bias=False)\n+        self.activation_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, hidden_states: torch.FloatTensor) -> torch.FloatTensor:\n+        up_states = self.gate_up_proj(hidden_states)\n+\n+        gate, up_states = up_states.chunk(2, dim=-1)\n+        up_states = up_states * self.activation_fn(gate)\n+\n+        return self.down_proj(up_states)\n+\n+\n+class Glm4vTextDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: Glm4vTextConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+        self.self_attn = Glm4vTextAttention(config, layer_idx)\n+        self.mlp = Glm4vTextMLP(config)\n+        self.input_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_self_attn_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_mlp_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[tuple[torch.Tensor]] = None,\n+        output_attentions: Optional[bool] = False,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> tuple[torch.FloatTensor, Optional[tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        residual = hidden_states\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # Self Attention\n+        hidden_states, self_attn_weights, present_key_value = self.self_attn(\n+            hidden_states=hidden_states,\n+            position_embeddings=position_embeddings,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+        )\n+\n+        hidden_states = self.post_self_attn_layernorm(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = self.post_mlp_layernorm(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        outputs = (hidden_states,)\n+\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        if use_cache:\n+            outputs += (present_key_value,)\n+\n+        return outputs\n+\n+\n+class KwargsForCausalLM(FlashAttentionKwargs, LossKwargs): ...\n+\n+\n+@dataclass\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    Base class for Llava outputs, with hidden states and attentions.\n+    \"\"\"\n+)\n+class Glm4vModelOutputWithPast(ModelOutput):\n+    r\"\"\"\n+    past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+        Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+        `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+\n+        Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+        `past_key_values` input) to speed up sequential decoding.\n+    rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+        The rope index difference between sequence length and multimodal rope.\n+    \"\"\"\n+\n+    last_hidden_state: torch.FloatTensor = None\n+    past_key_values: Optional[list[torch.FloatTensor]] = None\n+    hidden_states: Optional[tuple[torch.FloatTensor]] = None\n+    attentions: Optional[tuple[torch.FloatTensor]] = None\n+    rope_deltas: Optional[torch.LongTensor] = None\n+\n+\n+@auto_docstring\n+class Glm4vTextModel(Glm4vPreTrainedModel):\n+    config_class = Glm4vTextConfig\n+\n+    def __init__(self, config: Glm4vTextConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [Glm4vTextDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = Glm4vTextRotaryEmbedding(config=config)\n+\n+        self.gradient_checkpointing = False\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.embed_tokens = value\n+\n+    @auto_docstring\n+    @can_return_tuple\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Union[tuple, BaseModelOutputWithPast]:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if self.gradient_checkpointing and self.training:\n+            if use_cache:\n+                logger.warning_once(\n+                    \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n+                )\n+                use_cache = False\n+\n+        # torch.jit.trace() doesn't support cache objects in the output\n+        if use_cache and past_key_values is None and not torch.jit.is_tracing():\n+            past_key_values = DynamicCache()\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        # the hard coded `3` is for temporal, height and width.\n+        if position_ids is None:\n+            position_ids = cache_position.view(1, 1, -1).expand(3, inputs_embeds.shape[0], -1)\n+        elif position_ids.dim() == 2:\n+            position_ids = position_ids[None, ...].expand(3, position_ids.shape[0], -1)\n+\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+        )\n+\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+\n+        for decoder_layer in self.layers:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            layer_outputs = decoder_layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=causal_mask,\n+                position_ids=position_ids,\n+                past_key_value=past_key_values,\n+                output_attentions=output_attentions,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        # add hidden states from the last decoder layer\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values if use_cache else None,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+        )\n+\n+\n+@auto_docstring\n+class Glm4vModel(Glm4vPreTrainedModel):\n+    base_model_prefix = \"\"\n+    _checkpoint_conversion_mapping = None\n+    config_class = Glm4vConfig\n+    _no_split_modules = [\"Glm4vTextDecoderLayer\", \"Glm4vVisionBlock\"]\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.visual = Glm4vVisionModel._from_config(config.vision_config)\n+        self.language_model = Glm4vTextModel._from_config(config.text_config)\n+        self.rope_deltas = None  # cache rope_deltas here\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.language_model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.language_model.set_input_embeddings(value)\n+\n+    def set_decoder(self, decoder):\n+        self.language_model = decoder\n+\n+    def get_decoder(self):\n+        return self.language_model\n+\n+    def get_rope_index(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Calculate the 3D rope index based on image and video's temporal, height and width in LLM.\n+\n+        Explanation:\n+            Each embedding sequence contains vision embedding and text embedding or just contains text embedding.\n+\n+            For pure text embedding sequence, the rotary position embedding has no difference with modern LLMs.\n+            Examples:\n+                input_ids: [T T T T T], here T is for text.\n+                temporal position_ids: [0, 1, 2, 3, 4]\n+                height position_ids: [0, 1, 2, 3, 4]\n+                width position_ids: [0, 1, 2, 3, 4]\n+\n+            For vision and text embedding sequence, we calculate 3D rotary position embedding for vision part\n+            and 1D rotary position embedding for text part.\n+            Examples:\n+                Temporal (Time): 3 patches, representing different segments of the video in time.\n+                Height: 2 patches, dividing each frame vertically.\n+                Width: 2 patches, dividing each frame horizontally.\n+                We also have some important parameters:\n+                fps (Frames Per Second): The video's frame rate, set to 1. This means one frame is processed each second.\n+                tokens_per_second: This is a crucial parameter. It dictates how many \"time-steps\" or \"temporal tokens\" are conceptually packed into a one-second interval of the video. In this case, we have 25 tokens per second. So each second of the video will be represented with 25 separate time points. It essentially defines the temporal granularity.\n+                temporal_patch_size: The number of frames that compose one temporal patch. Here, it's 2 frames.\n+                interval: The step size for the temporal position IDs, calculated as tokens_per_second * temporal_patch_size / fps. In this case, 25 * 2 / 1 = 50. This means that each temporal patch will be have a difference of 50 in the temporal position IDs.\n+                input_ids: [V V V V V V V V V V V V T T T T T], here V is for vision.\n+                vision temporal position_ids: [0, 0, 0, 0, 50, 50, 50, 50, 100, 100, 100, 100]\n+                vision height position_ids: [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]\n+                vision width position_ids: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n+                text temporal position_ids: [101, 102, 103, 104, 105]\n+                text height position_ids: [101, 102, 103, 104, 105]\n+                text width position_ids: [101, 102, 103, 104, 105]\n+                Here we calculate the text start position_ids as the max vision position_ids plus 1.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+                it.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+\n+        Returns:\n+            position_ids (`torch.LongTensor` of shape `(3, batch_size, sequence_length)`)\n+            mrope_position_deltas (`torch.Tensor` of shape `(batch_size)`)\n+        \"\"\"\n+\n+        spatial_merge_size = self.config.vision_config.spatial_merge_size\n+        image_token_id = self.config.image_token_id\n+        video_start_token_id = self.config.video_start_token_id\n+        video_end_token_id = self.config.video_end_token_id\n+\n+        mrope_position_deltas = []\n+        if input_ids is not None and (image_grid_thw is not None or video_grid_thw is not None):\n+            total_input_ids = input_ids\n+            if attention_mask is None:\n+                attention_mask = torch.ones_like(total_input_ids)\n+            position_ids = torch.ones(\n+                3,\n+                input_ids.shape[0],\n+                input_ids.shape[1],\n+                dtype=input_ids.dtype,\n+                device=input_ids.device,\n+            )\n+\n+            attention_mask = attention_mask.to(total_input_ids.device)\n+            for i, input_ids in enumerate(total_input_ids):\n+                input_ids = input_ids[attention_mask[i] == 1]\n+                input_tokens = input_ids.tolist()\n+\n+                input_token_type = []\n+                video_check_flg = False\n+                for token in input_tokens:\n+                    if token == video_start_token_id:\n+                        video_check_flg = True\n+                    elif token == video_end_token_id:\n+                        video_check_flg = False\n+\n+                    if token == image_token_id and not video_check_flg:\n+                        input_token_type.append(\"image\")\n+                    elif token == image_token_id and video_check_flg:\n+                        input_token_type.append(\"video\")\n+                    else:\n+                        input_token_type.append(\"text\")\n+\n+                input_type_group = []\n+                for key, group in itertools.groupby(enumerate(input_token_type), lambda x: x[1]):\n+                    group = list(group)\n+                    start_index = group[0][0]\n+                    end_index = group[-1][0] + 1\n+                    input_type_group.append((key, start_index, end_index))\n+\n+                llm_pos_ids_list = []\n+                video_frame_num = 1\n+                image_index, video_index = 0, 0\n+\n+                for modality_type, start_idx, end_idx in input_type_group:\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+\n+                    if modality_type == \"image\":\n+                        t, h, w = (\n+                            image_grid_thw[image_index][0],\n+                            image_grid_thw[image_index][1],\n+                            image_grid_thw[image_index][2],\n+                        )\n+                        llm_grid_t, llm_grid_h, llm_grid_w = (\n+                            t.item(),\n+                            h.item() // spatial_merge_size,\n+                            w.item() // spatial_merge_size,\n+                        )\n+\n+                        t_index = torch.arange(llm_grid_t).view(-1, 1).expand(-1, llm_grid_h * llm_grid_w).flatten()\n+                        h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(llm_grid_t, -1, llm_grid_w).flatten()\n+                        w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(llm_grid_t, llm_grid_h, -1).flatten()\n+                        llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + st_idx)\n+\n+                        image_index += 1\n+                        video_frame_num = 1\n+\n+                    elif modality_type == \"video\":\n+                        t, h, w = (\n+                            video_frame_num,\n+                            video_grid_thw[video_index][1],\n+                            video_grid_thw[video_index][2],\n+                        )\n+\n+                        llm_grid_t, llm_grid_h, llm_grid_w = (\n+                            t,\n+                            h.item() // spatial_merge_size,\n+                            w.item() // spatial_merge_size,\n+                        )\n+\n+                        for t_idx in range(llm_grid_t):\n+                            t_index = torch.tensor(t_idx).view(-1, 1).expand(-1, llm_grid_h * llm_grid_w).flatten()\n+\n+                            h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(1, -1, llm_grid_w).flatten()\n+\n+                            w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(1, llm_grid_h, -1).flatten()\n+\n+                            llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + st_idx)\n+\n+                        video_index += 1\n+\n+                        video_frame_num += 1\n+\n+                    else:\n+                        text_len = end_idx - start_idx\n+                        llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                        video_frame_num = 1\n+\n+                llm_positions = torch.cat(llm_pos_ids_list, dim=1).reshape(3, -1)\n+                position_ids[..., i, attention_mask[i] == 1] = llm_positions.to(position_ids.device)\n+                mrope_position_deltas.append(llm_positions.max() + 1 - len(total_input_ids[i]))\n+            mrope_position_deltas = torch.tensor(mrope_position_deltas, device=input_ids.device).unsqueeze(1)\n+            return position_ids, mrope_position_deltas\n+        else:\n+            if attention_mask is not None:\n+                position_ids = attention_mask.long().cumsum(-1) - 1\n+                position_ids.masked_fill_(attention_mask == 0, 1)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1).to(attention_mask.device)\n+                max_position_ids = position_ids.max(0, keepdim=False)[0].max(-1, keepdim=True)[0]\n+                mrope_position_deltas = max_position_ids + 1 - attention_mask.shape[-1]\n+            else:\n+                position_ids = (\n+                    torch.arange(input_ids.shape[1], device=input_ids.device)\n+                    .view(1, 1, -1)\n+                    .expand(3, input_ids.shape[0], -1)\n+                )\n+                mrope_position_deltas = torch.zeros(\n+                    [input_ids.shape[0], 1],\n+                    device=input_ids.device,\n+                    dtype=input_ids.dtype,\n+                )\n+\n+            return position_ids, mrope_position_deltas\n+\n+    def get_video_features(\n+        self, pixel_values_videos: torch.FloatTensor, video_grid_thw: Optional[torch.LongTensor] = None\n+    ):\n+        \"\"\"\n+        Encodes videos into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values_videos (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input videos.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+        \"\"\"\n+        pixel_values_videos = pixel_values_videos.type(self.visual.dtype)\n+        video_embeds = self.visual(pixel_values_videos, grid_thw=video_grid_thw)\n+        split_sizes = (video_grid_thw.prod(-1) // self.visual.spatial_merge_size**2).tolist()\n+        video_embeds = torch.split(video_embeds, split_sizes)\n+        return video_embeds\n+\n+    def get_image_features(self, pixel_values: torch.FloatTensor, image_grid_thw: Optional[torch.LongTensor] = None):\n+        \"\"\"\n+        Encodes images into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input images.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        pixel_values = pixel_values.type(self.visual.dtype)\n+        image_embeds = self.visual(pixel_values, grid_thw=image_grid_thw)\n+        split_sizes = (image_grid_thw.prod(-1) // self.visual.spatial_merge_size**2).tolist()\n+        image_embeds = torch.split(image_embeds, split_sizes)\n+        return image_embeds\n+\n+    @auto_docstring\n+    @can_return_tuple\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[KwargsForCausalLM],\n+    ) -> Union[tuple, Glm4vModelOutputWithPast]:\n+        r\"\"\"\n+        pixel_values_videos (`torch.FloatTensor` of shape `(seq_length, num_channels * temporal_size * image_size * image_size)):\n+            The tensors corresponding to the input videos. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`Glm4vImageProcessor.__call__`] for details. [`Glm4vProcessor`] uses\n+            [`Glm4vImageProcessor`] for processing videos.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+        \"\"\"\n+\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if pixel_values is not None and inputs_embeds is not None:\n+            raise ValueError(\n+                \"You cannot specify both pixel_values and inputs_embeds at the same time, and must specify either one\"\n+            )\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.get_input_embeddings()(input_ids)\n+\n+        if pixel_values is not None:\n+            image_embeds = self.get_image_features(pixel_values, image_grid_thw)\n+            image_embeds = torch.cat(image_embeds, dim=0)\n+            n_image_tokens = (input_ids == self.config.image_token_id).sum()\n+            n_image_features = image_embeds.shape[0]\n+            if not is_torchdynamo_compiling() and n_image_tokens != n_image_features:\n+                raise ValueError(\n+                    f\"Image features and image tokens do not match: tokens: {n_image_tokens}, features {n_image_features}\"\n+                )\n+\n+            mask = input_ids == self.config.image_token_id\n+            mask_unsqueezed = mask.unsqueeze(-1)\n+            mask_expanded = mask_unsqueezed.expand_as(inputs_embeds)\n+            image_mask = mask_expanded.to(inputs_embeds.device)\n+            image_embeds = image_embeds.to(inputs_embeds.device, inputs_embeds.dtype)\n+            inputs_embeds = inputs_embeds.masked_scatter(image_mask, image_embeds)\n+\n+        if pixel_values_videos is not None:\n+            video_embeds = self.get_video_features(pixel_values_videos, video_grid_thw)\n+            video_embeds = torch.cat(video_embeds, dim=0)\n+            n_video_tokens = (input_ids == self.config.image_token_id).sum()\n+            n_video_features = video_embeds.shape[0]\n+            if not is_torchdynamo_compiling() and n_video_tokens != n_video_features:\n+                raise ValueError(\n+                    f\"Video features and video tokens do not match: tokens: {n_video_tokens}, features {n_video_features}\"\n+                )\n+\n+            mask = input_ids == self.config.image_token_id  # GLM-4.1V use image_token_id for video\n+            mask_unsqueezed = mask.unsqueeze(-1)\n+            mask_expanded = mask_unsqueezed.expand_as(inputs_embeds)\n+            video_mask = mask_expanded.to(inputs_embeds.device)\n+            video_embeds = video_embeds.to(inputs_embeds.device, inputs_embeds.dtype)\n+            inputs_embeds = inputs_embeds.masked_scatter(video_mask, video_embeds)\n+\n+        if position_ids is None:\n+            attention_mask_tensor = attention_mask\n+            if attention_mask_tensor is not None and attention_mask_tensor.ndim == 4:\n+                attention_mask_tensor = torch.diagonal(attention_mask_tensor[:, 0], dim1=1, dim2=2)\n+                attention_mask_tensor = attention_mask_tensor / torch.finfo(attention_mask_tensor.dtype).min\n+                attention_mask_tensor = (1.0 - attention_mask_tensor).int()\n+\n+            # Calculate RoPE index once per generation in the pre-fill stage only.\n+            # When compiling, we can't check tensor values thus we check only input length\n+            # It is safe to assume that `length!=1` means we're in pre-fill because compiled\n+            # models currently cannot do asssisted decoding\n+            prefill_compiled_stage = is_torchdynamo_compiling() and (\n+                (input_ids is not None and input_ids.shape[1] != 1)\n+                or (inputs_embeds is not None and inputs_embeds.shape[1] != 1)\n+            )\n+            prefill_noncompiled_stage = not is_torchdynamo_compiling() and (\n+                (cache_position is not None and cache_position[0] == 0)\n+                or (past_key_values is None or past_key_values.get_seq_length() == 0)\n+            )\n+            if (prefill_compiled_stage or prefill_noncompiled_stage) or self.rope_deltas is None:\n+                position_ids, rope_deltas = self.get_rope_index(\n+                    input_ids,\n+                    image_grid_thw,\n+                    video_grid_thw,\n+                    attention_mask=attention_mask_tensor,\n+                )\n+                self.rope_deltas = rope_deltas\n+            # then use the prev pre-calculated rope-deltas to get the correct position ids\n+            else:\n+                batch_size, seq_length, _ = inputs_embeds.shape\n+                delta = (\n+                    (cache_position[0] + self.rope_deltas).to(inputs_embeds.device)\n+                    if cache_position is not None\n+                    else 0\n+                )\n+                position_ids = torch.arange(seq_length, device=inputs_embeds.device)\n+                position_ids = position_ids.view(1, -1).expand(batch_size, -1)\n+                if cache_position is not None:  # otherwise `deltas` is an int `0`\n+                    delta = delta.repeat_interleave(batch_size // delta.shape[0], dim=0)\n+                position_ids = position_ids.add(delta)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1)\n+\n+        outputs = self.language_model(\n+            input_ids=None,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=True,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        return Glm4vModelOutputWithPast(\n+            last_hidden_state=outputs.last_hidden_state,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=self.rope_deltas,\n+        )\n+\n+\n+@dataclass\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    Base class for Glm4v causal language model (or autoregressive) outputs.\n+    \"\"\"\n+)\n+class Glm4vCausalLMOutputWithPast(ModelOutput):\n+    r\"\"\"\n+    loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+        Language modeling loss (for next-token prediction).\n+    logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n+        Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+    past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+        Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+        `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+\n+        Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+        `past_key_values` input) to speed up sequential decoding.\n+    rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+        The rope index difference between sequence length and multimodal rope.\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: Optional[torch.FloatTensor] = None\n+    past_key_values: Optional[list[torch.FloatTensor]] = None\n+    hidden_states: Optional[tuple[torch.FloatTensor]] = None\n+    attentions: Optional[tuple[torch.FloatTensor]] = None\n+    rope_deltas: Optional[torch.LongTensor] = None\n+\n+\n+class Glm4vForConditionalGeneration(Glm4vPreTrainedModel, GenerationMixin):\n+    _checkpoint_conversion_mapping = None\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = Glm4vModel(config)\n+        self.lm_head = nn.Linear(config.text_config.hidden_size, config.text_config.vocab_size, bias=False)\n+\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.model.set_input_embeddings(value)\n+\n+    def get_output_embeddings(self):\n+        return self.lm_head\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.lm_head = new_embeddings\n+\n+    def set_decoder(self, decoder):\n+        self.model.set_decoder(decoder)\n+\n+    def get_decoder(self):\n+        return self.model.get_decoder()\n+\n+    def get_video_features(\n+        self, pixel_values_videos: torch.FloatTensor, video_grid_thw: Optional[torch.LongTensor] = None\n+    ):\n+        return self.model.get_video_features(pixel_values_videos, video_grid_thw)\n+\n+    def get_image_features(self, pixel_values: torch.FloatTensor, image_grid_thw: Optional[torch.LongTensor] = None):\n+        return self.model.get_image_features(pixel_values, image_grid_thw)\n+\n+    # Make modules available throught conditional class for BC\n+    @property\n+    def language_model(self):\n+        return self.model.language_model\n+\n+    @property\n+    def visual(self):\n+        return self.model.visual\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[KwargsForCausalLM],\n+    ) -> Union[tuple, Glm4vCausalLMOutputWithPast]:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+        pixel_values_videos (`torch.FloatTensor` of shape `(seq_length, num_channels * temporal_size * image_size * image_size)):\n+            The tensors corresponding to the input videos. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`Glm4vImageProcessor.__call__`] for details. [`Glm4vProcessor`] uses\n+            [`Glm4vImageProcessor`] for processing videos.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+\n+        Example:\n+\n+        ```python\n+        >>> from PIL import Image\n+        >>> import requests\n+        >>> from transformers import AutoProcessor, Glm4vForConditionalGeneration\n+\n+        >>> model = Glm4vForConditionalGeneration.from_pretrained(\"THUDM/GLM-4.1V-9B-Thinking\")\n+        >>> processor = AutoProcessor.from_pretrained(\"THUDM/GLM-4.1V-9B-Thinking\")\n+\n+        >>> messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\"},\n+                    {\"type\": \"text\", \"text\": \"What is shown in this image?\"},\n+                ],\n+            },\n+        ]\n+        >>> url = \"https://www.ilankelman.org/stopsigns/australia.jpg\"\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> text = processor.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\n+        >>> inputs = processor(text=[text], images=[image], vision_infos=[vision_infos])\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"The image shows a street scene with a red stop sign in the foreground. In the background, there is a large red gate with Chinese characters ...\"\n+        ```\"\"\"\n+\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            pixel_values=pixel_values,\n+            pixel_values_videos=pixel_values_videos,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs[0]\n+        logits = self.lm_head(hidden_states)\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits=logits, labels=labels, vocab_size=self.config.text_config.vocab_size)\n+\n+        return Glm4vCausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=outputs.rope_deltas,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        attention_mask=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        position_ids=None,\n+        use_cache=True,\n+        pixel_values=None,\n+        pixel_values_videos=None,\n+        image_grid_thw=None,\n+        video_grid_thw=None,\n+        **kwargs,\n+    ):\n+        # Overwritten -- in specific circumstances we don't want to forward image inputs to the model\n+\n+        model_inputs = super().prepare_inputs_for_generation(\n+            input_ids,\n+            past_key_values=past_key_values,\n+            attention_mask=attention_mask,\n+            inputs_embeds=inputs_embeds,\n+            cache_position=cache_position,\n+            position_ids=position_ids,\n+            pixel_values=pixel_values,\n+            pixel_values_videos=pixel_values_videos,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            use_cache=use_cache,\n+            **kwargs,\n+        )\n+\n+        # GLM-4.1V position_ids are prepareed with rope_deltas in forward\n+        model_inputs[\"position_ids\"] = None\n+\n+        if cache_position[0] != 0:\n+            model_inputs[\"pixel_values\"] = None\n+            model_inputs[\"pixel_values_videos\"] = None\n+\n+        return model_inputs\n+\n+    def _get_image_nums_and_video_nums(\n+        self,\n+        input_ids: Optional[torch.LongTensor],\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Get the number of images and videos for each sample to calculate the separation length of the sample tensor.\n+        These parameters are not passed through the processor to avoid unpredictable impacts from interface modifications.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary.\n+\n+        Returns:\n+            image_nums (`torch.LongTensor` of shape `(batch_size, num_images_sample)`)\n+            video_nums (`torch.LongTensor` of shape `(batch_size, num_videos_sample)`)\n+        \"\"\"\n+\n+        is_image = input_ids == self.config.image_start_token_id\n+        is_video_start = input_ids == self.config.video_start_token_id\n+        is_video_end = input_ids == self.config.video_end_token_id\n+\n+        # Cumulative sum to track if we're inside a video span\n+        # We'll assume well-formed video tags (i.e. matching starts and ends)\n+        video_level = torch.cumsum(is_video_start.int() - is_video_end.int(), dim=1)\n+        inside_video = video_level > 0  # shape (batch_size, seq_length)\n+\n+        # Mask out image tokens that are inside video spans\n+        standalone_images = is_image & (~inside_video)\n+\n+        # Count per batch\n+        image_counts = standalone_images.sum(dim=1)\n+        video_counts = is_video_start.sum(dim=1)\n+\n+        return image_counts, video_counts\n+\n+    def _expand_inputs_for_generation(\n+        self,\n+        expand_size: int = 1,\n+        is_encoder_decoder: bool = False,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        **model_kwargs,\n+    ) -> tuple[torch.LongTensor, dict[str, Any]]:\n+        # Overwritten -- Support for expanding tensors without a batch size dimension\n+        # e.g., pixel_values, image_grid_thw, pixel_values_videos, video_grid_thw, second_per_grid_t\n+        # pixel_values.shape[0] is sum(seqlen_images for samples)\n+        # image_grid_thw.shape[0] is sum(num_images for samples)\n+\n+        if expand_size == 1:\n+            return input_ids, model_kwargs\n+\n+        visual_keys = [\"pixel_values\", \"image_grid_thw\", \"pixel_values_videos\", \"video_grid_thw\", \"second_per_grid_ts\"]\n+\n+        def _expand_dict_for_generation_visual(dict_to_expand):\n+            image_grid_thw = model_kwargs.get(\"image_grid_thw\", None)\n+            video_grid_thw = model_kwargs.get(\"video_grid_thw\", None)\n+            image_nums, video_nums = self._get_image_nums_and_video_nums(input_ids)\n+\n+            def _repeat_interleave_samples(x, lengths, repeat_times):\n+                samples = torch.split(x, lengths)\n+                repeat_args = [repeat_times] + [1] * (x.dim() - 1)\n+                result = torch.cat([sample.repeat(*repeat_args) for sample in samples], dim=0)\n+                return result\n+\n+            for key in dict_to_expand:\n+                if key == \"pixel_values\":\n+                    # split images into samples\n+                    samples = torch.split(image_grid_thw, list(image_nums))\n+                    # compute the sequence length of images for each sample\n+                    lengths = [torch.prod(sample, dim=1).sum() for sample in samples]\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"image_grid_thw\":\n+                    # get the num of images for each sample\n+                    lengths = list(image_nums)\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"pixel_values_videos\":\n+                    samples = torch.split(video_grid_thw, list(video_nums))\n+                    lengths = [torch.prod(sample, dim=1).sum() for sample in samples]\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"video_grid_thw\":\n+                    lengths = list(video_nums)\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"second_per_grid_ts\":\n+                    if not isinstance(dict_to_expand[key], list):\n+                        raise TypeError(\n+                            f\"Expected value for key '{key}' to be a list, but got {type(dict_to_expand[key])} instead.\"\n+                        )\n+                    tensor = torch.tensor(dict_to_expand[key])\n+                    lengths = list(video_nums)\n+                    tensor = _repeat_interleave_samples(tensor, lengths=lengths, repeat_times=expand_size)\n+                    dict_to_expand[key] = tensor.tolist()\n+            return dict_to_expand\n+\n+        def _expand_dict_for_generation(dict_to_expand):\n+            for key in dict_to_expand:\n+                if (\n+                    key != \"cache_position\"\n+                    and dict_to_expand[key] is not None\n+                    and isinstance(dict_to_expand[key], torch.Tensor)\n+                    and key not in visual_keys\n+                ):\n+                    dict_to_expand[key] = dict_to_expand[key].repeat_interleave(expand_size, dim=0)\n+            return dict_to_expand\n+\n+        # input_ids is required for expanding visual inputs\n+        # If input_ids is unavailable, visual inputs will not be used; therefore, there is no need to expand visual inputs.\n+        if input_ids is not None and input_ids.numel() != 0:\n+            model_kwargs = _expand_dict_for_generation_visual(model_kwargs)\n+\n+        if input_ids is not None:\n+            input_ids = input_ids.repeat_interleave(expand_size, dim=0)\n+\n+        model_kwargs = _expand_dict_for_generation(model_kwargs)\n+\n+        if is_encoder_decoder:\n+            if model_kwargs.get(\"encoder_outputs\") is None:\n+                raise ValueError(\"If `is_encoder_decoder` is True, make sure that `encoder_outputs` is defined.\")\n+            model_kwargs[\"encoder_outputs\"] = _expand_dict_for_generation(model_kwargs[\"encoder_outputs\"])\n+\n+        return input_ids, model_kwargs\n+\n+\n+__all__ = [\"Glm4vForConditionalGeneration\", \"Glm4vModel\", \"Glm4vPreTrainedModel\", \"Glm4vTextModel\"]"
        },
        {
            "sha": "bc1f9006b8d534bf5ae898d35786e26b0a63ba85",
            "filename": "src/transformers/models/glm4v/modular_glm4v.py",
            "status": "added",
            "additions": 1733,
            "deletions": 0,
            "changes": 1733,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodular_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodular_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodular_glm4v.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -0,0 +1,1733 @@\n+# coding=utf-8\n+# Copyright 2025 The ZhipuAI Inc. team and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import itertools\n+from typing import Callable, Optional, Union\n+\n+import torch\n+import torch.nn as nn\n+import torch.nn.functional as F\n+import torch.utils.checkpoint\n+from torch.nn import LayerNorm\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache\n+from ...configuration_utils import PretrainedConfig\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_utils import ImageInput\n+from ...masking_utils import create_causal_mask\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import BaseModelOutputWithPast\n+from ...modeling_rope_utils import rope_config_validation\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS\n+from ...processing_utils import ImagesKwargs, Unpack\n+from ...tokenization_utils_base import PreTokenizedInput, TextInput\n+from ...utils import LossKwargs, auto_docstring, can_return_tuple, is_torchdynamo_compiling, logging\n+from ...video_utils import VideoInput\n+from ..glm4.modeling_glm4 import Glm4MLP, Glm4RMSNorm, eager_attention_forward\n+from ..qwen2_5_vl.configuration_qwen2_5_vl import Qwen2_5_VLConfig\n+from ..qwen2_5_vl.modeling_qwen2_5_vl import (\n+    Qwen2_5_VisionPatchEmbed,\n+    Qwen2_5_VisionRotaryEmbedding,\n+    Qwen2_5_VLCausalLMOutputWithPast,\n+    Qwen2_5_VLForConditionalGeneration,\n+    Qwen2_5_VLMLP,\n+    Qwen2_5_VLModel,\n+    Qwen2_5_VLModelOutputWithPast,\n+    Qwen2_5_VLPreTrainedModel,\n+    Qwen2_5_VLRotaryEmbedding,\n+    Qwen2_5_VLTextModel,\n+    Qwen2_5_VLVisionBlock,\n+    apply_rotary_pos_emb_vision,\n+)\n+from ..qwen2_5_vl.processing_qwen2_5_vl import (\n+    Qwen2_5_VLProcessor,\n+    Qwen2_5_VLProcessorKwargs,\n+    Qwen2_5_VLVideosProcessorKwargs,\n+)\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Glm4vVisionConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vVisionModel`]. It is used to instantiate an Glm4vVisionModel\n+    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the defaults will yield\n+    a similar configuration to that of\n+    GLM-4.1V-9B-Thinking [THUDM/GLM-4.1V-9B-Thinking](https://huggingface.co/THUDM/GLM-4.1V-9B-Thinking).\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 1536):\n+            Dimensionality of the encoder layers and the pooler layer.\n+        depth (`int`, *optional*, defaults to 24):\n+            Number of layers (depth) in the model.\n+        attention_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to add a bias to the queries, keys and values.\n+        intermediate_size (`int`, *optional*, defaults to 13696):\n+            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"selu\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+            `\"relu\"`, `\"selu\"` and `\"gelu_new\"` are supported.\n+        hidden_dropout_prob (`float`, *optional*, defaults to 0.0):\n+            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            Dropout probability for attention weights.\n+        projection_dropout (`float`, *optional*, defaults to 0.0):\n+            Dropout probability for the projection layer.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        image_size (`int` or `list[int]`, *optional*, defaults to `[336, 336]`):\n+            The size (resolution) of each image.\n+        patch_size (`int`, *optional*, defaults to `14`):\n+            The size (resolution) of each patch.\n+        num_channels (`int`, *optional*, defaults to 3):\n+            The number of input channels.\n+        out_hidden_size (`int`, *optional*, defaults to 4096):\n+            The output hidden size of the vision model.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        spatial_merge_size (`int`, *optional*, defaults to 2):\n+            The size used for merging spatial dimensions.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The size used for patches along the temporal dimension.\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Glm4vVisionConfig, Glm4vVisionModel\n+\n+    >>> # Initializing a Glm4vVisionConfig GLM-4.1V-9B style configuration\n+    >>> configuration = Glm4vVisionConfig()\n+\n+    >>> # Initializing a model (with random weights) from the GLM-4.1V-9B configuration\n+    >>> model = Glm4vVisionModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"glm4v\"\n+    base_config_key = \"vision_config\"\n+\n+    def __init__(\n+        self,\n+        depth=24,\n+        hidden_size=1536,\n+        hidden_act=\"silu\",\n+        attention_bias=False,\n+        attention_dropout=0.0,\n+        num_heads=12,\n+        in_channels=3,\n+        image_size=336,\n+        patch_size=14,\n+        rms_norm_eps=1e-05,\n+        spatial_merge_size=2,\n+        temporal_patch_size=1,\n+        out_hidden_size=4096,\n+        intermediate_size=13696,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.depth = depth\n+        self.hidden_size = hidden_size\n+        self.hidden_act = hidden_act\n+        self.num_heads = num_heads\n+        self.in_channels = in_channels\n+        self.image_size = image_size\n+        self.patch_size = patch_size\n+        self.spatial_merge_size = spatial_merge_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.out_hidden_size = out_hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+\n+\n+class Glm4vTextConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vModel`]. It is used to instantiate a\n+    GLM-4.1V model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of\n+    GLM-4.1V-9B-Thinking [THUDM/GLM-4.1V-9B-Thinking](https://huggingface.co/THUDM/GLM-4.1V-9B-Thinking).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 151552):\n+            Vocabulary size of the Glm4v model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Glm4vModel`]\n+        hidden_size (`int`, *optional*, defaults to 4096):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 13696):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 40):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 32):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 2):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `32`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 32768):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_theta (`float`, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n+                    'llama3'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n+                    pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n+                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n+                    `factor` field to infer the suggested value.\n+        image_token_id (`int`, *optional*):\n+            Token index used as placeholder for image embeddings.\n+        video_token_id (`int`, *optional*):\n+            Token index used as placeholder for video embeddings.\n+\n+    ```python\n+    >>> from transformers import Glm4vTextModel, Glm4vConfig\n+\n+    >>> # Initializing a GLM-4.1V style configuration\n+    >>> configuration = Glm4vConfig()\n+\n+    >>> # Initializing a model from the GLM-4.1V style configuration\n+    >>> model = Glm4vTextModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"glm4v_text\"\n+    base_config_key = \"text_config\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    # Default tensor parallel plan for base model `Glm4v`\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_up_proj\": \"colwise_rep\",  # we need to replicate here due to the `chunk` operation\n+        \"layers.*.mlp.down_proj\": \"rowwise_rep\",  # we need to replicate here due to the `chunk` operation\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=151552,\n+        hidden_size=4096,\n+        intermediate_size=13696,\n+        num_hidden_layers=40,\n+        num_attention_heads=32,\n+        num_key_value_heads=2,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=32768,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-05,\n+        use_cache=True,\n+        tie_word_embeddings=False,\n+        rope_theta=10000.0,\n+        attention_dropout=0.0,\n+        rope_scaling=None,\n+        image_token_id=None,\n+        video_token_id=None,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.attention_dropout = attention_dropout\n+        self.rope_scaling = rope_scaling\n+\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, move it to 'rope_type'.\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self, ignore_keys={\"mrope_section\"})\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+\n+        super().__init__(tie_word_embeddings=tie_word_embeddings, **kwargs)\n+\n+\n+class Glm4vConfig(Qwen2_5_VLConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vModel`]. It is used to instantiate a\n+    GLM-4.1V model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of\n+    GLM-4.1V-9B-Thinking [THUDM/GLM-4.1V-9B-Thinking](https://huggingface.co/THUDM/GLM-4.1V-9B-Thinking).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        text_config (`Union[PreTrainedConfig, dict]`, *optional*, defaults to `Glm4vTextConfig`):\n+            The config object or dictionary of the text backbone.\n+        vision_config (`Union[PreTrainedConfig, dict]`,  *optional*, defaults to `Glm4vVisionConfig`):\n+            The config object or dictionary of the vision backbone.\n+        image_token_id (`int`, *optional*, defaults to 151343):\n+            The image token index to encode the image prompt.\n+        video_token_id (`int`, *optional*, defaults to 151344):\n+            The video token index to encode the image prompt.\n+        image_start_token_id (`int`, *optional*, defaults to 151339):\n+            The image start token index to encode the start of image.\n+        image_end_token_id (`int`, *optional*, defaults to 151340):\n+            The image end token index to encode the end of image.\n+        video_start_token_id (`int`, *optional*, defaults to 151341):\n+            The video start token index to encode the start of video.\n+        video_end_token_id (`int`, *optional*, defaults to 151342):\n+            The video end token index to encode the end of video.\n+\n+    ```python\n+    >>> from transformers import Glm4vForConditionalGeneration, Glm4vConfig\n+\n+    >>> # Initializing a GLM-4.1V style configuration\n+    >>> configuration = Glm4vConfig()\n+\n+    >>> # Initializing a model from the GLM-4.1V style configuration\n+    >>> model = Glm4vForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    def __init__(\n+        self,\n+        text_config=None,\n+        vision_config=None,\n+        image_token_id=151343,\n+        video_token_id=151344,\n+        image_start_token_id=151339,\n+        image_end_token_id=151340,\n+        video_start_token_id=151341,\n+        video_end_token_id=151342,\n+        **kwargs,\n+    ):\n+        super().__init__()\n+        self.video_start_token_id = video_start_token_id\n+        self.video_end_token_id = video_end_token_id\n+        self.image_start_token_id = image_start_token_id\n+        self.image_end_token_id = image_end_token_id\n+\n+\n+# Will be used for both Text and Vision modalities\n+class Glm4vRMSNorm(Glm4RMSNorm):\n+    pass\n+\n+\n+class Glm4VisionMlp(Qwen2_5_VLMLP):\n+    def __init__(self, config, bias: bool = False):\n+        super().__init__(config, bias)\n+        self.intermediate_size = config.out_hidden_size\n+\n+\n+class Glm4vVisionPatchEmbed(Qwen2_5_VisionPatchEmbed):\n+    def __init__(self, config: Glm4vVisionConfig) -> None:\n+        Qwen2_5_VisionPatchEmbed.__init__()\n+        self.patch_size = config.patch_size\n+        self.temporal_patch_size = config.temporal_patch_size\n+        self.in_channels = config.in_channels\n+        self.embed_dim = config.hidden_size\n+\n+        kernel_size = [self.temporal_patch_size, self.patch_size, self.patch_size]\n+        self.proj = nn.Conv3d(self.in_channels, self.embed_dim, kernel_size=kernel_size, stride=kernel_size)\n+\n+\n+class Glm4vVisionRotaryEmbedding(Qwen2_5_VisionRotaryEmbedding):\n+    pass\n+\n+\n+class Glm4vVisionPatchMerger(nn.Module):\n+    def __init__(self, dim: int, context_dim: int, hidden_act: str, bias: bool = False) -> None:\n+        super().__init__()\n+        self.proj = nn.Linear(dim, dim, bias=bias)\n+        self.post_projection_norm = LayerNorm(dim)\n+        self.gate_proj = nn.Linear(dim, context_dim, bias=bias)\n+        self.up_proj = nn.Linear(dim, context_dim, bias=bias)\n+        self.down_proj = nn.Linear(context_dim, dim, bias=bias)\n+        self.act1 = nn.GELU()\n+        self.act_fn = ACT2FN[hidden_act]\n+\n+    def forward(self, hidden_state: torch.Tensor) -> torch.Tensor:\n+        hidden_state = self.proj(hidden_state)\n+        hidden_state = self.act1(self.post_projection_norm(hidden_state))\n+        return self.down_proj(self.act_fn(self.gate_proj(hidden_state)) * self.up_proj(hidden_state))\n+\n+\n+class Glm4vVisionEmbeddings(nn.Module):\n+    def __init__(self, config: Glm4vVisionConfig):\n+        super().__init__()\n+        self.config = config\n+        self.embed_dim = config.hidden_size\n+        self.image_size = config.image_size\n+        self.patch_size = config.patch_size\n+\n+        self.num_patches = (self.image_size // self.patch_size) ** 2\n+        self.num_positions = self.num_patches\n+        self.position_embedding = nn.Embedding(self.num_positions, self.embed_dim)\n+        self.register_buffer(\"position_ids\", torch.arange(self.num_positions).expand((1, -1)), persistent=False)\n+\n+    def forward(self, embeddings, lengths, image_shapes, h_coords, w_coords) -> torch.Tensor:\n+        \"\"\"\n+        Forward pass with integrated position encoding adaptation using 2D interpolation.\n+\n+        Args:\n+            embeddings: Input embeddings tensor\n+            lengths (torch.Tensor): Sequence lengths for each image in the batch.\n+            image_shapes (torch.Tensor): Tensor of shape [batch_size, 3] representing the image shapes (t, h, w).\n+            h_coords (torch.Tensor): Tensor of shape [total_seq] representing the h coordinate for each patch.\n+            w_coords (torch.Tensor): Tensor of shape [total_seq] representing the w coordinate for each patch.\n+\n+        Returns:\n+            torch.Tensor: Embeddings with adapted position encoding added.\n+        \"\"\"\n+        # Get position embedding parameters\n+        pos_embed_weight = self.position_embedding.weight\n+        hidden_size = pos_embed_weight.shape[1]\n+        total_seq = h_coords.shape[0]\n+        device = pos_embed_weight.device\n+\n+        # Move coordinates to correct device\n+        h_coords, w_coords = h_coords.to(device), w_coords.to(device)\n+\n+        # Handle empty sequence case\n+        if total_seq == 0:\n+            adapted_pos_embed = torch.empty(0, hidden_size, device=device, dtype=pos_embed_weight.dtype)\n+        else:\n+            # Convert inputs to tensors if needed\n+            if isinstance(lengths, list):\n+                lengths = torch.tensor(lengths, device=device, dtype=torch.long)\n+            if not isinstance(image_shapes, torch.Tensor):\n+                image_shapes = torch.tensor(image_shapes, device=device, dtype=torch.long)\n+\n+            # Prepare 2D position embedding\n+            orig_size_sq = pos_embed_weight.shape[0]\n+            orig_size = int(orig_size_sq**0.5)\n+            pos_embed_2d = (\n+                pos_embed_weight.view(orig_size, orig_size, hidden_size)\n+                .permute(2, 0, 1)\n+                .unsqueeze(0)\n+                .to(device=device, dtype=torch.float32)\n+            )\n+\n+            # Calculate target dimensions for each patch\n+            target_h = torch.cat([image_shapes[i, 1].repeat(lengths[i]) for i in range(len(lengths))]).to(\n+                device=device, dtype=torch.float32\n+            )\n+            target_w = torch.cat([image_shapes[i, 2].repeat(lengths[i]) for i in range(len(lengths))]).to(\n+                device=device, dtype=torch.float32\n+            )\n+\n+            # Normalize coordinates to [-1, 1] range for grid_sample\n+            h_coords = h_coords.to(device=device, dtype=torch.float32)\n+            w_coords = w_coords.to(device=device, dtype=torch.float32)\n+            norm_w = ((w_coords + 0.5) / target_w) * 2 - 1\n+            norm_h = ((h_coords + 0.5) / target_h) * 2 - 1\n+\n+            # Create sampling grid\n+            grid = torch.stack((norm_w, norm_h), dim=-1).unsqueeze(0).unsqueeze(2)\n+\n+            # Perform bicubic interpolation\n+            interpolated_embed_fp32 = F.grid_sample(\n+                pos_embed_2d, grid, mode=\"bicubic\", align_corners=False, padding_mode=\"border\"\n+            )\n+\n+            # Reshape and convert back to original dtype\n+            adapted_pos_embed_fp32 = interpolated_embed_fp32.squeeze(0).squeeze(-1).permute(1, 0)\n+            adapted_pos_embed = adapted_pos_embed_fp32.to(pos_embed_weight.dtype).to(embeddings.device)\n+\n+        # Add adapted position encoding to embeddings\n+        embeddings = embeddings + adapted_pos_embed\n+        return embeddings\n+\n+\n+class Glm4vVisionAttention(nn.Module):\n+    def __init__(self, config: Glm4vVisionConfig) -> None:\n+        super().__init__()\n+        self.config = config\n+        self.num_heads = config.num_heads\n+        self.head_dim = config.hidden_size // self.num_heads\n+        self.num_key_value_groups = 1\n+        self.scale = self.head_dim**-0.5\n+        self.attention_dropout = config.attention_dropout\n+        self.qkv = nn.Linear(config.hidden_size, config.hidden_size * 3, bias=config.attention_bias)\n+        self.proj = nn.Linear(config.hidden_size, config.hidden_size, bias=False)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cu_seqlens: torch.Tensor,\n+        rotary_pos_emb: Optional[torch.Tensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> torch.Tensor:\n+        seq_length = hidden_states.shape[0]\n+        query_states, key_states, value_states = (\n+            self.qkv(hidden_states).reshape(seq_length, 3, self.num_heads, -1).permute(1, 0, 2, 3).unbind(0)\n+        )\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb_vision(query_states, key_states, cos, sin)\n+\n+        query_states = query_states.transpose(0, 1).unsqueeze(0)\n+        key_states = key_states.transpose(0, 1).unsqueeze(0)\n+        value_states = value_states.transpose(0, 1).unsqueeze(0)\n+\n+        attention_mask = torch.zeros([1, 1, seq_length, seq_length], device=query_states.device, dtype=torch.bool)\n+        for i in range(1, len(cu_seqlens)):\n+            attention_mask[..., cu_seqlens[i - 1] : cu_seqlens[i], cu_seqlens[i - 1] : cu_seqlens[i]] = True\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, _ = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scale,\n+            is_causal=False,\n+            **kwargs,\n+        )\n+        attn_output = attn_output.squeeze(0)\n+        attn_output = attn_output.reshape(seq_length, -1).contiguous()\n+        attn_output = self.proj(attn_output)\n+        return attn_output\n+\n+\n+class Glm4vVisionBlock(Qwen2_5_VLVisionBlock):\n+    def __init__(self, config) -> None:\n+        super().__init__()\n+        self.norm1 = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.norm2 = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.attn = Glm4vVisionAttention(config)\n+        self.mlp = Glm4VisionMlp(config, bias=False)\n+\n+\n+class Glm4vPreTrainedModel(Qwen2_5_VLPreTrainedModel):\n+    _no_split_modules = [\"Glm4vTextDecoderLayer\", \"Glm4vVisionBlock\"]\n+\n+    def _init_weights(self, module):\n+        std = self.config.get_text_config().initializer_range\n+        if isinstance(module, (nn.Linear, nn.Conv2d, nn.Conv3d)):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+        elif isinstance(module, Glm4vRMSNorm):\n+            module.weight.data.fill_(1.0)\n+        elif isinstance(module, nn.LayerNorm):\n+            module.weight.data.fill_(1.0)\n+            module.bias.data.zero_()\n+\n+\n+class Glm4vVisionModel(Glm4vPreTrainedModel):\n+    config_class = Glm4vVisionConfig\n+    _no_split_modules = [\"Glm4vVisionBlock\"]\n+\n+    def __init__(self, config) -> None:\n+        super().__init__(config)\n+        self.spatial_merge_size = config.spatial_merge_size\n+        self.patch_size = config.patch_size\n+\n+        self.embeddings = Glm4vVisionEmbeddings(config)\n+        self.patch_embed = Glm4vVisionPatchEmbed(config)\n+\n+        head_dim = config.hidden_size // config.num_heads\n+        self.rotary_pos_emb = Glm4vVisionRotaryEmbedding(head_dim // 2)\n+\n+        self.blocks = nn.ModuleList([Glm4vVisionBlock(config) for _ in range(config.depth)])\n+        self.merger = Glm4vVisionPatchMerger(\n+            dim=config.out_hidden_size, context_dim=config.intermediate_size, hidden_act=config.hidden_act\n+        )\n+\n+        self.post_conv_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.downsample = nn.Conv2d(\n+            in_channels=config.hidden_size,\n+            out_channels=config.out_hidden_size,\n+            kernel_size=config.spatial_merge_size,\n+            stride=config.spatial_merge_size,\n+        )\n+        self.post_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+        self.gradient_checkpointing = False\n+        self.post_init()\n+\n+    def rot_pos_emb(self, grid_thw):\n+        pos_ids = []\n+        for t, h, w in grid_thw:\n+            hpos_ids = torch.arange(h).unsqueeze(1).expand(-1, w)\n+            hpos_ids = hpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            hpos_ids = hpos_ids.permute(0, 2, 1, 3)\n+            hpos_ids = hpos_ids.flatten()\n+\n+            wpos_ids = torch.arange(w).unsqueeze(0).expand(h, -1)\n+            wpos_ids = wpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            wpos_ids = wpos_ids.permute(0, 2, 1, 3)\n+            wpos_ids = wpos_ids.flatten()\n+            pos_ids.append(torch.stack([hpos_ids, wpos_ids], dim=-1).repeat(t, 1))\n+        pos_ids = torch.cat(pos_ids, dim=0)\n+        max_grid_size = grid_thw[:, 1:].max()\n+        rotary_pos_emb_full = self.rotary_pos_emb(max_grid_size)\n+        rotary_pos_emb = rotary_pos_emb_full[pos_ids].flatten(1)\n+        return rotary_pos_emb, pos_ids\n+\n+    def forward(self, hidden_states: torch.Tensor, grid_thw: torch.Tensor) -> torch.Tensor:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.Tensor` of shape `(seq_len, hidden_size)`):\n+                The final hidden states of the model.\n+            grid_thw (`torch.Tensor` of shape `(num_images_or_videos, 3)`):\n+                The temporal, height and width of feature shape of each image in LLM.\n+\n+        Returns:\n+            `torch.Tensor`: hidden_states.\n+        \"\"\"\n+        hidden_states = self.patch_embed(hidden_states)\n+        hidden_states = self.post_conv_layernorm(hidden_states)\n+\n+        rotary_pos_emb, image_type_ids = self.rot_pos_emb(grid_thw)\n+        emb = torch.cat((rotary_pos_emb, rotary_pos_emb), dim=-1)\n+        position_embeddings = (emb.cos(), emb.sin())\n+\n+        cu_seqlens = torch.repeat_interleave(grid_thw[:, 1] * grid_thw[:, 2], grid_thw[:, 0]).cumsum(\n+            dim=0,\n+            # Select dtype based on the following factors:\n+            #  - FA2 requires that cu_seqlens_q must have dtype int32\n+            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n+            # See https://github.com/huggingface/transformers/pull/34852 for more information\n+            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_seqlens = F.pad(cu_seqlens, (1, 0), value=0)\n+        seqlens = (cu_seqlens[1:] - cu_seqlens[:-1]).tolist()\n+        hidden_states = self.embeddings(hidden_states, seqlens, grid_thw, image_type_ids[:, 0], image_type_ids[:, 1])\n+\n+        for blk in self.blocks:\n+            if self.gradient_checkpointing and self.training:\n+                hidden_states = self._gradient_checkpointing_func(\n+                    blk.__call__, hidden_states, cu_seqlens, None, position_embeddings\n+                )\n+            else:\n+                hidden_states = blk(hidden_states, cu_seqlens=cu_seqlens, position_embeddings=position_embeddings)\n+\n+        hidden_states = self.post_layernorm(hidden_states)\n+\n+        hidden_states = hidden_states.view(\n+            -1, self.spatial_merge_size, self.spatial_merge_size, hidden_states.shape[-1]\n+        )\n+        hidden_states = hidden_states.permute(0, 3, 1, 2)\n+        hidden_states = self.downsample(hidden_states).view(-1, self.config.out_hidden_size)\n+\n+        hidden_states = self.merger(hidden_states)\n+        return hidden_states\n+\n+\n+class Glm4vTextRotaryEmbedding(Qwen2_5_VLRotaryEmbedding):\n+    pass\n+\n+\n+def rotate_half_llm(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., 0::2]\n+    x2 = x[..., 1::2]\n+    return torch.stack((-x2, x1), dim=-1).flatten(-2)\n+\n+\n+def apply_multimodal_rotary_pos_emb(q, k, cos, sin, mrope_section, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding with Multimodal Sections to the query and key tensors (https://qwenlm.github.io/blog/qwen2-vl/).\n+\n+    Explanation:\n+        Multimodal 3D rotary position embedding is an extension to 1D rotary position embedding. The input embedding\n+        sequence contains vision (images / videos) embedding and text embedding or just contains text embedding. For\n+        vision embedding part, we apply rotary position embedding on temporal, height and width dimension separately.\n+        Here we split the channel dimension to 3 chunks for the temporal, height and width rotary position embedding.\n+        For text embedding part, we just apply 1D rotary position embedding. The three rotary position index (temporal,\n+        height and width) of text embedding is always the same, so the text embedding rotary position embedding has no\n+        difference with modern LLMs.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        mrope_section(`List(int)`):\n+            Multimodal rope section is for channel dimension of temporal, height and width in rope calculation.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    mrope_section = mrope_section * 2\n+    cos = torch.cat([m[i % 3] for i, m in enumerate(cos.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+    sin = torch.cat([m[i % 3] for i, m in enumerate(sin.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+\n+    # Interleave them instead of usual shape\n+    cos = cos[..., : cos.shape[-1] // 2].repeat_interleave(2, dim=-1)\n+    sin = sin[..., : sin.shape[-1] // 2].repeat_interleave(2, dim=-1)\n+\n+    # Keep half or full tensor for later concatenation\n+    rotary_dim = cos.shape[-1]\n+    q_rot, q_pass = q[..., :rotary_dim], q[..., rotary_dim:]\n+    k_rot, k_pass = k[..., :rotary_dim], k[..., rotary_dim:]\n+\n+    # Apply rotary embeddings on the first half or full tensor\n+    q_embed = (q_rot * cos) + (rotate_half_llm(q_rot) * sin)\n+    k_embed = (k_rot * cos) + (rotate_half_llm(k_rot) * sin)\n+\n+    # Concatenate back to full shape\n+    q_embed = torch.cat([q_embed, q_pass], dim=-1)\n+    k_embed = torch.cat([k_embed, k_pass], dim=-1)\n+\n+    return q_embed, k_embed\n+\n+\n+class Glm4vTextAttention(nn.Module):\n+    \"\"\"\n+    Multi-headed attention from 'Attention Is All You Need' paper.\n+    and \"Generating Long Sequences with Sparse Transformers\".\n+    \"\"\"\n+\n+    def __init__(self, config: Glm4vTextConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+\n+        self.hidden_size = config.hidden_size\n+        self.num_heads = config.num_attention_heads\n+        self.head_dim = self.hidden_size // self.num_heads\n+        self.num_key_value_heads = config.num_key_value_heads\n+        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n+        self.is_causal = True\n+        self.attention_dropout = config.attention_dropout\n+        self.rope_scaling = config.rope_scaling\n+        self.scaling = self.head_dim**-0.5\n+\n+        self.q_proj = nn.Linear(self.hidden_size, self.num_heads * self.head_dim, bias=True)\n+        self.k_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=True)\n+        self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=True)\n+        self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=False)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor], Optional[tuple[torch.Tensor]]]:\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_multimodal_rotary_pos_emb(  # diff with Llama\n+            query_states, key_states, cos, sin, self.rope_scaling[\"mrope_section\"]\n+        )\n+\n+        if past_key_value is not None:\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}  # Specific to RoPE models\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(bsz, q_len, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights, past_key_value\n+\n+\n+class Glm4vTextMLP(Glm4MLP):\n+    pass\n+\n+\n+class Glm4vTextDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: Glm4vTextConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+        self.self_attn = Glm4vTextAttention(config, layer_idx)\n+        self.mlp = Glm4vTextMLP(config)\n+        self.input_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_self_attn_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_mlp_layernorm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[tuple[torch.Tensor]] = None,\n+        output_attentions: Optional[bool] = False,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> tuple[torch.FloatTensor, Optional[tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        residual = hidden_states\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # Self Attention\n+        hidden_states, self_attn_weights, present_key_value = self.self_attn(\n+            hidden_states=hidden_states,\n+            position_embeddings=position_embeddings,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+        )\n+\n+        hidden_states = self.post_self_attn_layernorm(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = self.post_mlp_layernorm(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        outputs = (hidden_states,)\n+\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        if use_cache:\n+            outputs += (present_key_value,)\n+\n+        return outputs\n+\n+\n+class KwargsForCausalLM(FlashAttentionKwargs, LossKwargs): ...\n+\n+\n+class Glm4vModelOutputWithPast(Qwen2_5_VLModelOutputWithPast):\n+    pass\n+\n+\n+class Glm4vTextModel(Qwen2_5_VLTextModel):\n+    def __init__(self, config: Glm4vTextConfig):\n+        super().__init__(config)\n+        self.layers = nn.ModuleList(\n+            [Glm4vTextDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = Glm4vRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = Glm4vTextRotaryEmbedding(config=config)\n+        del self._attn_implementation\n+        del self.has_sliding_layers\n+\n+    @auto_docstring\n+    @can_return_tuple\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Union[tuple, BaseModelOutputWithPast]:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if self.gradient_checkpointing and self.training:\n+            if use_cache:\n+                logger.warning_once(\n+                    \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n+                )\n+                use_cache = False\n+\n+        # torch.jit.trace() doesn't support cache objects in the output\n+        if use_cache and past_key_values is None and not torch.jit.is_tracing():\n+            past_key_values = DynamicCache()\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        # the hard coded `3` is for temporal, height and width.\n+        if position_ids is None:\n+            position_ids = cache_position.view(1, 1, -1).expand(3, inputs_embeds.shape[0], -1)\n+        elif position_ids.dim() == 2:\n+            position_ids = position_ids[None, ...].expand(3, position_ids.shape[0], -1)\n+\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+        )\n+\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+\n+        for decoder_layer in self.layers:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            layer_outputs = decoder_layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=causal_mask,\n+                position_ids=position_ids,\n+                past_key_value=past_key_values,\n+                output_attentions=output_attentions,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        # add hidden states from the last decoder layer\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values if use_cache else None,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+        )\n+\n+\n+class Glm4vModel(Qwen2_5_VLModel):\n+    _checkpoint_conversion_mapping = None\n+    _no_split_modules = [\"Glm4vTextDecoderLayer\", \"Glm4vVisionBlock\"]\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.visual = Glm4vVisionModel._from_config(config.vision_config)\n+\n+    def get_rope_index(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Calculate the 3D rope index based on image and video's temporal, height and width in LLM.\n+\n+        Explanation:\n+            Each embedding sequence contains vision embedding and text embedding or just contains text embedding.\n+\n+            For pure text embedding sequence, the rotary position embedding has no difference with modern LLMs.\n+            Examples:\n+                input_ids: [T T T T T], here T is for text.\n+                temporal position_ids: [0, 1, 2, 3, 4]\n+                height position_ids: [0, 1, 2, 3, 4]\n+                width position_ids: [0, 1, 2, 3, 4]\n+\n+            For vision and text embedding sequence, we calculate 3D rotary position embedding for vision part\n+            and 1D rotary position embedding for text part.\n+            Examples:\n+                Temporal (Time): 3 patches, representing different segments of the video in time.\n+                Height: 2 patches, dividing each frame vertically.\n+                Width: 2 patches, dividing each frame horizontally.\n+                We also have some important parameters:\n+                fps (Frames Per Second): The video's frame rate, set to 1. This means one frame is processed each second.\n+                tokens_per_second: This is a crucial parameter. It dictates how many \"time-steps\" or \"temporal tokens\" are conceptually packed into a one-second interval of the video. In this case, we have 25 tokens per second. So each second of the video will be represented with 25 separate time points. It essentially defines the temporal granularity.\n+                temporal_patch_size: The number of frames that compose one temporal patch. Here, it's 2 frames.\n+                interval: The step size for the temporal position IDs, calculated as tokens_per_second * temporal_patch_size / fps. In this case, 25 * 2 / 1 = 50. This means that each temporal patch will be have a difference of 50 in the temporal position IDs.\n+                input_ids: [V V V V V V V V V V V V T T T T T], here V is for vision.\n+                vision temporal position_ids: [0, 0, 0, 0, 50, 50, 50, 50, 100, 100, 100, 100]\n+                vision height position_ids: [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]\n+                vision width position_ids: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n+                text temporal position_ids: [101, 102, 103, 104, 105]\n+                text height position_ids: [101, 102, 103, 104, 105]\n+                text width position_ids: [101, 102, 103, 104, 105]\n+                Here we calculate the text start position_ids as the max vision position_ids plus 1.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+                it.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+\n+        Returns:\n+            position_ids (`torch.LongTensor` of shape `(3, batch_size, sequence_length)`)\n+            mrope_position_deltas (`torch.Tensor` of shape `(batch_size)`)\n+        \"\"\"\n+\n+        spatial_merge_size = self.config.vision_config.spatial_merge_size\n+        image_token_id = self.config.image_token_id\n+        video_start_token_id = self.config.video_start_token_id\n+        video_end_token_id = self.config.video_end_token_id\n+\n+        mrope_position_deltas = []\n+        if input_ids is not None and (image_grid_thw is not None or video_grid_thw is not None):\n+            total_input_ids = input_ids\n+            if attention_mask is None:\n+                attention_mask = torch.ones_like(total_input_ids)\n+            position_ids = torch.ones(\n+                3,\n+                input_ids.shape[0],\n+                input_ids.shape[1],\n+                dtype=input_ids.dtype,\n+                device=input_ids.device,\n+            )\n+\n+            attention_mask = attention_mask.to(total_input_ids.device)\n+            for i, input_ids in enumerate(total_input_ids):\n+                input_ids = input_ids[attention_mask[i] == 1]\n+                input_tokens = input_ids.tolist()\n+\n+                input_token_type = []\n+                video_check_flg = False\n+                for token in input_tokens:\n+                    if token == video_start_token_id:\n+                        video_check_flg = True\n+                    elif token == video_end_token_id:\n+                        video_check_flg = False\n+\n+                    if token == image_token_id and not video_check_flg:\n+                        input_token_type.append(\"image\")\n+                    elif token == image_token_id and video_check_flg:\n+                        input_token_type.append(\"video\")\n+                    else:\n+                        input_token_type.append(\"text\")\n+\n+                input_type_group = []\n+                for key, group in itertools.groupby(enumerate(input_token_type), lambda x: x[1]):\n+                    group = list(group)\n+                    start_index = group[0][0]\n+                    end_index = group[-1][0] + 1\n+                    input_type_group.append((key, start_index, end_index))\n+\n+                llm_pos_ids_list = []\n+                video_frame_num = 1\n+                image_index, video_index = 0, 0\n+\n+                for modality_type, start_idx, end_idx in input_type_group:\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+\n+                    if modality_type == \"image\":\n+                        t, h, w = (\n+                            image_grid_thw[image_index][0],\n+                            image_grid_thw[image_index][1],\n+                            image_grid_thw[image_index][2],\n+                        )\n+                        llm_grid_t, llm_grid_h, llm_grid_w = (\n+                            t.item(),\n+                            h.item() // spatial_merge_size,\n+                            w.item() // spatial_merge_size,\n+                        )\n+\n+                        t_index = torch.arange(llm_grid_t).view(-1, 1).expand(-1, llm_grid_h * llm_grid_w).flatten()\n+                        h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(llm_grid_t, -1, llm_grid_w).flatten()\n+                        w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(llm_grid_t, llm_grid_h, -1).flatten()\n+                        llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + st_idx)\n+\n+                        image_index += 1\n+                        video_frame_num = 1\n+\n+                    elif modality_type == \"video\":\n+                        t, h, w = (\n+                            video_frame_num,\n+                            video_grid_thw[video_index][1],\n+                            video_grid_thw[video_index][2],\n+                        )\n+\n+                        llm_grid_t, llm_grid_h, llm_grid_w = (\n+                            t,\n+                            h.item() // spatial_merge_size,\n+                            w.item() // spatial_merge_size,\n+                        )\n+\n+                        for t_idx in range(llm_grid_t):\n+                            t_index = torch.tensor(t_idx).view(-1, 1).expand(-1, llm_grid_h * llm_grid_w).flatten()\n+\n+                            h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(1, -1, llm_grid_w).flatten()\n+\n+                            w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(1, llm_grid_h, -1).flatten()\n+\n+                            llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + st_idx)\n+\n+                        video_index += 1\n+\n+                        video_frame_num += 1\n+\n+                    else:\n+                        text_len = end_idx - start_idx\n+                        llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                        video_frame_num = 1\n+\n+                llm_positions = torch.cat(llm_pos_ids_list, dim=1).reshape(3, -1)\n+                position_ids[..., i, attention_mask[i] == 1] = llm_positions.to(position_ids.device)\n+                mrope_position_deltas.append(llm_positions.max() + 1 - len(total_input_ids[i]))\n+            mrope_position_deltas = torch.tensor(mrope_position_deltas, device=input_ids.device).unsqueeze(1)\n+            return position_ids, mrope_position_deltas\n+        else:\n+            if attention_mask is not None:\n+                position_ids = attention_mask.long().cumsum(-1) - 1\n+                position_ids.masked_fill_(attention_mask == 0, 1)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1).to(attention_mask.device)\n+                max_position_ids = position_ids.max(0, keepdim=False)[0].max(-1, keepdim=True)[0]\n+                mrope_position_deltas = max_position_ids + 1 - attention_mask.shape[-1]\n+            else:\n+                position_ids = (\n+                    torch.arange(input_ids.shape[1], device=input_ids.device)\n+                    .view(1, 1, -1)\n+                    .expand(3, input_ids.shape[0], -1)\n+                )\n+                mrope_position_deltas = torch.zeros(\n+                    [input_ids.shape[0], 1],\n+                    device=input_ids.device,\n+                    dtype=input_ids.dtype,\n+                )\n+\n+            return position_ids, mrope_position_deltas\n+\n+    @auto_docstring\n+    @can_return_tuple\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[KwargsForCausalLM],\n+    ) -> Union[tuple, Glm4vModelOutputWithPast]:\n+        r\"\"\"\n+        pixel_values_videos (`torch.FloatTensor` of shape `(seq_length, num_channels * temporal_size * image_size * image_size)):\n+            The tensors corresponding to the input videos. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`Glm4vImageProcessor.__call__`] for details. [`Glm4vProcessor`] uses\n+            [`Glm4vImageProcessor`] for processing videos.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+        \"\"\"\n+\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if pixel_values is not None and inputs_embeds is not None:\n+            raise ValueError(\n+                \"You cannot specify both pixel_values and inputs_embeds at the same time, and must specify either one\"\n+            )\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.get_input_embeddings()(input_ids)\n+\n+        if pixel_values is not None:\n+            image_embeds = self.get_image_features(pixel_values, image_grid_thw)\n+            image_embeds = torch.cat(image_embeds, dim=0)\n+            n_image_tokens = (input_ids == self.config.image_token_id).sum()\n+            n_image_features = image_embeds.shape[0]\n+            if not is_torchdynamo_compiling() and n_image_tokens != n_image_features:\n+                raise ValueError(\n+                    f\"Image features and image tokens do not match: tokens: {n_image_tokens}, features {n_image_features}\"\n+                )\n+\n+            mask = input_ids == self.config.image_token_id\n+            mask_unsqueezed = mask.unsqueeze(-1)\n+            mask_expanded = mask_unsqueezed.expand_as(inputs_embeds)\n+            image_mask = mask_expanded.to(inputs_embeds.device)\n+            image_embeds = image_embeds.to(inputs_embeds.device, inputs_embeds.dtype)\n+            inputs_embeds = inputs_embeds.masked_scatter(image_mask, image_embeds)\n+\n+        if pixel_values_videos is not None:\n+            video_embeds = self.get_video_features(pixel_values_videos, video_grid_thw)\n+            video_embeds = torch.cat(video_embeds, dim=0)\n+            n_video_tokens = (input_ids == self.config.image_token_id).sum()\n+            n_video_features = video_embeds.shape[0]\n+            if not is_torchdynamo_compiling() and n_video_tokens != n_video_features:\n+                raise ValueError(\n+                    f\"Video features and video tokens do not match: tokens: {n_video_tokens}, features {n_video_features}\"\n+                )\n+\n+            mask = input_ids == self.config.image_token_id  # GLM-4.1V use image_token_id for video\n+            mask_unsqueezed = mask.unsqueeze(-1)\n+            mask_expanded = mask_unsqueezed.expand_as(inputs_embeds)\n+            video_mask = mask_expanded.to(inputs_embeds.device)\n+            video_embeds = video_embeds.to(inputs_embeds.device, inputs_embeds.dtype)\n+            inputs_embeds = inputs_embeds.masked_scatter(video_mask, video_embeds)\n+\n+        if position_ids is None:\n+            attention_mask_tensor = attention_mask\n+            if attention_mask_tensor is not None and attention_mask_tensor.ndim == 4:\n+                attention_mask_tensor = torch.diagonal(attention_mask_tensor[:, 0], dim1=1, dim2=2)\n+                attention_mask_tensor = attention_mask_tensor / torch.finfo(attention_mask_tensor.dtype).min\n+                attention_mask_tensor = (1.0 - attention_mask_tensor).int()\n+\n+            # Calculate RoPE index once per generation in the pre-fill stage only.\n+            # When compiling, we can't check tensor values thus we check only input length\n+            # It is safe to assume that `length!=1` means we're in pre-fill because compiled\n+            # models currently cannot do asssisted decoding\n+            prefill_compiled_stage = is_torchdynamo_compiling() and (\n+                (input_ids is not None and input_ids.shape[1] != 1)\n+                or (inputs_embeds is not None and inputs_embeds.shape[1] != 1)\n+            )\n+            prefill_noncompiled_stage = not is_torchdynamo_compiling() and (\n+                (cache_position is not None and cache_position[0] == 0)\n+                or (past_key_values is None or past_key_values.get_seq_length() == 0)\n+            )\n+            if (prefill_compiled_stage or prefill_noncompiled_stage) or self.rope_deltas is None:\n+                position_ids, rope_deltas = self.get_rope_index(\n+                    input_ids,\n+                    image_grid_thw,\n+                    video_grid_thw,\n+                    attention_mask=attention_mask_tensor,\n+                )\n+                self.rope_deltas = rope_deltas\n+            # then use the prev pre-calculated rope-deltas to get the correct position ids\n+            else:\n+                batch_size, seq_length, _ = inputs_embeds.shape\n+                delta = (\n+                    (cache_position[0] + self.rope_deltas).to(inputs_embeds.device)\n+                    if cache_position is not None\n+                    else 0\n+                )\n+                position_ids = torch.arange(seq_length, device=inputs_embeds.device)\n+                position_ids = position_ids.view(1, -1).expand(batch_size, -1)\n+                if cache_position is not None:  # otherwise `deltas` is an int `0`\n+                    delta = delta.repeat_interleave(batch_size // delta.shape[0], dim=0)\n+                position_ids = position_ids.add(delta)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1)\n+\n+        outputs = self.language_model(\n+            input_ids=None,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=True,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        return Glm4vModelOutputWithPast(\n+            last_hidden_state=outputs.last_hidden_state,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=self.rope_deltas,\n+        )\n+\n+\n+class Glm4vCausalLMOutputWithPast(Qwen2_5_VLCausalLMOutputWithPast):\n+    pass\n+\n+\n+class Glm4vForConditionalGeneration(Qwen2_5_VLForConditionalGeneration):\n+    _checkpoint_conversion_mapping = None\n+\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[list[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[KwargsForCausalLM],\n+    ) -> Union[tuple, Glm4vCausalLMOutputWithPast]:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+        pixel_values_videos (`torch.FloatTensor` of shape `(seq_length, num_channels * temporal_size * image_size * image_size)):\n+            The tensors corresponding to the input videos. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`Glm4vImageProcessor.__call__`] for details. [`Glm4vProcessor`] uses\n+            [`Glm4vImageProcessor`] for processing videos.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+\n+        Example:\n+\n+        ```python\n+        >>> from PIL import Image\n+        >>> import requests\n+        >>> from transformers import AutoProcessor, Glm4vForConditionalGeneration\n+\n+        >>> model = Glm4vForConditionalGeneration.from_pretrained(\"THUDM/GLM-4.1V-9B-Thinking\")\n+        >>> processor = AutoProcessor.from_pretrained(\"THUDM/GLM-4.1V-9B-Thinking\")\n+\n+        >>> messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\"},\n+                    {\"type\": \"text\", \"text\": \"What is shown in this image?\"},\n+                ],\n+            },\n+        ]\n+        >>> url = \"https://www.ilankelman.org/stopsigns/australia.jpg\"\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> text = processor.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\n+        >>> inputs = processor(text=[text], images=[image], vision_infos=[vision_infos])\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"The image shows a street scene with a red stop sign in the foreground. In the background, there is a large red gate with Chinese characters ...\"\n+        ```\"\"\"\n+\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            pixel_values=pixel_values,\n+            pixel_values_videos=pixel_values_videos,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs[0]\n+        logits = self.lm_head(hidden_states)\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits=logits, labels=labels, vocab_size=self.config.text_config.vocab_size)\n+\n+        return Glm4vCausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=outputs.rope_deltas,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        attention_mask=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        position_ids=None,\n+        use_cache=True,\n+        pixel_values=None,\n+        pixel_values_videos=None,\n+        image_grid_thw=None,\n+        video_grid_thw=None,\n+        **kwargs,\n+    ):\n+        # Overwritten -- in specific circumstances we don't want to forward image inputs to the model\n+\n+        model_inputs = super().prepare_inputs_for_generation(\n+            input_ids,\n+            past_key_values=past_key_values,\n+            attention_mask=attention_mask,\n+            inputs_embeds=inputs_embeds,\n+            cache_position=cache_position,\n+            position_ids=position_ids,\n+            pixel_values=pixel_values,\n+            pixel_values_videos=pixel_values_videos,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            use_cache=use_cache,\n+            **kwargs,\n+        )\n+\n+        # GLM-4.1V position_ids are prepareed with rope_deltas in forward\n+        model_inputs[\"position_ids\"] = None\n+\n+        if cache_position[0] != 0:\n+            model_inputs[\"pixel_values\"] = None\n+            model_inputs[\"pixel_values_videos\"] = None\n+\n+        return model_inputs\n+\n+    def _get_image_nums_and_video_nums(\n+        self,\n+        input_ids: Optional[torch.LongTensor],\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Get the number of images and videos for each sample to calculate the separation length of the sample tensor.\n+        These parameters are not passed through the processor to avoid unpredictable impacts from interface modifications.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary.\n+\n+        Returns:\n+            image_nums (`torch.LongTensor` of shape `(batch_size, num_images_sample)`)\n+            video_nums (`torch.LongTensor` of shape `(batch_size, num_videos_sample)`)\n+        \"\"\"\n+\n+        is_image = input_ids == self.config.image_start_token_id\n+        is_video_start = input_ids == self.config.video_start_token_id\n+        is_video_end = input_ids == self.config.video_end_token_id\n+\n+        # Cumulative sum to track if we're inside a video span\n+        # We'll assume well-formed video tags (i.e. matching starts and ends)\n+        video_level = torch.cumsum(is_video_start.int() - is_video_end.int(), dim=1)\n+        inside_video = video_level > 0  # shape (batch_size, seq_length)\n+\n+        # Mask out image tokens that are inside video spans\n+        standalone_images = is_image & (~inside_video)\n+\n+        # Count per batch\n+        image_counts = standalone_images.sum(dim=1)\n+        video_counts = is_video_start.sum(dim=1)\n+\n+        return image_counts, video_counts\n+\n+\n+class Glm4vVideosProcessorKwargs(Qwen2_5_VLVideosProcessorKwargs):\n+    pass\n+\n+\n+class Glm4vImagesKwargs(ImagesKwargs):\n+    patch_size: Optional[int]\n+    temporal_patch_size: Optional[int]\n+    merge_size: Optional[int]\n+\n+\n+class Glm4vProcessorKwargs(Qwen2_5_VLProcessorKwargs):\n+    images_kwargs: Glm4vImagesKwargs\n+    videos_kwargs: Glm4vVideosProcessorKwargs\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": False,\n+        },\n+    }\n+\n+\n+class Glm4vProcessor(Qwen2_5_VLProcessor):\n+    r\"\"\"\n+    Constructs a GLM-4V processor which wraps a GLM-4V image processor and a GLM-4 tokenizer into a single processor.\n+    [`~Glm4vProcessor.__call__`] and [`~Glm4vProcessor.decode`] for more information.\n+    Args:\n+        image_processor ([`Glm4vProcessor`], *optional*):\n+            The image processor is a required input.\n+        tokenizer ([`PreTrainedTokenizerFast`], *optional*):\n+            The tokenizer is a required input.\n+        video_processor ([`Glm4vVideoProcessor`], *optional*):\n+            The video processor is a required input.\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    tokenizer_class = (\"PreTrainedTokenizer\", \"PreTrainedTokenizerFast\")\n+\n+    def __init__(self, image_processor=None, tokenizer=None, video_processor=None, chat_template=None, **kwargs):\n+        super().__init__(image_processor, tokenizer, video_processor, chat_template=chat_template)\n+        self.image_token = \"<|image|>\" if not hasattr(tokenizer, \"image_token\") else tokenizer.image_token\n+        self.video_token = \"<|video|>\" if not hasattr(tokenizer, \"video_token\") else tokenizer.video_token\n+\n+    def __call__(\n+        self,\n+        images: ImageInput = None,\n+        text: Union[TextInput, PreTokenizedInput, list[TextInput], list[PreTokenizedInput]] = None,\n+        videos: VideoInput = None,\n+        **kwargs: Unpack[Glm4vProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`\n+        and `kwargs` arguments to PreTrainedTokenizerFast's [`~PreTrainedTokenizerFast.__call__`] if `text` is not `None` to encode\n+        the text.\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. Both channels-first and channels-last formats are supported.\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            videos (`np.ndarray`, `torch.Tensor`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n+                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+            - **pixel_values_videos** -- Pixel values of videos to be fed to a model. Returned when `videos` is not `None`.\n+            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n+            - **video_grid_thw** -- List of video 3D grid in LLM. Returned when `videos` is not `None`.\n+        \"\"\"\n+        output_kwargs = self._merge_kwargs(\n+            Glm4vProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+        if images is not None:\n+            image_inputs = self.image_processor(images=images, **output_kwargs[\"images_kwargs\"])\n+            image_grid_thw = image_inputs[\"image_grid_thw\"]\n+        else:\n+            image_inputs = {}\n+            image_grid_thw = None\n+\n+        if videos is not None:\n+            videos_inputs = self.video_processor(videos=videos, **output_kwargs[\"videos_kwargs\"])\n+            timestamps = videos_inputs.pop(\"timestamps\")\n+            video_grid_thw = videos_inputs[\"video_grid_thw\"]\n+        else:\n+            videos_inputs = {}\n+            timestamps = []\n+            video_grid_thw = None\n+\n+        if not isinstance(text, list):\n+            text = [text]\n+\n+        text = text.copy()  # below lines change text in-place\n+        if image_grid_thw is not None:\n+            merge_length = self.image_processor.merge_size**2\n+            index = 0\n+            for i in range(len(text)):\n+                while self.image_token in text[i]:\n+                    num_image_tokens = image_grid_thw[index].prod() // merge_length\n+                    text[i] = text[i].replace(self.image_token, \"<|placeholder|>\" * num_image_tokens, 1)\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.image_token)\n+\n+        if video_grid_thw is not None:\n+            merge_length = self.video_processor.merge_size**2\n+            video_index = 0\n+            for i in range(len(text)):\n+                while self.video_token in text[i]:\n+                    num_frames = len(video_grid_thw)\n+                    video_structure = \"\"\n+\n+                    if hasattr(timestamps, \"tolist\"):\n+                        timestamps_list = timestamps.tolist()[0]\n+                    else:\n+                        timestamps_list = timestamps[0] if isinstance(timestamps[0], list) else timestamps\n+                    unique_timestamps = []\n+                    for idx in range(0, len(timestamps_list)):\n+                        unique_timestamps.append(timestamps_list[idx])\n+                    selected_timestamps = unique_timestamps[:num_frames]\n+                    while len(selected_timestamps) < num_frames:\n+                        selected_timestamps.append(selected_timestamps[-1] if selected_timestamps else 0)\n+                    for frame_idx in range(num_frames):\n+                        timestamp_sec = selected_timestamps[frame_idx]\n+                        frame_structure = f\"<|begin_of_image|>{self.image_token}<|end_of_image|>{timestamp_sec}\"\n+                        video_structure += frame_structure\n+                    text[i] = text[i].replace(self.video_token, video_structure, 1)\n+                    video_index += 1\n+\n+                for frame_idx in range(len(video_grid_thw)):\n+                    if self.image_token in text[i]:\n+                        num_image_tokens = video_grid_thw[frame_idx].prod() // merge_length\n+                        text[i] = text[i].replace(self.image_token, \"<|placeholder|>\" * num_image_tokens, 1)\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.image_token)\n+\n+        return_tensors = output_kwargs[\"text_kwargs\"].pop(\"return_tensors\", None)\n+        text_inputs = self.tokenizer(text, **output_kwargs[\"text_kwargs\"])\n+        self._check_special_mm_tokens(text, text_inputs, modalities=[\"image\", \"video\"])\n+\n+        return BatchFeature(data={**text_inputs, **image_inputs, **videos_inputs}, tensor_type=return_tensors)\n+\n+\n+__all__ = [\n+    \"Glm4vConfig\",\n+    \"Glm4vTextConfig\",\n+    \"Glm4vForConditionalGeneration\",\n+    \"Glm4vModel\",\n+    \"Glm4vPreTrainedModel\",\n+    \"Glm4vProcessor\",\n+    \"Glm4vTextModel\",\n+]"
        },
        {
            "sha": "5a0f5d94d816ad292c5117c79352fbe6974aada3",
            "filename": "src/transformers/models/glm4v/processing_glm4v.py",
            "status": "added",
            "additions": 289,
            "deletions": 0,
            "changes": 289,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fprocessing_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fprocessing_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fprocessing_glm4v.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -0,0 +1,289 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/glm4v/modular_glm4v.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_glm4v.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 The ZhipuAI Inc. team and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import Optional, Union\n+\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_utils import ImageInput\n+from ...processing_utils import ImagesKwargs, MultiModalData, ProcessingKwargs, ProcessorMixin, Unpack, VideosKwargs\n+from ...tokenization_utils_base import PreTokenizedInput, TextInput\n+from ...video_utils import VideoInput\n+\n+\n+class Glm4vVideosProcessorKwargs(VideosKwargs, total=False):\n+    fps: Union[list[float], float]\n+\n+\n+class Glm4vImagesKwargs(ImagesKwargs):\n+    patch_size: Optional[int]\n+    temporal_patch_size: Optional[int]\n+    merge_size: Optional[int]\n+\n+\n+class Glm4vProcessorKwargs(ProcessingKwargs, total=False):\n+    images_kwargs: Glm4vImagesKwargs\n+    videos_kwargs: Glm4vVideosProcessorKwargs\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": False,\n+        },\n+    }\n+\n+\n+class Glm4vProcessor(ProcessorMixin):\n+    r\"\"\"\n+    Constructs a GLM-4V processor which wraps a GLM-4V image processor and a GLM-4 tokenizer into a single processor.\n+    [`~Glm4vProcessor.__call__`] and [`~Glm4vProcessor.decode`] for more information.\n+    Args:\n+        image_processor ([`Glm4vProcessor`], *optional*):\n+            The image processor is a required input.\n+        tokenizer ([`PreTrainedTokenizerFast`], *optional*):\n+            The tokenizer is a required input.\n+        video_processor ([`Glm4vVideoProcessor`], *optional*):\n+            The video processor is a required input.\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    attributes = [\"image_processor\", \"tokenizer\", \"video_processor\"]\n+\n+    image_processor_class = \"AutoImageProcessor\"\n+    video_processor_class = \"AutoVideoProcessor\"\n+\n+    tokenizer_class = (\"PreTrainedTokenizer\", \"PreTrainedTokenizerFast\")\n+\n+    def __init__(self, image_processor=None, tokenizer=None, video_processor=None, chat_template=None, **kwargs):\n+        super().__init__(image_processor, tokenizer, video_processor, chat_template=chat_template)\n+        self.image_token = \"<|image|>\" if not hasattr(tokenizer, \"image_token\") else tokenizer.image_token\n+        self.video_token = \"<|video|>\" if not hasattr(tokenizer, \"video_token\") else tokenizer.video_token\n+        self.image_token_id = (\n+            tokenizer.image_token_id\n+            if getattr(tokenizer, \"image_token_id\", None)\n+            else tokenizer.convert_tokens_to_ids(self.image_token)\n+        )\n+        self.video_token_id = (\n+            tokenizer.video_token_id\n+            if getattr(tokenizer, \"video_token_id\", None)\n+            else tokenizer.convert_tokens_to_ids(self.video_token)\n+        )\n+\n+    def __call__(\n+        self,\n+        images: ImageInput = None,\n+        text: Union[TextInput, PreTokenizedInput, list[TextInput], list[PreTokenizedInput]] = None,\n+        videos: VideoInput = None,\n+        **kwargs: Unpack[Glm4vProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`\n+        and `kwargs` arguments to PreTrainedTokenizerFast's [`~PreTrainedTokenizerFast.__call__`] if `text` is not `None` to encode\n+        the text.\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. Both channels-first and channels-last formats are supported.\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            videos (`np.ndarray`, `torch.Tensor`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n+                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+            - **pixel_values_videos** -- Pixel values of videos to be fed to a model. Returned when `videos` is not `None`.\n+            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n+            - **video_grid_thw** -- List of video 3D grid in LLM. Returned when `videos` is not `None`.\n+        \"\"\"\n+        output_kwargs = self._merge_kwargs(\n+            Glm4vProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+        if images is not None:\n+            image_inputs = self.image_processor(images=images, **output_kwargs[\"images_kwargs\"])\n+            image_grid_thw = image_inputs[\"image_grid_thw\"]\n+        else:\n+            image_inputs = {}\n+            image_grid_thw = None\n+\n+        if videos is not None:\n+            videos_inputs = self.video_processor(videos=videos, **output_kwargs[\"videos_kwargs\"])\n+            timestamps = videos_inputs.pop(\"timestamps\")\n+            video_grid_thw = videos_inputs[\"video_grid_thw\"]\n+        else:\n+            videos_inputs = {}\n+            timestamps = []\n+            video_grid_thw = None\n+\n+        if not isinstance(text, list):\n+            text = [text]\n+\n+        text = text.copy()  # below lines change text in-place\n+        if image_grid_thw is not None:\n+            merge_length = self.image_processor.merge_size**2\n+            index = 0\n+            for i in range(len(text)):\n+                while self.image_token in text[i]:\n+                    num_image_tokens = image_grid_thw[index].prod() // merge_length\n+                    text[i] = text[i].replace(self.image_token, \"<|placeholder|>\" * num_image_tokens, 1)\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.image_token)\n+\n+        if video_grid_thw is not None:\n+            merge_length = self.video_processor.merge_size**2\n+            video_index = 0\n+            for i in range(len(text)):\n+                while self.video_token in text[i]:\n+                    num_frames = len(video_grid_thw)\n+                    video_structure = \"\"\n+\n+                    if hasattr(timestamps, \"tolist\"):\n+                        timestamps_list = timestamps.tolist()[0]\n+                    else:\n+                        timestamps_list = timestamps[0] if isinstance(timestamps[0], list) else timestamps\n+                    unique_timestamps = []\n+                    for idx in range(0, len(timestamps_list)):\n+                        unique_timestamps.append(timestamps_list[idx])\n+                    selected_timestamps = unique_timestamps[:num_frames]\n+                    while len(selected_timestamps) < num_frames:\n+                        selected_timestamps.append(selected_timestamps[-1] if selected_timestamps else 0)\n+                    for frame_idx in range(num_frames):\n+                        timestamp_sec = selected_timestamps[frame_idx]\n+                        frame_structure = f\"<|begin_of_image|>{self.image_token}<|end_of_image|>{timestamp_sec}\"\n+                        video_structure += frame_structure\n+                    text[i] = text[i].replace(self.video_token, video_structure, 1)\n+                    video_index += 1\n+\n+                for frame_idx in range(len(video_grid_thw)):\n+                    if self.image_token in text[i]:\n+                        num_image_tokens = video_grid_thw[frame_idx].prod() // merge_length\n+                        text[i] = text[i].replace(self.image_token, \"<|placeholder|>\" * num_image_tokens, 1)\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.image_token)\n+\n+        return_tensors = output_kwargs[\"text_kwargs\"].pop(\"return_tensors\", None)\n+        text_inputs = self.tokenizer(text, **output_kwargs[\"text_kwargs\"])\n+        self._check_special_mm_tokens(text, text_inputs, modalities=[\"image\", \"video\"])\n+\n+        return BatchFeature(data={**text_inputs, **image_inputs, **videos_inputs}, tensor_type=return_tensors)\n+\n+    def _get_num_multimodal_tokens(self, image_sizes=None, video_sizes=None, **kwargs):\n+        \"\"\"\n+        Computes the number of placeholder tokens needed for multimodal inputs with the given sizes.\n+        Args:\n+            image_sizes (`list[list[int]]`, *optional*):\n+                The input sizes formatted as (height, width) per each image.\n+            video_sizes (`list[list[int]]`, *optional*):\n+                The input sizes formatted as (num_frames, height, width) per each video.\n+        Returns:\n+            `MultiModalData`: A `MultiModalData` object holding number of tokens per each of the provided\n+            input modalities, along with other useful data.\n+        \"\"\"\n+\n+        vision_data = {}\n+        if image_sizes is not None:\n+            images_kwargs = Glm4vProcessorKwargs._defaults.get(\"images_kwargs\", {})\n+            images_kwargs.update(kwargs)\n+            merge_size = images_kwargs.get(\"merge_size\", None) or self.image_processor.merge_size\n+\n+            num_image_patches = [\n+                self.image_processor.get_number_of_image_patches(*image_size, images_kwargs)\n+                for image_size in image_sizes\n+            ]\n+            num_image_tokens = [(num_patches // merge_size**2) for num_patches in num_image_patches]\n+            vision_data.update({\"num_image_tokens\": num_image_tokens, \"num_image_patches\": num_image_patches})\n+\n+        if video_sizes is not None:\n+            videos_kwargs = Glm4vProcessorKwargs._defaults.get(\"videos_kwargs\", {})\n+            videos_kwargs.update(kwargs)\n+            num_video_patches = [\n+                self.video_processor.get_number_of_video_patches(*video_size, videos_kwargs)\n+                for video_size in video_sizes\n+            ]\n+            num_video_tokens = [(num_patches // merge_size**2) for num_patches in num_video_patches]\n+            vision_data[\"num_video_tokens\"] = num_video_tokens\n+\n+        return MultiModalData(**vision_data)\n+\n+    def batch_decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to Qwen2TokenizerFast's [`~PreTrainedTokenizer.batch_decode`]. Please\n+        refer to the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.batch_decode(*args, **kwargs)\n+\n+    def decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to Qwen2TokenizerFast's [`~PreTrainedTokenizer.decode`]. Please refer to\n+        the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.decode(*args, **kwargs)\n+\n+    def post_process_image_text_to_text(\n+        self, generated_outputs, skip_special_tokens=True, clean_up_tokenization_spaces=False, **kwargs\n+    ):\n+        \"\"\"\n+        Post-process the output of the model to decode the text.\n+\n+        Args:\n+            generated_outputs (`torch.Tensor` or `np.ndarray`):\n+                The output of the model `generate` function. The output is expected to be a tensor of shape `(batch_size, sequence_length)`\n+                or `(sequence_length,)`.\n+            skip_special_tokens (`bool`, *optional*, defaults to `True`):\n+                Whether or not to remove special tokens in the output. Argument passed to the tokenizer's `batch_decode` method.\n+            clean_up_tokenization_spaces (`bool`, *optional*, defaults to `False`):\n+                Whether or not to clean up the tokenization spaces. Argument passed to the tokenizer's `batch_decode` method.\n+            **kwargs:\n+                Additional arguments to be passed to the tokenizer's `batch_decode method`.\n+\n+        Returns:\n+            `list[str]`: The decoded text.\n+        \"\"\"\n+        return self.tokenizer.batch_decode(\n+            generated_outputs,\n+            skip_special_tokens=skip_special_tokens,\n+            clean_up_tokenization_spaces=clean_up_tokenization_spaces,\n+            **kwargs,\n+        )\n+\n+    @property\n+    def model_input_names(self):\n+        tokenizer_input_names = self.tokenizer.model_input_names\n+        image_processor_input_names = self.image_processor.model_input_names\n+        names_from_processor = list(dict.fromkeys(tokenizer_input_names + image_processor_input_names))\n+        return names_from_processor + [\"second_per_grid_ts\"]\n+\n+\n+__all__ = [\"Glm4vProcessor\"]"
        },
        {
            "sha": "ac6a992107889c1cf74f53dda1294d7de850c765",
            "filename": "src/transformers/models/glm4v/video_processing_glm4v.py",
            "status": "added",
            "additions": 262,
            "deletions": 0,
            "changes": 262,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fvideo_processing_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/src%2Ftransformers%2Fmodels%2Fglm4v%2Fvideo_processing_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fvideo_processing_glm4v.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -0,0 +1,262 @@\n+# coding=utf-8\n+# Copyright 2025 The ZhipuAI Inc. team and HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"video processor class for GLM-4.1V.\"\"\"\n+\n+import math\n+from typing import Optional, Union\n+\n+import numpy as np\n+\n+from ...image_processing_utils import (\n+    BatchFeature,\n+)\n+from ...image_utils import (\n+    OPENAI_CLIP_MEAN,\n+    OPENAI_CLIP_STD,\n+    ChannelDimension,\n+    SizeDict,\n+    get_image_size,\n+)\n+from ...processing_utils import Unpack, VideosKwargs\n+from ...utils import (\n+    TensorType,\n+    add_start_docstrings,\n+    is_torch_available,\n+    is_vision_available,\n+)\n+from .image_processing_glm4v import smart_resize\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+from ...utils.import_utils import requires\n+from ...video_processing_utils import (\n+    BASE_VIDEO_PROCESSOR_DOCSTRING,\n+    BaseVideoProcessor,\n+)\n+from ...video_utils import VideoMetadata, group_videos_by_shape, reorder_videos\n+\n+\n+if is_vision_available():\n+    from ...image_utils import PILImageResampling\n+\n+import torch.nn.functional as F\n+\n+\n+class Glm4vVideoProcessorInitKwargs(VideosKwargs):\n+    max_image_size: dict[str, int] = None\n+    patch_size: Optional[int] = None\n+    temporal_patch_size: Optional[int] = None\n+    merge_size: Optional[int] = None\n+    image_mean: Optional[list[float]] = None\n+    image_std: Optional[list[float]] = None\n+\n+\n+@add_start_docstrings(\n+    \"Constructs a fast GLM-4V image processor that dynamically resizes videos based on the original videos.\",\n+    BASE_VIDEO_PROCESSOR_DOCSTRING,\n+    \"\"\"\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spacial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The temporal patch size of the vision encoder.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+    \"\"\",\n+)\n+@requires(backends=(\"torchvision\",))\n+class Glm4vVideoProcessor(BaseVideoProcessor):\n+    resample = PILImageResampling.BICUBIC\n+    size = {\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 2 * 30000}\n+    max_image_size = {\"longest_edge\": 28 * 28 * 2 * 30000}\n+    image_mean = OPENAI_CLIP_MEAN\n+    image_std = OPENAI_CLIP_STD\n+    do_resize = True\n+    do_rescale = True\n+    do_normalize = True\n+    do_convert_rgb = True\n+    do_sample_frames = True\n+    patch_size = 14\n+    temporal_patch_size = 2\n+    max_duration = 300\n+    merge_size = 2\n+    valid_kwargs = Glm4vVideoProcessorInitKwargs\n+    num_frames = 16\n+    fps = 2\n+\n+    model_input_names = [\"pixel_values_videos\", \"video_grid_thw\"]\n+\n+    def __init__(self, **kwargs: Unpack[Glm4vVideoProcessorInitKwargs]):\n+        super().__init__(**kwargs)\n+\n+    def sample_frames(\n+        self,\n+        video: torch.Tensor,\n+        metadata: Union[VideoMetadata, dict],\n+    ):\n+        total_frames = video.shape[0]\n+        video_fps = getattr(metadata, \"fps\", 2.0)\n+        meta_frames = getattr(metadata, \"total_num_frames\", total_frames)\n+        max_frame_idx = meta_frames - 1\n+        duration = getattr(metadata, \"duration\", None)\n+        if duration is None:\n+            duration = round(max_frame_idx / video_fps) + 1\n+\n+        if duration <= self.max_duration:\n+            n = int(math.floor(duration * self.fps))\n+            frame_indices = [min(max_frame_idx, int(math.ceil(i * video_fps / self.fps))) for i in range(n)]\n+        else:\n+            num_samples = int(self.max_duration * self.fps)\n+            if num_samples >= meta_frames:\n+                frame_indices = list(range(meta_frames))\n+            else:\n+                target_seconds = np.linspace(0, duration, num_samples, endpoint=True)\n+                frame_indices = [min(max_frame_idx, int(math.ceil(t * video_fps))) for t in target_seconds]\n+\n+        seen, uniq = set(), []\n+        for idx in frame_indices:\n+            if idx not in seen:\n+                seen.add(idx)\n+                uniq.append(idx)\n+\n+        if len(uniq) & 1:\n+            uniq.append(uniq[-1])\n+\n+        frame_indices = uniq\n+        sampled_video = video[frame_indices]\n+        full_second_idxs = [int(idx / video_fps) for idx in frame_indices]\n+        second_idxs = full_second_idxs[::2]  # mrope\n+        return sampled_video, second_idxs\n+\n+    def _preprocess(\n+        self,\n+        videos: list[torch.Tensor],\n+        video_metadata: Optional[Union[list[VideoMetadata], list[dict]]] = None,\n+        do_convert_rgb: bool = True,\n+        do_resize: bool = True,\n+        size: SizeDict = None,\n+        do_rescale: bool = True,\n+        rescale_factor: float = 1 / 255.0,\n+        do_normalize: bool = True,\n+        do_sample_frames: bool = True,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        **kwargs,\n+    ):\n+        timestamps_list = []\n+        if do_sample_frames:\n+            if video_metadata is None or (isinstance(video_metadata, list) and video_metadata[0] is None):\n+                raise ValueError(\n+                    \"Frame sampling is enabled but no video metadata was found. \"\n+                    \"Please pass in `VideoMetadata` object per each input video or set `do_sample_frames=False`\"\n+                )\n+            processed_videos = []\n+            for video, metadata in zip(videos, video_metadata):\n+                video, timestamps = self.sample_frames(video, metadata)\n+                timestamps_list.append(timestamps)\n+                processed_videos.append(video)\n+        else:\n+            raise AssertionError(\"Must set `do_sample_frames=True` to sample frames from GLM-4.1V Model.\")\n+\n+        grouped_videos, grouped_videos_index = group_videos_by_shape(processed_videos)\n+        resized_videos_grouped = {}\n+\n+        for shape, stacked_videos in grouped_videos.items():\n+            B, T, C, H, W = stacked_videos.shape\n+            num_frames, height, width = T, H, W\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    num_frames=num_frames,\n+                    height=height,\n+                    width=width,\n+                    temporal_factor=temporal_patch_size,\n+                    factor=patch_size * merge_size,\n+                    max_pixels=self.max_image_size[\"longest_edge\"],\n+                )\n+                stacked_videos = stacked_videos.view(B * T, C, H, W)\n+                stacked_videos = F.interpolate(\n+                    stacked_videos, size=(resized_height, resized_width), mode=\"bicubic\", align_corners=False\n+                )\n+                stacked_videos = stacked_videos.view(B, T, C, resized_height, resized_width)\n+            resized_videos_grouped[shape] = stacked_videos\n+        resized_videos = reorder_videos(resized_videos_grouped, grouped_videos_index)\n+\n+        # Group videos by size for further processing\n+        # Needed in case do_resize is False, or resize returns videos with different sizes\n+        grouped_videos, grouped_videos_index = group_videos_by_shape(resized_videos)\n+        processed_videos_grouped = {}\n+        processed_grids = {}\n+        for shape, stacked_videos in grouped_videos.items():\n+            resized_height, resized_width = get_image_size(stacked_videos[0], channel_dim=ChannelDimension.FIRST)\n+\n+            # Fused rescale and normalize\n+            stacked_videos = self.rescale_and_normalize(\n+                stacked_videos, do_rescale, rescale_factor, do_normalize, image_mean, image_std\n+            )\n+            patches = stacked_videos\n+\n+            # Check that videos have `num_frames` divisible by `temporal_patch_size`\n+            if patches.shape[1] % temporal_patch_size != 0:\n+                repeats = patches[:, -1:].repeat(1, temporal_patch_size - 1, 1, 1, 1)\n+                patches = torch.cat([patches, repeats], dim=1)\n+            batch_size, grid_t, channel = patches.shape[:3]\n+            grid_t = grid_t // temporal_patch_size\n+            grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+\n+            patches = patches.view(\n+                batch_size,\n+                grid_t,\n+                temporal_patch_size,\n+                channel,\n+                grid_h // merge_size,\n+                merge_size,\n+                patch_size,\n+                grid_w // merge_size,\n+                merge_size,\n+                patch_size,\n+            )\n+            patches = patches.permute(0, 1, 4, 7, 5, 8, 3, 2, 6, 9)\n+            flatten_patches = patches.reshape(\n+                batch_size,\n+                grid_t * grid_h * grid_w,\n+                channel * temporal_patch_size * patch_size * patch_size,\n+            )\n+\n+            processed_videos_grouped[shape] = flatten_patches\n+            processed_grids[shape] = [[grid_t, grid_h, grid_w]] * batch_size\n+\n+        processed_videos = reorder_videos(processed_videos_grouped, grouped_videos_index)\n+        processed_grids = reorder_videos(processed_grids, grouped_videos_index)\n+        pixel_values_videos = torch.cat(processed_videos, dim=0)\n+        video_grid_thw = torch.tensor(processed_grids)\n+        total_frames = video_grid_thw[0][0].item()\n+        h = video_grid_thw[0][1].item()\n+        w = video_grid_thw[0][2].item()\n+        video_grid_thw = [[1, h, w] for _ in range(total_frames)]\n+        data = {\n+            \"pixel_values_videos\": pixel_values_videos,\n+            \"video_grid_thw\": video_grid_thw,\n+            \"timestamps\": timestamps_list,\n+        }\n+\n+        return BatchFeature(data=data, tensor_type=return_tensors)\n+\n+\n+__all__ = [\"Glm4vVideoProcessor\"]"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/glm4v/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/tests%2Fmodels%2Fglm4v%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/tests%2Fmodels%2Fglm4v%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fglm4v%2F__init__.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e"
        },
        {
            "sha": "4e444fb56e88e45fdb06bac401670f626a01753b",
            "filename": "tests/models/glm4v/test_modeling_glm4v.py",
            "status": "added",
            "additions": 512,
            "deletions": 0,
            "changes": 512,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/tests%2Fmodels%2Fglm4v%2Ftest_modeling_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/tests%2Fmodels%2Fglm4v%2Ftest_modeling_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fglm4v%2Ftest_modeling_glm4v.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -0,0 +1,512 @@\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch GLM-4.1V model.\"\"\"\n+\n+import copy\n+import gc\n+import unittest\n+\n+import requests\n+from parameterized import parameterized\n+\n+from transformers import (\n+    AutoProcessor,\n+    Glm4vConfig,\n+    Glm4vForConditionalGeneration,\n+    Glm4vModel,\n+    is_torch_available,\n+    is_vision_available,\n+)\n+from transformers.testing_utils import (\n+    require_flash_attn,\n+    require_torch,\n+    require_torch_gpu,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import (\n+    ModelTesterMixin,\n+    floats_tensor,\n+    ids_tensor,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+class Glm4vVisionText2TextModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=3,\n+        seq_length=7,\n+        num_channels=3,\n+        ignore_index=-100,\n+        image_size=112,\n+        video_start_token_id=3,\n+        video_end_token_id=4,\n+        image_start_token_id=5,\n+        image_end_token_id=6,\n+        image_token_id=7,\n+        video_token_id=8,\n+        is_training=True,\n+        text_config={\n+            \"vocab_size\": 99,\n+            \"hidden_size\": 32,\n+            \"intermediate_size\": 37,\n+            \"num_hidden_layers\": 4,\n+            \"num_attention_heads\": 4,\n+            \"num_key_value_heads\": 2,\n+            \"output_channels\": 64,\n+            \"hidden_act\": \"silu\",\n+            \"max_position_embeddings\": 512,\n+            \"rope_scaling\": {\"type\": \"default\", \"mrope_section\": [2, 1, 1]},\n+            \"max_window_layers\": 3,\n+            \"rope_theta\": 10000,\n+            \"tie_word_embeddings\": True,\n+            \"bos_token_id\": 0,\n+            \"eos_token_id\": 0,\n+            \"pad_token_id\": 0,\n+        },\n+        vision_config={\n+            \"depth\": 2,\n+            \"embed_dim\": 32,\n+            \"hidden_act\": \"silu\",\n+            \"hidden_size\": 32,\n+            \"mlp_ratio\": 4,\n+            \"num_heads\": 4,\n+            \"patch_size\": 14,\n+            \"spatial_merge_size\": 1,\n+            \"temporal_patch_size\": 2,\n+        },\n+    ):\n+        self.parent = parent\n+        self.ignore_index = ignore_index\n+        self.bos_token_id = text_config[\"bos_token_id\"]\n+        self.eos_token_id = text_config[\"eos_token_id\"]\n+        self.pad_token_id = text_config[\"pad_token_id\"]\n+        self.video_start_token_id = video_start_token_id\n+        self.video_end_token_id = video_end_token_id\n+        self.image_start_token_id = image_start_token_id\n+        self.image_end_token_id = image_end_token_id\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.text_config = text_config\n+        self.vision_config = vision_config\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.image_size = image_size\n+        self.is_training = is_training\n+        self.hidden_size = text_config[\"hidden_size\"]\n+        self.num_hidden_layers = text_config[\"num_hidden_layers\"]\n+        self.num_attention_heads = text_config[\"num_attention_heads\"]\n+        self.vocab_size = text_config[\"vocab_size\"]\n+        self.num_image_tokens = 64\n+        self.seq_length = seq_length + self.num_image_tokens\n+\n+    def get_config(self):\n+        return Glm4vConfig(\n+            text_config=self.text_config,\n+            vision_config=self.vision_config,\n+            image_token_id=self.image_token_id,\n+            video_token_id=self.video_token_id,\n+            video_start_token_id=self.video_start_token_id,\n+            video_end_token_id=self.video_end_token_id,\n+            image_start_token_id=self.image_start_token_id,\n+            image_end_token_id=self.image_end_token_id,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        config = self.get_config()\n+        patch_size = config.vision_config.patch_size\n+        temporal_patch_size = config.vision_config.temporal_patch_size\n+        pixel_values = floats_tensor(\n+            [\n+                self.batch_size * (self.image_size**2) // (patch_size**2),\n+                self.num_channels * (patch_size**2) * temporal_patch_size,\n+            ]\n+        )\n+\n+        return config, pixel_values\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], self.vocab_size)\n+        attention_mask = torch.ones(input_ids.shape, dtype=torch.long, device=torch_device)\n+\n+        input_ids[input_ids == self.video_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.video_start_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_start_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.video_end_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_end_token_id] = self.pad_token_id\n+\n+        input_ids[:, 0] = self.image_start_token_id\n+        input_ids[:, 1 : 1 + self.num_image_tokens] = self.image_token_id\n+        input_ids[:, 1 + self.num_image_tokens] = self.image_end_token_id\n+        patch_size = config.vision_config.patch_size\n+        patches_per_side = self.image_size // patch_size\n+\n+        inputs_dict = {\n+            \"pixel_values\": pixel_values,\n+            \"image_grid_thw\": torch.tensor([[1, patches_per_side, patches_per_side]] * self.batch_size),\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+        }\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class Glm4vModelTest(ModelTesterMixin, GenerationTesterMixin, unittest.TestCase):\n+    all_model_classes = (Glm4vModel, Glm4vForConditionalGeneration) if is_torch_available() else ()\n+    test_pruning = False\n+    test_head_masking = False\n+    _is_composite = True\n+\n+    def setUp(self):\n+        self.model_tester = Glm4vVisionText2TextModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Glm4vConfig, has_text_modality=False)\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    # GLM4V has images shaped as (bs*patch_len, dim) so we can't slice to batches in generate\n+    def prepare_config_and_inputs_for_generate(self, batch_size=2):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        # We don't want a few model inputs in our model input dictionary for generation tests\n+        input_keys_to_ignore = [\n+            # we don't want to mask attention heads\n+            \"head_mask\",\n+            \"decoder_head_mask\",\n+            \"cross_attn_head_mask\",\n+            # we don't want encoder-decoder models to start from filled decoder ids\n+            \"decoder_input_ids\",\n+            \"decoder_attention_mask\",\n+            # we'll set cache use in each test differently\n+            \"use_cache\",\n+            # Ignore labels if it is in the input dict\n+            \"labels\",\n+            # model-specific exceptions should overload/overwrite this function\n+        ]\n+\n+        # The diff from the general `prepare_config_and_inputs_for_generate` lies here\n+        patch_size = config.vision_config.patch_size\n+        filtered_image_length = batch_size * (self.model_tester.image_size**2) // (patch_size**2)\n+        filtered_inputs_dict = {\n+            k: v[:batch_size, ...] if isinstance(v, torch.Tensor) else v\n+            for k, v in inputs_dict.items()\n+            if k not in input_keys_to_ignore\n+        }\n+        filtered_inputs_dict[\"pixel_values\"] = inputs_dict[\"pixel_values\"][:filtered_image_length]\n+\n+        # It is important set `eos_token_id` to `None` to avoid early stopping (would break for length-based checks)\n+        text_gen_config = config.get_text_config(decoder=True)\n+        if text_gen_config.eos_token_id is not None and text_gen_config.pad_token_id is None:\n+            text_gen_config.pad_token_id = (\n+                text_gen_config.eos_token_id\n+                if isinstance(text_gen_config.eos_token_id, int)\n+                else text_gen_config.eos_token_id[0]\n+            )\n+        text_gen_config.eos_token_id = None\n+        text_gen_config.forced_eos_token_id = None\n+\n+        return config, filtered_inputs_dict\n+\n+    @unittest.skip(reason=\"No available kernels - not supported\")\n+    def test_sdpa_can_dispatch_on_flash(self):\n+        pass\n+\n+    @parameterized.expand([(\"greedy\", 1), (\"beam search\", 2)])\n+    @unittest.skip(\"Cannot generate from inputs embeds with pixel values\")\n+    def test_generate_from_inputs_embeds(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Size mismatch\")\n+    def test_multi_gpu_data_parallel_forward(self):\n+        pass\n+\n+    @unittest.skip(reason=\"We cannot configure to output a smaller model.\")\n+    def test_model_is_small(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot generate from inputs embeds with pixel values\")\n+    def test_generate_from_inputs_embeds_with_static_cache(self):\n+        pass\n+\n+    # The multimodal base model embeds will not match ids, due to pixel values. We can't change base test\n+    # because in some models `pixel_values` are required. Will be fixed when we add support for merging `embeds+pixels`\n+    # TODO: @raushan\n+\n+    def test_inputs_embeds(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            inputs = copy.deepcopy(self._prepare_for_class(inputs_dict, model_class))\n+\n+            input_ids = inputs[\"input_ids\"]\n+            del inputs[\"input_ids\"]\n+            del inputs[\"pixel_values\"]\n+            del inputs[\"image_grid_thw\"]\n+\n+            wte = model.get_input_embeddings()\n+            inputs[\"inputs_embeds\"] = wte(input_ids)\n+            with torch.no_grad():\n+                model(**inputs)[0]\n+\n+    def test_inputs_embeds_matches_input_ids(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            inputs = self._prepare_for_class(inputs_dict, model_class)\n+            input_ids = inputs[\"input_ids\"]\n+            del inputs[\"input_ids\"]\n+            del inputs[\"pixel_values\"]\n+            del inputs[\"image_grid_thw\"]\n+\n+            inputs_embeds = model.get_input_embeddings()(input_ids)\n+\n+            with torch.no_grad():\n+                out_ids = model(input_ids=input_ids, **inputs)[0]\n+                out_embeds = model(inputs_embeds=inputs_embeds, **inputs)[0]\n+            torch.testing.assert_close(out_embeds, out_ids)\n+\n+\n+@unittest.skip(\"Model checkpoint not yet released\")\n+@require_torch\n+class Glm4vIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = AutoProcessor.from_pretrained(\"z\")\n+        self.messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\"},\n+                    {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+                ],\n+            }\n+        ]\n+        url = \"https://qianwen-res.oss-accelerate-overseas.aliyuncs.com/Qwen2-VL/demo_small.jpg\"\n+        self.image = Image.open(requests.get(url, stream=True).raw)\n+\n+    def tearDown(self):\n+        gc.collect()\n+        torch.cuda.empty_cache()\n+\n+    @slow\n+    def test_small_model_integration_test(self):\n+        model = Glm4vForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text], images=[self.image], return_tensors=\"pt\")\n+\n+        expected_input_ids = [151644, 8948, 198, 2610, 525, 264, 10950, 17847, 13, 151645, 198, 151644, 872, 198, 151652, 151655, 151655]  # fmt: skip\n+        assert expected_input_ids == inputs.input_ids[0].tolist()[:17]\n+\n+        expected_pixel_slice = torch.tensor(\n+            [\n+                [0.8792, 0.8792, 0.9084],\n+                [1.1858, 1.1858, 1.2296],\n+                [1.2004, 1.2004, 1.2150],\n+                [1.4340, 1.4340, 1.4194],\n+                [1.3902, 1.4048, 1.4194],\n+                [1.5216, 1.5362, 1.5362],\n+            ],\n+            dtype=torch.float32,\n+            device=\"cpu\",\n+        )\n+        assert torch.allclose(expected_pixel_slice, inputs.pixel_values[:6, :3], atol=3e-3)\n+\n+        # verify generation\n+        inputs = inputs.to(torch_device)\n+\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        EXPECTED_DECODED_TEXT = \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular choices\"\n+\n+        self.assertEqual(\n+            self.processor.decode(output[0], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_batch(self):\n+        model = Glm4vForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text, text], images=[self.image, self.image], return_tensors=\"pt\").to(\n+            torch_device\n+        )\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            'system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular choices',\n+            'system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular choices',\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_expand(self):\n+        model = Glm4vForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text], images=[self.image], return_tensors=\"pt\").to(torch_device)\n+\n+        output = model.generate(**inputs, max_new_tokens=30, num_return_sequences=3)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            'system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular choices',\n+            'system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular choices',\n+            'system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular choices',\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_batch_wo_image(self):\n+        model = Glm4vForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        messages2 = [\n+            {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n+            {\"role\": \"user\", \"content\": \"Who are you?\"},\n+        ]\n+        text2 = self.processor.apply_chat_template(messages2, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text, text2], images=[self.image], padding=True, return_tensors=\"pt\").to(\n+            torch_device\n+        )\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            'system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular choices',\n+            'system\\nYou are a helpful assistant.\\nuser\\nWho are you?\\nassistant\\nI am a large language model created by Alibaba Cloud. I am called Qwen.'\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_batch_different_resolutions(self):\n+        model = Glm4vForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        text2 = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        image2 = self.image.resize((224, 224))\n+        inputs = self.processor(text=[text, text2], images=[self.image, image2], padding=True, return_tensors=\"pt\").to(\n+            torch_device\n+        )\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            'system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular choices',\n+            'system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular pets'\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    @require_flash_attn\n+    @require_torch_gpu\n+    def test_small_model_integration_test_batch_flashatt2(self):\n+        model = Glm4vForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\",\n+            torch_dtype=torch.bfloat16,\n+            attn_implementation=\"flash_attention_2\",\n+            device_map=\"auto\",\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text, text], images=[self.image, self.image], return_tensors=\"pt\").to(\n+            torch_device\n+        )\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular choices\",\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular choices\",\n+        ]\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    @require_flash_attn\n+    @require_torch_gpu\n+    def test_small_model_integration_test_batch_wo_image_flashatt2(self):\n+        model = Glm4vForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\",\n+            torch_dtype=torch.bfloat16,\n+            attn_implementation=\"flash_attention_2\",\n+            device_map=\"auto\",\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        messages2 = [\n+            {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n+            {\"role\": \"user\", \"content\": \"Who are you?\"},\n+        ]\n+        text2 = self.processor.apply_chat_template(messages2, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text, text2], images=[self.image], padding=True, return_tensors=\"pt\").to(\n+            torch_device\n+        )\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            'system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular choices',\n+            'system\\nYou are a helpful assistant.\\nuser\\nWho are you?\\nassistant\\nI am a large language model created by Alibaba Cloud. I am called Qwen.'\n+        ]  # fmt: skip\n+\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )"
        },
        {
            "sha": "717b853ac29be0122a3805f3b753848cc12d2078",
            "filename": "tests/models/glm4v/test_video_processing_glm4v.py",
            "status": "added",
            "additions": 330,
            "deletions": 0,
            "changes": 330,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/tests%2Fmodels%2Fglm4v%2Ftest_video_processing_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/tests%2Fmodels%2Fglm4v%2Ftest_video_processing_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fglm4v%2Ftest_video_processing_glm4v.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -0,0 +1,330 @@\n+# coding=utf-8\n+# Copyright 2025 HuggingFace Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+import numpy as np\n+\n+from transformers.image_utils import IMAGENET_STANDARD_MEAN, IMAGENET_STANDARD_STD\n+from transformers.testing_utils import require_torch, require_vision\n+from transformers.utils import is_torch_available, is_torchvision_available, is_vision_available\n+\n+from ...test_video_processing_common import VideoProcessingTestMixin, prepare_video_inputs\n+\n+\n+if is_torch_available():\n+    from PIL import Image\n+\n+if is_vision_available():\n+    if is_torchvision_available():\n+        from transformers import Glm4vVideoProcessor\n+        from transformers.models.glm4v.video_processing_glm4v import smart_resize\n+\n+\n+class Glm4vVideoProcessingTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=5,\n+        num_frames=8,\n+        num_channels=3,\n+        min_resolution=30,\n+        max_resolution=80,\n+        temporal_patch_size=2,\n+        patch_size=14,\n+        merge_size=2,\n+        do_resize=True,\n+        size=None,\n+        do_normalize=True,\n+        image_mean=IMAGENET_STANDARD_MEAN,\n+        image_std=IMAGENET_STANDARD_STD,\n+        do_convert_rgb=True,\n+    ):\n+        size = size if size is not None else {\"longest_edge\": 20}\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.num_frames = num_frames\n+        self.num_channels = num_channels\n+        self.min_resolution = min_resolution\n+        self.max_resolution = max_resolution\n+        self.do_resize = do_resize\n+        self.size = size\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean\n+        self.image_std = image_std\n+        self.do_convert_rgb = do_convert_rgb\n+        self.temporal_patch_size = temporal_patch_size\n+        self.patch_size = patch_size\n+        self.merge_size = merge_size\n+\n+    def prepare_video_processor_dict(self):\n+        return {\n+            \"do_resize\": self.do_resize,\n+            \"size\": self.size,\n+            \"do_normalize\": self.do_normalize,\n+            \"image_mean\": self.image_mean,\n+            \"image_std\": self.image_std,\n+            \"do_convert_rgb\": self.do_convert_rgb,\n+            \"do_sample_frames\": True,\n+        }\n+\n+    def prepare_video_metadata(self, videos):\n+        video_metadata = []\n+        for video in videos:\n+            if isinstance(video, list):\n+                num_frames = len(video)\n+            elif hasattr(video, \"shape\"):\n+                if len(video.shape) == 4:  # (T, H, W, C)\n+                    num_frames = video.shape[0]\n+                else:\n+                    num_frames = 1\n+            else:\n+                num_frames = self.num_frames\n+\n+            metadata = {\n+                \"fps\": 2,\n+                \"duration\": num_frames / 2,\n+                \"total_frames\": num_frames,\n+            }\n+            video_metadata.append(metadata)\n+        return video_metadata\n+\n+    def expected_output_video_shape(self, videos):\n+        grid_t = self.num_frames // self.temporal_patch_size\n+        hidden_dim = self.num_channels * self.temporal_patch_size * self.patch_size * self.patch_size\n+        seq_len = 0\n+        for video in videos:\n+            if isinstance(video, list) and isinstance(video[0], Image.Image):\n+                video = np.stack([np.array(frame) for frame in video])\n+            elif hasattr(video, \"shape\"):\n+                pass\n+            else:\n+                video = np.array(video)\n+\n+            if hasattr(video, \"shape\") and len(video.shape) >= 3:\n+                if len(video.shape) == 4:\n+                    t, height, width = video.shape[:3]\n+                elif len(video.shape) == 3:\n+                    height, width = video.shape[:2]\n+                    t = 1\n+                else:\n+                    t, height, width = self.num_frames, self.min_resolution, self.min_resolution\n+            else:\n+                t, height, width = self.num_frames, self.min_resolution, self.min_resolution\n+\n+            resized_height, resized_width = smart_resize(\n+                t,\n+                height,\n+                width,\n+                factor=self.patch_size * self.merge_size,\n+            )\n+            grid_h, grid_w = resized_height // self.patch_size, resized_width // self.patch_size\n+            seq_len += grid_t * grid_h * grid_w\n+        return [seq_len, hidden_dim]\n+\n+    def prepare_video_inputs(self, equal_resolution=False, return_tensors=\"pil\"):\n+        videos = prepare_video_inputs(\n+            batch_size=self.batch_size,\n+            num_frames=self.num_frames,\n+            num_channels=self.num_channels,\n+            min_resolution=self.min_resolution,\n+            max_resolution=self.max_resolution,\n+            equal_resolution=equal_resolution,\n+            return_tensors=return_tensors,\n+        )\n+        return videos\n+\n+\n+@require_torch\n+@require_vision\n+class Glm4vVideoProcessingTest(VideoProcessingTestMixin, unittest.TestCase):\n+    fast_video_processing_class = Glm4vVideoProcessor if is_torchvision_available() else None\n+    input_name = \"pixel_values_videos\"\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.video_processor_tester = Glm4vVideoProcessingTester(self)\n+\n+    @property\n+    def video_processor_dict(self):\n+        return self.video_processor_tester.prepare_video_processor_dict()\n+\n+    def test_video_processor_from_dict_with_kwargs(self):\n+        video_processor = self.fast_video_processing_class.from_dict(self.video_processor_dict)\n+        self.assertEqual(video_processor.size, {\"longest_edge\": 20})\n+\n+        video_processor = self.fast_video_processing_class.from_dict(self.video_processor_dict, size=42)\n+        self.assertEqual(video_processor.size, {\"height\": 42, \"width\": 42})\n+\n+    def test_call_pil(self):\n+        for video_processing_class in self.video_processor_list:\n+            video_processing = video_processing_class(**self.video_processor_dict)\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"pil\"\n+            )\n+\n+            for video in video_inputs:\n+                self.assertIsInstance(video[0], Image.Image)\n+\n+            video_metadata = self.video_processor_tester.prepare_video_metadata(video_inputs)\n+            encoded_videos = video_processing(\n+                video_inputs[0], video_metadata=[video_metadata[0]], return_tensors=\"pt\"\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+            encoded_videos = video_processing(video_inputs, video_metadata=video_metadata, return_tensors=\"pt\")[\n+                self.input_name\n+            ]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    def test_call_numpy(self):\n+        for video_processing_class in self.video_processor_list:\n+            video_processing = video_processing_class(**self.video_processor_dict)\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"np\"\n+            )\n+\n+            video_metadata = self.video_processor_tester.prepare_video_metadata(video_inputs)\n+            encoded_videos = video_processing(\n+                video_inputs[0], video_metadata=[video_metadata[0]], return_tensors=\"pt\"\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+            encoded_videos = video_processing(video_inputs, video_metadata=video_metadata, return_tensors=\"pt\")[\n+                self.input_name\n+            ]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    def test_call_pytorch(self):\n+        for video_processing_class in self.video_processor_list:\n+            video_processing = video_processing_class(**self.video_processor_dict)\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"pt\"\n+            )\n+            video_metadata = self.video_processor_tester.prepare_video_metadata(video_inputs)\n+            encoded_videos = video_processing(\n+                video_inputs[0], video_metadata=[video_metadata[0]], return_tensors=\"pt\"\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+            encoded_videos = video_processing(video_inputs, video_metadata=video_metadata, return_tensors=\"pt\")[\n+                self.input_name\n+            ]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    @unittest.skip(\"Skip for now, the test needs adjustment fo GLM-4.1V\")\n+    def test_call_numpy_4_channels(self):\n+        for video_processing_class in self.video_processor_list:\n+            # Test that can process videos which have an arbitrary number of channels\n+            # Initialize video_processing\n+            video_processor = video_processing_class(**self.video_processor_dict)\n+\n+            # create random numpy tensors\n+            self.video_processor_tester.num_channels = 4\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"np\"\n+            )\n+\n+            # Test not batched input\n+            encoded_videos = video_processor(\n+                video_inputs[0],\n+                return_tensors=\"pt\",\n+                input_data_format=\"channels_last\",\n+                image_mean=0,\n+                image_std=1,\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+            # Test batched\n+            encoded_videos = video_processor(\n+                video_inputs,\n+                return_tensors=\"pt\",\n+                input_data_format=\"channels_last\",\n+                image_mean=0,\n+                image_std=1,\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    def test_nested_input(self):\n+        \"\"\"Tests that the processor can work with nested list where each video is a list of arrays\"\"\"\n+        for video_processing_class in self.video_processor_list:\n+            video_processing = video_processing_class(**self.video_processor_dict)\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"np\"\n+            )\n+\n+            video_inputs_nested = [list(video) for video in video_inputs]\n+            video_metadata = self.video_processor_tester.prepare_video_metadata(video_inputs)\n+\n+            # Test not batched input\n+            encoded_videos = video_processing(\n+                video_inputs_nested[0], video_metadata=[video_metadata[0]], return_tensors=\"pt\"\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+            # Test batched\n+            encoded_videos = video_processing(video_inputs_nested, video_metadata=video_metadata, return_tensors=\"pt\")[\n+                self.input_name\n+            ]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    def test_call_sample_frames(self):\n+        for video_processing_class in self.video_processor_list:\n+            video_processor_dict = self.video_processor_dict.copy()\n+            video_processing = video_processing_class(**video_processor_dict)\n+\n+            prev_num_frames = self.video_processor_tester.num_frames\n+            self.video_processor_tester.num_frames = 8\n+            prev_min_resolution = getattr(self.video_processor_tester, \"min_resolution\", None)\n+            prev_max_resolution = getattr(self.video_processor_tester, \"max_resolution\", None)\n+            self.video_processor_tester.min_resolution = 56\n+            self.video_processor_tester.max_resolution = 112\n+\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False,\n+                return_tensors=\"torch\",\n+            )\n+\n+            metadata = [[{\"total_num_frames\": 8, \"fps\": 4}]]\n+            batched_metadata = metadata * len(video_inputs)\n+\n+            encoded_videos = video_processing(video_inputs[0], return_tensors=\"pt\", video_metadata=metadata)[\n+                self.input_name\n+            ]\n+            encoded_videos_batched = video_processing(\n+                video_inputs, return_tensors=\"pt\", video_metadata=batched_metadata\n+            )[self.input_name]\n+\n+            self.assertIsNotNone(encoded_videos)\n+            self.assertIsNotNone(encoded_videos_batched)\n+            self.assertEqual(len(encoded_videos.shape), 2)\n+            self.assertEqual(len(encoded_videos_batched.shape), 2)\n+\n+            with self.assertRaises(ValueError):\n+                video_processing(video_inputs[0], return_tensors=\"pt\")[self.input_name]\n+\n+            self.video_processor_tester.num_frames = prev_num_frames\n+            if prev_min_resolution is not None:\n+                self.video_processor_tester.min_resolution = prev_min_resolution\n+            if prev_max_resolution is not None:\n+                self.video_processor_tester.max_resolution = prev_max_resolution"
        },
        {
            "sha": "0487e1def262c6b190c48e90a93256cac9f80d57",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/af9870265e817e57541d90c1797cb68959eb7b1e/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/af9870265e817e57541d90c1797cb68959eb7b1e/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=af9870265e817e57541d90c1797cb68959eb7b1e",
            "patch": "@@ -91,6 +91,7 @@\n     \"AriaTextModel\",\n     \"Phi4MultimodalAudioModel\",\n     \"Phi4MultimodalVisionModel\",\n+    \"Glm4vVisionModel\",\n ]\n \n # Update this list for models that are not tested with a comment explaining the reason it should not be.\n@@ -155,6 +156,7 @@\n         \"Llama4VisionModel\",  # Building part of bigger (tested) model. # TODO: add tests\n         \"Emu3VQVAE\",  # Building part of bigger (tested) model\n         \"Emu3TextModel\",  # Building part of bigger (tested) model\n+        \"Glm4vTextModel\",  # Building part of bigger (tested) model\n         \"Qwen2VLTextModel\",  # Building part of bigger (tested) model\n         \"Qwen2_5_VLTextModel\",  # Building part of bigger (tested) model\n         \"InternVLVisionModel\",  # Building part of bigger (tested) model"
        }
    ],
    "stats": {
        "total": 6849,
        "additions": 6848,
        "deletions": 1
    }
}