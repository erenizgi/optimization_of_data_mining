{
    "author": "stevhliu",
    "message": "[docs] @auto_docstring (#39011)\n\n* refactor\n\n* feedback",
    "sha": "84e8696caebea4cc8afb16a62d5eaae29f01fdd9",
    "files": [
        {
            "sha": "26f4602df8227f097cb6a8f32afa50eb4771141e",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/84e8696caebea4cc8afb16a62d5eaae29f01fdd9/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/84e8696caebea4cc8afb16a62d5eaae29f01fdd9/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=84e8696caebea4cc8afb16a62d5eaae29f01fdd9",
            "patch": "@@ -22,7 +22,7 @@\n     - local: add_new_model\n       title: Legacy model contribution\n     - local: auto_docstring\n-      title: Document your models\n+      title: Documenting a model\n     - local: attention_interface\n       title: Customizing attention function\n     title: Models"
        },
        {
            "sha": "298a501dbf4fa92c0eae8f8b5c2e779681f8099c",
            "filename": "docs/source/en/auto_docstring.md",
            "status": "modified",
            "additions": 103,
            "deletions": 102,
            "changes": 205,
            "blob_url": "https://github.com/huggingface/transformers/blob/84e8696caebea4cc8afb16a62d5eaae29f01fdd9/docs%2Fsource%2Fen%2Fauto_docstring.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/84e8696caebea4cc8afb16a62d5eaae29f01fdd9/docs%2Fsource%2Fen%2Fauto_docstring.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fauto_docstring.md?ref=84e8696caebea4cc8afb16a62d5eaae29f01fdd9",
            "patch": "@@ -14,43 +14,26 @@ rendered properly in your Markdown viewer.\n \n -->\n \n-# Utilizing the @auto_docstring Decorator\n+# Documenting a model\n \n-The `@auto_docstring` decorator in the Hugging Face Transformers library helps generate docstrings for model classes and their methods, which will be used to build the documentation for the library. It aims to improve consistency and reduce boilerplate by automatically including standard argument descriptions and allowing for targeted overrides and additions.\n+The `@auto_docstring` decorator in Transformers generates consistent docstrings for model classes and their methods. It reduces boilerplate by automatically including standard argument descriptions while also allowing overrides to add new or custom arguments. [Contributing a new model](./modular_transformers) is easier because you don't need to manually add the standard docstrings, and only focus on documenting new arguments.\n \n----\n+This guide describes how to use the `@auto_docstring` decorator and how it works.\n \n-## üìú How it Works\n+## @auto_docstring\n \n-The `@auto_docstring` decorator constructs docstrings by:\n-\n-1.  **Signature Inspection:** It inspects the signature (arguments, types, defaults) of the decorated class's `__init__` method or the decorated function.\n-2.  **Centralized Docstring Fetching:** It retrieves predefined docstrings for common arguments (e.g., `input_ids`, `attention_mask`) from internal library sources (like `ModelArgs` or `ImageProcessorArgs` in `utils/args_doc.py`).\n-3.  **Overriding or Adding Arguments Descriptions:**\n-    * **Direct Docstring Block:** It incorporates custom docstring content from an `r\"\"\" \"\"\"` (or `\"\"\" \"\"\"`) block below the method signature or within the `__init__` docstring. This is for documenting new arguments or overriding standard descriptions.\n-    * **Decorator Arguments (`custom_args`):** A `custom_args` docstring block can be passed to the decorator to provide docstrings for specific arguments directly in the decorator call. This can be used to define the docstring block for new arguments once if they are repeated in multiple places in the modeling file.\n-4.  **Adding Classes and Functions Introduction:**\n-    * **`custom_intro` argument:** Allows prepending a custom introductory paragraph to a class or function docstring.\n-    * **Automatic Introduction Generation:** For model classes with standard naming patterns (like `ModelForCausalLM`) or belonging to a pipeline, the decorator automatically generates an appropriate introductory paragraph using `ClassDocstring` in `utils/args_doc.py` as the source.\n-5.  **Templating:** The decorator uses a templating system, allowing predefined docstrings to include dynamic information deduced from the `auto_modules` of the library, such as `{{processor_class}}` or `{{config_class}}`.\n-6.  **Deducing Relevant Examples:** The decorator attempts to find appropriate usage examples based on the model's task or pipeline compatibility. It extracts checkpoint information from the model's configuration class to provide concrete examples with real model identifiers.\n-7.  **Adding Return Value Documentation:** For methods like `forward`, the decorator can automatically generate the \"Returns\" section based on the method's return type annotation. For example, for a method returning a `ModelOutput` subclass, it will extracts field descriptions from that class's docstring to create a comprehensive return value description. A custom `Returns` section can also be manually specified in the function docstring block.\n-8.  **Unrolling Kwargs Typed With Unpack Operator:** For specific methods (defined in `UNROLL_KWARGS_METHODS`) or classes (defined in `UNROLL_KWARGS_CLASSES`), the decorator processes `**kwargs` parameters that are typed with `Unpack[KwargsTypedDict]`. It extracts the documentation from the TypedDict and adds each parameter to the function's docstring. Currently, this functionality is only supported for `FastImageProcessorKwargs`.\n-\n-\n----\n-\n-## üöÄ How to Use @auto_docstring\n-\n-### 1. Importing the Decorator\n-Import the decorator into your modeling file:\n+Start by importing the decorator in the modeling file (`modular_model.py` or `modeling_model.py`).\n \n ```python\n from ...utils import auto_docstring\n ```\n \n-### 2. Applying to Classes\n-Place `@auto_docstring` directly above the class definition. It uses the `__init__` method's signature and its docstring for parameter descriptions.\n+Select whether you'd like to apply `@auto_docstring` to a class or function below to see how to use it.\n+\n+<hfoptions id=\"type\">\n+<hfoption id=\"classes\">\n+\n+Place `@auto_docstring` directly above the class definition. The decorator derives parameter descriptions from the `__init__` method's signature and docstring.\n \n ```python\n from transformers.modeling_utils import PreTrainedModel\n@@ -73,9 +56,7 @@ class MyAwesomeModel(PreTrainedModel):\n     # ... other methods\n ```\n \n-#### Advanced Class Decoration:\n-\n-Arguments can be passed directly to `@auto_docstring` for more control:\n+Arguments can also be passed directly to `@auto_docstring` for more control. Use the `custom_intro` parameter to describe the argument and the `custom_args` parameter to describe the arguments.\n \n ```python\n @auto_docstring(\n@@ -93,7 +74,7 @@ class MySpecialModel(PreTrainedModel):\n         # ...\n ```\n \n-Or:\n+You can also choose to only use `custom_intro` and define the custom arguments directly in the class.\n \n ```python\n @auto_docstring(\n@@ -111,8 +92,10 @@ class MySpecialModel(PreTrainedModel):\n         # ...\n ```\n \n-### 3. Applying to Functions (e.g., `forward` method)\n-Apply the decorator above method definitions, such as the `forward` method.\n+</hfoption>\n+<hfoption id=\"functions\">\n+\n+Place `@auto_docstring` directly above the method definition. The decorator derives parameter descriptions from the function signature.\n \n ```python\n     @auto_docstring\n@@ -131,9 +114,10 @@ Apply the decorator above method definitions, such as the `forward` method.\n         # ...\n ```\n \n-#### Advanced Function Decoration:\n+Arguments can also be passed directly to `@auto_docstring` for more control. Use the `custom_intro` parameter to describe the argument and the `custom_args` parameter to describe the arguments.\n+\n+The `Returns` and `Examples` parts of the docstring can also be manually specified.\n \n-Arguments can be passed directly to `@auto_docstring` for more control. `Returns` and `Examples` sections can also be manually specified:\n \n ```python\n MODEL_COMMON_CUSTOM_ARGS = r\"\"\"\n@@ -180,100 +164,117 @@ class MyModel(PreTrainedModel):\n         # ...\n ```\n \n----\n+</hfoption>\n+</hfoptions>\n \n-### ‚úçÔ∏è Documenting Arguments: Approach & Priority\n+## Documenting arguments\n \n-1.  **Standard Arguments (e.g., `input_ids`, `attention_mask`, `pixel_values`, `encoder_hidden_states` etc.):**\n-    * `@auto_docstring` retrieves descriptions from a central source. Do not redefine these locally if their description and shape are the same as in `args_doc.py`.\n+There are some rules for documenting different types of arguments and they're listed below.\n+\n+- Standard arguments (`input_ids`, `attention_mask`, `pixel_values`, etc.) are defined and retrieved from `args_doc.py`. It is the single source of truth for standard arguments and should not be redefined locally if an argument's description and shape is the same as an argument in `args_doc.py`.\n+\n+    If a standard argument behaves differently in your model, then you can override it locally in a `r\"\"\" \"\"\"` block. This local definition has a higher priority. For example, the `labels` argument is often customized per model and typically requires overriding.\n+\n+\n+- New or custom arguments should be documented within an `r\"\"\" \"\"\"` block after the signature if it is a function or in the `__init__` method's docstring if it is a class.\n+\n+    ```py\n+    argument_name (`type`, *optional*, defaults to `X`):\n+        Description of the argument.\n+        Explain its purpose, expected shape/type if complex, and default behavior.\n+        This can span multiple lines.\n+    ```\n \n-2.  **New or Custom Arguments:**\n-    * **Primary Method:** Document these within an `r\"\"\" \"\"\"` docstring block following the signature (for functions) or in the `__init__` method's docstring (for class parameters).\n-    * **Format:**\n-        ```\n-        argument_name (`type`, *optional*, defaults to `X`):\n-            Description of the argument.\n-            Explain its purpose, expected shape/type if complex, and default behavior.\n-            This can span multiple lines.\n-        ```\n     * Include `type` in backticks.\n-    * Add \"*optional*\" if the argument is not required (has a default value).\n-    * Add \"defaults to `X`\" if it has a default value (no need to specify \"defaults to `None`\" if the default value is `None`).\n+    * Add *optional* if the argument is not required or has a default value.\n+    * Add \"defaults to X\" if it has a default value. You don't need to add \"defaults to `None`\" if the default value is `None`.\n \n-3.  **Overriding Standard Arguments:**\n-    * If a standard argument behaves differently (e.g., different expected shape, model-specific behavior), provide its complete description in the local `r\"\"\" \"\"\"` docstring. This local definition takes precedence.\n-    * The `labels` argument is often customized per model and typically requires a specific docstring.\n+    These arguments can also be passed to `@auto_docstring` as a `custom_args` argument. It is used to define the docstring block for new arguments once if they are repeated in multiple places in the modeling file.\n \n-4.  **Using Decorator Arguments for Overrides or New Arguments (`custom_args`):**\n-    * New or custom arguments docstrings can also be passed to `@auto_docstring` as a `custom_args` argument. This can be used to define the docstring block for new arguments once if they are repeated in multiple places in the modeling file.\n+    ```py\n+    class MyModel(PreTrainedModel):\n+    # ...\n+    @auto_docstring(\n+        custom_intro=\"\"\"\n+        This is a custom introduction for the function.\n+        \"\"\"\n+        custom_args=r\"\"\"\n+        common_arg_1 (`torch.Tensor`, *optional*, defaults to `default_value`):\n+            Description of common_arg_1\n+        \"\"\"\n+    )\n+    ```\n \n----\n+## Checking the docstrings\n \n-### Usage with [modular files](./modular_transformers)\n+Transformers includes a utility script to validate the docstrings when you open a Pull Request which triggers CI (continuous integration) checks. The script checks for the following criteria.\n \n-When working with modular files, follow these guidelines for applying the `@auto_docstring` decorator:\n+* Ensures `@auto_docstring` is applied to relevant mode classes and public methods.\n+* Ensures arguments are complete and consistent. It checks that documented arguments exist in the signature and verifies whether the types and default values in the docstring match the signature. Arguments that aren't known standard arguments or if they lack a local description are flagged.\n+* Reminds you to complete placeholders like `<fill_type>` and `<fill_docstring>`.\n+* Ensures docstrings are formatted according to the expected docstring style.\n \n-- **For standalone models in modular files:**\n-  Apply the `@auto_docstring` decorator just as you would in regular modeling files.\n+You can run this check locally - before committing - by running the following command.\n \n-- **For models inheriting from other library models:**\n-  - When inheriting from a parent model, decorators (including `@auto_docstring`) are automatically carried over to the generated modeling file without needing to add them in your modular file.\n-  - If you need to modify the `@auto_docstring` behavior, apply the customized decorator in your modular file, making sure to *include all other decorators* that were present on the original function/class.\n+```bash\n+make fix-copies\n+```\n \n-  > **Warning**: When overriding any decorator in a modular file, you must include ALL decorators that were applied to that function/class in the parent model. If you only override some decorators, the others won't be included in the generated modeling file.\n+`make fix-copies` runs several other checks as well. If you don't need those checks, run the command below to only perform docstring and auto-docstring checks.\n \n+```bash\n+python utils/check_docstrings.py # to only check files included in the diff without fixing them\n+# python utils/check_docstrings.py --fix_and_overwrite # to fix and overwrite the files in the diff\n+# python utils/check_docstrings.py --fix_and_overwrite --check_all # to fix and overwrite all files\n+```\n \n-**Note**: The `check_auto_docstrings` tool doesn't check modular files directly, but it will check (and modify when using `--fix_and_overwrite`) the generated modeling files. If issues are found in the generated files, you'll need to update your modular files accordingly.\n+## modular_model.py files\n \n----\n+When working with modular files (`modular_model.py`), follow the guidelines below for applying `@auto_docstring`.\n \n-## ‚úÖ Checking Your Docstrings with `check_auto_docstrings`\n+- For standalone models in modular files, apply `@auto_docstring` like you would in a `modeling_model.py` file.\n+- For models that inherit from other library models, `@auto_docstring` is automatically carried over to the generated modeling file. You don't need to add `@auto_docstring` in your modular file.\n \n-The library includes a utility script to validate docstrings. This check is typically run during Continuous Integration (CI).\n+    If you need to modify the `@auto_docstring` behavior, apply the customized decorator in your modular file. Make sure to **include all other decorators** that are present in the original function or class.\n \n-#### What it Checks:\n+> [!WARNING]\n+> When overriding any decorator in a modular file, you must include **all** decorators that were applied to that function or class in the parent model. If you only override some decorators, the others won't be included in the generated modeling file.\n \n-* **Decorator Presence:** Ensures `@auto_docstring` is applied to relevant model classes and public methods. (TODO)\n-* **Argument Completeness & Consistency:**\n-    * Flags arguments in the signature that are not known standard arguments and lack a local description.\n-    * Ensures documented arguments exist in the signature. (TODO)\n-    * Verifies that types and default values in the docstring match the signature. (TODO)\n-* **Placeholder Detection:** Reminds you to complete placeholders like `<fill_type>` or `<fill_docstring>`.\n-* **Formatting:** Adherence to the expected docstring style.\n+## How it works\n \n-#### Running the Check Locally:\n+The `@auto_docstring` decorator automatically generates docstrings by:\n \n-Run this check locally before committing. The common command is:\n+1. Inspecting the signature (arguments, types, defaults) of the decorated class' `__init__` method or the decorated function.\n+2. Retrieving the predefined docstrings for common arguments (`input_ids`, `attention_mask`, etc.) from internal library sources like [`ModelArgs`], [`ImageProcessorArgs`], and the `args_doc.py` file.\n+3. Adding argument descriptions in one of two ways as shown below.\n \n-```bash\n-make fix-copies\n-```\n+    | method | description | usage |\n+    |---|---|---|\n+    | `r\"\"\" \"\"\"` | add custom docstring content directly to a method signature or within the `__init__` docstring | document new arguments or override standard descriptions |\n+    | `custom_args` | add custom docstrings for specific arguments directly in `@auto_docstring` | define docstring for new arguments once if they're repeated in multiple places in the modeling file |\n \n-Alternatively, to only perform docstrings and auto-docstring checks, you can use:\n+4. Adding class and function descriptions. For model classes with standard naming patterns, like `ModelForCausalLM`, or if it belongs to a pipeline, `@auto_docstring` automatically generates the appropriate descriptions with `ClassDocstring` from `args_doc.py`.\n \n-```bash\n-python utils/check_docstrings.py # to only check files included in the diff without fixing them\n-# Or: python utils/check_docstrings.py --fix_and_overwrite # to fix and overwrite the files in the diff\n-# Or: python utils/check_docstrings.py --fix_and_overwrite --check_all # to fix and overwrite all files\n-```\n+    `@auto_docstring` also accepts the `custom_intro` argument to describe a class or function.\n \n-#### Workflow with the Checker:\n+5. Using a templating system to allow predefined docstrings to include dynamic information from Transformers' [auto_modules](https://github.com/huggingface/transformers/tree/main/src/transformers/models/auto) such as `{{processor_class}}` and `{{config_class}}`.\n \n-1.  Add `@auto_docstring(...)` to the class or method.\n-2.  For new, custom, or overridden arguments, add descriptions in an `r\"\"\" \"\"\"` block.\n-3.  Run `make fix-copies` (or the `check_docstrings.py` utility).\n-    * For unrecognized arguments lacking documentation, the utility will create placeholder entries.\n-4.  Manually edit these placeholders with accurate types and descriptions.\n-5.  Re-run the check to ensure all issues are resolved.\n+6. Finding appropriate usage examples based on the model's task or pipeline compatibility. It extracts checkpoint information form the model's configuration class to provide concrete examples with real model identifiers.\n \n----\n+7. Adding return values to the docstring. For methods like `forward`, the decorator automatically generates the `Returns` field in the docstring based on the method's return type annotation.\n \n-## üîë Key Takeaways & Best Practices\n+    For example, if a method returns a [`~transformers.utils.ModelOutput`] subclass, `@auto_docstring` extracts the field descriptions from the class' docstring to create a comprehensive return value description. You can also manually specifiy a custom `Returns` field in a functions docstring.\n \n-* Use `@auto_docstring` for new PyTorch model classes (`PreTrainedModel` subclasses) and their primary for methods (e.g., `forward`, `get_text_features` etc.).\n-* For classes, the `__init__` method's docstring is the main source for parameter descriptions when using `@auto_docstring` on the class.\n-* Rely on standard docstrings; do not redefine common arguments unless their behavior is different in your specific model.\n+8. Unrolling kwargs typed with the unpack operator. For specific methods (defined in `UNROLL_KWARGS_METHODS`) or classes (defined in `UNROLL_KWARGS_CLASSES`), the decorator processes `**kwargs` parameters that are typed with `Unpack[KwargsTypedDict]`. It extracts the documentations from the `TypedDict` and adds each parameter to the function's docstring.\n+\n+    Currently only supported for [`FastImageProcessorKwargs`].\n+\n+## Best practices\n+\n+Follow the best practices below to help maintain consistent and informative documentation for Transformers!\n+\n+* Use `@auto_docstring` for new PyTorch model classes ([`PreTrainedModel`] subclasses) and their primary methods like `forward` or `get_text_features`.\n+* For classes, `@auto_docstring` retrieves parameter descriptions from the `__init__` method's docstring.\n+* Rely on standard docstrings and do not redefine common arguments unless their behavior is different in your model.\n * Document new or custom arguments clearly.\n * Run `check_docstrings` locally and iteratively.\n-\n-By following these guidelines, you help maintain consistent and informative documentation for the Hugging Face Transformers library ü§ó."
        },
        {
            "sha": "76d77e2ffd5ebcc6154e74138539e77000debdca",
            "filename": "docs/source/en/modular_transformers.md",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/84e8696caebea4cc8afb16a62d5eaae29f01fdd9/docs%2Fsource%2Fen%2Fmodular_transformers.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/84e8696caebea4cc8afb16a62d5eaae29f01fdd9/docs%2Fsource%2Fen%2Fmodular_transformers.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodular_transformers.md?ref=84e8696caebea4cc8afb16a62d5eaae29f01fdd9",
            "patch": "@@ -540,6 +540,9 @@ This makes it very easy to switch decorators and makes it explicit that the only\n \n ## Docstring variables\n \n+> [!TIP]\n+> Refer to the [Documeting a model](./auto_docstring) guide for more information about how you can use the `@auto_docstring` decorator to help automatically generate consistent docstring arguments.\n+\n If an object defined in both the modular and modeling file from which it inherits, the modular definition has precedence unless for assignments containing the pattern `DOCSTRING`. These variables are typically used in `MODEL_START_DOCSTRING` and `MODEL_INPUT_DOCSTRING` in the modeling files. They are big blocks of docstrings and the linter rewrites the names everywhere. For this reason, assignments containing the `DOCSTRING` variable can use the definition found in the source file without copying the whole docstring, by simply setting the variable to `None` in the modular file.\n \n This is very useful if you need the variable reference somewhere but you don't want to clutter the modular file with docstrings which are always the same. The example code below allows you to automatically use the same docstrings from [Mistral](./model_doc/mistral) in [Starcoder2](./model_doc/starcoder2)."
        }
    ],
    "stats": {
        "total": 210,
        "additions": 107,
        "deletions": 103
    }
}