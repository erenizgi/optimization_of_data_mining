{
    "author": "MekkCyber",
    "message": "Add Bitnet model (#37742)\n\n* Adding BitNet b1.58 Model\n\n* Add testing code for BitNet\n\n* Fix format issues\n\n* Fix docstring format issues\n\n* Fix docstring\n\n* Fix docstring\n\n* Fix: weight back to uint8\n\n* Fix\n\n* Fix format issues\n\n* Remove copy comments\n\n* Add model link to the docstring\n\n* Fix: set tie_word_embeddings default to false\n\n* Update\n\n* Generate modeling file\n\n* Change config name for automatically generating modeling file.\n\n* Generate modeling file\n\n* Fix class name\n\n* Change testing branch\n\n* Remove unused param\n\n* Fix config docstring\n\n* Add docstring for BitNetQuantConfig.\n\n* Fix docstring\n\n* Update docs/source/en/model_doc/bitnet.md\n\nCo-authored-by: Mohamed Mekkouri <93391238+MekkCyber@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/bitnet.md\n\nCo-authored-by: Marc Sun <57196510+SunMarc@users.noreply.github.com>\n\n* Update bitnet config\n\n* Update explanation between online and offline mode\n\n* Remove space\n\n* revert changes\n\n* more revert\n\n* spaces\n\n* update\n\n* fix-copies\n\n* doc fix\n\n* fix minor nits\n\n* empty\n\n* small nit\n\n* empty\n\n---------\n\nCo-authored-by: Shuming Ma <shumingma@pku.edu.cn>\nCo-authored-by: shumingma <shmingm@gmail.com>\nCo-authored-by: Marc Sun <57196510+SunMarc@users.noreply.github.com>",
    "sha": "b262680af446ce012f43a44f20d97f8a2abba3bd",
    "files": [
        {
            "sha": "6a9a50c1f720aec82f8779f310c0d269cf552728",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -385,6 +385,8 @@\n         title: BigBirdPegasus\n       - local: model_doc/biogpt\n         title: BioGpt\n+      - local: model_doc/bitnet\n+        title: BitNet\n       - local: model_doc/blenderbot\n         title: Blenderbot\n       - local: model_doc/blenderbot-small"
        },
        {
            "sha": "83bc5451bc40d535f511aceff37599f965ffa1e4",
            "filename": "docs/source/en/main_classes/quantization.md",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/docs%2Fsource%2Fen%2Fmain_classes%2Fquantization.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/docs%2Fsource%2Fen%2Fmain_classes%2Fquantization.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmain_classes%2Fquantization.md?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -77,9 +77,9 @@ Learn how to quantize models in the [Quantization](../quantization) guide.\n \n [[autodoc]] TorchAoConfig\n \n-## BitNetConfig\n+## BitNetQuantConfig\n \n-[[autodoc]] BitNetConfig\n+[[autodoc]] BitNetQuantConfig\n \n ## SpQRConfig\n "
        },
        {
            "sha": "b77ac6c700c60f122b74d627eb415ab2fe39c73e",
            "filename": "docs/source/en/model_doc/bitnet.md",
            "status": "added",
            "additions": 121,
            "deletions": 0,
            "changes": 121,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/docs%2Fsource%2Fen%2Fmodel_doc%2Fbitnet.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/docs%2Fsource%2Fen%2Fmodel_doc%2Fbitnet.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fbitnet.md?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -0,0 +1,121 @@\n+<!--Copyright 2025 The BitNet Team and The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# BitNet\n+\n+## Overview\n+\n+Trained on a corpus of 4 trillion tokens, this model demonstrates that native 1-bit LLMs can achieve performance comparable to leading open-weight, full-precision models of similar size, while offering substantial advantages in computational efficiency (memory, energy, latency).\n+\n+âž¡ï¸ **Technical Report:** [BitNet b1.58 2B4T Technical Report](https://arxiv.org/abs/2504.12285)\n+\n+âž¡ï¸ **Official Inference Code:** [microsoft/BitNet (bitnet.cpp)](https://github.com/microsoft/BitNet)\n+\n+## Model Variants\n+\n+Several versions of the model weights are available on Hugging Face:\n+\n+* [**`microsoft/bitnet-b1.58-2B-4T`**](https://huggingface.co/microsoft/bitnet-b1.58-2B-4T): Contains the packed 1.58-bit weights optimized for efficient inference. **Use this for deployment.**\n+\n+* [**`microsoft/bitnet-b1.58-2B-4T-bf16`**](https://huggingface.co/microsoft/bitnet-b1.58-2B-4T-bf16): Contains the master weights in BF16 format. **Use this only for training or fine-tuning purposes.**\n+\n+* [**`microsoft/bitnet-b1.58-2B-4T-gguf`**](https://huggingface.co/microsoft/bitnet-b1.58-2B-4T-gguf): Contains the model weights in GGUF format, compatible with the `bitnet.cpp` library for CPU inference.\n+\n+\n+### Model Details\n+\n+\n+* **Architecture:** Transformer-based, modified with `BitLinear` layers (BitNet framework).\n+    * Uses Rotary Position Embeddings (RoPE).\n+    * Uses squared ReLU (ReLUÂ²) activation in FFN layers.\n+    * Employs [`subln`](https://proceedings.mlr.press/v202/wang23u.html) normalization.\n+    * No bias terms in linear or normalization layers.\n+* **Quantization:** Native 1.58-bit weights and 8-bit activations (W1.58A8).\n+    * Weights are quantized to ternary values {-1, 0, +1} using absmean quantization during the forward pass.\n+    * Activations are quantized to 8-bit integers using absmax quantization (per-token).\n+    * **Crucially, the model was *trained from scratch* with this quantization scheme, not post-training quantized.**\n+* **Parameters:** ~2 Billion\n+* **Training Tokens:** 4 Trillion\n+*   **Context Length:** Maximum sequence length of **4096 tokens**.\n+    *   *Recommendation:* For optimal performance on tasks requiring very long contexts (beyond the pre-training length or for specialized long-reasoning tasks), we recommend performing intermediate long-sequence adaptation/training before the final fine-tuning stage.\n+* **Training Stages:**\n+    1.  **Pre-training:** Large-scale training on public text/code and synthetic math data using a two-stage learning rate and weight decay schedule.\n+    2.  **Supervised Fine-tuning (SFT):** Fine-tuned on instruction-following and conversational datasets using sum loss aggregation and specific hyperparameter tuning.\n+    3.  **Direct Preference Optimization (DPO):** Aligned with human preferences using preference pairs.\n+* **Tokenizer:** LLaMA 3 Tokenizer (vocab size: 128,256).\n+\n+\n+## Usage tips\n+\n+\n+**VERY IMPORTANT NOTE ON EFFICIENCY**\n+\n+> Please do NOT expect performance efficiency gains (in terms of speed, latency, or energy consumption) when using this model with the standard transformers library.\n+>\n+> The current execution paths within transformers do not contain the specialized, highly optimized computational kernels required to leverage the advantages of the BitNet architecture. Running the model via transformers will likely result in inference speeds and energy usage comparable to, or potentially worse than, standard full-precision models within this framework on both CPU and GPU.\n+>\n+> While you might observe reduced memory usage due to the quantized weights, the primary computational efficiency benefits are not accessible through this standard transformers usage path.\n+>\n+> For achieving the efficiency benefits demonstrated in the technical paper, you MUST use the dedicated C++ implementation: [bitnet.cpp](https://github.com/microsoft/BitNet).\n+\n+### Requirements\n+\n+```bash\n+pip install transformers\n+```\n+\n+### Example\n+\n+```python\n+import torch\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+model_id = \"microsoft/bitnet-b1.58-2B-4T\"\n+\n+# Load tokenizer and model\n+tokenizer = AutoTokenizer.from_pretrained(model_id)\n+model = AutoModelForCausalLM.from_pretrained(\n+    model_id,\n+    torch_dtype=torch.bfloat16\n+)\n+\n+# Apply the chat template\n+messages = [\n+    {\"role\": \"system\", \"content\": \"You are a helpful AI assistant.\"},\n+    {\"role\": \"user\", \"content\": \"How are you?\"},\n+]\n+chat_input = tokenizer.apply_chat_template(messages, tokenize=True, add_generation_prompt=True, return_tensors=\"pt\").to(model.device)\n+\n+# Generate response\n+chat_outputs = model.generate(chat_input, max_new_tokens=50)\n+response = tokenizer.decode(chat_outputs[0][chat_input.shape[-1]:], skip_special_tokens=True) # Decode only the response part\n+print(\"\\nAssistant Response:\", response)\n+```\n+\n+\n+## BitNetConfig\n+\n+[[autodoc]] BitNetConfig\n+\n+## BitNetModel\n+\n+[[autodoc]] BitNetModel\n+    - forward\n+\n+## BitNetForCausalLM\n+\n+[[autodoc]] BitNetForCausalLM\n+    - forward"
        },
        {
            "sha": "691f8aad00d86be517df03fd4323d509ff4454da",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -261,7 +261,7 @@\n         \"AqlmConfig\",\n         \"AutoRoundConfig\",\n         \"AwqConfig\",\n-        \"BitNetConfig\",\n+        \"BitNetQuantConfig\",\n         \"BitsAndBytesConfig\",\n         \"CompressedTensorsConfig\",\n         \"EetqConfig\",\n@@ -757,7 +757,7 @@\n         AqlmConfig,\n         AutoRoundConfig,\n         AwqConfig,\n-        BitNetConfig,\n+        BitNetQuantConfig,\n         BitsAndBytesConfig,\n         CompressedTensorsConfig,\n         EetqConfig,"
        },
        {
            "sha": "d1fa65978dbc9bb46990f5c79a2526512b3a1ba6",
            "filename": "src/transformers/integrations/bitnet.py",
            "status": "modified",
            "additions": 112,
            "deletions": 8,
            "changes": 120,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fintegrations%2Fbitnet.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fintegrations%2Fbitnet.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fintegrations%2Fbitnet.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -190,6 +190,98 @@ def forward(self, input):\n         return y\n \n \n+class WeightQuant(torch.autograd.Function):\n+    \"\"\"\n+    Implements a custom autograd function for weight quantization.\n+    This performs ternary quantization (-1, 0, 1) based on scaling by the\n+    mean absolute value of the weights. It uses the Straight-Through Estimator\n+    (STE) for the backward pass.\n+    \"\"\"\n+\n+    @staticmethod\n+    @torch.compile\n+    def forward(ctx, weight):\n+        dtype = weight.dtype\n+        weight = weight.float()\n+        scale = 1.0 / weight.abs().mean().clamp_(min=1e-5)\n+        weight = (weight * scale).round().clamp(-1, 1) / scale\n+        return weight.to(dtype)\n+\n+    @staticmethod\n+    def backward(ctx, grad_output):\n+        grad_input = grad_output.clone()\n+        return grad_input\n+\n+\n+class ActQuant(torch.autograd.Function):\n+    \"\"\"\n+    Implements a custom autograd function for activation quantization.\n+    This performs symmetric 8-bit quantization (to the range [-128, 127])\n+    based on the maximum absolute value along the last dimension (per-token/row scaling).\n+    It uses the Straight-Through Estimator (STE) for the backward pass.\n+    \"\"\"\n+\n+    @staticmethod\n+    @torch.compile\n+    def forward(ctx, activation):\n+        dtype = activation.dtype\n+        activation = activation.float()\n+        scale = 127 / activation.abs().max(dim=-1, keepdim=True).values.clamp_(min=1e-5)\n+        activation = (activation * scale).round().clamp(-128, 127) / scale\n+        return activation.to(dtype)\n+\n+    @staticmethod\n+    def backward(ctx, grad_output):\n+        grad_input = grad_output.clone()\n+        return grad_input\n+\n+\n+class AutoBitLinear(nn.Linear):\n+    def __init__(\n+        self,\n+        in_features: int,\n+        out_features: int,\n+        bias: bool = True,\n+        device=None,\n+        dtype=None,\n+        online_quant: bool = False,\n+    ):\n+        super().__init__(in_features, out_features, bias)\n+        self.online_quant = online_quant\n+        if not online_quant:\n+            self.register_buffer(\n+                \"weight_scale\",\n+                torch.ones(\n+                    (1),\n+                    dtype=dtype,\n+                    device=device,\n+                ),\n+            )\n+            self._register_load_state_dict_pre_hook(self.load_hook)\n+\n+    def load_hook(\n+        self,\n+        state_dict,\n+        prefix,\n+        *args,\n+        **kwargs,\n+    ):\n+        if (prefix + \"weight\") in state_dict and state_dict[prefix + \"weight\"].dtype != self.weight.dtype:\n+            state_dict[prefix + \"weight\"] = unpack_weights(state_dict[prefix + \"weight\"], dtype=self.weight.dtype)\n+        return state_dict\n+\n+    def forward(self, input):\n+        if self.online_quant:\n+            weight = WeightQuant.apply(self.weight)\n+        else:\n+            weight = self.weight\n+        input = ActQuant.apply(input)\n+        output = F.linear(input, weight, self.bias)\n+        if not self.online_quant:\n+            output = output * self.weight_scale\n+        return output\n+\n+\n def _replace_with_bitnet_linear(\n     model,\n     modules_to_not_convert=None,\n@@ -218,15 +310,27 @@ def _replace_with_bitnet_linear(\n                 if isinstance(module, nn.Linear) and name not in modules_to_not_convert:\n                     in_features = module.in_features\n                     out_features = module.out_features\n-                    model._modules[name] = BitLinear(\n-                        in_features=in_features,\n-                        out_features=out_features,\n-                        bias=module.bias is not None,\n-                        device=module.weight.device,\n-                        dtype=module.weight.dtype,\n-                    )\n+                    if quantization_config and quantization_config.linear_class == \"autobitlinear\":\n+                        model._modules[name] = AutoBitLinear(\n+                            in_features=in_features,\n+                            out_features=out_features,\n+                            bias=module.bias is not None,\n+                            device=module.weight.device,\n+                            dtype=module.weight.dtype,\n+                            online_quant=(quantization_config.quantization_mode == \"online\"),\n+                        )\n+                        if quantization_config.quantization_mode == \"offline\":\n+                            model._modules[name].requires_grad_(False)\n+                    else:\n+                        model._modules[name] = BitLinear(\n+                            in_features=in_features,\n+                            out_features=out_features,\n+                            bias=module.bias is not None,\n+                            device=module.weight.device,\n+                            dtype=module.weight.dtype,\n+                        )\n+                        model._modules[name].requires_grad_(False)\n                     has_been_replaced = True\n-                    model._modules[name].requires_grad_(False)\n \n         if len(list(module.children())) > 0:\n             _, has_been_replaced = _replace_with_bitnet_linear("
        },
        {
            "sha": "8b439b47c0b955dc326e107da2baa3186884d9e9",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -40,6 +40,7 @@\n     from .bigbird_pegasus import *\n     from .biogpt import *\n     from .bit import *\n+    from .bitnet import *\n     from .blenderbot import *\n     from .blenderbot_small import *\n     from .blip import *"
        },
        {
            "sha": "9da4e5c460bc56dc7c898a3c0fa723c2e4910a43",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -50,6 +50,7 @@\n         (\"bigbird_pegasus\", \"BigBirdPegasusConfig\"),\n         (\"biogpt\", \"BioGptConfig\"),\n         (\"bit\", \"BitConfig\"),\n+        (\"bitnet\", \"BitNetConfig\"),\n         (\"blenderbot\", \"BlenderbotConfig\"),\n         (\"blenderbot-small\", \"BlenderbotSmallConfig\"),\n         (\"blip\", \"BlipConfig\"),\n@@ -398,6 +399,7 @@\n         (\"bigbird_pegasus\", \"BigBird-Pegasus\"),\n         (\"biogpt\", \"BioGpt\"),\n         (\"bit\", \"BiT\"),\n+        (\"bitnet\", \"BitNet\"),\n         (\"blenderbot\", \"Blenderbot\"),\n         (\"blenderbot-small\", \"BlenderbotSmall\"),\n         (\"blip\", \"BLIP\"),"
        },
        {
            "sha": "889d3658ed235aaddbd9288b8142a060c9003335",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -49,6 +49,7 @@\n         (\"bigbird_pegasus\", \"BigBirdPegasusModel\"),\n         (\"biogpt\", \"BioGptModel\"),\n         (\"bit\", \"BitModel\"),\n+        (\"bitnet\", \"BitNetModel\"),\n         (\"blenderbot\", \"BlenderbotModel\"),\n         (\"blenderbot-small\", \"BlenderbotSmallModel\"),\n         (\"blip\", \"BlipModel\"),\n@@ -515,6 +516,7 @@\n         (\"big_bird\", \"BigBirdForCausalLM\"),\n         (\"bigbird_pegasus\", \"BigBirdPegasusForCausalLM\"),\n         (\"biogpt\", \"BioGptForCausalLM\"),\n+        (\"bitnet\", \"BitNetForCausalLM\"),\n         (\"blenderbot\", \"BlenderbotForCausalLM\"),\n         (\"blenderbot-small\", \"BlenderbotSmallForCausalLM\"),\n         (\"bloom\", \"BloomForCausalLM\"),"
        },
        {
            "sha": "c3428dd3800b58e8052c53cbd71adb7dce8ea451",
            "filename": "src/transformers/models/bitnet/__init__.py",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2Fbitnet%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2Fbitnet%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fbitnet%2F__init__.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -0,0 +1,27 @@\n+# Copyright 2025 The BitNet Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_bitnet import *\n+    from .modeling_bitnet import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "645af2699e2fdc1987e213be446ffe1a95d13358",
            "filename": "src/transformers/models/bitnet/configuration_bitnet.py",
            "status": "added",
            "additions": 147,
            "deletions": 0,
            "changes": 147,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2Fbitnet%2Fconfiguration_bitnet.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2Fbitnet%2Fconfiguration_bitnet.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fbitnet%2Fconfiguration_bitnet.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -0,0 +1,147 @@\n+# coding=utf-8\n+# Copyright 2025 The BitNet Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+\"\"\"BitNet model configuration\"\"\"\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...utils import logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class BitNetConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`BitNetModel`]. It is used to instantiate an BitNet\n+    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n+    defaults will yield a similar configuration to that of\n+    BitNet b1.58 2B4T [microsoft/bitnet-b1.58-2B-4T](https://huggingface.co/microsoft/bitnet-b1.58-2B-4T).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 128256):\n+            Vocabulary size of the BitNet model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`BitNetModel`]\n+        hidden_size (`int`, *optional*, defaults to 2560):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 6912):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 30):\n+            Number of hidden layers in the Transformer decoder.\n+        num_attention_heads (`int`, *optional*, defaults to 20):\n+            Number of attention heads for each attention layer in the Transformer decoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 5):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1 the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to\n+            `num_attention_heads`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"relu2\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 2048):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        pad_token_id (`int`, *optional*):\n+            Padding token id.\n+        bos_token_id (`int`, *optional*, defaults to 128000):\n+            Beginning of stream token id.\n+        eos_token_id (`int`, *optional*, defaults to 128001):\n+            End of stream token id.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether to tie weight embeddings\n+        rope_theta (`float`, *optional*, defaults to 500000.0):\n+            The base period of the RoPE embeddings.\n+        attention_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+\n+    ```python\n+    >>> from transformers import BitNetModel, BitNetConfig\n+\n+    >>> # Initializing a BitNet style configuration\n+    >>> configuration = BitNetConfig()\n+\n+    >>> # Initializing a model from the BitNet style configuration\n+    >>> model = BitNetModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"bitnet\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        vocab_size=128256,\n+        hidden_size=2560,\n+        intermediate_size=6912,\n+        num_hidden_layers=30,\n+        num_attention_heads=20,\n+        num_key_value_heads=5,\n+        hidden_act=\"relu2\",\n+        max_position_embeddings=2048,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-5,\n+        use_cache=True,\n+        pad_token_id=None,\n+        bos_token_id=128000,\n+        eos_token_id=128001,\n+        tie_word_embeddings=False,\n+        rope_theta=500000.0,\n+        attention_bias=False,\n+        attention_dropout=0.0,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+\n+\n+__all__ = [\"BitNetConfig\"]"
        },
        {
            "sha": "2f722ba00b251f62af7f3133d63c0efc7c808175",
            "filename": "src/transformers/models/bitnet/modeling_bitnet.py",
            "status": "added",
            "additions": 823,
            "deletions": 0,
            "changes": 823,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2Fbitnet%2Fmodeling_bitnet.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2Fbitnet%2Fmodeling_bitnet.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fbitnet%2Fmodeling_bitnet.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -0,0 +1,823 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/bitnet/modular_bitnet.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_bitnet.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 The BitNet Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+\n+from typing import Callable, Optional, Tuple, Union\n+\n+import torch\n+from torch import nn\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache, StaticCache\n+from ...generation import GenerationMixin\n+from ...integrations import use_kernel_forward_from_hub\n+from ...modeling_attn_mask_utils import AttentionMaskConverter\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import BaseModelOutputWithPast, CausalLMOutputWithPast\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS, dynamic_rope_update\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import (\n+    LossKwargs,\n+    add_start_docstrings,\n+    add_start_docstrings_to_model_forward,\n+    can_return_tuple,\n+    is_torch_flex_attn_available,\n+    logging,\n+    replace_return_docstrings,\n+)\n+from .configuration_bitnet import BitNetConfig\n+\n+\n+if is_torch_flex_attn_available():\n+    from torch.nn.attention.flex_attention import BlockMask\n+\n+    from ...integrations.flex_attention import make_flex_block_causal_mask\n+\n+\n+logger = logging.get_logger(__name__)\n+_CONFIG_FOR_DOC = \"BitNetConfig\"\n+\n+\n+@use_kernel_forward_from_hub(\"RMSNorm\")\n+class BitNetRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        BitNetRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class BitNetMLP(nn.Module):\n+    def __init__(self, config: BitNetConfig):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=False)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+        self.ffn_sub_norm = BitNetRMSNorm(config.intermediate_size, eps=config.rms_norm_eps)\n+\n+    def forward(self, x):\n+        down_proj = self.down_proj(self.ffn_sub_norm(self.act_fn(self.gate_proj(x)) * self.up_proj(x)))\n+        return down_proj\n+\n+\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`, *optional*):\n+            Deprecated and unused.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    return q_embed, k_embed\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs,\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+class BitNetAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: BitNetConfig, layer_idx: int):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.head_dim = getattr(config, \"head_dim\", config.hidden_size // config.num_attention_heads)\n+        self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.attention_dropout = config.attention_dropout\n+        self.is_causal = True\n+\n+        self.q_proj = nn.Linear(\n+            config.hidden_size, config.num_attention_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.k_proj = nn.Linear(\n+            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.v_proj = nn.Linear(\n+            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.o_proj = nn.Linear(\n+            config.num_attention_heads * self.head_dim, config.hidden_size, bias=config.attention_bias\n+        )\n+        self.attn_sub_norm = BitNetRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: Tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+\n+        if self.config._attn_implementation != \"eager\":\n+            if self.config._attn_implementation == \"sdpa\" and kwargs.get(\"output_attentions\", False):\n+                logger.warning_once(\n+                    \"`torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. Falling back to \"\n+                    'eager attention. This warning can be removed using the argument `attn_implementation=\"eager\"` when loading the model.'\n+                )\n+            else:\n+                attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.attn_sub_norm(attn_output)  # diff with Llama\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class BitNetDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: BitNetConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        self.self_attn = BitNetAttention(config=config, layer_idx=layer_idx)\n+\n+        self.mlp = BitNetMLP(config)\n+        self.input_layernorm = BitNetRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = BitNetRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: Optional[bool] = False,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,  # necessary, but kept here for BC\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Tuple[torch.FloatTensor, Optional[Tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        residual = hidden_states\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # Self Attention\n+        hidden_states, self_attn_weights = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        outputs = (hidden_states,)\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        return outputs\n+\n+\n+class BitNetRotaryEmbedding(nn.Module):\n+    def __init__(self, config: BitNetConfig, device=None):\n+        super().__init__()\n+        # BC: \"rope_type\" was originally \"type\"\n+        if hasattr(config, \"rope_scaling\") and config.rope_scaling is not None:\n+            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n+        else:\n+            self.rope_type = \"default\"\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = self.inv_freq\n+\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1).to(x.device)\n+        position_ids_expanded = position_ids[:, None, :].float()\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(1, 2)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos() * self.attention_scaling\n+            sin = emb.sin() * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+BITNET_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`BitNetConfig`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare BitNet Model outputting raw hidden-states without any specific head on top.\",\n+    BITNET_START_DOCSTRING,\n+)\n+class BitNetPreTrainedModel(PreTrainedModel):\n+    config_class = BitNetConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"BitNetDecoderLayer\"]\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = True\n+    _supports_flex_attn = True\n+    _supports_cache_class = True\n+    _supports_quantized_cache = True\n+    _supports_static_cache = True\n+    _supports_attention_backend = True\n+\n+    def _init_weights(self, module):\n+        std = self.config.initializer_range\n+        if isinstance(module, nn.Linear):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+        elif isinstance(module, BitNetRMSNorm):\n+            module.weight.data.fill_(1.0)\n+\n+\n+BITNET_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+            it.\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            [What are input IDs?](../glossary#input-ids)\n+        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length) or `BlockMask`, *optional*):\n+            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+            - 1 for tokens that are **not masked**,\n+            - 0 for tokens that are **masked**.\n+\n+            If the model is configured to use flex_attention, it will attempt to convert the mask Tensor into a BlockMask,\n+            but you can also pass a `BlockMask` object directly here.\n+\n+            [What are attention masks?](../glossary#attention-mask)\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            If `past_key_values` is used, optionally only the last `input_ids` have to be input (see\n+            `past_key_values`).\n+\n+            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n+            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n+            information on the default strategy.\n+\n+            - 1 indicates the head is **not masked**,\n+            - 0 indicates the head is **masked**.\n+        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n+            config.n_positions - 1]`.\n+\n+            [What are position IDs?](../glossary#position-ids)\n+        past_key_values (`Cache`, *optional*):\n+            Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n+            blocks) that can be used to speed up sequential decoding. This typically consists in the `past_key_values`\n+            returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n+\n+            It is a [`~cache_utils.Cache`] instance. For more details, see our [kv cache guide](https://huggingface.co/docs/transformers/en/kv_cache).\n+\n+            If `past_key_values` are used, the user can optionally input only the last `input_ids` (those that don't\n+            have their past key value states given to this model) of shape `(batch_size, 1)` instead of all `input_ids`\n+            of shape `(batch_size, sequence_length)`.\n+        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n+            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n+            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n+            model's internal embedding lookup matrix.\n+        use_cache (`bool`, *optional*):\n+            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n+            `past_key_values`).\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+        cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n+            Indices depicting the position of the input sequence tokens in the sequence. Contrarily to `position_ids`,\n+            this tensor is not affected by padding. It is used to update the cache in the correct position and to infer\n+            the complete sequence length.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare BitNet Model outputting raw hidden-states without any specific head on top.\",\n+    BITNET_START_DOCSTRING,\n+)\n+class BitNetModel(BitNetPreTrainedModel):\n+    \"\"\"\n+    Transformer decoder consisting of *config.num_hidden_layers* layers. Each layer is a [`BitNetDecoderLayer`]\n+\n+    Args:\n+        config: BitNetConfig\n+    \"\"\"\n+\n+    def __init__(self, config: BitNetConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [BitNetDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = BitNetRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = BitNetRotaryEmbedding(config=config)\n+        self.gradient_checkpointing = False\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.embed_tokens = value\n+\n+    @can_return_tuple\n+    @add_start_docstrings_to_model_forward(BITNET_INPUTS_DOCSTRING)\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **flash_attn_kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> BaseModelOutputWithPast:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if self.gradient_checkpointing and self.training and use_cache:\n+            logger.warning_once(\n+                \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`.\"\n+            )\n+            use_cache = False\n+\n+        # TODO (joao): remove this exception in v4.56 -- it exists for users that try to pass a legacy cache\n+        if not isinstance(past_key_values, (type(None), Cache)):\n+            raise ValueError(\"The `past_key_values` should be either a `Cache` object or `None`.\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache()\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        causal_mask = self._update_causal_mask(\n+            attention_mask, inputs_embeds, cache_position, past_key_values, output_attentions\n+        )\n+\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            layer_outputs = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask,\n+                position_ids=position_ids,\n+                past_key_value=past_key_values,\n+                output_attentions=output_attentions,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                position_embeddings=position_embeddings,\n+                **flash_attn_kwargs,\n+            )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        # add hidden states from the last decoder layer\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values if use_cache else None,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+        )\n+\n+    def _update_causal_mask(\n+        self,\n+        attention_mask: Union[torch.Tensor, \"BlockMask\"],\n+        input_tensor: torch.Tensor,\n+        cache_position: torch.Tensor,\n+        past_key_values: Cache,\n+        output_attentions: bool = False,\n+    ):\n+        if self.config._attn_implementation == \"flash_attention_2\":\n+            if attention_mask is not None and (attention_mask == 0.0).any():\n+                return attention_mask\n+            return None\n+        if self.config._attn_implementation == \"flex_attention\":\n+            if isinstance(attention_mask, torch.Tensor):\n+                attention_mask = make_flex_block_causal_mask(attention_mask)\n+            return attention_mask\n+\n+        # For SDPA, when possible, we will rely on its `is_causal` argument instead of its `attn_mask` argument, in\n+        # order to dispatch on Flash Attention 2. This feature is not compatible with static cache, as SDPA will fail\n+        # to infer the attention mask.\n+        past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+        using_static_cache = isinstance(past_key_values, StaticCache)\n+\n+        # When output attentions is True, sdpa implementation's forward method calls the eager implementation's forward\n+        if self.config._attn_implementation == \"sdpa\" and not using_static_cache and not output_attentions:\n+            if AttentionMaskConverter._ignore_causal_mask_sdpa(\n+                attention_mask,\n+                inputs_embeds=input_tensor,\n+                past_key_values_length=past_seen_tokens,\n+                is_training=self.training,\n+            ):\n+                return None\n+\n+        dtype = input_tensor.dtype\n+        sequence_length = input_tensor.shape[1]\n+        if using_static_cache:\n+            target_length = past_key_values.get_max_cache_shape()\n+        else:\n+            target_length = (\n+                attention_mask.shape[-1]\n+                if isinstance(attention_mask, torch.Tensor)\n+                else past_seen_tokens + sequence_length + 1\n+            )\n+\n+        # In case the provided `attention` mask is 2D, we generate a causal mask here (4D).\n+        causal_mask = self._prepare_4d_causal_attention_mask_with_cache_position(\n+            attention_mask,\n+            sequence_length=sequence_length,\n+            target_length=target_length,\n+            dtype=dtype,\n+            cache_position=cache_position,\n+            batch_size=input_tensor.shape[0],\n+        )\n+\n+        if (\n+            self.config._attn_implementation == \"sdpa\"\n+            and attention_mask is not None\n+            and attention_mask.device.type in [\"cuda\", \"xpu\", \"npu\"]\n+            and not output_attentions\n+        ):\n+            # Attend to all tokens in fully masked rows in the causal_mask, for example the relevant first rows when\n+            # using left padding. This is required by F.scaled_dot_product_attention memory-efficient attention path.\n+            # Details: https://github.com/pytorch/pytorch/issues/110213\n+            min_dtype = torch.finfo(dtype).min\n+            causal_mask = AttentionMaskConverter._unmask_unattended(causal_mask, min_dtype)\n+\n+        return causal_mask\n+\n+    @staticmethod\n+    def _prepare_4d_causal_attention_mask_with_cache_position(\n+        attention_mask: torch.Tensor,\n+        sequence_length: int,\n+        target_length: int,\n+        dtype: torch.dtype,\n+        cache_position: torch.Tensor,\n+        batch_size: int,\n+        **kwargs,\n+    ):\n+        \"\"\"\n+        Creates a causal 4D mask of shape `(batch_size, 1, query_length, key_value_length)` from a 2D mask of shape\n+        `(batch_size, key_value_length)`, or if the input `attention_mask` is already 4D, do nothing.\n+\n+        Args:\n+            attention_mask (`torch.Tensor`):\n+                A 2D attention mask of shape `(batch_size, key_value_length)` or a 4D attention mask of shape\n+                `(batch_size, 1, query_length, key_value_length)`.\n+            sequence_length (`int`):\n+                The sequence length being processed.\n+            target_length (`int`):\n+                The target length: when generating with static cache, the mask should be as long as the static cache,\n+                to account for the 0 padding, the part of the cache that is not filled yet.\n+            dtype (`torch.dtype`):\n+                The dtype to use for the 4D attention mask.\n+            cache_position (`torch.Tensor`):\n+                Indices depicting the position of the input sequence tokens in the sequence.\n+            batch_size (`torch.Tensor`):\n+                Batch size.\n+        \"\"\"\n+        if attention_mask is not None and attention_mask.dim() == 4:\n+            # In this case we assume that the mask comes already in inverted form and requires no inversion or slicing.\n+            causal_mask = attention_mask\n+        else:\n+            min_dtype = torch.finfo(dtype).min\n+            causal_mask = torch.full(\n+                (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=cache_position.device\n+            )\n+            if sequence_length != 1:\n+                causal_mask = torch.triu(causal_mask, diagonal=1)\n+            causal_mask *= torch.arange(target_length, device=cache_position.device) > cache_position.reshape(-1, 1)\n+            causal_mask = causal_mask[None, None, :, :].expand(batch_size, 1, -1, -1)\n+            if attention_mask is not None:\n+                causal_mask = causal_mask.clone()  # copy to contiguous memory for in-place edit\n+                mask_length = attention_mask.shape[-1]\n+                padding_mask = causal_mask[:, :, :, :mask_length] + attention_mask[:, None, None, :].to(\n+                    causal_mask.device\n+                )\n+                padding_mask = padding_mask == 0\n+                causal_mask[:, :, :, :mask_length] = causal_mask[:, :, :, :mask_length].masked_fill(\n+                    padding_mask, min_dtype\n+                )\n+\n+        return causal_mask\n+\n+\n+class KwargsForCausalLM(FlashAttentionKwargs, LossKwargs): ...\n+\n+\n+class BitNetForCausalLM(BitNetPreTrainedModel, GenerationMixin):\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+    _tp_plan = None\n+    _pp_plan = None\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = BitNetModel(config)\n+        self.vocab_size = config.vocab_size\n+        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    def get_output_embeddings(self):\n+        return self.lm_head\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.lm_head = new_embeddings\n+\n+    def set_decoder(self, decoder):\n+        self.model = decoder\n+\n+    def get_decoder(self):\n+        return self.model\n+\n+    @can_return_tuple\n+    @add_start_docstrings_to_model_forward(BITNET_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=CausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[KwargsForCausalLM],\n+    ) -> CausalLMOutputWithPast:\n+        r\"\"\"\n+        Args:\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, transformers.,\n+                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, transformers., config.vocab_size]`.\n+\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, BitNetForCausalLM\n+\n+        >>> model = BitNetForCausalLM.from_pretrained(\"microsoft/bitnet-b1.58-2B-4T\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"microsoft/bitnet-b1.58-2B-4T\")\n+\n+        >>> prompt = f'<|begin_of_text|>User: Hey, are you conscious? Can you talk to me?<|eot_id|>Assistant: '\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=100)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"User: Hey, are you conscious? Can you talk to me?Assistant: No, I'm not conscious. I'm an artificial intelligence designed to assist with information and tasks. How can I help you today?\"\n+        ```\"\"\"\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+\n+        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n+        outputs: BaseModelOutputWithPast = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs.last_hidden_state\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits=logits, labels=labels, vocab_size=self.config.vocab_size, **kwargs)\n+\n+        return CausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+\n+__all__ = [\"BitNetForCausalLM\", \"BitNetModel\", \"BitNetPreTrainedModel\"]"
        },
        {
            "sha": "824ac6f0f39b8419aafca0c7464f74941d4bb988",
            "filename": "src/transformers/models/bitnet/modular_bitnet.py",
            "status": "added",
            "additions": 166,
            "deletions": 0,
            "changes": 166,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2Fbitnet%2Fmodular_bitnet.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fmodels%2Fbitnet%2Fmodular_bitnet.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fbitnet%2Fmodular_bitnet.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -0,0 +1,166 @@\n+# coding=utf-8\n+# Copyright 2025 The BitNet Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+\"\"\"PyTorch BitNet model.\"\"\"\n+\n+from typing import Callable, Optional, Tuple\n+\n+import torch\n+\n+from ...cache_utils import Cache\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_outputs import CausalLMOutputWithPast\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS\n+from ...processing_utils import Unpack\n+from ...utils import (\n+    logging,\n+)\n+from ..gemma.modeling_gemma import GemmaMLP\n+from ..llama.modeling_llama import (\n+    LlamaAttention,\n+    LlamaDecoderLayer,\n+    LlamaForCausalLM,\n+    LlamaModel,\n+    LlamaRMSNorm,\n+    apply_rotary_pos_emb,\n+    eager_attention_forward,\n+)\n+from .configuration_bitnet import BitNetConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+_CHECKPOINT_FOR_DOC = \"microsoft/bitnet-b1.58-2B-4T\"\n+\n+\n+class BitNetRMSNorm(LlamaRMSNorm):\n+    pass\n+\n+\n+class BitNetMLP(GemmaMLP):\n+    def __init__(self, config: BitNetConfig):\n+        super().__init__(config)\n+        self.ffn_sub_norm = BitNetRMSNorm(config.intermediate_size, eps=config.rms_norm_eps)\n+\n+    def forward(self, x):\n+        down_proj = self.down_proj(self.ffn_sub_norm(self.act_fn(self.gate_proj(x)) * self.up_proj(x)))\n+        return down_proj\n+\n+\n+class BitNetAttention(LlamaAttention):\n+    def __init__(self, config: BitNetConfig, layer_idx: int):\n+        super().__init__(config, layer_idx)\n+        self.attn_sub_norm = BitNetRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: Tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+\n+        if self.config._attn_implementation != \"eager\":\n+            if self.config._attn_implementation == \"sdpa\" and kwargs.get(\"output_attentions\", False):\n+                logger.warning_once(\n+                    \"`torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. Falling back to \"\n+                    'eager attention. This warning can be removed using the argument `attn_implementation=\"eager\"` when loading the model.'\n+                )\n+            else:\n+                attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.attn_sub_norm(attn_output)  # diff with Llama\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class BitNetDecoderLayer(LlamaDecoderLayer):\n+    pass\n+\n+\n+class BitNetModel(LlamaModel):\n+    pass\n+\n+\n+class BitNetForCausalLM(LlamaForCausalLM):\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+    _tp_plan = None\n+    _pp_plan = None\n+\n+    def forward(\n+        self,\n+        **super_kwargs,\n+    ) -> CausalLMOutputWithPast:\n+        r\"\"\"\n+        Args:\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, transformers.,\n+                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, transformers., config.vocab_size]`.\n+\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, BitNetForCausalLM\n+\n+        >>> model = BitNetForCausalLM.from_pretrained(\"microsoft/bitnet-b1.58-2B-4T\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"microsoft/bitnet-b1.58-2B-4T\")\n+\n+        >>> prompt = f'<|begin_of_text|>User: Hey, are you conscious? Can you talk to me?<|eot_id|>Assistant: '\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=100)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"User: Hey, are you conscious? Can you talk to me?Assistant: No, I'm not conscious. I'm an artificial intelligence designed to assist with information and tasks. How can I help you today?\"\n+        ```\"\"\"\n+        return super().forward(**super_kwargs)\n+\n+\n+__all__ = [\n+    \"BitNetForCausalLM\",\n+    \"BitNetModel\",\n+    \"BitNetPreTrainedModel\",  # noqa: F822\n+]"
        },
        {
            "sha": "97933a818e4a333a7d14181fc1e68907f5f230f9",
            "filename": "src/transformers/quantizers/auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fquantizers%2Fauto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fquantizers%2Fauto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fquantizers%2Fauto.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -21,7 +21,7 @@\n     AqlmConfig,\n     AutoRoundConfig,\n     AwqConfig,\n-    BitNetConfig,\n+    BitNetQuantConfig,\n     BitsAndBytesConfig,\n     CompressedTensorsConfig,\n     EetqConfig,\n@@ -94,7 +94,7 @@\n     \"fbgemm_fp8\": FbgemmFp8Config,\n     \"higgs\": HiggsConfig,\n     \"torchao\": TorchAoConfig,\n-    \"bitnet\": BitNetConfig,\n+    \"bitnet\": BitNetQuantConfig,\n     \"vptq\": VptqConfig,\n     \"spqr\": SpQRConfig,\n     \"fp8\": FineGrainedFP8Config,"
        },
        {
            "sha": "bac1f01a9acfb4176c822b5cc4da0065db0ad101",
            "filename": "src/transformers/quantizers/quantizer_bitnet.py",
            "status": "modified",
            "additions": 12,
            "deletions": 1,
            "changes": 13,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fquantizers%2Fquantizer_bitnet.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Fquantizers%2Fquantizer_bitnet.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fquantizers%2Fquantizer_bitnet.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -110,4 +110,15 @@ def is_serializable(self, safe_serialization=None):\n \n     @property\n     def is_trainable(self) -> bool:\n-        return False\n+        return (\n+            self.quantization_config.linear_class == \"autobitlinear\"\n+            and self.quantization_config.quantization_mode == \"online\"\n+        )\n+\n+    @property\n+    def is_qat_trainable(self) -> bool:\n+        \"\"\"Flag indicating whether the quantized model can carry out quantization aware training\"\"\"\n+        return (\n+            self.quantization_config.linear_class == \"autobitlinear\"\n+            and self.quantization_config.quantization_mode == \"online\"\n+        )"
        },
        {
            "sha": "636161bfdf28db982420a1a7f26636eb6f419b8f",
            "filename": "src/transformers/utils/fx.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Futils%2Ffx.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Futils%2Ffx.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Ffx.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -119,6 +119,7 @@ def _generate_supported_model_class_names(\n     \"albert\",\n     \"bart\",\n     \"bert\",\n+    \"bitnet\",\n     \"blenderbot\",\n     \"blenderbot-small\",\n     \"bloom\","
        },
        {
            "sha": "816ff9ae559e10c857e8dba0eca2e5d1f7c6124d",
            "filename": "src/transformers/utils/quantization_config.py",
            "status": "modified",
            "additions": 31,
            "deletions": 1,
            "changes": 32,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Futils%2Fquantization_config.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/src%2Ftransformers%2Futils%2Fquantization_config.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fquantization_config.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -1761,14 +1761,44 @@ def from_dict(cls, config_dict, return_unused_kwargs=False, **kwargs):\n \n \n @dataclass\n-class BitNetConfig(QuantizationConfigMixin):\n+class BitNetQuantConfig(QuantizationConfigMixin):\n+    \"\"\"\n+    Configuration class for applying BitNet quantization.\n+\n+    Args:\n+        modules_to_not_convert (`Optional[List]`, *optional*):\n+            Optionally, provides a list of full paths of `nn.Linear` weight parameters\n+            that shall not be quantized. Defaults to None.\n+        linear_class (`str`, *optional*, defaults to `\"bitlinear\"`):\n+            The type of linear class to use. Can be either `bitlinear` or `autobitlinear`.\n+        quantization_mode (`str`, *optional*, defaults to `\"offline\"`):\n+            The quantization mode to use. Can be either `online` or `offline`.\n+            In `online` mode, the weight quantization parameters are calculated dynamically\n+            during each forward pass (e.g., based on the current weight values). This can\n+            adapt to weight changes during training (Quantization-Aware Training - QAT).\n+            In `offline` mode, quantization parameters are pre-calculated *before* inference.\n+            These parameters are then fixed and loaded into the quantized model. This\n+            generally results in lower runtime overhead compared to online quantization.\n+        kwargs (`Dict[str, Any]`, *optional*):\n+            Additional keyword arguments that may be used by specific quantization\n+            backends or future versions.\n+    \"\"\"\n+\n     def __init__(\n         self,\n         modules_to_not_convert: Optional[List] = None,\n+        linear_class: Optional[str] = \"bitlinear\",\n+        quantization_mode: Optional[str] = \"offline\",\n         **kwargs,\n     ):\n+        if linear_class not in [\"bitlinear\", \"autobitlinear\"]:\n+            raise ValueError(f\"linear_class must be either 'bitlinear' or 'autobitlinear', but got {linear_class}\")\n+        if quantization_mode not in [\"online\", \"offline\"]:\n+            raise ValueError(f\"quantization_mode must be either 'online' or 'offline', but got {quantization_mode}\")\n         self.quant_method = QuantizationMethod.BITNET\n         self.modules_to_not_convert = modules_to_not_convert\n+        self.linear_class = linear_class\n+        self.quantization_mode = quantization_mode\n         self.post_init()\n \n     def post_init(self):"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/bitnet/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/tests%2Fmodels%2Fbitnet%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/tests%2Fmodels%2Fbitnet%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fbitnet%2F__init__.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd"
        },
        {
            "sha": "5af4e4554322530f8f7a1ed5aa327f714b04e58c",
            "filename": "tests/models/bitnet/test_modeling_bitnet.py",
            "status": "added",
            "additions": 253,
            "deletions": 0,
            "changes": 253,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/tests%2Fmodels%2Fbitnet%2Ftest_modeling_bitnet.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/tests%2Fmodels%2Fbitnet%2Ftest_modeling_bitnet.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fbitnet%2Ftest_modeling_bitnet.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -0,0 +1,253 @@\n+# Copyright 2025 The BitNet team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch BitNet model.\"\"\"\n+\n+import gc\n+import unittest\n+\n+import pytest\n+\n+from transformers import AutoTokenizer, BitNetConfig, is_torch_available\n+from transformers.testing_utils import (\n+    backend_empty_cache,\n+    require_flash_attn,\n+    require_torch,\n+    require_torch_gpu,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import ModelTesterMixin, ids_tensor\n+from ...test_pipeline_mixin import PipelineTesterMixin\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import (\n+        BitNetForCausalLM,\n+        BitNetModel,\n+    )\n+\n+\n+class BitNetModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=13,\n+        seq_length=7,\n+        is_training=True,\n+        use_input_mask=True,\n+        vocab_size=99,\n+        hidden_size=64,\n+        num_hidden_layers=5,\n+        num_attention_heads=4,\n+        num_key_value_heads=2,\n+        intermediate_size=37,\n+        hidden_act=\"gelu\",\n+        max_position_embeddings=512,\n+        initializer_range=0.02,\n+        pad_token_id=0,\n+        bos_token_id=1,\n+        scope=None,\n+    ):\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.seq_length = seq_length\n+        self.is_training = is_training\n+        self.use_input_mask = use_input_mask\n+        self.vocab_size = vocab_size\n+        self.hidden_size = hidden_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads\n+        self.intermediate_size = intermediate_size\n+        self.hidden_act = hidden_act\n+        self.max_position_embeddings = max_position_embeddings\n+        self.initializer_range = initializer_range\n+        self.pad_token_id = pad_token_id\n+        self.bos_token_id = bos_token_id\n+        self.scope = scope\n+\n+    def prepare_config_and_inputs(self):\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], self.vocab_size)\n+\n+        input_mask = None\n+        if self.use_input_mask:\n+            input_mask = torch.tril(torch.ones_like(input_ids).to(torch_device))\n+\n+        config = self.get_config()\n+\n+        return config, input_ids, input_mask\n+\n+    def get_config(self):\n+        return BitNetConfig(\n+            vocab_size=self.vocab_size,\n+            hidden_size=self.hidden_size,\n+            num_hidden_layers=self.num_hidden_layers,\n+            num_attention_heads=self.num_attention_heads,\n+            num_key_value_heads=self.num_key_value_heads,\n+            intermediate_size=self.intermediate_size,\n+            hidden_act=self.hidden_act,\n+            max_position_embeddings=self.max_position_embeddings,\n+            initializer_range=self.initializer_range,\n+            pad_token_id=self.pad_token_id,\n+            bos_token_id=self.bos_token_id,\n+        )\n+\n+    def create_and_check_model(self, config, input_ids, input_mask):\n+        model = BitNetModel(config=config)\n+        model.to(torch_device)\n+        model.eval()\n+        result = model(input_ids, attention_mask=input_mask)\n+        result = model(input_ids)\n+        self.parent.assertEqual(result.last_hidden_state.shape, (self.batch_size, self.seq_length, self.hidden_size))\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        (\n+            config,\n+            input_ids,\n+            input_mask,\n+        ) = config_and_inputs\n+        inputs_dict = {\"input_ids\": input_ids, \"attention_mask\": input_mask}\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class BitNetModelTest(ModelTesterMixin, GenerationTesterMixin, PipelineTesterMixin, unittest.TestCase):\n+    all_model_classes = (\n+        (\n+            BitNetModel,\n+            BitNetForCausalLM,\n+        )\n+        if is_torch_available()\n+        else ()\n+    )\n+    pipeline_model_mapping = (\n+        {\n+            \"feature-extraction\": BitNetModel,\n+            \"text-generation\": BitNetForCausalLM,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+    test_headmasking = False\n+    test_pruning = False\n+    fx_compatible = False  # Broken by attention refactor cc @Cyrilvallez\n+\n+    # TODO (ydshieh): Check this. See https://app.circleci.com/pipelines/github/huggingface/transformers/79245/workflows/9490ef58-79c2-410d-8f51-e3495156cf9c/jobs/1012146\n+    def is_pipeline_test_to_skip(\n+        self,\n+        pipeline_test_case_name,\n+        config_class,\n+        model_architecture,\n+        tokenizer_name,\n+        image_processor_name,\n+        feature_extractor_name,\n+        processor_name,\n+    ):\n+        return True\n+\n+    def setUp(self):\n+        self.model_tester = BitNetModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=BitNetConfig, hidden_size=37)\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    def test_model(self):\n+        config_and_inputs = self.model_tester.prepare_config_and_inputs()\n+        self.model_tester.create_and_check_model(*config_and_inputs)\n+\n+    def test_model_various_embeddings(self):\n+        config_and_inputs = self.model_tester.prepare_config_and_inputs()\n+        for type in [\"absolute\", \"relative_key\", \"relative_key_query\"]:\n+            config_and_inputs[0].position_embedding_type = type\n+            self.model_tester.create_and_check_model(*config_and_inputs)\n+\n+    def test_torch_fx_output_loss(self):\n+        super().test_torch_fx_output_loss()\n+\n+    # Ignore copy\n+    def test_past_key_values_format(self):\n+        super().test_past_key_values_format()\n+\n+    @require_flash_attn\n+    @require_torch_gpu\n+    @pytest.mark.flash_attn_test\n+    @slow\n+    def test_flash_attn_2_inference_equivalence_right_padding(self):\n+        self.skipTest(reason=\"BitNet flash attention does not support right padding\")\n+\n+\n+@require_torch\n+class BitNetIntegrationTest(unittest.TestCase):\n+    @slow\n+    def test_model_logits(self):\n+        input_ids = [128000, 128000, 1502, 25, 2650, 527, 499, 30, 128009, 72803, 25, 220]\n+        model = BitNetForCausalLM.from_pretrained(\"microsoft/bitnet-b1.58-2B-4T\")\n+        input_ids = torch.tensor([input_ids]).to(model.model.embed_tokens.weight.device)\n+        with torch.no_grad():\n+            out = model(input_ids).logits.float().cpu()\n+        # Expected mean on dim = -1\n+        EXPECTED_MEAN = torch.tensor(\n+            [\n+                [\n+                    -1.8665,\n+                    -1.7681,\n+                    -1.7043,\n+                    3.7446,\n+                    2.7730,\n+                    4.7133,\n+                    0.9768,\n+                    -3.5018,\n+                    -12.2812,\n+                    -8.1477,\n+                    -10.2571,\n+                    -8.7610,\n+                ]\n+            ]\n+        )\n+        torch.testing.assert_close(out.mean(-1), EXPECTED_MEAN, rtol=1e-2, atol=1e-2)\n+        # slicing logits[0, 0, 0:30]\n+        EXPECTED_SLICE = torch.tensor([5.5815, 4.9154, 1.0478, 4.3869, 3.0112, 0.8235, 3.8412, 2.9233, 8.1140, 1.9406, 1.7973, 10.5025, 4.7796, 8.5926, 4.5196, 3.1549, 3.2656, 3.2588, 2.7356, 2.6032, 2.1454, 1.5683, 1.3465, 1.5329, 1.1886, 7.7902, 5.9326, 1.4737, 3.3319, 1.6291])  # fmt: skip\n+        torch.testing.assert_close(out[0, 0, :30], EXPECTED_SLICE, rtol=1e-4, atol=1e-4)\n+\n+        del model\n+        backend_empty_cache(torch_device)\n+        gc.collect()\n+\n+    @slow\n+    def test_model_generation(self):\n+        EXPECTED_TEXT_COMPLETION = \"\"\"User: What is your favourite food?Assistant: As an AI, I don't have personal preferences or the ability to eat food. However, I\"\"\"\n+        tokenizer = AutoTokenizer.from_pretrained(\"microsoft/bitnet-b1.58-2B-4T\")\n+        prompt = tokenizer.apply_chat_template(\n+            [{\"role\": \"user\", \"content\": \"What is your favourite food?\"}], add_generation_prompt=True, tokenize=False\n+        )\n+        model = BitNetForCausalLM.from_pretrained(\n+            \"microsoft/bitnet-b1.58-2B-4T\", device_map=\"auto\", torch_dtype=torch.bfloat16\n+        )\n+        input_ids = tokenizer.encode(prompt, return_tensors=\"pt\").to(model.model.embed_tokens.weight.device)\n+\n+        # greedy generation outputs\n+        generated_ids = model.generate(input_ids, max_new_tokens=20, do_sample=False)\n+        text = tokenizer.decode(generated_ids[0], skip_special_tokens=True)\n+        self.assertEqual(EXPECTED_TEXT_COMPLETION, text)\n+\n+        del model\n+        backend_empty_cache(torch_device)\n+        gc.collect()"
        },
        {
            "sha": "10a1843dc17308ee6a1a73148dcf2752b42ac8fc",
            "filename": "tests/quantization/bitnet_integration/test_bitnet.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/b262680af446ce012f43a44f20d97f8a2abba3bd/tests%2Fquantization%2Fbitnet_integration%2Ftest_bitnet.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/b262680af446ce012f43a44f20d97f8a2abba3bd/tests%2Fquantization%2Fbitnet_integration%2Ftest_bitnet.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fquantization%2Fbitnet_integration%2Ftest_bitnet.py?ref=b262680af446ce012f43a44f20d97f8a2abba3bd",
            "patch": "@@ -19,7 +19,7 @@\n     AutoConfig,\n     AutoModelForCausalLM,\n     AutoTokenizer,\n-    BitNetConfig,\n+    BitNetQuantConfig,\n     OPTForCausalLM,\n )\n from transformers.testing_utils import (\n@@ -39,12 +39,12 @@\n \n \n @require_torch_gpu\n-class BitNetConfigTest(unittest.TestCase):\n+class BitNetQuantConfigTest(unittest.TestCase):\n     def test_to_dict(self):\n         \"\"\"\n         Simple test that checks if one uses a config and converts it to a dict, the dict is the same as the config object\n         \"\"\"\n-        quantization_config = BitNetConfig()\n+        quantization_config = BitNetQuantConfig()\n         config_to_dict = quantization_config.to_dict()\n \n         for key in config_to_dict:"
        }
    ],
    "stats": {
        "total": 1728,
        "additions": 1709,
        "deletions": 19
    }
}