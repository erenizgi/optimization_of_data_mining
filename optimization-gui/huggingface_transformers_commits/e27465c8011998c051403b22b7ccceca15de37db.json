{
    "author": "jmamou",
    "message": "Adaptive dynamic number of speculative tokens (#34156)\n\n* initial commit\n\n* update strategy\n\n* add tradeoff FPR TPR with cost\n\n* all probs\n\n* fix\n\n* fix\n\n* fix style\n\n* Update src/transformers/generation/configuration_utils.py\r\n\r\nshorter docstring\n\nCo-authored-by: Joao Gante <joaofranciscocardosogante@gmail.com>\n\n* import guard\n\n* fix style\n\n* add is_sklearn_available condition\n\n* vectorizing to flatten the for-loop\n\n* fix style\n\n* disable adaptation for UAG\n\n* update doc\n\n* add TestAssistedCandidateGeneratorUpdateStrategy\n\n* fix style\n\n* protect import\n\n* fix style\n\n---------\n\nCo-authored-by: Joao Gante <joaofranciscocardosogante@gmail.com>",
    "sha": "e27465c8011998c051403b22b7ccceca15de37db",
    "files": [
        {
            "sha": "47032a2a292b1be8563d70c64975b4d5956746ed",
            "filename": "docs/source/en/generation_strategies.md",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/e27465c8011998c051403b22b7ccceca15de37db/docs%2Fsource%2Fen%2Fgeneration_strategies.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/e27465c8011998c051403b22b7ccceca15de37db/docs%2Fsource%2Fen%2Fgeneration_strategies.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fgeneration_strategies.md?ref=e27465c8011998c051403b22b7ccceca15de37db",
            "patch": "@@ -456,6 +456,8 @@ just like in multinomial sampling. However, in assisted decoding, reducing the t\n ['Alice and Bob, a couple of friends of mine, who are both in the same office as']\n ```\n \n+We recommend to install `scikit-learn` library to enhance the candidate generation strategy and achieve additional speedup.\n+\n #### Universal Assisted Decoding\n \n Universal Assisted Decoding (UAD) adds support for main and assistant models with different tokenizers."
        },
        {
            "sha": "9a62b5709b5f43479312e41c7e94bb0c4c1f8b7b",
            "filename": "src/transformers/generation/candidate_generator.py",
            "status": "modified",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/huggingface/transformers/blob/e27465c8011998c051403b22b7ccceca15de37db/src%2Ftransformers%2Fgeneration%2Fcandidate_generator.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e27465c8011998c051403b22b7ccceca15de37db/src%2Ftransformers%2Fgeneration%2Fcandidate_generator.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Fcandidate_generator.py?ref=e27465c8011998c051403b22b7ccceca15de37db",
            "patch": "@@ -19,6 +19,12 @@\n import numpy as np\n import torch\n \n+from ..utils import is_sklearn_available\n+\n+\n+if is_sklearn_available():\n+    from sklearn.metrics import roc_curve\n+\n from ..cache_utils import DynamicCache\n from ..pytorch_utils import isin_mps_friendly\n from .logits_process import LogitsProcessorList, MinLengthLogitsProcessor\n@@ -180,6 +186,14 @@ def __init__(\n         # We need to roll back the cache in assisted generation, only DynamicCache is supported\n         self.generation_config.cache_implementation = None\n \n+        if (\n+            is_sklearn_available()\n+            and self.assistant_model.generation_config.assistant_confidence_threshold\n+            and type(self) is AssistedCandidateGenerator\n+        ):\n+            self.probs = []\n+            self.matches = []\n+\n     def get_candidates(self, input_ids: torch.LongTensor) -> Tuple[torch.LongTensor, Optional[torch.FloatTensor]]:\n         \"\"\"\n         Fetches the candidates to be tried for the current input.\n@@ -230,6 +244,17 @@ def get_candidates(self, input_ids: torch.LongTensor) -> Tuple[torch.LongTensor,\n         # 3. Update variables for the next round of candidate generation\n         self.assistant_kwargs[\"past_key_values\"] = assistant_output.past_key_values\n \n+        if (\n+            is_sklearn_available()\n+            and self.assistant_model.generation_config.assistant_confidence_threshold\n+            and type(self) is AssistedCandidateGenerator\n+        ):\n+            scores_tensor = torch.cat(assistant_output.scores, dim=0)\n+            scores_softmax = torch.softmax(scores_tensor, dim=-1)\n+            ids = assistant_output.sequences[-1, -len(assistant_output.scores) :]\n+            p = scores_softmax[range(len(ids)), ids]\n+            self.probs.extend(p.tolist())\n+\n         # 4. Prepare variables for output\n         candidate_logits = torch.stack(assistant_output.scores, dim=1)\n         candidate_ids = assistant_output.sequences\n@@ -261,6 +286,38 @@ def update_candidate_strategy(self, input_ids: torch.LongTensor, scores: torch.F\n             else:\n                 self.num_assistant_tokens = max(1.0, self.num_assistant_tokens - 1.0)\n \n+        # The assistant's confidence threshold is adjusted throughout the speculative iterations to reduce the number of unnecessary draft and target forward passes. The costs are estimated based on the ROC curve, which considers the probability of the draft token and its match with the target. A cost of 25% is assigned to false positives and 75% to false negatives.\n+        # This adaptation is not compatible with UAG, as it relies on the number of matched tokens based on the draft vocabulary, which is unavailable in UAG.\n+        if (\n+            is_sklearn_available()\n+            and self.assistant_model.generation_config.assistant_confidence_threshold\n+            and type(self) is AssistedCandidateGenerator\n+        ):\n+            # update self.matches\n+            self.matches.extend([1] * num_matches)\n+            if len(self.probs) > len(self.matches):\n+                self.matches.append(0)\n+\n+            # update self.probs\n+            excess_length = len(self.probs) - len(self.matches)\n+            if excess_length > 0:\n+                del self.probs[-excess_length:]\n+\n+            if (\n+                len(self.probs) > 5 and {0, 1}.issubset(self.matches)\n+            ):  # require at least 5 samples to calculate the ROC curve and at least one positive and one negative sample\n+                fpr, tpr, thresholds = roc_curve(self.matches, self.probs)\n+                fnr = 1 - tpr\n+\n+                # Calculate the cost for each threshold\n+                costs = fpr + 3 * fnr\n+\n+                # Find the threshold that minimizes the cost\n+                optimal_threshold_index = np.argmin(costs)\n+                best_threshold = thresholds[optimal_threshold_index]\n+\n+                self.assistant_model.generation_config.assistant_confidence_threshold = best_threshold\n+\n \n class AssistedCandidateGeneratorDifferentTokenizers(AssistedCandidateGenerator):\n     \"\"\""
        },
        {
            "sha": "0a6fdd9fb51a5f23a89d9af500a96a4ba12e864f",
            "filename": "src/transformers/generation/configuration_utils.py",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/e27465c8011998c051403b22b7ccceca15de37db/src%2Ftransformers%2Fgeneration%2Fconfiguration_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e27465c8011998c051403b22b7ccceca15de37db/src%2Ftransformers%2Fgeneration%2Fconfiguration_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Fconfiguration_utils.py?ref=e27465c8011998c051403b22b7ccceca15de37db",
            "patch": "@@ -353,7 +353,9 @@ class GenerationConfig(PushToHubMixin):\n         assistant_confidence_threshold (`float`, *optional*, defaults to 0.4):\n             The confidence threshold for the assistant model. If the assistant model's confidence in its prediction for the current token is lower\n             than this threshold, the assistant model stops the current token generation iteration, even if the number of _speculative tokens_\n-            (defined by `num_assistant_tokens`) is not yet reached. It is an unsupervised version of the dynamic speculation lookahead\n+            (defined by `num_assistant_tokens`) is not yet reached. The assistant's confidence threshold is adjusted throughout the speculative iterations to reduce the number of unnecessary draft and target forward passes, biased towards avoiding false negatives.\n+            `assistant_confidence_threshold` value is persistent over multiple generation calls with the same assistant model.\n+            It is an unsupervised version of the dynamic speculation lookahead\n             from Dynamic Speculation Lookahead Accelerates Speculative Decoding of Large Language Models <https://arxiv.org/abs/2405.04304>.\n         prompt_lookup_num_tokens (`int`, *optional*):\n             The number of tokens to be output as candidate tokens."
        },
        {
            "sha": "12faeb8da9256a84cb888b8566f46c53655fd8b5",
            "filename": "tests/generation/test_utils.py",
            "status": "modified",
            "additions": 115,
            "deletions": 1,
            "changes": 116,
            "blob_url": "https://github.com/huggingface/transformers/blob/e27465c8011998c051403b22b7ccceca15de37db/tests%2Fgeneration%2Ftest_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e27465c8011998c051403b22b7ccceca15de37db/tests%2Fgeneration%2Ftest_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_utils.py?ref=e27465c8011998c051403b22b7ccceca15de37db",
            "patch": "@@ -92,9 +92,16 @@\n         WatermarkDetector,\n         WatermarkingConfig,\n     )\n-    from transformers.generation.candidate_generator import AssistedCandidateGeneratorDifferentTokenizers\n+    from transformers.generation.candidate_generator import (\n+        AssistedCandidateGenerator,\n+        AssistedCandidateGeneratorDifferentTokenizers,\n+    )\n     from transformers.generation.utils import _speculative_sampling\n \n+from unittest.mock import patch\n+\n+from transformers.utils import is_sklearn_available\n+\n \n class GenerationTesterMixin:\n     input_name = \"input_ids\"\n@@ -4312,3 +4319,110 @@ def test_no_new_tokens(self):\n         self.assertEqual(discrep_length, 0)\n         np.testing.assert_array_equal(new_tokens_only, np.array([[]]))\n         np.testing.assert_array_equal(discrep_only, np.array([[]]))\n+\n+\n+class TestAssistedCandidateGeneratorUpdateStrategy(unittest.TestCase):\n+    def setUp(self):\n+        checkpoint = \"EleutherAI/pythia-160m-deduped\"\n+        self.assistant_model = AutoModelForCausalLM.from_pretrained(checkpoint)\n+        self.assistant_model.generation_config.assistant_confidence_threshold = 0.4\n+        self.model_kwargs = {}\n+        self.input_ids = torch.randint(1, 10, (1, 9))\n+        self.candidate_generator = AssistedCandidateGenerator(\n+            input_ids=self.input_ids,\n+            assistant_model=self.assistant_model,\n+            generation_config=self.assistant_model.generation_config,\n+            model_kwargs=self.model_kwargs,\n+        )\n+        self.candidate_generator.probs = [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]\n+        self.original_probs = self.candidate_generator.probs\n+        self.original_threshold = self.assistant_model.generation_config.assistant_confidence_threshold\n+\n+    def assert_no_sklearn(self):\n+        with patch(\"transformers.utils.import_utils._sklearn_available\", False):\n+            self.candidate_generator.update_candidate_strategy(self.input_ids, None, self.num_matches)\n+            self.assertEqual(self.candidate_generator.matches, self.original_matches)\n+            self.assertEqual(self.candidate_generator.probs, self.original_probs)\n+            self.assertEqual(\n+                self.assistant_model.generation_config.assistant_confidence_threshold, self.original_threshold\n+            )\n+\n+    @parameterized.expand([(is_sklearn_available(),), (False,)])\n+    def test_update_candidate_strategy_no_matches_short(self, sklearn_available):\n+        print(\"test_update_candidate_strategy_no_matches_short\")\n+        self.original_matches = []\n+        self.candidate_generator.matches = self.original_matches\n+        self.num_matches = 0\n+\n+        if sklearn_available:\n+            self.candidate_generator.update_candidate_strategy(self.input_ids, None, self.num_matches)\n+            self.assertEqual(self.candidate_generator.matches, [0])\n+            self.assertEqual(self.candidate_generator.probs, [0.9])\n+            self.assertEqual(self.assistant_model.generation_config.assistant_confidence_threshold, 0.4)\n+        else:\n+            self.assert_no_sklearn()\n+\n+    @parameterized.expand([(is_sklearn_available(),), (False,)])\n+    def test_update_candidate_strategy_with_mix_matches_3(self, sklearn_available):\n+        self.original_matches = [1, 0, 1, 0, 1]\n+        self.candidate_generator.matches = self.original_matches\n+        self.num_matches = 3\n+        if sklearn_available:\n+            self.candidate_generator.update_candidate_strategy(self.input_ids, None, self.num_matches)\n+            self.assertEqual(self.candidate_generator.matches, [1, 0, 1, 0, 1, 1, 1, 1, 0])\n+            self.assertEqual(self.candidate_generator.probs, [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1])\n+            self.assertEqual(self.assistant_model.generation_config.assistant_confidence_threshold, 0.2)\n+        else:\n+            self.assert_no_sklearn()\n+\n+    @parameterized.expand([(is_sklearn_available(),), (False,)])\n+    def test_update_candidate_strategy_with_matches_4(self, sklearn_available):\n+        self.original_matches = [1, 1, 1, 1, 1]\n+        self.candidate_generator.matches = self.original_matches\n+        self.num_matches = 4\n+        if sklearn_available:\n+            self.candidate_generator.update_candidate_strategy(self.input_ids, None, self.num_matches)\n+            self.assertEqual(self.candidate_generator.matches, [1, 1, 1, 1, 1, 1, 1, 1, 1])\n+            self.assertEqual(self.candidate_generator.probs, [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1])\n+            self.assertEqual(self.assistant_model.generation_config.assistant_confidence_threshold, 0.4)\n+        else:\n+            self.assert_no_sklearn()\n+\n+    @parameterized.expand([(is_sklearn_available(),), (False,)])\n+    def test_update_candidate_strategy_with_matches_3(self, sklearn_available):\n+        self.original_matches = [1, 1, 1, 1, 1]\n+        self.candidate_generator.matches = self.original_matches\n+        self.num_matches = 3\n+        if sklearn_available:\n+            self.candidate_generator.update_candidate_strategy(self.input_ids, None, self.num_matches)\n+            self.assertEqual(self.candidate_generator.matches, [1, 1, 1, 1, 1, 1, 1, 1, 0])\n+            self.assertEqual(self.candidate_generator.probs, [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1])\n+            self.assertEqual(self.assistant_model.generation_config.assistant_confidence_threshold, 0.2)\n+        else:\n+            self.assert_no_sklearn()\n+\n+    @parameterized.expand([(is_sklearn_available(),), (False,)])\n+    def test_update_candidate_strategy_with_matches_2(self, sklearn_available):\n+        self.original_matches = [1, 1, 1, 1, 1]\n+        self.candidate_generator.matches = self.original_matches\n+        self.num_matches = 2\n+        if sklearn_available:\n+            self.candidate_generator.update_candidate_strategy(self.input_ids, None, self.num_matches)\n+            self.assertEqual(self.candidate_generator.matches, [1, 1, 1, 1, 1, 1, 1, 0])\n+            self.assertEqual(self.candidate_generator.probs, [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2])\n+            self.assertEqual(self.assistant_model.generation_config.assistant_confidence_threshold, 0.3)\n+        else:\n+            self.assert_no_sklearn()\n+\n+    @parameterized.expand([(is_sklearn_available(),), (False,)])\n+    def test_update_candidate_strategy_with_matches_1(self, sklearn_available):\n+        self.original_matches = [1, 1, 1, 1, 1]\n+        self.candidate_generator.matches = self.original_matches\n+        self.num_matches = 1\n+        if sklearn_available:\n+            self.candidate_generator.update_candidate_strategy(self.input_ids, None, self.num_matches)\n+            self.assertEqual(self.candidate_generator.matches, [1, 1, 1, 1, 1, 1, 0])\n+            self.assertEqual(self.candidate_generator.probs, [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3])\n+            self.assertEqual(self.assistant_model.generation_config.assistant_confidence_threshold, 0.4)\n+        else:\n+            self.assert_no_sklearn()"
        }
    ],
    "stats": {
        "total": 179,
        "additions": 177,
        "deletions": 2
    }
}