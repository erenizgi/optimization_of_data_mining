{
    "author": "BakerBunker",
    "message": "Add Qwen2.5-Omni (#36752)\n\n* Add qwen2.5-omni\n\n* Remove einops dependency\n\n* Add torchdiffeq dependency\n\n* Sort init\n\n* Add torchdiffeq to extras['diffeq']\n\n* Fix repo consistency\n\n* use cached_file\n\n* del odeint\n\n* renew pytest\n\n* format\n\n* Remove torchdiffeq\n\n* format\n\n* fixed batch infer bug\n\n* Change positional_embedding to parameter\n\n* Change default speaker\n\n* Config revision\n\n* Use modular & code clean\n\n* code clean\n\n* decouple padding with model & code cleaning\n\n* sort init\n\n* fix\n\n* fix\n\n* Second code review\n\n* fix\n\n* fix\n\n* rename vars to full name + some comments\n\n* update pytest\n\n* Code clean & fix\n\n* fix\n\n* style\n\n* more clean up\n\n* fixup\n\n* smaller vision model in tests\n\n* fix processor test\n\n* deflake a bit the tests (still flaky though)\n\n* de-flake tests finally + add generation mixin\n\n* final nits i hope\n\n* make sure processor tests are complete\n\n* replace with Qwen2_5OmniForConditionalGeneration\n\n* fix tests after updating ckpt\n\n* fix typos when cleaning, also we can't change ckpt\n\n* fixup\n\n* images and videos kwargs for processor\n\n* thinker and talker loadable from hub ckpt\n\n* address comments and update tests after rebase\n\n* fixup\n\n* skip for now\n\n* fixup\n\n* fixup\n\n* remove torch dependency in processors\n\n---------\n\nCo-authored-by: lvyuanjun.lyj <lvyuanjun.lyj@alibaba-inc.con>\nCo-authored-by: feizi.wx <feizi.wx@alibaba-inc.com>\nCo-authored-by: raushan <raushan@huggingface.co>",
    "sha": "4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
    "files": [
        {
            "sha": "cba824aedc2553336a872dc336a83ca760aafe97",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -993,6 +993,8 @@\n         title: Pix2Struct\n       - local: model_doc/pixtral\n         title: Pixtral\n+      - local: model_doc/qwen2_5_omni\n+        title: Qwen2.5-Omni\n       - local: model_doc/qwen2_5_vl\n         title: Qwen2.5-VL\n       - local: model_doc/qwen2_audio"
        },
        {
            "sha": "3e50d45ee86fe4a05cd11ed6a3ba21f565c72712",
            "filename": "docs/source/en/model_doc/qwen2_5_omni.md",
            "status": "added",
            "additions": 400,
            "deletions": 0,
            "changes": 400,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen2_5_omni.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen2_5_omni.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen2_5_omni.md?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -0,0 +1,400 @@\n+<!--Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# Qwen2.5-Omni\n+\n+<div class=\"flex flex-wrap space-x-1\">\n+<img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+<img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+<img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+</div>\n+\n+## Overview\n+\n+The [Qwen2.5-Omni](https://qwenlm.github.io/blog/) model is a unified multiple modalities model proposed in [Qwen2.5-Omni Technical Report]() from Qwen team, Alibaba Group.\n+\n+The abstract from the technical report is the following:\n+\n+*We present Qwen2.5-Omni, an end-to-end multimodal model designed to perceive diverse modalities, including text, images, audio, and video, while simultaneously generating text and natural speech responses in a streaming manner. To enable the streaming of multimodal information inputs, both audio and visual encoders utilize a block-wise processing approach. This strategy effectively decouples the handling of long sequences of multimodal data, assigning the perceptual responsibilities to the multimodal encoder and entrusting the modeling of extended sequences to a large language model. Such a division of labor enhances the fusion of different modalities via the shared attention mechanism. To synchronize the timestamps of video inputs with audio, we organized the audio and video sequentially in an interleaved manner and propose a novel position embedding approach, named TMRoPE (Time-aligned Multimodal RoPE). To concurrently generate text and speech while avoiding interference between the two modalities, we propose Thinker-Talker architecture. In this framework, Thinker functions as a large language model tasked with text generation, while Talker is a dual-track autoregressive model that directly utilizes the hidden representations from the Thinker to produce audio tokens as output. Both the Thinker and Talker models are designed to be trained and inferred in an end-to-end manner. For decoding audio tokens in a streaming manner, we introduce a sliding-window DiT that restricts the receptive field, aiming to reduce the initial package delay. Qwen2.5-Omni outperforms the similarly sized Qwen2-VL and Qwen2-Audio in both image and audio capabilities. Furthermore, Qwen2.5-Omni achieves state-of-the-art performance on multimodal benchmarks like Omni-Bench. Notably, Qwen2.5-Omni is the first open-source model to achieve a level of performance in end-to-end speech instruction following that is comparable to its capabilities with text inputs, as evidenced by benchmarks such as MMLU and GSM8K. As for speech generation, Qwen2.5-Omniâ€™s streaming Talker outperform most existing streaming and non-streaming alternatives in robustness and naturalness.*\n+\n+\n+\n+## Notes\n+\n+- Use [`Qwen2_5OmniForConditionalGeneration`] to generate audio and text output. To generate only one output type, use [`Qwen2_5OmniThinkerForConditionalGeneration`] for text-only and [`Qwen2_5OmniTalkersForConditionalGeneration`] for audio-only outputs.\n+- Audio generation with [`Qwen2_5OmniForConditionalGeneration`] supports only single batch size at the moment.\n+- In case out out-of-memory errors hwen working with video input, decrease `processor.max_pixels`. By default the maximum is set to a very arge value and high resolution visuals will not be resized, unless resolution exceeds `processor.max_pixels`.\n+- The processor has its own [`~ProcessorMixin.apply_chat_template`] method to convert chat messages to model inputs.\n+\n+\n+## Usage example\n+\n+`Qwen2.5-Omni` can be found on the [Huggingface Hub](https://huggingface.co/Qwen).\n+\n+### Single Media inference\n+\n+The model can accept text, images, audio and videos as input. Here's an example code for inference.\n+\n+```python\n+import soundfile as sf\n+from transformers import Qwen2_5OmniForConditionalGeneration, Qwen2_5OmniProcessor\n+\n+model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-Omni-7B\",\n+    torch_dtype=\"auto\",\n+    device_map=\"auto\"\n+)\n+processor = Qwen2_5OmniProcessor.from_pretrained(\"Qwen/Qwen2.5-Omni-7B\")\n+\n+conversation = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"}\n+        ],\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"video\", \"video\": \"/path/to/video.mp4\"},\n+            {\"type\": \"text\", \"text\": \"What cant you hear and see in this video?\"},\n+        ],\n+    },\n+]\n+\n+inputs = processor.apply_chat_template(\n+    conversations,\n+    load_audio_from_video=True,\n+    add_generation_prompt=True,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\",\n+    video_fps=1,\n+\n+    # kwargs to be passed to `Qwen2-5-OmniProcessor`\n+    padding=True,\n+    use_audio_in_video=True,\n+).to(model.device)\n+\n+# Generation params for audio or text can be different and have to be prefixed with `thinker_` or `talker_`\n+text_ids, audio = model.generate(**inputs, use_audio_in_video=True, thinker_do_sample=False, talker_do_sample=True)\n+text = processor.batch_decode(text_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)\n+\n+sf.write(\n+    \"output.wav\",\n+    audio.reshape(-1).detach().cpu().numpy(),\n+    samplerate=24000,\n+)\n+print(text)\n+```\n+\n+### Text-only generation\n+\n+To generate only text output and save compute by not loading the audio generation model, we can use `Qwen2_5OmniThinkerForConditionalGeneration` model.  \n+\n+```python\n+from transformers import Qwen2_5OmniThinkerForConditionalGeneration, Qwen2_5OmniProcessor\n+\n+model = Qwen2_5OmniThinkerForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-Omni-7B\",\n+    torch_dtype=\"auto\",\n+    device_map=\"auto\",\n+)\n+processor = Qwen2_5OmniProcessor.from_pretrained(\"Qwen/Qwen2.5-Omni-7B\")\n+\n+conversation = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"}\n+        ],\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"video\", \"video\": \"/path/to/video.mp4\"},\n+            {\"type\": \"text\", \"text\": \"What cant you hear and see in this video?\"},\n+        ],\n+    },\n+]\n+\n+inputs = processor.apply_chat_template(\n+    conversations,\n+    load_audio_from_video=True,\n+    add_generation_prompt=True,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\",\n+    video_fps=1,\n+\n+    # kwargs to be passed to `Qwen2-5-OmniProcessor`\n+    padding=True,\n+    use_audio_in_video=True,\n+).to(model.device)\n+\n+\n+text_ids = model.generate(**inputs, use_audio_in_video=True)\n+text = processor.batch_decode(text_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)\n+\n+sf.write(\n+    \"output.wav\",\n+    audio.reshape(-1).detach().cpu().numpy(),\n+    samplerate=24000,\n+)\n+print(text)\n+```\n+\n+### Batch Mixed Media Inference\n+\n+The model can batch inputs composed of mixed samples of various types such as text, images, audio and videos as input when using `Qwen2_5OmniThinkerForConditionalGeneration` model. Here is an example.\n+\n+```python\n+import soundfile as sf\n+from transformers import Qwen2_5OmniForConditionalGeneration, Qwen2_5OmniProcessor\n+\n+model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-Omni-7B\",\n+    torch_dtype=\"auto\",\n+    device_map=\"auto\"\n+)\n+processor = Qwen2_5OmniProcessor.from_pretrained(\"Qwen/Qwen2.5-Omni-7B\")\n+\n+# Conversation with video only\n+conversation1 = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"}\n+        ],\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"video\", \"path\": \"/path/to/video.mp4\"},\n+        ]\n+    }\n+]\n+\n+# Conversation with audio only\n+conversation2 = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"}\n+        ],\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"audio\", \"path\": \"/path/to/audio.wav\"},\n+        ]\n+    }\n+]\n+\n+# Conversation with pure text\n+conversation3 = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"}\n+        ],\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [{\"type\": \"text\", \"text\": \"who are you?\"}],\n+    }\n+]\n+\n+\n+# Conversation with mixed media\n+conversation4 = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"}\n+        ],\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\", \"path\": \"/path/to/image.jpg\"},\n+            {\"type\": \"video\", \"path\": \"/path/to/video.mp4\"},\n+            {\"type\": \"audio\", \"path\": \"/path/to/audio.wav\"},\n+            {\"type\": \"text\", \"text\": \"What are the elements can you see and hear in these medias?\"},\n+        ],\n+    }\n+]\n+\n+conversations = [conversation1, conversation2, conversation3, conversation4]\n+\n+inputs = processor.apply_chat_template(\n+    conversations,\n+    load_audio_from_video=True,\n+    add_generation_prompt=True,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\",\n+    video_fps=1,\n+\n+    # kwargs to be passed to `Qwen2-5-OmniProcessor`\n+    padding=True,\n+    use_audio_in_video=True,\n+).to(model.thinker.device)\n+\n+text_ids = model.generate(**inputs, use_audio_in_video=True)\n+text = processor.batch_decode(text_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)\n+\n+print(text)\n+```\n+\n+### Usage Tips\n+\n+#### Image Resolution trade-off\n+\n+The model supports a wide range of resolution inputs. By default, it uses the native resolution for input, but higher resolutions can enhance performance at the cost of more computation. Users can set the minimum and maximum number of pixels to achieve an optimal configuration for their needs.\n+\n+```python\n+min_pixels = 128*28*28\n+max_pixels = 768*28*28\n+processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2.5-Omni-7B\", min_pixels=min_pixels, max_pixels=max_pixels)\n+```\n+\n+#### Prompt for audio output\n+If users need audio output, the system prompt must be set as \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\", otherwise the audio output may not work as expected.\n+```\n+{\n+    \"role\": \"system\",\n+    \"content\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\",\n+}\n+```\n+\n+#### Use audio output or not\n+\n+The model supports both text and audio outputs, if users do not need audio outputs, they can set `enable_audio_output` in the `from_pretrained` function. This option will save about `~2GB` of GPU memory but the `return_audio` option for `generate` function will only allow to be set at `False`.\n+```python\n+model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-Omni-7B\",\n+    torch_dtype=\"auto\",\n+    device_map=\"auto\",\n+    enable_audio_output=False,\n+)\n+```\n+\n+In order to obtain a flexible experience, we recommend that users set `enable_audio_output` at `True` when initializing the model through `from_pretrained` function, and then decide whether to return audio when `generate` function is called. When `return_audio` is set to `False`, the model will only return text outputs to get text responses faster.\n+\n+```python\n+model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-Omni-7B\",\n+    torch_dtype=\"auto\",\n+    device_map=\"auto\",\n+    enable_audio_output=True,\n+)\n+...\n+text_ids = model.generate(**inputs, return_audio=False)\n+```\n+\n+#### Change voice type of output audio\n+Qwen2.5-Omni supports the ability to change the voice of the output audio. Users can use the `spk` parameter of `generate` function to specify the voice type. The `\"Qwen/Qwen2.5-Omni-7B\"` checkpoint support two voice types: `Chelsie` and `Ethan`, while `Chelsie` is a female voice and `Ethan` is a male voice. By defalut, if `spk` is not specified, the default voice type is `Chelsie`.\n+\n+```python\n+text_ids, audio = model.generate(**inputs, spk=\"Chelsie\")\n+```\n+\n+```python\n+text_ids, audio = model.generate(**inputs, spk=\"Ethan\")\n+```\n+\n+#### Flash-Attention 2 to speed up generation\n+\n+First, make sure to install the latest version of Flash Attention 2:\n+\n+```bash\n+pip install -U flash-attn --no-build-isolation\n+```\n+\n+Also, you should have hardware that is compatible with FlashAttention 2. Read more about it in the official documentation of the [flash attention repository](https://github.com/Dao-AILab/flash-attention). FlashAttention-2 can only be used when a model is loaded in `torch.float16` or `torch.bfloat16`.\n+\n+To load and run a model using FlashAttention-2, add `attn_implementation=\"flash_attention_2\"` when loading the model:\n+\n+```python\n+from transformers import Qwen2_5OmniForConditionalGeneration\n+\n+model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-Omni-7B\",\n+    device_map=\"auto\",\n+    torch_dtype=torch.bfloat16,\n+    attn_implementation=\"flash_attention_2\",\n+)\n+```\n+\n+\n+\n+## Qwen2_5OmniConfig\n+\n+[[autodoc]] Qwen2_5OmniConfig\n+\n+## Qwen2_5OmniProcessor\n+\n+[[autodoc]] Qwen2_5OmniProcessor\n+\n+## Qwen2_5OmniForConditionalGeneration\n+\n+[[autodoc]] Qwen2_5OmniForConditionalGeneration\n+    - forward\n+\n+## Qwen2_5OmniPreTrainedModelForConditionalGeneration\n+\n+[[autodoc]] Qwen2_5OmniPreTrainedModelForConditionalGeneration\n+\n+## Qwen2_5OmniThinkerConfig\n+\n+[[autodoc]] Qwen2_5OmniThinkerConfig\n+\n+## Qwen2_5OmniThinkerForConditionalGeneration\n+\n+[[autodoc]] Qwen2_5OmniThinkerForConditionalGeneration\n+\n+## Qwen2_5OmniThinkerTextModel\n+\n+[[autodoc]] Qwen2_5OmniThinkerTextModel\n+\n+## Qwen2_5OmniTalkerConfig\n+\n+[[autodoc]] Qwen2_5OmniTalkerConfig\n+\n+## Qwen2_5OmniTalkerForConditionalGeneration\n+\n+[[autodoc]] Qwen2_5OmniTalkerForConditionalGeneration\n+\n+## Qwen2_5OmniTalkerModel\n+\n+[[autodoc]] Qwen2_5OmniTalkerModel\n+\n+## Qwen2_5OmniToken2WavConfig\n+\n+[[autodoc]] Qwen2_5OmniToken2WavConfig\n+\n+## Qwen2_5OmniToken2WavModel\n+\n+[[autodoc]] Qwen2_5OmniToken2WavModel\n+\n+## Qwen2_5OmniToken2WavDiTModel\n+\n+[[autodoc]] Qwen2_5OmniToken2WavDiTModel\n+\n+## Qwen2_5OmniToken2WavBigVGANModel\n+\n+[[autodoc]] Qwen2_5OmniToken2WavBigVGANModel"
        },
        {
            "sha": "25fa6c31b0aff4f9cb9c99978a24d4272d3c52ca",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -254,6 +254,7 @@\n         (\"pvt_v2\", \"PvtV2Config\"),\n         (\"qdqbert\", \"QDQBertConfig\"),\n         (\"qwen2\", \"Qwen2Config\"),\n+        (\"qwen2_5_omni\", \"Qwen2_5OmniConfig\"),\n         (\"qwen2_5_vl\", \"Qwen2_5_VLConfig\"),\n         (\"qwen2_audio\", \"Qwen2AudioConfig\"),\n         (\"qwen2_audio_encoder\", \"Qwen2AudioEncoderConfig\"),\n@@ -617,6 +618,7 @@\n         (\"pvt_v2\", \"PVTv2\"),\n         (\"qdqbert\", \"QDQBert\"),\n         (\"qwen2\", \"Qwen2\"),\n+        (\"qwen2_5_omni\", \"Qwen2_5Omni\"),\n         (\"qwen2_5_vl\", \"Qwen2_5_VL\"),\n         (\"qwen2_audio\", \"Qwen2Audio\"),\n         (\"qwen2_audio_encoder\", \"Qwen2AudioEncoder\"),"
        },
        {
            "sha": "8ed315c61b2459aa7e006ea4ae14de6ffac060bc",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -1429,6 +1429,7 @@\n         (\"fastspeech2_conformer\", \"FastSpeech2ConformerWithHifiGan\"),\n         (\"musicgen\", \"MusicgenForConditionalGeneration\"),\n         (\"musicgen_melody\", \"MusicgenMelodyForConditionalGeneration\"),\n+        (\"qwen2_5_omni\", \"Qwen2_5OmniForConditionalGeneration\"),\n         (\"seamless_m4t\", \"SeamlessM4TForTextToSpeech\"),\n         (\"seamless_m4t_v2\", \"SeamlessM4Tv2ForTextToSpeech\"),\n         (\"vits\", \"VitsModel\"),"
        },
        {
            "sha": "9213b23ced144721bbf59c215122c452df2092d8",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -97,6 +97,7 @@\n         (\"pix2struct\", \"Pix2StructProcessor\"),\n         (\"pixtral\", \"PixtralProcessor\"),\n         (\"pop2piano\", \"Pop2PianoProcessor\"),\n+        (\"qwen2_5_omni\", \"Qwen2_5OmniProcessor\"),\n         (\"qwen2_5_vl\", \"Qwen2_5_VLProcessor\"),\n         (\"qwen2_audio\", \"Qwen2AudioProcessor\"),\n         (\"qwen2_vl\", \"Qwen2VLProcessor\"),"
        },
        {
            "sha": "102a48f3ad41894e78765a643f44e053bf5696a1",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -459,6 +459,7 @@\n                     \"Qwen2TokenizerFast\" if is_tokenizers_available() else None,\n                 ),\n             ),\n+            (\"qwen2_5_omni\", (\"Qwen2Tokenizer\", \"Qwen2TokenizerFast\" if is_tokenizers_available() else None)),\n             (\"qwen2_5_vl\", (\"Qwen2Tokenizer\", \"Qwen2TokenizerFast\" if is_tokenizers_available() else None)),\n             (\"qwen2_audio\", (\"Qwen2Tokenizer\", \"Qwen2TokenizerFast\" if is_tokenizers_available() else None)),\n             ("
        },
        {
            "sha": "8fb2a0abf5e1c3e4bff20db459f388d574edacf9",
            "filename": "src/transformers/models/glm4/modeling_glm4.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fglm4%2Fmodeling_glm4.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fglm4%2Fmodeling_glm4.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4%2Fmodeling_glm4.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -678,7 +678,7 @@ def _update_causal_mask(\n         if (\n             self.config._attn_implementation == \"sdpa\"\n             and attention_mask is not None\n-            and attention_mask.device.type in [\"cuda\", \"xpu\"]\n+            and attention_mask.device.type in [\"cuda\", \"xpu\", \"npu\"]\n             and not output_attentions\n         ):\n             # Attend to all tokens in fully masked rows in the causal_mask, for example the relevant first rows when"
        },
        {
            "sha": "317f5ae01b9098c62983f91f099005ba18af46de",
            "filename": "src/transformers/models/mimi/modeling_mimi.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fmimi%2Fmodeling_mimi.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fmimi%2Fmodeling_mimi.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmimi%2Fmodeling_mimi.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -1161,12 +1161,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "2ee9f9ccd779b3066d5ab08dfcbe27bde965ddbc",
            "filename": "src/transformers/models/mistral/modeling_mistral.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fmistral%2Fmodeling_mistral.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fmistral%2Fmodeling_mistral.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmistral%2Fmodeling_mistral.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -692,12 +692,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "aae4cb9d52c33920280529edb984574ded46cdeb",
            "filename": "src/transformers/models/mistral/modular_mistral.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fmistral%2Fmodular_mistral.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fmistral%2Fmodular_mistral.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmistral%2Fmodular_mistral.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -246,12 +246,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "3075eb01f60a137762c3f3c27e0747f01e08cd58",
            "filename": "src/transformers/models/mixtral/modeling_mixtral.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fmixtral%2Fmodeling_mixtral.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fmixtral%2Fmodeling_mixtral.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmixtral%2Fmodeling_mixtral.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -821,12 +821,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "609abb1deb5ce645fa3fc02bf3d8d7d5e3d52dc0",
            "filename": "src/transformers/models/moshi/modeling_moshi.py",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fmoshi%2Fmodeling_moshi.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fmoshi%2Fmodeling_moshi.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmoshi%2Fmodeling_moshi.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -1391,12 +1391,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask\n@@ -1705,12 +1705,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "ac36fa5e211d53691c748ace8be5dcc70d3e18c6",
            "filename": "src/transformers/models/phi3/modeling_phi3.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fphi3%2Fmodeling_phi3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fphi3%2Fmodeling_phi3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fphi3%2Fmodeling_phi3.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -747,12 +747,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "d0a6b3816c846045e9863684d4648c7ab248f593",
            "filename": "src/transformers/models/phi4_multimodal/modeling_phi4_multimodal.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fphi4_multimodal%2Fmodeling_phi4_multimodal.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fphi4_multimodal%2Fmodeling_phi4_multimodal.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fphi4_multimodal%2Fmodeling_phi4_multimodal.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -2041,12 +2041,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "a4dee0a6f7f4d7701d80246574366fdc62a502df",
            "filename": "src/transformers/models/phimoe/modeling_phimoe.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fphimoe%2Fmodeling_phimoe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fphimoe%2Fmodeling_phimoe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fphimoe%2Fmodeling_phimoe.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -1294,12 +1294,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "ca85bacbb2fedc9d83b35ed876866006c1f36c13",
            "filename": "src/transformers/models/qwen2/modeling_qwen2.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2%2Fmodeling_qwen2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2%2Fmodeling_qwen2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2%2Fmodeling_qwen2.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -705,12 +705,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "0d7ddae0da7e1b2c16b95e94e6678f9511cb716f",
            "filename": "src/transformers/models/qwen2_5_omni/__init__.py",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2F__init__.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -0,0 +1,28 @@\n+# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_qwen2_5_omni import *\n+    from .modeling_qwen2_5_omni import *\n+    from .processing_qwen2_5_omni import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "19e8615baf4d3db2646d02d7634075e1b87a1ebb",
            "filename": "src/transformers/models/qwen2_5_omni/configuration_qwen2_5_omni.py",
            "status": "added",
            "additions": 1036,
            "deletions": 0,
            "changes": 1036,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fconfiguration_qwen2_5_omni.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fconfiguration_qwen2_5_omni.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fconfiguration_qwen2_5_omni.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -0,0 +1,1036 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/qwen2_5_omni/modular_qwen2_5_omni.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_qwen2_5_omni.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...modeling_rope_utils import rope_config_validation\n+from ...utils import logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Qwen2_5OmniVisionEncoderConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen2_5OmniThinkerVision`]. It is used to instantiate a\n+    Qwen2.5-VL vision encoder according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the audio encoder of the Qwen2.5-VL\n+    architecture.\n+\n+    e.g. [Qwen/Qwen2.5-Omni-7B](https://huggingface.co/Qwen/Qwen2.5-Omni-7B)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        depth (`int`, *optional*, defaults to 32):\n+            Number of layers (depth) in the model.\n+        hidden_size (`int`, *optional*, defaults to 3584):\n+            The size of the hidden layers.\n+        hidden_act (`str`, *optional*, defaults to `\"quick_gelu\"`):\n+            The non-linear activation function used in the model. Supported options include `\"quick_gelu\"` and others as applicable.\n+        mlp_ratio (`float`, *optional*, defaults to 4):\n+            The ratio used to determine the size of the MLP (Multi-Layer Perceptron) hidden layer.\n+        num_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer.\n+        in_channels (`int`, *optional*, defaults to 3):\n+            Number of input channels.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The size of the patches extracted from the input.\n+        spatial_merge_size (`int`, *optional*, defaults to 2):\n+            The size used for merging spatial dimensions.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The size used for patches along the temporal dimension.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Qwen2_5OmniVisionEncoderConfig, Qwen2_5OmniVisionEncoder\n+\n+    >>> # Initializing a Qwen2_5OmniVisionEncoderConfig\n+    >>> configuration = Qwen2_5OmniVisionEncoderConfig()\n+\n+    >>> # Initializing a Qwen2_5OmniVisionEncoder (with random weights)\n+    >>> model = Qwen2_5OmniVisionEncoder(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen2_5_omni_vision_encoder\"\n+    base_config_key = \"vision_config\"\n+\n+    def __init__(\n+        self,\n+        depth=32,\n+        hidden_size=3584,\n+        hidden_act=\"silu\",\n+        intermediate_size=3420,\n+        num_heads=16,\n+        in_channels=3,\n+        patch_size=14,\n+        spatial_merge_size=2,\n+        temporal_patch_size=2,\n+        window_size=112,\n+        out_hidden_size=3584,\n+        fullatt_block_indexes=[7, 15, 23, 31],\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.depth = depth\n+        self.hidden_size = hidden_size\n+        self.hidden_act = hidden_act\n+        self.intermediate_size = intermediate_size\n+        self.num_heads = num_heads\n+        self.in_channels = in_channels\n+        self.patch_size = patch_size\n+        self.spatial_merge_size = spatial_merge_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.window_size = window_size\n+        self.fullatt_block_indexes = fullatt_block_indexes\n+        self.out_hidden_size = out_hidden_size\n+\n+\n+class Qwen2_5OmniAudioEncoderConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen2_5OmniAudioEncoder`]. It is used to instantiate a\n+    Qwen2.5-Omni-Thinker audio encoder according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the audio encoder of the Qwen2-Audio\n+    architecture.\n+\n+    e.g. [Qwen/Qwen2.5-Omni-7B](https://huggingface.co/Qwen/Qwen2.5-Omni-7B)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        num_mel_bins (`int`, *optional*, defaults to 128):\n+            Number of mel features used per input features. Should correspond to the value used in the\n+            `Qwen2_5OmniProcessor` class.\n+        encoder_layers (`int`, *optional*, defaults to 32):\n+            Number of encoder layers.\n+        encoder_attention_heads (`int`, *optional*, defaults to 20):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        encoder_ffn_dim (`int`, *optional*, defaults to 5120):\n+            Dimensionality of the \"intermediate\" (often named feed-forward) layer in encoder.\n+        d_model (`int`, *optional*, defaults to 1280):\n+            Dimensionality of the layers.\n+        dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        activation_function (`str`, *optional*, defaults to `\"gelu\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+            `\"relu\"`, `\"silu\"` and `\"gelu_new\"` are supported.\n+        activation_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for activations inside the fully connected layer.\n+        scale_embedding (`bool`, *optional*, defaults to `False`):\n+            Scale embeddings by diving by sqrt(d_model).\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        max_source_positions (`int`, *optional*, defaults to 1500):\n+            The maximum sequence length of log-mel filter-bank features that this model might ever be used with.\n+        n_window (`int`, *optional*, defaults to 100):\n+            The chunk for conv and flash attn in AudioEncoder.\n+        output_dim (`int`, *optional*, defaults to 3584):\n+            The output dimention of AudioEncoder.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Qwen2_5OmniAudioEncoderConfig, Qwen2_5OmniAudioEncoder\n+\n+    >>> # Initializing a Qwen2_5OmniAudioEncoderConfig\n+    >>> configuration = Qwen2_5OmniAudioEncoderConfig()\n+\n+    >>> # Initializing a Qwen2_5OmniAudioEncoder (with random weights)\n+    >>> model = Qwen2_5OmniAudioEncoder(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen2_5_omni_audio_encoder\"\n+\n+    def __init__(\n+        self,\n+        num_mel_bins=128,\n+        encoder_layers=32,\n+        encoder_attention_heads=20,\n+        encoder_ffn_dim=5120,\n+        d_model=1280,\n+        dropout=0,\n+        attention_dropout=0,\n+        activation_function=\"gelu\",\n+        activation_dropout=0,\n+        scale_embedding=False,\n+        initializer_range=0.02,\n+        max_source_positions=1500,\n+        n_window=100,\n+        output_dim=3584,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.num_mel_bins = num_mel_bins\n+        self.d_model = d_model\n+        self.encoder_layers = encoder_layers\n+        self.encoder_attention_heads = encoder_attention_heads\n+        self.encoder_ffn_dim = encoder_ffn_dim\n+        self.dropout = dropout\n+        self.attention_dropout = attention_dropout\n+        self.activation_function = activation_function\n+        self.activation_dropout = activation_dropout\n+        self.num_hidden_layers = encoder_layers\n+        self.initializer_range = initializer_range\n+        self.scale_embedding = scale_embedding  # scale factor will be sqrt(d_model) if True\n+        self.max_source_positions = max_source_positions\n+        self.n_window = n_window\n+        self.output_dim = output_dim\n+\n+\n+class Qwen2_5OmniTextConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen2_5OmniThinkerForConditionalGeneration`]. It is used to instantiate an\n+    Qwen2.5-Omni-Thinker model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of the Qwen2.5-Omni-Thinker.\n+\n+    e.g. [Qwen/Qwen2.5-Omni-7B](https://huggingface.co/Qwen/Qwen2.5-Omni-7B)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 152064):\n+            Vocabulary size of the QwenOmni model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Qwen2VLModel`]\n+        hidden_size (`int`, *optional*, defaults to 3584):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 18944):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 28):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 28):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 4):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `32`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 32768):\n+            The maximum sequence length that this model might ever be used with.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        rope_theta (`float`, *optional*, defaults to 1000000.0):\n+            The base period of the RoPE embeddings.\n+        use_sliding_window (`bool`, *optional*, defaults to `False`):\n+            Whether to use sliding window attention.\n+        sliding_window (`int`, *optional*, defaults to 32768):\n+            Sliding window attention (SWA) window size. If not specified, will default to `4096`.\n+        max_window_layers (`int`, *optional*, defaults to 28):\n+            The number of layers that use SWA (Sliding Window Attention). The bottom layers use SWA while the top use full attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n+                    'llama3'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n+                    pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n+                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n+                    `factor` field to infer the suggested value.\n+                `beta_fast` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for extrapolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 32.\n+                `beta_slow` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for interpolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 1.\n+                `short_factor` (`List[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to short contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `long_factor` (`List[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to long contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `low_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to low frequency components of the RoPE\n+                `high_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to high frequency components of the RoPE\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Qwen2_5OmniThinkerForConditionalGeneration, Qwen2_5OmniThinkerConfig, Qwen2_5OmniAudioEncoderConfig, Qwen2_5OmniVisionEncoderConfig\n+\n+    >>> # Initializing a Qwen2_5OmniAudioEncoder config\n+    >>> audio_config = Qwen2_5OmniAudioEncoderConfig()\n+\n+    >>> # Initializing a Qwen2_5OmniVisionEncoder config\n+    >>> vision_config = Qwen2_5OmniVisionEncoderConfig()\n+\n+    >>> # Initializing a Qwen2.5OmniThinker configuration\n+    >>> configuration = Qwen2_5OmniThinkerConfig(audio_config, vision_config)\n+\n+    >>> # Initializing a model from the Qwen-Omni style configuration\n+    >>> model = Qwen2_5OmniThinkerForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen2_5_omni_text\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    # Default tensor parallel plan for base model `Qwen25OmniText`\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.up_proj\": \"colwise\",\n+        \"layers.*.mlp.down_proj\": \"rowwise\",\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=152064,\n+        hidden_size=3584,\n+        intermediate_size=18944,\n+        num_hidden_layers=28,\n+        num_attention_heads=28,\n+        num_key_value_heads=4,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=32768,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-6,\n+        use_cache=True,\n+        tie_word_embeddings=False,\n+        rope_theta=1000000.0,\n+        rope_scaling=None,\n+        use_sliding_window=False,\n+        sliding_window=32768,\n+        max_window_layers=28,\n+        attention_dropout=0.0,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.use_sliding_window = use_sliding_window\n+        self.sliding_window = sliding_window  # we check `use_sliding_window` in the modeling code\n+        self.max_window_layers = max_window_layers\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.attention_dropout = attention_dropout\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, move it to 'rope_type'.\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self)\n+        if self.rope_scaling is None:\n+            self.rope_scaling = {\"mrope_section\": [16, 24, 24], \"rope_type\": \"default\", \"type\": \"default\"}\n+\n+\n+class Qwen2_5OmniThinkerConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen2_5OmniThinkerForConditionalGeneration`]. It is used to instantiate an\n+    Qwen2.5-Omni-Thinker model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of the Qwen2.5-Omni-Thinker.\n+\n+    e.g. [Qwen/Qwen2.5-Omni-7B](https://huggingface.co/Qwen/Qwen2.5-Omni-7B)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        audio_config (`dict`,  *optional*):\n+            The config dictionary of the audio backbone.\n+        vision_config (`dict`, *optional*):\n+            The config dictionary of the vision backbone.\n+        text_config (`dict`, *optional*):\n+            The config dictionary of the text backbone.\n+        audio_token_index (`int`, *optional*, defaults to 151646):\n+            The audio token index to encode the audio prompt.\n+        image_token_index (`int`, *optional*, defaults to 151655):\n+            The image token index to encode the image prompt.\n+        video_token_index (`int`, *optional*, defaults to 151656):\n+            The video token index to encode the video prompt.\n+        position_id_per_seconds (`int`, *optional*, defaults to 25):\n+            The increment of position id per second.\n+        seconds_per_chunk (`int`, *optional*, defaults to 2):\n+            The duration in seconds of the chunk of audio and video data.\n+        audio_start_token_id (`int`, *optional*, defaults to 151647):\n+            The audio start token index to encode the audio prompt.\n+        audio_end_token_id (`int`, *optional*, defaults to 151648):\n+            The audio end token index to encode the audio prompt.\n+        user_token_id (`int, *optional*, defaults to 872):\n+            The user token index to encode the user token.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Qwen2_5OmniThinkerForConditionalGeneration, Qwen2_5OmniThinkerConfig, Qwen2_5OmniAudioEncoderConfig, Qwen2_5OmniVisionEncoderConfig\n+\n+    >>> # Initializing a Qwen2_5OmniAudioEncoder config\n+    >>> audio_config = Qwen2_5OmniAudioEncoderConfig()\n+\n+    >>> # Initializing a Qwen2_5OmniVisionEncoder config\n+    >>> vision_config = Qwen2_5OmniVisionEncoderConfig()\n+\n+    >>> # Initializing a Qwen2_5OmniTextConfig config\n+    >>> text_config = Qwen2_5OmniTextConfig()\n+\n+    >>> # Initializing a Qwen2.5OmniThinker configuration\n+    >>> configuration = Qwen2_5OmniThinkerConfig(audio_config, vision_config, text_config)\n+\n+    >>> # Initializing a model from the Qwen-Omni style configuration\n+    >>> model = Qwen2_5OmniThinkerForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen2_5_omni_thinker\"\n+    sub_configs = {\n+        \"audio_config\": Qwen2_5OmniAudioEncoderConfig,\n+        \"vision_config\": Qwen2_5OmniVisionEncoderConfig,\n+        \"text_config\": Qwen2_5OmniTextConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        audio_config=None,\n+        vision_config=None,\n+        text_config=None,\n+        audio_token_index=151646,\n+        image_token_index=151655,\n+        video_token_index=151656,\n+        position_id_per_seconds=25,\n+        seconds_per_chunk=2,\n+        audio_start_token_id=151647,\n+        audio_end_token_id=151648,\n+        user_token_id=872,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        self.audio_token_index = audio_token_index\n+        self.image_token_index = image_token_index\n+        self.video_token_index = video_token_index\n+        self.user_token_id = user_token_id\n+        self.position_id_per_seconds = position_id_per_seconds\n+        self.seconds_per_chunk = seconds_per_chunk\n+        self.audio_start_token_id = audio_start_token_id\n+        self.audio_end_token_id = audio_end_token_id\n+        self.initializer_range = initializer_range\n+\n+        if isinstance(vision_config, dict):\n+            vision_config = Qwen2_5OmniVisionEncoderConfig(**vision_config)\n+        elif vision_config is None:\n+            vision_config = Qwen2_5OmniVisionEncoderConfig()\n+        self.vision_config = vision_config\n+\n+        if isinstance(audio_config, dict):\n+            audio_config = Qwen2_5OmniAudioEncoderConfig(**audio_config)\n+        elif audio_config is None:\n+            audio_config = Qwen2_5OmniAudioEncoderConfig()\n+        self.audio_config = audio_config\n+\n+        if isinstance(text_config, dict):\n+            text_config = Qwen2_5OmniTextConfig(**text_config)\n+        elif text_config is None:\n+            text_config = Qwen2_5OmniTextConfig()\n+        self.text_config = text_config\n+\n+        super().__init__(**kwargs)\n+\n+\n+class Qwen2_5OmniTalkerConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen2_5OmniTalkerForConditionalGeneration`]. It is used to instantiate an\n+    Qwen2.5-Omni-Talker model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of the Qwen2.5-Omni-Thinker.\n+\n+    e.g. [Qwen/Qwen2.5-Omni-7B](https://huggingface.co/Qwen/Qwen2.5-Omni-7B)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        audio_token_index (`int`, *optional*, defaults to 151646):\n+            The audio token index to encode the audio prompt.\n+        image_token_index (`int`, *optional*, defaults to 151655):\n+            The image token index to encode the image prompt.\n+        video_token_index (`int`, *optional*, defaults to 151656):\n+            The video token index to encode the video prompt.\n+        vocab_size (`int`, *optional*, defaults to 8448):\n+            Vocabulary size of the QwenOmni model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Qwen2VLModel`]\n+        tts_text_start_token_id (`int`, *optional*, defaults to 151860):\n+            The tts text start token index to encode the start of tts text.\n+        tts_text_end_token_id (`int`, *optional*, defaults to 151861):\n+            The tts text end token index to encode the end of tts text.\n+        tts_text_pad_token_id (`int`, *optional*, defaults to 151859):\n+            The tts text pad token index to encode the pad of tts text.\n+        tts_codec_start_token_id (`int`, *optional*, defaults to 8293):\n+            The tts codec start token index to encode the start of tts codec.\n+        tts_codec_end_token_id (`int`, *optional*, defaults to 8294):\n+            The tts codec end token index to encode the end of tts codec.\n+        tts_codec_pad_token_id (`int`, *optional*, defaults to 8292):\n+            The tts codec pad token index to encode the pad of tts codec.\n+        tts_codec_mask_token_id (`int`, *optional*, defaults to 8296):\n+            The tts codec mask token index to encode the mask of tts codec.\n+        vision_start_token_id (`int`, *optional*, defaults to 151652):\n+            The tts vision start token index to encode the start of vision.\n+        vision_end_token_id (`int`, *optional*, defaults to 151653):\n+            The tts vision end token index to encode the end of vision.\n+        embedding_size (`int`, *optional*, defaults to 3584):\n+            Dimension of the embedding representations.\n+        hidden_size (`int`, *optional*, defaults to 3584):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 18944):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 28):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 28):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 4):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `32`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 32768):\n+            The maximum sequence length that this model might ever be used with.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the rms normalization layers.\n+        head_dim (`int`, *optional*, defaults to 128):\n+            The dimension of each attention head.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_theta (`float`, *optional*, defaults to 1000000.0):\n+            The base period of the RoPE embeddings.\n+        use_sliding_window (`bool`, *optional*, defaults to `False`):\n+            Whether to use sliding window attention.\n+        sliding_window (`int`, *optional*, defaults to 32768):\n+            Sliding window attention (SWA) window size. If not specified, will default to `4096`.\n+        max_window_layers (`int`, *optional*, defaults to 28):\n+            The number of layers that use SWA (Sliding Window Attention). The bottom layers use SWA while the top use full attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n+                    'llama3'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n+                    pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n+                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n+                    `factor` field to infer the suggested value.\n+                `beta_fast` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for extrapolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 32.\n+                `beta_slow` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for interpolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 1.\n+                `short_factor` (`List[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to short contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `long_factor` (`List[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to long contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `low_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to low frequency components of the RoPE\n+                `high_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to high frequency components of the RoPE\n+        position_id_per_seconds (`int`, *optional*, defaults to 25):\n+            The increment of position id per second.\n+        seconds_per_chunk (`int`, *optional*, defaults to 2):\n+            The duration in seconds of the chunk of audio and video data.\n+        audio_start_token_id (`int`, *optional*, defaults to 151647):\n+            The audio start token index to encode the audio prompt.\n+        audio_end_token_id (`int`, *optional*, defaults to 151648):\n+            The audio end token index to encode the audio prompt.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        spatial_merge_size (`int`, *optional*, defaults to 2):\n+            The size used for merging spatial dimensions.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Qwen2_5OmniTalkerForConditionalGeneration, Qwen2_5OmniThinkerConfig, Qwen2_5OmniAudioEncoderConfig, Qwen2_5OmniVisionEncoderConfig\n+\n+    >>> # Initializing a Qwen2_5OmniAudioEncoder config\n+    >>> audio_config = Qwen2_5OmniAudioEncoderConfig()\n+\n+    >>> # Initializing a Qwen2 config\n+    >>> text_config = Qwen2Config()\n+\n+    >>> # Initializing a Qwen2_5Omni configuration\n+    >>> configuration = Qwen2_5OmniThinkerConfig(audio_config, text_config)\n+\n+    >>> # Initializing a model from the qwen2-audio style configuration\n+    >>> model = Qwen2_5OmniTalkerForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen2_5_omni_talker\"\n+\n+    def __init__(\n+        self,\n+        audio_token_index=151646,\n+        image_token_index=151655,\n+        video_token_index=151656,\n+        vocab_size=8448,\n+        tts_text_start_token_id=151860,\n+        tts_text_end_token_id=151861,\n+        tts_text_pad_token_id=151859,\n+        tts_codec_start_token_id=8293,\n+        tts_codec_end_token_id=8294,\n+        tts_codec_pad_token_id=8292,\n+        tts_codec_mask_token_id=8296,\n+        vision_start_token_id=151652,\n+        vision_end_token_id=151653,\n+        embedding_size=3584,\n+        hidden_size=3584,\n+        intermediate_size=18944,\n+        num_hidden_layers=28,\n+        num_attention_heads=28,\n+        num_key_value_heads=4,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=32768,\n+        rms_norm_eps=1e-06,\n+        head_dim=128,\n+        use_cache=True,\n+        tie_word_embeddings=False,\n+        rope_theta=1000000.0,\n+        use_sliding_window=False,\n+        sliding_window=32768,\n+        max_window_layers=28,\n+        attention_dropout=0.0,\n+        rope_scaling=None,\n+        position_id_per_seconds=25,\n+        seconds_per_chunk=2,\n+        audio_start_token_id=151647,\n+        audio_end_token_id=151648,\n+        initializer_range=0.02,\n+        spatial_merge_size=2,\n+        **kwargs,\n+    ):\n+        self.audio_token_index = audio_token_index\n+        self.image_token_index = image_token_index\n+        self.video_token_index = video_token_index\n+\n+        self.tts_text_start_token_id = tts_text_start_token_id\n+        self.tts_text_end_token_id = tts_text_end_token_id\n+        self.tts_text_pad_token_id = tts_text_pad_token_id\n+        self.tts_codec_start_token_id = tts_codec_start_token_id\n+        self.tts_codec_end_token_id = tts_codec_end_token_id\n+        self.tts_codec_pad_token_id = tts_codec_pad_token_id\n+\n+        self.tts_codec_mask_token_id = tts_codec_mask_token_id\n+\n+        self.vision_start_token_id = vision_start_token_id\n+        self.vision_end_token_id = vision_end_token_id\n+\n+        self.vocab_size = vocab_size\n+        self.head_dim = head_dim\n+        self.embedding_size = embedding_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.use_sliding_window = use_sliding_window\n+        self.sliding_window = sliding_window\n+        self.max_window_layers = max_window_layers\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.attention_dropout = attention_dropout\n+        self.rope_scaling = rope_scaling\n+        self.position_id_per_seconds = position_id_per_seconds  # zf\n+        self.seconds_per_chunk = seconds_per_chunk  # zf\n+        self.audio_start_token_id = audio_start_token_id  # zf\n+        self.audio_end_token_id = audio_end_token_id  # zf\n+\n+        self.initializer_range = initializer_range\n+        self.spatial_merge_size = spatial_merge_size\n+\n+        super().__init__(tie_word_embeddings=tie_word_embeddings, **kwargs)\n+\n+\n+class Qwen2_5OmniDiTConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of the Qwen2_5OmniToken2WavDiT used in the Qwen2.5-Omni-Token2Wav model.\n+    It defines the architecture of the DiT model, which is used for generating mel-spectrograms from tokens.\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 1024):\n+            The dimension of the model.\n+        num_hidden_layers (`int`, *optional*, defaults to 22):\n+            The number of transformer blocks in the DiT model.\n+        num_attention_heads (`int`, *optional*, defaults to 16):\n+            The number of attention heads in each transformer block.\n+        ff_mult (`int`, *optional*, defaults to 2):\n+            The multiplier for the feedforward layer in each transformer block.\n+        emb_dim (`int`, *optional*, defaults to 512):\n+            The dimension of the embedding layer.\n+        head_dim (`int`, *optional*, defaults to 64):\n+            The dimension of each attention head.\n+        repeats (`int`, *optional*, defaults to 2):\n+            The number of times the codec embeddings are repeated.\n+        num_embeds (`int`, *optional*, defaults to 8193):\n+            The number of unique embeddings in the codec.\n+        mel_dim (`int`, *optional*, defaults to 80):\n+            The dimension of the mel-spectrogram.\n+        dropout (`float`, *optional*, defaults to 0.1):\n+            The dropout rate for the transformer blocks.\n+\n+        enc_emb_dim (`int`, *optional*, defaults to 192):\n+            The dimension of the pre-trained speaker embedding.\n+        enc_dim (`int`, *optional*, defaults to 128):\n+            The dimension of the encoder output.\n+        enc_channels (`List[int]`, *optional*, defaults to `[256, 256, 256, 256, 768]`):\n+            A list of output channels for each TDNN/SERes2Net layer in the encoder.\n+        enc_kernel_sizes (`List[int]`, *optional*, defaults to `[5, 3, 3, 3, 1]`):\n+            A list of kernel sizes for each layer in the encoder.\n+        enc_dilations (`List[int]`, *optional*, defaults to `[1, 2, 3, 4, 1]`):\n+            A list of dilations for each layer in the encoder.\n+        enc_attention_channels (`int`, *optional*, defaults to 64):\n+            The number of attention channels in the SqueezeExcitationBlock.\n+        enc_res2net_scale (`int`, *optional*, defaults to 2):\n+            The scale of the Res2Net block in the encoder.\n+        enc_se_channels (`int`, *optional*, defaults to 64):\n+            The number of output channels after squeeze in the SqueezeExcitationBlock.\n+    \"\"\"\n+\n+    model_type = \"qwen2_5_omni_dit\"\n+\n+    def __init__(\n+        self,\n+        hidden_size=1024,\n+        num_hidden_layers=22,\n+        num_attention_heads=16,\n+        ff_mult=2,\n+        emb_dim=512,\n+        head_dim=64,\n+        rope_theta=10000.0,\n+        max_position_embeddings=32768,\n+        block_size=24,\n+        look_ahead_layers=[10],\n+        look_backward_layers=[0, 20],\n+        repeats=2,\n+        num_embeds=8193,\n+        mel_dim=80,\n+        dropout=0.1,\n+        enc_emb_dim=192,\n+        enc_dim=128,\n+        enc_channels=[256, 256, 256, 256, 768],\n+        enc_kernel_sizes=[5, 3, 3, 3, 1],\n+        enc_dilations=[1, 2, 3, 4, 1],\n+        enc_attention_channels=64,\n+        enc_res2net_scale=2,\n+        enc_se_channels=64,\n+        **kwargs,\n+    ):\n+        self.hidden_size = hidden_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.ff_mult = ff_mult\n+        self.emb_dim = emb_dim\n+        self.head_dim = head_dim\n+        self.rope_theta = rope_theta\n+        self.max_position_embeddings = max_position_embeddings\n+        self.block_size = block_size\n+        self.look_ahead_layers = look_ahead_layers\n+        self.look_backward_layers = look_backward_layers\n+        self.repeats = repeats\n+        self.num_embeds = num_embeds\n+        self.mel_dim = mel_dim\n+        self.dropout = dropout\n+        self.enc_emb_dim = enc_emb_dim\n+        self.enc_dim = enc_dim\n+        self.enc_channels = enc_channels\n+        self.enc_kernel_sizes = enc_kernel_sizes\n+        self.enc_dilations = enc_dilations\n+        self.enc_attention_channels = enc_attention_channels\n+        self.enc_res2net_scale = enc_res2net_scale\n+        self.enc_se_channels = enc_se_channels\n+        super().__init__(**kwargs)\n+\n+\n+class Qwen2_5OmniBigVGANConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of the Qwen2_5OmniToken2WavBigVGAN module used in the Qwen2.5-Omni-Token2Wav model.\n+    It defines the architecture of the BigVGAN model, which is used for converting mel-spectrograms to waveforms.\n+\n+    Args:\n+        mel_dim (`int`, *optional*, defaults to 80):\n+            The dimension of the mel-spectrogram.\n+        upsample_initial_channel (`int`, *optional*, defaults to 1536):\n+            The number of channels in the initial upsampling layer.\n+        resblock_kernel_sizes (`List[int]`, *optional*, defaults to `[3, 7, 11]`):\n+            A list of kernel sizes for each residual block.\n+        resblock_dilation_sizes (`List[List[int]]`, *optional*, defaults to `[[1, 3, 5], [1, 3, 5], [1, 3, 5]]`):\n+            A list of dilation sizes for each residual block.\n+        upsample_rates (`List[int]`, *optional*, defaults to `[5, 3, 2, 2, 2, 2]`):\n+            A list of upsampling rates for each upsampling layer.\n+        upsample_kernel_sizes (`List[int]`, *optional*, defaults to `[11, 7, 4, 4, 4, 4]`):\n+            A list of kernel sizes for each upsampling layer.\n+    \"\"\"\n+\n+    model_type = \"qwen2_5_omni_bigvgan\"\n+\n+    def __init__(\n+        self,\n+        mel_dim=80,\n+        upsample_initial_channel=1536,\n+        resblock_kernel_sizes=[3, 7, 11],\n+        resblock_dilation_sizes=[[1, 3, 5], [1, 3, 5], [1, 3, 5]],\n+        upsample_rates=[5, 3, 2, 2, 2, 2],\n+        upsample_kernel_sizes=[11, 7, 4, 4, 4, 4],\n+        **kwargs,\n+    ):\n+        self.mel_dim = mel_dim\n+        self.upsample_initial_channel = upsample_initial_channel\n+        self.resblock_kernel_sizes = resblock_kernel_sizes\n+        self.resblock_dilation_sizes = resblock_dilation_sizes\n+        self.upsample_rates = upsample_rates\n+        self.upsample_kernel_sizes = upsample_kernel_sizes\n+        super().__init__(**kwargs)\n+\n+\n+class Qwen2_5OmniToken2WavConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen2_5OmniToken2WavModel`].\n+    It is used to instantiate the Qwen2.5-Omni-Token2Wav model which combines a Diffusion Transformer (DiT) for mel-spectrogram generation with a BigVGAN model for waveform synthesis. The configuration contains sub-configurations for both components.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        dit_config ([`DiT_Args`], *optional*):\n+            Configuration class for the Diffusion Transformer (DiT) module responsible for generating mel-spectrograms.\n+        bigvgan_config ([`BigVGAN_Args`], *optional*):\n+            Configuration class for the BigVGAN module responsible for converting mel-spectrograms to waveforms.\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Qwen2_5OmniToken2WavModel, DiT_Args, BigVGAN_Args\n+\n+    >>> # Initialize DiT configuration\n+    >>> dit_config = DiT_Args(\n+    ...     dim=1024,\n+    ...     depth=22,\n+    ...     heads=16,\n+    ...     ff_mult=2\n+    ... )\n+\n+    >>> # Initialize BigVGAN configuration\n+    >>> bigvgan_config = BigVGAN_Args(\n+    ...     mel_dim=80,\n+    ...     upsample_rates=[5,3,2,2,2,2]\n+    ... )\n+\n+    >>> # Initialize main configuration\n+    >>> config = Qwen2_5OmniToken2WavConfig(dit_config, bigvgan_config)\n+\n+    >>> # Initialize model with config\n+    >>> model = Qwen2_5OmniToken2Wav(config)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    \"\"\"\n+\n+    model_type = \"qwen2_5_omni_token2wav\"\n+    sub_configs = {\n+        \"dit_config\": Qwen2_5OmniDiTConfig,\n+        \"bigvgan_config\": Qwen2_5OmniBigVGANConfig,\n+    }\n+\n+    def __init__(self, dit_config=None, bigvgan_config=None, **kwargs):\n+        if dit_config is None:\n+            dit_config = {}\n+        if bigvgan_config is None:\n+            bigvgan_config = {}\n+        self.dit_config = Qwen2_5OmniDiTConfig(**dit_config)\n+        self.bigvgan_config = Qwen2_5OmniBigVGANConfig(**bigvgan_config)\n+        super().__init__(**kwargs)\n+\n+\n+class Qwen2_5OmniConfig(PretrainedConfig):\n+    \"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen2_5OmniForConditionalGeneration`]. It is used to instantiate a Qwen2.5Omni\n+    model according to the specified sub-models configurations, defining the model architecture.\n+\n+    Instantiating a configuration with the defaults will yield a similar configuration to that of the\n+    [Qwen/Qwen2.5-Omni-7B](https://huggingface.co/Qwen/Qwen2.5-Omni-7B) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        thinker_config (`dict`, *optional*): Configuration of the underlying thinker sub-model.\n+        talker_config (`dict`, *optional*): Configuration of the underlying talker sub-model.\n+        token2wav_config (`dict`, *optional*): Configuration of the underlying codec sub-model.\n+        enable_audio_output (`bool`, *optional*, defaults to `True`): Whether enabel audio output and load talker and token2wav module.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import (\n+    ...     Qwen2_5OmniThinkerConfig,\n+    ...     Qwen2_5OmniTalkerConfig,\n+    ...     Qwen2_5OmniToken2WavConfig,\n+    ...     Qwen2_5OmniForConditionalGeneration,\n+    ...     Qwen2_5OmniConfig,\n+    ... )\n+\n+    >>> # Initializing sub-modules configurations.\n+    >>> thinker_config = Qwen2_5OmniThinkerConfig()\n+    >>> talker_config = Qwen2_5OmniTalkerConfig()\n+    >>> token2wav_config = Qwen2_5OmniToken2WavConfig()\n+\n+\n+    >>> # Initializing a module style configuration\n+    >>> configuration = Qwen2_5OmniConfig.from_sub_model_configs(\n+    ...     thinker_config, talker_config, token2wav_config\n+    ... )\n+\n+    >>> # Initializing a model (with random weights)\n+    >>> model = Qwen2_5OmniForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\n+    \"\"\"\n+\n+    model_type = \"qwen2_5_omni\"\n+    sub_configs = {\n+        \"thinker_config\": Qwen2_5OmniThinkerConfig,\n+        \"talker_config\": Qwen2_5OmniTalkerConfig,\n+        \"token2wav_config\": Qwen2_5OmniToken2WavConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        thinker_config=None,\n+        talker_config=None,\n+        token2wav_config=None,\n+        enable_audio_output: bool = True,\n+        **kwargs,\n+    ):\n+        if thinker_config is None:\n+            thinker_config = {}\n+            logger.info(\"thinker_config is None. Initializing thinker model with default values\")\n+\n+        if talker_config is None:\n+            talker_config = {}\n+            logger.info(\"talker_config is None. Initializing talker model with default values\")\n+\n+        if token2wav_config is None:\n+            token2wav_config = {}\n+            logger.info(\"token2wav_config is None. Initializing token2wav model with default values\")\n+\n+        self.thinker_config = Qwen2_5OmniThinkerConfig(**thinker_config)\n+        self.talker_config = Qwen2_5OmniTalkerConfig(**talker_config)\n+        self.token2wav_config = Qwen2_5OmniToken2WavConfig(**token2wav_config)\n+        self.enable_audio_output = enable_audio_output\n+\n+        super().__init__(**kwargs)\n+\n+\n+__all__ = [\"Qwen2_5OmniConfig\", \"Qwen2_5OmniThinkerConfig\", \"Qwen2_5OmniTalkerConfig\", \"Qwen2_5OmniToken2WavConfig\"]"
        },
        {
            "sha": "464bf2bd8aff8887bc91b6b74c4b017f5ac41293",
            "filename": "src/transformers/models/qwen2_5_omni/modeling_qwen2_5_omni.py",
            "status": "added",
            "additions": 4639,
            "deletions": 0,
            "changes": 4639,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fmodeling_qwen2_5_omni.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fmodeling_qwen2_5_omni.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fmodeling_qwen2_5_omni.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182"
        },
        {
            "sha": "5eef7eff2fb1044aef0d11cb4ebb1d2da47268ef",
            "filename": "src/transformers/models/qwen2_5_omni/modular_qwen2_5_omni.py",
            "status": "added",
            "additions": 4313,
            "deletions": 0,
            "changes": 4313,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fmodular_qwen2_5_omni.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fmodular_qwen2_5_omni.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fmodular_qwen2_5_omni.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182"
        },
        {
            "sha": "e223bbe59c4d6691de5957a2979907833efd74e1",
            "filename": "src/transformers/models/qwen2_5_omni/processing_qwen2_5_omni.py",
            "status": "added",
            "additions": 356,
            "deletions": 0,
            "changes": 356,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fprocessing_qwen2_5_omni.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fprocessing_qwen2_5_omni.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_omni%2Fprocessing_qwen2_5_omni.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -0,0 +1,356 @@\n+# coding=utf-8\n+# Copyright 2025 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"\n+Processor class for Qwen2.5Omni.\n+\"\"\"\n+\n+import logging\n+import re\n+from typing import List, Optional, Union\n+\n+import numpy as np\n+\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_utils import ImageInput, VideoInput, make_batched_videos\n+from ...processing_utils import ImagesKwargs, ProcessingKwargs, ProcessorMixin, Unpack, VideosKwargs\n+from ...tokenization_utils_base import AudioInput, PreTokenizedInput, TextInput\n+\n+\n+class Qwen2_5_OmniVideosKwargs(VideosKwargs):\n+    fps: Optional[List[int]] = None\n+    use_audio_in_video: Optional[bool] = None\n+    seconds_per_chunk: Optional[float] = None\n+    position_id_per_seconds: Optional[int] = None\n+    min_pixels: Optional[int]\n+    max_pixels: Optional[int]\n+    patch_size: Optional[int]\n+    temporal_patch_size: Optional[int]\n+    merge_size: Optional[int]\n+\n+\n+class Qwen2_5_OmniImagesKwargs(ImagesKwargs):\n+    min_pixels: Optional[int]\n+    max_pixels: Optional[int]\n+    patch_size: Optional[int]\n+    temporal_patch_size: Optional[int]\n+    merge_size: Optional[int]\n+\n+\n+class Qwen2_5OmniProcessorKwargs(ProcessingKwargs, total=False):\n+    videos_kwargs: Qwen2_5_OmniVideosKwargs\n+    images_kwargs: Qwen2_5_OmniImagesKwargs\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": False,\n+            \"padding_side\": \"left\",\n+        },\n+        \"videos_kwargs\": {\n+            \"seconds_per_chunk\": 2.0,\n+            \"position_id_per_seconds\": 25,\n+            \"use_audio_in_video\": False,\n+        },\n+        \"audio_kwargs\": {\n+            \"sampling_rate\": 16000,\n+            \"padding\": \"max_length\",\n+            \"return_attention_mask\": True,\n+        },\n+    }\n+\n+\n+class Qwen2_5OmniProcessor(ProcessorMixin):\n+    r\"\"\"\n+    Constructs a Qwen2.5Omni processor.\n+    [`Qwen2_5OmniProcessor`] offers all the functionalities of [`Qwen2VLImageProcessor`], [`WhisperFeatureExtractor`], and [`Qwen2TokenizerFast`]. See the\n+    [`~Qwen2_5OmniProcessor.__call__`] and [`~Qwen2_5OmniProcessor.decode`] for more information.\n+\n+    Args:\n+        image_processor ([`Qwen2VLImageProcessor`], *optional*):\n+            The image processor.\n+        feature_extractor ([`WhisperFeatureExtractor`], *optional*):\n+            The audio feature extractor.\n+        tokenizer ([`Qwen2TokenizerFast`], *optional*):\n+            The text tokenizer.\n+        chat_template (`Optional[str]`, *optional*):\n+            The Jinja template to use for formatting the conversation. If not provided, the default chat template is used.\n+    \"\"\"\n+\n+    attributes = [\"image_processor\", \"feature_extractor\", \"tokenizer\"]\n+    image_processor_class = \"Qwen2VLImageProcessor\"\n+    feature_extractor_class = \"WhisperFeatureExtractor\"\n+    tokenizer_class = (\"Qwen2Tokenizer\", \"Qwen2TokenizerFast\")\n+    valid_kwargs = [\"chat_template\"]\n+\n+    def __init__(self, image_processor=None, feature_extractor=None, tokenizer=None, chat_template=None):\n+        super().__init__(image_processor, feature_extractor, tokenizer, chat_template=chat_template)\n+        self.image_token = self.tokenizer.image_token\n+        self.audio_token = self.tokenizer.audio_token\n+        self.video_token = self.tokenizer.video_token\n+        self.vision_bos_token = self.tokenizer.vision_bos_token\n+        self.vision_eos_token = self.tokenizer.vision_eos_token\n+        self.audio_bos_token = self.tokenizer.audio_bos_token\n+        self.audio_eos_token = self.tokenizer.audio_eos_token\n+\n+    def __call__(\n+        self,\n+        text: Union[TextInput, PreTokenizedInput, List[TextInput], List[PreTokenizedInput]] = None,\n+        images: ImageInput = None,\n+        videos: VideoInput = None,\n+        audio: AudioInput = None,\n+        **kwargs: Unpack[Qwen2_5OmniProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Main method to prepare for the model one or several sequences(s) and audio(s). This method forwards the `text`\n+        and `kwargs` arguments to Qwen2TokenizerFast's [`~Qwen2TokenizerFast.__call__`] if `text` is not `None` to encode\n+        the text. To prepare the audio(s), this method forwards the `audio` and `kwargs` arguments to\n+        WhisperFeatureExtractor's [`~WhisperFeatureExtractor.__call__`] if `audio` is not `None`. To prepare the vision inputs,\n+        this method forwards the `vision_infos` and `kwargs` arguments to Qwen2VLImageProcessor's [`~Qwen2VLImageProcessor.__call__`]\n+        if `vision_infos` is not `None`. Please refer to the doctsring\n+        of the above two methods for more information.\n+\n+        Args:\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. Both channels-first and channels-last formats are supported.\n+            videos (`np.ndarray`, `torch.Tensor`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n+                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n+            audio (`np.ndarray`, `List[np.ndarray]`):\n+                The audio or batch of audio to be prepared. Each audio can be a NumPy array.\n+        \"\"\"\n+\n+        if text is None:\n+            raise ValueError(\"You need to specify either a `text` input to process.\")\n+\n+        output_kwargs = self._merge_kwargs(\n+            Qwen2_5OmniProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+\n+        seconds_per_chunk = output_kwargs[\"videos_kwargs\"].pop(\"seconds_per_chunk\")\n+        position_id_per_seconds = output_kwargs[\"videos_kwargs\"].pop(\"position_id_per_seconds\")\n+        use_audio_in_video = output_kwargs[\"videos_kwargs\"].pop(\"use_audio_in_video\")\n+        fps = output_kwargs[\"videos_kwargs\"].pop(\"fps\", None)\n+\n+        if audio is not None:\n+            output_kwargs[\"audio_kwargs\"][\"padding\"] = \"max_length\"  # Support \"max_length\" padding only here\n+            audio_inputs = self.feature_extractor(audio, **output_kwargs[\"audio_kwargs\"])\n+            audio_inputs[\"feature_attention_mask\"] = audio_inputs.pop(\n+                \"attention_mask\"\n+            )  # rename feature_attention_mask to prevent conflicts later on\n+            audio_inputs[\"input_features\"] = audio_inputs.pop(\n+                \"input_features\"\n+            )  # rename input_features to prevent conflicts later on\n+            input_lengths = (audio_inputs[\"feature_attention_mask\"].sum(-1) - 1) // 2 + 1\n+            audio_lengths = iter((input_lengths - 2) // 2 + 1)\n+        else:\n+            audio_inputs = {}\n+            audio_lengths = iter([])\n+\n+        if images is not None:\n+            images_inputs = self.image_processor(images=images, videos=None, **output_kwargs[\"images_kwargs\"])\n+            image_grid_thw = iter(images_inputs[\"image_grid_thw\"])\n+        else:\n+            images_inputs = {}\n+            image_grid_thw = iter([])\n+\n+        if videos is not None:\n+            videos = make_batched_videos(videos)\n+            videos_inputs = self.image_processor(images=None, videos=videos, **output_kwargs[\"videos_kwargs\"])\n+            if fps is None:\n+                fps = [2.0] * len(videos)\n+            videos_inputs[\"video_second_per_grid\"] = [\n+                self.image_processor.temporal_patch_size / fps[i] for i in range(len(fps))\n+            ]\n+            video_grid_thw = iter(videos_inputs[\"video_grid_thw\"])\n+            video_second_per_grid = iter(videos_inputs[\"video_second_per_grid\"])\n+        else:\n+            videos_inputs = {}\n+            video_grid_thw = iter([])\n+            video_second_per_grid = iter([])\n+\n+        if not isinstance(text, list):\n+            text = [text]\n+\n+        text = self.replace_multimodal_special_tokens(\n+            text,\n+            audio_lengths,\n+            image_grid_thw,\n+            video_grid_thw,\n+            video_second_per_grid=video_second_per_grid,\n+            use_audio_in_video=use_audio_in_video,\n+            position_id_per_seconds=position_id_per_seconds,\n+            seconds_per_chunk=seconds_per_chunk,\n+        )\n+\n+        texts_inputs = self.tokenizer(text, **output_kwargs[\"text_kwargs\"])\n+\n+        return BatchFeature(\n+            data={**texts_inputs, **images_inputs, **videos_inputs, **audio_inputs},\n+            tensor_type=kwargs.get(\"return_tensors\"),\n+        )\n+\n+    def replace_multimodal_special_tokens(\n+        self,\n+        text,\n+        audio_lengths,\n+        image_grid_thw,\n+        video_grid_thw,\n+        video_second_per_grid,\n+        use_audio_in_video,\n+        position_id_per_seconds,\n+        seconds_per_chunk,\n+    ):\n+        # Extend mm token length\n+        merge_length = self.image_processor.merge_size**2\n+\n+        processed_text = []\n+        for sample in text:\n+            positions = []\n+            special_tokens = [re.escape(tok) for tok in [self.audio_token, self.image_token, self.video_token]]\n+            pattern = \"|\".join(special_tokens)\n+            positions = sorted([(match.start(), match.group()) for match in re.finditer(pattern, sample)])\n+            positions.sort(key=lambda x: x[0])\n+\n+            for _, special_token in positions:\n+                if special_token == self.audio_token:\n+                    sample = sample.replace(self.audio_token, \"<|audio_placeholder|>\" * next(audio_lengths), 1)\n+                elif special_token == self.image_token:\n+                    image_seq_length = next(image_grid_thw).prod() // merge_length\n+                    sample = sample.replace(self.image_token, \"<|image_placeholder|>\" * image_seq_length, 1)\n+                elif special_token == self.video_token:\n+                    if not use_audio_in_video:\n+                        video_seq_length = next(video_grid_thw).prod() // merge_length\n+                        sample = sample.replace(self.video_token, \"<|video_placeholder|>\" * video_seq_length, 1)\n+                    else:\n+                        audio_token_indices = np.arange(next(audio_lengths))\n+                        curr_video_grid_thw = next(video_grid_thw)\n+                        height = curr_video_grid_thw[1] // self.image_processor.merge_size\n+                        width = curr_video_grid_thw[2] // self.image_processor.merge_size\n+                        video_token_indices = np.arange(curr_video_grid_thw[0]).view(-1, 1, 1)\n+                        video_token_indices = video_token_indices.expand(-1, height, width).flatten()\n+                        video_token_indices = (\n+                            video_token_indices * next(video_second_per_grid) * position_id_per_seconds\n+                        ).long()\n+\n+                        tokens_per_chunk = int(position_id_per_seconds * seconds_per_chunk)\n+                        video_chunk_indexes = self.get_chunked_index(video_token_indices, tokens_per_chunk)\n+                        audio_chunk_indexes = self.get_chunked_index(audio_token_indices, tokens_per_chunk)\n+\n+                        placeholder_string = self.vision_bos_token + self.audio_bos_token\n+                        for j in range(max(len(video_chunk_indexes), len(audio_chunk_indexes))):\n+                            if j < len(video_chunk_indexes):\n+                                video_seq_length = video_chunk_indexes[j][1] - video_chunk_indexes[j][0]\n+                                placeholder_string += \"<|video_placeholder|>\" * video_seq_length\n+                            if j < len(audio_chunk_indexes):\n+                                audio_seq_length = audio_chunk_indexes[j][1] - audio_chunk_indexes[j][0]\n+                                placeholder_string += \"<|audio_placeholder|>\" * audio_seq_length\n+                        placeholder_string += self.audio_eos_token + self.vision_eos_token\n+                        sample = sample.replace(\n+                            self.vision_bos_token + self.video_token + self.vision_eos_token,\n+                            placeholder_string,\n+                            1,\n+                        )\n+\n+            sample = sample.replace(\"<|audio_placeholder|>\", self.audio_token)\n+            sample = sample.replace(\"<|image_placeholder|>\", self.image_token)\n+            sample = sample.replace(\"<|video_placeholder|>\", self.video_token)\n+            processed_text.append(sample)\n+        return processed_text\n+\n+    def get_chunked_index(self, token_indices: np.ndarray, tokens_per_chunk: int) -> list[tuple[int, int]]:\n+        \"\"\"\n+        Splits token index list into chunks based on token value ranges.\n+\n+        Given a list of token indices, returns a list of (start, end) index tuples representing\n+        slices of the list where the token values fall within successive ranges of `t_ntoken_per_chunk`.\n+\n+        For example, if `t_ntoken_per_chunk` is 1000, the function will create chunks such that:\n+        - the first chunk contains token values < 1000,\n+        - the second chunk contains values >= 1000 and < 2000, and so on.\n+\n+        Parameters:\n+            token_indices (`List[int]`): A monotonically increasing list of token index values.\n+            t_ntoken_per_chunk (`int`): Number of tokens per chunk (used as the chunk size threshold).\n+\n+        Returns:\n+            `List[Tuple[int, int]]`: A list of tuples, each representing the start (inclusive)\n+                                and end (exclusive) indices of a chunk in `token_indices`.\n+        \"\"\"\n+\n+        def _iter():\n+            i, start_idx = 0, 0  # skip bos token\n+            current_chunk = 1\n+            while i < len(token_indices):  # skip eos token\n+                if token_indices[i] >= current_chunk * tokens_per_chunk:\n+                    yield (start_idx, i)\n+                    start_idx = i\n+                    current_chunk += 1\n+                i += 1\n+            yield (start_idx, len(token_indices))\n+\n+        return list(_iter())\n+\n+    def batch_decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to Qwen2TokenizerFast's [`~PreTrainedTokenizer.batch_decode`]. Please\n+        refer to the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.batch_decode(*args, **kwargs)\n+\n+    def decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to Qwen2TokenizerFast's [`~PreTrainedTokenizer.decode`]. Please refer to\n+        the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.decode(*args, **kwargs)\n+\n+    def apply_chat_template(self, conversations, chat_template=None, **kwargs):\n+        if isinstance(conversations[0], dict):\n+            conversations = [conversations]\n+        for conversation in conversations:\n+            if (\n+                conversation[0][\"role\"] != \"system\"\n+                or conversation[0][\"content\"][0][\"text\"]\n+                != \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\"\n+            ):\n+                logging.warning(\n+                    \"System prompt modified, audio output may not work as expected. \"\n+                    + \"Audio output mode only works when using default system prompt 'You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.'\"\n+                )\n+        return super().apply_chat_template(conversations, chat_template, **kwargs)\n+\n+    @property\n+    def model_input_names(self):\n+        tokenizer_input_names = self.tokenizer.model_input_names\n+        feature_extractor_input_names = self.feature_extractor.model_input_names\n+        image_processor_input_names = self.image_processor.model_input_names\n+        return list(\n+            dict.fromkeys(\n+                tokenizer_input_names\n+                + feature_extractor_input_names\n+                + image_processor_input_names\n+                + [\"feature_attention_mask\"]\n+                + [\"video_second_per_grid\"]\n+            )\n+        )\n+\n+\n+__all__ = [\"Qwen2_5OmniProcessor\"]"
        },
        {
            "sha": "6e1bfb0e5f6f6513f8c76cb1fa552a942746a835",
            "filename": "src/transformers/models/qwen2_5_vl/modeling_qwen2_5_vl.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fmodeling_qwen2_5_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fmodeling_qwen2_5_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fmodeling_qwen2_5_vl.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -868,7 +868,7 @@ def forward(\n             use_top_left_mask=self._flash_attn_uses_top_left_mask,\n         )\n \n-        attn_output = attn_output.reshape(bsz, q_len, self.hidden_size).contiguous()\n+        attn_output = attn_output.reshape(bsz, q_len, -1).contiguous()\n         attn_output = self.o_proj(attn_output)\n \n         if not output_attentions:\n@@ -1332,12 +1332,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "53bd4df9c315a67158d3658ffa81f76fdf1c343a",
            "filename": "src/transformers/models/qwen2_audio/configuration_qwen2_audio.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_audio%2Fconfiguration_qwen2_audio.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_audio%2Fconfiguration_qwen2_audio.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_audio%2Fconfiguration_qwen2_audio.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -59,7 +59,7 @@ class Qwen2AudioEncoderConfig(PretrainedConfig):\n             The dropout ratio for activations inside the fully connected layer.\n         scale_embedding (`bool`, *optional*, defaults to `False`):\n             Scale embeddings by diving by sqrt(d_model).\n-        init_std (`float`, *optional*, defaults to 0.02):\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n             The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n         max_source_positions (`int`, *optional*, defaults to 1500):\n             The maximum sequence length of log-mel filter-bank features that this model might ever be used with.\n@@ -94,7 +94,7 @@ def __init__(\n         activation_function=\"gelu\",\n         activation_dropout=0.0,\n         scale_embedding=False,\n-        init_std=0.02,\n+        initializer_range=0.02,\n         max_source_positions=1500,\n         **kwargs,\n     ):\n@@ -111,7 +111,7 @@ def __init__(\n         self.activation_dropout = activation_dropout\n         self.encoder_layerdrop = encoder_layerdrop\n         self.num_hidden_layers = encoder_layers\n-        self.init_std = init_std\n+        self.initializer_range = initializer_range\n         self.scale_embedding = scale_embedding  # scale factor will be sqrt(d_model) if True\n         self.max_source_positions = max_source_positions\n "
        },
        {
            "sha": "ad586a45c5083fdac21391fa940efa1485c3e80a",
            "filename": "src/transformers/models/qwen2_audio/modeling_qwen2_audio.py",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_audio%2Fmodeling_qwen2_audio.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_audio%2Fmodeling_qwen2_audio.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_audio%2Fmodeling_qwen2_audio.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -471,7 +471,11 @@ class Qwen2AudioPreTrainedModel(PreTrainedModel):\n     def _init_weights(self, module):\n         # important: this ported version of Qwen2Audio isn't meant for training from scratch - only\n         # inference and fine-tuning - so the proper init weights code has been removed\n-        std = self.config.init_std if hasattr(self.config, \"init_std\") else self.config.audio_config.init_std\n+        std = (\n+            self.config.initializer_range\n+            if hasattr(self.config, \"initializer_range\")\n+            else self.config.audio_config.initializer_range\n+        )\n \n         if isinstance(module, (nn.Linear, nn.Conv1d)):\n             module.weight.data.normal_(mean=0.0, std=std)"
        },
        {
            "sha": "40be54033cbca036dcd0abca887e8f3beac2ba6c",
            "filename": "src/transformers/models/qwen2_moe/modeling_qwen2_moe.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_moe%2Fmodeling_qwen2_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_moe%2Fmodeling_qwen2_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_moe%2Fmodeling_qwen2_moe.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -1157,12 +1157,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "f92402c92e7c64931247c51e2a8ef35edea77e6d",
            "filename": "src/transformers/models/qwen2_vl/modeling_qwen2_vl.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fmodeling_qwen2_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fmodeling_qwen2_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fmodeling_qwen2_vl.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -689,7 +689,7 @@ def forward(\n             use_top_left_mask=self._flash_attn_uses_top_left_mask,\n         )\n \n-        attn_output = attn_output.reshape(bsz, q_len, self.hidden_size).contiguous()\n+        attn_output = attn_output.reshape(bsz, q_len, -1).contiguous()\n         attn_output = self.o_proj(attn_output)\n \n         if not output_attentions:\n@@ -1287,12 +1287,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "f98a8a2759be4f6b2d4ff9a9da2420d8d722e241",
            "filename": "src/transformers/models/qwen3/modeling_qwen3.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen3%2Fmodeling_qwen3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen3%2Fmodeling_qwen3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen3%2Fmodeling_qwen3.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -732,12 +732,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "4196693d19ac05a2fa68a250fbccc4d4d311fc7d",
            "filename": "src/transformers/models/qwen3_moe/modeling_qwen3_moe.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen3_moe%2Fmodeling_qwen3_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fqwen3_moe%2Fmodeling_qwen3_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen3_moe%2Fmodeling_qwen3_moe.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -835,12 +835,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "64ffd865a5d4744ea5c5ef04d87ad1e4c7c97139",
            "filename": "src/transformers/models/starcoder2/modeling_starcoder2.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fstarcoder2%2Fmodeling_starcoder2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/src%2Ftransformers%2Fmodels%2Fstarcoder2%2Fmodeling_starcoder2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fstarcoder2%2Fmodeling_starcoder2.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -681,12 +681,12 @@ def _prepare_4d_causal_attention_mask_with_cache_position(\n                 (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n             )\n             diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n-            if config.sliding_window is not None:\n+            if config.get_text_config().sliding_window is not None:\n                 # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n                 # the check is needed to verify is current checkpoint was trained with sliding window or not\n                 if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n                     sliding_attend_mask = torch.arange(target_length, device=device) <= (\n-                        cache_position.reshape(-1, 1) - config.sliding_window\n+                        cache_position.reshape(-1, 1) - config.get_text_config().sliding_window\n                     )\n                     diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n             causal_mask *= diagonal_attend_mask"
        },
        {
            "sha": "fc74c1ae71474ceb9fc9c993d7c6fa932445357a",
            "filename": "tests/generation/test_utils.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/tests%2Fgeneration%2Ftest_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/tests%2Fgeneration%2Ftest_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_utils.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -129,6 +129,7 @@\n     \"gemma3\",\n     \"mistral3\",\n     \"chameleon\",\n+    \"qwen2_5_omni\",\n ]\n \n "
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/qwen2_5_omni/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/tests%2Fmodels%2Fqwen2_5_omni%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/tests%2Fmodels%2Fqwen2_5_omni%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen2_5_omni%2F__init__.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182"
        },
        {
            "sha": "f43f7bc6b1797404d9082b47d1fb131b030d15d9",
            "filename": "tests/models/qwen2_5_omni/test_modeling_qwen2_5_omni.py",
            "status": "added",
            "additions": 606,
            "deletions": 0,
            "changes": 606,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/tests%2Fmodels%2Fqwen2_5_omni%2Ftest_modeling_qwen2_5_omni.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/tests%2Fmodels%2Fqwen2_5_omni%2Ftest_modeling_qwen2_5_omni.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen2_5_omni%2Ftest_modeling_qwen2_5_omni.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -0,0 +1,606 @@\n+# coding=utf-8\n+# Copyright 2025 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch Qwen2.5-Omni model.\"\"\"\n+\n+import tempfile\n+import unittest\n+from io import BytesIO\n+from urllib.request import urlopen\n+\n+import librosa\n+import requests\n+from parameterized import parameterized\n+\n+from transformers import (\n+    AutoProcessor,\n+    Qwen2_5OmniForConditionalGeneration,\n+    Qwen2_5OmniThinkerConfig,\n+    Qwen2_5OmniThinkerForConditionalGeneration,\n+    is_torch_available,\n+    is_vision_available,\n+)\n+from transformers.testing_utils import (\n+    cleanup,\n+    require_flash_attn,\n+    require_torch,\n+    require_torch_gpu,\n+    require_torch_sdpa,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import (\n+    ModelTesterMixin,\n+    floats_tensor,\n+    ids_tensor,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+class Qwen2_5OmniThinkerForConditionalGenerationTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=3,\n+        feat_seq_length=30,\n+        num_channels=3,\n+        image_size=14,\n+        seq_length=39,\n+        vision_config={\n+            \"depth\": 2,\n+            \"embed_dim\": 32,\n+            \"hidden_act\": \"quick_gelu\",\n+            \"hidden_size\": 32,\n+            \"out_hidden_size\": 32,\n+            \"intermediate_size\": 24,\n+            \"mlp_ratio\": 4,\n+            \"num_heads\": 4,\n+            \"patch_size\": 14,\n+            \"spatial_merge_size\": 1,\n+            \"temporal_patch_size\": 2,\n+            \"fullatt_block_indexes\": [0],\n+            \"initializer_range\": 0.02,\n+        },\n+        audio_config={\n+            \"model_type\": \"qwen_omni_thinker_audio_encoder\",\n+            \"d_model\": 32,\n+            \"encoder_attention_heads\": 4,\n+            \"encoder_ffn_dim\": 32,\n+            \"encoder_layers\": 2,\n+            \"num_mel_bins\": 20,\n+            \"max_source_positions\": 1500,\n+            \"initializer_range\": 0.02,\n+            \"n_window\": 100,\n+            \"output_dim\": 32,\n+        },\n+        text_config={\n+            \"rope_scaling\": {\"mrope_section\": [1, 1, 2], \"rope_type\": \"default\", \"type\": \"default\"},\n+            \"vocab_size\": 99,\n+            \"hidden_size\": 32,\n+            \"intermediate_size\": 37,\n+            \"num_hidden_layers\": 4,\n+            \"num_attention_heads\": 4,\n+            \"num_key_value_heads\": 2,\n+            \"hidden_act\": \"silu\",\n+            \"max_position_embeddings\": 1024,\n+            \"rms_norm_eps\": 1e-06,\n+            \"use_cache\": True,\n+            \"tie_word_embeddings\": False,\n+            \"rope_theta\": 1000000.0,\n+            \"use_sliding_window\": False,\n+            \"sliding_window\": 50,\n+            \"max_window_layers\": 3,\n+            \"attention_dropout\": 0.0,\n+            \"pad_token_id\": 0,\n+            \"initializer_range\": 0.02,\n+        },\n+        audio_token_index=1,\n+        image_token_index=2,\n+        video_token_index=3,\n+        position_id_per_seconds=25,\n+        seconds_per_chunk=2,\n+        audio_start_token_id=4,\n+        audio_end_token_id=5,\n+        user_token_id=6,\n+        vision_start_token_id=7,\n+        vision_end_token_id=8,\n+        initializer_range=0.02,\n+    ):\n+        self.parent = parent\n+        self.audio_config = audio_config\n+        self.vision_config = vision_config\n+        self.text_config = text_config\n+        self.audio_token_index = audio_token_index\n+        self.image_token_index = image_token_index\n+        self.video_token_index = video_token_index\n+        self.position_id_per_seconds = position_id_per_seconds\n+        self.seconds_per_chunk = seconds_per_chunk\n+        self.audio_start_token_id = audio_start_token_id\n+        self.audio_end_token_id = audio_end_token_id\n+        self.vision_start_token_id = vision_start_token_id\n+        self.vision_end_token_id = vision_end_token_id\n+        self.user_token_id = user_token_id\n+        self.initializer_range = initializer_range\n+        self.batch_size = batch_size\n+        self.feat_seq_length = feat_seq_length\n+        self.num_channels = num_channels\n+        self.image_size = image_size\n+        self.seq_length = seq_length\n+        self.is_training = False\n+\n+        # Used from `self.model_tester` by common model tests\n+        self.num_hidden_layers = self.text_config[\"num_hidden_layers\"]\n+        self.hidden_size = self.text_config[\"hidden_size\"]\n+        self.num_attention_heads = self.text_config[\"num_attention_heads\"]\n+        self.vocab_size = self.text_config[\"vocab_size\"]\n+\n+    def get_config(self):\n+        return Qwen2_5OmniThinkerConfig(\n+            audio_config=self.audio_config,\n+            vision_config=self.vision_config,\n+            text_config=self.text_config,\n+            audio_token_index=self.audio_token_index,\n+            image_token_index=self.image_token_index,\n+            video_token_index=self.video_token_index,\n+            position_id_per_seconds=self.position_id_per_seconds,\n+            seconds_per_chunk=self.seconds_per_chunk,\n+            audio_start_token_id=self.audio_start_token_id,\n+            audio_end_token_id=self.audio_end_token_id,\n+            vision_start_token_id=self.vision_start_token_id,\n+            vision_end_token_id=self.vision_end_token_id,\n+            user_token_id=self.user_token_id,\n+            initializer_range=self.initializer_range,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        config = self.get_config()\n+        patch_size = config.vision_config.patch_size\n+        temporal_patch_size = config.vision_config.temporal_patch_size\n+        pixel_values = floats_tensor(\n+            [\n+                self.batch_size * (self.image_size**2) // (patch_size**2),\n+                self.num_channels * (patch_size**2) * temporal_patch_size,\n+            ]\n+        )\n+        pixel_grid_thw = torch.LongTensor(\n+            [[1, self.image_size / patch_size, self.image_size / patch_size]] * self.batch_size\n+        ).to(pixel_values.device)\n+        input_features_values = floats_tensor(\n+            [self.batch_size, self.audio_config[\"num_mel_bins\"], self.feat_seq_length]\n+        )\n+        feature_attention_mask = torch.ones([self.batch_size, self.feat_seq_length], dtype=torch.long).to(torch_device)\n+        return config, pixel_values, pixel_grid_thw, input_features_values, feature_attention_mask\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values, pixel_grid_thw, input_features_values, feature_attention_mask = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], config.get_text_config().vocab_size - 3) + 3\n+        attention_mask = torch.ones(input_ids.shape, dtype=torch.long).to(torch_device)\n+\n+        # Make sure no other tokens are set to special, to prevetn flakiness\n+        tokens_to_replace = torch.tensor(\n+            [\n+                config.image_token_index,\n+                config.audio_token_index,\n+                config.audio_start_token_id,\n+                config.audio_end_token_id,\n+                config.vision_start_token_id,\n+                config.vision_end_token_id,\n+            ],\n+            device=input_ids.device,\n+        )\n+        input_ids[torch.isin(input_ids, tokens_to_replace)] = config.text_config.pad_token_id\n+\n+        attention_mask[:, :1] = 0\n+\n+        # Audio token placeholders should be wrapped in start and end token ids\n+        audio_feat_length = ((self.feat_seq_length - 1) // 2 + 1 - 2) // 2 + 1\n+        input_ids[:, 1] = config.audio_start_token_id\n+        input_ids[:, 2 : (2 + audio_feat_length)] = config.audio_token_index\n+        input_ids[:, 2 + audio_feat_length] = config.audio_end_token_id\n+\n+        # Image token placeholders should be wrapped in start and end token ids\n+        input_ids[:, -4:-1] = torch.tensor(\n+            [config.vision_start_token_id, config.image_token_index, config.vision_end_token_id]\n+        )\n+        inputs_dict = {\n+            \"input_features\": input_features_values,\n+            \"feature_attention_mask\": feature_attention_mask,\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+            \"image_grid_thw\": pixel_grid_thw,\n+            \"pixel_values\": pixel_values,\n+        }\n+        return config, inputs_dict\n+\n+    def create_and_check_qwenomnithinker_model_fp16_forward(self, config, input_ids, pixel_values, attention_mask):\n+        model = Qwen2_5OmniThinkerForConditionalGeneration(config=config)\n+        model.to(torch_device)\n+        model.eval()\n+        with torch.autocast(device_type=torch_device, dtype=torch.float16):\n+            logits = model(\n+                input_ids=input_ids,\n+                attention_mask=attention_mask,\n+                pixel_values=pixel_values.to(torch.bfloat16),\n+                return_dict=True,\n+            )[\"logits\"]\n+        self.parent.assertFalse(torch.isnan(logits).any().item())\n+\n+\n+@require_torch\n+class Qwen2_5OmniThinkerForConditionalGenerationModelTest(ModelTesterMixin, GenerationTesterMixin, unittest.TestCase):\n+    \"\"\"\n+    Model tester for `Qwen2_5OmniThinkerForConditionalGeneration`.\n+    \"\"\"\n+\n+    all_model_classes = (Qwen2_5OmniThinkerForConditionalGeneration,) if is_torch_available() else ()\n+    all_generative_model_classes = (Qwen2_5OmniThinkerForConditionalGeneration,) if is_torch_available() else ()\n+    test_pruning = False\n+    test_head_masking = False\n+    _is_composite = True\n+\n+    def setUp(self):\n+        self.model_tester = Qwen2_5OmniThinkerForConditionalGenerationTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Qwen2_5OmniThinkerConfig, has_text_modality=False)\n+\n+    @unittest.skip(reason=\"Cpu not yet supported because in QwenOmniThinker models\")\n+    def test_disk_offload_bin(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Disk offload bin not yet supported because in QwenOmniThinker models\")\n+    def test_cpu_offload(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Disk offload safetensors not yet supported because in QwenOmniThinker models\")\n+    def test_disk_offload_safetensors(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Correct missing keys not yet supported because in QwenOmniThinker models\")\n+    def test_correct_missing_keys(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Compile not yet supported because in QwenOmniThinker models\")\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Sdpa dispatch not yet supported because in QwenOmniThinker models\")\n+    def test_sdpa_can_dispatch_on_flash(self):\n+        pass\n+\n+    @unittest.skip(reason=\"QwenOmniThinker does not use inputs_embeds\")\n+    def test_inputs_embeds(self):\n+        pass\n+\n+    @unittest.skip(reason=\"QwenOmniThinker does not support output_hidden_states test\")\n+    def test_model_outputs_equivalence(self):\n+        pass\n+\n+    @require_torch_sdpa\n+    def test_sdpa_can_dispatch_composite_models(self):\n+        # overwrite because Qwen2 is audio+text model (not vision+text)\n+        if not self.has_attentions:\n+            self.skipTest(reason=\"Model architecture does not support attentions\")\n+\n+        if not self._is_composite:\n+            self.skipTest(f\"{self.all_model_classes[0].__name__} does not support SDPA\")\n+\n+        for model_class in self.all_model_classes:\n+            config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+            model = model_class(config)\n+\n+            with tempfile.TemporaryDirectory() as tmpdirname:\n+                model.save_pretrained(tmpdirname)\n+                model_sdpa = model_class.from_pretrained(tmpdirname)\n+                model_sdpa = model_sdpa.eval().to(torch_device)\n+\n+                text_attn = \"sdpa\" if model.model._supports_sdpa else \"eager\"\n+                audio_attn = \"sdpa\" if model.audio_tower._supports_sdpa else \"eager\"\n+                vision_attn = \"sdpa\" if model.visual._supports_sdpa else \"eager\"\n+                # `None` as it is the requested one which will be assigned to each sub-config\n+                # Sub-model will dispatch to SDPA if it can (checked below that `SDPA` layers are present)\n+                self.assertTrue(model_sdpa.config._attn_implementation == \"sdpa\")\n+                self.assertTrue(model.model.config._attn_implementation == text_attn)\n+                self.assertTrue(model.audio_tower.config._attn_implementation == audio_attn)\n+                self.assertTrue(model.visual.config._attn_implementation == vision_attn)\n+\n+                model_eager = model_class.from_pretrained(tmpdirname, attn_implementation=\"eager\")\n+                model_eager = model_eager.eval().to(torch_device)\n+                self.assertTrue(model_eager.config._attn_implementation == \"eager\")\n+                self.assertTrue(model_eager.model.config._attn_implementation == \"eager\")\n+                self.assertTrue(model_eager.audio_tower.config._attn_implementation == \"eager\")\n+                self.assertTrue(model_eager.visual.config._attn_implementation == \"eager\")\n+\n+                for name, submodule in model_eager.named_modules():\n+                    class_name = submodule.__class__.__name__\n+                    if \"SdpaAttention\" in class_name or \"SdpaSelfAttention\" in class_name:\n+                        raise ValueError(\"The eager model should not have SDPA attention layers\")\n+\n+    @parameterized.expand([(\"greedy\", 1), (\"beam search\", 2)])\n+    @unittest.skip(\"Cannot generate from inputs embeds\")\n+    def test_generate_from_inputs_embeds(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot do contrastive generation, has custom `generate()`\")\n+    def test_contrastive_generate(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot do contrastive generation, has custom `generate()`\")\n+    def test_contrastive_generate_dict_outputs_use_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot do contrastive generation, has custom `generate()`\")\n+    def test_contrastive_generate_low_memory(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot do constraint generation, has custom `generate()`\")\n+    def test_constrained_beam_search_generate_dict_output(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot do dola generation, has custom `generate()`\")\n+    def test_dola_decoding_sample(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot generate from inputs embeds\")\n+    def test_generate_from_inputs_embeds_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot handle 4D attention mask\")\n+    def test_generate_compile_model_forward(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot handle 4D attention mask\")\n+    def test_generate_compilation_all_outputs(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot handle 4D attention mask\")\n+    def test_generate_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Cannot handle 4D attention mask\")\n+    def test_custom_4d_attention_mask(self):\n+        pass\n+\n+\n+@require_torch\n+class Qwen2_5OmniModelIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2.5-Omni-7B\")\n+        self.audio_url = \"https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen2-Audio/audio/glass-breaking-151256.mp3\"\n+        self.audio_url_additional = (\n+            \"https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen2-Audio/audio/f2641_0_throatclearing.wav\"\n+        )\n+        self.image_url = \"https://qianwen-res.oss-accelerate-overseas.aliyuncs.com/Qwen2-VL/demo_small.jpg\"\n+        self.messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"audio\", \"audio_url\": self.audio_url},\n+                    {\"type\": \"image\", \"image_url\": self.image_url},\n+                    {\"type\": \"text\", \"text\": \"What's that sound and what kind of dog is this?\"},\n+                ],\n+            }\n+        ]\n+\n+        self.raw_audio, _ = librosa.load(\n+            BytesIO(urlopen(self.audio_url).read()), sr=self.processor.feature_extractor.sampling_rate\n+        )\n+        self.raw_audio_additional, _ = librosa.load(\n+            BytesIO(urlopen(self.audio_url_additional).read()), sr=self.processor.feature_extractor.sampling_rate\n+        )\n+        self.raw_image = Image.open(requests.get(self.image_url, stream=True).raw)\n+\n+    def tearDown(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    @slow\n+    def test_small_model_integration_test(self):\n+        model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-Omni-7B\", torch_dtype=torch.float32, device_map=\"auto\"\n+        )\n+\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(\n+            text=[text], audio=[self.raw_audio], images=[self.raw_image], return_tensors=\"pt\", padding=True\n+        )\n+\n+        expected_input_ids = torch.tensor(\n+            [\n+                151644,\n+                8948,\n+                198,\n+                2610,\n+                525,\n+                264,\n+                10950,\n+                17847,\n+                13,\n+                151645,\n+                198,\n+                151644,\n+                872,\n+                198,\n+                151647,\n+                151646,\n+                151648,\n+            ]\n+        )\n+        assert torch.allclose(expected_input_ids, inputs.input_ids[0][:17], atol=3e-3)\n+\n+        expected_pixel_slice = torch.tensor(\n+            [\n+                [0.8792, 0.8792, 0.9084],\n+                [1.1858, 1.1858, 1.2296],\n+                [1.2004, 1.2004, 1.2150],\n+                [1.4340, 1.4340, 1.4194],\n+                [1.3902, 1.4048, 1.4194],\n+                [1.5216, 1.5362, 1.5362],\n+            ],\n+            dtype=torch.float32,\n+            device=\"cpu\",\n+        )\n+        assert torch.allclose(expected_pixel_slice, inputs.pixel_values[:6, :3], atol=3e-3)\n+\n+        # verify generation\n+        inputs = inputs.to(torch_device)\n+\n+        output = model.generate(**inputs, thinker_temperature=0, thinker_do_sample=False, return_audio=False)\n+\n+        EXPECTED_DECODED_TEXT = \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog appears to be a Labrador Retriever.\"\n+\n+        self.assertEqual(\n+            self.processor.decode(output[0], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_batch(self):\n+        model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-Omni-7B\", torch_dtype=torch.float32, device_map=\"auto\"\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(\n+            text=[text, text],\n+            audio=[self.raw_audio, self.raw_audio],\n+            images=[self.raw_image, self.raw_image],\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        output = model.generate(**inputs, thinker_temperature=0, thinker_do_sample=False, return_audio=False)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog appears to be a Labrador Retriever.\",\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog appears to be a Labrador Retriever.\",\n+        ]\n+\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_multiturn(self):\n+        model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-Omni-7B\", torch_dtype=torch.float32, device_map=\"auto\"\n+        )\n+\n+        messages = [\n+            self.messages[0],\n+            {\n+                \"role\": \"assistant\",\n+                \"content\": \"The sound is glass shattering, and the dog appears to be a Labrador Retriever.\",\n+            },\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"audio\", \"audio_url\": self.audio_url_additional},\n+                    {\"type\": \"text\", \"text\": \"How about this one?\"},\n+                ],\n+            },\n+        ]\n+\n+        text = self.processor.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(\n+            text=[text],\n+            audio=[self.raw_audio, self.raw_audio_additional],\n+            images=[self.raw_image],\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        output = model.generate(**inputs, thinker_temperature=0, thinker_do_sample=False, return_audio=False)\n+\n+        EXPECTED_DECODED_TEXT = \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog appears to be a Labrador Retriever.\\nuser\\nHow about this one?\\nassistant\\nThe sound is a cough.\"\n+\n+        self.assertEqual(\n+            self.processor.decode(output[0], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_w_audio(self):\n+        model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-Omni-7B\", torch_dtype=torch.float32, device_map=\"auto\"\n+        )\n+        audio_url = \"https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen2-Audio/audio/guess_age_gender.wav\"\n+\n+        messages = [\n+            {\n+                \"role\": \"system\",\n+                \"content\": \"You are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\",\n+            },\n+            {\n+                \"role\": \"user\",\n+                \"content\": [{\"type\": \"audio\", \"audio\": audio_url}],\n+            },\n+        ]\n+        audio, _ = librosa.load(BytesIO(urlopen(audio_url).read()), sr=self.processor.feature_extractor.sampling_rate)\n+\n+        text = self.processor.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text], audio=[audio], return_tensors=\"pt\", padding=True).to(torch_device)\n+\n+        output = model.generate(**inputs, thinker_temperature=0, thinker_do_sample=False)\n+\n+        EXPECTED_DECODED_TEXT = \"system\\nYou are Qwen, a virtual human developed by the Qwen Team, Alibaba Group, capable of perceiving auditory and visual inputs, as well as generating text and speech.\\nuser\\n\\nassistant\\nWell, I can't really guess your age and gender just from your voice. There are so many factors that can affect how a voice sounds, like the environment you're in, how you're feeling at the moment, and even the microphone you're using. But if you want to share more about your voice, like if it's high - pitched or low - pitched, that might give me a bit of an idea. So, what can you tell me about your voice?\"\n+\n+        self.assertEqual(\n+            self.processor.decode(output[0][0], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+        self.assertFalse(torch.isnan(output[1]).any().item())\n+\n+    @slow\n+    @require_flash_attn\n+    @require_torch_gpu\n+    def test_small_model_integration_test_batch_flashatt2(self):\n+        model = Qwen2_5OmniForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-Omni-7B\",\n+            torch_dtype=torch.bfloat16,\n+            attn_implementation=\"flash_attention_2\",\n+            device_map=\"auto\",\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(\n+            text=[text, text],\n+            audio=[self.raw_audio, self.raw_audio],\n+            images=[self.raw_image, self.raw_image],\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        output = model.generate(**inputs, thinker_temperature=0, thinker_do_sample=False, return_audio=False)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog appears to be a Labrador Retriever.\",\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat's that sound and what kind of dog is this?\\nassistant\\nThe sound is glass shattering, and the dog appears to be a Labrador Retriever.\",\n+        ]\n+\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True)[0],\n+            self.processor.batch_decode(output, skip_special_tokens=True)[1],\n+        )"
        },
        {
            "sha": "411063480d0c789067a53096abf50108afc4ebcd",
            "filename": "tests/models/qwen2_5_omni/test_processor_qwen2_5_omni.py",
            "status": "added",
            "additions": 616,
            "deletions": 0,
            "changes": 616,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/tests%2Fmodels%2Fqwen2_5_omni%2Ftest_processor_qwen2_5_omni.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/tests%2Fmodels%2Fqwen2_5_omni%2Ftest_processor_qwen2_5_omni.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen2_5_omni%2Ftest_processor_qwen2_5_omni.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -0,0 +1,616 @@\n+# coding=utf-8\n+# Copyright 2025 The Qwen team, Alibaba Group and the HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import inspect\n+import shutil\n+import tempfile\n+import unittest\n+\n+import numpy as np\n+import pytest\n+from huggingface_hub import hf_hub_download\n+\n+from transformers import (\n+    AutoProcessor,\n+    Qwen2_5OmniProcessor,\n+    Qwen2Tokenizer,\n+    WhisperFeatureExtractor,\n+)\n+from transformers.testing_utils import require_av, require_librosa, require_torch, require_torchaudio, require_vision\n+from transformers.utils import is_torch_available, is_vision_available\n+\n+from ...test_processing_common import ProcessorTesterMixin\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_vision_available():\n+    from transformers import Qwen2VLImageProcessor\n+\n+\n+@require_vision\n+@require_torch\n+@require_torchaudio\n+class Qwen2_5OmniProcessorTest(ProcessorTesterMixin, unittest.TestCase):\n+    processor_class = Qwen2_5OmniProcessor\n+\n+    #  text + audio kwargs testing\n+    @require_torch\n+    def test_tokenizer_defaults_preserved_by_kwargs_audio(self):\n+        if \"feature_extractor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n+        feature_extractor = self.get_component(\"feature_extractor\")\n+        if hasattr(self, \"get_tokenizer\"):\n+            tokenizer = self.get_tokenizer(max_length=800, padding=\"max_length\")\n+        elif hasattr(self, \"get_component\"):\n+            tokenizer = self.get_component(\"tokenizer\", max_length=800, padding=\"max_length\")\n+        else:\n+            self.assertTrue(False, \"Processor doesn't have get_tokenizer or get_component defined\")\n+        if not tokenizer.pad_token:\n+            tokenizer.pad_token = \"[TEST_PAD]\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        processor = self.processor_class(\n+            tokenizer=tokenizer, feature_extractor=feature_extractor, image_processor=image_processor\n+        )\n+        self.skip_processor_without_typed_kwargs(processor)\n+        input_str = \"lower newer\"\n+        raw_speech = self.prepare_audio_inputs()\n+        inputs = processor(text=input_str, audio=raw_speech, return_tensors=\"pt\")\n+        if \"input_ids\" in inputs:\n+            self.assertEqual(len(inputs[\"input_ids\"][0]), 800)\n+        elif \"labels\" in inputs:\n+            self.assertEqual(len(inputs[\"labels\"][0]), 800)\n+\n+    @require_torch\n+    @require_vision\n+    def test_structured_kwargs_audio_nested(self):\n+        if \"feature_extractor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n+        feature_extractor = self.get_component(\"feature_extractor\")\n+        if hasattr(self, \"get_tokenizer\"):\n+            tokenizer = self.get_tokenizer()\n+        elif hasattr(self, \"get_component\"):\n+            tokenizer = self.get_component(\"tokenizer\")\n+        if not tokenizer.pad_token:\n+            tokenizer.pad_token = \"[TEST_PAD]\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        processor = self.processor_class(\n+            tokenizer=tokenizer, feature_extractor=feature_extractor, image_processor=image_processor\n+        )\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = [\"lower newer\"]\n+        raw_speech = self.prepare_audio_inputs()\n+\n+        # Define the kwargs for each modality\n+        all_kwargs = {\n+            \"common_kwargs\": {\"return_tensors\": \"pt\"},\n+            \"audio_kwargs\": {\"max_length\": 800},\n+        }\n+\n+        inputs = processor(text=input_str, audio=raw_speech, **all_kwargs)\n+        if \"input_ids\" in inputs:\n+            self.assertEqual(len(inputs[\"input_ids\"][0]), 2)\n+        elif \"labels\" in inputs:\n+            self.assertEqual(len(inputs[\"labels\"][0]), 2)\n+\n+    @require_torch\n+    def test_unstructured_kwargs_audio(self):\n+        if \"feature_extractor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n+        feature_extractor = self.get_component(\"feature_extractor\")\n+        if hasattr(self, \"get_tokenizer\"):\n+            tokenizer = self.get_tokenizer(max_length=117)\n+        elif hasattr(self, \"get_component\"):\n+            tokenizer = self.get_component(\"tokenizer\", max_length=117)\n+        if not tokenizer.pad_token:\n+            tokenizer.pad_token = \"[TEST_PAD]\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        processor = self.processor_class(\n+            tokenizer=tokenizer, feature_extractor=feature_extractor, image_processor=image_processor\n+        )\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = \"lower newer\"\n+        raw_speech = self.prepare_audio_inputs()\n+        inputs = processor(\n+            text=input_str,\n+            audio=raw_speech,\n+            return_tensors=\"pt\",\n+            padding=\"max_length\",\n+            max_length=800,\n+        )\n+\n+        if \"input_ids\" in inputs:\n+            self.assertEqual(len(inputs[\"input_ids\"][0]), 800)\n+        elif \"labels\" in inputs:\n+            self.assertEqual(len(inputs[\"labels\"][0]), 800)\n+\n+    @require_torch\n+    def test_doubly_passed_kwargs_audio(self):\n+        if \"feature_extractor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n+        feature_extractor = self.get_component(\"feature_extractor\")\n+        if hasattr(self, \"get_tokenizer\"):\n+            tokenizer = self.get_tokenizer()\n+        elif hasattr(self, \"get_component\"):\n+            tokenizer = self.get_component(\"tokenizer\")\n+        if not tokenizer.pad_token:\n+            tokenizer.pad_token = \"[TEST_PAD]\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        self.processor_class(tokenizer=tokenizer, feature_extractor=feature_extractor, image_processor=image_processor)\n+\n+    @require_torch\n+    def test_kwargs_overrides_default_tokenizer_kwargs_audio(self):\n+        if \"feature_extractor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n+        feature_extractor = self.get_component(\"feature_extractor\")\n+        if hasattr(self, \"get_tokenizer\"):\n+            tokenizer = self.get_tokenizer(max_length=117)\n+        elif hasattr(self, \"get_component\"):\n+            tokenizer = self.get_component(\"tokenizer\", max_length=117)\n+        if not tokenizer.pad_token:\n+            tokenizer.pad_token = \"[TEST_PAD]\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        self.processor_class(tokenizer=tokenizer, feature_extractor=feature_extractor, image_processor=image_processor)\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.tmpdirname = tempfile.mkdtemp()\n+        processor_kwargs = cls.prepare_processor_dict()\n+        processor = Qwen2_5OmniProcessor.from_pretrained(\"Qwen/Qwen2.5-Omni-7B\", **processor_kwargs)\n+        processor.save_pretrained(cls.tmpdirname)\n+\n+    def get_tokenizer(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).tokenizer\n+\n+    def get_image_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).image_processor\n+\n+    def get_feature_extractor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).feature_extractor\n+\n+    @staticmethod\n+    def prepare_processor_dict():\n+        return {\n+            \"chat_template\": \"{% set audio_count = namespace(value=0) %}{% set image_count = namespace(value=0) %}{% set video_count = namespace(value=0) %}{% for message in messages %}{% if loop.first and message['role'] != 'system' %}<|im_start|>system\\nYou are a helpful assistant.<|im_end|>\\n{% endif %}<|im_start|>{{ message['role'] }}\\n{% if message['content'] is string %}{{ message['content'] }}<|im_end|>\\n{% else %}{% for content in message['content'] %}{% if content['type'] == 'image' or 'image' in content or 'image_url' in content %}{% set image_count.value = image_count.value + 1 %}{% if add_vision_id %}Picture {{ image_count.value }}: {% endif %}<|vision_bos|><|IMAGE|><|vision_eos|>{% elif content['type'] == 'audio' or 'audio' in content or 'audio_url' in content %}{% set audio_count.value = audio_count.value + 1 %}{% if add_audio_id %}Audio {{ audio_count.value }}: {% endif %}<|audio_bos|><|AUDIO|><|audio_eos|>{% elif content['type'] == 'video' or 'video' in content %}{% set video_count.value = video_count.value + 1 %}{% if add_vision_id %}Video {{ video_count.value }}: {% endif %}<|vision_bos|><|VIDEO|><|vision_eos|>{% elif 'text' in content %}{{ content['text'] }}{% endif %}{% endfor %}<|im_end|>\\n{% endif %}{% endfor %}{% if add_generation_prompt %}<|im_start|>assistant\\n{% endif %}\"\n+        }\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        shutil.rmtree(cls.tmpdirname, ignore_errors=True)\n+\n+    def prepare_audio_inputs(self):\n+        \"\"\"This function prepares a list of numpy audios.\"\"\"\n+        audio_inputs = [np.random.rand(160000) * 2 - 1] * 3  # batch-size=3\n+        return audio_inputs\n+\n+    def test_save_load_pretrained_default(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+        feature_extractor = self.get_feature_extractor()\n+\n+        processor = Qwen2_5OmniProcessor(\n+            image_processor=image_processor, feature_extractor=feature_extractor, tokenizer=tokenizer\n+        )\n+        processor.save_pretrained(self.tmpdirname)\n+        processor = Qwen2_5OmniProcessor.from_pretrained(self.tmpdirname, use_fast=False)\n+\n+        self.assertEqual(processor.tokenizer.get_vocab(), tokenizer.get_vocab())\n+        self.assertEqual(processor.image_processor.to_json_string(), image_processor.to_json_string())\n+        self.assertEqual(processor.feature_extractor.to_json_string(), feature_extractor.to_json_string())\n+        self.assertIsInstance(processor.tokenizer, Qwen2Tokenizer)\n+        self.assertIsInstance(processor.image_processor, Qwen2VLImageProcessor)\n+        self.assertIsInstance(processor.feature_extractor, WhisperFeatureExtractor)\n+\n+    def test_image_processor(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+        feature_extractor = self.get_feature_extractor()\n+\n+        processor = Qwen2_5OmniProcessor(\n+            image_processor=image_processor, feature_extractor=feature_extractor, tokenizer=tokenizer\n+        )\n+\n+        image_input = self.prepare_image_inputs()\n+\n+        input_image_proc = image_processor(image_input, return_tensors=\"np\")\n+        input_processor = processor(images=image_input, text=\"dummy\", return_tensors=\"np\")\n+\n+        for key in input_image_proc.keys():\n+            self.assertAlmostEqual(input_image_proc[key].sum(), input_processor[key].sum(), delta=1e-2)\n+\n+    def test_processor(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+        feature_extractor = self.get_feature_extractor()\n+\n+        processor = Qwen2_5OmniProcessor(\n+            image_processor=image_processor, feature_extractor=feature_extractor, tokenizer=tokenizer\n+        )\n+\n+        input_str = \"lower newer\"\n+        image_input = self.prepare_image_inputs()\n+        audio_input = self.prepare_audio_inputs()\n+        inputs = processor(text=input_str, images=image_input, audio=audio_input)\n+        keys = list(inputs.keys())\n+        self.assertListEqual(\n+            keys,\n+            [\n+                \"input_ids\",\n+                \"attention_mask\",\n+                \"pixel_values\",\n+                \"image_grid_thw\",\n+                \"feature_attention_mask\",\n+                \"input_features\",\n+            ],\n+        )\n+\n+        # test if it raises when no input is passed\n+        with pytest.raises(ValueError):\n+            processor()\n+\n+        # test if it raises when no text is passed\n+        with pytest.raises(ValueError):\n+            processor(images=image_input)\n+\n+    def test_model_input_names(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+        feature_extractor = self.get_feature_extractor()\n+\n+        processor = Qwen2_5OmniProcessor(\n+            image_processor=image_processor, feature_extractor=feature_extractor, tokenizer=tokenizer\n+        )\n+\n+        input_str = \"lower newer\"\n+        image_input = self.prepare_image_inputs()\n+        video_inputs = self.prepare_video_inputs()\n+        audio_input = self.prepare_audio_inputs()\n+\n+        inputs = processor(text=input_str, images=image_input, videos=video_inputs, audio=audio_input)\n+        self.assertListEqual(sorted(inputs.keys()), sorted(processor.model_input_names))\n+\n+    @require_torch\n+    def _test_apply_chat_template(\n+        self,\n+        modality: str,\n+        batch_size: int,\n+        return_tensors: str,\n+        input_name: str,\n+        processor_name: str,\n+        input_data: list[str],\n+    ):\n+        processor = self.get_processor()\n+        if processor.chat_template is None:\n+            self.skipTest(\"Processor has no chat template\")\n+\n+        if processor_name not in self.processor_class.attributes:\n+            self.skipTest(f\"{processor_name} attribute not present in {self.processor_class}\")\n+\n+        batch_messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [{\"type\": \"text\", \"text\": \"Describe this.\"}],\n+                },\n+            ]\n+        ] * batch_size\n+\n+        # Test that jinja can be applied\n+        formatted_prompt = processor.apply_chat_template(batch_messages, add_generation_prompt=True, tokenize=False)\n+        self.assertEqual(len(formatted_prompt), batch_size)\n+\n+        # Test that tokenizing with template and directly with `self.tokenizer` gives same output\n+        formatted_prompt_tokenized = processor.apply_chat_template(\n+            batch_messages, add_generation_prompt=True, tokenize=True, return_tensors=return_tensors\n+        )\n+        add_special_tokens = True\n+        if processor.tokenizer.bos_token is not None and formatted_prompt[0].startswith(processor.tokenizer.bos_token):\n+            add_special_tokens = False\n+        tok_output = processor.tokenizer(\n+            formatted_prompt, return_tensors=return_tensors, add_special_tokens=add_special_tokens\n+        )\n+        expected_output = tok_output.input_ids\n+        self.assertListEqual(expected_output.tolist(), formatted_prompt_tokenized.tolist())\n+\n+        # Test that kwargs passed to processor's `__call__` are actually used\n+        tokenized_prompt_100 = processor.apply_chat_template(\n+            batch_messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            padding=\"max_length\",\n+            truncation=True,\n+            return_tensors=return_tensors,\n+            max_length=100,\n+        )\n+        self.assertEqual(len(tokenized_prompt_100[0]), 100)\n+\n+        # Test that `return_dict=True` returns text related inputs in the dict\n+        out_dict_text = processor.apply_chat_template(\n+            batch_messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=return_tensors,\n+        )\n+        self.assertTrue(all(key in out_dict_text for key in [\"input_ids\", \"attention_mask\"]))\n+        self.assertEqual(len(out_dict_text[\"input_ids\"]), batch_size)\n+        self.assertEqual(len(out_dict_text[\"attention_mask\"]), batch_size)\n+\n+        # Test that with modality URLs and `return_dict=True`, we get modality inputs in the dict\n+        for idx, url in enumerate(input_data[:batch_size]):\n+            batch_messages[idx][0][\"content\"] = [batch_messages[idx][0][\"content\"][0], {\"type\": modality, \"url\": url}]\n+\n+        out_dict = processor.apply_chat_template(\n+            batch_messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=return_tensors,\n+            num_frames=4,  # by default no more than 4 frames, otherwise too slow\n+        )\n+        input_name = getattr(self, input_name)\n+        self.assertTrue(input_name in out_dict)\n+        self.assertEqual(len(out_dict[\"input_ids\"]), batch_size)\n+        self.assertEqual(len(out_dict[\"attention_mask\"]), batch_size)\n+        self.assertEqual(len(out_dict[input_name]), batch_size * 1564)\n+\n+        return_tensor_to_type = {\"pt\": torch.Tensor, \"np\": np.ndarray, None: list}\n+        for k in out_dict:\n+            self.assertIsInstance(out_dict[k], return_tensor_to_type[return_tensors])\n+\n+    @require_av\n+    def test_apply_chat_template_video_frame_sampling(self):\n+        processor = self.get_processor()\n+        if processor.chat_template is None:\n+            self.skipTest(\"Processor has no chat template\")\n+\n+        signature = inspect.signature(processor.__call__)\n+        if \"videos\" not in {*signature.parameters.keys()} or (\n+            signature.parameters.get(\"videos\") is not None\n+            and signature.parameters[\"videos\"].annotation == inspect._empty\n+        ):\n+            self.skipTest(\"Processor doesn't accept videos at input\")\n+\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\"type\": \"text\", \"text\": \"What is shown in this video?\"},\n+                    ],\n+                },\n+            ]\n+        ]\n+\n+        formatted_prompt = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=False)\n+        self.assertEqual(len(formatted_prompt), 1)\n+\n+        formatted_prompt_tokenized = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=True)\n+        expected_output = processor.tokenizer(formatted_prompt, return_tensors=None).input_ids\n+        self.assertListEqual(expected_output, formatted_prompt_tokenized)\n+\n+        out_dict = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=True, return_dict=True)\n+        self.assertListEqual(list(out_dict.keys()), [\"input_ids\", \"attention_mask\"])\n+\n+        # Add video URL for return dict and load with `num_frames` arg\n+        messages[0][0][\"content\"].append(\n+            {\n+                \"type\": \"video\",\n+                \"url\": \"https://test-videos.co.uk/vids/bigbuckbunny/mp4/h264/720/Big_Buck_Bunny_720_10s_10MB.mp4\",\n+            }\n+        )\n+        num_frames = 3\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            num_frames=num_frames,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 9568)\n+\n+        # Load with `video_fps` arg\n+        video_fps = 1\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            video_fps=video_fps,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 23920)\n+\n+        # Load with `video_fps` and `num_frames` args, should raise an error\n+        with self.assertRaises(ValueError):\n+            out_dict_with_video = processor.apply_chat_template(\n+                messages,\n+                add_generation_prompt=True,\n+                tokenize=True,\n+                return_dict=True,\n+                video_fps=video_fps,\n+                num_frames=num_frames,\n+            )\n+\n+        # Load without any arg should load the whole video\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 717600)\n+\n+        # Load video as a list of frames (i.e. images). NOTE: each frame should have same size\n+        # because we assume they come from one video\n+        messages[0][0][\"content\"][-1] = {\n+            \"type\": \"video\",\n+            \"url\": [\n+                \"https://www.ilankelman.org/stopsigns/australia.jpg\",\n+                \"https://www.ilankelman.org/stopsigns/australia.jpg\",\n+            ],\n+        }\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 5704)\n+\n+    @require_av\n+    def test_apply_chat_template_video_special_processing(self):\n+        \"\"\"\n+        Tests that models can use their own preprocessing to preprocess conversations.\n+        \"\"\"\n+        processor = self.get_processor()\n+        if processor.chat_template is None:\n+            self.skipTest(\"Processor has no chat template\")\n+\n+        signature = inspect.signature(processor.__call__)\n+        if \"videos\" not in {*signature.parameters.keys()} or (\n+            signature.parameters.get(\"videos\") is not None\n+            and signature.parameters[\"videos\"].annotation == inspect._empty\n+        ):\n+            self.skipTest(\"Processor doesn't accept videos at input\")\n+\n+        video_file_path = hf_hub_download(\n+            repo_id=\"raushan-testing-hf/videos-test\", filename=\"sample_demo_1.mp4\", repo_type=\"dataset\"\n+        )\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\"type\": \"video\", \"path\": video_file_path},\n+                        {\"type\": \"text\", \"text\": \"What is shown in this video?\"},\n+                    ],\n+                },\n+            ]\n+        ]\n+\n+        def _process_messages_for_chat_template(\n+            conversation,\n+            batch_images,\n+            batch_videos,\n+            batch_video_metadata,\n+            **chat_template_kwargs,\n+        ):\n+            # Let us just always return a dummy prompt\n+            new_msg = [\n+                [\n+                    {\n+                        \"role\": \"user\",\n+                        \"content\": [\n+                            {\"type\": \"video\"},  # no need to use path, video is loaded already by this moment\n+                            {\"type\": \"text\", \"text\": \"Dummy prompt for preprocess testing\"},\n+                        ],\n+                    },\n+                ]\n+            ]\n+            return new_msg\n+\n+        processor._process_messages_for_chat_template = _process_messages_for_chat_template\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+\n+        # Check with `in` because we don't know how each template formats the prompt with BOS/EOS/etc\n+        formatted_text = processor.batch_decode(out_dict_with_video[\"input_ids\"], skip_special_tokens=True)[0]\n+        self.assertTrue(\"Dummy prompt for preprocess testing\" in formatted_text)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 145912)\n+\n+    @require_librosa\n+    @require_av\n+    @unittest.skip(\n+        \"@raushan: librosa can'r decode this audio in CI runner, fix after adding moviepy or another decoder\"\n+    )\n+    def test_chat_template_audio_from_video(self):\n+        processor = self.get_processor()\n+        if processor.chat_template is None:\n+            self.skipTest(\"Processor has no chat template\")\n+\n+        signature = inspect.signature(processor.__call__)\n+        if \"videos\" not in {*signature.parameters.keys()} or (\n+            signature.parameters.get(\"videos\") is not None\n+            and signature.parameters[\"videos\"].annotation == inspect._empty\n+        ):\n+            self.skipTest(f\"{self.processor_class} does not suport video inputs\")\n+\n+        if \"feature_extractor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n+\n+        video_file_path = hf_hub_download(\n+            repo_id=\"raushan-testing-hf/videos-test\", filename=\"sample_demo_1.mp4\", repo_type=\"dataset\"\n+        )\n+        messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"video\", \"path\": video_file_path},\n+                    {\"type\": \"text\", \"text\": \"Which of these animals is making the sound?\"},\n+                ],\n+            },\n+            {\n+                \"role\": \"assistant\",\n+                \"content\": [{\"type\": \"text\", \"text\": \"It is a cow.\"}],\n+            },\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"text\", \"text\": \"Tell me all about this animal.\"},\n+                ],\n+            },\n+        ]\n+\n+        formatted_prompt = processor.apply_chat_template([messages], add_generation_prompt=True, tokenize=False)\n+        self.assertEqual(len(formatted_prompt), 1)  # batch size=1\n+\n+        out_dict = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=\"np\",\n+            load_audio_from_video=True,\n+        )\n+        self.assertTrue(self.audio_input_name in out_dict)\n+        self.assertTrue(self.videos_input_name in out_dict)\n+\n+        # should always have input_ids and attention_mask\n+        self.assertEqual(len(out_dict[\"input_ids\"]), 1)  # batch-size=1\n+        self.assertEqual(len(out_dict[\"attention_mask\"]), 1)  # batch-size=1\n+        self.assertEqual(len(out_dict[self.audio_input_name]), 1)  # 1 audio in the conversation\n+        self.assertEqual(len(out_dict[self.videos_input_name]), 145912)  # 1 video in the conversation"
        },
        {
            "sha": "4c6f9031ae2fb80dfd282d3bdcf6f562ce599d4f",
            "filename": "tests/test_processing_common.py",
            "status": "modified",
            "additions": 4,
            "deletions": 10,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/tests%2Ftest_processing_common.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/tests%2Ftest_processing_common.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Ftest_processing_common.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -719,11 +719,9 @@ def test_overlapping_text_audio_kwargs_handling(self):\n         if \"feature_extractor\" not in self.processor_class.attributes:\n             self.skipTest(f\"feature_extractor attribute not present in {self.processor_class}\")\n \n-        feature_extractor = self.get_component(\"feature_extractor\")\n-        tokenizer = self.get_component(\"tokenizer\")\n+        processor_components = self.prepare_components()\n         processor_kwargs = self.prepare_processor_dict()\n-\n-        processor = self.processor_class(tokenizer=tokenizer, feature_extractor=feature_extractor, **processor_kwargs)\n+        processor = self.processor_class(**processor_components, **processor_kwargs)\n         self.skip_processor_without_typed_kwargs(processor)\n \n         input_str = self.prepare_text_inputs(batch_size=3, modality=\"audio\")\n@@ -1128,11 +1126,7 @@ def test_chat_template_audio_from_video(self):\n             {\n                 \"role\": \"user\",\n                 \"content\": [\n-                    {\n-                        \"type\": \"audio\",\n-                        \"url\": \"https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen2-Audio/audio/glass-breaking-151256.mp3\",\n-                    },\n-                    {\"type\": \"text\", \"text\": \"Is it the same sound?\"},\n+                    {\"type\": \"text\", \"text\": \"Tell me all about this animal.\"},\n                 ],\n             },\n         ]\n@@ -1154,5 +1148,5 @@ def test_chat_template_audio_from_video(self):\n         # should always have input_ids and attention_mask\n         self.assertEqual(len(out_dict[\"input_ids\"]), 1)  # batch-size=1\n         self.assertEqual(len(out_dict[\"attention_mask\"]), 1)  # batch-size=1\n-        self.assertEqual(len(out_dict[self.audio_input_name]), 2)  # 2 audios in the conversation\n+        self.assertEqual(len(out_dict[self.audio_input_name]), 1)  # 1 audio in the conversation\n         self.assertEqual(len(out_dict[self.videos_input_name]), 1)  # 1 video in the conversation"
        },
        {
            "sha": "aeba4ee73de4f3b9fcf2edeb48e3a9f482c273de",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/4b8c6d4cf8c779bf0895deb980669f5b2cb5d182/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=4b8c6d4cf8c779bf0895deb980669f5b2cb5d182",
            "patch": "@@ -143,6 +143,13 @@\n         \"ChameleonVQVAE\",  # VQVAE here is used only for encoding (discretizing) and is tested as part of bigger model\n         \"Qwen2VLModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2VLForConditionalGeneration.\n         \"Qwen2_5_VLModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2_5_VLForConditionalGeneration.\n+        \"Qwen2_5OmniForConditionalGeneration\",  # Not a regular model. Testted in Qwen2_5OmniModelIntergrationTest\n+        \"Qwen2_5OmniTalkerForConditionalGeneration\",  #  Building part of bigger (tested) model. Tested implicitly through Qwen2_5OmniModelIntergrationTest.\n+        \"Qwen2_5OmniTalkerModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2_5OmniModelIntergrationTest.\n+        \"Qwen2_5OmniThinkerTextModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2_5OmniModelIntergrationTest.\n+        \"Qwen2_5OmniToken2WavModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2_5OmniModelIntergrationTest.\n+        \"Qwen2_5OmniToken2WavDiTModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2_5OmniModelIntergrationTest.\n+        \"Qwen2_5OmniToken2WavBigVGANModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2_5OmniModelIntergrationTest.\n         \"MllamaTextModel\",  # Building part of bigger (tested) model. # TODO: add tests\n         \"MllamaVisionModel\",  # Building part of bigger (tested) model. # TODO: add tests\n         \"Llama4TextModel\",  # Building part of bigger (tested) model. # TODO: add tests\n@@ -348,6 +355,13 @@\n     \"MoshiForConditionalGeneration\",  # no auto class for speech-to-speech\n     \"Emu3VQVAE\",  # no autoclass for VQ-VAE models\n     \"Emu3TextModel\",  # Building part of bigger (tested) model\n+    \"Qwen2_5OmniTalkerForConditionalGeneration\",  # Building part of a bigger model\n+    \"Qwen2_5OmniTalkerModel\",  # Building part of a bigger model\n+    \"Qwen2_5OmniThinkerForConditionalGeneration\",  # Building part of a bigger model\n+    \"Qwen2_5OmniThinkerTextModel\",  # Building part of a bigger model\n+    \"Qwen2_5OmniToken2WavModel\",  # Building part of a bigger model\n+    \"Qwen2_5OmniToken2WavBigVGANModel\",  # Building part of a bigger model\n+    \"Qwen2_5OmniToken2WavDiTModel\",  # Building part of a bigger model\n ]\n \n # DO NOT edit this list!"
        }
    ],
    "stats": {
        "total": 12112,
        "additions": 12063,
        "deletions": 49
    }
}