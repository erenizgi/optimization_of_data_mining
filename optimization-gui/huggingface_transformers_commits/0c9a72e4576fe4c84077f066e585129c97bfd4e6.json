{
    "author": "paulpak58",
    "message": "[Model] Lfm2Moe (#41401)\n\n* [new-models] LFM2-MoE\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [docs] add in template lfm2_moe doc files\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [configuration] update configuration class\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [modular][lfm] minor: fix rotary_emb typo\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [modeling] modular/modeling files for Lfm2Moe\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [modeling][lfm2_moe] fix Lfm2Moe modular/modeling\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [configuration][lfm2_moe] update configuration keys with latest config changes\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [misc] make fixup\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [modular][lfm2_moe] address comments: dtype, mlp, buffers\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [configuration][lfm2_moe] add initializer_range\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [modular][lfm2_moe] include init_weights to pass test_initialization\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [tests][causal_lm] include pos_emb as possible rope attribute\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [modeling][lfm2_moe] remove load_balancing_loss_func due to lack of support for hooking expert biases\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [misc] make style\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [modeling][lfm2_moe] MoE refactor PR update in LFM2Moe\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [tests] lfm2_moe: unit tests\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [misc] update LFM2-8B-A1B repo id\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [tests] lfm2: update ModelTests for lfm2\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* Update LFM2 documentation\n\nUpdated the LFM2 documentation to reflect the addition of a new model size and clarified architectural details.\n\n* Add Lfm2Moe documentation\n\nAdd Lfm2Moe model documentation with overview and example usage.\n\n* [misc] fix ci\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [docs] remove trust_remote_code\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* [misc] ci: fix modular\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\n\n* reapply modular\n\n* simplify\n\n* remove static address and inplace op\n\n* simplify\n\n* simplify a bit more the modular\n\n* imports\n\n---------\n\nSigned-off-by: Paul Pak <paulpak58@gmail.com>\nCo-authored-by: Maxime Labonne <81252890+mlabonne@users.noreply.github.com>\nCo-authored-by: Cyril Vallez <cyril.vallez@huggingface.co>\nCo-authored-by: Cyril Vallez <cyril.vallez@gmail.com>",
    "sha": "0c9a72e4576fe4c84077f066e585129c97bfd4e6",
    "files": [
        {
            "sha": "86d19cb09b1535e9f3edc29f3b131a1d1005a7e9",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -562,6 +562,8 @@\n         title: LED\n       - local: model_doc/lfm2\n         title: LFM2\n+      - local: model_doc/lfm2_moe\n+        title: LFM2Moe\n       - local: model_doc/llama\n         title: LLaMA\n       - local: model_doc/llama2"
        },
        {
            "sha": "131733ed6ec01850dcc2e87fe70ca439a5619e6f",
            "filename": "docs/source/en/model_doc/lfm2.md",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/docs%2Fsource%2Fen%2Fmodel_doc%2Flfm2.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/docs%2Fsource%2Fen%2Fmodel_doc%2Flfm2.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Flfm2.md?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -23,15 +23,15 @@ rendered properly in your Markdown viewer.\n \n ## Overview\n \n-[LFM2](https://www.liquid.ai/blog/liquid-foundation-models-v2-our-second-series-of-generative-ai-models) represents a new generation of Liquid Foundation Models developed by [Liquid AI](https://liquid.ai/), specifically designed for edge AI and on-device deployment.\n+[LFM2](https://www.liquid.ai/blog/liquid-foundation-models-v2-our-second-series-of-generative-ai-models) represents a new generation of Liquid Foundation Models developed by Liquid AI, specifically designed for edge AI and on-device deployment.\n \n-The models are available in three sizes (350M, 700M, and 1.2B parameters) and are engineered to run efficiently on CPU, GPU, and NPU hardware, making them particularly well-suited for applications requiring low latency, offline operation, and privacy.\n+The models are available in four sizes (350M, 700M, 1.2B, and 2.6B parameters) and are engineered to run efficiently on CPU, GPU, and NPU hardware, making them particularly well-suited for applications requiring low latency, offline operation, and privacy.\n \n ## Architecture\n \n-The architecture consists of 16 blocks total: 10 double-gated short-range convolution blocks and 6 blocks of grouped query attention. This design stems from the concept of dynamical systems, where linear operations are modulated by input-dependent gates, allowing for \"liquid\" dynamics that can adapt in real-time. The short convolutions are particularly optimized for embedded SoC CPUs, making them ideal for devices that require fast, local inference without relying on cloud connectivity.\n+The architecture consists of blocks of gated short convolution blocks and blocks of grouped query attention with QK layernorm. This design stems from the concept of dynamical systems, where linear operations are modulated by input-dependent gates. The short convolutions are particularly optimized for embedded SoC CPUs, making them ideal for devices that require fast, local inference without relying on cloud connectivity.\n \n-The key architectural innovation of LFM2 lies in its systematic approach to balancing quality, latency, and memory efficiency through our STAR neural architecture search engine. Using STAR, Liquid AI optimized the models for real-world performance on embedded hardware, measuring actual peak memory usage and inference speed on Qualcomm Snapdragon processors. This results in models that achieve 2x faster decode and prefill performance compared to similar-sized models, while maintaining superior benchmark performance across knowledge, mathematics, instruction following, and multilingual tasks.\n+LFM2 was designed to maximize quality under strict speed and memory constraints. This was accomplished through a systematic architecture search to optimize the models for real-world performance on embedded hardware by measuring actual peak memory usage and inference speed on Qualcomm Snapdragon processors. This results in models that achieve 2x faster decode and prefill performance compared to similar-sized models, while maintaining superior benchmark performance across knowledge, mathematics, instruction following, and multilingual tasks.\n \n ## Example\n "
        },
        {
            "sha": "bdaaebaa604486f1ef7a49460d0c2aad30a80aa1",
            "filename": "docs/source/en/model_doc/lfm2_moe.md",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/docs%2Fsource%2Fen%2Fmodel_doc%2Flfm2_moe.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/docs%2Fsource%2Fen%2Fmodel_doc%2Flfm2_moe.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Flfm2_moe.md?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -0,0 +1,83 @@\n+<!--Copyright 2025 the HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be rendered properly in your Markdown viewer.\n+\n+-->\n+\n+\n+# Lfm2Moe\n+\n+## Overview\n+\n+LFM2-MoE is a Mixture-of-Experts (MoE) variant of [LFM2](https://huggingface.co/collections/LiquidAI/lfm2-686d721927015b2ad73eaa38). The LFM2 family is optimized for on-device inference by combining shortâ€‘range, inputâ€‘aware gated convolutions with groupedâ€‘query attention (GQA) in a layout tuned to maximize quality under strict speed and memory constraints.\n+\n+LFM2â€‘MoE keeps this fast backbone and introduces sparse MoE feedâ€‘forward networks to add representational capacity without significantly increasing the active compute path. The first LFM2-MoE release is LFM2-8B-A1B, with 8.3B total parameters and 1.5B active parameters. The model excels in quality (comparable to 3-4B dense models) and speed (faster than other 1.5B class models). \n+\n+## Example\n+\n+The following example shows how to generate an answer using the `AutoModelForCausalLM` class.\n+\n+```python\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+# Load model and tokenizer\n+model_id = \"LiquidAI/LFM2-8B-A1B\"\n+model = AutoModelForCausalLM.from_pretrained(\n+    model_id,\n+    device_map=\"auto\",\n+    dtype=\"bfloat16\",\n+#    attn_implementation=\"flash_attention_2\" <- uncomment on compatible GPU\n+)\n+tokenizer = AutoTokenizer.from_pretrained(model_id)\n+\n+# Generate answer\n+prompt = \"What is C. elegans?\"\n+input_ids = tokenizer.apply_chat_template(\n+    [{\"role\": \"user\", \"content\": prompt}],\n+    add_generation_prompt=True,\n+    return_tensors=\"pt\",\n+    tokenize=True,\n+).to(model.device)\n+\n+output = model.generate(\n+    input_ids,\n+    do_sample=True,\n+    temperature=0.3,\n+    min_p=0.15,\n+    repetition_penalty=1.05,\n+    max_new_tokens=512,\n+)\n+\n+print(tokenizer.decode(output[0], skip_special_tokens=False))\n+```\n+\n+## Lfm2MoeConfig\n+\n+[[autodoc]] Lfm2MoeConfig\n+\n+## Lfm2MoeForCausalLM\n+\n+[[autodoc]] Lfm2MoeForCausalLM\n+\n+## Lfm2MoeModel\n+\n+[[autodoc]] Lfm2MoeModel\n+    - forward\n+\n+## Lfm2MoePreTrainedModel\n+\n+[[autodoc]] Lfm2MoePreTrainedModel\n+    - forward"
        },
        {
            "sha": "9d0c4445475ce233e0f52d0707bee466f092f588",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -186,6 +186,7 @@\n     from .led import *\n     from .levit import *\n     from .lfm2 import *\n+    from .lfm2_moe import *\n     from .lfm2_vl import *\n     from .lightglue import *\n     from .lilt import *"
        },
        {
            "sha": "1cb5f37dad6b8e0f9c1023f5817fe54d8da868b8",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -226,6 +226,7 @@\n         (\"led\", \"LEDConfig\"),\n         (\"levit\", \"LevitConfig\"),\n         (\"lfm2\", \"Lfm2Config\"),\n+        (\"lfm2_moe\", \"Lfm2MoeConfig\"),\n         (\"lfm2_vl\", \"Lfm2VlConfig\"),\n         (\"lightglue\", \"LightGlueConfig\"),\n         (\"lilt\", \"LiltConfig\"),\n@@ -670,6 +671,7 @@\n         (\"led\", \"LED\"),\n         (\"levit\", \"LeViT\"),\n         (\"lfm2\", \"Lfm2\"),\n+        (\"lfm2_moe\", \"Lfm2Moe\"),\n         (\"lfm2_vl\", \"Lfm2Vl\"),\n         (\"lightglue\", \"LightGlue\"),\n         (\"lilt\", \"LiLT\"),"
        },
        {
            "sha": "4248fdabdad7b866329f8bb4801c68eba673594c",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -226,6 +226,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"led\", \"LEDModel\"),\n         (\"levit\", \"LevitModel\"),\n         (\"lfm2\", \"Lfm2Model\"),\n+        (\"lfm2_moe\", \"Lfm2MoeModel\"),\n         (\"lfm2_vl\", \"Lfm2VlModel\"),\n         (\"lightglue\", \"LightGlueForKeypointMatching\"),\n         (\"lilt\", \"LiltModel\"),\n@@ -694,6 +695,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"jamba\", \"JambaForCausalLM\"),\n         (\"jetmoe\", \"JetMoeForCausalLM\"),\n         (\"lfm2\", \"Lfm2ForCausalLM\"),\n+        (\"lfm2_moe\", \"Lfm2MoeForCausalLM\"),\n         (\"llama\", \"LlamaForCausalLM\"),\n         (\"llama4\", \"Llama4ForCausalLM\"),\n         (\"llama4_text\", \"Llama4ForCausalLM\"),"
        },
        {
            "sha": "752621d6c0ccf419cb63ddaffc95cfb78d0cbb96",
            "filename": "src/transformers/models/lfm2/modeling_lfm2.py",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Flfm2%2Fmodeling_lfm2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Flfm2%2Fmodeling_lfm2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Flfm2%2Fmodeling_lfm2.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -163,7 +163,6 @@ def __init__(\n                 dtype=self._dtype,\n                 device=device,\n             )\n-            torch._dynamo.mark_static_address(conv_state)\n             self.conv_cache.append(conv_state)\n             self.key_cache.append(torch.tensor([]))\n             self.value_cache.append(torch.tensor([]))\n@@ -595,7 +594,6 @@ def __init__(self, config: Lfm2Config):\n         self.layers = nn.ModuleList(\n             [Lfm2DecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n         )\n-        self.rotary_emb = Lfm2RotaryEmbedding(config=config)\n         self.gradient_checkpointing = False\n         self.pos_emb = Lfm2RotaryEmbedding(config)\n         self.embedding_norm = Lfm2RMSNorm(config.hidden_size, eps=config.norm_eps)"
        },
        {
            "sha": "355d3baff3ab3a7b57aafe59dbab4eb710b2932d",
            "filename": "src/transformers/models/lfm2/modular_lfm2.py",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Flfm2%2Fmodular_lfm2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Flfm2%2Fmodular_lfm2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Flfm2%2Fmodular_lfm2.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -121,7 +121,6 @@ def __init__(\n                 dtype=self._dtype,\n                 device=device,\n             )\n-            torch._dynamo.mark_static_address(conv_state)\n             self.conv_cache.append(conv_state)\n             self.key_cache.append(torch.tensor([]))\n             self.value_cache.append(torch.tensor([]))\n@@ -441,7 +440,7 @@ def __init__(self, config: Lfm2Config):\n         self.pos_emb = Lfm2RotaryEmbedding(config)\n         self.embedding_norm = Lfm2RMSNorm(config.hidden_size, eps=config.norm_eps)\n         del self.norm\n-        del self.rotary_emv\n+        del self.rotary_emb\n \n     def forward(\n         self,"
        },
        {
            "sha": "3ebaf8f93e82d432fee6166fdf56c6bb99c61c51",
            "filename": "src/transformers/models/lfm2_moe/__init__.py",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Flfm2_moe%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Flfm2_moe%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Flfm2_moe%2F__init__.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -0,0 +1,29 @@\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_lfm2_moe import *\n+    from .modeling_lfm2_moe import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "550954ecfd20d43cac4a2ddd608b8a60f8437376",
            "filename": "src/transformers/models/lfm2_moe/configuration_lfm2_moe.py",
            "status": "added",
            "additions": 169,
            "deletions": 0,
            "changes": 169,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Flfm2_moe%2Fconfiguration_lfm2_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Flfm2_moe%2Fconfiguration_lfm2_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Flfm2_moe%2Fconfiguration_lfm2_moe.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -0,0 +1,169 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import Optional\n+\n+from ...configuration_utils import PretrainedConfig\n+\n+\n+class Lfm2MoeConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Lfm2MoeModel`]. It is used to instantiate a LFM2 Moe\n+    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n+    defaults will yield a similar configuration to that of the LFM2-8B-A1B model.\n+    e.g. [LiquidAI/LFM2-8B-A1B](https://huggingface.co/LiquidAI/LFM2-8B-A1B)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 65536):\n+            Vocabulary size of the LLaMA model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Lfm2Model`]\n+        hidden_size (`int`, *optional*, defaults to 2048):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 7168):\n+            Dimension of the MLP representations.\n+        moe_intermediate_size (`int`, *optional*, defaults to 1792):\n+            Intermediate size of the routed expert.\n+        num_hidden_layers (`int`, *optional*, defaults to 32):\n+            Number of hidden layers in the Transformer decoder.\n+        pad_token_id (`int`, *optional*, defaults to 0):\n+            Padding token id.\n+        bos_token_id (`int`, *optional*, defaults to 1):\n+            Beginning of stream token id.\n+        eos_token_id (`int`, *optional*, defaults to 2):\n+            End of stream token id.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `True`):\n+            Whether to tie weight embeddings\n+        rope_theta (`float`, *optional*, defaults to 1000000.0):\n+            The base period of the RoPE embeddings.\n+        max_position_embeddings (`int`, *optional*, defaults to 128000):\n+            The maximum sequence length that this model might ever be used with.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        num_attention_heads (`int`, *optional*, defaults to 32):\n+            Number of attention heads for each attention layer in the Transformer decoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 8):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details, check out [this\n+            paper](https://huggingface.co/papers/2305.13245). If it is not specified, will default to\n+            `num_attention_heads`.\n+        conv_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use bias in the conv layers.\n+        conv_L_cache (`int`, *optional*, defaults to 3):\n+            L_cache dim in the conv layers.\n+        num_dense_layers (`int`, *optional*, defaults to 2):\n+            Number of dense Lfm2MoeMLP layers in shallow layers(embed->dense->dense->...->dense->moe->moe...->lm_head).\n+        num_experts_per_tok (`int`, *optional*, defaults to 4):\n+            Number of selected experts.\n+        num_experts (`int`, *optional*, defaults to 32):\n+            Number of routed experts.\n+        use_expert_bias (`bool`, *optional*, defaults to `True`):\n+            Whether to use the expert bias on the routing weights.\n+        routed_scaling_factor (`float`, *optional*, defaults to 1.0):\n+            Scaling factor for routed experts in MoE models.\n+        norm_topk_prob (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the topk probabilities.\n+        layer_types (`Optional`, *optional*):\n+            Type of each layers.\n+\n+    ```python\n+    >>> from transformers import Lfm2MoeModel, Lfm2MoeConfig\n+\n+    >>> # Initializing a LFM2 Moe model\n+    >>> configuration = Lfm2MoeConfig()\n+\n+    >>> # Initializing a model from the LFM2-8B-A1B style configuration\n+    >>> model = Lfm2MoeModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"lfm2_moe\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        vocab_size: int = 65536,\n+        hidden_size: int = 2048,\n+        intermediate_size: int = 7168,\n+        moe_intermediate_size: int = 1792,\n+        num_hidden_layers: int = 32,\n+        pad_token_id: int = 0,\n+        bos_token_id: int = 1,\n+        eos_token_id: int = 2,\n+        tie_word_embeddings: bool = True,\n+        rope_theta: float = 1000000.0,\n+        max_position_embeddings: int = 128_000,\n+        use_cache: bool = True,\n+        norm_eps: float = 0.00001,\n+        num_attention_heads: int = 32,\n+        num_key_value_heads: int = 8,\n+        conv_bias: bool = False,\n+        conv_L_cache: int = 3,\n+        num_dense_layers: int = 2,\n+        num_experts_per_tok: int = 4,\n+        num_experts: int = 32,\n+        use_expert_bias: bool = True,\n+        routed_scaling_factor: float = 1.0,\n+        norm_topk_prob: bool = True,\n+        layer_types: Optional[list[str]] = None,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.rope_theta = rope_theta\n+        self.max_position_embeddings = max_position_embeddings\n+        self.use_cache = use_cache\n+        self.norm_eps = norm_eps\n+\n+        # attn operator config\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads\n+\n+        # custom operator config\n+        self.conv_bias = conv_bias\n+        self.conv_L_cache = conv_L_cache\n+\n+        # moe config\n+        self.num_dense_layers = num_dense_layers\n+        self.moe_intermediate_size = moe_intermediate_size\n+        self.num_experts_per_tok = num_experts_per_tok\n+        self.num_experts = num_experts\n+        self.use_expert_bias = use_expert_bias\n+        self.routed_scaling_factor = routed_scaling_factor\n+        self.norm_topk_prob = norm_topk_prob\n+        self.layer_types = layer_types\n+\n+        tie_word_embeddings = kwargs.get(\"tie_embedding\", tie_word_embeddings)  # to fit original config keys\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+\n+\n+__all__ = [\"Lfm2MoeConfig\"]"
        },
        {
            "sha": "6f879ec9c5e91da2d74ed99a6b3ad6a3a13b0dac",
            "filename": "src/transformers/models/lfm2_moe/modeling_lfm2_moe.py",
            "status": "added",
            "additions": 813,
            "deletions": 0,
            "changes": 813,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Flfm2_moe%2Fmodeling_lfm2_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Flfm2_moe%2Fmodeling_lfm2_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Flfm2_moe%2Fmodeling_lfm2_moe.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -0,0 +1,813 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/lfm2_moe/modular_lfm2_moe.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_lfm2_moe.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import Any, Callable, Optional, Union\n+\n+import torch\n+import torch.nn.functional as F\n+from torch import nn\n+\n+from ...cache_utils import Cache\n+from ...generation import GenerationMixin\n+from ...integrations import use_kernel_forward_from_hub\n+from ...masking_utils import create_causal_mask\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import BaseModelOutputWithPast, CausalLMOutputWithPast, MoeModelOutputWithPast\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS, dynamic_rope_update\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring, can_return_tuple\n+from ...utils.deprecation import deprecate_kwarg\n+from ...utils.generic import check_model_inputs\n+from ...utils.import_utils import is_causal_conv1d_available\n+from .configuration_lfm2_moe import Lfm2MoeConfig\n+\n+\n+if is_causal_conv1d_available():\n+    from causal_conv1d import causal_conv1d_fn, causal_conv1d_update\n+else:\n+    causal_conv1d_fn, causal_conv1d_update = None, None\n+\n+\n+@use_kernel_forward_from_hub(\"RMSNorm\")\n+class Lfm2MoeRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        Lfm2MoeRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class Lfm2MoeRotaryEmbedding(nn.Module):\n+    inv_freq: torch.Tensor  # fix linting for `register_buffer`\n+\n+    def __init__(self, config: Lfm2MoeConfig, device=None):\n+        super().__init__()\n+        # BC: \"rope_type\" was originally \"type\"\n+        if hasattr(config, \"rope_scaling\") and isinstance(config.rope_scaling, dict):\n+            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n+        else:\n+            self.rope_type = \"default\"\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = self.inv_freq\n+\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1).to(x.device)\n+        position_ids_expanded = position_ids[:, None, :].float()\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(1, 2)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos() * self.attention_scaling\n+            sin = emb.sin() * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+class Lfm2MoeMLP(nn.Module):\n+    def __init__(self, config: Lfm2MoeConfig, intermediate_size: Optional[int] = None):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size if intermediate_size is None else intermediate_size\n+        self.w1 = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.w3 = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.w2 = nn.Linear(self.intermediate_size, self.hidden_size, bias=False)\n+\n+    def forward(self, x):\n+        return self.w2(F.silu(self.w1(x)) * self.w3(x))\n+\n+\n+class Lfm2MoeExperts(nn.ModuleList):\n+    \"\"\"\n+    ModuleList of experts.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+        self.num_experts = config.num_experts\n+        for _ in range(config.num_experts):\n+            self.append(Lfm2MoeMLP(config, intermediate_size=config.moe_intermediate_size))\n+\n+    def forward(\n+        self, hidden_states: torch.Tensor, top_k_index: torch.Tensor, top_k_weights: torch.Tensor\n+    ) -> torch.Tensor:\n+        \"\"\"\n+        Args:\n+            hidden_states: (batch_size * sequence_length, hidden_dim)\n+            selected_experts: (batch_size * sequence_length, top_k)\n+            routing_weights: (batch_size * sequence_length, top_k)\n+        Returns:\n+            (batch_size * sequence_length, hidden_dim)\n+        \"\"\"\n+        final_hidden_states = torch.zeros_like(hidden_states)\n+        expert_mask = torch.nn.functional.one_hot(top_k_index, num_classes=self.num_experts).permute(2, 1, 0)\n+\n+        expert_hit = torch.greater(expert_mask.sum(dim=(-1, -2)), 0).nonzero()\n+        for expert_idx in expert_hit:\n+            idx, top_x = torch.where(expert_mask[expert_idx].squeeze(0))\n+            current_state = hidden_states[None, top_x].reshape(-1, hidden_states.shape[-1])\n+            current_hidden_states = self[expert_idx](current_state) * top_k_weights[top_x, idx, None]\n+            final_hidden_states.index_add_(0, top_x, current_hidden_states.to(hidden_states.dtype))\n+        return final_hidden_states\n+\n+\n+class Lfm2MoeSparseMoeBlock(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.top_k = config.num_experts_per_tok\n+        self.routed_scaling_factor = config.routed_scaling_factor\n+        self.norm_topk_prob = config.norm_topk_prob\n+        self.use_expert_bias = config.use_expert_bias\n+\n+        self.gate = nn.Linear(config.hidden_size, config.num_experts, bias=False)\n+        self.experts = Lfm2MoeExperts(config)\n+        if self.use_expert_bias:\n+            self.register_buffer(\"expert_bias\", torch.zeros(config.num_experts, dtype=torch.float32))\n+\n+    def route_tokens_to_experts(self, router_logits):\n+        routing_weights = router_logits.sigmoid()\n+        if self.use_expert_bias:\n+            scores_for_routing = routing_weights + self.expert_bias\n+            _, selected_experts = torch.topk(scores_for_routing, k=self.top_k, dim=-1)\n+            routing_weights = torch.gather(routing_weights, dim=1, index=selected_experts).type_as(router_logits)\n+        else:\n+            routing_weights, selected_experts = torch.topk(routing_weights, k=self.top_k, dim=-1)\n+\n+        if self.norm_topk_prob:\n+            routing_weights = routing_weights / (routing_weights.sum(dim=-1, keepdim=True) + 1e-6)\n+        routing_weights = routing_weights * self.routed_scaling_factor\n+        return selected_experts, routing_weights\n+\n+    def forward(self, hidden_states: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n+        batch_size, sequence_length, hidden_dim = hidden_states.shape\n+        hidden_states_reshaped = hidden_states.view(-1, hidden_dim)\n+        router_logits = self.gate(hidden_states_reshaped)\n+        selected_experts, routing_weights = self.route_tokens_to_experts(router_logits)\n+        final_hidden_states = self.experts(hidden_states_reshaped, selected_experts, routing_weights)\n+        return final_hidden_states.reshape(batch_size, sequence_length, hidden_dim)\n+\n+\n+class Lfm2MoeHybridConvCache:\n+    \"\"\"\n+    Attention and conv cache for Lfm2Moe.\n+\n+    It stores the Key and Value states as a list of tensors, one for each layer.\n+    Attention layer cache shape: `[batch_size, num_heads, seq_len, head_dim]`.\n+    Conv layer cache shape: `[batch_size, hidden_size, L_cache-1]`.\n+    \"\"\"\n+\n+    # Override @property existing in Cache\n+    max_batch_size = None\n+    is_compileable = False\n+    key_cache = None\n+    value_cache = None\n+\n+    def __init__(\n+        self,\n+        config: Lfm2MoeConfig,\n+        max_batch_size: int,\n+        dtype: torch.dtype = torch.float32,\n+        device: Union[torch.device, str, None] = None,\n+    ):\n+        self.key_cache = []\n+        self.value_cache = []\n+        self.max_batch_size = max_batch_size\n+        self.layer_types = config.layer_types\n+        self.first_attention_layer = self.layer_types.index(\"full_attention\")\n+        self.conv_L_cache = config.conv_L_cache\n+        self._dtype = dtype\n+\n+        self.conv_cache: list[torch.Tensor] = []\n+        device = torch.device(device) if device is not None else None\n+\n+        for _ in range(config.num_hidden_layers):\n+            conv_state = torch.zeros(\n+                self.max_batch_size,\n+                config.hidden_size,\n+                self.conv_L_cache,\n+                dtype=self._dtype,\n+                device=device,\n+            )\n+            self.conv_cache.append(conv_state)\n+            self.key_cache.append(torch.tensor([]))\n+            self.value_cache.append(torch.tensor([]))\n+\n+    def update(\n+        self,\n+        key_states: torch.Tensor,\n+        value_states: torch.Tensor,\n+        layer_idx: int,\n+        cache_kwargs: Optional[dict[str, Any]] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Updates the cache with the new `key_states` and `value_states` for the layer `layer_idx`.\n+\n+        Parameters:\n+            key_states (`torch.Tensor`):\n+                The new key states to cache.\n+            value_states (`torch.Tensor`):\n+                The new value states to cache.\n+            layer_idx (`int`):\n+                The index of the layer to cache the states for.\n+            cache_kwargs (`Dict[str, Any]`, `optional`):\n+                Additional arguments for the cache subclass. No additional arguments are used in `DynamicCache`.\n+\n+        Return:\n+            A tuple containing the updated key and value states.\n+        \"\"\"\n+        # Update the cache\n+        if self.key_cache[layer_idx].numel() == 0:\n+            self.key_cache[layer_idx] = key_states\n+            self.value_cache[layer_idx] = value_states\n+        else:\n+            self.key_cache[layer_idx] = torch.cat([self.key_cache[layer_idx], key_states], dim=-2)\n+            self.value_cache[layer_idx] = torch.cat([self.value_cache[layer_idx], value_states], dim=-2)\n+\n+        return self.key_cache[layer_idx], self.value_cache[layer_idx]\n+\n+    def reorder_cache(self, beam_idx: torch.LongTensor):\n+        \"\"\"Reorders the cache for beam search, given the selected beam indices.\"\"\"\n+        for layer_idx in range(len(self.key_cache)):\n+            if self.key_cache[layer_idx].numel():\n+                device = self.key_cache[layer_idx].device\n+                self.key_cache[layer_idx] = self.key_cache[layer_idx].index_select(0, beam_idx.to(device))\n+                device = self.value_cache[layer_idx].device\n+                self.value_cache[layer_idx] = self.value_cache[layer_idx].index_select(0, beam_idx.to(device))\n+\n+            if self.conv_cache[layer_idx].numel():\n+                device = self.conv_cache[layer_idx].device\n+                self.conv_cache[layer_idx] = self.conv_cache[layer_idx].index_select(0, beam_idx.to(device))\n+\n+    def get_seq_length(self, layer_idx: Optional[int] = 0) -> int:\n+        \"\"\"Returns the sequence length of the cached states. A layer index can be optionally passed.\"\"\"\n+        # take any layer that contains cache and not empty tensor\n+        layer_idx = self.first_attention_layer if self.layer_types[layer_idx] != \"full_attention\" else layer_idx\n+        if len(self.key_cache) <= layer_idx or self.key_cache[layer_idx].numel() == 0:\n+            return 0\n+        return self.key_cache[layer_idx].shape[-2]\n+\n+    def get_mask_sizes(self, cache_position: torch.Tensor, layer_idx: int) -> tuple[int, int]:\n+        \"\"\"\n+        Return a tuple (kv_length, kv_offset) corresponding to the length and offset that will be returned for\n+        the given layer at `layer_idx`.\n+        The masks are then prepared according to the given lengths (kv_length, kv_offset) and patterns (i.e. sliding_window, chunk_size),\n+        for each layer.\n+        \"\"\"\n+        full_mask_kv_offset = 0\n+        query_length = cache_position.shape[0]\n+        past_seen_tokens = self.get_seq_length()\n+        kv_length = query_length + past_seen_tokens\n+        return kv_length, full_mask_kv_offset\n+\n+    def crop(self, max_length: int):\n+        \"\"\"Crop the cache to the given length\"\"\"\n+        if max_length < 0:\n+            max_length = self.get_seq_length() - abs(max_length)\n+\n+        if self.get_seq_length() <= max_length:\n+            return\n+\n+        for idx in range(len(self.key_cache)):\n+            if self.key_cache[idx].numel():\n+                self.key_cache[idx] = self.key_cache[idx][..., :max_length, :]\n+                self.value_cache[idx] = self.value_cache[idx][..., :max_length, :]\n+\n+    def __len__(self) -> int:\n+        return len(self.key_cache)\n+\n+    def __getitem__(self, layer_idx: int) -> tuple[torch.Tensor, torch.Tensor]:\n+        return self.key_cache[layer_idx], self.value_cache[layer_idx]\n+\n+    def reset(self):\n+        for layer_idx in range(len(self.conv_cache)):\n+            # In-place ops prevent breaking the static address\n+            self.conv_cache[layer_idx].zero_()\n+\n+\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`, *optional*):\n+            Deprecated and unused.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    return q_embed, k_embed\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs: Unpack[TransformersKwargs],\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+class Lfm2MoeAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: Lfm2MoeConfig, layer_idx: int):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.head_dim = getattr(config, \"head_dim\", config.hidden_size // config.num_attention_heads)\n+        self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.is_causal = True\n+        self.q_proj = nn.Linear(config.hidden_size, config.num_attention_heads * self.head_dim, bias=False)\n+        self.k_proj = nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=False)\n+        self.v_proj = nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=False)\n+        self.out_proj = nn.Linear(config.num_attention_heads * self.head_dim, config.hidden_size, bias=False)\n+        self.q_layernorm = Lfm2MoeRMSNorm(self.head_dim, eps=config.norm_eps)\n+        self.k_layernorm = Lfm2MoeRMSNorm(self.head_dim, eps=config.norm_eps)\n+\n+    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_values: Optional[Lfm2MoeHybridConvCache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_layernorm(self.q_proj(hidden_states).view(*hidden_shape)).transpose(1, 2)\n+        key_states = self.k_layernorm(self.k_proj(hidden_states).view(*hidden_shape)).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(*hidden_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_values is not None:\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_values.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        output = self.out_proj(attn_output)\n+        return output, attn_weights\n+\n+\n+def apply_mask_to_padding_states(hidden_states, attention_mask):\n+    \"\"\"\n+    Tunes out the hidden states for padding tokens, see https://github.com/state-spaces/mamba/issues/66\n+    \"\"\"\n+    if attention_mask is not None and attention_mask.shape[1] > 1 and attention_mask.shape[0] > 1:\n+        dtype = hidden_states.dtype\n+        hidden_states = (hidden_states * attention_mask[:, :, None]).to(dtype)\n+\n+    return hidden_states\n+\n+\n+kernel_modules = (causal_conv1d_fn, causal_conv1d_update)\n+is_fast_path_available = all(kernel_modules)\n+\n+\n+class Lfm2MoeShortConv(nn.Module):\n+    def __init__(\n+        self,\n+        config: Lfm2MoeConfig,\n+        layer_idx: int,\n+    ):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.L_cache = config.conv_L_cache\n+        self.bias = config.conv_bias\n+\n+        self.conv = nn.Conv1d(\n+            in_channels=config.hidden_size,\n+            out_channels=config.hidden_size,\n+            kernel_size=self.L_cache,\n+            groups=config.hidden_size,\n+            bias=self.bias,\n+            padding=self.L_cache - 1,\n+        )\n+        self.in_proj = nn.Linear(config.hidden_size, 3 * config.hidden_size, bias=self.bias)\n+        self.out_proj = nn.Linear(config.hidden_size, config.hidden_size, bias=self.bias)\n+\n+    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n+    def cuda_kernels_forward(\n+        self,\n+        x: torch.Tensor,\n+        past_key_values: Optional[Lfm2MoeHybridConvCache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+    ):\n+        x = apply_mask_to_padding_states(x, attention_mask)\n+        BCx = self.in_proj(x).transpose(-1, -2)\n+        B, C, x = BCx.chunk(3, dim=-2)\n+\n+        Bx = B * x\n+\n+        conv_weights = self.conv.weight.view(self.conv.weight.size(0), self.conv.weight.size(2))\n+        if past_key_values is not None and cache_position[0] > 0:\n+            conv_out = causal_conv1d_update(\n+                Bx.squeeze(-1),\n+                past_key_values.conv_cache[self.layer_idx],\n+                conv_weights,\n+                self.conv.bias,\n+                None,\n+            )\n+            conv_out = conv_out.unsqueeze(-1)\n+        else:\n+            if past_key_values is not None:\n+                conv_state = nn.functional.pad(Bx, (self.L_cache - Bx.shape[-1], 0))\n+                past_key_values.conv_cache[self.layer_idx].copy_(conv_state)\n+\n+            conv_out = causal_conv1d_fn(Bx, conv_weights, self.conv.bias, activation=None)\n+\n+        y = C * conv_out\n+        y = self.out_proj(y.transpose(-1, -2).contiguous())\n+        return y\n+\n+    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n+    def slow_forward(\n+        self,\n+        x: torch.Tensor,\n+        past_key_values: Optional[Lfm2MoeHybridConvCache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+    ):\n+        seqlen = x.shape[1]\n+\n+        x = apply_mask_to_padding_states(x, attention_mask)\n+        BCx = self.in_proj(x).transpose(-1, -2)\n+        B, C, x = BCx.chunk(3, dim=-2)\n+\n+        Bx = B * x\n+\n+        if past_key_values is not None and cache_position[0] > 0:\n+            conv_state = past_key_values.conv_cache[self.layer_idx]\n+            cache_position = cache_position.clamp(0, self.L_cache - 1)\n+            conv_state = conv_state.roll(shifts=-1, dims=-1)\n+            conv_state[:, :, cache_position] = Bx.to(device=conv_state.device, dtype=conv_state.dtype)\n+            past_key_values.conv_cache[self.layer_idx].copy_(conv_state)\n+            conv_out = torch.sum(conv_state.to(Bx.device) * self.conv.weight[:, 0, :], dim=-1)\n+            if self.bias:\n+                conv_out += self.conv.bias\n+\n+            conv_out = conv_out.unsqueeze(-1)\n+        else:\n+            if past_key_values is not None:\n+                conv_state = nn.functional.pad(Bx, (self.L_cache - Bx.shape[-1], 0))\n+                past_key_values.conv_cache[self.layer_idx].copy_(conv_state)\n+\n+            conv_out = self.conv(Bx)[..., :seqlen]\n+\n+        y = C * conv_out\n+        y = y.transpose(-1, -2).contiguous()\n+        y = self.out_proj(y)\n+        return y\n+\n+    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        past_key_values: Optional[Lfm2MoeHybridConvCache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+    ):\n+        if is_fast_path_available and \"cuda\" in hidden_states.device.type and not torch._dynamo.is_compiling():\n+            return self.cuda_kernels_forward(hidden_states, past_key_values, cache_position, attention_mask)\n+        return self.slow_forward(hidden_states, past_key_values, cache_position, attention_mask)\n+\n+\n+class Lfm2MoeDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: Lfm2MoeConfig, layer_idx: int):\n+        super().__init__()\n+        self.is_attention_layer = config.layer_types[layer_idx] == \"full_attention\"\n+\n+        if self.is_attention_layer:\n+            self.self_attn = Lfm2MoeAttention(config, layer_idx)\n+        else:\n+            self.conv = Lfm2MoeShortConv(config, layer_idx)\n+        self.feed_forward = (\n+            Lfm2MoeMLP(config, intermediate_size=config.intermediate_size)\n+            if layer_idx < config.num_dense_layers\n+            else Lfm2MoeSparseMoeBlock(config)\n+        )\n+        self.operator_norm = Lfm2MoeRMSNorm(config.hidden_size, eps=config.norm_eps)\n+        self.ffn_norm = Lfm2MoeRMSNorm(config.hidden_size, eps=config.norm_eps)\n+\n+    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Lfm2MoeHybridConvCache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs,\n+    ) -> torch.Tensor:\n+        residual = hidden_states\n+        if self.is_attention_layer:\n+            hidden_states, _ = self.self_attn(\n+                hidden_states=self.operator_norm(hidden_states),\n+                position_embeddings=position_embeddings,\n+                attention_mask=attention_mask,\n+                position_ids=position_ids,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+        else:\n+            hidden_states = self.conv(\n+                hidden_states=self.operator_norm(hidden_states),\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                attention_mask=attention_mask,\n+            )\n+        hidden_states = hidden_states + residual\n+        hidden_states = hidden_states + self.feed_forward(self.ffn_norm(hidden_states))\n+\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class Lfm2MoePreTrainedModel(PreTrainedModel):\n+    config: Lfm2MoeConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"Lfm2MoeDecoderLayer\"]\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _supports_flash_attn = True\n+    _supports_sdpa = True\n+    _supports_flex_attn = True\n+    _can_compile_fullgraph = False\n+    _supports_attention_backend = True\n+    _can_record_outputs = {\n+        \"hidden_states\": Lfm2MoeDecoderLayer,\n+        \"attentions\": Lfm2MoeAttention,\n+    }\n+\n+\n+@auto_docstring\n+class Lfm2MoeModel(Lfm2MoePreTrainedModel):\n+    def __init__(self, config: Lfm2MoeConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [Lfm2MoeDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.gradient_checkpointing = False\n+        self.pos_emb = Lfm2MoeRotaryEmbedding(config)\n+        self.embedding_norm = Lfm2MoeRMSNorm(config.hidden_size, eps=config.norm_eps)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @check_model_inputs()\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Lfm2MoeHybridConvCache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> MoeModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if use_cache and past_key_values is None:\n+            batch_size = inputs_embeds.shape[0]\n+            past_key_values = Lfm2MoeHybridConvCache(\n+                config=self.config, max_batch_size=batch_size, dtype=self.dtype, device=self.device\n+            )\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=position_ids,\n+        )\n+\n+        hidden_states = inputs_embeds\n+        position_embeddings = self.pos_emb(hidden_states, position_ids)\n+\n+        # decoder layers\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask,\n+                position_ids=position_ids,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                position_embeddings=position_embeddings,\n+                **kwargs,\n+            )\n+\n+        hidden_states = self.embedding_norm(hidden_states)\n+\n+        return MoeModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+@auto_docstring\n+class Lfm2MoeForCausalLM(Lfm2MoePreTrainedModel, GenerationMixin):\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+    _tp_plan = {\"lm_head\": \"colwise_rep\"}\n+    _pp_plan = {\"lm_head\": ([\"hidden_states\"], [\"logits\"])}\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = Lfm2MoeModel(config)\n+        self.vocab_size = config.vocab_size\n+        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> CausalLMOutputWithPast:\n+        r\"\"\"\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, Lfm2MoeForCausalLM\n+\n+        >>> model = Lfm2MoeForCausalLM.from_pretrained(\"meta-lfm2_moe/Lfm2Moe-2-7b-hf\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"meta-lfm2_moe/Lfm2Moe-2-7b-hf\")\n+\n+        >>> prompt = \"Hey, are you conscious? Can you talk to me?\"\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"Hey, are you conscious? Can you talk to me?\\nI'm not conscious, but I can talk to you.\"\n+        ```\"\"\"\n+        outputs: BaseModelOutputWithPast = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs.last_hidden_state\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits=logits, labels=labels, vocab_size=self.config.vocab_size, **kwargs)\n+\n+        return CausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+\n+__all__ = [\"Lfm2MoeForCausalLM\", \"Lfm2MoeModel\", \"Lfm2MoePreTrainedModel\"]"
        },
        {
            "sha": "9a4f5ff73c84ef09c6b29767831d0685c833393e",
            "filename": "src/transformers/models/lfm2_moe/modular_lfm2_moe.py",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Flfm2_moe%2Fmodular_lfm2_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/src%2Ftransformers%2Fmodels%2Flfm2_moe%2Fmodular_lfm2_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Flfm2_moe%2Fmodular_lfm2_moe.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -0,0 +1,204 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import Optional\n+\n+import torch\n+from torch import nn\n+\n+from ...masking_utils import create_causal_mask\n+from ...modeling_outputs import MoeModelOutputWithPast\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, logging\n+from ...utils.import_utils import is_causal_conv1d_available\n+from ..lfm2.modeling_lfm2 import Lfm2Attention, Lfm2DecoderLayer, Lfm2HybridConvCache, Lfm2MLP, Lfm2ShortConv\n+from ..llama.modeling_llama import LlamaForCausalLM, LlamaPreTrainedModel, LlamaRMSNorm, LlamaRotaryEmbedding\n+from ..mixtral.modeling_mixtral import MixtralModel\n+from ..qwen2_moe.modeling_qwen2_moe import Qwen2MoeExperts\n+from .configuration_lfm2_moe import Lfm2MoeConfig\n+\n+\n+if is_causal_conv1d_available():\n+    from causal_conv1d import causal_conv1d_fn, causal_conv1d_update\n+else:\n+    causal_conv1d_fn, causal_conv1d_update = None, None\n+\n+\n+kernel_modules = (causal_conv1d_fn, causal_conv1d_update)\n+is_fast_path_available = all(kernel_modules)\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Lfm2MoeRMSNorm(LlamaRMSNorm):\n+    pass\n+\n+\n+class Lfm2MoeRotaryEmbedding(LlamaRotaryEmbedding):\n+    pass\n+\n+\n+class Lfm2MoeMLP(Lfm2MLP):\n+    def __init__(self, config: Lfm2MoeConfig, intermediate_size: Optional[int] = None):\n+        nn.Module.__init__(self)\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size if intermediate_size is None else intermediate_size\n+        self.w1 = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.w3 = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.w2 = nn.Linear(self.intermediate_size, self.hidden_size, bias=False)\n+\n+\n+class Lfm2MoeExperts(Qwen2MoeExperts):\n+    pass\n+\n+\n+class Lfm2MoeSparseMoeBlock(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.top_k = config.num_experts_per_tok\n+        self.routed_scaling_factor = config.routed_scaling_factor\n+        self.norm_topk_prob = config.norm_topk_prob\n+        self.use_expert_bias = config.use_expert_bias\n+\n+        self.gate = nn.Linear(config.hidden_size, config.num_experts, bias=False)\n+        self.experts = Lfm2MoeExperts(config)\n+        if self.use_expert_bias:\n+            self.register_buffer(\"expert_bias\", torch.zeros(config.num_experts, dtype=torch.float32))\n+\n+    def route_tokens_to_experts(self, router_logits):\n+        routing_weights = router_logits.sigmoid()\n+        if self.use_expert_bias:\n+            scores_for_routing = routing_weights + self.expert_bias\n+            _, selected_experts = torch.topk(scores_for_routing, k=self.top_k, dim=-1)\n+            routing_weights = torch.gather(routing_weights, dim=1, index=selected_experts).type_as(router_logits)\n+        else:\n+            routing_weights, selected_experts = torch.topk(routing_weights, k=self.top_k, dim=-1)\n+\n+        if self.norm_topk_prob:\n+            routing_weights = routing_weights / (routing_weights.sum(dim=-1, keepdim=True) + 1e-6)\n+        routing_weights = routing_weights * self.routed_scaling_factor\n+        return selected_experts, routing_weights\n+\n+    def forward(self, hidden_states: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n+        batch_size, sequence_length, hidden_dim = hidden_states.shape\n+        hidden_states_reshaped = hidden_states.view(-1, hidden_dim)\n+        router_logits = self.gate(hidden_states_reshaped)\n+        selected_experts, routing_weights = self.route_tokens_to_experts(router_logits)\n+        final_hidden_states = self.experts(hidden_states_reshaped, selected_experts, routing_weights)\n+        return final_hidden_states.reshape(batch_size, sequence_length, hidden_dim)\n+\n+\n+class Lfm2MoeHybridConvCache(Lfm2HybridConvCache):\n+    pass\n+\n+\n+class Lfm2MoeAttention(Lfm2Attention):\n+    pass\n+\n+\n+class Lfm2MoeShortConv(Lfm2ShortConv):\n+    pass\n+\n+\n+class Lfm2MoeDecoderLayer(Lfm2DecoderLayer):\n+    def __init__(self, config: Lfm2MoeConfig, layer_idx: int):\n+        super().__init__(config, layer_idx)\n+        self.feed_forward = (\n+            Lfm2MoeMLP(config, intermediate_size=config.intermediate_size)\n+            if layer_idx < config.num_dense_layers\n+            else Lfm2MoeSparseMoeBlock(config)\n+        )\n+\n+\n+class Lfm2MoePreTrainedModel(LlamaPreTrainedModel):\n+    _can_compile_fullgraph = False\n+\n+\n+class Lfm2MoeModel(MixtralModel):\n+    def __init__(self, config: Lfm2MoeConfig):\n+        super().__init__(config)\n+        self.pos_emb = Lfm2MoeRotaryEmbedding(config)\n+        self.embedding_norm = Lfm2MoeRMSNorm(config.hidden_size, eps=config.norm_eps)\n+        del self.norm\n+        del self.rotary_emb\n+\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Lfm2MoeHybridConvCache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> MoeModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if use_cache and past_key_values is None:\n+            batch_size = inputs_embeds.shape[0]\n+            past_key_values = Lfm2MoeHybridConvCache(\n+                config=self.config, max_batch_size=batch_size, dtype=self.dtype, device=self.device\n+            )\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=position_ids,\n+        )\n+\n+        hidden_states = inputs_embeds\n+        position_embeddings = self.pos_emb(hidden_states, position_ids)\n+\n+        # decoder layers\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask,\n+                position_ids=position_ids,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                position_embeddings=position_embeddings,\n+                **kwargs,\n+            )\n+\n+        hidden_states = self.embedding_norm(hidden_states)\n+\n+        return MoeModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+class Lfm2MoeForCausalLM(LlamaForCausalLM):\n+    pass\n+\n+\n+__all__ = [\"Lfm2MoeForCausalLM\", \"Lfm2MoeModel\", \"Lfm2MoePreTrainedModel\"]"
        },
        {
            "sha": "dbd52c8307c7a19a3a10dbf5318bbc6b3f107d9e",
            "filename": "tests/causal_lm_tester.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/tests%2Fcausal_lm_tester.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/tests%2Fcausal_lm_tester.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fcausal_lm_tester.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -448,6 +448,7 @@ def test_model_rope_scaling_frequencies(self):\n         # named location of the RoPE layer class.\n         base_model = self.model_tester.base_model_class(config)\n         possible_rope_attributes = [\n+            \"pos_emb\",\n             \"rotary_emb\",  # most common case\n             \"global_rotary_emb\",\n             \"local_rotary_emb\","
        },
        {
            "sha": "e3cac3927ee3eb5a9cd59ba3a9b28c896a6e2dc8",
            "filename": "tests/models/lfm2/test_modeling_lfm2.py",
            "status": "modified",
            "additions": 77,
            "deletions": 14,
            "changes": 91,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/tests%2Fmodels%2Flfm2%2Ftest_modeling_lfm2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/tests%2Fmodels%2Flfm2%2Ftest_modeling_lfm2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Flfm2%2Ftest_modeling_lfm2.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -23,12 +23,15 @@\n     require_torch,\n     require_torch_accelerator,\n     slow,\n+    torch_device,\n )\n \n from ...causal_lm_tester import CausalLMModelTest, CausalLMModelTester\n \n \n if is_torch_available():\n+    import torch\n+\n     from transformers import Lfm2ForCausalLM, Lfm2Model\n \n \n@@ -60,22 +63,82 @@ class Lfm2ModelTest(CausalLMModelTest, unittest.TestCase):\n     # used in `test_torch_compile_for_training`\n     _torch_compile_train_cls = Lfm2ForCausalLM if is_torch_available() else None\n \n-    @unittest.skip(\n-        \"Lfm2 alternates between attention and conv layers, so attention are only returned for attention layers\"\n-    )\n     def test_attention_outputs(self):\n-        pass\n-\n-    @unittest.skip(\"Lfm2 has a special cache format as it alternates between attention and conv layers\")\n+        \"\"\"Lfm2Moe alternates between attention and short-conv layers.\"\"\"\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+        config.return_dict = True\n+        # force eager attention to support output attentions\n+        config._attn_implementation = \"eager\"\n+        seq_len = getattr(self.model_tester, \"seq_length\", None)\n+\n+        for model_class in self.all_model_classes:\n+            inputs_dict[\"output_attentions\"] = True\n+            inputs_dict[\"output_hidden_states\"] = False\n+            config.return_dict = True\n+            model = model_class._from_config(config, attn_implementation=\"eager\").to(torch_device).eval()\n+            config = model.config\n+            with torch.no_grad():\n+                outputs = model(**self._prepare_for_class(inputs_dict, model_class))\n+            attentions = outputs.attentions\n+            self.assertEqual(len(attentions), sum(layer == \"full_attention\" for layer in config.layer_types))\n+\n+            # check that output_attentions also work using config\n+            del inputs_dict[\"output_attentions\"]\n+            config.output_attentions = True\n+            model = model_class(config).to(torch_device).eval()\n+            with torch.no_grad():\n+                outputs = model(**self._prepare_for_class(inputs_dict, model_class))\n+            attentions = outputs.attentions\n+            self.assertEqual(len(attentions), sum(layer == \"full_attention\" for layer in config.layer_types))\n+            self.assertListEqual(list(attentions[0].shape[-3:]), [config.num_attention_heads, seq_len, seq_len])\n+            out_len = len(outputs)\n+\n+            # Check attention is always last and order is fine\n+            inputs_dict[\"output_attentions\"] = True\n+            inputs_dict[\"output_hidden_states\"] = True\n+            model = model_class(config).to(torch_device).eval()\n+            with torch.no_grad():\n+                outputs = model(**self._prepare_for_class(inputs_dict, model_class))\n+                self_attentions = outputs.attentions\n+\n+            self.assertEqual(out_len + 1, len(outputs))\n+            self.assertEqual(len(self_attentions), sum(layer == \"full_attention\" for layer in config.layer_types))\n+            self.assertListEqual(list(self_attentions[0].shape[-3:]), [config.num_attention_heads, seq_len, seq_len])\n+\n+    @pytest.mark.generate\n     def test_past_key_values_format(self):\n-        pass\n-\n-    @unittest.skip(\n-        \"Lfm2 has a special cache format which is not compatible with compile as it has static address for conv cache\"\n-    )\n-    @pytest.mark.torch_compile_test\n-    def test_sdpa_can_compile_dynamic(self):\n-        pass\n+        \"\"\"Lfm2Moe has a special cache format as it alternates between attention and conv layers\"\"\"\n+        for model_class in self.all_generative_model_classes:\n+            config, inputs = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+            model = model_class(config).to(torch_device).eval()\n+            if \"use_cache\" not in inputs:\n+                inputs[\"use_cache\"] = True\n+            outputs = model(**inputs)\n+\n+            past_kv = outputs[\"past_key_values\"]\n+\n+            num_query_attention_heads = config.num_attention_heads\n+            embed_dim = config.hidden_size\n+            per_head_embed_dim = embed_dim // num_query_attention_heads\n+            num_key_value_heads = getattr(config, \"num_key_value_heads\", num_query_attention_heads)\n+\n+            batch_size, seq_length = inputs[\"input_ids\"].shape[:2]\n+            default_self_attention_shape = (batch_size, num_key_value_heads, seq_length, per_head_embed_dim)\n+            default_conv_shape = (batch_size, config.hidden_size, config.conv_L_cache)\n+\n+            num_cache_decoder_layers = len(past_kv)\n+            self.assertEqual(num_cache_decoder_layers, config.num_hidden_layers)\n+\n+            for i in range(config.num_hidden_layers):\n+                if config.layer_types[i] == \"full_attention\":\n+                    self_attention_layer_keys = past_kv.key_cache[i]\n+                    self_attention_layer_values = past_kv.value_cache[i]\n+                    self.assertEqual(self_attention_layer_keys.shape, default_self_attention_shape)\n+                    self.assertEqual(self_attention_layer_values.shape, default_self_attention_shape)\n+                else:\n+                    conv_layer = past_kv.conv_cache[i]\n+                    self.assertEqual(conv_layer.shape, default_conv_shape)\n \n \n @require_torch_accelerator"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/lfm2_moe/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/tests%2Fmodels%2Flfm2_moe%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/tests%2Fmodels%2Flfm2_moe%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Flfm2_moe%2F__init__.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6"
        },
        {
            "sha": "9d24a5fde32fe054469e5c72339707ec5c569a4f",
            "filename": "tests/models/lfm2_moe/test_modeling_lfm2_moe.py",
            "status": "added",
            "additions": 246,
            "deletions": 0,
            "changes": 246,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/tests%2Fmodels%2Flfm2_moe%2Ftest_modeling_lfm2_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/tests%2Fmodels%2Flfm2_moe%2Ftest_modeling_lfm2_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Flfm2_moe%2Ftest_modeling_lfm2_moe.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -0,0 +1,246 @@\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch LLaMA model.\"\"\"\n+\n+import unittest\n+\n+import pytest\n+\n+from transformers import AutoTokenizer, is_torch_available, set_seed\n+from transformers.testing_utils import (\n+    cleanup,\n+    require_read_token,\n+    require_torch,\n+    require_torch_accelerator,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...causal_lm_tester import CausalLMModelTest, CausalLMModelTester\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import Lfm2MoeConfig, Lfm2MoeForCausalLM, Lfm2MoeModel\n+\n+\n+class Lfm2MoeModelTester(CausalLMModelTester):\n+    if is_torch_available():\n+        config_class = Lfm2MoeConfig\n+        base_model_class = Lfm2MoeModel\n+        causal_lm_class = Lfm2MoeForCausalLM\n+\n+    def __init__(\n+        self,\n+        parent,\n+        layer_types=[\"full_attention\", \"conv\"],\n+    ):\n+        super().__init__(parent)\n+        self.layer_types = layer_types\n+\n+\n+@require_torch\n+class Lfm2MoeModelTest(CausalLMModelTest, unittest.TestCase):\n+    all_model_classes = (Lfm2MoeModel, Lfm2MoeForCausalLM) if is_torch_available() else ()\n+    pipeline_model_mapping = (\n+        {\n+            \"feature-extraction\": Lfm2MoeModel,\n+            \"text-generation\": Lfm2MoeForCausalLM,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+    test_headmasking = False\n+    test_pruning = False\n+    fx_compatible = False\n+    model_tester_class = Lfm2MoeModelTester\n+    # used in `test_torch_compile_for_training`\n+    _torch_compile_train_cls = Lfm2MoeForCausalLM if is_torch_available() else None\n+\n+    def test_attention_outputs(self):\n+        \"\"\"Lfm2Moe alternates between attention and short-conv layers.\"\"\"\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+        config.return_dict = True\n+        # force eager attention to support output attentions\n+        config._attn_implementation = \"eager\"\n+        seq_len = getattr(self.model_tester, \"seq_length\", None)\n+\n+        for model_class in self.all_model_classes:\n+            inputs_dict[\"output_attentions\"] = True\n+            inputs_dict[\"output_hidden_states\"] = False\n+            config.return_dict = True\n+            model = model_class._from_config(config, attn_implementation=\"eager\").to(torch_device).eval()\n+            config = model.config\n+            with torch.no_grad():\n+                outputs = model(**self._prepare_for_class(inputs_dict, model_class))\n+            attentions = outputs.attentions\n+            self.assertEqual(len(attentions), sum(layer == \"full_attention\" for layer in config.layer_types))\n+\n+            # check that output_attentions also work using config\n+            del inputs_dict[\"output_attentions\"]\n+            config.output_attentions = True\n+            model = model_class(config).to(torch_device).eval()\n+            with torch.no_grad():\n+                outputs = model(**self._prepare_for_class(inputs_dict, model_class))\n+            attentions = outputs.attentions\n+            self.assertEqual(len(attentions), sum(layer == \"full_attention\" for layer in config.layer_types))\n+            self.assertListEqual(list(attentions[0].shape[-3:]), [config.num_attention_heads, seq_len, seq_len])\n+            out_len = len(outputs)\n+\n+            # Check attention is always last and order is fine\n+            inputs_dict[\"output_attentions\"] = True\n+            inputs_dict[\"output_hidden_states\"] = True\n+            model = model_class(config).to(torch_device).eval()\n+            with torch.no_grad():\n+                outputs = model(**self._prepare_for_class(inputs_dict, model_class))\n+                self_attentions = outputs.attentions\n+\n+            self.assertEqual(out_len + 1, len(outputs))\n+            self.assertEqual(len(self_attentions), sum(layer == \"full_attention\" for layer in config.layer_types))\n+            self.assertListEqual(list(self_attentions[0].shape[-3:]), [config.num_attention_heads, seq_len, seq_len])\n+\n+    @pytest.mark.generate\n+    def test_past_key_values_format(self):\n+        \"\"\"Lfm2Moe has a special cache format as it alternates between attention and conv layers\"\"\"\n+        for model_class in self.all_generative_model_classes:\n+            config, inputs = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+            model = model_class(config).to(torch_device).eval()\n+            if \"use_cache\" not in inputs:\n+                inputs[\"use_cache\"] = True\n+            outputs = model(**inputs)\n+\n+            past_kv = outputs[\"past_key_values\"]\n+\n+            num_query_attention_heads = config.num_attention_heads\n+            embed_dim = config.hidden_size\n+            per_head_embed_dim = embed_dim // num_query_attention_heads\n+            num_key_value_heads = getattr(config, \"num_key_value_heads\", num_query_attention_heads)\n+\n+            batch_size, seq_length = inputs[\"input_ids\"].shape[:2]\n+            default_self_attention_shape = (batch_size, num_key_value_heads, seq_length, per_head_embed_dim)\n+            default_conv_shape = (batch_size, config.hidden_size, config.conv_L_cache)\n+\n+            num_cache_decoder_layers = len(past_kv)\n+            self.assertEqual(num_cache_decoder_layers, config.num_hidden_layers)\n+\n+            for i in range(config.num_hidden_layers):\n+                if config.layer_types[i] == \"full_attention\":\n+                    self_attention_layer_keys = past_kv.key_cache[i]\n+                    self_attention_layer_values = past_kv.value_cache[i]\n+                    self.assertEqual(self_attention_layer_keys.shape, default_self_attention_shape)\n+                    self.assertEqual(self_attention_layer_values.shape, default_self_attention_shape)\n+                else:\n+                    conv_layer = past_kv.conv_cache[i]\n+                    self.assertEqual(conv_layer.shape, default_conv_shape)\n+\n+\n+@require_torch_accelerator\n+@require_read_token\n+@slow\n+class Lfm2MoeIntegrationTest(unittest.TestCase):\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.model = None\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        del cls.model\n+        cleanup(torch_device, gc_collect=True)\n+\n+    def tearDown(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    @classmethod\n+    def get_model(cls):\n+        if cls.model is None:\n+            cls.model = Lfm2MoeForCausalLM.from_pretrained(\n+                \"LiquidAI/LFM2-8B-A1B\", device_map=\"auto\", dtype=torch.bfloat16\n+            )\n+        return cls.model\n+\n+    @slow\n+    def test_model_1a8b_logits(self):\n+        set_seed(1789)\n+        input_ids = [1, 22998, 768, 1947, 797, 22017, 811, 6332, 928, 5743, 797, 779, 48123, 772, 33551, 60996, 523]\n+        model = self.get_model()\n+        input_ids = torch.tensor([input_ids]).to(model.model.embed_tokens.weight.device)\n+        with torch.no_grad():\n+            out = model(input_ids).logits.float().cpu()\n+        # Expected mean on dim = -1\n+        EXPECTED_MEAN = torch.tensor(\n+            [\n+                [\n+                    -1.3855,\n+                    -0.5123,\n+                    -1.3143,\n+                    -1.2144,\n+                    -1.0791,\n+                    -1.2117,\n+                    -1.4704,\n+                    -0.7648,\n+                    -0.6175,\n+                    -1.2402,\n+                    -1.1459,\n+                    -1.0083,\n+                    -1.0247,\n+                    -0.8830,\n+                    -1.5643,\n+                    -1.7266,\n+                    -1.6254,\n+                ]\n+            ]\n+        )\n+        torch.testing.assert_close(out.mean(-1), EXPECTED_MEAN, rtol=1e-2, atol=1e-2)\n+        # Expected portion of the logits\n+        EXPECTED_SLICE = torch.tensor(\n+            [-1.2656, 2.4844, 5.5000, -1.3359, -1.3203, -1.3438, 1.9375, 5.8438, -0.6523, -1.2891]\n+        )\n+        torch.testing.assert_close(out[0, 0, :10], EXPECTED_SLICE, rtol=1e-4, atol=1e-4)\n+\n+    @slow\n+    def test_model_1a8b_generation(self):\n+        EXPECTED_TEXT_COMPLETION = \"\"\"In 1st century A.D., the Roman Empire controlled much of Europe, North Africa, and parts of the Middle East.\"\"\"\n+        set_seed(1789)\n+        prompt = \"In 1st century A.D., the Roman Empire\"\n+        tokenizer = AutoTokenizer.from_pretrained(\"LiquidAI/LFM2-8B-A1B\", use_fast=False)\n+        model = self.get_model()\n+        input_ids = tokenizer.encode(prompt, return_tensors=\"pt\", add_special_tokens=True).to(\n+            model.model.embed_tokens.weight.device\n+        )\n+        with torch.no_grad():\n+            generated_ids = model.generate(input_ids, max_new_tokens=15, do_sample=False)\n+        text = tokenizer.decode(generated_ids[0], skip_special_tokens=True)\n+        self.assertEqual(EXPECTED_TEXT_COMPLETION, text)\n+\n+    @slow\n+    def test_model_1a8b_batched_chat_generation(self):\n+        prompts = [\"Who are you?\", \"Complete the text: Lorem ipsum dolor \", \"The Meji Restoration in Japan ended\"]\n+        EXPECTED_TEXT_COMPLETIONS = [\n+            \"Who are you??  \\nI am an artificial intelligence assistant designed to provide information, answer questions\",\n+            \"Complete the text: Lorem ipsum dolor ipsum dolor ipsum dolor ipsum dolor ipsum dolor\",\n+            \"The Meji Restoration in Japan ended (1868) marked the:  \\nA) Establishment of a constitutional\",\n+        ]\n+        set_seed(1789)\n+        tokenizer = AutoTokenizer.from_pretrained(\"LiquidAI/LFM2-8B-A1B\", use_fast=False)\n+        model = self.get_model()\n+        batched_input_ids = tokenizer(prompts, return_tensors=\"pt\", padding=True).to(\n+            model.model.embed_tokens.weight.device\n+        )\n+        with torch.no_grad():\n+            generated_ids = model.generate(**batched_input_ids, max_new_tokens=15, do_sample=False)\n+        text = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)\n+        self.assertEqual(EXPECTED_TEXT_COMPLETIONS, text)"
        },
        {
            "sha": "8545d91c07b8b58a688cc20b31a0cfae0e6cc046",
            "filename": "utils/check_config_attributes.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/0c9a72e4576fe4c84077f066e585129c97bfd4e6/utils%2Fcheck_config_attributes.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0c9a72e4576fe4c84077f066e585129c97bfd4e6/utils%2Fcheck_config_attributes.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_config_attributes.py?ref=0c9a72e4576fe4c84077f066e585129c97bfd4e6",
            "patch": "@@ -36,6 +36,7 @@\n     \"Ernie4_5Config\": [\"tie_word_embeddings\"],\n     \"Ernie4_5_MoeConfig\": [\"tie_word_embeddings\"],\n     \"Lfm2Config\": [\"full_attn_idxs\", \"tie_word_embeddings\"],\n+    \"Lfm2MoeConfig\": [\"tie_word_embeddings\"],\n     # used internally during generation to provide the custom logit processors with their necessary information\n     \"DiaConfig\": [\n         \"delay_pattern\","
        }
    ],
    "stats": {
        "total": 1657,
        "additions": 1635,
        "deletions": 22
    }
}