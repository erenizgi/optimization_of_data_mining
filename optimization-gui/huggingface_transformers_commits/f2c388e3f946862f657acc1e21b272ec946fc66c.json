{
    "author": "andimarafioti",
    "message": "Add Idefics 3! (#32473)\n\n* Add Idefics 3!\r\n\r\n* fixes to make both pipelines identical\r\n\r\n* fix for quantized models\r\n\r\n* First pass at the review\r\n\r\n* remove vocab size from the main config (it's still in the text_config)\r\n\r\n* hot fix for merve\r\n\r\n* Apply suggestions from code review\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* re-add model_type for text_config\r\n\r\n* remove support for old_cache\r\n\r\n* remove hidden_size from main config\r\n\r\n* rename idefics3 HF repo\r\n\r\n* few changes suggested in the PR\r\n\r\n* fix to input_data_format computation\r\n\r\n* remove overwrite of _autoset_attn_implementation following @zucchini-nlp suggestion\r\n\r\n* improve example\r\n\r\n* few improvements from amy's review\r\n\r\n* big change to enable processing input images as numpy arrays\r\n\r\n* Changes to the code to uniformize processor kwargs\r\n\r\n* image processing tests\r\n\r\n* image processing tests fixes and some bugs they discovered\r\n\r\n* addressed review comments from Yoni\r\n\r\n* fix modeling tests\r\n\r\n* remove special tokens that are not special\r\n\r\n* fixes tests\r\n\r\n* skip failing tests - they also fail for idefics2\r\n\r\n* added paper and readded the tests with multi gpu, who knows\r\n\r\n* Update docs/source/en/model_doc/idefics3.md\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* Apply suggestions from code review\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* review amy until image_processing_idefics3\r\n\r\n* last comments from Amy\r\n\r\n* review amy\r\n\r\n* Update src/transformers/models/idefics3/image_processing_idefics3.py\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* Update src/transformers/models/idefics3/modeling_idefics3.py\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* Update docs/source/en/model_doc/idefics3.md\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* doc improvement - amy review\r\n\r\n* fix runtime error during fine-tuning\r\n\r\n* amy's review\r\n\r\n* Update src/transformers/models/idefics3/image_processing_idefics3.py\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* Update src/transformers/models/idefics3/image_processing_idefics3.py\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* Update src/transformers/models/idefics3/modeling_idefics3.py\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* ruff\r\n\r\n* amy's comment on the order\r\n\r\n* ruff ruff\r\n\r\n* fix copies\r\n\r\n* square images when they are not splitted\r\n\r\n* ruff :(\r\n\r\n* Update src/transformers/models/idefics3/image_processing_idefics3.py\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* Update tests/models/idefics3/test_processing_idefics3.py\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>\r\n\r\n* fix small bug introduced in refactor\r\n\r\n* amy's image processing changes\r\n\r\n* fixes peft tests and ruff\r\n\r\n* modify to_pil_image from transformers. and review from emanuele.\r\n\r\n* add modified to_pil_image\r\n\r\n---------\r\n\r\nCo-authored-by: amyeroberts <22614925+amyeroberts@users.noreply.github.com>",
    "sha": "f2c388e3f946862f657acc1e21b272ec946fc66c",
    "files": [
        {
            "sha": "ae632376f9469c2830be023140e9d1eeffdd39c3",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -830,6 +830,8 @@\n         title: IDEFICS\n       - local: model_doc/idefics2\n         title: Idefics2\n+      - local: model_doc/idefics3\n+        title: Idefics3\n       - local: model_doc/instructblip\n         title: InstructBLIP\n       - local: model_doc/instructblipvideo"
        },
        {
            "sha": "0a5518fd71c840f5d841224c188d5c9f0573a530",
            "filename": "docs/source/en/index.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/docs%2Fsource%2Fen%2Findex.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/docs%2Fsource%2Fen%2Findex.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Findex.md?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -169,6 +169,7 @@ Flax), PyTorch, and/or TensorFlow.\n |                        [I-BERT](model_doc/ibert)                         |       ✅        |         ❌         |      ❌      |\n |                       [IDEFICS](model_doc/idefics)                       |       ✅        |         ✅         |      ❌      |\n |                      [Idefics2](model_doc/idefics2)                      |       ✅        |         ❌         |      ❌      |\n+|                      [Idefics3](model_doc/idefics3)                      |       ✅        |         ❌         |      ❌      |\n |                      [ImageGPT](model_doc/imagegpt)                      |       ✅        |         ❌         |      ❌      |\n |                      [Informer](model_doc/informer)                      |       ✅        |         ❌         |      ❌      |\n |                  [InstructBLIP](model_doc/instructblip)                  |       ✅        |         ❌         |      ❌      |"
        },
        {
            "sha": "dfaf40477a7b523a7a515b7a2a82e94bc51dd240",
            "filename": "docs/source/en/model_doc/idefics3.md",
            "status": "added",
            "additions": 73,
            "deletions": 0,
            "changes": 73,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/docs%2Fsource%2Fen%2Fmodel_doc%2Fidefics3.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/docs%2Fsource%2Fen%2Fmodel_doc%2Fidefics3.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fidefics3.md?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -0,0 +1,73 @@\n+<!--Copyright 2024 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# Idefics3\n+\n+## Overview\n+\n+The Idefics3 model was proposed in [Building and better understanding vision-language models: insights and future directions](https://huggingface.co/papers/2408.12637) by Hugo Laurençon, Andrés Marafioti, Victor Sanh, and Léo Tronchon.\n+\n+Idefics3 is an adaptation of the Idefics2 model with three main differences:\n+\n+- It uses Llama3 for the text model.\n+- It uses an updated processing logic for the images.\n+- It removes the perceiver.\n+\n+The abstract from the paper is the following:\n+\n+*The field of vision-language models (VLMs), which take images and texts as inputs and output texts, is rapidly evolving and has yet to reach consensus on several key aspects of the development pipeline, including data, architecture, and training methods. This paper can be seen as a tutorial for building a VLM. We begin by providing a comprehensive overview of the current state-of-the-art approaches, highlighting the strengths and weaknesses of each, addressing the major challenges in the field, and suggesting promising research directions for underexplored areas. We then walk through the practical steps to build Idefics3-8B, a powerful VLM that significantly outperforms its predecessor Idefics2-8B, while being trained efficiently, exclusively on open datasets, and using a straightforward pipeline. These steps include the creation of Docmatix, a dataset for improving document understanding capabilities, which is 240 times larger than previously available datasets. We release the model along with the datasets created for its training.*\n+\n+## Usage tips\n+\n+Input images are processed either by upsampling (if resizing is enabled) or at their original resolution. The resizing behavior depends on two parameters: do_resize and size.\n+\n+If `do_resize` is set to `True`, the model resizes images so that the longest edge is 4*364 pixels by default.\n+The default resizing behavior can be customized by passing a dictionary to the `size` parameter. For example, `{\"longest_edge\": 4 * 364}` is the default, but you can change it to a different value if needed.\n+\n+Here’s how to control resizing and set a custom size:\n+```python\n+image_processor = Idefics3ImageProcessor(do_resize=True, size={\"longest_edge\": 2 * 364}, max_image_size=364)\n+```\n+\n+Additionally, the `max_image_size` parameter, which controls the size of each square patch the image is decomposed into, is set to 364 by default but can be adjusted as needed. After resizing (if applicable), the image processor decomposes the images into square patches based on the `max_image_size` parameter.\n+\n+This model was contributed by [amyeroberts](https://huggingface.co/amyeroberts) and [andimarafioti](https://huggingface.co/andito).\n+\n+\n+## Idefics3Config\n+\n+[[autodoc]] Idefics3Config\n+\n+\n+## Idefics3Model\n+\n+[[autodoc]] Idefics3Model\n+    - forward\n+\n+## Idefics3ForConditionalGeneration\n+\n+[[autodoc]] Idefics3ForConditionalGeneration\n+    - forward\n+\n+\n+## Idefics3ImageProcessor\n+[[autodoc]] Idefics3ImageProcessor\n+    - preprocess\n+\n+\n+## Idefics3Processor\n+[[autodoc]] Idefics3Processor\n+    - __call__"
        },
        {
            "sha": "346759aa2b2517cf2522333d0c4d1708b5b676c6",
            "filename": "docs/source/en/perf_infer_gpu_one.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -54,6 +54,7 @@ FlashAttention-2 is currently supported for the following architectures:\n * [Granite](https://huggingface.co/docs/transformers/model_doc/granite#transformers.GraniteModel)\n * [GraniteMoe](https://huggingface.co/docs/transformers/model_doc/granitemoe#transformers.GraniteMoeModel)\n * [Idefics2](https://huggingface.co/docs/transformers/model_doc/idefics2#transformers.Idefics2Model)\n+* [Idefics3](https://huggingface.co/docs/transformers/model_doc/idefics3#transformers.Idefics3Model)\n * [Falcon](https://huggingface.co/docs/transformers/model_doc/falcon#transformers.FalconModel)\n * [JetMoe](https://huggingface.co/docs/transformers/model_doc/jetmoe#transformers.JetMoeModel)\n * [Jamba](https://huggingface.co/docs/transformers/model_doc/jamba#transformers.JambaModel)"
        },
        {
            "sha": "078e4d0e4abdeeb082b1321601738ca02c26fc1b",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -481,6 +481,7 @@\n     \"models.ibert\": [\"IBertConfig\"],\n     \"models.idefics\": [\"IdeficsConfig\"],\n     \"models.idefics2\": [\"Idefics2Config\"],\n+    \"models.idefics3\": [\"Idefics3Config\"],\n     \"models.imagegpt\": [\"ImageGPTConfig\"],\n     \"models.informer\": [\"InformerConfig\"],\n     \"models.instructblip\": [\n@@ -1191,6 +1192,7 @@\n     _import_structure[\"models.grounding_dino\"].extend([\"GroundingDinoImageProcessor\"])\n     _import_structure[\"models.idefics\"].extend([\"IdeficsImageProcessor\"])\n     _import_structure[\"models.idefics2\"].extend([\"Idefics2ImageProcessor\"])\n+    _import_structure[\"models.idefics3\"].extend([\"Idefics3ImageProcessor\"])\n     _import_structure[\"models.imagegpt\"].extend([\"ImageGPTFeatureExtractor\", \"ImageGPTImageProcessor\"])\n     _import_structure[\"models.instructblipvideo\"].extend([\"InstructBlipVideoImageProcessor\"])\n     _import_structure[\"models.layoutlmv2\"].extend([\"LayoutLMv2FeatureExtractor\", \"LayoutLMv2ImageProcessor\"])\n@@ -2420,6 +2422,14 @@\n             \"Idefics2Processor\",\n         ]\n     )\n+    _import_structure[\"models.idefics3\"].extend(\n+        [\n+            \"Idefics3ForConditionalGeneration\",\n+            \"Idefics3Model\",\n+            \"Idefics3PreTrainedModel\",\n+            \"Idefics3Processor\",\n+        ]\n+    )\n     _import_structure[\"models.imagegpt\"].extend(\n         [\n             \"ImageGPTForCausalImageModeling\",\n@@ -5289,6 +5299,7 @@\n         IdeficsConfig,\n     )\n     from .models.idefics2 import Idefics2Config\n+    from .models.idefics3 import Idefics3Config\n     from .models.imagegpt import ImageGPTConfig\n     from .models.informer import InformerConfig\n     from .models.instructblip import (\n@@ -6037,6 +6048,7 @@\n         from .models.grounding_dino import GroundingDinoImageProcessor\n         from .models.idefics import IdeficsImageProcessor\n         from .models.idefics2 import Idefics2ImageProcessor\n+        from .models.idefics3 import Idefics3ImageProcessor\n         from .models.imagegpt import ImageGPTFeatureExtractor, ImageGPTImageProcessor\n         from .models.instructblipvideo import InstructBlipVideoImageProcessor\n         from .models.layoutlmv2 import (\n@@ -7071,6 +7083,12 @@\n             Idefics2PreTrainedModel,\n             Idefics2Processor,\n         )\n+        from .models.idefics3 import (\n+            Idefics3ForConditionalGeneration,\n+            Idefics3Model,\n+            Idefics3PreTrainedModel,\n+            Idefics3Processor,\n+        )\n         from .models.imagegpt import (\n             ImageGPTForCausalImageModeling,\n             ImageGPTForImageClassification,"
        },
        {
            "sha": "4fef6012012f36d2c27b28bcdc0490036ddbc6da",
            "filename": "src/transformers/image_transforms.py",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fimage_transforms.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fimage_transforms.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fimage_transforms.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -162,6 +162,7 @@ def _rescale_for_pil_conversion(image):\n def to_pil_image(\n     image: Union[np.ndarray, \"PIL.Image.Image\", \"torch.Tensor\", \"tf.Tensor\", \"jnp.ndarray\"],\n     do_rescale: Optional[bool] = None,\n+    image_mode: Optional[str] = None,\n     input_data_format: Optional[Union[str, ChannelDimension]] = None,\n ) -> \"PIL.Image.Image\":\n     \"\"\"\n@@ -175,6 +176,8 @@ def to_pil_image(\n             Whether or not to apply the scaling factor (to make pixel values integers between 0 and 255). Will default\n             to `True` if the image type is a floating type and casting to `int` would result in a loss of precision,\n             and `False` otherwise.\n+        image_mode (`str`, *optional*):\n+            The mode to use for the PIL image. If unset, will use the default mode for the input image type.\n         input_data_format (`ChannelDimension`, *optional*):\n             The channel dimension format of the input image. If unset, will use the inferred format from the input.\n \n@@ -207,7 +210,7 @@ def to_pil_image(\n         image = rescale(image, 255)\n \n     image = image.astype(np.uint8)\n-    return PIL.Image.fromarray(image)\n+    return PIL.Image.fromarray(image, mode=image_mode)\n \n \n # Logic adapted from torchvision resizing logic: https://github.com/pytorch/vision/blob/511924c1ced4ce0461197e5caa64ce5b9e558aab/torchvision/transforms/functional.py#L366"
        },
        {
            "sha": "e47a4ed9c342e4ae7013b36b27148ad05b0f0ba5",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -115,6 +115,7 @@\n     ibert,\n     idefics,\n     idefics2,\n+    idefics3,\n     imagegpt,\n     informer,\n     instructblip,"
        },
        {
            "sha": "6d55f87d60ac8eac64c09ed74b44d4afd3d42dc9",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -133,6 +133,7 @@\n         (\"ibert\", \"IBertConfig\"),\n         (\"idefics\", \"IdeficsConfig\"),\n         (\"idefics2\", \"Idefics2Config\"),\n+        (\"idefics3\", \"Idefics3Config\"),\n         (\"imagegpt\", \"ImageGPTConfig\"),\n         (\"informer\", \"InformerConfig\"),\n         (\"instructblip\", \"InstructBlipConfig\"),\n@@ -432,6 +433,7 @@\n         (\"ibert\", \"I-BERT\"),\n         (\"idefics\", \"IDEFICS\"),\n         (\"idefics2\", \"Idefics2\"),\n+        (\"idefics3\", \"Idefics3\"),\n         (\"imagegpt\", \"ImageGPT\"),\n         (\"informer\", \"Informer\"),\n         (\"instructblip\", \"InstructBLIP\"),"
        },
        {
            "sha": "f404c92780c39f0c47669acf3535a4053cfd59fd",
            "filename": "src/transformers/models/auto/image_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -89,6 +89,7 @@\n             (\"hiera\", (\"BitImageProcessor\",)),\n             (\"idefics\", (\"IdeficsImageProcessor\",)),\n             (\"idefics2\", (\"Idefics2ImageProcessor\",)),\n+            (\"idefics3\", (\"Idefics3ImageProcessor\",)),\n             (\"imagegpt\", (\"ImageGPTImageProcessor\",)),\n             (\"instructblip\", (\"BlipImageProcessor\",)),\n             (\"instructblipvideo\", (\"InstructBlipVideoImageProcessor\",)),"
        },
        {
            "sha": "6e730e848db7558bfdab6dc8cc02df94fe38cc3d",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -130,6 +130,7 @@\n         (\"ibert\", \"IBertModel\"),\n         (\"idefics\", \"IdeficsModel\"),\n         (\"idefics2\", \"Idefics2Model\"),\n+        (\"idefics3\", \"Idefics3Model\"),\n         (\"imagegpt\", \"ImageGPTModel\"),\n         (\"informer\", \"InformerModel\"),\n         (\"jamba\", \"JambaModel\"),\n@@ -315,6 +316,7 @@\n         (\"ibert\", \"IBertForMaskedLM\"),\n         (\"idefics\", \"IdeficsForVisionText2Text\"),\n         (\"idefics2\", \"Idefics2ForConditionalGeneration\"),\n+        (\"idefics3\", \"Idefics3ForConditionalGeneration\"),\n         (\"layoutlm\", \"LayoutLMForMaskedLM\"),\n         (\"llava\", \"LlavaForConditionalGeneration\"),\n         (\"llava_next\", \"LlavaNextForConditionalGeneration\"),\n@@ -733,6 +735,7 @@\n         (\"chameleon\", \"ChameleonForConditionalGeneration\"),\n         (\"git\", \"GitForCausalLM\"),\n         (\"idefics2\", \"Idefics2ForConditionalGeneration\"),\n+        (\"idefics3\", \"Idefics3ForConditionalGeneration\"),\n         (\"instructblip\", \"InstructBlipForConditionalGeneration\"),\n         (\"instructblipvideo\", \"InstructBlipVideoForConditionalGeneration\"),\n         (\"kosmos-2\", \"Kosmos2ForConditionalGeneration\"),"
        },
        {
            "sha": "c894840c6ad229a63a8691a9694893e98ea0cd14",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -65,6 +65,7 @@\n         (\"hubert\", \"Wav2Vec2Processor\"),\n         (\"idefics\", \"IdeficsProcessor\"),\n         (\"idefics2\", \"Idefics2Processor\"),\n+        (\"idefics3\", \"Idefics3Processor\"),\n         (\"instructblip\", \"InstructBlipProcessor\"),\n         (\"instructblipvideo\", \"InstructBlipVideoProcessor\"),\n         (\"kosmos-2\", \"Kosmos2Processor\"),"
        },
        {
            "sha": "6a5cba11f0949f99d3fa769427065a45c7583794",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -219,6 +219,7 @@\n             (\"ibert\", (\"RobertaTokenizer\", \"RobertaTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"idefics\", (None, \"LlamaTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"idefics2\", (\"LlamaTokenizer\", \"LlamaTokenizerFast\" if is_tokenizers_available() else None)),\n+            (\"idefics3\", (\"LlamaTokenizer\", \"LlamaTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"instructblip\", (\"GPT2Tokenizer\", \"GPT2TokenizerFast\" if is_tokenizers_available() else None)),\n             (\"instructblipvideo\", (\"GPT2Tokenizer\", \"GPT2TokenizerFast\" if is_tokenizers_available() else None)),\n             ("
        },
        {
            "sha": "d8079537bb5e275e88bf26d04b18ef55e17235b6",
            "filename": "src/transformers/models/idefics2/modeling_idefics2.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics2%2Fmodeling_idefics2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics2%2Fmodeling_idefics2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fidefics2%2Fmodeling_idefics2.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -1098,7 +1098,7 @@ class Idefics2PreTrainedModel(PreTrainedModel):\n \n     def _init_weights(self, module):\n         std = (\n-            self.config.text_config.initializer_range\n+            self.config.initializer_range\n             if hasattr(self.config, \"initializer_range\")\n             else self.config.text_config.initializer_range\n         )"
        },
        {
            "sha": "35b1df5c6784393798137e835443b83d02c2b6c8",
            "filename": "src/transformers/models/idefics3/__init__.py",
            "status": "added",
            "additions": 72,
            "deletions": 0,
            "changes": 72,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics3%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics3%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fidefics3%2F__init__.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -0,0 +1,72 @@\n+# Copyright 2024 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import OptionalDependencyNotAvailable, _LazyModule, is_torch_available, is_vision_available\n+\n+\n+_import_structure = {\"configuration_idefics3\": [\"Idefics3Config\"]}\n+\n+\n+try:\n+    if not is_vision_available():\n+        raise OptionalDependencyNotAvailable()\n+except OptionalDependencyNotAvailable:\n+    pass\n+else:\n+    _import_structure[\"image_processing_idefics3\"] = [\"Idefics3ImageProcessor\"]\n+\n+\n+try:\n+    if not is_torch_available():\n+        raise OptionalDependencyNotAvailable()\n+except OptionalDependencyNotAvailable:\n+    pass\n+else:\n+    _import_structure[\"modeling_idefics3\"] = [\n+        \"Idefics3ForConditionalGeneration\",\n+        \"Idefics3PreTrainedModel\",\n+        \"Idefics3Model\",\n+    ]\n+    _import_structure[\"processing_idefics3\"] = [\"Idefics3Processor\"]\n+\n+if TYPE_CHECKING:\n+    from .configuration_idefics3 import Idefics3Config\n+\n+    try:\n+        if not is_vision_available():\n+            raise OptionalDependencyNotAvailable()\n+    except OptionalDependencyNotAvailable:\n+        pass\n+    else:\n+        from .image_processing_idefics3 import Idefics3ImageProcessor\n+\n+    try:\n+        if not is_torch_available():\n+            raise OptionalDependencyNotAvailable()\n+    except OptionalDependencyNotAvailable:\n+        pass\n+    else:\n+        from .modeling_idefics3 import (\n+            Idefics3ForConditionalGeneration,\n+            Idefics3Model,\n+            Idefics3PreTrainedModel,\n+        )\n+        from .processing_idefics3 import Idefics3Processor\n+\n+\n+else:\n+    import sys\n+\n+    sys.modules[__name__] = _LazyModule(__name__, globals()[\"__file__\"], _import_structure)"
        },
        {
            "sha": "45afe685f5209cc2dfe2163a8e271c417c919e01",
            "filename": "src/transformers/models/idefics3/configuration_idefics3.py",
            "status": "added",
            "additions": 207,
            "deletions": 0,
            "changes": 207,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics3%2Fconfiguration_idefics3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics3%2Fconfiguration_idefics3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fidefics3%2Fconfiguration_idefics3.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -0,0 +1,207 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Idefics3 model configuration\"\"\"\n+\n+import os\n+from typing import Union\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...utils import logging\n+from ..auto import CONFIG_MAPPING\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Idefics3VisionConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Idefics3VisionModel`]. It is used to instantiate a\n+    Idefics3 vision encoder according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the SigLIP checkpoint\n+    [google/siglip-base-patch16-224](https://huggingface.co/google/siglip-base-patch16-224) used in the Idefics3 model\n+    [HuggingFaceM4/Idefics3-8B-Llama3](https://huggingface.co/HuggingFaceM4/Idefics3-8B-Llama3).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        hidden_size (`int`, *optional*, defaults to 1152):\n+            Dimensionality of the encoder layers and the pooler layer.\n+        intermediate_size (`int`, *optional*, defaults to 3072):\n+            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+        num_hidden_layers (`int`, *optional*, defaults to 12):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 16):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_channels (`int`, *optional*, defaults to 3):\n+            Number of channels in the input images.\n+        image_size (`int`, *optional*, defaults to 224):\n+            The size (resolution) of each image.\n+        patch_size (`int`, *optional*, defaults to 32):\n+            The size (resolution) of each patch.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"gelu_pytorch_tanh\"`):\n+            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+            `\"relu\"`, `\"selu\"` and `\"gelu_new\"` `\"quick_gelu\"` are supported.\n+        layer_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the layer normalization layers.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        intializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation for initializing all weight matrices in the model.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers.models.idefics3.modeling_idefics3 import Idefics3VisionTransformer\n+    >>> from transformers.models.idefics3.configuration_idefics3 import Idefics3VisionConfig\n+\n+    >>> # Initializing a Idefics3VisionConfig with google/siglip-base-patch16-224 style configuration\n+    >>> configuration = Idefics3VisionConfig()\n+\n+    >>> # Initializing a Idefics3VisionTransformer (with random weights) from the google/siglip-base-patch16-224 style configuration\n+    >>> model = Idefics3VisionTransformer(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"idefics3\"\n+\n+    def __init__(\n+        self,\n+        hidden_size=1152,\n+        intermediate_size=3072,\n+        num_hidden_layers=12,\n+        num_attention_heads=16,\n+        num_channels=3,\n+        image_size=224,\n+        patch_size=32,\n+        hidden_act=\"gelu_pytorch_tanh\",\n+        layer_norm_eps=1e-6,\n+        attention_dropout=0.0,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.num_channels = num_channels\n+        self.patch_size = patch_size\n+        self.image_size = image_size\n+        self.attention_dropout = attention_dropout\n+        self.layer_norm_eps = layer_norm_eps\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+\n+    @classmethod\n+    def from_pretrained(cls, pretrained_model_name_or_path: Union[str, os.PathLike], **kwargs) -> \"PretrainedConfig\":\n+        cls._set_token_in_kwargs(kwargs)\n+\n+        config_dict, kwargs = cls.get_config_dict(pretrained_model_name_or_path, **kwargs)\n+\n+        # get the vision config dict if we are loading from Idefics3Config\n+        if config_dict.get(\"model_type\") == \"idefics3\":\n+            config_dict = config_dict[\"vision_config\"]\n+\n+        if \"model_type\" in config_dict and hasattr(cls, \"model_type\") and config_dict[\"model_type\"] != cls.model_type:\n+            logger.warning(\n+                f\"You are using a model of type {config_dict['model_type']} to instantiate a model of type \"\n+                f\"{cls.model_type}. This is not supported for all configurations of models and can yield errors.\"\n+            )\n+\n+        return cls.from_dict(config_dict, **kwargs)\n+\n+\n+class Idefics3Config(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Idefics3Model`]. It is used to instantiate a\n+    Idefics3 model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of the model of the Idefics3\n+    [HuggingFaceM4/Idefics3-8B-Llama3](https://huggingface.co/HuggingFaceM4/Idefics3-8B-Llama3) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should cache the key/value pairs of the attention mechanism. Only\n+            relevant if `config.is_decoder=True`.\n+        image_token_id (`int`, *optional*, defaults to 128257):\n+            The id of the \"image\" token.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether or not to tie the word embeddings with the token embeddings.\n+        vision_config (`IdeficsVisionConfig` or `dict`, *optional*, defaults to `IdeficsVisionConfig`):\n+            Custom vision config or dict for the vision tower\n+        text_config (`PretrainedConfig` or `dict`, *optional*, defaults to `LlamaConfig`):\n+            Custom text config or dict for the text model\n+        scale_factor (`int`, *optional*, defaults to 2):\n+            The scale factor for the image encoder.\n+        pad_token_id (`int`, *optional*, defaults to 128002):\n+            The id of the padding token.\n+\n+    Example:\n+    ```python\n+    >>> from transformers import Idefics3Model, Idefics3Config\n+    >>> # Initializing configuration\n+    >>> configuration = Idefics3Config()\n+    >>> # Initializing a model from the configuration\n+    >>> model = Idefics3Model(configuration)\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"idefics3\"\n+    is_composition = True\n+\n+    def __init__(\n+        self,\n+        use_cache=True,\n+        image_token_id=128257,\n+        tie_word_embeddings=False,\n+        vision_config=None,\n+        text_config=None,\n+        scale_factor=2,\n+        pad_token_id=128_002,\n+        **kwargs,\n+    ):\n+        self.image_token_id = image_token_id\n+        self.use_cache = use_cache\n+        self.tie_word_embeddings = tie_word_embeddings\n+\n+        if vision_config is None:\n+            self.vision_config = Idefics3VisionConfig()\n+            logger.info(\"vision_config is None, using default vision config\")\n+        elif isinstance(vision_config, dict):\n+            self.vision_config = Idefics3VisionConfig(**vision_config)\n+        elif isinstance(vision_config, Idefics3VisionConfig):\n+            self.vision_config = vision_config\n+\n+        if isinstance(text_config, dict):\n+            text_config[\"model_type\"] = text_config[\"model_type\"] if \"model_type\" in text_config else \"llama\"\n+            text_config = CONFIG_MAPPING[text_config[\"model_type\"]](**text_config)\n+        elif text_config is None:\n+            logger.info(\"text_config is None, using default text config\")\n+            text_config = CONFIG_MAPPING[\"llama\"](\n+                rms_norm_eps=1e-5,\n+                pad_token_id=pad_token_id,\n+                tie_word_embeddings=False,\n+            )\n+\n+        self.text_config = text_config\n+        self.scale_factor = scale_factor\n+\n+        super().__init__(**kwargs, tie_word_embeddings=tie_word_embeddings)"
        },
        {
            "sha": "204104a58b30e82bfb03f4a54983d712bc2265b3",
            "filename": "src/transformers/models/idefics3/convert_idefics3_weights_to_hf.py",
            "status": "added",
            "additions": 214,
            "deletions": 0,
            "changes": 214,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics3%2Fconvert_idefics3_weights_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics3%2Fconvert_idefics3_weights_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fidefics3%2Fconvert_idefics3_weights_to_hf.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -0,0 +1,214 @@\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import argparse\n+import json\n+\n+import torch\n+from accelerate import init_empty_weights\n+from huggingface_hub import hf_hub_download\n+\n+from transformers import (\n+    AutoModelForCausalLM,\n+    AutoTokenizer,\n+    Idefics3Config,\n+    Idefics3ForConditionalGeneration,\n+    Idefics3ImageProcessor,\n+    Idefics3Processor,\n+    LlamaConfig,\n+)\n+\n+\n+EPILOG_TXT = \"\"\"Example:\n+    python transformers/src/transformers/models/idefics3/convert_idefics3_weights_to_hf.py --original_model_id HuggingFaceM4/Idefics3-8B-Llama3 --output_hub_path org/idefics3\n+\"\"\"\n+\n+\n+KEYS_TO_MODIFY_MAPPING = {\n+    \"lm_head.weight\": \"lm_head.linear.weight\",\n+    \"model.layers\": \"model.text_model.layers\",\n+    \"model.norm\": \"model.text_model.norm\",\n+    \"model.modality_projection\": \"model.connector.modality_projection\",\n+}\n+\n+\n+WEIGHTS_TO_MERGE_MAPPING = (\n+    # (weights to merge in merging order), (new weight name)\n+    (\n+        (\"model.embed_tokens.weight\", \"model.embed_tokens.additional_embedding.weight\"),\n+        \"model.text_model.embed_tokens.weight\",\n+    ),\n+    ((\"lm_head.linear.weight\", \"additional_fc.weight\"), \"lm_head.weight\"),\n+)\n+\n+WEIGHTS_TO_DROP = (\n+    # The original model had a vision head, but this is never used\n+    \"model.vision_model.head\",\n+)\n+\n+\n+def convert_state_dict_to_hf(state_dict):\n+    new_state_dict = {}\n+    old_state_dict_keys = set(state_dict.keys())\n+\n+    # Flattened list of weights to merge. We keep these in the original state dict to merge them later\n+    original_weights_to_merge = [w for weights in WEIGHTS_TO_MERGE_MAPPING for w in weights[0]]\n+\n+    # for key, value in state_dict.items():\n+    for old_key in old_state_dict_keys:\n+        if old_key.endswith(\".inv_freq\") or any(w in old_key for w in WEIGHTS_TO_DROP):\n+            state_dict.pop(old_key)\n+            continue\n+\n+        key = old_key\n+        for key_to_modify, new_key in KEYS_TO_MODIFY_MAPPING.items():\n+            if key_to_modify in key:\n+                key = key.replace(key_to_modify, new_key)\n+\n+        weight = state_dict.pop(old_key)\n+        if key in original_weights_to_merge:\n+            new_state_dict[key] = weight\n+            # Bit of a hack - we need to keep the original weights to merge them later\n+            state_dict[key] = weight\n+        else:\n+            new_state_dict[key] = weight\n+\n+    return new_state_dict\n+\n+\n+def merge_weights(state_dict, new_state_dict):\n+    old_weight_names = set(state_dict.keys())\n+\n+    # Merge the weights\n+    for weights_to_merge, new_weight_name in WEIGHTS_TO_MERGE_MAPPING:\n+        for weight_to_merge in weights_to_merge:\n+            print(weight_to_merge)\n+            assert weight_to_merge in state_dict, f\"Weight {weight_to_merge} is missing in the state dict\"\n+\n+            weight = state_dict.pop(weight_to_merge)\n+            if new_weight_name not in new_state_dict:\n+                new_state_dict[new_weight_name] = [weight]\n+            else:\n+                new_state_dict[new_weight_name].append(weight)\n+\n+            old_weight_names.remove(weight_to_merge)\n+\n+        new_state_dict[new_weight_name] = torch.cat(new_state_dict[new_weight_name], dim=0)\n+\n+    # Remove the weights that were merged\n+    for weights_to_merge, new_weight_name in WEIGHTS_TO_MERGE_MAPPING:\n+        for weight in weights_to_merge:\n+            if weight in new_state_dict and weight != new_weight_name:\n+                new_state_dict.pop(weight)\n+\n+    return new_state_dict\n+\n+\n+def get_config(checkpoint):\n+    # We load the config then recreate to use the text_config\n+\n+    # download the config file\n+    filepath = hf_hub_download(repo_id=checkpoint, filename=\"config.json\")\n+    with open(filepath, \"r\") as f:\n+        config_json = json.load(f)\n+\n+    # Setup the vision config\n+    vision_config = config_json.pop(\"vision_config\")\n+    vision_config.pop(\"vision_model_name\", None)\n+    if \"embed_dim\" in vision_config:\n+        vision_config[\"hidden_size\"] = vision_config.pop(\"embed_dim\")\n+\n+    config_json[\"vocab_size\"] = config_json.pop(\"vocab_size\") + config_json.pop(\"additional_vocab_size\")\n+\n+    image_token_id = config_json.pop(\"image_token_id\", config_json[\"vocab_size\"] - 2)\n+    use_cache = config_json.pop(\"use_cache\", True)\n+    tie_word_embeddings = config_json.pop(\"tie_word_embeddings\", True)\n+    scale_factor = config_json.pop(\"scale_factor\", 2)\n+    vocab_size = config_json.pop(\"vocab_size\", 100000)\n+\n+    # Remove \"freeze\" params from the config\n+    config_json = {k: v for k, v in config_json.items() if not k.startswith(\"freeze_\")}\n+    text_config = LlamaConfig(**config_json)\n+\n+    config = Idefics3Config(\n+        text_config=text_config,\n+        vision_config=vision_config,\n+        use_cache=use_cache,\n+        image_token_id=image_token_id,\n+        tie_word_embeddings=tie_word_embeddings,\n+        scale_factor=scale_factor,\n+        vocab_size=vocab_size,\n+    )\n+    return config\n+\n+\n+def convert_idefics3_hub_to_hf(original_model_id, output_hub_path, push_to_hub):\n+    # The original model maps to AutoModelForCausalLM, converted we map to Idefics3ForConditionalGeneration\n+    original_model = AutoModelForCausalLM.from_pretrained(\n+        original_model_id, trust_remote_code=True, torch_dtype=torch.bfloat16\n+    )\n+    # The original model doesn't use the Idefics3 processing objects\n+    image_processor = Idefics3ImageProcessor()\n+    tokenizer = AutoTokenizer.from_pretrained(original_model_id)\n+    processor = Idefics3Processor(\n+        image_processor=image_processor,\n+        tokenizer=tokenizer,\n+    )\n+    state_dict = original_model.state_dict()\n+    new_state_dict = convert_state_dict_to_hf(state_dict)\n+\n+    # Merge weights\n+    new_state_dict = merge_weights(state_dict, new_state_dict)\n+    del state_dict\n+\n+    config = get_config(original_model_id)\n+    print(config)\n+\n+    with init_empty_weights():\n+        model = Idefics3ForConditionalGeneration(config)\n+\n+    model.load_state_dict(new_state_dict, strict=True, assign=True)\n+\n+    model.save_pretrained(output_hub_path)\n+    processor.save_pretrained(output_hub_path)\n+\n+    if push_to_hub:\n+        model.push_to_hub(output_hub_path, private=True)\n+        processor.push_to_hub(output_hub_path, private=True)\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser(\n+        epilog=EPILOG_TXT,\n+        formatter_class=argparse.RawDescriptionHelpFormatter,\n+    )\n+    parser.add_argument(\n+        \"--original_model_id\",\n+        help=\"Hub location of the text model\",\n+    )\n+    parser.add_argument(\n+        \"--output_hub_path\",\n+        help=\"Location on the hub of the converted model\",\n+    )\n+    parser.add_argument(\n+        \"--push_to_hub\",\n+        action=\"store_true\",\n+        help=\"If set, the model will be pushed to the hub after conversion.\",\n+    )\n+    args = parser.parse_args()\n+    convert_idefics3_hub_to_hf(args.original_model_id, args.output_hub_path, args.push_to_hub)\n+\n+\n+if __name__ == \"__main__\":\n+    main()"
        },
        {
            "sha": "495ac04595fbc6da0e71d733aa3b7fcaeb4cc5fb",
            "filename": "src/transformers/models/idefics3/image_processing_idefics3.py",
            "status": "added",
            "additions": 890,
            "deletions": 0,
            "changes": 890,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics3%2Fimage_processing_idefics3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics3%2Fimage_processing_idefics3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fidefics3%2Fimage_processing_idefics3.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -0,0 +1,890 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import math\n+from typing import Any, Dict, Iterable, List, Optional, Tuple, Union\n+\n+import numpy as np\n+\n+from ...image_processing_utils import BaseImageProcessor, BatchFeature\n+from ...image_transforms import PaddingMode, pad, to_channel_dimension_format, to_pil_image\n+from ...image_utils import (\n+    IMAGENET_STANDARD_MEAN,\n+    IMAGENET_STANDARD_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    is_scaled_image,\n+    is_valid_image,\n+    to_numpy_array,\n+    valid_images,\n+    validate_preprocess_arguments,\n+)\n+from ...utils import TensorType, is_vision_available, logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+if is_vision_available():\n+    import PIL\n+    from PIL import Image\n+\n+\n+def _resize_output_size_rescale_to_max_len(\n+    height: int, width: int, min_len: Optional[int] = 1, max_len: Optional[int] = None\n+) -> Tuple[int, int]:\n+    \"\"\"\n+    Get the output size of the image after resizing given a dictionary specifying the max and min sizes.\n+    Args:\n+        height (`int`):\n+            Height of the input image.\n+        width (`int`):\n+            Width of the input image.\n+        min_len (`int`, *optional*, defaults to 1):\n+            Minimum size of the output image.\n+        max_len (`int`, *optional*, defaults to the maximum size of the image):\n+            Maximum size of the output image.\n+    Returns:\n+        The output size of the image after resizing.\n+    \"\"\"\n+    max_len = max(height, width) if max_len is None else max_len\n+    aspect_ratio = width / height\n+\n+    if width >= height:\n+        width = max_len\n+        height = int(width / aspect_ratio)\n+        if height % 2 != 0:\n+            height += 1\n+    elif height > width:\n+        height = max_len\n+        width = int(height * aspect_ratio)\n+        if width % 2 != 0:\n+            width += 1\n+\n+    # Avoid resizing to a size smaller than min_len\n+    height = max(height, min_len)\n+    width = max(width, min_len)\n+    return height, width\n+\n+\n+def _resize_output_size_scale_below_upper_bound(\n+    height: int, width: int, max_len: Optional[Dict[str, int]] = None\n+) -> Tuple[int, int]:\n+    \"\"\"\n+    Get the output size of the image after resizing given a dictionary specifying the max and min sizes.\n+    Args:\n+        height (`int`):\n+            Height of the input image.\n+        width (`int`):\n+            Width of the input image.\n+        max_len (`Dict[str, int]`, *optional*, defaults to the maximum size of the image):\n+            Defines the maximum dimensions of the image.\n+    Returns:\n+        The output size of the image after resizing.\n+    \"\"\"\n+    max_len = max(height, width) if max_len is None else max_len\n+\n+    aspect_ratio = width / height\n+    if width >= height and width > max_len:\n+        width = max_len\n+        height = int(width / aspect_ratio)\n+    elif height > width and height > max_len:\n+        height = max_len\n+        width = int(height * aspect_ratio)\n+\n+    # Avoid resizing to a size smaller than 1\n+    height = max(height, 1)\n+    width = max(width, 1)\n+    return height, width\n+\n+\n+def get_resize_output_image_size(\n+    image,\n+    resolution_max_side: int,\n+    max_image_size: int = 1820,\n+    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+) -> Tuple[int, int]:\n+    \"\"\"\n+    Get the output size of the image after resizing given a dictionary specifying the max and min sizes.\n+    Args:\n+        image (`np.ndarray`):\n+            Image to resize.\n+        resolution_max_side (`int`):\n+            The longest edge of the image will be resized to this value. The shortest edge will be resized to keep the\n+            input aspect ratio, with a lower bound of `min_image_size`.\n+        max_image_size (`int`, *optional*, defaults to 1820):\n+            Maximum image resolution. If the image is larger than this size, the longest edge will be resized to this\n+            value, with the shortest edge resized to keep the input aspect ratio, with a lower bound of `min_image_size`.\n+        input_data_format (`ChannelDimension` or `str`):\n+            The channel dimension format of the input image.\n+    Returns:\n+        The output size of the image after resizing.\n+    \"\"\"\n+    if resolution_max_side > max_image_size:\n+        raise ValueError(\"`resolution_max_side` cannot be larger than `max_image_size`\")\n+\n+    height, width = get_image_size(image, channel_dim=input_data_format)\n+\n+    # Find the output size, when rescaling the longest edge to max_len and preserving the aspect ratio\n+    height, width = _resize_output_size_rescale_to_max_len(height, width, max_len=resolution_max_side)\n+    # Find the output size when scaling the image to be below the max_image_size\n+    height, width = _resize_output_size_scale_below_upper_bound(height, width, max_len=max_image_size)\n+    return height, width\n+\n+\n+# Copied from transformers.models.idefics2.image_processing_idefics2.make_list_of_images\n+def make_list_of_images(images: ImageInput) -> List[List[np.ndarray]]:\n+    \"\"\"\n+    Convert a single image or a list of images to a list of numpy arrays.\n+    Args:\n+        images (`ImageInput`):\n+            A single image or a list of images.\n+    Returns:\n+        A list of numpy arrays.\n+    \"\"\"\n+    # If it's a single image, convert it to a list of lists\n+    if is_valid_image(images):\n+        images = [[images]]\n+    # If it's a list of images, it's a single batch, so convert it to a list of lists\n+    elif isinstance(images, (list, tuple)) and len(images) > 0 and is_valid_image(images[0]):\n+        images = [images]\n+    # If it's a list of batches, it's already in the right format\n+    elif (\n+        isinstance(images, (list, tuple))\n+        and len(images) > 0\n+        and isinstance(images[0], (list, tuple))\n+        and is_valid_image(images[0][0])\n+    ):\n+        pass\n+    else:\n+        raise ValueError(\n+            \"Invalid input type. Must be a single image, a list of images, or a list of batches of images.\"\n+        )\n+    return images\n+\n+\n+# Copied from transformers.models.detr.image_processing_detr.max_across_indices\n+def max_across_indices(values: Iterable[Any]) -> List[Any]:\n+    \"\"\"\n+    Return the maximum value across all indices of an iterable of values.\n+    \"\"\"\n+    return [max(values_i) for values_i in zip(*values)]\n+\n+\n+def get_max_height_width(\n+    images_list: List[List[np.ndarray]], input_data_format: Optional[Union[str, ChannelDimension]] = None\n+) -> List[int]:\n+    \"\"\"\n+    Get the maximum height and width across all images in a batch.\n+    \"\"\"\n+    if input_data_format is None:\n+        input_data_format = infer_channel_dimension_format(images_list[0][0], num_channels=(1, 3, 4))\n+\n+    max_height = max_width = float(\"-inf\")\n+    for images in images_list:\n+        for image in images:\n+            height, width = get_image_size(image, channel_dim=input_data_format)\n+            max_height = max(height, max_height)\n+            max_width = max(width, max_width)\n+    return (max_height, max_width)\n+\n+\n+# Copied from transformers.models.detr.image_processing_detr.make_pixel_mask\n+def make_pixel_mask(\n+    image: np.ndarray, output_size: Tuple[int, int], input_data_format: Optional[Union[str, ChannelDimension]] = None\n+) -> np.ndarray:\n+    \"\"\"\n+    Make a pixel mask for the image, where 1 indicates a valid pixel and 0 indicates padding.\n+    Args:\n+        image (`np.ndarray`):\n+            Image to make the pixel mask for.\n+        output_size (`Tuple[int, int]`):\n+            Output size of the mask.\n+    \"\"\"\n+    input_height, input_width = get_image_size(image, channel_dim=input_data_format)\n+    mask = np.zeros(output_size, dtype=np.int64)\n+    mask[:input_height, :input_width] = 1\n+    return mask\n+\n+\n+def convert_to_rgb(\n+    image: np.ndarray,\n+    palette: Optional[PIL.ImagePalette.ImagePalette] = None,\n+    data_format: Optional[Union[str, ChannelDimension]] = None,\n+    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+) -> ImageInput:\n+    \"\"\"\n+    Converts an image to RGB format.\n+    Args:\n+        image (`np.ndarray`):\n+            The image to convert.\n+        palette (List[int], *optional*):\n+            The palette to use if given.\n+        data_format (ChannelDimension or str, *optional*):\n+            The channel dimension format for the output image. If not provided, it will be the same as the input image.\n+        input_data_format (ChannelDimension or str, *optional*):\n+            The channel dimension format of the input image.\n+    \"\"\"\n+    if input_data_format is None:\n+        input_data_format = infer_channel_dimension_format(image, num_channels=(1, 3, 4))\n+\n+    # For all transformations, we want to keep the same data format as the input image unless otherwise specified.\n+    # The resized image from PIL will always have channels last, so find the input format first.\n+    data_format = input_data_format if data_format is None else data_format\n+\n+    mode = \"P\" if palette is not None else None\n+    image = to_pil_image(image, image_mode=mode)\n+    if image.mode == \"P\" and palette is not None:\n+        image.putpalette(palette)\n+\n+    image_rgba = image.convert(\"RGBA\")\n+    background = Image.new(\"RGBA\", image_rgba.size, (255, 255, 255))\n+    alpha_composite = Image.alpha_composite(background, image_rgba)\n+    alpha_composite = alpha_composite.convert(\"RGB\")\n+\n+    output_array = np.array(alpha_composite)\n+    # The image is always in channels last format after converting from a PIL image\n+    output_array = to_channel_dimension_format(output_array, data_format, input_channel_dim=ChannelDimension.LAST)\n+    return output_array\n+\n+\n+# FIXME Amy: make a more general crop function that isn't just centre crop\n+def _crop(\n+    image: np.ndarray,\n+    w1: int,\n+    h1: int,\n+    w2: int,\n+    h2: int,\n+    data_format: Optional[Union[str, ChannelDimension]] = None,\n+) -> np.ndarray:\n+    if data_format is None:\n+        data_format = infer_channel_dimension_format(image, num_channels=(1, 3, 4))\n+\n+    if data_format == ChannelDimension.FIRST:\n+        image = image[:, h1:h2, w1:w2]\n+    elif data_format == ChannelDimension.LAST:\n+        image = image[h1:h2, w1:w2, :]\n+    else:\n+        raise ValueError(\"Invalid channel dimension format.\")\n+\n+    return image\n+\n+\n+class Idefics3ImageProcessor(BaseImageProcessor):\n+    r\"\"\"\n+    Constructs a Idefics3 image processor.\n+    Args:\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB. This is useful if the input image is of a different format e.g. RGBA.\n+            Only has an effect if the input image is in the PIL format.\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image. The longest edge of the image is resized to  be <= `size[\"longest_edge\"]`, with the\n+            shortest edge resized to keep the input aspect ratio.\n+        size (`Dict`, *optional*, defaults to `{\"longest_edge\": 4 * 364}`):\n+            Controls the size of the output image. This is a dictionary containing the key \"longest_edge\".\n+            The image will be resized such that the longest edge is <= `size[\"longest_edge\"]` and the shortest edge is resized\n+            to keep the input aspect ratio.\n+        resample (`Resampling`, *optional*, defaults to `Resampling.LANCZOS`):\n+            Resampling filter to use when resizing the image.\n+        do_image_splitting (`bool`, *optional*, defaults to `True`):\n+            Whether to split the image into sub-images concatenated with the original image. They are split into patches\n+            such that each patch has a size of `max_image_size[\"height\"]` x `max_image_size[\"width\"]`.\n+        max_image_size (`Dict`, *optional*, defaults to `{\"longest_edge\": 364}`):\n+            Maximum resolution of the patches of images accepted by the model. This is a dictionary containing the key \"longest_edge\".\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image. If set to `True`, the image is rescaled to have pixel values between 0 and 1.\n+        rescale_factor (`float`, *optional*, defaults to `1/255`):\n+            Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image. If set to `True`, the image is normalized to have a mean of `image_mean` and\n+            a standard deviation of `image_std`.\n+        image_mean (`float` or `List[float]`, *optional*, defaults to `IDEFICS_STANDARD_MEAN`):\n+            Mean to use if normalizing the image. This is a float or list of floats the length of the number of\n+            channels in the image. Can be overridden by the `image_mean` parameter in the `preprocess` method. Can be\n+            overridden by the `image_mean` parameter in the `preprocess` method.\n+        image_std (`float` or `List[float]`, *optional*, defaults to `IDEFICS_STANDARD_STD`):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats the length of the\n+            number of channels in the image. Can be overridden by the `image_std` parameter in the `preprocess` method.\n+            Can be overridden by the `image_std` parameter in the `preprocess` method.\n+        do_pad (`bool`, *optional*, defaults to `True`):\n+            Whether or not to pad the images to the largest height and width in the batch and number of images per\n+            sample in the batch, such that the returned tensor is of shape (batch_size, max_num_images, num_channels, max_height, max_width).\n+    \"\"\"\n+\n+    model_input_names = [\"pixel_values\"]\n+\n+    def __init__(\n+        self,\n+        do_convert_rgb: bool = True,\n+        do_resize: bool = True,\n+        size: Dict[str, int] = None,\n+        resample: PILImageResampling = PILImageResampling.LANCZOS,\n+        do_image_splitting: bool = True,\n+        max_image_size: Dict[str, int] = None,\n+        do_rescale: bool = True,\n+        rescale_factor: float = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_pad: bool = True,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        self.do_convert_rgb = do_convert_rgb\n+        self.do_resize = do_resize\n+        self.size = size if size is not None else {\"longest_edge\": 4 * 364}\n+        self.resample = resample\n+        self.do_image_splitting = do_image_splitting\n+        self.max_image_size = max_image_size if max_image_size is not None else {\"longest_edge\": 364}\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean if image_mean is not None else IMAGENET_STANDARD_MEAN\n+        self.image_std = image_std if image_std is not None else IMAGENET_STANDARD_STD\n+        self.do_pad = do_pad\n+\n+    def resize(\n+        self,\n+        image: np.ndarray,\n+        size: Dict[str, int],\n+        resample: PILImageResampling = PILImageResampling.LANCZOS,\n+        data_format: Optional[Union[str, ChannelDimension]] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+        **kwargs,\n+    ) -> np.ndarray:\n+        \"\"\"\n+        Resize an image. The longest edge of the image is resized to size[\"longest_edge\"], with the shortest edge\n+        resized to keep the input aspect ratio. Can also be used with size[\"height\"] and size[\"width\"].\n+        Args:\n+            image (`np.ndarray`):\n+                Image to resize.\n+            size (`Dict[str, int]`):\n+                Size of the output image.\n+            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.LANCZOS`):\n+                Resampling filter to use when resizing the image.\n+            data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the output image. If not provided, it will be the same as the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the input image. If not provided, it will be inferred.\n+        \"\"\"\n+        if input_data_format is None:\n+            input_data_format = infer_channel_dimension_format(image, num_channels=(1, 3, 4))\n+\n+        # For all transformations, we want to keep the same data format as the input image unless otherwise specified.\n+        # The resized image from PIL will always have channels last, so find the input format first.\n+        data_format = input_data_format if data_format is None else data_format\n+\n+        if \"longest_edge\" in size:\n+            size = get_resize_output_image_size(\n+                image, resolution_max_side=size[\"longest_edge\"], input_data_format=input_data_format\n+            )\n+        elif \"height\" in size and \"width\" in size:\n+            size = (size[\"height\"], size[\"width\"])\n+        else:\n+            raise ValueError(\"size must be a dictionary with key 'longest_edge' or 'height' and 'width'.\")\n+\n+        image_mode = None\n+        if image.ndim == 2 or image.shape[-1] == 1:\n+            image_mode = \"P\"\n+        image = to_pil_image(image, image_mode=image_mode)\n+\n+        resized_image = image.resize((size[1], size[0]), resample=resample)\n+        resized_image = np.array(resized_image)\n+\n+        # If the input image channel dimension was of size 1, then it is dropped when converting to a PIL image\n+        # so we need to add it back if necessary.\n+        resized_image = np.expand_dims(resized_image, axis=-1) if resized_image.ndim == 2 else resized_image\n+        # The image is always in channels last format after converting from a PIL image\n+        resized_image = to_channel_dimension_format(\n+            resized_image, data_format, input_channel_dim=ChannelDimension.LAST\n+        )\n+        return resized_image\n+\n+    def split_image(\n+        self,\n+        image,\n+        max_image_size: Dict[str, int],\n+        resample: PILImageResampling = PILImageResampling.LANCZOS,\n+        data_format: Optional[Union[str, ChannelDimension]] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Split an image into squares of side max_image_size and the original image resized to max_image_size.\n+        That means that a single image becomes a sequence of images.\n+        This is a \"trick\" to spend more compute on each image with no changes in the vision encoder.\n+        1) If one side of the original image is larger than `max_image_size`, resize it to `max_image_size` while preserving the aspect ratio.\n+        2) Divide the resulting image into `ceil(height / max_image_size)` x `ceil(width / max_image_size)`\n+        sub-images of the same size each (image_size, image_size). Typically, 364x364.\n+        3) Returns the list of the crops and the original image, in addition to the number of splits for the height and the width.\n+        Args:\n+            image (`np.ndarray`):\n+                Images to split.\n+            max_image_size (`Dict[str, int]`):\n+                Maximum size of the output image. If the image is larger than this size, it will be split into\n+                patches of this size, and the original image will be concatenated with the patches, resized to max_size.\n+            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.LANCZOS`):\n+                Resampling filter to use when resizing the image.\n+            data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the output image. If not provided, it will be the same as the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the input image. If not provided, it will be inferred.\n+        \"\"\"\n+        height, width = get_image_size(image, channel_dim=input_data_format)\n+        max_height = max_width = max_image_size[\"longest_edge\"]\n+\n+        frames = []\n+        if height > max_height or width > max_width:\n+            # Calculate the number of splits\n+            num_splits_h = math.ceil(height / max_height)\n+            num_splits_w = math.ceil(width / max_width)\n+            # Calculate the optimal width and height for the sub-images\n+            optimal_height = math.ceil(height / num_splits_h)\n+            optimal_width = math.ceil(width / num_splits_w)\n+\n+            # Iterate through each row and column\n+            for r in range(num_splits_h):\n+                for c in range(num_splits_w):\n+                    # Calculate the starting point of the crop\n+                    start_x = c * optimal_width\n+                    start_y = r * optimal_height\n+\n+                    # Calculate the ending point of the crop\n+                    end_x = min(start_x + optimal_width, width)\n+                    end_y = min(start_y + optimal_height, height)\n+\n+                    # Crop the image\n+                    cropped_image = _crop(\n+                        image,\n+                        start_x,\n+                        start_y,\n+                        end_x,\n+                        end_y,\n+                        data_format=data_format,\n+                    )\n+                    frames.append(cropped_image)\n+\n+            # For the global image at the end, we resize it to match the max_image_size, for cpu memory efficiency\n+            global_image_height, global_image_width = max_height, max_width\n+            if height != global_image_height or width != global_image_width:\n+                image = self.resize(\n+                    image,\n+                    {\"height\": global_image_height, \"width\": global_image_width},\n+                    resample=resample,\n+                    input_data_format=data_format,\n+                )\n+        else:\n+            num_splits_h, num_splits_w = 0, 0\n+\n+        frames.append(image)\n+\n+        return frames, num_splits_h, num_splits_w\n+\n+    def resize_for_vision_encoder(\n+        self,\n+        image: np.ndarray,\n+        vision_encoder_max_size: int,\n+        resample: PILImageResampling = PILImageResampling.LANCZOS,\n+        data_format: Optional[Union[str, ChannelDimension]] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Resize images to be multiples of `vision_encoder_max_size` while preserving the aspect ratio.\n+        Args:\n+            image (`np.ndarray`):\n+                Images to resize.\n+            vision_encoder_max_size (`int`):\n+                Maximum size of the output image. If the image is larger than this size, it will be split into\n+                patches of this size, and the original image will be concatenated with the patches, resized to max_size.\n+            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.LANCZOS`):\n+                Resampling filter to use when resizing the image.\n+            data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the output image. If not provided, it will be the same as the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the input image. If not provided, it will be inferred\n+        \"\"\"\n+        height, width = get_image_size(image, channel_dim=input_data_format)\n+\n+        aspect_ratio = width / height\n+        if width >= height:\n+            width = math.ceil(width / vision_encoder_max_size) * vision_encoder_max_size\n+            height = int(width / aspect_ratio)\n+            height = math.ceil(height / vision_encoder_max_size) * vision_encoder_max_size\n+        elif height > width:\n+            height = math.ceil(height / vision_encoder_max_size) * vision_encoder_max_size\n+            width = int(height * aspect_ratio)\n+            width = math.ceil(width / vision_encoder_max_size) * vision_encoder_max_size\n+        new_size = {\"height\": height, \"width\": width}\n+        return self.resize(\n+            image, size=new_size, resample=resample, input_data_format=input_data_format, data_format=data_format\n+        )\n+\n+    def _pad_image(\n+        self,\n+        image: np.ndarray,\n+        output_size: Tuple[int, int],\n+        constant_values: Union[float, Iterable[float]] = 0,\n+        data_format: Optional[ChannelDimension] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ) -> np.ndarray:\n+        \"\"\"\n+        Pad an image with zeros to the given size.\n+        \"\"\"\n+        input_height, input_width = get_image_size(image, channel_dim=input_data_format)\n+        output_height, output_width = output_size\n+\n+        pad_bottom = output_height - input_height\n+        pad_right = output_width - input_width\n+        padding = ((0, pad_bottom), (0, pad_right))\n+        padded_image = pad(\n+            image,\n+            padding,\n+            mode=PaddingMode.CONSTANT,\n+            constant_values=constant_values,\n+            data_format=data_format,\n+            input_data_format=input_data_format,\n+        )\n+        return padded_image\n+\n+    def pad(\n+        self,\n+        images: List[np.ndarray],\n+        constant_values: Union[float, Iterable[float]] = 0,\n+        return_pixel_mask: bool = True,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        data_format: Optional[ChannelDimension] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ) -> BatchFeature:\n+        \"\"\"\n+        For a list of images, for each images, pads a batch of images to the bottom and right of the image with zeros to the size of largest height and width.\n+        For each sample in the batch, pads the sample with empty images to the max_number of images per sample in the batch. Optionally returns a pixel mask.\n+        Args:\n+            images (`List[np.ndarray]`):\n+                List of list of images to pad. Pads to the largest height and width in the batch.\n+            constant_values (`float` or `Iterable[float]`, *optional*):\n+                The value to use for the padding if `mode` is `\"constant\"`.\n+            return_pixel_mask (`bool`, *optional*, defaults to `True`):\n+                Whether to return a pixel mask.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                    - Unset: Return a list of `np.ndarray`.\n+                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n+                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n+            data_format (`str` or `ChannelDimension`, *optional*):\n+                The channel dimension format of the image. If not provided, it will be the same as the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the input image. If not provided, it will be inferred.\n+        \"\"\"\n+        pad_size = get_max_height_width(images, input_data_format=input_data_format)\n+\n+        batch_size = len(images)\n+        max_num_images = max(len(images_) for images_ in images)\n+        input_data_format = (\n+            infer_channel_dimension_format(images[0][0], num_channels=(1, 3, 4))\n+            if input_data_format is None\n+            else input_data_format\n+        )\n+        data_format = input_data_format if data_format is None else data_format\n+\n+        if input_data_format == ChannelDimension.FIRST:\n+            n_channels = images[0][0].shape[0]\n+        elif input_data_format == ChannelDimension.LAST:\n+            n_channels = images[0][0].shape[-1]\n+        else:\n+            raise ValueError(\"Invalid channel dimension format.\")\n+\n+        def empty_image(size, input_data_format):\n+            if input_data_format == ChannelDimension.FIRST:\n+                return np.zeros((n_channels, *size), dtype=np.uint8)\n+            elif input_data_format == ChannelDimension.LAST:\n+                return np.zeros((*size, n_channels), dtype=np.uint8)\n+\n+        padded_images_list = [\n+            [empty_image(pad_size, data_format) for _ in range(max_num_images)] for _ in range(batch_size)\n+        ]\n+        padded_masks = [[np.zeros(pad_size) for _ in range(max_num_images)] for _ in range(batch_size)]\n+\n+        for batch_idx in range(batch_size):\n+            for sample_idx, image in enumerate(images[batch_idx]):\n+                padded_images_list[batch_idx][sample_idx] = self._pad_image(\n+                    image,\n+                    pad_size,\n+                    constant_values=constant_values,\n+                    data_format=data_format,\n+                    input_data_format=input_data_format,\n+                )\n+                padded_masks[batch_idx][sample_idx] = make_pixel_mask(\n+                    image, output_size=pad_size, input_data_format=input_data_format\n+                )\n+\n+        padded_masks = padded_masks if return_pixel_mask else None\n+        return padded_images_list, padded_masks\n+\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        do_convert_rgb: Optional[bool] = None,\n+        do_resize: Optional[bool] = None,\n+        size: Optional[Dict[str, int]] = None,\n+        resample: PILImageResampling = None,\n+        do_image_splitting: Optional[bool] = None,\n+        do_rescale: Optional[bool] = None,\n+        max_image_size: Optional[Dict[str, int]] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_pad: Optional[bool] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        return_row_col_info: bool = False,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Preprocess a batch of images.\n+        Args:\n+            images (`ImageInput`):\n+                A list of images to preprocess.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. With the longest edge resized to keep the input aspect ratio.\n+            resample (`int`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n+                has an effect if `do_resize` is set to `True`.\n+            do_image_splitting (`bool`, *optional*, defaults to `self.do_image_splitting`):\n+                Whether to split the image into sub-images concatenated with the original image. They are split into patches\n+                such that each patch has a size of `max_image_size[\"height\"]` x `max_image_size[\"width\"]`.\n+            max_image_size (`Dict`, *optional*, defaults to `self.max_image_size`):\n+                Maximum resolution of the images. If the image is larger than this size, the image is split into patches.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n+                `True`.\n+            do_pad (`bool`, *optional*, defaults to `self.do_pad`):\n+                Whether or not to pad the images to the largest height and width in the batch.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                - Unset: Return a list of `np.ndarray`.\n+                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n+                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n+            return_row_col_info (`bool`, *optional*, default to `False`):\n+                Whether to return the number of rows and columns of the split images. This is used for the\n+                `Idefics3Processor` to generate prompt strings based on the number of rows and columns.\n+            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n+                from the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+        do_resize = do_resize if do_resize is not None else self.do_resize\n+        size = size if size is not None else self.size\n+        resample = resample if resample is not None else self.resample\n+        do_rescale = do_rescale if do_rescale is not None else self.do_rescale\n+        rescale_factor = rescale_factor if rescale_factor is not None else self.rescale_factor\n+        do_image_splitting = do_image_splitting if do_image_splitting is not None else self.do_image_splitting\n+        max_image_size = max_image_size if max_image_size is not None else self.max_image_size\n+        do_normalize = do_normalize if do_normalize is not None else self.do_normalize\n+        image_mean = image_mean if image_mean is not None else self.image_mean\n+        image_std = image_std if image_std is not None else self.image_std\n+        do_convert_rgb = do_convert_rgb if do_convert_rgb is not None else self.do_convert_rgb\n+        do_pad = do_pad if do_pad is not None else self.do_pad\n+\n+        images_list = make_list_of_images(images)\n+\n+        if not valid_images(images_list[0]):\n+            raise ValueError(\n+                \"Invalid image type. Must be of type PIL.Image.Image, numpy.ndarray, \"\n+                \"torch.Tensor, tf.Tensor or jax.ndarray.\"\n+            )\n+\n+        validate_preprocess_arguments(\n+            do_rescale=do_rescale,\n+            rescale_factor=rescale_factor,\n+            do_normalize=do_normalize,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            do_resize=do_resize,\n+            size=size,\n+            resample=resample,\n+        )\n+\n+        # save the palettes for conversion to RGB\n+        palettes_list = [\n+            [im.getpalette() if isinstance(im, Image.Image) and im.mode == \"P\" else None for im in images]\n+            for images in images_list\n+        ]\n+\n+        # All transformations expect numpy arrays.\n+        images_list = [[to_numpy_array(image) for image in images] for images in images_list]\n+\n+        if is_scaled_image(images_list[0][0]) and do_rescale:\n+            logger.warning_once(\n+                \"It looks like you are trying to rescale already rescaled images. If the input\"\n+                \" images have pixel values between 0 and 1, set `do_rescale=False` to avoid rescaling them again.\"\n+            )\n+\n+        # We assume that all images have the same channel dimension format.\n+        if input_data_format is None:\n+            input_data_format = infer_channel_dimension_format(images_list[0][0], num_channels=(1, 3, 4))\n+\n+        # Extra channel dimension for grayscale images\n+        if input_data_format == ChannelDimension.LAST:\n+            images_list = [\n+                [np.expand_dims(img, axis=-1) if img.ndim == 2 else img for img in images] for images in images_list\n+            ]\n+        elif input_data_format == ChannelDimension.FIRST:\n+            images_list = [\n+                [np.expand_dims(img, axis=0) if img.ndim == 2 else img for img in images] for images in images_list\n+            ]\n+        else:\n+            raise ValueError(f\"Invalid channel dimension format {input_data_format}.\")\n+\n+        if do_resize:\n+            images_list = [\n+                [\n+                    self.resize(image=image, size=size, resample=resample, input_data_format=input_data_format)\n+                    for image in images\n+                ]\n+                for images in images_list\n+            ]\n+\n+        if do_image_splitting:\n+            # We first resize both height and width of each image to the nearest max_image_size multiple, disregarding the aspect ratio\n+            # for size=(10, max_image_size) -> rescaled_size=(max_image_size, max_image_size)\n+            # for size=(11, max_image_size+1) -> rescaled_size=(max_image_size, max_image_size*2)\n+            images_list = [\n+                [\n+                    self.resize_for_vision_encoder(\n+                        image, max_image_size[\"longest_edge\"], resample=resample, input_data_format=input_data_format\n+                    )\n+                    for image in images\n+                ]\n+                for images in images_list\n+            ]\n+            images_list_split_arrays = []\n+            palettes_list_split_arrays = []\n+            images_list_rows = []\n+            images_list_cols = []\n+            for images, palettes in zip(images_list, palettes_list):\n+                split_image_arrays = []\n+                split_palettes_arrays = []\n+                image_rows = []\n+                image_cols = []\n+                for image, palette in zip(images, palettes):\n+                    split_image_array, rows, cols = self.split_image(\n+                        image,\n+                        max_image_size=max_image_size,\n+                        input_data_format=input_data_format,\n+                    )\n+                    split_image_arrays.extend(split_image_array)\n+                    split_palettes_arrays.extend([palette] * len(split_image_array))\n+                    image_rows.append(rows)\n+                    image_cols.append(cols)\n+                images_list_split_arrays.append(split_image_arrays)\n+                palettes_list_split_arrays.append(split_palettes_arrays)\n+                images_list_rows.append(image_rows)\n+                images_list_cols.append(image_cols)\n+            images_list = images_list_split_arrays\n+            palettes_list = palettes_list_split_arrays\n+        else:\n+            # We square the images to max_image_size\n+            images_list = [\n+                [\n+                    self.resize(\n+                        image=image,\n+                        size={\"height\": max_image_size[\"longest_edge\"], \"width\": max_image_size[\"longest_edge\"]},\n+                        resample=resample,\n+                        input_data_format=input_data_format,\n+                    )\n+                    for image in images\n+                ]\n+                for images in images_list\n+            ]\n+            images_list_rows = [[0] * len(images) for images in images_list]\n+            images_list_cols = [[0] * len(images) for images in images_list]\n+\n+        if do_convert_rgb:\n+            images_list = [\n+                [convert_to_rgb(img, palette) for img, palette in zip(images, palettes)]\n+                for images, palettes in zip(images_list, palettes_list)\n+            ]\n+\n+        if do_rescale:\n+            images_list = [\n+                [self.rescale(image, rescale_factor, input_data_format=input_data_format) for image in images]\n+                for images in images_list\n+            ]\n+\n+        if do_normalize:\n+            images_list = [\n+                [\n+                    self.normalize(image=image, mean=image_mean, std=image_std, input_data_format=input_data_format)\n+                    for image in images\n+                ]\n+                for images in images_list\n+            ]\n+\n+        pixel_attention_mask = None\n+        if do_pad:\n+            images_list, pixel_attention_mask = self.pad(\n+                images_list, return_pixel_mask=True, return_tensors=return_tensors, input_data_format=input_data_format\n+            )\n+\n+        if data_format is not None:\n+            images_list = [\n+                [\n+                    to_channel_dimension_format(image, data_format, input_channel_dim=input_data_format)\n+                    for image in images\n+                ]\n+                for images in images_list\n+            ]\n+\n+        # Faster tensor conversion\n+        data = {\"pixel_values\": np.array(images_list) if do_pad and return_tensors is not None else images_list}\n+        if pixel_attention_mask is not None:\n+            data[\"pixel_attention_mask\"] = (\n+                np.array(pixel_attention_mask) if do_pad and return_tensors is not None else pixel_attention_mask\n+            )\n+\n+        encoding = BatchFeature(data=data, tensor_type=return_tensors)\n+\n+        # This is needed for generating correct text inputs in the processor - we don't pad to the max number of images\n+        if return_row_col_info:\n+            encoding[\"rows\"] = images_list_rows\n+            encoding[\"cols\"] = images_list_cols\n+\n+        return encoding"
        },
        {
            "sha": "bd64e5db681b713f2a1a756a79868ff153bdd88b",
            "filename": "src/transformers/models/idefics3/modeling_idefics3.py",
            "status": "added",
            "additions": 1323,
            "deletions": 0,
            "changes": 1323,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics3%2Fmodeling_idefics3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics3%2Fmodeling_idefics3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fidefics3%2Fmodeling_idefics3.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -0,0 +1,1323 @@\n+# coding=utf-8\n+# Copyright 2024 the HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch Idefics3 model.\"\"\"\n+\n+from dataclasses import dataclass\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+import torch.utils.checkpoint\n+from torch import nn\n+from torch.nn import CrossEntropyLoss\n+\n+from ... import PreTrainedModel\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache\n+from ...modeling_attn_mask_utils import _prepare_4d_attention_mask\n+from ...modeling_outputs import BaseModelOutput, ModelOutput\n+from ...utils import (\n+    add_start_docstrings,\n+    add_start_docstrings_to_model_forward,\n+    is_flash_attn_2_available,\n+    is_flash_attn_greater_or_equal_2_10,\n+    logging,\n+    replace_return_docstrings,\n+)\n+from ..auto import AutoModel\n+from .configuration_idefics3 import Idefics3Config, Idefics3VisionConfig\n+\n+\n+if is_flash_attn_2_available():\n+    from ...modeling_flash_attention_utils import _flash_attention_forward\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+_CONFIG_FOR_DOC = \"Idefics3Config\"\n+\n+\n+@dataclass\n+class Idefics3BaseModelOutputWithPast(ModelOutput):\n+    \"\"\"\n+    Base class for Idefics3 model's outputs that may also contain a past key/values (to speed up sequential decoding).\n+    Args:\n+        last_hidden_state (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`):\n+            Sequence of hidden-states at the output of the last layer of the model.\n+            If `past_key_values` is used only the last hidden-state of the sequences of shape `(batch_size, 1,\n+            hidden_size)` is output.\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`) and optionally if\n+            `config.is_encoder_decoder=True` 2 additional tensors of shape `(batch_size, num_heads,\n+            encoder_sequence_length, embed_size_per_head)`.\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks and optionally if\n+            `config.is_encoder_decoder=True` in the cross-attention blocks) that can be used (see `past_key_values`\n+            input) to speed up sequential decoding.\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        image_hidden_states (`tuple(torch.FloatTensor)`, *optional*):\n+            Tuple of `torch.FloatTensor` (one for the output of the image embeddings, `(batch_size, num_images,\n+            sequence_length, hidden_size)`.\n+            image_hidden_states of the model produced by the vision encoder\n+    \"\"\"\n+\n+    last_hidden_state: torch.FloatTensor = None\n+    past_key_values: Optional[Tuple[Tuple[torch.FloatTensor]]] = None\n+    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+    attentions: Optional[Tuple[torch.FloatTensor]] = None\n+    image_hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+\n+\n+@dataclass\n+class Idefics3CausalLMOutputWithPast(ModelOutput):\n+    \"\"\"\n+    Base class for Idefics causal language model (or autoregressive) outputs.\n+\n+    Args:\n+        loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+            Language modeling loss (for next-token prediction).\n+        logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n+            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+            `past_key_values` input) to speed up sequential decoding.\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        image_hidden_states (`tuple(torch.FloatTensor)`, *optional*):\n+            Tuple of `torch.FloatTensor` (one for the output of the image embeddings, `(batch_size, num_images,\n+            sequence_length, hidden_size)`.\n+            image_hidden_states of the model produced by the vision encoder\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: torch.FloatTensor = None\n+    past_key_values: Optional[List[torch.FloatTensor]] = None\n+    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+    attentions: Optional[Tuple[torch.FloatTensor]] = None\n+    image_hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+\n+\n+# Copied from transformers.models.idefics2.modeling_idefics2.Idefics2VisionEmbeddings with Idefics2->Idefics3\n+class Idefics3VisionEmbeddings(nn.Module):\n+    \"\"\"\n+    This is a modified version of `siglip.modelign_siglip.SiglipVisionEmbeddings` to enable images of variable\n+    resolution.\n+\n+    The modifications are adapted from [Patch n' Pack: NaViT, a Vision Transformer for any Aspect Ratio and Resolution](https://arxiv.org/abs/2307.06304)\n+    which allows treating images in their native aspect ratio and without the need to resize them to the same\n+    fixed size. In particular, we start from the original pre-trained SigLIP model\n+    (which uses images of fixed-size square images) and adapt it by training on images of variable resolutions.\n+    \"\"\"\n+\n+    def __init__(self, config: Idefics3VisionConfig):\n+        super().__init__()\n+        self.embed_dim = config.hidden_size\n+        self.image_size = config.image_size\n+        self.patch_size = config.patch_size\n+\n+        self.patch_embedding = nn.Conv2d(\n+            in_channels=config.num_channels,\n+            out_channels=self.embed_dim,\n+            kernel_size=self.patch_size,\n+            stride=self.patch_size,\n+            padding=\"valid\",\n+        )\n+\n+        self.num_patches_per_side = self.image_size // self.patch_size\n+        self.num_patches = self.num_patches_per_side**2\n+        self.num_positions = self.num_patches\n+        self.position_embedding = nn.Embedding(self.num_positions, self.embed_dim)\n+\n+    def forward(self, pixel_values: torch.FloatTensor, patch_attention_mask: torch.BoolTensor) -> torch.Tensor:\n+        batch_size, _, max_im_h, max_im_w = pixel_values.shape\n+\n+        patch_embeds = self.patch_embedding(pixel_values)\n+        embeddings = patch_embeds.flatten(2).transpose(1, 2)\n+\n+        max_nb_patches_h, max_nb_patches_w = max_im_h // self.patch_size, max_im_w // self.patch_size\n+        boundaries = torch.arange(1 / self.num_patches_per_side, 1.0, 1 / self.num_patches_per_side)\n+        position_ids = torch.full(size=(batch_size, max_nb_patches_h * max_nb_patches_w), fill_value=0)\n+\n+        for batch_idx, p_attn_mask in enumerate(patch_attention_mask):\n+            nb_patches_h = p_attn_mask[:, 0].sum()\n+            nb_patches_w = p_attn_mask[0].sum()\n+\n+            fractional_coords_h = torch.arange(0, 1 - 1e-6, 1 / nb_patches_h)\n+            fractional_coords_w = torch.arange(0, 1 - 1e-6, 1 / nb_patches_w)\n+\n+            bucket_coords_h = torch.bucketize(fractional_coords_h, boundaries, right=True)\n+            bucket_coords_w = torch.bucketize(fractional_coords_w, boundaries, right=True)\n+\n+            pos_ids = (bucket_coords_h[:, None] * self.num_patches_per_side + bucket_coords_w).flatten()\n+            position_ids[batch_idx][p_attn_mask.view(-1).cpu()] = pos_ids\n+\n+        position_ids = position_ids.to(self.position_embedding.weight.device)\n+        embeddings = embeddings + self.position_embedding(position_ids)\n+        return embeddings\n+\n+\n+# Copied from transformers.models.siglip.modeling_siglip.SiglipAttention with Siglip->Idefics3Vision\n+class Idefics3VisionAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    # Copied from transformers.models.clip.modeling_clip.CLIPAttention.__init__\n+    def __init__(self, config):\n+        super().__init__()\n+        self.config = config\n+        self.embed_dim = config.hidden_size\n+        self.num_heads = config.num_attention_heads\n+        self.head_dim = self.embed_dim // self.num_heads\n+        if self.head_dim * self.num_heads != self.embed_dim:\n+            raise ValueError(\n+                f\"embed_dim must be divisible by num_heads (got `embed_dim`: {self.embed_dim} and `num_heads`:\"\n+                f\" {self.num_heads}).\"\n+            )\n+        self.scale = self.head_dim**-0.5\n+        self.dropout = config.attention_dropout\n+\n+        self.k_proj = nn.Linear(self.embed_dim, self.embed_dim)\n+        self.v_proj = nn.Linear(self.embed_dim, self.embed_dim)\n+        self.q_proj = nn.Linear(self.embed_dim, self.embed_dim)\n+        self.out_proj = nn.Linear(self.embed_dim, self.embed_dim)\n+\n+        # Ignore copy\n+        self.is_causal = False\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        output_attentions: Optional[bool] = False,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor]]:\n+        \"\"\"Input shape: Batch x Time x Channel\"\"\"\n+\n+        batch_size, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(batch_size, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(batch_size, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(batch_size, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+\n+        k_v_seq_len = key_states.shape[-2]\n+        attn_weights = torch.matmul(query_states, key_states.transpose(2, 3)) * self.scale\n+\n+        if attn_weights.size() != (batch_size, self.num_heads, q_len, k_v_seq_len):\n+            raise ValueError(\n+                f\"Attention weights should be of size {(batch_size, self.num_heads, q_len, k_v_seq_len)}, but is\"\n+                f\" {attn_weights.size()}\"\n+            )\n+\n+        if attention_mask is not None:\n+            if attention_mask.size() != (batch_size, 1, q_len, k_v_seq_len):\n+                raise ValueError(\n+                    f\"Attention mask should be of size {(batch_size, 1, q_len, k_v_seq_len)}, but is {attention_mask.size()}\"\n+                )\n+            attn_weights = attn_weights + attention_mask\n+\n+        # upcast attention to fp32\n+        attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query_states.dtype)\n+        attn_weights = nn.functional.dropout(attn_weights, p=self.dropout, training=self.training)\n+        attn_output = torch.matmul(attn_weights, value_states)\n+\n+        if attn_output.size() != (batch_size, self.num_heads, q_len, self.head_dim):\n+            raise ValueError(\n+                f\"`attn_output` should be of size {(batch_size, self.num_heads, q_len, self.head_dim)}, but is\"\n+                f\" {attn_output.size()}\"\n+            )\n+\n+        attn_output = attn_output.transpose(1, 2).contiguous()\n+        attn_output = attn_output.reshape(batch_size, q_len, self.embed_dim)\n+\n+        attn_output = self.out_proj(attn_output)\n+\n+        return attn_output, attn_weights\n+\n+\n+# Copied from transformers.models.idefics2.modeling_idefics2.Idefics2VisionFlashAttention2 with Idefics2->Idefics3\n+class Idefics3VisionFlashAttention2(Idefics3VisionAttention):\n+    \"\"\"\n+    Idefics3Vision flash attention module. This module inherits from `Idefics3VisionAttention` as the weights of the module stays\n+    untouched. The only required change would be on the forward pass where it needs to correctly call the public API of\n+    flash attention and deal with padding tokens in case the input contains any of them.\n+    \"\"\"\n+\n+    # Copied from transformers.models.llama.modeling_llama.LlamaFlashAttention2.__init__\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        # TODO: Should be removed once Flash Attention for RoCm is bumped to 2.1.\n+        # flash_attn<2.1 generates top-left aligned causal mask, while what is needed here is bottom-right alignement, that was made default for flash_attn>=2.1. This attribute is used to handle this difference. Reference: https://github.com/Dao-AILab/flash-attention/releases/tag/v2.1.0.\n+        # Beware that with flash_attn<2.1, using q_seqlen != k_seqlen (except for the case q_seqlen == 1) produces a wrong mask (top-left).\n+        self._flash_attn_uses_top_left_mask = not is_flash_attn_greater_or_equal_2_10()\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.LongTensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        **kwargs,\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        output_attentions = False\n+\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        # Flash attention requires the input to have the shape\n+        # batch_size x seq_length x head_dim x hidden_dim\n+        # therefore we just need to keep the original shape\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim)\n+        key_states = key_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+\n+        kv_seq_len = key_states.shape[-2]\n+        if past_key_value is not None:\n+            kv_seq_len += past_key_value.get_usable_length(kv_seq_len, self.layer_idx)\n+\n+        # TODO: These transpose are quite inefficient but Flash Attention requires the layout [batch_size, sequence_length, num_heads, head_dim]. We would need to refactor the KV cache\n+        # to be able to avoid many of these transpose/reshape/view.\n+        key_states = key_states.transpose(1, 2)\n+        value_states = value_states.transpose(1, 2)\n+\n+        dropout_rate = self.dropout if self.training else 0.0\n+\n+        # In PEFT, usually we cast the layer norms in float32 for training stability reasons\n+        # therefore the input hidden states gets silently casted in float32. Hence, we need\n+        # cast them back in the correct dtype just to be sure everything works as expected.\n+        # This might slowdown training & inference so it is recommended to not cast the LayerNorms\n+        # in fp32. (Idefics3VisionRMSNorm handles it correctly)\n+\n+        input_dtype = query_states.dtype\n+        if input_dtype == torch.float32:\n+            if torch.is_autocast_enabled():\n+                target_dtype = torch.get_autocast_gpu_dtype()\n+            # Handle the case where the model is quantized\n+            elif hasattr(self.config, \"_pre_quantization_dtype\"):\n+                target_dtype = self.config._pre_quantization_dtype\n+            else:\n+                target_dtype = self.q_proj.weight.dtype\n+\n+            logger.warning_once(\n+                f\"The input hidden states seems to be silently casted in float32, this might be related to\"\n+                f\" the fact you have upcasted embedding or layer norm layers in float32. We will cast back the input in\"\n+                f\" {target_dtype}.\"\n+            )\n+\n+            query_states = query_states.to(target_dtype)\n+            key_states = key_states.to(target_dtype)\n+            value_states = value_states.to(target_dtype)\n+\n+        attn_output = _flash_attention_forward(\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            q_len,\n+            dropout=dropout_rate,\n+            is_causal=self.is_causal,\n+            use_top_left_mask=self._flash_attn_uses_top_left_mask,\n+        )\n+\n+        attn_output = attn_output.reshape(bsz, q_len, self.embed_dim).contiguous()\n+        attn_output = self.out_proj(attn_output)\n+\n+        if not output_attentions:\n+            attn_weights = None\n+\n+        return attn_output, attn_weights\n+\n+\n+IDEFICS_VISION_ATTENTION_CLASSES = {\n+    \"eager\": Idefics3VisionAttention,\n+    \"flash_attention_2\": Idefics3VisionFlashAttention2,\n+}\n+\n+\n+# Copied from transformers.models.siglip.modeling_siglip.SiglipMLP with Siglip->Idefics3Vision\n+class Idefics3VisionMLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.config = config\n+        self.activation_fn = ACT2FN[config.hidden_act]\n+        self.fc1 = nn.Linear(config.hidden_size, config.intermediate_size)\n+        self.fc2 = nn.Linear(config.intermediate_size, config.hidden_size)\n+\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        hidden_states = self.fc1(hidden_states)\n+        hidden_states = self.activation_fn(hidden_states)\n+        hidden_states = self.fc2(hidden_states)\n+        return hidden_states\n+\n+\n+class Idefics3SimpleMLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        input_size = config.vision_config.hidden_size * (config.scale_factor**2)\n+        output_size = config.text_config.hidden_size\n+        self.proj = nn.Linear(input_size, output_size, bias=False)\n+\n+    def forward(self, x):\n+        return self.proj(x)\n+\n+\n+# Copied from transformers.models.idefics2.modeling_idefics2.Idefics2EncoderLayer with Idefics2->Idefics3\n+class Idefics3EncoderLayer(nn.Module):\n+    def __init__(self, config: Idefics3VisionConfig):\n+        super().__init__()\n+        self.embed_dim = config.hidden_size\n+        self.self_attn = IDEFICS_VISION_ATTENTION_CLASSES[config._attn_implementation](config)\n+        self.layer_norm1 = nn.LayerNorm(self.embed_dim, eps=config.layer_norm_eps)\n+        self.mlp = Idefics3VisionMLP(config)\n+        self.layer_norm2 = nn.LayerNorm(self.embed_dim, eps=config.layer_norm_eps)\n+\n+    # Copied from transformers.models.siglip.modeling_siglip.SiglipEncoderLayer.forward\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: torch.Tensor,\n+        output_attentions: Optional[bool] = False,\n+    ) -> Tuple[torch.FloatTensor]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.FloatTensor`):\n+                Input to the layer of shape `(batch, seq_len, embed_dim)`.\n+            attention_mask (`torch.FloatTensor`):\n+                Attention mask of shape `(batch, 1, q_len, k_v_seq_len)` where padding elements are indicated by very large negative values.\n+            output_attentions (`bool`, *optional*, defaults to `False`):\n+                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n+                returned tensors for more detail.\n+        \"\"\"\n+        residual = hidden_states\n+\n+        hidden_states = self.layer_norm1(hidden_states)\n+        hidden_states, attn_weights = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            output_attentions=output_attentions,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        residual = hidden_states\n+        hidden_states = self.layer_norm2(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        outputs = (hidden_states,)\n+\n+        if output_attentions:\n+            outputs += (attn_weights,)\n+\n+        return outputs\n+\n+\n+# Copied from transformers.models.siglip.modeling_siglip.SiglipEncoder with Siglip->Idefics3\n+class Idefics3Encoder(nn.Module):\n+    \"\"\"\n+    Transformer encoder consisting of `config.num_hidden_layers` self attention layers. Each layer is a\n+    [`Idefics3EncoderLayer`].\n+\n+    Args:\n+        config: Idefics3Config\n+    \"\"\"\n+\n+    def __init__(self, config: Idefics3Config):\n+        super().__init__()\n+        self.config = config\n+        self.layers = nn.ModuleList([Idefics3EncoderLayer(config) for _ in range(config.num_hidden_layers)])\n+        self.gradient_checkpointing = False\n+\n+    # Ignore copy\n+    def forward(\n+        self,\n+        inputs_embeds,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Union[Tuple, BaseModelOutput]:\n+        r\"\"\"\n+        Args:\n+            inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`):\n+                Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation.\n+                This is useful if you want more control over how to convert `input_ids` indices into associated vectors\n+                than the model's internal embedding lookup matrix.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+\n+                [What are attention masks?](../glossary#attention-mask)\n+            output_attentions (`bool`, *optional*):\n+                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n+                returned tensors for more detail.\n+            output_hidden_states (`bool`, *optional*):\n+                Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors\n+                for more detail.\n+            return_dict (`bool`, *optional*):\n+                Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+        \"\"\"\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        encoder_states = () if output_hidden_states else None\n+        all_attentions = () if output_attentions else None\n+\n+        hidden_states = inputs_embeds\n+        for encoder_layer in self.layers:\n+            if output_hidden_states:\n+                encoder_states = encoder_states + (hidden_states,)\n+            if self.gradient_checkpointing and self.training:\n+                layer_outputs = self._gradient_checkpointing_func(\n+                    encoder_layer.__call__,\n+                    hidden_states,\n+                    attention_mask,\n+                    output_attentions,\n+                )\n+            else:\n+                layer_outputs = encoder_layer(\n+                    hidden_states,\n+                    attention_mask,\n+                    output_attentions=output_attentions,\n+                )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if output_attentions:\n+                all_attentions = all_attentions + (layer_outputs[1],)\n+\n+        if output_hidden_states:\n+            encoder_states = encoder_states + (hidden_states,)\n+\n+        if not return_dict:\n+            return tuple(v for v in [hidden_states, encoder_states, all_attentions] if v is not None)\n+        return BaseModelOutput(\n+            last_hidden_state=hidden_states, hidden_states=encoder_states, attentions=all_attentions\n+        )\n+\n+\n+# Copied from transformers.models.llama.modeling_llama.repeat_kv\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+# Copied from transformers.models.llama.modeling_llama.LlamaRMSNorm with Llama->Idefics3\n+class Idefics3RMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        Idefics3RMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class Idefics3Connector(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.scale_factor = config.scale_factor\n+        self.modality_projection = Idefics3SimpleMLP(config)\n+\n+    def pixel_shuffle(self, x, scale_factor=2):\n+        bsz, seq, embed_dim = x.size()\n+        height = width = int(seq**0.5)\n+        x = x.view(bsz, height, width, embed_dim)\n+        x = x.view(bsz, height, int(width / scale_factor), embed_dim * scale_factor)\n+        x = x.permute(0, 2, 1, 3)\n+        x = x.reshape(bsz, int(width / scale_factor), int(height / scale_factor), embed_dim * (scale_factor**2))\n+        x = x.permute(0, 2, 1, 3)\n+        x = x.reshape(bsz, int(seq / (scale_factor**2)), embed_dim * (scale_factor**2))\n+        return x\n+\n+    def forward(self, image_hidden_states):\n+        image_hidden_states = self.pixel_shuffle(image_hidden_states, self.scale_factor)\n+        image_hidden_states = self.modality_projection(image_hidden_states)\n+        return image_hidden_states\n+\n+\n+IDEFICS3_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`Idefics3Config`] or [`Idefics3VisionConfig`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare Idefics3 Model outputting raw hidden-states without any specific head on top.\",\n+    IDEFICS3_START_DOCSTRING,\n+)\n+class Idefics3PreTrainedModel(PreTrainedModel):\n+    config_class = Idefics3Config\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"Idefics3VisionAttention\", \"Idefics3DecoderLayer\"]\n+    _skip_keys_device_placement = \"past_key_values\"\n+    _supports_flash_attn_2 = True\n+    _supports_cache_class = True\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2PreTrainedModel._init_weights\n+    def _init_weights(self, module):\n+        std = (\n+            self.config.initializer_range\n+            if hasattr(self.config, \"initializer_range\")\n+            else self.config.text_config.initializer_range\n+        )\n+\n+        if hasattr(module, \"class_embedding\"):\n+            module.class_embedding.data.normal_(mean=0.0, std=std)\n+\n+        if isinstance(module, (nn.Linear, nn.Conv2d)):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+\n+\n+IDEFICS3_VISION_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`Idefics3VisionConfig`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The Idefics3 Vision Transformer Model outputting raw image embedding.\",\n+    IDEFICS3_VISION_START_DOCSTRING,\n+)\n+class Idefics3VisionTransformer(Idefics3PreTrainedModel):\n+    config_class = Idefics3VisionConfig\n+\n+    def __init__(self, config: Idefics3VisionConfig):\n+        super().__init__(config)\n+        embed_dim = config.hidden_size\n+\n+        self.embeddings = Idefics3VisionEmbeddings(config)\n+        self.encoder = Idefics3Encoder(config)\n+        self.patch_size = config.patch_size\n+        self.post_layernorm = nn.LayerNorm(embed_dim, eps=config.layer_norm_eps)\n+        self._use_flash_attention_2 = config._attn_implementation == \"flash_attention_2\"\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2VisionTransformer.get_input_embeddings\n+    def get_input_embeddings(self):\n+        return self.embeddings\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2VisionTransformer.set_input_embeddings\n+    def set_input_embeddings(self, value):\n+        self.embeddings = value\n+\n+    def forward(\n+        self,\n+        pixel_values,\n+        patch_attention_mask: Optional[torch.BoolTensor] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Union[Tuple, BaseModelOutput]:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        batch_size = pixel_values.size(0)\n+        if patch_attention_mask is None:\n+            patch_size = self.patch_size\n+            patch_attention_mask = torch.ones(\n+                (\n+                    batch_size,\n+                    pixel_values.size(2) // patch_size,\n+                    pixel_values.size(3) // patch_size,\n+                )\n+            )\n+            patch_attention_mask = patch_attention_mask.to(dtype=torch.bool, device=pixel_values.device)\n+\n+        hidden_states = self.embeddings(pixel_values=pixel_values, patch_attention_mask=patch_attention_mask)\n+\n+        patch_attention_mask = patch_attention_mask.view(batch_size, -1)\n+        # The call to `_upad_input` in `_flash_attention_forward` is expensive\n+        # So when the `patch_attention_mask` is full of 1s (i.e. attending to the whole sequence),\n+        # avoiding passing the attention_mask, which is equivalent to attending to the full sequence\n+        if not torch.any(~patch_attention_mask):\n+            patch_attention_mask = None\n+        elif not self._use_flash_attention_2:\n+            patch_attention_mask = _prepare_4d_attention_mask(patch_attention_mask, hidden_states.dtype)\n+\n+        encoder_outputs = self.encoder(\n+            inputs_embeds=hidden_states,\n+            attention_mask=patch_attention_mask,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+        )\n+\n+        last_hidden_state = encoder_outputs[0]\n+        last_hidden_state = self.post_layernorm(last_hidden_state)\n+\n+        if not return_dict:\n+            return (last_hidden_state,) + encoder_outputs[1:]\n+\n+        return BaseModelOutput(\n+            last_hidden_state=last_hidden_state,\n+            hidden_states=encoder_outputs.hidden_states,\n+            attentions=encoder_outputs.attentions,\n+        )\n+\n+\n+IDEFICS3_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+            it.\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            [What are input IDs?](../glossary#input-ids)\n+        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+            - 1 for tokens that are **not masked**,\n+            - 0 for tokens that are **masked**.\n+\n+            [What are attention masks?](../glossary#attention-mask)\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            If `past_key_values` is used, optionally only the last `decoder_input_ids` have to be input (see\n+            `past_key_values`).\n+\n+            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n+            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n+            information on the default strategy.\n+\n+            - 1 indicates the head is **not masked**,\n+            - 0 indicates the head is **masked**.\n+        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n+            config.n_positions - 1]`. [What are position IDs?](../glossary#position-ids)\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`) and 2 additional tensors of shape\n+            `(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`.\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n+            blocks) that can be used (see `past_key_values` input) to speed up sequential decoding.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n+            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n+            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n+        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n+            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n+            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n+            model's internal embedding lookup matrix.\n+        pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)):\n+            The tensors corresponding to the input images. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`CLIPImageProcessor.__call__`] for details ([]`LlavaProcessor`] uses\n+            [`CLIPImageProcessor`] for processing images).\n+        pixel_attention_mask (`torch.Tensor` of shape `(batch_size, image_size, image_size)`, *optional*):\n+            Mask to avoid performing attention on padding pixel indices.\n+        image_hidden_states (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+            The hidden states of the image encoder after modality projection.\n+        use_cache (`bool`, *optional*):\n+            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n+            `past_key_values`).\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"\"\"Idefics3 model consisting of a SIGLIP vision encoder and Llama3 language decoder\"\"\",\n+    IDEFICS3_START_DOCSTRING,\n+)\n+class Idefics3Model(Idefics3PreTrainedModel):\n+    def __init__(self, config: Idefics3Config):\n+        super().__init__(config)\n+        self.padding_idx = self.config.text_config.pad_token_id\n+        self.vocab_size = self.config.text_config.vocab_size\n+\n+        self.vision_model = Idefics3VisionTransformer._from_config(\n+            config.vision_config, attn_implementation=config._attn_implementation\n+        )\n+        self.connector = Idefics3Connector(config)\n+        self.text_model = AutoModel.from_config(config.text_config, attn_implementation=config._attn_implementation)\n+\n+        self.image_seq_len = int(\n+            ((config.vision_config.image_size // config.vision_config.patch_size) ** 2) / (config.scale_factor**2)\n+        )\n+        self.image_token_id = self.config.image_token_id\n+\n+        self._use_flash_attention_2 = config._attn_implementation == \"flash_attention_2\"\n+\n+        self.post_init()\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2Model.enable_input_require_grads\n+    def enable_input_require_grads(self):\n+        \"\"\"\n+        Enables the gradients for the input embeddings.\n+\n+        This is useful for lora when using gradient checkpointing.\n+        c.f. https://github.com/huggingface/peft/issues/1402#issuecomment-1913675032\n+\n+        Override to set output.requires_grad = True for both the decoder's and vision model's embeddings.\n+        \"\"\"\n+\n+        def get_lowest_module(module):\n+            if len(list(module.children())) == 0:\n+                # If the module has no children, it is a leaf module (e.g., Linear, Conv2d, etc.)\n+                return module\n+            else:\n+                # Recursively call the function on each child module\n+                return get_lowest_module(list(module.children())[0])\n+\n+        def make_inputs_require_grads(module, input, output):\n+            output.requires_grad_(True)\n+\n+        self._text_require_grads_hook = self.get_input_embeddings().register_forward_hook(make_inputs_require_grads)\n+        self._vision_require_grads_hook = get_lowest_module(self.vision_model).register_forward_hook(\n+            make_inputs_require_grads\n+        )\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2Model.disable_input_require_grads\n+    def disable_input_require_grads(self):\n+        self._text_require_grads_hook.remove()\n+        self._vision_require_grads_hook.remove()\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2Model.get_input_embeddings\n+    def get_input_embeddings(self):\n+        return self.text_model.get_input_embeddings()\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2Model.set_input_embeddings\n+    def set_input_embeddings(self, value):\n+        self.text_model.set_input_embeddings(value)\n+\n+    def inputs_merger(\n+        self,\n+        input_ids: torch.LongTensor,\n+        inputs_embeds: Optional[torch.Tensor],\n+        image_hidden_states: Optional[torch.Tensor],\n+    ):\n+        \"\"\"\n+        This method aims at merging the token embeddings with the image hidden states into one single sequence of vectors that are fed to the transformer LM.\n+        The merging happens as follows:\n+        - The text token sequence is: `tok_1 tok_2 tok_3 <fake_token_around_image> <image> <image> ... <image> <fake_token_around_image> tok_4`.\n+        - We get the image hidden states for the image through the vision encoder and that hidden state, after a pixel shuffle operation, is then projected into the text embedding space.\n+        We thus have a sequence of image hidden states of size (1, image_seq_len, hidden_dim), where 1 is for batch_size of 1 image and hidden_dim is the hidden_dim of the LM transformer.\n+        - The merging happens so that we obtain the following sequence: `vector_tok_1 vector_tok_2 vector_tok_3 vector_fake_tok_around_image {sequence of image_seq_len image hidden states} vector_fake_toke_around_image vector_tok_4`. That sequence is fed to the LM.\n+        - To fit the format of that sequence, `input_ids`, `input_embeds`, `attention_mask` are all 3 adapted to insert the image hidden states.\n+        \"\"\"\n+        num_images, _, vision_hidden_size = image_hidden_states.shape\n+        special_image_token_mask = input_ids == self.image_token_id\n+        #  Fixes RuntimeError: a leaf Variable that requires grad is being used in an in-place operation.\n+        new_inputs_embeds = inputs_embeds.clone()\n+        reshaped_image_hidden_states = image_hidden_states.view(-1, vision_hidden_size)\n+        # cast to the dtype of the input_embeds to support quantized models\n+        reshaped_image_hidden_states = reshaped_image_hidden_states.to(inputs_embeds.dtype)\n+        new_inputs_embeds[special_image_token_mask] = reshaped_image_hidden_states\n+        return new_inputs_embeds\n+\n+    @add_start_docstrings_to_model_forward(\n+        \"\"\"\n+        Inputs fed to the model can have an arbitrary number of images. To account for this, pixel_values fed to\n+        the model have image padding -> (batch_size, max_num_images, 3, max_heights, max_widths) where\n+        max_num_images is the maximum number of images among the batch_size samples in the batch.\n+        Padding images are not needed beyond padding the pixel_values at the entrance of the model.\n+        For efficiency, we only pass through the vision_model's forward the real images by\n+        discarding the padding images i.e. pixel_values of size (image_batch_size, 3, height, width) where\n+        image_batch_size would be 7 when num_images_per_sample=[1, 3, 1, 2] and max_num_images would be 3.\n+        \"\"\",\n+        IDEFICS3_INPUTS_DOCSTRING,\n+    )\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        pixel_values: Optional[torch.FloatTensor] = None,\n+        pixel_attention_mask: Optional[torch.BoolTensor] = None,\n+        image_hidden_states: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Union[Tuple, Idefics3BaseModelOutputWithPast]:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        if self.training and self.text_model.gradient_checkpointing and use_cache:\n+            logger.warning_once(\n+                \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n+            )\n+            use_cache = False\n+\n+        # retrieve input_ids and inputs_embeds\n+        if input_ids is not None:\n+            batch_size, seq_length = input_ids.shape\n+        elif inputs_embeds is not None:\n+            batch_size, seq_length, _ = inputs_embeds.shape\n+        else:\n+            raise ValueError(\"You have to specify either input_ids or inputs_embeds\")\n+\n+        past_seen_tokens = 0\n+        if use_cache:\n+            past_seen_tokens = past_key_values.get_seq_length()\n+\n+        if inputs_embeds is not None and input_ids is None and past_seen_tokens == 0:\n+            raise ValueError(\"When first calling the model, if input_embeds are passed, input_ids should not be None.\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.text_model.get_input_embeddings()(input_ids).to(self.device)\n+\n+        # START VISUAL INPUTS INTEGRATION\n+        if pixel_values is not None and image_hidden_states is not None:\n+            raise ValueError(\"You cannot specify both pixel_values and image_hidden_states at the same time\")\n+        elif pixel_values is not None:\n+            batch_size, num_images, num_channels, height, width = pixel_values.shape\n+            pixel_values = pixel_values.to(dtype=self.dtype)  # fp16 compatibility\n+            pixel_values = pixel_values.view(batch_size * num_images, *pixel_values.shape[2:])\n+\n+            # Remove padding images - padding images are full 0.\n+            nb_values_per_image = pixel_values.shape[1:].numel()\n+            real_images_inds = (pixel_values == 0.0).sum(dim=(-1, -2, -3)) != nb_values_per_image\n+            pixel_values = pixel_values[real_images_inds].contiguous()\n+\n+            # Handle the vision attention mask\n+            if pixel_attention_mask is None:\n+                pixel_attention_mask = torch.ones(\n+                    size=(pixel_values.size(0), pixel_values.size(2), pixel_values.size(3)),\n+                    dtype=torch.bool,\n+                    device=pixel_values.device,\n+                )\n+            else:\n+                # Remove padding images from the mask\n+                pixel_attention_mask = pixel_attention_mask.view(\n+                    batch_size * num_images, *pixel_attention_mask.shape[2:]\n+                )\n+                pixel_attention_mask = pixel_attention_mask[real_images_inds].contiguous()\n+\n+            patch_size = self.config.vision_config.patch_size\n+            patches_subgrid = pixel_attention_mask.unfold(dimension=1, size=patch_size, step=patch_size)\n+            patches_subgrid = patches_subgrid.unfold(dimension=2, size=patch_size, step=patch_size)\n+            patch_attention_mask = (patches_subgrid.sum(dim=(-1, -2)) > 0).bool()\n+\n+            # Get sequence from the vision encoder\n+            image_hidden_states = self.vision_model(\n+                pixel_values=pixel_values,\n+                patch_attention_mask=patch_attention_mask,\n+            ).last_hidden_state\n+\n+            # Modality projection & resampling\n+            image_hidden_states = self.connector(image_hidden_states)\n+\n+        elif image_hidden_states is not None:\n+            image_hidden_states = image_hidden_states.to(dtype=self.dtype, device=input_ids.device)\n+\n+        if past_seen_tokens == 0 and inputs_embeds is not None and image_hidden_states is not None:\n+            # When we generate, we don't want to replace the potential image_token_id that we generated by images\n+            # that simply don't exist\n+            inputs_embeds = self.inputs_merger(\n+                input_ids=input_ids,\n+                inputs_embeds=inputs_embeds,\n+                image_hidden_states=image_hidden_states,\n+            )\n+\n+        outputs = self.text_model(\n+            inputs_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+        )\n+\n+        if not return_dict:\n+            return tuple(v for v in [*outputs, image_hidden_states] if v is not None)\n+\n+        return Idefics3BaseModelOutputWithPast(\n+            last_hidden_state=outputs.last_hidden_state,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            image_hidden_states=image_hidden_states,\n+        )\n+\n+\n+@add_start_docstrings(\n+    \"\"\"The Idefics3 Model with a language modeling head. It is made up a SigLIP vision encoder, with a language modeling head on top. \"\"\",\n+    IDEFICS3_START_DOCSTRING,\n+)\n+class Idefics3ForConditionalGeneration(Idefics3PreTrainedModel):\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2ForConditionalGeneration.__init__ with Idefics2->Idefics3\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = Idefics3Model(config)\n+        self.image_token_id = self.config.image_token_id\n+\n+        self.lm_head = nn.Linear(config.text_config.hidden_size, config.text_config.vocab_size, bias=False)\n+        self.vocab_size = config.text_config.vocab_size\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2ForConditionalGeneration.enable_input_require_grads\n+    def enable_input_require_grads(self):\n+        \"\"\"\n+        Enables the gradients for the input embeddings. This is useful for fine-tuning adapter weights while keeping\n+        the model weights fixed.\n+        \"\"\"\n+\n+        def make_inputs_require_grads(module, input, output):\n+            output.requires_grad_(True)\n+\n+        self._text_require_grads_hook = self.get_input_embeddings().register_forward_hook(make_inputs_require_grads)\n+        self._vision_require_grads_hook = self.model.vision_model.get_input_embeddings().register_forward_hook(\n+            make_inputs_require_grads\n+        )\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2ForConditionalGeneration.disable_input_require_grads\n+    def disable_input_require_grads(self):\n+        self._text_require_grads_hook.remove()\n+        self._vision_require_grads_hook.remove()\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2ForConditionalGeneration.get_input_embeddings\n+    def get_input_embeddings(self):\n+        return self.model.text_model.get_input_embeddings()\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2ForConditionalGeneration.set_input_embeddings\n+    def set_input_embeddings(self, value):\n+        self.model.text_model.set_input_embeddings(value)\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2ForConditionalGeneration.get_output_embeddings\n+    def get_output_embeddings(self):\n+        return self.lm_head\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2ForConditionalGeneration.set_output_embeddings\n+    def set_output_embeddings(self, new_embeddings):\n+        self.lm_head = new_embeddings\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2ForConditionalGeneration.tie_weights\n+    def tie_weights(self):\n+        \"\"\"\n+        Overwrite `transformers.modeling_utils.PreTrainedModel.tie_weights` to handle the case of DecoupledLinear and DecoupledEmbedding.\n+        \"\"\"\n+        output_embeddings = self.get_output_embeddings()\n+        input_embeddings = self.get_input_embeddings()\n+\n+        if getattr(self.config, \"tie_word_embeddings\", True):\n+            output_embeddings.weight = input_embeddings.weight\n+\n+    @add_start_docstrings_to_model_forward(IDEFICS3_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=Idefics3CausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        pixel_values: Optional[torch.FloatTensor] = None,\n+        pixel_attention_mask: Optional[torch.BoolTensor] = None,\n+        image_hidden_states: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Union[Tuple, Idefics3CausalLMOutputWithPast]:\n+        r\"\"\"\n+        Args:\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.vocab_size]` or `model.image_token_id` (where `model` is your instance of `Idefics3ForConditionalGeneration`).\n+                Tokens with indices set to `model.image_token_id` are ignored (masked), the loss is only\n+                computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> import requests\n+        >>> import torch\n+        >>> from PIL import Image\n+        >>> from io import BytesIO\n+\n+        >>> from transformers import AutoProcessor, AutoModelForVision2Seq\n+        >>> from transformers.image_utils import load_image\n+\n+        >>> # Note that passing the image urls (instead of the actual pil images) to the processor is also possible\n+        >>> image1 = load_image(\"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\")\n+        >>> image2 = load_image(\"https://cdn.britannica.com/59/94459-050-DBA42467/Skyline-Chicago.jpg\")\n+        >>> image3 = load_image(\"https://cdn.britannica.com/68/170868-050-8DDE8263/Golden-Gate-Bridge-San-Francisco.jpg\")\n+\n+        >>> processor = AutoProcessor.from_pretrained(\"HuggingFaceM4/Idefics3-8B-Llama3\")\n+        >>> model = AutoModelForVision2Seq.from_pretrained(\"HuggingFaceM4/Idefics3-8B-Llama3\", torch_dtype=torch.bfloat16, device_map=\"auto\")\n+\n+        >>> # Create inputs\n+        >>> messages = [\n+        ...     {\n+        ...         \"role\": \"user\",\n+        ...         \"content\": [\n+        ...             {\"type\": \"image\"},\n+        ...             {\"type\": \"text\", \"text\": \"In this image, we can see the city of New York, and more specifically the Statue of Liberty.\"},\n+        ...             {\"type\": \"image\"},\n+        ...             {\"type\": \"text\", \"text\": \"What can we see in this image?\"},\n+        ...         ]\n+        ...     },\n+        ...     {\n+        ...         \"role\": \"user\",\n+        ...         \"content\": [\n+        ...             {\"type\": \"image\"},\n+        ...             {\"type\": \"text\", \"text\": \"In which city is that bridge located?\"},\n+        ...         ]\n+        ...     }\n+        ... ]\n+\n+        >>> prompts = [processor.apply_chat_template([message], add_generation_prompt=True) for message in messages]\n+        >>> images = [[image1, image2], [image3]]\n+        >>> inputs = processor(text=prompts, images=images, padding=True, return_tensors=\"pt\").to(model.device)\n+\n+        >>> # Generate\n+        >>> generated_ids = model.generate(**inputs, max_new_tokens=256)\n+        >>> generated_texts = processor.batch_decode(generated_ids, skip_special_tokens=True)\n+\n+        >>> print(generated_texts[0])\n+        Assistant: There are buildings, trees, lights, and water visible in this image.\n+\n+        >>> print(generated_texts[1])\n+        Assistant: The bridge is in San Francisco.\n+        ```\"\"\"\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            pixel_values=pixel_values,\n+            pixel_attention_mask=pixel_attention_mask,\n+            image_hidden_states=image_hidden_states,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+        )\n+\n+        hidden_states = outputs[0]\n+        logits = self.lm_head(hidden_states)\n+        logits = logits.float()\n+\n+        loss = None\n+        if labels is not None:\n+            labels = labels.to(logits.device)\n+            # Shift so that tokens < n predict n\n+            if attention_mask is not None:\n+                shift_attention_mask = attention_mask[..., 1:].to(logits.device)\n+                shift_logits = logits[..., :-1, :][shift_attention_mask != 0].contiguous()\n+                shift_labels = labels[..., 1:][shift_attention_mask != 0].contiguous()\n+            else:\n+                shift_logits = logits[..., :-1, :].contiguous()\n+                shift_labels = labels[..., 1:].contiguous()\n+            # Flatten the tokens\n+            loss_fct = CrossEntropyLoss()\n+            loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)), shift_labels.view(-1))\n+\n+        if not return_dict:\n+            output = (logits,) + outputs[1:]\n+            return (loss,) + output if loss is not None else output\n+\n+        return Idefics3CausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            image_hidden_states=outputs.image_hidden_states,\n+        )\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2ForConditionalGeneration.prepare_inputs_for_generation\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        attention_mask=None,\n+        inputs_embeds=None,\n+        num_logits_to_keep=None,\n+        **kwargs,\n+    ):\n+        past_length = 0\n+        # Omit tokens covered by past_key_values\n+        if past_key_values is not None:\n+            # Past key values are always initialized with a `Cache` object -> no need for if-else anymore\n+            past_length = past_key_values.get_seq_length()\n+            max_cache_length = past_key_values.get_max_length()\n+\n+            # Keep only the unprocessed tokens:\n+            # 1 - If the length of the attention_mask exceeds the length of input_ids, then we are in a setting where\n+            # some of the inputs are exclusively passed as part of the cache (e.g. when passing input_embeds as\n+            # input)\n+            if attention_mask is not None and attention_mask.shape[1] > input_ids.shape[1]:\n+                input_ids = input_ids[:, -(attention_mask.shape[1] - past_length) :]\n+            # 2 - If the past_length is smaller than input_ids', then input_ids holds all input tokens. We can discard\n+            # input_ids based on the past_length.\n+            elif past_length < input_ids.shape[1]:\n+                input_ids = input_ids[:, past_length:]\n+            # 3 - Otherwise (past_length >= input_ids.shape[1]), let's assume input_ids only has unprocessed tokens.\n+\n+            # If we are about to go beyond the maximum cache length, we need to crop the input attention mask.\n+            if (\n+                max_cache_length is not None\n+                and attention_mask is not None\n+                and past_length + input_ids.shape[1] > max_cache_length\n+            ):\n+                attention_mask = attention_mask[:, -max_cache_length:]\n+\n+        position_ids = kwargs.get(\"position_ids\", None)\n+        if attention_mask is not None and position_ids is None:\n+            # create position_ids on the fly for batch generation\n+            position_ids = attention_mask.long().cumsum(-1) - 1\n+            position_ids.masked_fill_(attention_mask == 0, 1)\n+            if past_key_values:\n+                position_ids = position_ids[:, -input_ids.shape[1] :]\n+\n+        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n+        if inputs_embeds is not None and past_length == 0:\n+            model_inputs = {\"inputs_embeds\": inputs_embeds}\n+        else:\n+            model_inputs = {\"input_ids\": input_ids}\n+\n+        if num_logits_to_keep is not None:\n+            model_inputs[\"num_logits_to_keep\"] = num_logits_to_keep\n+\n+        image_hidden_states = kwargs.get(\"image_hidden_states\", None)\n+        if image_hidden_states is not None:\n+            pixel_values = None\n+            pixel_attention_mask = None\n+        else:\n+            pixel_values = kwargs.get(\"pixel_values\", None)\n+            pixel_attention_mask = kwargs.get(\"pixel_attention_mask\", None)\n+        model_inputs.update(\n+            {\n+                \"position_ids\": position_ids,\n+                \"past_key_values\": past_key_values,\n+                \"use_cache\": kwargs.get(\"use_cache\"),\n+                \"attention_mask\": attention_mask,\n+                \"pixel_values\": pixel_values,\n+                \"pixel_attention_mask\": pixel_attention_mask,\n+                \"image_hidden_states\": image_hidden_states,\n+            }\n+        )\n+        return model_inputs\n+\n+    # Copied from transformers.models.idefics2.modeling_idefics2.Idefics2ForConditionalGeneration._update_model_kwargs_for_generation\n+    def _update_model_kwargs_for_generation(self, outputs, model_kwargs, is_encoder_decoder, **kwargs):\n+        model_kwargs = super()._update_model_kwargs_for_generation(\n+            outputs=outputs,\n+            model_kwargs=model_kwargs,\n+            is_encoder_decoder=is_encoder_decoder,\n+            **kwargs,\n+        )\n+        # Get the precomputed image_hidden_states\n+        model_kwargs[\"image_hidden_states\"] = outputs.image_hidden_states\n+        return model_kwargs"
        },
        {
            "sha": "10042ca4529204546e02163a5008ded39493003d",
            "filename": "src/transformers/models/idefics3/processing_idefics3.py",
            "status": "added",
            "additions": 344,
            "deletions": 0,
            "changes": 344,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics3%2Fprocessing_idefics3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fmodels%2Fidefics3%2Fprocessing_idefics3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fidefics3%2Fprocessing_idefics3.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -0,0 +1,344 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"\n+Processor class for Idefics3.\n+\"\"\"\n+\n+import re\n+import sys\n+from typing import TYPE_CHECKING, Dict, List, Optional, Union\n+\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_utils import ImageInput, is_valid_image, load_image\n+from ...processing_utils import ImagesKwargs, ProcessingKwargs, ProcessorMixin\n+from ...tokenization_utils_base import AddedToken, BatchEncoding, TextInput\n+from ...utils import logging\n+\n+\n+if TYPE_CHECKING:\n+    from ...tokenization_utils_base import PreTokenizedInput\n+\n+if sys.version_info >= (3, 11):\n+    from typing import Unpack\n+else:\n+    from typing_extensions import Unpack\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+def is_url(val) -> bool:\n+    return isinstance(val, str) and val.startswith(\"http\")\n+\n+\n+def is_image_or_image_url(elem):\n+    return is_url(elem) or is_valid_image(elem)\n+\n+\n+def _prompt_split_image(image_seq_len, image_rows, image_cols, fake_token_around_image, image_token, global_img_token):\n+    \"\"\"Prompt with expanded image tokens for when the image is split into patches.\"\"\"\n+    text_split_images = \"\"\n+    for n_h in range(image_rows):\n+        for n_w in range(image_cols):\n+            text_split_images += (\n+                f\"{fake_token_around_image}\" + f\"<row_{n_h + 1}_col_{n_w + 1}>\" + f\"{image_token}\" * image_seq_len\n+            )\n+        text_split_images += \"\\n\"\n+\n+    text_split_images += (\n+        f\"\\n{fake_token_around_image}\"\n+        + f\"{global_img_token}\"\n+        + f\"{image_token}\" * image_seq_len\n+        + f\"{fake_token_around_image}\"\n+    )\n+    return text_split_images\n+\n+\n+def _prompt_single_image(image_seq_len, fake_token_around_image, image_token, global_img_token):\n+    \"\"\"Prompt with expanded image tokens for a single image.\"\"\"\n+    return (\n+        f\"{fake_token_around_image}\"\n+        + f\"{global_img_token}\"\n+        + f\"{image_token}\" * image_seq_len\n+        + f\"{fake_token_around_image}\"\n+    )\n+\n+\n+def get_image_prompt_string(\n+    image_rows, image_cols, image_seq_len, fake_token_around_image, image_token, global_img_token\n+):\n+    if image_rows == 0 and image_cols == 0:\n+        return _prompt_single_image(\n+            image_seq_len,\n+            fake_token_around_image=fake_token_around_image,\n+            image_token=image_token,\n+            global_img_token=global_img_token,\n+        )\n+    return _prompt_split_image(\n+        image_seq_len, image_rows, image_cols, fake_token_around_image, image_token, global_img_token\n+    )\n+\n+\n+class Idefics3ImagesKwargs(ImagesKwargs, total=False):\n+    return_row_col_info: Optional[bool]\n+    max_image_size: Optional[Dict[str, int]]\n+\n+\n+class Idefics3ProcessorKwargs(ProcessingKwargs, total=False):\n+    images_kwargs: Idefics3ImagesKwargs\n+\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"add_special_tokens\": True,\n+            \"padding\": False,\n+            \"is_split_into_words\": False,\n+        },\n+        \"images_kwargs\": {\n+            \"return_row_col_info\": True,\n+        },\n+    }\n+\n+\n+Idefics3ProcessorKwargs.__annotations__[\"images_kwargs\"] = Idefics3ImagesKwargs  # python 3.8 compatibility\n+\n+\n+class Idefics3Processor(ProcessorMixin):\n+    r\"\"\"\n+    Constructs a Idefics3 processor which wraps a LLama tokenizer and Idefics3 image processor into a single processor.\n+\n+    [`Idefics3Processor`] offers all the functionalities of [`Idefics3ImageProcessor`] and [`Idefics3TokenizerFast`]. See\n+    the docstring of [`~IdeficsProcessor.__call__`] and [`~IdeficsProcessor.decode`] for more information.\n+\n+    Args:\n+        image_processor (`Idefics3ImageProcessor`):\n+            An instance of [`Idefics3ImageProcessor`]. The image processor is a required input.\n+        tokenizer (`PreTrainedTokenizerBase`, *optional*):\n+            An instance of [`PreTrainedTokenizerBase`]. This should correspond with the model's text model. The tokenizer is a required input.\n+        image_seq_len (`int`, *optional*, defaults to 169):\n+            The length of the image sequence i.e. the number of <image> tokens per image in the input.\n+            This parameter is used to build the string from the input prompt and image tokens and should match the\n+            value the model used. It is computed as: image_seq_len = int(((image_size // patch_size) ** 2) / (scale_factor**2))\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    attributes = [\"image_processor\", \"tokenizer\"]\n+    image_processor_class = \"Idefics3ImageProcessor\"\n+    tokenizer_class = \"AutoTokenizer\"\n+\n+    def __init__(self, image_processor, tokenizer=None, image_seq_len: int = 169, chat_template: str = None, **kwargs):\n+        if image_processor is None:\n+            raise ValueError(\"You need to specify an `image_processor`.\")\n+        if tokenizer is None:\n+            raise ValueError(\"You need to specify a `tokenizer`.\")\n+\n+        self.fake_image_token = AddedToken(\"<fake_token_around_image>\", normalized=False, special=True)\n+        self.image_token = AddedToken(\"<image>\", normalized=False, special=True)\n+        self.end_of_utterance_token = AddedToken(\"<end_of_utterance>\", normalized=False, special=True)\n+        self.global_image_tag = \"<global-img>\"  # https://github.com/huggingface/transformers/pull/32473/files/8063e5e17362571b693f1db95167f5443a3be1b2#r1734825341\n+        self.image_seq_len = image_seq_len\n+\n+        # This regex matches one or more occurrences of <global-img> tags (optionally surrounded by newline characters)\n+        # or <row_x_col_y> tags (where x and y are digits, also optionally surrounded by newline characters).\n+        self._regex_to_remove_extra_special_tokens = re.compile(r\"(\\n?<global-img>\\n?|<row_\\d+_col_\\d+>\\n?)+\")\n+\n+        tokens_to_add = {\n+            \"additional_special_tokens\": [\n+                self.fake_image_token,\n+                self.image_token,\n+                self.end_of_utterance_token,\n+            ]\n+        }\n+        tokenizer.add_special_tokens(tokens_to_add)\n+\n+        super().__init__(image_processor, tokenizer, chat_template=chat_template, **kwargs)\n+\n+    def _extract_images_from_prompts(self, prompts):\n+        prompt_images = []\n+        for prompt in prompts:\n+            images = []\n+            for elem in prompt:\n+                if is_valid_image(elem):\n+                    images.append(elem)\n+                elif is_url(elem):\n+                    images.append(load_image(elem))\n+            prompt_images.append(images)\n+        return prompt_images\n+\n+    def __call__(\n+        self,\n+        images: Union[ImageInput, List[ImageInput], List[List[ImageInput]]] = None,\n+        text: Union[TextInput, \"PreTokenizedInput\", List[TextInput], List[\"PreTokenizedInput\"]] = None,\n+        audio=None,\n+        videos=None,\n+        image_seq_len: Optional[int] = None,\n+        **kwargs: Unpack[Idefics3ProcessorKwargs],\n+    ) -> BatchEncoding:\n+        \"\"\"\n+        Processes the input prompts and returns a BatchEncoding.\n+\n+        Example:\n+\n+        ```python\n+        >>> import requests\n+        >>> from transformers import Idefics3Processor\n+        >>> from transformers.image_utils import load_image\n+\n+        >>> processor = Idefics3Processor.from_pretrained(\"HuggingFaceM4/Idefics3-8B-Llama3\")\n+        >>> processor.image_processor.do_image_splitting = False  # Force as False to simplify the example\n+\n+        >>> url1 = \"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\"\n+        >>> url2 = \"https://cdn.britannica.com/59/94459-050-DBA42467/Skyline-Chicago.jpg\"\n+\n+        >>> image1, image2 = load_image(url1), load_image(url2)\n+        >>> images = [[image1], [image2]]\n+\n+        >>> text = [\n+        ...     \"<image>In this image, we see\",\n+        ...     \"bla bla bla<image>\",\n+        ... ]\n+        >>> outputs = processor(images=images, text=text, return_tensors=\"pt\", padding=True)\n+        >>> input_ids = outputs.input_ids\n+        >>> input_tokens = processor.tokenizer.batch_decode(input_ids)\n+        >>> print(input_tokens)\n+        ['<|begin_of_text|><fake_token_around_image><global-img>((<image>)*169)<fake_token_around_image> In this image, we see', '<|reserved_special_token_0|><|reserved_special_token_0|><|reserved_special_token_0|><|begin_of_text|>bla bla bla<fake_token_around_image><global-img>((<image>)*169)<fake_token_around_image>']\n+        ```\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`, *optional*):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. If is of type `List[ImageInput]`, it's assumed that this is for a single prompt i.e. of batch size 1.\n+            text (`Union[TextInput, PreTokenizedInput, List[TextInput], List[PreTokenizedInput]]`, *optional*):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+                Wherever an image token, `<image>` is encountered it is expanded to\n+                `<fake_token_around_image>` + `<row_x_col_y>` + `<image>` * `image_seq_len` * <fake_token_around_image>`.\n+            image_seq_len (`int`, *optional*):\n+                The length of the image sequence. If not provided, the default value of self.image_seq_len is used.\n+                image_seq_len should be equal to int(((image_size // patch_size) ** 2) / (scale_factor**2))\n+            return_tensors (`Union[str, TensorType]`, *optional*):\n+                If set, will return tensors of a particular framework. See [`PreTrainedTokenizerFast.__call__`] for more\n+                information.\n+        \"\"\"\n+        if text is None and images is None:\n+            raise ValueError(\"You must provide either `text` or `images`.\")\n+\n+        output_kwargs = self._merge_kwargs(\n+            Idefics3ProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+\n+        # Temporary fix for \"padding_side\" in init_kwargs\n+        output_kwargs[\"text_kwargs\"].pop(\"padding_side\", None)\n+\n+        image_seq_len = image_seq_len if image_seq_len is not None else self.image_seq_len\n+\n+        n_images_in_text = []\n+        n_images_in_images = []\n+        inputs = BatchFeature()\n+\n+        if images is not None:\n+            if is_image_or_image_url(images):\n+                images = [[images]]\n+            elif isinstance(images, list) and is_image_or_image_url(images[0]):\n+                images = [images]\n+            elif (\n+                not isinstance(images, list)\n+                and not isinstance(images[0], list)\n+                and not is_image_or_image_url(images[0][0])\n+            ):\n+                raise ValueError(\n+                    \"Invalid input images. Please provide a single image or a list of images or a list of list of images.\"\n+                )\n+            n_images_in_images = [len(sample) for sample in images]\n+\n+            # Load images if they are URLs\n+            images = [[load_image(im) if is_url(im) else im for im in sample] for sample in images]\n+\n+            image_inputs = self.image_processor(images, **output_kwargs[\"images_kwargs\"])\n+            inputs.update(image_inputs)\n+\n+        if text is not None:\n+            if isinstance(text, str):\n+                text = [text]\n+            elif not isinstance(text, list) and not isinstance(text[0], str):\n+                raise ValueError(\"Invalid input text. Please provide a string, or a list of strings\")\n+\n+            image_rows = inputs.pop(\"rows\", [[0] * len(text)])\n+            image_cols = inputs.pop(\"cols\", [[0] * len(text)])\n+\n+            fake_image_token = self.fake_image_token.content\n+            image_token = self.image_token.content\n+            global_img_token = self.global_image_tag\n+\n+            prompt_strings = []\n+            for sample, sample_rows, sample_cols in zip(text, image_rows, image_cols):\n+                n_images_in_text.append(sample.count(image_token))\n+\n+                # Replace the image token with fake tokens around the expanded image token sequence of length `image_seq_len`\n+                image_prompt_strings = []\n+                for n_rows, n_cols in zip(sample_rows, sample_cols):\n+                    image_prompt_string = get_image_prompt_string(\n+                        n_rows,\n+                        n_cols,\n+                        image_seq_len,\n+                        image_token=image_token,\n+                        fake_token_around_image=fake_image_token,\n+                        global_img_token=global_img_token,\n+                    )\n+                    image_prompt_strings.append(image_prompt_string)\n+\n+                split_sample = sample.split(image_token)\n+                if len(split_sample) == 0:\n+                    raise ValueError(\"The image token should be present in the text.\")\n+\n+                # Place in the image prompt strings where the image tokens are\n+                sample = split_sample[0]\n+                for i, image_prompt_string in enumerate(image_prompt_strings):\n+                    sample += image_prompt_string + split_sample[i + 1]\n+                prompt_strings.append(sample)\n+\n+            text_inputs = self.tokenizer(text=prompt_strings, **output_kwargs[\"text_kwargs\"])\n+            inputs.update(text_inputs)\n+\n+            if n_images_in_images != n_images_in_text:\n+                raise ValueError(\n+                    f\"The number of images in the text {n_images_in_text} and images  {n_images_in_images} should be the same.\"\n+                )\n+\n+        return inputs\n+\n+    def batch_decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to Idefics3TokenizerFast's [`~PreTrainedTokenizer.batch_decode`]. Please\n+        refer to the docstring of this method for more information.\n+        \"\"\"\n+        batched_decode_output = self.tokenizer.batch_decode(*args, **kwargs)\n+        return [self._regex_to_remove_extra_special_tokens.sub(\"<image>\", s) for s in batched_decode_output]\n+\n+    def decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to Idefics3TokenizerFast's [`~PreTrainedTokenizer.decode`]. Please refer to\n+        the docstring of this method for more information.\n+        \"\"\"\n+        decode_output = self.tokenizer.decode(*args, **kwargs)\n+        return self._regex_to_remove_extra_special_tokens.sub(\"<image>\", decode_output)\n+\n+    @property\n+    def model_input_names(self):\n+        tokenizer_input_names = self.tokenizer.model_input_names\n+        image_processor_input_names = self.image_processor.model_input_names\n+        return list(dict.fromkeys(tokenizer_input_names + image_processor_input_names))"
        },
        {
            "sha": "58eb3e6ed6f206a13266fea0d706cd248f65ca71",
            "filename": "src/transformers/processing_utils.py",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fprocessing_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Fprocessing_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fprocessing_utils.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -307,6 +307,17 @@ class ModelProcessorKwargs(ProcessingKwargs, total=False):\n         }\n \n     ```\n+\n+    For Python 3.8 compatibility, when inheriting from this class and overriding one of the kwargs,\n+    you need to manually update the __annotations__ dictionary. This can be done as follows:\n+\n+    ```python\n+    class CustomProcessorKwargs(ProcessingKwargs, total=False):\n+        images_kwargs: CustomImagesKwargs\n+\n+    CustomProcessorKwargs.__annotations__[\"images_kwargs\"] = CustomImagesKwargs  # python 3.8 compatibility\n+    ```python\n+\n     \"\"\"\n \n     common_kwargs: CommonKwargs = {"
        },
        {
            "sha": "f4e471ee7ab58b6a8f943b4928ca38a514b5c513",
            "filename": "src/transformers/utils/dummy_pt_objects.py",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -4870,6 +4870,34 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torch\"])\n \n \n+class Idefics3ForConditionalGeneration(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class Idefics3Model(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class Idefics3PreTrainedModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class Idefics3Processor(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n class ImageGPTForCausalImageModeling(metaclass=DummyObject):\n     _backends = [\"torch\"]\n "
        },
        {
            "sha": "d2ccaeaaed23a8571a6ad6f4f01e613ccd55063e",
            "filename": "src/transformers/utils/dummy_vision_objects.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -296,6 +296,13 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"vision\"])\n \n \n+class Idefics3ImageProcessor(metaclass=DummyObject):\n+    _backends = [\"vision\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"vision\"])\n+\n+\n class ImageGPTFeatureExtractor(metaclass=DummyObject):\n     _backends = [\"vision\"]\n "
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/idefics3/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/tests%2Fmodels%2Fidefics3%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/tests%2Fmodels%2Fidefics3%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fidefics3%2F__init__.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c"
        },
        {
            "sha": "102356dc1dd931667fbd776545a1c73db960e8ad",
            "filename": "tests/models/idefics3/test_image_processing_idefics3.py",
            "status": "added",
            "additions": 285,
            "deletions": 0,
            "changes": 285,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/tests%2Fmodels%2Fidefics3%2Ftest_image_processing_idefics3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/tests%2Fmodels%2Fidefics3%2Ftest_image_processing_idefics3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fidefics3%2Ftest_image_processing_idefics3.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -0,0 +1,285 @@\n+# coding=utf-8\n+# Copyright 2024 HuggingFace Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+import unittest\n+\n+import numpy as np\n+\n+from transformers.image_utils import PILImageResampling\n+from transformers.testing_utils import require_torch, require_vision\n+from transformers.utils import is_torch_available, is_vision_available\n+\n+from ...test_image_processing_common import ImageProcessingTestMixin\n+\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+    from transformers import Idefics3ImageProcessor\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+class Idefics3ImageProcessingTester(unittest.TestCase):\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=7,\n+        num_channels=3,\n+        num_images=1,\n+        image_size=18,\n+        min_resolution=30,\n+        max_resolution=40,\n+        do_resize=True,\n+        size=None,\n+        max_image_size=None,\n+        do_rescale=True,\n+        rescale_factor=1 / 255,\n+        do_normalize=True,\n+        image_mean=[0.5, 0.5, 0.5],\n+        image_std=[0.5, 0.5, 0.5],\n+        do_convert_rgb=True,\n+        do_pad=True,\n+        do_image_splitting=True,\n+        resample=PILImageResampling.LANCZOS,\n+    ):\n+        super().__init__()\n+        self.size = size if size is not None else {\"longest_edge\": max_resolution}\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.num_images = num_images\n+        self.image_size = image_size\n+        self.min_resolution = min_resolution\n+        self.max_resolution = max_resolution\n+        self.do_resize = do_resize\n+        self.resample = resample\n+        self.do_image_splitting = do_image_splitting\n+        self.max_image_size = max_image_size if max_image_size is not None else {\"longest_edge\": 20}\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean\n+        self.image_std = image_std\n+        self.do_convert_rgb = do_convert_rgb\n+        self.do_pad = do_pad\n+\n+    def prepare_image_processor_dict(self):\n+        return {\n+            \"do_convert_rgb\": self.do_convert_rgb,\n+            \"do_resize\": self.do_resize,\n+            \"size\": self.size,\n+            \"max_image_size\": self.max_image_size,\n+            \"do_rescale\": self.do_rescale,\n+            \"rescale_factor\": self.rescale_factor,\n+            \"do_normalize\": self.do_normalize,\n+            \"image_mean\": self.image_mean,\n+            \"image_std\": self.image_std,\n+            \"do_pad\": self.do_pad,\n+            \"do_image_splitting\": self.do_image_splitting,\n+        }\n+\n+    def get_expected_values(self, image_inputs, batched=False):\n+        \"\"\"\n+        This function computes the expected height and width when providing images to Idefics3ImageProcessor,\n+        assuming do_resize is set to True. The expected size in that case the max image size.\n+        \"\"\"\n+        return self.max_image_size[\"longest_edge\"], self.max_image_size[\"longest_edge\"]\n+\n+    def expected_output_image_shape(self, images):\n+        height, width = self.get_expected_values(images, batched=True)\n+        effective_nb_images = (\n+            self.num_images * 5 if self.do_image_splitting else 1\n+        )  # 5 is a squared image divided into 4 + global image resized\n+        return effective_nb_images, self.num_channels, height, width\n+\n+    def prepare_image_inputs(\n+        self,\n+        batch_size=None,\n+        min_resolution=None,\n+        max_resolution=None,\n+        num_channels=None,\n+        num_images=None,\n+        size_divisor=None,\n+        equal_resolution=False,\n+        numpify=False,\n+        torchify=False,\n+    ):\n+        \"\"\"This function prepares a list of PIL images, or a list of numpy arrays if one specifies numpify=True,\n+        or a list of PyTorch tensors if one specifies torchify=True.\n+\n+        One can specify whether the images are of the same resolution or not.\n+        \"\"\"\n+        assert not (numpify and torchify), \"You cannot specify both numpy and PyTorch tensors at the same time\"\n+\n+        batch_size = batch_size if batch_size is not None else self.batch_size\n+        min_resolution = min_resolution if min_resolution is not None else self.min_resolution\n+        max_resolution = max_resolution if max_resolution is not None else self.max_resolution\n+        num_channels = num_channels if num_channels is not None else self.num_channels\n+        num_images = num_images if num_images is not None else self.num_images\n+\n+        images_list = []\n+        for i in range(batch_size):\n+            images = []\n+            for j in range(num_images):\n+                if equal_resolution:\n+                    width = height = max_resolution\n+                else:\n+                    # To avoid getting image width/height 0\n+                    if size_divisor is not None:\n+                        # If `size_divisor` is defined, the image needs to have width/size >= `size_divisor`\n+                        min_resolution = max(size_divisor, min_resolution)\n+                    width, height = np.random.choice(np.arange(min_resolution, max_resolution), 2)\n+                images.append(np.random.randint(255, size=(num_channels, width, height), dtype=np.uint8))\n+            images_list.append(images)\n+\n+        if not numpify and not torchify:\n+            # PIL expects the channel dimension as last dimension\n+            images_list = [[Image.fromarray(np.moveaxis(image, 0, -1)) for image in images] for images in images_list]\n+\n+        if torchify:\n+            images_list = [[torch.from_numpy(image) for image in images] for images in images_list]\n+\n+        if numpify:\n+            # Numpy images are typically in channels last format\n+            images_list = [[image.transpose(1, 2, 0) for image in images] for images in images_list]\n+\n+        return images_list\n+\n+\n+@require_torch\n+@require_vision\n+class Idefics3ImageProcessingTest(ImageProcessingTestMixin, unittest.TestCase):\n+    image_processing_class = Idefics3ImageProcessor if is_vision_available() else None\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.image_processor_tester = Idefics3ImageProcessingTester(self)\n+\n+    @property\n+    def image_processor_dict(self):\n+        return self.image_processor_tester.prepare_image_processor_dict()\n+\n+    def test_image_processor_properties(self):\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        self.assertTrue(hasattr(image_processing, \"do_convert_rgb\"))\n+        self.assertTrue(hasattr(image_processing, \"do_resize\"))\n+        self.assertTrue(hasattr(image_processing, \"size\"))\n+        self.assertTrue(hasattr(image_processing, \"resample\"))\n+        self.assertTrue(hasattr(image_processing, \"do_image_splitting\"))\n+        self.assertTrue(hasattr(image_processing, \"max_image_size\"))\n+        self.assertTrue(hasattr(image_processing, \"do_rescale\"))\n+        self.assertTrue(hasattr(image_processing, \"rescale_factor\"))\n+        self.assertTrue(hasattr(image_processing, \"do_normalize\"))\n+        self.assertTrue(hasattr(image_processing, \"image_mean\"))\n+        self.assertTrue(hasattr(image_processing, \"image_std\"))\n+        self.assertTrue(hasattr(image_processing, \"do_pad\"))\n+        self.assertTrue(hasattr(image_processing, \"do_image_splitting\"))\n+\n+    def test_call_numpy(self):\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = self.image_processing_class(**self.image_processor_dict)\n+            # create random numpy tensors\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False, numpify=True)\n+            for sample_images in image_inputs:\n+                for image in sample_images:\n+                    self.assertIsInstance(image, np.ndarray)\n+\n+            # Test not batched input\n+            encoded_images = image_processing(image_inputs[0], return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape([image_inputs[0]])\n+            self.assertEqual(tuple(encoded_images.shape), (1, *expected_output_image_shape))\n+\n+            # Test batched\n+            encoded_images = image_processing(image_inputs, return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape(image_inputs)\n+            self.assertEqual(\n+                tuple(encoded_images.shape), (self.image_processor_tester.batch_size, *expected_output_image_shape)\n+            )\n+\n+    def test_call_numpy_4_channels(self):\n+        # Idefics3 always processes images as RGB, so it always returns images with 3 channels\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processor_dict = self.image_processor_dict\n+            image_processing = self.image_processing_class(**image_processor_dict)\n+            # create random numpy tensors\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False, numpify=True)\n+\n+            for sample_images in image_inputs:\n+                for image in sample_images:\n+                    self.assertIsInstance(image, np.ndarray)\n+\n+            # Test not batched input\n+            encoded_images = image_processing(image_inputs[0], return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape([image_inputs[0]])\n+            self.assertEqual(tuple(encoded_images.shape), (1, *expected_output_image_shape))\n+\n+            # Test batched\n+            encoded_images = image_processing(image_inputs, return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape(image_inputs)\n+            self.assertEqual(\n+                tuple(encoded_images.shape), (self.image_processor_tester.batch_size, *expected_output_image_shape)\n+            )\n+\n+    def test_call_pil(self):\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = self.image_processing_class(**self.image_processor_dict)\n+            # create random PIL images\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False)\n+            for images in image_inputs:\n+                for image in images:\n+                    self.assertIsInstance(image, Image.Image)\n+\n+            # Test not batched input\n+            encoded_images = image_processing(image_inputs[0], return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape([image_inputs[0]])\n+            self.assertEqual(tuple(encoded_images.shape), (1, *expected_output_image_shape))\n+\n+            # Test batched\n+            encoded_images = image_processing(image_inputs, return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape(image_inputs)\n+            self.assertEqual(\n+                tuple(encoded_images.shape), (self.image_processor_tester.batch_size, *expected_output_image_shape)\n+            )\n+\n+    def test_call_pytorch(self):\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = self.image_processing_class(**self.image_processor_dict)\n+            # create random PyTorch tensors\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=False, torchify=True)\n+\n+            for images in image_inputs:\n+                for image in images:\n+                    self.assertIsInstance(image, torch.Tensor)\n+\n+            # Test not batched input\n+            encoded_images = image_processing(image_inputs[0], return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape([image_inputs[0]])\n+            self.assertEqual(tuple(encoded_images.shape), (1, *expected_output_image_shape))\n+\n+            # Test batched\n+            expected_output_image_shape = self.image_processor_tester.expected_output_image_shape(image_inputs)\n+            encoded_images = image_processing(image_inputs, return_tensors=\"pt\").pixel_values\n+            self.assertEqual(\n+                tuple(encoded_images.shape),\n+                (self.image_processor_tester.batch_size, *expected_output_image_shape),\n+            )"
        },
        {
            "sha": "550bb2785e0057bdb396ceeaf778807db7cad496",
            "filename": "tests/models/idefics3/test_modeling_idefics3.py",
            "status": "added",
            "additions": 529,
            "deletions": 0,
            "changes": 529,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/tests%2Fmodels%2Fidefics3%2Ftest_modeling_idefics3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/tests%2Fmodels%2Fidefics3%2Ftest_modeling_idefics3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fidefics3%2Ftest_modeling_idefics3.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -0,0 +1,529 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch Idefics3 model.\"\"\"\n+\n+import copy\n+import gc\n+import unittest\n+from io import BytesIO\n+\n+import requests\n+\n+from transformers import (\n+    AutoProcessor,\n+    is_torch_available,\n+    is_vision_available,\n+)\n+from transformers.testing_utils import require_bitsandbytes, require_torch, slow, torch_device\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import ModelTesterMixin, floats_tensor, ids_tensor\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import (\n+        Idefics3Config,\n+        Idefics3ForConditionalGeneration,\n+        Idefics3Model,\n+    )\n+else:\n+    is_torch_greater_or_equal_than_2_0 = False\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+class Idefics3VisionText2TextModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        is_training=True,\n+        batch_size=2,\n+        scale_factor=2,\n+        num_images=2,\n+        vision_config={\n+            \"image_size\": 16,\n+            \"patch_size\": 4,\n+            \"hidden_size\": 32,\n+            \"num_hidden_layers\": 2,\n+            \"num_attention_heads\": 4,\n+            \"intermediate_size\": 32,\n+            \"dropout\": 0.1,\n+            \"attention_dropout\": 0.1,\n+            \"initializer_range\": 0.02,\n+        },\n+        text_config={\n+            \"vocab_size\": 100,\n+            \"hidden_size\": 64,\n+            \"intermediate_size\": 56,\n+            \"num_hidden_layers\": 3,\n+            \"num_attention_heads\": 2,\n+            \"num_key_value_heads\": 2,\n+            \"hidden_act\": \"silu\",\n+            \"max_position_embeddings\": 256,\n+            \"initializer_range\": 0.02,\n+            \"rms_norm_eps\": 1e-6,\n+            \"pad_token_id\": 2,\n+            \"bos_token_id\": 0,\n+            \"eos_token_id\": 1,\n+            \"image_token_id\": 57,\n+            \"tie_word_embeddings\": False,\n+            \"rope_theta\": 10000.0,\n+            \"sliding_window\": 32,\n+            \"attention_dropout\": 0.0,\n+        },\n+        use_cache=False,\n+        tie_word_embeddings=False,\n+        image_token_id=57,\n+    ):\n+        self.parent = parent\n+        self.is_training = is_training\n+        self.batch_size = batch_size\n+        self.num_images = num_images\n+        self.scale_factor = scale_factor\n+        self.seq_length = (\n+            int(((vision_config[\"image_size\"] // vision_config[\"patch_size\"]) ** 2) / (self.scale_factor**2))\n+            * self.num_images\n+        )\n+        self.use_cache = use_cache\n+        self.image_token_id = image_token_id\n+        self.tie_word_embeddings = tie_word_embeddings\n+        # Hack - add properties here so use common tests\n+        self.vocab_size = text_config[\"vocab_size\"]\n+        self.num_hidden_layers = text_config[\"num_hidden_layers\"]\n+        self.num_attention_heads = text_config[\"num_attention_heads\"]\n+        self.hidden_size = text_config[\"hidden_size\"]\n+\n+        self.vision_config = vision_config\n+        self.text_config = text_config\n+\n+    def get_config(self):\n+        return Idefics3Config(\n+            use_cache=self.use_cache,\n+            image_token_id=self.image_token_id,\n+            tie_word_embeddings=self.tie_word_embeddings,\n+            vision_config=self.vision_config,\n+            text_config=self.text_config,\n+            vocab_size=self.vocab_size,\n+            scale_factor=self.scale_factor,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        pixel_values = floats_tensor(\n+            [\n+                self.batch_size,\n+                self.num_images,\n+                3,  # Idefics3ImageProcessor always generates RGB pixel values\n+                self.vision_config[\"image_size\"],\n+                self.vision_config[\"image_size\"],\n+            ]\n+        )\n+        config = self.get_config()\n+\n+        return config, pixel_values\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], config.text_config.vocab_size - 2) + 1\n+\n+        # For simplicity just set the last n tokens to the image token\n+        n_image_tokens_per_batch = self.seq_length\n+        input_ids[:, -n_image_tokens_per_batch:] = self.image_token_id\n+        attention_mask = input_ids.ne(1).to(torch_device)\n+        inputs_dict = {\n+            \"pixel_values\": pixel_values,\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+        }\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class Idefics3ModelTest(ModelTesterMixin, unittest.TestCase):\n+    \"\"\"\n+    Model tester for `Idefics3`.\n+    \"\"\"\n+\n+    all_model_classes = (Idefics3Model,) if is_torch_available() else ()\n+    fx_compatible = False\n+    test_torchscript = False\n+    test_pruning = False\n+    test_resize_embeddings = True\n+    test_head_masking = False\n+\n+    def setUp(self):\n+        self.model_tester = Idefics3VisionText2TextModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Idefics3Config, has_text_modality=False)\n+\n+    @unittest.skip(reason=\"input_embeds cannot be passed in without input_ids\")\n+    def test_inputs_embeds():\n+        pass\n+\n+    @unittest.skip(reason=\"input_embeds cannot be passed in without input_ids\")\n+    def test_inputs_embeds_matches_input_ids(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Model does not support padding right\")\n+    def test_flash_attn_2_generate_padding_right(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Model does not support padding right\")\n+    def test_flash_attn_2_inference_padding_right(self):\n+        pass\n+\n+    # We need to override as we need to prepare such that the image token is the last token\n+    def test_resize_tokens_embeddings(self):\n+        (original_config, inputs_dict) = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            config = copy.deepcopy(original_config)\n+            model = model_class(config)\n+            model.to(torch_device)\n+\n+            if self.model_tester.is_training is False:\n+                model.eval()\n+\n+            model_vocab_size = config.text_config.vocab_size\n+            # Retrieve the embeddings and clone theme\n+            model_embed = model.resize_token_embeddings(model_vocab_size)\n+            cloned_embeddings = model_embed.weight.clone()\n+\n+            # Check that resizing the token embeddings with a larger vocab size increases the model's vocab size\n+            model_embed = model.resize_token_embeddings(model_vocab_size + 10)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size + 10)\n+            # Check that it actually resizes the embeddings matrix\n+            self.assertEqual(model_embed.weight.shape[0], cloned_embeddings.shape[0] + 10)\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that resizing the token embeddings with a smaller vocab size decreases the model's vocab size\n+            model_embed = model.resize_token_embeddings(model_vocab_size - 15)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size - 15)\n+            # Check that it actually resizes the embeddings matrix\n+            self.assertEqual(model_embed.weight.shape[0], cloned_embeddings.shape[0] - 15)\n+\n+            # Ignore copy\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            # Input ids should be clamped to the maximum size of the vocabulary - 1 and the image token should be the last token\n+            inputs_dict[\"input_ids\"].clamp_(max=model_vocab_size - 15 - 2)\n+            n_images = self.model_tester.num_images * self.model_tester.seq_length\n+            model.image_token_id = model_vocab_size - 15 - 1\n+            inputs_dict[\"input_ids\"][:, -n_images:] = model.image_token_id\n+\n+            # make sure that decoder_input_ids are resized as well\n+            if \"decoder_input_ids\" in inputs_dict:\n+                inputs_dict[\"decoder_input_ids\"].clamp_(max=model_vocab_size - 15 - 1)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that adding and removing tokens has not modified the first part of the embedding matrix.\n+            models_equal = True\n+            for p1, p2 in zip(cloned_embeddings, model_embed.weight):\n+                if p1.data.ne(p2.data).sum() > 0:\n+                    models_equal = False\n+\n+            self.assertTrue(models_equal)\n+\n+            config = copy.deepcopy(original_config)\n+            model = model_class(config)\n+            model.to(torch_device)\n+\n+            model_vocab_size = config.text_config.vocab_size\n+            model.resize_token_embeddings(model_vocab_size + 10, pad_to_multiple_of=1)\n+            self.assertTrue(model.config.text_config.vocab_size + 10, model_vocab_size)\n+\n+            model_embed = model.resize_token_embeddings(model_vocab_size, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0] // 64, 0)\n+\n+            self.assertTrue(model_embed.weight.shape[0], model.config.text_config.vocab_size)\n+            self.assertTrue(model.config.text_config.vocab_size, model.vocab_size)\n+\n+            model_embed = model.resize_token_embeddings(model_vocab_size + 13, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0] // 64, 0)\n+\n+            # Check that resizing a model to a multiple of pad_to_multiple leads to a model of exactly that size\n+            target_dimension = 128\n+            model_embed = model.resize_token_embeddings(target_dimension, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0], target_dimension)\n+\n+            with self.assertRaisesRegex(\n+                ValueError,\n+                \"Asking to pad the embedding matrix to a multiple of `1.3`, which is not and integer. Please make sure to pass an integer\",\n+            ):\n+                model.resize_token_embeddings(model_vocab_size, pad_to_multiple_of=1.3)\n+\n+    # We need to override as we need to prepare such that the image token is the last token\n+    def test_resize_embeddings_untied(self):\n+        (original_config, inputs_dict) = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        original_config.tie_word_embeddings = False\n+\n+        for model_class in self.all_model_classes:\n+            config = copy.deepcopy(original_config)\n+            model = model_class(config).to(torch_device)\n+\n+            # if no output embeddings -> leave test\n+            if model.get_output_embeddings() is None:\n+                continue\n+\n+            # Check that resizing the token embeddings with a larger vocab size increases the model's vocab size\n+            model_vocab_size = config.text_config.vocab_size\n+            model.resize_token_embeddings(model_vocab_size + 10)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size + 10)\n+            output_embeds = model.get_output_embeddings()\n+            self.assertEqual(output_embeds.weight.shape[0], model_vocab_size + 10)\n+            # Check bias if present\n+            if output_embeds.bias is not None:\n+                self.assertEqual(output_embeds.bias.shape[0], model_vocab_size + 10)\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that resizing the token embeddings with a smaller vocab size decreases the model's vocab size\n+            model.resize_token_embeddings(model_vocab_size - 15)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size - 15)\n+            # Check that it actually resizes the embeddings matrix\n+            output_embeds = model.get_output_embeddings()\n+            self.assertEqual(output_embeds.weight.shape[0], model_vocab_size - 15)\n+            # Check bias if present\n+            if output_embeds.bias is not None:\n+                self.assertEqual(output_embeds.bias.shape[0], model_vocab_size - 15)\n+\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            # Input ids should be clamped to the maximum size of the vocabulary - 1 and the image token should be the last token\n+            inputs_dict[\"input_ids\"].clamp_(max=model_vocab_size - 15 - 2)\n+            n_images = self.model_tester.num_images * self.model_tester.seq_length\n+            model.image_token_id = model_vocab_size - 15 - 1\n+            inputs_dict[\"input_ids\"][:, -n_images:] = model.image_token_id\n+\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+\n+@require_torch\n+class Idefics3ForConditionalGenerationModelTest(GenerationTesterMixin, ModelTesterMixin, unittest.TestCase):\n+    \"\"\"\n+    Model tester for `Idefics3ForConditionalGeneration`.\n+    \"\"\"\n+\n+    all_model_classes = (Idefics3ForConditionalGeneration,) if is_torch_available() else ()\n+    fx_compatible = False\n+    test_pruning = False\n+    test_resize_embeddings = True\n+    test_head_masking = False\n+    test_torchscript = False\n+\n+    def setUp(self):\n+        self.model_tester = Idefics3VisionText2TextModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Idefics3Config, has_text_modality=False)\n+\n+    @unittest.skip(reason=\"input_embeds cannot be passed in without input_ids\")\n+    def test_inputs_embeds():\n+        pass\n+\n+    @unittest.skip(reason=\"Model does not support padding right\")\n+    def test_flash_attn_2_generate_padding_right(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Model does not support padding right\")\n+    def test_flash_attn_2_inference_padding_right(self):\n+        pass\n+\n+    # We need to override as we need to prepare such that the image token is the last token\n+    def test_resize_tokens_embeddings(self):\n+        (original_config, inputs_dict) = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            config = copy.deepcopy(original_config)\n+            model = model_class(config)\n+            model.to(torch_device)\n+\n+            model_vocab_size = config.text_config.vocab_size\n+            # Retrieve the embeddings and clone theme\n+            model_embed = model.resize_token_embeddings(model_vocab_size)\n+            cloned_embeddings = model_embed.weight.clone()\n+\n+            # Check that resizing the token embeddings with a larger vocab size increases the model's vocab size\n+            model_embed = model.resize_token_embeddings(model_vocab_size + 10)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size + 10)\n+            # Check that it actually resizes the embeddings matrix\n+            self.assertEqual(model_embed.weight.shape[0], cloned_embeddings.shape[0] + 10)\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that resizing the token embeddings with a smaller vocab size decreases the model's vocab size\n+            model_embed = model.resize_token_embeddings(model_vocab_size - 15)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size - 15)\n+            # Check that it actually resizes the embeddings matrix\n+            self.assertEqual(model_embed.weight.shape[0], cloned_embeddings.shape[0] - 15)\n+\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            # Input ids should be clamped to the maximum size of the vocabulary - 1 and the image token should be the last token\n+            inputs_dict[\"input_ids\"].clamp_(max=model_vocab_size - 15 - 2)\n+            n_images = self.model_tester.num_images * self.model_tester.seq_length\n+            model.model.image_token_id = model_vocab_size - 15 - 1\n+            inputs_dict[\"input_ids\"][:, -n_images:] = model.model.image_token_id\n+\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that adding and removing tokens has not modified the first part of the embedding matrix.\n+            models_equal = True\n+            for p1, p2 in zip(cloned_embeddings, model_embed.weight):\n+                if p1.data.ne(p2.data).sum() > 0:\n+                    models_equal = False\n+\n+            self.assertTrue(models_equal)\n+\n+            config = copy.deepcopy(original_config)\n+            model = model_class(config)\n+            model.to(torch_device)\n+\n+            model_vocab_size = config.text_config.vocab_size\n+            model.resize_token_embeddings(model_vocab_size + 10, pad_to_multiple_of=1)\n+            self.assertTrue(model.config.text_config.vocab_size + 10, model_vocab_size)\n+\n+            model_embed = model.resize_token_embeddings(model_vocab_size, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0] // 64, 0)\n+\n+            self.assertTrue(model_embed.weight.shape[0], model.config.text_config.vocab_size)\n+            self.assertTrue(model.config.text_config.vocab_size, model.vocab_size)\n+\n+            model_embed = model.resize_token_embeddings(model_vocab_size + 13, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0] // 64, 0)\n+\n+            # Check that resizing a model to a multiple of pad_to_multiple leads to a model of exactly that size\n+            target_dimension = 128\n+            model_embed = model.resize_token_embeddings(target_dimension, pad_to_multiple_of=64)\n+            self.assertTrue(model_embed.weight.shape[0], target_dimension)\n+\n+            with self.assertRaisesRegex(\n+                ValueError,\n+                \"Asking to pad the embedding matrix to a multiple of `1.3`, which is not and integer. Please make sure to pass an integer\",\n+            ):\n+                model.resize_token_embeddings(model_vocab_size, pad_to_multiple_of=1.3)\n+\n+    # We need to override as we need to prepare such that the image token is the last token\n+    def test_resize_embeddings_untied(self):\n+        (original_config, inputs_dict) = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        original_config.tie_word_embeddings = False\n+\n+        for model_class in self.all_model_classes:\n+            config = copy.deepcopy(original_config)\n+            model = model_class(config).to(torch_device)\n+\n+            # Check that resizing the token embeddings with a larger vocab size increases the model's vocab size\n+            model_vocab_size = config.text_config.vocab_size\n+            model.resize_token_embeddings(model_vocab_size + 10)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size + 10)\n+            output_embeds = model.get_output_embeddings()\n+            self.assertEqual(output_embeds.weight.shape[0], model_vocab_size + 10)\n+            # Check bias if present\n+            if output_embeds.bias is not None:\n+                self.assertEqual(output_embeds.bias.shape[0], model_vocab_size + 10)\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+            # Check that resizing the token embeddings with a smaller vocab size decreases the model's vocab size\n+            model.resize_token_embeddings(model_vocab_size - 15)\n+            self.assertEqual(model.config.text_config.vocab_size, model_vocab_size - 15)\n+            # Check that it actually resizes the embeddings matrix\n+            output_embeds = model.get_output_embeddings()\n+            self.assertEqual(output_embeds.weight.shape[0], model_vocab_size - 15)\n+            # Check bias if present\n+            if output_embeds.bias is not None:\n+                self.assertEqual(output_embeds.bias.shape[0], model_vocab_size - 15)\n+\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            # Input ids should be clamped to the maximum size of the vocabulary - 1 and the image token should be the last token\n+            inputs_dict[\"input_ids\"].clamp_(max=model_vocab_size - 15 - 2)\n+            n_images = self.model_tester.num_images * self.model_tester.seq_length\n+            model.model.image_token_id = model_vocab_size - 15 - 1\n+            inputs_dict[\"input_ids\"][:, -n_images:] = model.model.image_token_id\n+\n+            # Check that the model can still do a forward pass successfully (every parameter should be resized)\n+            model(**self._prepare_for_class(inputs_dict, model_class))\n+\n+\n+@require_torch\n+class Idefics3ForConditionalGenerationIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = AutoProcessor.from_pretrained(\"HuggingFaceM4/Idefics3-8B-Llama3\")\n+        self.image1 = Image.open(\n+            BytesIO(\n+                requests.get(\n+                    \"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\"\n+                ).content\n+            )\n+        )\n+        self.image2 = Image.open(\n+            BytesIO(requests.get(\"https://cdn.britannica.com/59/94459-050-DBA42467/Skyline-Chicago.jpg\").content)\n+        )\n+        self.image3 = Image.open(\n+            BytesIO(\n+                requests.get(\n+                    \"https://thumbs.dreamstime.com/b/golden-gate-bridge-san-francisco-purple-flowers-california-echium-candicans-36805947.jpg\"\n+                ).content\n+            )\n+        )\n+\n+    def tearDown(self):\n+        gc.collect()\n+        torch.cuda.empty_cache()\n+\n+    @slow\n+    @unittest.skip(\"multi-gpu tests are disabled for now\")\n+    def test_integration_test(self):\n+        model = Idefics3ForConditionalGeneration.from_pretrained(\n+            \"HuggingFaceM4/Idefics3-8B-Llama3\",\n+            torch_dtype=torch.bfloat16,\n+            device_map=\"auto\",\n+        )\n+\n+        # Create inputs\n+        text = \"<image>In this image, we see\"\n+        images = self.image1\n+        inputs = self.processor(text=text, images=images, return_tensors=\"pt\", padding=True)\n+        inputs.to(torch_device)\n+\n+        generated_ids = model.generate(**inputs, max_new_tokens=10)\n+        generated_texts = self.processor.batch_decode(generated_ids, skip_special_tokens=True)\n+\n+        expected_generated_text = \"<image>In this image, we see the Statue of Liberty, which is located on Liberty\"\n+        self.assertEqual(generated_texts[0], expected_generated_text)\n+\n+    @slow\n+    @require_bitsandbytes\n+    @unittest.skip(\"multi-gpu tests are disabled for now\")\n+    def test_integration_test_4bit(self):\n+        # Let' s make sure we test the preprocessing to replace what is used\n+        model = Idefics3ForConditionalGeneration.from_pretrained(\n+            \"HuggingFaceM4/Idefics3-8B-Llama3\",\n+            load_in_4bit=True,\n+            device_map=\"auto\",\n+        )\n+\n+        # Create pixel inputs\n+        text = [\"<image>In this image, we see\", \"bla, bla <image><image>\"]\n+        images = [[self.image1], [self.image2, self.image3]]\n+        inputs = self.processor(text=text, images=images, padding=True, return_tensors=\"pt\")\n+\n+        generated_ids = model.generate(**inputs, max_new_tokens=10)\n+        generated_texts = self.processor.batch_decode(generated_ids, skip_special_tokens=True)\n+\n+        expected_generated_text = \"<image>In this image, we see the Statue of Liberty, trees, buildings, water\"\n+        self.assertEqual(generated_texts[0], expected_generated_text)"
        },
        {
            "sha": "92f0fbb1f8e2689dbbac7c58ff61d2301c29cfa4",
            "filename": "tests/models/idefics3/test_processing_idefics3.py",
            "status": "added",
            "additions": 462,
            "deletions": 0,
            "changes": 462,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/tests%2Fmodels%2Fidefics3%2Ftest_processing_idefics3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/tests%2Fmodels%2Fidefics3%2Ftest_processing_idefics3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fidefics3%2Ftest_processing_idefics3.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -0,0 +1,462 @@\n+# coding=utf-8\n+# Copyright 2024 HuggingFace Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import shutil\n+import tempfile\n+import unittest\n+from io import BytesIO\n+\n+import numpy as np\n+import requests\n+\n+from transformers import Idefics3Processor\n+from transformers.models.auto.processing_auto import AutoProcessor\n+from transformers.testing_utils import require_torch, require_vision\n+from transformers.utils import is_vision_available\n+\n+from ...test_processing_common import ProcessorTesterMixin\n+\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+@require_torch\n+@require_vision\n+class Idefics3ProcessorTest(ProcessorTesterMixin, unittest.TestCase):\n+    processor_class = Idefics3Processor\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.tmpdirname = tempfile.mkdtemp()\n+        processor = Idefics3Processor.from_pretrained(\"HuggingFaceM4/Idefics3-8B-Llama3\", image_seq_len=2)\n+        processor.save_pretrained(cls.tmpdirname)\n+        cls.image1 = Image.open(\n+            BytesIO(\n+                requests.get(\n+                    \"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\"\n+                ).content\n+            )\n+        )\n+        cls.image2 = Image.open(\n+            BytesIO(requests.get(\"https://cdn.britannica.com/59/94459-050-DBA42467/Skyline-Chicago.jpg\").content)\n+        )\n+        cls.image3 = Image.open(\n+            BytesIO(\n+                requests.get(\n+                    \"https://thumbs.dreamstime.com/b/golden-gate-bridge-san-francisco-purple-flowers-california-echium-candicans-36805947.jpg\"\n+                ).content\n+            )\n+        )\n+        cls.bos_token = processor.tokenizer.bos_token\n+        cls.image_token = processor.image_token.content\n+        cls.fake_image_token = processor.fake_image_token.content\n+        cls.global_img_token = processor.global_image_tag\n+\n+        cls.bos_token_id = processor.tokenizer.convert_tokens_to_ids(cls.bos_token)\n+        cls.image_token_id = processor.tokenizer.convert_tokens_to_ids(cls.image_token)\n+        cls.fake_image_token_id = processor.tokenizer.convert_tokens_to_ids(cls.fake_image_token)\n+        cls.global_img_tokens_id = processor.tokenizer(cls.global_img_token, add_special_tokens=False)[\"input_ids\"]\n+        cls.padding_token_id = processor.tokenizer.pad_token_id\n+        cls.image_seq_len = processor.image_seq_len\n+\n+    def get_tokenizer(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).tokenizer\n+\n+    def get_image_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).image_processor\n+\n+    def get_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs)\n+\n+    def get_split_image_expected_tokens(self, processor, image_rows, image_cols):\n+        text_split_images = []\n+        for n_h in range(image_rows):\n+            for n_w in range(image_cols):\n+                text_split_images += (\n+                    [self.fake_image_token_id]\n+                    + processor.tokenizer(f\"<row_{n_h + 1}_col_{n_w + 1}>\", add_special_tokens=False)[\"input_ids\"]\n+                    + [self.image_token_id] * self.image_seq_len\n+                )\n+            text_split_images += processor.tokenizer(\"\\n\", add_special_tokens=False)[\"input_ids\"]\n+        text_split_images = text_split_images[:-1]  # remove last newline\n+        # add double newline, as it gets its own token\n+        text_split_images += processor.tokenizer(\"\\n\\n\", add_special_tokens=False)[\"input_ids\"]\n+        text_split_images += (\n+            [self.fake_image_token_id]\n+            + self.global_img_tokens_id\n+            + [self.image_token_id] * self.image_seq_len\n+            + [self.fake_image_token_id]\n+        )\n+        return text_split_images\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        shutil.rmtree(cls.tmpdirname)\n+\n+    def test_process_interleaved_images_prompts_no_image_splitting(self):\n+        processor = self.get_processor()\n+        processor.image_processor.do_image_splitting = False\n+\n+        # Test that a single image is processed correctly\n+        inputs = processor(images=self.image1)\n+        image1_expected_size = (364, 364)\n+        self.assertEqual(np.array(inputs[\"pixel_values\"]).shape, (1, 1, 3, *image1_expected_size))\n+        self.assertEqual(np.array(inputs[\"pixel_attention_mask\"]).shape, (1, 1, *image1_expected_size))\n+        # fmt: on\n+\n+        # Test a single sample with image and text\n+        image_str = \"<image>\"\n+        text_str = \"In this image, we see\"\n+        text = image_str + text_str\n+        inputs = processor(text=text, images=self.image1)\n+\n+        # fmt: off\n+        tokenized_sentence = processor.tokenizer(text_str, add_special_tokens=False)\n+        expected_input_ids = [[self.bos_token_id] + [self.fake_image_token_id] + self.global_img_tokens_id + [self.image_token_id] * self.image_seq_len + [self.fake_image_token_id] + tokenized_sentence[\"input_ids\"]]\n+        self.assertEqual(inputs[\"input_ids\"], expected_input_ids)\n+        self.assertEqual(inputs[\"attention_mask\"], [[1] * len(expected_input_ids[0])])\n+        self.assertEqual(np.array(inputs[\"pixel_values\"]).shape, (1, 1, 3, *image1_expected_size))\n+        self.assertEqual(np.array(inputs[\"pixel_attention_mask\"]).shape, (1, 1, *image1_expected_size))\n+        # fmt: on\n+\n+        # Test that batch is correctly processed\n+        image_str = \"<image>\"\n+        text_str_1 = \"In this image, we see\"\n+        text_str_2 = \"In this image, we see\"\n+\n+        text = [\n+            image_str + text_str_1,\n+            image_str + image_str + text_str_2,\n+        ]\n+        images = [[self.image1], [self.image2, self.image3]]\n+\n+        inputs = processor(text=text, images=images, padding=True)\n+\n+        # fmt: off\n+        tokenized_sentence_1 = processor.tokenizer(text_str_1, add_special_tokens=False)\n+        tokenized_sentence_2 = processor.tokenizer(text_str_2, add_special_tokens=False)\n+        image_tokens = [self.fake_image_token_id] + self.global_img_tokens_id + [self.image_token_id] * self.image_seq_len + [self.fake_image_token_id]\n+        expected_input_ids_1 = [self.bos_token_id] + image_tokens + tokenized_sentence_1[\"input_ids\"]\n+        expected_input_ids_2 = [self.bos_token_id] + 2 * image_tokens + tokenized_sentence_2[\"input_ids\"]\n+        # Pad the first input to match the second input\n+        pad_len = len(expected_input_ids_2) - len(expected_input_ids_1)\n+        padded_expected_input_ids_1 = [self.padding_token_id] * pad_len + expected_input_ids_1\n+\n+        self.assertEqual(\n+            inputs[\"input_ids\"], [padded_expected_input_ids_1, expected_input_ids_2]\n+        )\n+        self.assertEqual(\n+            inputs[\"attention_mask\"],\n+            [[0] * pad_len + [1] * len(expected_input_ids_1), [1] * len(expected_input_ids_2)]\n+        )\n+        self.assertEqual(np.array(inputs['pixel_values']).shape, (2, 2, 3, 364, 364))\n+        self.assertEqual(np.array(inputs['pixel_attention_mask']).shape, (2, 2, 364, 364))\n+        # fmt: on\n+\n+    def test_process_interleaved_images_prompts_image_splitting(self):\n+        processor = self.get_processor()\n+        processor.image_processor.do_image_splitting = True\n+\n+        # Test that a single image is processed correctly\n+        inputs = processor(images=self.image1)\n+        self.assertEqual(np.array(inputs[\"pixel_values\"]).shape, (1, 13, 3, 364, 364))\n+        self.assertEqual(np.array(inputs[\"pixel_attention_mask\"]).shape, (1, 13, 364, 364))\n+        # fmt: on\n+        self.maxDiff = None\n+\n+        # Test a single sample with image and text\n+        image_str = \"<image>\"\n+        text_str = \"In this image, we see\"\n+        text = image_str + text_str\n+        inputs = processor(text=text, images=self.image1)\n+\n+        # fmt: off\n+        tokenized_sentence = processor.tokenizer(text_str, add_special_tokens=False)\n+        split_image1_tokens = self.get_split_image_expected_tokens(processor, 3, 4)\n+        expected_input_ids_1 = [[self.bos_token_id] + split_image1_tokens + tokenized_sentence[\"input_ids\"]]\n+        self.assertEqual(inputs[\"input_ids\"], expected_input_ids_1)\n+        self.assertEqual(inputs[\"attention_mask\"], [[1] * len(expected_input_ids_1[0])])\n+        self.assertEqual(np.array(inputs[\"pixel_values\"]).shape, (1, 13, 3, 364, 364))\n+        self.assertEqual(np.array(inputs[\"pixel_attention_mask\"]).shape, (1, 13, 364, 364))\n+        # fmt: on\n+\n+        # Test that batch is correctly processed\n+        image_str = \"<image>\"\n+        text_str_1 = \"In this image, we see\"\n+        text_str_2 = \"bla, bla\"\n+\n+        text = [\n+            image_str + text_str_1,\n+            text_str_2 + image_str + image_str,\n+        ]\n+        images = [[self.image1], [self.image2, self.image3]]\n+\n+        inputs = processor(text=text, images=images, padding=True)\n+\n+        # fmt: off\n+        tokenized_sentence_1 = processor.tokenizer(text_str_1, add_special_tokens=False)\n+        tokenized_sentence_2 = processor.tokenizer(text_str_2, add_special_tokens=False)\n+\n+        split_image1_tokens = self.get_split_image_expected_tokens(processor, 3, 4)\n+        split_image2_tokens = self.get_split_image_expected_tokens(processor, 4, 4)\n+        split_image3_tokens = self.get_split_image_expected_tokens(processor, 3, 4)\n+        expected_input_ids_1 = [self.bos_token_id] + split_image1_tokens + tokenized_sentence_1[\"input_ids\"]\n+        expected_input_ids_2 = [self.bos_token_id] + tokenized_sentence_2[\"input_ids\"] + split_image2_tokens + split_image3_tokens\n+        # Pad the first input to match the second input\n+        pad_len = len(expected_input_ids_2) - len(expected_input_ids_1)\n+        padded_expected_input_ids_1 = [self.padding_token_id] * pad_len + expected_input_ids_1\n+\n+        self.assertEqual(\n+            inputs[\"input_ids\"], [padded_expected_input_ids_1, expected_input_ids_2]\n+        )\n+        self.assertEqual(\n+            inputs[\"attention_mask\"],\n+            [[0] * pad_len + [1] * len(expected_input_ids_1), [1] * len(expected_input_ids_2)]\n+        )\n+        self.assertEqual(np.array(inputs['pixel_values']).shape, (2, 30, 3, 364, 364))\n+        self.assertEqual(np.array(inputs['pixel_attention_mask']).shape, (2, 30, 364, 364))\n+        # fmt: on\n+\n+    def test_add_special_tokens_processor(self):\n+        processor = self.get_processor()\n+\n+        image_str = \"<image>\"\n+        text_str = \"In this image, we see\"\n+        text = text_str + image_str\n+\n+        # fmt: off\n+        inputs = processor(text=text, images=self.image1, add_special_tokens=False)\n+        tokenized_sentence = processor.tokenizer(text_str, add_special_tokens=False)\n+        split_image1_tokens = self.get_split_image_expected_tokens(processor, 3, 4)\n+        expected_input_ids = [tokenized_sentence[\"input_ids\"] + split_image1_tokens]\n+        self.assertEqual(inputs[\"input_ids\"], expected_input_ids)\n+\n+        inputs = processor(text=text, images=self.image1)\n+        expected_input_ids = [[self.bos_token_id] + tokenized_sentence[\"input_ids\"] + split_image1_tokens]\n+        self.assertEqual(inputs[\"input_ids\"], expected_input_ids)\n+        # fmt: on\n+\n+    def test_apply_chat_template(self):\n+        # Message contains content which a mix of lists with images and image urls and string\n+        messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"text\", \"text\": \"What do these images show?\"},\n+                    {\"type\": \"image\"},\n+                    {\"type\": \"image\"},\n+                    \"What do these images show?\",\n+                ],\n+            },\n+            {\n+                \"role\": \"assistant\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"text\",\n+                        \"text\": \"The first image shows the statue of Liberty in New York. The second image picture depicts Idefix, the dog of Obelix in Asterix and Obelix.\",\n+                    }\n+                ],\n+            },\n+            {\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"And who is that?\"}]},\n+        ]\n+        processor = self.get_processor()\n+        # Make short sequence length to test that the fake tokens are added correctly\n+        rendered = processor.apply_chat_template(messages, add_generation_prompt=True)\n+\n+        expected_rendered = (\n+            \"<|begin_of_text|>User: What do these images show?<image><image><end_of_utterance>\\n\"\n+            \"Assistant: The first image shows the statue of Liberty in New York. The second image picture depicts Idefix, the dog of Obelix in Asterix and Obelix.<end_of_utterance>\\n\"\n+            \"User: And who is that?<end_of_utterance>\\n\"\n+            \"Assistant:\"\n+        )\n+        self.assertEqual(rendered, expected_rendered)\n+\n+    @require_torch\n+    @require_vision\n+    def test_image_processor_defaults_preserved_by_image_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\", max_length=117)\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = \"lower newer <image>\"\n+        image_input = self.prepare_image_inputs()\n+\n+        inputs = processor(text=input_str, images=image_input)\n+        self.assertEqual(len(inputs[\"pixel_values\"][0][0]), 3)\n+        self.assertEqual(len(inputs[\"pixel_values\"][0][0][0]), 364)  # crop size doesn't affect our image processor\n+\n+    @require_torch\n+    @require_vision\n+    def test_kwargs_overrides_default_image_processor_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\n+            \"image_processor\", max_image_size={\"longest_edge\": 32}, size={\"longest_edge\": 32}\n+        )\n+        tokenizer = self.get_component(\"tokenizer\", max_length=117, padding=\"max_length\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor, image_seq_len=2)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = \"lower newer <image>\"\n+        image_input = self.prepare_image_inputs()\n+\n+        inputs = processor(text=input_str, images=image_input)\n+        self.assertEqual(len(inputs[\"pixel_values\"][0][0]), 3)\n+        self.assertEqual(len(inputs[\"pixel_values\"][0][0][0]), 32)\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 117)\n+\n+    @require_vision\n+    @require_torch\n+    def test_kwargs_overrides_default_tokenizer_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\", max_length=30)\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+        input_str = \"lower newer<image>\"\n+        image_input = self.prepare_image_inputs()\n+\n+        inputs = processor(text=input_str, images=image_input, return_tensors=\"pt\", max_length=30)\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 30)\n+\n+    @require_torch\n+    @require_vision\n+    def test_structured_kwargs_nested(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = \"lower newer<image>\"\n+        image_input = self.prepare_image_inputs()\n+\n+        # Define the kwargs for each modality\n+        inputs = processor(\n+            text=input_str,\n+            images=image_input,\n+            common_kwargs={\"return_tensors\": \"pt\"},\n+            images_kwargs={\"max_image_size\": {\"longest_edge\": 32}},\n+            text_kwargs={\"padding\": \"max_length\", \"max_length\": 120, \"truncation\": \"longest_first\"},\n+        )\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        self.assertEqual(inputs[\"pixel_values\"].shape[3], 32)\n+\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 120)\n+\n+    @require_torch\n+    @require_vision\n+    def test_structured_kwargs_nested_from_dict(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+        input_str = \"lower newer<image>\"\n+        image_input = self.prepare_image_inputs()\n+\n+        # Define the kwargs for each modality\n+        all_kwargs = {\n+            \"common_kwargs\": {\"return_tensors\": \"pt\"},\n+            \"images_kwargs\": {\"max_image_size\": {\"longest_edge\": 32}},\n+            \"text_kwargs\": {\"padding\": \"max_length\", \"max_length\": 120, \"truncation\": \"longest_first\"},\n+        }\n+\n+        inputs = processor(text=input_str, images=image_input, **all_kwargs)\n+        self.assertEqual(inputs[\"pixel_values\"].shape[3], 32)\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 120)\n+\n+    @require_vision\n+    @require_torch\n+    def test_tokenizer_defaults_preserved_by_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\", max_length=30)\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+        input_str = \"lower newer<image>\"\n+        image_input = self.prepare_image_inputs()\n+\n+        inputs = processor(text=input_str, images=image_input, return_tensors=\"pt\")\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 30)\n+\n+    @require_torch\n+    @require_vision\n+    def test_unstructured_kwargs_batched(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = [\"<image>lower newer\", \"<image>upper older longer string\"]\n+        image_input = self.prepare_image_inputs()\n+        inputs = processor(\n+            text=input_str,\n+            images=[image_input, image_input],\n+            return_tensors=\"pt\",\n+            padding=\"longest\",\n+            max_length=76,\n+            truncation=True,\n+            max_image_size={\"longest_edge\": 30},\n+        )\n+\n+        self.assertEqual(inputs[\"pixel_values\"].shape[2], 3)\n+        self.assertEqual(inputs[\"pixel_values\"].shape[3], 30)\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 76)\n+\n+    @require_torch\n+    @require_vision\n+    def test_unstructured_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = \"lower newer<image>\"\n+        image_input = self.prepare_image_inputs()\n+        inputs = processor(\n+            text=input_str,\n+            images=image_input,\n+            return_tensors=\"pt\",\n+            max_image_size={\"longest_edge\": 32},\n+            padding=\"max_length\",\n+            max_length=120,\n+            truncation=\"longest_first\",\n+        )\n+\n+        self.assertEqual(inputs[\"pixel_values\"].shape[3], 32)\n+        self.assertEqual(len(inputs[\"input_ids\"][0]), 120)"
        },
        {
            "sha": "75bd2ed1c6bfda17314b6b3ce824c14c4602f13a",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f2c388e3f946862f657acc1e21b272ec946fc66c/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f2c388e3f946862f657acc1e21b272ec946fc66c/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=f2c388e3f946862f657acc1e21b272ec946fc66c",
            "patch": "@@ -82,6 +82,7 @@\n     \"SeamlessM4Tv2TextToUnitModel\",\n     \"SeamlessM4Tv2CodeHifiGan\",\n     \"SeamlessM4Tv2TextToUnitForConditionalGeneration\",\n+    \"Idefics3VisionTransformer\",\n ]\n \n # Update this list for models that are not tested with a comment explaining the reason it should not be."
        }
    ],
    "stats": {
        "total": 4484,
        "additions": 4482,
        "deletions": 2
    }
}