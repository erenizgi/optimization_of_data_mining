{
    "author": "jacobkahn",
    "message": "Add Code World Model (CWM) (#41199)\n\n* [wip][cwm] Code World Model stubs and setup in HF Transformers\n\n* [wip] Get other things working\n\n* [wip] Working\n\n* Tokenizer pad\n\n* fix: cwm window attn\n\n* temp remove test\n\n* temp remove test\n\n* Fixes\n\n* Temporarily add auto config remapping option until VLLM 0.11 is out\n\n* Fix model type and add layer validation\n\n* Lint, remove CwmForSequenceClassification\n\n* Lint, tests\n\n* Remove CwmForSequenceClassification\n\n* Lint\n\n* Remove intermediary layer expors/doc errorss, fix tests\n\n* Lint\n\n* run python utils/sort_auto_mappings.py --check_only\n\n* Remove Cwm processor mapping, get check_repo passing\n\n* Remove CwmTextConfig from test\n\n* Add docstring for CwmConfig\n\n* remove global_window and window_pattern params from config\n\n* Fix docstrings\n\n* Revert change to auto docstring util\n\n* lint\n\n* Fixes minus test improvements\n\n* Alter tests to simply check logits\n\n* lint\n\n* Have slow tests use repo, make CwmPretrainedModel passthrough\n\n* Remove decoder layer implementation, use Llama3Decoder + CwmAttetion\n\n* Use linear w/o bias for CwmAttention, add token-level integration test\n\n* Don't ignore config attention bias\n\n* Remove attention bias parameter entirely from config\n\n---------\n\nCo-authored-by: galco <galco@meta.com>",
    "sha": "0eae41ad36c2a9823bf3906eb9e332f125583998",
    "files": [
        {
            "sha": "abe305eedd671f4f302aeb7d63b533cf7322aec5",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=0eae41ad36c2a9823bf3906eb9e332f125583998",
            "patch": "@@ -1026,6 +1026,8 @@\n         title: CLIPSeg\n       - local: model_doc/clvp\n         title: CLVP\n+      - local: model_doc/cwm\n+        title: Code World Model (CWM)\n       - local: model_doc/cohere2_vision\n         title: Cohere2Vision\n       - local: model_doc/colpali"
        },
        {
            "sha": "c789d1abdab1235f47bda5e3460d8eae8ec83f44",
            "filename": "docs/source/en/model_doc/cwm.md",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/docs%2Fsource%2Fen%2Fmodel_doc%2Fcwm.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/docs%2Fsource%2Fen%2Fmodel_doc%2Fcwm.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fcwm.md?ref=0eae41ad36c2a9823bf3906eb9e332f125583998",
            "patch": "@@ -0,0 +1,186 @@\n+<-- Copyright 2025 the HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be rendered properly in your Markdown viewer.\n+\n+-->\n+\n+\n+# Code World Model (CWM)\n+\n+## Overview\n+\n+The Code World Model (CWM) model was proposed in [CWM: An Open-Weights LLM for Research on Code\n+Generation with World Models](https://ai.facebook.com/research/publications/cwm) by Meta FAIR CodeGen Team.\n+CWM is an LLM for code generation and reasoning about code that has, in particular, been trained\n+to better represent and reason about how code and commands affect the state of a program or system.\n+Specifically, we mid-trained CWM on a large number of observation-action trajectories from Python\n+execution traces and agentic interactions in containerized environments. We post-trained with\n+extensive multi-task RL in verifiable coding, math, and multi-turn software engineering environments.\n+\n+The abstract from the paper is the following:\n+\n+> *We release Code World Model (CWM), a 32-billion-parameter open-weights LLM, to advance research\n+on code generation with world models. To improve code understanding beyond what can be learned\n+from training on static code alone, we mid-train CWM on a large amount of observation-action\n+trajectories from Python interpreter and agentic Docker environments, and perform extensive multi-\n+task reasoning RL in verifiable coding, math, and multi-turn software engineering environments. With\n+CWM, we provide a strong testbed for researchers to explore the opportunities world modeling affords\n+for improving code generation with reasoning and planning in computational environments. We\n+present first steps of how world models can benefit agentic coding, enable step-by-step simulation of\n+Python code execution, and show early results of how reasoning can benefit from the latter. CWM is\n+a dense, decoder-only LLM trained with a context size of up to 131 k tokens. Independent of its world\n+modeling capabilities, CWM offers strong performance on general coding and math tasks: it reaches\n+pass@1 scores of 65.8 % on SWE-bench Verified (with test-time scaling), 68.9 % on LiveCodeBench,\n+96.6 % on Math-500, and 76.0 % on AIME 2024. To support further research on code world modeling,\n+we release model checkpoints after mid-training, SFT, and RL.*\n+\n+Tips:\n+\n+CWM requires a dedicated system prompt to function optimally during inference. Without proper prompt\n+configuration, CWM's output quality may be significantly degraded. The following serves as the default\n+system prompt for reasoning tasks. For agentic workflows, append the relevant tool specifications\n+after this base prompt. Checkout the original code repository for more details.\n+```\n+You are a helpful AI assistant. You always reason before responding, using the following format:\n+\n+<think>\n+your internal reasoning\n+</think>\n+your external response\n+```\n+\n+This model was contributed by [Meta FAIR CodeGen Team](https://huggingface.co/facebook).\n+The original code can be found [here](https://github.com/facebookresearch/cwm).\n+\n+## Usage examples\n+\n+```python\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+model_name = 'facebook/cwm'\n+tokenizer = AutoTokenizer.from_pretrained(model_name)\n+model = AutoModelForCausalLM.from_pretrained(\n+    model_name,\n+    dtype=\"auto\",\n+    device_map=\"auto\"\n+)\n+\n+system_prompt = \"\"\"\n+You are a helpful AI assistant. You always reason before responding, using the following format:\n+\n+<think>\n+your internal reasoning\n+</think>\n+your external response\n+\"\"\".strip()\n+\n+messages = [\n+    {\"role\": \"system\", \"content\": system_prompt},\n+    {\"role\": \"user\", \"content\": \"Write a haiku about recursion in programming.\"}\n+]\n+\n+\n+text = tokenizer.apply_chat_template(\n+    messages,\n+    tokenize=False,\n+    add_generation_prompt=True,\n+    enable_thinking=True, # Switches between thinking and non-thinking modes. Default is True.\n+    preserve_previous_think=True, # Switches between keeping thinking blocks from previous messages or not. Default is True.\n+)\n+\n+model_inputs = tokenizer([text], return_tensors=\"pt\").to(model.device)\n+\n+generated_ids = model.generate(\n+    **model_inputs,\n+    max_new_tokens=1024\n+)\n+output_ids = generated_ids[0][len(model_inputs.input_ids[0]):].tolist()\n+print(tokenizer.decode(output_ids))\n+```\n+<details>\n+<summary>Produces the following output:</summary>\n+\n+    Okay, I need to write a haiku about recursion in programming. Let's start by recalling what recursion is. Recursion is a programming technique where a function calls itself in its own definition, often used to solve problems that can be broken down into smaller, similar sub-problems.\n+\n+    A haiku is a three-line poem with a syllable count of 5-7-5. So, I need to capture the essence of recursion in a concise and poetic way. Let's think about the key elements of recursion: the function calling itself, the base case that stops the recursion, and the idea of breaking down problems into smaller parts.\n+\n+    Maybe I can use imagery related to mirrors or reflections, since recursion often involves a function reflecting or repeating itself. Alternatively, I could use natural imagery like a spiral or a tree, which suggests self-similar patterns.\n+\n+    Let me try to come up with some ideas. For example, \"Function calls itself\" could be a starting point. But how to make that into a haiku? Maybe something like:\n+\n+    Function calls itself\n+    Base case stops the endless loop\n+    Spiral of code\n+\n+    Hmm, that's a start. But maybe I can make it more poetic. Let's think about the idea of a function calling itself as a kind of infinite loop, but with a base case that stops it. That's like a spiral that unwinds at the center.\n+\n+    Another angle: recursion is often used for problems that have a recursive structure, like tree traversals or factorial calculations. Maybe I can use a natural image to represent that.\n+\n+    How about:\n+\n+    Branches split again\n+    Leaves unfold in endless dance\n+    Roots hold the base case\n+\n+    That's a bit more poetic. The branches splitting represent the recursive calls, the leaves unfolding could represent the processing of each sub-problem, and the roots holding the base case are what stops the recursion.\n+\n+    Alternatively, maybe something simpler:\n+\n+    Mirror within mirror\n+    Reflections infinite deep\n+    Base case breaks the glass\n+\n+    This uses the mirror metaphor to represent the function calling itself, with the base case being the point where the recursion stops, breaking the infinite reflection.\n+\n+    I think I like the mirror idea better. Let me refine that:\n+\n+    Mirror within mirror\n+    Infinite reflections dance\n+    Base case shatters glass\n+\n+    Yes, that seems to capture the idea of recursion well. The mirror represents the function calling itself, the infinite reflections are the recursive calls, and the base case shattering the glass is what stops the recursion.\n+\n+    Let me check the syllable count:\n+\n+    Mirror within mirror (5 syllables: Mir-ror-with-in-mir-ror)\n+    Infinite reflections dance (7 syllables: In-fi-nite-ref-lec-tions-dance)\n+    Base case shatters glass (5 syllables: Base-case-shat-ters-glass)\n+\n+    Yes, that fits the 5-7-5 structure. I think that's a good haiku about recursion.\n+    </think>\n+    Mirror within mirror\n+    Infinite reflections dance\n+    Base case shatters glass<|eot_id|>\n+\n+</details>\n+\n+## CwmConfig\n+\n+[[autodoc]] CwmConfig\n+\n+## CwmPreTrainedModel\n+\n+[[autodoc]] CwmPreTrainedModel\n+    - forward\n+\n+## CwmModel\n+\n+[[autodoc]] CwmModel\n+    - forward\n+\n+## CwmForCausalLM\n+\n+[[autodoc]] CwmForCausalLM"
        },
        {
            "sha": "33f068abe3b40744834bc6601f8a96119089ea1e",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=0eae41ad36c2a9823bf3906eb9e332f125583998",
            "patch": "@@ -76,6 +76,7 @@\n     from .csm import *\n     from .ctrl import *\n     from .cvt import *\n+    from .cwm import *\n     from .d_fine import *\n     from .dab_detr import *\n     from .dac import *"
        },
        {
            "sha": "589d56eb958bad4a5de67a47237b7a6a9e6e6d8b",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=0eae41ad36c2a9823bf3906eb9e332f125583998",
            "patch": "@@ -94,6 +94,7 @@\n         (\"csm\", \"CsmConfig\"),\n         (\"ctrl\", \"CTRLConfig\"),\n         (\"cvt\", \"CvtConfig\"),\n+        (\"cwm\", \"CwmConfig\"),\n         (\"d_fine\", \"DFineConfig\"),\n         (\"dab-detr\", \"DabDetrConfig\"),\n         (\"dac\", \"DacConfig\"),\n@@ -529,6 +530,7 @@\n         (\"csm\", \"CSM\"),\n         (\"ctrl\", \"CTRL\"),\n         (\"cvt\", \"CvT\"),\n+        (\"cwm\", \"Code World Model (CWM)\"),\n         (\"d_fine\", \"D-FINE\"),\n         (\"dab-detr\", \"DAB-DETR\"),\n         (\"dac\", \"DAC\"),"
        },
        {
            "sha": "fb2d722336495c2f40eee663e63762e06e0ae9ca",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=0eae41ad36c2a9823bf3906eb9e332f125583998",
            "patch": "@@ -99,6 +99,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"csm\", \"CsmForConditionalGeneration\"),\n         (\"ctrl\", \"CTRLModel\"),\n         (\"cvt\", \"CvtModel\"),\n+        (\"cwm\", \"CwmModel\"),\n         (\"d_fine\", \"DFineModel\"),\n         (\"dab-detr\", \"DabDetrModel\"),\n         (\"dac\", \"DacModel\"),\n@@ -647,6 +648,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"cohere2\", \"Cohere2ForCausalLM\"),\n         (\"cpmant\", \"CpmAntForCausalLM\"),\n         (\"ctrl\", \"CTRLLMHeadModel\"),\n+        (\"cwm\", \"CwmForCausalLM\"),\n         (\"data2vec-text\", \"Data2VecTextForCausalLM\"),\n         (\"dbrx\", \"DbrxForCausalLM\"),\n         (\"deepseek_v2\", \"DeepseekV2ForCausalLM\"),"
        },
        {
            "sha": "7ab64ff70cbda390f50bae8427273fee7537b64b",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=0eae41ad36c2a9823bf3906eb9e332f125583998",
            "patch": "@@ -170,6 +170,13 @@\n         (\"cpmant\", (\"CpmAntTokenizer\", None)),\n         (\"csm\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"ctrl\", (\"CTRLTokenizer\", None)),\n+        (\n+            \"cwm\",\n+            (\n+                \"LlamaTokenizer\" if is_sentencepiece_available() else None,\n+                \"LlamaTokenizerFast\" if is_tokenizers_available() else None,\n+            ),\n+        ),\n         (\"data2vec-audio\", (\"Wav2Vec2CTCTokenizer\", None)),\n         (\"data2vec-text\", (\"RobertaTokenizer\", \"RobertaTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"dbrx\", (\"GPT2Tokenizer\", \"GPT2TokenizerFast\" if is_tokenizers_available() else None)),"
        },
        {
            "sha": "93c906ce6db979d5c222f39ed0f6db64ab3d114b",
            "filename": "src/transformers/models/cwm/__init__.py",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fcwm%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fcwm%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fcwm%2F__init__.py?ref=0eae41ad36c2a9823bf3906eb9e332f125583998",
            "patch": "@@ -0,0 +1,29 @@\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_cwm import *\n+    from .modeling_cwm import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "8dd2887722f71910baaa0d7d1fc5d18e62206d00",
            "filename": "src/transformers/models/cwm/configuration_cwm.py",
            "status": "added",
            "additions": 196,
            "deletions": 0,
            "changes": 196,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fcwm%2Fconfiguration_cwm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fcwm%2Fconfiguration_cwm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fcwm%2Fconfiguration_cwm.py?ref=0eae41ad36c2a9823bf3906eb9e332f125583998",
            "patch": "@@ -0,0 +1,196 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/cwm/modular_cwm.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_cwm.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import Optional\n+\n+from ...configuration_utils import PretrainedConfig, layer_type_validation\n+from ...modeling_rope_utils import rope_config_validation\n+\n+\n+class CwmConfig(PretrainedConfig):\n+    \"\"\"\n+    Configuration for Code World Model (CWM).\n+    This is an inherited Llama3-compatible configuration with layer-interleaved\n+    sliding-window attention. Configures a `CwmModel`. Designed to yield a configuartion mirroring the model in the\n+    [facebook/cwm](https://huggingface.co/facebook/cwm) architecture by default. Other models include:\n+    - [facebook/cwm-sft](https://huggingface.co/facebook/cwm-sft)\n+    - [facebook/cwm-pretrain](https://huggingface.co/facebook/cwm-pretrain)\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 128256):\n+            Vocabulary size of the CWM model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`CwmModel`]\n+        hidden_size (`int`, *optional*, defaults to 6144):\n+            Dimension of the hidden representations\n+        intermediate_size (`int`, *optional*, defaults to 21504):\n+            Dimension of the MLP representations\n+        num_hidden_layers (`int`, *optional*, defaults to 64):\n+            Number of hidden layers in the Transformer decoder\n+        num_attention_heads (`int`, *optional*, defaults to 48):\n+            Number of attention heads for each attention layer in the Transformer decoder\n+        num_key_value_heads (`int`, *optional*, defaults to 8):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention (GQA).\n+            If it is not specified, will default to `num_attention_heads`.\n+        head_dim (`int`, *optional*, defaults to 128):\n+            The attention head dimension.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 131072):\n+            The maximum sequence length that this model might ever be used with. CWM's attention allows sequence\n+            lengths up to 131072 tokens.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        pad_token_id (`int`, *optional*):\n+            Padding token id.\n+        eos_token_id (`int` or `list[int]`, *optional*, defaults to `[128001, 128008, 128009]`):\n+            The id of the *end-of-sequence* token. Optionally, use a list to set multiple *end-of-sequence* tokens.\n+        bos_token_id (`int`, *optional*, defaults to 128000):\n+            The id of the *beginning-of-sequence* token.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether to tie weight embeddings\n+        rope_theta (`float`, *optional*, defaults to 1000000.0):\n+            The base period of the RoPE embeddings.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        pretraining_tp (`int`, *optional*, defaults to 1):\n+            Tensor parallelism degree used during pretraining. See [this\n+            document](https://huggingface.co/docs/transformers/parallelism) and [this\n+            issue](https://github.com/pytorch/pytorch/issues/76232).\n+        mlp_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use a bias in up_proj, down_proj and gate_proj layers in the MLP layers.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings\n+        sliding_window (`int`, *optional*, defaults to 8192):\n+            Sliding window attention window size.\n+        layer_types (`List[str]`, *optional*):\n+            List of layer types for each layer. Each element should be either \"full_attention\" or \"sliding_attention\".\n+            If not specified, will default to alternating pattern based on the provided window pattern.\n+    \"\"\"\n+\n+    model_type = \"cwm\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    # Default tensor parallel plan for base model `CwmModel`\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.up_proj\": \"colwise\",\n+        \"layers.*.mlp.down_proj\": \"rowwise\",\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size: int = 128256,\n+        hidden_size: int = 6144,\n+        intermediate_size: int = 21504,\n+        num_hidden_layers: int = 64,\n+        num_attention_heads: int = 48,\n+        num_key_value_heads: int = 8,\n+        head_dim: int = 128,\n+        hidden_act: str = \"silu\",\n+        max_position_embeddings: int = 131072,\n+        initializer_range: float = 0.02,\n+        rms_norm_eps: float = 1e-5,\n+        use_cache: bool = True,\n+        pad_token_id: Optional[int] = None,\n+        eos_token_id=[128001, 128008, 128009],\n+        bos_token_id: int = 128000,\n+        tie_word_embeddings: bool = False,\n+        rope_theta: float = 1_000_000.0,\n+        attention_dropout: float = 0.0,\n+        pretraining_tp: int = 1,\n+        mlp_bias: bool = False,\n+        rope_scaling: Optional[dict] = None,\n+        # CWM interleaved sliding window fields\n+        sliding_window: int = 8192,\n+        layer_types: Optional[list[str]] = None,  # [\"full_attention\"|\"sliding_attention\"] per layer\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+        if rope_scaling is None:\n+            rope_scaling = {\n+                \"factor\": 16.0,\n+                \"high_freq_factor\": 4.0,\n+                \"low_freq_factor\": 1.0,\n+                \"original_max_position_embeddings\": 8192,\n+                \"rope_type\": \"llama3\",\n+            }\n+\n+        if layer_types is None:\n+            # Default pattern: every 4th layer uses full attention, others use sliding attention\n+            window_pattern = 4\n+            layer_types = [\n+                (\"full_attention\" if (i % window_pattern == 0) else \"sliding_attention\")\n+                for i in range(num_hidden_layers)\n+            ]\n+        else:\n+            layer_type_validation(layer_types, num_hidden_layers)\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.pretraining_tp = pretraining_tp\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.attention_dropout = attention_dropout\n+        self.mlp_bias = mlp_bias\n+        self.head_dim = head_dim if head_dim is not None else self.hidden_size // self.num_attention_heads\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, copy it it to 'rope_type'.\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self)\n+\n+        self.sliding_window = int(sliding_window) if sliding_window else None\n+        self.layer_types = list(layer_types)\n+\n+\n+__all__ = [\"CwmConfig\"]"
        },
        {
            "sha": "1f0c09996086ebb1c74ff45ef77767e4f5820cb4",
            "filename": "src/transformers/models/cwm/modeling_cwm.py",
            "status": "added",
            "additions": 486,
            "deletions": 0,
            "changes": 486,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fcwm%2Fmodeling_cwm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fcwm%2Fmodeling_cwm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fcwm%2Fmodeling_cwm.py?ref=0eae41ad36c2a9823bf3906eb9e332f125583998",
            "patch": "@@ -0,0 +1,486 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/cwm/modular_cwm.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_cwm.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import Callable, Optional, Union\n+\n+import torch\n+from torch import nn\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...integrations import use_kernel_forward_from_hub\n+from ...masking_utils import create_causal_mask, create_sliding_window_causal_mask\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import BaseModelOutputWithPast, CausalLMOutputWithPast\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS, dynamic_rope_update\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring, can_return_tuple\n+from ...utils.deprecation import deprecate_kwarg\n+from ...utils.generic import check_model_inputs\n+from .configuration_cwm import CwmConfig\n+\n+\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`, *optional*):\n+            Deprecated and unused.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    return q_embed, k_embed\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs: Unpack[TransformersKwargs],\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+class CwmAttention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: CwmConfig, layer_idx: int):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.head_dim = getattr(config, \"head_dim\", config.hidden_size // config.num_attention_heads)\n+        self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.attention_dropout = config.attention_dropout\n+        self.is_causal = True\n+        self.q_proj = torch.nn.Linear(config.hidden_size, config.num_attention_heads * self.head_dim, bias=False)\n+        self.k_proj = torch.nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=False)\n+        self.v_proj = torch.nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=False)\n+        self.o_proj = nn.Linear(config.num_attention_heads * self.head_dim, config.hidden_size, bias=False)\n+        self.sliding_window = config.sliding_window if config.layer_types[layer_idx] == \"sliding_attention\" else None\n+\n+    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_values: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_values is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_values.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            sliding_window=self.sliding_window,  # main diff with Llama\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+@use_kernel_forward_from_hub(\"RMSNorm\")\n+class CwmRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        CwmRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class CwmMLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=config.mlp_bias)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=config.mlp_bias)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=config.mlp_bias)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, x):\n+        down_proj = self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x))\n+        return down_proj\n+\n+\n+class CwmDecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: CwmConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+        self.self_attn = CwmAttention(config=config, layer_idx=layer_idx)\n+\n+        self.mlp = CwmMLP(config)\n+        self.input_layernorm = CwmRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = CwmRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.attention_type = config.layer_types[layer_idx]\n+\n+    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,  # necessary, but kept here for BC\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> torch.Tensor:\n+        residual = hidden_states\n+        hidden_states = self.input_layernorm(hidden_states)\n+        # Self Attention\n+        hidden_states, _ = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class CwmPreTrainedModel(PreTrainedModel):\n+    config: CwmConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"CwmDecoderLayer\"]\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _supports_flash_attn = True\n+    _supports_sdpa = True\n+    _supports_flex_attn = True\n+\n+    _can_compile_fullgraph = True\n+    _supports_attention_backend = True\n+    _can_record_outputs = {\n+        \"hidden_states\": CwmDecoderLayer,\n+        \"attentions\": CwmAttention,\n+    }\n+\n+\n+class CwmModelOutputWithPast(BaseModelOutputWithPast):\n+    pass\n+\n+\n+class CwmRotaryEmbedding(nn.Module):\n+    inv_freq: torch.Tensor  # fix linting for `register_buffer`\n+\n+    def __init__(self, config: CwmConfig, device=None):\n+        super().__init__()\n+        # BC: \"rope_type\" was originally \"type\"\n+        if hasattr(config, \"rope_scaling\") and isinstance(config.rope_scaling, dict):\n+            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n+        else:\n+            self.rope_type = \"default\"\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = self.inv_freq\n+\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1).to(x.device)\n+        position_ids_expanded = position_ids[:, None, :].float()\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(1, 2)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos() * self.attention_scaling\n+            sin = emb.sin() * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+@auto_docstring\n+class CwmModel(CwmPreTrainedModel):\n+    config_class = CwmConfig\n+\n+    def __init__(self, config: CwmConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = torch.nn.ModuleList(\n+            [CwmDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = CwmRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = CwmRotaryEmbedding(config=config)\n+        self.gradient_checkpointing = False\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @check_model_inputs\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> CwmModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds: torch.Tensor = self.embed_tokens(input_ids)\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache(config=self.config)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position: torch.Tensor = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        if not isinstance(causal_mask_mapping := attention_mask, dict):\n+            mask_kwargs = {\n+                \"config\": self.config,\n+                \"input_embeds\": inputs_embeds,\n+                \"attention_mask\": attention_mask,\n+                \"cache_position\": cache_position,\n+                \"past_key_values\": past_key_values,\n+                \"position_ids\": position_ids,\n+            }\n+            sliding_mask_kwargs = mask_kwargs.copy()\n+\n+            causal_mask_mapping = {\n+                \"full_attention\": create_causal_mask(**mask_kwargs),\n+                \"sliding_attention\": create_sliding_window_causal_mask(**sliding_mask_kwargs),\n+            }\n+\n+        hidden_states = inputs_embeds\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask_mapping[decoder_layer.attention_type],\n+                position_ids=position_ids,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                position_embeddings=position_embeddings,\n+                **kwargs,\n+            )\n+\n+        hidden_states = self.norm(hidden_states)\n+        return CwmModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+@auto_docstring\n+class CwmForCausalLM(CwmPreTrainedModel, GenerationMixin):\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+    _tp_plan = {\"lm_head\": \"colwise_rep\"}\n+    _pp_plan = {\"lm_head\": ([\"hidden_states\"], [\"logits\"])}\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = CwmModel(config)\n+        self.vocab_size = config.vocab_size\n+        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> CausalLMOutputWithPast:\n+        r\"\"\"\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, CwmForCausalLM\n+\n+        >>> model = CwmForCausalLM.from_pretrained(\"meta-cwm/Cwm-2-7b-hf\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"meta-cwm/Cwm-2-7b-hf\")\n+\n+        >>> prompt = \"Hey, are you conscious? Can you talk to me?\"\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"Hey, are you conscious? Can you talk to me?\\nI'm not conscious, but I can talk to you.\"\n+        ```\"\"\"\n+        outputs: BaseModelOutputWithPast = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs.last_hidden_state\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits=logits, labels=labels, vocab_size=self.config.vocab_size, **kwargs)\n+\n+        return CausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+\n+__all__ = [\"CwmPreTrainedModel\", \"CwmModel\", \"CwmForCausalLM\"]"
        },
        {
            "sha": "022fe9c21c196e775e73eceb552eb1ea5b6c8cc8",
            "filename": "src/transformers/models/cwm/modular_cwm.py",
            "status": "added",
            "additions": 293,
            "deletions": 0,
            "changes": 293,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fcwm%2Fmodular_cwm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/src%2Ftransformers%2Fmodels%2Fcwm%2Fmodular_cwm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fcwm%2Fmodular_cwm.py?ref=0eae41ad36c2a9823bf3906eb9e332f125583998",
            "patch": "@@ -0,0 +1,293 @@\n+# coding=utf-8\n+# Copyright 2025\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import Optional\n+\n+import torch\n+\n+from ...cache_utils import Cache, DynamicCache\n+from ...configuration_utils import layer_type_validation\n+from ...masking_utils import create_causal_mask, create_sliding_window_causal_mask\n+from ...modeling_outputs import BaseModelOutputWithPast\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, logging\n+from ..llama.configuration_llama import LlamaConfig\n+from ..llama.modeling_llama import (\n+    LlamaDecoderLayer,\n+    LlamaForCausalLM,\n+    LlamaModel,\n+    LlamaPreTrainedModel,\n+)\n+from ..qwen2.modeling_qwen2 import Qwen2Attention\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class CwmConfig(LlamaConfig):\n+    \"\"\"\n+    Configuration for Code World Model (CWM).\n+    This is an inherited Llama3-compatible configuration with layer-interleaved\n+    sliding-window attention. Configures a `CwmModel`. Designed to yield a configuartion mirroring the model in the\n+    [facebook/cwm](https://huggingface.co/facebook/cwm) architecture by default. Other models include:\n+    - [facebook/cwm-sft](https://huggingface.co/facebook/cwm-sft)\n+    - [facebook/cwm-pretrain](https://huggingface.co/facebook/cwm-pretrain)\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 128256):\n+            Vocabulary size of the CWM model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`CwmModel`]\n+        hidden_size (`int`, *optional*, defaults to 6144):\n+            Dimension of the hidden representations\n+        intermediate_size (`int`, *optional*, defaults to 21504):\n+            Dimension of the MLP representations\n+        num_hidden_layers (`int`, *optional*, defaults to 64):\n+            Number of hidden layers in the Transformer decoder\n+        num_attention_heads (`int`, *optional*, defaults to 48):\n+            Number of attention heads for each attention layer in the Transformer decoder\n+        num_key_value_heads (`int`, *optional*, defaults to 8):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention (GQA).\n+            If it is not specified, will default to `num_attention_heads`.\n+        head_dim (`int`, *optional*, defaults to 128):\n+            The attention head dimension.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 131072):\n+            The maximum sequence length that this model might ever be used with. CWM's attention allows sequence\n+            lengths up to 131072 tokens.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        pad_token_id (`int`, *optional*):\n+            Padding token id.\n+        eos_token_id (`int` or `list[int]`, *optional*, defaults to `[128001, 128008, 128009]`):\n+            The id of the *end-of-sequence* token. Optionally, use a list to set multiple *end-of-sequence* tokens.\n+        bos_token_id (`int`, *optional*, defaults to 128000):\n+            The id of the *beginning-of-sequence* token.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether to tie weight embeddings\n+        rope_theta (`float`, *optional*, defaults to 1000000.0):\n+            The base period of the RoPE embeddings.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        pretraining_tp (`int`, *optional*, defaults to 1):\n+            Tensor parallelism degree used during pretraining. See [this\n+            document](https://huggingface.co/docs/transformers/parallelism) and [this\n+            issue](https://github.com/pytorch/pytorch/issues/76232).\n+        mlp_bias (`bool`, *optional*, defaults to `False`):\n+            Whether to use a bias in up_proj, down_proj and gate_proj layers in the MLP layers.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings\n+        sliding_window (`int`, *optional*, defaults to 8192):\n+            Sliding window attention window size.\n+        layer_types (`List[str]`, *optional*):\n+            List of layer types for each layer. Each element should be either \"full_attention\" or \"sliding_attention\".\n+            If not specified, will default to alternating pattern based on the provided window pattern.\n+    \"\"\"\n+\n+    model_type = \"cwm\"\n+\n+    def __init__(\n+        self,\n+        vocab_size: int = 128256,\n+        hidden_size: int = 6144,\n+        intermediate_size: int = 21504,\n+        num_hidden_layers: int = 64,\n+        num_attention_heads: int = 48,\n+        num_key_value_heads: int = 8,\n+        head_dim: int = 128,\n+        hidden_act: str = \"silu\",\n+        max_position_embeddings: int = 131072,\n+        initializer_range: float = 0.02,\n+        rms_norm_eps: float = 1e-5,\n+        use_cache: bool = True,\n+        pad_token_id: Optional[int] = None,\n+        eos_token_id=[128001, 128008, 128009],\n+        bos_token_id: int = 128000,\n+        tie_word_embeddings: bool = False,\n+        rope_theta: float = 1_000_000.0,\n+        attention_dropout: float = 0.0,\n+        pretraining_tp: int = 1,\n+        mlp_bias: bool = False,\n+        rope_scaling: Optional[dict] = None,\n+        # CWM interleaved sliding window fields\n+        sliding_window: int = 8192,\n+        layer_types: Optional[list[str]] = None,  # [\"full_attention\"|\"sliding_attention\"] per layer\n+        **kwargs,\n+    ):\n+        if rope_scaling is None:\n+            rope_scaling = {\n+                \"factor\": 16.0,\n+                \"high_freq_factor\": 4.0,\n+                \"low_freq_factor\": 1.0,\n+                \"original_max_position_embeddings\": 8192,\n+                \"rope_type\": \"llama3\",\n+            }\n+\n+        if layer_types is None:\n+            # Default pattern: every 4th layer uses full attention, others use sliding attention\n+            window_pattern = 4\n+            layer_types = [\n+                (\"full_attention\" if (i % window_pattern == 0) else \"sliding_attention\")\n+                for i in range(num_hidden_layers)\n+            ]\n+        else:\n+            layer_type_validation(layer_types, num_hidden_layers)\n+\n+        super().__init__(\n+            vocab_size=vocab_size,\n+            hidden_size=hidden_size,\n+            intermediate_size=intermediate_size,\n+            num_hidden_layers=num_hidden_layers,\n+            num_attention_heads=num_attention_heads,\n+            num_key_value_heads=num_key_value_heads,\n+            head_dim=head_dim,\n+            hidden_act=hidden_act,\n+            max_position_embeddings=max_position_embeddings,\n+            initializer_range=initializer_range,\n+            rms_norm_eps=rms_norm_eps,\n+            use_cache=use_cache,\n+            pad_token_id=pad_token_id,\n+            eos_token_id=list(eos_token_id),\n+            bos_token_id=bos_token_id,\n+            tie_word_embeddings=tie_word_embeddings,\n+            rope_theta=rope_theta,\n+            attention_bias=False,\n+            attention_dropout=attention_dropout,\n+            rope_scaling=rope_scaling,\n+            pretraining_tp=pretraining_tp,\n+            mlp_bias=mlp_bias,\n+            **kwargs,\n+        )\n+\n+        # CWM models don't use attention bias, remove it from config\n+        del self.attention_bias\n+\n+        self.sliding_window = int(sliding_window) if sliding_window else None\n+        self.layer_types = list(layer_types)\n+\n+\n+class CwmAttention(Qwen2Attention):\n+    def __init__(self, config: CwmConfig, layer_idx: int):\n+        super().__init__(config=config, layer_idx=layer_idx)\n+        self.q_proj = torch.nn.Linear(config.hidden_size, config.num_attention_heads * self.head_dim, bias=False)\n+        self.k_proj = torch.nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=False)\n+        self.v_proj = torch.nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=False)\n+\n+\n+class CwmDecoderLayer(LlamaDecoderLayer):\n+    def __init__(self, config: CwmConfig, layer_idx: int):\n+        super().__init__(config=config, layer_idx=layer_idx)\n+        self.attention_type = config.layer_types[layer_idx]\n+        self.self_attn = CwmAttention(config=config, layer_idx=layer_idx)\n+\n+\n+class CwmPreTrainedModel(LlamaPreTrainedModel):\n+    pass\n+\n+\n+class CwmModelOutputWithPast(BaseModelOutputWithPast):\n+    pass\n+\n+\n+class CwmModel(LlamaModel):\n+    config_class = CwmConfig\n+\n+    def __init__(self, config: CwmConfig):\n+        super().__init__(config)\n+        self.layers = torch.nn.ModuleList(\n+            [CwmDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> CwmModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds: torch.Tensor = self.embed_tokens(input_ids)\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache(config=self.config)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position: torch.Tensor = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        if not isinstance(causal_mask_mapping := attention_mask, dict):\n+            mask_kwargs = {\n+                \"config\": self.config,\n+                \"input_embeds\": inputs_embeds,\n+                \"attention_mask\": attention_mask,\n+                \"cache_position\": cache_position,\n+                \"past_key_values\": past_key_values,\n+                \"position_ids\": position_ids,\n+            }\n+            sliding_mask_kwargs = mask_kwargs.copy()\n+\n+            causal_mask_mapping = {\n+                \"full_attention\": create_causal_mask(**mask_kwargs),\n+                \"sliding_attention\": create_sliding_window_causal_mask(**sliding_mask_kwargs),\n+            }\n+\n+        hidden_states = inputs_embeds\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask_mapping[decoder_layer.attention_type],\n+                position_ids=position_ids,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                position_embeddings=position_embeddings,\n+                **kwargs,\n+            )\n+\n+        hidden_states = self.norm(hidden_states)\n+        return CwmModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+class CwmForCausalLM(LlamaForCausalLM):\n+    pass\n+\n+\n+__all__ = [\n+    \"CwmConfig\",\n+    \"CwmPreTrainedModel\",\n+    \"CwmModel\",\n+    \"CwmForCausalLM\",\n+]"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/cwm/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/tests%2Fmodels%2Fcwm%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/tests%2Fmodels%2Fcwm%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fcwm%2F__init__.py?ref=0eae41ad36c2a9823bf3906eb9e332f125583998"
        },
        {
            "sha": "3d6f49527875d1f6e1847a4898e0e8d36579a48c",
            "filename": "tests/models/cwm/test_configuration_cwm.py",
            "status": "added",
            "additions": 126,
            "deletions": 0,
            "changes": 126,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/tests%2Fmodels%2Fcwm%2Ftest_configuration_cwm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/tests%2Fmodels%2Fcwm%2Ftest_configuration_cwm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fcwm%2Ftest_configuration_cwm.py?ref=0eae41ad36c2a9823bf3906eb9e332f125583998",
            "patch": "@@ -0,0 +1,126 @@\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+from transformers.models.cwm import CwmConfig\n+from transformers.testing_utils import require_torch\n+\n+from ...test_configuration_common import ConfigTester\n+\n+\n+class CwmConfigTest(unittest.TestCase):\n+    def test_default_config(self):\n+        \"\"\"Test default CWM configuration\"\"\"\n+        config = CwmConfig()\n+\n+        # CWM defaults\n+        self.assertEqual(config.sliding_window, 8192)\n+        self.assertIsInstance(config.layer_types, list)\n+\n+        # Llama3 defaults\n+        self.assertEqual(config.vocab_size, 128256)\n+        self.assertEqual(config.rope_theta, 1_000_000.0)\n+        self.assertIsNotNone(config.rope_scaling)\n+        self.assertEqual(config.rope_scaling[\"rope_type\"], \"llama3\")\n+\n+    def test_custom_sliding_window_config(self):\n+        config = CwmConfig(sliding_window=4096)\n+\n+        self.assertEqual(config.sliding_window, 4096)\n+\n+    def test_custom_layer_types_config(self):\n+        layer_types = [\"full_attention\", \"sliding_attention\", \"sliding_attention\", \"full_attention\"]\n+        config = CwmConfig(num_hidden_layers=4, layer_types=layer_types)\n+\n+        self.assertEqual(config.layer_types, layer_types)\n+        self.assertEqual(len(config.layer_types), config.num_hidden_layers)\n+\n+    def test_invalid_layer_types_length(self):\n+        with self.assertRaises(ValueError):\n+            CwmConfig(\n+                num_hidden_layers=4,\n+                layer_types=[\"full_attention\", \"sliding_attention\"],  # Only 2 types for 4 layers\n+            )\n+\n+    def test_invalid_layer_type_value(self):\n+        with self.assertRaises(ValueError):\n+            CwmConfig(num_hidden_layers=2, layer_types=[\"full_attention\", \"invalid_attention\"])\n+\n+    def test_automatic_layer_types_generation(self):\n+        # Test default pattern (every 4th layer uses full attention)\n+        config = CwmConfig(num_hidden_layers=8)\n+\n+        expected_types = [\n+            \"full_attention\",  # layer 0: 0 % 4 == 0\n+            \"sliding_attention\",  # layer 1: 1 % 4 != 0\n+            \"sliding_attention\",  # layer 2: 2 % 4 != 0\n+            \"sliding_attention\",  # layer 3: 3 % 4 != 0\n+            \"full_attention\",  # layer 4: 4 % 4 == 0\n+            \"sliding_attention\",  # layer 5: 5 % 4 != 0\n+            \"sliding_attention\",  # layer 6: 6 % 4 != 0\n+            \"sliding_attention\",  # layer 7: 7 % 4 != 0\n+        ]\n+\n+        self.assertEqual(config.layer_types, expected_types)\n+\n+    def test_rope_scaling_config(self):\n+        custom_rope_scaling = {\n+            \"factor\": 8.0,\n+            \"high_freq_factor\": 2.0,\n+            \"low_freq_factor\": 0.5,\n+            \"original_max_position_embeddings\": 4096,\n+            \"rope_type\": \"llama3\",\n+        }\n+\n+        config = CwmConfig(rope_scaling=custom_rope_scaling)\n+\n+        self.assertEqual(config.rope_scaling, custom_rope_scaling)\n+\n+    def test_config_serialization(self):\n+        config = CwmConfig(\n+            sliding_window=4096,\n+            layer_types=[\"full_attention\", \"sliding_attention\"] * 3,\n+            num_hidden_layers=6,\n+        )\n+\n+        config_dict = config.to_dict()\n+        self.assertIn(\"sliding_window\", config_dict)\n+        self.assertIn(\"layer_types\", config_dict)\n+\n+        new_config = CwmConfig.from_dict(config_dict)\n+        self.assertEqual(new_config.sliding_window, config.sliding_window)\n+        self.assertEqual(new_config.layer_types, config.layer_types)\n+\n+    def test_config_inheritance_from_llama(self):\n+        config = CwmConfig()\n+\n+        # Llama config attributes\n+        self.assertTrue(hasattr(config, \"hidden_size\"))\n+        self.assertTrue(hasattr(config, \"num_attention_heads\"))\n+        self.assertTrue(hasattr(config, \"num_key_value_heads\"))\n+        self.assertTrue(hasattr(config, \"intermediate_size\"))\n+        self.assertTrue(hasattr(config, \"rope_theta\"))\n+        self.assertTrue(hasattr(config, \"attention_dropout\"))\n+\n+\n+@require_torch\n+class CwmConfigTester(ConfigTester):\n+    def __init__(self, parent, config_class=None, **kwargs):\n+        super().__init__(parent, config_class=config_class, **kwargs)\n+\n+    def test_config(self):\n+        config_class = CwmConfig\n+        self.config_tester = ConfigTester(self, config_class=config_class)\n+        self.config_tester.run_common_tests()"
        },
        {
            "sha": "ff1a90323903b76c7b0adeed884c6c70cb545fba",
            "filename": "tests/models/cwm/test_modeling_cwm.py",
            "status": "added",
            "additions": 298,
            "deletions": 0,
            "changes": 298,
            "blob_url": "https://github.com/huggingface/transformers/blob/0eae41ad36c2a9823bf3906eb9e332f125583998/tests%2Fmodels%2Fcwm%2Ftest_modeling_cwm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0eae41ad36c2a9823bf3906eb9e332f125583998/tests%2Fmodels%2Fcwm%2Ftest_modeling_cwm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fcwm%2Ftest_modeling_cwm.py?ref=0eae41ad36c2a9823bf3906eb9e332f125583998",
            "patch": "@@ -0,0 +1,298 @@\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+from transformers import is_torch_available\n+from transformers.testing_utils import (\n+    cleanup,\n+    require_torch,\n+    require_torch_accelerator,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...causal_lm_tester import CausalLMModelTest, CausalLMModelTester\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers.models.cwm import (\n+        CwmConfig,\n+        CwmForCausalLM,\n+        CwmModel,\n+    )\n+\n+\n+class CwmModelTester(CausalLMModelTester):\n+    if is_torch_available():\n+        config_class = CwmConfig\n+        base_model_class = CwmModel\n+        causal_lm_class = CwmForCausalLM\n+\n+    def get_config(self):\n+        config = super().get_config()\n+\n+        config.sliding_window = 8192\n+        config.rope_scaling = {\n+            \"factor\": 16.0,\n+            \"high_freq_factor\": 4.0,\n+            \"low_freq_factor\": 1.0,\n+            \"original_max_position_embeddings\": 8192,\n+            \"rope_type\": \"llama3\",\n+        }\n+\n+        return config\n+\n+\n+@require_torch\n+class CwmModelTest(CausalLMModelTest, unittest.TestCase):\n+    all_model_classes = (\n+        (\n+            CwmModel,\n+            CwmForCausalLM,\n+        )\n+        if is_torch_available()\n+        else ()\n+    )\n+    pipeline_model_mapping = (\n+        {\n+            \"feature-extraction\": CwmModel,\n+            \"text-generation\": CwmForCausalLM,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+    test_headmasking = False\n+    test_pruning = False\n+    fx_compatible = False\n+    model_tester_class = CwmModelTester\n+\n+    model_split_percents = [0.5, 0.7, 0.8]\n+\n+    _torch_compile_train_cls = CwmForCausalLM if is_torch_available() else None\n+\n+\n+@require_torch_accelerator\n+@slow\n+class CwmIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    def tearDown(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    @slow\n+    def test_cwm_integration(self):\n+        from transformers import AutoTokenizer\n+\n+        tokenizer = AutoTokenizer.from_pretrained(\"facebook/cwm\")\n+        model = CwmForCausalLM.from_pretrained(\"facebook/cwm\", device_map=\"auto\", dtype=torch.bfloat16)\n+\n+        self.assertIsNotNone(model.config.sliding_window)\n+        self.assertIsNotNone(model.config.layer_types)\n+        self.assertIn(\"full_attention\", model.config.layer_types)\n+        self.assertIn(\"sliding_attention\", model.config.layer_types)\n+\n+        for i, layer in enumerate(model.model.layers):\n+            expected_type = model.config.layer_types[i]\n+            self.assertEqual(layer.attention_type, expected_type)\n+            if expected_type == \"sliding_attention\":\n+                self.assertEqual(layer.self_attn.sliding_window, model.config.sliding_window)\n+\n+        prompt = \"def quicksort(arr):\"\n+        inputs = tokenizer(prompt, return_tensors=\"pt\").to(model.device)\n+\n+        with torch.no_grad():\n+            out = model(**inputs)\n+\n+        expected_logits = torch.tensor(\n+            [\n+                0.5625,\n+                2.9531,\n+                9.1875,\n+                0.4746,\n+                -0.3613,\n+                2.2031,\n+                2.9844,\n+                1.5312,\n+                0.5859,\n+                1.5391,\n+                2.7500,\n+                3.4375,\n+                2.0156,\n+                2.1719,\n+                1.5469,\n+                2.5469,\n+                2.8438,\n+                1.8203,\n+                1.7188,\n+                1.3984,\n+                1.0469,\n+                0.1748,\n+                0.4453,\n+                0.1533,\n+                -0.1157,\n+                0.8516,\n+                2.2344,\n+                5.2188,\n+                1.2891,\n+                1.5234,\n+                0.8555,\n+                0.6992,\n+            ],\n+            dtype=torch.bfloat16,\n+        ).to(model.device)\n+\n+        self.assertTrue(torch.allclose(out.logits[0, -1, :32], expected_logits, atol=1e-2, rtol=1e-2))\n+\n+        self.assertEqual(out.logits.shape[1], inputs.input_ids.shape[1])\n+        self.assertEqual(out.logits.shape[2], model.config.vocab_size)\n+        self.assertFalse(torch.isnan(out.logits).any())\n+        self.assertFalse(torch.isinf(out.logits).any())\n+\n+    @slow\n+    def test_cwm_sliding_window_long_sequence(self):\n+        from transformers import AutoTokenizer\n+\n+        tokenizer = AutoTokenizer.from_pretrained(\"facebook/cwm\")\n+        model = CwmForCausalLM.from_pretrained(\"facebook/cwm\", device_map=\"auto\", dtype=torch.bfloat16)\n+\n+        sliding_window = model.config.sliding_window\n+        long_text = \"for i in range(1000):\\n    print(f'iteration {i}')\\n\" * 600\n+\n+        inputs = tokenizer(long_text, return_tensors=\"pt\").to(model.device)\n+        seq_len = inputs.input_ids.shape[1]\n+\n+        # create a sequence longer than sliding window\n+        self.assertGreater(\n+            seq_len, sliding_window, f\"Test sequence length {seq_len} should be > sliding window {sliding_window}\"\n+        )\n+\n+        with torch.no_grad():\n+            out = model(**inputs)\n+\n+        expected_logits = torch.tensor(\n+            [\n+                4.7812,\n+                6.1875,\n+                13.1875,\n+                4.4062,\n+                5.0312,\n+                3.9844,\n+                6.6875,\n+                4.8438,\n+                2.3125,\n+                6.5000,\n+                4.4688,\n+                0.5195,\n+                5.6562,\n+                3.3125,\n+                2.7500,\n+                4.9062,\n+                5.5938,\n+                4.1562,\n+                3.9531,\n+                2.4062,\n+                3.2812,\n+                2.8594,\n+                3.4688,\n+                2.9688,\n+                2.6875,\n+                3.4531,\n+                2.7344,\n+                7.2812,\n+                4.5000,\n+                5.7500,\n+                2.3438,\n+                5.9688,\n+            ],\n+            dtype=torch.bfloat16,\n+        ).to(model.device)\n+\n+        self.assertTrue(torch.allclose(out.logits[0, -1, :32], expected_logits, atol=1e-2, rtol=1e-2))\n+\n+        self.assertEqual(out.logits.shape[1], seq_len)\n+        self.assertEqual(out.logits.shape[2], model.config.vocab_size)\n+        self.assertFalse(torch.isnan(out.logits).any())\n+        self.assertFalse(torch.isinf(out.logits).any())\n+\n+        for i, layer in enumerate(model.model.layers):\n+            if model.config.layer_types[i] == \"sliding_attention\":\n+                self.assertEqual(layer.self_attn.sliding_window, sliding_window)\n+\n+    @slow\n+    def test_cwm_generation_20_tokens(self):\n+        from transformers import AutoTokenizer\n+\n+        tokenizer = AutoTokenizer.from_pretrained(\"facebook/cwm\")\n+        model = CwmForCausalLM.from_pretrained(\"facebook/cwm\", device_map=\"auto\", dtype=torch.bfloat16)\n+\n+        system_prompt = \"You are a helpful AI assistant. You always reason before responding, using the following format:\\n\\n<think>\\nyour internal reasoning\\n</think>\\nyour external response\"\n+        messages = [\n+            {\"role\": \"system\", \"content\": system_prompt},\n+            {\"role\": \"user\", \"content\": \"Write a simple Python function to add two numbers.\"},\n+        ]\n+\n+        text = tokenizer.apply_chat_template(\n+            messages,\n+            tokenize=False,\n+            add_generation_prompt=True,\n+            enable_thinking=True,\n+            preserve_previous_think=True,\n+        )\n+        model_inputs = tokenizer([text], return_tensors=\"pt\").to(model.device)\n+\n+        with torch.no_grad():\n+            generated_ids = model.generate(\n+                **model_inputs,\n+                max_new_tokens=20,\n+                do_sample=False,\n+                temperature=1.0,\n+                top_p=1.0,\n+                pad_token_id=tokenizer.eos_token_id,\n+            )\n+\n+        output_ids = generated_ids[0][len(model_inputs.input_ids[0]) :].tolist()\n+        generated_text = tokenizer.decode(output_ids, skip_special_tokens=False)\n+\n+        self.assertEqual(len(output_ids), 20, \"Should generate exactly 20 tokens\")\n+\n+        expected_token_ids = [\n+            33413,\n+            11,\n+            358,\n+            1205,\n+            311,\n+            3350,\n+            264,\n+            13325,\n+            734,\n+            430,\n+            11621,\n+            1403,\n+            5219,\n+            13,\n+            6914,\n+            596,\n+            1212,\n+            555,\n+            89746,\n+            1268,\n+        ]\n+        expected_text = \"Okay, I need to write a Python function that adds two numbers. Let's start by recalling how\"\n+\n+        self.assertEqual(output_ids, expected_token_ids, \"Generated tokens should match ground truth\")\n+        self.assertEqual(generated_text, expected_text, \"Generated text should match ground truth\")"
        }
    ],
    "stats": {
        "total": 1628,
        "additions": 1628,
        "deletions": 0
    }
}