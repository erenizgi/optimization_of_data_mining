{
    "author": "tonywu71",
    "message": "Add ColPali to ü§ó transformers (#33736)\n\n* feat: run `add-new-model-like`\n\n* feat: add paligemma code with \"copied from\"\n\n* feat: add ColPaliProcessor\n\n* feat: add ColPaliModel\n\n* feat: add ColPaliConfig\n\n* feat: rename `ColPaliForConditionalGeneration` to `ColPaliModel`\n\n* fixup modeling colpali\n\n* fix: fix root import shortcuts\n\n* fix: fix `modeling_auto` dict\n\n* feat: comment out ColPali test file\n\n* fix: fix typos from `add-new-model-like`\n\n* feat: explicit the forward input args\n\n* feat: move everything to `modular_colpali.py`\n\n* fix: put back ColPaliProcesor\n\n* feat: add auto-generated files\n\n* fix: run `fix-copies`\n\n* fix: remove DOCStRING constants to make modular converter work\n\n* fix: fix typo + modular converter\n\n* fix: add missing imports\n\n* feat: no more errors when loading ColPaliModel\n\n* fix: remove unused args in forward + tweak doc\n\n* feat: rename `ColPaliModel` to `ColPaliForRetrieval`\n\n* fix: apply `fix-copies`\n\n* feat: add ColPaliProcessor to `modular_colpali`\n\n* fix: run make quality + make style\n\n* fix: remove duplicate line in configuration_auto\n\n* feat: make ColPaliModel inehrit from PaliGemmaForConditionalGeneration\n\n* fix: tweak and use ColPaliConfig\n\n* feat: rename `score` to `post_process_retrieval`\n\n* build: run modular formatter + make style\n\n* feat: convert colpali weights + fixes\n\n* feat: remove old weight converter file\n\n* feat: add and validate tests\n\n* feat: replace harcoded path to \"vidore/colpali-v1.2-hf\" in tests\n\n* fix: add bfloat16 conversion in weight converter\n\n* feat: replace pytest with unittest in modeling colpali test\n\n* feat: add sanity check for weight conversion (doesn't work yet)\n\n* feat: add shape sanity check in weigth converter\n\n* feat: make ColPaliProcessor args explicit\n\n* doc: add doc for ColPali\n\n* fix: trying to fix output mismatch\n\n* feat: tweaks\n\n* fix: ColPaliModelOutput inherits from ModelOutput instead of PaliGemmaCausalLMOutputWithPast\n\n* fix: address comments on PR\n\n* fix: adapt tests to the Hf norm\n\n* wip: try things\n\n* feat: add `__call__` method to `ColPaliProcessor`\n\n* feat: remove need for dummy image in `process_queries`\n\n* build: run new modular converter\n\n* fix: fix incorrect method override\n\n* Fix tests, processing, modular, convert\n\n* fix tokenization auto\n\n* hotfix: manually fix processor -> fixme once convert modular is fixed\n\n* fix: convert weights working\n\n* feat: rename and improve convert weight script\n\n* feat: tweaks\n\n* fest: remove `device` input for `post_process_retrieval`\n\n* refactor: remove unused `get_torch_device`\n\n* Fix all tests\n\n* docs: update ColPali model doc\n\n* wip: fix convert weights to hf\n\n* fix logging modular\n\n* docs: add acknowledgements in model doc\n\n* docs: add missing docstring to ColPaliProcessor\n\n* docs: tweak\n\n* docs: add doc for `ColPaliForRetrievalOutput.forward`\n\n* feat: add modifications from colpali-engine v0.3.2 in ColPaliProcessor\n\n* fix: fix and upload colapli hf weights\n\n* refactor: rename `post_process_retrieval` to `score_retrieval`\n\n* fix: fix wrong typing for `score_retrieval`\n\n* test: add integration test for ColPali\n\n* chore: rerun convert modular\n\n* build: fix root imports\n\n* Update docs/source/en/index.md\n\nCo-authored-by: Yoni Gozlan <74535834+yonigozlan@users.noreply.github.com>\n\n* fix: address PR comments\n\n* wip: reduce the prediction gap in weight conversion\n\n* docs: add comment in weight conversion script\n\n* docs: add example for `ColPaliForRetrieval.forward`\n\n* tests: change dataset path to the new one in hf-internal\n\n* fix: colpali weight conversion works\n\n* test: add fine-grained check for ColPali integration test\n\n* fix: fix typos in convert weight script\n\n* docs: move input docstring in a variable\n\n* fix: remove hardcoded torch device in test\n\n* fix: run the new modular refactor\n\n* docs: fix python example for ColPali\n\n* feat: add option to choose `score_retrieval`'s output dtype and device\n\n* docs: update doc for `score_retrieval`\n\n* feat: add `patch_size` property in ColPali model\n\n* chore: run `make fix-copies`\n\n* docs: update description for ColPali cookbooks\n\n* fix: remove `ignore_index` methods\n\n* feat: remove non-transformers specific methods\n\n* feat: update `__init__.py` to new hf format\n\n* fix: fix root imports in transformers\n\n* feat: remove ColPali's inheritance from PaliGemma\n\n* Fix CI issues\n\n* nit remove prints\n\n* feat: remove ColPali config and model from `modular_colpali.py`\n\n* feat: add `ColPaliPreTrainedModel` and update modeling and configuration code\n\n* fix: fix auto-removed imports in root `__init__.py`\n\n* fix: various fixes\n\n* fix: fix `_init_weight`\n\n* temp: comment `AutoModel.from_config` for experiments\n\n* fix: add missing `output_attentions` arg in ColPali's forward\n\n* fix: fix `resize_token_embeddings`\n\n* fix: make `input_ids` optional in forward\n\n* feat: rename `projection_layer` to `embedding_proj_layer`\n\n* wip: fix convert colpali weight script\n\n* fix tests and convert weights from original repo\n\n* fix unprotected import\n\n* fix unprotected torch import\n\n* fix style\n\n* change vlm_backbone_config to vlm_config\n\n* fix unprotected import in modular this time\n\n* fix: load config from Hub + tweaks in convert weight script\n\n* docs: move example usage from model docstring to model markdown\n\n* docs: fix input docstring for ColPali's forward method\n\n* fix: use `sub_configs` for ColPaliConfig\n\n* fix: remove non-needed sanity checks in weight conversion script + tweaks\n\n* fix: fix issue with `replace_return_docstrings` in ColPali's `forward`\n\n* docs: update docstring for `ColPaliConfig`\n\n* test: change model path in ColPali test\n\n* fix: fix ColPaliConfig\n\n* fix: fix weight conversion script\n\n* test: fix expected weights for ColPali model\n\n* docs: update ColPali markdown\n\n* docs: fix minor typo in ColPaliProcessor\n\n* Fix tests and add _no_split_modules\n\n* add text_config to colpali config\n\n* [run slow] colpali\n\n* move inputs to torch_device in integration test\n\n* skip test_model_parallelism\n\n* docs: clarify quickstart snippet in ColPali's model card\n\n* docs: update ColPali's model card\n\n---------\n\nCo-authored-by: yonigozlan <yoni.gozlan@huggingface.co>\nCo-authored-by: Yoni Gozlan <74535834+yonigozlan@users.noreply.github.com>",
    "sha": "f33a0cebb37454a25af3d0be44832ea53c39733d",
    "files": [
        {
            "sha": "d87906159ce34fafa7151539eb1d406863714add",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -834,6 +834,8 @@\n         title: CLIPSeg\n       - local: model_doc/clvp\n         title: CLVP\n+      - local: model_doc/colpali\n+        title: ColPali\n       - local: model_doc/data2vec\n         title: Data2Vec\n       - local: model_doc/deplot"
        },
        {
            "sha": "a40bb8254634958d5c4f0f50a83c0f6d699469bb",
            "filename": "docs/source/en/index.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/docs%2Fsource%2Fen%2Findex.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/docs%2Fsource%2Fen%2Findex.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Findex.md?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -100,6 +100,7 @@ Flax), PyTorch, and/or TensorFlow.\n |                    [CodeLlama](model_doc/code_llama)                     |       ‚úÖ        |         ‚ùå         |      ‚úÖ      |\n |                        [Cohere](model_doc/cohere)                        |       ‚úÖ        |         ‚ùå         |      ‚ùå      |\n |                       [Cohere2](model_doc/cohere2)                       |       ‚úÖ        |         ‚ùå         |      ‚ùå      |\n+|                       [ColPali](model_doc/colpali)                       |       ‚úÖ        |         ‚ùå         |      ‚ùå      |\n |              [Conditional DETR](model_doc/conditional_detr)              |       ‚úÖ        |         ‚ùå         |      ‚ùå      |\n |                      [ConvBERT](model_doc/convbert)                      |       ‚úÖ        |         ‚úÖ         |      ‚ùå      |\n |                      [ConvNeXT](model_doc/convnext)                      |       ‚úÖ        |         ‚úÖ         |      ‚ùå      |"
        },
        {
            "sha": "d47f0aa072262c29144933a60d2bff4e7c6c51f8",
            "filename": "docs/source/en/model_doc/colpali.md",
            "status": "added",
            "additions": 95,
            "deletions": 0,
            "changes": 95,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/docs%2Fsource%2Fen%2Fmodel_doc%2Fcolpali.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/docs%2Fsource%2Fen%2Fmodel_doc%2Fcolpali.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fcolpali.md?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -0,0 +1,95 @@\n+<!--Copyright 2024 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+‚ö†Ô∏è Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# ColPali\n+\n+## Overview\n+\n+The ColPali model was proposed in [ColPali: Efficient Document Retrieval with Vision Language Models](https://doi.org/10.48550/arXiv.2407.01449) by **Manuel Faysse***, **Hugues Sibille***, **Tony Wu***, Bilel Omrani, Gautier Viaud, C√©line Hudelot, Pierre Colombo (* denotes equal contribution).\n+\n+With our new model *ColPali*, we propose to leverage VLMs to construct efficient multi-vector embeddings in the visual space for document retrieval. By feeding the ViT output patches from PaliGemma-3B to a linear projection, we create a multi-vector representation of documents. We train the model to maximize the similarity between these document embeddings and the query embeddings, following the ColBERT method.\n+\n+Using ColPali removes the need for potentially complex and brittle layout recognition and OCR pipelines with a single model that can take into account both the textual and visual content (layout, charts, ...) of a document. ColPali is also highly interpretable: similarity maps can be obtained between patches and query tokens. These maps highlight ColPali‚Äôs strong OCR capabilities and chart understanding.\n+\n+**Paper abstract:**\n+\n+> Documents are visually rich structures that convey information through text, but also figures, page layouts, tables, or even fonts. Since modern retrieval systems mainly rely on the textual information they extract from document pages to index documents -often through lengthy and brittle processes-, they struggle to exploit key visual cues efficiently. This limits their capabilities in many practical document retrieval applications such as Retrieval Augmented Generation (RAG). To benchmark current systems on visually rich document retrieval, we introduce the Visual Document Retrieval Benchmark *ViDoRe*, composed of various page-level retrieval tasks spanning multiple domains, languages, and practical settings. The inherent complexity and performance shortcomings of modern systems motivate a new concept; doing document retrieval by directly embedding the images of the document pages. We release *ColPali*, a Vision Language Model trained to produce high-quality multi-vector embeddings from images of document pages. Combined with a late interaction matching mechanism, *ColPali* largely outperforms modern document retrieval pipelines while being drastically simpler, faster and end-to-end trainable.\n+>\n+> We release models, data, code and benchmarks under open licenses at [https://huggingface.co/vidore](https://huggingface.co/vidore).\n+\n+## Resources\n+\n+- The official blog post detailing ColPali can be found [here](https://huggingface.co/blog/manu/colpali). üìù\n+- The original model implementation code for the ColPali model and for the `colpali-engine` package can be found [here](https://github.com/illuin-tech/colpali). üåé\n+- Cookbooks for learning to use the transformers-native version of ColPali, fine-tuning, and similarity maps generation can be found [here](https://github.com/tonywu71/colpali-cookbooks). üìö\n+\n+This model was contributed by [@tonywu71](https://huggingface.co/tonywu71) and [@yonigozlan](https://huggingface.co/yonigozlan).\n+\n+## Usage\n+\n+This example demonstrates how to use ColPali to embed both queries and images, calculate their similarity scores, and identify the most relevant matches. For a specific query, you can retrieve the top-k most similar images by selecting the ones with the highest similarity scores.\n+\n+```python\n+import torch\n+from PIL import Image\n+\n+from transformers import ColPaliForRetrieval, ColPaliProcessor\n+\n+model_name = \"vidore/colpali-v1.2-hf\"\n+\n+model = ColPaliForRetrieval.from_pretrained(\n+    model_name,\n+    torch_dtype=torch.bfloat16,\n+    device_map=\"cuda:0\",  # or \"mps\" if on Apple Silicon\n+).eval()\n+\n+processor = ColPaliProcessor.from_pretrained(model_name)\n+\n+# Your inputs (replace dummy images with screenshots of your documents)\n+images = [\n+    Image.new(\"RGB\", (32, 32), color=\"white\"),\n+    Image.new(\"RGB\", (16, 16), color=\"black\"),\n+]\n+queries = [\n+    \"What is the organizational structure for our R&D department?\",\n+    \"Can you provide a breakdown of last year‚Äôs financial performance?\",\n+]\n+\n+# Process the inputs\n+batch_images = processor(images=images).to(model.device)\n+batch_queries = processor(text=queries).to(model.device)\n+\n+# Forward pass\n+with torch.no_grad():\n+    image_embeddings = model(**batch_images)\n+    query_embeddings = model(**batch_queries)\n+\n+# Score the queries against the images\n+scores = processor.score_retrieval(query_embeddings, image_embeddings)\n+```\n+\n+## ColPaliConfig\n+\n+[[autodoc]] ColPaliConfig\n+\n+## ColPaliProcessor\n+\n+[[autodoc]] ColPaliProcessor\n+\n+## ColPaliForRetrieval\n+\n+[[autodoc]] ColPaliForRetrieval\n+    - forward"
        },
        {
            "sha": "920dc334dbb2a40ff44fffeb18669c434a529034",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -306,6 +306,10 @@\n     ],\n     \"models.cohere\": [\"CohereConfig\"],\n     \"models.cohere2\": [\"Cohere2Config\"],\n+    \"models.colpali\": [\n+        \"ColPaliConfig\",\n+        \"ColPaliProcessor\",\n+    ],\n     \"models.conditional_detr\": [\"ConditionalDetrConfig\"],\n     \"models.convbert\": [\n         \"ConvBertConfig\",\n@@ -1468,6 +1472,7 @@\n             \"MODEL_FOR_OBJECT_DETECTION_MAPPING\",\n             \"MODEL_FOR_PRETRAINING_MAPPING\",\n             \"MODEL_FOR_QUESTION_ANSWERING_MAPPING\",\n+            \"MODEL_FOR_RETRIEVAL_MAPPING\",\n             \"MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING\",\n             \"MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING\",\n             \"MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING\",\n@@ -1789,6 +1794,12 @@\n     )\n     _import_structure[\"models.cohere\"].extend([\"CohereForCausalLM\", \"CohereModel\", \"CoherePreTrainedModel\"])\n     _import_structure[\"models.cohere2\"].extend([\"Cohere2ForCausalLM\", \"Cohere2Model\", \"Cohere2PreTrainedModel\"])\n+    _import_structure[\"models.colpali\"].extend(\n+        [\n+            \"ColPaliForRetrieval\",\n+            \"ColPaliPreTrainedModel\",\n+        ]\n+    )\n     _import_structure[\"models.conditional_detr\"].extend(\n         [\n             \"ConditionalDetrForObjectDetection\",\n@@ -5207,6 +5218,10 @@\n     )\n     from .models.cohere import CohereConfig\n     from .models.cohere2 import Cohere2Config\n+    from .models.colpali import (\n+        ColPaliConfig,\n+        ColPaliProcessor,\n+    )\n     from .models.conditional_detr import (\n         ConditionalDetrConfig,\n     )\n@@ -6413,6 +6428,7 @@\n             MODEL_FOR_OBJECT_DETECTION_MAPPING,\n             MODEL_FOR_PRETRAINING_MAPPING,\n             MODEL_FOR_QUESTION_ANSWERING_MAPPING,\n+            MODEL_FOR_RETRIEVAL_MAPPING,\n             MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING,\n             MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING,\n             MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING,\n@@ -6689,6 +6705,10 @@\n             Cohere2Model,\n             Cohere2PreTrainedModel,\n         )\n+        from .models.colpali import (\n+            ColPaliForRetrieval,\n+            ColPaliPreTrainedModel,\n+        )\n         from .models.conditional_detr import (\n             ConditionalDetrForObjectDetection,\n             ConditionalDetrForSegmentation,"
        },
        {
            "sha": "5eb74fab5abe7181125cf1614560d61d71a21f46",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -53,6 +53,7 @@\n     codegen,\n     cohere,\n     cohere2,\n+    colpali,\n     conditional_detr,\n     convbert,\n     convnext,"
        },
        {
            "sha": "1f626d8c24f42a0cd214e5032e023b7006c19094",
            "filename": "src/transformers/models/auto/__init__.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fauto%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fauto%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2F__init__.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -74,6 +74,7 @@\n         \"MODEL_FOR_UNIVERSAL_SEGMENTATION_MAPPING\",\n         \"MODEL_FOR_VIDEO_CLASSIFICATION_MAPPING\",\n         \"MODEL_FOR_VISION_2_SEQ_MAPPING\",\n+        \"MODEL_FOR_RETRIEVAL_MAPPING\",\n         \"MODEL_FOR_IMAGE_TEXT_TO_TEXT_MAPPING\",\n         \"MODEL_FOR_VISUAL_QUESTION_ANSWERING_MAPPING\",\n         \"MODEL_MAPPING\",\n@@ -252,6 +253,7 @@\n             MODEL_FOR_OBJECT_DETECTION_MAPPING,\n             MODEL_FOR_PRETRAINING_MAPPING,\n             MODEL_FOR_QUESTION_ANSWERING_MAPPING,\n+            MODEL_FOR_RETRIEVAL_MAPPING,\n             MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING,\n             MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING,\n             MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING,"
        },
        {
            "sha": "1fb7464f41116a1ee6e2a29d2f90807ccffad5f5",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -70,6 +70,7 @@\n         (\"codegen\", \"CodeGenConfig\"),\n         (\"cohere\", \"CohereConfig\"),\n         (\"cohere2\", \"Cohere2Config\"),\n+        (\"colpali\", \"ColPaliConfig\"),\n         (\"conditional_detr\", \"ConditionalDetrConfig\"),\n         (\"convbert\", \"ConvBertConfig\"),\n         (\"convnext\", \"ConvNextConfig\"),\n@@ -373,6 +374,7 @@\n         (\"codegen\", \"CodeGen\"),\n         (\"cohere\", \"Cohere\"),\n         (\"cohere2\", \"Cohere2\"),\n+        (\"colpali\", \"ColPali\"),\n         (\"conditional_detr\", \"Conditional DETR\"),\n         (\"convbert\", \"ConvBERT\"),\n         (\"convnext\", \"ConvNeXT\"),"
        },
        {
            "sha": "5d41ad42beea7e012349a33cbe6d1099debe71f6",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -306,6 +306,7 @@\n         (\"big_bird\", \"BigBirdForPreTraining\"),\n         (\"bloom\", \"BloomForCausalLM\"),\n         (\"camembert\", \"CamembertForMaskedLM\"),\n+        (\"colpali\", \"ColPaliForRetrieval\"),\n         (\"ctrl\", \"CTRLLMHeadModel\"),\n         (\"data2vec-text\", \"Data2VecTextForMaskedLM\"),\n         (\"deberta\", \"DebertaForMaskedLM\"),\n@@ -775,6 +776,12 @@\n     ]\n )\n \n+MODEL_FOR_RETRIEVAL_MAPPING_NAMES = OrderedDict(\n+    [\n+        (\"colpali\", \"ColPaliForRetrieval\"),\n+    ]\n+)\n+\n MODEL_FOR_IMAGE_TEXT_TO_TEXT_MAPPING_NAMES = OrderedDict(\n     [\n         (\"aria\", \"AriaForConditionalGeneration\"),\n@@ -1473,6 +1480,7 @@\n MODEL_FOR_IMAGE_TEXT_TO_TEXT_MAPPING = _LazyAutoMapping(\n     CONFIG_MAPPING_NAMES, MODEL_FOR_IMAGE_TEXT_TO_TEXT_MAPPING_NAMES\n )\n+MODEL_FOR_RETRIEVAL_MAPPING = _LazyAutoMapping(CONFIG_MAPPING_NAMES, MODEL_FOR_RETRIEVAL_MAPPING_NAMES)\n MODEL_FOR_VISUAL_QUESTION_ANSWERING_MAPPING = _LazyAutoMapping(\n     CONFIG_MAPPING_NAMES, MODEL_FOR_VISUAL_QUESTION_ANSWERING_MAPPING_NAMES\n )"
        },
        {
            "sha": "815e2ca755bee354ba06666ca8bd28fd66217b1a",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -58,6 +58,7 @@\n         (\"clip\", \"CLIPProcessor\"),\n         (\"clipseg\", \"CLIPSegProcessor\"),\n         (\"clvp\", \"ClvpProcessor\"),\n+        (\"colpali\", \"ColPaliProcessor\"),\n         (\"flava\", \"FlavaProcessor\"),\n         (\"fuyu\", \"FuyuProcessor\"),\n         (\"git\", \"GitProcessor\"),"
        },
        {
            "sha": "1cdebde8cd904fbd8205a7383487bae980c67fe6",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -148,6 +148,7 @@\n             (\"codegen\", (\"CodeGenTokenizer\", \"CodeGenTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"cohere\", (None, \"CohereTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"cohere2\", (None, \"CohereTokenizerFast\" if is_tokenizers_available() else None)),\n+            (\"colpali\", (\"LlamaTokenizer\", \"LlamaTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"convbert\", (\"ConvBertTokenizer\", \"ConvBertTokenizerFast\" if is_tokenizers_available() else None)),\n             (\n                 \"cpm\","
        },
        {
            "sha": "fa1b63fd009803e27cc25ebe591ab4fa2cd32cb9",
            "filename": "src/transformers/models/colpali/__init__.py",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fcolpali%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fcolpali%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fcolpali%2F__init__.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -0,0 +1,28 @@\n+# Copyright 2024 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_colpali import *\n+    from .modeling_colpali import *\n+    from .processing_colpali import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "045462adca4e2c5f4c084e402a3b01afcdc14c82",
            "filename": "src/transformers/models/colpali/configuration_colpali.py",
            "status": "added",
            "additions": 106,
            "deletions": 0,
            "changes": 106,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fcolpali%2Fconfiguration_colpali.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fcolpali%2Fconfiguration_colpali.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fcolpali%2Fconfiguration_colpali.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -0,0 +1,106 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"ColPali model configuration\"\"\"\n+\n+import logging\n+from copy import deepcopy\n+\n+from ...configuration_utils import PretrainedConfig\n+from ..auto import CONFIG_MAPPING, AutoConfig\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class ColPaliConfig(PretrainedConfig):\n+    r\"\"\"\n+    Configuration class to store the configuration of a [`ColPaliForRetrieval`]. It is used to instantiate an instance\n+    of `ColPaliForRetrieval` according to the specified arguments, defining the model architecture following the methodology\n+    from the \"ColPali: Efficient Document Retrieval with Vision Language Models\" paper.\n+\n+    Creating a configuration with the default settings will result in a configuration where the VLM backbone is set to the\n+    default PaliGemma configuration, i.e the one from [vidore/colpali-v1.2](https://huggingface.co/vidore/colpali-v1.2).\n+\n+    The ColPali config is very similar to [`PaligemmaConfig`], but with an extra attribute defining the embedding dimension.\n+\n+    Note that contrarily to what the class name suggests (actually the name refers to the ColPali **methodology**), you can\n+    use a different VLM backbone model than PaliGemma by passing the corresponding VLM configuration to the class constructor.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vlm_config (`PretrainedConfig`, *optional*):\n+            Configuration of the VLM backbone model.\n+        text_config (`PretrainedConfig`, *optional*):\n+            Configuration of the text backbone model. Overrides the `text_config` attribute of the `vlm_config` if provided.\n+        embedding_dim (`int`, *optional*, defaults to 128):\n+            Dimension of the multi-vector embeddings produced by the model.\n+\n+    Example:\n+\n+    ```python\n+    from transformers.models.colpali import ColPaliConfig, ColPaliForRetrieval\n+\n+    config = ColPaliConfig()\n+    model = ColPaliForRetrieval(config)\n+    ```\n+    \"\"\"\n+\n+    model_type = \"colpali\"\n+    sub_configs = {\"vlm_config\": PretrainedConfig, \"text_config\": AutoConfig}\n+\n+    def __init__(\n+        self,\n+        vlm_config=None,\n+        text_config=None,\n+        embedding_dim: int = 128,\n+        **kwargs,\n+    ):\n+        if vlm_config is None:\n+            vlm_config = CONFIG_MAPPING[\"paligemma\"]()\n+            logger.info(\n+                \"`vlm_config` is `None`. Initializing `vlm_config` with the `PaliGemmaConfig` with default values.\"\n+            )\n+        elif isinstance(vlm_config, dict):\n+            vlm_config = deepcopy(vlm_config)\n+            if \"model_type\" not in vlm_config:\n+                raise KeyError(\n+                    \"The `model_type` key is missing in the `vlm_config` dictionary. Please provide the model type.\"\n+                )\n+            elif vlm_config[\"model_type\"] not in CONFIG_MAPPING:\n+                raise ValueError(\n+                    f\"The model type `{vlm_config['model_type']}` is not supported. Please provide a valid model type.\"\n+                )\n+            vlm_config = CONFIG_MAPPING[vlm_config[\"model_type\"]](**vlm_config)\n+        elif isinstance(vlm_config, PretrainedConfig):\n+            vlm_config = vlm_config\n+        else:\n+            raise TypeError(\n+                f\"Invalid type for `vlm_config`. Expected `PretrainedConfig`, `dict`, or `None`, but got {type(vlm_config)}.\"\n+            )\n+\n+        self.vlm_config = vlm_config\n+        self.text_config = text_config = text_config if text_config is not None else vlm_config.text_config\n+        if isinstance(self.text_config, dict):\n+            text_config[\"model_type\"] = text_config[\"model_type\"] if \"model_type\" in text_config else \"gemma\"\n+            self.text_config = CONFIG_MAPPING[text_config[\"model_type\"]](**text_config)\n+\n+        self.embedding_dim = embedding_dim\n+\n+        super().__init__(**kwargs)\n+\n+\n+__all__ = [\"ColPaliConfig\"]"
        },
        {
            "sha": "595974e0da1c3f5af31470d5e596b23d46b37c6e",
            "filename": "src/transformers/models/colpali/convert_colpali_weights_to_hf.py",
            "status": "added",
            "additions": 207,
            "deletions": 0,
            "changes": 207,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fcolpali%2Fconvert_colpali_weights_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fcolpali%2Fconvert_colpali_weights_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fcolpali%2Fconvert_colpali_weights_to_hf.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -0,0 +1,207 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"\n+Convert ColPali weights from the original repository to the HF model format.\n+\n+Original repository: https://github.com/illuin-tech/colpali.\n+\n+NOTE: This script was originally run using `torch==2.5.1` and with:\n+\n+```bash\n+python src/transformers/models/colpali/convert_colpali_weights_to_hf.py \\\n+    --model_id vidore/colpali-v1.2-merged \\\n+    --revision 89fd9736194236a1ecb7a9ec9b04f537f6f896af \\\n+    --original_vlm_name_or_path google/paligemma-3b-mix-448 \\\n+    --output_dir vidore/colpali-v1.2-hf-internal \\\n+    --push_to_hub\n+```\n+\"\"\"\n+\n+import argparse\n+import glob\n+from pathlib import Path\n+from typing import Any, Dict, Optional\n+\n+import torch\n+from huggingface_hub import snapshot_download\n+from safetensors import safe_open\n+\n+from transformers import AutoConfig\n+from transformers.models.colpali import ColPaliForRetrieval\n+from transformers.models.colpali.configuration_colpali import ColPaliConfig\n+from transformers.utils import logging\n+\n+\n+logging.set_verbosity_info()\n+logger = logging.get_logger(__name__)\n+\n+\n+ORIGINAL_DTYPE = torch.bfloat16\n+\n+\n+def rename_state_dict_keys(state_dict: Dict[str, Any]) -> Dict[str, Any]:\n+    new_state_dict = {}\n+    for key, value in state_dict.items():\n+        new_key = key\n+        if key.startswith(\"custom_text_proj\"):\n+            new_key = key.replace(\"custom_text_proj\", \"embedding_proj_layer\")\n+        if key.startswith(\"model.\"):\n+            new_key = key.replace(\"model.\", \"vlm.\", 1)\n+        new_state_dict[new_key] = value\n+    return new_state_dict\n+\n+\n+def load_original_state_dict(model_id: str, revision: Optional[str] = None) -> Dict[str, torch.Tensor]:\n+    directory_path = snapshot_download(\n+        repo_id=model_id,\n+        revision=revision,\n+        allow_patterns=[\"*.safetensors\"],\n+    )\n+\n+    original_state_dict = {}\n+    for path in glob.glob(f\"{directory_path}/*\"):\n+        if path.endswith(\".safetensors\"):\n+            with safe_open(path, framework=\"pt\", device=\"cpu\") as f:\n+                for key in f.keys():\n+                    original_state_dict[key] = f.get_tensor(key)\n+\n+    # Some weights are tied, so `lm.head`` is not saved. Let's clone to load state dict.\n+    if \"lm_head.weight\" not in original_state_dict:\n+        original_state_dict[\"vlm.language_model.lm_head.weight\"] = original_state_dict[\n+            \"model.language_model.model.embed_tokens.weight\"\n+        ].clone()\n+\n+    return original_state_dict\n+\n+\n+@torch.no_grad()\n+def convert_colpali_weights_to_hf(\n+    model_id: str,\n+    output_dir: str,\n+    push_to_hub: bool,\n+    revision: Optional[str] = None,\n+    original_vlm_name_or_path: Optional[str] = None,\n+):\n+    # Load the original model data\n+    original_config = AutoConfig.from_pretrained(\n+        model_id,\n+        revision=revision,\n+    )\n+    if original_vlm_name_or_path is not None:\n+        original_config._name_or_path = original_vlm_name_or_path\n+    if hasattr(original_config, \"architectures\"):\n+        delattr(original_config, \"architectures\")\n+\n+    original_state_dict = load_original_state_dict(model_id, revision=revision)\n+\n+    # Format the state_dict keys\n+    original_state_dict = rename_state_dict_keys(original_state_dict)\n+\n+    # Create the new config\n+    config = ColPaliConfig(\n+        vlm_config=original_config,\n+        embedding_dim=128,  # hardcoded in the original model\n+    )\n+    config.model_type = \"colpali\"\n+    config.is_composition = False\n+\n+    # Load the untrained model\n+    model = ColPaliForRetrieval(config=config).to(\"cpu\").eval()\n+    print(\"Created model with new config and randomly initialized weights\")\n+\n+    # NOTE: The model was initialized with float32 weights. We need to convert it to the desired precision.\n+    # There are two ways to set the model's dtype:\n+    # - Using `model.from_pretrained(..., torch_dtype=dtype_precision)` doesn't convert the hyperparameters to the desired precision.\n+    # - Using `model.to(dtype_precision)` converts all values - including the hyperparameters - to the desired precision.\n+    # The following snippet allows a fine-grained control over the model's dtype, making sure that all\n+    # the new weights' dtypes match the original model.\n+    for param in model.parameters():\n+        param.data = param.data.to(ORIGINAL_DTYPE)\n+    print(f\"Converted the new model weights to `{ORIGINAL_DTYPE}`\")\n+\n+    # Load the original weights\n+    model.load_state_dict(original_state_dict)\n+    print(\"Loaded original model weights\")\n+\n+    # Tie the weights (following ColPali's `__init__`` step)\n+    if model.vlm.language_model._tied_weights_keys is not None:\n+        model._tied_weights_keys = [f\"vlm.language_model.{k}\" for k in model.vlm.language_model._tied_weights_keys]\n+\n+    # Sanity check: ensure all keys are the same\n+    state_dict_keys_old = set(original_state_dict.keys())\n+    state_dict_keys_new = set(model.state_dict().keys())\n+    disjoint_keys = state_dict_keys_old.symmetric_difference(state_dict_keys_new)\n+    if disjoint_keys:\n+        raise ValueError(f\"Incompatible keys: {disjoint_keys}\")\n+\n+    # Save the model\n+    if push_to_hub:\n+        model.push_to_hub(output_dir, private=True)\n+        print(f\"Model pushed to the hub at `{output_dir}`\")\n+    else:\n+        Path(output_dir).mkdir(exist_ok=True, parents=True)\n+        model.save_pretrained(output_dir)\n+        print(f\"Model saved to `{output_dir}`\")\n+\n+\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser(\n+        description=\"\"\"\n+        This script converts the original ColPali model to the HF model format.\n+\n+        Example usage:\n+        ```bash\n+        python src/transformers/models/colpali/convert_colpali_weights_to_hf.py \\\n+            --model_id vidore/colpali-v1.2-merged \\\n+            --revision 89fd9736194236a1ecb7a9ec9b04f537f6f896af \\\n+            --original_vlm_name_or_path google/paligemma-3b-mix-448 \\\n+            --output_dir vidore/colpali-v1.2-hf \\\n+            --push_to_hub\n+        ```\n+        \"\"\"\n+    )\n+    parser.add_argument(\n+        \"--model_id\",\n+        help=\"Model ID of the original model to convert\",\n+    )\n+    parser.add_argument(\n+        \"--output_dir\",\n+        help=\"Location to write HF model and tokenizer\",\n+    )\n+    parser.add_argument(\n+        \"--push_to_hub\",\n+        help=\"Whether or not to push the model to the hub at `output_dir` instead of saving it locally\",\n+        action=\"store_true\",\n+        default=False,\n+    )\n+    parser.add_argument(\n+        \"--revision\",\n+        help=\"Revision of the model to download\",\n+        default=None,\n+    )\n+    parser.add_argument(\n+        \"--original_vlm_name_or_path\",\n+        help=\"Name or path of the original VLM backbone model\",\n+        default=None,\n+    )\n+    args = parser.parse_args()\n+\n+    convert_colpali_weights_to_hf(\n+        model_id=args.model_id,\n+        output_dir=args.output_dir,\n+        push_to_hub=args.push_to_hub,\n+        revision=args.revision,\n+        original_vlm_name_or_path=args.original_vlm_name_or_path,\n+    )"
        },
        {
            "sha": "8bfff814c837565ad590a42017265861b79a2a70",
            "filename": "src/transformers/models/colpali/modeling_colpali.py",
            "status": "added",
            "additions": 299,
            "deletions": 0,
            "changes": 299,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fcolpali%2Fmodeling_colpali.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fcolpali%2Fmodeling_colpali.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fcolpali%2Fmodeling_colpali.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -0,0 +1,299 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch ColPali model\"\"\"\n+\n+from dataclasses import dataclass\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+from torch import nn\n+\n+from transformers import AutoModelForImageTextToText\n+\n+from ...cache_utils import Cache\n+from ...modeling_utils import PreTrainedModel\n+from ...utils import (\n+    ModelOutput,\n+    add_start_docstrings,\n+    add_start_docstrings_to_model_forward,\n+    replace_return_docstrings,\n+)\n+from .configuration_colpali import ColPaliConfig\n+\n+\n+_CONFIG_FOR_DOC = \"ColPaliConfig\"\n+\n+COLPALI_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`ColPaliConfig`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare ColPali model outputting raw hidden-states without any specific head on top.\",\n+    COLPALI_START_DOCSTRING,\n+)\n+class ColPaliPreTrainedModel(PreTrainedModel):\n+    config_class = ColPaliConfig\n+    base_model_prefix = \"model\"\n+    _no_split_modules = []\n+\n+    def _init_weights(self, module):\n+        std = (\n+            self.config.initializer_range\n+            if hasattr(self.config, \"initializer_range\")\n+            else self.config.vlm_config.text_config.initializer_range\n+        )\n+\n+        if isinstance(module, (nn.Linear, nn.Conv2d)):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+\n+\n+@dataclass\n+class ColPaliForRetrievalOutput(ModelOutput):\n+    \"\"\"\n+    Base class for ColPali embeddings output.\n+\n+    Args:\n+        loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+            Language modeling loss (for next-token prediction).\n+        embeddings (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`):\n+            The embeddings of the model.\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+            `past_key_values` input) to speed up sequential decoding.\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        image_hidden_states (`torch.FloatTensor`, *optional*):\n+            A `torch.FloatTensor` of size `(batch_size, num_images, sequence_length, hidden_size)`.\n+            image_hidden_states of the model produced by the vision encoder after projecting last hidden state.\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    embeddings: torch.Tensor = None\n+    past_key_values: Optional[Union[List[torch.FloatTensor], Cache]] = None\n+    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+    attentions: Optional[Tuple[torch.FloatTensor]] = None\n+    image_hidden_states: Optional[torch.FloatTensor] = None\n+\n+\n+COLPALI_FOR_RETRIEVAL_INPUT_DOCSTRING = r\"\"\"\n+    Args:\n+        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+            it.\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+            [What are input IDs?](../glossary#input-ids)\n+        pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)):\n+            The tensors corresponding to the input images. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`SiglipImageProcessor.__call__`] for details ([]`PaliGemmaProcessor`] uses\n+            [`SiglipImageProcessor`] for processing images). If none, ColPali will only process text (query embeddings).\n+        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+            - 1 for tokens that are **not masked**,\n+            - 0 for tokens that are **masked**.\n+            [What are attention masks?](../glossary#attention-mask)\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+            If `past_key_values` is used, optionally only the last `decoder_input_ids` have to be input (see\n+            `past_key_values`).\n+            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n+            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n+            information on the default strategy.\n+            - 1 indicates the head is **not masked**,\n+            - 0 indicates the head is **masked**.\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+        kwargs (`Dict[str, Any]`, *optional*):\n+            Additional key word arguments passed along to the vlm backbone model.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"\"\"\n+    ColPali leverages Vision Language Models (VLMs) to construct efficient multi-vector embeddings in the visual space for document retrieval.\n+    By feeding the ViT output patches from PaliGemma-3B to a linear projection, we create a multi-vector representation of documents. The model\n+    is trained to maximize the similarity between these document embeddings and the query embeddings, following the ColBERT method.\n+\n+    Using ColPali removes the need for potentially complex and brittle layout recognition and OCR pipelines with a single model that can take into account\n+    both the textual and visual content (layout, charts, ...) of a document.\n+\n+    ColPali was introduced in the following paper: [*ColPali: Efficient Document Retrieval with Vision Language Models*](https://arxiv.org/abs/2407.01449).\n+\n+    Resources:\n+    - A blog post detailing ColPali, a vision retrieval model, can be found [here](https://huggingface.co/blog/manu/colpali). üìù\n+    - The code for using and training the original ColPali model and for the `colpali-engine` package can be found [here](https://github.com/illuin-tech/colpali). üåé\n+    - Cookbooks for learning to use the Hf version of ColPali, fine-tuning, and similarity maps generation can be found [here](https://github.com/tonywu71/colpali-cookbooks). üìö\n+    \"\"\"\n+)\n+class ColPaliForRetrieval(ColPaliPreTrainedModel):\n+    def __init__(self, config: ColPaliConfig):\n+        super().__init__(config)\n+        self.config = config\n+        self.vocab_size = config.vlm_config.text_config.vocab_size\n+\n+        vlm = AutoModelForImageTextToText.from_config(config.vlm_config)\n+        if vlm.language_model._tied_weights_keys is not None:\n+            self._tied_weights_keys = [f\"vlm.language_model.{k}\" for k in vlm.language_model._tied_weights_keys]\n+        self.vlm = vlm\n+\n+        self.embedding_dim = self.config.embedding_dim\n+        self.embedding_proj_layer = nn.Linear(\n+            self.config.vlm_config.text_config.hidden_size,\n+            self.embedding_dim,\n+        )\n+\n+        self.post_init()\n+\n+    @add_start_docstrings_to_model_forward(COLPALI_FOR_RETRIEVAL_INPUT_DOCSTRING)\n+    @replace_return_docstrings(output_type=ColPaliForRetrievalOutput, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        pixel_values: torch.FloatTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        **kwargs,\n+    ) -> Union[Tuple, ColPaliForRetrievalOutput]:\n+        r\"\"\"\n+        Returns:\n+        \"\"\"\n+        if \"pixel_values\" in kwargs:\n+            kwargs[\"pixel_values\"] = kwargs[\"pixel_values\"].to(dtype=self.dtype)\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        outputs = self.vlm(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            pixel_values=pixel_values,\n+            output_hidden_states=True,\n+            return_dict=return_dict,\n+            output_attentions=output_attentions,\n+            **kwargs,\n+        )\n+\n+        last_hidden_states = outputs.hidden_states[-1]  # (batch_size, sequence_length, hidden_size)\n+        embeddings = self.embedding_proj_layer(last_hidden_states)  # (batch_size, sequence_length, dim)\n+\n+        # L2 normalization\n+        embeddings = embeddings / embeddings.norm(dim=-1, keepdim=True)  # (batch_size, sequence_length, dim)\n+\n+        embeddings = embeddings * attention_mask.unsqueeze(-1)  # (batch_size, sequence_length, dim)\n+\n+        loss = None\n+        if not return_dict:\n+            output = (embeddings,) + outputs[2:]\n+            output[2] = output[2] if output_hidden_states is not None else None\n+            output[-1] = (outputs.image_hidden_states if pixel_values is not None else None,)\n+            return (loss,) + output if loss is not None else output\n+\n+        return ColPaliForRetrievalOutput(\n+            loss=loss,\n+            embeddings=embeddings,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states if output_hidden_states else None,\n+            attentions=outputs.attentions,\n+            image_hidden_states=outputs.image_hidden_states if pixel_values is not None else None,\n+        )\n+\n+    def get_input_embeddings(self):\n+        return self.vlm.language_model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.vlm.language_model.set_input_embeddings(value)\n+\n+    def get_output_embeddings(self):\n+        return self.vlm.language_model.get_output_embeddings()\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.vlm.language_model.set_output_embeddings(new_embeddings)\n+\n+    def set_decoder(self, decoder):\n+        self.vlm.language_model.set_decoder(decoder)\n+\n+    def get_decoder(self):\n+        return self.vlm.language_model.get_decoder()\n+\n+    def tie_weights(self):\n+        return self.vlm.language_model.tie_weights()\n+\n+    def resize_token_embeddings(\n+        self,\n+        new_num_tokens: Optional[int] = None,\n+        pad_to_multiple_of: Optional[int] = None,\n+        mean_resizing: bool = True,\n+    ) -> nn.Embedding:\n+        model_embeds = self.vlm.language_model.resize_token_embeddings(\n+            new_num_tokens=new_num_tokens,\n+            pad_to_multiple_of=pad_to_multiple_of,\n+            mean_resizing=mean_resizing,\n+        )\n+\n+        self.config.vlm_config.text_config.vocab_size = model_embeds.num_embeddings\n+        self.config.vlm_config.vocab_size = model_embeds.num_embeddings\n+        self.vlm.vocab_size = model_embeds.num_embeddings\n+        self.vocab_size = model_embeds.num_embeddings\n+\n+        return model_embeds\n+\n+\n+__all__ = [\n+    \"ColPaliForRetrieval\",\n+    \"ColPaliForRetrievalOutput\",\n+    \"ColPaliPreTrainedModel\",\n+]"
        },
        {
            "sha": "ceb43e2d66f33525bf8b9f9c8d46b78ed20e03e9",
            "filename": "src/transformers/models/colpali/modular_colpali.py",
            "status": "added",
            "additions": 354,
            "deletions": 0,
            "changes": 354,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fcolpali%2Fmodular_colpali.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fcolpali%2Fmodular_colpali.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fcolpali%2Fmodular_colpali.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -0,0 +1,354 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+from typing import ClassVar, List, Optional, Union\n+\n+from transformers.models.paligemma.processing_paligemma import (\n+    IMAGE_TOKEN,\n+    PaliGemmaProcessor,\n+    build_string_from_input,\n+    make_batched_images,\n+)\n+\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_utils import ImageInput, is_valid_image\n+from ...processing_utils import (\n+    ProcessingKwargs,\n+    Unpack,\n+)\n+from ...tokenization_utils_base import (\n+    PreTokenizedInput,\n+    TextInput,\n+)\n+from ...utils import (\n+    is_torch_available,\n+    logging,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class ColPaliProcessorKwargs(ProcessingKwargs, total=False):\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": \"longest\",\n+        },\n+        \"images_kwargs\": {\n+            \"data_format\": \"channels_first\",\n+            \"do_convert_rgb\": True,\n+        },\n+        \"common_kwargs\": {\"return_tensors\": \"pt\"},\n+    }\n+\n+\n+class ColPaliProcessor(PaliGemmaProcessor):\n+    r\"\"\"\n+    Constructs a ColPali processor which wraps a PaliGemmaProcessor and special methods to process images and queries, as\n+    well as to compute the late-interaction retrieval score.\n+\n+    [`ColPaliProcessor`] offers all the functionalities of [`PaliGemmaProcessor`]. See the [`~PaliGemmaProcessor.__call__`]\n+    for more information.\n+\n+    Args:\n+        image_processor ([`SiglipImageProcessor`], *optional*):\n+            The image processor is a required input.\n+        tokenizer ([`LlamaTokenizerFast`], *optional*):\n+            The tokenizer is a required input.\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    visual_prompt_prefix: ClassVar[str] = \"Describe the image.\"\n+    query_prefix: ClassVar[str] = \"Question: \"\n+\n+    @property\n+    def query_augmentation_token(self) -> str:\n+        \"\"\"\n+        Return the query augmentation token.\n+\n+        Query augmentation buffers are used as reasoning buffers during inference.\n+        \"\"\"\n+        return self.tokenizer.pad_token\n+\n+    def __call__(\n+        self,\n+        images: ImageInput = None,\n+        text: Union[TextInput, PreTokenizedInput, List[TextInput], List[PreTokenizedInput]] = None,\n+        audio=None,\n+        videos=None,\n+        **kwargs: Unpack[ColPaliProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Main method to prepare for the model either (1) one or several texts, either (2) one or several image(s). This method is custom\n+        wrapper around the PaliGemmaProcessor's [`~PaliGemmaProcessor.__call__`] method adapted for the ColPali model. It cannot process\n+        both text and images at the same time.\n+\n+        When preparing the the text(s), this method forwards the `text` and `kwargs` arguments to LlamaTokenizerFast's\n+        [`~LlamaTokenizerFast.__call__`].\n+        When preparing the the image(s), this method forwards the `images` and `kwargs` arguments to SiglipImageProcessor's\n+        [`~SiglipImageProcessor.__call__`].\n+        Please refer to the doctsring of the above two methods for more information.\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. In case of a NumPy array/PyTorch tensor, each image should be of shape (C, H, W), where C is a\n+                number of channels, H and W are image height and width.\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+        \"\"\"\n+        output_kwargs = self._merge_kwargs(\n+            ColPaliProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+        suffix = output_kwargs[\"text_kwargs\"].pop(\"suffix\", None)\n+\n+        return_token_type_ids = True if suffix is not None else False\n+\n+        if text is None and images is None:\n+            raise ValueError(\"Either text or images must be provided\")\n+        if text is not None and images is not None:\n+            raise ValueError(\"Only one of text or images can be processed at a time\")\n+\n+        if images is not None:\n+            if is_valid_image(images):\n+                images = [images]\n+            elif isinstance(images, list) and is_valid_image(images[0]):\n+                pass\n+            elif not (isinstance(images, list) and isinstance(images[0], list) and is_valid_image(images[0][0])):\n+                raise ValueError(\"images must be an image, list of images or list of list of images\")\n+\n+            texts_doc = [self.visual_prompt_prefix] * len(images)\n+            images = [image.convert(\"RGB\") for image in images]\n+\n+            input_strings = [\n+                build_string_from_input(\n+                    prompt=prompt,\n+                    bos_token=self.tokenizer.bos_token,\n+                    image_seq_len=self.image_seq_length,\n+                    image_token=IMAGE_TOKEN,\n+                    num_images=len(image_list) if isinstance(image_list, list) else 1,\n+                )\n+                for prompt, image_list in zip(texts_doc, images)\n+            ]\n+            images = make_batched_images(images)\n+            pixel_values = self.image_processor(images, **output_kwargs[\"images_kwargs\"])[\"pixel_values\"]\n+\n+            # max_length has to account for the image tokens\n+            if output_kwargs[\"text_kwargs\"].get(\"max_length\", None) is not None:\n+                output_kwargs[\"text_kwargs\"][\"max_length\"] += self.image_seq_length\n+\n+            inputs = self.tokenizer(\n+                input_strings,\n+                return_token_type_ids=False,\n+                **output_kwargs[\"text_kwargs\"],\n+            )\n+\n+            return_data = {**inputs, \"pixel_values\": pixel_values}\n+\n+            if return_token_type_ids:\n+                labels = inputs[\"input_ids\"].masked_fill(inputs[\"token_type_ids\"] == 0, -100)\n+                return_data.update({\"labels\": labels})\n+\n+            return BatchFeature(data=return_data)\n+\n+        elif text is not None:\n+            if isinstance(text, str):\n+                text = [text]\n+            elif not (isinstance(text, list) and isinstance(text[0], str)):\n+                raise ValueError(\"Text must be a string or a list of strings\")\n+\n+            if suffix is None:\n+                suffix = self.query_augmentation_token * 10\n+            texts_query: List[str] = []\n+\n+            for query in text:\n+                query = self.tokenizer.bos_token + self.query_prefix + query\n+                query += suffix  # add suffix (pad tokens)\n+                query += \"\\n\"  # make input ISO to PaliGemma's processor\n+                texts_query.append(query)\n+\n+            output_kwargs[\"text_kwargs\"][\"max_length\"] = output_kwargs[\"text_kwargs\"].get(\"max_length\", 50)\n+\n+            batch_query = self.tokenizer(\n+                texts_query,\n+                return_token_type_ids=False,\n+                **output_kwargs[\"text_kwargs\"],\n+            )\n+\n+            return batch_query\n+\n+    def process_images(\n+        self,\n+        images: ImageInput = None,\n+        **kwargs: Unpack[ColPaliProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Prepare for the model one or several image(s). This method is a wrapper around the `__call__` method of the ColPaliProcessor's\n+        [`ColPaliProcessor.__call__`].\n+\n+        This method forwards the `images` and `kwargs` arguments to SiglipImageProcessor's [`~SiglipImageProcessor.__call__`].\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. In case of a NumPy array/PyTorch tensor, each image should be of shape (C, H, W), where C is a\n+                number of channels, H and W are image height and width.\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+        \"\"\"\n+        return self.__call__(images=images, **kwargs)\n+\n+    def process_queries(\n+        self,\n+        text: Union[TextInput, List[TextInput]],\n+        **kwargs: Unpack[ColPaliProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Prepare for the model one or several texts. This method is a wrapper around the `__call__` method of the ColPaliProcessor's\n+        [`ColPaliProcessor.__call__`].\n+\n+        This method forwards the `text` and `kwargs` arguments to LlamaTokenizerFast's [`~LlamaTokenizerFast.__call__`].\n+\n+        Args:\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+        \"\"\"\n+        return self.__call__(text=text, **kwargs)\n+\n+    def score_retrieval(\n+        self,\n+        query_embeddings: Union[\"torch.Tensor\", List[\"torch.Tensor\"]],\n+        passage_embeddings: Union[\"torch.Tensor\", List[\"torch.Tensor\"]],\n+        batch_size: int = 128,\n+        output_dtype: Optional[\"torch.dtype\"] = None,\n+        output_device: Union[\"torch.device\", str] = \"cpu\",\n+    ) -> \"torch.Tensor\":\n+        \"\"\"\n+        Compute the late-interaction/MaxSim score (ColBERT-like) for the given multi-vector\n+        query embeddings (`qs`) and passage embeddings (`ps`). For ColPali, a passage is the\n+        image of a document page.\n+\n+        Because the embedding tensors are multi-vector and can thus have different shapes, they\n+        should be fed as:\n+        (1) a list of tensors, where the i-th tensor is of shape (sequence_length_i, embedding_dim)\n+        (2) a single tensor of shape (n_passages, max_sequence_length, embedding_dim) -> usually\n+            obtained by padding the list of tensors.\n+\n+        Args:\n+            query_embeddings (`Union[torch.Tensor, List[torch.Tensor]`): Query embeddings.\n+            passage_embeddings (`Union[torch.Tensor, List[torch.Tensor]`): Passage embeddings.\n+            batch_size (`int`, *optional*, defaults to 128): Batch size for computing scores.\n+            output_dtype (`torch.dtype`, *optional*, defaults to `torch.float32`): The dtype of the output tensor.\n+                If `None`, the dtype of the input embeddings is used.\n+            output_device (`torch.device` or `str`, *optional*, defaults to \"cpu\"): The device of the output tensor.\n+\n+        Returns:\n+            `torch.Tensor`: A tensor of shape `(n_queries, n_passages)` containing the scores. The score\n+            tensor is saved on the \"cpu\" device.\n+        \"\"\"\n+\n+        if len(query_embeddings) == 0:\n+            raise ValueError(\"No queries provided\")\n+        if len(passage_embeddings) == 0:\n+            raise ValueError(\"No passages provided\")\n+\n+        if query_embeddings[0].device != passage_embeddings[0].device:\n+            raise ValueError(\"Queries and passages must be on the same device\")\n+\n+        if query_embeddings[0].dtype != passage_embeddings[0].dtype:\n+            raise ValueError(\"Queries and passages must have the same dtype\")\n+\n+        if output_dtype is None:\n+            output_dtype = query_embeddings[0].dtype\n+\n+        scores: List[torch.Tensor] = []\n+\n+        for i in range(0, len(query_embeddings), batch_size):\n+            batch_scores: List[torch.Tensor] = []\n+            batch_queries = torch.nn.utils.rnn.pad_sequence(\n+                query_embeddings[i : i + batch_size], batch_first=True, padding_value=0\n+            )\n+            for j in range(0, len(passage_embeddings), batch_size):\n+                batch_passages = torch.nn.utils.rnn.pad_sequence(\n+                    passage_embeddings[j : j + batch_size], batch_first=True, padding_value=0\n+                )\n+                batch_scores.append(\n+                    torch.einsum(\"bnd,csd->bcns\", batch_queries, batch_passages).max(dim=3)[0].sum(dim=2)\n+                )\n+            scores.append(torch.cat(batch_scores, dim=1).to(output_dtype).to(output_device))\n+\n+        return torch.cat(scores, dim=0)\n+\n+\n+__all__ = [\n+    \"ColPaliProcessor\",\n+]"
        },
        {
            "sha": "f8d68675798bc472c6d2d609f33edc677ba4cb81",
            "filename": "src/transformers/models/colpali/processing_colpali.py",
            "status": "added",
            "additions": 443,
            "deletions": 0,
            "changes": 443,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fcolpali%2Fprocessing_colpali.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Fmodels%2Fcolpali%2Fprocessing_colpali.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fcolpali%2Fprocessing_colpali.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -0,0 +1,443 @@\n+#                üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®\n+#           This file was automatically generated from src/transformers/models/colpali/modular_colpali.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_colpali.py file directly. One of our CI enforces this.\n+#                üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®üö®\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+from typing import ClassVar, List, Optional, Union\n+\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_utils import ImageInput, is_valid_image\n+from ...processing_utils import ProcessingKwargs, ProcessorMixin, Unpack\n+from ...tokenization_utils_base import AddedToken, PreTokenizedInput, TextInput\n+from ...utils import is_torch_available\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+class ColPaliProcessorKwargs(ProcessingKwargs, total=False):\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": \"longest\",\n+        },\n+        \"images_kwargs\": {\n+            \"data_format\": \"channels_first\",\n+            \"do_convert_rgb\": True,\n+        },\n+        \"common_kwargs\": {\"return_tensors\": \"pt\"},\n+    }\n+\n+\n+IMAGE_TOKEN = \"<image>\"\n+EXTRA_TOKENS = [f\"<loc{i:0>4}>\" for i in range(1024)] + [f\"<seg{i:0>3}>\" for i in range(128)]\n+\n+\n+def build_string_from_input(prompt, bos_token, image_seq_len, image_token, num_images):\n+    \"\"\"\n+    Builds a string from the input prompt and image tokens.\n+    For example, for the call:\n+    build_string_from_input(\n+        prompt=\"Prefix str\"\n+        bos_token=\"<s>\",\n+        image_seq_len=3,\n+        image_token=\"<im>\",\n+    )\n+    The output will be:\n+    \"<im><im><im><s>Initial str\"\n+    Args:\n+        prompt (`List[Union[str, ImageInput]]`): The input prompt.\n+        bos_token (`str`): The beginning of sentence token.\n+        image_seq_len (`int`): The length of the image sequence.\n+        image_token (`str`): The image token.\n+        num_images (`int`): Number of images in the prompt.\n+    \"\"\"\n+    return f\"{image_token * image_seq_len * num_images}{bos_token}{prompt}\\n\"\n+\n+\n+def make_batched_images(images) -> List[List[ImageInput]]:\n+    \"\"\"\n+    Accepts images in list or nested list format, and makes a list of images for preprocessing.\n+\n+    Args:\n+        images (`Union[List[List[ImageInput]], List[ImageInput], ImageInput]`):\n+            The input image.\n+\n+    Returns:\n+        list: A list of images.\n+    \"\"\"\n+    if isinstance(images, (list, tuple)) and isinstance(images[0], (list, tuple)) and is_valid_image(images[0][0]):\n+        return [img for img_list in images for img in img_list]\n+\n+    elif isinstance(images, (list, tuple)) and is_valid_image(images[0]):\n+        return images\n+\n+    elif is_valid_image(images):\n+        return [images]\n+\n+    raise ValueError(f\"Could not make batched video from {images}\")\n+\n+\n+class ColPaliProcessor(ProcessorMixin):\n+    r\"\"\"\n+    Constructs a ColPali processor which wraps a PaliGemmaProcessor and special methods to process images and queries, as\n+    well as to compute the late-interaction retrieval score.\n+\n+    [`ColPaliProcessor`] offers all the functionalities of [`PaliGemmaProcessor`]. See the [`~PaliGemmaProcessor.__call__`]\n+    for more information.\n+\n+    Args:\n+        image_processor ([`SiglipImageProcessor`], *optional*):\n+            The image processor is a required input.\n+        tokenizer ([`LlamaTokenizerFast`], *optional*):\n+            The tokenizer is a required input.\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    attributes = [\"image_processor\", \"tokenizer\"]\n+    valid_kwargs = [\"chat_template\"]\n+    image_processor_class = \"SiglipImageProcessor\"\n+    tokenizer_class = (\"GemmaTokenizer\", \"GemmaTokenizerFast\")\n+\n+    visual_prompt_prefix: ClassVar[str] = \"Describe the image.\"\n+    query_prefix: ClassVar[str] = \"Question: \"\n+\n+    def __init__(\n+        self,\n+        image_processor=None,\n+        tokenizer=None,\n+        chat_template=None,\n+        **kwargs,\n+    ):\n+        if image_processor is None:\n+            raise ValueError(\"You need to specify an `image_processor`.\")\n+        if tokenizer is None:\n+            raise ValueError(\"You need to specify a `tokenizer`.\")\n+        if not hasattr(image_processor, \"image_seq_length\"):\n+            raise ValueError(\"Image processor is missing an `image_seq_length` attribute.\")\n+\n+        self.image_seq_length = image_processor.image_seq_length\n+\n+        if not hasattr(tokenizer, \"image_token\"):\n+            image_token = AddedToken(IMAGE_TOKEN, normalized=False, special=True)\n+            tokens_to_add = {\"additional_special_tokens\": [image_token]}\n+            tokenizer.add_special_tokens(tokens_to_add)\n+            self.image_token_id = tokenizer.convert_tokens_to_ids(IMAGE_TOKEN)\n+        else:\n+            self.image_token_id = tokenizer.image_token_id\n+\n+        tokenizer.add_tokens(EXTRA_TOKENS)\n+        tokenizer.add_bos_token = False\n+        tokenizer.add_eos_token = False\n+\n+        super().__init__(image_processor, tokenizer, chat_template=chat_template)\n+\n+    def __call__(\n+        self,\n+        images: ImageInput = None,\n+        text: Union[TextInput, PreTokenizedInput, List[TextInput], List[PreTokenizedInput]] = None,\n+        audio=None,\n+        videos=None,\n+        **kwargs: Unpack[ColPaliProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Main method to prepare for the model either (1) one or several texts, either (2) one or several image(s). This method is custom\n+        wrapper around the PaliGemmaProcessor's [`~PaliGemmaProcessor.__call__`] method adapted for the ColPali model. It cannot process\n+        both text and images at the same time.\n+\n+        When preparing the the text(s), this method forwards the `text` and `kwargs` arguments to LlamaTokenizerFast's\n+        [`~LlamaTokenizerFast.__call__`].\n+        When preparing the the image(s), this method forwards the `images` and `kwargs` arguments to SiglipImageProcessor's\n+        [`~SiglipImageProcessor.__call__`].\n+        Please refer to the doctsring of the above two methods for more information.\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. In case of a NumPy array/PyTorch tensor, each image should be of shape (C, H, W), where C is a\n+                number of channels, H and W are image height and width.\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+        \"\"\"\n+        output_kwargs = self._merge_kwargs(\n+            ColPaliProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+        suffix = output_kwargs[\"text_kwargs\"].pop(\"suffix\", None)\n+\n+        return_token_type_ids = True if suffix is not None else False\n+\n+        if text is None and images is None:\n+            raise ValueError(\"Either text or images must be provided\")\n+        if text is not None and images is not None:\n+            raise ValueError(\"Only one of text or images can be processed at a time\")\n+\n+        if images is not None:\n+            if is_valid_image(images):\n+                images = [images]\n+            elif isinstance(images, list) and is_valid_image(images[0]):\n+                pass\n+            elif not (isinstance(images, list) and isinstance(images[0], list) and is_valid_image(images[0][0])):\n+                raise ValueError(\"images must be an image, list of images or list of list of images\")\n+\n+            texts_doc = [self.visual_prompt_prefix] * len(images)\n+            images = [image.convert(\"RGB\") for image in images]\n+\n+            input_strings = [\n+                build_string_from_input(\n+                    prompt=prompt,\n+                    bos_token=self.tokenizer.bos_token,\n+                    image_seq_len=self.image_seq_length,\n+                    image_token=IMAGE_TOKEN,\n+                    num_images=len(image_list) if isinstance(image_list, list) else 1,\n+                )\n+                for prompt, image_list in zip(texts_doc, images)\n+            ]\n+            images = make_batched_images(images)\n+            pixel_values = self.image_processor(images, **output_kwargs[\"images_kwargs\"])[\"pixel_values\"]\n+\n+            # max_length has to account for the image tokens\n+            if output_kwargs[\"text_kwargs\"].get(\"max_length\", None) is not None:\n+                output_kwargs[\"text_kwargs\"][\"max_length\"] += self.image_seq_length\n+\n+            inputs = self.tokenizer(\n+                input_strings,\n+                return_token_type_ids=False,\n+                **output_kwargs[\"text_kwargs\"],\n+            )\n+\n+            return_data = {**inputs, \"pixel_values\": pixel_values}\n+\n+            if return_token_type_ids:\n+                labels = inputs[\"input_ids\"].masked_fill(inputs[\"token_type_ids\"] == 0, -100)\n+                return_data.update({\"labels\": labels})\n+\n+            return BatchFeature(data=return_data)\n+\n+        elif text is not None:\n+            if isinstance(text, str):\n+                text = [text]\n+            elif not (isinstance(text, list) and isinstance(text[0], str)):\n+                raise ValueError(\"Text must be a string or a list of strings\")\n+\n+            if suffix is None:\n+                suffix = self.query_augmentation_token * 10\n+            texts_query: List[str] = []\n+\n+            for query in text:\n+                query = self.tokenizer.bos_token + self.query_prefix + query\n+                query += suffix  # add suffix (pad tokens)\n+                query += \"\\n\"  # make input ISO to PaliGemma's processor\n+                texts_query.append(query)\n+\n+            output_kwargs[\"text_kwargs\"][\"max_length\"] = output_kwargs[\"text_kwargs\"].get(\"max_length\", 50)\n+\n+            batch_query = self.tokenizer(\n+                texts_query,\n+                return_token_type_ids=False,\n+                **output_kwargs[\"text_kwargs\"],\n+            )\n+\n+            return batch_query\n+\n+    def batch_decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to GemmaTokenizerFast's [`~PreTrainedTokenizer.batch_decode`]. Please\n+        refer to the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.batch_decode(*args, **kwargs)\n+\n+    def decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to GemmaTokenizerFast's [`~PreTrainedTokenizer.decode`]. Please refer to\n+        the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.decode(*args, **kwargs)\n+\n+    @property\n+    def model_input_names(self):\n+        tokenizer_input_names = self.tokenizer.model_input_names\n+        image_processor_input_names = self.image_processor.model_input_names\n+        return list(dict.fromkeys(tokenizer_input_names + image_processor_input_names))\n+\n+    @property\n+    def query_augmentation_token(self) -> str:\n+        \"\"\"\n+        Return the query augmentation token.\n+\n+        Query augmentation buffers are used as reasoning buffers during inference.\n+        \"\"\"\n+        return self.tokenizer.pad_token\n+\n+    def process_images(\n+        self,\n+        images: ImageInput = None,\n+        **kwargs: Unpack[ColPaliProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Prepare for the model one or several image(s). This method is a wrapper around the `__call__` method of the ColPaliProcessor's\n+        [`ColPaliProcessor.__call__`].\n+\n+        This method forwards the `images` and `kwargs` arguments to SiglipImageProcessor's [`~SiglipImageProcessor.__call__`].\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. In case of a NumPy array/PyTorch tensor, each image should be of shape (C, H, W), where C is a\n+                number of channels, H and W are image height and width.\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+        \"\"\"\n+        return self.__call__(images=images, **kwargs)\n+\n+    def process_queries(\n+        self,\n+        text: Union[TextInput, List[TextInput]],\n+        **kwargs: Unpack[ColPaliProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Prepare for the model one or several texts. This method is a wrapper around the `__call__` method of the ColPaliProcessor's\n+        [`ColPaliProcessor.__call__`].\n+\n+        This method forwards the `text` and `kwargs` arguments to LlamaTokenizerFast's [`~LlamaTokenizerFast.__call__`].\n+\n+        Args:\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+        \"\"\"\n+        return self.__call__(text=text, **kwargs)\n+\n+    def score_retrieval(\n+        self,\n+        query_embeddings: Union[\"torch.Tensor\", List[\"torch.Tensor\"]],\n+        passage_embeddings: Union[\"torch.Tensor\", List[\"torch.Tensor\"]],\n+        batch_size: int = 128,\n+        output_dtype: Optional[\"torch.dtype\"] = None,\n+        output_device: Union[\"torch.device\", str] = \"cpu\",\n+    ) -> \"torch.Tensor\":\n+        \"\"\"\n+        Compute the late-interaction/MaxSim score (ColBERT-like) for the given multi-vector\n+        query embeddings (`qs`) and passage embeddings (`ps`). For ColPali, a passage is the\n+        image of a document page.\n+\n+        Because the embedding tensors are multi-vector and can thus have different shapes, they\n+        should be fed as:\n+        (1) a list of tensors, where the i-th tensor is of shape (sequence_length_i, embedding_dim)\n+        (2) a single tensor of shape (n_passages, max_sequence_length, embedding_dim) -> usually\n+            obtained by padding the list of tensors.\n+\n+        Args:\n+            query_embeddings (`Union[torch.Tensor, List[torch.Tensor]`): Query embeddings.\n+            passage_embeddings (`Union[torch.Tensor, List[torch.Tensor]`): Passage embeddings.\n+            batch_size (`int`, *optional*, defaults to 128): Batch size for computing scores.\n+            output_dtype (`torch.dtype`, *optional*, defaults to `torch.float32`): The dtype of the output tensor.\n+                If `None`, the dtype of the input embeddings is used.\n+            output_device (`torch.device` or `str`, *optional*, defaults to \"cpu\"): The device of the output tensor.\n+\n+        Returns:\n+            `torch.Tensor`: A tensor of shape `(n_queries, n_passages)` containing the scores. The score\n+            tensor is saved on the \"cpu\" device.\n+        \"\"\"\n+\n+        if len(query_embeddings) == 0:\n+            raise ValueError(\"No queries provided\")\n+        if len(passage_embeddings) == 0:\n+            raise ValueError(\"No passages provided\")\n+\n+        if query_embeddings[0].device != passage_embeddings[0].device:\n+            raise ValueError(\"Queries and passages must be on the same device\")\n+\n+        if query_embeddings[0].dtype != passage_embeddings[0].dtype:\n+            raise ValueError(\"Queries and passages must have the same dtype\")\n+\n+        if output_dtype is None:\n+            output_dtype = query_embeddings[0].dtype\n+\n+        scores: List[torch.Tensor] = []\n+\n+        for i in range(0, len(query_embeddings), batch_size):\n+            batch_scores: List[torch.Tensor] = []\n+            batch_queries = torch.nn.utils.rnn.pad_sequence(\n+                query_embeddings[i : i + batch_size], batch_first=True, padding_value=0\n+            )\n+            for j in range(0, len(passage_embeddings), batch_size):\n+                batch_passages = torch.nn.utils.rnn.pad_sequence(\n+                    passage_embeddings[j : j + batch_size], batch_first=True, padding_value=0\n+                )\n+                batch_scores.append(\n+                    torch.einsum(\"bnd,csd->bcns\", batch_queries, batch_passages).max(dim=3)[0].sum(dim=2)\n+                )\n+            scores.append(torch.cat(batch_scores, dim=1).to(output_dtype).to(output_device))\n+\n+        return torch.cat(scores, dim=0)\n+\n+\n+__all__ = [\"ColPaliProcessor\"]"
        },
        {
            "sha": "823c51a290713d39eea595bc240578405842055a",
            "filename": "src/transformers/utils/dummy_pt_objects.py",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -813,6 +813,9 @@ def __init__(self, *args, **kwargs):\n MODEL_FOR_QUESTION_ANSWERING_MAPPING = None\n \n \n+MODEL_FOR_RETRIEVAL_MAPPING = None\n+\n+\n MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING = None\n \n \n@@ -2258,6 +2261,20 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torch\"])\n \n \n+class ColPaliForRetrieval(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class ColPaliPreTrainedModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n class ConditionalDetrForObjectDetection(metaclass=DummyObject):\n     _backends = [\"torch\"]\n "
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/colpali/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/tests%2Fmodels%2Fcolpali%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/tests%2Fmodels%2Fcolpali%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fcolpali%2F__init__.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d"
        },
        {
            "sha": "646726ac700ee525082ccdcae367b8a8df0097f6",
            "filename": "tests/models/colpali/test_modeling_colpali.py",
            "status": "added",
            "additions": 368,
            "deletions": 0,
            "changes": 368,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/tests%2Fmodels%2Fcolpali%2Ftest_modeling_colpali.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/tests%2Fmodels%2Fcolpali%2Ftest_modeling_colpali.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fcolpali%2Ftest_modeling_colpali.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -0,0 +1,368 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch ColPali model.\"\"\"\n+\n+import gc\n+import unittest\n+from typing import ClassVar\n+\n+import torch\n+from datasets import load_dataset\n+from parameterized import parameterized\n+\n+from tests.test_configuration_common import ConfigTester\n+from tests.test_modeling_common import ModelTesterMixin, floats_tensor, ids_tensor\n+from transformers import (\n+    is_torch_available,\n+    is_vision_available,\n+)\n+from transformers.models.colpali.configuration_colpali import ColPaliConfig\n+from transformers.models.colpali.modeling_colpali import ColPaliForRetrieval, ColPaliForRetrievalOutput\n+from transformers.models.colpali.processing_colpali import ColPaliProcessor\n+from transformers.testing_utils import (\n+    require_torch,\n+    require_torch_sdpa,\n+    require_vision,\n+    slow,\n+    torch_device,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_vision_available():\n+    pass\n+\n+\n+class ColPaliForRetrievalModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        ignore_index=-100,\n+        image_token_index=0,\n+        projector_hidden_act=\"gelu\",\n+        seq_length=25,\n+        vision_feature_select_strategy=\"default\",\n+        vision_feature_layer=-1,\n+        projection_dim=32,\n+        text_config={\n+            \"model_type\": \"gemma\",\n+            \"seq_length\": 128,\n+            \"is_training\": True,\n+            \"use_token_type_ids\": False,\n+            \"use_labels\": True,\n+            \"vocab_size\": 99,\n+            \"hidden_size\": 32,\n+            \"num_hidden_layers\": 2,\n+            \"num_attention_heads\": 4,\n+            \"num_key_value_heads\": 1,\n+            \"head_dim\": 8,\n+            \"intermediate_size\": 37,\n+            \"hidden_activation\": \"gelu_pytorch_tanh\",\n+            \"hidden_dropout_prob\": 0.1,\n+            \"attention_probs_dropout_prob\": 0.1,\n+            \"max_position_embeddings\": 512,\n+            \"type_vocab_size\": 16,\n+            \"type_sequence_label_size\": 2,\n+            \"initializer_range\": 0.02,\n+            \"num_labels\": 3,\n+            \"num_choices\": 4,\n+            \"pad_token_id\": 1,\n+        },\n+        is_training=False,\n+        vision_config={\n+            \"use_labels\": True,\n+            \"image_size\": 20,\n+            \"patch_size\": 5,\n+            \"num_image_tokens\": 4,\n+            \"num_channels\": 3,\n+            \"is_training\": True,\n+            \"hidden_size\": 32,\n+            \"projection_dim\": 32,\n+            \"num_key_value_heads\": 1,\n+            \"num_hidden_layers\": 2,\n+            \"num_attention_heads\": 4,\n+            \"intermediate_size\": 37,\n+            \"dropout\": 0.1,\n+            \"attention_dropout\": 0.1,\n+            \"initializer_range\": 0.02,\n+        },\n+        use_cache=False,\n+        embedding_dim=128,\n+    ):\n+        self.parent = parent\n+        self.ignore_index = ignore_index\n+        # `image_token_index` is set to 0 to pass \"resize_embeddings\" test, do not modify\n+        self.image_token_index = image_token_index\n+        self.projector_hidden_act = projector_hidden_act\n+        self.vision_feature_select_strategy = vision_feature_select_strategy\n+        self.vision_feature_layer = vision_feature_layer\n+        self.text_config = text_config\n+        self.vision_config = vision_config\n+        self.seq_length = seq_length\n+        self.projection_dim = projection_dim\n+        self.pad_token_id = text_config[\"pad_token_id\"]\n+\n+        self.num_hidden_layers = text_config[\"num_hidden_layers\"]\n+        self.vocab_size = text_config[\"vocab_size\"]\n+        self.hidden_size = text_config[\"hidden_size\"]\n+        self.num_attention_heads = text_config[\"num_attention_heads\"]\n+        self.is_training = is_training\n+\n+        self.batch_size = 3\n+        self.num_channels = vision_config[\"num_channels\"]\n+        self.image_size = vision_config[\"image_size\"]\n+        self.encoder_seq_length = seq_length\n+        self.use_cache = use_cache\n+\n+        self.embedding_dim = embedding_dim\n+        self.vlm_config = {\n+            \"model_type\": \"paligemma\",\n+            \"text_config\": self.text_config,\n+            \"vision_config\": self.vision_config,\n+            \"ignore_index\": self.ignore_index,\n+            \"image_token_index\": self.image_token_index,\n+            \"projector_hidden_act\": self.projector_hidden_act,\n+            \"projection_dim\": self.projection_dim,\n+            \"vision_feature_select_strategy\": self.vision_feature_select_strategy,\n+            \"vision_feature_layer\": self.vision_feature_layer,\n+        }\n+\n+    def get_config(self):\n+        return ColPaliConfig(\n+            vlm_config=self.vlm_config,\n+            embedding_dim=self.embedding_dim,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        pixel_values = floats_tensor(\n+            [\n+                self.batch_size,\n+                self.vision_config[\"num_channels\"],\n+                self.vision_config[\"image_size\"],\n+                self.vision_config[\"image_size\"],\n+            ]\n+        )\n+        config = self.get_config()\n+\n+        return config, pixel_values\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], config.vlm_config.text_config.vocab_size - 1) + 1\n+        attention_mask = input_ids.ne(1).to(torch_device)\n+        # set the 16 first tokens to be image, and ensure that no other tokens are image tokens\n+        # do not change this unless you modified image size or patch size\n+        input_ids[input_ids == config.vlm_config.image_token_index] = self.pad_token_id\n+        input_ids[:, :16] = config.vlm_config.image_token_index\n+        inputs_dict = {\n+            \"pixel_values\": pixel_values,\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+            \"labels\": input_ids,\n+            \"token_type_ids\": torch.zeros_like(input_ids),\n+        }\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class ColPaliForRetrievalModelTest(ModelTesterMixin, unittest.TestCase):\n+    \"\"\"\n+    Model tester for `ColPaliForRetrieval`.\n+    \"\"\"\n+\n+    all_model_classes = (ColPaliForRetrieval,) if is_torch_available() else ()\n+    fx_compatible = False\n+    test_torchscript = False\n+    test_pruning = False\n+    test_resize_embeddings = True\n+    test_head_masking = False\n+\n+    def setUp(self):\n+        self.model_tester = ColPaliForRetrievalModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=ColPaliConfig, has_text_modality=False)\n+\n+        # overwrite inputs_embeds tests because we need to delete \"pixel values\" for LVLMs\n+\n+    def test_inputs_embeds(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            inputs = self._prepare_for_class(inputs_dict, model_class)\n+\n+            input_ids = inputs[\"input_ids\"]\n+            del inputs[\"input_ids\"]\n+            del inputs[\"pixel_values\"]\n+\n+            wte = model.get_input_embeddings()\n+            inputs[\"inputs_embeds\"] = wte(input_ids)\n+\n+            with torch.no_grad():\n+                model(**inputs)\n+\n+    # overwrite inputs_embeds tests because we need to delete \"pixel values\" for LVLMs\n+    # while some other models require pixel_values to be present\n+    def test_inputs_embeds_matches_input_ids(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            inputs = self._prepare_for_class(inputs_dict, model_class)\n+            input_ids = inputs[\"input_ids\"]\n+            del inputs[\"input_ids\"]\n+            del inputs[\"pixel_values\"]\n+\n+            inputs_embeds = model.get_input_embeddings()(input_ids)\n+\n+            with torch.no_grad():\n+                out_ids = model(input_ids=input_ids, **inputs)[0]\n+                out_embeds = model(inputs_embeds=inputs_embeds, **inputs)[0]\n+            self.assertTrue(torch.allclose(out_embeds, out_ids))\n+\n+    @slow\n+    @require_vision\n+    def test_colpali_forward_inputs(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            inputs = self._prepare_for_class(inputs_dict, model_class)\n+\n+            with torch.no_grad():\n+                outputs = model(**inputs, return_dict=True)\n+\n+            self.assertIsInstance(outputs, ColPaliForRetrievalOutput)\n+\n+    @unittest.skip(\n+        reason=\"This architecure seem to not compute gradients properly when using GC, check: https://github.com/huggingface/transformers/pull/27124\"\n+    )\n+    def test_training_gradient_checkpointing(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"This architecure seem to not compute gradients properly when using GC, check: https://github.com/huggingface/transformers/pull/27124\"\n+    )\n+    def test_training_gradient_checkpointing_use_reentrant(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"This architecure seem to not compute gradients properly when using GC, check: https://github.com/huggingface/transformers/pull/27124\"\n+    )\n+    def test_training_gradient_checkpointing_use_reentrant_false(self):\n+        pass\n+\n+    @require_torch_sdpa\n+    @slow\n+    @parameterized.expand([(\"float16\",), (\"bfloat16\",), (\"float32\",)])\n+    def test_eager_matches_sdpa_inference(self, torch_dtype: str):\n+        self.skipTest(\n+            \"Due to custom causal mask, there is a slightly too big difference between eager and sdpa in bfloat16.\"\n+        )\n+\n+    @unittest.skip(\n+        reason=\"From PaliGemma: Some undefined behavior encountered with test versions of this model. Skip for now.\"\n+    )\n+    def test_model_parallelism(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"PaliGemmma's SigLip encoder uses the same initialization scheme as the Flax original implementation\"\n+    )\n+    def test_initialization(self):\n+        pass\n+\n+    # TODO extend valid outputs to include this test @Molbap\n+    @unittest.skip(reason=\"PaliGemma has currently one output format.\")\n+    def test_model_outputs_equivalence(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Pass because ColPali requires `attention_mask is not None`\")\n+    def test_sdpa_can_dispatch_on_flash(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Pass because ColPali requires `attention_mask is not None`\")\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n+\n+@require_torch\n+class ColPaliModelIntegrationTest(unittest.TestCase):\n+    model_name: ClassVar[str] = \"vidore/colpali-v1.2-hf\"\n+\n+    def setUp(self):\n+        self.processor = ColPaliProcessor.from_pretrained(self.model_name)\n+\n+    def tearDown(self):\n+        gc.collect()\n+        torch.cuda.empty_cache()\n+\n+    @slow\n+    def test_model_integration_test(self):\n+        \"\"\"\n+        Test if the model is able to retrieve the correct pages for a small and easy dataset.\n+        \"\"\"\n+        model = ColPaliForRetrieval.from_pretrained(\n+            self.model_name,\n+            torch_dtype=torch.bfloat16,\n+            device_map=torch_device,\n+        ).eval()\n+\n+        # Load the test dataset\n+        ds = load_dataset(\"hf-internal-testing/document-visual-retrieval-test\", split=\"test\")\n+\n+        # Preprocess the examples\n+        batch_images = self.processor(images=ds[\"image\"]).to(torch_device)\n+        batch_queries = self.processor(text=ds[\"query\"]).to(torch_device)\n+\n+        # Run inference\n+        with torch.inference_mode():\n+            image_embeddings = model(**batch_images).embeddings\n+            query_embeddings = model(**batch_queries).embeddings\n+\n+        # Compute retrieval scores\n+        scores = self.processor.score_retrieval(\n+            query_embeddings=query_embeddings,\n+            passage_embeddings=image_embeddings,\n+        )  # (len(qs), len(ps))\n+\n+        assert scores.ndim == 2, f\"Expected 2D tensor, got {scores.ndim}\"\n+        assert scores.shape == (len(ds), len(ds)), f\"Expected shape {(len(ds), len(ds))}, got {scores.shape}\"\n+\n+        # Check if the maximum scores per row are in the diagonal of the matrix score\n+        self.assertTrue((scores.argmax(axis=1) == torch.arange(len(ds), device=scores.device)).all())\n+\n+        # Further validation: fine-grained check, with a hardcoded score from the original implementation\n+        expected_scores = torch.tensor(\n+            [\n+                [15.5625, 6.5938, 14.4375],\n+                [12.2500, 16.2500, 11.0000],\n+                [15.0625, 11.7500, 21.0000],\n+            ],\n+            dtype=scores.dtype,\n+        )\n+\n+        assert torch.allclose(scores, expected_scores, atol=1), f\"Expected scores {expected_scores}, got {scores}\""
        },
        {
            "sha": "42592460fa28ed1976faa3d2c5ff9cfc875c1d73",
            "filename": "tests/models/colpali/test_processing_colpali.py",
            "status": "added",
            "additions": 247,
            "deletions": 0,
            "changes": 247,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/tests%2Fmodels%2Fcolpali%2Ftest_processing_colpali.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/tests%2Fmodels%2Fcolpali%2Ftest_processing_colpali.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fcolpali%2Ftest_processing_colpali.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -0,0 +1,247 @@\n+import shutil\n+import tempfile\n+import unittest\n+\n+import torch\n+\n+from transformers import GemmaTokenizer\n+from transformers.models.colpali.processing_colpali import ColPaliProcessor\n+from transformers.testing_utils import get_tests_dir, require_torch, require_vision\n+from transformers.utils import is_vision_available\n+from transformers.utils.dummy_vision_objects import SiglipImageProcessor\n+\n+from ...test_processing_common import ProcessorTesterMixin\n+\n+\n+if is_vision_available():\n+    from transformers import (\n+        ColPaliProcessor,\n+        PaliGemmaProcessor,\n+        SiglipImageProcessor,\n+    )\n+\n+SAMPLE_VOCAB = get_tests_dir(\"fixtures/test_sentencepiece.model\")\n+\n+\n+@require_vision\n+class ColPaliProcessorTest(ProcessorTesterMixin, unittest.TestCase):\n+    processor_class = ColPaliProcessor\n+\n+    def setUp(self):\n+        self.tmpdirname = tempfile.mkdtemp()\n+        image_processor = SiglipImageProcessor.from_pretrained(\"google/siglip-so400m-patch14-384\")\n+        image_processor.image_seq_length = 0\n+        tokenizer = GemmaTokenizer(SAMPLE_VOCAB, keep_accents=True)\n+        processor = PaliGemmaProcessor(image_processor=image_processor, tokenizer=tokenizer)\n+        processor.save_pretrained(self.tmpdirname)\n+\n+    def tearDown(self):\n+        shutil.rmtree(self.tmpdirname)\n+\n+    @require_torch\n+    @require_vision\n+    def test_process_images(self):\n+        # Processor configuration\n+        image_input = self.prepare_image_inputs()\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\", max_length=112, padding=\"max_length\")\n+        image_processor.image_seq_length = 14\n+\n+        # Get the processor\n+        processor = self.processor_class(\n+            tokenizer=tokenizer,\n+            image_processor=image_processor,\n+        )\n+\n+        # Process the image\n+        batch_feature = processor.process_images(images=image_input, return_tensors=\"pt\")\n+\n+        # Assertions\n+        self.assertIn(\"pixel_values\", batch_feature)\n+        self.assertEqual(batch_feature[\"pixel_values\"].shape, torch.Size([1, 3, 384, 384]))\n+\n+    @require_torch\n+    @require_vision\n+    def test_process_queries(self):\n+        # Inputs\n+        queries = [\n+            \"Is attention really all you need?\",\n+            \"Are Benjamin, Antoine, Merve, and Jo best friends?\",\n+        ]\n+\n+        # Processor configuration\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\", max_length=112, padding=\"max_length\")\n+        image_processor.image_seq_length = 14\n+\n+        # Get the processor\n+        processor = self.processor_class(\n+            tokenizer=tokenizer,\n+            image_processor=image_processor,\n+        )\n+\n+        # Process the image\n+        batch_feature = processor.process_queries(text=queries, return_tensors=\"pt\")\n+\n+        # Assertions\n+        self.assertIn(\"input_ids\", batch_feature)\n+        self.assertIsInstance(batch_feature[\"input_ids\"], torch.Tensor)\n+        self.assertEqual(batch_feature[\"input_ids\"].shape[0], len(queries))\n+\n+        # The following tests are overwritten as ColPaliProcessor can only take one of images or text as input at a time\n+\n+    def test_tokenizer_defaults_preserved_by_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        processor_components = self.prepare_components()\n+        processor_components[\"tokenizer\"] = self.get_component(\"tokenizer\", max_length=117, padding=\"max_length\")\n+\n+        processor = self.processor_class(**processor_components)\n+        self.skip_processor_without_typed_kwargs(processor)\n+        input_str = self.prepare_text_inputs()\n+        inputs = processor(text=input_str, return_tensors=\"pt\")\n+        self.assertEqual(inputs[self.text_input_name].shape[-1], 117)\n+\n+    def test_image_processor_defaults_preserved_by_image_kwargs(self):\n+        \"\"\"\n+        We use do_rescale=True, rescale_factor=-1 to ensure that image_processor kwargs are preserved in the processor.\n+        We then check that the mean of the pixel_values is less than or equal to 0 after processing.\n+        Since the original pixel_values are in [0, 255], this is a good indicator that the rescale_factor is indeed applied.\n+        \"\"\"\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        processor_components = self.prepare_components()\n+        processor_components[\"image_processor\"] = self.get_component(\n+            \"image_processor\", do_rescale=True, rescale_factor=-1\n+        )\n+        processor_components[\"tokenizer\"] = self.get_component(\"tokenizer\", max_length=117, padding=\"max_length\")\n+\n+        processor = self.processor_class(**processor_components)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        image_input = self.prepare_image_inputs()\n+\n+        inputs = processor(images=image_input, return_tensors=\"pt\")\n+        self.assertLessEqual(inputs[self.images_input_name][0][0].mean(), 0)\n+\n+    def test_kwargs_overrides_default_tokenizer_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        processor_components = self.prepare_components()\n+        processor_components[\"tokenizer\"] = self.get_component(\"tokenizer\", padding=\"longest\")\n+\n+        processor = self.processor_class(**processor_components)\n+        self.skip_processor_without_typed_kwargs(processor)\n+        input_str = self.prepare_text_inputs()\n+        inputs = processor(text=input_str, return_tensors=\"pt\", max_length=112, padding=\"max_length\")\n+        self.assertEqual(inputs[self.text_input_name].shape[-1], 112)\n+\n+    def test_kwargs_overrides_default_image_processor_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        processor_components = self.prepare_components()\n+        processor_components[\"image_processor\"] = self.get_component(\n+            \"image_processor\", do_rescale=True, rescale_factor=1\n+        )\n+        processor_components[\"tokenizer\"] = self.get_component(\"tokenizer\", max_length=117, padding=\"max_length\")\n+\n+        processor = self.processor_class(**processor_components)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        image_input = self.prepare_image_inputs()\n+\n+        inputs = processor(images=image_input, do_rescale=True, rescale_factor=-1, return_tensors=\"pt\")\n+        self.assertLessEqual(inputs[self.images_input_name][0][0].mean(), 0)\n+\n+    def test_unstructured_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        processor_components = self.prepare_components()\n+        processor = self.processor_class(**processor_components)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = self.prepare_text_inputs()\n+        inputs = processor(\n+            text=input_str,\n+            return_tensors=\"pt\",\n+            do_rescale=True,\n+            rescale_factor=-1,\n+            padding=\"max_length\",\n+            max_length=76,\n+        )\n+\n+        self.assertEqual(inputs[self.text_input_name].shape[-1], 76)\n+\n+    def test_unstructured_kwargs_batched(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        processor_components = self.prepare_components()\n+        processor = self.processor_class(**processor_components)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        image_input = self.prepare_image_inputs(batch_size=2)\n+        inputs = processor(\n+            images=image_input,\n+            return_tensors=\"pt\",\n+            do_rescale=True,\n+            rescale_factor=-1,\n+            padding=\"longest\",\n+            max_length=76,\n+        )\n+\n+        self.assertLessEqual(inputs[self.images_input_name][0][0].mean(), 0)\n+\n+    def test_doubly_passed_kwargs(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        processor_components = self.prepare_components()\n+        processor = self.processor_class(**processor_components)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        image_input = self.prepare_image_inputs()\n+        with self.assertRaises(ValueError):\n+            _ = processor(\n+                images=image_input,\n+                images_kwargs={\"do_rescale\": True, \"rescale_factor\": -1},\n+                do_rescale=True,\n+                return_tensors=\"pt\",\n+            )\n+\n+    def test_structured_kwargs_nested(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        processor_components = self.prepare_components()\n+        processor = self.processor_class(**processor_components)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        input_str = self.prepare_text_inputs()\n+\n+        # Define the kwargs for each modality\n+        all_kwargs = {\n+            \"common_kwargs\": {\"return_tensors\": \"pt\"},\n+            \"images_kwargs\": {\"do_rescale\": True, \"rescale_factor\": -1},\n+            \"text_kwargs\": {\"padding\": \"max_length\", \"max_length\": 76},\n+        }\n+\n+        inputs = processor(text=input_str, **all_kwargs)\n+        self.skip_processor_without_typed_kwargs(processor)\n+\n+        self.assertEqual(inputs[self.text_input_name].shape[-1], 76)\n+\n+    def test_structured_kwargs_nested_from_dict(self):\n+        if \"image_processor\" not in self.processor_class.attributes:\n+            self.skipTest(f\"image_processor attribute not present in {self.processor_class}\")\n+        processor_components = self.prepare_components()\n+        processor = self.processor_class(**processor_components)\n+        self.skip_processor_without_typed_kwargs(processor)\n+        image_input = self.prepare_image_inputs()\n+\n+        # Define the kwargs for each modality\n+        all_kwargs = {\n+            \"common_kwargs\": {\"return_tensors\": \"pt\"},\n+            \"images_kwargs\": {\"do_rescale\": True, \"rescale_factor\": -1},\n+            \"text_kwargs\": {\"padding\": \"max_length\", \"max_length\": 76},\n+        }\n+\n+        inputs = processor(images=image_input, **all_kwargs)\n+        self.assertEqual(inputs[self.text_input_name].shape[-1], 76)"
        },
        {
            "sha": "4a392a58fd0500a4e6e9837d5aba7a63268e9be5",
            "filename": "utils/check_table.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/utils%2Fcheck_table.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/utils%2Fcheck_table.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_table.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -87,7 +87,7 @@ def _find_text_in_file(filename: str, start_prompt: str, end_prompt: str) -> str\n _re_tf_models = re.compile(r\"TF(.*)(?:Model|Encoder|Decoder|ForConditionalGeneration)\")\n _re_flax_models = re.compile(r\"Flax(.*)(?:Model|Encoder|Decoder|ForConditionalGeneration)\")\n # Will match any TF or Flax model too so need to be in an else branch after the two previous regexes.\n-_re_pt_models = re.compile(r\"(.*)(?:Model|Encoder|Decoder|ForConditionalGeneration)\")\n+_re_pt_models = re.compile(r\"(.*)(?:Model|Encoder|Decoder|ForConditionalGeneration|ForRetrieval)\")\n \n \n # This is to make sure the transformers module imported is the one in the repo."
        },
        {
            "sha": "8e4a7e3fe5340e292a9409932f8e71989f5a4520",
            "filename": "utils/update_metadata.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/f33a0cebb37454a25af3d0be44832ea53c39733d/utils%2Fupdate_metadata.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f33a0cebb37454a25af3d0be44832ea53c39733d/utils%2Fupdate_metadata.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fupdate_metadata.py?ref=f33a0cebb37454a25af3d0be44832ea53c39733d",
            "patch": "@@ -56,7 +56,7 @@\n _re_tf_models = re.compile(r\"TF(.*)(?:Model|Encoder|Decoder|ForConditionalGeneration)\")\n _re_flax_models = re.compile(r\"Flax(.*)(?:Model|Encoder|Decoder|ForConditionalGeneration)\")\n # Will match any TF or Flax model too so need to be in an else branch afterthe two previous regexes.\n-_re_pt_models = re.compile(r\"(.*)(?:Model|Encoder|Decoder|ForConditionalGeneration)\")\n+_re_pt_models = re.compile(r\"(.*)(?:Model|Encoder|Decoder|ForConditionalGeneration|ForRetrieval)\")\n \n \n # Fill this with tuples (pipeline_tag, model_mapping, auto_model)"
        }
    ],
    "stats": {
        "total": 2206,
        "additions": 2204,
        "deletions": 2
    }
}