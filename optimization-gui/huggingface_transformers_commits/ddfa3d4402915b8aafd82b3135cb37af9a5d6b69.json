{
    "author": "itazap",
    "message": "blt wip (#38579)\n\n* blt wip\n\n* cpu version\n\n* cpu friendly with full entropy model (real time patching)\n\n* adding config file instead of args file\n\n* enable MPS\n\n* refactoring unused code\n\n* single config class in config file\n\n* inherit from PreTrainedModel\n\n* refactor LMTransformer --> BLTPatcher\n\n* add conversion script\n\n* load from new checkpoing with form_pretrained\n\n* fixed demo from_pretrained\n\n* clean up\n\n* clean a few comments\n\n* cleanup folder\n\n* clean up dir\n\n* cleaned up modeling further\n\n* rename classes\n\n* adding transformers Attention class and RotaryEmbedding class\n\n* exchanged blt modules for transformers modules: attention, rotary_emb, create_causal_mask, etc\n\n* seperate out patcher config, update modeling and conversion script\n\n* rename vars to be more transformers-like\n\n* rm unused functions\n\n* adding cross attention from transformers\n\n* pass arg\n\n* rename weights\n\n* updated conversion script\n\n* overwritten commit! fixing PR\n\n* apply feedback\n\n* adding BLTRMSNorm like Llama\n\n* add repeat_kv and eager_attention_forward copied from\n\n* BLTMLP identical to MllamTextMLP\n\n* clean up some args'\n\n* more like mllama, but busier inits\n\n* BLTTransformerLayer config\n\n* decoder, encoder, global configs\n\n* wip working on modular file\n\n* cleaning up patch and configs\n\n* clean up patcher helpers\n\n* clean up patcher helpers further\n\n* clean up\n\n* some config renaming\n\n* clean up unused configs\n\n* clean up configs\n\n* clean up configs\n\n* update modular\n\n* clean\n\n* update demo\n\n* config more like mllama, seperated subconfigs from subdicts\n\n* read from config instead of self args\n\n* update demo file\n\n* model weights to causal lm weights\n\n* missed file\n\n* added tied weights keys\n\n* BLTForCausalLM\n\n* adding files after add-new-model-like\n\n* update demo\n\n* working on tests\n\n* first running integration tests\n\n* added integration tests\n\n* adding tokenization tests, integration tests, and cleaned up tokenization file, + ruff\n\n* tokenizer clean up\n\n* modular file\n\n* fixing rebase\n\n* ruff\n\n* adding correct basemodel output and updating config with checkpoint vals (for testing)\n\n* BLTModelTests git status\n\n* enabling inputs_embeds, although won't be equal to input_ids since need ids for patching logic\n\n* fix sdpa == causal tests\n\n* fix small model test and some gradient checkpointing\n\n* skip training GC tests\n\n* fix test\n\n* updated modular\n\n* update modular\n\n* ruff\n\n* adding modular + modeling\n\n* modular\n\n* more modern is_casual check\n\n* cleaning up modular\n\n* more modular reduction\n\n* ruff\n\n* modular fix\n\n* fix styling\n\n* return 2\n\n* return 2\n\n* fix some tests\n\n* fix bltcrossattention after modular break\n\n* some fixes / feedback\n\n* try cache generate fix\n\n* try cache generate fix\n\n* fix generate tests\n\n* attn_impl workaround\n\n* refactoring to use recent TransformersKwargs changes\n\n* fix hidden_states shape test\n\n* refactor to new outputs\n\n* simplify outputs a bit\n\n* rm unneeded decoderlayer overwriting\n\n* rename blt\n\n* forgot tokenizer test renamed\n\n* Reorder\n\n* Reorder\n\n* working on modular\n\n* updates from modular\n\n* new modular\n\n* ruff and such\n\n* update pretrainedmodel modular\n\n* using cohere2 apply_rotary_pos_emb\n\n* small changes\n\n* apply feedback r2\n\n* fix cross_attention\n\n* apply more feedback\n\n* update modeling fix\n\n* load submodules from pretrainedmodel\n\n* set initializer_range to subconfigs\n\n* rm cross_attnetion_states pass when not needed\n\n* add 7b projection layer support\n\n* check repo\n\n* make copies\n\n* lost cohere2 rotate_half\n\n* ruff\n\n* copies?\n\n* don't tie weights for submodules\n\n* tie weights setting\n\n* check docstrings\n\n* apply feedback\n\n* rebase\n\n* rebased modeling\n\n* update docs\n\n* applying feedback\n\n* few more fixes\n\n* fix can_record_outputs\n\n* fast tokenizer\n\n* no more modulelist\n\n* tok auto\n\n* rm tokenizersss\n\n* fix docs\n\n* ruff\n\n* fix after rebase\n\n* fix test, configs are not subscriptable\n\n---------\n\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-168-30.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-161-103.ec2.internal>\nCo-authored-by: Lysandre <hi@lysand.re>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-174-36.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-164-45.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-173-121.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-160-103.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-161-178.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-162-79.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-169-239.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-167-111.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-160-100.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-161-153.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-166-15.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-165-131.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-161-138.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-174-215.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-172-142.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-172-147.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-164-0.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-163-58.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-165-202.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-166-244.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-174-186.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-160-192.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-162-14.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-171-249.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-164-75.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-161-78.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-163-134.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-162-180.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-175-241.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-160-225.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-167-9.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-168-34.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-166-68.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-167-175.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-170-160.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-168-95.ec2.internal>\nCo-authored-by: ita.zaporozhets@huggingface.co <ita_zaporozhets@ip-26-0-172-73.ec2.internal>",
    "sha": "ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
    "files": [
        {
            "sha": "6fdc16bcfce110412c3ccc25d48ab24202292ca7",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -407,6 +407,8 @@\n         title: Blenderbot Small\n       - local: model_doc/bloom\n         title: BLOOM\n+      - local: model_doc/blt\n+        title: BLT\n       - local: model_doc/bort\n         title: BORT\n       - local: model_doc/byt5"
        },
        {
            "sha": "0289f77ac90117fc437c0f2853928cb0b9a2b021",
            "filename": "docs/source/en/model_doc/blt.md",
            "status": "added",
            "additions": 97,
            "deletions": 0,
            "changes": 97,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/docs%2Fsource%2Fen%2Fmodel_doc%2Fblt.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/docs%2Fsource%2Fen%2Fmodel_doc%2Fblt.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fblt.md?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -0,0 +1,97 @@\n+<!--Copyright 2025 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+<div style=\"float: right;\">\n+    <div class=\"flex flex-wrap space-x-1\">\n+        <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+        <img alt=\"Flax\" src=\"https://img.shields.io/badge/Flax-29a79b.svg?style=flat&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAMAAAANxBKoAAAC7lBMVEUAAADg5vYHPVgAoJH+/v76+v39/f9JbLP///9+AIgAnY3///+mcqzt8fXy9fgkXa3Ax9709fr+///9/f8qXq49qp5AaLGMwrv8/P0eW60VWawxYq8yqJzG2dytt9Wyu9elzci519Lf3O3S2efY3OrY0+Xp7PT///////+dqNCexMc6Z7AGpJeGvbenstPZ5ejQ1OfJzOLa7ejh4+/r8fT29vpccbklWK8PVa0AS6ghW63O498vYa+lsdKz1NDRt9Kw1c672tbD3tnAxt7R6OHp5vDe7OrDyuDn6vLl6/EAQKak0MgATakkppo3ZK/Bz9y8w9yzu9jey97axdvHzeG21NHH4trTwthKZrVGZLSUSpuPQJiGAI+GAI8SWKydycLL4d7f2OTi1+S9xNzL0ePT6OLGzeEAo5U0qJw/aLEAo5JFa7JBabEAp5Y4qZ2QxLyKmsm3kL2xoMOehrRNb7RIbbOZgrGre68AUqwAqZqNN5aKJ5N/lMq+qsd8kMa4pcWzh7muhLMEV69juq2kbKqgUaOTR5uMMZWLLZSGAI5VAIdEAH+ovNDHuNCnxcy3qcaYx8K8msGplrx+wLahjbYdXrV6vbMvYK9DrZ8QrZ8tqJuFms+Sos6sw8ecy8RffsNVeMCvmb43aLltv7Q4Y7EZWK4QWa1gt6meZKUdr6GOAZVeA4xPAISyveLUwtivxtKTpNJ2jcqfvcltiMiwwcfAoMVxhL+Kx7xjdrqTe60tsaNQs6KaRKACrJ6UTZwkqpqTL5pkHY4AloSgsd2ptNXPvNOOncuxxsqFl8lmg8apt8FJcr9EbryGxLqlkrkrY7dRa7ZGZLQ5t6iXUZ6PPpgVpZeJCJFKAIGareTa0+KJod3H0deY2M+esM25usmYu8d2zsJOdcBVvrCLbqcAOaaHaKQAMaScWqKBXqCXMJ2RHpiLF5NmJZAdAHN2kta11dKu1M+DkcZLdb+Mcql3TppyRJdzQ5ZtNZNlIY+DF4+voCOQAAAAZ3RSTlMABAT+MEEJ/RH+/TP+Zlv+pUo6Ifz8+fco/fz6+evr39S9nJmOilQaF/7+/f38+smmoYp6b1T+/v7++vj189zU0tDJxsGzsrKSfv34+Pf27dDOysG9t6+n/vv6+vr59uzr1tG+tZ6Qg9Ym3QAABR5JREFUSMeNlVVUG1EQhpcuxEspXqS0SKEtxQp1d3d332STTRpIQhIISQgJhODu7lAoDoUCpe7u7u7+1puGpqnCPOyZvffbOXPm/PsP9JfQgyCC+tmTABTOcbxDz/heENS7/1F+9nhvkHePG0wNDLbGWwdXL+rbLWvpmZHXD8+gMfBjTh+aSe6Gnn7lwQIOTR0c8wfX3PWgv7avbdKwf/ZoBp1Gp/PvuvXW3vw5ib7emnTW4OR+3D4jB9vjNJ/7gNvfWWeH/TO/JyYrsiKCRjVEZA3UB+96kON+DxOQ/NLE8PE5iUYgIXjFnCOlxEQMaSGVxjg4gxOnEycGz8bptuNjVx08LscIgrzH3umcn+KKtiBIyvzOO2O99aAdR8cF19oZalnCtvREUw79tCd5sow1g1UKM6kXqUx4T8wsi3sTjJ3yzDmmhenLXLpo8u45eG5y4Vvbk6kkC4LLtJMowkSQxmk4ggVJEG+7c6QpHT8vvW9X7/o7+3ELmiJi2mEzZJiz8cT6TBlanBk70cB5GGIGC1gRDdZ00yADLW1FL6gqhtvNXNG5S9gdSrk4M1qu7JAsmYshzDS4peoMrU/gT7qQdqYGZaYhxZmVbGJAm/CS/HloWyhRUlknQ9KYcExTwS80d3VNOxUZJpITYyspl0LbhArhpZCD9cRWEQuhYkNGMHToQ/2Cs6swJlb39CsllxdXX6IUKh/H5jbnSsPKjgmoaFQ1f8wRLR0UnGE/RcDEjj2jXG1WVTwUs8+zxfcrVO+vSsuOpVKxCfYZiQ0/aPKuxQbQ8lIz+DClxC8u+snlcJ7Yr1z1JPqUH0V+GDXbOwAib931Y4Imaq0NTIXPXY+N5L18GJ37SVWu+hwXff8l72Ds9XuwYIBaXPq6Shm4l+Vl/5QiOlV+uTk6YR9PxKsI9xNJny31ygK1e+nIRC1N97EGkFPI+jCpiHe5PCEy7oWqWSwRrpOvhFzcbTWMbm3ZJAOn1rUKpYIt/lDhW/5RHHteeWFN60qo98YJuoq1nK3uW5AabyspC1BcIEpOhft+SZAShYoLSvnmSfnYADUERP5jJn2h5XtsgCRuhYQqAvwTwn33+YWEKUI72HX5AtfSAZDe8F2DtPPm77afhl0EkthzuCQU0BWApgQIH9+KB0JhopMM7bJrdTRoleM2JAVNMyPF+wdoaz+XJpGoVAQ7WXUkcV7gT3oUZyi/ISIJAVKhgNp+4b4veCFhYVJw4locdSjZCp9cPUhLF9EZ3KKzURepMEtCDPP3VcWFx4UIiZIklIpFNfHpdEafIF2aRmOcrUmjohbT2WUllbmRvgfbythbQO3222fpDJoufaQPncYYuqoGtUEsCJZL6/3PR5b4syeSjZMQG/T2maGANlXT2v8S4AULWaUkCxfLyW8iW4kdka+nEMjxpL2NCwsYNBp+Q61PF43zyDg9Bm9+3NNySn78jMZUUkumqE4Gp7JmFOdP1vc8PpRrzj9+wPinCy8K1PiJ4aYbnTYpCCbDkBSbzhu2QJ1Gd82t8jI8TH51+OzvXoWbnXUOBkNW+0mWFwGcGOUVpU81/n3TOHb5oMt2FgYGjzau0Nif0Ss7Q3XB33hjjQHjHA5E5aOyIQc8CBrLdQSs3j92VG+3nNEjbkbdbBr9zm04ruvw37vh0QKOdeGIkckc80fX3KH/h7PT4BOjgCty8VZ5ux1MoO5Cf5naca2LAsEgehI+drX8o/0Nu+W0m6K/I9gGPd/dfx/EN/wN62AhsBWuAAAAAElFTkSuQmCC\n+        \">\n+        <img alt=\"FlashAttention\" src=\"https://img.shields.io/badge/%E2%9A%A1%EF%B8%8E%20FlashAttention-eae0c8?style=flat\">\n+        <img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+    </div>\n+</div>\n+\n+# Byte Lantet Transformer (BLT)\n+\n+## Overview\n+\n+The BLT model was proposed in [Byte Latent Transformer: Patches Scale Better Than Tokens](<https://arxiv.org/pdf/2412.09871>) by Artidoro Pagnoni, Ram Pasunuru, Pedro Rodriguez, John Nguyen, Benjamin Muller, Margaret Li1, Chunting Zhou, Lili Yu, Jason Weston, Luke Zettlemoyer, Gargi Ghosh, Mike Lewis, Ari Holtzman†, Srinivasan Iyer.\n+BLT is a byte-level LLM that achieves tokenization-level performance through entropy-based dynamic patching.\n+\n+The abstract from the paper is the following:\n+\n+*We introduce the Byte Latent Transformer (BLT), a new byte-level LLM architecture that, for the first time, matches tokenization-based LLM performance at scale with significant improvements in inference\n+efficiency and robustness. BLT encodes bytes into dynamically sized patches, which serve as the primary units of computation. Patches are segmented based on the entropy of the next byte, allocating\n+more compute and model capacity where increased data complexity demands it. We present the first flop controlled scaling study of byte-level models up to 8B parameters and 4T training bytes. Our results demonstrate the feasibility of scaling models trained on raw bytes without a fixed vocabulary. Both training and inference efficiency improve due to dynamically selecting long patches when data is predictable, along with qualitative improvements on reasoning and long tail generalization. Overall, for fixed inference costs, BLT shows significantly better scaling than tokenization-based models, by simultaneously growing both patch and model size.*\n+\n+## Usage Tips:\n+\n+- **Dual Model Architecture**: BLT consists of two separate trained models:\n+  - **Patcher (Entropy Model)**: A smaller transformer model that predicts byte-level entropy to determine patch boundaries and segment input.\n+  - **Main Transformer Model**: The primary model that processes the patches through a Local Encoder, Global Transformer, and Local Decoder.\n+\n+- **Dynamic Patching**: The model uses entropy-based dynamic patching where:\n+  - High-entropy regions (complex data) get shorter patches with more computational attention\n+  - Low-entropy regions (predictable data) get longer patches for efficiency\n+  - This allows the model to allocate compute resources where they're most needed\n+\n+- **Local Encoder**: Processes byte sequences with cross-attention to patch embeddings\n+- **Global Transformer**: Processes patch-level representations with full attention across patches\n+- **Local Decoder**: Generates output with cross-attention back to the original byte sequence\n+\n+- **Byte-Level Tokenizer**: Unlike traditional tokenizers that use learned vocabularies, BLT's tokenizer simply converts text to UTF-8 bytes and maps each byte to a token ID. There is no need for a vocabulary.\n+\n+The model can be loaded via:\n+\n+<hfoption id=\"AutoModel\">\n+\n+```python\n+import torch\n+from transformers import AutoTokenizer, AutoModelForCausalLM\n+\n+tokenizer = AutoTokenizer.from_pretrained(\"itazap/blt-1b-hf\")\n+model = AutoModelForCausalLM.from_pretrained(\n+    \"itazap/blt-1b-hf\", \n+    device_map=\"auto\", \n+)\n+\n+inputs = tokenizer(prompt, return_tensors=\"pt\").to(model.device)\n+\n+prompt = \"my name is\"\n+generated_ids = model.generate(\n+    **inputs, max_new_tokens=NUM_TOKENS_TO_GENERATE, do_sample=False, use_cache=False\n+)\n+\n+print(tokenizer.decode(generated_ids[0]))\n+```\n+\n+</hfoption>\n+\n+This model was contributed by [itazap](https://huggingface.co/<itazap>).\n+The original code can be found [here](<https://github.com/facebookresearch/blt>).\n+\n+\n+## BltConfig\n+\n+[[autodoc]] BltConfig\n+\n+[[autodoc]] BltModel\n+    - forward\n+\n+## BltForCausalLM\n+\n+[[autodoc]] BltForCausalLM\n+    - forward"
        },
        {
            "sha": "f0939b089977cac42a340ef611be8f644afaf381",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -48,6 +48,7 @@\n     from .blip import *\n     from .blip_2 import *\n     from .bloom import *\n+    from .blt import *\n     from .bridgetower import *\n     from .bros import *\n     from .byt5 import *"
        },
        {
            "sha": "ec6ce58f7994d35670f3c24da66628e49a68de65",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -65,6 +65,7 @@\n         (\"blip-2\", \"Blip2Config\"),\n         (\"blip_2_qformer\", \"Blip2QFormerConfig\"),\n         (\"bloom\", \"BloomConfig\"),\n+        (\"blt\", \"BltConfig\"),\n         (\"bridgetower\", \"BridgeTowerConfig\"),\n         (\"bros\", \"BrosConfig\"),\n         (\"camembert\", \"CamembertConfig\"),\n@@ -490,6 +491,7 @@\n         (\"blip-2\", \"BLIP-2\"),\n         (\"blip_2_qformer\", \"BLIP-2 QFormer\"),\n         (\"bloom\", \"BLOOM\"),\n+        (\"blt\", \"Blt\"),\n         (\"bort\", \"BORT\"),\n         (\"bridgetower\", \"BridgeTower\"),\n         (\"bros\", \"BROS\"),"
        },
        {
            "sha": "3d0ee2e9fcbd1e0f6d319b530e55aa0ffc4ab7da",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -72,6 +72,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"blip-2\", \"Blip2Model\"),\n         (\"blip_2_qformer\", \"Blip2QFormerModel\"),\n         (\"bloom\", \"BloomModel\"),\n+        (\"blt\", \"BltModel\"),\n         (\"bridgetower\", \"BridgeTowerModel\"),\n         (\"bros\", \"BrosModel\"),\n         (\"camembert\", \"CamembertModel\"),\n@@ -633,6 +634,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"blenderbot\", \"BlenderbotForCausalLM\"),\n         (\"blenderbot-small\", \"BlenderbotSmallForCausalLM\"),\n         (\"bloom\", \"BloomForCausalLM\"),\n+        (\"blt\", \"BltForCausalLM\"),\n         (\"camembert\", \"CamembertForCausalLM\"),\n         (\"code_llama\", \"LlamaForCausalLM\"),\n         (\"codegen\", \"CodeGenForCausalLM\"),"
        },
        {
            "sha": "52726fd6200a6361afa9b66c0b3177ca6c532fce",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -105,6 +105,7 @@\n         (\"blip\", (\"BertTokenizer\", \"BertTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"blip-2\", (\"GPT2Tokenizer\", \"GPT2TokenizerFast\" if is_tokenizers_available() else None)),\n         (\"bloom\", (None, \"BloomTokenizerFast\" if is_tokenizers_available() else None)),\n+        (\"blt\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"bridgetower\", (\"RobertaTokenizer\", \"RobertaTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"bros\", (\"BertTokenizer\", \"BertTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"byt5\", (\"ByT5Tokenizer\", None)),"
        },
        {
            "sha": "703b81ecdd09dda47a97c641f7e440bcb5e81119",
            "filename": "src/transformers/models/blt/__init__.py",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fblt%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fblt%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fblt%2F__init__.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -0,0 +1,28 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_blt import *\n+    from .modeling_blt import *\n+    from .tokenization_blt import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "0bc6718e5bd151e902dc755e21aa07cccbd6e73f",
            "filename": "src/transformers/models/blt/configuration_blt.py",
            "status": "added",
            "additions": 423,
            "deletions": 0,
            "changes": 423,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fblt%2Fconfiguration_blt.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fblt%2Fconfiguration_blt.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fblt%2Fconfiguration_blt.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -0,0 +1,423 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Blt model configuration\"\"\"\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...utils import logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class BltLocalEncoderConfig(PretrainedConfig):\n+    \"\"\"\n+    Configuration class for the Blt Local Encoder component.\n+    \"\"\"\n+\n+    model_type = \"blt_local_encoder\"\n+\n+    def __init__(\n+        self,\n+        vocab_size=260,\n+        cross_attn_all_layers=False,\n+        cross_attn_k=2,\n+        hidden_size_global=2048,\n+        hidden_size=1024,\n+        num_attention_heads=16,\n+        num_key_value_heads=None,\n+        num_hidden_layers=1,\n+        rms_norm_eps=1e-5,\n+        dropout=0.0,\n+        max_position_embeddings=24576,\n+        rope_theta=500000.0,\n+        rope_scaling=None,\n+        hidden_act=\"silu\",\n+        intermediate_size=2816,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.cross_attn_all_layers = cross_attn_all_layers\n+        self.cross_attn_k = cross_attn_k\n+        self.hidden_size_global = hidden_size_global\n+        self.hidden_size = hidden_size\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads or num_attention_heads\n+        self.head_dim = hidden_size // num_attention_heads\n+        self.intermediate_size = intermediate_size or int(8 * hidden_size / 3)\n+        self.num_hidden_layers = num_hidden_layers\n+        self.rms_norm_eps = rms_norm_eps\n+        self.dropout = dropout\n+        self.max_position_embeddings = max_position_embeddings\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+\n+        # Remove tie_word_embeddings from kwargs to avoid duplicate parameter error\n+        kwargs.pop(\"tie_word_embeddings\", None)\n+        super().__init__(**kwargs, tie_word_embeddings=False)\n+\n+\n+class BltLocalDecoderConfig(PretrainedConfig):\n+    \"\"\"\n+    Configuration class for the Blt Local Decoder component.\n+    \"\"\"\n+\n+    model_type = \"blt_local_decoder\"\n+\n+    def __init__(\n+        self,\n+        vocab_size=260,\n+        cross_attn_all_layers=True,\n+        cross_attn_k=2,\n+        hidden_size_global=2048,\n+        hidden_size=1024,\n+        num_attention_heads=16,\n+        num_key_value_heads=None,\n+        num_hidden_layers=9,\n+        rms_norm_eps=1e-5,\n+        dropout=0.0,\n+        max_position_embeddings=24576,\n+        rope_theta=500000.0,\n+        rope_scaling=None,\n+        hidden_act=\"silu\",\n+        intermediate_size=2816,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.cross_attn_all_layers = cross_attn_all_layers\n+        self.cross_attn_k = cross_attn_k\n+        self.hidden_size_global = hidden_size_global\n+        self.hidden_size = hidden_size\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads or num_attention_heads\n+        self.head_dim = hidden_size // num_attention_heads\n+        self.intermediate_size = intermediate_size or int(8 * hidden_size / 3)\n+        self.num_hidden_layers = num_hidden_layers\n+        self.rms_norm_eps = rms_norm_eps\n+        self.dropout = dropout\n+        self.max_position_embeddings = max_position_embeddings\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+\n+        # Remove tie_word_embeddings from kwargs to avoid duplicate parameter error\n+        kwargs.pop(\"tie_word_embeddings\", None)\n+        super().__init__(**kwargs, tie_word_embeddings=False)\n+\n+\n+class BltGlobalTransformerConfig(PretrainedConfig):\n+    \"\"\"\n+    Configuration class for the Blt Global Transformer component.\n+    \"\"\"\n+\n+    model_type = \"blt_global_transformer\"\n+\n+    def __init__(\n+        self,\n+        hidden_size=2048,\n+        num_attention_heads=16,\n+        num_key_value_heads=None,\n+        num_hidden_layers=25,\n+        rms_norm_eps=1e-5,\n+        dropout=0.0,\n+        max_position_embeddings=4096,\n+        rope_theta=500000.0,\n+        rope_scaling=None,\n+        hidden_act=\"silu\",\n+        intermediate_size=5632,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        self.hidden_size = hidden_size\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads or num_attention_heads\n+        self.head_dim = hidden_size // num_attention_heads\n+        self.intermediate_size = intermediate_size or int(8 * hidden_size / 3)\n+        self.num_hidden_layers = num_hidden_layers\n+        self.rms_norm_eps = rms_norm_eps\n+        self.dropout = dropout\n+        self.max_position_embeddings = max_position_embeddings\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+\n+        # Remove tie_word_embeddings from kwargs to avoid duplicate parameter error\n+        kwargs.pop(\"tie_word_embeddings\", None)\n+        super().__init__(**kwargs, tie_word_embeddings=False)\n+\n+\n+class BltPatcherConfig(PretrainedConfig):\n+    r\"\"\"\n+    Configuration class for the Blt Patcher/Entropy model component.\n+\n+    Args:\n+            vocab_size (`int`, *optional*, defaults to 260):\n+                Vocabulary size of the Blt patcher model. Defines the number of different tokens that can be represented by the\n+                `inputs_ids` passed when calling the patcher model.\n+            hidden_size (`int`, *optional*, defaults to 768):\n+                Dimension of the hidden representations.\n+            num_hidden_layers (`int`, *optional*, defaults to 14):\n+                Number of hidden layers in the Transformer decoder.\n+            num_attention_heads (`int`, *optional*, defaults to 12):\n+                Number of attention heads for each attention layer in the Transformer decoder.\n+            num_key_value_heads (`int`, *optional*):\n+                This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+                `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+                `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+                converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+                by meanpooling all the original heads within that group. For more details, check out [this\n+                paper](https://huggingface.co/papers/2305.13245). If it is not specified, will default to\n+                `num_attention_heads`.\n+            max_position_embeddings (`int`, *optional*, defaults to 8192):\n+                The maximum sequence length that this model might ever be used with.\n+            rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+                The epsilon used by the rms normalization layers.\n+            dropout (`float`, *optional*, defaults to 0.0):\n+                The dropout ratio for the attention probabilities.\n+            rope_theta (`float`, *optional*, defaults to 10000.0):\n+                The base period of the RoPE embeddings.\n+            intermediate_size (`int`, *optional*, defaults to 2048):\n+                Dimension of the MLP representations.\n+            rope_scaling (`dict`, *optional*):\n+                Dictionary containing the RoPE scaling configuration.\n+            initializer_range (`float`, *optional*, defaults to 0.02):\n+                The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+    \"\"\"\n+\n+    model_type = \"blt_patcher\"\n+\n+    def __init__(\n+        self,\n+        vocab_size=260,\n+        hidden_size=768,\n+        num_hidden_layers=14,\n+        num_attention_heads=12,\n+        num_key_value_heads=None,\n+        max_position_embeddings=8192,\n+        rms_norm_eps=1e-5,\n+        dropout=0.0,\n+        rope_theta=10000.0,\n+        intermediate_size=2048,\n+        rope_scaling=None,\n+        initializer_range=0.02,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.hidden_size = hidden_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.head_dim = hidden_size // num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads if num_key_value_heads is not None else num_attention_heads\n+        self.max_position_embeddings = max_position_embeddings\n+        self.rms_norm_eps = rms_norm_eps\n+        self.dropout = dropout\n+        self.rope_theta = rope_theta\n+        self.hidden_act = \"silu\"  # Blt uses silu activation\n+        self.intermediate_size = intermediate_size or int(8 * self.hidden_size / 3)\n+        self.rope_scaling = rope_scaling\n+        self.initializer_range = initializer_range\n+\n+        # Remove tie_word_embeddings from kwargs to avoid duplicate parameter error\n+        kwargs.pop(\"tie_word_embeddings\", None)\n+        super().__init__(**kwargs, tie_word_embeddings=False)\n+\n+\n+class BltConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`BltModel`]. It is used to instantiate a\n+    Blt model according to the specified arguments, defining the model architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+            vocab_size (`int`, *optional*, defaults to 260):\n+                Vocabulary size of the Blt model. Defines the number of different tokens that can be represented by the\n+                `inputs_ids` passed when calling [`BltModel`].\n+            max_position_embeddings (`int`, *optional*, defaults to 4096):\n+                The maximum sequence length that this model might ever be used with.\n+            patch_in_forward (`bool`, *optional*, defaults to `True`):\n+                Whether to perform patching during the forward pass.\n+            patch_size (`int`, *optional*, defaults to 4):\n+                Size of the patches used in the patching mechanism.\n+            patching_mode (`str`, *optional*, defaults to `\"entropy\"`):\n+                The mode used for patching, such as entropy-based patching.\n+            patching_threshold (`float`, *optional*, defaults to 1.34):\n+                Threshold value used for determining when to apply patches.\n+            patching_batch_size (`int`, *optional*, defaults to 1):\n+                Batch size used during the patching process.\n+            max_patch_length (`int`, *optional*):\n+                Maximum length of patches that can be generated.\n+            cross_attn_k (`int`, *optional*, defaults to 2):\n+                Number of cross-attention heads used in the model.\n+            encoder_hash_byte_group_size (`list`, *optional*):\n+                List of byte group sizes used in the encoder hash function.\n+            encoder_hash_byte_group_vocab (`int`, *optional*, defaults to 500002):\n+                Vocabulary size for the encoder hash byte groups.\n+            encoder_hash_byte_group_nb_functions (`int`, *optional*, defaults to 1):\n+                Number of hash functions used in the encoder byte grouping.\n+            patcher_config (`BltPatcherConfig`, *optional*):\n+                Configuration for the patcher component of the model.\n+            encoder_config (`BltLocalEncoderConfig`, *optional*):\n+                Configuration for the local encoder component of the model.\n+            decoder_config (`BltLocalDecoderConfig`, *optional*):\n+                Configuration for the local decoder component of the model.\n+            global_config (`BltGlobalTransformerConfig`, *optional*):\n+                Configuration for the global transformer component of the model.\n+            tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+                Whether to tie weight embeddings.\n+            initializer_range (`float`, *optional*, defaults to 0.02):\n+                The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+            rope_theta (`float`, *optional*, defaults to 500000.0):\n+                The base period of the RoPE embeddings.\n+            rope_scaling (`dict`, *optional*):\n+                Dictionary containing the RoPE scaling configuration.\n+\n+    ```python\n+    >>> from transformers import BltModel, BltConfig\n+\n+    >>> # Initializing a Blt configuration\n+    >>> configuration = BltConfig()\n+\n+    >>> # Initializing a model from the configuration\n+    >>> model = BltModel(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\n+\n+    Checkpoint: [facebook/blt](https://huggingface.co/facebook/blt)\n+    \"\"\"\n+\n+    model_type = \"blt\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    sub_configs = {\n+        \"patcher_config\": BltPatcherConfig,\n+        \"encoder_config\": BltLocalEncoderConfig,\n+        \"decoder_config\": BltLocalDecoderConfig,\n+        \"global_config\": BltGlobalTransformerConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=260,\n+        max_position_embeddings=4096,\n+        patch_in_forward=True,\n+        patch_size=4,\n+        patching_mode=\"entropy\",\n+        patching_threshold=1.335442066192627,\n+        patching_batch_size=1,\n+        max_patch_length=None,\n+        cross_attn_k=2,\n+        encoder_hash_byte_group_size=None,\n+        encoder_hash_byte_group_vocab=500002,\n+        encoder_hash_byte_group_nb_functions=1,\n+        patcher_config=None,\n+        encoder_config=None,\n+        decoder_config=None,\n+        global_config=None,\n+        tie_word_embeddings=False,\n+        initializer_range=0.02,\n+        rope_theta=500000.0,\n+        rope_scaling=None,\n+        **kwargs,\n+    ):\n+        # Basic model configuration\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.initializer_range = initializer_range\n+        self.rope_theta = rope_theta\n+        self.rope_scaling = rope_scaling\n+\n+        # Patching configuration\n+        self.patch_in_forward = patch_in_forward\n+        self.patch_size = patch_size\n+        self.patching_mode = patching_mode\n+        self.patching_threshold = patching_threshold\n+        self.patching_batch_size = patching_batch_size\n+        self.max_patch_length = max_patch_length\n+        self.patching_device = kwargs.get(\"patching_device\", \"cuda\")\n+        self.realtime_patching = kwargs.get(\"realtime_patching\", True)\n+        self.patching_threshold_add = kwargs.get(\"patching_threshold_add\")\n+        self.monotonicity = kwargs.get(\"monotonicity\", False)\n+\n+        # Cross attention configurations\n+        self.cross_attn_k = cross_attn_k\n+\n+        # Encoder configurations\n+        self.encoder_hash_byte_group_size = encoder_hash_byte_group_size or [3, 4, 5, 6, 7, 8]\n+        self.encoder_hash_byte_group_vocab = encoder_hash_byte_group_vocab\n+        self.encoder_hash_byte_group_nb_functions = encoder_hash_byte_group_nb_functions\n+\n+        # Initialize component configurations\n+        if patcher_config is None:\n+            self.patcher_config = BltPatcherConfig(initializer_range=initializer_range)\n+            logger.info(\"patcher_config is None, using default Blt patcher config\")\n+        elif isinstance(patcher_config, dict):\n+            patcher_config.setdefault(\"initializer_range\", initializer_range)\n+            self.patcher_config = BltPatcherConfig(**patcher_config)\n+        elif isinstance(patcher_config, BltPatcherConfig):\n+            self.patcher_config = patcher_config\n+\n+        if encoder_config is None:\n+            self.encoder_config = BltLocalEncoderConfig(initializer_range=initializer_range)\n+            logger.info(\"encoder_config is None, using default Blt encoder config\")\n+        elif isinstance(encoder_config, dict):\n+            encoder_config.setdefault(\"initializer_range\", initializer_range)\n+            self.encoder_config = BltLocalEncoderConfig(**encoder_config)\n+        elif isinstance(encoder_config, BltLocalEncoderConfig):\n+            self.encoder_config = encoder_config\n+\n+        if decoder_config is None:\n+            self.decoder_config = BltLocalDecoderConfig(initializer_range=initializer_range)\n+            logger.info(\"decoder_config is None, using default Blt decoder config\")\n+        elif isinstance(decoder_config, dict):\n+            decoder_config.setdefault(\"initializer_range\", initializer_range)\n+            self.decoder_config = BltLocalDecoderConfig(**decoder_config)\n+        elif isinstance(decoder_config, BltLocalDecoderConfig):\n+            self.decoder_config = decoder_config\n+\n+        if global_config is None:\n+            self.global_config = BltGlobalTransformerConfig(initializer_range=initializer_range)\n+            logger.info(\"global_config is None, using default Blt global config\")\n+        elif isinstance(global_config, dict):\n+            global_config.setdefault(\"initializer_range\", initializer_range)\n+            self.global_config = BltGlobalTransformerConfig(**global_config)\n+        elif isinstance(global_config, BltGlobalTransformerConfig):\n+            self.global_config = global_config\n+\n+        # Determine if token embedding projection is needed based on dimension mismatch (7b)\n+        encoder_cross_output_size = self.encoder_config.hidden_size * self.cross_attn_k\n+        self.global_config.encoder_cross_output_size = (\n+            encoder_cross_output_size if encoder_cross_output_size != self.global_config.hidden_size else None\n+        )\n+\n+        # Remove tie_word_embeddings from kwargs to avoid duplicate parameter error\n+        kwargs.pop(\"tie_word_embeddings\", None)\n+        super().__init__(tie_word_embeddings=tie_word_embeddings, **kwargs)\n+\n+\n+__all__ = [\n+    \"BltConfig\",\n+    \"BltPatcherConfig\",\n+    \"BltLocalEncoderConfig\",\n+    \"BltLocalDecoderConfig\",\n+    \"BltGlobalTransformerConfig\",\n+]"
        },
        {
            "sha": "f9decff3a1f8ba332b062fcd8b34a4123074c224",
            "filename": "src/transformers/models/blt/convert_blt_weights_to_hf.py",
            "status": "added",
            "additions": 487,
            "deletions": 0,
            "changes": 487,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fblt%2Fconvert_blt_weights_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fblt%2Fconvert_blt_weights_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fblt%2Fconvert_blt_weights_to_hf.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -0,0 +1,487 @@\n+import argparse\n+import json\n+import logging\n+import os\n+from typing import Any, Optional\n+\n+import torch\n+from huggingface_hub import hf_hub_download, upload_folder\n+from safetensors.torch import load_file, save_file\n+from tokenizers import Tokenizer, decoders, pre_tokenizers, processors\n+from tokenizers.models import BPE\n+\n+from transformers import PreTrainedTokenizerFast\n+from transformers.convert_slow_tokenizer import bytes_to_unicode\n+from transformers.utils import logging as transformers_logging\n+\n+\n+logger = transformers_logging.get_logger(__name__)\n+transformers_logging.set_verbosity_info()\n+\n+\n+def merge_configurations(config_path: str, entropy_params_path: str) -> dict[str, Any]:\n+    logger.info(\"Merging configurations\")\n+\n+    with open(config_path, \"r\") as f:\n+        main_config = json.load(f)\n+\n+    with open(entropy_params_path, \"r\") as f:\n+        entropy_data = json.load(f)\n+\n+    entropy_model_params = entropy_data.get(\"entropy_model\", {})\n+    patcher_args = entropy_data.get(\"data\", {}).get(\"patcher_args\", {})\n+\n+    unified_config = main_config.copy()[\"args\"]\n+\n+    for key in [\"vocab_size\", \"dim\", \"n_layers\", \"n_heads\", \"max_seqlen\"]:\n+        if key in unified_config and not isinstance(unified_config[key], int):\n+            unified_config[key] = int(unified_config[key])\n+\n+    patch_size = patcher_args.get(\"patch_size\", 8)\n+    if isinstance(patch_size, float):\n+        patch_size = int(patch_size)\n+\n+    # Create patcher config\n+    patcher_hidden_size = int(entropy_model_params.get(\"dim\", 512))\n+    patcher_multiple_of = int(entropy_model_params.get(\"multiple_of\", 256))\n+    patcher_intermediate_size = patcher_multiple_of * (\n+        (int(8 * patcher_hidden_size / 3) + patcher_multiple_of - 1) // patcher_multiple_of\n+    )\n+\n+    patcher_config = {\n+        \"vocab_size\": int(entropy_model_params.get(\"vocab_size\", 256)),\n+        \"hidden_size\": patcher_hidden_size,\n+        \"num_hidden_layers\": int(entropy_model_params.get(\"n_layers\", 8)),\n+        \"num_attention_heads\": int(entropy_model_params.get(\"n_heads\", 8)),\n+        \"num_key_value_heads\": int(entropy_model_params.get(\"n_kv_heads\"))\n+        if entropy_model_params.get(\"n_kv_heads\") is not None\n+        else None,\n+        \"max_position_embeddings\": int(entropy_model_params.get(\"max_seqlen\", 1024)),\n+        \"norm_eps\": entropy_model_params.get(\"norm_eps\", 1e-5),\n+        \"dropout\": entropy_model_params.get(\"dropout\", 0.0),\n+        \"rope_theta\": entropy_model_params.get(\"rope_theta\", 10000.0),\n+        \"attn_impl\": entropy_model_params.get(\"attn_impl\", \"sdpa\"),\n+        \"attn_bias_type\": entropy_model_params.get(\"attn_bias_type\", \"causal\"),\n+        \"intermediate_size\": patcher_intermediate_size,\n+    }\n+\n+    # Create encoder config\n+    encoder_hidden_size = unified_config.get(\"dim_local_encoder\", 1024)\n+    encoder_multiple_of = unified_config.get(\"multiple_of\", 256)\n+    encoder_intermediate_size = encoder_multiple_of * (\n+        (int(8 * encoder_hidden_size / 3) + encoder_multiple_of - 1) // encoder_multiple_of\n+    )\n+\n+    encoder_config = {\n+        \"vocab_size\": unified_config.get(\"vocab_size\", 256),\n+        \"cross_attn_all_layers\": unified_config.get(\"cross_attn_all_layers_encoder\", False),\n+        \"cross_attn_k\": unified_config.get(\"cross_attn_k\", 2),\n+        \"hidden_size_global\": unified_config.get(\"dim_global\", 2048),\n+        \"pm_size\": unified_config.get(\"pm_size\", 0),\n+        \"hidden_size\": encoder_hidden_size,\n+        \"num_attention_heads\": unified_config.get(\"n_heads_local_encoder\", 16),\n+        \"num_key_value_heads\": unified_config.get(\"n_kv_heads\"),\n+        \"num_hidden_layers\": unified_config.get(\"n_layers_local_encoder\", 1),\n+        \"norm_eps\": unified_config.get(\"norm_eps\", 1e-5),\n+        \"dropout\": unified_config.get(\"dropout\", 0.0),\n+        \"max_position_embeddings\": unified_config.get(\"max_encoder_seq_length\")\n+        or unified_config.get(\"max_seqlen\", 1024),\n+        \"rope_theta\": unified_config.get(\"rope_theta\", 10000.0),\n+        \"rope_scaling\": {\"rope_type\": \"default\"},\n+        \"hidden_act\": unified_config.get(\"hidden_act\", \"silu\"),\n+        \"_attn_implementation\": unified_config.get(\"_attn_implementation\", \"sdpa\"),\n+        \"intermediate_size\": encoder_intermediate_size,\n+    }\n+\n+    # Create decoder config\n+    decoder_hidden_size = unified_config.get(\"dim_local_decoder\", 1024)\n+    decoder_multiple_of = unified_config.get(\"multiple_of\", 256)\n+    decoder_intermediate_size = decoder_multiple_of * (\n+        (int(8 * decoder_hidden_size / 3) + decoder_multiple_of - 1) // decoder_multiple_of\n+    )\n+\n+    decoder_config = {\n+        \"vocab_size\": unified_config.get(\"vocab_size\", 256),\n+        \"cross_attn_all_layers\": unified_config.get(\"cross_attn_all_layers_decoder\", False),\n+        \"cross_attn_k\": unified_config.get(\"cross_attn_k\", 2),\n+        \"hidden_size_global\": unified_config.get(\"dim_global\", 2048),\n+        \"hidden_size\": decoder_hidden_size,\n+        \"num_attention_heads\": unified_config.get(\"n_heads_local_decoder\", 16),\n+        \"num_key_value_heads\": unified_config.get(\"n_kv_heads\"),\n+        \"num_hidden_layers\": unified_config.get(\"n_layers_local_decoder\", 9),\n+        \"norm_eps\": unified_config.get(\"norm_eps\", 1e-5),\n+        \"dropout\": unified_config.get(\"dropout\", 0.0),\n+        \"max_position_embeddings\": unified_config.get(\"max_encoder_seq_length\")\n+        or unified_config.get(\"max_seqlen\", 1024),\n+        \"rope_theta\": unified_config.get(\"rope_theta\", 10000.0),\n+        \"rope_scaling\": {\"rope_type\": \"default\"},\n+        \"hidden_act\": unified_config.get(\"hidden_act\", \"silu\"),\n+        \"_attn_implementation\": unified_config.get(\"_attn_implementation\", \"sdpa\"),\n+        \"intermediate_size\": decoder_intermediate_size,\n+    }\n+\n+    # Create global transformer config\n+    global_hidden_size = unified_config.get(\"dim_global\", 2048)\n+    global_multiple_of = unified_config.get(\"multiple_of\", 256)\n+    global_intermediate_size = global_multiple_of * (\n+        (int(8 * global_hidden_size / 3) + global_multiple_of - 1) // global_multiple_of\n+    )\n+\n+    global_config = {\n+        \"hidden_size\": global_hidden_size,\n+        \"num_attention_heads\": unified_config.get(\"n_heads_global\", 16),\n+        \"num_key_value_heads\": unified_config.get(\"n_kv_heads_global\"),\n+        \"num_hidden_layers\": unified_config.get(\"n_layers_global\", 25),\n+        \"norm_eps\": unified_config.get(\"norm_eps\", 1e-5),\n+        \"dropout\": unified_config.get(\"dropout\", 0.0),\n+        \"max_position_embeddings\": unified_config.get(\"max_seqlen\", 1024),\n+        \"rope_theta\": unified_config.get(\"rope_theta\", 10000.0),\n+        \"rope_scaling\": {\"rope_type\": \"default\"},\n+        \"hidden_act\": unified_config.get(\"hidden_act\", \"silu\"),\n+        \"_attn_implementation\": unified_config.get(\"_attn_implementation\", \"sdpa\"),\n+        \"intermediate_size\": global_intermediate_size,\n+    }\n+\n+    # Create main config with sub-configs\n+    main_config_dict = {\n+        \"model_type\": \"blt\",\n+        \"vocab_size\": unified_config.get(\"vocab_size\", 256),\n+        \"max_position_embeddings\": unified_config.get(\"max_seqlen\", 1024),\n+        \"patch_in_forward\": True,\n+        \"realtime_patching\": True,\n+        \"patching_mode\": \"entropy\",\n+        \"patch_size\": patch_size,\n+        \"patching_threshold\": patcher_args.get(\"threshold\", 0.5),\n+        \"patching_threshold_add\": patcher_args.get(\"threshold_add\", 0.0),\n+        \"max_patch_length\": patcher_args.get(\"max_patch_length\"),\n+        \"patching_batch_size\": patcher_args.get(\"patching_batch_size\", 1),\n+        \"patching_device\": patcher_args.get(\"patching_device\", \"cuda\"),\n+        \"monotonicity\": patcher_args.get(\"monotonicity\", False),\n+        \"cross_attn_k\": unified_config.get(\"cross_attn_k\", 2),\n+        \"encoder_hash_byte_group_size\": unified_config.get(\"encoder_hash_byte_group_size\"),\n+        \"encoder_hash_byte_group_vocab\": unified_config.get(\"encoder_hash_byte_group_vocab\", 30000),\n+        \"encoder_hash_byte_group_nb_functions\": unified_config.get(\"encoder_hash_byte_group_nb_functions\", 3),\n+        \"pm_size\": unified_config.get(\"pm_size\", 0),\n+        \"patcher_config\": patcher_config,\n+        \"encoder_config\": encoder_config,\n+        \"decoder_config\": decoder_config,\n+        \"global_config\": global_config,\n+    }\n+\n+    main_config_dict[\"tie_word_embeddings\"] = False\n+\n+    logger.info(f\"Merged configuration with {len(main_config_dict)} parameters\")\n+    return main_config_dict\n+\n+\n+def apply_weight_mapping(state_dict: dict[str, torch.Tensor]) -> dict[str, torch.Tensor]:\n+    component_mappings = {\n+        \".attention.\": \".self_attn.\",\n+        \".feed_forward.\": \".mlp.\",\n+        \".attention_norm.\": \".input_layernorm.\",\n+        \".ffn_norm.\": \".post_attention_layernorm.\",\n+        \".tok_embeddings.\": \".embed_tokens.\",\n+        \".cross_attn_norm_q.\": \".q_norm.\",\n+        \".cross_attn_norm_kv.\": \".k_norm.\",\n+        \".w1.\": \".gate_proj.\",\n+        \".w2.\": \".down_proj.\",\n+        \".w3.\": \".up_proj.\",\n+        \".wq.\": \".q_proj.\",\n+        \".wk.\": \".k_proj.\",\n+        \".wv.\": \".v_proj.\",\n+        \".wo.\": \".o_proj.\",\n+        \".output.\": \".lm_head.\",\n+    }\n+\n+    new_state_dict = {}\n+\n+    for old_key, tensor in state_dict.items():\n+        new_key = old_key\n+\n+        for old_pattern, new_pattern in component_mappings.items():\n+            if old_pattern in new_key:\n+                new_key = new_key.replace(old_pattern, new_pattern)\n+\n+        new_state_dict[new_key] = tensor\n+\n+    return new_state_dict\n+\n+\n+def convert_hash_embeddings_to_fused(\n+    unified_weights: dict[str, torch.Tensor], config: dict[str, Any]\n+) -> dict[str, torch.Tensor]:\n+    \"\"\"Convert ModuleList hash embeddings to nn.embedding format\"\"\"\n+    original_keys_format = [\n+        key\n+        for key in unified_weights.keys()\n+        if \"encoder_hash_tok_embedding.\" in key and \".weight\" in key and key.split(\".\")[-2].isdigit()\n+    ]\n+\n+    num_embeddings = config.get(\"encoder_hash_byte_group_nb_functions\", 1) * len(\n+        config.get(\"encoder_hash_byte_group_size\", [3, 4, 5, 6, 7, 8])\n+    )\n+    vocab_size = config.get(\"encoder_hash_byte_group_vocab\", 500002)\n+    hidden_size = config.get(\"encoder_config\", {}).get(\"hidden_size\", 1024)\n+\n+    fused_weight = torch.zeros(vocab_size * num_embeddings, hidden_size)\n+\n+    sorted_keys = sorted(original_keys_format, key=lambda k: int(k.split(\".\")[-2]))\n+\n+    for i, old_key in enumerate(sorted_keys):\n+        start_idx = i * vocab_size\n+        end_idx = (i + 1) * vocab_size\n+        fused_weight[start_idx:end_idx] = unified_weights[old_key]\n+        logger.info(f\"Copied {old_key} to indices {start_idx}:{end_idx}\")\n+        del unified_weights[old_key]\n+\n+    fused_key = \"model.encoder_hash_tok_embedding.weight\"\n+    unified_weights[fused_key] = fused_weight\n+\n+    return unified_weights\n+\n+\n+def merge_weights(weights_path: str, entropy_weights_path: str) -> dict[str, torch.Tensor]:\n+    main_weights = load_file(weights_path)\n+\n+    entropy_weights = torch.load(entropy_weights_path, map_location=\"cpu\", weights_only=True)\n+\n+    if \"model\" in entropy_weights:\n+        entropy_weights = entropy_weights[\"model\"]\n+    elif \"state_dict\" in entropy_weights:\n+        entropy_weights = entropy_weights[\"state_dict\"]\n+\n+    unified_weights = main_weights.copy()\n+\n+    for key, tensor in entropy_weights.items():\n+        patcher_key = f\"patcher.{key}\"\n+        unified_weights[patcher_key] = tensor\n+\n+    unified_weights = apply_weight_mapping(unified_weights)\n+\n+    decoder_lm_head_key = \"local_decoder.lm_head.weight\"\n+    top_lm_head_key = \"lm_head.weight\"\n+    unified_weights[top_lm_head_key] = unified_weights[decoder_lm_head_key]\n+    del unified_weights[decoder_lm_head_key]\n+\n+    prefixed_weights = {}\n+    for key, tensor in unified_weights.items():\n+        if key == top_lm_head_key:\n+            prefixed_weights[key] = tensor\n+        elif not key.startswith(\"model.\"):\n+            prefixed_weights[f\"model.{key}\"] = tensor\n+        else:\n+            prefixed_weights[key] = tensor\n+\n+    unified_weights = prefixed_weights\n+\n+    return unified_weights\n+\n+\n+def create_tokenizer_config(output_dir: str, config: dict[str, Any]):\n+    tokenizer_config = {\n+        \"tokenizer_class\": \"PreTrainedTokenizerFast\",\n+        \"vocab_size\": config.get(\"vocab_size\", 256),\n+        \"model_max_length\": config.get(\"max_seqlen\", 1024),\n+        \"model_input_names\": [\"input_ids\", \"attention_mask\"],\n+        \"add_bos_token\": True,\n+        \"add_eos_token\": True,\n+        \"bos_token\": \"<s>\",\n+        \"eos_token\": \"</s>\",\n+        \"pad_token\": \"<pad>\",\n+        \"unk_token\": \"<unk>\",\n+    }\n+\n+    tokenizer_path = os.path.join(output_dir, \"tokenizer_config.json\")\n+    with open(tokenizer_path, \"w\") as f:\n+        json.dump(tokenizer_config, f, indent=2)\n+\n+\n+def create_tokenizer_json(output_dir: str, config: dict[str, Any]):\n+    byte_encoder = bytes_to_unicode()\n+\n+    vocab: dict[str, int] = {}\n+    vocab[\"<boe>\"] = 0\n+    vocab[\"<s>\"] = 1\n+    vocab[\"</s>\"] = 2\n+    vocab[\"<pad>\"] = 3\n+\n+    offset = 4\n+    for byte_val, unicode_char in byte_encoder.items():\n+        vocab[unicode_char] = byte_val + offset\n+\n+    backend = Tokenizer(\n+        BPE(vocab=vocab, merges=[], continuing_subword_prefix=\"\", end_of_word_suffix=\"\", fuse_unk=False)\n+    )\n+    backend.pre_tokenizer = pre_tokenizers.ByteLevel(add_prefix_space=False)\n+    backend.decoder = decoders.ByteLevel()\n+\n+    bos = config.get(\"bos_token\", \"<s>\")\n+    backend.post_processor = processors.TemplateProcessing(\n+        single=f\"{bos}:0 $A:0\",\n+        pair=f\"{bos}:0 $A:0 $B:1\",\n+        special_tokens=[(bos, 1)],\n+    )\n+\n+    tokenizer = PreTrainedTokenizerFast(\n+        tokenizer_object=backend,\n+        bos_token=config.get(\"bos_token\", \"<s>\"),\n+        eos_token=config.get(\"eos_token\", \"</s>\"),\n+        pad_token=config.get(\"pad_token\", \"<pad>\"),\n+        unk_token=config.get(\"unk_token\", \"<unk>\"),\n+    )\n+\n+    tokenizer.add_bos_token = bool(config.get(\"add_bos_token\", True))\n+    tokenizer.add_eos_token = bool(config.get(\"add_eos_token\", True))\n+\n+    tokenizer.save_pretrained(output_dir)\n+    logger.info(f\"Saved tokenizer.json to {os.path.join(output_dir, 'tokenizer.json')}\")\n+\n+\n+def push_to_hub(\n+    local_dir: str,\n+    repo_id: str,\n+    commit_message: str = \"Upload converted Blt model\",\n+    private: bool = False,\n+    token: Optional[str] = None,\n+) -> None:\n+    try:\n+        upload_folder(\n+            folder_path=local_dir,\n+            repo_id=repo_id,\n+            commit_message=commit_message,\n+            repo_type=\"model\",\n+            token=token,\n+        )\n+        logger.info(f\"Successfully pushed model to {repo_id}\")\n+\n+    except Exception as e:\n+        logger.error(f\"Failed to push model to Hub: {e}\")\n+        raise\n+\n+\n+def convert_hf_blt_to_unified(\n+    model_id: str,\n+    output_dir: str,\n+    config_name: str = \"config.json\",\n+    weights_name: str = \"model.bin\",\n+    cache_dir: Optional[str] = None,\n+    push_to_hub_repo: Optional[str] = None,\n+    hub_private: bool = False,\n+    hub_token: Optional[str] = None,\n+) -> None:\n+    # Download model files\n+    config_path = hf_hub_download(repo_id=model_id, filename=\"config.json\", cache_dir=cache_dir)\n+    weights_path = hf_hub_download(repo_id=model_id, filename=\"model.safetensors\", cache_dir=cache_dir)\n+    entropy_params_path = hf_hub_download(repo_id=model_id, filename=\"entropy_model/params.json\", cache_dir=cache_dir)\n+    entropy_weights_path = hf_hub_download(\n+        repo_id=model_id, filename=\"entropy_model/consolidated.pth\", cache_dir=cache_dir\n+    )\n+\n+    unified_config = merge_configurations(config_path, entropy_params_path)\n+    unified_weights = merge_weights(weights_path, entropy_weights_path)\n+\n+    unified_weights = convert_hash_embeddings_to_fused(unified_weights, unified_config)\n+\n+    os.makedirs(output_dir, exist_ok=True)\n+\n+    config_path = os.path.join(output_dir, config_name)\n+    with open(config_path, \"w\") as f:\n+        json.dump(unified_config, f, indent=2)\n+\n+    if weights_name.endswith(\".bin\"):\n+        weights_name = weights_name.replace(\".bin\", \".safetensors\")\n+\n+    weights_path = os.path.join(output_dir, weights_name)\n+    save_file(unified_weights, weights_path)\n+\n+    create_tokenizer_json(output_dir=output_dir, config=unified_config)\n+\n+    create_tokenizer_config(output_dir, unified_config)\n+\n+    logger.info(f\"Conversion completed, model saved to: {output_dir}\")\n+\n+    if push_to_hub_repo:\n+        push_to_hub(\n+            local_dir=output_dir,\n+            repo_id=push_to_hub_repo,\n+            commit_message=\"Upload Blt model converted\",\n+            private=hub_private,\n+            token=hub_token,\n+        )\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser(\n+        description=\"Convert Blt models from HuggingFace Hub format to unified format\",\n+        formatter_class=argparse.RawDescriptionHelpFormatter,\n+    )\n+\n+    parser.add_argument(\n+        \"--model_id\",\n+        type=str,\n+        default=\"facebook/blt-7b\",\n+    )\n+    parser.add_argument(\n+        \"--output_dir\",\n+        type=str,\n+        default=\"./blt_converted\",\n+    )\n+    parser.add_argument(\n+        \"--config_name\",\n+        type=str,\n+        default=\"config.json\",\n+    )\n+    parser.add_argument(\n+        \"--weights_name\",\n+        type=str,\n+        default=\"model.bin\",\n+    )\n+    parser.add_argument(\n+        \"--cache_dir\",\n+        type=str,\n+        default=None,\n+    )\n+    parser.add_argument(\n+        \"--debug\",\n+        action=\"store_true\",\n+        default=True,\n+    )\n+    parser.add_argument(\n+        \"--push_to_hub\",\n+        type=str,\n+        default=None,\n+    )\n+    parser.add_argument(\n+        \"--hub_private\",\n+        action=\"store_true\",\n+        default=False,\n+    )\n+    parser.add_argument(\n+        \"--hub_token\",\n+        type=str,\n+        default=\"hf_token\",\n+    )\n+\n+    args = parser.parse_args()\n+\n+    transformers_logging.set_verbosity_debug()\n+    logging.basicConfig(level=logging.DEBUG)\n+\n+    try:\n+        convert_hf_blt_to_unified(\n+            model_id=args.model_id,\n+            output_dir=args.output_dir,\n+            config_name=args.config_name,\n+            weights_name=args.weights_name,\n+            cache_dir=args.cache_dir,\n+            push_to_hub_repo=False,  # args.push_to_hub,\n+            hub_private=args.hub_private,\n+            hub_token=args.hub_token,\n+        )\n+    except Exception as e:\n+        logger.error(f\"Conversion failed: {e}\")\n+        raise\n+\n+\n+if __name__ == \"__main__\":\n+    main()"
        },
        {
            "sha": "e1639d4e3e2b3b74ace1fd1002d6d4d47396ec6d",
            "filename": "src/transformers/models/blt/modeling_blt.py",
            "status": "added",
            "additions": 1306,
            "deletions": 0,
            "changes": 1306,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fblt%2Fmodeling_blt.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fblt%2Fmodeling_blt.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fblt%2Fmodeling_blt.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -0,0 +1,1306 @@\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+#           This file was automatically generated from src/transformers/models/blt/modular_blt.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_blt.py file directly. One of our CI enforces this.\n+#                🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨🚨\n+# coding=utf-8\n+# Copyright 2025 HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import Callable, Optional, Union\n+\n+import torch\n+import torch.distributions\n+import torch.nn as nn\n+import torch.nn.functional as F\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...masking_utils import create_causal_mask\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import BaseModelOutputWithPast, CausalLMOutputWithPast\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS, dynamic_rope_update\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring, can_return_tuple\n+from ...utils.deprecation import deprecate_kwarg\n+from ...utils.generic import OutputRecorder, check_model_inputs\n+from .configuration_blt import (\n+    BltConfig,\n+    BltGlobalTransformerConfig,\n+    BltLocalDecoderConfig,\n+    BltLocalEncoderConfig,\n+    BltPatcherConfig,\n+)\n+\n+\n+class BltMLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=False)\n+        # Ignore copy\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, x):\n+        down_proj = self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x))\n+        return down_proj\n+\n+\n+class BltRMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        BltRMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class BltRotaryEmbedding(nn.Module):\n+    inv_freq: torch.Tensor  # fix linting for `register_buffer`\n+\n+    def __init__(self, config: BltConfig, device=None):\n+        super().__init__()\n+        # BC: \"rope_type\" was originally \"type\"\n+        if hasattr(config, \"rope_scaling\") and isinstance(config.rope_scaling, dict):\n+            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n+        else:\n+            self.rope_type = \"default\"\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = self.inv_freq\n+\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1)\n+        position_ids_expanded = position_ids[:, None, :].float()\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(1, 2)\n+            emb = torch.repeat_interleave(freqs, 2, dim=-1)  # diff from Llama: we interleave() instead of cat()\n+            cos = emb.cos() * self.attention_scaling\n+            sin = emb.sin() * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+# Modified from transformers.models.llama.modeling_llama.LlamaDecoderLayer\n+class BltTransformerLayer(GradientCheckpointingLayer):\n+    def __init__(self, config, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        self.self_attn = BltSelfAttention(config=config, layer_idx=layer_idx)\n+        self.mlp = BltMLP(config)\n+        self.input_layernorm = BltRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = BltRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+        self.layer_idx = layer_idx\n+\n+    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cross_attention_states: Optional[torch.Tensor] = None,\n+        cross_attention_mask: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        full_text_row_masked_out_mask: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[tuple[torch.Tensor, torch.Tensor]] = None,  # necessary, but kept here for BC\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> tuple[torch.FloatTensor, Optional[tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.FloatTensor`): input to the layer of shape `(batch, seq_len, embed_dim)`\n+            attention_mask (`torch.FloatTensor`, *optional*):\n+                attention mask of size `(batch_size, sequence_length)` if flash attention is used or `(batch_size, 1,\n+                query_sequence_length, key_sequence_length)` if default attention is used.\n+\n+            use_cache (`bool`, *optional*):\n+                If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding\n+                (see `past_key_values`).\n+            past_key_values (`Cache`, *optional*): cached past key and value projection states\n+            cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n+                Indices depicting the position of the input sequence tokens in the sequence\n+            position_embeddings (`tuple[torch.FloatTensor, torch.FloatTensor]`, *optional*):\n+                Tuple containing the cosine and sine positional embeddings of shape `(batch_size, seq_len, head_dim)`,\n+                with `head_dim` being the embedding dimension of each attention head.\n+            kwargs (`dict`, *optional*):\n+                Arbitrary kwargs to be ignored, used for FSDP and other methods that injects code\n+                into the model\n+        \"\"\"\n+        residual = hidden_states\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # Self Attention\n+        hidden_states, self_attn_weights = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            position_embeddings=position_embeddings,\n+            **kwargs,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        return hidden_states\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs: Unpack[TransformersKwargs],\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+def rotate_half(x):\n+    # Split and rotate. Note that this function is different from e.g. Llama.\n+    x1 = x[..., ::2]\n+    x2 = x[..., 1::2]\n+    rot_x = torch.stack([-x2, x1], dim=-1).flatten(-2)\n+    return rot_x\n+\n+\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`, *optional*):\n+            Deprecated and unused.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    return q_embed, k_embed\n+\n+\n+class BltSelfAttention(nn.Module):\n+    def __init__(self, config: BltConfig, layer_idx: int):\n+        super().__init__()\n+        self.config = config\n+        self.num_heads = config.num_attention_heads\n+        self.dropout = config.dropout\n+        self.hidden_size = config.hidden_size\n+        self.num_key_value_heads = config.num_key_value_heads\n+        self.head_dim = config.hidden_size // self.num_heads\n+        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.rope_theta = config.rope_theta\n+        self.layer_idx = layer_idx\n+\n+        self.q_proj = nn.Linear(self.hidden_size, self.num_heads * self.head_dim, bias=False)\n+        self.k_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=False)\n+        self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=False)\n+        self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=False)\n+        self.is_causal = True\n+\n+    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: torch.Tensor,\n+        position_embeddings: torch.Tensor,\n+        use_cache: bool = False,\n+        past_key_values=None,\n+        cache_position=None,\n+        **kwargs,\n+    ):\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_values is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_values.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(bsz, q_len, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+\n+        return attn_output, attn_weights\n+\n+\n+class BltCrossAttention(nn.Module):\n+    \"\"\"Cross-attention module for Blt, following transformers style\"\"\"\n+\n+    def __init__(self, config: BltConfig, layer_idx: int, hidden_size: Optional[int] = None):\n+        super().__init__()\n+        self.config = config\n+        self.num_heads = self.config.num_attention_heads\n+        self.num_key_value_heads = self.config.num_key_value_heads\n+        self.dropout = config.dropout\n+        self.hidden_size = config.hidden_size\n+        self.head_dim = config.hidden_size // self.num_heads\n+        self.layer_idx = layer_idx\n+        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n+        self.scaling = self.head_dim**-0.5\n+\n+        self.q_proj = nn.Linear(self.hidden_size, self.num_heads * self.head_dim, bias=False)\n+        self.k_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=False)\n+        self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=False)\n+        self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=False)\n+        self.q_norm = BltRMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+        self.k_norm = BltRMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+        self.is_causal = False\n+\n+    @deprecate_kwarg(\"past_key_value\", new_name=\"past_key_values\", version=\"4.58\")\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cross_attention_states: Optional[torch.Tensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor], Optional[tuple[torch.Tensor]]]:\n+        \"\"\"Input shape: Batch x Time x Channel\"\"\"\n+        bsz, q_len, _ = hidden_states.size()\n+        query_states = self.q_norm(hidden_states)\n+        query_states = self.q_proj(query_states)\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+\n+        if cross_attention_states is not None:\n+            cross_attention_states = self.k_norm(cross_attention_states)\n+            key_states = self.k_proj(cross_attention_states)\n+            value_states = self.v_proj(cross_attention_states)\n+            key_states = key_states.view(bsz, -1, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+            value_states = value_states.view(bsz, -1, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+            if past_key_values is not None:\n+                key_states, value_states = past_key_values.update(\n+                    key_states, value_states, self.layer_idx, {\"cache_position\": cache_position}\n+                )\n+        elif cache_position[0] != 0:\n+            key_states, value_states = (\n+                past_key_values.layers[self.layer_idx].keys,\n+                past_key_values.layers[self.layer_idx].values,\n+            )\n+        else:\n+            raise ValueError(\n+                \"Cross attention layer can't find neither `cross_attn_states` nor cached values for key/values!\"\n+            )\n+        attention_interface: Callable = eager_attention_forward\n+\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+        attn_output = attn_output.reshape(bsz, q_len, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        attn_output = attn_output + hidden_states\n+        return attn_output, attn_weights\n+\n+\n+@auto_docstring\n+class BltPreTrainedModel(PreTrainedModel):\n+    config: BltConfig\n+    base_model_prefix = \"\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"BltTransformerLayer\"]\n+    _can_compile_fullgraph = False  # static cache cannot have different shapes for each layer\n+    _supports_sdpa = True\n+    _supports_flash_attn = True\n+    _supports_flex_attn = True\n+    _supports_attention_backend = False\n+    _can_record_outputs = {\n+        \"hidden_states\": OutputRecorder(BltTransformerLayer, index=0, layer_name=\"local_decoder\"),\n+        \"attentions\": OutputRecorder(BltSelfAttention, index=1, layer_name=\"local_decoder\"),\n+    }\n+\n+\n+class BltLocalEncoder(BltPreTrainedModel):\n+    config: BltLocalEncoderConfig\n+    _can_record_outputs = {\n+        \"encoder_attentions\": OutputRecorder(BltSelfAttention, index=1, layer_name=\"local_encoder\"),\n+    }\n+\n+    def __init__(self, config: BltLocalEncoderConfig):\n+        super().__init__(config)\n+        self.gradient_checkpointing = False\n+        self.config = config\n+        self.layers = nn.ModuleList(\n+            [BltTransformerLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.rotary_emb = BltRotaryEmbedding(config=config)\n+        self.patch_embedding_projection = nn.Linear(\n+            in_features=config.hidden_size,\n+            out_features=config.hidden_size * config.cross_attn_k,\n+            bias=False,\n+        )\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size)\n+        self.cross_attn_layers = nn.ModuleList()\n+        layers_to_add = config.num_hidden_layers if config.cross_attn_all_layers else 1\n+        for layer_idx in range(layers_to_add):\n+            self.cross_attn_layers.append(\n+                BltCrossAttention(config=config, layer_idx=layer_idx, hidden_size=config.hidden_size)\n+            )\n+\n+        self.post_init()\n+\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        patch_embeds: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        encoder_attention_mask: Optional[torch.Tensor] = None,\n+        num_patches: Optional[int] = None,\n+        patch_ids: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ):\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        batch_size = inputs_embeds.shape[0]\n+        hidden_states = F.dropout(inputs_embeds, p=self.config.dropout, training=self.training)\n+\n+        if position_ids is None:\n+            position_ids = (\n+                torch.arange(inputs_embeds.shape[1], device=inputs_embeds.device).unsqueeze(0).expand(batch_size, -1)\n+            )\n+\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+        hidden_states = F.dropout(hidden_states, p=self.config.dropout, training=self.training)\n+\n+        for idx, layer in enumerate(self.layers):\n+            hidden_states = layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=attention_mask,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+            if idx == len(self.layers) - 1 or self.config.cross_attn_all_layers:\n+                patch_embeds = self.patch_reduce(hidden_states, num_patches, patch_ids)\n+                patch_embeds = self.patch_embedding_projection(patch_embeds)\n+                patch_embeds = patch_embeds.reshape(\n+                    batch_size, patch_embeds.shape[1] * self.config.cross_attn_k, self.config.hidden_size\n+                )\n+                layer_idx = idx if self.config.cross_attn_all_layers else 0\n+                cross_attention_output, _ = self.cross_attn_layers[layer_idx](\n+                    hidden_states=patch_embeds,\n+                    cross_attention_states=hidden_states,\n+                    attention_mask=encoder_attention_mask,\n+                    **kwargs,\n+                )\n+                patch_embeds = patch_embeds + cross_attention_output\n+        encoder_cross_states = patch_embeds\n+        return hidden_states, encoder_cross_states\n+\n+    def patch_reduce(self, hidden_states, max_num_patches, patch_ids):\n+        \"\"\"\n+        Reduce variable length patches to single embedding per patch\n+        Note: this works with variable number of patches for different sequences in the batch\n+        It handles variable length patches by assuming that patch_lengths will be 0 for any\n+        extra patches on the *right*. Since there can be a variable number of patches\n+        this function also return the number of patches for each sequence in the batch.\n+        Any embeddings on the right that are not allocated to a patch\n+        (i.e. if the sum(patch_lengths[i]) < seq_len for any i)\n+        will be sent to a dummy patch, which is trimmed before returning.\n+        \"\"\"\n+        batch_size = hidden_states.shape[0]\n+        embedding_dim = hidden_states.shape[-1]\n+\n+        patch_ids = patch_ids.unsqueeze(-1).expand(-1, -1, hidden_states.shape[-1])\n+\n+        reduced_embeddings = torch.zeros(\n+            (batch_size, max_num_patches, embedding_dim), dtype=hidden_states.dtype, device=hidden_states.device\n+        )\n+\n+        reduced_embeddings = reduced_embeddings.scatter_reduce(\n+            src=hidden_states,\n+            dim=1,\n+            index=patch_ids,\n+            reduce=\"amax\",\n+            include_self=False,\n+        )\n+        reduced_embeddings = reduced_embeddings[:, :max_num_patches, :]\n+\n+        return reduced_embeddings\n+\n+\n+class BltLocalDecoder(BltPreTrainedModel):\n+    config: BltLocalDecoderConfig\n+\n+    def __init__(self, config: BltLocalDecoderConfig):\n+        super().__init__(config)\n+        self.gradient_checkpointing = False\n+        self.config = config\n+        self.cross_attn_decoder = True\n+        self.layers = nn.ModuleList(\n+            [BltTransformerLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.rotary_emb = BltRotaryEmbedding(config=config)\n+        self.patch_embedding_projection = nn.Linear(\n+            in_features=config.hidden_size_global,\n+            out_features=config.hidden_size * config.cross_attn_k,\n+            bias=False,\n+        )\n+        self.norm = BltRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.cross_attn_layers = nn.ModuleList()\n+        layers_to_add = config.num_hidden_layers if config.cross_attn_all_layers else 1\n+        for layer_idx in range(layers_to_add):\n+            self.cross_attn_layers.append(\n+                BltCrossAttention(config=config, layer_idx=layer_idx, hidden_size=config.hidden_size)\n+            )\n+\n+        self.post_init()\n+\n+    @check_model_inputs\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        patch_embeds: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        encoder_attention_mask: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ):\n+        batch_size = inputs_embeds.shape[0]\n+        hidden_states = inputs_embeds\n+        patch_embeds = self.patch_embedding_projection(patch_embeds)\n+        patch_embeds = patch_embeds.reshape(\n+            batch_size, patch_embeds.shape[1] * self.config.cross_attn_k, self.config.hidden_size\n+        )\n+\n+        if patch_embeds is not None and not self.cross_attn_decoder:\n+            hidden_states = hidden_states + patch_embeds\n+\n+        if position_ids is None:\n+            position_ids = (\n+                torch.arange(inputs_embeds.shape[1], device=inputs_embeds.device).unsqueeze(0).expand(batch_size, -1)\n+            )\n+\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+        hidden_states = F.dropout(hidden_states, p=self.config.dropout, training=self.training)\n+\n+        for i, layer in enumerate(self.layers):\n+            if i == 0 or self.config.cross_attn_all_layers:\n+                cross_attention_output, _ = self.cross_attn_layers[i](\n+                    hidden_states=hidden_states,\n+                    cross_attention_states=patch_embeds,\n+                    attention_mask=encoder_attention_mask,\n+                    **kwargs,\n+                )\n+                hidden_states = hidden_states + cross_attention_output\n+            hidden_states = layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=attention_mask,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+        logits = self.norm(hidden_states)\n+        return logits\n+\n+\n+class BltGlobalTransformer(BltPreTrainedModel):\n+    config: BltGlobalTransformerConfig\n+    _can_record_outputs = {\n+        \"global_attentions\": OutputRecorder(BltSelfAttention, index=1, layer_name=\"global_transformer\"),\n+    }\n+\n+    def __init__(self, config: BltGlobalTransformerConfig):\n+        super().__init__(config)\n+        self.config = config\n+        self.layers = nn.ModuleList()\n+        for layer_idx in range(config.num_hidden_layers):\n+            self.layers.append(BltTransformerLayer(config, layer_idx))\n+        self.rotary_emb = BltRotaryEmbedding(config=config)\n+\n+        # Create token embedding projection (use nn.Identity() when no projection needed)\n+        if getattr(config, \"encoder_cross_output_size\", None) is not None:\n+            self.token_embedding_projection = nn.Linear(\n+                config.encoder_cross_output_size, config.hidden_size, bias=False\n+            )\n+        else:\n+            self.token_embedding_projection = nn.Identity()\n+\n+        self.post_init()\n+\n+    def forward(\n+        self,\n+        input_embeds: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ):\n+        batch_size, seq_len, _ = input_embeds.shape\n+        hidden_states = self.token_embedding_projection(input_embeds)\n+        hidden_states = F.dropout(hidden_states, p=self.config.dropout, training=self.training)\n+        if position_ids is None:\n+            position_ids = (\n+                torch.arange(input_embeds.shape[1], device=input_embeds.device).unsqueeze(0).expand(batch_size, -1)\n+            )\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+        for i, layer in enumerate(self.layers):\n+            hidden_states = layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=attention_mask,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+        return hidden_states\n+\n+\n+def process_patch_lengths(patch_lengths: torch.Tensor, max_patch_length: Optional[int]) -> torch.Tensor:\n+    \"\"\"\n+    Splits patch lengths into smaller segments if they exceed `max_patch_length`.\n+    Pads the result to uniform length across the batch.\n+\n+    Args:\n+        patch_lengths (torch.Tensor): [batch_size, num_patches] tensor of patch lengths.\n+        max_patch_length (int, optional): Maximum allowed length per patch.\n+\n+    Returns:\n+        torch.Tensor: [batch_size, max_len] tensor of split and padded patch lengths.\n+    \"\"\"\n+    if max_patch_length is None:\n+        return patch_lengths\n+\n+    batch_size = patch_lengths.size(0)\n+    processed = []\n+\n+    for seq in patch_lengths:\n+        splits = []\n+        for length in seq[seq > 0]:\n+            length = length.item()\n+            full_chunks, remainder = divmod(length, max_patch_length)\n+            splits.extend([max_patch_length] * full_chunks)\n+            if remainder:\n+                splits.append(remainder)\n+        processed.append(splits)\n+\n+    # Find max length to pad to\n+    max_len = max(len(splits) for splits in processed)\n+    padded = torch.zeros((batch_size, max_len), dtype=patch_lengths.dtype, device=patch_lengths.device)\n+\n+    for i, splits in enumerate(processed):\n+        if splits:\n+            padded[i, : len(splits)] = torch.tensor(splits, dtype=patch_lengths.dtype, device=patch_lengths.device)\n+\n+    # Trim zero columns\n+    if (padded != 0).any(dim=0).sum() < padded.shape[1]:\n+        last_nonzero = (padded != 0).any(dim=0).nonzero().max().item() + 1\n+        padded = padded[:, :last_nonzero]\n+\n+    return padded\n+\n+\n+class BltPatcher(BltPreTrainedModel):\n+    config: BltPatcherConfig\n+\n+    def __init__(self, config: BltPatcherConfig):\n+        super().__init__(config)\n+        self.rotary_emb = BltRotaryEmbedding(config=self.config)\n+        self.layers = nn.ModuleList()\n+        for layer_idx in range(self.config.num_hidden_layers):\n+            self.layers.append(BltTransformerLayer(self.config, layer_idx))\n+        self.embed_tokens = nn.Embedding(self.config.vocab_size, self.config.hidden_size)\n+        self.norm = BltRMSNorm(self.config.hidden_size, eps=self.config.rms_norm_eps)\n+        self.lm_head = nn.Linear(\n+            self.config.hidden_size,\n+            self.config.vocab_size,\n+            bias=False,\n+        )\n+\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        patch_size: Optional[int] = None,\n+        threshold: Optional[float] = None,\n+        max_patch_length: Optional[int] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ):\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache()\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=position_ids,\n+        )\n+\n+        hidden_states = inputs_embeds\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        for layer in self.layers:\n+            hidden_states = layer(hidden_states, position_embeddings=position_embeddings, attention_mask=causal_mask)\n+\n+        logits = self.lm_head(self.norm(hidden_states))\n+        prediction_entropies = torch.distributions.Categorical(logits=logits).entropy()\n+\n+        batch_size, sequence_length = inputs_embeds.shape[:2]\n+        if patch_size is not None:\n+            patch_lengths = self.patch_lengths_from_entropies(\n+                entropies=prediction_entropies,\n+                sequence_length=sequence_length,\n+                patch_size=patch_size,\n+                threshold=threshold,\n+            )\n+        else:\n+            patch_lengths = torch.ones(\n+                (batch_size, sequence_length), dtype=inputs_embeds.dtype, device=inputs_embeds.device\n+            )\n+        patch_lengths = process_patch_lengths(patch_lengths, max_patch_length)\n+        return prediction_entropies, patch_lengths, logits\n+\n+    @staticmethod\n+    def patch_lengths_from_entropies(\n+        entropies,\n+        sequence_length,\n+        patch_size=None,\n+        threshold=None,\n+    ):\n+        \"\"\"\n+        Computes patch lengths from token entropies.\n+\n+        Depending on whether a threshold is provided, the function uses either:\n+        - Thresholding the entropy values (when `threshold` is set).\n+        \"\"\"\n+\n+        batch_size = entropies.shape[0]\n+\n+        # Always include token 0 and 1 as starting tokens\n+        init_tokens = (\n+            torch.tensor([0, 1], dtype=torch.long, device=entropies.device).unsqueeze(0).repeat(batch_size, 1)\n+        )\n+        offset = init_tokens.shape[1]\n+\n+        # Ignore first token entropy (BOS)\n+        entropies = entropies[:, 1:]\n+\n+        # Threshold the entropy values to define patch start points\n+        patch_mask = entropies > threshold\n+\n+        seq_len = patch_mask.shape[1]\n+\n+        # Create patch IDs (token indices), and add a sentinel to ensure alignment\n+        token_indices = torch.arange(seq_len, device=entropies.device).unsqueeze(0).expand(batch_size, -1)\n+        sentinel = torch.full_like(token_indices, seq_len)\n+        padded_indices = torch.cat([token_indices, sentinel], dim=1)\n+\n+        # Pad mask with inverse to align sentinel correctly\n+        padded_mask = torch.cat([patch_mask, ~patch_mask], dim=1)\n+\n+        # Select indices where mask is True\n+        patch_starts = padded_indices[padded_mask].reshape(batch_size, seq_len)\n+        max_valid_patches = patch_mask.sum(dim=1).max()\n+        patch_starts = patch_starts[:, :max_valid_patches]\n+\n+        # Offset patch starts to account for the two initial tokens\n+        patch_start_ids = torch.cat((init_tokens, patch_starts + offset), dim=1)\n+\n+        # Compute patch end positions by shifting start positions\n+        last_token = torch.full_like(patch_start_ids[:, :1], sequence_length - 1)\n+        patch_ends = torch.cat((patch_start_ids[:, 1:] - 1, last_token), dim=1)\n+\n+        patch_lengths = patch_ends - patch_start_ids + 1\n+\n+        return patch_lengths\n+\n+\n+def rolling_polynomial_hash(token_tensor, prime: int = 1000000007):\n+    \"\"\"\n+    A polynomial rolling hash algorithm that converts sequences\n+    of tokens into hash values. The hash is computed as:\n+        hash = (token_0 * prime^0 + token_1 * prime^1 + ... + token_n * prime^n)\n+\n+    The rolling hash allows the model to efficiently\n+    identify and encode recurring byte-level patterns in the input text.\n+\n+    Args:\n+        token_tensor (torch.Tensor): [batch_size, seq_len, group_size] containing token IDs to hash\n+        prime (int): Prime number used as the base for the polynomial hash.\n+\n+    Returns:\n+        torch.Tensor: Hash values of shape [batch_size, seq_len] where each value\n+                     represents the hash of the corresponding token group\n+\n+    Example:\n+        >>> tokens = torch.tensor([[1, 2, 3], [4, 5, 6]])\n+        >>> hashes = rolling_polynomial_hash(tokens, prime=31)\n+        >>> # hash[0] = 1*31^0 + 2*31^1 + 3*31^2\n+        >>> # hash[1] = 4*31^0 + 5*31^1 + 6*31^2\n+    \"\"\"\n+    prime_tensor = torch.tensor(prime, dtype=torch.int64, device=token_tensor.device)\n+    powers = torch.arange(token_tensor.shape[-1], device=token_tensor.device)\n+    prime_powers = prime_tensor**powers\n+    return torch.sum(token_tensor * prime_powers, dim=-1)\n+\n+\n+def byte_group_hash_function(\n+    token_ids: torch.Tensor, group_size: int = 2, prime: int = 1000000007, max_hash: int = 30000\n+):\n+    \"\"\"Hash token groups and map to range [0, max_hash].\"\"\"\n+    with torch.no_grad():\n+        batch_size, seq_len = token_ids.shape\n+        # Add padding for sliding window\n+        padding = torch.zeros(batch_size, group_size - 1, dtype=torch.int64, device=token_ids.device)\n+        padded_tokens = torch.cat([padding, token_ids], dim=1)\n+\n+        # Create sliding windows and compute hashes\n+        windows = padded_tokens.unfold(1, group_size, 1)\n+        hashes = rolling_polynomial_hash(windows, prime)\n+        hash_values = hashes % max_hash\n+\n+    return hash_values\n+\n+\n+def compute_hash_embeddings(\n+    local_encoder_tokens: torch.Tensor,\n+    local_encoder,\n+    encoder_hash_tok_embedding: nn.Embedding,\n+    encoder_hash_byte_group_nb_functions: int,\n+    encoder_hash_byte_group_size: list,\n+    encoder_hash_byte_group_vocab: int,\n+) -> torch.Tensor:\n+    \"\"\"Compute token embeddings enhanced with hash-based embeddings.\"\"\"\n+    # Available primes for hash functions\n+    primes = [\n+        1000000007,\n+        5915587277,\n+        1500450271,\n+        3267000013,\n+        5754853343,\n+        4093082899,\n+        9576890767,\n+        3628273133,\n+        2860486313,\n+        5463458053,\n+        3367900313,\n+    ]\n+\n+    embeddings = local_encoder.embed_tokens(local_encoder_tokens)\n+    embedding_idx = 0\n+    for func_nb in range(encoder_hash_byte_group_nb_functions):\n+        prime = primes[func_nb % len(primes)]  # Cycle through primes if more functions than primes\n+        for group_size in encoder_hash_byte_group_size:\n+            hash_ids = byte_group_hash_function(local_encoder_tokens, group_size, prime, encoder_hash_byte_group_vocab)\n+            # Apply offset to get the correct slice of the fused embedding\n+            offset_hash_ids = hash_ids + embedding_idx * encoder_hash_byte_group_vocab\n+            embeddings += encoder_hash_tok_embedding(offset_hash_ids)\n+            embedding_idx += 1\n+\n+    return embeddings\n+\n+\n+def _prepare_patch_cross_attention_mask(\n+    patch_ids: torch.Tensor,\n+    num_patches: int,\n+    sequence_length: int,\n+    patches_as_queries: bool = False,\n+    cross_attn_k: int = 1,\n+    dtype: torch.dtype = torch.float32,\n+) -> tuple[torch.Tensor, torch.Tensor]:\n+    \"\"\"\n+    Prepare cross-attention mask for patch-based attention, following mllama's robust approach.\n+\n+    This function creates masks that control which patches can attend to which other patches,\n+    with support for query/key role swapping and cross-attention multipliers.\n+\n+    Args:\n+        patch_ids (torch.Tensor): Tensor of shape [batch_size, seq_len] containing patch ids.\n+        num_patches (int): Total number of patches.\n+        sequence_length (int): Length of the sequence.\n+        patches_as_queries (bool): If True, patches are used as queries, otherwise as keys.\n+        cross_attn_k (int): Cross-attention multiplier for repeating patches.\n+        dtype (torch.dtype): Data type for the output mask.\n+\n+    Returns:\n+        Tuple[torch.Tensor, torch.Tensor]:\n+            - cross_attention_mask: 4D tensor [batch_size, 1, q_len, kv_len]\n+    \"\"\"\n+    batch_size, seq_len = patch_ids.shape\n+    device = patch_ids.device\n+\n+    # Determine query and key lengths based on configuration\n+    if patches_as_queries:\n+        q_len = num_patches * cross_attn_k\n+        kv_len = sequence_length\n+        # Create patch-to-sequence mapping\n+        q_patch_ids = (\n+            torch.arange(num_patches, device=device)\n+            .unsqueeze(0)\n+            .unsqueeze(-1)\n+            .expand(batch_size, num_patches, seq_len)\n+        )\n+        kv_patch_ids = patch_ids.unsqueeze(1).expand(batch_size, num_patches, seq_len)\n+    else:\n+        q_len = sequence_length\n+        kv_len = num_patches * cross_attn_k\n+        # Create sequence-to-patch mapping\n+        q_patch_ids = patch_ids.unsqueeze(-1).expand(batch_size, seq_len, num_patches)\n+        kv_patch_ids = (\n+            torch.arange(num_patches, device=device).unsqueeze(0).unsqueeze(0).expand(batch_size, seq_len, num_patches)\n+        )\n+\n+    # Create base attention mask - boolean mask where True means \"should attend\"\n+    # Exact patch matching\n+    cross_attention_mask = q_patch_ids == kv_patch_ids\n+\n+    # Handle cross_attn_k multiplier by repeating along appropriate dimension\n+    repeat_dim = 1 if patches_as_queries else -1\n+    cross_attention_mask = cross_attention_mask.repeat_interleave(cross_attn_k, dim=repeat_dim)\n+\n+    # Validate dimensions\n+    expected_shape = (batch_size, q_len, kv_len)\n+    if cross_attention_mask.shape != expected_shape:\n+        raise ValueError(\n+            f\"Cross attention mask shape {cross_attention_mask.shape} doesn't match expected {expected_shape}\"\n+        )\n+\n+    # Reshape so it can be used by attn module - add head dimension\n+    cross_attention_mask = cross_attention_mask.unsqueeze(1)  # [batch_size, 1, q_len, kv_len]\n+\n+    # Invert the mask (following mllama pattern exactly)\n+    # True -> 0.0 (attend), False -> 1.0 (will become -inf)\n+    inverted_cross_attn_mask = 1.0 - cross_attention_mask.to(dtype)\n+    cross_attention_mask = inverted_cross_attn_mask.masked_fill(\n+        inverted_cross_attn_mask.to(torch.bool), torch.finfo(dtype).min\n+    )\n+\n+    return cross_attention_mask\n+\n+\n+class BltModel(BltPreTrainedModel):\n+    def __init__(self, config: BltConfig):\n+        super().__init__(config)\n+        self.gradient_checkpointing = False\n+\n+        self.config = config\n+        self.local_encoder = BltLocalEncoder(config.encoder_config)\n+        self.global_transformer = BltGlobalTransformer(config.global_config)\n+        self.local_decoder = BltLocalDecoder(config.decoder_config)\n+        num_embeddings = config.encoder_hash_byte_group_nb_functions * len(config.encoder_hash_byte_group_size)\n+        total_vocab_size = config.encoder_hash_byte_group_vocab * num_embeddings\n+        self.encoder_hash_tok_embedding = nn.Embedding(total_vocab_size, config.encoder_config.hidden_size)\n+        if self.config.patch_in_forward:\n+            self.patcher = BltPatcher(config.patcher_config)\n+            self.patcher.eval()\n+            for param in self.patcher.parameters():\n+                param.requires_grad = False\n+        else:\n+            self.patcher = None\n+        self.post_init()\n+\n+    @check_model_inputs\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        patch_lengths: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> BaseModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        # Extract input embeddings as early as possible\n+        if inputs_embeds is not None:\n+            encoder_embeds = inputs_embeds\n+            batch_size, sequence_length, _ = inputs_embeds.shape\n+        else:\n+            batch_size, sequence_length = input_ids.shape\n+            encoder_embeds = compute_hash_embeddings(\n+                input_ids,\n+                self.local_encoder,\n+                self.encoder_hash_tok_embedding,\n+                self.config.encoder_hash_byte_group_nb_functions,\n+                self.config.encoder_hash_byte_group_size,\n+                self.config.encoder_hash_byte_group_vocab,\n+            )\n+\n+        if patch_lengths is None:\n+            if self.config.patching_mode == \"entropy\" and self.patcher is not None:\n+                if input_ids is None:\n+                    raise ValueError(\"input_ids is required for entropy-based patching\")\n+                _, patch_lengths, _ = self.patcher(\n+                    input_ids,\n+                    patch_size=self.config.patch_size,\n+                    threshold=self.config.patching_threshold,\n+                    max_patch_length=self.config.max_patch_length,\n+                    patching_batch_size=self.config.patching_batch_size,\n+                    device=input_ids.device,\n+                )\n+            else:\n+                device = input_ids.device if input_ids is not None else inputs_embeds.device\n+                dtype = input_ids.dtype if input_ids is not None else inputs_embeds.dtype\n+                patch_lengths = process_patch_lengths(\n+                    torch.ones((batch_size, sequence_length + 1), dtype=dtype, device=device),\n+                    self.config.max_patch_length,\n+                )\n+        patch_ids = self._patch_ids_from_lengths(patch_lengths, sequence_length)\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + encoder_embeds.shape[1], device=encoder_embeds.device\n+            )\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=encoder_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=position_ids,\n+        )\n+\n+        cross_attn_mask_enc = _prepare_patch_cross_attention_mask(\n+            patch_ids, patch_lengths.shape[1], sequence_length, True, self.config.cross_attn_k, encoder_embeds.dtype\n+        )\n+        encoder_hidden_states, encoder_cross_states = self.local_encoder(\n+            input_ids=input_ids,\n+            inputs_embeds=encoder_embeds,\n+            attention_mask=causal_mask,\n+            position_ids=position_ids,\n+            encoder_attention_mask=cross_attn_mask_enc,\n+            num_patches=patch_lengths.shape[1],\n+            patch_ids=patch_ids,\n+            **kwargs,\n+        )\n+        encoder_cross_states = encoder_cross_states.view(batch_size, patch_lengths.shape[1], -1)\n+        global_cache_position = torch.arange(0, encoder_cross_states.shape[1], device=encoder_cross_states.device)\n+        global_position_ids = global_cache_position.unsqueeze(0)\n+        global_causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=encoder_cross_states,\n+            attention_mask=None,\n+            cache_position=global_cache_position,\n+            past_key_values=None,\n+            position_ids=None,\n+        )\n+\n+        global_hidden_states = self.global_transformer(\n+            input_embeds=encoder_cross_states,\n+            attention_mask=global_causal_mask,\n+            position_ids=global_position_ids,\n+            **kwargs,\n+        )\n+        decoder_patch_ids = self._patch_ids_from_lengths(patch_lengths[:, 1:], sequence_length)\n+        cross_attn_mask_dec = _prepare_patch_cross_attention_mask(\n+            decoder_patch_ids,\n+            patch_lengths.shape[1],\n+            sequence_length,\n+            False,\n+            self.config.cross_attn_k,\n+            encoder_embeds.dtype,\n+        )\n+        output = self.local_decoder(\n+            input_ids=input_ids,\n+            inputs_embeds=encoder_hidden_states,\n+            patch_embeds=global_hidden_states,\n+            attention_mask=causal_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            cache_position=cache_position,\n+            encoder_attention_mask=cross_attn_mask_dec,\n+            **kwargs,\n+        )\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=output,\n+            past_key_values=past_key_values,\n+        )\n+\n+    def get_input_embeddings(self):\n+        return self.local_encoder.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.local_encoder.embed_tokens = value\n+\n+    def _patch_ids_from_lengths(self, patch_lengths: torch.Tensor, seq_len: int) -> torch.Tensor:\n+        batch_size = patch_lengths.shape[0]\n+        patch_starts = torch.cat(\n+            [\n+                torch.zeros(batch_size, 1, dtype=patch_lengths.dtype, device=patch_lengths.device),\n+                patch_lengths.cumsum(dim=-1)[:, :-1],\n+            ],\n+            dim=-1,\n+        )\n+        token_positions = torch.arange(seq_len, device=patch_lengths.device)\n+        return (patch_starts.unsqueeze(1) <= token_positions.unsqueeze(0).unsqueeze(-1)).sum(dim=-1) - 1\n+\n+\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    The Blt Text Model with a language modeling head on top.\n+    \"\"\"\n+)\n+class BltForCausalLM(BltPreTrainedModel, GenerationMixin):\n+    config: BltConfig\n+    _can_compile_fullgraph = False\n+    base_model_prefix = \"model\"\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+\n+    def __init__(self, config: BltConfig):\n+        super().__init__(config.get_text_config())\n+        self.text_config = config.get_text_config()\n+        self.vocab_size = config.vocab_size\n+        self.model = BltModel(config)\n+        self.lm_head = nn.Linear(config.decoder_config.hidden_size, config.vocab_size, bias=False)\n+\n+        self.post_init()\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        cross_attention_states: Optional[torch.LongTensor] = None,  # Keep for compatibility\n+        cross_attention_mask: Optional[torch.LongTensor] = None,\n+        full_text_row_masked_out_mask: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        past_key_values: Optional[Union[Cache, list[torch.FloatTensor]]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, CausalLMOutputWithPast]:\n+        r\"\"\"\n+        cross_attention_states (`torch.FloatTensor`, *optional*):\n+            Output of the vision model, used for cross-attention. This tensor contains the processed image features that\n+            the language model will attend to.\n+        cross_attention_mask (`torch.Tensor` of shape `(batch_size, seq_length, max_num_images, max_num_tiles)`, *optional*):\n+            Cross-attention mask to control the interaction between text tokens and image tiles.\n+            This 4D tensor defines which image tiles each text token should attend to.\n+\n+            For each text token (in seq_length):\n+            - 1 indicates the token **should attend** to the corresponding image tile\n+            - 0 indicates the token **should not attend** to the corresponding image tile\n+        full_text_row_masked_out_mask (`tuple[torch.Tensor, torch.Tensor]`, *optional*):\n+            A tuple containing two tensors that mask out rows in the cross-attention mechanism:\n+            - The first tensor has shape `(batch_size, 1, seq_length, 1)` and contains values of 0 or 1.\n+              A value of 0 indicates that the corresponding text token's entire row in the cross-attention\n+              matrix should be masked out (all image tokens ignored).\n+            - The second tensor has the same shape and is used internally to apply the masking during\n+              the forward pass of cross-attention layers.\n+            This mask is derived from the cross_attention_mask and is used to handle cases where a text token\n+            should not attend to any image token.\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, BltForCausalLM\n+\n+        >>> model = BltForCausalLM.from_pretrained(\"Llama-3.2-11B-Vision\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"Llama-3.2-11B-Vision\")\n+\n+        >>> prompt = \"If I had to write a haiku, it would be:\"\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=40, do_sample=True, temperature=0.6)\n+        >>> result = tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        >>> print(result)\n+        If I had to write a haiku, it would be: \"Snowflakes gently fall\" - simple, yet peaceful.\n+        I love the idea of snowflakes gently falling, each one\n+        ```\n+        \"\"\"\n+        # Call parent forward but exclude cross_attention_states from model call\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            cross_attention_mask=cross_attention_mask,\n+            full_text_row_masked_out_mask=full_text_row_masked_out_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs.last_hidden_state\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :]).float()\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits, labels, self.vocab_size, **kwargs)\n+\n+        return CausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+\n+__all__ = [\"BltPreTrainedModel\", \"BltModel\", \"BltPatcher\", \"BltForCausalLM\"]"
        },
        {
            "sha": "0b04966d97fe1ad521e4d7697a7a9fcd804faafb",
            "filename": "src/transformers/models/blt/modular_blt.py",
            "status": "added",
            "additions": 1008,
            "deletions": 0,
            "changes": 1008,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fblt%2Fmodular_blt.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/src%2Ftransformers%2Fmodels%2Fblt%2Fmodular_blt.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fblt%2Fmodular_blt.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -0,0 +1,1008 @@\n+# coding=utf-8\n+# Copyright 2025 HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Blt modular model, inheriting from Mllama where appropriate.\"\"\"\n+\n+from typing import Callable, Optional, Union\n+\n+import torch\n+import torch.distributions\n+import torch.nn as nn\n+import torch.nn.functional as F\n+\n+from ...cache_utils import Cache, DynamicCache\n+from ...masking_utils import create_causal_mask\n+from ...modeling_outputs import BaseModelOutputWithPast, CausalLMOutputWithPast\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring, logging\n+from ...utils.generic import OutputRecorder, check_model_inputs\n+from ..cohere2.modeling_cohere2 import (\n+    Cohere2RotaryEmbedding,\n+    rotate_half,  # noqa: F401\n+)\n+from ..mllama.modeling_mllama import (\n+    MllamaForCausalLM,\n+    MllamaPreTrainedModel,\n+    MllamaSelfAttentionDecoderLayer,\n+    MllamaTextCrossAttention,\n+    MllamaTextMLP,\n+    MllamaTextRMSNorm,\n+    MllamaTextSelfAttention,\n+    eager_attention_forward,\n+)\n+from .configuration_blt import (\n+    BltConfig,\n+    BltGlobalTransformerConfig,\n+    BltLocalDecoderConfig,\n+    BltLocalEncoderConfig,\n+    BltPatcherConfig,\n+)\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+def rolling_polynomial_hash(token_tensor, prime: int = 1000000007):\n+    \"\"\"\n+    A polynomial rolling hash algorithm that converts sequences\n+    of tokens into hash values. The hash is computed as:\n+        hash = (token_0 * prime^0 + token_1 * prime^1 + ... + token_n * prime^n)\n+\n+    The rolling hash allows the model to efficiently\n+    identify and encode recurring byte-level patterns in the input text.\n+\n+    Args:\n+        token_tensor (torch.Tensor): [batch_size, seq_len, group_size] containing token IDs to hash\n+        prime (int): Prime number used as the base for the polynomial hash.\n+\n+    Returns:\n+        torch.Tensor: Hash values of shape [batch_size, seq_len] where each value\n+                     represents the hash of the corresponding token group\n+\n+    Example:\n+        >>> tokens = torch.tensor([[1, 2, 3], [4, 5, 6]])\n+        >>> hashes = rolling_polynomial_hash(tokens, prime=31)\n+        >>> # hash[0] = 1*31^0 + 2*31^1 + 3*31^2\n+        >>> # hash[1] = 4*31^0 + 5*31^1 + 6*31^2\n+    \"\"\"\n+    prime_tensor = torch.tensor(prime, dtype=torch.int64, device=token_tensor.device)\n+    powers = torch.arange(token_tensor.shape[-1], device=token_tensor.device)\n+    prime_powers = prime_tensor**powers\n+    return torch.sum(token_tensor * prime_powers, dim=-1)\n+\n+\n+def byte_group_hash_function(\n+    token_ids: torch.Tensor, group_size: int = 2, prime: int = 1000000007, max_hash: int = 30000\n+):\n+    \"\"\"Hash token groups and map to range [0, max_hash].\"\"\"\n+    with torch.no_grad():\n+        batch_size, seq_len = token_ids.shape\n+        # Add padding for sliding window\n+        padding = torch.zeros(batch_size, group_size - 1, dtype=torch.int64, device=token_ids.device)\n+        padded_tokens = torch.cat([padding, token_ids], dim=1)\n+\n+        # Create sliding windows and compute hashes\n+        windows = padded_tokens.unfold(1, group_size, 1)\n+        hashes = rolling_polynomial_hash(windows, prime)\n+        hash_values = hashes % max_hash\n+\n+    return hash_values\n+\n+\n+def compute_hash_embeddings(\n+    local_encoder_tokens: torch.Tensor,\n+    local_encoder,\n+    encoder_hash_tok_embedding: nn.Embedding,\n+    encoder_hash_byte_group_nb_functions: int,\n+    encoder_hash_byte_group_size: list,\n+    encoder_hash_byte_group_vocab: int,\n+) -> torch.Tensor:\n+    \"\"\"Compute token embeddings enhanced with hash-based embeddings.\"\"\"\n+    # Available primes for hash functions\n+    primes = [\n+        1000000007,\n+        5915587277,\n+        1500450271,\n+        3267000013,\n+        5754853343,\n+        4093082899,\n+        9576890767,\n+        3628273133,\n+        2860486313,\n+        5463458053,\n+        3367900313,\n+    ]\n+\n+    embeddings = local_encoder.embed_tokens(local_encoder_tokens)\n+    embedding_idx = 0\n+    for func_nb in range(encoder_hash_byte_group_nb_functions):\n+        prime = primes[func_nb % len(primes)]  # Cycle through primes if more functions than primes\n+        for group_size in encoder_hash_byte_group_size:\n+            hash_ids = byte_group_hash_function(local_encoder_tokens, group_size, prime, encoder_hash_byte_group_vocab)\n+            # Apply offset to get the correct slice of the fused embedding\n+            offset_hash_ids = hash_ids + embedding_idx * encoder_hash_byte_group_vocab\n+            embeddings += encoder_hash_tok_embedding(offset_hash_ids)\n+            embedding_idx += 1\n+\n+    return embeddings\n+\n+\n+def _prepare_patch_cross_attention_mask(\n+    patch_ids: torch.Tensor,\n+    num_patches: int,\n+    sequence_length: int,\n+    patches_as_queries: bool = False,\n+    cross_attn_k: int = 1,\n+    dtype: torch.dtype = torch.float32,\n+) -> tuple[torch.Tensor, torch.Tensor]:\n+    \"\"\"\n+    Prepare cross-attention mask for patch-based attention, following mllama's robust approach.\n+\n+    This function creates masks that control which patches can attend to which other patches,\n+    with support for query/key role swapping and cross-attention multipliers.\n+\n+    Args:\n+        patch_ids (torch.Tensor): Tensor of shape [batch_size, seq_len] containing patch ids.\n+        num_patches (int): Total number of patches.\n+        sequence_length (int): Length of the sequence.\n+        patches_as_queries (bool): If True, patches are used as queries, otherwise as keys.\n+        cross_attn_k (int): Cross-attention multiplier for repeating patches.\n+        dtype (torch.dtype): Data type for the output mask.\n+\n+    Returns:\n+        Tuple[torch.Tensor, torch.Tensor]:\n+            - cross_attention_mask: 4D tensor [batch_size, 1, q_len, kv_len]\n+    \"\"\"\n+    batch_size, seq_len = patch_ids.shape\n+    device = patch_ids.device\n+\n+    # Determine query and key lengths based on configuration\n+    if patches_as_queries:\n+        q_len = num_patches * cross_attn_k\n+        kv_len = sequence_length\n+        # Create patch-to-sequence mapping\n+        q_patch_ids = (\n+            torch.arange(num_patches, device=device)\n+            .unsqueeze(0)\n+            .unsqueeze(-1)\n+            .expand(batch_size, num_patches, seq_len)\n+        )\n+        kv_patch_ids = patch_ids.unsqueeze(1).expand(batch_size, num_patches, seq_len)\n+    else:\n+        q_len = sequence_length\n+        kv_len = num_patches * cross_attn_k\n+        # Create sequence-to-patch mapping\n+        q_patch_ids = patch_ids.unsqueeze(-1).expand(batch_size, seq_len, num_patches)\n+        kv_patch_ids = (\n+            torch.arange(num_patches, device=device).unsqueeze(0).unsqueeze(0).expand(batch_size, seq_len, num_patches)\n+        )\n+\n+    # Create base attention mask - boolean mask where True means \"should attend\"\n+    # Exact patch matching\n+    cross_attention_mask = q_patch_ids == kv_patch_ids\n+\n+    # Handle cross_attn_k multiplier by repeating along appropriate dimension\n+    repeat_dim = 1 if patches_as_queries else -1\n+    cross_attention_mask = cross_attention_mask.repeat_interleave(cross_attn_k, dim=repeat_dim)\n+\n+    # Validate dimensions\n+    expected_shape = (batch_size, q_len, kv_len)\n+    if cross_attention_mask.shape != expected_shape:\n+        raise ValueError(\n+            f\"Cross attention mask shape {cross_attention_mask.shape} doesn't match expected {expected_shape}\"\n+        )\n+\n+    # Reshape so it can be used by attn module - add head dimension\n+    cross_attention_mask = cross_attention_mask.unsqueeze(1)  # [batch_size, 1, q_len, kv_len]\n+\n+    # Invert the mask (following mllama pattern exactly)\n+    # True -> 0.0 (attend), False -> 1.0 (will become -inf)\n+    inverted_cross_attn_mask = 1.0 - cross_attention_mask.to(dtype)\n+    cross_attention_mask = inverted_cross_attn_mask.masked_fill(\n+        inverted_cross_attn_mask.to(torch.bool), torch.finfo(dtype).min\n+    )\n+\n+    return cross_attention_mask\n+\n+\n+def process_patch_lengths(patch_lengths: torch.Tensor, max_patch_length: Optional[int]) -> torch.Tensor:\n+    \"\"\"\n+    Splits patch lengths into smaller segments if they exceed `max_patch_length`.\n+    Pads the result to uniform length across the batch.\n+\n+    Args:\n+        patch_lengths (torch.Tensor): [batch_size, num_patches] tensor of patch lengths.\n+        max_patch_length (int, optional): Maximum allowed length per patch.\n+\n+    Returns:\n+        torch.Tensor: [batch_size, max_len] tensor of split and padded patch lengths.\n+    \"\"\"\n+    if max_patch_length is None:\n+        return patch_lengths\n+\n+    batch_size = patch_lengths.size(0)\n+    processed = []\n+\n+    for seq in patch_lengths:\n+        splits = []\n+        for length in seq[seq > 0]:\n+            length = length.item()\n+            full_chunks, remainder = divmod(length, max_patch_length)\n+            splits.extend([max_patch_length] * full_chunks)\n+            if remainder:\n+                splits.append(remainder)\n+        processed.append(splits)\n+\n+    # Find max length to pad to\n+    max_len = max(len(splits) for splits in processed)\n+    padded = torch.zeros((batch_size, max_len), dtype=patch_lengths.dtype, device=patch_lengths.device)\n+\n+    for i, splits in enumerate(processed):\n+        if splits:\n+            padded[i, : len(splits)] = torch.tensor(splits, dtype=patch_lengths.dtype, device=patch_lengths.device)\n+\n+    # Trim zero columns\n+    if (padded != 0).any(dim=0).sum() < padded.shape[1]:\n+        last_nonzero = (padded != 0).any(dim=0).nonzero().max().item() + 1\n+        padded = padded[:, :last_nonzero]\n+\n+    return padded\n+\n+\n+class BltMLP(MllamaTextMLP):\n+    pass\n+\n+\n+class BltRMSNorm(MllamaTextRMSNorm):\n+    pass\n+\n+\n+class BltRotaryEmbedding(Cohere2RotaryEmbedding):\n+    pass\n+\n+\n+class BltTransformerLayer(MllamaSelfAttentionDecoderLayer):\n+    def __init__(self, config, layer_idx: int):\n+        super().__init__()\n+\n+        self.self_attn = BltSelfAttention(config=config, layer_idx=layer_idx)\n+        self.mlp = BltMLP(config)\n+        self.input_layernorm = BltRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = BltRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+\n+class BltSelfAttention(MllamaTextSelfAttention):\n+    def __init__(self, config: BltConfig, layer_idx: int):\n+        super().__init__(config, layer_idx)\n+        self.is_causal = True\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: torch.Tensor,\n+        position_embeddings: torch.Tensor,\n+        use_cache: bool = False,\n+        past_key_values=None,\n+        cache_position=None,\n+        **kwargs,\n+    ):\n+        return super().forward(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_embeddings=position_embeddings,\n+            use_cache=use_cache,\n+            past_key_values=past_key_values,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+\n+class BltCrossAttention(MllamaTextCrossAttention):\n+    \"\"\"Cross-attention module for Blt, following transformers style\"\"\"\n+\n+    def __init__(self, config: BltConfig, layer_idx: int, hidden_size: Optional[int] = None):\n+        super().__init__()\n+        self.is_causal = False\n+        self.q_norm = BltRMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+        self.k_norm = BltRMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cross_attention_states: Optional[torch.Tensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ):\n+        bsz, q_len, _ = hidden_states.size()\n+        query_states = self.q_norm(hidden_states)\n+        query_states = self.q_proj(query_states)\n+        query_states = query_states.view(bsz, q_len, self.num_heads, self.head_dim).transpose(1, 2)\n+\n+        if cross_attention_states is not None:\n+            cross_attention_states = self.k_norm(cross_attention_states)\n+            key_states = self.k_proj(cross_attention_states)\n+            value_states = self.v_proj(cross_attention_states)\n+            key_states = key_states.view(bsz, -1, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+            value_states = value_states.view(bsz, -1, self.num_key_value_heads, self.head_dim).transpose(1, 2)\n+            if past_key_values is not None:\n+                key_states, value_states = past_key_values.update(\n+                    key_states, value_states, self.layer_idx, {\"cache_position\": cache_position}\n+                )\n+        elif cache_position[0] != 0:\n+            key_states, value_states = (\n+                past_key_values.layers[self.layer_idx].keys,\n+                past_key_values.layers[self.layer_idx].values,\n+            )\n+        else:\n+            raise ValueError(\n+                \"Cross attention layer can't find neither `cross_attn_states` nor cached values for key/values!\"\n+            )\n+        attention_interface: Callable = eager_attention_forward\n+\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+        attn_output = attn_output.reshape(bsz, q_len, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        attn_output = attn_output + hidden_states\n+        return attn_output, attn_weights\n+\n+\n+@auto_docstring\n+class BltPreTrainedModel(MllamaPreTrainedModel):\n+    config: BltConfig\n+    _supports_attention_backend = False\n+    _no_split_modules = [\"BltTransformerLayer\"]\n+    _can_record_outputs = {\n+        \"hidden_states\": OutputRecorder(BltTransformerLayer, index=0, layer_name=\"local_decoder\"),\n+        \"attentions\": OutputRecorder(BltSelfAttention, index=1, layer_name=\"local_decoder\"),\n+    }\n+\n+    def _init_weights(self, module):\n+        raise AttributeError(\"No need to inherit it!\")\n+\n+    def _update_causal_mask(self, module):\n+        raise AttributeError(\"No need to inherit it!\")\n+\n+    def _prepare_4d_causal_attention_mask_with_cache_position(self, module):\n+        raise AttributeError(\"No need to inherit it!\")\n+\n+\n+class BltLocalEncoder(BltPreTrainedModel):\n+    config: BltLocalEncoderConfig\n+    _can_record_outputs = {\n+        \"encoder_attentions\": OutputRecorder(BltSelfAttention, index=1, layer_name=\"local_encoder\"),\n+    }\n+\n+    def __init__(self, config: BltLocalEncoderConfig):\n+        super().__init__(config)\n+        self.gradient_checkpointing = False\n+        self.config = config\n+        self.layers = nn.ModuleList(\n+            [BltTransformerLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.rotary_emb = BltRotaryEmbedding(config=config)\n+        self.patch_embedding_projection = nn.Linear(\n+            in_features=config.hidden_size,\n+            out_features=config.hidden_size * config.cross_attn_k,\n+            bias=False,\n+        )\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size)\n+        self.cross_attn_layers = nn.ModuleList()\n+        layers_to_add = config.num_hidden_layers if config.cross_attn_all_layers else 1\n+        for layer_idx in range(layers_to_add):\n+            self.cross_attn_layers.append(\n+                BltCrossAttention(config=config, layer_idx=layer_idx, hidden_size=config.hidden_size)\n+            )\n+\n+        self.post_init()\n+\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        patch_embeds: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        encoder_attention_mask: Optional[torch.Tensor] = None,\n+        num_patches: Optional[int] = None,\n+        patch_ids: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ):\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        batch_size = inputs_embeds.shape[0]\n+        hidden_states = F.dropout(inputs_embeds, p=self.config.dropout, training=self.training)\n+\n+        if position_ids is None:\n+            position_ids = (\n+                torch.arange(inputs_embeds.shape[1], device=inputs_embeds.device).unsqueeze(0).expand(batch_size, -1)\n+            )\n+\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+        hidden_states = F.dropout(hidden_states, p=self.config.dropout, training=self.training)\n+\n+        for idx, layer in enumerate(self.layers):\n+            hidden_states = layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=attention_mask,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+            if idx == len(self.layers) - 1 or self.config.cross_attn_all_layers:\n+                patch_embeds = self.patch_reduce(hidden_states, num_patches, patch_ids)\n+                patch_embeds = self.patch_embedding_projection(patch_embeds)\n+                patch_embeds = patch_embeds.reshape(\n+                    batch_size, patch_embeds.shape[1] * self.config.cross_attn_k, self.config.hidden_size\n+                )\n+                layer_idx = idx if self.config.cross_attn_all_layers else 0\n+                cross_attention_output, _ = self.cross_attn_layers[layer_idx](\n+                    hidden_states=patch_embeds,\n+                    cross_attention_states=hidden_states,\n+                    attention_mask=encoder_attention_mask,\n+                    **kwargs,\n+                )\n+                patch_embeds = patch_embeds + cross_attention_output\n+        encoder_cross_states = patch_embeds\n+        return hidden_states, encoder_cross_states\n+\n+    def patch_reduce(self, hidden_states, max_num_patches, patch_ids):\n+        \"\"\"\n+        Reduce variable length patches to single embedding per patch\n+        Note: this works with variable number of patches for different sequences in the batch\n+        It handles variable length patches by assuming that patch_lengths will be 0 for any\n+        extra patches on the *right*. Since there can be a variable number of patches\n+        this function also return the number of patches for each sequence in the batch.\n+        Any embeddings on the right that are not allocated to a patch\n+        (i.e. if the sum(patch_lengths[i]) < seq_len for any i)\n+        will be sent to a dummy patch, which is trimmed before returning.\n+        \"\"\"\n+        batch_size = hidden_states.shape[0]\n+        embedding_dim = hidden_states.shape[-1]\n+\n+        patch_ids = patch_ids.unsqueeze(-1).expand(-1, -1, hidden_states.shape[-1])\n+\n+        reduced_embeddings = torch.zeros(\n+            (batch_size, max_num_patches, embedding_dim), dtype=hidden_states.dtype, device=hidden_states.device\n+        )\n+\n+        reduced_embeddings = reduced_embeddings.scatter_reduce(\n+            src=hidden_states,\n+            dim=1,\n+            index=patch_ids,\n+            reduce=\"amax\",\n+            include_self=False,\n+        )\n+        reduced_embeddings = reduced_embeddings[:, :max_num_patches, :]\n+\n+        return reduced_embeddings\n+\n+\n+class BltLocalDecoder(BltPreTrainedModel):\n+    config: BltLocalDecoderConfig\n+\n+    def __init__(self, config: BltLocalDecoderConfig):\n+        super().__init__(config)\n+        self.gradient_checkpointing = False\n+        self.config = config\n+        self.cross_attn_decoder = True\n+        self.layers = nn.ModuleList(\n+            [BltTransformerLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.rotary_emb = BltRotaryEmbedding(config=config)\n+        self.patch_embedding_projection = nn.Linear(\n+            in_features=config.hidden_size_global,\n+            out_features=config.hidden_size * config.cross_attn_k,\n+            bias=False,\n+        )\n+        self.norm = BltRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.cross_attn_layers = nn.ModuleList()\n+        layers_to_add = config.num_hidden_layers if config.cross_attn_all_layers else 1\n+        for layer_idx in range(layers_to_add):\n+            self.cross_attn_layers.append(\n+                BltCrossAttention(config=config, layer_idx=layer_idx, hidden_size=config.hidden_size)\n+            )\n+\n+        self.post_init()\n+\n+    @check_model_inputs\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+        patch_embeds: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        encoder_attention_mask: Optional[torch.Tensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ):\n+        batch_size = inputs_embeds.shape[0]\n+        hidden_states = inputs_embeds\n+        patch_embeds = self.patch_embedding_projection(patch_embeds)\n+        patch_embeds = patch_embeds.reshape(\n+            batch_size, patch_embeds.shape[1] * self.config.cross_attn_k, self.config.hidden_size\n+        )\n+\n+        if patch_embeds is not None and not self.cross_attn_decoder:\n+            hidden_states = hidden_states + patch_embeds\n+\n+        if position_ids is None:\n+            position_ids = (\n+                torch.arange(inputs_embeds.shape[1], device=inputs_embeds.device).unsqueeze(0).expand(batch_size, -1)\n+            )\n+\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+        hidden_states = F.dropout(hidden_states, p=self.config.dropout, training=self.training)\n+\n+        for i, layer in enumerate(self.layers):\n+            if i == 0 or self.config.cross_attn_all_layers:\n+                cross_attention_output, _ = self.cross_attn_layers[i](\n+                    hidden_states=hidden_states,\n+                    cross_attention_states=patch_embeds,\n+                    attention_mask=encoder_attention_mask,\n+                    **kwargs,\n+                )\n+                hidden_states = hidden_states + cross_attention_output\n+            hidden_states = layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=attention_mask,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+        logits = self.norm(hidden_states)\n+        return logits\n+\n+\n+class BltGlobalTransformer(BltPreTrainedModel):\n+    config: BltGlobalTransformerConfig\n+    _can_record_outputs = {\n+        \"global_attentions\": OutputRecorder(BltSelfAttention, index=1, layer_name=\"global_transformer\"),\n+    }\n+\n+    def __init__(self, config: BltGlobalTransformerConfig):\n+        super().__init__(config)\n+        self.config = config\n+        self.layers = nn.ModuleList()\n+        for layer_idx in range(config.num_hidden_layers):\n+            self.layers.append(BltTransformerLayer(config, layer_idx))\n+        self.rotary_emb = BltRotaryEmbedding(config=config)\n+\n+        # Create token embedding projection (use nn.Identity() when no projection needed)\n+        if getattr(config, \"encoder_cross_output_size\", None) is not None:\n+            self.token_embedding_projection = nn.Linear(\n+                config.encoder_cross_output_size, config.hidden_size, bias=False\n+            )\n+        else:\n+            self.token_embedding_projection = nn.Identity()\n+\n+        self.post_init()\n+\n+    def forward(\n+        self,\n+        input_embeds: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ):\n+        batch_size, seq_len, _ = input_embeds.shape\n+        hidden_states = self.token_embedding_projection(input_embeds)\n+        hidden_states = F.dropout(hidden_states, p=self.config.dropout, training=self.training)\n+        if position_ids is None:\n+            position_ids = (\n+                torch.arange(input_embeds.shape[1], device=input_embeds.device).unsqueeze(0).expand(batch_size, -1)\n+            )\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+        for i, layer in enumerate(self.layers):\n+            hidden_states = layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=attention_mask,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+        return hidden_states\n+\n+\n+class BltPatcher(BltPreTrainedModel):\n+    config: BltPatcherConfig\n+\n+    def __init__(self, config: BltPatcherConfig):\n+        super().__init__(config)\n+        self.rotary_emb = BltRotaryEmbedding(config=self.config)\n+        self.layers = nn.ModuleList()\n+        for layer_idx in range(self.config.num_hidden_layers):\n+            self.layers.append(BltTransformerLayer(self.config, layer_idx))\n+        self.embed_tokens = nn.Embedding(self.config.vocab_size, self.config.hidden_size)\n+        self.norm = BltRMSNorm(self.config.hidden_size, eps=self.config.rms_norm_eps)\n+        self.lm_head = nn.Linear(\n+            self.config.hidden_size,\n+            self.config.vocab_size,\n+            bias=False,\n+        )\n+\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        patch_size: Optional[int] = None,\n+        threshold: Optional[float] = None,\n+        max_patch_length: Optional[int] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ):\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache()\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=position_ids,\n+        )\n+\n+        hidden_states = inputs_embeds\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        for layer in self.layers:\n+            hidden_states = layer(hidden_states, position_embeddings=position_embeddings, attention_mask=causal_mask)\n+\n+        logits = self.lm_head(self.norm(hidden_states))\n+        prediction_entropies = torch.distributions.Categorical(logits=logits).entropy()\n+\n+        batch_size, sequence_length = inputs_embeds.shape[:2]\n+        if patch_size is not None:\n+            patch_lengths = self.patch_lengths_from_entropies(\n+                entropies=prediction_entropies,\n+                sequence_length=sequence_length,\n+                patch_size=patch_size,\n+                threshold=threshold,\n+            )\n+        else:\n+            patch_lengths = torch.ones(\n+                (batch_size, sequence_length), dtype=inputs_embeds.dtype, device=inputs_embeds.device\n+            )\n+        patch_lengths = process_patch_lengths(patch_lengths, max_patch_length)\n+        return prediction_entropies, patch_lengths, logits\n+\n+    @staticmethod\n+    def patch_lengths_from_entropies(\n+        entropies,\n+        sequence_length,\n+        patch_size=None,\n+        threshold=None,\n+    ):\n+        \"\"\"\n+        Computes patch lengths from token entropies.\n+\n+        Depending on whether a threshold is provided, the function uses either:\n+        - Thresholding the entropy values (when `threshold` is set).\n+        \"\"\"\n+\n+        batch_size = entropies.shape[0]\n+\n+        # Always include token 0 and 1 as starting tokens\n+        init_tokens = (\n+            torch.tensor([0, 1], dtype=torch.long, device=entropies.device).unsqueeze(0).repeat(batch_size, 1)\n+        )\n+        offset = init_tokens.shape[1]\n+\n+        # Ignore first token entropy (BOS)\n+        entropies = entropies[:, 1:]\n+\n+        # Threshold the entropy values to define patch start points\n+        patch_mask = entropies > threshold\n+\n+        seq_len = patch_mask.shape[1]\n+\n+        # Create patch IDs (token indices), and add a sentinel to ensure alignment\n+        token_indices = torch.arange(seq_len, device=entropies.device).unsqueeze(0).expand(batch_size, -1)\n+        sentinel = torch.full_like(token_indices, seq_len)\n+        padded_indices = torch.cat([token_indices, sentinel], dim=1)\n+\n+        # Pad mask with inverse to align sentinel correctly\n+        padded_mask = torch.cat([patch_mask, ~patch_mask], dim=1)\n+\n+        # Select indices where mask is True\n+        patch_starts = padded_indices[padded_mask].reshape(batch_size, seq_len)\n+        max_valid_patches = patch_mask.sum(dim=1).max()\n+        patch_starts = patch_starts[:, :max_valid_patches]\n+\n+        # Offset patch starts to account for the two initial tokens\n+        patch_start_ids = torch.cat((init_tokens, patch_starts + offset), dim=1)\n+\n+        # Compute patch end positions by shifting start positions\n+        last_token = torch.full_like(patch_start_ids[:, :1], sequence_length - 1)\n+        patch_ends = torch.cat((patch_start_ids[:, 1:] - 1, last_token), dim=1)\n+\n+        patch_lengths = patch_ends - patch_start_ids + 1\n+\n+        return patch_lengths\n+\n+\n+class BltModel(BltPreTrainedModel):\n+    def __init__(self, config: BltConfig):\n+        super().__init__(config)\n+        self.gradient_checkpointing = False\n+\n+        self.config = config\n+        self.local_encoder = BltLocalEncoder(config.encoder_config)\n+        self.global_transformer = BltGlobalTransformer(config.global_config)\n+        self.local_decoder = BltLocalDecoder(config.decoder_config)\n+        num_embeddings = config.encoder_hash_byte_group_nb_functions * len(config.encoder_hash_byte_group_size)\n+        total_vocab_size = config.encoder_hash_byte_group_vocab * num_embeddings\n+        self.encoder_hash_tok_embedding = nn.Embedding(total_vocab_size, config.encoder_config.hidden_size)\n+        if self.config.patch_in_forward:\n+            self.patcher = BltPatcher(config.patcher_config)\n+            self.patcher.eval()\n+            for param in self.patcher.parameters():\n+                param.requires_grad = False\n+        else:\n+            self.patcher = None\n+        self.post_init()\n+\n+    @check_model_inputs\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        patch_lengths: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> BaseModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        # Extract input embeddings as early as possible\n+        if inputs_embeds is not None:\n+            encoder_embeds = inputs_embeds\n+            batch_size, sequence_length, _ = inputs_embeds.shape\n+        else:\n+            batch_size, sequence_length = input_ids.shape\n+            encoder_embeds = compute_hash_embeddings(\n+                input_ids,\n+                self.local_encoder,\n+                self.encoder_hash_tok_embedding,\n+                self.config.encoder_hash_byte_group_nb_functions,\n+                self.config.encoder_hash_byte_group_size,\n+                self.config.encoder_hash_byte_group_vocab,\n+            )\n+\n+        if patch_lengths is None:\n+            if self.config.patching_mode == \"entropy\" and self.patcher is not None:\n+                if input_ids is None:\n+                    raise ValueError(\"input_ids is required for entropy-based patching\")\n+                _, patch_lengths, _ = self.patcher(\n+                    input_ids,\n+                    patch_size=self.config.patch_size,\n+                    threshold=self.config.patching_threshold,\n+                    max_patch_length=self.config.max_patch_length,\n+                    patching_batch_size=self.config.patching_batch_size,\n+                    device=input_ids.device,\n+                )\n+            else:\n+                device = input_ids.device if input_ids is not None else inputs_embeds.device\n+                dtype = input_ids.dtype if input_ids is not None else inputs_embeds.dtype\n+                patch_lengths = process_patch_lengths(\n+                    torch.ones((batch_size, sequence_length + 1), dtype=dtype, device=device),\n+                    self.config.max_patch_length,\n+                )\n+        patch_ids = self._patch_ids_from_lengths(patch_lengths, sequence_length)\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + encoder_embeds.shape[1], device=encoder_embeds.device\n+            )\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=encoder_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=position_ids,\n+        )\n+\n+        cross_attn_mask_enc = _prepare_patch_cross_attention_mask(\n+            patch_ids, patch_lengths.shape[1], sequence_length, True, self.config.cross_attn_k, encoder_embeds.dtype\n+        )\n+        encoder_hidden_states, encoder_cross_states = self.local_encoder(\n+            input_ids=input_ids,\n+            inputs_embeds=encoder_embeds,\n+            attention_mask=causal_mask,\n+            position_ids=position_ids,\n+            encoder_attention_mask=cross_attn_mask_enc,\n+            num_patches=patch_lengths.shape[1],\n+            patch_ids=patch_ids,\n+            **kwargs,\n+        )\n+        encoder_cross_states = encoder_cross_states.view(batch_size, patch_lengths.shape[1], -1)\n+        global_cache_position = torch.arange(0, encoder_cross_states.shape[1], device=encoder_cross_states.device)\n+        global_position_ids = global_cache_position.unsqueeze(0)\n+        global_causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=encoder_cross_states,\n+            attention_mask=None,\n+            cache_position=global_cache_position,\n+            past_key_values=None,\n+            position_ids=None,\n+        )\n+\n+        global_hidden_states = self.global_transformer(\n+            input_embeds=encoder_cross_states,\n+            attention_mask=global_causal_mask,\n+            position_ids=global_position_ids,\n+            **kwargs,\n+        )\n+        decoder_patch_ids = self._patch_ids_from_lengths(patch_lengths[:, 1:], sequence_length)\n+        cross_attn_mask_dec = _prepare_patch_cross_attention_mask(\n+            decoder_patch_ids,\n+            patch_lengths.shape[1],\n+            sequence_length,\n+            False,\n+            self.config.cross_attn_k,\n+            encoder_embeds.dtype,\n+        )\n+        output = self.local_decoder(\n+            input_ids=input_ids,\n+            inputs_embeds=encoder_hidden_states,\n+            patch_embeds=global_hidden_states,\n+            attention_mask=causal_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            cache_position=cache_position,\n+            encoder_attention_mask=cross_attn_mask_dec,\n+            **kwargs,\n+        )\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=output,\n+            past_key_values=past_key_values,\n+        )\n+\n+    def get_input_embeddings(self):\n+        return self.local_encoder.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.local_encoder.embed_tokens = value\n+\n+    def _patch_ids_from_lengths(self, patch_lengths: torch.Tensor, seq_len: int) -> torch.Tensor:\n+        batch_size = patch_lengths.shape[0]\n+        patch_starts = torch.cat(\n+            [\n+                torch.zeros(batch_size, 1, dtype=patch_lengths.dtype, device=patch_lengths.device),\n+                patch_lengths.cumsum(dim=-1)[:, :-1],\n+            ],\n+            dim=-1,\n+        )\n+        token_positions = torch.arange(seq_len, device=patch_lengths.device)\n+        return (patch_starts.unsqueeze(1) <= token_positions.unsqueeze(0).unsqueeze(-1)).sum(dim=-1) - 1\n+\n+\n+class BltForCausalLM(MllamaForCausalLM):\n+    config: BltConfig\n+    _can_compile_fullgraph = False\n+    base_model_prefix = \"model\"\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+\n+    def __init__(self, config: BltConfig):\n+        super().__init__(config)\n+        self.vocab_size = config.vocab_size\n+        self.model = BltModel(config)\n+        self.lm_head = nn.Linear(config.decoder_config.hidden_size, config.vocab_size, bias=False)\n+        self.post_init()\n+\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        cross_attention_states: Optional[torch.LongTensor] = None,  # Keep for compatibility\n+        cross_attention_mask: Optional[torch.LongTensor] = None,\n+        full_text_row_masked_out_mask: Optional[tuple[torch.Tensor, torch.Tensor]] = None,\n+        past_key_values: Optional[Union[Cache, list[torch.FloatTensor]]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, CausalLMOutputWithPast]:\n+        # Call parent forward but exclude cross_attention_states from model call\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            cross_attention_mask=cross_attention_mask,\n+            full_text_row_masked_out_mask=full_text_row_masked_out_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs.last_hidden_state\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :]).float()\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits, labels, self.vocab_size, **kwargs)\n+\n+        return CausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+\n+__all__ = [\n+    \"BltPreTrainedModel\",\n+    \"BltModel\",\n+    \"BltPatcher\",\n+    \"BltForCausalLM\",\n+]"
        },
        {
            "sha": "4757d4b69c6cabdd1ba7a0e2b1fdafbda7991c2a",
            "filename": "tests/causal_lm_tester.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/tests%2Fcausal_lm_tester.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/tests%2Fcausal_lm_tester.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fcausal_lm_tester.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -497,7 +497,7 @@ def _config_supports_rope_scaling(config: PretrainedConfig) -> bool:\n     # Has rope_theta (and no rope_scaling) -> probably an older model, but should support rope scaling as well\n     main_config_has_rope = hasattr(config, \"rope_scaling\") or hasattr(config, \"rope_theta\")\n     sub_config_has_rope = any(\n-        hasattr(config[sub_config], \"rope_scaling\") or hasattr(config[sub_config], \"rope_theta\")\n+        hasattr(getattr(config, sub_config), \"rope_scaling\") or hasattr(getattr(config, sub_config), \"rope_theta\")\n         for sub_config in config.sub_configs.keys()\n     )\n     return main_config_has_rope or sub_config_has_rope"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/blt/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/tests%2Fmodels%2Fblt%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/tests%2Fmodels%2Fblt%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fblt%2F__init__.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69"
        },
        {
            "sha": "dc470397478184515042e4c49fed95a22df7b676",
            "filename": "tests/models/blt/test_modeling_blt.py",
            "status": "added",
            "additions": 561,
            "deletions": 0,
            "changes": 561,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/tests%2Fmodels%2Fblt%2Ftest_modeling_blt.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/tests%2Fmodels%2Fblt%2Ftest_modeling_blt.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fblt%2Ftest_modeling_blt.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -0,0 +1,561 @@\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch Blt model.\"\"\"\n+\n+import unittest\n+\n+import pytest\n+from parameterized import parameterized\n+\n+from transformers import AutoTokenizer, is_torch_available, set_seed\n+from transformers.testing_utils import (\n+    cleanup,\n+    require_read_token,\n+    require_torch,\n+    require_torch_accelerator,\n+    require_torch_bf16,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...causal_lm_tester import CausalLMModelTest, CausalLMModelTester\n+from ...test_modeling_common import (\n+    TEST_EAGER_MATCHES_SDPA_INFERENCE_PARAMETERIZATION,\n+    _test_eager_matches_sdpa_inference,\n+    ids_tensor,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import BltConfig, BltForCausalLM, BltModel\n+from transformers.models.blt.modeling_blt import BltRotaryEmbedding\n+\n+\n+class BltModelTester(CausalLMModelTester):\n+    if is_torch_available():\n+        config_class = BltConfig\n+        base_model_class = BltModel\n+        causal_lm_class = BltForCausalLM\n+\n+    def __init__(\n+        self,\n+        parent,\n+        ignore_index=-100,\n+        seq_length=7,\n+        is_training=True,\n+    ):\n+        super().__init__(parent)\n+        self.parent = parent\n+        self.ignore_index = ignore_index\n+        self.seq_length = seq_length\n+        self.is_training = is_training\n+        self.batch_size = 3\n+\n+        # Common parameters for all configs\n+        self.hidden_size = 16\n+        self.num_hidden_layers = 1\n+        self.num_attention_heads = 2\n+        self.num_key_value_heads = 2\n+        self.intermediate_size = 32\n+        self.hidden_act = \"silu\"\n+        self.max_position_embeddings = 32\n+        self.vocab_size = 32\n+        self.rope_theta = 500000.0\n+        self.rope_scaling = {\"rope_type\": \"default\"}\n+        self.rms_norm_eps = 1e-5\n+        self.dropout = 0.0\n+        self.encoder_hash_byte_group_size = [2, 3]\n+        self.encoder_hash_byte_group_vocab = 64\n+        self.encoder_hash_byte_group_nb_functions = 1\n+        # Common parameters for all configs\n+        self.patcher_config = {\n+            \"hidden_size\": self.hidden_size,\n+            \"num_hidden_layers\": self.num_hidden_layers,\n+            \"num_attention_heads\": self.num_attention_heads,\n+            \"num_key_value_heads\": self.num_key_value_heads,\n+            \"intermediate_size\": self.intermediate_size,\n+            \"max_position_embeddings\": self.max_position_embeddings,\n+            \"rope_theta\": self.rope_theta,\n+            \"rope_scaling\": self.rope_scaling,\n+            \"hidden_act\": self.hidden_act,\n+            \"rms_norm_eps\": self.rms_norm_eps,\n+            \"dropout\": self.dropout,\n+        }\n+\n+        self.encoder_config = {\n+            \"hidden_size\": self.hidden_size,\n+            \"num_hidden_layers\": self.num_hidden_layers,\n+            \"num_attention_heads\": self.num_attention_heads,\n+            \"num_key_value_heads\": self.num_key_value_heads,\n+            \"intermediate_size\": self.intermediate_size,\n+            \"max_position_embeddings\": self.max_position_embeddings,\n+            \"rope_theta\": self.rope_theta,\n+            \"rope_scaling\": self.rope_scaling,\n+            \"hidden_act\": self.hidden_act,\n+            \"rms_norm_eps\": self.rms_norm_eps,\n+            \"dropout\": self.dropout,\n+        }\n+\n+        self.decoder_config = {\n+            \"vocab_size\": self.vocab_size,\n+            \"hidden_size\": self.hidden_size,\n+            \"hidden_size_global\": self.hidden_size * 2,  # Must match global transformer output size\n+            \"num_hidden_layers\": self.num_hidden_layers,\n+            \"num_attention_heads\": self.num_attention_heads,\n+            \"num_key_value_heads\": self.num_key_value_heads,\n+            \"intermediate_size\": self.intermediate_size,\n+            \"max_position_embeddings\": self.max_position_embeddings,\n+            \"rope_theta\": self.rope_theta,\n+            \"rope_scaling\": self.rope_scaling,\n+            \"hidden_act\": self.hidden_act,\n+            \"rms_norm_eps\": self.rms_norm_eps,\n+            \"dropout\": self.dropout,\n+        }\n+\n+        self.global_config = {\n+            \"hidden_size\": self.hidden_size * 2,  # Double the hidden size for global transformer\n+            \"num_hidden_layers\": self.num_hidden_layers,\n+            \"num_attention_heads\": self.num_attention_heads,\n+            \"num_key_value_heads\": self.num_key_value_heads,\n+            \"intermediate_size\": self.intermediate_size,\n+            \"max_position_embeddings\": self.max_position_embeddings,\n+            \"rope_theta\": self.rope_theta,\n+            \"rope_scaling\": self.rope_scaling,\n+            \"hidden_act\": self.hidden_act,\n+            \"rms_norm_eps\": self.rms_norm_eps,\n+            \"dropout\": self.dropout,\n+        }\n+\n+        self.num_hidden_layers = self.encoder_config[\"num_hidden_layers\"]\n+\n+    def get_config(self):\n+        config = BltConfig(\n+            vocab_size=self.vocab_size,\n+            max_position_embeddings=self.max_position_embeddings,\n+            patch_in_forward=False,  # Disable patching for tests\n+            patch_size=4,\n+            patching_mode=\"entropy\",\n+            patching_threshold=1.335442066192627,\n+            patching_batch_size=1,\n+            max_patch_length=None,\n+            cross_attn_k=2,\n+            encoder_hash_byte_group_size=self.encoder_hash_byte_group_size,\n+            encoder_hash_byte_group_vocab=self.encoder_hash_byte_group_vocab,\n+            encoder_hash_byte_group_nb_functions=self.encoder_hash_byte_group_nb_functions,\n+            patcher_config=self.patcher_config,\n+            encoder_config=self.encoder_config,\n+            decoder_config=self.decoder_config,\n+            global_config=self.global_config,\n+            rope_scaling=self.rope_scaling,\n+            tie_word_embeddings=False,\n+        )\n+\n+        config.num_attention_heads = config.decoder_config.num_attention_heads\n+        config.num_hidden_layers = config.encoder_config.num_hidden_layers\n+        config.hidden_size = config.decoder_config.hidden_size\n+\n+        return config\n+\n+\n+@require_torch\n+class BltModelTest(CausalLMModelTest, unittest.TestCase):\n+    all_model_classes = (\n+        (\n+            BltModel,\n+            BltForCausalLM,\n+        )\n+        if is_torch_available()\n+        else ()\n+    )\n+    pipeline_model_mapping = (\n+        {\n+            \"feature-extraction\": BltModel,\n+            \"text-generation\": BltForCausalLM,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+    test_headmasking = False\n+    test_pruning = False\n+    fx_compatible = False\n+    model_tester_class = BltModelTester\n+    rotary_embedding_layer = BltRotaryEmbedding  # Enables RoPE tests if set\n+\n+    # Need to use `0.8` instead of `0.9` for `test_cpu_offload`\n+    # This is because we are hitting edge cases with the causal_mask buffer\n+    model_split_percents = [0.5, 0.7, 0.8]\n+\n+    # used in `test_torch_compile_for_training`\n+    _torch_compile_train_cls = BltForCausalLM if is_torch_available() else None\n+\n+    @pytest.mark.generate\n+    @parameterized.expand([(\"greedy\", 1), (\"beam search\", 2)])\n+    @unittest.skip(\n+        \"Blt requires real token IDs for its hash-based embedding computation, making inputs_embeds generation incompatible with identical outputs\"\n+    )\n+    def test_generate_from_inputs_embeds(self, _, num_beams):\n+        pass\n+\n+    @pytest.mark.generate\n+    @unittest.skip(\n+        \"Blt requires real token IDs for its hash-based embedding computation, making inputs_embeds generation incompatible with identical outputs\"\n+    )\n+    def test_inputs_embeds_matches_input_ids(self):\n+        pass\n+\n+    @parameterized.expand(TEST_EAGER_MATCHES_SDPA_INFERENCE_PARAMETERIZATION)\n+    def test_eager_matches_sdpa_inference(\n+        self,\n+        name,\n+        torch_dtype,\n+        padding_side,\n+        use_attention_mask,\n+        output_attentions,\n+        enable_kernels,\n+    ):\n+        \"We need to relax a bit the `atols` for fp32 here due to the altup projections\"\n+        atols = {\n+            (\"cpu\", False, torch.float32): 2e-2,  # this was relaxed\n+            (\"cpu\", False, torch.float16): 5e-3,\n+            (\"cpu\", False, torch.bfloat16): 1e-2,\n+            (\"cpu\", True, torch.float32): 2e-2,  # this was relaxed\n+            (\"cpu\", True, torch.float16): 5e-3,\n+            (\"cpu\", True, torch.bfloat16): 1e-2,\n+            (\"cuda\", False, torch.float32): 2e-2,  # this was relaxed\n+            (\"cuda\", False, torch.bfloat16): 1e-2,\n+            (\"cuda\", False, torch.float16): 5e-3,\n+            (\"cuda\", True, torch.float32): 2e-2,  # this was relaxed\n+            (\"cuda\", True, torch.bfloat16): 1e-2,\n+            (\"cuda\", True, torch.float16): 5e-3,\n+        }\n+        _test_eager_matches_sdpa_inference(\n+            self, name, torch_dtype, padding_side, use_attention_mask, output_attentions, enable_kernels, atols=atols\n+        )\n+\n+    @parameterized.expand([(\"linear\",), (\"dynamic\",), (\"yarn\",)])\n+    def test_model_rope_scaling_from_config(self, scaling_type):\n+        \"\"\"Override rope scaling from config test to handle Blt's sub-config structure.\"\"\"\n+        if self.rotary_embedding_layer is None:\n+            self.skipTest(\"Rotary embedding layer not set\")\n+        config, _ = self.model_tester.prepare_config_and_inputs_for_common()\n+        short_input = ids_tensor([1, 10], config.vocab_size)\n+        long_input = ids_tensor([1, int(config.max_position_embeddings * 1.5)], config.vocab_size)\n+\n+        set_seed(42)  # Fixed seed at init time so the two models get the same random weights\n+        original_model = self.model_tester_class.base_model_class(config)\n+        original_model.to(torch_device)\n+        original_model.eval()\n+        original_short_output = original_model(short_input).last_hidden_state\n+        original_long_output = original_model(long_input).last_hidden_state\n+\n+        set_seed(42)  # Fixed seed at init time so the two models get the same random weights\n+        config.rope_scaling = {\"rope_type\": scaling_type, \"factor\": 10.0}\n+        # Propagate rope_scaling to sub-configs for Blt\n+        config.encoder_config.rope_scaling = config.rope_scaling\n+        config.decoder_config.rope_scaling = config.rope_scaling\n+        config.global_config.rope_scaling = config.rope_scaling\n+        config.patcher_config.rope_scaling = config.rope_scaling\n+\n+        scaled_model = self.model_tester_class.base_model_class(config)\n+        scaled_model.to(torch_device)\n+        scaled_model.eval()\n+        scaled_short_output = scaled_model(short_input).last_hidden_state\n+        scaled_long_output = scaled_model(long_input).last_hidden_state\n+\n+        # Dynamic scaling does not change the RoPE embeddings until it receives an input longer than the original\n+        # maximum sequence length, so the outputs for the short input should match.\n+        if scaling_type == \"dynamic\":\n+            torch.testing.assert_close(original_short_output, scaled_short_output, rtol=1e-5, atol=1e-5)\n+        else:\n+            self.assertFalse(torch.allclose(original_short_output, scaled_short_output, atol=1e-5))\n+\n+        self.assertFalse(torch.allclose(original_long_output, scaled_long_output, atol=1e-5))\n+\n+    @unittest.skip(reason=\"Decoder cannot keep gradients\")\n+    def test_flex_attention_with_grads():\n+        pass\n+\n+\n+@require_torch_accelerator\n+class BltIntegrationTest(unittest.TestCase):\n+    def tearDown(self):\n+        # TODO (joao): automatic compilation, i.e. compilation when `cache_implementation=\"static\"` is used, leaves\n+        # some memory allocated in the cache, which means some object is not being released properly. This causes some\n+        # unoptimal memory usage, e.g. after certain tests a 7B model in FP16 no longer fits in a 24GB GPU.\n+        # Investigate the root cause.\n+        cleanup(torch_device, gc_collect=False)\n+\n+    @slow\n+    @require_read_token\n+    def test_model(self):\n+        NUM_TOKENS_TO_GENERATE = 200\n+        EXPECTED_TEXT = \"my name is alex and i am a student at the university of michigan. i am a senior majoring in computer science and minoring in mathematics. i am also a member of the michigan math club and the michigan computer s\"\n+\n+        prompt = \"my name is\"\n+\n+        model = BltForCausalLM.from_pretrained(\"itazap/blt-1b-hf\", device_map=\"auto\", attn_implementation=\"sdpa\")\n+\n+        tokenizer = AutoTokenizer.from_pretrained(\"itazap/blt-1b-hf\")\n+\n+        inputs = tokenizer(prompt, return_tensors=\"pt\").to(model.device)\n+\n+        generated_ids = model.generate(\n+            **inputs, max_new_tokens=NUM_TOKENS_TO_GENERATE, do_sample=False, use_cache=False\n+        )\n+\n+        output_text = tokenizer.decode(generated_ids[0], skip_special_tokens=True)\n+        self.assertEqual(output_text, EXPECTED_TEXT)\n+\n+    @slow\n+    @require_read_token\n+    def test_model_logits(self):\n+        EXPECTED_OUTPUT = torch.tensor(\n+            [\n+                [\n+                    -10.4948,\n+                    -10.7065,\n+                    -6.1813,\n+                    -10.5545,\n+                    -10.3428,\n+                    -9.1493,\n+                    -8.4937,\n+                    -8.6382,\n+                    -9.2159,\n+                    -9.5907,\n+                    -9.3679,\n+                    -8.4184,\n+                    -9.0655,\n+                    -3.4436,\n+                    2.9616,\n+                    -10.3157,\n+                    -6.3723,\n+                    -6.0133,\n+                    -9.7100,\n+                    -9.2128,\n+                    -8.8064,\n+                    -9.8179,\n+                    -9.7516,\n+                    -9.4681,\n+                    -9.7715,\n+                    -9.4897,\n+                    -9.0491,\n+                    -9.8098,\n+                    -9.4648,\n+                    -9.3294,\n+                ],\n+                [\n+                    -13.3010,\n+                    -13.1910,\n+                    -5.7230,\n+                    -13.2895,\n+                    -13.4864,\n+                    -8.7140,\n+                    -7.0275,\n+                    -7.0182,\n+                    -10.1362,\n+                    -10.3762,\n+                    -9.9086,\n+                    -7.8049,\n+                    -8.8660,\n+                    -5.2711,\n+                    -3.5778,\n+                    -12.5346,\n+                    -9.1609,\n+                    -6.7925,\n+                    -10.3717,\n+                    -9.2650,\n+                    -10.6393,\n+                    -11.4807,\n+                    -11.2128,\n+                    -10.9615,\n+                    -10.5806,\n+                    -10.8873,\n+                    -11.0651,\n+                    -11.3471,\n+                    -10.5437,\n+                    -9.9688,\n+                ],\n+            ]\n+        ).to(torch_device)\n+\n+        input_ids = [1, 42, 21, 12, 43, 23, 1, 4]\n+\n+        model = BltForCausalLM.from_pretrained(\"itazap/blt-1b-hf\", attn_implementation=\"sdpa\", device_map=\"auto\")\n+\n+        with torch.no_grad():\n+            output = model(torch.tensor([input_ids]).to(torch_device))[0]\n+\n+        torch.testing.assert_close(EXPECTED_OUTPUT, output[0, :2, :30], rtol=1e-4, atol=1e-4)\n+\n+    @slow\n+    @require_read_token\n+    @require_torch_bf16\n+    def test_model_bf16(self):\n+        \"\"\"Test Blt model with bfloat16 precision.\"\"\"\n+        NUM_TOKENS_TO_GENERATE = 200\n+        EXPECTED_TEXT = \"my name is alex and i am a student at the university of michigan. i am a senior majoring in computer science and minoring in mathematics. i am also a member of the michigan math club and the michigan computer s\"\n+\n+        prompt = \"my name is\"\n+\n+        model = BltForCausalLM.from_pretrained(\n+            \"itazap/blt-1b-hf\", device_map=\"auto\", attn_implementation=\"sdpa\", torch_dtype=torch.bfloat16\n+        )\n+\n+        tokenizer = AutoTokenizer.from_pretrained(\"itazap/blt-1b-hf\")\n+\n+        inputs = tokenizer(prompt, return_tensors=\"pt\").to(model.device)\n+\n+        generated_ids = model.generate(\n+            **inputs, max_new_tokens=NUM_TOKENS_TO_GENERATE, do_sample=False, use_cache=False\n+        )\n+\n+        output_text = tokenizer.decode(generated_ids[0], skip_special_tokens=True)\n+        self.assertEqual(output_text, EXPECTED_TEXT)\n+\n+    @slow\n+    @require_read_token\n+    @require_torch_bf16\n+    def test_model_logits_bf16(self):\n+        \"\"\"Test Blt model logits with bfloat16 precision.\"\"\"\n+\n+        EXPECTED_OUTPUT = torch.tensor(\n+            [\n+                [\n+                    -10.5000,\n+                    -10.6875,\n+                    -6.1875,\n+                    -10.5625,\n+                    -10.3125,\n+                    -9.1875,\n+                    -8.5000,\n+                    -8.6875,\n+                    -9.1875,\n+                    -9.5625,\n+                    -9.3750,\n+                    -8.5000,\n+                    -9.0625,\n+                    -3.4219,\n+                    2.9531,\n+                    -10.3125,\n+                    -6.4062,\n+                    -6.0000,\n+                    -9.6875,\n+                    -9.1875,\n+                    -8.8125,\n+                    -9.8125,\n+                    -9.7500,\n+                    -9.4375,\n+                    -9.8125,\n+                    -9.5000,\n+                    -9.0000,\n+                    -9.8125,\n+                    -9.4375,\n+                    -9.3125,\n+                ],\n+                [\n+                    -13.2500,\n+                    -13.1875,\n+                    -5.6875,\n+                    -13.3125,\n+                    -13.5000,\n+                    -8.7500,\n+                    -7.0625,\n+                    -7.0312,\n+                    -10.1250,\n+                    -10.3750,\n+                    -9.8750,\n+                    -7.8438,\n+                    -8.8750,\n+                    -5.2812,\n+                    -3.5625,\n+                    -12.5000,\n+                    -9.1875,\n+                    -6.8125,\n+                    -10.3750,\n+                    -9.3125,\n+                    -10.6250,\n+                    -11.5000,\n+                    -11.2500,\n+                    -11.0000,\n+                    -10.5625,\n+                    -10.8750,\n+                    -11.0625,\n+                    -11.3750,\n+                    -10.5625,\n+                    -10.0000,\n+                ],\n+            ]\n+        ).to(torch_device)\n+\n+        input_ids = [1, 42, 21, 12, 43, 23, 1, 4]\n+\n+        model = BltForCausalLM.from_pretrained(\n+            \"itazap/blt-1b-hf\", device_map=\"auto\", attn_implementation=\"sdpa\", torch_dtype=torch.bfloat16\n+        )\n+\n+        with torch.no_grad():\n+            output = model(torch.tensor([input_ids]).to(torch_device))[0]\n+\n+        torch.testing.assert_close(EXPECTED_OUTPUT, output[0, :2, :30], rtol=1e-3, atol=1e-3)\n+\n+    @slow\n+    @require_read_token\n+    def test_model_eager(self):\n+        \"\"\"Test Blt model with bfloat16 precision using eager attention implementation.\"\"\"\n+        NUM_TOKENS_TO_GENERATE = 200\n+        EXPECTED_TEXT = \"my name is alex and i am a student at the university of michigan. i am a senior majoring in computer science and minoring in mathematics. i am also a member of the michigan math club and the michigan computer s\"\n+\n+        prompt = \"my name is\"\n+\n+        model = BltForCausalLM.from_pretrained(\"itazap/blt-1b-hf\", device_map=\"auto\", attn_implementation=\"eager\")\n+\n+        tokenizer = AutoTokenizer.from_pretrained(\"itazap/blt-1b-hf\")\n+\n+        inputs = tokenizer(prompt, return_tensors=\"pt\").to(model.device)\n+\n+        generated_ids = model.generate(\n+            **inputs, max_new_tokens=NUM_TOKENS_TO_GENERATE, do_sample=False, use_cache=False\n+        )\n+\n+        output_text = tokenizer.decode(generated_ids[0], skip_special_tokens=True)\n+        self.assertEqual(output_text, EXPECTED_TEXT)\n+\n+    @slow\n+    @require_read_token\n+    @require_torch_bf16\n+    def test_model_bf16_static_cache(self):\n+        \"\"\"Test Blt model with bfloat16 precision and static cache.\"\"\"\n+        NUM_TOKENS_TO_GENERATE = 200\n+        EXPECTED_TEXT = \"my name is alex and i am a student at the university of michigan. i am a senior majoring in computer science and minoring in mathematics. i am also a member of the michigan math club and the michigan computer s\"\n+\n+        prompt = \"my name is\"\n+\n+        model = BltForCausalLM.from_pretrained(\n+            \"itazap/blt-1b-hf\", device_map=\"auto\", attn_implementation=\"sdpa\", torch_dtype=torch.bfloat16\n+        )\n+\n+        model.generation_config.cache_implementation = \"static\"\n+\n+        tokenizer = AutoTokenizer.from_pretrained(\"itazap/blt-1b-hf\")\n+\n+        inputs = tokenizer(prompt, return_tensors=\"pt\").to(model.device)\n+\n+        generated_ids = model.generate(\n+            **inputs, max_new_tokens=NUM_TOKENS_TO_GENERATE, do_sample=False, use_cache=False\n+        )\n+\n+        output_text = tokenizer.decode(generated_ids[0], skip_special_tokens=True)\n+        self.assertEqual(output_text, EXPECTED_TEXT)"
        },
        {
            "sha": "37bc980e745cb23976423ce00236495a448498b4",
            "filename": "utils/check_docstrings.py",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/utils%2Fcheck_docstrings.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/utils%2Fcheck_docstrings.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_docstrings.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -128,6 +128,8 @@\n     \"BlipVisionConfig\",\n     \"BloomConfig\",\n     \"BloomTokenizerFast\",\n+    \"BLTConfig\",\n+    \"BLTPatcherConfig\",\n     \"BridgeTowerTextConfig\",\n     \"BridgeTowerVisionConfig\",\n     \"BrosModel\",\n@@ -460,6 +462,8 @@\n     \"ZeroShotImageClassificationPipeline\",\n     \"ZeroShotObjectDetectionPipeline\",\n     \"Llama4TextConfig\",\n+    \"BltConfig\",\n+    \"BltPatcherConfig\",\n }\n # In addition to the objects above, we also ignore objects with certain prefixes. If you add an item to the list\n # below, make sure to add a comment explaining why."
        },
        {
            "sha": "29bd3dfc35862408307a778edeb4d0fde620c9bb",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/huggingface/transformers/blob/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/ddfa3d4402915b8aafd82b3135cb37af9a5d6b69/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=ddfa3d4402915b8aafd82b3135cb37af9a5d6b69",
            "patch": "@@ -96,6 +96,9 @@\n     \"Glm4vVisionModel\",\n     \"Glm4vMoeVisionModel\",\n     \"EvollaSaProtPreTrainedModel\",\n+    \"BltLocalEncoder\",  # Building part of bigger (tested) model. Tested implicitly through BLTForCausalLM.\n+    \"BltLocalDecoder\",  # Building part of bigger (tested) model. Tested implicitly through BLTForCausalLM.\n+    \"BltGlobalTransformer\",  # Building part of bigger (tested) model. Tested implicitly through BLTForCausalLM.\n     \"Ovis2VisionModel\",\n ]\n \n@@ -170,6 +173,10 @@\n         \"CsmDepthDecoderForCausalLM\",  # Building part of bigger (tested) model. Tested implicitly through CsmForConditionalGenerationIntegrationTest.\n         \"CsmDepthDecoderModel\",  # Building part of bigger (tested) model. Tested implicitly through CsmForConditionalGenerationIntegrationTest.\n         \"CsmBackboneModel\",  # Building part of bigger (tested) model. Tested implicitly through CsmForConditionalGenerationIntegrationTest.\n+        \"BltPatcher\",  # Building part of bigger (tested) model. Tested implicitly through BLTForCausalLM.\n+        \"BltLocalEncoder\",  # Building part of bigger (tested) model. Tested implicitly through BLTForCausalLM.\n+        \"BltLocalDecoder\",  # Building part of bigger (tested) model. Tested implicitly through BLTForCausalLM.\n+        \"BltGlobalTransformer\",  # Building part of bigger (tested) model. Tested implicitly through BLTForCausalLM.\n         \"Florence2VisionBackbone\",  # Building part of bigger (tested) model. Tested implicitly through Florence2ForConditionalGeneration.\n     ]\n )\n@@ -360,6 +367,7 @@\n     \"CsmDepthDecoderModel\",  # Building part of a bigger model\n     \"CsmDepthDecoderForCausalLM\",  # Building part of a bigger model\n     \"CsmForConditionalGeneration\",  # Building part of a bigger model\n+    \"BltPatcher\",  # Building part of a bigger model, tested implicitly through BltForCausalLM\n     \"Florence2VisionBackbone\",  # Building part of a bigger model\n ]\n \n@@ -1006,6 +1014,9 @@ def ignore_undocumented(name: str) -> bool:\n     # MMBT model does not really work.\n     if name.startswith(\"MMBT\"):\n         return True\n+    # BLT models are internal building blocks, tested implicitly through BltForCausalLM\n+    if name.startswith(\"Blt\"):\n+        return True\n     if name in SHOULD_HAVE_THEIR_OWN_PAGE:\n         return True\n     return False"
        }
    ],
    "stats": {
        "total": 3935,
        "additions": 3934,
        "deletions": 1
    }
}