{
    "author": "rogeryoungh",
    "message": "Add support for MiniMax-M2 (#42028)\n\n* update: init m2\n\nSigned-off-by: xuebi <xuebi@minimaxi.com>\n\n* update: docs and config\n\nSigned-off-by: xuebi <xuebi@minimaxi.com>\n\n* update: init minimax-m2 test\n\nSigned-off-by: xuebi <xuebi@minimaxi.com>\n\n* update: fix tests\n\nSigned-off-by: xuebi <xuebi@minimaxi.com>\n\n* update: use partial_rotary_factor\n\nSigned-off-by: xuebi <xuebi@minimaxi.com>\n\n* update: some fix\n\nSigned-off-by: xuebi <xuebi@minimaxi.com>\n\n* fix: import Unpack from processing_utils\n\nSigned-off-by: xuebi <xuebi@minimaxi.com>\n\n* update: apply suggestions from code review\n\nCo-authored-by: Pablo Montalvo <39954772+molbap@users.noreply.github.com>\n\n* update: remove MiniMaxM2DecoderLayer and MiniMaxM2MLP\n\nSigned-off-by: xuebi <xuebi@minimaxi.com>\n\n* update: remove use_qk_norm\n\n* update: remove unused use_qk_norm\n\n* update: update config and attention\n\n* update: add to tokenization_auto and remove unused test\n\n* update: fix decoder layer and experts\n\n* update: fix docs\n\n* update: make ci happy\n\n* refactor: use mapping\n\n* update: remove unused comments\n\n* update: fix rope_params and router\n\n* update: remove rope_theta\n\n* update: test_load_balancing_loss\n\n* update: docs\n\n* update: fix default theta\n\n* update to proper default values, proper config rope, simplified modular\n\n* fix docs\n\n* modular fixup\n\n* review comments\n\n* update slow tests\n\n* style\n\n* fp32 strict\n\n* revert the flag\n\n* sync with latest changes\n\n* fixup buffer init\n\n* add cache exception to minimax m2 as we have a naming clash\n\n* fix dtype issue in gate\n\n* lift fp8 test restriction and apply new linter rules\n\n* update docs\n\n---------\n\nSigned-off-by: xuebi <xuebi@minimaxi.com>\nCo-authored-by: xuebi <xuebi@minimaxi.com>\nCo-authored-by: Pablo Montalvo <39954772+molbap@users.noreply.github.com>\nCo-authored-by: vasqu <antonprogamer@gmail.com>\nCo-authored-by: Anton Vlasjuk <73884904+vasqu@users.noreply.github.com>",
    "sha": "7a2bf25f36264f3f5409d2743722e4f6b3504e86",
    "files": [
        {
            "sha": "58a9809b068f1a1c57313b0d9b4dc7b8b8c5755b",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -601,6 +601,8 @@\n         title: MegatronGPT2\n       - local: model_doc/minimax\n         title: MiniMax\n+      - local: model_doc/minimax_m2\n+        title: MiniMax-M2\n       - local: model_doc/ministral\n         title: Ministral\n       - local: model_doc/ministral3"
        },
        {
            "sha": "a2d5a781c2518d161ce9526db3d545db04eed2b7",
            "filename": "docs/source/en/model_doc/minimax.md",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/docs%2Fsource%2Fen%2Fmodel_doc%2Fminimax.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/docs%2Fsource%2Fen%2Fmodel_doc%2Fminimax.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fminimax.md?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -17,6 +17,8 @@ rendered properly in your Markdown viewer.\n \n # MiniMax\n \n+> [MiniMax-M2](https://huggingface.co/docs/transformers/en/model_doc/minimax_m2) was released on 2025â€‘10â€‘27. We recommend using MiniMaxâ€‘M2 for most use cases due to better overall performance.\n+\n ## Overview\n \n The MiniMax-Text-01 model was proposed in [MiniMax-01: Scaling Foundation Models with Lightning Attention](https://huggingface.co/papers/2501.08313) by MiniMax, Aonian Li, Bangwei Gong, Bo Yang, Boji Shan, Chang Liu, Cheng Zhu, Chunhao Zhang, Congchao Guo, Da Chen, Dong Li, Enwei Jiao, Gengxin Li, Guojun Zhang, Haohai Sun, Houze Dong, Jiadai Zhu, Jiaqi Zhuang, Jiayuan Song, Jin Zhu, Jingtao Han, Jingyang Li, Junbin Xie, Junhao Xu, Junjie Yan, Kaishun Zhang, Kecheng Xiao, Kexi Kang, Le Han, Leyang Wang, Lianfei Yu, Liheng Feng, Lin Zheng, Linbo Chai, Long Xing, Meizhi Ju, Mingyuan Chi, Mozhi Zhang, Peikai Huang, Pengcheng Niu, Pengfei Li, Pengyu Zhao, Qi Yang, Qidi Xu, Qiexiang Wang, Qin Wang, Qiuhui Li, Ruitao Leng, Shengmin Shi, Shuqi Yu, Sichen Li, Songquan Zhu, Tao Huang, Tianrun Liang, Weigao Sun, Weixuan Sun, Weiyu Cheng, Wenkai Li, Xiangjun Song, Xiao Su, Xiaodong Han, Xinjie Zhang, Xinzhu Hou, Xu Min, Xun Zou, Xuyang Shen, Yan Gong, Yingjie Zhu, Yipeng Zhou, Yiran Zhong, Yongyi Hu, Yuanxiang Fan, Yue Yu, Yufeng Yang, Yuhao Li, Yunan Huang, Yunji Li, Yunpeng Huang, Yunzhi Xu, Yuxin Mao, Zehan Li, Zekang Li, Zewei Tao, Zewen Ying, Zhaoyang Cong, Zhen Qin, Zhenhua Fan, Zhihang Yu, Zhuo Jiang, Zijia Wu."
        },
        {
            "sha": "56e518644b80d397fe445e42a7fe44baa5219a3c",
            "filename": "docs/source/en/model_doc/minimax_m2.md",
            "status": "added",
            "additions": 69,
            "deletions": 0,
            "changes": 69,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/docs%2Fsource%2Fen%2Fmodel_doc%2Fminimax_m2.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/docs%2Fsource%2Fen%2Fmodel_doc%2Fminimax_m2.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fminimax_m2.md?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -0,0 +1,69 @@\n+<!--Copyright 2025 the HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be rendered properly in your Markdown viewer.\n+\n+-->\n+\n+\n+# MiniMax-M2\n+\n+## Overview\n+\n+MiniMax-M2 is a compact, fast, and cost-effective MoE model (230 billion total parameters with 10 billion active parameters) built for elite performance in coding and agentic tasks, all while maintaining powerful general intelligence. With just 10 billion activated parameters, MiniMax-M2 provides the sophisticated, end-to-end tool use performance expected from today's leading models, but in a streamlined form factor that makes deployment and scaling easier than ever.\n+\n+For more details refer to the [release blog post](https://www.minimax.io/news/minimax-m2).\n+\n+## Usage examples\n+\n+```python\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+model = AutoModelForCausalLM.from_pretrained(\n+    \"MiniMaxAI/MiniMax-M2\",\n+    device_map=\"auto\",\n+    revision=\"refs/pr/52\",\n+)\n+\n+tokenizer = AutoTokenizer.from_pretrained(\"MiniMaxAI/MiniMax-M2\", revision=\"refs/pr/52\")\n+\n+messages = [\n+    {\"role\": \"user\", \"content\": \"What is your favourite condiment?\"},\n+    {\"role\": \"assistant\", \"content\": \"Well, I'm quite partial to a good squeeze of fresh lemon juice. It adds just the right amount of zesty flavour to whatever I'm cooking up in the kitchen!\"},\n+    {\"role\": \"user\", \"content\": \"Do you have mayonnaise recipes?\"}\n+]\n+\n+model_inputs = tokenizer.apply_chat_template(messages, return_tensors=\"pt\", add_generation_prompt=True).to(\"cuda\")\n+\n+generated_ids = model.generate(**model_inputs, max_new_tokens=100)\n+\n+response = tokenizer.batch_decode(generated_ids)[0]\n+\n+print(response)\n+```\n+\n+## MiniMaxM2Config\n+\n+[[autodoc]] MiniMaxM2Config\n+\n+## MiniMaxM2Model\n+\n+[[autodoc]] MiniMaxM2Model\n+    - forward\n+\n+## MiniMaxM2ForCausalLM\n+\n+[[autodoc]] MiniMaxM2ForCausalLM\n+    - forward"
        },
        {
            "sha": "e56db36874b6493bb615f67c2480f2072e49dfd2",
            "filename": "src/transformers/conversion_mapping.py",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fconversion_mapping.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fconversion_mapping.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fconversion_mapping.py?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -236,6 +236,10 @@ def _build_checkpoint_conversion_mapping():\n     mapping[\"qwen3_vl_moe\"] = mapping[\"qwen2_moe\"].copy()\n     mapping[\"hunyuan_v1_moe\"] = mapping[\"qwen2_moe\"].copy()\n     mapping[\"minimax\"] = mapping[\"mixtral\"].copy()\n+    mapping[\"minimax_m2\"] = mapping[\"mixtral\"].copy()\n+    mapping[\"minimax_m2\"] += [\n+        WeightRenaming(\".block_sparse_moe.e_score_correction_bias\", \".mlp.e_score_correction_bias\"),\n+    ]\n     mapping[\"flex_olmo\"] = mapping[\"qwen2_moe\"].copy()\n     mapping[\"olmoe\"] = mapping[\"qwen2_moe\"].copy()\n "
        },
        {
            "sha": "0afaf19dbd604c425ea85b19455b370a98c5468d",
            "filename": "src/transformers/generation/utils.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fgeneration%2Futils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fgeneration%2Futils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Futils.py?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -1899,6 +1899,7 @@ def _supports_default_dynamic_cache(cls) -> bool:\n         # NOTE: remove xlnet/reformer when the models are deprecated, non-standard model architecture/cache name\n         return not cls._is_stateful and all(\n             special_model_name not in cls.__name__.lower()\n+            or \"minimaxm2\" in cls.__name__.lower()  # name clash between minimax and minimax m2\n             for special_model_name in [\n                 \"reformer\",\n                 \"minimax\","
        },
        {
            "sha": "255a6ba4e6864d5377079eb97415b9c3d63c6192",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -234,6 +234,7 @@\n     from .mgp_str import *\n     from .mimi import *\n     from .minimax import *\n+    from .minimax_m2 import *\n     from .ministral import *\n     from .ministral3 import *\n     from .mistral import *"
        },
        {
            "sha": "430fb0de117499e5362b72ed8f87a43e44ac1440",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -263,6 +263,7 @@\n         (\"mgp-str\", \"MgpstrConfig\"),\n         (\"mimi\", \"MimiConfig\"),\n         (\"minimax\", \"MiniMaxConfig\"),\n+        (\"minimax_m2\", \"MiniMaxM2Config\"),\n         (\"ministral\", \"MinistralConfig\"),\n         (\"ministral3\", \"Ministral3Config\"),\n         (\"mistral\", \"MistralConfig\"),\n@@ -725,6 +726,7 @@\n         (\"mgp-str\", \"MGP-STR\"),\n         (\"mimi\", \"Mimi\"),\n         (\"minimax\", \"MiniMax\"),\n+        (\"minimax_m2\", \"MiniMax-M2\"),\n         (\"ministral\", \"Ministral\"),\n         (\"ministral3\", \"Ministral3\"),\n         (\"mistral\", \"Mistral\"),"
        },
        {
            "sha": "8e7d115962bdd3801a3ddc3dbb849cd6d9ffe196",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -263,6 +263,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"mgp-str\", \"MgpstrForSceneTextRecognition\"),\n         (\"mimi\", \"MimiModel\"),\n         (\"minimax\", \"MiniMaxModel\"),\n+        (\"minimax_m2\", \"MiniMaxM2Model\"),\n         (\"ministral\", \"MinistralModel\"),\n         (\"ministral3\", \"Ministral3Model\"),\n         (\"mistral\", \"MistralModel\"),\n@@ -715,6 +716,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"mbart\", \"MBartForCausalLM\"),\n         (\"megatron-bert\", \"MegatronBertForCausalLM\"),\n         (\"minimax\", \"MiniMaxForCausalLM\"),\n+        (\"minimax_m2\", \"MiniMaxM2ForCausalLM\"),\n         (\"ministral\", \"MinistralForCausalLM\"),\n         (\"ministral3\", \"Ministral3ForCausalLM\"),\n         (\"mistral\", \"MistralForCausalLM\"),"
        },
        {
            "sha": "87f3fe717035c8f6541717add547a5b7644107d7",
            "filename": "src/transformers/models/minimax_m2/__init__.py",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2Fminimax_m2%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2Fminimax_m2%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fminimax_m2%2F__init__.py?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -0,0 +1,28 @@\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_minimax_m2 import *\n+    from .modeling_minimax_m2 import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "32f5954d775d2293d9cea1bb2af94e765144ca31",
            "filename": "src/transformers/models/minimax_m2/configuration_minimax_m2.py",
            "status": "added",
            "additions": 211,
            "deletions": 0,
            "changes": 211,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2Fminimax_m2%2Fconfiguration_minimax_m2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2Fminimax_m2%2Fconfiguration_minimax_m2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fminimax_m2%2Fconfiguration_minimax_m2.py?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -0,0 +1,211 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/minimax_m2/modular_minimax_m2.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_minimax_m2.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# Copyright 2025 the MiniMax AI Team and HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+from ...configuration_utils import PreTrainedConfig\n+from ...modeling_rope_utils import RopeParameters\n+\n+\n+class MiniMaxM2Config(PreTrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`MiniMaxM2Model`]. It is used to instantiate an\n+    MiniMaxM2 model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of the MiniMaxM2.\n+\n+    [MiniMaxAI/MiniMax-M2](https://huggingface.co/MiniMaxAI/MiniMax-M2)\n+\n+    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PreTrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`Optional`, *optional*, defaults to 200064):\n+            Vocabulary size of the MiniMaxM2 model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`MiniMaxM2Model`]\n+        hidden_size (`Optional`, *optional*, defaults to 3072):\n+            Dimension of the hidden representations.\n+        intermediate_size (`Optional`, *optional*, defaults to 1536):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`Optional`, *optional*, defaults to 62):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`Optional`, *optional*, defaults to 48):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`Optional`, *optional*, defaults to 8):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details, check out [this\n+            paper](https://huggingface.co/papers/2305.13245). If it is not specified, will default to `8`.\n+        head_dim (`Optional`, *optional*, defaults to 128):\n+            The attention head dimension.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`Optional`, *optional*, defaults to 196608):\n+            The maximum sequence length that this model might ever be used with. MiniMaxM2's sliding window attention\n+            allows sequence of up to 196608 tokens.\n+        initializer_range (`Optional`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`Optional`, *optional*, defaults to 1e-06):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`Optional`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        pad_token_id (`Optional`, *optional*):\n+            The id of the padding token.\n+        bos_token_id (`Optional`, *optional*, defaults to 200034):\n+            The id of the \"beginning-of-sequence\" token.\n+        eos_token_id (`Optional`, *optional*, defaults to 200020):\n+            The id of the \"end-of-sequence\" token.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        attention_dropout (`Optional`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        num_experts_per_tok (`Optional`, *optional*, defaults to 8):\n+            The number of experts to route per-token, can be also interpreted as the `top-k` routing\n+            parameter\n+        num_local_experts (`Optional`, *optional*, defaults to 256):\n+            Number of experts per Sparse MLP layer.\n+        output_router_logits (`Optional`, *optional*, defaults to `False`):\n+            Whether or not the router logits should be returned by the model. Enabling this will also\n+            allow the model to output the auxiliary loss. See [here]() for more details\n+        router_aux_loss_coef (`Optional`, *optional*, defaults to 0.001):\n+            The aux loss factor for the total loss.\n+        router_jitter_noise (`Optional`, *optional*, defaults to 0.0):\n+            Amount of noise to add to the router.\n+        rope_parameters (`RopeParameters`, *optional*):\n+            Dictionary containing the configuration parameters for the RoPE embeddings. The dictionaty should contain\n+            a value for `rope_theta` and optionally parameters used for scaling in case you want to use RoPE\n+            with longer `max_position_embeddings`.\n+\n+    ```python\n+    >>> from transformers import MiniMaxM2Model, MiniMaxM2Config\n+\n+    >>> # Initializing a MiniMaxM2 style configuration\n+    >>> configuration = MiniMaxM2Config()\n+\n+    >>> # Initializing a model from the MiniMaxM2 style configuration\n+    >>> model = MiniMaxM2Model(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"minimax_m2\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise_rep\",\n+        \"layers.*.self_attn.k_proj\": \"colwise_rep\",\n+        \"layers.*.self_attn.v_proj\": \"colwise_rep\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise_rep\",\n+        \"layers.*.mlp.gate\": \"colwise_rep\",  # we need to replicate here to correctly route experts\n+        \"layers.*.mlp.experts.gate_up_proj\": \"local_rowwise\",\n+        \"layers.*.mlp.experts.down_proj\": \"local_rowwise\",\n+        \"layers.*.mlp.experts\": \"gather\",\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+    attribute_map = {\n+        \"num_experts\": \"num_local_experts\",\n+    }\n+    default_theta = 5000000.0\n+\n+    def __init__(\n+        self,\n+        vocab_size: int | None = 200064,\n+        hidden_size: int | None = 3072,\n+        intermediate_size: int | None = 1536,\n+        num_hidden_layers: int | None = 62,\n+        num_attention_heads: int | None = 48,\n+        num_key_value_heads: int | None = 8,\n+        head_dim: int | None = 128,\n+        hidden_act: str | None = \"silu\",\n+        max_position_embeddings: int | None = 196608,\n+        initializer_range: float | None = 0.02,\n+        rms_norm_eps: int | None = 1e-06,\n+        use_cache: bool | None = True,\n+        pad_token_id: int | None = None,\n+        bos_token_id: int | None = 200034,\n+        eos_token_id: int | None = 200020,\n+        tie_word_embeddings: bool | None = False,\n+        attention_dropout: float | None = 0.0,\n+        num_experts_per_tok: int | None = 8,\n+        num_local_experts: int | None = 256,\n+        output_router_logits: bool | None = False,\n+        router_aux_loss_coef: float | None = 0.001,\n+        router_jitter_noise: float | None = 0.0,\n+        rope_parameters: RopeParameters | dict[RopeParameters] | None = None,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.attention_dropout = attention_dropout\n+        self.head_dim = head_dim\n+        self.rope_parameters = rope_parameters\n+\n+        self.num_experts_per_tok = num_experts_per_tok\n+        self.num_local_experts = num_local_experts\n+        self.output_router_logits = output_router_logits\n+        self.router_aux_loss_coef = router_aux_loss_coef\n+        self.router_jitter_noise = router_jitter_noise\n+\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+\n+    def convert_rope_params_to_dict(self, ignore_keys_at_rope_validation=None, **kwargs):\n+        rope_scaling = kwargs.pop(\"rope_scaling\", None)\n+        self.rope_parameters = rope_scaling or self.rope_parameters\n+        self.rope_parameters = self.rope_parameters if self.rope_parameters is not None else {}\n+\n+        # Standardize and validate the correctness of rotary position embeddings parameters\n+        # Model uses non-standard naming for rope params, overwrite!\n+        self.rope_parameters.setdefault(\"rope_theta\", self.default_theta)\n+        self.rope_parameters[\"partial_rotary_factor\"] = (\n+            kwargs.pop(\"rotary_dim\", self.head_dim // 2) / self.head_dim\n+        )  # Default to `0.5`\n+        self.standardize_rope_params()\n+\n+        if ignore_keys_at_rope_validation is None:\n+            ignore_keys_at_rope_validation = {\"partial_rotary_factor\"}\n+        else:\n+            ignore_keys_at_rope_validation |= {\"partial_rotary_factor\"}\n+\n+        self.validate_rope(ignore_keys=ignore_keys_at_rope_validation)\n+        return kwargs\n+\n+\n+__all__ = [\"MiniMaxM2Config\"]"
        },
        {
            "sha": "9129465382815d60c331b0a36efa387c8a531e87",
            "filename": "src/transformers/models/minimax_m2/modeling_minimax_m2.py",
            "status": "added",
            "additions": 706,
            "deletions": 0,
            "changes": 706,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2Fminimax_m2%2Fmodeling_minimax_m2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2Fminimax_m2%2Fmodeling_minimax_m2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fminimax_m2%2Fmodeling_minimax_m2.py?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -0,0 +1,706 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/minimax_m2/modular_minimax_m2.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_minimax_m2.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# Copyright 2025 the MiniMax AI Team and HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+from collections.abc import Callable\n+from typing import Optional\n+\n+import torch\n+import torch.nn.functional as F\n+from torch import nn\n+\n+from ... import initialization as init\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache\n+from ...generation import GenerationMixin\n+from ...integrations import use_experts_implementation, use_kernel_forward_from_hub, use_kernelized_func\n+from ...masking_utils import create_causal_mask\n+from ...modeling_layers import GradientCheckpointingLayer\n+from ...modeling_outputs import MoeCausalLMOutputWithPast, MoeModelOutputWithPast\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS, dynamic_rope_update\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring, can_return_tuple, is_grouped_mm_available\n+from ...utils.generic import OutputRecorder, check_model_inputs, maybe_autocast\n+from .configuration_minimax_m2 import MiniMaxM2Config\n+\n+\n+class MiniMaxM2TopKRouter(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.top_k = config.num_experts_per_tok\n+        self.num_experts = config.num_local_experts\n+        self.hidden_dim = config.hidden_size\n+        self.weight = nn.Parameter(torch.empty(self.num_experts, self.hidden_dim))\n+\n+    def forward(self, hidden_states, e_score_correction_bias):\n+        hidden_states = hidden_states.reshape(-1, self.hidden_dim)\n+        router_logits = F.linear(hidden_states.to(self.weight.dtype), self.weight)  # (seq_len, num_experts)\n+        # Main difference to other Moe, using Sigmoid activation instead of Softmax\n+        routing_weights = nn.functional.sigmoid(router_logits.float())\n+        scores_for_choice = routing_weights + e_score_correction_bias\n+        _, top_k_index = torch.topk(scores_for_choice, self.top_k, dim=-1, sorted=False)\n+        top_k_weights = routing_weights.gather(1, top_k_index)\n+        top_k_weights /= top_k_weights.sum(dim=-1, keepdim=True)\n+        router_scores = top_k_weights\n+        return router_logits, router_scores, top_k_index\n+\n+\n+@use_experts_implementation\n+class MiniMaxM2Experts(nn.Module):\n+    \"\"\"Collection of expert weights stored as 3D tensors.\"\"\"\n+\n+    def __init__(self, config: MiniMaxM2Config):\n+        super().__init__()\n+        self.num_experts = config.num_local_experts\n+        self.hidden_dim = config.hidden_size\n+        self.intermediate_dim = config.intermediate_size\n+        self.gate_up_proj = nn.Parameter(torch.empty(self.num_experts, 2 * self.intermediate_dim, self.hidden_dim))\n+        self.down_proj = nn.Parameter(torch.empty(self.num_experts, self.hidden_dim, self.intermediate_dim))\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        top_k_index: torch.Tensor,\n+        top_k_weights: torch.Tensor,\n+    ) -> torch.Tensor:\n+        final_hidden_states = torch.zeros_like(hidden_states)\n+        with torch.no_grad():\n+            expert_mask = torch.nn.functional.one_hot(top_k_index, num_classes=self.num_experts)\n+            expert_mask = expert_mask.permute(2, 1, 0)\n+            expert_hit = torch.greater(expert_mask.sum(dim=(-1, -2)), 0).nonzero()\n+\n+        for expert_idx in expert_hit:\n+            expert_idx = expert_idx[0]\n+            if expert_idx == self.num_experts:\n+                continue\n+            top_k_pos, token_idx = torch.where(expert_mask[expert_idx])\n+            current_state = hidden_states[token_idx]\n+            gate, up = nn.functional.linear(current_state, self.gate_up_proj[expert_idx]).chunk(2, dim=-1)\n+            current_hidden_states = self.act_fn(gate) * up\n+            current_hidden_states = nn.functional.linear(current_hidden_states, self.down_proj[expert_idx])\n+            current_hidden_states = current_hidden_states * top_k_weights[token_idx, top_k_pos, None]\n+            final_hidden_states.index_add_(0, token_idx, current_hidden_states.to(final_hidden_states.dtype))\n+\n+        return final_hidden_states\n+\n+\n+class MiniMaxM2SparseMoeBlock(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.top_k = config.num_experts_per_tok\n+        self.jitter_noise = config.router_jitter_noise\n+        self.gate = MiniMaxM2TopKRouter(config)\n+        self.experts = MiniMaxM2Experts(config)\n+        self.register_buffer(\"e_score_correction_bias\", torch.zeros(config.num_local_experts))\n+\n+    def forward(self, hidden_states: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n+        batch_size, sequence_length, hidden_dim = hidden_states.shape\n+        if self.training and self.jitter_noise > 0:\n+            hidden_states *= torch.empty_like(hidden_states).uniform_(1.0 - self.jitter_noise, 1.0 + self.jitter_noise)\n+        hidden_states = hidden_states.view(-1, hidden_states.shape[-1])\n+        _, top_k_weights, top_k_index = self.gate(hidden_states, self.e_score_correction_bias)\n+        hidden_states = self.experts(hidden_states, top_k_index, top_k_weights)\n+        hidden_states = hidden_states.reshape(batch_size, sequence_length, hidden_dim)\n+        return hidden_states\n+\n+\n+@use_kernel_forward_from_hub(\"RMSNorm\")\n+class MiniMaxM2RMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        MiniMaxM2RMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class MiniMaxM2RotaryEmbedding(nn.Module):\n+    inv_freq: torch.Tensor  # fix linting for `register_buffer`\n+\n+    def __init__(self, config: MiniMaxM2Config, device=None):\n+        super().__init__()\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+\n+        self.rope_type = self.config.rope_parameters[\"rope_type\"]\n+        rope_init_fn: Callable = self.compute_default_rope_parameters\n+        if self.rope_type != \"default\":\n+            rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+        inv_freq, self.attention_scaling = rope_init_fn(self.config, device)\n+\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.register_buffer(\"original_inv_freq\", inv_freq.clone(), persistent=False)\n+\n+    @staticmethod\n+    def compute_default_rope_parameters(\n+        config: MiniMaxM2Config | None = None,\n+        device: Optional[\"torch.device\"] = None,\n+        seq_len: int | None = None,\n+    ) -> tuple[\"torch.Tensor\", float]:\n+        \"\"\"\n+        Computes the inverse frequencies according to the original RoPE implementation\n+        Args:\n+            config ([`~transformers.PreTrainedConfig`]):\n+                The model configuration.\n+            device (`torch.device`):\n+                The device to use for initialization of the inverse frequencies.\n+            seq_len (`int`, *optional*):\n+                The current sequence length. Unused for this type of RoPE.\n+        Returns:\n+            Tuple of (`torch.Tensor`, `float`), containing the inverse frequencies for the RoPE embeddings and the\n+            post-processing scaling factor applied to the computed cos/sin (unused in this type of RoPE).\n+        \"\"\"\n+        base = config.rope_parameters[\"rope_theta\"]\n+        partial_rotary_factor = config.rope_parameters.get(\"partial_rotary_factor\", 1.0)\n+        head_dim = getattr(config, \"head_dim\", None) or config.hidden_size // config.num_attention_heads\n+        dim = int(head_dim * partial_rotary_factor)\n+\n+        attention_factor = 1.0  # Unused in this type of RoPE\n+\n+        # Compute the inverse frequencies\n+        inv_freq = 1.0 / (\n+            base ** (torch.arange(0, dim, 2, dtype=torch.int64).to(device=device, dtype=torch.float) / dim)\n+        )\n+        return inv_freq, attention_factor\n+\n+    @torch.no_grad()\n+    @dynamic_rope_update  # power user: used with advanced RoPE types (e.g. dynamic rope)\n+    def forward(self, x, position_ids):\n+        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1).to(x.device)\n+        position_ids_expanded = position_ids[:, None, :].float()\n+\n+        device_type = x.device.type if isinstance(x.device.type, str) and x.device.type != \"mps\" else \"cpu\"\n+        with maybe_autocast(device_type=device_type, enabled=False):  # Force float32\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(1, 2)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos() * self.attention_scaling\n+            sin = emb.sin() * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: torch.Tensor | None,\n+    scaling: float,\n+    dropout: float = 0.0,\n+    **kwargs: Unpack[TransformersKwargs],\n+):\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+    if attention_mask is not None:\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+\n+    return attn_output, attn_weights\n+\n+\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`, *optional*):\n+            Deprecated and unused.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+\n+    # Keep half or full tensor for later concatenation\n+    rotary_dim = cos.shape[-1]\n+    q_rot, q_pass = q[..., :rotary_dim], q[..., rotary_dim:]\n+    k_rot, k_pass = k[..., :rotary_dim], k[..., rotary_dim:]\n+\n+    # Apply rotary embeddings on the first half or full tensor\n+    q_embed = (q_rot * cos) + (rotate_half(q_rot) * sin)\n+    k_embed = (k_rot * cos) + (rotate_half(k_rot) * sin)\n+\n+    # Concatenate back to full shape\n+    q_embed = torch.cat([q_embed, q_pass], dim=-1)\n+    k_embed = torch.cat([k_embed, k_pass], dim=-1)\n+    return q_embed, k_embed\n+\n+\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+@use_kernelized_func(apply_rotary_pos_emb)\n+class MiniMaxM2Attention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: MiniMaxM2Config, layer_idx: int):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.head_dim = getattr(config, \"head_dim\", config.hidden_size // config.num_attention_heads)\n+        self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n+        self.scaling = self.head_dim**-0.5\n+        self.attention_dropout = config.attention_dropout\n+        self.is_causal = True\n+        self.q_proj = nn.Linear(config.hidden_size, config.num_attention_heads * self.head_dim, bias=False)\n+        self.k_proj = nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=False)\n+        self.v_proj = nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=False)\n+        self.o_proj = nn.Linear(config.num_attention_heads * self.head_dim, config.hidden_size, bias=False)\n+        self.q_norm = MiniMaxM2RMSNorm(config.num_attention_heads * self.head_dim, config.rms_norm_eps)\n+        self.k_norm = MiniMaxM2RMSNorm(config.num_key_value_heads * self.head_dim, config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor],\n+        attention_mask: torch.Tensor | None,\n+        past_key_values: Cache | None = None,\n+        cache_position: torch.LongTensor | None = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> tuple[torch.Tensor, torch.Tensor | None]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_norm(self.q_proj(hidden_states))\n+        key_states = self.k_norm(self.k_proj(hidden_states))\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(hidden_shape).transpose(1, 2)\n+        key_states = key_states.view(hidden_shape).transpose(1, 2)\n+        value_states = value_states.view(hidden_shape).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_values is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}\n+            key_states, value_states = past_key_values.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            dropout=0.0 if not self.training else self.attention_dropout,\n+            scaling=self.scaling,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class MiniMaxM2DecoderLayer(GradientCheckpointingLayer):\n+    def __init__(self, config: MiniMaxM2Config, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        self.self_attn = MiniMaxM2Attention(config, layer_idx)\n+\n+        self.mlp = MiniMaxM2SparseMoeBlock(config)\n+        self.input_layernorm = MiniMaxM2RMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = MiniMaxM2RMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: tuple[torch.Tensor, torch.Tensor] | None = None,\n+        attention_mask: torch.Tensor | None = None,\n+        position_ids: torch.LongTensor | None = None,\n+        past_key_values: Cache | None = None,\n+        cache_position: torch.LongTensor | None = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> torch.Tensor:\n+        residual = hidden_states\n+        hidden_states = self.input_layernorm(hidden_states)\n+        hidden_states, _ = self.self_attn(\n+            hidden_states=hidden_states,\n+            position_embeddings=position_embeddings,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = residual + hidden_states\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+        return hidden_states\n+\n+\n+@auto_docstring\n+class MiniMaxM2PreTrainedModel(PreTrainedModel):\n+    config: MiniMaxM2Config\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"MiniMaxM2DecoderLayer\"]\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _supports_flash_attn = True\n+    _supports_sdpa = True\n+    _supports_flex_attn = True\n+    _can_compile_fullgraph = (\n+        is_grouped_mm_available()\n+    )  # https://huggingface.co/docs/transformers/experts_interface#torchcompile\n+    _supports_attention_backend = True\n+    _can_record_outputs = {\n+        \"router_logits\": OutputRecorder(MiniMaxM2TopKRouter, index=0),\n+        \"hidden_states\": MiniMaxM2DecoderLayer,\n+        \"attentions\": MiniMaxM2Attention,\n+    }\n+\n+    @torch.no_grad()\n+    def _init_weights(self, module):\n+        super()._init_weights(module)\n+        std = self.config.initializer_range\n+        if isinstance(module, MiniMaxM2Experts):\n+            init.normal_(module.gate_up_proj, mean=0.0, std=std)\n+            init.normal_(module.down_proj, mean=0.0, std=std)\n+        elif isinstance(module, MiniMaxM2TopKRouter):\n+            init.normal_(module.weight, mean=0.0, std=std)\n+        elif isinstance(module, MiniMaxM2SparseMoeBlock):\n+            init.zeros_(module.e_score_correction_bias)\n+\n+\n+@auto_docstring\n+class MiniMaxM2Model(MiniMaxM2PreTrainedModel):\n+    def __init__(self, config: MiniMaxM2Config):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [MiniMaxM2DecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = MiniMaxM2RMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = MiniMaxM2RotaryEmbedding(config=config)\n+        self.gradient_checkpointing = False\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @check_model_inputs\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor | None = None,\n+        attention_mask: torch.Tensor | None = None,\n+        position_ids: torch.LongTensor | None = None,\n+        past_key_values: Cache | None = None,\n+        inputs_embeds: torch.FloatTensor | None = None,\n+        use_cache: bool | None = None,\n+        cache_position: torch.LongTensor | None = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> MoeModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache(config=self.config)\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        # No sliding window opposed to mixtral\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=position_ids,\n+        )\n+\n+        hidden_states = inputs_embeds\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids=position_ids)\n+\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask,\n+                position_ids=position_ids,\n+                past_key_values=past_key_values,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                position_embeddings=position_embeddings,\n+                **kwargs,\n+            )\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        return MoeModelOutputWithPast(  # only diff with Mistral is the output type, we need MoE\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+def load_balancing_loss_func(\n+    gate_logits: torch.Tensor | tuple[torch.Tensor] | None,\n+    num_experts: int | None = None,\n+    top_k=2,\n+    attention_mask: torch.Tensor | None = None,\n+) -> torch.Tensor | int:\n+    r\"\"\"\n+    Computes auxiliary load balancing loss as in Switch Transformer - implemented in Pytorch.\n+\n+    See Switch Transformer (https://huggingface.co/papers/2101.03961) for more details. This function implements the loss\n+    function presented in equations (4) - (6) of the paper. It aims at penalizing cases where the routing between\n+    experts is too unbalanced.\n+\n+    Args:\n+        gate_logits:\n+            Logits from the `gate`, should be a tuple of model.config.num_hidden_layers tensors of\n+            shape [batch_size X sequence_length, num_experts].\n+        num_experts:\n+            Number of experts\n+        top_k:\n+            The number of experts to route per-token, can be also interpreted as the `top-k` routing\n+            parameter.\n+        attention_mask (`torch.Tensor`, *optional*):\n+            The attention_mask used in forward function\n+            shape [batch_size X sequence_length] if not None.\n+\n+    Returns:\n+        The auxiliary loss.\n+    \"\"\"\n+    if gate_logits is None or not isinstance(gate_logits, tuple):\n+        return 0\n+\n+    if isinstance(gate_logits, tuple):\n+        compute_device = gate_logits[0].device\n+        concatenated_gate_logits = torch.cat([layer_gate.to(compute_device) for layer_gate in gate_logits], dim=0)\n+\n+    routing_weights = torch.nn.functional.softmax(concatenated_gate_logits, dim=-1)\n+\n+    _, selected_experts = torch.topk(routing_weights, top_k, dim=-1)\n+\n+    expert_mask = torch.nn.functional.one_hot(selected_experts, num_experts)\n+\n+    if attention_mask is None:\n+        # Compute the percentage of tokens routed to each experts\n+        tokens_per_expert = torch.mean(expert_mask.float(), dim=0)\n+\n+        # Compute the average probability of routing to these experts\n+        router_prob_per_expert = torch.mean(routing_weights, dim=0)\n+    else:\n+        batch_size, sequence_length = attention_mask.shape\n+        num_hidden_layers = concatenated_gate_logits.shape[0] // (batch_size * sequence_length)\n+\n+        # Compute the mask that masks all padding tokens as 0 with the same shape of expert_mask\n+        expert_attention_mask = (\n+            attention_mask[None, :, :, None, None]\n+            .expand((num_hidden_layers, batch_size, sequence_length, top_k, num_experts))\n+            .reshape(-1, top_k, num_experts)\n+            .to(compute_device)\n+        )\n+\n+        # Compute the percentage of tokens routed to each experts\n+        tokens_per_expert = torch.sum(expert_mask.float() * expert_attention_mask, dim=0) / torch.sum(\n+            expert_attention_mask, dim=0\n+        )\n+\n+        # Compute the mask that masks all padding tokens as 0 with the same shape of tokens_per_expert\n+        router_per_expert_attention_mask = (\n+            attention_mask[None, :, :, None]\n+            .expand((num_hidden_layers, batch_size, sequence_length, num_experts))\n+            .reshape(-1, num_experts)\n+            .to(compute_device)\n+        )\n+\n+        # Compute the average probability of routing to these experts\n+        router_prob_per_expert = torch.sum(routing_weights * router_per_expert_attention_mask, dim=0) / torch.sum(\n+            router_per_expert_attention_mask, dim=0\n+        )\n+\n+    overall_loss = torch.sum(tokens_per_expert * router_prob_per_expert.unsqueeze(0))\n+    return overall_loss * num_experts\n+\n+\n+@auto_docstring\n+class MiniMaxM2ForCausalLM(MiniMaxM2PreTrainedModel, GenerationMixin):\n+    _tied_weights_keys = {\"lm_head.weight\": \"model.embed_tokens.weight\"}\n+    _tp_plan = {\"lm_head\": \"colwise_rep\"}\n+    _pp_plan = {\"lm_head\": ([\"hidden_states\"], [\"logits\"])}\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = MiniMaxM2Model(config)\n+        self.vocab_size = config.vocab_size\n+        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n+        self.router_aux_loss_coef = config.router_aux_loss_coef\n+        self.num_experts = config.num_local_experts\n+        self.num_experts_per_tok = config.num_experts_per_tok\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor | None = None,\n+        attention_mask: torch.Tensor | None = None,\n+        position_ids: torch.LongTensor | None = None,\n+        past_key_values: Cache | None = None,\n+        inputs_embeds: torch.FloatTensor | None = None,\n+        labels: torch.LongTensor | None = None,\n+        use_cache: bool | None = None,\n+        output_router_logits: bool | None = None,\n+        cache_position: torch.LongTensor | None = None,\n+        logits_to_keep: int | torch.Tensor = 0,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> MoeCausalLMOutputWithPast:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, MiniMaxM2ForCausalLM\n+\n+        >>> model = MiniMaxM2ForCausalLM.from_pretrained(\"mistralai/MiniMaxM2-8x7B-v0.1\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"mistralai/MiniMaxM2-8x7B-v0.1\")\n+\n+        >>> prompt = \"Hey, are you conscious? Can you talk to me?\"\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"Hey, are you conscious? Can you talk to me?\\nI'm not conscious, but I can talk to you.\"\n+        ```\"\"\"\n+\n+        output_router_logits = (\n+            output_router_logits if output_router_logits is not None else self.config.output_router_logits\n+        )\n+\n+        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n+        outputs: MoeModelOutputWithPast = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_router_logits=output_router_logits,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs.last_hidden_state\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits, labels, self.vocab_size, **kwargs)\n+\n+        aux_loss = None\n+        if output_router_logits:\n+            aux_loss = load_balancing_loss_func(\n+                outputs.router_logits,\n+                self.num_experts,\n+                self.num_experts_per_tok,\n+                attention_mask,\n+            )\n+            if labels is not None:\n+                loss += self.router_aux_loss_coef * aux_loss.to(loss.device)  # make sure to reside in the same device\n+\n+        return MoeCausalLMOutputWithPast(\n+            loss=loss,\n+            aux_loss=aux_loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            router_logits=outputs.router_logits,\n+        )\n+\n+\n+__all__ = [\"MiniMaxM2ForCausalLM\", \"MiniMaxM2Model\", \"MiniMaxM2PreTrainedModel\"]"
        },
        {
            "sha": "bd09d08491aed801173a6ab4410a44743dcd1e9e",
            "filename": "src/transformers/models/minimax_m2/modular_minimax_m2.py",
            "status": "added",
            "additions": 369,
            "deletions": 0,
            "changes": 369,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2Fminimax_m2%2Fmodular_minimax_m2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/src%2Ftransformers%2Fmodels%2Fminimax_m2%2Fmodular_minimax_m2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fminimax_m2%2Fmodular_minimax_m2.py?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -0,0 +1,369 @@\n+# Copyright 2025 the MiniMax AI Team and HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+import torch\n+import torch.nn.functional as F\n+from torch import nn\n+\n+from ... import initialization as init\n+from ...cache_utils import Cache, DynamicCache\n+from ...configuration_utils import PreTrainedConfig\n+from ...masking_utils import create_causal_mask\n+from ...modeling_outputs import MoeModelOutputWithPast\n+from ...modeling_rope_utils import RopeParameters\n+from ...modeling_utils import PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring\n+from ...utils.generic import check_model_inputs\n+from ..flex_olmo.modeling_flex_olmo import FlexOlmoAttention\n+from ..glm4_moe.modeling_glm4_moe import (\n+    Glm4MoeRotaryEmbedding,\n+    apply_rotary_pos_emb,  # noqa: F401\n+)\n+from ..mixtral.modeling_mixtral import (\n+    MixtralExperts,\n+    MixtralForCausalLM,\n+    MixtralModel,\n+    MixtralPreTrainedModel,\n+    MixtralRMSNorm,\n+    MixtralSparseMoeBlock,\n+    MixtralTopKRouter,\n+)\n+\n+\n+class MiniMaxM2Config(PreTrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`MiniMaxM2Model`]. It is used to instantiate an\n+    MiniMaxM2 model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of the MiniMaxM2.\n+\n+    [MiniMaxAI/MiniMax-M2](https://huggingface.co/MiniMaxAI/MiniMax-M2)\n+\n+    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PreTrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`Optional`, *optional*, defaults to 200064):\n+            Vocabulary size of the MiniMaxM2 model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`MiniMaxM2Model`]\n+        hidden_size (`Optional`, *optional*, defaults to 3072):\n+            Dimension of the hidden representations.\n+        intermediate_size (`Optional`, *optional*, defaults to 1536):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`Optional`, *optional*, defaults to 62):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`Optional`, *optional*, defaults to 48):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`Optional`, *optional*, defaults to 8):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details, check out [this\n+            paper](https://huggingface.co/papers/2305.13245). If it is not specified, will default to `8`.\n+        head_dim (`Optional`, *optional*, defaults to 128):\n+            The attention head dimension.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`Optional`, *optional*, defaults to 196608):\n+            The maximum sequence length that this model might ever be used with. MiniMaxM2's sliding window attention\n+            allows sequence of up to 196608 tokens.\n+        initializer_range (`Optional`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`Optional`, *optional*, defaults to 1e-06):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`Optional`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        pad_token_id (`Optional`, *optional*):\n+            The id of the padding token.\n+        bos_token_id (`Optional`, *optional*, defaults to 200034):\n+            The id of the \"beginning-of-sequence\" token.\n+        eos_token_id (`Optional`, *optional*, defaults to 200020):\n+            The id of the \"end-of-sequence\" token.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        attention_dropout (`Optional`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        num_experts_per_tok (`Optional`, *optional*, defaults to 8):\n+            The number of experts to route per-token, can be also interpreted as the `top-k` routing\n+            parameter\n+        num_local_experts (`Optional`, *optional*, defaults to 256):\n+            Number of experts per Sparse MLP layer.\n+        output_router_logits (`Optional`, *optional*, defaults to `False`):\n+            Whether or not the router logits should be returned by the model. Enabling this will also\n+            allow the model to output the auxiliary loss. See [here]() for more details\n+        router_aux_loss_coef (`Optional`, *optional*, defaults to 0.001):\n+            The aux loss factor for the total loss.\n+        router_jitter_noise (`Optional`, *optional*, defaults to 0.0):\n+            Amount of noise to add to the router.\n+        rope_parameters (`RopeParameters`, *optional*):\n+            Dictionary containing the configuration parameters for the RoPE embeddings. The dictionaty should contain\n+            a value for `rope_theta` and optionally parameters used for scaling in case you want to use RoPE\n+            with longer `max_position_embeddings`.\n+\n+    ```python\n+    >>> from transformers import MiniMaxM2Model, MiniMaxM2Config\n+\n+    >>> # Initializing a MiniMaxM2 style configuration\n+    >>> configuration = MiniMaxM2Config()\n+\n+    >>> # Initializing a model from the MiniMaxM2 style configuration\n+    >>> model = MiniMaxM2Model(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"minimax_m2\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise_rep\",\n+        \"layers.*.self_attn.k_proj\": \"colwise_rep\",\n+        \"layers.*.self_attn.v_proj\": \"colwise_rep\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise_rep\",\n+        \"layers.*.mlp.gate\": \"colwise_rep\",  # we need to replicate here to correctly route experts\n+        \"layers.*.mlp.experts.gate_up_proj\": \"local_rowwise\",\n+        \"layers.*.mlp.experts.down_proj\": \"local_rowwise\",\n+        \"layers.*.mlp.experts\": \"gather\",\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+    attribute_map = {\n+        \"num_experts\": \"num_local_experts\",\n+    }\n+    default_theta = 5000000.0\n+\n+    def __init__(\n+        self,\n+        vocab_size: int | None = 200064,\n+        hidden_size: int | None = 3072,\n+        intermediate_size: int | None = 1536,\n+        num_hidden_layers: int | None = 62,\n+        num_attention_heads: int | None = 48,\n+        num_key_value_heads: int | None = 8,\n+        head_dim: int | None = 128,\n+        hidden_act: str | None = \"silu\",\n+        max_position_embeddings: int | None = 196608,\n+        initializer_range: float | None = 0.02,\n+        rms_norm_eps: int | None = 1e-06,\n+        use_cache: bool | None = True,\n+        pad_token_id: int | None = None,\n+        bos_token_id: int | None = 200034,\n+        eos_token_id: int | None = 200020,\n+        tie_word_embeddings: bool | None = False,\n+        attention_dropout: float | None = 0.0,\n+        num_experts_per_tok: int | None = 8,\n+        num_local_experts: int | None = 256,\n+        output_router_logits: bool | None = False,\n+        router_aux_loss_coef: float | None = 0.001,\n+        router_jitter_noise: float | None = 0.0,\n+        rope_parameters: RopeParameters | dict[RopeParameters] | None = None,\n+        **kwargs,\n+    ):\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.attention_dropout = attention_dropout\n+        self.head_dim = head_dim\n+        self.rope_parameters = rope_parameters\n+\n+        self.num_experts_per_tok = num_experts_per_tok\n+        self.num_local_experts = num_local_experts\n+        self.output_router_logits = output_router_logits\n+        self.router_aux_loss_coef = router_aux_loss_coef\n+        self.router_jitter_noise = router_jitter_noise\n+\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+\n+    def convert_rope_params_to_dict(self, ignore_keys_at_rope_validation=None, **kwargs):\n+        rope_scaling = kwargs.pop(\"rope_scaling\", None)\n+        self.rope_parameters = rope_scaling or self.rope_parameters\n+        self.rope_parameters = self.rope_parameters if self.rope_parameters is not None else {}\n+\n+        # Standardize and validate the correctness of rotary position embeddings parameters\n+        # Model uses non-standard naming for rope params, overwrite!\n+        self.rope_parameters.setdefault(\"rope_theta\", self.default_theta)\n+        self.rope_parameters[\"partial_rotary_factor\"] = (\n+            kwargs.pop(\"rotary_dim\", self.head_dim // 2) / self.head_dim\n+        )  # Default to `0.5`\n+        self.standardize_rope_params()\n+\n+        if ignore_keys_at_rope_validation is None:\n+            ignore_keys_at_rope_validation = {\"partial_rotary_factor\"}\n+        else:\n+            ignore_keys_at_rope_validation |= {\"partial_rotary_factor\"}\n+\n+        self.validate_rope(ignore_keys=ignore_keys_at_rope_validation)\n+        return kwargs\n+\n+\n+class MiniMaxM2TopKRouter(MixtralTopKRouter):\n+    def forward(self, hidden_states, e_score_correction_bias):\n+        hidden_states = hidden_states.reshape(-1, self.hidden_dim)\n+        router_logits = F.linear(hidden_states.to(self.weight.dtype), self.weight)  # (seq_len, num_experts)\n+        # Main difference to other Moe, using Sigmoid activation instead of Softmax\n+        routing_weights = nn.functional.sigmoid(router_logits.float())\n+        scores_for_choice = routing_weights + e_score_correction_bias\n+        _, top_k_index = torch.topk(scores_for_choice, self.top_k, dim=-1, sorted=False)\n+        top_k_weights = routing_weights.gather(1, top_k_index)\n+        top_k_weights /= top_k_weights.sum(dim=-1, keepdim=True)\n+        router_scores = top_k_weights\n+        return router_logits, router_scores, top_k_index\n+\n+\n+class MiniMaxM2Experts(MixtralExperts):\n+    pass\n+\n+\n+class MiniMaxM2SparseMoeBlock(MixtralSparseMoeBlock):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.register_buffer(\"e_score_correction_bias\", torch.zeros(config.num_local_experts))\n+\n+    def forward(self, hidden_states: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n+        batch_size, sequence_length, hidden_dim = hidden_states.shape\n+        if self.training and self.jitter_noise > 0:\n+            hidden_states *= torch.empty_like(hidden_states).uniform_(1.0 - self.jitter_noise, 1.0 + self.jitter_noise)\n+        hidden_states = hidden_states.view(-1, hidden_states.shape[-1])\n+        _, top_k_weights, top_k_index = self.gate(hidden_states, self.e_score_correction_bias)\n+        hidden_states = self.experts(hidden_states, top_k_index, top_k_weights)\n+        hidden_states = hidden_states.reshape(batch_size, sequence_length, hidden_dim)\n+        return hidden_states\n+\n+\n+class MiniMaxM2RMSNorm(MixtralRMSNorm):\n+    pass\n+\n+\n+class MiniMaxM2RotaryEmbedding(Glm4MoeRotaryEmbedding):\n+    pass\n+\n+\n+class MiniMaxM2Attention(FlexOlmoAttention):\n+    def __init__(self, config: MiniMaxM2Config, layer_idx: int):\n+        super().__init__(config, layer_idx)\n+        self.q_proj = nn.Linear(config.hidden_size, config.num_attention_heads * self.head_dim, bias=False)\n+        self.k_proj = nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=False)\n+        self.v_proj = nn.Linear(config.hidden_size, config.num_key_value_heads * self.head_dim, bias=False)\n+        self.o_proj = nn.Linear(config.num_attention_heads * self.head_dim, config.hidden_size, bias=False)\n+\n+\n+class MiniMaxM2PreTrainedModel(MixtralPreTrainedModel):\n+    @torch.no_grad()\n+    def _init_weights(self, module):\n+        PreTrainedModel._init_weights(self, module)\n+        std = self.config.initializer_range\n+        if isinstance(module, MiniMaxM2Experts):\n+            init.normal_(module.gate_up_proj, mean=0.0, std=std)\n+            init.normal_(module.down_proj, mean=0.0, std=std)\n+        elif isinstance(module, MiniMaxM2TopKRouter):\n+            init.normal_(module.weight, mean=0.0, std=std)\n+        elif isinstance(module, MiniMaxM2SparseMoeBlock):\n+            init.zeros_(module.e_score_correction_bias)\n+\n+\n+class MiniMaxM2Model(MixtralModel):\n+    @check_model_inputs\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor | None = None,\n+        attention_mask: torch.Tensor | None = None,\n+        position_ids: torch.LongTensor | None = None,\n+        past_key_values: Cache | None = None,\n+        inputs_embeds: torch.FloatTensor | None = None,\n+        use_cache: bool | None = None,\n+        cache_position: torch.LongTensor | None = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> MoeModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if use_cache and past_key_values is None:\n+            past_key_values = DynamicCache(config=self.config)\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        # No sliding window opposed to mixtral\n+        causal_mask = create_causal_mask(\n+            config=self.config,\n+            input_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            past_key_values=past_key_values,\n+            position_ids=position_ids,\n+        )\n+\n+        hidden_states = inputs_embeds\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids=position_ids)\n+\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            hidden_states = decoder_layer(\n+                hidden_states,\n+                attention_mask=causal_mask,\n+                position_ids=position_ids,\n+                past_key_values=past_key_values,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                position_embeddings=position_embeddings,\n+                **kwargs,\n+            )\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        return MoeModelOutputWithPast(  # only diff with Mistral is the output type, we need MoE\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n+class MiniMaxM2ForCausalLM(MixtralForCausalLM):\n+    pass\n+\n+\n+__all__ = [\n+    \"MiniMaxM2Config\",\n+    \"MiniMaxM2ForCausalLM\",\n+    \"MiniMaxM2Model\",  # noqa: F822\n+    \"MiniMaxM2PreTrainedModel\",  # noqa: F822\n+]"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/minimax_m2/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/tests%2Fmodels%2Fminimax_m2%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/tests%2Fmodels%2Fminimax_m2%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fminimax_m2%2F__init__.py?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86"
        },
        {
            "sha": "1d070f82ab34cf033c5454783eb6bb378964bdab",
            "filename": "tests/models/minimax_m2/test_modeling_minimax_m2.py",
            "status": "added",
            "additions": 162,
            "deletions": 0,
            "changes": 162,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/tests%2Fmodels%2Fminimax_m2%2Ftest_modeling_minimax_m2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/tests%2Fmodels%2Fminimax_m2%2Ftest_modeling_minimax_m2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fminimax_m2%2Ftest_modeling_minimax_m2.py?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -0,0 +1,162 @@\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch MiniMaxM2 model.\"\"\"\n+\n+import unittest\n+\n+from transformers import AutoTokenizer, is_torch_available\n+from transformers.testing_utils import (\n+    Expectations,\n+    cleanup,\n+    is_flaky,\n+    require_torch,\n+    require_torch_accelerator,\n+    slow,\n+    torch_device,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import (\n+        MiniMaxM2ForCausalLM,\n+        MiniMaxM2Model,\n+    )\n+\n+from ...causal_lm_tester import CausalLMModelTest, CausalLMModelTester\n+\n+\n+class MiniMaxM2ModelTester(CausalLMModelTester):\n+    if is_torch_available():\n+        base_model_class = MiniMaxM2Model\n+\n+\n+@require_torch\n+class MiniMaxM2ModelTest(CausalLMModelTest, unittest.TestCase):\n+    model_tester_class = MiniMaxM2ModelTester\n+\n+    @is_flaky(max_attempts=2)\n+    def test_load_balancing_loss(self):\n+        r\"\"\"\n+        Let's make sure we can actually compute the loss and do a backward on it.\n+        \"\"\"\n+        config, input_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+        config.num_labels = 3\n+        config.num_experts = 3\n+        config.output_router_logits = True\n+        input_ids = input_dict[\"input_ids\"]\n+        attention_mask = input_ids.ne(config.pad_token_id).to(torch_device)\n+        model = MiniMaxM2ForCausalLM(config)\n+        model.to(torch_device)\n+        model.eval()\n+        result = model(input_ids, attention_mask=attention_mask)\n+        bs, seqlen = input_ids.shape\n+        self.assertEqual(result.router_logits[0].shape, (bs * seqlen, config.num_experts))\n+        torch.testing.assert_close(result.aux_loss.cpu(), torch.tensor(2, dtype=torch.float32), rtol=1e-2, atol=1e-2)\n+\n+        # First, we make sure that adding padding tokens doesn't change the loss\n+        # loss(input_ids, attention_mask=None) == loss(input_ids + padding, attention_mask=attention_mask_with_padding)\n+        # (This length is selected from experiments)\n+        pad_length = input_ids.shape[1] * 4\n+        # Add padding tokens to input_ids\n+        padding_block = config.pad_token_id * torch.ones(input_ids.shape[0], pad_length, dtype=torch.int32).to(\n+            torch_device\n+        )\n+        padded_input_ids = torch.cat((padding_block, input_ids), dim=1)  # this is to simulate padding to the left\n+        padded_attention_mask = padded_input_ids.ne(config.pad_token_id).to(torch_device)\n+\n+        padded_result = model(padded_input_ids, attention_mask=padded_attention_mask)\n+        torch.testing.assert_close(result.aux_loss.cpu(), padded_result.aux_loss.cpu(), rtol=1e-4, atol=1e-4)\n+\n+        # We make sure that the loss of including padding tokens != the loss without padding tokens\n+        # if attention_mask=None --> we don't exclude padding tokens\n+        include_padding_result = model(padded_input_ids, attention_mask=None)\n+\n+        # This is to mimic torch.testing.assert_not_close\n+        self.assertNotAlmostEqual(include_padding_result.aux_loss.item(), result.aux_loss.item())\n+\n+\n+@slow\n+@require_torch\n+class MiniMaxM2IntegrationTest(unittest.TestCase):\n+    def setup(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    def tearDown(self):\n+        # TODO (joao): automatic compilation, i.e. compilation when `cache_implementation=\"static\"` is used, leaves\n+        # some memory allocated in the cache, which means some object is not being released properly. This causes some\n+        # unoptimal memory usage, e.g. after certain tests a 7B model in FP16 no longer fits in a 24GB GPU.\n+        # Investigate the root cause.\n+        cleanup(torch_device, gc_collect=True)\n+\n+    @require_torch_accelerator\n+    def test_small_model_logits_batched(self):\n+        model_id = \"hf-internal-testing/MiniMax-M2-Small\"\n+        dummy_input = torch.LongTensor([[0, 0, 0, 0, 0, 0, 1, 2, 3], [1, 1, 2, 3, 4, 5, 6, 7, 8]]).to(torch_device)\n+        attention_mask = dummy_input.ne(0).to(torch.long)\n+\n+        model = MiniMaxM2ForCausalLM.from_pretrained(\n+            model_id, dtype=\"auto\", device_map=\"auto\", experts_implementation=\"eager\"\n+        )\n+\n+        EXPECTED_LOGITS_LEFT_UNPADDED = Expectations(\n+            {\n+                (\"cuda\", 8): [[1.1094, -1.5352, -1.5811], [1.9395, 0.1461, -1.5537], [1.7803, 0.2466, -0.4316]],\n+            }\n+        )\n+        expected_left_unpadded = torch.tensor(EXPECTED_LOGITS_LEFT_UNPADDED.get_expectation(), device=torch_device)\n+\n+        EXPECTED_LOGITS_RIGHT_UNPADDED = Expectations(\n+            {\n+                (\"cuda\", 8): [[0.8135, -1.8164, -1.5898], [0.0663, -1.3408, -0.5435], [0.5396, 0.3293, -1.7529]],\n+            }\n+        )\n+        expected_right_unpadded = torch.tensor(EXPECTED_LOGITS_RIGHT_UNPADDED.get_expectation(), device=torch_device)\n+\n+        with torch.no_grad():\n+            logits = model(dummy_input, attention_mask=attention_mask).logits\n+        logits = logits.float()\n+\n+        torch.testing.assert_close(\n+            logits[0, -3:, -3:],\n+            expected_left_unpadded,\n+            atol=1e-3,\n+            rtol=1e-3,\n+        )\n+        torch.testing.assert_close(\n+            logits[1, -3:, -3:],\n+            expected_right_unpadded,\n+            atol=1e-3,\n+            rtol=1e-3,\n+        )\n+\n+    def test_small_model_generation(self):\n+        expected_texts = Expectations(\n+            {\n+                (\"cuda\", 8): 'Tell me about the french revolution. Pemkab Pemkab Ø§Ù„Ù…ØªØ§Ø­Ø©/journal blinded blindedÃ©bÃ©æŠ“ç®—ä¸ä¸Š blinded blinded healthiest.ClÃ©bÃ© Bronxå¼€å¯äº† Bronx BronxæŠ½æ ·ikatç³œ BronxSources TODOSources parfum Bronx parfum donde donde donde Ø§Ùˆ',\n+            }\n+        )  # fmt: skip\n+        EXPECTED_TEXT = expected_texts.get_expectation()\n+\n+        tokenizer = AutoTokenizer.from_pretrained(\"MiniMaxAI/MiniMax-M2\")\n+        model = MiniMaxM2ForCausalLM.from_pretrained(\n+            \"hf-internal-testing/MiniMax-M2-Small\", device_map=\"auto\", dtype=\"auto\", experts_implementation=\"eager\"\n+        )\n+        input_text = [\"Tell me about the french revolution.\"]\n+        model_inputs = tokenizer(input_text, return_tensors=\"pt\").to(model.device)\n+\n+        generated_ids = model.generate(**model_inputs, max_new_tokens=32, do_sample=False)\n+        generated_text = tokenizer.decode(generated_ids[0], skip_special_tokens=True)\n+        self.assertEqual(generated_text, EXPECTED_TEXT)"
        },
        {
            "sha": "122cab45e4a3b2397547a46c5e6f7f3890eecd81",
            "filename": "tests/quantization/finegrained_fp8/test_fp8.py",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/7a2bf25f36264f3f5409d2743722e4f6b3504e86/tests%2Fquantization%2Ffinegrained_fp8%2Ftest_fp8.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/7a2bf25f36264f3f5409d2743722e4f6b3504e86/tests%2Fquantization%2Ffinegrained_fp8%2Ftest_fp8.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fquantization%2Ffinegrained_fp8%2Ftest_fp8.py?ref=7a2bf25f36264f3f5409d2743722e4f6b3504e86",
            "patch": "@@ -376,7 +376,6 @@ def test_compute_module_sizes(self):\n         # we should at least have 1.5 times memory reduction in total\n         assert model_size[\"\"] > quantized_model_size[\"\"] * 1.5\n \n-    @unittest.skip(reason=\"Dependent on #42028, will be removed alongside that PR\")\n     def test_quantized_moe_forward(self):\n         \"\"\"\n         Checks implicitly if the moe implementation is correct, i.e. it does not crash for cases"
        }
    ],
    "stats": {
        "total": 1560,
        "additions": 1559,
        "deletions": 1
    }
}