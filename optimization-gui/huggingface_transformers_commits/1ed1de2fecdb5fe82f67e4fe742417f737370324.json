{
    "author": "stevhliu",
    "message": "[docs] Increase visibility of torch_dtype=\"auto\" (#35067)\n\n* auto-dtype\r\n\r\n* feedback",
    "sha": "1ed1de2fecdb5fe82f67e4fe742417f737370324",
    "files": [
        {
            "sha": "33f48b2b043fec9e6ea13bfa43e1fadb669558bd",
            "filename": "docs/source/en/autoclass_tutorial.md",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/huggingface/transformers/blob/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fautoclass_tutorial.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fautoclass_tutorial.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fautoclass_tutorial.md?ref=1ed1de2fecdb5fe82f67e4fe742417f737370324",
            "patch": "@@ -138,20 +138,23 @@ Load a processor with [`AutoProcessor.from_pretrained`]:\n \n <frameworkcontent>\n <pt>\n-The `AutoModelFor` classes let you load a pretrained model for a given task (see [here](model_doc/auto) for a complete list of available tasks). For example, load a model for sequence classification with [`AutoModelForSequenceClassification.from_pretrained`]:\n+The `AutoModelFor` classes let you load a pretrained model for a given task (see [here](model_doc/auto) for a complete list of available tasks). For example, load a model for sequence classification with [`AutoModelForSequenceClassification.from_pretrained`].\n+\n+> [!WARNING]\n+> By default, the weights are loaded in full precision (torch.float32) regardless of the actual data type the weights are stored in such as torch.float16. Set `torch_dtype=\"auto\"` to load the weights in the data type defined in a model's `config.json` file to automatically load the most memory-optimal data type.\n \n ```py\n >>> from transformers import AutoModelForSequenceClassification\n \n->>> model = AutoModelForSequenceClassification.from_pretrained(\"distilbert/distilbert-base-uncased\")\n+>>> model = AutoModelForSequenceClassification.from_pretrained(\"distilbert/distilbert-base-uncased\", torch_dtype=\"auto\")\n ```\n \n Easily reuse the same checkpoint to load an architecture for a different task:\n \n ```py\n >>> from transformers import AutoModelForTokenClassification\n \n->>> model = AutoModelForTokenClassification.from_pretrained(\"distilbert/distilbert-base-uncased\")\n+>>> model = AutoModelForTokenClassification.from_pretrained(\"distilbert/distilbert-base-uncased\", torch_dtype=\"auto\")\n ```\n \n <Tip warning={true}>"
        },
        {
            "sha": "e97ace8a625050ac4440487ae8c821d05b1410fa",
            "filename": "docs/source/en/llm_optims.md",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fllm_optims.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fllm_optims.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fllm_optims.md?ref=1ed1de2fecdb5fe82f67e4fe742417f737370324",
            "patch": "@@ -57,7 +57,7 @@ import os\n os.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"  # To prevent long warnings :)\n \n tokenizer = AutoTokenizer.from_pretrained(\"google/gemma-2b\")\n-model = AutoModelForCausalLM.from_pretrained(\"google/gemma-2b\", device_map=\"auto\")\n+model = AutoModelForCausalLM.from_pretrained(\"google/gemma-2b\", torch_dtype=\"auto\", device_map=\"auto\")\n \n model.generation_config.cache_implementation = \"static\"\n \n@@ -89,7 +89,7 @@ import os\n os.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"  # To prevent long warnings :)\n \n tokenizer = AutoTokenizer.from_pretrained(\"google/gemma-2b\")\n-model = AutoModelForCausalLM.from_pretrained(\"google/gemma-2b\", device_map=\"auto\")\n+model = AutoModelForCausalLM.from_pretrained(\"google/gemma-2b\", torch_dtype=\"auto\", device_map=\"auto\")\n \n model.forward = torch.compile(model.forward, mode=\"reduce-overhead\", fullgraph=True)\n input_text = \"The theory of special relativity states \"\n@@ -202,7 +202,7 @@ import os\n os.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"  # To prevent long warnings :)\n \n tokenizer = AutoTokenizer.from_pretrained(\"google/gemma-2b\")\n-model = AutoModelForCausalLM.from_pretrained(\"google/gemma-2b\", device_map=\"auto\")\n+model = AutoModelForCausalLM.from_pretrained(\"google/gemma-2b\", torch_dtype=\"auto\", device_map=\"auto\")\n \n model.generate = torch.compile(model.generate, mode=\"reduce-overhead\", fullgraph=True)\n input_text = \"The theory of special relativity states \"\n@@ -249,7 +249,7 @@ device, _, _ = get_backend() # automatically detects the underlying device type\n tokenizer = AutoTokenizer.from_pretrained(\"facebook/opt-1.3b\")\n inputs = tokenizer(\"Einstein's theory of relativity states\", return_tensors=\"pt\").to(device)\n \n-model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-1.3b\").to(device)\n+model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-1.3b\", torch_dtype=\"auto\").to(device)\n assistant_model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-125m\").to(device)\n outputs = model.generate(**inputs, assistant_model=assistant_model)\n tokenizer.batch_decode(outputs, skip_special_tokens=True)\n@@ -271,7 +271,7 @@ device, _, _ = get_backend() # automatically detects the underlying device type\n tokenizer = AutoTokenizer.from_pretrained(\"facebook/opt-1.3b\")\n inputs = tokenizer(\"Einstein's theory of relativity states\", return_tensors=\"pt\").to(device)\n \n-model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-1.3b\").to(device)\n+model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-1.3b\", torch_dtype=\"auto\").to(device)\n assistant_model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-125m\").to(device)\n outputs = model.generate(**inputs, assistant_model=assistant_model, do_sample=True, temperature=0.7)\n print(tokenizer.batch_decode(outputs, skip_special_tokens=True))\n@@ -300,7 +300,7 @@ device, _, _ = get_backend() # automatically detects the underlying device type\n tokenizer = AutoTokenizer.from_pretrained(\"facebook/opt-1.3b\")\n inputs = tokenizer(\"The second law of thermodynamics states\", return_tensors=\"pt\").to(device)\n \n-model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-1.3b\").to(device)\n+model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-1.3b\", torch_dtype=\"auto\").to(device)\n assistant_model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-125m\").to(device)\n outputs = model.generate(**inputs, prompt_lookup_num_tokens=3)\n print(tokenizer.batch_decode(outputs, skip_special_tokens=True))\n@@ -322,7 +322,7 @@ device, _, _ = get_backend() # automatically detects the underlying device type\n tokenizer = AutoTokenizer.from_pretrained(\"facebook/opt-1.3b\")\n inputs = tokenizer(\"The second law of thermodynamics states\", return_tensors=\"pt\").to(device)\n \n-model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-1.3b\").to(device)\n+model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-1.3b\", torch_dtype=\"auto\").to(device)\n outputs = model.generate(**inputs, prompt_lookup_num_tokens=3, do_sample=True, temperature=0.7)\n print(tokenizer.batch_decode(outputs, skip_special_tokens=True))\n [\"The second law of thermodynamics states that energy cannot be created nor destroyed. It's not a\"]"
        },
        {
            "sha": "7f8b525b3df610123e97abe2bd8f8097ffe66984",
            "filename": "docs/source/en/perf_infer_cpu.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fperf_infer_cpu.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fperf_infer_cpu.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fperf_infer_cpu.md?ref=1ed1de2fecdb5fe82f67e4fe742417f737370324",
            "patch": "@@ -41,7 +41,7 @@ Enable BetterTransformer with the [`PreTrainedModel.to_bettertransformer`] metho\n ```py\n from transformers import AutoModelForCausalLM\n \n-model = AutoModelForCausalLM.from_pretrained(\"bigcode/starcoder\")\n+model = AutoModelForCausalLM.from_pretrained(\"bigcode/starcoder\", torch_dtype=\"auto\")\n ```\n \n ## TorchScript"
        },
        {
            "sha": "12f492ff29a5ee01401c39f238f0ab1693416212",
            "filename": "docs/source/en/perf_infer_gpu_one.md",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/huggingface/transformers/blob/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md?ref=1ed1de2fecdb5fe82f67e4fe742417f737370324",
            "patch": "@@ -405,7 +405,7 @@ To load a model in 4-bit for inference, use the `load_in_4bit` parameter. The `d\n from transformers import AutoModelForCausalLM\n \n model_name = \"bigscience/bloom-2b5\"\n-model_4bit = AutoModelForCausalLM.from_pretrained(model_name, device_map=\"auto\", load_in_4bit=True)\n+model_4bit = AutoModelForCausalLM.from_pretrained(model_name, torch_dtype=\"auto\", device_map=\"auto\", load_in_4bit=True)\n ```\n \n To load a model in 4-bit for inference with multiple GPUs, you can control how much GPU RAM you want to allocate to each GPU. For example, to distribute 600MB of memory to the first GPU and 1GB of memory to the second GPU:\n@@ -414,7 +414,7 @@ To load a model in 4-bit for inference with multiple GPUs, you can control how m\n max_memory_mapping = {0: \"600MB\", 1: \"1GB\"}\n model_name = \"bigscience/bloom-3b\"\n model_4bit = AutoModelForCausalLM.from_pretrained(\n-    model_name, device_map=\"auto\", load_in_4bit=True, max_memory=max_memory_mapping\n+    model_name, torch_dtype=\"auto\", device_map=\"auto\", load_in_4bit=True, max_memory=max_memory_mapping\n )\n ```\n \n@@ -432,7 +432,7 @@ To load a model in 8-bit for inference, use the `load_in_8bit` parameter. The `d\n from transformers import AutoModelForCausalLM, BitsAndBytesConfig\n \n model_name = \"bigscience/bloom-2b5\"\n-model_8bit = AutoModelForCausalLM.from_pretrained(model_name, quantization_config=BitsAndBytesConfig(load_in_8bit=True))\n+model_8bit = AutoModelForCausalLM.from_pretrained(model_name, torch_dtype=\"auto\", quantization_config=BitsAndBytesConfig(load_in_8bit=True))\n ```\n \n If you're loading a model in 8-bit for text generation, you should use the [`~transformers.GenerationMixin.generate`] method instead of the [`Pipeline`] function which is not optimized for 8-bit models and will be slower. Some sampling strategies, like nucleus sampling, are also not supported by the [`Pipeline`] for 8-bit models. You should also place all inputs on the same device as the model:\n@@ -442,7 +442,7 @@ from transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig\n \n model_name = \"bigscience/bloom-2b5\"\n tokenizer = AutoTokenizer.from_pretrained(model_name)\n-model_8bit = AutoModelForCausalLM.from_pretrained(model_name, quantization_config=BitsAndBytesConfig(load_in_8bit=True))\n+model_8bit = AutoModelForCausalLM.from_pretrained(model_name, torch_dtype=\"auto\", quantization_config=BitsAndBytesConfig(load_in_8bit=True))\n \n prompt = \"Hello, my llama is cute\"\n inputs = tokenizer(prompt, return_tensors=\"pt\").to(\"cuda\")\n@@ -456,7 +456,7 @@ To load a model in 4-bit for inference with multiple GPUs, you can control how m\n max_memory_mapping = {0: \"1GB\", 1: \"2GB\"}\n model_name = \"bigscience/bloom-3b\"\n model_8bit = AutoModelForCausalLM.from_pretrained(\n-    model_name, device_map=\"auto\", load_in_8bit=True, max_memory=max_memory_mapping\n+    model_name, torch_dtype=\"auto\", device_map=\"auto\", load_in_8bit=True, max_memory=max_memory_mapping\n )\n ```\n \n@@ -515,7 +515,7 @@ quantization_config = BitsAndBytesConfig(\n )\n \n tokenizer = AutoTokenizer.from_pretrained(\"facebook/opt-350m\")\n-model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-350m\", quantization_config=quantization_config)\n+model = AutoModelForCausalLM.from_pretrained(\"facebook/opt-350m\", torch_dtype=\"auto\", quantization_config=quantization_config)\n \n # enable BetterTransformer\n model = model.to_bettertransformer()"
        },
        {
            "sha": "357bc7f636ec259a7687a69d07aa6af37fed5374",
            "filename": "docs/source/en/pipeline_tutorial.md",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fpipeline_tutorial.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fpipeline_tutorial.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fpipeline_tutorial.md?ref=1ed1de2fecdb5fe82f67e4fe742417f737370324",
            "patch": "@@ -59,10 +59,10 @@ Let's try the [Whisper large-v2](https://huggingface.co/openai/whisper-large-v2)\n benchmarks. It also has the added benefit of predicting punctuation and casing, neither of which are possible with  \n Wav2Vec2.\n \n-Let's give it a try here to see how it performs:\n+Let's give it a try here to see how it performs. Set `torch_dtype=\"auto\"` to automatically load the most memory-efficient data type the weights are stored in.\n \n ```py\n->>> transcriber = pipeline(model=\"openai/whisper-large-v2\")\n+>>> transcriber = pipeline(model=\"openai/whisper-large-v2\", torch_dtype=\"auto\")\n >>> transcriber(\"https://huggingface.co/datasets/Narsil/asr_dummy/resolve/main/mlk.flac\")\n {'text': ' I have a dream that one day this nation will rise up and live out the true meaning of its creed.'}\n ```"
        },
        {
            "sha": "6c6b92d0a6e594f727c2b9e9ebc42732a9be997f",
            "filename": "docs/source/en/quantization/bitsandbytes.md",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/huggingface/transformers/blob/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fquantization%2Fbitsandbytes.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fquantization%2Fbitsandbytes.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fquantization%2Fbitsandbytes.md?ref=1ed1de2fecdb5fe82f67e4fe742417f737370324",
            "patch": "@@ -64,7 +64,7 @@ model_8bit = AutoModelForCausalLM.from_pretrained(\n )\n ```\n \n-By default, all the other modules such as `torch.nn.LayerNorm` are converted to `torch.float16`. You can change the data type of these modules with the `torch_dtype` parameter if you want:\n+By default, all the other modules such as `torch.nn.LayerNorm` are converted to `torch.float16`. You can change the data type of these modules with the `torch_dtype` parameter if you want. Setting `torch_dtype=\"auto\"` loads the model in the data type defined in a model's `config.json` file.\n \n ```py\n import torch\n@@ -75,7 +75,7 @@ quantization_config = BitsAndBytesConfig(load_in_8bit=True)\n model_8bit = AutoModelForCausalLM.from_pretrained(\n     \"facebook/opt-350m\", \n     quantization_config=quantization_config, \n-    torch_dtype=torch.float32\n+    torch_dtype=\"auto\"\n )\n model_8bit.model.decoder.layers[-1].final_layer_norm.weight.dtype\n ```\n@@ -112,7 +112,7 @@ model_4bit = AutoModelForCausalLM.from_pretrained(\n )\n ```\n \n-By default, all the other modules such as `torch.nn.LayerNorm` are converted to `torch.float16`. You can change the data type of these modules with the `torch_dtype` parameter if you want:\n+By default, all the other modules such as `torch.nn.LayerNorm` are converted to `torch.float16`. You can change the data type of these modules with the `torch_dtype` parameter if you want. Setting `torch_dtype=\"auto\"` loads the model in the data type defined in a model's `config.json` file.\n \n ```py\n import torch\n@@ -123,7 +123,7 @@ quantization_config = BitsAndBytesConfig(load_in_4bit=True)\n model_4bit = AutoModelForCausalLM.from_pretrained(\n     \"facebook/opt-350m\",\n     quantization_config=quantization_config, \n-    torch_dtype=torch.float32\n+    torch_dtype=\"auto\"\n )\n model_4bit.model.decoder.layers[-1].final_layer_norm.weight.dtype\n ```\n@@ -190,6 +190,7 @@ Now load your model with the custom `device_map` and `quantization_config`:\n ```py\n model_8bit = AutoModelForCausalLM.from_pretrained(\n     \"bigscience/bloom-1b7\",\n+    torch_dtype=\"auto\",\n     device_map=device_map,\n     quantization_config=quantization_config,\n )\n@@ -212,6 +213,7 @@ quantization_config = BitsAndBytesConfig(\n \n model_8bit = AutoModelForCausalLM.from_pretrained(\n     model_id,\n+    torch_dtype=\"auto\",\n     device_map=device_map,\n     quantization_config=quantization_config,\n )\n@@ -232,6 +234,7 @@ quantization_config = BitsAndBytesConfig(\n \n model_8bit = AutoModelForCausalLM.from_pretrained(\n     model_id,\n+    torch_dtype=\"auto\",\n     device_map=\"auto\",\n     quantization_config=quantization_config,\n )\n@@ -275,7 +278,7 @@ nf4_config = BitsAndBytesConfig(\n     bnb_4bit_quant_type=\"nf4\",\n )\n \n-model_nf4 = AutoModelForCausalLM.from_pretrained(model_id, quantization_config=nf4_config)\n+model_nf4 = AutoModelForCausalLM.from_pretrained(model_id, torch_dtype=\"auto\", quantization_config=nf4_config)\n ```\n \n For inference, the `bnb_4bit_quant_type` does not have a huge impact on performance. However, to remain consistent with the model weights, you should use the `bnb_4bit_compute_dtype` and `torch_dtype` values.\n@@ -292,7 +295,7 @@ double_quant_config = BitsAndBytesConfig(\n     bnb_4bit_use_double_quant=True,\n )\n \n-model_double_quant = AutoModelForCausalLM.from_pretrained(\"meta-llama/Llama-2-13b\", quantization_config=double_quant_config)\n+model_double_quant = AutoModelForCausalLM.from_pretrained(\"meta-llama/Llama-2-13b\", torch_dtype=\"auto\", quantization_config=double_quant_config)\n ```\n \n ## Dequantizing `bitsandbytes` models"
        },
        {
            "sha": "61cf8a059bf2776ecebc0fa4c8f2572f22439c6e",
            "filename": "docs/source/en/quantization/fbgemm_fp8.md",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fquantization%2Ffbgemm_fp8.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fquantization%2Ffbgemm_fp8.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fquantization%2Ffbgemm_fp8.md?ref=1ed1de2fecdb5fe82f67e4fe742417f737370324",
            "patch": "@@ -33,13 +33,14 @@ pip install --upgrade accelerate fbgemm-gpu torch\n \n If you are having issues with fbgemm-gpu and torch library, you might need to install the nightly release. You can follow the instruction [here](https://pytorch.org/FBGEMM/fbgemm_gpu-development/InstallationInstructions.html#fbgemm-gpu-install-libraries:~:text=found%20here.-,Install%20the%20FBGEMM_GPU%20Package,-Install%20through%20PyTorch)\n \n+By default, the weights are loaded in full precision (torch.float32) regardless of the actual data type the weights are stored in such as torch.float16. Set `torch_dtype=\"auto\"` to load the weights in the data type defined in a model's `config.json` file to automatically load the most memory-optimal data type.\n \n ```py\n from transformers import FbgemmFp8Config, AutoModelForCausalLM, AutoTokenizer\n \n model_name = \"meta-llama/Meta-Llama-3-8B\"\n quantization_config = FbgemmFp8Config()\n-quantized_model = AutoModelForCausalLM.from_pretrained(model_name, device_map=\"auto\", quantization_config=quantization_config)\n+quantized_model = AutoModelForCausalLM.from_pretrained(model_name, torch_dtype=\"auto\", device_map=\"auto\", quantization_config=quantization_config)\n \n tokenizer = AutoTokenizer.from_pretrained(model_name)\n input_text = \"What are we having for dinner?\""
        },
        {
            "sha": "7feadefd83d2aa94d8b68e1bd29d2d7702386975",
            "filename": "docs/source/en/quantization/quanto.md",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fquantization%2Fquanto.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fquantization%2Fquanto.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fquantization%2Fquanto.md?ref=1ed1de2fecdb5fe82f67e4fe742417f737370324",
            "patch": "@@ -42,15 +42,17 @@ pip install optimum-quanto accelerate transformers\n \n Now you can quantize a model by passing [`QuantoConfig`] object in the [`~PreTrainedModel.from_pretrained`] method. This works for any model in any modality, as long as it contains `torch.nn.Linear` layers. \n \n-The integration with transformers only supports weights quantization. For the more complex use case such as activation quantization, calibration and quantization aware training, you should use [optimum-quanto](https://github.com/huggingface/optimum-quanto) library instead. \n+The integration with transformers only supports weights quantization. For the more complex use case such as activation quantization, calibration and quantization aware training, you should use [optimum-quanto](https://github.com/huggingface/optimum-quanto) library instead.\n+\n+By default, the weights are loaded in full precision (torch.float32) regardless of the actual data type the weights are stored in such as torch.float16. Set `torch_dtype=\"auto\"` to load the weights in the data type defined in a model's `config.json` file to automatically load the most memory-optimal data type.\n \n ```py\n from transformers import AutoModelForCausalLM, AutoTokenizer, QuantoConfig\n \n model_id = \"facebook/opt-125m\"\n tokenizer = AutoTokenizer.from_pretrained(model_id)\n quantization_config = QuantoConfig(weights=\"int8\")\n-quantized_model = AutoModelForCausalLM.from_pretrained(model_id, device_map=\"cuda:0\", quantization_config=quantization_config)\n+quantized_model = AutoModelForCausalLM.from_pretrained(model_id, torch_dtype=\"auto\", device_map=\"cuda:0\", quantization_config=quantization_config)\n ```\n \n Note that serialization is not supported yet with transformers but it is coming soon! If you want to save the model, you can use quanto library instead."
        },
        {
            "sha": "38f7c074c97d904146705b27b8a7a8a9ab39282a",
            "filename": "docs/source/en/quantization/torchao.md",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fquantization%2Ftorchao.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fquantization%2Ftorchao.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fquantization%2Ftorchao.md?ref=1ed1de2fecdb5fe82f67e4fe742417f737370324",
            "patch": "@@ -19,6 +19,7 @@ Before you begin, make sure the following libraries are installed with their lat\n pip install --upgrade torch torchao\n ```\n \n+By default, the weights are loaded in full precision (torch.float32) regardless of the actual data type the weights are stored in such as torch.float16. Set `torch_dtype=\"auto\"` to load the weights in the data type defined in a model's `config.json` file to automatically load the most memory-optimal data type.\n \n ```py\n import torch\n@@ -28,7 +29,7 @@ model_name = \"meta-llama/Meta-Llama-3-8B\"\n # We support int4_weight_only, int8_weight_only and int8_dynamic_activation_int8_weight\n # More examples and documentations for arguments can be found in https://github.com/pytorch/ao/tree/main/torchao/quantization#other-available-quantization-techniques\n quantization_config = TorchAoConfig(\"int4_weight_only\", group_size=128)\n-quantized_model = AutoModelForCausalLM.from_pretrained(model_name, device_map=\"auto\", quantization_config=quantization_config)\n+quantized_model = AutoModelForCausalLM.from_pretrained(model_name, torch_dtype=\"auto\", device_map=\"auto\", quantization_config=quantization_config)\n \n tokenizer = AutoTokenizer.from_pretrained(model_name)\n input_text = \"What are we having for dinner?\""
        },
        {
            "sha": "70afa1ea57107f2fca9021d8bf09e40978bbdda5",
            "filename": "docs/source/en/quicktour.md",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/huggingface/transformers/blob/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fquicktour.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Fquicktour.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fquicktour.md?ref=1ed1de2fecdb5fe82f67e4fe742417f737370324",
            "patch": "@@ -245,13 +245,15 @@ Check out the [preprocess](./preprocessing) tutorial for more details about toke\n \n <frameworkcontent>\n <pt>\n-ðŸ¤— Transformers provides a simple and unified way to load pretrained instances. This means you can load an [`AutoModel`] like you would load an [`AutoTokenizer`]. The only difference is selecting the correct [`AutoModel`] for the task. For text (or sequence) classification, you should load [`AutoModelForSequenceClassification`]:\n+ðŸ¤— Transformers provides a simple and unified way to load pretrained instances. This means you can load an [`AutoModel`] like you would load an [`AutoTokenizer`]. The only difference is selecting the correct [`AutoModel`] for the task. For text (or sequence) classification, you should load [`AutoModelForSequenceClassification`].\n+\n+By default, the weights are loaded in full precision (torch.float32) regardless of the actual data type the weights are stored in such as torch.float16. Set `torch_dtype=\"auto\"` to load the weights in the data type defined in a model's `config.json` file to automatically load the most memory-optimal data type.\n \n ```py\n >>> from transformers import AutoModelForSequenceClassification\n \n >>> model_name = \"nlptown/bert-base-multilingual-uncased-sentiment\"\n->>> pt_model = AutoModelForSequenceClassification.from_pretrained(model_name)\n+>>> pt_model = AutoModelForSequenceClassification.from_pretrained(model_name, torch_dtype=\"auto\")\n ```\n \n <Tip>\n@@ -416,12 +418,12 @@ All models are a standard [`torch.nn.Module`](https://pytorch.org/docs/stable/nn\n \n Depending on your task, you'll typically pass the following parameters to [`Trainer`]:\n \n-1. You'll start with a [`PreTrainedModel`] or a [`torch.nn.Module`](https://pytorch.org/docs/stable/nn.html#torch.nn.Module):\n+1. You'll start with a [`PreTrainedModel`] or a [`torch.nn.Module`](https://pytorch.org/docs/stable/nn.html#torch.nn.Module). Set `torch_dtype=\"auto\"` to automatically load the most memory-efficient data type the weights are stored in.\n \n    ```py\n    >>> from transformers import AutoModelForSequenceClassification\n \n-   >>> model = AutoModelForSequenceClassification.from_pretrained(\"distilbert/distilbert-base-uncased\")\n+   >>> model = AutoModelForSequenceClassification.from_pretrained(\"distilbert/distilbert-base-uncased\", torch_dtype=\"auto\")\n    ```\n \n 2. [`TrainingArguments`] contains the model hyperparameters you can change like learning rate, batch size, and the number of epochs to train for. The default values are used if you don't specify any training arguments:"
        },
        {
            "sha": "fa6ef0c0da6e4b3e8198846cb87bac45dabc857a",
            "filename": "docs/source/en/training.md",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Ftraining.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1ed1de2fecdb5fe82f67e4fe742417f737370324/docs%2Fsource%2Fen%2Ftraining.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Ftraining.md?ref=1ed1de2fecdb5fe82f67e4fe742417f737370324",
            "patch": "@@ -81,12 +81,14 @@ just use the button at the top-right of that framework's block!\n \n ðŸ¤— Transformers provides a [`Trainer`] class optimized for training ðŸ¤— Transformers models, making it easier to start training without manually writing your own training loop. The [`Trainer`] API supports a wide range of training options and features such as logging, gradient accumulation, and mixed precision.\n \n-Start by loading your model and specify the number of expected labels. From the Yelp Review [dataset card](https://huggingface.co/datasets/yelp_review_full#data-fields), you know there are five labels:\n+Start by loading your model and specify the number of expected labels. From the Yelp Review [dataset card](https://huggingface.co/datasets/yelp_review_full#data-fields), you know there are five labels.\n+\n+By default, the weights are loaded in full precision (torch.float32) regardless of the actual data type the weights are stored in such as torch.float16. Set `torch_dtype=\"auto\"` to load the weights in the data type defined in a model's `config.json` file to automatically load the most memory-optimal data type.\n \n ```py\n >>> from transformers import AutoModelForSequenceClassification\n \n->>> model = AutoModelForSequenceClassification.from_pretrained(\"google-bert/bert-base-cased\", num_labels=5)\n+>>> model = AutoModelForSequenceClassification.from_pretrained(\"google-bert/bert-base-cased\", num_labels=5, torch_dtype=\"auto\")\n ```\n \n <Tip>"
        }
    ],
    "stats": {
        "total": 84,
        "additions": 49,
        "deletions": 35
    }
}