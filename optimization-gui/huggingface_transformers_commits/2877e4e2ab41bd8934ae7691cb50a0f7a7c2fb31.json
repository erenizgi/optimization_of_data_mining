{
    "author": "juliendenize",
    "message": "Inherit from PreTrainedTokenizerBase (#43143)\n\n* Inherit from PreTrainedTokenizerBase\n\n* Improve docs\n\n* ruff\n\n* Typing\n\n* Ruff",
    "sha": "2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31",
    "files": [
        {
            "sha": "8bd8dc5415de768d37f8a11732d80e06bdabc561",
            "filename": "setup.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31/setup.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31/setup.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/setup.py?ref=2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31",
            "patch": "@@ -156,7 +156,7 @@\n     \"libcst\",\n     \"rich\",\n     \"opentelemetry-api\",\n-    \"mistral-common[opencv]>=1.6.3\",\n+    \"mistral-common[image]>=1.8.8\",\n ]\n \n \n@@ -266,7 +266,7 @@ def run(self):\n extras[\"num2words\"] = deps_list(\"num2words\")\n extras[\"sentencepiece\"] = deps_list(\"sentencepiece\", \"protobuf\")\n extras[\"tiktoken\"] = deps_list(\"tiktoken\", \"blobfile\")\n-extras[\"mistral-common\"] = deps_list(\"mistral-common[opencv]\")\n+extras[\"mistral-common\"] = deps_list(\"mistral-common[image]\")\n extras[\"chat_template\"] = deps_list(\"jinja2\", \"jmespath\")\n extras[\"testing\"] = (\n     deps_list("
        },
        {
            "sha": "c89f04beda68e6c50d1506ea74bca7fee42ceb41",
            "filename": "src/transformers/dependency_versions_table.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31/src%2Ftransformers%2Fdependency_versions_table.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31/src%2Ftransformers%2Fdependency_versions_table.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fdependency_versions_table.py?ref=2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31",
            "patch": "@@ -91,5 +91,5 @@\n     \"libcst\": \"libcst\",\n     \"rich\": \"rich\",\n     \"opentelemetry-api\": \"opentelemetry-api\",\n-    \"mistral-common[opencv]\": \"mistral-common[opencv]>=1.6.3\",\n+    \"mistral-common[image]\": \"mistral-common[image]>=1.8.8\",\n }"
        },
        {
            "sha": "e878e20940cfb458d5408d0b3f8d72965aad30b2",
            "filename": "src/transformers/tokenization_mistral_common.py",
            "status": "modified",
            "additions": 551,
            "deletions": 900,
            "changes": 1451,
            "blob_url": "https://github.com/huggingface/transformers/blob/2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31/src%2Ftransformers%2Ftokenization_mistral_common.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31/src%2Ftransformers%2Ftokenization_mistral_common.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Ftokenization_mistral_common.py?ref=2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31",
            "patch": "@@ -14,39 +14,39 @@\n import os\n import re\n import shutil\n-import warnings\n-from collections.abc import Callable, Mapping, Sized\n+from collections.abc import Callable, Sequence\n from enum import Enum\n from pathlib import Path\n-from typing import Any, Union, overload\n+from typing import Any, Literal, Union, overload\n \n import numpy as np\n from huggingface_hub import create_repo\n \n from transformers.audio_utils import load_audio_as\n from transformers.tokenization_utils_base import (\n-    LARGE_INTEGER,\n     VERY_LARGE_INTEGER,\n+    AddedToken,\n     BatchEncoding,\n     EncodedInput,\n     PreTokenizedInput,\n+    PreTrainedTokenizerBase,\n     TextInput,\n     TruncationStrategy,\n )\n from transformers.utils import PaddingStrategy, TensorType, add_end_docstrings, logging, to_py_obj\n-from transformers.utils.generic import is_torch_tensor\n-from transformers.utils.hub import PushToHubMixin\n from transformers.utils.import_utils import is_mistral_common_available, is_torch_available, requires\n \n \n if is_mistral_common_available():\n     from mistral_common.protocol.instruct.request import ChatCompletionRequest\n     from mistral_common.protocol.instruct.validator import ValidationMode\n-    from mistral_common.tokens.tokenizers.base import SpecialTokenPolicy, TokenizerVersion\n-    from mistral_common.tokens.tokenizers.image import MultiModalVersion\n+    from mistral_common.tokens.tokenizers.base import SpecialTokenPolicy, SpecialTokens\n     from mistral_common.tokens.tokenizers.mistral import MistralTokenizer\n     from mistral_common.tokens.tokenizers.tekken import Tekkenizer\n-    from mistral_common.tokens.tokenizers.utils import download_tokenizer_from_hf_hub\n+    from mistral_common.tokens.tokenizers.utils import (\n+        download_tokenizer_from_hf_hub,\n+        get_one_valid_tokenizer_file,\n+    )\n \n \n if is_torch_available():\n@@ -103,6 +103,10 @@\n \"\"\"\n \n ENCODE_PLUS_ADDITIONAL_KWARGS_DOCSTRING = r\"\"\"\n+            return_token_type_ids (`bool`, *optional*):\n+                Whether to return token type IDs. For `MistralCommonBackend` it returns a list of zeros of the sequence length as only one sequence is supported.\n+\n+                [What are token type IDs?](../glossary#token-type-ids)\n             return_attention_mask (`bool`, *optional*):\n                 Whether to return the attention mask. If left to the default, will return the attention mask according\n                 to the specific tokenizer's default, defined by the `return_outputs` attribute.\n@@ -118,6 +122,8 @@\n                 Whether or not to return the lengths of the encoded inputs.\n             verbose (`bool`, *optional*, defaults to `True`):\n                 Whether or not to print more information and warnings.\n+            return_offsets_mapping (`Literal[False]`, *optional*): False, kept to match Transformers' signature.\n+            split_special_tokens (`Literal[False]`, *optional*): False, kept to match Transformers' signature.\n             **kwargs: passed to the `self.tokenize()` method\n \n         Return:\n@@ -149,8 +155,35 @@ class MistralTokenizerType(str, Enum):\n     tekken = \"tekken\"\n \n \n+@overload\n+def _maybe_remove_lang(text: str, skip_special_tokens: bool) -> str: ...\n+@overload\n+def _maybe_remove_lang(text: list[str], skip_special_tokens: bool) -> list[str]: ...\n+def _maybe_remove_lang(text: str | list[str], skip_special_tokens: bool) -> str | list[str]:\n+    # in the specific case of Voxtral, the added f\"lang:xx\" (always a two char language code since it follows ISO 639-1 alpha-2 format)\n+    # is not considered as a special token by mistral-common and is encoded/ decoded as normal text.\n+    # Nevertheless we should remove it to ease users life.\n+    if not skip_special_tokens:\n+        return text\n+\n+    if isinstance(text, str):\n+        return re.sub(r\"^lang:[a-z]{2}\", \"\", text)\n+\n+    return [re.sub(r\"^lang:[a-z]{2}\", \"\", string) for string in text]\n+\n+\n+_MAP_SPECIAL_TOKENS = {\n+    \"bos_token\": SpecialTokens.bos.value,\n+    \"eos_token\": SpecialTokens.eos.value,\n+    \"pad_token\": SpecialTokens.pad.value,\n+    \"unk_token\": SpecialTokens.unk.value,\n+}\n+\n+_VALID_INIT_KWARGS = {\"_from_auto\", \"backend\", \"files_loaded\"}\n+\n+\n @requires(backends=(\"mistral-common\",))\n-class MistralCommonBackend(PushToHubMixin):\n+class MistralCommonBackend(PreTrainedTokenizerBase):\n     \"\"\"\n     Class to wrap `mistral-common` tokenizers.\n \n@@ -165,41 +198,26 @@ class MistralCommonBackend(PushToHubMixin):\n     For more info on `mistral-common`, see [mistral-common](https://github.com/mistralai/mistral-common).\n \n     This class is a wrapper around a `mistral_common.tokens.tokenizers.mistral.MistralTokenizer`.\n-    It provides a Hugging Face compatible interface to tokenize using the official mistral-common tokenizer.\n-\n-    Supports the following methods from the `PreTrainedTokenizerBase` class:\n-\n-    - [`~MistralCommonBackend.get_vocab`]: Returns the vocabulary as a dictionary of token to index.\n-        This is a lossy conversion for Tekkenizer as some decoding errors are collapsed into the same token.\n-    - [`~MistralCommonBackend.encode`]: Encode a string to a list of integers.\n-    - [`~MistralCommonBackend.decode`]: Decode a list of integers to a string.\n-    - [`~MistralCommonBackend.batch_decode`]: Decode a batch of list of integers to a list of strings.\n-    - [`~MistralCommonBackend.convert_tokens_to_ids`]: Convert a list of tokens to a list of integers.\n-    - [`~MistralCommonBackend.convert_ids_to_tokens`]: Convert a list of integers to a list of tokens.\n-    - [`~MistralCommonBackend.tokenize`]: Tokenize a string.\n-    - [`~MistralCommonBackend.get_special_tokens_mask`]: Get the special tokens mask for a list of tokens.\n-    - [`~MistralCommonBackend.prepare_for_model`]: Prepare a list of inputs for the model.\n-    - [`~MistralCommonBackend.pad`]: Pad a list of inputs to the same length.\n-    - [`~MistralCommonBackend.truncate_sequences`]: Truncate a list of sequences to the same length.\n-    - [`~MistralCommonBackend.apply_chat_template`]: Apply a chat template to a list of messages.\n-    - [`~MistralCommonBackend.__call__`]: Tokenize a string or a list of strings.\n-    - [`~MistralCommonBackend.from_pretrained`]: Download and cache a pretrained tokenizer from the Hugging Face model hub or local directory.\n-    - [`~MistralCommonBackend.save_pretrained`]: Save a tokenizer to a directory, so it can be reloaded using the `from_pretrained` class method.\n-    - [`~MistralCommonBackend.push_to_hub`]: Upload tokenizer to the Hugging Face model hub.\n-\n-    Here are the key differences with the `PreTrainedTokenizerBase` class:\n-\n-    - Pair of sequences are not supported. The signature have been kept for compatibility but all arguments related to pair of sequences are ignored. The return values of pairs are returned as `None`.\n+    It provides a Hugging Face compatible interface to tokenize using the official mistral-common tokenizer and inherits from the `PreTrainedTokenizerBase` class.\n+\n+    Here are the key behavior differences with the `PythonBackend` class:\n+\n+    - Pair of sequences are not supported. The signature has been kept for compatibility but all arguments related to pair of sequences are ignored. The return values for pairs are returned as `None`.\n     - The `is_split_into_words` argument is not supported.\n-    - The `return_token_type_ids` argument is not supported.\n-    - It is not possible to add new tokens to the tokenizer. Also the special tokens are handled differently from Transformers. In `mistral-common`, special tokens are never encoded directly. This means that: `tokenizer.encode(\"<s>\")` will not return the ID of the `<s>` token. Instead, it will return a list of IDs corresponding to the tokenization of the string `\"<s>\"`. For more information, see the [mistral-common documentation](https://mistralai.github.io/mistral-common/usage/tokenizers/#special-tokens).\n+    - It is not possible to add new tokens to the tokenizer. Special tokens are handled differently from Transformers. In `mistral-common`, special tokens are never encoded directly. This means that: `tokenizer.encode(\"<s>\")` will not return the ID of the `<s>` token. Instead, it will return a list of IDs corresponding to the tokenization of the string `\"<s>\"`. For more information, see the [mistral-common documentation](https://mistralai.github.io/mistral-common/usage/tokenizers/#special-tokens).\n \n     If you have suggestions to improve this class, please open an issue on the [mistral-common GitHub repository](https://github.com/mistralai/mistral-common/issues) if it is related to the tokenizer or on the [Transformers GitHub repository](https://github.com/huggingface/transformers/issues) if it is related to the Hugging Face interface.\n     \"\"\"\n \n     model_input_names: list[str] = [\"input_ids\", \"attention_mask\"]\n     padding_side: str = \"left\"\n     truncation_side: str = \"right\"\n+    SPECIAL_TOKENS_ATTRIBUTES = [\n+        \"bos_token\",\n+        \"eos_token\",\n+        \"unk_token\",\n+        \"pad_token\",\n+    ]\n \n     def __init__(\n         self,\n@@ -226,7 +244,7 @@ def __init__(\n                 Path to the tokenizer file to load the `MistralTokenizer`.\n             mode (`Union[str, ValidationMode]`, *optional*, defaults to `ValidationMode.test`):\n                 The mode to use for the tokenizer. This will be passed to the `MistralTokenizer` constructor. Possible values are:\n-                - `\"finetuning\"` or `ValidationMode.finetuning`: The finetuning mode.\n+                - `\"finetuning\"` or `ValidationMode.finetuning`: The fine-tuning mode.\n                 - `\"test\"` or `ValidationMode.test`: The test mode.\n                 It changes how the tokenizer validates the input and prepares the request to the model.\n             model_max_length (`int`, *optional*):\n@@ -240,60 +258,40 @@ def __init__(\n             truncation_side (`str`, *optional*):\n                 The side on which the model should have truncation applied. Should be selected between ['right', 'left'].\n                 Default value is picked from the class attribute of the same name.\n-            model_input_names (`List[string]`, *optional*):\n+            model_input_names (`List[str]`, *optional*):\n                 The list of inputs accepted by the forward pass of the model (like `\"token_type_ids\"` or\n                 `\"attention_mask\"`). Default value is picked from the class attribute of the same name.\n             clean_up_tokenization_spaces (`bool`, *optional*, defaults to `False`):\n-                Whether or not the model should cleanup the spaces that were added when splitting the input text during the\n+                Whether or not the model should clean up the spaces that were added when splitting the input text during the\n                 tokenization process.\n         \"\"\"\n-        if kwargs:\n+        if kwargs and not set(kwargs.keys()).issubset(_VALID_INIT_KWARGS):\n             raise ValueError(f\"Kwargs {list(kwargs.keys())} are not supported to init `MistralCommonBackend`.\")\n \n         self._tokenizer_path = Path(tokenizer_path)\n         self._mode = self._get_validation_mode(mode)\n+\n         self.tokenizer: MistralTokenizer = MistralTokenizer.from_file(str(self._tokenizer_path), mode=self._mode)\n         self._tokenizer_type = (\n             MistralTokenizerType.tekken\n             if isinstance(self.tokenizer.instruct_tokenizer.tokenizer, Tekkenizer)\n             else MistralTokenizerType.spm\n         )\n-        self.truncation_side = truncation_side\n-        self.padding_side = padding_side\n-        self.model_max_length = model_max_length\n-        self.cleanup_tokenization_spaces = clean_up_tokenization_spaces\n-        self.deprecation_warnings = {}  # Use to store when we have already noticed a deprecation warning (avoid overlogging).\n-        self._all_special_tokens_ids = self._get_all_special_ids()\n-\n-        if model_input_names is not None:\n-            if (\n-                not isinstance(model_input_names, (list, tuple))\n-                and len(model_input_names) == 0\n-                and not all(isinstance(i, str) for i in model_input_names)\n-            ):\n-                raise ValueError(\n-                    \"`model_input_names` should be a non-empty list or tuple of str but got an empty value.\"\n-                )\n-            self.model_input_names = model_input_names\n-\n         self._cache_get_vocab: dict[str, int] | None = None\n \n-    @staticmethod\n-    def clean_up_tokenization(text: str) -> str:\n-        \"\"\"\n-        Clean up a list of simple English tokenization artifacts like spaces before punctuation.\n-        \"\"\"\n-        return (\n-            text.replace(\" .\", \".\")\n-            .replace(\" ?\", \"?\")\n-            .replace(\" !\", \"!\")\n-            .replace(\" ,\", \",\")\n-            .replace(\" ' \", \"'\")\n-            .replace(\" n't\", \"n't\")\n-            .replace(\" 'm\", \"'m\")\n-            .replace(\" 's\", \"'s\")\n-            .replace(\" 've\", \"'ve\")\n-            .replace(\" 're\", \"'re\")\n+        self._all_special_ids = self._get_all_special_ids()\n+        self._all_special_tokens = self.convert_ids_to_tokens(self.all_special_ids)\n+\n+        super().__init__(\n+            truncation_side=truncation_side,\n+            padding_side=padding_side,\n+            model_max_length=model_max_length,\n+            clean_up_tokenization_spaces=clean_up_tokenization_spaces,\n+            extra_special_tokens=None,  # Not used by this backend.\n+            model_specific_special_tokens=None,  # Not used by this backend.\n+            model_input_names=model_input_names or self.model_input_names,\n+            **_MAP_SPECIAL_TOKENS,\n+            **kwargs,\n         )\n \n     @property\n@@ -306,75 +304,19 @@ def mode(self) -> ValidationMode:\n         \"\"\"\n         return self._mode\n \n-    @property\n-    def bos_token_id(self) -> int:\n-        \"\"\"\n-        Id of the beginning of sentence token in the vocabulary.\n-        \"\"\"\n-        return self.tokenizer.instruct_tokenizer.tokenizer.bos_id\n-\n-    @property\n-    def eos_token_id(self) -> int:\n-        \"\"\"\n-        Id of the end of sentence token in the vocabulary.\n-        \"\"\"\n-        return self.tokenizer.instruct_tokenizer.tokenizer.eos_id\n-\n-    @property\n-    def unk_token_id(self) -> int:\n-        \"\"\"\n-        Id of the unknown token in the vocabulary.\n-        \"\"\"\n-        return self.tokenizer.instruct_tokenizer.tokenizer.unk_id\n-\n-    @property\n-    def pad_token_id(self) -> int:\n-        \"\"\"\n-        Id of the padding token in the vocabulary.\n-        \"\"\"\n-        return self.tokenizer.instruct_tokenizer.tokenizer.pad_id\n-\n-    @property\n-    def bos_token(self) -> str:\n-        \"\"\"\n-        String associated to the beginning of sentence token in the vocabulary.\n-        \"\"\"\n-        return self.convert_ids_to_tokens(self.bos_token_id)\n-\n-    @property\n-    def eos_token(self) -> str:\n-        \"\"\"\n-        String associated to the end of sentence token in the vocabulary.\n-        \"\"\"\n-        return self.convert_ids_to_tokens(self.eos_token_id)\n-\n-    @property\n-    def unk_token(self) -> str:\n-        \"\"\"\n-        String associated to the unknown token in the vocabulary.\n-        \"\"\"\n-        return self.convert_ids_to_tokens(self.unk_token_id)\n-\n-    @property\n-    def pad_token(self) -> str:\n-        \"\"\"\n-        String associated to the padding token in the vocabulary.\n-        \"\"\"\n-        return self.convert_ids_to_tokens(self.pad_token_id)\n-\n     @property\n     def all_special_ids(self) -> list[int]:\n         \"\"\"\n         `list[int]`: List the ids of the special tokens(`'<unk>'`, `'<cls>'`, etc.).\n         \"\"\"\n-        return sorted(self._all_special_tokens_ids)\n+        return sorted(self._all_special_ids)\n \n     @property\n     def all_special_tokens(self) -> list[str]:\n         \"\"\"\n         `list[str]`: A list of all unique special tokens.\n         \"\"\"\n-        return self.convert_ids_to_tokens(self.all_special_ids)\n+        return self._all_special_tokens\n \n     @property\n     def vocab_size(self) -> int:\n@@ -435,6 +377,8 @@ def encode(\n         padding_side: str | None = None,\n         return_tensors: str | TensorType | None = None,\n         verbose: bool = True,\n+        return_offsets_mapping: Literal[False] = False,\n+        split_special_tokens: Literal[False] = False,\n         **kwargs,\n     ) -> list[int]:\n         \"\"\"\n@@ -446,37 +390,81 @@ def encode(\n             text_pair (`None`, *optional*):\n                 Not supported by `MistralCommonBackend.encode`. Kept to match `PreTrainedTokenizerBase.encode` signature.\n         \"\"\"\n+        if return_offsets_mapping or split_special_tokens:\n+            raise ValueError(\n+                \"`MistralCommonBackend` does not support `return_offsets_mapping` and `split_special_tokens`.\"\n+            )\n+\n+        if truncation in [TruncationStrategy.ONLY_FIRST, TruncationStrategy.ONLY_SECOND, \"only_first\", \"only_second\"]:\n+            raise ValueError(\n+                \"Truncation strategy `only_first` and `only_second` are not supported by `MistralCommonBackend`.\"\n+            )\n+\n         if kwargs:\n             raise ValueError(f\"Kwargs {list(kwargs.keys())} are not supported by `MistralCommonBackend.encode`.\")\n+\n         if text_pair:\n             raise ValueError(\"`MistralCommonBackend.encode` does not support `text_pair`.\")\n \n-        padding_strategy, truncation_strategy, max_length, _ = self._get_padding_truncation_strategies(\n+        return super().encode(\n+            text=text,\n+            text_pair=text_pair,\n+            add_special_tokens=add_special_tokens,\n             padding=padding,\n             truncation=truncation,\n             max_length=max_length,\n-            pad_to_multiple_of=pad_to_multiple_of,\n-            verbose=verbose,\n-        )\n-\n-        encoded_inputs = self._encode_plus(\n-            text,\n-            add_special_tokens=add_special_tokens,\n-            padding_strategy=padding_strategy,\n-            truncation_strategy=truncation_strategy,\n-            max_length=max_length,\n             stride=stride,\n+            return_tensors=return_tensors,\n             pad_to_multiple_of=pad_to_multiple_of,\n             padding_side=padding_side,\n-            return_tensors=return_tensors,\n-            return_attention_mask=False,\n-            return_overflowing_tokens=False,\n-            return_special_tokens_mask=False,\n-            return_length=False,\n             verbose=verbose,\n         )\n \n-        return encoded_inputs[\"input_ids\"]\n+    def _decode(\n+        self,\n+        token_ids: int | list[int],\n+        skip_special_tokens: bool = False,\n+        clean_up_tokenization_spaces: bool | None = None,\n+        **kwargs,\n+    ) -> str:\n+        if kwargs:\n+            raise ValueError(f\"Kwargs {list(kwargs.keys())} are not supported by `MistralCommonBackend.decode`.\")\n+\n+        token_ids = to_py_obj(token_ids)\n+\n+        if isinstance(token_ids, int):\n+            token_ids = [token_ids]\n+\n+        special_token_policy = SpecialTokenPolicy.IGNORE if skip_special_tokens else SpecialTokenPolicy.KEEP\n+\n+        text = self.tokenizer.decode(token_ids, special_token_policy=special_token_policy)\n+\n+        # Apply tokenizer-specific cleanup if available and requested\n+        clean_up_tokenization_spaces = (\n+            clean_up_tokenization_spaces\n+            if clean_up_tokenization_spaces is not None\n+            else self.clean_up_tokenization_spaces\n+        )\n+        if clean_up_tokenization_spaces:\n+            # Call custom cleanup method if it exists (e.g., for CLVP's [SPACE] token replacement)\n+            if hasattr(self, \"clean_up_tokenization\") and callable(self.clean_up_tokenization):\n+                text = self.clean_up_tokenization(text)\n+            else:\n+                # Otherwise apply standard cleanup\n+                text = (\n+                    text.replace(\" .\", \".\")\n+                    .replace(\" ?\", \"?\")\n+                    .replace(\" !\", \"!\")\n+                    .replace(\" ,\", \",\")\n+                    .replace(\" ' \", \"'\")\n+                    .replace(\" n't\", \"n't\")\n+                    .replace(\" 'm\", \"'m\")\n+                    .replace(\" 's\", \"'s\")\n+                    .replace(\" 've\", \"'ve\")\n+                    .replace(\" 're\", \"'re\")\n+                )\n+\n+        return _maybe_remove_lang(text=text, skip_special_tokens=skip_special_tokens)\n \n     def decode(\n         self,\n@@ -509,16 +497,7 @@ def decode(\n         if kwargs:\n             raise ValueError(f\"Kwargs {list(kwargs.keys())} are not supported by `MistralCommonBackend.decode`.\")\n \n-        token_ids = to_py_obj(token_ids)\n-\n-        if isinstance(token_ids, (list, tuple)) and len(token_ids) > 0 and isinstance(token_ids[0], (list, tuple)):\n-            return self._batch_decode(\n-                sequences=token_ids,\n-                skip_special_tokens=skip_special_tokens,\n-                clean_up_tokenization_spaces=clean_up_tokenization_spaces,\n-            )\n-\n-        return self._decode(\n+        return super().decode(\n             token_ids=token_ids,\n             skip_special_tokens=skip_special_tokens,\n             clean_up_tokenization_spaces=clean_up_tokenization_spaces,\n@@ -555,63 +534,12 @@ def batch_decode(\n         if kwargs:\n             raise ValueError(f\"Kwargs {list(kwargs.keys())} are not supported by `MistralCommonBackend.batch_decode`.\")\n \n-        return self._batch_decode(\n+        return super().batch_decode(\n             sequences=sequences,\n             skip_special_tokens=skip_special_tokens,\n             clean_up_tokenization_spaces=clean_up_tokenization_spaces,\n         )\n \n-    def _decode(\n-        self,\n-        token_ids: Union[int, list[int], list[list[int]], np.ndarray, \"torch.Tensor\"],\n-        skip_special_tokens: bool = False,\n-        clean_up_tokenization_spaces: bool | None = None,\n-    ) -> str:\n-        clean_up_tokenization_spaces = clean_up_tokenization_spaces or self.cleanup_tokenization_spaces\n-\n-        # Convert inputs to python lists\n-        if isinstance(token_ids, int):\n-            token_ids = [token_ids]\n-\n-        token_ids = to_py_obj(token_ids)\n-\n-        special_token_policy = SpecialTokenPolicy.IGNORE if skip_special_tokens else SpecialTokenPolicy.KEEP\n-\n-        decoded_string = self.tokenizer.decode(token_ids, special_token_policy=special_token_policy)\n-        if clean_up_tokenization_spaces:\n-            decoded_string = self.clean_up_tokenization(decoded_string)\n-\n-        # in the specific case of Voxtral, the added f\"lang:xx\" (always a two char language code since it follows ISO 639-1 alpha-2 format)\n-        # is not considered as a special token by mistral-common and is encoded/ decoded as normal text.\n-        # Nevertheless we should remove it to ease users life.\n-        if skip_special_tokens:\n-            decoded_string = re.sub(r\"^lang:[a-z]{2}\", \"\", decoded_string)\n-\n-        return decoded_string\n-\n-    def _batch_decode(\n-        self,\n-        sequences: Union[list[int], list[list[int]], np.ndarray, \"torch.Tensor\"],\n-        skip_special_tokens: bool = False,\n-        clean_up_tokenization_spaces: bool | None = None,\n-    ) -> list[str]:\n-        return [\n-            self._decode(\n-                seq,\n-                skip_special_tokens=skip_special_tokens,\n-                clean_up_tokenization_spaces=clean_up_tokenization_spaces,\n-            )\n-            for seq in sequences\n-        ]\n-\n-    def _is_control_token(self, token_id: int) -> bool:\n-        if self._tokenizer_type == MistralTokenizerType.spm:\n-            return token_id in self.tokenizer.instruct_tokenizer.tokenizer._control_tokens\n-        elif self._tokenizer_type == MistralTokenizerType.tekken:\n-            return token_id < self.tokenizer.instruct_tokenizer.tokenizer.num_special_tokens\n-        else:\n-            raise ValueError(f\"Unknown tokenizer type: {self._tokenizer_type}\")\n-\n     @overload\n     def convert_ids_to_tokens(self, ids: int, skip_special_tokens: bool = False) -> str: ...\n     @overload\n@@ -632,22 +560,22 @@ def convert_ids_to_tokens(self, ids: int | list[int], skip_special_tokens: bool\n         \"\"\"\n \n         if isinstance(ids, int):\n-            one_token = True\n+            return_int = True\n             ids = [ids]\n         else:\n-            one_token = False\n+            return_int = False\n \n         tokens: list[str] = []\n         for token_id in ids:\n-            if self._is_control_token(token_id) and skip_special_tokens:\n+            if self.tokenizer.instruct_tokenizer.tokenizer.is_special(token_id) and skip_special_tokens:\n                 continue\n             tokens.append(self.tokenizer.instruct_tokenizer.tokenizer.id_to_piece(token_id))\n \n-        if one_token:\n-            if tokens == []:\n-                raise ValueError(f\"Invalid token id {ids}.\")\n-\n+        if return_int and tokens == []:\n+            raise ValueError(f\"Invalid token id {ids[0]}.\")\n+        elif return_int:\n             return tokens[0]\n+\n         return tokens\n \n     def _tekken_piece_to_id(self, piece: str, warn: bool) -> int:\n@@ -708,7 +636,13 @@ def _text_to_ids(self, text: TextInput, add_special_tokens: bool) -> list[int]:\n         tokens_ids = self.tokenizer.instruct_tokenizer.tokenizer.encode(text, bos=add_special_tokens, eos=add_eos)\n         return tokens_ids\n \n-    def tokenize(self, text: TextInput, **kwargs) -> list[str]:\n+    def tokenize(\n+        self,\n+        text: TextInput,\n+        return_offsets_mapping: Literal[False] = False,\n+        split_special_tokens: Literal[False] = False,\n+        **kwargs,\n+    ) -> list[str]:\n         \"\"\"\n         Converts a string into a sequence of tokens, using the tokenizer.\n \n@@ -717,47 +651,173 @@ def tokenize(self, text: TextInput, **kwargs) -> list[str]:\n         Args:\n             text (`str`):\n                 The sequence to be encoded.\n+            return_offsets_mapping (`Literal[False]`, *optional*): False, kept to match Transformers' signature.\n+            split_special_tokens (`Literal[False]`, *optional*): False, kept to match Transformers' signature.\n             **kwargs (additional keyword arguments):\n                 Not supported by `MistralCommonBackend.tokenize`.\n                 Will raise an error if used.\n \n         Returns:\n             `list[str]`: The list of tokens.\n         \"\"\"\n+        if return_offsets_mapping or split_special_tokens:\n+            raise ValueError(\n+                \"`MistralCommonBackend` does not support `return_offsets_mapping` and `split_special_tokens`.\"\n+            )\n+\n         if kwargs:\n             raise ValueError(f\"Kwargs {list(kwargs.keys())} are not supported by `MistralCommonBackend.tokenize`.\")\n \n         return self.convert_ids_to_tokens(self._text_to_ids(text, add_special_tokens=False), skip_special_tokens=False)\n \n-    def _encode_plus(\n+    def _get_all_special_ids(self) -> set[int]:\n+        if self._tokenizer_type == MistralTokenizerType.tekken:\n+            return self.tokenizer.instruct_tokenizer.tokenizer._special_token_ids\n+        elif self._tokenizer_type == MistralTokenizerType.spm:\n+            return {\n+                token_id\n+                for token_id in range(self.tokenizer.instruct_tokenizer.tokenizer.n_words)\n+                if self.tokenizer.instruct_tokenizer.tokenizer.is_special(token_id)\n+            }\n+        else:\n+            raise ValueError(f\"Unknown tokenizer type: {self._tokenizer_type}\")\n+\n+    def get_special_tokens_mask(\n+        self, token_ids_0: list[int], token_ids_1: None = None, already_has_special_tokens: bool = False\n+    ) -> list[int]:\n+        \"\"\"\n+        Retrieves sequence ids from a token list that has no special tokens added. This method is called when adding\n+        special tokens using the tokenizer `prepare_for_model` or `encode_plus` methods.\n+\n+        Args:\n+            token_ids_0 (`list[int]`): List of ids of the sequence.\n+            token_ids_1 (`None`, *optional*): None, kept to match Transformers' implementation.\n+            already_has_special_tokens (`bool`, *optional*, defaults to `False`):\n+                Whether or not the token list is already formatted with special tokens for the model.\n+\n+        Returns:\n+            A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.\n+        \"\"\"\n+        if token_ids_1 is not None:\n+            raise ValueError(\n+                \"`token_ids_1` is not supported by `MistralCommonBackend` and should be `None`, kept for compatibility.\"\n+            )\n+\n+        if already_has_special_tokens:\n+            return [1 if int(token_id) in self._all_special_ids else 0 for token_id in token_ids_0]\n+\n+        if self.mode == ValidationMode.test:\n+            # [BOS] seq0\n+            return [1] + ([0] * len(token_ids_0))\n+        else:\n+            # [BOS] seq0 [EOS]\n+            return [1] + ([0] * len(token_ids_0)) + [1]\n+\n+    def _encode_plus(  # type: ignore[override]\n         self,\n-        text: TextInput | EncodedInput,\n+        text: TextInput | PreTokenizedInput | EncodedInput,\n+        text_pair: None = None,\n         add_special_tokens: bool = True,\n         padding_strategy: PaddingStrategy = PaddingStrategy.DO_NOT_PAD,\n         truncation_strategy: TruncationStrategy = TruncationStrategy.DO_NOT_TRUNCATE,\n         max_length: int | None = None,\n         stride: int = 0,\n+        is_split_into_words: bool = False,\n         pad_to_multiple_of: int | None = None,\n         padding_side: str | None = None,\n         return_tensors: str | TensorType | None = None,\n+        return_token_type_ids: bool | None = None,\n         return_attention_mask: bool | None = None,\n         return_overflowing_tokens: bool = False,\n         return_special_tokens_mask: bool = False,\n         return_length: bool = False,\n         verbose: bool = True,\n+        return_offsets_mapping: Literal[False] = False,\n+        split_special_tokens: Literal[False] = False,\n+        **kwargs,\n     ) -> BatchEncoding:\n+        # Detect batched inputs (list of sequences)\n+        if text_pair is not None:\n+            raise ValueError(\"`MistralCommonBackend` does not support `text_pair != None` for `_encode_plus`.\")\n+\n+        if return_offsets_mapping or split_special_tokens:\n+            raise ValueError(\n+                \"`MistralCommonBackend` does not support `return_offsets_mapping` and `split_special_tokens`.\"\n+            )\n+\n+        if kwargs:\n+            raise ValueError(f\"Kwargs {list(kwargs.keys())} are not supported by `MistralCommonBackend._encode_plus`.\")\n+\n+        is_batched = isinstance(text, (list, tuple)) and (\n+            (not text and not is_split_into_words)\n+            or (text and is_split_into_words and isinstance(text[0], (list, tuple)))\n+            or (text and not is_split_into_words and isinstance(text[0], (str, list, tuple)))\n+        )\n+\n+        if is_batched:\n+            batch_outputs = {}\n+            one_overflowed = False\n+            for current_text in text:\n+                current_output = self._encode_plus(\n+                    text=current_text,\n+                    text_pair=None,\n+                    add_special_tokens=add_special_tokens,\n+                    padding_strategy=PaddingStrategy.DO_NOT_PAD,  # we pad in batch afterward\n+                    truncation_strategy=truncation_strategy,\n+                    max_length=max_length,\n+                    stride=stride,\n+                    is_split_into_words=is_split_into_words,\n+                    pad_to_multiple_of=None,  # we pad in batch afterward\n+                    padding_side=None,  # we pad in batch afterward\n+                    return_tensors=None,  # We convert the whole batch to tensors at the end\n+                    return_token_type_ids=return_token_type_ids,\n+                    return_attention_mask=False,  # we pad in batch afterward\n+                    return_overflowing_tokens=return_overflowing_tokens,\n+                    return_special_tokens_mask=return_special_tokens_mask,\n+                    return_length=return_length,\n+                    verbose=verbose,\n+                )\n+                for key, value in current_output.items():\n+                    batch_outputs.setdefault(key, []).append(value)\n+\n+                # To ensure the list is built for each sample, we need to add this.\n+                if return_overflowing_tokens and not return_tensors:\n+                    if \"overflowing_tokens\" not in current_output:\n+                        batch_outputs.setdefault(\"overflowing_tokens\", []).append([0])\n+                        batch_outputs.setdefault(\"num_truncated_tokens\", []).append([0])\n+                    else:\n+                        one_overflowed = True\n+\n+            # Remove overflow-related keys before tensor conversion if return_tensors is set\n+            # Slow tokenizers don't support returning these as tensors\n+            if return_overflowing_tokens and (return_tensors or not one_overflowed):\n+                batch_outputs.pop(\"overflowing_tokens\", None)\n+                batch_outputs.pop(\"num_truncated_tokens\", None)\n+\n+            batch_outputs = self.pad(\n+                batch_outputs,\n+                padding=padding_strategy.value,\n+                max_length=max_length,\n+                pad_to_multiple_of=pad_to_multiple_of,\n+                padding_side=padding_side,\n+                return_attention_mask=return_attention_mask,\n+            )\n+\n+            return BatchEncoding(batch_outputs, tensor_type=return_tensors)\n+\n         def get_input_ids(text):\n             if isinstance(text, str):\n-                return self._text_to_ids(text, add_special_tokens)\n+                return self._text_to_ids(text, False)\n             elif isinstance(text, (list, tuple)) and len(text) > 0 and isinstance(text[0], int):\n                 return text\n             else:\n                 raise ValueError(f\"Input {text} is not valid. Should be a string, or a list/tuple of integers.\")\n \n-        ids = get_input_ids(text)\n+        first_ids = get_input_ids(text)\n \n         return self.prepare_for_model(\n-            ids,\n+            first_ids,\n+            pair_ids=None,\n             add_special_tokens=add_special_tokens,\n             padding=padding_strategy.value,\n             truncation=truncation_strategy.value,\n@@ -768,242 +828,128 @@ def get_input_ids(text):\n             return_tensors=return_tensors,\n             prepend_batch_axis=True,\n             return_attention_mask=return_attention_mask,\n+            return_token_type_ids=return_token_type_ids,\n             return_overflowing_tokens=return_overflowing_tokens,\n             return_special_tokens_mask=return_special_tokens_mask,\n             return_length=return_length,\n             verbose=verbose,\n         )\n \n-    def _batch_encode_plus(\n+    @add_end_docstrings(ENCODE_KWARGS_DOCSTRING, ENCODE_PLUS_ADDITIONAL_KWARGS_DOCSTRING)\n+    def prepare_for_model(\n         self,\n-        batch_text: list[TextInput] | list[EncodedInput],\n+        ids: list[int],\n+        pair_ids: None = None,\n         add_special_tokens: bool = True,\n-        padding_strategy: PaddingStrategy = PaddingStrategy.DO_NOT_PAD,\n-        truncation_strategy: TruncationStrategy = TruncationStrategy.DO_NOT_TRUNCATE,\n+        padding: bool | str | PaddingStrategy = False,\n+        truncation: bool | str | TruncationStrategy | None = None,\n         max_length: int | None = None,\n         stride: int = 0,\n         pad_to_multiple_of: int | None = None,\n         padding_side: str | None = None,\n         return_tensors: str | TensorType | None = None,\n+        return_token_type_ids: bool | None = None,\n         return_attention_mask: bool | None = None,\n         return_overflowing_tokens: bool = False,\n         return_special_tokens_mask: bool = False,\n         return_length: bool = False,\n         verbose: bool = True,\n+        prepend_batch_axis: bool = False,\n+        return_offsets_mapping: Literal[False] = False,\n+        split_special_tokens: Literal[False] = False,\n+        **kwargs,\n     ) -> BatchEncoding:\n-        def get_input_ids(text):\n-            if isinstance(text, str):\n-                return self._text_to_ids(text, add_special_tokens)\n-            elif isinstance(text, (list, tuple)) and len(text) > 0 and isinstance(text[0], int):\n-                return text\n-            else:\n-                raise ValueError(\"Input is not valid. Should be a string or a list/tuple of integers.\")\n-\n-        input_ids = []\n-        for ids in batch_text:\n-            input_ids.append(get_input_ids(ids))\n-\n-        batch_outputs = self._batch_prepare_for_model(\n-            input_ids,\n-            add_special_tokens=add_special_tokens,\n-            padding_strategy=padding_strategy,\n-            truncation_strategy=truncation_strategy,\n-            max_length=max_length,\n-            stride=stride,\n-            pad_to_multiple_of=pad_to_multiple_of,\n-            padding_side=padding_side,\n-            return_attention_mask=return_attention_mask,\n-            return_overflowing_tokens=return_overflowing_tokens,\n-            return_special_tokens_mask=return_special_tokens_mask,\n-            return_length=return_length,\n-            return_tensors=return_tensors,\n-            verbose=verbose,\n-        )\n-\n-        return BatchEncoding(batch_outputs)\n-\n-    def _get_all_special_ids(self) -> set[int]:\n-        if self._tokenizer_type == MistralTokenizerType.tekken:\n-            return {t[\"rank\"] for t in self.tokenizer.instruct_tokenizer.tokenizer._all_special_tokens}\n-        elif self._tokenizer_type == MistralTokenizerType.spm:\n-            return self.tokenizer.instruct_tokenizer.tokenizer._control_tokens\n-        else:\n-            raise ValueError(f\"Unknown tokenizer type: {self._tokenizer_type}\")\n-\n-    def get_special_tokens_mask(\n-        self, token_ids_0: list, token_ids_1: None = None, already_has_special_tokens: bool = False\n-    ) -> list[int]:\n         \"\"\"\n-        Retrieves sequence ids from a token list that has no special tokens added. This method is called when adding\n-        special tokens using the tokenizer `prepare_for_model` or `encode_plus` methods.\n+        Prepares a sequence of input id so that it can be used by the model. It\n+        adds special tokens, truncates sequences if overflowing while taking into account the special tokens and\n+        manages a moving window (with user defined stride) for overflowing tokens.\n \n         Args:\n-            token_ids_0 (`list[int]`):\n-                List of ids of the sequence.\n-            token_ids_1 (`list[int]`, *optional*):\n+            ids (`list[int]`):\n+                Tokenized input ids of the first sequence.\n+            pair_ids (`None`, *optional*):\n                 Not supported by `MistralCommonBackend`. Kept to match the interface of `PreTrainedTokenizerBase`.\n-            already_has_special_tokens (`bool`, *optional*, defaults to `False`):\n-                Whether or not the token list is already formatted with special tokens for the model.\n-\n-        Returns:\n-            A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.\n         \"\"\"\n-        if token_ids_1 is not None:\n+        if return_offsets_mapping or split_special_tokens:\n             raise ValueError(\n-                \"`token_ids_1` is not supported by `MistralCommonBackend` and should be `None`, kept for compatibility.\"\n+                \"`MistralCommonBackend` does not support `return_offsets_mapping` and `split_special_tokens`.\"\n             )\n-        if already_has_special_tokens:\n+\n+        if pair_ids is not None:\n             raise ValueError(\n-                \"`already_has_special_tokens` is not supported by `MistralCommonBackend` and should be `False`.\"\n+                \"`pair_ids` is not supported by `MistralCommonBackend` and should be `None`, kept for compatibility.\"\n             )\n \n-        special_tokens_mask = [1 if token in self._all_special_tokens_ids else 0 for token in token_ids_0]\n-        return special_tokens_mask\n-\n-    def _batch_prepare_for_model(\n-        self,\n-        batch_ids: list[PreTokenizedInput | list[int]],\n-        add_special_tokens: bool = True,\n-        padding_strategy: PaddingStrategy = PaddingStrategy.DO_NOT_PAD,\n-        truncation_strategy: TruncationStrategy = TruncationStrategy.DO_NOT_TRUNCATE,\n-        max_length: int | None = None,\n-        stride: int = 0,\n-        pad_to_multiple_of: int | None = None,\n-        padding_side: str | None = None,\n-        return_tensors: str | None = None,\n-        return_attention_mask: bool | None = None,\n-        return_overflowing_tokens: bool = False,\n-        return_special_tokens_mask: bool = False,\n-        return_length: bool = False,\n-        verbose: bool = True,\n-    ) -> BatchEncoding:\n-        \"\"\"\n-        Prepares a sequence of input id so that it can be used by the model. It\n-        adds special tokens, truncates sequences if overflowing while taking into account the special tokens and\n-        manages a moving window (with user defined stride) for overflowing tokens.\n-\n-        Args:\n-            batch_ids: list of tokenized input ids\n-        \"\"\"\n-\n-        batch_outputs = {}\n-        for ids in batch_ids:\n-            outputs = self.prepare_for_model(\n-                ids,\n-                add_special_tokens=add_special_tokens,\n-                padding=PaddingStrategy.DO_NOT_PAD.value,  # we pad in batch afterward\n-                truncation=truncation_strategy.value,\n-                max_length=max_length,\n-                stride=stride,\n-                pad_to_multiple_of=None,  # we pad in batch afterward\n-                padding_side=None,  # we pad in batch afterward\n-                return_attention_mask=False,  # we pad in batch afterward\n-                return_overflowing_tokens=return_overflowing_tokens,\n-                return_special_tokens_mask=return_special_tokens_mask,\n-                return_length=return_length,\n-                return_tensors=None,  # We convert the whole batch to tensors at the end\n-                prepend_batch_axis=False,\n-                verbose=verbose,\n-            )\n-\n-            for key, value in outputs.items():\n-                if key not in batch_outputs:\n-                    batch_outputs[key] = []\n-                batch_outputs[key].append(value)\n-\n-        batch_outputs = self.pad(\n-            batch_outputs,\n-            padding=padding_strategy.value,\n-            max_length=max_length,\n-            pad_to_multiple_of=pad_to_multiple_of,\n-            padding_side=padding_side,\n-            return_attention_mask=return_attention_mask,\n-        )\n-\n-        batch_outputs = BatchEncoding(batch_outputs, tensor_type=return_tensors)\n-\n-        return batch_outputs\n-\n-    @add_end_docstrings(ENCODE_KWARGS_DOCSTRING, ENCODE_PLUS_ADDITIONAL_KWARGS_DOCSTRING)\n-    def prepare_for_model(\n-        self,\n-        ids: list[int],\n-        pair_ids: None = None,\n-        add_special_tokens: bool = True,\n-        padding: bool | str | PaddingStrategy = False,\n-        truncation: bool | str | TruncationStrategy | None = None,\n-        max_length: int | None = None,\n-        stride: int = 0,\n-        pad_to_multiple_of: int | None = None,\n-        padding_side: str | None = None,\n-        return_tensors: str | TensorType | None = None,\n-        return_attention_mask: bool | None = None,\n-        return_overflowing_tokens: bool = False,\n-        return_special_tokens_mask: bool = False,\n-        return_length: bool = False,\n-        verbose: bool = True,\n-        prepend_batch_axis: bool = False,\n-        **kwargs,\n-    ) -> BatchEncoding:\n-        \"\"\"\n-        Prepares a sequence of input id so that it can be used by the model. It\n-        adds special tokens, truncates sequences if overflowing while taking into account the special tokens and\n-        manages a moving window (with user defined stride) for overflowing tokens.\n-\n-        Args:\n-            ids (`list[int]`):\n-                Tokenized input ids of the first sequence.\n-            pair_ids (`None`, *optional*):\n-                Not supported by `MistralCommonBackend`. Kept to match the interface of `PreTrainedTokenizerBase`.\n-        \"\"\"\n-        if pair_ids is not None:\n-            raise ValueError(\n-                \"`pair_ids` is not supported by `MistralCommonBackend` and should be `None`, kept for compatibility.\"\n-            )\n-        if kwargs:\n-            raise ValueError(\n-                f\"Kwargs {list(kwargs.keys())} are not supported by `MistralCommonBackend.prepare_for_model`.\"\n-            )\n+        if kwargs:\n+            raise ValueError(\n+                f\"Kwargs {list(kwargs.keys())} are not supported by `MistralCommonBackend.prepare_for_model`.\"\n+            )\n \n         padding_strategy, truncation_strategy, max_length, _ = self._get_padding_truncation_strategies(\n             padding=padding,\n             truncation=truncation,\n             max_length=max_length,\n             pad_to_multiple_of=pad_to_multiple_of,\n             verbose=verbose,\n+            **kwargs,\n         )\n \n-        len_ids = len(ids)\n+        # Validation\n+        if (\n+            return_overflowing_tokens\n+            and truncation_strategy == TruncationStrategy.LONGEST_FIRST\n+            and pair_ids is not None\n+        ):\n+            raise ValueError(\n+                \"Not possible to return overflowing tokens for pair of sequences with the \"\n+                \"`longest_first`. Please select another truncation strategy than `longest_first`, \"\n+                \"for instance `only_second` or `only_first`.\"\n+            )\n \n-        # Load from model defaults\n+        # Defaults\n+        if return_token_type_ids is None:\n+            return_token_type_ids = \"token_type_ids\" in self.model_input_names\n         if return_attention_mask is None:\n             return_attention_mask = \"attention_mask\" in self.model_input_names\n \n-        encoded_inputs = {}\n+        # Truncation\n+        num_special = self.num_special_tokens_to_add(pair=False) if add_special_tokens else 0\n+        total_len = len(ids) + len(pair_ids or []) + num_special\n \n-        # Truncation: Handle max sequence length\n         overflowing_tokens = []\n-        if truncation_strategy != TruncationStrategy.DO_NOT_TRUNCATE and max_length and len_ids > max_length:\n+        if truncation_strategy != TruncationStrategy.DO_NOT_TRUNCATE and max_length and total_len > max_length:\n             ids, _, overflowing_tokens = self.truncate_sequences(\n                 ids,\n-                num_tokens_to_remove=len_ids - max_length,\n+                pair_ids=None,\n+                num_tokens_to_remove=total_len - max_length,\n                 truncation_strategy=truncation_strategy,\n                 stride=stride,\n             )\n \n-        if return_overflowing_tokens:\n-            encoded_inputs[\"overflowing_tokens\"] = overflowing_tokens\n-            encoded_inputs[\"num_truncated_tokens\"] = len_ids - max_length\n+        # Add special tokens\n+        if add_special_tokens:\n+            sequence = self.build_inputs_with_special_tokens(ids, None)\n+            token_type_ids = self.create_token_type_ids_from_sequences(ids, None)\n+        else:\n+            sequence = ids\n+            token_type_ids = [0] * len(sequence)\n \n-        # Build output dictionary\n-        encoded_inputs[self.model_input_names[0]] = ids\n+        # Build output\n+        encoded_inputs = {\"input_ids\": sequence}\n+        if return_token_type_ids:\n+            encoded_inputs[\"token_type_ids\"] = token_type_ids\n         if return_special_tokens_mask:\n-            if add_special_tokens:\n-                encoded_inputs[\"special_tokens_mask\"] = self.get_special_tokens_mask(ids, None)\n-            else:\n-                encoded_inputs[\"special_tokens_mask\"] = [0] * len(ids)\n+            encoded_inputs[\"special_tokens_mask\"] = (\n+                self.get_special_tokens_mask(ids, None) if add_special_tokens else [0] * len(sequence)\n+            )\n+        if return_overflowing_tokens and not return_tensors and overflowing_tokens:\n+            encoded_inputs[\"overflowing_tokens\"] = overflowing_tokens\n+            encoded_inputs[\"num_truncated_tokens\"] = total_len - max_length if max_length else 0\n+\n+        # Check sequence length and warn if needed\n+        self._eventual_warn_about_too_long_sequence(encoded_inputs[\"input_ids\"], max_length, verbose)\n \n-        # Padding\n+        # Pad\n         if padding_strategy != PaddingStrategy.DO_NOT_PAD or return_attention_mask:\n             encoded_inputs = self.pad(\n                 encoded_inputs,\n@@ -1017,362 +963,9 @@ def prepare_for_model(\n         if return_length:\n             encoded_inputs[\"length\"] = len(encoded_inputs[\"input_ids\"])\n \n-        batch_outputs = BatchEncoding(\n-            encoded_inputs, tensor_type=return_tensors, prepend_batch_axis=prepend_batch_axis\n-        )\n-\n-        return batch_outputs\n-\n-    def _get_padding_truncation_strategies(\n-        self,\n-        padding: str | PaddingStrategy | bool = False,\n-        truncation: str | TruncationStrategy | bool | None = None,\n-        max_length: int | None = None,\n-        pad_to_multiple_of: int | None = None,\n-        verbose: bool = True,\n-        **kwargs,\n-    ):\n-        \"\"\"\n-        Find the correct padding/truncation strategy.\n-        \"\"\"\n-\n-        # Backward compatibility for previous behavior, maybe we should deprecate it:\n-        # If you only set max_length, it activates truncation for max_length\n-        if max_length is not None and padding is False and truncation is None:\n-            if verbose:\n-                if not self.deprecation_warnings.get(\"Truncation-not-explicitly-activated\", False):\n-                    logger.warning(\n-                        \"Truncation was not explicitly activated but `max_length` is provided a specific value, please\"\n-                        \" use `truncation=True` to explicitly truncate examples to max length. Defaulting to\"\n-                        \" 'longest_first' truncation strategy.\"\n-                    )\n-                self.deprecation_warnings[\"Truncation-not-explicitly-activated\"] = True\n-            truncation = \"longest_first\"\n-\n-        # Get padding strategy\n-        if padding is not False:\n-            if padding is True:\n-                if verbose:\n-                    if max_length is not None and (\n-                        truncation is None or truncation is False or truncation == \"do_not_truncate\"\n-                    ):\n-                        warnings.warn(\n-                            \"`max_length` is ignored when `padding`=`True` and there is no truncation strategy. \"\n-                            \"To pad to max length, use `padding='max_length'`.\"\n-                        )\n-                padding_strategy = PaddingStrategy.LONGEST  # Default to pad to the longest sequence in the batch\n-            elif not isinstance(padding, PaddingStrategy):\n-                padding_strategy = PaddingStrategy(padding)\n-            elif isinstance(padding, PaddingStrategy):\n-                padding_strategy = padding\n-        else:\n-            padding_strategy = PaddingStrategy.DO_NOT_PAD\n-\n-        # Get truncation strategy\n-        if truncation is not False and truncation is not None:\n-            if truncation is True:\n-                truncation_strategy = (\n-                    TruncationStrategy.LONGEST_FIRST\n-                )  # Default to truncate the longest sequences in pairs of inputs\n-            elif not isinstance(truncation, TruncationStrategy):\n-                truncation_strategy = TruncationStrategy(truncation)\n-            elif isinstance(truncation, TruncationStrategy):\n-                truncation_strategy = truncation\n-            if truncation in [TruncationStrategy.ONLY_FIRST, TruncationStrategy.ONLY_SECOND]:\n-                raise ValueError(\n-                    \"Truncation strategy `only_first` and `only_second` are not supported by `MistralCommonBackend`.\"\n-                )\n-        else:\n-            truncation_strategy = TruncationStrategy.DO_NOT_TRUNCATE\n-\n-        # Set max length if needed\n-        if max_length is None:\n-            if padding_strategy == PaddingStrategy.MAX_LENGTH:\n-                if self.model_max_length > LARGE_INTEGER:\n-                    if verbose:\n-                        if not self.deprecation_warnings.get(\"Asking-to-pad-to-max_length\", False):\n-                            logger.warning(\n-                                \"Asking to pad to max_length but no maximum length is provided and the model has no\"\n-                                \" predefined maximum length. Default to no padding.\"\n-                            )\n-                        self.deprecation_warnings[\"Asking-to-pad-to-max_length\"] = True\n-                    padding_strategy = PaddingStrategy.DO_NOT_PAD\n-                else:\n-                    max_length = self.model_max_length\n-\n-            if truncation_strategy != TruncationStrategy.DO_NOT_TRUNCATE:\n-                if self.model_max_length > LARGE_INTEGER:\n-                    if verbose:\n-                        if not self.deprecation_warnings.get(\"Asking-to-truncate-to-max_length\", False):\n-                            logger.warning(\n-                                \"Asking to truncate to max_length but no maximum length is provided and the model has\"\n-                                \" no predefined maximum length. Default to no truncation.\"\n-                            )\n-                        self.deprecation_warnings[\"Asking-to-truncate-to-max_length\"] = True\n-                    truncation_strategy = TruncationStrategy.DO_NOT_TRUNCATE\n-                else:\n-                    max_length = self.model_max_length\n-\n-        # Test if we have a padding token\n-        if padding_strategy != PaddingStrategy.DO_NOT_PAD and (self.pad_token_id is None or self.pad_token_id < 0):\n-            raise ValueError(\n-                \"Asking to pad but the tokenizer does not have a padding token. \"\n-                \"Please select a token to use as `pad_token` `(tokenizer.pad_token = tokenizer.eos_token e.g.)` \"\n-                \"or add a new pad token via `tokenizer.add_special_tokens({'pad_token': '[PAD]'})`.\"\n-            )\n-\n-        # Check that we will truncate to a multiple of pad_to_multiple_of if both are provided\n-        if (\n-            truncation_strategy != TruncationStrategy.DO_NOT_TRUNCATE\n-            and padding_strategy != PaddingStrategy.DO_NOT_PAD\n-            and pad_to_multiple_of is not None\n-            and max_length is not None\n-            and (max_length % pad_to_multiple_of != 0)\n-        ):\n-            raise ValueError(\n-                \"Truncation and padding are both activated but \"\n-                f\"truncation length ({max_length}) is not a multiple of pad_to_multiple_of ({pad_to_multiple_of}).\"\n-            )\n-\n-        return padding_strategy, truncation_strategy, max_length, kwargs\n-\n-    def _pad(\n-        self,\n-        encoded_inputs: dict[str, EncodedInput] | BatchEncoding,\n-        max_length: int | None = None,\n-        padding_strategy: PaddingStrategy = PaddingStrategy.DO_NOT_PAD,\n-        pad_to_multiple_of: int | None = None,\n-        padding_side: str | None = None,\n-        return_attention_mask: bool | None = None,\n-    ) -> dict:\n-        \"\"\"\n-        Pad encoded inputs (on left/right and up to predefined length or max length in the batch)\n-\n-        Args:\n-            encoded_inputs:\n-                Dictionary of tokenized inputs (`list[int]`) or batch of tokenized inputs (`list[list[int]]`).\n-            max_length: maximum length of the returned list and optionally padding length (see below).\n-                Will truncate by taking into account the special tokens.\n-            padding_strategy: PaddingStrategy to use for padding.\n-\n-                - PaddingStrategy.LONGEST Pad to the longest sequence in the batch\n-                - PaddingStrategy.MAX_LENGTH: Pad to the max length (default)\n-                - PaddingStrategy.DO_NOT_PAD: Do not pad\n-                The tokenizer padding sides are defined in `padding_side` argument:\n-\n-                    - 'left': pads on the left of the sequences\n-                    - 'right': pads on the right of the sequences\n-            pad_to_multiple_of: (optional) Integer if set will pad the sequence to a multiple of the provided value.\n-                This is especially useful to enable the use of Tensor Core on NVIDIA hardware with compute capability\n-                `>= 7.5` (Volta).\n-            padding_side:\n-                The side on which the model should have padding applied. Should be selected between ['right', 'left'].\n-                Default value is picked from the class attribute of the same name.\n-            return_attention_mask:\n-                (optional) Set to False to avoid returning attention mask (default: set to model specifics)\n-        \"\"\"\n-        # Load from model defaults\n-        if return_attention_mask is None:\n-            return_attention_mask = \"attention_mask\" in self.model_input_names\n-\n-        required_input = encoded_inputs[self.model_input_names[0]]\n-\n-        if padding_strategy == PaddingStrategy.LONGEST:\n-            max_length = len(required_input)\n-\n-        if max_length is not None and pad_to_multiple_of is not None and (max_length % pad_to_multiple_of != 0):\n-            max_length = ((max_length // pad_to_multiple_of) + 1) * pad_to_multiple_of\n-\n-        needs_to_be_padded = padding_strategy != PaddingStrategy.DO_NOT_PAD and len(required_input) != max_length\n-\n-        # Initialize attention mask if not present.\n-        if return_attention_mask and \"attention_mask\" not in encoded_inputs:\n-            encoded_inputs[\"attention_mask\"] = [1] * len(required_input)\n-\n-        if needs_to_be_padded:\n-            difference = max_length - len(required_input)\n-            padding_side = padding_side if padding_side is not None else self.padding_side\n-\n-            if padding_side == \"right\":\n-                if return_attention_mask:\n-                    encoded_inputs[\"attention_mask\"] = encoded_inputs[\"attention_mask\"] + [0] * difference\n-                if \"special_tokens_mask\" in encoded_inputs:\n-                    encoded_inputs[\"special_tokens_mask\"] = encoded_inputs[\"special_tokens_mask\"] + [1] * difference\n-                encoded_inputs[self.model_input_names[0]] = required_input + [self.pad_token_id] * difference\n-            elif padding_side == \"left\":\n-                if return_attention_mask:\n-                    encoded_inputs[\"attention_mask\"] = [0] * difference + encoded_inputs[\"attention_mask\"]\n-                if \"special_tokens_mask\" in encoded_inputs:\n-                    encoded_inputs[\"special_tokens_mask\"] = [1] * difference + encoded_inputs[\"special_tokens_mask\"]\n-                encoded_inputs[self.model_input_names[0]] = [self.pad_token_id] * difference + required_input\n-            else:\n-                raise ValueError(f\"Invalid padding strategy:{padding_side}\")\n-\n-        return encoded_inputs\n+        return BatchEncoding(encoded_inputs, tensor_type=return_tensors, prepend_batch_axis=prepend_batch_axis)\n \n-    def pad(\n-        self,\n-        encoded_inputs: BatchEncoding\n-        | list[BatchEncoding]\n-        | dict[str, EncodedInput]\n-        | dict[str, list[EncodedInput]]\n-        | list[dict[str, EncodedInput]],\n-        padding: bool | str | PaddingStrategy = True,\n-        max_length: int | None = None,\n-        pad_to_multiple_of: int | None = None,\n-        padding_side: str | None = None,\n-        return_attention_mask: bool | None = None,\n-        return_tensors: str | TensorType | None = None,\n-        verbose: bool = True,\n-    ) -> BatchEncoding:\n-        \"\"\"\n-        Pad a single encoded input or a batch of encoded inputs up to predefined length or to the max sequence length\n-        in the batch.\n-\n-        Padding side (left/right) padding token ids are defined at the tokenizer level (with `self.padding_side`,\n-        `self.pad_token_id`).\n-        <Tip>\n-\n-        If the `encoded_inputs` passed are dictionary of numpy arrays, PyTorch tensors, the\n-        result will use the same type unless you provide a different tensor type with `return_tensors`. In the case of\n-        PyTorch tensors, you will lose the specific device of your tensors however.\n-\n-        </Tip>\n-\n-        Args:\n-            encoded_inputs ([`BatchEncoding`], list of [`BatchEncoding`], `Dict[str, list[int]]`, `Dict[str, list[list[int]]` or `List[Dict[str, list[int]]]`):\n-                Tokenized inputs. Can represent one input ([`BatchEncoding`] or `Dict[str, list[int]]`) or a batch of\n-                tokenized inputs (list of [`BatchEncoding`], *Dict[str, list[list[int]]]* or *List[Dict[str,\n-                list[int]]]*) so you can use this method during preprocessing as well as in a PyTorch Dataloader\n-                collate function.\n-\n-                Instead of `list[int]` you can have tensors (numpy arrays, PyTorch tensors), see\n-                the note above for the return type.\n-            padding (`bool`, `str` or [`~utils.PaddingStrategy`], *optional*, defaults to `True`):\n-                 Select a strategy to pad the returned sequences (according to the model's padding side and padding\n-                 index) among:\n-\n-                - `True` or `'longest'` (default): Pad to the longest sequence in the batch (or no padding if only a single\n-                  sequence if provided).\n-                - `'max_length'`: Pad to a maximum length specified with the argument `max_length` or to the maximum\n-                  acceptable input length for the model if that argument is not provided.\n-                - `False` or `'do_not_pad'`: No padding (i.e., can output a batch with sequences of different\n-                  lengths).\n-            max_length (`int`, *optional*):\n-                Maximum length of the returned list and optionally padding length (see above).\n-            pad_to_multiple_of (`int`, *optional*):\n-                If set will pad the sequence to a multiple of the provided value.\n-\n-                This is especially useful to enable the use of Tensor Cores on NVIDIA hardware with compute capability\n-                `>= 7.5` (Volta).\n-            padding_side (`str`, *optional*):\n-                The side on which the model should have padding applied. Should be selected between ['right', 'left'].\n-                Default value is picked from the class attribute of the same name.\n-            return_attention_mask (`bool`, *optional*):\n-                Whether to return the attention mask. If left to the default, will return the attention mask according\n-                to the specific tokenizer's default, defined by the `return_outputs` attribute.\n-\n-                [What are attention masks?](../glossary#attention-mask)\n-            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n-                If set, will return tensors instead of list of python integers. Acceptable values are:\n-\n-                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n-                - `'np'`: Return Numpy `np.ndarray` objects.\n-            verbose (`bool`, *optional*, defaults to `True`):\n-                Whether or not to print more information and warnings.\n-        \"\"\"\n-        # If we have a list of dicts, let's convert it in a dict of lists\n-        # We do this to allow using this method as a collate_fn function in PyTorch Dataloader\n-        if isinstance(encoded_inputs, (list, tuple)) and isinstance(encoded_inputs[0], Mapping):\n-            # Call .keys() explicitly for compatibility with TensorDict and other Mapping subclasses\n-            encoded_inputs = {key: [example[key] for example in encoded_inputs] for key in encoded_inputs[0].keys()}\n-\n-        # The model's main input name, usually `input_ids`, has been passed for padding\n-        if self.model_input_names[0] not in encoded_inputs:\n-            raise ValueError(\n-                \"You should supply an encoding or a list of encodings to this method \"\n-                f\"that includes {self.model_input_names[0]}, but you provided {list(encoded_inputs.keys())}\"\n-            )\n-\n-        required_input = encoded_inputs[self.model_input_names[0]]\n-\n-        if required_input is None or (isinstance(required_input, Sized) and len(required_input) == 0):\n-            if return_attention_mask:\n-                encoded_inputs[\"attention_mask\"] = []\n-            return encoded_inputs\n-\n-        # If we have PyTorch/NumPy tensors/arrays as inputs, we cast them as python objects\n-        # and rebuild them afterwards if no return_tensors is specified\n-        # Note that we lose the specific device the tensor may be on for PyTorch\n-\n-        first_element = required_input[0]\n-        if isinstance(first_element, (list, tuple)):\n-            # first_element might be an empty list/tuple in some edge cases so we grab the first non empty element.\n-            for item in required_input:\n-                if len(item) != 0:\n-                    first_element = item[0]\n-                    break\n-        # At this state, if `first_element` is still a list/tuple, it's an empty one so there is nothing to do.\n-        if not isinstance(first_element, (int, list, tuple)):\n-            if is_torch_tensor(first_element):\n-                return_tensors = \"pt\" if return_tensors is None else return_tensors\n-            elif isinstance(first_element, np.ndarray):\n-                return_tensors = \"np\" if return_tensors is None else return_tensors\n-            else:\n-                raise ValueError(\n-                    f\"type of {first_element} unknown: {type(first_element)}. \"\n-                    \"Should be one of a python, numpy, or pytorch object.\"\n-                )\n-\n-            for key, value in encoded_inputs.items():\n-                encoded_inputs[key] = to_py_obj(value)\n-\n-        # Convert padding_strategy in PaddingStrategy\n-        padding_strategy, _, max_length, _ = self._get_padding_truncation_strategies(\n-            padding=padding, max_length=max_length, verbose=verbose\n-        )\n-\n-        required_input = encoded_inputs[self.model_input_names[0]]\n-        if required_input and not isinstance(required_input[0], (list, tuple)):\n-            encoded_inputs = self._pad(\n-                encoded_inputs,\n-                max_length=max_length,\n-                padding_strategy=padding_strategy,\n-                pad_to_multiple_of=pad_to_multiple_of,\n-                padding_side=padding_side,\n-                return_attention_mask=return_attention_mask,\n-            )\n-            return BatchEncoding(encoded_inputs, tensor_type=return_tensors)\n-\n-        batch_size = len(required_input)\n-        assert all(len(v) == batch_size for v in encoded_inputs.values()), (\n-            \"Some items in the output dictionary have a different batch size than others.\"\n-        )\n-\n-        if padding_strategy == PaddingStrategy.LONGEST:\n-            max_length = max(len(inputs) for inputs in required_input)\n-            padding_strategy = PaddingStrategy.MAX_LENGTH\n-\n-        batch_outputs = {}\n-        for i in range(batch_size):\n-            inputs = {k: v[i] for k, v in encoded_inputs.items()}\n-            outputs = self._pad(\n-                inputs,\n-                max_length=max_length,\n-                padding_strategy=padding_strategy,\n-                pad_to_multiple_of=pad_to_multiple_of,\n-                padding_side=padding_side,\n-                return_attention_mask=return_attention_mask,\n-            )\n-\n-            for key, value in outputs.items():\n-                if key not in batch_outputs:\n-                    batch_outputs[key] = []\n-                batch_outputs[key].append(value)\n-\n-        return BatchEncoding(batch_outputs, tensor_type=return_tensors)\n-\n-    def truncate_sequences(\n+    def truncate_sequences(  # type: ignore[override]\n         self,\n         ids: list[int],\n         pair_ids: None = None,\n@@ -1407,47 +1000,36 @@ def truncate_sequences(\n             `Tuple[list[int], None, list[int]]`: The truncated `ids` and the list of\n             overflowing tokens. `None` is returned to match Transformers signature.\n         \"\"\"\n-        if kwargs:\n-            raise ValueError(\n-                f\"Kwargs {list(kwargs.keys())} are not supported by `MistralCommonBackend.truncate_sequences`.\"\n-            )\n+\n         if pair_ids:\n             raise ValueError(\"`pair_ids` is not supported by `MistralCommonBackend.truncate_sequences`.\")\n \n-        if num_tokens_to_remove <= 0:\n-            return (ids, None, [])\n-\n         if not isinstance(truncation_strategy, TruncationStrategy):\n             truncation_strategy = TruncationStrategy(truncation_strategy)\n \n-        if truncation_strategy in [TruncationStrategy.ONLY_FIRST, TruncationStrategy.ONLY_SECOND]:\n-            raise ValueError(\n-                f\"Only {TruncationStrategy.LONGEST_FIRST} and {TruncationStrategy.DO_NOT_TRUNCATE} are supported.\"\n-            )\n+        if truncation_strategy in [\n+            TruncationStrategy.ONLY_FIRST,\n+            TruncationStrategy.ONLY_SECOND,\n+        ]:\n+            raise ValueError(f\"{truncation_strategy=} is not supported by `MistralCommonBackend`.\")\n+\n+        if num_tokens_to_remove <= 0:\n+            return ids, None, []\n \n         overflowing_tokens = []\n-        if truncation_strategy == TruncationStrategy.LONGEST_FIRST:\n-            if len(ids) > num_tokens_to_remove:\n-                window_len = min(len(ids), stride + num_tokens_to_remove)\n-                if self.truncation_side == \"left\":\n-                    overflowing_tokens = ids[:window_len]\n-                    ids = ids[num_tokens_to_remove:]\n-                elif self.truncation_side == \"right\":\n-                    overflowing_tokens = ids[-window_len:]\n-                    ids = ids[:-num_tokens_to_remove]\n-                else:\n-                    raise ValueError(f\"invalid truncation strategy: {self.truncation_side}, use 'left' or 'right'.\")\n \n+        if truncation_strategy == TruncationStrategy.LONGEST_FIRST:\n+            window_len = min(len(ids), stride + num_tokens_to_remove)\n+            if self.truncation_side == \"left\":\n+                overflowing_tokens = ids[:window_len]\n+                ids = ids[num_tokens_to_remove:]\n             else:\n-                error_msg = (\n-                    f\"We need to remove {num_tokens_to_remove} to truncate the input \"\n-                    f\"but the first sequence has a length {len(ids)}. \"\n-                )\n-                logger.error(error_msg)\n+                overflowing_tokens = ids[-window_len:]\n+                ids = ids[:-num_tokens_to_remove]\n \n-        return (ids, None, overflowing_tokens)\n+        return ids, None, overflowing_tokens\n \n-    def apply_chat_template(\n+    def apply_chat_template(  # type: ignore[override]\n         self,\n         conversation: list[dict[str, str]] | list[list[dict[str, str]]],\n         tools: list[dict | Callable] | None = None,\n@@ -1475,8 +1057,8 @@ def apply_chat_template(\n                 [chat templating guide](https://huggingface.co/docs/transformers/main/en/chat_templating#automated-function-conversion-for-tool-use)\n                 for more information.\n             add_generation_prompt (`bool`, *optional*):\n-                This argument is a no-op for `MistralCommonBackend`. However it cannot be used at the same time as `continue_final_message` to keep the API consistent and\n-                if any conversation ends with an assistant message, it will raise an error. In such case, use `continue_final_message` instead.\n+                This argument is a no-op for `MistralCommonBackend`. However, it cannot be used at the same time as `continue_final_message` to keep the API consistent.\n+                If any conversation ends with an assistant message, it will raise an error. In such cases, use `continue_final_message` instead.\n             continue_final_message (bool, *optional*):\n                 If this is set, the chat will be formatted so that the final\n                 message in the chat is open-ended, without any EOS tokens. The model will continue this message\n@@ -1511,8 +1093,7 @@ def apply_chat_template(\n                 Will raise an error if used.\n \n         Returns:\n-            `Union[str, list[int], list[str], list[list[int]], BatchEncoding]`: A list of token ids representing the tokenized chat so far, including control\n-            tokens. This output is ready to pass to the model, either directly or via methods like `generate()`.\n+            `Union[str, list[int], list[str], list[list[int]], BatchEncoding]`: The tokenized chat so far, including control tokens. This output is ready to pass to the model, either directly or via methods like `generate()`.\n         \"\"\"\n         if kwargs:\n             raise ValueError(\n@@ -1659,6 +1240,83 @@ def _maybe_adapt_message(message: dict[str, Any]) -> None:\n             )\n             return outputs\n \n+    def build_inputs_with_special_tokens(self, token_ids_0: list[int], token_ids_1: None = None) -> list[int]:\n+        \"\"\"\n+        Build model inputs from a sequence by adding special tokens.\n+\n+        This method dynamically builds inputs based on the tokenizer's `mode`:\n+        - `\"test\"`: seq0 [EOS]\n+        - `\"finetuning\"`: [BOS] seq0\n+\n+        Args:\n+            token_ids_0 (`list[int]`):\n+                List of IDs to which the special tokens will be added.\n+            token_ids_1 (`None`, *optional*): None, kept to match Transformers' signature.\n+\n+        Returns:\n+            `list[int]`: List of input IDs with the appropriate special tokens.\n+        \"\"\"\n+        if token_ids_1 is not None:\n+            raise ValueError(\n+                \"`MistralCommonBackend` does not implement `token_ids_1 != None` for `build_inputs_with_special_tokens`.\"\n+            )\n+\n+        if self.mode == ValidationMode.test:\n+            # [BOS] seq0\n+            return [self.bos_token_id] + token_ids_0\n+\n+        else:\n+            # [BOS] seq0 [EOS]\n+            return [self.bos_token_id] + token_ids_0 + [self.eos_token_id]\n+\n+    def create_token_type_ids_from_sequences(self, token_ids_0: list[int], token_ids_1: None = None) -> list[int]:\n+        \"\"\"\n+        Create a mask of zeroes from the token ids with special tokens added.\n+\n+        Kept to match Transformers' implementation.\n+\n+        Args:\n+            token_ids_0 (`list[int]`):\n+                List of IDs.\n+            token_ids_1 (`None`, *optional*): None, kept to match Transformers' signature.\n+\n+\n+        Returns:\n+            `list[int]`: Token type IDs according to the configured pattern.\n+        \"\"\"\n+        if token_ids_1 is not None:\n+            raise ValueError(\n+                \"`MistralCommonBackend` does not implement `token_ids_1 != None` for `create_token_type_ids_from_sequences`.\"\n+            )\n+\n+        sequence = self.build_inputs_with_special_tokens(token_ids_0)\n+\n+        return [0] * len(sequence)\n+\n+    def num_special_tokens_to_add(self, pair: Literal[False] = False) -> int:\n+        \"\"\"\n+        Returns the number of added tokens when encoding a sequence with special tokens.\n+\n+        <Tip>\n+\n+        This encodes a dummy input and checks the number of added tokens, and is therefore not efficient. Do not put\n+        this inside your training loop.\n+\n+        </Tip>\n+\n+        Args:\n+            pair (`Literal[False]`, *optional*): False, kept to match Transformer's signature.\n+\n+        Returns:\n+            `int`: Number of special tokens added to sequences.\n+        \"\"\"\n+        if pair:\n+            raise ValueError(\n+                \"`MistralCommonBackend` does not implement `pair = True` for `num_special_tokens_to_add`.\"\n+            )\n+\n+        return len(self.build_inputs_with_special_tokens([], None))\n+\n     @add_end_docstrings(ENCODE_KWARGS_DOCSTRING, ENCODE_PLUS_ADDITIONAL_KWARGS_DOCSTRING)\n     def __call__(\n         self,\n@@ -1679,6 +1337,8 @@ def __call__(\n         return_special_tokens_mask: bool = False,\n         return_length: bool = False,\n         verbose: bool = True,\n+        return_offsets_mapping: Literal[False] = False,\n+        split_special_tokens: Literal[False] = False,\n         **kwargs,\n     ) -> BatchEncoding:\n         \"\"\"\n@@ -1696,86 +1356,43 @@ def __call__(\n             text_pair_target (`None`, *optional*):\n                 Not supported by `MistralCommonBackend`. Kept to match the signature of `PreTrainedTokenizerBase.__call__`.\n         \"\"\"\n-        if kwargs:\n-            raise ValueError(f\"Kwargs {list(kwargs.keys())} are not supported by `MistralCommonBackend.__call__`.\")\n+        if return_offsets_mapping or split_special_tokens:\n+            raise ValueError(\n+                \"`MistralCommonBackend` does not support `return_offsets_mapping` and `split_special_tokens`.\"\n+            )\n \n-        if text_pair or text_target or text_pair_target:\n+        if truncation in [TruncationStrategy.ONLY_FIRST, TruncationStrategy.ONLY_SECOND, \"only_first\", \"only_second\"]:\n             raise ValueError(\n-                \"`text_pair`, `text_target` and `text_pair_target` are not supported by `MistralCommonBackend`.\"\n+                \"Truncation strategy `only_first` and `only_second` are not supported by `MistralCommonBackend`.\"\n             )\n \n-        def _is_valid_text_input(t):\n-            if isinstance(t, str):\n-                # Strings are fine\n-                return True\n-            elif isinstance(t, (list, tuple)):\n-                # List are fine as long as they are...\n-                if len(t) == 0:\n-                    # ... empty\n-                    return True\n-                elif isinstance(t[0], (str, int)):\n-                    # ... list of strings or int\n-                    return True\n-                elif isinstance(t[0], (list, tuple)):\n-                    # ... list with an empty list or with a list of strings or with a list of ints\n-                    return len(t[0]) == 0 or isinstance(t[0][0], (str, int))\n-                else:\n-                    return False\n-            else:\n-                return False\n+        if kwargs:\n+            raise ValueError(f\"Kwargs {list(kwargs.keys())} are not supported by `MistralCommonBackend.__call__`.\")\n \n-        if not _is_valid_text_input(text):\n+        if text_pair or text_target or text_pair_target:\n             raise ValueError(\n-                \"text input must be of type `str` (single example), `list[str]` (batch or single encoded example) \"\n-                \"or `list[list[int]]` (batch of encoded examples).\"\n+                \"`text_pair`, `text_target` and `text_pair_target` are not supported by `MistralCommonBackend`.\"\n             )\n \n-        is_batched = isinstance(text, (list, tuple)) and isinstance(text[0], (str, list, tuple))\n-\n-        padding_strategy, truncation_strategy, max_length, kwargs = self._get_padding_truncation_strategies(\n+        return super().__call__(\n+            text=text,\n+            text_pair=text_pair,\n+            text_target=text_target,\n+            add_special_tokens=add_special_tokens,\n             padding=padding,\n             truncation=truncation,\n             max_length=max_length,\n+            stride=stride,\n             pad_to_multiple_of=pad_to_multiple_of,\n+            padding_side=padding_side,\n+            return_tensors=return_tensors,\n+            return_attention_mask=return_attention_mask,\n+            return_overflowing_tokens=return_overflowing_tokens,\n+            return_special_tokens_mask=return_special_tokens_mask,\n+            return_length=return_length,\n             verbose=verbose,\n-            **kwargs,\n         )\n \n-        if is_batched:\n-            return self._batch_encode_plus(\n-                batch_text=text,\n-                add_special_tokens=add_special_tokens,\n-                padding_strategy=padding_strategy,\n-                truncation_strategy=truncation_strategy,\n-                max_length=max_length,\n-                stride=stride,\n-                pad_to_multiple_of=pad_to_multiple_of,\n-                padding_side=padding_side,\n-                return_tensors=return_tensors,\n-                return_attention_mask=return_attention_mask,\n-                return_overflowing_tokens=return_overflowing_tokens,\n-                return_special_tokens_mask=return_special_tokens_mask,\n-                return_length=return_length,\n-                verbose=verbose,\n-            )\n-        else:\n-            return self._encode_plus(\n-                text=text,\n-                add_special_tokens=add_special_tokens,\n-                padding_strategy=padding_strategy,\n-                truncation_strategy=truncation_strategy,\n-                max_length=max_length,\n-                stride=stride,\n-                pad_to_multiple_of=pad_to_multiple_of,\n-                padding_side=padding_side,\n-                return_tensors=return_tensors,\n-                return_attention_mask=return_attention_mask,\n-                return_overflowing_tokens=return_overflowing_tokens,\n-                return_special_tokens_mask=return_special_tokens_mask,\n-                return_length=return_length,\n-                verbose=verbose,\n-            )\n-\n     @classmethod\n     def from_pretrained(\n         cls,\n@@ -1808,9 +1425,9 @@ def from_pretrained(\n                   `./my_model_directory/`.\n             mode (`Union[str, ValidationMode]`, *optional*, defaults to `ValidationMode.test`):\n                 Validation mode for the `MistralTokenizer` tokenizer. Possible values are:\n-                - `\"finetuning\"` or `ValidationMode.finetuning`: The finetuning mode.\n+                - `\"finetuning\"` or `ValidationMode.finetuning`: The fine-tuning mode.\n                 - `\"test\"` or `ValidationMode.test`: The test mode.\n-                It changes how the tokenizer validates the input and prepare the request to the model.\n+                It changes how the tokenizer validates the input and prepares the request to the model.\n             cache_dir (`str` or `os.PathLike`, *optional*):\n                 Path to a directory in which a downloaded predefined tokenizer vocabulary files should be cached if the\n                 standard cache should not be used.\n@@ -1837,11 +1454,11 @@ def from_pretrained(\n                 Default value is picked from the class attribute of the same name.\n             truncation_side (`str`, *optional*, defaults to `\"right\"`):\n                 The side on which the model should have truncation applied. Should be selected between ['right', 'left'].\n-            model_input_names (`List[string]`, *optional*):\n+            model_input_names (`List[str]`, *optional*):\n                 The list of inputs accepted by the forward pass of the model (like `\"token_type_ids\"` or\n                 `\"attention_mask\"`). Default value is picked from the class attribute of the same name.\n             clean_up_tokenization_spaces (`bool`, *optional*, defaults to `False`):\n-                Whether or not the model should cleanup the spaces that were added when splitting the input text during the\n+                Whether or not the model should clean up the spaces that were added when splitting the input text during the\n                 tokenization process.\n             kwargs (additional keyword arguments, *optional*):\n                 Not supported by `MistralCommonBackend.from_pretrained`.\n@@ -1851,11 +1468,13 @@ def from_pretrained(\n             raise ValueError(\"`init_inputs` are not supported by `MistralCommonBackend.from_pretrained`.\")\n \n         # Handle kwargs and AutoTokenizer/AutoProcessor case\n-        # These kwargs are passed by AutoTokenizer/AutoProcessor but are not used by MistralCommonBackend\n-        if kwargs and not set(kwargs.keys()).issubset(\n-            {\"trust_remote_code\", \"_from_pipeline\", \"_commit_hash\", \"dtype\", \"_from_auto\", \"subfolder\"}\n-        ):\n-            raise ValueError(f\"Some kwargs in {kwargs} are not supported by `MistralCommonBackend.from_pretrained`.\")\n+        valid_kwargs = _VALID_INIT_KWARGS.union(\n+            {\"trust_remote_code\", \"_from_pipeline\", \"_commit_hash\", \"dtype\", \"subfolder\"}\n+        )\n+        if kwargs and not set(kwargs.keys()).issubset(valid_kwargs):\n+            raise ValueError(\n+                f\"Some kwargs in {list(kwargs.keys())} are not supported by `MistralCommonBackend.from_pretrained`.\"\n+            )\n \n         mode = cls._get_validation_mode(mode)\n \n@@ -1869,35 +1488,8 @@ def from_pretrained(\n                 local_files_only=local_files_only,\n             )\n         else:\n-            valid_tokenizer_files = []\n-            tokenizer_file: str\n-\n-            instruct_versions = list(TokenizerVersion.__members__)\n-            mm_versions = list(MultiModalVersion.__members__) + [\"\"]  # allow no mm version\n-            sentencepiece_suffixes = [f\".model.{v}{m}\" for v in instruct_versions for m in mm_versions] + [\".model\"]\n-\n-            for path in os.listdir(pretrained_model_name_or_path):\n-                pathlib_repo_file = Path(path)\n-                file_name = pathlib_repo_file.name\n-                suffix = \"\".join(pathlib_repo_file.suffixes)\n-                if file_name == \"tekken.json\" or suffix in sentencepiece_suffixes:\n-                    valid_tokenizer_files.append(file_name)\n-\n-            if len(valid_tokenizer_files) == 0:\n-                raise ValueError(f\"No tokenizer file found in directory: {pretrained_model_name_or_path}\")\n-            # If there are multiple tokenizer files, we use tekken.json if it exists, otherwise the versioned one.\n-            if len(valid_tokenizer_files) > 1:\n-                if \"tekken.json\" in valid_tokenizer_files:\n-                    tokenizer_file = \"tekken.json\"\n-                else:\n-                    tokenizer_file = max(valid_tokenizer_files)\n-                logger.warning(\n-                    f\"Multiple tokenizer files found in directory: {pretrained_model_name_or_path}. Using {tokenizer_file}.\"\n-                )\n-            else:\n-                tokenizer_file = valid_tokenizer_files[0]\n-\n-            tokenizer_path = os.path.join(pretrained_model_name_or_path, tokenizer_file)\n+            candidate_files = os.listdir(pretrained_model_name_or_path)\n+            tokenizer_path = os.path.join(pretrained_model_name_or_path, get_one_valid_tokenizer_file(candidate_files))\n \n         return cls(\n             tokenizer_path=tokenizer_path,\n@@ -1909,7 +1501,7 @@ def from_pretrained(\n             clean_up_tokenization_spaces=clean_up_tokenization_spaces,\n         )\n \n-    def save_pretrained(\n+    def save_pretrained(  # type: ignore[override]\n         self,\n         save_directory: str | os.PathLike | Path,\n         push_to_hub: bool = False,\n@@ -1988,6 +1580,65 @@ def _get_validation_mode(mode: str | ValidationMode) -> ValidationMode:\n             raise ValueError(_invalid_mode_msg)\n         return mode\n \n+    def add_special_tokens(\n+        self,\n+        special_tokens_dict: dict[str, str | AddedToken | Sequence[str | AddedToken]],\n+        replace_extra_special_tokens: bool = True,\n+    ):\n+        r\"\"\"`MistralCommonBackend` does not implement `add_special_tokens` by design.\n+\n+        If you would like this behaviour to be implemented, please open an issue in the `Transformers` or `mistral-common` repositories to request it.\n+        \"\"\"\n+\n+        raise NotImplementedError(\"`MistralCommonBackend` does not implement `add_special_tokens`.\")\n+\n+    def add_tokens(  # type: ignore[override]\n+        self,\n+        special_tokens_dict: dict[str, str | AddedToken | Sequence[str | AddedToken]],\n+        replace_extra_special_tokens: bool = True,\n+    ):\n+        \"\"\"\n+        `MistralCommonBackend` does not implement `add_special_tokens` by design.\n+\n+        If you would like this behaviour to be implemented, please open an issue in the `Transformers` or `mistral-common` repositories to request it.\n+        \"\"\"\n+\n+        raise NotImplementedError(\"`MistralCommonBackend` does not implement `add_tokens`.\")\n+\n+    def convert_added_tokens(cls, obj: AddedToken | Any, save: bool = False, add_type_field: bool = True):  # type: ignore[override]\n+        \"\"\"\n+        `MistralCommonBackend` does not implement `convert_added_tokens` by design.\n+\n+        If you would like this behaviour to be implemented, please open an issue in the `Transformers` or `mistral-common` repositories to request it.\n+        \"\"\"\n+\n+        raise NotImplementedError(\"`MistralCommonBackend` does not implement `convert_added_tokens`.\")\n+\n+    def get_chat_template(self, chat_template: str | None = None, tools: list[dict] | None = None) -> str:\n+        \"\"\"`MistralCommonBackend` does not implement `get_chat_template` by design as `mistral-common` does not use chat templates.\"\"\"\n+\n+        raise NotImplementedError(\"`MistralCommonBackend` does not implement `get_chat_template`.\")\n+\n+    def save_chat_templates(\n+        self,\n+        save_directory: str | os.PathLike,\n+        tokenizer_config: dict,\n+        filename_prefix: str | None,\n+        save_jinja_files: bool,\n+    ):\n+        \"\"\"`MistralCommonBackend` does not implement `save_chat_templates` by design as `mistral-common` does not use chat templates.\"\"\"\n+\n+        raise NotImplementedError(\"`MistralCommonBackend` does not implement `save_chat_templates`.\")\n+\n+    def save_vocabulary(self, save_directory: str, filename_prefix: str | None = None) -> tuple[str, ...]:\n+        \"\"\"\n+        `MistralCommonBackend` does not implement `save_vocabulary` by design.\n+\n+        This is because `mistral-common` is configured by one tokenizer file. If you'd like to save the vocabulary, please consider using the `save_pretrained` method instead.\n+        \"\"\"\n+\n+        raise NotImplementedError(\"`MistralCommonBackend` does not implement `save_vocabulary`.\")\n+\n \n # Backward compatibility alias for codebases still importing the legacy name.\n MistralCommonTokenizer = MistralCommonBackend"
        },
        {
            "sha": "5800964f0c34f91146b8bae9ab2c5928f241332c",
            "filename": "src/transformers/tokenization_utils_base.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31/src%2Ftransformers%2Ftokenization_utils_base.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31/src%2Ftransformers%2Ftokenization_utils_base.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Ftokenization_utils_base.py?ref=2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31",
            "patch": "@@ -2312,15 +2312,15 @@ def encode(\n                 the `tokenize` method) or a list of integers (tokenized string ids using the `convert_tokens_to_ids`\n                 method).\n         \"\"\"\n-        padding_strategy, truncation_strategy, max_length, kwargs = self._get_padding_truncation_strategies(\n+        padding_strategy, truncation_strategy, max_length, kwargs_updated = self._get_padding_truncation_strategies(\n             padding=padding,\n             truncation=truncation,\n             max_length=max_length,\n-            pad_to_multiple_of=kwargs.get(\"pad_to_multiple_of\"),\n-            verbose=kwargs.get(\"verbose\", True),\n             **kwargs,\n         )\n \n+        kwargs.update(kwargs_updated)\n+\n         encoded_inputs = self._encode_plus(\n             text,\n             text_pair=text_pair,"
        },
        {
            "sha": "54daa393b4d7efb0401d91040f5885eef77e2a58",
            "filename": "tests/test_tokenization_mistral_common.py",
            "status": "modified",
            "additions": 158,
            "deletions": 46,
            "changes": 204,
            "blob_url": "https://github.com/huggingface/transformers/blob/2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31/tests%2Ftest_tokenization_mistral_common.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31/tests%2Ftest_tokenization_mistral_common.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Ftest_tokenization_mistral_common.py?ref=2877e4e2ab41bd8934ae7691cb50a0f7a7c2fb31"
        }
    ],
    "stats": {
        "total": 1667,
        "additions": 715,
        "deletions": 952
    }
}