{
    "author": "ydshieh",
    "message": "Fix `_get_test_info` for inherited tests (#41106)\n\n* fix _get_test_info\n\n* fix patched\n\n* add comment\n\n* ruff\n\n---------\n\nCo-authored-by: ydshieh <ydshieh@users.noreply.github.com>",
    "sha": "00f3d90720957cb4a723d29004424368025b7ae6",
    "files": [
        {
            "sha": "a7bbc8cd82fcf9cdf843754fb2881a9f0edab368",
            "filename": "src/transformers/testing_utils.py",
            "status": "modified",
            "additions": 38,
            "deletions": 14,
            "changes": 52,
            "blob_url": "https://github.com/huggingface/transformers/blob/00f3d90720957cb4a723d29004424368025b7ae6/src%2Ftransformers%2Ftesting_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/00f3d90720957cb4a723d29004424368025b7ae6/src%2Ftransformers%2Ftesting_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Ftesting_utils.py?ref=00f3d90720957cb4a723d29004424368025b7ae6",
            "patch": "@@ -3357,15 +3357,27 @@ def _get_test_info():\n     stack_from_inspect = inspect.stack()\n     # but visit from the top frame to the most recent frame\n \n+    actual_test_file, _actual_test_class = test_file, test_class\n     test_frame, test_obj, test_method = None, None, None\n     for frame in reversed(stack_from_inspect):\n-        if test_file in str(frame).replace(r\"\\\\\", \"/\"):\n-            if test_name == frame.frame.f_locals[\"self\"]._testMethodName:\n-                test_frame = frame\n-                # The test instance\n-                test_obj = frame.frame.f_locals[\"self\"]\n-                test_method = getattr(test_obj, test_name)\n-                break\n+        # if test_file in str(frame).replace(r\"\\\\\", \"/\"):\n+        # check frame's function + if it has `self` as locals; double check if self has the (function) name\n+        # TODO: Question: How about expanded?\n+        if (\n+            frame.function == test_name\n+            and \"self\" in frame.frame.f_locals\n+            and hasattr(frame.frame.f_locals[\"self\"], test_name)\n+        ):\n+            # if test_name == frame.frame.f_locals[\"self\"]._testMethodName:\n+            test_frame = frame\n+            # The test instance\n+            test_obj = frame.frame.f_locals[\"self\"]\n+            # TODO: Do we get the (relative?) path or it's just a file name?\n+            # TODO: Does `test_obj` always have `tearDown` object?\n+            actual_test_file = frame.filename\n+            # TODO: check `test_method` will work used at the several places!\n+            test_method = getattr(test_obj, test_name)\n+            break\n \n     if test_frame is not None:\n         line_number = test_frame.lineno\n@@ -3379,9 +3391,12 @@ def _get_test_info():\n     # From the most outer (i.e. python's `runpy.py`) frame to most inner frame (i.e. the frame of this method)\n     # Between `the test method being called` and `before entering `patched``.\n     for frame in reversed(stack_from_inspect):\n-        if test_file in str(frame).replace(r\"\\\\\", \"/\"):\n-            if \"self\" in frame.frame.f_locals and test_name == frame.frame.f_locals[\"self\"]._testMethodName:\n-                to_capture = True\n+        if (\n+            frame.function == test_name\n+            and \"self\" in frame.frame.f_locals\n+            and hasattr(frame.frame.f_locals[\"self\"], test_name)\n+        ):\n+            to_capture = True\n         # TODO: check simply with the name is not robust.\n         elif \"patched\" == frame.frame.f_code.co_name:\n             frame_of_patched_obj = frame\n@@ -3415,7 +3430,7 @@ def _get_test_info():\n     # Get the code context in the test function/method.\n     from _pytest._code.source import Source\n \n-    with open(test_file) as fp:\n+    with open(actual_test_file) as fp:\n         s = fp.read()\n         source = Source(s)\n         test_code_context = \"\\n\".join(source.getstatement(test_lineno - 1).lines)\n@@ -3426,9 +3441,7 @@ def _get_test_info():\n         source = Source(s)\n         caller_code_context = \"\\n\".join(source.getstatement(caller_lineno - 1).lines)\n \n-    test_info = (\n-        f\"test:\\n\\n{full_test_name}\\n\\n{'-' * 80}\\n\\ntest context: {test_file}:{test_lineno}\\n\\n{test_code_context}\"\n-    )\n+    test_info = f\"test:\\n\\n{full_test_name}\\n\\n{'-' * 80}\\n\\ntest context: {actual_test_file}:{test_lineno}\\n\\n{test_code_context}\"\n     test_info = f\"{test_info}\\n\\n{'-' * 80}\\n\\ncaller context: {caller_path}:{caller_lineno}\\n\\n{caller_code_context}\"\n \n     return (\n@@ -3649,6 +3662,17 @@ def patched(*args, **kwargs):\n             info = _parse_call_info_func(orig_method, args, kwargs, call_argument_expressions, target_args)\n             info = _prepare_debugging_info(test_info, info)\n \n+            # If the test is running in a CI environment (e.g. not a manual run), let's raise and fail the test, so it\n+            # behaves as usual.\n+            # On Github Actions or CircleCI, this is set automatically.\n+            # When running manually, it's the user to determine if to set it.\n+            # This is to avoid the patched function being called `with self.assertRaises(AssertionError):` and fails\n+            # because of the missing expected `AssertionError`.\n+            # TODO (ydshieh): If there is way to raise only when we are inside such context managers?\n+            # TODO (ydshieh): How not to record the failure if it happens inside `self.assertRaises(AssertionError)`?\n+            if os.getenv(\"CI\") == \"true\":\n+                raise captured_exception.with_traceback(test_traceback)\n+\n             # Save this, so we can raise at the end of the current test\n             captured_failure = {\n                 \"result\": \"failed\","
        }
    ],
    "stats": {
        "total": 52,
        "additions": 38,
        "deletions": 14
    }
}