{
    "author": "manueldeprada",
    "message": "ðŸš¨ Remove Constrained Beam Search decoding strategy (#40518)\n\n* Squashed remove-constrastive-search\n\n* sweeep ready for tests\n\n* testing...\n\n* whoops\n\n* ops\n\n* tests fix\n\n* tests green, changed handling of deprecated methods\n\n* tests gone after green\n\n* restore and deprecate beam obkects\n\n* restore and deprecate constraint objects\n\n* fix ci\n\n* review",
    "sha": "8564e210ca02f88892e04ded0c8321bb44e4398d",
    "files": [
        {
            "sha": "05991e4fc323f379b990dabc000fd28ba24634e5",
            "filename": "docs/source/ar/notebooks.md",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/docs%2Fsource%2Far%2Fnotebooks.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/docs%2Fsource%2Far%2Fnotebooks.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Far%2Fnotebooks.md?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -39,7 +39,6 @@\n | [ÙƒÙŠÙÙŠØ© Ø¶Ø¨Ø· Ù†Ù…ÙˆØ°Ø¬ Ø¨Ø¯Ù‚Ø© Ø¹Ù„Ù‰ Ø§Ù„ØªÙ„Ø®ÙŠØµ](https://github.com/huggingface/notebooks/blob/main/examples/summarization.ipynb)| ÙŠÙˆØ¶Ø­ ÙƒÙŠÙÙŠØ© Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø³Ø¨Ù‚Ù‹Ø§ ÙˆØ¶Ø¨Ø· Ù†Ù…ÙˆØ°Ø¬ Ù…ÙØ¯Ø±ÙŽÙ‘Ø¨ Ù…Ø³Ø¨Ù‚Ù‹Ø§ Ø¨Ø¯Ù‚Ø© Ø¹Ù„Ù‰ XSUM. | [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/summarization.ipynb)| [![Open in AWS Studio](https://studiolab.sagemaker.aws/studiolab.svg)](https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/main/examples/summarization.ipynb)|\n | [ÙƒÙŠÙÙŠØ© ØªØ¯Ø±ÙŠØ¨ Ù†Ù…ÙˆØ°Ø¬ Ù„ØºØ© Ù…Ù† Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©](https://github.com/huggingface/blog/blob/main/notebooks/01_how_to_train.ipynb)| ØªØ³Ù„ÙŠØ· Ø§Ù„Ø¶ÙˆØ¡ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ù„ØªØ¯Ø±ÙŠØ¨ Ù†Ù…ÙˆØ°Ø¬ Transformer Ø¨Ø´ÙƒÙ„ ÙØ¹Ø§Ù„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø®ØµØµØ© | [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/huggingface/blog/blob/main/notebooks/01_how_to_train.ipynb)| [![Open in AWS Studio](https://studiolab.sagemaker.aws/studiolab.svg)](https://studiolab.sagemaker.aws/import/github/huggingface/blog/blob/main/notebooks/01_how_to_train.ipynb)|\n | [ÙƒÙŠÙÙŠØ© Ø¥Ù†Ø´Ø§Ø¡ Ù†Øµ](https://github.com/huggingface/blog/blob/main/notebooks/02_how_to_generate.ipynb)| ÙƒÙŠÙÙŠØ© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ø³Ø§Ù„ÙŠØ¨ ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ± Ø§Ù„Ù…Ø®ØªÙ„ÙØ© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù„ØºØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø­ÙˆÙ„Ø§Øª | [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/huggingface/blog/blob/main/notebooks/02_how_to_generate.ipynb)| [![Open in AWS Studio](https://studiolab.sagemaker.aws/studiolab.svg)](https://studiolab.sagemaker.aws/import/github/huggingface/blog/blob/main/notebooks/02_how_to_generate.ipynb)|\n-| [ÙƒÙŠÙÙŠØ© Ø¥Ù†Ø´Ø§Ø¡ Ù†Øµ (Ù…Ø¹ Ù‚ÙŠÙˆØ¯)](https://github.com/huggingface/blog/blob/main/notebooks/53_constrained_beam_search.ipynb)| ÙƒÙŠÙÙŠØ© ØªÙˆØ¬ÙŠÙ‡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù„ØºØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù‚ÙŠÙˆØ¯ Ø§Ù„ØªÙŠ ÙŠÙˆÙØ±Ù‡Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… | [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/huggingface/blog/blob/main/notebooks/53_constrained_beam_search.ipynb)| [![Open in AWS Studio](https://studiolab.sagemaker.aws/studiolab.svg)](https://studiolab.sagemaker.aws/import/github/huggingface/blog/blob/main/notebooks/53_constrained_beam_search.ipynb)|\n | [Reformer](https://github.com/huggingface/blog/blob/main/notebooks/03_reformer.ipynb)| ÙƒÙŠÙ ÙŠØ¯ÙØ¹ Reformer Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù†Ù…Ø°Ø¬Ø© Ø§Ù„Ù„ØºÙˆÙŠØ© | [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/patrickvonplaten/blog/blob/main/notebooks/03_reformer.ipynb)| [![Open in AWS Studio](https://studiolab.sagemaker.aws/studiolab.svg)](https://studiolab.sagemaker.aws/import/github/patrickvonplaten/blog/blob/main/notebooks/03_reformer.ipynb)|\n \n #### Ø±Ø¤ÙŠØ© Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±[[pytorch-cv]]"
        },
        {
            "sha": "4b29c125373d2f3223466e673c587eb5eef08f57",
            "filename": "docs/source/ja/internal/generation_utils.md",
            "status": "modified",
            "additions": 0,
            "deletions": 22,
            "changes": 22,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/docs%2Fsource%2Fja%2Finternal%2Fgeneration_utils.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/docs%2Fsource%2Fja%2Finternal%2Fgeneration_utils.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fja%2Finternal%2Fgeneration_utils.md?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -300,28 +300,6 @@ generation_output[:2]\n [[autodoc]] MaxTimeCriteria\n     - __call__\n \n-## Constraints\n-\n-[`Constraint`] ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ç”Ÿæˆæ™‚ã«å‡ºåŠ›ã«ç‰¹å®šã®ãƒˆãƒ¼ã‚¯ãƒ³ã¾ãŸã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒå«ã¾ã‚Œã‚‹ã‚ˆã†ã«å¼·åˆ¶ã§ãã¾ã™ã€‚ã“ã‚Œã¯ PyTorch å®Ÿè£…ã§ã®ã¿åˆ©ç”¨å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚\n-\n-[[autodoc]] Constraint\n-\n-[[autodoc]] PhrasalConstraint\n-\n-[[autodoc]] DisjunctiveConstraint\n-\n-[[autodoc]] ConstraintListState\n-\n-## BeamSearch\n-\n-[[autodoc]] BeamScorer\n-    - process\n-    - finalize\n-\n-[[autodoc]] ConstrainedBeamSearchScorer\n-    - process\n-    - finalize\n-\n ## Streamers\n \n [[autodoc]] TextStreamer"
        },
        {
            "sha": "8b844260997947a35b4c248d1893640026751cf9",
            "filename": "docs/source/ko/internal/generation_utils.md",
            "status": "modified",
            "additions": 0,
            "deletions": 22,
            "changes": 22,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/docs%2Fsource%2Fko%2Finternal%2Fgeneration_utils.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/docs%2Fsource%2Fko%2Finternal%2Fgeneration_utils.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fko%2Finternal%2Fgeneration_utils.md?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -305,28 +305,6 @@ generation_output[:2]\n [[autodoc]] EosTokenCriteria\n     - __call__\n \n-## Constraint [[transformers.Constraint]]\n-\n-[`Constraint`]ëŠ” ìƒì„± ì¶œë ¥ì— íŠ¹ì • í† í°ì´ë‚˜ ì‹œí€€ìŠ¤ë¥¼ ê°•ì œë¡œ í¬í•¨ì‹œí‚¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ì´ ê¸°ëŠ¥ì€ PyTorch êµ¬í˜„ì—ë§Œ ì œê³µë©ë‹ˆë‹¤.\n-\n-[[autodoc]] Constraint\n-\n-[[autodoc]] PhrasalConstraint\n-\n-[[autodoc]] DisjunctiveConstraint\n-\n-[[autodoc]] ConstraintListState\n-\n-## ë¹” ê²€ìƒ‰ (BeamSearch) [[transformers.BeamScorer]]\n-\n-[[autodoc]] BeamScorer\n-    - process\n-    - finalize\n-\n-[[autodoc]] ConstrainedBeamSearchScorer\n-    - process\n-    - finalize\n-\n ## ìŠ¤íŠ¸ë¦¬ë¨¸ (Streamers) [[transformers.TextStreamer]]\n \n [[autodoc]] TextStreamer"
        },
        {
            "sha": "e7b821f93ecdbf7f30011e02999f9ca2151adb64",
            "filename": "docs/source/zh/internal/generation_utils.md",
            "status": "modified",
            "additions": 0,
            "deletions": 22,
            "changes": 22,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/docs%2Fsource%2Fzh%2Finternal%2Fgeneration_utils.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/docs%2Fsource%2Fzh%2Finternal%2Fgeneration_utils.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fzh%2Finternal%2Fgeneration_utils.md?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -295,28 +295,6 @@ generation_output[:2]\n [[autodoc]] MaxTimeCriteria\n     - __call__\n \n-## Constraints\n-\n-å¯ä»¥ä½¿ç”¨[`Constraint`]æ¥å¼ºåˆ¶ç”Ÿæˆç»“æžœåŒ…å«è¾“å‡ºä¸­çš„ç‰¹å®štokensæˆ–åºåˆ—ã€‚è¯·æ³¨æ„ï¼Œè¿™ä»…é€‚ç”¨äºŽæˆ‘ä»¬çš„PyTorchå®žçŽ°ã€‚\n-\n-[[autodoc]] Constraint\n-\n-[[autodoc]] PhrasalConstraint\n-\n-[[autodoc]] DisjunctiveConstraint\n-\n-[[autodoc]] ConstraintListState\n-\n-## BeamSearch\n-\n-[[autodoc]] BeamScorer\n-    - process\n-    - finalize\n-\n-[[autodoc]] ConstrainedBeamSearchScorer\n-    - process\n-    - finalize\n-\n ## Streamers\n \n [[autodoc]] TextStreamer"
        },
        {
            "sha": "4d31797104f83e60b230b246dfb930f5ae5ff0ab",
            "filename": "notebooks/README.md",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/notebooks%2FREADME.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/notebooks%2FREADME.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/notebooks%2FREADME.md?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -56,7 +56,6 @@ You can open any page of the documentation as a notebook in Colab (there is a bu\n | [How to fine-tune a model on summarization](https://github.com/huggingface/notebooks/blob/main/examples/summarization.ipynb)| Show how to preprocess the data and fine-tune a pretrained model on XSUM. | [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/summarization.ipynb)| [![Open in AWS Studio](https://studiolab.sagemaker.aws/studiolab.svg)](https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/main/examples/summarization.ipynb)|\n | [How to train a language model from scratch](https://github.com/huggingface/blog/blob/main/notebooks/01_how_to_train.ipynb)| Highlight all the steps to effectively train Transformer model on custom data | [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/huggingface/blog/blob/main/notebooks/01_how_to_train.ipynb)| [![Open in AWS Studio](https://studiolab.sagemaker.aws/studiolab.svg)](https://studiolab.sagemaker.aws/import/github/huggingface/blog/blob/main/notebooks/01_how_to_train.ipynb)|\n | [How to generate text](https://github.com/huggingface/blog/blob/main/notebooks/02_how_to_generate.ipynb)| How to use different decoding methods for language generation with transformers | [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/huggingface/blog/blob/main/notebooks/02_how_to_generate.ipynb)| [![Open in AWS Studio](https://studiolab.sagemaker.aws/studiolab.svg)](https://studiolab.sagemaker.aws/import/github/huggingface/blog/blob/main/notebooks/02_how_to_generate.ipynb)|\n-| [How to generate text (with constraints)](https://github.com/huggingface/blog/blob/main/notebooks/53_constrained_beam_search.ipynb)| How to guide language generation with user-provided constraints | [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/huggingface/blog/blob/main/notebooks/53_constrained_beam_search.ipynb)| [![Open in AWS Studio](https://studiolab.sagemaker.aws/studiolab.svg)](https://studiolab.sagemaker.aws/import/github/huggingface/blog/blob/main/notebooks/53_constrained_beam_search.ipynb)|\n | [Reformer](https://github.com/huggingface/blog/blob/main/notebooks/03_reformer.ipynb)| How Reformer pushes the limits of language modeling | [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/patrickvonplaten/blog/blob/main/notebooks/03_reformer.ipynb)| [![Open in AWS Studio](https://studiolab.sagemaker.aws/studiolab.svg)](https://studiolab.sagemaker.aws/import/github/patrickvonplaten/blog/blob/main/notebooks/03_reformer.ipynb)|\n \n #### Computer Vision[[pytorch-cv]]"
        },
        {
            "sha": "2a21cd3a620fcf1b58c4e078b33f575325acf70d",
            "filename": "src/transformers/generation/beam_constraints.py",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/src%2Ftransformers%2Fgeneration%2Fbeam_constraints.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/src%2Ftransformers%2Fgeneration%2Fbeam_constraints.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Fbeam_constraints.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -1,7 +1,13 @@\n from abc import ABC, abstractmethod\n from typing import Optional\n \n+from ..utils import logging\n \n+\n+logger = logging.get_logger(__name__)\n+\n+\n+# TODO joao, manuel: remove in v4.58.0\n class Constraint(ABC):\n     r\"\"\"Abstract base class for all constraints that can be applied during generation.\n     It must define how the constraint can be satisfied.\n@@ -18,6 +24,9 @@ class Constraint(ABC):\n     \"\"\"\n \n     def __init__(self):\n+        logger.warning_once(\n+            \"Importing `Constraint` classes is deprecated and will be removed in v4.58.0. Constrained beam search has been moved to the Hub: https://hf.co/transformers-community/constrained-beam-search. Please import using `from transformers.generation import Constraint` instead.\"\n+        )\n         # test for the above condition\n         self.test()\n "
        },
        {
            "sha": "ead906e603396b48d4f2ca39ab609a866bf4eaf8",
            "filename": "src/transformers/generation/beam_search.py",
            "status": "modified",
            "additions": 309,
            "deletions": 1,
            "changes": 310,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/src%2Ftransformers%2Fgeneration%2Fbeam_search.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/src%2Ftransformers%2Fgeneration%2Fbeam_search.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Fbeam_search.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -20,10 +20,13 @@\n import numpy as np\n import torch\n \n-from ..utils import add_start_docstrings\n+from ..utils import add_start_docstrings, logging\n from .beam_constraints import Constraint, ConstraintListState\n \n \n+logger = logging.get_logger(__name__)\n+\n+\n PROCESS_INPUTS_DOCSTRING = r\"\"\"\n     Args:\n         input_ids (`torch.LongTensor` of shape `(batch_size * num_beams, sequence_length)`):\n@@ -118,6 +121,305 @@ def finalize(\n         raise NotImplementedError(\"This is an abstract method.\")\n \n \n+class BeamSearchScorer(BeamScorer):\n+    r\"\"\"\n+    [`BeamScorer`] implementing standard beam search decoding.\n+\n+    Adapted in part from [Facebook's XLM beam search\n+    code](https://github.com/facebookresearch/XLM/blob/9e6f6814d17be4fe5b15f2e6c43eb2b2d76daeb4/src/model/transformer.py#L529).\n+\n+    Reference for the diverse beam search algorithm and implementation [Ashwin Kalyan's DBS\n+    implementation](https://github.com/ashwinkalyan/dbs/blob/master/dbs/beam_utils.lua)\n+\n+    Args:\n+        batch_size (`int`):\n+            Batch Size of `input_ids` for which standard beam search decoding is run in parallel.\n+        num_beams (`int`):\n+            Number of beams for beam search.\n+        device (`torch.device`):\n+            Defines the device type (*e.g.*, `\"cpu\"` or `\"cuda\"`) on which this instance of `BeamSearchScorer` will be\n+            allocated.\n+        length_penalty (`float`, *optional*, defaults to 1.0):\n+            Exponential penalty to the length that is used with beam-based generation. It is applied as an exponent to\n+            the sequence length, which in turn is used to divide the score of the sequence. Since the score is the log\n+            likelihood of the sequence (i.e. negative), `length_penalty` > 0.0 promotes longer sequences, while\n+            `length_penalty` < 0.0 encourages shorter sequences.\n+        do_early_stopping (`bool` or `str`, *optional*, defaults to `False`):\n+            Controls the stopping condition for beam-based methods, like beam-search. It accepts the following values:\n+            `True`, where the generation stops as soon as there are `num_beams` complete candidates; `False`, where an\n+            heuristic is applied and the generation stops when is it very unlikely to find better candidates;\n+            `\"never\"`, where the beam search procedure only stops when there cannot be better candidates (canonical\n+            beam search algorithm).\n+        num_beam_hyps_to_keep (`int`, *optional*, defaults to 1):\n+            The number of beam hypotheses that shall be returned upon calling\n+            [`~transformers.BeamSearchScorer.finalize`].\n+        num_beam_groups (`int`, *optional*, defaults to 1):\n+            Number of groups to divide `num_beams` into in order to ensure diversity among different groups of beams.\n+            See [this paper](https://huggingface.co/papers/1610.02424) for more details.\n+        max_length (`int`, *optional*):\n+            The maximum length of the sequence to be generated.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        batch_size: int,\n+        num_beams: int,\n+        device: torch.device,\n+        length_penalty: Optional[float] = 1.0,\n+        do_early_stopping: Optional[Union[bool, str]] = False,\n+        num_beam_hyps_to_keep: Optional[int] = 1,\n+        num_beam_groups: Optional[int] = 1,\n+        max_length: Optional[int] = None,\n+    ):\n+        logger.warning_once(\n+            \"`BeamSearchScorer` is deprecated and will be removed in v4.62.0, as constrained beam search has been moved to the Hub: https://hf.co/transformers-community/constrained-beam-search.\"\n+        )\n+        self.num_beams = num_beams\n+        self.device = device\n+        self.length_penalty = length_penalty\n+        self.do_early_stopping = do_early_stopping\n+        self.num_beam_hyps_to_keep = num_beam_hyps_to_keep\n+        self.num_beam_groups = num_beam_groups\n+        self.group_size = self.num_beams // self.num_beam_groups\n+\n+        self._is_init = False\n+        # self._beam_hyps[i*self.num_beam_groups+j] is the beam_hyps of the j-th group in the i-th mini-batch.\n+        # If group_beam_search is not used, the list consists of `batch_size` beam_hyps.\n+        self._beam_hyps = [\n+            BeamHypotheses(\n+                num_beams=self.group_size,\n+                length_penalty=self.length_penalty,\n+                early_stopping=self.do_early_stopping,\n+                max_length=max_length,\n+            )\n+            for _ in range(batch_size * self.num_beam_groups)\n+        ]\n+        # self._done[i*self.num_beam_groups+j] indicates whether the generation of the beam_hyps of the j-th group\n+        # in the i-th mini-batch is complete.\n+        self._done = torch.tensor(\n+            [False for _ in range(batch_size * self.num_beam_groups)], dtype=torch.bool, device=self.device\n+        )\n+\n+        if not isinstance(num_beams, int) or num_beams <= 1:\n+            raise ValueError(\n+                f\"`num_beams` has to be an integer strictly greater than 1, but is {num_beams}. For `num_beams` == 1,\"\n+                \" one should make use of `greedy_search` instead.\"\n+            )\n+\n+        if not isinstance(num_beam_groups, int) or (num_beam_groups > num_beams) or (num_beams % num_beam_groups != 0):\n+            raise ValueError(\n+                \"`num_beam_groups` has to be an integer smaller or equal than `num_beams` and `num_beams` has to be\"\n+                f\" divisible by `num_beam_groups`, but is {num_beam_groups} with `num_beams` being {num_beams}.\"\n+            )\n+\n+    @property\n+    def is_done(self) -> bool:\n+        return self._done.all()\n+\n+    def process(\n+        self,\n+        input_ids: torch.LongTensor,\n+        next_scores: torch.FloatTensor,\n+        next_tokens: torch.LongTensor,\n+        next_indices: torch.LongTensor,\n+        pad_token_id: Optional[Union[int, torch.Tensor]] = None,\n+        eos_token_id: Optional[Union[int, list[int], torch.Tensor]] = None,\n+        beam_indices: Optional[torch.LongTensor] = None,\n+        group_index: Optional[int] = 0,\n+        decoder_prompt_len: Optional[int] = 0,\n+    ) -> dict[str, torch.Tensor]:\n+        # add up to the length which the next_scores is calculated on (including decoder prompt)\n+        cur_len = input_ids.shape[-1] + 1\n+        batch_size = len(self._beam_hyps) // self.num_beam_groups\n+\n+        if batch_size != (input_ids.shape[0] // self.group_size):\n+            if self.num_beam_groups > 1:\n+                raise ValueError(\n+                    f\"A group beam size of {input_ids.shape[0]} is used as the input, but a group beam \"\n+                    f\"size of {self.group_size} is expected by the beam scorer.\"\n+                )\n+            else:\n+                raise ValueError(\n+                    f\"A beam size of {input_ids.shape[0]} is used as the input, but a beam size of \"\n+                    f\"{self.group_size} is expected by the beam scorer.\"\n+                )\n+\n+        device = input_ids.device\n+        next_beam_scores = torch.zeros((batch_size, self.group_size), dtype=next_scores.dtype, device=device)\n+        next_beam_tokens = torch.zeros((batch_size, self.group_size), dtype=next_tokens.dtype, device=device)\n+        next_beam_indices = torch.zeros((batch_size, self.group_size), dtype=next_indices.dtype, device=device)\n+\n+        if eos_token_id is not None and not isinstance(eos_token_id, torch.Tensor):\n+            if isinstance(eos_token_id, int):\n+                eos_token_id = [eos_token_id]\n+            eos_token_id = torch.tensor(eos_token_id)\n+\n+        for batch_idx in range(batch_size):\n+            batch_group_idx = batch_idx * self.num_beam_groups + group_index\n+            if self._done[batch_group_idx]:\n+                if self.num_beams < len(self._beam_hyps[batch_group_idx]):\n+                    raise ValueError(f\"Batch can only be done if at least {self.num_beams} beams have been generated\")\n+                if eos_token_id is None or pad_token_id is None:\n+                    raise ValueError(\"Generated beams >= num_beams -> eos_token_id and pad_token have to be defined\")\n+                # pad the batch\n+                next_beam_scores[batch_idx, :] = 0\n+                next_beam_tokens[batch_idx, :] = pad_token_id\n+                next_beam_indices[batch_idx, :] = 0\n+                continue\n+\n+            # next tokens for this sentence\n+            beam_idx = 0\n+            for beam_token_rank, (next_token, next_score, next_index) in enumerate(\n+                zip(next_tokens[batch_idx], next_scores[batch_idx], next_indices[batch_idx])\n+            ):\n+                batch_beam_idx = batch_idx * self.group_size + next_index\n+                # add to generated hypotheses if end of sentence\n+                if (eos_token_id is not None) and (next_token.item() in eos_token_id):\n+                    # if beam_token does not belong to top num_beams tokens, it should not be added\n+                    is_beam_token_worse_than_top_num_beams = beam_token_rank >= self.group_size\n+                    if is_beam_token_worse_than_top_num_beams:\n+                        continue\n+                    if beam_indices is not None:\n+                        beam_index = beam_indices[batch_beam_idx]\n+                        beam_index = beam_index + (batch_beam_idx,)\n+                    else:\n+                        beam_index = None\n+\n+                    self._beam_hyps[batch_group_idx].add(\n+                        input_ids[batch_beam_idx].clone(),\n+                        next_score.item(),\n+                        beam_indices=beam_index,\n+                        generated_len=cur_len - decoder_prompt_len,\n+                    )\n+                else:\n+                    # add next predicted token since it is not eos_token\n+                    next_beam_scores[batch_idx, beam_idx] = next_score\n+                    next_beam_tokens[batch_idx, beam_idx] = next_token\n+                    next_beam_indices[batch_idx, beam_idx] = batch_beam_idx\n+                    beam_idx += 1\n+\n+                # once the beam for next step is full, don't add more tokens to it.\n+                if beam_idx == self.group_size:\n+                    break\n+\n+            if beam_idx < self.group_size:\n+                raise ValueError(\n+                    f\"At most {self.group_size} tokens in {next_tokens[batch_idx]} can be equal to `eos_token_id:\"\n+                    f\" {eos_token_id}`. Make sure {next_tokens[batch_idx]} are corrected.\"\n+                )\n+\n+            # Check if we are done so that we can save a pad step if all(done)\n+            self._done[batch_group_idx] = self._done[batch_group_idx] or self._beam_hyps[batch_group_idx].is_done(\n+                next_scores[batch_idx].max().item(), cur_len, decoder_prompt_len\n+            )\n+\n+        return UserDict(\n+            {\n+                \"next_beam_scores\": next_beam_scores.view(-1),\n+                \"next_beam_tokens\": next_beam_tokens.view(-1),\n+                \"next_beam_indices\": next_beam_indices.view(-1),\n+            }\n+        )\n+\n+    def finalize(\n+        self,\n+        input_ids: torch.LongTensor,\n+        final_beam_scores: torch.FloatTensor,\n+        final_beam_tokens: torch.LongTensor,\n+        final_beam_indices: torch.LongTensor,\n+        max_length: int,\n+        pad_token_id: Optional[Union[int, torch.Tensor]] = None,\n+        eos_token_id: Optional[Union[int, list[int], torch.Tensor]] = None,\n+        beam_indices: Optional[torch.LongTensor] = None,\n+        decoder_prompt_len: Optional[int] = 0,\n+    ) -> tuple[torch.LongTensor]:\n+        batch_size = len(self._beam_hyps) // self.num_beam_groups\n+\n+        if eos_token_id is not None and not isinstance(eos_token_id, torch.Tensor):\n+            if isinstance(eos_token_id, int):\n+                eos_token_id = [eos_token_id]\n+            eos_token_id = torch.tensor(eos_token_id)\n+\n+        # finalize all open beam hypotheses and add to generated hypotheses\n+        for batch_group_idx, beam_hyp in enumerate(self._beam_hyps):\n+            if self._done[batch_group_idx]:\n+                continue\n+\n+            # all open beam hypotheses are added to the beam hypothesis\n+            # beam hypothesis class automatically keeps the best beams\n+            for index_per_group in range(self.group_size):\n+                batch_beam_idx = batch_group_idx * self.group_size + index_per_group\n+                final_score = final_beam_scores[batch_beam_idx].item()\n+                final_tokens = input_ids[batch_beam_idx]\n+                beam_index = beam_indices[batch_beam_idx] if beam_indices is not None else None\n+                generated_len = final_tokens.shape[-1] - decoder_prompt_len\n+                beam_hyp.add(final_tokens, final_score, beam_indices=beam_index, generated_len=generated_len)\n+\n+        # select the best hypotheses\n+        sent_lengths = input_ids.new(batch_size * self.num_beam_hyps_to_keep)\n+        best = []\n+        best_indices = []\n+        best_scores = torch.zeros(batch_size * self.num_beam_hyps_to_keep, device=self.device, dtype=torch.float32)\n+\n+        # retrieve best hypotheses\n+        for i in range(batch_size):\n+            beam_hyps_in_batch = self._beam_hyps[i * self.num_beam_groups : (i + 1) * self.num_beam_groups]\n+            candidate_beams = [beam for beam_hyp in beam_hyps_in_batch for beam in beam_hyp.beams]\n+            sorted_hyps = sorted(candidate_beams, key=lambda x: x[0])\n+            for j in range(self.num_beam_hyps_to_keep):\n+                best_hyp_tuple = sorted_hyps.pop()\n+                best_score = best_hyp_tuple[0]\n+                best_hyp = best_hyp_tuple[1]\n+                best_index = best_hyp_tuple[2]\n+                sent_lengths[self.num_beam_hyps_to_keep * i + j] = len(best_hyp)\n+\n+                # append hyp to lists\n+                best.append(best_hyp)\n+\n+                # append indices to list\n+                best_indices.append(best_index)\n+\n+                best_scores[i * self.num_beam_hyps_to_keep + j] = best_score\n+\n+        # prepare for adding eos\n+        sent_lengths_max = sent_lengths.max().item() + 1\n+        sent_max_len = min(sent_lengths_max, max_length) if max_length is not None else sent_lengths_max\n+        decoded: torch.LongTensor = input_ids.new(batch_size * self.num_beam_hyps_to_keep, sent_max_len)\n+\n+        if len(best_indices) > 0 and best_indices[0] is not None:\n+            indices: torch.LongTensor = input_ids.new(batch_size * self.num_beam_hyps_to_keep, sent_max_len)\n+        else:\n+            indices = None\n+\n+        # shorter batches are padded if needed\n+        if sent_lengths.min().item() != sent_lengths.max().item():\n+            if pad_token_id is None:\n+                raise ValueError(\"`pad_token_id` has to be defined\")\n+            decoded.fill_(pad_token_id)\n+\n+        if indices is not None:\n+            indices.fill_(-1)\n+\n+        # fill with hypotheses and eos_token_id if the latter fits in\n+        for i, (hypo, best_idx) in enumerate(zip(best, best_indices)):\n+            decoded[i, : sent_lengths[i]] = hypo\n+\n+            if indices is not None:\n+                indices[i, : len(best_idx)] = torch.tensor(best_idx)\n+\n+            if sent_lengths[i] < sent_max_len:\n+                # inserting only the first eos_token_id\n+                decoded[i, sent_lengths[i]] = eos_token_id[0]\n+\n+        return UserDict(\n+            {\n+                \"sequences\": decoded,\n+                \"sequence_scores\": best_scores,\n+                \"beam_indices\": indices,\n+            }\n+        )\n+\n+\n class ConstrainedBeamSearchScorer(BeamScorer):\n     r\"\"\"\n     [`BeamScorer`] implementing constrained beam search decoding.\n@@ -163,6 +465,9 @@ def __init__(\n         num_beam_hyps_to_keep: Optional[int] = 1,\n         max_length: Optional[int] = None,\n     ):\n+        logger.warning_once(\n+            \"`ConstrainedBeamSearchScorer` is deprecated and will be removed in v4.62.0, as constrained beam search has been moved to the Hub: https://hf.co/transformers-community/constrained-beam-search.\"\n+        )\n         self.num_beams = num_beams\n         self.device = device\n         self.length_penalty = length_penalty\n@@ -611,6 +916,9 @@ def __init__(self, num_beams: int, length_penalty: float, early_stopping: bool,\n         \"\"\"\n         Initialize n-best list of hypotheses.\n         \"\"\"\n+        logger.warning_once(\n+            \"`BeamHypotheses` is deprecated and will be removed in v4.62.0, as constrained beam search has been moved to the Hub: https://hf.co/transformers-community/constrained-beam-search.\"\n+        )\n         self.length_penalty = length_penalty\n         self.early_stopping = early_stopping\n         self.max_length = max_length"
        },
        {
            "sha": "2b9d25381f26b20f6a26e339153e56d1c7cd3ca5",
            "filename": "src/transformers/generation/configuration_utils.py",
            "status": "modified",
            "additions": 2,
            "deletions": 29,
            "changes": 31,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/src%2Ftransformers%2Fgeneration%2Fconfiguration_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/src%2Ftransformers%2Fgeneration%2Fconfiguration_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Fconfiguration_utils.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -89,7 +89,6 @@ class GenerationConfig(PushToHubMixin):\n         - *multinomial sampling* if `num_beams=1` and `do_sample=True`\n         - *beam-search decoding* if `num_beams>1` and `do_sample=False`\n         - *beam-search multinomial sampling* if `num_beams>1` and `do_sample=True`\n-        - *constrained beam-search decoding* if `constraints!=None` or `force_words_ids!=None`\n         - *assisted decoding* if `assistant_model` or `prompt_lookup_num_tokens` is passed to `.generate()`\n \n     To learn more about decoding strategies refer to the [text generation strategies guide](../generation_strategies).\n@@ -202,18 +201,10 @@ class GenerationConfig(PushToHubMixin):\n         bad_words_ids (`list[list[int]]`, *optional*):\n             List of list of token ids that are not allowed to be generated. Check\n             [`~generation.NoBadWordsLogitsProcessor`] for further documentation and examples.\n-        force_words_ids (`list[list[int]]` or `list[list[list[int]]]`, *optional*):\n-            List of token ids that must be generated. If given a `list[list[int]]`, this is treated as a simple list of\n-            words that must be included, the opposite to `bad_words_ids`. If given `list[list[list[int]]]`, this\n-            triggers a [disjunctive constraint](https://github.com/huggingface/transformers/issues/14081), where one\n-            can allow different forms of each word.\n         renormalize_logits (`bool`, *optional*, defaults to `False`):\n             Whether to renormalize the logits after applying all the logits processors (including the custom\n             ones). It's highly recommended to set this flag to `True` as the search algorithms suppose the score logits\n             are normalized but some logit processors break the normalization.\n-        constraints (`list[Constraint]`, *optional*):\n-            Custom constraints that can be added to the generation to ensure that the output will contain the use of\n-            certain tokens as defined by `Constraint` objects, in the most sensible way possible.\n         forced_bos_token_id (`int`, *optional*, defaults to `model.config.forced_bos_token_id`):\n             The id of the token to force as the first generated token after the `decoder_start_token_id`. Useful for\n             multilingual models like [mBART](../model_doc/mbart) where the first generated token needs to be the target\n@@ -374,9 +365,7 @@ def __init__(self, **kwargs):\n         self.length_penalty = kwargs.pop(\"length_penalty\", 1.0)\n         self.no_repeat_ngram_size = kwargs.pop(\"no_repeat_ngram_size\", 0)\n         self.bad_words_ids = kwargs.pop(\"bad_words_ids\", None)\n-        self.force_words_ids = kwargs.pop(\"force_words_ids\", None)\n         self.renormalize_logits = kwargs.pop(\"renormalize_logits\", False)\n-        self.constraints = kwargs.pop(\"constraints\", None)\n         self.forced_bos_token_id = kwargs.pop(\"forced_bos_token_id\", None)\n         self.forced_eos_token_id = kwargs.pop(\"forced_eos_token_id\", None)\n         self.remove_invalid_values = kwargs.pop(\"remove_invalid_values\", False)\n@@ -434,6 +423,8 @@ def __init__(self, **kwargs):\n         self.dola_layers = kwargs.pop(\"dola_layers\", None)\n         self.diversity_penalty = kwargs.pop(\"diversity_penalty\", 0.0)\n         self.num_beam_groups = kwargs.pop(\"num_beam_groups\", 1)\n+        self.constraints = kwargs.pop(\"constraints\", None)\n+        self.force_words_ids = kwargs.pop(\"force_words_ids\", None)\n \n         # The remaining attributes do not parametrize `.generate()`, but are informative and/or used by the hub\n         # interface.\n@@ -625,24 +616,6 @@ def validate(self, strict=False):\n                 minor_issues[\"length_penalty\"] = single_beam_wrong_parameter_msg.format(\n                     flag_name=\"length_penalty\", flag_value=self.length_penalty\n                 )\n-            if self.constraints is not None:\n-                minor_issues[\"constraints\"] = single_beam_wrong_parameter_msg.format(\n-                    flag_name=\"constraints\", flag_value=self.constraints\n-                )\n-\n-        # 2.3. detect incorrect parameterization specific to advanced beam modes\n-        else:\n-            # constrained beam search\n-            if self.constraints is not None or self.force_words_ids is not None:\n-                constrained_wrong_parameter_msg = (\n-                    \"one of `constraints`, `force_words_ids` is not `None`, triggering constrained beam search. \"\n-                    \"However, `{flag_name}` is set to `{flag_value}`, which is incompatible with this generation \"\n-                    \"mode. Set `constraints` and `force_words_ids` to `None` or unset `{flag_name}` to continue.\"\n-                )\n-                if self.do_sample is True:\n-                    raise ValueError(\n-                        constrained_wrong_parameter_msg.format(flag_name=\"do_sample\", flag_value=self.do_sample)\n-                    )\n \n         # 2.4. check `num_return_sequences`\n         if self.num_return_sequences != 1:"
        },
        {
            "sha": "f63d2246c6a98b5f3b26ffe3f595d2cc007d3e31",
            "filename": "src/transformers/generation/logits_process.py",
            "status": "modified",
            "additions": 127,
            "deletions": 0,
            "changes": 127,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/src%2Ftransformers%2Fgeneration%2Flogits_process.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/src%2Ftransformers%2Fgeneration%2Flogits_process.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Flogits_process.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -1441,6 +1441,133 @@ def __call__(self, input_ids: torch.LongTensor, scores: torch.FloatTensor) -> to\n         return scores_processed\n \n \n+class HammingDiversityLogitsProcessor(LogitsProcessor):\n+    r\"\"\"\n+    [`LogitsProcessor`] that enforces diverse beam search.\n+    Note that this logits processor is only effective for [`PreTrainedModel.group_beam_search`]. See [Diverse Beam\n+    Search: Decoding Diverse Solutions from Neural Sequence Models](https://huggingface.co/papers/1610.02424) for more\n+    details.\n+    Traditional beam search often generates very similar sequences across different beams.\n+    `HammingDiversityLogitsProcessor` addresses this by penalizing beams that generate tokens already chosen by other\n+    beams in the same time step.\n+    Args:\n+        diversity_penalty (`float`):\n+            This value is subtracted from a beam's score if it generates a token same as any beam from other group at a\n+            particular time. A higher `diversity_penalty` will enforce greater diversity among the beams. Adjusting\n+            this value can help strike a balance between diversity and natural likelihood.\n+        num_beams (`int`):\n+            Number of beams for beam search. 1 means no beam search.\n+        num_beam_groups (`int`):\n+            Number of groups to divide `num_beams` into in order to ensure diversity among different groups of beams.\n+            [this paper](https://huggingface.co/papers/1610.02424) for more details.\n+    Examples:\n+    ```python\n+    >>> from transformers import AutoTokenizer, AutoModelForSeq2SeqLM\n+    >>> import torch\n+    >>> # Initialize the model and tokenizer\n+    >>> tokenizer = AutoTokenizer.from_pretrained(\"google-t5/t5-base\")\n+    >>> model = AutoModelForSeq2SeqLM.from_pretrained(\"google-t5/t5-base\")\n+    >>> # A long text about the solar system\n+    >>> text = (\n+    ...     \"The Solar System is a gravitationally bound system comprising the Sun and the objects that orbit it, \"\n+    ...     \"either directly or indirectly. Of the objects that orbit the Sun directly, the largest are the eight \"\n+    ...     \"planets, with the remainder being smaller objects, such as the five dwarf planets and small Solar System \"\n+    ...     \"bodies. The Solar System formed 4.6 billion years ago from the gravitational collapse of a giant \"\n+    ...     \"interstellar molecular cloud.\"\n+    ... )\n+    >>> inputs = tokenizer(\"summarize: \" + text, return_tensors=\"pt\")\n+    >>> # Generate diverse summary\n+    >>> outputs_diverse = model.generate(\n+    ...     **inputs,\n+    ...     num_beam_groups=2,\n+    ...     diversity_penalty=10.0,\n+    ...     max_length=100,\n+    ...     num_beams=4,\n+    ...     num_return_sequences=2,\n+    ... )\n+    >>> summaries_diverse = tokenizer.batch_decode(outputs_diverse, skip_special_tokens=True)\n+    >>> # Generate non-diverse summary\n+    >>> outputs_non_diverse = model.generate(\n+    ...     **inputs,\n+    ...     max_length=100,\n+    ...     num_beams=4,\n+    ...     num_return_sequences=2,\n+    ... )\n+    >>> summary_non_diverse = tokenizer.batch_decode(outputs_non_diverse, skip_special_tokens=True)\n+    >>> # With `diversity_penalty`, the resulting beams are much more diverse\n+    >>> print(summary_non_diverse)\n+    ['the solar system formed 4.6 billion years ago from the collapse of a giant interstellar molecular cloud. of the objects that orbit the Sun directly, the largest are the eight planets.',\n+    'the Solar System formed 4.6 billion years ago from the collapse of a giant interstellar molecular cloud. of the objects that orbit the Sun directly, the largest are the eight planets.']\n+    >>> print(summaries_diverse)\n+    ['the solar system formed 4.6 billion years ago from the collapse of a giant interstellar molecular cloud. of the objects that orbit the Sun directly, the largest are the eight planets.',\n+    'the solar system formed 4.6 billion years ago from the collapse of a giant interstellar molecular cloud. of the objects that orbit the Sun directly, the largest are the eight planets. the rest of the objects are smaller objects, such as the five dwarf planets and small solar system bodies.']\n+    ```\n+    \"\"\"\n+\n+    def __init__(self, diversity_penalty: float, num_beams: int, num_beam_groups: int):\n+        logger.warning_once(\n+            \"`HammingDiversityLogitsProcessor` is deprecated and will be removed in v4.62.0, as constrained beam search has been moved to the Hub: https://hf.co/transformers-community/constrained-beam-search.\"\n+        )\n+        if not isinstance(diversity_penalty, float) or (not diversity_penalty > 0.0):\n+            raise ValueError(\"`diversity_penalty` should be a float strictly larger than 0.\")\n+        self._diversity_penalty = diversity_penalty\n+        if not isinstance(num_beams, int) or num_beams < 2:\n+            raise ValueError(\"`num_beams` should be an integer strictly larger than 1.\")\n+        self._num_beams = num_beams\n+        if not isinstance(num_beam_groups, int) or num_beam_groups < 2:\n+            raise ValueError(\"`num_beam_groups` should be an integer strictly larger than 1.\")\n+        if num_beam_groups > num_beams:\n+            raise ValueError(\"`beam_groups` has to be smaller or equal to `num_beams`.\")\n+        self._num_sub_beams = num_beams // num_beam_groups\n+\n+    def __call__(\n+        self,\n+        input_ids: torch.LongTensor,\n+        scores: torch.FloatTensor,\n+        current_tokens: torch.LongTensor,\n+        beam_group_idx: int,\n+    ) -> torch.FloatTensor:\n+        r\"\"\"\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary. [What are input IDs?](../glossary#input-ids)\n+            scores (`torch.FloatTensor` of shape `(batch_size, config.vocab_size)`):\n+                Prediction scores of a language modeling head. These can be logits for each vocabulary when not using\n+                beam search or log softmax for each vocabulary token when using beam search\n+            current_tokens (`torch.LongTensor` of shape `(batch_size)`):\n+                Indices of input sequence tokens in the vocabulary, corresponding to the tokens selected by the other\n+                beam groups in the current generation step.\n+            beam_group_idx (`int`):\n+                The index of the beam group currently being processed.\n+        Return:\n+            `torch.FloatTensor` of shape `(batch_size, config.vocab_size)`:\n+                The processed prediction scores.\n+        \"\"\"\n+        # hamming diversity: penalise using same token in current group which was used in previous groups at\n+        # the same time step\n+        batch_size = current_tokens.shape[0] // self._num_beams\n+        group_start_idx = beam_group_idx * self._num_sub_beams\n+        group_end_idx = min(group_start_idx + self._num_sub_beams, self._num_beams)\n+        group_size = group_end_idx - group_start_idx\n+        vocab_size = scores.shape[-1]\n+\n+        if group_start_idx == 0:\n+            return scores\n+\n+        scores_processed = scores.clone()\n+        for batch_idx in range(batch_size):\n+            # predicted tokens of last time step of previous groups\n+            previous_group_tokens = current_tokens[\n+                batch_idx * self._num_beams : batch_idx * self._num_beams + group_start_idx\n+            ]\n+            token_frequency = torch.bincount(previous_group_tokens, minlength=vocab_size).to(scores.device)\n+            scores_processed[batch_idx * group_size : (batch_idx + 1) * group_size] -= (\n+                self._diversity_penalty * token_frequency\n+            )\n+\n+        return scores_processed\n+\n+\n class ForcedBOSTokenLogitsProcessor(LogitsProcessor):\n     r\"\"\"\n     [`LogitsProcessor`] that enforces the specified token as the first generated token. Used with encoder-decoder"
        },
        {
            "sha": "f118cf5276b08cbac3b2cc71029efe767709bbdd",
            "filename": "src/transformers/generation/utils.py",
            "status": "modified",
            "additions": 61,
            "deletions": 421,
            "changes": 482,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/src%2Ftransformers%2Fgeneration%2Futils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/src%2Ftransformers%2Fgeneration%2Futils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Futils.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -33,7 +33,6 @@\n     QuantizedCache,\n     StaticCache,\n )\n-from ..configuration_utils import PretrainedConfig\n from ..dynamic_module_utils import (\n     check_python_requirements,\n     get_cached_module_file,\n@@ -53,8 +52,6 @@\n     is_torchdynamo_exporting,\n     logging,\n )\n-from .beam_constraints import DisjunctiveConstraint, PhrasalConstraint\n-from .beam_search import ConstrainedBeamSearchScorer\n from .candidate_generator import (\n     AssistantVocabTranslatorCache,\n     AssistedCandidateGenerator,\n@@ -370,7 +367,6 @@ class GenerationMixin(ContinuousMixin):\n         - *multinomial sampling* if `num_beams=1` and `do_sample=True`\n         - *beam-search decoding* if `num_beams>1` and `do_sample=False`\n         - *beam-search multinomial sampling* if `num_beams>1` and `do_sample=True`\n-        - *constrained beam-search decoding* if `constraints!=None` or `force_words_ids!=None`\n         - *assisted decoding* if `assistant_model` or `prompt_lookup_num_tokens` is passed to `.generate()`\n \n     To learn more about decoding strategies refer to the [text generation strategies guide](../generation_strategies).\n@@ -2127,6 +2123,39 @@ def _valid_auto_compile_criteria(self, model_kwargs: dict, generation_config: Ge\n \n         return can_compile\n \n+    def _get_deprecated_gen_repo(\n+        self,\n+        generation_config: GenerationConfig,\n+        trust_remote_code: bool,\n+        custom_generate: Optional[str] = None,\n+        assistant_model: Optional[\"PreTrainedModel\"] = None,\n+    ) -> Optional[str]:\n+        \"\"\"\n+        Returns the Hub repo for a deprecated generation strategy, if any.\n+        \"\"\"\n+        generation_mode = generation_config.get_generation_mode(assistant_model)\n+        moved_to_hub_modes = {\n+            GenerationMode.DOLA_GENERATION: \"transformers-community/dola\",\n+            GenerationMode.CONTRASTIVE_SEARCH: \"transformers-community/contrastive-search\",\n+            GenerationMode.GROUP_BEAM_SEARCH: \"transformers-community/group-beam-search\",\n+            GenerationMode.CONSTRAINED_BEAM_SEARCH: \"transformers-community/constrained-beam-search\",\n+        }\n+        if custom_generate is not None or generation_mode not in moved_to_hub_modes:\n+            return None\n+\n+        repo = moved_to_hub_modes[generation_mode]\n+        logger.warning_once(\n+            f\"{generation_mode.name.replace('_', ' ').title()} was moved to a `custom_generate` repo: https://hf.co/{repo}. \"\n+            f\"To prevent loss of backward compatibility, add `custom_generate='{repo}'` \"\n+            \"to your `generate` call before v4.62.0.\"\n+        )\n+        if not trust_remote_code:\n+            raise ValueError(\n+                f\"{generation_mode.name.replace('_', ' ').title()} requires `trust_remote_code=True` in your `generate` call, \"\n+                f\"since it loads https://hf.co/{repo}.\"\n+            )\n+        return repo\n+\n     @torch.no_grad()\n     def generate(\n         self,\n@@ -2243,6 +2272,7 @@ def generate(\n         \"\"\"\n         # 0. If requested, load an arbitrary generation recipe from the Hub and run it instead\n         trust_remote_code = kwargs.pop(\"trust_remote_code\", None)\n+\n         if custom_generate is not None and isinstance(custom_generate, str):\n             # Get all `generate` arguments in a single variable. Custom functions are responsible for handling them:\n             # they receive the same inputs as `generate`, with `model` instead of `self` and excluding the arguments to\n@@ -2272,6 +2302,33 @@ def generate(\n         self._validate_model_kwargs(model_kwargs.copy())\n         self._validate_assistant(assistant_model, tokenizer, assistant_tokenizer)\n \n+        # Deprecation-related step: set Hub repo for deprecated strategies.\n+        # NOTE: This must come after initializing generation_config, since we need it to determine if this is a deprecated mode.\n+        # It must also be before any preparation steps, since Hub repos expect to be loaded before preparation steps.\n+        # TODO joao, manuel: remove this in v4.62.0\n+        if deprecate_mode_repo := self._get_deprecated_gen_repo(\n+            generation_config, trust_remote_code, custom_generate, assistant_model\n+        ):\n+            return GenerationMixin.generate(\n+                self,\n+                inputs,\n+                generation_config,\n+                logits_processor,\n+                stopping_criteria,\n+                prefix_allowed_tokens_fn,\n+                synced_gpus,\n+                assistant_model,\n+                streamer,\n+                negative_prompt_ids,\n+                negative_prompt_attention_mask,\n+                use_model_defaults,\n+                custom_generate=deprecate_mode_repo,\n+                trust_remote_code=trust_remote_code,\n+                tokenizer=tokenizer,\n+                assistant_tokenizer=assistant_tokenizer,\n+                **kwargs,\n+            )\n+\n         # 2. Set generation parameters if not already defined\n         if synced_gpus is None:\n             synced_gpus = (is_deepspeed_zero3_enabled() or is_fsdp_managed_module(self)) and dist.get_world_size() > 1\n@@ -2482,47 +2539,6 @@ def generate(\n                 streamer=streamer,\n                 **model_kwargs,\n             )\n-        # TODO joao, manuel: remove this in v4.62.0\n-        elif generation_mode == GenerationMode.DOLA_GENERATION:\n-            logger.warning_once(\n-                \"DoLa generation was moved to a `custom_generate` repo: https://hf.co/transformers-community/dola. \"\n-                \"To prevent loss of backward compatibility, add `custom_generate='transformers-community/dola'` \"\n-                \"to your `generate` call before v4.62.0.\"\n-            )\n-            if not trust_remote_code:\n-                raise ValueError(\n-                    \"DoLa generation requires `trust_remote_code=True` in your `generate` call, since \"\n-                    \"it loads https://hf.co/transformers-community/dola.\"\n-                )\n-            return GenerationMixin.generate(\n-                self,\n-                inputs,\n-                custom_generate=\"transformers-community/dola\",\n-                generation_config=generation_config,\n-                trust_remote_code=trust_remote_code,\n-                **kwargs,\n-            )\n-        # TODO joao, manuel: remove this in v4.62.0\n-        elif generation_mode == GenerationMode.CONTRASTIVE_SEARCH:\n-            logger.warning_once(\n-                \"Contrastive search was moved to a `custom_generate` repo: https://hf.co/transformers-community/contrastive-search. \"\n-                \"To prevent loss of backward compatibility, add `custom_generate='transformers-community/contrastive-search'` \"\n-                \"to your `generate` call before v4.62.0.\"\n-            )\n-            if not trust_remote_code:\n-                logger.warning_once(\n-                    \"Contrastive search requires `trust_remote_code=True` in your `generate` call, since \"\n-                    \"it loads https://hf.co/transformers-community/contrastive-search.\"\n-                )\n-            # Avoid calling the model-defined `generate` method, since some models (e.g. Janus, Whisper) override it.\n-            return GenerationMixin.generate(\n-                self,\n-                inputs,\n-                custom_generate=\"transformers-community/contrastive-search\",\n-                generation_config=generation_config,\n-                trust_remote_code=trust_remote_code,\n-                **kwargs,\n-            )\n \n         elif generation_mode in (GenerationMode.SAMPLE, GenerationMode.GREEDY_SEARCH):\n             # 11. run sample (it degenerates to greedy search when `generation_config.do_sample=False`)\n@@ -2547,93 +2563,6 @@ def generate(\n                 **model_kwargs,\n             )\n \n-        elif generation_mode == GenerationMode.GROUP_BEAM_SEARCH:\n-            logger.warning_once(\n-                \"Group Beam Search was moved to a `custom_generate` repo: https://hf.co/transformers-community/group-beam-search. \"\n-                \"To prevent loss of backward compatibility, add `custom_generate='transformers-community/group-beam-search'` \"\n-                \"to your `generate` call before v4.62.0.\"\n-            )\n-            if not trust_remote_code:\n-                raise ValueError(\n-                    \"Group Beam Search requires `trust_remote_code=True` in your `generate` call, since \"\n-                    \"it loads https://hf.co/transformers-community/group-beam-search.\"\n-                )\n-            return GenerationMixin.generate(\n-                self,\n-                inputs,\n-                custom_generate=\"transformers-community/group-beam-search\",\n-                generation_config=generation_config,\n-                trust_remote_code=trust_remote_code,\n-                **kwargs,\n-            )\n-\n-        elif generation_mode == GenerationMode.CONSTRAINED_BEAM_SEARCH:\n-            logger.warning_once(\n-                \"Constrained Beam Search is scheduled to be moved to a `custom_generate` repository in v4.55.0. \"\n-                \"To prevent loss of backward compatibility, add `trust_remote_code=True` to your `generate` call.\"\n-            )\n-            final_constraints = []\n-            if generation_config.constraints is not None:\n-                final_constraints = generation_config.constraints\n-\n-            if generation_config.force_words_ids is not None:\n-\n-                def typeerror():\n-                    raise ValueError(\n-                        \"`force_words_ids` has to either be a `list[list[list[int]]]` or `list[list[int]]` \"\n-                        f\"of positive integers, but is {generation_config.force_words_ids}.\"\n-                    )\n-\n-                if (\n-                    not isinstance(generation_config.force_words_ids, list)\n-                    or len(generation_config.force_words_ids) == 0\n-                ):\n-                    typeerror()\n-\n-                for word_ids in generation_config.force_words_ids:\n-                    if isinstance(word_ids[0], list):\n-                        if not isinstance(word_ids, list) or len(word_ids) == 0:\n-                            typeerror()\n-                        if any(not isinstance(token_ids, list) for token_ids in word_ids):\n-                            typeerror()\n-                        if any(\n-                            any((not isinstance(token_id, int) or token_id < 0) for token_id in token_ids)\n-                            for token_ids in word_ids\n-                        ):\n-                            typeerror()\n-\n-                        constraint = DisjunctiveConstraint(word_ids)\n-                    else:\n-                        if not isinstance(word_ids, list) or len(word_ids) == 0:\n-                            typeerror()\n-                        if any((not isinstance(token_id, int) or token_id < 0) for token_id in word_ids):\n-                            typeerror()\n-\n-                        constraint = PhrasalConstraint(word_ids)\n-                    final_constraints.append(constraint)\n-\n-            # 11. prepare beam search scorer\n-            constrained_beam_scorer = ConstrainedBeamSearchScorer(\n-                constraints=final_constraints,\n-                batch_size=batch_size,\n-                num_beams=generation_config.num_beams,\n-                device=inputs_tensor.device,\n-                length_penalty=generation_config.length_penalty,\n-                do_early_stopping=generation_config.early_stopping,\n-                num_beam_hyps_to_keep=generation_config.num_return_sequences,\n-                max_length=generation_config.max_length,\n-            )\n-            # 12. run beam search\n-            result = self._constrained_beam_search(\n-                input_ids,\n-                constrained_beam_scorer=constrained_beam_scorer,\n-                logits_processor=prepared_logits_processor,\n-                stopping_criteria=prepared_stopping_criteria,\n-                generation_config=generation_config,\n-                synced_gpus=synced_gpus,\n-                **model_kwargs,\n-            )\n-\n         # Convert to legacy cache format if requested\n         if (\n             generation_config.return_legacy_cache is True\n@@ -3511,246 +3440,6 @@ def _beam_search(\n         else:\n             return sequences\n \n-    def _constrained_beam_search(\n-        self,\n-        input_ids: torch.LongTensor,\n-        constrained_beam_scorer: ConstrainedBeamSearchScorer,\n-        logits_processor: LogitsProcessorList,\n-        stopping_criteria: StoppingCriteriaList,\n-        generation_config: GenerationConfig,\n-        synced_gpus: bool,\n-        **model_kwargs,\n-    ) -> Union[GenerateBeamOutput, torch.LongTensor]:\n-        r\"\"\"\n-        Generates sequences of token ids for models with a language modeling head using **constrained beam search\n-        decoding** and can be used for text-decoder, text-to-text, speech-to-text, and vision-to-text models.\n-\n-        Parameters:\n-            input_ids (`torch.LongTensor` of shape `(batch_size*num_beams, sequence_length)`):\n-                The sequence used as a prompt for the generation.\n-            constrained_beam_scorer (`ConstrainedBeamSearchScorer`):\n-                A derived instance of [`BeamScorer`] that defines how beam hypotheses are constructed, stored and\n-                sorted during generation, while satisfying a list of positive constraints. For more information, the\n-                documentation of [`ConstrainedBeamSearchScorer`] should be read.\n-            logits_processor (`LogitsProcessorList`):\n-                An instance of [`LogitsProcessorList`]. List of instances of class derived from [`LogitsProcessor`]\n-                used to modify the prediction scores of the language modeling head applied at each generation step.\n-            stopping_criteria (`StoppingCriteriaList`):\n-                An instance of [`StoppingCriteriaList`]. List of instances of class derived from [`StoppingCriteria`]\n-                used to tell if the generation loop should stop.\n-            generation_config ([`~generation.GenerationConfig`]):\n-                The generation configuration to be used as parametrization of the decoding method.\n-            synced_gpus (`bool`):\n-                Whether to continue running the while loop until max_length (needed to avoid deadlocking with\n-                `FullyShardedDataParallel` and DeepSpeed ZeRO Stage 3).\n-            model_kwargs:\n-                Additional model specific kwargs will be forwarded to the `forward` function of the model. If model is\n-                an encoder-decoder model the kwargs should include `encoder_outputs`.\n-\n-        Return:\n-            [`~generation.GenerateBeamDecoderOnlyOutput`], [`~generation.GenerateBeamEncoderDecoderOutput`] or\n-            `torch.LongTensor`: A `torch.LongTensor` containing the generated tokens (default behaviour) or a\n-            [`~generation.GenerateBeamDecoderOnlyOutput`] if `model.config.is_encoder_decoder=False` and\n-            `return_dict_in_generate=True` or a [`~generation.GenerateBeamEncoderDecoderOutput`] if\n-            `model.config.is_encoder_decoder=True`.\n-        \"\"\"\n-        # init values\n-        pad_token_id = generation_config._pad_token_tensor\n-        eos_token_id = generation_config._eos_token_tensor\n-        output_attentions = generation_config.output_attentions\n-        output_hidden_states = generation_config.output_hidden_states\n-        output_scores = generation_config.output_scores\n-        output_logits = generation_config.output_logits\n-        return_dict_in_generate = generation_config.return_dict_in_generate\n-\n-        batch_size = len(constrained_beam_scorer._beam_hyps)\n-        num_beams = constrained_beam_scorer.num_beams\n-\n-        batch_beam_size, cur_len = input_ids.shape[:2]\n-        model_kwargs = self._get_initial_cache_position(cur_len, input_ids.device, model_kwargs)\n-\n-        if num_beams * batch_size != batch_beam_size:\n-            raise ValueError(\n-                f\"Batch dimension of `input_ids` should be {num_beams * batch_size}, but is {batch_beam_size}.\"\n-            )\n-\n-        # init attention / hidden states / scores tuples\n-        scores = () if (return_dict_in_generate and output_scores) else None\n-        raw_logits = () if (return_dict_in_generate and output_logits) else None\n-        beam_indices = (\n-            tuple(() for _ in range(batch_beam_size)) if (return_dict_in_generate and output_scores) else None\n-        )\n-        decoder_attentions = () if (return_dict_in_generate and output_attentions) else None\n-        cross_attentions = () if (return_dict_in_generate and output_attentions) else None\n-        decoder_hidden_states = () if (return_dict_in_generate and output_hidden_states) else None\n-\n-        # if model is an encoder-decoder, retrieve encoder attention weights and hidden states\n-        if return_dict_in_generate and self.config.is_encoder_decoder:\n-            encoder_attentions = model_kwargs[\"encoder_outputs\"].get(\"attentions\") if output_attentions else None\n-            encoder_hidden_states = (\n-                model_kwargs[\"encoder_outputs\"].get(\"hidden_states\") if output_hidden_states else None\n-            )\n-\n-        # initialise score of first beam with 0 and the rest with -1e9. This makes sure that only tokens\n-        # of the first beam are considered to avoid sampling the exact same tokens across all beams.\n-        beam_scores = torch.zeros((batch_size, num_beams), dtype=torch.float, device=input_ids.device)\n-        beam_scores[:, 1:] = -1e9\n-        beam_scores = beam_scores.view((batch_size * num_beams,))\n-\n-        this_peer_finished = False\n-\n-        decoder_prompt_len = input_ids.shape[1]  # record the prompt length of decoder\n-        while self._has_unfinished_sequences(this_peer_finished, synced_gpus, device=input_ids.device):\n-            model_inputs = self.prepare_inputs_for_generation(input_ids, **model_kwargs)\n-\n-            # prepare variable output controls (note: some models won't accept all output controls)\n-            model_inputs.update({\"output_attentions\": output_attentions} if output_attentions else {})\n-            model_inputs.update({\"output_hidden_states\": output_hidden_states} if output_hidden_states else {})\n-\n-            outputs = self(**model_inputs, return_dict=True)\n-\n-            # synced_gpus: don't waste resources running the code we don't need; kwargs must be updated before skipping\n-            model_kwargs = self._update_model_kwargs_for_generation(\n-                outputs,\n-                model_kwargs,\n-                is_encoder_decoder=self.config.is_encoder_decoder,\n-            )\n-            if synced_gpus and this_peer_finished:\n-                cur_len = cur_len + 1\n-                continue\n-\n-            # Copy is needed to avoid keeping a hanging ref to outputs.logits which may be very large for first iteration\n-            # (the clone itself is always small)\n-            # .float() is needed to retain precision for later logits manipulations\n-            next_token_logits = outputs.logits[:, -1, :].to(copy=True, dtype=torch.float32, device=input_ids.device)\n-            next_token_scores = nn.functional.log_softmax(\n-                next_token_logits, dim=-1\n-            )  # (batch_size * num_beams, vocab_size)\n-\n-            next_token_scores_processed = logits_processor(input_ids, next_token_scores)\n-\n-            next_token_scores = next_token_scores_processed + beam_scores[:, None].expand_as(\n-                next_token_scores_processed\n-            )\n-\n-            scores_for_all_vocab = next_token_scores.clone()\n-\n-            # Store scores, attentions and hidden_states when required\n-            if return_dict_in_generate:\n-                if output_scores:\n-                    scores += (next_token_scores,)\n-                if output_logits:\n-                    raw_logits += (next_token_logits,)\n-                if output_attentions:\n-                    decoder_attentions += (\n-                        (outputs.decoder_attentions,) if self.config.is_encoder_decoder else (outputs.attentions,)\n-                    )\n-                    if self.config.is_encoder_decoder:\n-                        cross_attentions += (outputs.cross_attentions,)\n-\n-                if output_hidden_states:\n-                    decoder_hidden_states += (\n-                        (outputs.decoder_hidden_states,)\n-                        if self.config.is_encoder_decoder\n-                        else (outputs.hidden_states,)\n-                    )\n-\n-            # reshape for beam search\n-            vocab_size = next_token_scores.shape[-1]\n-            next_token_scores = next_token_scores.view(batch_size, num_beams * vocab_size)\n-\n-            # Sample 1 + len(eos_token_id) next tokens for each beam so we have at least 1 non eos token per beam.\n-            n_eos_tokens = eos_token_id.shape[0] if eos_token_id is not None else 0\n-            next_token_scores, next_tokens = torch.topk(\n-                next_token_scores, max(2, 1 + n_eos_tokens) * num_beams, dim=1, largest=True, sorted=True\n-            )\n-\n-            next_indices = (next_tokens / vocab_size).long()\n-            next_tokens = next_tokens % vocab_size\n-\n-            # stateless\n-            beam_outputs = constrained_beam_scorer.process(\n-                input_ids,\n-                next_token_scores,\n-                next_tokens,\n-                next_indices,\n-                scores_for_all_vocab,\n-                pad_token_id=pad_token_id,\n-                eos_token_id=eos_token_id,\n-                beam_indices=beam_indices,\n-                decoder_prompt_len=decoder_prompt_len,\n-            )\n-            beam_scores = beam_outputs[\"next_beam_scores\"]\n-            beam_next_tokens = beam_outputs[\"next_beam_tokens\"]\n-            beam_idx = beam_outputs[\"next_beam_indices\"]\n-\n-            input_ids = torch.cat([input_ids[beam_idx, :], beam_next_tokens.unsqueeze(-1)], dim=-1)\n-\n-            # This is needed to properly delete outputs.logits which may be very large for first iteration\n-            # Otherwise a reference to outputs is kept which keeps the logits alive in the next iteration\n-            # IMPORTANT: Note that this should appear BEFORE the call to _reorder_cache() to save the maximum memory\n-            # (that way the memory peak does not include outputs.logits)\n-            del outputs\n-\n-            # NOTE: we need to check if `self._reorder_cache` exists for special models like RAG, RecurrentGemma etc.\n-            if model_kwargs.get(\"past_key_values\", None) is not None:\n-                if hasattr(self, \"_reorder_cache\"):\n-                    model_kwargs[\"past_key_values\"] = self._reorder_cache(model_kwargs[\"past_key_values\"], beam_idx)\n-                else:\n-                    model_kwargs[\"past_key_values\"].reorder_cache(beam_idx)\n-\n-            if return_dict_in_generate and output_scores:\n-                beam_indices = tuple(beam_indices[beam_idx[i]] + (beam_idx[i],) for i in range(len(beam_indices)))\n-\n-            # increase cur_len\n-            cur_len = cur_len + 1\n-\n-            if constrained_beam_scorer.is_done or all(stopping_criteria(input_ids, scores)):\n-                this_peer_finished = True\n-\n-        sequence_outputs = constrained_beam_scorer.finalize(\n-            input_ids,\n-            beam_scores,\n-            next_tokens,\n-            next_indices,\n-            pad_token_id=pad_token_id,\n-            eos_token_id=eos_token_id,\n-            max_length=stopping_criteria.max_length,\n-            beam_indices=beam_indices,\n-            decoder_prompt_len=decoder_prompt_len,\n-        )\n-\n-        if return_dict_in_generate:\n-            if not output_scores:\n-                sequence_outputs[\"sequence_scores\"] = None\n-            if self.config.is_encoder_decoder:\n-                return GenerateBeamEncoderDecoderOutput(\n-                    sequences=sequence_outputs[\"sequences\"],\n-                    sequences_scores=sequence_outputs[\"sequence_scores\"],\n-                    scores=scores,\n-                    logits=raw_logits,\n-                    beam_indices=sequence_outputs[\"beam_indices\"],\n-                    encoder_attentions=encoder_attentions,\n-                    encoder_hidden_states=encoder_hidden_states,\n-                    decoder_attentions=decoder_attentions,\n-                    cross_attentions=cross_attentions,\n-                    decoder_hidden_states=decoder_hidden_states,\n-                    past_key_values=model_kwargs.get(\"past_key_values\"),\n-                )\n-            else:\n-                return GenerateBeamDecoderOnlyOutput(\n-                    sequences=sequence_outputs[\"sequences\"],\n-                    sequences_scores=sequence_outputs[\"sequence_scores\"],\n-                    scores=scores,\n-                    logits=raw_logits,\n-                    beam_indices=sequence_outputs[\"beam_indices\"],\n-                    attentions=decoder_attentions,\n-                    hidden_states=decoder_hidden_states,\n-                    past_key_values=model_kwargs.get(\"past_key_values\"),\n-                )\n-        else:\n-            return sequence_outputs[\"sequences\"]\n-\n     def _assisted_decoding(\n         self,\n         input_ids: torch.LongTensor,\n@@ -4142,52 +3831,3 @@ def _split_model_outputs(outputs, new_outputs, cur_len, added_len, is_decoder_at\n             new_tuple += (layer[..., i : i + 1, :last_dim_size],)\n         outputs += (new_tuple,)\n     return outputs\n-\n-\n-def stack_model_outputs(model_outputs: list[ModelOutput], config: PretrainedConfig) -> ModelOutput:\n-    \"\"\"\n-    Stack a list of ModelOutput objects (or its subclasses) along the batch_size dimension. The function infers the\n-    specific ModelOutput subclass from the list provided.\n-    \"\"\"\n-    if not model_outputs:\n-        raise ValueError(\"Input list is empty.\")\n-\n-    # Infer the class from the first object in the list\n-    model_output_cls = type(model_outputs[0])\n-\n-    # Ensure all objects are of the same type\n-    if not all(isinstance(obj, model_output_cls) for obj in model_outputs):\n-        raise ValueError(\"All elements in the list should be of the same type.\")\n-\n-    # Helper function to concat tensors or tuples of tensors\n-    def _concat(data):\n-        \"\"\"\n-        Reverse of `_split` function above.\n-        \"\"\"\n-        if any(data is None for data in data):\n-            return None\n-        if isinstance(data[0], torch.Tensor):\n-            return torch.cat(data, dim=0)\n-        elif isinstance(data[0], tuple):\n-            # If the elements of the tuple are also tuples (e.g., past_key_values in our earlier example)\n-            if isinstance(data[0][0], tuple):\n-                return tuple(\n-                    tuple(torch.cat([attr[i][j] for attr in data], dim=0) for j in range(len(data[0][0])))\n-                    for i in range(len(data[0]))\n-                )\n-            else:\n-                return tuple(torch.cat([attr[i] for attr in data], dim=0) for i in range(len(data[0])))\n-        elif isinstance(data[0], (int, float)):\n-            # If the elements are integers or floats, return a tensor\n-            return torch.tensor(data)\n-        else:\n-            raise TypeError(f\"Unexpected attribute type: {type(data[0])}\")\n-\n-    # Use a dictionary comprehension to gather attributes from all objects and concatenate them\n-    concatenated_data = {\n-        k: _concat([getattr(model_output, k) for model_output in model_outputs])\n-        for k in model_output_cls.__dataclass_fields__\n-    }\n-\n-    # Return a new object of the inferred class with the concatenated attributes\n-    return model_output_cls(**concatenated_data)"
        },
        {
            "sha": "69bb0a40e2925fbfd8794f64a9cd839007da25a1",
            "filename": "tests/generation/test_beam_search.py",
            "status": "removed",
            "additions": 0,
            "deletions": 340,
            "changes": 340,
            "blob_url": "https://github.com/huggingface/transformers/blob/564be6d8950ae781c1b0e93435a4fe7d80e59fc9/tests%2Fgeneration%2Ftest_beam_search.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/564be6d8950ae781c1b0e93435a4fe7d80e59fc9/tests%2Fgeneration%2Ftest_beam_search.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_beam_search.py?ref=564be6d8950ae781c1b0e93435a4fe7d80e59fc9",
            "patch": "@@ -1,340 +0,0 @@\n-# Copyright 2020 The HuggingFace Team Inc.\n-#\n-# Licensed under the Apache License, Version 2.0 (the \"License\");\n-# you may not use this file except in compliance with the License.\n-# You may obtain a clone of the License at\n-#\n-#     http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing, software\n-# distributed under the License is distributed on an \"AS IS\" BASIS,\n-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-# See the License for the specific language governing permissions and\n-# limitations under the License.\n-\n-\n-import unittest\n-\n-from transformers import is_torch_available\n-from transformers.testing_utils import require_torch, torch_device\n-\n-from ..test_modeling_common import floats_tensor, ids_tensor\n-\n-\n-if is_torch_available():\n-    import torch\n-\n-    from transformers.generation import (\n-        BeamHypotheses,\n-        ConstrainedBeamSearchScorer,\n-        DisjunctiveConstraint,\n-        PhrasalConstraint,\n-    )\n-\n-\n-class ConstrainedBeamSearchTester:\n-    def __init__(\n-        self,\n-        parent,\n-        constraints=None,\n-        batch_size=3,\n-        sequence_length=10,\n-        vocab_size=99,\n-        pad_token_id=0,\n-        max_length=20,\n-        num_beams=4,\n-        length_penalty=2.0,\n-        do_early_stopping=True,\n-        num_beam_hyps_to_keep=2,\n-    ):\n-        self.parent = parent\n-        self.batch_size = batch_size\n-        self.sequence_length = sequence_length\n-        self.vocab_size = vocab_size\n-        self.pad_token_id = pad_token_id\n-        self.max_length = max_length\n-        self.num_beams = num_beams\n-        self.length_penalty = length_penalty\n-        self.do_early_stopping = do_early_stopping\n-        self.num_beam_hyps_to_keep = num_beam_hyps_to_keep\n-\n-        if constraints is None:\n-            force_tokens = torch.randint(10, 50, (1, 2))[0].tolist()\n-            disjunctive_tokens = torch.randint(10, 50, (2, 2)).tolist()\n-\n-            constraints = [PhrasalConstraint(force_tokens), DisjunctiveConstraint(disjunctive_tokens)]\n-            self.constraints = constraints\n-        # cannot be randomly generated\n-        self.eos_token_id = vocab_size + 1\n-\n-    def prepare_constrained_beam_scorer(self, **kwargs):\n-        return ConstrainedBeamSearchScorer(\n-            constraints=kwargs.get(\"constraints\", self.constraints),\n-            batch_size=kwargs.get(\"batch_size\", self.batch_size),\n-            num_beams=kwargs.get(\"num_beams\", self.num_beams),\n-            device=torch_device,\n-            length_penalty=kwargs.get(\"length_penalty\", self.length_penalty),\n-            do_early_stopping=kwargs.get(\"do_early_stopping\", self.do_early_stopping),\n-            num_beam_hyps_to_keep=kwargs.get(\"num_beam_hyps_to_keep\", self.num_beam_hyps_to_keep),\n-        )\n-\n-    def prepare_inputs(self):\n-        input_ids = ids_tensor((self.batch_size * self.num_beams, self.sequence_length), self.vocab_size)\n-        next_tokens = ids_tensor((self.batch_size, 2 * self.num_beams), self.vocab_size).to(torch_device)\n-        next_indices = ids_tensor((self.batch_size, 2 * self.num_beams), self.num_beams).to(torch_device)\n-        next_scores, _ = (-floats_tensor((self.batch_size, 2 * self.num_beams)).to(torch_device)).sort(descending=True)\n-        scores_for_all_vocab, _ = (\n-            -floats_tensor((self.batch_size * self.num_beams, self.vocab_size)).to(torch_device)\n-        ).sort(descending=True)\n-        return (input_ids, next_tokens, next_indices, next_scores, scores_for_all_vocab)\n-\n-    def check_beam_hypotheses(self, input_ids, *args):\n-        # check that correct number of beam hypotheses is set in beam scorer\n-        constrained_beam_scorer = self.prepare_constrained_beam_scorer(do_early_stopping=True)\n-        beam_hyp = constrained_beam_scorer._beam_hyps[0]\n-\n-        self.parent.assertEqual(len(constrained_beam_scorer._beam_hyps), self.batch_size)\n-\n-        # check correct type\n-        self.parent.assertTrue(isinstance(beam_hyp, BeamHypotheses))\n-\n-        # check that num_beams is correctly set\n-        self.parent.assertEqual(beam_hyp.num_beams, self.num_beams)\n-\n-        # check for early stopping deactivated\n-        for beam_idx in range(self.num_beams):\n-            beam_hyp.add(input_ids[beam_idx], -10.0)\n-\n-        # if early stopping True -> score does not matter\n-        self.parent.assertTrue(beam_hyp.is_done(-10.0, 5))\n-\n-        # re-init\n-        constrained_beam_scorer = self.prepare_constrained_beam_scorer(do_early_stopping=False)\n-        beam_hyp = constrained_beam_scorer._beam_hyps[0]\n-\n-        # add `num_beams + 1` beams to change `worst_score`\n-        for beam_idx in range(self.num_beams + 1):\n-            beam_hyp.add(input_ids[beam_idx], -10.0 + float(beam_idx))\n-\n-        # -10.0 is removed => -9.0 is worst score\n-        self.parent.assertAlmostEqual(beam_hyp.worst_score, -9.0 / (self.sequence_length**beam_hyp.length_penalty))\n-\n-        # -5.0 is better than worst score => should not be finished\n-        self.parent.assertFalse(beam_hyp.is_done(-5.0, self.sequence_length))\n-\n-        # -20.0 is worse than worst score => should be finished\n-        self.parent.assertTrue(beam_hyp.is_done(-20.0, self.sequence_length))\n-\n-    def check_constrained_beam_scorer_update(\n-        self, input_ids, next_tokens, next_indices, next_scores, scores_for_all_vocab\n-    ):\n-        # check too many eos tokens\n-        constrained_beam_scorer = self.prepare_constrained_beam_scorer()\n-        stacked_token_ids = []\n-        for constraint in self.constraints:\n-            token_ids = constraint.token_ids\n-            token_ids = token_ids[0] if isinstance(token_ids[0], list) else token_ids\n-            stacked_token_ids = stacked_token_ids + token_ids\n-\n-        fulfilling_sequence = torch.LongTensor(stacked_token_ids)\n-        fulfill_len = fulfilling_sequence.size(0)\n-        input_ids[:, :fulfill_len] = fulfilling_sequence\n-\n-        tokens = next_tokens.clone()\n-        tokens[0, :] = self.eos_token_id\n-\n-        with self.parent.assertRaises(ValueError):\n-            constrained_beam_scorer.process(\n-                input_ids, next_scores, tokens, next_indices, scores_for_all_vocab, eos_token_id=self.eos_token_id\n-            )\n-\n-        # check all batches are done\n-        constrained_beam_scorer = self.prepare_constrained_beam_scorer()\n-\n-        tokens = next_tokens.clone()\n-        tokens[:, : self.num_beams] = self.eos_token_id\n-        constrained_beam_scorer.process(\n-            input_ids, next_scores, tokens, next_indices, scores_for_all_vocab, eos_token_id=self.eos_token_id\n-        )\n-        # beam scorer should be done\n-        self.parent.assertTrue(constrained_beam_scorer.is_done)\n-\n-        # check\n-        constrained_beam_scorer = self.prepare_constrained_beam_scorer()\n-\n-        tokens = next_tokens.clone()\n-        tokens[:, 1] = self.eos_token_id\n-        beam_outputs = constrained_beam_scorer.process(\n-            input_ids, next_scores, tokens, next_indices, scores_for_all_vocab, eos_token_id=self.eos_token_id\n-        )\n-        output_scores = beam_outputs[\"next_beam_scores\"]\n-        output_tokens = beam_outputs[\"next_beam_tokens\"]\n-        output_indices = beam_outputs[\"next_beam_indices\"]\n-\n-        def cut_expected_tensor(tensor):\n-            return torch.cat([tensor[:, :1], tensor[:, 2 : self.num_beams + 1]], dim=1).flatten()\n-\n-        # check all outptus\n-        # cut out id of eos token and take best `num_beams` outputs\n-        expected_output_tokens = cut_expected_tensor(tokens)\n-        expected_output_scores = cut_expected_tensor(next_scores)\n-\n-        # add num_beams * batch_idx\n-        offset = torch.div(\n-            torch.arange(self.num_beams * self.batch_size, device=torch_device), self.num_beams, rounding_mode=\"floor\"\n-        )\n-        expected_output_indices = cut_expected_tensor(next_indices) + offset * self.num_beams\n-\n-        self.parent.assertListEqual(expected_output_tokens.tolist(), output_tokens.tolist())\n-        self.parent.assertListEqual(expected_output_indices.tolist(), output_indices.tolist())\n-        self.parent.assertTrue(torch.allclose(expected_output_scores, output_scores, atol=1e-3))\n-\n-        # make sure ids of eos token are correctly saved in beam_hyps of beam scorer\n-        for batch_idx in range(self.batch_size):\n-            correct_idx = batch_idx * self.num_beams + next_indices[batch_idx, 1]\n-            self.parent.assertListEqual(\n-                input_ids[correct_idx].tolist(), constrained_beam_scorer._beam_hyps[batch_idx].beams[0][1].tolist()\n-            )\n-\n-    def check_constrained_beam_scorer_finalize(\n-        self, input_ids, next_tokens, next_indices, next_scores, scores_for_all_vocab\n-    ):\n-        # max_length should be only one more than current input_ids to check that eos is correctly appended\n-        max_length = self.sequence_length + 1\n-\n-        # for testing finalize, we do want to have fulfilled constraints\n-        stacked_token_ids = []\n-        for constraint in self.constraints:\n-            token_ids = constraint.token_ids\n-            token_ids = token_ids[0] if isinstance(token_ids[0], list) else token_ids\n-            stacked_token_ids = stacked_token_ids + token_ids\n-\n-        fulfilling_sequence = torch.LongTensor(stacked_token_ids)\n-\n-        fulfill_len = fulfilling_sequence.size(0)\n-        input_ids[:, :fulfill_len] = fulfilling_sequence\n-\n-        constrained_beam_scorer = self.prepare_constrained_beam_scorer(\n-            num_beam_hyps_to_keep=1, length_penalty=1.0, do_early_stopping=False\n-        )\n-\n-        constraints = constrained_beam_scorer.constraints\n-        # update beams and append to input_ids\n-        tokens = next_tokens.clone()\n-        # first batch, first output has to finish with eos token id since scores are correctly sorted\n-        tokens[0, 0] = self.eos_token_id\n-        # make sure corresponding score is as good as possible to surely be picked first\n-        next_scores[0, 0] = 0.0\n-\n-        beam_outputs = constrained_beam_scorer.process(\n-            input_ids, next_scores, tokens, next_indices, scores_for_all_vocab, eos_token_id=self.eos_token_id\n-        )\n-        output_scores = beam_outputs[\"next_beam_scores\"]\n-        output_tokens = beam_outputs[\"next_beam_tokens\"]\n-        output_indices = beam_outputs[\"next_beam_indices\"]\n-        input_ids = torch.cat([input_ids[output_indices, :], output_tokens.unsqueeze(-1)], dim=-1)\n-\n-        # finalize\n-        sequence_output = constrained_beam_scorer.finalize(\n-            input_ids,\n-            output_scores,\n-            output_tokens,\n-            output_indices,\n-            pad_token_id=self.pad_token_id,\n-            eos_token_id=self.eos_token_id,\n-            max_length=max_length,\n-        )\n-\n-        sequences = sequence_output[\"sequences\"]\n-        sequence_scores = sequence_output[\"sequence_scores\"]\n-\n-        # since `num_beam_hyps_to_keep` = 1 => only return `batch_size` x `max_length`\n-        self.parent.assertListEqual(list(sequences.shape), [self.batch_size, max_length])\n-        self.parent.assertListEqual(list(sequence_scores.shape), [self.batch_size])\n-\n-        # check sequence_scores\n-        self.parent.assertFalse((sequence_scores > 0).any().item())\n-\n-        # first batch has to finish with eos_token\n-        self.parent.assertEqual(sequences[0, -1].item(), self.eos_token_id)\n-\n-        # other batches cannot finish with eos token\n-        self.parent.assertNotEqual(sequences[1, -1].item(), self.eos_token_id)\n-        self.parent.assertNotEqual(sequences[2, -1].item(), self.eos_token_id)\n-\n-        # test that the constraint is indeed fulfilled\n-        for output, constraint in [(s, c) for s in sequences for c in constraints]:\n-            forced_token_ids = constraint.token_ids\n-            if isinstance(forced_token_ids[0], list):\n-                # disjunctive case\n-                flag = False\n-                for token_ids in forced_token_ids:\n-                    if self._check_sequence_inside_sequence(output, token_ids):\n-                        flag = True\n-                        break\n-                self.parent.assertEqual(flag, True)\n-            else:\n-                self.parent.assertEqual(self._check_sequence_inside_sequence(output, forced_token_ids), True)\n-\n-        # now test that if `num_beam_hyps_to_keep` is 3 => all beams are returned\n-\n-        # constrained_beam_scorer.num_beam_hyps_to_keep = self.num_beams\n-        constrained_beam_scorer = self.prepare_constrained_beam_scorer(\n-            num_beam_hyps_to_keep=self.num_beams, length_penalty=1.0, do_early_stopping=False\n-        )\n-\n-        sequence_output = constrained_beam_scorer.finalize(\n-            input_ids,\n-            output_scores,\n-            output_tokens,\n-            output_indices,\n-            pad_token_id=self.pad_token_id,\n-            eos_token_id=self.eos_token_id,\n-            max_length=max_length,\n-        )\n-        sequences = sequence_output[\"sequences\"]\n-        sequence_scores = sequence_output[\"sequence_scores\"]\n-\n-        self.parent.assertListEqual(list(sequences.shape), [self.num_beams * self.batch_size, max_length])\n-        self.parent.assertListEqual(list(sequence_scores.shape), [self.num_beams * self.batch_size])\n-\n-    def _check_sequence_inside_sequence(self, tensor_1, tensor_2):\n-        # check if tensor_1 inside tensor_2 or tensor_2 inside tensor_1.\n-        # set to same device. we don't care what device.\n-\n-        if not isinstance(tensor_1, list):\n-            tensor_1 = tensor_1.tolist()\n-        if not isinstance(tensor_2, list):\n-            tensor_2 = tensor_2.tolist()\n-\n-        in_order = len(tensor_1) <= len(tensor_2)\n-        longer = tensor_2 if in_order else tensor_1\n-        shorter = tensor_1 if in_order else tensor_2\n-\n-        flag = False\n-        chunk_size = len(shorter)\n-        for chunk_idx in range(len(longer) - chunk_size + 1):\n-            subseq = longer[chunk_idx : chunk_idx + chunk_size]\n-            if subseq == shorter:\n-                flag = True\n-                break\n-\n-        return flag\n-\n-\n-@require_torch\n-class ConstrainedBeamSearchTest(unittest.TestCase):\n-    def setUp(self):\n-        self.constrained_beam_search_tester = ConstrainedBeamSearchTester(self)\n-\n-    def test_constrained_beam_hypotheses(self):\n-        inputs = self.constrained_beam_search_tester.prepare_inputs()\n-        self.constrained_beam_search_tester.check_beam_hypotheses(*inputs)\n-\n-    def test_constrained_beam_scorer_update(self):\n-        inputs = self.constrained_beam_search_tester.prepare_inputs()\n-        self.constrained_beam_search_tester.check_constrained_beam_scorer_update(*inputs)\n-\n-    def test_constrained_beam_scorer_finalize(self):\n-        inputs = self.constrained_beam_search_tester.prepare_inputs()\n-        self.constrained_beam_search_tester.check_constrained_beam_scorer_finalize(*inputs)"
        },
        {
            "sha": "bb4c2a52986c0c4962bdf761fb43a28c5a1c21e4",
            "filename": "tests/generation/test_configuration_utils.py",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fgeneration%2Ftest_configuration_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fgeneration%2Ftest_configuration_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_configuration_utils.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -189,14 +189,9 @@ def test_validate(self):\n             generation_config_bad_temperature.update(temperature=None)\n         self.assertEqual(len(captured_logs.out), 0)\n \n-        # Impossible sets of constraints/parameters will raise an exception\n+        # Impossible sets of parameters will raise an exception\n         with self.assertRaises(ValueError):\n             GenerationConfig(do_sample=False, num_beams=1, num_return_sequences=2)\n-        with self.assertRaises(ValueError):\n-            # dummy constraint\n-            GenerationConfig(do_sample=True, num_beams=2, constraints=[\"dummy\"])\n-        with self.assertRaises(ValueError):\n-            GenerationConfig(do_sample=True, num_beams=2, force_words_ids=[[[1, 2, 3]]])\n \n         # Passing `generate()`-only flags to `validate` will raise an exception\n         with self.assertRaises(ValueError):"
        },
        {
            "sha": "69c1e0f6674c13b613425fd41e1890d807cf1b7a",
            "filename": "tests/generation/test_utils.py",
            "status": "modified",
            "additions": 7,
            "deletions": 331,
            "changes": 338,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fgeneration%2Ftest_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fgeneration%2Ftest_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_utils.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -40,7 +40,6 @@\n )\n from transformers.testing_utils import (\n     CaptureLogger,\n-    is_flaky,\n     require_accelerate,\n     require_flash_attn,\n     require_flash_attn_3,\n@@ -89,7 +88,6 @@\n         BeamSearchDecoderOnlyOutput,\n         BeamSearchEncoderDecoderOutput,\n         CompileConfig,\n-        DisjunctiveConstraint,\n         GenerateBeamDecoderOnlyOutput,\n         GenerateBeamEncoderDecoderOutput,\n         GenerateDecoderOnlyOutput,\n@@ -101,7 +99,6 @@\n         LogitsProcessorList,\n         MaxLengthCriteria,\n         MinLengthLogitsProcessor,\n-        PhrasalConstraint,\n         PromptLookupCandidateGenerator,\n         SampleDecoderOnlyOutput,\n         SampleEncoderDecoderOutput,\n@@ -209,15 +206,6 @@ def _get_beam_kwargs(self, num_return_sequences=1):\n         }\n         return beam_kwargs\n \n-    def _get_constrained_beam_kwargs(self, num_return_sequences=1):\n-        beam_kwargs = {\n-            \"early_stopping\": False,\n-            \"length_penalty\": 2.0,\n-            \"num_beams\": num_return_sequences * 4,\n-            \"num_return_sequences\": num_return_sequences,\n-        }\n-        return beam_kwargs\n-\n     def _greedy_generate(\n         self,\n         model,\n@@ -340,38 +328,6 @@ def _beam_sample_generate(\n \n         return output_generate\n \n-    def _constrained_beam_search_generate(\n-        self,\n-        model,\n-        inputs_dict,\n-        constraints,\n-        beam_kwargs,\n-        output_scores=False,\n-        output_logits=False,\n-        output_attentions=False,\n-        output_hidden_states=False,\n-        return_dict_in_generate=False,\n-        use_cache=True,\n-    ):\n-        logits_processor_kwargs = self._get_logits_processor_kwargs(do_sample=False, config=model.config)\n-        output_generate = model.generate(\n-            do_sample=False,\n-            max_new_tokens=self.max_new_tokens,\n-            min_new_tokens=self.max_new_tokens,\n-            output_scores=output_scores,\n-            output_logits=output_logits,\n-            output_attentions=output_attentions,\n-            output_hidden_states=output_hidden_states,\n-            return_dict_in_generate=return_dict_in_generate,\n-            constraints=constraints,\n-            use_cache=use_cache,\n-            **beam_kwargs,\n-            **logits_processor_kwargs,\n-            **inputs_dict,\n-        )\n-\n-        return output_generate\n-\n     @pytest.mark.generate\n     def test_greedy_generate(self):\n         for model_class in self.all_generative_model_classes:\n@@ -706,115 +662,6 @@ def test_generate_without_input_ids(self):\n             )\n             self.assertIsNotNone(output_ids_generate)\n \n-    @is_flaky()  # Some models have position-specific tokens, this test may try to force them in an invalid position\n-    @pytest.mark.generate\n-    def test_constrained_beam_search_generate(self):\n-        for model_class in self.all_generative_model_classes:\n-            config, inputs_dict = self.prepare_config_and_inputs_for_generate()\n-\n-            model = model_class(config).to(torch_device).eval()\n-\n-            # Sample constraints\n-            min_id = 3\n-            max_id = config.get_text_config(decoder=True).vocab_size\n-\n-            force_tokens = torch.randint(min_id, max_id, (1, 2)).tolist()[0]\n-            constraints = [\n-                PhrasalConstraint(force_tokens),\n-            ]\n-\n-            beam_kwargs = self._get_constrained_beam_kwargs()\n-            output_generate = self._constrained_beam_search_generate(\n-                model=model,\n-                inputs_dict=inputs_dict,\n-                constraints=constraints,\n-                beam_kwargs=beam_kwargs,\n-            )\n-\n-            if model.config.get_text_config(decoder=True).is_encoder_decoder:\n-                self.assertTrue(output_generate.shape[1] == self.max_new_tokens + 1)\n-            else:\n-                self.assertTrue(output_generate.shape[1] == self.max_new_tokens + inputs_dict[\"input_ids\"].shape[1])\n-\n-            for generation_output in output_generate:\n-                self._check_sequence_inside_sequence(force_tokens, generation_output)\n-\n-            # check`constrained_beam_search` for higher than 1 `num_return_sequences`\n-            # Sample constraints\n-            force_tokens = torch.randint(min_id, max_id, (1, 2)).tolist()[0]\n-            constraints = [\n-                PhrasalConstraint(force_tokens),\n-            ]\n-\n-            beam_kwargs = self._get_constrained_beam_kwargs(num_return_sequences=2)\n-\n-            output_generate = self._constrained_beam_search_generate(\n-                model=model,\n-                inputs_dict=inputs_dict,\n-                constraints=constraints,\n-                beam_kwargs=beam_kwargs,\n-            )\n-\n-            if model.config.get_text_config(decoder=True).is_encoder_decoder:\n-                self.assertTrue(output_generate.shape[1] == self.max_new_tokens + 1)\n-            else:\n-                self.assertTrue(output_generate.shape[1] == self.max_new_tokens + inputs_dict[\"input_ids\"].shape[1])\n-\n-            for generation_output in output_generate:\n-                self._check_sequence_inside_sequence(force_tokens, generation_output)\n-\n-    @is_flaky()  # Some models have position-specific tokens, this test may try to force them in an invalid position\n-    @pytest.mark.generate\n-    def test_constrained_beam_search_generate_dict_output(self):\n-        for model_class in self.all_generative_model_classes:\n-            config, inputs_dict = self.prepare_config_and_inputs_for_generate()\n-            if self.has_attentions:\n-                config._attn_implementation = \"eager\"  # can't output attentions otherwise\n-\n-            model = model_class(config).to(torch_device).eval()\n-\n-            # Sample constraints\n-            min_id = 3\n-            max_id = model.config.get_text_config(decoder=True).vocab_size\n-            force_tokens = torch.randint(min_id, max_id, (1, 2)).tolist()[0]\n-            constraints = [\n-                PhrasalConstraint(force_tokens),\n-            ]\n-\n-            beam_kwargs = self._get_constrained_beam_kwargs()\n-            output_generate = self._constrained_beam_search_generate(\n-                model=model,\n-                inputs_dict=inputs_dict,\n-                constraints=constraints,\n-                beam_kwargs=beam_kwargs,\n-                output_scores=True,\n-                output_logits=True,\n-                output_hidden_states=True,\n-                output_attentions=self.has_attentions,\n-                return_dict_in_generate=True,\n-                use_cache=False,\n-            )\n-\n-            if model.config.get_text_config(decoder=True).is_encoder_decoder:\n-                self.assertTrue(output_generate.sequences.shape[1] == self.max_new_tokens + 1)\n-                self.assertIsInstance(output_generate, GenerateBeamEncoderDecoderOutput)\n-                # Retrocompatibility check\n-                self.assertIsInstance(output_generate, BeamSearchEncoderDecoderOutput)\n-            else:\n-                self.assertTrue(\n-                    output_generate.sequences.shape[1] == self.max_new_tokens + inputs_dict[\"input_ids\"].shape[1]\n-                )\n-                self.assertIsInstance(output_generate, GenerateBeamDecoderOnlyOutput)\n-                # Retrocompatibility check\n-                self.assertIsInstance(output_generate, BeamSearchDecoderOnlyOutput)\n-\n-            self._check_generate_outputs(\n-                output_generate,\n-                model.config,\n-                num_return_sequences=beam_kwargs[\"num_return_sequences\"],\n-                num_beams=beam_kwargs[\"num_beams\"],\n-            )\n-\n     @parameterized.expand([(\"random\",), (\"same\",)])\n     @pytest.mark.generate\n     def test_assisted_decoding_matches_greedy_search(self, assistant_type):\n@@ -2881,120 +2728,6 @@ def test_beam_search_example_integration(self):\n \n         self.assertListEqual(outputs, [\"Wie alt bist du?\"])\n \n-    @slow\n-    def test_constrained_beam_search(self):\n-        model = GPT2LMHeadModel.from_pretrained(\"openai-community/gpt2\").to(torch_device)\n-        tokenizer = GPT2Tokenizer.from_pretrained(\"openai-community/gpt2\")\n-\n-        force_tokens = tokenizer(\"scared\", add_prefix_space=True, add_special_tokens=False).input_ids\n-        force_tokens_2 = tokenizer(\"big weapons\", add_prefix_space=True, add_special_tokens=False).input_ids\n-\n-        constraints = [\n-            PhrasalConstraint(force_tokens),\n-            PhrasalConstraint(force_tokens_2),\n-        ]\n-\n-        starting_text = [\"The soldiers were not prepared and\"]\n-\n-        input_ids = tokenizer(starting_text, return_tensors=\"pt\").input_ids.to(torch_device)\n-\n-        outputs = model.generate(\n-            input_ids,\n-            constraints=constraints,\n-            num_beams=10,\n-            num_return_sequences=1,\n-            no_repeat_ngram_size=1,\n-            max_length=30,\n-            remove_invalid_values=True,\n-        )\n-\n-        generated_text = tokenizer.batch_decode(outputs, skip_special_tokens=True)\n-\n-        self.assertListEqual(\n-            generated_text,\n-            [\n-                \"The soldiers were not prepared and didn't know what to do. They had no idea how they would react if\"\n-                \" the enemy attacked them, big weapons scared\"\n-            ],\n-        )\n-\n-    @slow\n-    def test_constrained_beam_search_mixed(self):\n-        model = GPT2LMHeadModel.from_pretrained(\"openai-community/gpt2\").to(torch_device)\n-        tokenizer = GPT2Tokenizer.from_pretrained(\"openai-community/gpt2\")\n-\n-        force_phrase = tokenizer(\"scared\", add_prefix_space=True, add_special_tokens=False).input_ids\n-        flexible_phrases = tokenizer(\n-            [\"scream\", \"screams\", \"screaming\", \"screamed\"], add_prefix_space=True, add_special_tokens=False\n-        ).input_ids\n-\n-        constraints = [\n-            PhrasalConstraint(force_phrase),\n-            DisjunctiveConstraint(flexible_phrases),\n-        ]\n-\n-        starting_text = [\"The soldiers\", \"The child\"]\n-\n-        input_ids = tokenizer(starting_text, return_tensors=\"pt\").input_ids.to(torch_device)\n-\n-        outputs = model.generate(\n-            input_ids,\n-            constraints=constraints,\n-            num_beams=10,\n-            num_return_sequences=1,\n-            no_repeat_ngram_size=1,\n-            # max_length=20,\n-            remove_invalid_values=True,\n-        )\n-\n-        generated_text = tokenizer.batch_decode(outputs, skip_special_tokens=True)\n-\n-        self.assertListEqual(\n-            generated_text,\n-            [\n-                \"The soldiers, who had been stationed at the base for more than a year before being evacuated\"\n-                \" screaming scared\",\n-                \"The child was taken to a local hospital where he died.\\n 'I don't think screaming scared\",\n-            ],\n-        )\n-\n-    @slow\n-    def test_constrained_beam_search_mixed_mixin(self):\n-        model = GPT2LMHeadModel.from_pretrained(\"openai-community/gpt2\").to(torch_device)\n-        tokenizer = GPT2Tokenizer.from_pretrained(\"openai-community/gpt2\")\n-\n-        force_word = \"scared\"\n-        force_flexible = [\"scream\", \"screams\", \"screaming\", \"screamed\"]\n-\n-        force_words_ids = [\n-            tokenizer([force_word], add_prefix_space=True, add_special_tokens=False).input_ids,\n-            tokenizer(force_flexible, add_prefix_space=True, add_special_tokens=False).input_ids,\n-        ]\n-\n-        starting_text = [\"The soldiers\", \"The child\"]\n-\n-        input_ids = tokenizer(starting_text, return_tensors=\"pt\").input_ids.to(torch_device)\n-\n-        outputs = model.generate(\n-            input_ids,\n-            force_words_ids=force_words_ids,\n-            num_beams=10,\n-            num_return_sequences=1,\n-            no_repeat_ngram_size=1,\n-            remove_invalid_values=True,\n-        )\n-\n-        generated_text = tokenizer.batch_decode(outputs, skip_special_tokens=True)\n-\n-        self.assertListEqual(\n-            generated_text,\n-            [\n-                \"The soldiers, who had been stationed at the base for more than a year before being evacuated\"\n-                \" screaming scared\",\n-                \"The child was taken to a local hospital where he died.\\n 'I don't think screaming scared\",\n-            ],\n-        )\n-\n     @slow\n     def test_cfg_mixin(self):\n         model = GPT2LMHeadModel.from_pretrained(\"openai-community/gpt2\").to(torch_device)\n@@ -3035,30 +2768,7 @@ def test_cfg_mixin(self):\n             ],\n         )\n \n-    @slow\n-    def test_constrained_beam_search_example_translation_mixin(self):\n-        tokenizer = AutoTokenizer.from_pretrained(\"google-t5/t5-base\")\n-        model = AutoModelForSeq2SeqLM.from_pretrained(\"google-t5/t5-base\")\n-\n-        encoder_input_str = \"translate English to German: How old are you?\"\n-        force_words = [\"sind\"]\n-\n-        input_ids = tokenizer(encoder_input_str, return_tensors=\"pt\").input_ids\n-        force_words_ids = tokenizer(force_words, add_special_tokens=False).input_ids\n-\n-        outputs = model.generate(\n-            input_ids,\n-            force_words_ids=force_words_ids,\n-            num_beams=10,\n-            num_return_sequences=1,\n-            no_repeat_ngram_size=1,\n-            remove_invalid_values=True,\n-        )\n-\n-        outputs = tokenizer.batch_decode(outputs, skip_special_tokens=True)\n-\n-        self.assertListEqual(outputs, [\"Wie alt sind Sie?\"])\n-\n+    # TODO joao, manuel: remove in v4.62.0\n     @slow\n     def test_constrained_beam_search_example_integration(self):\n         tokenizer = AutoTokenizer.from_pretrained(\"google-t5/t5-base\")\n@@ -3085,6 +2795,8 @@ def test_constrained_beam_search_example_integration(self):\n             force_words_ids=[constraint_token_ids],\n             min_length=5,\n             eos_token_id=model.config.eos_token_id,\n+            trust_remote_code=True,\n+            custom_generate=\"transformers-community/constrained-beam-search\",\n             **model_kwargs,\n         )\n         outputs = tokenizer.batch_decode(outputs, skip_special_tokens=True)\n@@ -3128,46 +2840,6 @@ def test_per_row_stopping_criteria(self):\n         ]\n         self.assertListEqual(out_text, expected_out)\n \n-    def test_constrained_beam_search_mixin_type_checks(self):\n-        tokenizer = AutoTokenizer.from_pretrained(\"patrickvonplaten/t5-tiny-random\")\n-        model = AutoModelForSeq2SeqLM.from_pretrained(\"patrickvonplaten/t5-tiny-random\")\n-\n-        encoder_input_str = \"translate English to German: How old are you?\"\n-        input_ids = tokenizer(encoder_input_str, return_tensors=\"pt\").input_ids\n-\n-        with self.assertRaises(ValueError):\n-            force_words = [\"sind\"]\n-            force_words_ids = tokenizer(force_words, return_tensors=\"pt\").input_ids\n-            model.generate(\n-                input_ids,\n-                force_words_ids=force_words_ids,\n-                num_beams=10,\n-                num_return_sequences=1,\n-                no_repeat_ngram_size=1,\n-                remove_invalid_values=True,\n-            )\n-\n-        with self.assertRaises(ValueError):\n-            force_words = [\"sind\"]\n-            force_words_ids = [tokenizer(force_words, return_tensors=\"pt\").input_ids]\n-            model.generate(\n-                input_ids,\n-                force_words_ids=force_words_ids,\n-                num_beams=10,\n-                num_return_sequences=1,\n-                no_repeat_ngram_size=1,\n-                remove_invalid_values=True,\n-            )\n-\n-        with self.assertRaises(ValueError):\n-            model.generate(input_ids, force_words_ids=[])\n-\n-        with self.assertRaises(ValueError):\n-            model.generate(input_ids, force_words_ids=[[-1]])\n-\n-        with self.assertRaises(ValueError):\n-            model.generate(input_ids, force_words_ids=[[[-1]]])\n-\n     def test_batched_decoder_start_id(self):\n         articles = [\n             \"Justin Timberlake and Jessica Biel, welcome to parenthood.\",\n@@ -4742,6 +4414,10 @@ def test_generate_custom_cache_position(self):\n                     \"length_penalty\": 2.0,\n                 },\n             ),\n+            (\n+                \"transformers-community/constrained-beam-search\",\n+                {\"do_sample\": False, \"num_beams\": 2, \"force_words_ids\": [[167, 168, 169]]},\n+            ),\n         ]\n     )\n     def test_hub_gen_strategies(self, custom_generate, extra_kwargs):"
        },
        {
            "sha": "19e0beb39cb9eb524a60a819a261eb30c3c3959a",
            "filename": "tests/models/csm/test_modeling_csm.py",
            "status": "modified",
            "additions": 0,
            "deletions": 10,
            "changes": 10,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fmodels%2Fcsm%2Ftest_modeling_csm.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fmodels%2Fcsm%2Ftest_modeling_csm.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fcsm%2Ftest_modeling_csm.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -272,16 +272,6 @@ def test_beam_search_generate_dict_outputs_use_cache(self):\n     def test_beam_sample_generate_dict_output(self):\n         pass\n \n-    @pytest.mark.generate\n-    @unittest.skip(reason=\"CSM does not support constrained beam search.\")\n-    def test_constrained_beam_search_generate(self):\n-        pass\n-\n-    @pytest.mark.generate\n-    @unittest.skip(reason=\"CSM does not support constrained beam search.\")\n-    def test_constrained_beam_search_generate_dict_output(self):\n-        pass\n-\n     @pytest.mark.generate\n     @unittest.skip(reason=\"CSM does not support prompt lookup decoding.\")\n     def test_prompt_lookup_decoding_matches_greedy_search(self):"
        },
        {
            "sha": "b927b903085b3e611a75a616cc16f42795afa156",
            "filename": "tests/models/dia/test_modeling_dia.py",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fmodels%2Fdia%2Ftest_modeling_dia.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fmodels%2Fdia%2Ftest_modeling_dia.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fdia%2Ftest_modeling_dia.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -237,7 +237,6 @@ def skip_non_greedy_generate(self):\n         skippable_tests = [\n             \"test_sample_generate_dict_output\",  # return sequences > 1\n             \"test_beam\",\n-            \"test_constrained_beam\",\n             \"test_contrastive\",\n             \"test_assisted\",\n             \"test_prompt_lookup\","
        },
        {
            "sha": "e96fa660c66527083c698db7a9c5918f736418c2",
            "filename": "tests/models/qwen2_5_omni/test_modeling_qwen2_5_omni.py",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fmodels%2Fqwen2_5_omni%2Ftest_modeling_qwen2_5_omni.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fmodels%2Fqwen2_5_omni%2Ftest_modeling_qwen2_5_omni.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen2_5_omni%2Ftest_modeling_qwen2_5_omni.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -430,10 +430,6 @@ def test_contrastive_generate_dict_outputs_use_cache(self):\n     def test_contrastive_generate_low_memory(self):\n         pass\n \n-    @unittest.skip(\"Cannot do constraint generation, has custom `generate()`\")\n-    def test_constrained_beam_search_generate_dict_output(self):\n-        pass\n-\n     @unittest.skip(\"Cannot generate from inputs embeds\")\n     def test_generate_from_inputs_embeds_with_static_cache(self):\n         pass"
        },
        {
            "sha": "687248e9543ee103a251583b45bfb4cab2b770ad",
            "filename": "tests/models/recurrent_gemma/test_modeling_recurrent_gemma.py",
            "status": "modified",
            "additions": 0,
            "deletions": 10,
            "changes": 10,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fmodels%2Frecurrent_gemma%2Ftest_modeling_recurrent_gemma.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fmodels%2Frecurrent_gemma%2Ftest_modeling_recurrent_gemma.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Frecurrent_gemma%2Ftest_modeling_recurrent_gemma.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -128,21 +128,11 @@ def test_beam_search_generate_dict_output(self):\n     def test_beam_search_generate_dict_outputs_use_cache(self):\n         pass\n \n-    @unittest.skip(reason=\"RecurrentGemma is unusual and fails a lot of generation tests\")\n-    @pytest.mark.generate\n-    def test_constrained_beam_search_generate_dict_output(self):\n-        pass\n-\n     @unittest.skip(reason=\"RecurrentGemma is unusual and fails a lot of generation tests\")\n     @pytest.mark.generate\n     def test_generate_without_input_ids(self):\n         pass\n \n-    @unittest.skip(reason=\"RecurrentGemma is unusual and fails a lot of generation tests\")\n-    @pytest.mark.generate\n-    def test_constrained_beam_search_generate(self):\n-        pass\n-\n     @unittest.skip(reason=\"RecurrentGemma is unusual and fails a lot of generation tests\")\n     @pytest.mark.generate\n     def test_greedy_generate_dict_outputs(self):"
        },
        {
            "sha": "6498011e5da9f86d034529f0126c01df4fbc17d8",
            "filename": "tests/models/rwkv/test_modeling_rwkv.py",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fmodels%2Frwkv%2Ftest_modeling_rwkv.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fmodels%2Frwkv%2Ftest_modeling_rwkv.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Frwkv%2Ftest_modeling_rwkv.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -387,13 +387,6 @@ def test_beam_search_generate_dict_output(self):\n         super().test_beam_search_generate_dict_output()\n         self.has_attentions = old_has_attentions\n \n-    def test_constrained_beam_search_generate_dict_output(self):\n-        # This model has a custom attention output shape AND config flags, let's skip those checks\n-        old_has_attentions = self.has_attentions\n-        self.has_attentions = False\n-        super().test_constrained_beam_search_generate_dict_output()\n-        self.has_attentions = old_has_attentions\n-\n     def test_greedy_generate_dict_outputs(self):\n         # This model has a custom attention output shape AND config flags, let's skip those checks\n         old_has_attentions = self.has_attentions"
        },
        {
            "sha": "81770ac1b19feb7491104a9706ba1a2fe95188eb",
            "filename": "tests/models/whisper/test_modeling_whisper.py",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fmodels%2Fwhisper%2Ftest_modeling_whisper.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/8564e210ca02f88892e04ded0c8321bb44e4398d/tests%2Fmodels%2Fwhisper%2Ftest_modeling_whisper.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fwhisper%2Ftest_modeling_whisper.py?ref=8564e210ca02f88892e04ded0c8321bb44e4398d",
            "patch": "@@ -404,12 +404,6 @@ def _get_beam_kwargs(self, num_return_sequences=1):\n         beam_kwargs[\"num_return_sequences\"] = beam_kwargs[\"num_beams\"]\n         return beam_kwargs\n \n-    def _get_constrained_beam_kwargs(self, num_return_sequences=1):\n-        # Overwritten from `GenerationTesterMixin`, Whisper's `num_return_sequences` differs from the core `generate`\n-        beam_kwargs = super()._get_constrained_beam_kwargs(num_return_sequences=num_return_sequences)\n-        beam_kwargs[\"num_return_sequences\"] = beam_kwargs[\"num_beams\"]\n-        return beam_kwargs\n-\n     def setUp(self):\n         self.model_tester = WhisperModelTester(self)\n         self.config_tester = ConfigTester(self, config_class=WhisperConfig)"
        }
    ],
    "stats": {
        "total": 1750,
        "additions": 516,
        "deletions": 1234
    }
}