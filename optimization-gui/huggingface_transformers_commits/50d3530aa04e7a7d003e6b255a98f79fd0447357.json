{
    "author": "RyanMullins",
    "message": "Gemma3 (#36658)\n\n* Fix converter\n\n* [Broken] Adds Gemma 3 to Hugging Face Transformers\n\n* Consolidating Config and Processor params across impls\n\n* Sorting out configuration parameters. Adds qk_norm before RoPE. Still not sure if RoPE is right.\n\n* Additional plumbing for CausalLM and ConditionalGeneration variants\n\n* incomplete draft of Orbax conversion script\n\n* More complete checkpoint conversion\n\n* Supporting Gemma 3 1B checkpoints\n\n* Updating RoPE for multiple frequencies\n\n* Adjustments to rotary embedder\n\n* Proof of life for text-only operation\n\n* Updating the conversion script to handle multimodal projection weights\n\n* Fixing tet-only conversions\n\n* Cleaner conversion script with multimodal support and a simpler processor\n\n* Additional refatcors to the Gemma3Processor\n\n* Simplified Processor to work over text representations\n\n* Updated conversion script to join text and vision embeddings at converion time\n\n* Logging for debugging\n\n* Update src/transformers/models/gemma2/modeling_gemma2.py\n\nCo-authored-by: Joshua Lochner <admin@xenova.com>\n\n* Removed extraneous Config params\n\n* Switching to fast tokenizer for checkpoint conversions\n\n* isolating siglip for performance tetsing\n\n* Minor changes for debugging tests against baselines\n\n* Adding average pooling for soft tokens\n\n* Updating processor code to enable simpler embedding interleaving for arbitrary number of images in prompts\n\n* Updating conversion script for ShieldGemma 2 conversion compatibility\n\n* Allow disable_compile to be provided as a kwarg\n\n* Refresh from modular\n\n* Updated conversion script and corrected sliding window\n\n* Fix type mismatch in cache_position (#4)\n\n* Fix dtype (#5)\n\n* Fix type mismatch in cache_position\n\n* Actually fix in the modular file\n\nCo-authored-by: Aritra Roy Gosthipaty <aritra.born2fly@gmail.com>\n\n---------\n\nCo-authored-by: Aritra Roy Gosthipaty <aritra.born2fly@gmail.com>\n\n* fixes for embedding table overflow and missing image_soft_token_mask from Gemma3Processor\n\n* Adding 2D pooling for image embeddings\n\n* Revert \"Adding 2D pooling for image embeddings\"\n\nThis reverts commit 65350cf531296f050b2078a5b8e46f61642b2648.\n\n* Gemma3 average pooling changed from 1D to 2D\n\n* Major refactor to Gemma3MultimodalInputProjection\n\n* Updating Gemm 3 Auto* registrations\n\n* Add option to save Gemma 3 chat template with tokenizer during weights conversion\n\n* Removing unused imports\n\n* Moving out-of-vocab handling from Gemma3Processor to Gemma3ForConditionalGeneration\n\n* Removing duplicate config property\n\n* Removing final logit softcapping and 1-indexing of position ids\n\n* Fixing image processor config and none --> None typo\n\n* Fixing sliding window size for 1B\n\n* Updating image_mean and image_std in Image Processor\n\n* Attention masking changed to lower triangular\n\n* Moving image special tokens to conversion script\n\n* Mirror image processor defaults from conversion script into Gemma3ProcessorKwargs\n\n* Remove special token variables from symbol space\n\n* Moving image soft token mask computation from Gemma3Processor to Gemma3ForConditionalGeneration\n\n* tie lm_head and embedding weights\n\nCo-authored-by: Matthew Douglas <38992547+matthewdouglas@users.noreply.github.com>\n\n* Correct tied weights in Gemma3CausalLM\n\n* iterative bidirectional attention\n\n* resolving merge conflicts\n\n* Reverting to Gemma 2 HybridCache with sldiing window support and a sliding_window_pattern of 6\n\n* Correcting RoPE scaling\n\n* clean up first pass, dummy model geenration works\n\n* final clean up before fixing tests\n\n* causal lm test works, so fine\n\n* Fix conversion\n\n* Update src/transformers/models/gemma3/processing_gemma3.py\n\n* model tests are happy\n\n* processor tests are happy\n\n* image processing tests added\n\n* fixup\n\n* Fix pre-processing in conversion\n\n* Inputs merging\n\n* Do not normalize vision embeddings\n\n* Apply Ryan's (and team) changes to attention\n\n* token type ids + mask\n\n* template\n\n* move embed scale, add rope scale, fix tests\n\n* Add chat template to tokenizer\n\n* Use prefix for causal model loading\n\n* use existing code for sliding mask from gemma2\n\n* self.embed_tokens already normalizes\n\n* Correcting Gemma3TextConfig parameters in conversion script\n\n* typo, modular overwrites my fixes\n\n* enable device map for text model\n\n* Conversion updates\n\n* ultra nit: no einsums\n\n* update image token\n\n* copy deepcopy config + some docs\n\n* add some test, still WIP\n\n* Refactoring --include_chat_tempalte logic in converter\n\n* Update src/transformers/models/gemma3/modular_gemma3.py\n\nCo-authored-by: Xuan-Son Nguyen <thichthat@gmail.com>\n\n* Add eos tokens for instruct models\n\n* dump so i can work on dgx\n\n* Removing add_bos by default\n\n* dump\n\n* add fast im proc\n\n* docs for PaS + fixup\n\n* another fixup\n\n* one more fixup\n\n* fix tests\n\n* Inverting prior BOS change\n\n* ultra nit\n\n* Reverting to Tokenizer saved with add_bos_token=True and chat template starting with BOS\n\n* resize embeds, remove sqrt, add slow test outputs\n\n* FA2 but quality is meh\n\n* nit\n\n* skip FA2, no idea what happened\n\n* last bit for green CI\n\n* please, green CI for docs\n\n* T_T\n\n* Fix for Gemma3 logits\n\n* Support both options for system prompt\n\n* Update src/transformers/models/gemma3/image_processing_gemma3_fast.py\n\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\n\n* Update docs/source/en/model_doc/gemma3.md\n\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\n\n* Update docs/source/en/model_doc/gemma3.md\n\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\n\n* Update docs/source/en/model_doc/gemma3.md\n\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\n\n* Update docs/source/en/model_doc/gemma3.md\n\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\n\n* Update docs/source/en/model_doc/gemma3.md\n\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\n\n* Docs updates now that assets are live\n\n* Style fixes\n\n---------\n\nCo-authored-by: Joshua Lochner <admin@xenova.com>\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\nCo-authored-by: Aritra Roy Gosthipaty <aritra.born2fly@gmail.com>\nCo-authored-by: Mayank Chaturvedi <imayank@google.com>\nCo-authored-by: Matthew Douglas <38992547+matthewdouglas@users.noreply.github.com>\nCo-authored-by: raushan <raushan@huggingface.co>\nCo-authored-by: Raushan Turganbay <raushan.turganbay@alumni.nu.edu.kz>\nCo-authored-by: Xuan-Son Nguyen <thichthat@gmail.com>\nCo-authored-by: Lysandre <hi@lysand.re>",
    "sha": "50d3530aa04e7a7d003e6b255a98f79fd0447357",
    "files": [
        {
            "sha": "0f466bb55bf2646fba23ba75f7cba4dfa2f810ac",
            "filename": "docs/source/en/model_doc/gemma3.md",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/docs%2Fsource%2Fen%2Fmodel_doc%2Fgemma3.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/docs%2Fsource%2Fen%2Fmodel_doc%2Fgemma3.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fgemma3.md?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -0,0 +1,203 @@\n+\n+<!--Copyright 2025 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# Gemma3\n+\n+## Overview\n+\n+The Gemma 3 model was proposed in the [Gemma 3 Techncial Report](https://goo.gle/Gemma3Report) by Google. It is a vision-language model composed by a [SigLIP](siglip) vision encoder and a [Gemma 2](gemma_2) language decoder, linked by a multimodal linear projection. It cuts an image into a fixed number of tokens, in the same way as SigLIP, as long as the image does not exceed certain aspect ratio. For images that exceed the given aspect ratio, it crops the image into multiple smaller patches and concatenates them with the base image embedding. One particularity is that the model uses bidirectional attention on all the image tokens. In addition, the model interleaves sliding window local attention with full causal attention in the language backbone, where each sixth layer is a full causal attention layer.\n+\n+This model was contributed by [Ryan Mullins](https://huggingface.co/RyanMullins), [Raushan Turganbay](https://huggingface.co/RaushanTurganbay) [Arthur Zucker](https://huggingface.co/ArthurZ), and [Pedro Cuenca](https://huggingface.co/pcuenq).\n+\n+\n+## Usage tips\n+\n+\n+- For image+text and image-only inputs use `Gemma3ForConditionalGeneration`.\n+- For text-only inputs use `Gemma3ForCausalLM` for generation to avoid loading the vision tower.\n+- Each sample can contain multiple images, and the number of images can vary between samples. However, make sure to pass correctly batched images to the processor, where each batch is a list of one or more images.\n+- The text passed to the processor should have a `<start_of_image>` token wherever an image should be inserted.\n+- The processor has its own `apply_chat_template` method to convert chat messages to model inputs. See the examples below for more details on how to use it.\n+\n+\n+### Image cropping for high resolution images\n+\n+The model supports cropping images into smaller patches when the image aspect ratio exceeds a certain value. By default the images are not cropped and only the base image is forwarded to the model. Users can set `do_pan_and_scan=True` to obtain several crops per image along with the base image to improve the quality in DocVQA or similar tasks requiring higher resolution images.\n+\n+Pan and scan is an inference time optimization to handle images with skewed aspect ratios. When enabled, it improves performance on tasks related to document understanding, infographics, OCR, etc.\n+\n+```python\n+\n+processor = AutoProcessor.from_pretrained(\"google/gemma-3-4b-it\", padding_side=\"left\")\n+\n+url = \"https://media.istockphoto.com/id/1192867753/photo/cow-in-berchida-beach-siniscola.jpg?s=612x612&w=0&k=20&c=v0hjjniwsMNfJSuKWZuIn8pssmD5h5bSN1peBd1CmH4=\"\n+messages = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are a helpful assistant.\"}\n+        ]\n+    },\n+    {\n+        \"role\": \"user\", \"content\": [\n+            {\"type\": \"image\", \"url\": url},\n+            {\"type\": \"text\", \"text\": \"What is shown in this image?\"},\n+        ]\n+    },\n+]\n+inputs = processor.apply_chat_template(\n+    messages,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\",\n+    add_generation_prompt=True,\n+    do_pan_and_scan=True,\n+).to(model.device)\n+\n+```\n+\n+\n+## Usage Example\n+\n+### Single-image Inference\n+\n+```python\n+from transformers import AutoProcessor, Gemma3ForConditionalGeneration\n+\n+model_id = \"google/gemma-3-4b-it\"\n+model = Gemma3ForConditionalGeneration.from_pretrained(model_id, device_map=\"auto\")\n+processor = AutoProcessor.from_pretrained(model_id, padding_side=\"left\")\n+\n+url = \"https://media.istockphoto.com/id/1192867753/photo/cow-in-berchida-beach-siniscola.jpg?s=612x612&w=0&k=20&c=v0hjjniwsMNfJSuKWZuIn8pssmD5h5bSN1peBd1CmH4=\"\n+messages = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are a helpful assistant.\"}\n+        ]\n+    },\n+    {\n+        \"role\": \"user\", \"content\": [\n+            {\"type\": \"image\", \"url\": url},\n+            {\"type\": \"text\", \"text\": \"What is shown in this image?\"},\n+        ]\n+    },\n+]\n+inputs = processor.apply_chat_template(\n+    messages,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\",\n+    add_generation_prompt=True,\n+).to(model.device)\n+\n+output = model.generate(**inputs, max_new_tokens=50)\n+print(processor.decode(output[0], skip_special_tokens=True)[inputs.input_ids.shape[1]: ])\n+```\n+\n+### Multi-image Inference\n+\n+```python\n+model_id = \"google/gemma-3-4b-it\"\n+model = Gemma3ForConditionalGeneration.from_pretrained(model_id, device_map=\"auto\")\n+processor = AutoProcessor.from_pretrained(model_id, padding_side=\"left\")\n+\n+url_cow = \"https://media.istockphoto.com/id/1192867753/photo/cow-in-berchida-beach-siniscola.jpg?s=612x612&w=0&k=20&c=v0hjjniwsMNfJSuKWZuIn8pssmD5h5bSN1peBd1CmH4=\"\n+url_stop = \"https://www.ilankelman.org/stopsigns/australia.jpg\"\n+messages = [\n+    {\n+        \"role\": \"system\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"You are a helpful assistant.\"}\n+        ]\n+    },\n+    {\n+        \"role\": \"user\", \"content\": [\n+            {\"type\": \"image\", \"url\": url_cow},\n+            {\"type\": \"image\", \"url\": url_stop},\n+            {\"type\": \"text\", \"text\": \"Are these two images identical?\"},\n+        ]\n+    },\n+]\n+inputs = processor.apply_chat_template(\n+    messages,\n+    tokenize=True,\n+    return_dict=True,\n+    return_tensors=\"pt\",\n+    add_generation_prompt=True,\n+).to(model.device)\n+\n+output = model.generate(**inputs, max_new_tokens=50)\n+print(processor.decode(output[0], skip_special_tokens=True)[inputs.input_ids.shape[1]: ])\n+\n+```\n+\n+### Text-only inference\n+\n+You can use the VLMs for text-only generation by omitting images in your input. However, you can also load the models in text-only mode as shown below. This will skip loading the vision tower and will save resources when you just need the LLM capabilities.\n+```python\n+from transformers import AutoTokenizer, Gemma3ForCausalLM\n+\n+model_id = \"google/gemma-3-1b-it\"\n+\n+tokenizer = AutoTokenizer.from_pretrained(model_id)\n+model = Gemma3ForCausalLM.from_pretrained(model_id, device_map=\"auto\")\n+\n+input_ids = tokenizer(\"Write me a poem about Machine Learning.\", return_tensors=\"pt\").to(model.device)\n+\n+outputs = model.generate(**input_ids, max_new_tokens=100)\n+text = tokenizer.batch_decode(outputs, skip_special_tokens=True)\n+\n+print(text)\n+\n+```\n+\n+\n+## Gemma3ImageProcessor\n+\n+[[autodoc]] Gemma3ImageProcessor\n+\n+## Gemma3ImageProcessorFast\n+\n+[[autodoc]] Gemma3ImageProcessorFast\n+\n+## Gemma3Processor\n+\n+[[autodoc]] Gemma3Processor\n+\n+## Gemma3TextConfig\n+\n+[[autodoc]] Gemma3TextConfig\n+\n+## Gemma3Config\n+\n+[[autodoc]] Gemma3Config\n+\n+## Gemma3TextModel\n+\n+[[autodoc]] Gemma3TextModel\n+    - forward\n+\n+## Gemma3ForCausalLM\n+\n+[[autodoc]] Gemma3ForCausalLM\n+    - forward\n+\n+## Gemma3ForConditionalGeneration\n+\n+[[autodoc]] Gemma3ForConditionalGeneration\n+    - forward"
        },
        {
            "sha": "9ce1fe1378bf985ea1bc9b8f5afca5ed5c9d01bc",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 21,
            "deletions": 1,
            "changes": 22,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -474,6 +474,7 @@\n     \"models.fuyu\": [\"FuyuConfig\"],\n     \"models.gemma\": [\"GemmaConfig\"],\n     \"models.gemma2\": [\"Gemma2Config\"],\n+    \"models.gemma3\": [\"Gemma3Config\", \"Gemma3Processor\", \"Gemma3TextConfig\"],\n     \"models.git\": [\n         \"GitConfig\",\n         \"GitProcessor\",\n@@ -1259,6 +1260,7 @@\n     _import_structure[\"models.emu3\"].append(\"Emu3ImageProcessor\")\n     _import_structure[\"models.flava\"].extend([\"FlavaFeatureExtractor\", \"FlavaImageProcessor\", \"FlavaProcessor\"])\n     _import_structure[\"models.fuyu\"].extend([\"FuyuImageProcessor\", \"FuyuProcessor\"])\n+    _import_structure[\"models.gemma3\"].append(\"Gemma3ImageProcessor\")\n     _import_structure[\"models.glpn\"].extend([\"GLPNFeatureExtractor\", \"GLPNImageProcessor\"])\n     _import_structure[\"models.got_ocr2\"].extend([\"GotOcr2ImageProcessor\"])\n     _import_structure[\"models.grounding_dino\"].extend([\"GroundingDinoImageProcessor\"])\n@@ -1332,6 +1334,7 @@\n     _import_structure[\"models.deit\"].append(\"DeiTImageProcessorFast\")\n     _import_structure[\"models.depth_pro\"].append(\"DepthProImageProcessorFast\")\n     _import_structure[\"models.detr\"].append(\"DetrImageProcessorFast\")\n+    _import_structure[\"models.gemma3\"].append(\"Gemma3ImageProcessorFast\")\n     _import_structure[\"models.got_ocr2\"].append(\"GotOcr2ImageProcessorFast\")\n     _import_structure[\"models.llava\"].append(\"LlavaImageProcessorFast\")\n     _import_structure[\"models.llava_next\"].append(\"LlavaNextImageProcessorFast\")\n@@ -2452,6 +2455,14 @@\n             \"Gemma2PreTrainedModel\",\n         ]\n     )\n+    _import_structure[\"models.gemma3\"].extend(\n+        [\n+            \"Gemma3ForCausalLM\",\n+            \"Gemma3ForConditionalGeneration\",\n+            \"Gemma3PreTrainedModel\",\n+            \"Gemma3TextModel\",\n+        ]\n+    )\n     _import_structure[\"models.git\"].extend(\n         [\n             \"GitForCausalLM\",\n@@ -2554,14 +2565,14 @@\n             \"GraniteMoePreTrainedModel\",\n         ]\n     )\n+\n     _import_structure[\"models.granitemoeshared\"].extend(\n         [\n             \"GraniteMoeSharedForCausalLM\",\n             \"GraniteMoeSharedModel\",\n             \"GraniteMoeSharedPreTrainedModel\",\n         ]\n     )\n-\n     _import_structure[\"models.grounding_dino\"].extend(\n         [\n             \"GroundingDinoForObjectDetection\",\n@@ -5629,6 +5640,7 @@\n     from .models.fuyu import FuyuConfig\n     from .models.gemma import GemmaConfig\n     from .models.gemma2 import Gemma2Config\n+    from .models.gemma3 import Gemma3Config, Gemma3Processor, Gemma3TextConfig\n     from .models.git import (\n         GitConfig,\n         GitProcessor,\n@@ -6450,6 +6462,7 @@\n             FlavaProcessor,\n         )\n         from .models.fuyu import FuyuImageProcessor, FuyuProcessor\n+        from .models.gemma3 import Gemma3ImageProcessor\n         from .models.glpn import GLPNFeatureExtractor, GLPNImageProcessor\n         from .models.got_ocr2 import GotOcr2ImageProcessor\n         from .models.grounding_dino import GroundingDinoImageProcessor\n@@ -6535,6 +6548,7 @@\n         from .models.deit import DeiTImageProcessorFast\n         from .models.depth_pro import DepthProImageProcessorFast\n         from .models.detr import DetrImageProcessorFast\n+        from .models.gemma3 import Gemma3ImageProcessorFast\n         from .models.got_ocr2 import GotOcr2ImageProcessorFast\n         from .models.llava import LlavaImageProcessorFast\n         from .models.llava_next import LlavaNextImageProcessorFast\n@@ -7461,6 +7475,12 @@\n             Gemma2Model,\n             Gemma2PreTrainedModel,\n         )\n+        from .models.gemma3 import (\n+            Gemma3ForCausalLM,\n+            Gemma3ForConditionalGeneration,\n+            Gemma3PreTrainedModel,\n+            Gemma3TextModel,\n+        )\n         from .models.git import (\n             GitForCausalLM,\n             GitModel,"
        },
        {
            "sha": "93b083d7bed565ee465b36b3a84a307066f78399",
            "filename": "src/transformers/convert_slow_tokenizer.py",
            "status": "modified",
            "additions": 11,
            "deletions": 9,
            "changes": 20,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fconvert_slow_tokenizer.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fconvert_slow_tokenizer.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fconvert_slow_tokenizer.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -113,10 +113,10 @@ def extract(self, vocab_scores=None) -> Tuple[Dict[str, int], List[Tuple]]:\n         sp = self.sp\n         vocab = {sp.id_to_piece(index): index for index in range(sp.GetPieceSize())}\n \n-        # there is a missing token in the vocab. We have to do this to support merges\n+        # If \"\\t\" is missing in the vocab, we have to do this to support merges\n         # \"<0x09>\" is the bytefallback for `\\t`\n-        vocab[\"\\t\"] = vocab.get(\"<0x09>\")\n-\n+        if \"\\t\" not in vocab:\n+            vocab[\"\\t\"] = vocab.get(\"<0x09>\")\n         merges = generate_merges(vocab, vocab_scores)\n         return vocab, merges\n \n@@ -1296,12 +1296,14 @@ def vocab(self, proto):\n             (self.original_tokenizer.eos_token, 0.0),\n             (self.original_tokenizer.bos_token, 0.0),\n         ]\n-        for piece in proto.pieces[3:]:\n-            if piece.piece == \"<0x09>\":\n-                vocab += [(\"\\t\", piece.score)]\n-            else:\n-                vocab += [(piece.piece, piece.score)]\n-        # vocab += [(piece.piece, piece.score) for piece in proto.pieces[3:]]\n+        vocab += [(piece.piece, piece.score) for piece in proto.pieces[3:]]\n+\n+        # Older gemma tokenizers had a missing tab token, so we fix that here\n+        if not any(x[0] == \"\\t\" for x in vocab):\n+            override_index = next((i for i, x in enumerate(vocab) if x[0] == \"<0x09>\"), None)\n+            if override_index is not None:\n+                vocab[override_index] = (\"\\t\", 0.0)\n+\n         return vocab\n \n     def pre_tokenizer(self, replacement, add_prefix_space):"
        },
        {
            "sha": "14fa63213182b7c9380d3700faf5080516b1394c",
            "filename": "src/transformers/modeling_utils.py",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodeling_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodeling_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodeling_utils.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -849,13 +849,13 @@ def _load_state_dict_into_meta_model(\n     is_quantized = hf_quantizer is not None\n \n     for serialized_param_name, empty_param in state_dict.items():\n+        if serialized_param_name not in expected_keys:\n+            continue\n+\n         # serialized_param_name is the raw, serialized name\n         # fixed_param_name is the model's equivalent\n         fixed_param_name, _ = model.rename_key(serialized_param_name)\n \n-        if fixed_param_name not in expected_keys:\n-            continue\n-\n         # we need to use serialized_param_name as file pointer is untouched\n         if shard_file.endswith(\".safetensors\"):\n             param = file_pointer.get_slice(serialized_param_name)"
        },
        {
            "sha": "c30b97ade727663e92bb7391db18faa0bea4e035",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -106,6 +106,7 @@\n     fuyu,\n     gemma,\n     gemma2,\n+    gemma3,\n     git,\n     glm,\n     glpn,"
        },
        {
            "sha": "3c6b849d8c406ccb6c689f856811cc6a5dce77ed",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -124,6 +124,8 @@\n         (\"fuyu\", \"FuyuConfig\"),\n         (\"gemma\", \"GemmaConfig\"),\n         (\"gemma2\", \"Gemma2Config\"),\n+        (\"gemma3\", \"Gemma3Config\"),\n+        (\"gemma3_text\", \"Gemma3TextConfig\"),\n         (\"git\", \"GitConfig\"),\n         (\"glm\", \"GlmConfig\"),\n         (\"glpn\", \"GLPNConfig\"),\n@@ -459,6 +461,8 @@\n         (\"fuyu\", \"Fuyu\"),\n         (\"gemma\", \"Gemma\"),\n         (\"gemma2\", \"Gemma2\"),\n+        (\"gemma3\", \"Gemma3ForConditionalGeneration\"),\n+        (\"gemma3_text\", \"Gemma3ForCausalLM\"),\n         (\"git\", \"GIT\"),\n         (\"glm\", \"GLM\"),\n         (\"glpn\", \"GLPN\"),\n@@ -748,6 +752,7 @@\n         (\"qwen2_audio_encoder\", \"qwen2_audio\"),\n         (\"clip_text_model\", \"clip\"),\n         (\"aria_text\", \"aria\"),\n+        (\"gemma3_text\", \"gemma3\"),\n         (\"idefics3_vision\", \"idefics3\"),\n         (\"siglip_vision_model\", \"siglip\"),\n         (\"smolvlm_vision\", \"smolvlm\"),"
        },
        {
            "sha": "fedf1070e046bc9c123ec71fd5fa8c2722e87b1c",
            "filename": "src/transformers/models/auto/image_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -86,6 +86,7 @@\n             (\"flava\", (\"FlavaImageProcessor\",)),\n             (\"focalnet\", (\"BitImageProcessor\",)),\n             (\"fuyu\", (\"FuyuImageProcessor\",)),\n+            (\"gemma3\", (\"Gemma3ImageProcessor\", \"Gemma3ImageProcessorFast\")),\n             (\"git\", (\"CLIPImageProcessor\", \"CLIPImageProcessorFast\")),\n             (\"glpn\", (\"GLPNImageProcessor\",)),\n             (\"got_ocr2\", (\"GotOcr2ImageProcessor\", \"GotOcr2ImageProcessorFast\")),"
        },
        {
            "sha": "aa0d120b7f57f57f2795e3fb3a0e4610637125d1",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -118,6 +118,7 @@\n         (\"funnel\", (\"FunnelModel\", \"FunnelBaseModel\")),\n         (\"gemma\", \"GemmaModel\"),\n         (\"gemma2\", \"Gemma2Model\"),\n+        (\"gemma3_text\", \"Gemma3TextModel\"),\n         (\"git\", \"GitModel\"),\n         (\"glm\", \"GlmModel\"),\n         (\"glpn\", \"GLPNModel\"),\n@@ -338,6 +339,7 @@\n         (\"fnet\", \"FNetForPreTraining\"),\n         (\"fsmt\", \"FSMTForConditionalGeneration\"),\n         (\"funnel\", \"FunnelForPreTraining\"),\n+        (\"gemma3\", \"Gemma3ForConditionalGeneration\"),\n         (\"gpt-sw3\", \"GPT2LMHeadModel\"),\n         (\"gpt2\", \"GPT2LMHeadModel\"),\n         (\"gpt_bigcode\", \"GPTBigCodeForCausalLM\"),\n@@ -518,6 +520,8 @@\n         (\"fuyu\", \"FuyuForCausalLM\"),\n         (\"gemma\", \"GemmaForCausalLM\"),\n         (\"gemma2\", \"Gemma2ForCausalLM\"),\n+        (\"gemma3\", \"Gemma3ForCausalLM\"),\n+        (\"gemma3_text\", \"Gemma3ForCausalLM\"),\n         (\"git\", \"GitForCausalLM\"),\n         (\"glm\", \"GlmForCausalLM\"),\n         (\"got_ocr2\", \"GotOcr2ForConditionalGeneration\"),\n@@ -824,6 +828,7 @@\n         (\"chameleon\", \"ChameleonForConditionalGeneration\"),\n         (\"emu3\", \"Emu3ForConditionalGeneration\"),\n         (\"fuyu\", \"FuyuForCausalLM\"),\n+        (\"gemma3\", \"Gemma3ForConditionalGeneration\"),\n         (\"git\", \"GitForCausalLM\"),\n         (\"got_ocr2\", \"GotOcr2ForConditionalGeneration\"),\n         (\"idefics\", \"IdeficsForVisionText2Text\"),"
        },
        {
            "sha": "d29d3f8d1a1bc893136620c56dd91ad53c9b27c5",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -63,6 +63,7 @@\n         (\"emu3\", \"Emu3Processor\"),\n         (\"flava\", \"FlavaProcessor\"),\n         (\"fuyu\", \"FuyuProcessor\"),\n+        (\"gemma3\", \"Gemma3Processor\"),\n         (\"git\", \"GitProcessor\"),\n         (\"got_ocr2\", \"GotOcr2Processor\"),\n         (\"grounding-dino\", \"GroundingDinoProcessor\"),"
        },
        {
            "sha": "cb3e921f8ea2ff8c65efd2cccdc80b74f2902554",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -215,6 +215,13 @@\n                     \"GemmaTokenizerFast\" if is_tokenizers_available() else None,\n                 ),\n             ),\n+            (\n+                \"gemma3\",\n+                (\n+                    \"GemmaTokenizer\" if is_sentencepiece_available() else None,\n+                    \"GemmaTokenizerFast\" if is_tokenizers_available() else None,\n+                ),\n+            ),\n             (\"git\", (\"BertTokenizer\", \"BertTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"glm\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"gpt-sw3\", (\"GPTSw3Tokenizer\" if is_sentencepiece_available() else None, None)),"
        },
        {
            "sha": "9db0b8368bba85616c38d26d352a76b83c71ade6",
            "filename": "src/transformers/models/gemma2/modeling_gemma2.py",
            "status": "modified",
            "additions": 14,
            "deletions": 45,
            "changes": 59,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma2%2Fmodeling_gemma2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma2%2Fmodeling_gemma2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma2%2Fmodeling_gemma2.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -41,7 +41,6 @@\n     add_code_sample_docstrings,\n     add_start_docstrings,\n     add_start_docstrings_to_model_forward,\n-    is_torchdynamo_compiling,\n     logging,\n     replace_return_docstrings,\n )\n@@ -936,42 +935,23 @@ def prepare_inputs_for_generation(\n     ):\n         # Overwritten: has a special cache type, `HybridCache`\n \n-        # If we have cache: let's slice `input_ids` through `cache_position`, to keep only the unprocessed tokens\n-        # Exception 1: when passing input_embeds, input_ids may be missing entries\n-        # Exception 2: some generation methods do special slicing of input_ids, so we don't need to do it here\n-        # Exception 3: with synced GPUs cache_position may go out of bounds, but we only want dummy token in that case.\n-        #              (we can't check exception 3 while compiling)\n-        if past_key_values is not None:\n-            if (\n-                inputs_embeds is not None  # Exception 1\n-                or (is_torchdynamo_compiling() or cache_position[-1] >= input_ids.shape[1])  # Exception 3\n-            ):\n-                input_ids = input_ids[:, -cache_position.shape[0] :]\n-            elif input_ids.shape[1] != cache_position.shape[0]:  # Default case (the \"else\", a no op, is Exception 2)\n-                input_ids = input_ids[:, cache_position]\n-        if attention_mask is not None and position_ids is None:\n-            # create position_ids on the fly for batch generation\n-            position_ids = attention_mask.long().cumsum(-1) - 1\n-            position_ids.masked_fill_(attention_mask == 0, 1)\n-            if past_key_values:\n-                position_ids = position_ids[:, -input_ids.shape[1] :]\n-                # This `clone` call is needed to avoid recapturing cuda graphs with `torch.compile`'s\n-                # `mode=\"reduce-overhead`, as otherwise the input `position_ids` would have various stride\n-                # during the decoding. Here, simply using `.contiguous()` is not sufficient as in the\n-                # batch size = 1 case, `position_ids` is already contiguous but with varying stride\n-                # which retriggers a capture.\n-                position_ids = position_ids.clone(memory_format=torch.contiguous_format)\n-\n-        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n-        if inputs_embeds is not None and cache_position[0] == 0:\n-            model_inputs = {\"inputs_embeds\": inputs_embeds, \"input_ids\": None}\n-        else:\n-            # The clone here is for the same reason as for `position_ids`.\n-            model_inputs = {\"input_ids\": input_ids.clone(memory_format=torch.contiguous_format), \"inputs_embeds\": None}\n+        model_inputs = super().prepare_inputs_for_generation(\n+            input_ids,\n+            past_key_values=past_key_values,\n+            attention_mask=attention_mask,\n+            inputs_embeds=inputs_embeds,\n+            cache_position=cache_position,\n+            position_ids=position_ids,\n+            use_cache=use_cache,\n+            logits_to_keep=logits_to_keep,\n+            **kwargs,\n+        )\n \n         # This is needed to correctly slice the mask without data-dependent slicing later on if using dynamo tracing\n         # (retrieving the same value from `cache_position` later on would crash dynamo)\n         model_inputs[\"last_cache_position\"] = attention_mask.shape[-1] if attention_mask is not None else 0\n+        if logits_to_keep is None:\n+            _ = model_inputs.pop(\"logits_to_keep\", None)\n \n         if (\n             isinstance(past_key_values, HybridCache)\n@@ -994,19 +974,8 @@ def prepare_inputs_for_generation(\n                 cache_position=cache_position,\n                 batch_size=batch_size,\n             )\n+            model_inputs[\"attention_mask\"] = attention_mask\n \n-        if logits_to_keep is not None:\n-            model_inputs[\"logits_to_keep\"] = logits_to_keep\n-\n-        model_inputs.update(\n-            {\n-                \"position_ids\": position_ids,\n-                \"cache_position\": cache_position,\n-                \"past_key_values\": past_key_values,\n-                \"use_cache\": use_cache,\n-                \"attention_mask\": attention_mask,\n-            }\n-        )\n         return model_inputs\n \n "
        },
        {
            "sha": "0f32c00287e7f58c57b9e1f855df21c5f740023a",
            "filename": "src/transformers/models/gemma2/modular_gemma2.py",
            "status": "modified",
            "additions": 15,
            "deletions": 45,
            "changes": 60,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma2%2Fmodular_gemma2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma2%2Fmodular_gemma2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma2%2Fmodular_gemma2.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -29,7 +29,7 @@\n )\n from ...modeling_utils import ALL_ATTENTION_FUNCTIONS\n from ...processing_utils import Unpack\n-from ...utils import is_torchdynamo_compiling, logging\n+from ...utils import logging\n from ..gemma.modeling_gemma import (\n     GemmaAttention,\n     GemmaForCausalLM,\n@@ -686,42 +686,23 @@ def prepare_inputs_for_generation(\n     ):\n         # Overwritten: has a special cache type, `HybridCache`\n \n-        # If we have cache: let's slice `input_ids` through `cache_position`, to keep only the unprocessed tokens\n-        # Exception 1: when passing input_embeds, input_ids may be missing entries\n-        # Exception 2: some generation methods do special slicing of input_ids, so we don't need to do it here\n-        # Exception 3: with synced GPUs cache_position may go out of bounds, but we only want dummy token in that case.\n-        #              (we can't check exception 3 while compiling)\n-        if past_key_values is not None:\n-            if (\n-                inputs_embeds is not None  # Exception 1\n-                or (is_torchdynamo_compiling() or cache_position[-1] >= input_ids.shape[1])  # Exception 3\n-            ):\n-                input_ids = input_ids[:, -cache_position.shape[0] :]\n-            elif input_ids.shape[1] != cache_position.shape[0]:  # Default case (the \"else\", a no op, is Exception 2)\n-                input_ids = input_ids[:, cache_position]\n-        if attention_mask is not None and position_ids is None:\n-            # create position_ids on the fly for batch generation\n-            position_ids = attention_mask.long().cumsum(-1) - 1\n-            position_ids.masked_fill_(attention_mask == 0, 1)\n-            if past_key_values:\n-                position_ids = position_ids[:, -input_ids.shape[1] :]\n-                # This `clone` call is needed to avoid recapturing cuda graphs with `torch.compile`'s\n-                # `mode=\"reduce-overhead`, as otherwise the input `position_ids` would have various stride\n-                # during the decoding. Here, simply using `.contiguous()` is not sufficient as in the\n-                # batch size = 1 case, `position_ids` is already contiguous but with varying stride\n-                # which retriggers a capture.\n-                position_ids = position_ids.clone(memory_format=torch.contiguous_format)\n-\n-        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n-        if inputs_embeds is not None and cache_position[0] == 0:\n-            model_inputs = {\"inputs_embeds\": inputs_embeds, \"input_ids\": None}\n-        else:\n-            # The clone here is for the same reason as for `position_ids`.\n-            model_inputs = {\"input_ids\": input_ids.clone(memory_format=torch.contiguous_format), \"inputs_embeds\": None}\n+        model_inputs = super().prepare_inputs_for_generation(\n+            input_ids,\n+            past_key_values=past_key_values,\n+            attention_mask=attention_mask,\n+            inputs_embeds=inputs_embeds,\n+            cache_position=cache_position,\n+            position_ids=position_ids,\n+            use_cache=use_cache,\n+            logits_to_keep=logits_to_keep,\n+            **kwargs,\n+        )\n \n         # This is needed to correctly slice the mask without data-dependent slicing later on if using dynamo tracing\n         # (retrieving the same value from `cache_position` later on would crash dynamo)\n         model_inputs[\"last_cache_position\"] = attention_mask.shape[-1] if attention_mask is not None else 0\n+        if logits_to_keep is None:\n+            _ = model_inputs.pop(\"logits_to_keep\", None)\n \n         if (\n             isinstance(past_key_values, HybridCache)\n@@ -744,19 +725,8 @@ def prepare_inputs_for_generation(\n                 cache_position=cache_position,\n                 batch_size=batch_size,\n             )\n+            model_inputs[\"attention_mask\"] = attention_mask\n \n-        if logits_to_keep is not None:\n-            model_inputs[\"logits_to_keep\"] = logits_to_keep\n-\n-        model_inputs.update(\n-            {\n-                \"position_ids\": position_ids,\n-                \"cache_position\": cache_position,\n-                \"past_key_values\": past_key_values,\n-                \"use_cache\": use_cache,\n-                \"attention_mask\": attention_mask,\n-            }\n-        )\n         return model_inputs\n \n "
        },
        {
            "sha": "37ec82f91037a6988291c99971b27964b33e5193",
            "filename": "src/transformers/models/gemma3/__init__.py",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3%2F__init__.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -0,0 +1,30 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_gemma3 import *\n+    from .image_processing_gemma3 import *\n+    from .image_processing_gemma3_fast import *\n+    from .modeling_gemma3 import *\n+    from .processing_gemma3 import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "c19a05ba60c407eb349d84e19413e919976489bc",
            "filename": "src/transformers/models/gemma3/configuration_gemma3.py",
            "status": "added",
            "additions": 330,
            "deletions": 0,
            "changes": 330,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fconfiguration_gemma3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fconfiguration_gemma3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3%2Fconfiguration_gemma3.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -0,0 +1,330 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/gemma3/modular_gemma3.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_gemma3.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 Google Inc. HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import Optional\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...modeling_rope_utils import rope_config_validation\n+from ...utils import logging\n+from ..siglip import SiglipVisionConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Gemma3TextConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Gemma3TextModel`]. It is used to instantiate an Gemma3Text\n+    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n+    defaults will yield a similar configuration to that of the Gemma3Text-7B.\n+    e.g. [google/gemma3_text-7b](https://huggingface.co/google/gemma3_text-7b)\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 262208):\n+            Vocabulary size of the Gemma3Text model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Gemma3TextModel`]\n+        hidden_size (`int`, *optional*, defaults to 2304):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 9216):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 26):\n+            Number of hidden layers in the Transformer decoder.\n+        num_attention_heads (`int`, *optional*, defaults to 8):\n+            Number of attention heads for each attention layer in the Transformer decoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 4):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to\n+            `num_attention_heads`.\n+        head_dim (`int`, *optional*, defaults to 256):\n+            The attention head dimension.\n+        hidden_activation (`str` or `function`, *optional*, defaults to `\"gelu_pytorch_tanh\"`):\n+            The non-linear activation function (function or string) in the decoder. Will default to `\"gelu_pytorch_tanh\"`\n+            if not specified. `\"gelu_pytorch_tanh\"` uses an approximation of the `\"gelu\"` activation function.\n+        max_position_embeddings (`int`, *optional*, defaults to 131072):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        pad_token_id (`int`, *optional*, defaults to 0):\n+            Padding token id.\n+        eos_token_id (`int`, *optional*, defaults to 1):\n+            End of stream token id.\n+        bos_token_id (`int`, *optional*, defaults to 2):\n+            Beginning of stream token id.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `True`):\n+            Whether to tie weight embeddings\n+        rope_theta (`float`, *optional*, defaults to 1000000.0):\n+            The base period of the RoPE embeddings.\n+        attention_bias (`bool`, defaults to `False`, *optional*, defaults to `False`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        query_pre_attn_scalar (`float`, *optional*, defaults to 256):\n+            Scaling factor used on the attention scores\n+        sliding_window (`int`, *optional*, defaults to 4096): in Gemma3Text, every other layer uses sliding window attention. This is the\n+            size of the sliding window.\n+        final_logit_softcapping (`float`, *optional*):\n+            Scaling factor when applying tanh softcapping on the logits.\n+        attn_logit_softcapping (`float`, *optional*):\n+            Scaling factor when applying tanh softcapping on the attention scores.\n+        cache_implementation (`str`, *optional*, defaults to `\"hybrid\"`): the cache type to be used with `generate`.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings used in gloabl attention. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n+                    'llama3'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n+                    pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n+                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n+                    `factor` field to infer the suggested value.\n+                `beta_fast` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for extrapolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 32.\n+                `beta_slow` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for interpolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 1.\n+                `short_factor` (`List[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to short contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `long_factor` (`List[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to long contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `low_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to low frequency components of the RoPE\n+                `high_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to high frequency components of the RoPE\n+        rope_local_base_freq (float, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings for local attention.\n+        sliding_window_pattern (`int`, *optional*, defaults to 6):\n+            Pattern for the sliding window attention.\n+\n+    ```python\n+    >>> from transformers import Gemma3TextModel, Gemma3TextConfig\n+    >>> # Initializing a Gemma3Text gemma3_text-7b style configuration\n+    >>> configuration = Gemma3TextConfig()\n+    >>> # Initializing a model from the gemma3_text-7b style configuration\n+    >>> model = Gemma3TextModel(configuration)\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\n+        rope_local_base_freq (float, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings for local attention.\n+        sliding_window_pattern (`int`, *optional*, defaults to 6):\n+            Pattern for the sliding window attention.\n+    \"\"\"\n+\n+    model_type = \"gemma3_text\"\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.up_proj\": \"colwise\",\n+        \"layers.*.mlp.down_proj\": \"rowwise\",\n+    }\n+    base_model_pp_plan = {\n+        \"embed_tokens\": ([\"input_ids\"], [\"inputs_embeds\"]),\n+        \"layers\": ([\"hidden_states\", \"attention_mask\"], [\"hidden_states\"]),\n+        \"norm\": ([\"hidden_states\"], [\"hidden_states\"]),\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=262_208,\n+        hidden_size=2304,\n+        intermediate_size=9216,\n+        num_hidden_layers=26,\n+        num_attention_heads=8,\n+        num_key_value_heads=4,\n+        head_dim=256,\n+        hidden_activation=\"gelu_pytorch_tanh\",\n+        max_position_embeddings=131_072,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-6,\n+        use_cache=True,\n+        pad_token_id=0,\n+        eos_token_id=1,\n+        bos_token_id=2,\n+        tie_word_embeddings=True,\n+        rope_theta=1_000_000.0,\n+        attention_bias=False,\n+        attention_dropout=0.0,\n+        query_pre_attn_scalar=256,\n+        sliding_window=4096,\n+        final_logit_softcapping=None,\n+        attn_logit_softcapping=None,\n+        cache_implementation=\"hybrid\",\n+        rope_scaling=None,\n+        rope_local_base_freq=10_000.0,\n+        sliding_window_pattern=6,\n+        **kwargs,\n+    ):\n+        super().__init__(\n+            pad_token_id=pad_token_id,\n+            bos_token_id=bos_token_id,\n+            eos_token_id=eos_token_id,\n+            tie_word_embeddings=tie_word_embeddings,\n+            **kwargs,\n+        )\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.head_dim = head_dim\n+        self.num_key_value_heads = num_key_value_heads\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.attention_bias = attention_bias\n+        self.attention_dropout = attention_dropout\n+        self.hidden_activation = hidden_activation\n+        self.query_pre_attn_scalar = query_pre_attn_scalar\n+        self.sliding_window = sliding_window\n+        self.final_logit_softcapping = final_logit_softcapping\n+        self.attn_logit_softcapping = attn_logit_softcapping\n+        self.cache_implementation = cache_implementation\n+\n+        self.rope_local_base_freq = rope_local_base_freq\n+        # For configuring HybridCache to work with 5:1 attention pattern\n+        self.sliding_window_pattern = sliding_window_pattern\n+        self.rope_scaling = rope_scaling\n+        rope_config_validation(self)\n+\n+\n+class Gemma3Config(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Gemma3ForConditionalGeneration`]. It is used to instantiate an\n+    Gemma3ForConditionalGeneration according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of the PaliGemma-2B.\n+\n+    e.g. [google/gemma-3-4b](https://huggingface.co/google/gemma-3-4b)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        text_config (`Union[Gemma3TextConfig, dict]`, *optional*):\n+            The config object of the text backbone.\n+        vision_config (`Union[AutoConfig, dict]`,  *optional*):\n+            Custom vision config or dict.\n+        mm_tokens_per_image (`int`, *optional*, defaults to 256):\n+            The number of tokens per image embedding.\n+        boi_token_index (`int`, *optional*, defaults to 255999):\n+            The begin-of-image token index to wrap the image prompt.\n+        eoi_token_index (`int`, *optional*, defaults to 256000):\n+            The end-of-image token index to wrap the image prompt.\n+        image_token_index (`int`, *optional*, defaults to 262144):\n+            The image token index to encode the image prompt.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Gemma3ForConditionalGeneration, Gemma3Config, SiglipVisionConfig, Gemma3TextConfig\n+\n+    >>> # Initializing a Siglip-like vision config\n+    >>> vision_config = SiglipVisionConfig()\n+\n+    >>> # Initializing a Gemma3 Text config\n+    >>> text_config = Gemma3TextConfig()\n+\n+    >>> # Initializing a Gemma3 gemma-3-4b style configuration\n+    >>> configuration = Gemma3Config(vision_config, text_config)\n+\n+    >>> # Initializing a model from the gemma-3-4b style configuration\n+    >>> model = Gemma3TextConfig(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"gemma3\"\n+    sub_configs = {\n+        \"text_config\": Gemma3TextConfig,\n+        \"vision_config\": SiglipVisionConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        text_config: Optional[Gemma3TextConfig] = None,\n+        vision_config: Optional[SiglipVisionConfig] = None,\n+        mm_tokens_per_image: int = 256,\n+        boi_token_index: int = 255_999,\n+        eoi_token_index: int = 256_000,\n+        image_token_index: int = 262_144,\n+        initializer_range: float = 0.02,\n+        **kwargs,\n+    ):\n+        if text_config is None:\n+            text_config = Gemma3TextConfig()\n+            logger.info(\"text_config is None, using default Gemma3TextConfig vision config.\")\n+        elif isinstance(text_config, dict):\n+            text_config = Gemma3TextConfig(**text_config)\n+\n+        if isinstance(vision_config, dict):\n+            vision_config = SiglipVisionConfig(**vision_config)\n+        else:\n+            vision_config = SiglipVisionConfig()\n+            logger.info(\n+                \"vision_config is None or incompatible with Gemma3VisionConfig intialization. Gemma3 will be limited \"\n+                \"to text tasks.\"\n+            )\n+\n+        self.text_config = text_config\n+        self.vision_config = vision_config\n+        self.mm_tokens_per_image = mm_tokens_per_image\n+        self.boi_token_index = boi_token_index\n+        self.eoi_token_index = eoi_token_index\n+        self.image_token_index = image_token_index\n+        self.initializer_range = initializer_range\n+\n+        super().__init__(**kwargs)\n+\n+\n+__all__ = [\"Gemma3Config\", \"Gemma3TextConfig\"]"
        },
        {
            "sha": "28c0192cc78c555ce991cd756380b7b29c1b265a",
            "filename": "src/transformers/models/gemma3/convert_gemma3_weights_orbax_to_hf.py",
            "status": "added",
            "additions": 592,
            "deletions": 0,
            "changes": 592,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fconvert_gemma3_weights_orbax_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fconvert_gemma3_weights_orbax_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3%2Fconvert_gemma3_weights_orbax_to_hf.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -0,0 +1,592 @@\n+# coding=utf-8\n+# Copyright 2025 Google Inc. HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+r\"\"\"Utility to convert Gemma models from Orbax to HF Transformers checkpoint.\n+\n+python -m transformers.models.gemma3.convert_gemma3_weights_orbax_to_hf \\\n+    --variant='gemma3_4b' \\\n+    --tokenizer_path=\"$HOME/gemma3/tokenizer/gemma3_cleaned_262144_v2.spiece.model\" \\\n+    --checkpoint_path=\"$HOME/gemma3/gemma3_4b_pt_orbax/\" \\\n+    --output_path=\"$HOME/gemma3/gemma3_4b_pt_safetensors/\" \\\n+    --precision='bfloat16'\n+\"\"\"\n+\n+import dataclasses\n+from collections.abc import Iterator, Sequence\n+from typing import Any\n+\n+import accelerate\n+import numpy as np\n+import torch\n+import tree\n+from absl import app, flags, logging\n+from orbax import checkpoint as obc\n+\n+from ...image_utils import PILImageResampling\n+from ..gemma import GemmaTokenizerFast\n+from . import (\n+    Gemma3ForCausalLM,\n+    Gemma3ForConditionalGeneration,\n+    Gemma3ImageProcessor,\n+    Gemma3Processor,\n+)\n+from .configuration_gemma3 import (\n+    Gemma3Config,\n+    Gemma3TextConfig,\n+    SiglipVisionConfig,\n+)\n+\n+\n+# ==== Internal Constants and Classes ====\n+\n+\n+_CHAT_TEMPLATE = \"\"\"{{ bos_token }}\n+{%- if messages[0]['role'] == 'system' -%}\n+    {%- if messages[0]['content'] is string -%}\n+        {%- set first_user_prefix = messages[0]['content'] + '\\n\\n' -%}\n+    {%- else -%}\n+        {%- set first_user_prefix = messages[0]['content'][0]['text'] + '\\n\\n' -%}\n+    {%- endif -%}\n+    {%- set loop_messages = messages[1:] -%}\n+{%- else -%}\n+    {%- set first_user_prefix = \"\" -%}\n+    {%- set loop_messages = messages -%}\n+{%- endif -%}\n+{%- for message in loop_messages -%}\n+    {%- if (message['role'] == 'user') != (loop.index0 % 2 == 0) -%}\n+        {{ raise_exception(\"Conversation roles must alternate user/assistant/user/assistant/...\") }}\n+    {%- endif -%}\n+    {%- if (message['role'] == 'assistant') -%}\n+        {%- set role = \"model\" -%}\n+    {%- else -%}\n+        {%- set role = message['role'] -%}\n+    {%- endif -%}\n+    {{ '<start_of_turn>' + role + '\\n' + (first_user_prefix if loop.first else \"\") }}\n+    {%- if message['content'] is string -%}\n+        {{ message['content'] | trim }}\n+    {%- elif message['content'] is iterable -%}\n+        {%- for item in message['content'] -%}\n+            {%- if item['type'] == 'image' -%}\n+                {{ '<start_of_image>' }}\n+            {%- elif item['type'] == 'text' -%}\n+                {{ item['text'] | trim }}\n+            {%- endif -%}\n+        {%- endfor -%}\n+    {%- else -%}\n+        {{ raise_exception(\"Invalid content type\") }}\n+    {%- endif -%}\n+    {{ '<end_of_turn>\\n' }}\n+{%- endfor -%}\n+{%- if add_generation_prompt -%}\n+    {{'<start_of_turn>model\\n'}}\n+{%- endif -%}\n+\"\"\"\n+\n+_DTYPES = {\n+    \"float32\": torch.float32,\n+    \"bfloat16\": torch.bfloat16,\n+    \"float16\": torch.float16,\n+}\n+\n+_SIGLIP_BASE = \"SigLiPFromPatches_0/siglip_encoder\"\n+_SIGLIP_EMBEDDING = \"SigLiPFromPatches_0/siglip_encoder/embedding\"\n+_SIGLIP_TRANSFORMER_ENCODER_BLOCK = \"SigLiPFromPatches_0/siglip_encoder/Transformer/encoderblock_\"\n+_SIGLIP_TRANSFORMER_ENCODER_BLOCK_LEN = len(_SIGLIP_TRANSFORMER_ENCODER_BLOCK)\n+_SIGLIP_TRANSFORMER_ENCODER_NORM = \"SigLiPFromPatches_0/siglip_encoder/Transformer/encoder_norm\"\n+\n+_TRANSFORMER_DECODER_BLOCK = \"transformer/layer_\"\n+_TRANSFORMER_DECODER_BLOCK_LEN = len(_TRANSFORMER_DECODER_BLOCK)\n+_TRANSFORMER_EMBEDDER = \"transformer/embedder\"\n+_TRANSFORMER_FINAL_NORM = \"transformer/final_norm\"\n+_TRANSFORMER_POST_TRAINING_PREFIX = \"rlx_networks/policy_network/\"\n+_TRANSFORMER_POST_TRAINING_PREFIX_LEN = len(_TRANSFORMER_POST_TRAINING_PREFIX)\n+\n+_VISION_CONFIG = {\n+    \"hidden_size\": 1152,\n+    \"intermediate_size\": 4304,\n+    \"num_hidden_layers\": 27,\n+    \"num_attention_heads\": 16,\n+    \"num_channels\": 3,\n+    \"image_size\": 896,\n+    \"patch_size\": 14,\n+    \"hidden_act\": \"gelu_pytorch_tanh\",\n+    \"layer_norm_eps\": 1e-6,\n+    \"attention_dropout\": 0.0,\n+    \"vision_use_head\": False,\n+}\n+\n+_VARIANT_GEMMA_3_1B = \"gemma3_1b\"\n+_VARIANT_GEMMA_3_4B = \"gemma3_4b\"\n+_VARIANT_GEMMA_3_12B = \"gemma3_12b\"\n+_VARIANT_GEMMA_3_27B = \"gemma3_27b\"\n+_VARIANTS = {\n+    _VARIANT_GEMMA_3_1B: Gemma3Config(\n+        text_config=Gemma3TextConfig(\n+            vocab_size=262_144,\n+            hidden_size=1152,\n+            intermediate_size=6 * 1152,\n+            num_attention_heads=4,\n+            num_hidden_layers=26,\n+            num_key_value_heads=1,\n+            head_dim=256,\n+            sliding_window=512,\n+            rope_theta=1_000_000,  # used for global RoPE only\n+            rope_local_base_freq=10_000,\n+            attn_logit_softcapping=None,\n+            query_pre_attn_scalar=256,\n+            max_position_embeddings=32_768,\n+        ),\n+        vision_config=None,\n+    ),\n+    _VARIANT_GEMMA_3_4B: Gemma3Config(\n+        text_config=Gemma3TextConfig(\n+            vocab_size=262_208,\n+            hidden_size=2560,\n+            intermediate_size=2560 * 8 // 2,\n+            num_attention_heads=8,\n+            head_dim=256,\n+            num_hidden_layers=34,\n+            num_key_value_heads=4,\n+            sliding_window=1024,\n+            rope_scaling={\"rope_type\": \"linear\", \"factor\": 8.0},  # used for global RoPE only\n+            rope_theta=1_000_000,\n+            rope_local_base_freq=10_000,\n+            attn_logit_softcapping=None,\n+            query_pre_attn_scalar=256,\n+        ),\n+        vision_config=_VISION_CONFIG,\n+    ),\n+    _VARIANT_GEMMA_3_12B: Gemma3Config(\n+        text_config=Gemma3TextConfig(\n+            vocab_size=262_208,\n+            hidden_size=30 * 128,\n+            intermediate_size=30 * 128 * 8 // 2,\n+            num_attention_heads=16,\n+            head_dim=256,\n+            num_hidden_layers=48,\n+            num_key_value_heads=8,\n+            sliding_window=1024,\n+            rope_scaling={\"rope_type\": \"linear\", \"factor\": 8.0},  # used for global RoPE only\n+            rope_theta=1_000_000,\n+            rope_local_base_freq=10_000,\n+            attn_logit_softcapping=None,\n+            query_pre_attn_scalar=256,\n+        ),\n+        vision_config=_VISION_CONFIG,\n+    ),\n+    _VARIANT_GEMMA_3_27B: Gemma3Config(\n+        text_config=Gemma3TextConfig(\n+            vocab_size=262_208,\n+            hidden_size=42 * 128,\n+            intermediate_size=42 * 128 * 8 // 2,\n+            num_attention_heads=32,\n+            num_hidden_layers=62,\n+            num_key_value_heads=16,\n+            head_dim=128,\n+            sliding_window=1024,\n+            rope_scaling={\"rope_type\": \"linear\", \"factor\": 8.0},  # used for global RoPE only\n+            rope_theta=1_000_000,\n+            rope_local_base_freq=10_000,\n+            attn_logit_softcapping=None,\n+            query_pre_attn_scalar=(42 * 128 // 32),  # 1 / sqrt(hidden_size // num_attention_heads)\n+        ),\n+        vision_config=_VISION_CONFIG,\n+    ),\n+}\n+\n+# ==== Flags ====\n+\n+CHECKPOINT_PATH = flags.DEFINE_string(\n+    name=\"checkpoint_path\",\n+    default=None,\n+    help=\"Path to the Orbax checkpoint.\",\n+    required=True,\n+)\n+\n+INCLUDE_CHAT_TEMPLATE = flags.DEFINE_bool(\n+    name=\"include_chat_template\", default=False, help=\"If true, will save the default chat template with the tokenizer\"\n+)\n+\n+OUTPUT_PATH = flags.DEFINE_string(\n+    name=\"output_path\",\n+    default=None,\n+    help=\"Path to store the HF checkpoint.\",\n+    required=True,\n+)\n+\n+PRECISION = flags.DEFINE_enum(\n+    name=\"precision\",\n+    default=None,\n+    help=\"The floating point precision (aka dtype) of the model.\",\n+    enum_values=set(_DTYPES.keys()),\n+    required=True,\n+)\n+\n+_TEXT_ONLY = flags.DEFINE_bool(\n+    name=\"text_only\",\n+    default=False,\n+    help=(\n+        \"If True, the model is loaded and saved as a Gemma3ForCausalLM, \"\n+        \"otherwise model saed as Gemma3ForConditionalGeneration.\"\n+    ),\n+)\n+\n+TOKENIZER_PATH = flags.DEFINE_string(\n+    name=\"tokenizer_path\",\n+    default=None,\n+    help=\"Path to the SentencePiece model file.\",\n+    required=True,\n+)\n+\n+_VARIANT = flags.DEFINE_enum(\n+    name=\"variant\",\n+    default=_VARIANT_GEMMA_3_4B,\n+    help=\"The model variant to convert.\",\n+    enum_values=set(_VARIANTS.keys()),\n+)\n+\n+\n+def convert_siglip_weight(\n+    config: SiglipVisionConfig,\n+    paths: Sequence[str],\n+    weights: np.ndarray,\n+) -> tuple[str, np.ndarray]:\n+    path, prop = paths\n+    normalized_path: str = \"\"\n+    updated_weights: np.ndarray = None\n+\n+    if path == _SIGLIP_BASE:\n+        normalized_path = \"vision_tower.vision_model.embeddings.position_embedding.weight\"\n+        updated_weights = weights.reshape(-1, config.hidden_size)\n+    elif path == _SIGLIP_EMBEDDING:\n+        if prop == \"kernel\":\n+            normalized_path = \"vision_tower.vision_model.embeddings.patch_embedding.weight\"\n+            updated_weights = weights.transpose(3, 2, 0, 1)\n+        elif prop == \"bias\":\n+            normalized_path = \"vision_tower.vision_model.embeddings.patch_embedding.bias\"\n+            updated_weights = weights\n+        else:\n+            raise ValueError(f\"Unexpected member, `{prop}`, for path `{path}`. Should be `bias` or `kernel`.\")\n+    elif path.startswith(_SIGLIP_TRANSFORMER_ENCODER_BLOCK):\n+        encoder_block_path = path[_SIGLIP_TRANSFORMER_ENCODER_BLOCK_LEN:]\n+        next_path_seperator_idx = encoder_block_path.find(\"/\")\n+        layer_idx = encoder_block_path[:next_path_seperator_idx]\n+        encoder_block_path = encoder_block_path[next_path_seperator_idx:]\n+        normalized_path = f\"vision_tower.vision_model.encoder.layers.{layer_idx}\"\n+\n+        if encoder_block_path.startswith(\"/LayerNorm\"):\n+            normalized_path += \".layer_norm1\" if path.endswith(\"_0\") else \".layer_norm2\"\n+\n+            if prop == \"scale\":\n+                normalized_path += \".weight\"\n+                updated_weights = weights.transpose()\n+            elif prop == \"bias\":\n+                normalized_path += \".bias\"\n+                updated_weights = weights\n+            else:\n+                raise ValueError(f\"Unexpected member, `{prop}`, for path `{path}`. Should be `bias` or `scale`.\")\n+        elif encoder_block_path.startswith(\"/MlpBlock_0\"):\n+            normalized_path += \".mlp.fc1\" if \"/Dense_0\" in encoder_block_path else \".mlp.fc2\"\n+\n+            if prop == \"kernel\":\n+                normalized_path += \".weight\"\n+                updated_weights = weights.transpose()\n+            elif prop == \"bias\":\n+                normalized_path += \".bias\"\n+                updated_weights = weights\n+            else:\n+                raise ValueError(f\"Unexpected member, `{prop}`, for path `{path}`. Should be `bias` or `kernel`.\")\n+        elif encoder_block_path.startswith(\"/MultiHeadDotProductAttention_0\"):\n+            if encoder_block_path.endswith(\"/key\"):\n+                normalized_path += \".self_attn.k_proj\"\n+            elif encoder_block_path.endswith(\"/out\"):\n+                normalized_path += \".self_attn.out_proj\"\n+            elif encoder_block_path.endswith(\"/query\"):\n+                normalized_path += \".self_attn.q_proj\"\n+            elif encoder_block_path.endswith(\"/value\"):\n+                normalized_path += \".self_attn.v_proj\"\n+            else:\n+                raise ValueError(f\"Unexpected path `{path}` in SigLIP Transformer MultiHeadDotProductAttention_0.\")\n+\n+            if prop == \"bias\":\n+                normalized_path += \".bias\"\n+                updated_weights = weights.reshape(-1, config.hidden_size).reshape(-1)\n+            elif prop == \"kernel\":\n+                normalized_path += \".weight\"\n+                updated_weights = weights.reshape(-1, config.hidden_size).transpose()\n+            else:\n+                raise ValueError(f\"Unexpected member, `{prop}`, for path `{path}`. Should be `bias` or `kernel`.\")\n+        else:\n+            raise ValueError(f\"Unexpected path `{path}` in SigLIP Transformer Encoder Block.\")\n+    elif path == _SIGLIP_TRANSFORMER_ENCODER_NORM:\n+        if prop == \"scale\":\n+            normalized_path = \"vision_tower.vision_model.post_layernorm.weight\"\n+            updated_weights = weights.transpose()\n+        elif prop == \"bias\":\n+            normalized_path = \"vision_tower.vision_model.post_layernorm.bias\"\n+            updated_weights = weights\n+        else:\n+            raise ValueError(f\"Unexpected member, `{prop}`, for path `{path}`. Should be `bias` or `scale`.\")\n+    else:\n+        raise ValueError(f\"Unexpected path `{path}`.\")\n+\n+    if \"vision\" in normalized_path:\n+        print(normalized_path)\n+    return normalized_path, updated_weights\n+\n+\n+def convert_transformer_weights(\n+    config: Gemma3TextConfig,\n+    paths: Sequence[str],\n+    weights: np.ndarray,\n+) -> Iterator[tuple[str, np.ndarray]]:\n+    path, prop = paths\n+\n+    if path.startswith(_TRANSFORMER_POST_TRAINING_PREFIX):\n+        path = path[_TRANSFORMER_POST_TRAINING_PREFIX_LEN:]\n+\n+    converted_paths: list[str] = []\n+    converted_weights: list[Any] = []\n+\n+    attn_head_dim = config.num_attention_heads * config.head_dim\n+    kv_head_dim = config.num_key_value_heads * config.head_dim\n+\n+    if path == _TRANSFORMER_EMBEDDER:\n+        if prop == \"input_embedding\":\n+            # Tied to language_model.lm_head.weight, assigned at the end.\n+            converted_paths = [\"language_model.model.embed_tokens.weight\"]\n+\n+            if not _TEXT_ONLY.value:\n+                # Gemma3 model doesn't have image soft token in input and output embeddings, resize to avoid bugs we had with Mllama\n+                pre_expansion_embeddings = weights\n+                mu = np.mean(pre_expansion_embeddings, axis=0)\n+                sigma = np.cov(pre_expansion_embeddings, rowvar=False, bias=True)\n+                new_embeddings = np.random.multivariate_normal(mu, 1e-5 * sigma, size=64)\n+                weights = np.vstack([pre_expansion_embeddings, new_embeddings])\n+\n+            converted_weights = [weights]\n+        elif _TEXT_ONLY.value or prop in (\"mm_output_embedding\", \"mm_input_embedding_extra\"):\n+            return zip([], [])\n+        else:\n+            raise ValueError(f\"Unexpected member, {prop}, in Embedder.\")\n+    elif path.startswith(f\"{_TRANSFORMER_EMBEDDER}/mm\"):\n+        if _TEXT_ONLY.value:\n+            return zip([], [])\n+\n+        if path.endswith(\"/mm_input_projection\"):\n+            converted_paths = [\"multi_modal_projector.mm_input_projection_weight\"]\n+            converted_weights = [weights]\n+        elif path.endswith(\"/mm_soft_embedding_norm\"):\n+            converted_paths = [\"multi_modal_projector.mm_soft_emb_norm.weight\"]\n+            converted_weights = [weights]\n+        else:\n+            raise ValueError(f\"Unexpected subpath, `{path}`, in Embedder.\")\n+    elif path == _TRANSFORMER_FINAL_NORM:\n+        converted_paths = [\"language_model.model.norm.weight\"]\n+        converted_weights = [weights]\n+    elif path.startswith(_TRANSFORMER_DECODER_BLOCK):\n+        decoder_block_path = path[_TRANSFORMER_DECODER_BLOCK_LEN:]\n+        next_path_seperator_idx = decoder_block_path.find(\"/\")\n+        layer_idx = decoder_block_path[:next_path_seperator_idx]\n+        decoder_block_path = decoder_block_path[next_path_seperator_idx:]\n+\n+        base_path = f\"language_model.model.layers.{layer_idx}\"\n+\n+        if path.endswith(\"attn/attn_vec_einsum\"):\n+            converted_paths = [f\"{base_path}.self_attn.o_proj.weight\"]\n+            converted_weights = [weights.transpose(2, 0, 1).reshape(config.hidden_size, attn_head_dim)]\n+        elif path.endswith(\"attn/_key_norm\"):\n+            converted_paths = [f\"{base_path}.self_attn.k_norm.weight\"]\n+            converted_weights = [weights]\n+        elif path.endswith(\"attn/kv_einsum\"):\n+            converted_paths = [\n+                f\"{base_path}.self_attn.k_proj.weight\",\n+                f\"{base_path}.self_attn.v_proj.weight\",\n+            ]\n+            k_proj_weights, v_proj_weights = weights\n+            converted_weights = [\n+                k_proj_weights.transpose(0, 2, 1).reshape(kv_head_dim, config.hidden_size),\n+                v_proj_weights.transpose(0, 2, 1).reshape(kv_head_dim, config.hidden_size),\n+            ]\n+        elif path.endswith(\"attn/q_einsum\"):\n+            converted_paths = [f\"{base_path}.self_attn.q_proj.weight\"]\n+            converted_weights = [weights.transpose(0, 2, 1).reshape(attn_head_dim, config.hidden_size)]\n+        elif path.endswith(\"attn/_query_norm\"):\n+            converted_paths = [f\"{base_path}.self_attn.q_norm.weight\"]\n+            converted_weights = [weights]\n+        elif path.endswith(\"mlp/gating_einsum\"):\n+            converted_paths = [\n+                f\"{base_path}.mlp.gate_proj.weight\",\n+                f\"{base_path}.mlp.up_proj.weight\",\n+            ]\n+            gate_proj_weight, up_proj_weight = weights\n+            converted_weights = [gate_proj_weight, up_proj_weight]\n+        elif path.endswith(\"mlp/linear\"):\n+            converted_paths = [f\"{base_path}.mlp.down_proj.weight\"]\n+            converted_weights = [weights.transpose()]\n+        elif path.endswith(\"post_attention_norm\"):\n+            converted_paths = [f\"{base_path}.post_attention_layernorm.weight\"]\n+            converted_weights = [weights]\n+        elif path.endswith(\"post_ffw_norm\"):\n+            converted_paths = [f\"{base_path}.post_feedforward_layernorm.weight\"]\n+            converted_weights = [weights]\n+        elif path.endswith(\"pre_attention_norm\"):\n+            converted_paths = [f\"{base_path}.input_layernorm.weight\"]\n+            converted_weights = [weights]\n+        elif path.endswith(\"pre_ffw_norm\"):\n+            converted_paths = [f\"{base_path}.pre_feedforward_layernorm.weight\"]\n+            converted_weights = [weights]\n+        else:\n+            raise ValueError(f\"Unexpected path `{path}` in Decoder Block.\")\n+    else:\n+        raise ValueError(f\"Unexpected path `{path}`.\")\n+\n+    if (cpl := len(converted_paths)) != (cwl := len(converted_weights)):\n+        raise ValueError(\n+            \"The `converted_paths` and `converted_weights` should be the same \"\n+            f\"length. Got {cpl} and {cwl}, respectively, for {path}.\"\n+        )\n+\n+    return zip(converted_paths, converted_weights)\n+\n+\n+@dataclasses.dataclass(frozen=True)\n+class ConversionResult:\n+    state_tree: dict[str, torch.Tensor]\n+    config: Gemma3Config\n+\n+\n+def convert(\n+    checkpoint_path: str,\n+    config: Gemma3Config,\n+    target_dtype: torch.dtype,\n+) -> ConversionResult:\n+    \"\"\"Loads Orbax checkpoint from `input_path` and converts it to HF tree.\"\"\"\n+    checkpointer = obc.PyTreeCheckpointer()\n+    ckpt = checkpointer.restore(checkpoint_path)\n+    hf_tree: dict[str, torch.Tensor] = {}\n+\n+    def update_tree(path: str, weights: np.ndarray) -> None:\n+        torch_tensor = torch.from_numpy(weights.astype(\"float32\")).type(target_dtype)\n+        logging.info(\n+            \"%s converted shape=%s with dtype=%s\",\n+            path,\n+            weights.shape,\n+            torch_tensor.dtype,\n+        )\n+        hf_tree[path] = torch_tensor\n+\n+    for paths, value in tree.flatten_with_path(ckpt):\n+        if paths[0].startswith(\"SigLiPFromPatches_\"):\n+            if config.vision_config is None:\n+                continue\n+\n+            path, weights = convert_siglip_weight(config=config.vision_config, paths=paths, weights=value)\n+            update_tree(path, weights)\n+        else:\n+            for path, weights in convert_transformer_weights(config=config.text_config, paths=paths, weights=value):\n+                if config.vision_config is None:\n+                    path = path[len(\"language_model.\") :]\n+\n+                update_tree(path, weights)\n+\n+    if config.vision_config is None:\n+        hf_tree[\"lm_head.weight\"] = hf_tree[\"model.embed_tokens.weight\"]\n+    else:\n+        hf_tree[\"language_model.lm_head.weight\"] = hf_tree[\"language_model.model.embed_tokens.weight\"]\n+\n+    return ConversionResult(state_tree=hf_tree, config=config)\n+\n+\n+def main(*args):\n+    del args\n+\n+    variant = _VARIANT.value\n+    dtype = getattr(torch, PRECISION.value)\n+    config = _VARIANTS[variant]\n+    output_path = OUTPUT_PATH.value\n+\n+    if variant == _VARIANT_GEMMA_3_1B:\n+        flags.FLAGS.set_default(_TEXT_ONLY.name, True)\n+\n+    tokenizer = GemmaTokenizerFast(\n+        TOKENIZER_PATH.value,\n+        add_bos_token=True,\n+        extra_special_tokens={\n+            \"image_token\": \"<image_soft_token>\",  # Should be ID=262_144\n+            \"boi_token\": \"<start_of_image>\",  # Should be ID=255_999\n+            \"eoi_token\": \"<end_of_image>\",  # Should be ID=256_000\n+        },\n+    )\n+\n+    if INCLUDE_CHAT_TEMPLATE.value:\n+        # Include chat template for CausalLM models\n+        tokenizer.chat_template = _CHAT_TEMPLATE\n+        config.eos_token_id = [1, 106]\n+\n+    if _TEXT_ONLY.value:\n+        config.vision_config = None\n+        tokenizer.save_pretrained(output_path)\n+        logging.info(\"Saved GemmaTokenizer for %s to %s\", variant, output_path)\n+        del tokenizer\n+    else:\n+        image_processor = Gemma3ImageProcessor(\n+            image_seq_length=256,\n+            image_mean=(0.5,) * 3,\n+            image_std=(0.5,) * 3,\n+            size={\"height\": 896, \"width\": 896},\n+            resample=PILImageResampling.BILINEAR,\n+        )\n+        processor = Gemma3Processor(\n+            image_processor=image_processor,\n+            tokenizer=tokenizer,\n+        )\n+        if INCLUDE_CHAT_TEMPLATE.value:\n+            # Duplicate so multimodal instruct models can also be used for CausalLM\n+            processor.chat_template = tokenizer.chat_template\n+\n+        processor.save_pretrained(output_path)\n+        logging.info(\"Saved Gemma3Processor for %s to %s\", variant, output_path)\n+        del processor\n+        del tokenizer\n+\n+    logging.info(\"Gemma 3 (%s) configured as: %s\", variant, config)\n+    logging.info(\"Converting Gemma 3 (%s) @ %s\", variant, dtype)\n+    result = convert(CHECKPOINT_PATH.value, config, dtype)\n+    logging.info(\"Converted Gemma 3 (%s) state tree from Orbax to Hugging Face.\", variant)\n+\n+    with accelerate.init_empty_weights():\n+        if config.vision_config is None:\n+            model = Gemma3ForCausalLM(config=config.text_config)\n+        else:\n+            model = Gemma3ForConditionalGeneration(config)\n+\n+    model.load_state_dict(result.state_tree, assign=True, strict=True)\n+    model.config.torch_dtype = dtype\n+    logging.info(\"Loaded Gemma 3 (%s) in Hugging Face Transformers as a %s instance.\", variant, type(model).__name__)\n+    model.save_pretrained(output_path, safe_serialization=True)\n+    logging.info(\n+        \"Saved Gemma 3 (%s) to SafeTensors in %s using %s\",\n+        variant,\n+        output_path,\n+        type(model).__name__,\n+    )\n+    del model\n+    del result\n+\n+\n+if __name__ == \"__main__\":\n+    app.run(main)"
        },
        {
            "sha": "f985a9a9dd8048dd15bb079dca312f4c8e7b7483",
            "filename": "src/transformers/models/gemma3/image_processing_gemma3.py",
            "status": "added",
            "additions": 413,
            "deletions": 0,
            "changes": 413,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fimage_processing_gemma3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fimage_processing_gemma3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3%2Fimage_processing_gemma3.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -0,0 +1,413 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Image processor class for Gemma3.\"\"\"\n+\n+import itertools\n+import math\n+from typing import Dict, List, Optional, Union\n+\n+import numpy as np\n+\n+from ...image_processing_utils import BaseImageProcessor, BatchFeature, get_size_dict\n+from ...image_transforms import (\n+    convert_to_rgb,\n+    resize,\n+    to_channel_dimension_format,\n+)\n+from ...image_utils import (\n+    IMAGENET_STANDARD_MEAN,\n+    IMAGENET_STANDARD_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    is_scaled_image,\n+    make_nested_list_of_images,\n+    to_numpy_array,\n+    valid_images,\n+    validate_preprocess_arguments,\n+)\n+from ...utils import TensorType, filter_out_non_signature_kwargs, is_vision_available, logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+if is_vision_available():\n+    import PIL\n+\n+\n+class Gemma3ImageProcessor(BaseImageProcessor):\n+    r\"\"\"\n+    Constructs a SigLIP image processor.\n+\n+    Args:\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image's (height, width) dimensions to the specified `size`. Can be overridden by\n+            `do_resize` in the `preprocess` method.\n+        size (`Dict[str, int]` *optional*, defaults to `{\"height\": 224, \"width\": 224}`):\n+            Size of the image after resizing. Can be overridden by `size` in the `preprocess` method.\n+        resample (`PILImageResampling`, *optional*, defaults to `Resampling.BILINEAR`):\n+            Resampling filter to use if resizing the image. Can be overridden by `resample` in the `preprocess` method.\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image by the specified scale `rescale_factor`. Can be overridden by `do_rescale` in\n+            the `preprocess` method.\n+        rescale_factor (`int` or `float`, *optional*, defaults to `1/255`):\n+            Scale factor to use if rescaling the image. Can be overridden by `rescale_factor` in the `preprocess`\n+            method.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image by the specified mean and standard deviation. Can be overridden by\n+            `do_normalize` in the `preprocess` method.\n+        image_mean (`float` or `List[float]`, *optional*, defaults to `[0.5, 0.5, 0.5]`):\n+            Mean to use if normalizing the image. This is a float or list of floats the length of the number of\n+            channels in the image. Can be overridden by the `image_mean` parameter in the `preprocess` method.\n+        image_std (`float` or `List[float]`, *optional*, defaults to `[0.5, 0.5, 0.5]`):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats the length of the\n+            number of channels in the image. Can be overridden by the `image_std` parameter in the `preprocess` method.\n+            Can be overridden by the `image_std` parameter in the `preprocess` method.\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB.\n+        do_pan_and_scan (`bool`, *optional*):\n+            Whether to apply `pan_and_scan` to images.\n+        pan_and_scan_min_crop_size (`int`, *optional*):\n+            Minimum size of each crop in pan and scan.\n+        pan_and_scan_max_num_crops (`int`, *optional*):\n+            Maximum number of crops per image in pan and scan.\n+        pan_and_scan_min_ratio_to_activate (`float`, *optional*):\n+            Minimum aspect ratio to activate pan and scan.\n+    \"\"\"\n+\n+    model_input_names = [\"pixel_values\", \"num_crops\"]\n+\n+    def __init__(\n+        self,\n+        do_resize: bool = True,\n+        size: Dict[str, int] = None,\n+        resample: PILImageResampling = PILImageResampling.BILINEAR,\n+        do_rescale: bool = True,\n+        rescale_factor: Union[int, float] = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_convert_rgb: bool = None,\n+        do_pan_and_scan: bool = None,\n+        pan_and_scan_min_crop_size: int = None,\n+        pan_and_scan_max_num_crops: int = None,\n+        pan_and_scan_min_ratio_to_activate: float = None,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        size = size if size is not None else {\"height\": 224, \"width\": 224}\n+        size = get_size_dict(size, default_to_square=True)\n+        image_mean = image_mean if image_mean is not None else IMAGENET_STANDARD_MEAN\n+        image_std = image_std if image_std is not None else IMAGENET_STANDARD_STD\n+\n+        self.do_resize = do_resize\n+        self.size = size\n+        self.resample = resample\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean\n+        self.image_std = image_std\n+        self.do_convert_rgb = do_convert_rgb\n+        self.do_pan_and_scan = do_pan_and_scan\n+        self.pan_and_scan_min_crop_size = pan_and_scan_min_crop_size\n+        self.pan_and_scan_max_num_crops = pan_and_scan_max_num_crops\n+        self.pan_and_scan_min_ratio_to_activate = pan_and_scan_min_ratio_to_activate\n+\n+    def pan_and_scan(\n+        self,\n+        image: np.ndarray,\n+        pan_and_scan_min_crop_size: int,\n+        pan_and_scan_max_num_crops: int,\n+        pan_and_scan_min_ratio_to_activate: float,\n+        data_format: Optional[Union[str, ChannelDimension]] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Pan and Scan and image, by cropping into smaller images when the aspect ratio exceeds\n+        minumum allowed ratio.\n+\n+        Args:\n+            image (`np.ndarray`):\n+                Image to resize.\n+            pan_and_scan_min_crop_size (`int`, *optional*):\n+                Minimum size of each crop in pan and scan.\n+            pan_and_scan_max_num_crops (`int`, *optional*):\n+                Maximum number of crops per image in pan and scan.\n+            pan_and_scan_min_ratio_to_activate (`float`, *optional*):\n+                Minimum aspect ratio to activate pan and scan.\n+            data_format (`str` or `ChannelDimension`, *optional*):\n+                The channel dimension format of the image. If not provided, it will be the same as the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format of the input image. If not provided, it will be inferred.\n+        \"\"\"\n+        height, width = get_image_size(image)\n+\n+        # Square or landscape image.\n+        if width >= height:\n+            # Only apply PaS if the image is sufficiently exaggerated\n+            if width / height < pan_and_scan_min_ratio_to_activate:\n+                return []\n+\n+            # Select ideal number of crops close to the image aspect ratio and such that crop_size > min_crop_size.\n+            num_crops_w = int(math.floor(width / height + 0.5))  # Half round up rounding.\n+            num_crops_w = min(int(math.floor(width / pan_and_scan_min_crop_size)), num_crops_w)\n+\n+            # Make sure the number of crops is in range [2, pan_and_scan_max_num_crops].\n+            num_crops_w = max(2, num_crops_w)\n+            num_crops_w = min(pan_and_scan_max_num_crops, num_crops_w)\n+            num_crops_h = 1\n+\n+        # Portrait image.\n+        else:\n+            # Only apply PaS if the image is sufficiently exaggerated\n+            if height / width < pan_and_scan_min_ratio_to_activate:\n+                return []\n+\n+            # Select ideal number of crops close to the image aspect ratio and such that crop_size > min_crop_size.\n+            num_crops_h = int(math.floor(height / width + 0.5))\n+            num_crops_h = min(int(math.floor(height / pan_and_scan_min_crop_size)), num_crops_h)\n+\n+            # Make sure the number of crops is in range [2, pan_and_scan_max_num_crops].\n+            num_crops_h = max(2, num_crops_h)\n+            num_crops_h = min(pan_and_scan_max_num_crops, num_crops_h)\n+            num_crops_w = 1\n+\n+        crop_size_w = int(math.ceil(width / num_crops_w))\n+        crop_size_h = int(math.ceil(height / num_crops_h))\n+\n+        # Don't apply PaS if crop size is too small.\n+        if min(crop_size_w, crop_size_h) < pan_and_scan_min_crop_size:\n+            return []\n+\n+        crop_positions_w = [crop_size_w * i for i in range(num_crops_w)]\n+        crop_positions_h = [crop_size_h * i for i in range(num_crops_h)]\n+\n+        if input_data_format == ChannelDimension.LAST:\n+            image_crops = [\n+                image[pos_h : pos_h + crop_size_h, pos_w : pos_w + crop_size_w]\n+                for pos_h, pos_w in itertools.product(crop_positions_h, crop_positions_w)\n+            ]\n+        else:\n+            image_crops = [\n+                image[:, pos_h : pos_h + crop_size_h, pos_w : pos_w + crop_size_w]\n+                for pos_h, pos_w in itertools.product(crop_positions_h, crop_positions_w)\n+            ]\n+\n+        return image_crops\n+\n+    def _process_images_for_pan_and_scan(\n+        self,\n+        images: List[np.ndarray],\n+        do_pan_and_scan: bool,\n+        pan_and_scan_min_crop_size: int,\n+        pan_and_scan_max_num_crops: int,\n+        pan_and_scan_min_ratio_to_activate: float,\n+        data_format: Optional[Union[str, ChannelDimension]] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        pas_images_list = []\n+        num_crops = []\n+        for image in images:\n+            pas_images = self.pan_and_scan(\n+                image=image,\n+                pan_and_scan_min_crop_size=pan_and_scan_min_crop_size,\n+                pan_and_scan_max_num_crops=pan_and_scan_max_num_crops,\n+                pan_and_scan_min_ratio_to_activate=pan_and_scan_min_ratio_to_activate,\n+                data_format=data_format,\n+                input_data_format=input_data_format,\n+            )\n+            pas_images_list.extend([image] + pas_images)\n+            num_crops.append(len(pas_images))\n+        return pas_images_list, num_crops\n+\n+    @filter_out_non_signature_kwargs()\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        do_resize: bool = None,\n+        size: Dict[str, int] = None,\n+        resample: PILImageResampling = None,\n+        do_rescale: bool = None,\n+        rescale_factor: float = None,\n+        do_normalize: bool = None,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+        do_convert_rgb: bool = None,\n+        do_pan_and_scan: bool = None,\n+        pan_and_scan_min_crop_size: int = None,\n+        pan_and_scan_max_num_crops: int = None,\n+        pan_and_scan_min_ratio_to_activate: float = None,\n+    ) -> PIL.Image.Image:\n+        \"\"\"\n+        Preprocess an image or batch of images.\n+\n+        Args:\n+            images (`ImageInput`):\n+                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n+                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing.\n+            resample (`int`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n+                has an effect if `do_resize` is set to `True`.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n+                `True`.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                - Unset: Return a list of `np.ndarray`.\n+                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n+                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n+            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n+                from the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            do_pan_and_scan (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to apply `pan_and_scan` to images.\n+            pan_and_scan_min_crop_size (`int`, *optional*, defaults to `self.pan_and_scan_min_crop_size`):\n+                Minimum size of each crop in pan and scan.\n+            pan_and_scan_max_num_crops (`int`, *optional*, defaults to `self.pan_and_scan_max_num_crops`):\n+                Maximum number of crops per image in pan and scan.\n+            pan_and_scan_min_ratio_to_activate (`float`, *optional*, defaults to `self.pan_and_scan_min_ratio_to_activate`):\n+                Minimum aspect ratio to activate pan and scan.\n+        \"\"\"\n+        do_resize = do_resize if do_resize is not None else self.do_resize\n+        size = size if size is not None else self.size\n+        size = get_size_dict(size, param_name=\"size\", default_to_square=False)\n+        resample = resample if resample is not None else self.resample\n+        do_rescale = do_rescale if do_rescale is not None else self.do_rescale\n+        rescale_factor = rescale_factor if rescale_factor is not None else self.rescale_factor\n+        do_normalize = do_normalize if do_normalize is not None else self.do_normalize\n+        image_mean = image_mean if image_mean is not None else self.image_mean\n+        image_std = image_std if image_std is not None else self.image_std\n+        do_convert_rgb = do_convert_rgb if do_convert_rgb is not None else self.do_convert_rgb\n+        do_pan_and_scan = do_pan_and_scan if do_pan_and_scan is not None else self.do_pan_and_scan\n+        pan_and_scan_min_crop_size = (\n+            pan_and_scan_min_crop_size if pan_and_scan_min_crop_size is not None else self.pan_and_scan_min_crop_size\n+        )\n+        pan_and_scan_max_num_crops = (\n+            pan_and_scan_max_num_crops if pan_and_scan_max_num_crops is not None else self.pan_and_scan_max_num_crops\n+        )\n+        pan_and_scan_min_ratio_to_activate = (\n+            pan_and_scan_min_ratio_to_activate\n+            if pan_and_scan_min_ratio_to_activate is not None\n+            else self.pan_and_scan_min_ratio_to_activate\n+        )\n+\n+        images_list = make_nested_list_of_images(images)\n+\n+        if not valid_images(images_list[0]):\n+            raise ValueError(\n+                \"Invalid image type. Must be of type PIL.Image.Image, numpy.ndarray, \"\n+                \"torch.Tensor, tf.Tensor or jax.ndarray.\"\n+            )\n+\n+        validate_preprocess_arguments(\n+            do_rescale=do_rescale,\n+            rescale_factor=rescale_factor,\n+            do_normalize=do_normalize,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            do_resize=do_resize,\n+            size=size,\n+            resample=resample,\n+        )\n+        if do_convert_rgb:\n+            images_list = [[convert_to_rgb(image) for image in images] for images in images_list]\n+\n+        # All transformations expect numpy arrays.\n+        images_list = [[to_numpy_array(image) for image in images] for images in images_list]\n+\n+        if do_rescale and is_scaled_image(images_list[0][0]):\n+            logger.warning_once(\n+                \"It looks like you are trying to rescale already rescaled images. If the input\"\n+                \" images have pixel values between 0 and 1, set `do_rescale=False` to avoid rescaling them again.\"\n+            )\n+\n+        if input_data_format is None:\n+            # We assume that all images have the same channel dimension format.\n+            input_data_format = infer_channel_dimension_format(images_list[0][0])\n+\n+        if do_pan_and_scan:\n+            images_list_and_num_crops = [\n+                self._process_images_for_pan_and_scan(\n+                    images=images,\n+                    do_pan_and_scan=do_pan_and_scan,\n+                    pan_and_scan_min_crop_size=pan_and_scan_min_crop_size,\n+                    pan_and_scan_max_num_crops=pan_and_scan_max_num_crops,\n+                    pan_and_scan_min_ratio_to_activate=pan_and_scan_min_ratio_to_activate,\n+                    data_format=data_format,\n+                    input_data_format=input_data_format,\n+                )\n+                for images in images_list\n+            ]\n+            images_list = [images for images, _ in images_list_and_num_crops]\n+            num_crops = [num_crops for _, num_crops in images_list_and_num_crops]\n+        else:\n+            num_crops = [[0] for images in images_list]\n+\n+        processed_images = []\n+        for images in images_list:\n+            for image in images:\n+                if do_resize:\n+                    height, width = size[\"height\"], size[\"width\"]\n+                    image = resize(\n+                        image=image, size=(height, width), resample=resample, input_data_format=input_data_format\n+                    )\n+\n+                if do_rescale:\n+                    image = self.rescale(image=image, scale=rescale_factor, input_data_format=input_data_format)\n+\n+                if do_normalize:\n+                    image = self.normalize(\n+                        image=image, mean=image_mean, std=image_std, input_data_format=input_data_format\n+                    )\n+\n+                image = to_channel_dimension_format(image, data_format, input_channel_dim=input_data_format)\n+                processed_images.append(image)\n+\n+        data = {\"pixel_values\": processed_images, \"num_crops\": num_crops}\n+        return BatchFeature(data=data, tensor_type=return_tensors)\n+\n+\n+__all__ = [\"Gemma3ImageProcessor\"]"
        },
        {
            "sha": "0a26f25231c23acb8f6863bcd49e59c6ccd346a7",
            "filename": "src/transformers/models/gemma3/image_processing_gemma3_fast.py",
            "status": "added",
            "additions": 387,
            "deletions": 0,
            "changes": 387,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fimage_processing_gemma3_fast.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fimage_processing_gemma3_fast.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3%2Fimage_processing_gemma3_fast.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -0,0 +1,387 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Fast Image processor class for SigLIP.\"\"\"\n+\n+import itertools\n+import math\n+from functools import partial\n+from typing import List, Optional, Union\n+\n+from ...image_processing_utils_fast import (\n+    BASE_IMAGE_PROCESSOR_FAST_DOCSTRING,\n+    BASE_IMAGE_PROCESSOR_FAST_DOCSTRING_PREPROCESS,\n+    BaseImageProcessorFast,\n+    BatchFeature,\n+    DefaultFastImageProcessorInitKwargs,\n+    DefaultFastImageProcessorPreprocessKwargs,\n+    get_size_dict,\n+    group_images_by_shape,\n+    reorder_images,\n+)\n+from ...image_utils import (\n+    IMAGENET_STANDARD_MEAN,\n+    IMAGENET_STANDARD_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    SizeDict,\n+    get_image_size,\n+    make_nested_list_of_images,\n+    validate_kwargs,\n+)\n+from ...processing_utils import Unpack\n+from ...utils import (\n+    TensorType,\n+    add_start_docstrings,\n+    is_torch_available,\n+    is_torchvision_available,\n+    is_torchvision_v2_available,\n+    is_vision_available,\n+    logging,\n+)\n+\n+\n+if is_vision_available():\n+    from ...image_utils import PILImageResampling\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_torchvision_available():\n+    if is_torchvision_v2_available():\n+        from torchvision.transforms.v2 import functional as F\n+    else:\n+        from torchvision.transforms import functional as F\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Gemma3FastImageProcessorInitKwargs(DefaultFastImageProcessorInitKwargs):\n+    do_pan_and_scan: Optional[bool]\n+    pan_and_scan_min_crop_size: Optional[int]\n+    pan_and_scan_max_num_crops: Optional[int]\n+    pan_and_scan_min_ratio_to_activate: Optional[float]\n+\n+\n+class Gemma3FastImageProcessorPreprocessKwargs(DefaultFastImageProcessorPreprocessKwargs):\n+    do_pan_and_scan: Optional[bool]\n+    pan_and_scan_min_crop_size: Optional[int]\n+    pan_and_scan_max_num_crops: Optional[int]\n+    pan_and_scan_min_ratio_to_activate: Optional[float]\n+\n+\n+@add_start_docstrings(\n+    \"Constructs a fast ConvNeXT image processor. Based on [`SiglipImageProcessor`] with incorporation of Pan adn Scan cropping method.\",\n+    BASE_IMAGE_PROCESSOR_FAST_DOCSTRING,\n+    \"\"\"\n+        do_pan_and_scan (`bool`, *optional*):\n+            Whether to apply `pan_and_scan` to images.\n+        pan_and_scan_min_crop_size (`int`, *optional*):\n+            Minimum size of each crop in pan and scan.\n+        pan_and_scan_max_num_crops (`int`, *optional*):\n+            Maximum number of crops per image in pan and scan.\n+        pan_and_scan_min_ratio_to_activate (`float`, *optional*):\n+            Minimum aspect ratio to activate pan and scan.\n+    \"\"\",\n+)\n+class Gemma3ImageProcessorFast(BaseImageProcessorFast):\n+    resample = PILImageResampling.BILINEAR\n+    image_mean = IMAGENET_STANDARD_MEAN\n+    image_std = IMAGENET_STANDARD_STD\n+    size = {\"height\": 224, \"width\": 224}\n+    default_to_square = True\n+    do_resize = True\n+    do_rescale = True\n+    do_normalize = True\n+    do_pan_and_scan = None\n+    pan_and_scan_min_crop_size = None\n+    pan_and_scan_max_num_crops = None\n+    pan_and_scan_min_ratio_to_activate = None\n+    valid_init_kwargs = Gemma3FastImageProcessorInitKwargs\n+    valid_preprocess_kwargs = Gemma3FastImageProcessorPreprocessKwargs\n+\n+    def __init__(self, **kwargs: Unpack[Gemma3FastImageProcessorInitKwargs]):\n+        super().__init__(**kwargs)\n+\n+    def _prepare_images_structure(\n+        self,\n+        images: ImageInput,\n+    ) -> ImageInput:\n+        \"\"\"\n+        Prepare the images structure for processing.\n+\n+        Args:\n+            images (`ImageInput`):\n+                The input images to process.\n+\n+        Returns:\n+            `ImageInput`: The images with a valid nesting.\n+        \"\"\"\n+        return make_nested_list_of_images(images)\n+\n+    def _prepare_input_images(\n+        self,\n+        images: ImageInput,\n+        do_convert_rgb: bool = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+        device: Optional[\"torch.device\"] = None,\n+    ) -> List[\"torch.Tensor\"]:\n+        \"\"\"\n+        Prepare the input images for processing.\n+        \"\"\"\n+        batch_images = self._prepare_images_structure(images)\n+        process_image_fn = partial(\n+            self._process_image,\n+            do_convert_rgb=do_convert_rgb,\n+            input_data_format=input_data_format,\n+            device=device,\n+        )\n+        # todo: yoni - check if we can parallelize this efficiently\n+        batch_processed_images = []\n+        for image_list in batch_images:\n+            processed_images = []\n+            for image in image_list:\n+                processed_images.append(process_image_fn(image))\n+            batch_processed_images.append(processed_images)\n+\n+        return batch_processed_images\n+\n+    def pan_and_scan(\n+        self,\n+        image: \"torch.Tensor\",\n+        pan_and_scan_min_crop_size: int,\n+        pan_and_scan_max_num_crops: int,\n+        pan_and_scan_min_ratio_to_activate: float,\n+    ):\n+        \"\"\"\n+        Pan and Scan an image, by cropping into smaller images when the aspect ratio exceeds\n+        minumum allowed ratio.\n+\n+        Args:\n+            image (`torch.Tensor`):\n+                Image to resize.\n+            pan_and_scan_min_crop_size (`int`, *optional*):\n+                Minimum size of each crop in pan and scan.\n+            pan_and_scan_max_num_crops (`int`, *optional*):\n+                Maximum number of crops per image in pan and scan.\n+            pan_and_scan_min_ratio_to_activate (`float`, *optional*):\n+                Minimum aspect ratio to activate pan and scan.\n+        \"\"\"\n+        height, width = get_image_size(image, channel_dim=ChannelDimension.FIRST)\n+\n+        # Square or landscape image.\n+        if width >= height:\n+            # Only apply PaS if the image is sufficiently exaggerated\n+            if width / height < pan_and_scan_min_ratio_to_activate:\n+                return []\n+\n+            # Select ideal number of crops close to the image aspect ratio and such that crop_size > min_crop_size.\n+            num_crops_w = int(math.floor(width / height + 0.5))  # Half round up rounding.\n+            num_crops_w = min(int(math.floor(width / pan_and_scan_min_crop_size)), num_crops_w)\n+\n+            # Make sure the number of crops is in range [2, pan_and_scan_max_num_crops].\n+            num_crops_w = max(2, num_crops_w)\n+            num_crops_w = min(pan_and_scan_max_num_crops, num_crops_w)\n+            num_crops_h = 1\n+\n+        # Portrait image.\n+        else:\n+            # Only apply PaS if the image is sufficiently exaggerated\n+            if height / width < pan_and_scan_min_ratio_to_activate:\n+                return []\n+\n+            # Select ideal number of crops close to the image aspect ratio and such that crop_size > min_crop_size.\n+            num_crops_h = int(math.floor(height / width + 0.5))\n+            num_crops_h = min(int(math.floor(height / pan_and_scan_min_crop_size)), num_crops_h)\n+\n+            # Make sure the number of crops is in range [2, pan_and_scan_max_num_crops].\n+            num_crops_h = max(2, num_crops_h)\n+            num_crops_h = min(pan_and_scan_max_num_crops, num_crops_h)\n+            num_crops_w = 1\n+\n+        crop_size_w = int(math.ceil(width / num_crops_w))\n+        crop_size_h = int(math.ceil(height / num_crops_h))\n+\n+        # Don't apply PaS if crop size is too small.\n+        if min(crop_size_w, crop_size_h) < pan_and_scan_min_crop_size:\n+            return []\n+\n+        crop_positions_w = [crop_size_w * i for i in range(num_crops_w)]\n+        crop_positions_h = [crop_size_h * i for i in range(num_crops_h)]\n+\n+        return [\n+            image[:, pos_h : pos_h + crop_size_h, pos_w : pos_w + crop_size_w]\n+            for pos_h, pos_w in itertools.product(crop_positions_h, crop_positions_w)\n+        ]\n+\n+    def _process_images_for_pan_and_scan(\n+        self,\n+        images: List[\"torch.Tensor\"],\n+        do_pan_and_scan: bool,\n+        pan_and_scan_min_crop_size: int,\n+        pan_and_scan_max_num_crops: int,\n+        pan_and_scan_min_ratio_to_activate: float,\n+    ):\n+        pas_images_list = []\n+        num_crops = []\n+        for image in images:\n+            pas_images = self.pan_and_scan(\n+                image=image,\n+                pan_and_scan_min_crop_size=pan_and_scan_min_crop_size,\n+                pan_and_scan_max_num_crops=pan_and_scan_max_num_crops,\n+                pan_and_scan_min_ratio_to_activate=pan_and_scan_min_ratio_to_activate,\n+            )\n+            pas_images_list.extend([image] + pas_images)\n+            num_crops.append(len(pas_images))\n+        return pas_images_list, num_crops\n+\n+    @add_start_docstrings(\n+        BASE_IMAGE_PROCESSOR_FAST_DOCSTRING_PREPROCESS,\n+        \"\"\"\n+            do_pan_and_scan (`bool`, *optional*):\n+                Whether to apply `pan_and_scan` to images.\n+            pan_and_scan_min_crop_size (`int`, *optional*):\n+                Minimum size of each crop in pan and scan.\n+            pan_and_scan_max_num_crops (`int`, *optional*):\n+                Maximum number of crops per image in pan and scan.\n+            pan_and_scan_min_ratio_to_activate (`float`, *optional*):\n+                Minimum aspect ratio to activate pan and scan.\n+        \"\"\",\n+    )\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        **kwargs: Unpack[Gemma3FastImageProcessorPreprocessKwargs],\n+    ) -> BatchFeature:\n+        validate_kwargs(\n+            captured_kwargs=kwargs.keys(), valid_processor_keys=self.valid_preprocess_kwargs.__annotations__.keys()\n+        )\n+        # Set default kwargs from self. This ensures that if a kwarg is not provided\n+        # by the user, it gets its default value from the instance, or is set to None.\n+        for kwarg_name in self.valid_preprocess_kwargs.__annotations__:\n+            kwargs.setdefault(kwarg_name, getattr(self, kwarg_name, None))\n+\n+        # Extract parameters that are only used for preparing the input images\n+        do_convert_rgb = kwargs.pop(\"do_convert_rgb\")\n+        input_data_format = kwargs.pop(\"input_data_format\")\n+        device = kwargs.pop(\"device\")\n+\n+        images = self._prepare_input_images(\n+            images=images, do_convert_rgb=do_convert_rgb, input_data_format=input_data_format, device=device\n+        )\n+\n+        # Pop kwargs that need further processing or won't be used in _preprocess\n+        default_to_square = kwargs.pop(\"default_to_square\")\n+        size = kwargs.pop(\"size\")\n+        crop_size = kwargs.pop(\"crop_size\")\n+        image_mean = kwargs.pop(\"image_mean\")\n+        image_std = kwargs.pop(\"image_std\")\n+        data_format = kwargs.pop(\"data_format\")\n+        resample = kwargs.pop(\"resample\")\n+\n+        # Make hashable for cache\n+        size = SizeDict(**get_size_dict(size=size, default_to_square=default_to_square)) if size is not None else None\n+        crop_size = SizeDict(**get_size_dict(crop_size, param_name=\"crop_size\")) if crop_size is not None else None\n+        image_mean = tuple(image_mean) if isinstance(image_mean, list) else image_mean\n+        image_std = tuple(image_std) if isinstance(image_std, list) else image_std\n+\n+        image_mean, image_std, interpolation = self._prepare_process_arguments(\n+            size=size,\n+            crop_size=crop_size,\n+            resample=resample,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            data_format=data_format if data_format is not None else ChannelDimension.FIRST,\n+            device=images[0][0].device,\n+            do_resize=kwargs.get(\"do_resize\"),\n+            do_center_crop=kwargs.get(\"do_center_crop\"),\n+            do_rescale=kwargs.get(\"do_rescale\"),\n+            rescale_factor=kwargs.get(\"rescale_factor\"),\n+            do_normalize=kwargs.get(\"do_normalize\"),\n+            return_tensors=kwargs.get(\"return_tensors\"),\n+        )\n+\n+        return self._preprocess(\n+            images=images,\n+            size=size,\n+            crop_size=crop_size,\n+            interpolation=interpolation,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            **kwargs,\n+        )\n+\n+    def _preprocess(\n+        self,\n+        images: List[List[\"torch.Tensor\"]],\n+        do_resize: bool,\n+        size: SizeDict,\n+        do_pan_and_scan: Optional[bool],\n+        pan_and_scan_min_crop_size: Optional[int],\n+        pan_and_scan_max_num_crops: Optional[int],\n+        pan_and_scan_min_ratio_to_activate: Optional[float],\n+        interpolation: Optional[\"F.InterpolationMode\"],\n+        do_center_crop: bool,\n+        crop_size: SizeDict,\n+        do_rescale: bool,\n+        rescale_factor: float,\n+        do_normalize: bool,\n+        image_mean: Optional[Union[float, List[float]]],\n+        image_std: Optional[Union[float, List[float]]],\n+        return_tensors: Optional[Union[str, TensorType]],\n+    ) -> BatchFeature:\n+        processed_images = []\n+        batch_num_crops = []\n+\n+        for image_list in images:\n+            if do_pan_and_scan:\n+                images_list, num_crops = self._process_images_for_pan_and_scan(\n+                    images=image_list,\n+                    do_pan_and_scan=do_pan_and_scan,\n+                    pan_and_scan_min_crop_size=pan_and_scan_min_crop_size,\n+                    pan_and_scan_max_num_crops=pan_and_scan_max_num_crops,\n+                    pan_and_scan_min_ratio_to_activate=pan_and_scan_min_ratio_to_activate,\n+                )\n+            else:\n+                num_crops = [[0] for images in images_list]\n+\n+            # Group images by size for batched processing\n+            processed_image_patches_grouped = {}\n+            grouped_image_patches, grouped_image_patches_index = group_images_by_shape(images_list)\n+            for shape, stacked_image_patches in grouped_image_patches.items():\n+                if do_resize:\n+                    stacked_image_patches = self.resize(\n+                        image=stacked_image_patches,\n+                        size=size,\n+                        interpolation=interpolation,\n+                    )\n+                # Fused rescale and normalize\n+                stacked_image_patches = self.rescale_and_normalize(\n+                    stacked_image_patches, do_rescale, rescale_factor, do_normalize, image_mean, image_std\n+                )\n+                processed_image_patches_grouped[shape] = stacked_image_patches\n+            processed_image_patches = reorder_images(processed_image_patches_grouped, grouped_image_patches_index)\n+            processed_image_patches = (\n+                torch.stack(processed_image_patches, dim=0) if return_tensors else processed_image_patches\n+            )\n+            processed_images.extend(processed_image_patches)\n+            batch_num_crops.extend(num_crops)\n+\n+        processed_images = torch.stack(processed_images, dim=0) if return_tensors else processed_images\n+        return BatchFeature(\n+            data={\"pixel_values\": processed_images, \"num_crops\": batch_num_crops}, tensor_type=return_tensors\n+        )\n+\n+\n+__all__ = [\"Gemma3ImageProcessorFast\"]"
        },
        {
            "sha": "d5498c8615dbc31415cb9d8021c3b0eb1aea67d7",
            "filename": "src/transformers/models/gemma3/modeling_gemma3.py",
            "status": "added",
            "additions": 1451,
            "deletions": 0,
            "changes": 1451,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fmodeling_gemma3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fmodeling_gemma3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3%2Fmodeling_gemma3.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -0,0 +1,1451 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/gemma3/modular_gemma3.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_gemma3.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 Google Inc. HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import copy\n+from collections.abc import Callable\n+from dataclasses import dataclass\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+import torch.nn as nn\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, HybridCache, StaticCache\n+from ...generation import GenerationMixin\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_outputs import BaseModelOutputWithPast, CausalLMOutputWithPast, ModelOutput\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS, PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import (\n+    add_start_docstrings,\n+    add_start_docstrings_to_model_forward,\n+    is_torchdynamo_compiling,\n+    logging,\n+    replace_return_docstrings,\n+)\n+from ...utils.deprecation import deprecate_kwarg\n+from ..auto import AutoModel, AutoModelForCausalLM\n+from .configuration_gemma3 import Gemma3Config, Gemma3TextConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+_CONFIG_FOR_DOC = \"Gemma3Config\"\n+\n+\n+@dataclass\n+class Gemma3CausalLMOutputWithPast(ModelOutput):\n+    \"\"\"\n+    Base class for Gemma3 causal language model (or autoregressive) outputs.\n+\n+    Args:\n+        loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+            Language modeling loss (for next-token prediction).\n+        logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.text_config.vocab_size)`):\n+            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+            `past_key_values` input) to speed up sequential decoding.\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        image_hidden_states (`torch.FloatTensor`, *optional*):\n+            A `torch.FloatTensor` of size `(batch_size, sequence_length, hidden_size)`.\n+            image_hidden_states of the model produced by the vision encoder after projecting last hidden state.\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: torch.FloatTensor = None\n+    past_key_values: Optional[Union[List[torch.FloatTensor], Cache]] = None\n+    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+    attentions: Optional[Tuple[torch.FloatTensor]] = None\n+    image_hidden_states: Optional[torch.FloatTensor] = None\n+\n+\n+class Gemma3TextScaledWordEmbedding(nn.Embedding):\n+    \"\"\"\n+    This module overrides nn.Embeddings' forward by multiplying with embeddings scale.\n+    \"\"\"\n+\n+    def __init__(self, num_embeddings: int, embedding_dim: int, padding_idx: int, embed_scale: Optional[float] = 1.0):\n+        super().__init__(num_embeddings, embedding_dim, padding_idx)\n+        self.embed_scale = embed_scale\n+\n+    def forward(self, input_ids: torch.Tensor):\n+        return super().forward(input_ids) * self.embed_scale\n+\n+\n+class Gemma3MLP(nn.Module):\n+    def __init__(self, config: Gemma3TextConfig):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=False)\n+        self.act_fn = ACT2FN[config.hidden_activation]\n+\n+    def forward(self, x):\n+        down_proj = self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x))\n+        return down_proj\n+\n+\n+class Gemma3RMSNorm(nn.Module):\n+    def __init__(self, dim: int, eps: float = 1e-6):\n+        super().__init__()\n+        self.eps = eps\n+        self.weight = nn.Parameter(torch.zeros(dim))\n+\n+    def _norm(self, x):\n+        return x * torch.rsqrt(x.pow(2).mean(-1, keepdim=True) + self.eps)\n+\n+    def forward(self, x):\n+        output = self._norm(x.float())\n+        # Llama does x.to(float16) * w whilst Gemma3 is (x * w).to(float16)\n+        # See https://github.com/huggingface/transformers/pull/29402\n+        output = output * (1.0 + self.weight.float())\n+        return output.type_as(x)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.eps}\"\n+\n+\n+class Gemma3RotaryEmbedding(nn.Module):\n+    def __init__(self, config: Gemma3TextConfig, device=None):\n+        super().__init__()\n+        # BC: \"rope_type\" was originally \"type\"\n+        if hasattr(config, \"rope_scaling\") and config.rope_scaling is not None:\n+            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n+        else:\n+            self.rope_type = \"default\"\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = self.inv_freq\n+\n+    def _dynamic_frequency_update(self, position_ids, device):\n+        \"\"\"\n+        dynamic RoPE layers should recompute `inv_freq` in the following situations:\n+        1 - growing beyond the cached sequence length (allow scaling)\n+        2 - the current sequence length is in the original scale (avoid losing precision with small sequences)\n+        \"\"\"\n+        seq_len = torch.max(position_ids) + 1\n+        if seq_len > self.max_seq_len_cached:  # growth\n+            inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device, seq_len=seq_len)\n+            self.register_buffer(\"inv_freq\", inv_freq, persistent=False)  # TODO joao: may break with compilation\n+            self.max_seq_len_cached = seq_len\n+\n+        if seq_len < self.original_max_seq_len and self.max_seq_len_cached > self.original_max_seq_len:  # reset\n+            # This .to() is needed if the model has been moved to a device after being initialized (because\n+            # the buffer is automatically moved, but not the original copy)\n+            self.original_inv_freq = self.original_inv_freq.to(device)\n+            self.register_buffer(\"inv_freq\", self.original_inv_freq, persistent=False)\n+            self.max_seq_len_cached = self.original_max_seq_len\n+\n+    @torch.no_grad()\n+    def forward(self, x, position_ids):\n+        if \"dynamic\" in self.rope_type:\n+            self._dynamic_frequency_update(position_ids, device=x.device)\n+\n+        # Core RoPE block\n+        inv_freq_expanded = self.inv_freq[None, :, None].float().expand(position_ids.shape[0], -1, 1)\n+        position_ids_expanded = position_ids[:, None, :].float()\n+        # Force float32 (see https://github.com/huggingface/transformers/pull/29285)\n+        device_type = x.device.type\n+        device_type = device_type if isinstance(device_type, str) and device_type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):\n+            freqs = (inv_freq_expanded.float().to(x.device) @ position_ids_expanded.float()).transpose(1, 2)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos()\n+            sin = emb.sin()\n+\n+        # Advanced RoPE types (e.g. yarn) apply a post-processing scaling factor, equivalent to scaling attention\n+        cos = cos * self.attention_scaling\n+        sin = sin * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+def apply_rotary_pos_emb(q, k, cos, sin, position_ids=None, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding to the query and key tensors.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`, *optional*):\n+            Deprecated and unused.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    cos = cos.unsqueeze(unsqueeze_dim)\n+    sin = sin.unsqueeze(unsqueeze_dim)\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    return q_embed, k_embed\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+def eager_attention_forward(\n+    module: nn.Module,\n+    query: torch.Tensor,\n+    key: torch.Tensor,\n+    value: torch.Tensor,\n+    attention_mask: Optional[torch.Tensor],\n+    dropout: float = 0.0,\n+    scaling: Optional[float] = None,\n+    softcap: Optional[float] = None,\n+    **kwargs,\n+) -> Tuple[torch.Tensor, torch.Tensor]:\n+    if scaling is None:\n+        scaling = module.head_dim**-0.5\n+\n+    key_states = repeat_kv(key, module.num_key_value_groups)\n+    value_states = repeat_kv(value, module.num_key_value_groups)\n+\n+    attn_weights = torch.matmul(query, key_states.transpose(2, 3)) * scaling\n+\n+    if softcap is not None:\n+        attn_weights = attn_weights / softcap\n+        attn_weights = torch.tanh(attn_weights)\n+        attn_weights = attn_weights * softcap\n+    if attention_mask is not None:  # no matter the length, we just slice it\n+        causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+        attn_weights = attn_weights + causal_mask\n+\n+    # upcast attention to fp32\n+    attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query.dtype)\n+    attn_weights = nn.functional.dropout(attn_weights, p=dropout, training=module.training)\n+    attn_output = torch.matmul(attn_weights, value_states)\n+    attn_output = attn_output.transpose(1, 2).contiguous()\n+    return attn_output, attn_weights\n+\n+\n+class Gemma3Attention(nn.Module):\n+    \"\"\"Multi-headed attention from 'Attention Is All You Need' paper\"\"\"\n+\n+    def __init__(self, config: Gemma3TextConfig, layer_idx: int):\n+        super().__init__()\n+        self.is_sliding = bool((layer_idx + 1) % config.sliding_window_pattern)\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        self.head_dim = getattr(config, \"head_dim\", config.hidden_size // config.num_attention_heads)\n+        self.num_key_value_groups = config.num_attention_heads // config.num_key_value_heads\n+        self.scaling = config.query_pre_attn_scalar**-0.5\n+        self.attention_dropout = self.config.attention_dropout\n+        self.is_causal = True\n+\n+        self.q_proj = nn.Linear(\n+            config.hidden_size, config.num_attention_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.k_proj = nn.Linear(\n+            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.v_proj = nn.Linear(\n+            config.hidden_size, config.num_key_value_heads * self.head_dim, bias=config.attention_bias\n+        )\n+        self.o_proj = nn.Linear(\n+            config.num_attention_heads * self.head_dim, config.hidden_size, bias=config.attention_bias\n+        )\n+        self.attn_logit_softcapping = self.config.attn_logit_softcapping\n+        self.sliding_window = config.sliding_window if self.is_sliding else None\n+\n+        self.q_norm = Gemma3RMSNorm(dim=config.head_dim, eps=config.rms_norm_eps)\n+        self.k_norm = Gemma3RMSNorm(dim=config.head_dim, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        query_states = self.q_norm(query_states)\n+        key_states = self.k_norm(key_states)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\n+                \"sin\": sin,\n+                \"cos\": cos,\n+                \"cache_position\": cache_position,\n+                \"sliding_window\": self.sliding_window,\n+            }\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+            # Here we need to slice as we use a static cache by default, but FA2 does not support it\n+            if attention_mask is not None and self.config._attn_implementation == \"flash_attention_2\":\n+                seq_len = attention_mask.shape[-1]\n+                key_states, value_states = key_states[:, :, :seq_len, :], value_states[:, :, :seq_len, :]\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            if self.config._attn_implementation == \"sdpa\" and kwargs.get(\"output_attentions\", False):\n+                logger.warning_once(\n+                    \"`torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. \"\n+                    \"Falling back to eager attention. This warning can be removed using the argument \"\n+                    '`attn_implementation=\"eager\"` when loading the model.'\n+                )\n+            else:\n+                attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask.to(query_states),\n+            dropout=self.attention_dropout if self.training else 0.0,\n+            scaling=self.scaling,\n+            sliding_window=self.sliding_window,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class Gemma3DecoderLayer(nn.Module):\n+    def __init__(self, config: Gemma3TextConfig, layer_idx: int):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.layer_idx = layer_idx\n+        self.self_attn = Gemma3Attention(config=config, layer_idx=layer_idx)\n+        self.mlp = Gemma3MLP(config)\n+        self.input_layernorm = Gemma3RMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = Gemma3RMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+        self.pre_feedforward_layernorm = Gemma3RMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+        self.post_feedforward_layernorm = Gemma3RMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+        self.is_sliding = self.self_attn.is_sliding\n+        self.sliding_window = config.sliding_window\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings_global: torch.Tensor,\n+        position_embeddings_local: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: Optional[bool] = False,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        last_cache_position: int = 0,\n+        **kwargs,\n+    ) -> tuple[torch.FloatTensor, Optional[tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        if self.is_sliding and attention_mask is not None:  # efficient SDPA and no padding\n+            # In prefill, we may be larger than sliding window\n+            effective_seq_len = max(cache_position.shape[0], self.sliding_window)\n+            # For FA2, the mask is 2D and is of shape [bs, processed_tokens] (not [bs, max_cache_len]),\n+            # thus we must slice from the right (at most `effective_seq_len` elements)\n+            if self.config._attn_implementation == \"flash_attention_2\":\n+                attention_mask = attention_mask[:, -effective_seq_len:]\n+            # Otherwise, the mask is 4D of shape [bs, 1, query_len, max_cache_len] thus we must slice\n+            # from the left, with an offset if we are beyond the sliding window\n+            else:\n+                min_dtype = torch.finfo(attention_mask.dtype).min\n+                sliding_window_mask = torch.tril(\n+                    torch.ones_like(attention_mask, dtype=torch.bool), diagonal=-self.sliding_window\n+                )\n+                attention_mask = torch.where(sliding_window_mask, min_dtype, attention_mask)\n+                # In case we are beyond the sliding window, we need to correctly offset the mask slicing\n+                # `last_cache_position` is equivalent to `cache_position[-1]` but without breaking dynamo\n+                offset = last_cache_position - effective_seq_len\n+                # Should only be used when beyond the sliding window (i.e. offset > 0)\n+                offset = max(0, offset)\n+                attention_mask = attention_mask[:, :, :, offset : offset + effective_seq_len]\n+\n+        residual = hidden_states\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # apply global RoPE to non-sliding layer only\n+        if self.self_attn.is_sliding:\n+            position_embeddings = position_embeddings_local\n+        else:\n+            position_embeddings = position_embeddings_global\n+\n+        hidden_states, self_attn_weights = self.self_attn(\n+            hidden_states=hidden_states,\n+            position_embeddings=position_embeddings,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        residual = hidden_states\n+        hidden_states = self.pre_feedforward_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = self.post_feedforward_layernorm(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        outputs = (hidden_states,)\n+\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        return outputs\n+\n+\n+GEMMA3_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`Gemma3Config`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare Gemma3 Model outputting raw hidden-states without any specific head on top.\",\n+    GEMMA3_START_DOCSTRING,\n+)\n+class Gemma3PreTrainedModel(PreTrainedModel):\n+    config_class = Gemma3Config\n+    base_model_prefix = \"language_model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\n+        \"Gemma3DecoderLayer\",\n+        \"SiglipVisionEmbeddings\",\n+        \"SiglipEncoderLayer\",\n+        \"SiglipMultiheadAttentionPoolingHead\",\n+    ]\n+    _skip_keys_device_placement = [\"past_key_values\"]\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = True\n+    _supports_flex_attn = True\n+    _supports_cache_class = True\n+    _supports_quantized_cache = True\n+    _supports_static_cache = True\n+    _supports_attention_backend = True\n+\n+    def _init_weights(self, module):\n+        # important: this ported version of Gemma2 isn't meant for training from scratch - only\n+        # inference and fine-tuning - so the proper init weights code has been removed\n+        std = (\n+            self.config.initializer_range\n+            if hasattr(self.config, \"initializer_range\")\n+            else self.config.text_config.initializer_range\n+        )\n+\n+        if isinstance(module, (nn.Linear, nn.Conv2d)):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+\n+\n+GEMMA3_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+            it.\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            [What are input IDs?](../glossary#input-ids)\n+        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+            - 1 for tokens that are **not masked**,\n+            - 0 for tokens that are **masked**.\n+\n+            [What are attention masks?](../glossary#attention-mask)\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            If `past_key_values` is used, optionally only the last `input_ids` have to be input (see\n+            `past_key_values`).\n+\n+            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n+            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n+            information on the default strategy.\n+\n+            - 1 indicates the head is **not masked**,\n+            - 0 indicates the head is **masked**.\n+        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n+            config.n_positions - 1]`.\n+\n+            [What are position IDs?](../glossary#position-ids)\n+        past_key_values (`Cache` or `tuple(tuple(torch.FloatTensor))`, *optional*):\n+            Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n+            blocks) that can be used to speed up sequential decoding. This typically consists in the `past_key_values`\n+            returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n+\n+            Two formats are allowed:\n+            - a [`~cache_utils.Cache`] instance, see our\n+            [kv cache guide](https://huggingface.co/docs/transformers/en/kv_cache);\n+            - Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of\n+            shape `(batch_size, num_heads, sequence_length, embed_size_per_head)`). This is also known as the legacy\n+            cache format.\n+\n+            The model will output the same cache format that is fed as input. If no `past_key_values` are passed, the\n+            legacy cache format will be returned.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `input_ids` (those that don't\n+            have their past key value states given to this model) of shape `(batch_size, 1)` instead of all `input_ids`\n+            of shape `(batch_size, sequence_length)`.\n+        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n+            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n+            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n+            model's internal embedding lookup matrix.\n+        use_cache (`bool`, *optional*):\n+            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n+            `past_key_values`).\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+        cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n+            Indices depicting the position of the input sequence tokens in the sequence. Contrarily to `position_ids`,\n+            this tensor is not affected by padding. It is used to update the cache in the correct position and to infer\n+            the complete sequence length.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare Gemma3Text Model outputting raw hidden-states without any specific head on top.\",\n+    GEMMA3_START_DOCSTRING,\n+)\n+class Gemma3TextModel(Gemma3PreTrainedModel):\n+    \"\"\"\n+    Transformer decoder consisting of *config.num_hidden_layers* layers. Each layer is a [`Gemma3TextDecoderLayer`]\n+\n+    Args:\n+        config: Gemma3TextConfig\n+    \"\"\"\n+\n+    config_class = Gemma3TextConfig\n+\n+    def __init__(self, config: Gemma3TextConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        # Gemma3 downcasts the below to float16, causing sqrt(3072)=55.4256 to become 55.5. See https://github.com/huggingface/transformers/pull/29402\n+        self.embed_tokens = Gemma3TextScaledWordEmbedding(\n+            config.vocab_size, config.hidden_size, self.padding_idx, embed_scale=self.config.hidden_size**0.5\n+        )\n+        self.layers = nn.ModuleList(\n+            [Gemma3DecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = Gemma3RMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = Gemma3RotaryEmbedding(config=config)\n+        self.gradient_checkpointing = False\n+\n+        # TODO: raushan fix this after RoPE refactor. For now we hack it by reassigning thetas\n+        # when we want to create a local RoPE layer. Config defaults should hold values for global RoPE\n+        config = copy.deepcopy(config)\n+        config.rope_theta = config.rope_local_base_freq\n+        config.rope_scaling = {\"rope_type\": \"default\"}\n+        self.rotary_emb_local = Gemma3RotaryEmbedding(config=config)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.embed_tokens = value\n+\n+    @add_start_docstrings_to_model_forward(GEMMA3_INPUTS_DOCSTRING)\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[HybridCache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        last_cache_position: Optional[int] = None,\n+        **flash_attn_kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Union[Tuple, BaseModelOutputWithPast]:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if self.gradient_checkpointing and self.training and use_cache:\n+            logger.warning_once(\n+                \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`.\"\n+            )\n+            use_cache = False\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if use_cache and past_key_values is None and not self.training:\n+            batch_size, seq_len, _ = inputs_embeds.shape\n+            past_key_values = HybridCache(\n+                self.config,\n+                max_batch_size=batch_size,\n+                max_cache_len=seq_len,\n+                dtype=inputs_embeds.dtype,\n+            )\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens,\n+                past_seen_tokens + inputs_embeds.shape[1],\n+                device=inputs_embeds.device,\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        # This is needed to correctly slice the mask without data-dependent slicing later on if using dynamo tracing\n+        # (retrieving the same value from `cache_position` later on would crash dynamo)\n+        if last_cache_position is None:\n+            last_cache_position = 0\n+            if attention_mask is not None:\n+                # In case a 4d mask is passed directly without using `generate`, we have to rely on cache_position\n+                # It will break dynamo tracing but there are no way around it (and it should never happen in practice)\n+                last_cache_position = (\n+                    attention_mask.shape[-1] if attention_mask.dim() == 2 else cache_position[-1].item()\n+                )\n+        causal_mask = self._update_causal_mask(\n+            attention_mask,\n+            inputs_embeds,\n+            cache_position,\n+            past_key_values,\n+            output_attentions,\n+        )\n+\n+        # embed positions\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings_global = self.rotary_emb(hidden_states, position_ids)\n+        position_embeddings_local = self.rotary_emb_local(hidden_states, position_ids)\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            if self.gradient_checkpointing and self.training:\n+                layer_outputs = self._gradient_checkpointing_func(\n+                    decoder_layer.__call__,\n+                    hidden_states,\n+                    position_embeddings_global,\n+                    position_embeddings_local,\n+                    causal_mask,\n+                    position_ids,\n+                    past_key_values,\n+                    output_attentions,\n+                    use_cache,\n+                    cache_position,\n+                    last_cache_position,\n+                )\n+            else:\n+                layer_outputs = decoder_layer(\n+                    hidden_states,\n+                    position_embeddings_global=position_embeddings_global,\n+                    position_embeddings_local=position_embeddings_local,\n+                    attention_mask=causal_mask,\n+                    position_ids=position_ids,\n+                    past_key_value=past_key_values,\n+                    output_attentions=output_attentions,\n+                    use_cache=use_cache,\n+                    cache_position=cache_position,\n+                    last_cache_position=last_cache_position,\n+                    **flash_attn_kwargs,\n+                )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        output = BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+        )\n+        return output if return_dict else output.to_tuple()\n+\n+    @torch.no_grad()\n+    def _update_causal_mask(\n+        self,\n+        attention_mask: torch.Tensor,\n+        input_tensor: torch.Tensor,\n+        cache_position: torch.Tensor,\n+        past_key_values: HybridCache,\n+        output_attentions: bool,\n+    ):\n+        # Flash Attention currently doesn't support static cache but Gemma3Text work only with static cache.\n+        # So we will pass in attention mask as is in any case, not only when ther's padding. Then we'll use its shape\n+        # to cut out keys/values trailing 0 used in static cache. This workaround should be compile compatible\n+        # as it doesn't cause dynamic control issues.\n+        if self.config._attn_implementation == \"flash_attention_2\":\n+            return attention_mask\n+\n+        dtype, device = input_tensor.dtype, input_tensor.device\n+        sequence_length = input_tensor.shape[1]\n+        if isinstance(past_key_values, (HybridCache, StaticCache)):\n+            target_length = past_key_values.get_max_cache_shape()\n+        else:\n+            target_length = attention_mask.shape[-1] if attention_mask is not None else input_tensor.shape[1]\n+\n+        # In case the provided `attention` mask is 2D, we generate a causal mask here (4D).\n+        causal_mask = self._prepare_4d_causal_attention_mask_with_cache_position(\n+            attention_mask,\n+            sequence_length=sequence_length,\n+            target_length=target_length,\n+            dtype=dtype,\n+            device=device,\n+            cache_position=cache_position,\n+            batch_size=input_tensor.shape[0],\n+        )\n+        return causal_mask\n+\n+    @staticmethod\n+    def _prepare_4d_causal_attention_mask_with_cache_position(\n+        attention_mask: torch.Tensor,\n+        sequence_length: int,\n+        target_length: int,\n+        dtype: torch.dtype,\n+        device: torch.device,\n+        cache_position: torch.Tensor,\n+        batch_size: int,\n+        **kwargs,\n+    ):\n+        \"\"\"\n+        Creates a causal 4D mask of shape `(batch_size, 1, query_length, key_value_length)` from a 2D mask of shape\n+        `(batch_size, key_value_length)`, or if the input `attention_mask` is already 4D, do nothing.\n+\n+        Args:\n+            attention_mask (`torch.Tensor`):\n+                A 2D attention mask of shape `(batch_size, key_value_length)` or a 4D attention mask of shape\n+                `(batch_size, 1, query_length, key_value_length)`.\n+            sequence_length (`int`):\n+                The sequence length being processed.\n+            target_length (`int`):\n+                The target length: when generating with static cache, the mask should be as long as the static cache,\n+                to account for the 0 padding, the part of the cache that is not filled yet.\n+            dtype (`torch.dtype`):\n+                The dtype to use for the 4D attention mask.\n+            device (`torch.device`):\n+                The device to plcae the 4D attention mask on.\n+            cache_position (`torch.Tensor`):\n+                Indices depicting the position of the input sequence tokens in the sequence.\n+            batch_size (`torch.Tensor`):\n+                Batch size.\n+        \"\"\"\n+        if attention_mask is not None and attention_mask.dim() == 4:\n+            # In this case we assume that the mask comes already in inverted form and requires no inversion or slicing.\n+            causal_mask = attention_mask\n+        else:\n+            min_dtype = torch.finfo(dtype).min\n+            causal_mask = torch.full(\n+                (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n+            )\n+            if sequence_length != 1:\n+                causal_mask = torch.triu(causal_mask, diagonal=1)\n+            causal_mask *= torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n+            causal_mask = causal_mask[None, None, :, :].expand(batch_size, 1, -1, -1)\n+            if attention_mask is not None:\n+                causal_mask = causal_mask.clone()  # copy to contiguous memory for in-place edit\n+                mask_length = attention_mask.shape[-1]\n+                padding_mask = causal_mask[:, :, :, :mask_length] + attention_mask[:, None, None, :].to(\n+                    causal_mask.device\n+                )\n+                padding_mask = padding_mask == 0\n+                causal_mask[:, :, :, :mask_length] = causal_mask[:, :, :, :mask_length].masked_fill(\n+                    padding_mask, min_dtype\n+                )\n+\n+        return causal_mask\n+\n+\n+class Gemma3ForCausalLM(Gemma3PreTrainedModel, GenerationMixin):\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+    _tp_plan = {\"lm_head\": \"colwise_rep\"}\n+    _pp_plan = {\"lm_head\": ([\"hidden_states\"], [\"logits\"])}\n+    config_class = Gemma3TextConfig\n+    base_model_prefix = \"language_model\"\n+\n+    def __init__(self, config: Gemma3TextConfig):\n+        super().__init__(config)\n+        self.model = Gemma3TextModel(config)\n+        self.vocab_size = config.vocab_size\n+        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    def get_output_embeddings(self):\n+        return self.lm_head\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.lm_head = new_embeddings\n+\n+    def set_decoder(self, decoder):\n+        self.model = decoder\n+\n+    def get_decoder(self):\n+        return self.model\n+\n+    @deprecate_kwarg(\"num_logits_to_keep\", version=\"4.50\", new_name=\"logits_to_keep\")\n+    @add_start_docstrings_to_model_forward(GEMMA3_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=CausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[HybridCache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **loss_kwargs,\n+    ) -> Union[Tuple, CausalLMOutputWithPast]:\n+        r\"\"\"\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+            logits_to_keep (`int` or `torch.Tensor`, *optional*):\n+                If an `int`, compute logits for the last `logits_to_keep` tokens. If `0`, calculate logits for all\n+                `input_ids` (special case). Only last token logits are needed for generation, and calculating them only for that\n+                token can save memory, which becomes pretty significant for long sequences or large vocabulary size.\n+                If a `torch.Tensor`, must be 1D corresponding to the indices to keep in the sequence length dimension.\n+                This is useful when using packed tensor format (single dimension for batch and sequence length).\n+\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> from transformers import AutoTokenizer, Gemma3ForCausalLM\n+\n+        >>> model = Gemma3ForCausalLM.from_pretrained(\"google/gemma-2-9b\")\n+        >>> tokenizer = AutoTokenizer.from_pretrained(\"google/gemma-2-9b\")\n+\n+        >>> prompt = \"What is your favorite condiment?\"\n+        >>> inputs = tokenizer(prompt, return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"What is your favorite condiment?\"\n+        ```\"\"\"\n+\n+        if self.training and self.config._attn_implementation != \"eager\":\n+            logger.warning_once(\n+                \"It is strongly recommended to train Gemma3 models with the `eager` attention implementation \"\n+                f\"instead of `{self.config._attn_implementation}`. Use `eager` with `AutoModelForCausalLM.from_pretrained('<path-to-checkpoint>', attn_implementation='eager')`.\"\n+            )\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+        # decoder outputs consists of (dec_features, layer_state, dec_hidden, dec_attn)\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+            cache_position=cache_position,\n+            **loss_kwargs,\n+        )\n+\n+        hidden_states = outputs[0]\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+        if self.config.final_logit_softcapping is not None:\n+            logits = logits / self.config.final_logit_softcapping\n+            logits = torch.tanh(logits)\n+            logits = logits * self.config.final_logit_softcapping\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits, labels, self.vocab_size, **loss_kwargs)\n+\n+        if not return_dict:\n+            output = (logits,) + outputs[1:]\n+            return (loss,) + output if loss is not None else output\n+\n+        return CausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        attention_mask=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        position_ids=None,\n+        use_cache=True,\n+        logits_to_keep=None,\n+        **kwargs,\n+    ):\n+        # Overwritten: has a special cache type, `HybridCache`\n+\n+        model_inputs = super().prepare_inputs_for_generation(\n+            input_ids,\n+            past_key_values=past_key_values,\n+            attention_mask=attention_mask,\n+            inputs_embeds=inputs_embeds,\n+            cache_position=cache_position,\n+            position_ids=position_ids,\n+            use_cache=use_cache,\n+            logits_to_keep=logits_to_keep,\n+            **kwargs,\n+        )\n+\n+        # This is needed to correctly slice the mask without data-dependent slicing later on if using dynamo tracing\n+        # (retrieving the same value from `cache_position` later on would crash dynamo)\n+        model_inputs[\"last_cache_position\"] = attention_mask.shape[-1] if attention_mask is not None else 0\n+        if logits_to_keep is None:\n+            _ = model_inputs.pop(\"logits_to_keep\", None)\n+\n+        if (\n+            isinstance(past_key_values, HybridCache)\n+            and attention_mask.ndim == 2\n+            and not self.config._attn_implementation == \"flash_attention_2\"\n+        ):\n+            if model_inputs[\"inputs_embeds\"] is not None:\n+                batch_size, sequence_length, _ = model_inputs[\"inputs_embeds\"].shape\n+                device = model_inputs[\"inputs_embeds\"].device\n+            else:\n+                batch_size, sequence_length = model_inputs[\"input_ids\"].shape\n+                device = model_inputs[\"input_ids\"].device\n+\n+            attention_mask = self.model._prepare_4d_causal_attention_mask_with_cache_position(\n+                attention_mask,\n+                sequence_length=sequence_length,\n+                target_length=past_key_values.get_max_cache_shape(),\n+                dtype=self.lm_head.weight.dtype,\n+                device=device,\n+                cache_position=cache_position,\n+                batch_size=batch_size,\n+            )\n+            model_inputs[\"attention_mask\"] = attention_mask\n+\n+        return model_inputs\n+\n+\n+class Gemma3MultiModalProjector(nn.Module):\n+    def __init__(self, config: Gemma3Config):\n+        super().__init__()\n+\n+        self.mm_input_projection_weight = nn.Parameter(\n+            torch.zeros(config.vision_config.hidden_size, config.text_config.hidden_size)\n+        )\n+\n+        self.mm_soft_emb_norm = Gemma3RMSNorm(\n+            config.vision_config.hidden_size, eps=config.vision_config.layer_norm_eps\n+        )\n+\n+        self.patches_per_image = int(config.vision_config.image_size // config.vision_config.patch_size)\n+        self.tokens_per_side = int(config.mm_tokens_per_image**0.5)\n+        self.kernel_size = self.patches_per_image // self.tokens_per_side\n+        self.avg_pool = nn.AvgPool2d(kernel_size=self.kernel_size, stride=self.kernel_size)\n+\n+    def forward(self, vision_outputs: torch.Tensor):\n+        batch_size, _, seq_length = vision_outputs.shape\n+\n+        reshaped_vision_outputs = vision_outputs.transpose(1, 2)\n+        reshaped_vision_outputs = reshaped_vision_outputs.reshape(\n+            batch_size, seq_length, self.patches_per_image, self.patches_per_image\n+        )\n+        reshaped_vision_outputs = reshaped_vision_outputs.contiguous()\n+\n+        pooled_vision_outputs = self.avg_pool(reshaped_vision_outputs)\n+        pooled_vision_outputs = pooled_vision_outputs.flatten(2)\n+        pooled_vision_outputs = pooled_vision_outputs.transpose(1, 2)\n+\n+        normed_vision_outputs = self.mm_soft_emb_norm(pooled_vision_outputs)\n+\n+        projected_vision_outputs = torch.matmul(normed_vision_outputs, self.mm_input_projection_weight)\n+        return projected_vision_outputs.type_as(vision_outputs)\n+\n+\n+@add_start_docstrings(\n+    \"\"\"The GEMMA3 model which consists of a vision backbone and a language model.\"\"\",\n+    GEMMA3_START_DOCSTRING,\n+)\n+class Gemma3ForConditionalGeneration(Gemma3PreTrainedModel, GenerationMixin):\n+    def __init__(self, config: Gemma3Config):\n+        super().__init__(config)\n+        self.vision_tower = AutoModel.from_config(config=config.vision_config)\n+        self.multi_modal_projector = Gemma3MultiModalProjector(config)\n+        self.vocab_size = config.text_config.vocab_size\n+\n+        language_model = AutoModelForCausalLM.from_config(config=config.text_config)\n+\n+        if language_model._tied_weights_keys is not None:\n+            self._tied_weights_keys = [f\"language_model.{k}\" for k in language_model._tied_weights_keys]\n+        self.language_model = language_model\n+\n+        self.pad_token_id = self.config.pad_token_id if self.config.pad_token_id is not None else -1\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.language_model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.language_model.set_input_embeddings(value)\n+\n+    def get_output_embeddings(self):\n+        return self.language_model.get_output_embeddings()\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.language_model.set_output_embeddings(new_embeddings)\n+\n+    def set_decoder(self, decoder):\n+        self.language_model.set_decoder(decoder)\n+\n+    def get_decoder(self):\n+        return self.language_model.get_decoder()\n+\n+    def _update_causal_mask(\n+        self,\n+        attention_mask,\n+        token_type_ids,\n+        past_key_values,\n+        cache_position,\n+        input_tensor,\n+        is_training: bool = False,\n+    ):\n+        if self.config.text_config._attn_implementation == \"flash_attention_2\":\n+            return attention_mask\n+\n+        if attention_mask is not None and attention_mask.dim() == 4:\n+            # In this case we assume that the mask comes already in inverted\n+            # form and requires no inversion or slicing.\n+            return attention_mask\n+\n+        using_static_cache = isinstance(past_key_values, StaticCache)\n+        min_dtype = torch.finfo(self.dtype).min\n+        inputs_lead_dim, sequence_length = input_tensor.shape[:2]\n+        if using_static_cache:\n+            target_length = past_key_values.get_max_cache_shape()\n+        elif isinstance(past_key_values, HybridCache):\n+            target_length = past_key_values.get_max_cache_shape()\n+        else:\n+            target_length = (\n+                attention_mask.shape[-1]\n+                if isinstance(attention_mask, torch.Tensor)\n+                else cache_position[0] + sequence_length + 1\n+            )\n+\n+        if attention_mask is not None and attention_mask.dim() == 4:\n+            # In this case we assume that the mask comes already in inverted form and requires no inversion or slicing.\n+            return attention_mask\n+\n+        causal_mask = torch.full(\n+            (sequence_length, target_length), fill_value=min_dtype, dtype=self.dtype, device=cache_position.device\n+        )\n+\n+        # Causal diagonal mask only if training, otherwise attend to the whole prefix. Training-specific attn for prefix is handled below\n+        if sequence_length != 1:\n+            causal_mask = torch.triu(causal_mask, diagonal=1)\n+\n+        causal_mask *= torch.arange(target_length, device=cache_position.device) > cache_position.reshape(-1, 1)\n+        causal_mask = causal_mask[None, None, :, :].expand(inputs_lead_dim, 1, -1, -1)\n+\n+        # Apply bidirectional mask on images if token type ids are provided\n+        if token_type_ids is not None and sequence_length != 1:\n+            token_type_mask = token_type_ids.unsqueeze(1) == token_type_ids.unsqueeze(2)\n+            token_type_mask[token_type_ids == 0] = False  # if text token do not change anything\n+            token_type_mask = token_type_mask.unsqueeze(1).to(causal_mask.device, dtype=torch.bool)\n+            causal_mask = causal_mask.clone()\n+            causal_mask[:, :, :, :sequence_length] = causal_mask[:, :, :, :sequence_length].masked_fill(\n+                token_type_mask, 0.0\n+            )\n+\n+        if attention_mask is not None:\n+            causal_mask = causal_mask.clone()  # copy to contiguous memory for in-place edit\n+            mask_length = attention_mask.shape[-1]\n+\n+            # Then apply padding mask (will mask pad tokens)\n+            padding_mask = causal_mask[:, :, :, :mask_length] + attention_mask[:, None, None, :].to(causal_mask.device)\n+            padding_mask = padding_mask == 0\n+            causal_mask[:, :, :, :mask_length] = causal_mask[:, :, :, :mask_length].masked_fill(\n+                padding_mask, min_dtype\n+            )\n+\n+        return causal_mask\n+\n+    def get_image_features(self, pixel_values: torch.Tensor):\n+        \"\"\"\n+        Projects the last hidden state from the vision model into language model space.\n+\n+        Args:\n+            pixel_values (`torch.FloatTensor]` of shape `(batch_size, channels, height, width)`)\n+               The tensors corresponding to the input images.\n+        Returns:\n+            image_features (`torch.Tensor`): Image feature tensor of shape `(num_images, image_length, embed_dim)`).\n+        \"\"\"\n+        vision_outputs = self.vision_tower(pixel_values=pixel_values).last_hidden_state\n+        image_features = self.multi_modal_projector(vision_outputs)\n+        return image_features\n+\n+    @deprecate_kwarg(\"num_logits_to_keep\", version=\"4.50\", new_name=\"logits_to_keep\")\n+    @add_start_docstrings_to_model_forward(GEMMA3_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=Gemma3CausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        pixel_values: torch.FloatTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Union[List[torch.FloatTensor], Cache]] = None,\n+        token_type_ids: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **lm_kwargs,\n+    ) -> Union[Tuple, Gemma3CausalLMOutputWithPast]:\n+        r\"\"\"\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.text_config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, ..., config.text_config.vocab_size]`.\n+\n+            logits_to_keep (`int` or `torch.Tensor`, *optional*):\n+                If an `int`, compute logits for the last `logits_to_keep` tokens. If `0`, calculate logits for all\n+                `input_ids` (special case). Only last token logits are needed for generation, and calculating them only for that\n+                token can save memory, which becomes pretty significant for long sequences or large vocabulary size.\n+                If a `torch.Tensor`, must be 1D corresponding to the indices to keep in the sequence length dimension.\n+                This is useful when using packed tensor format (single dimension for batch and sequence length).\n+\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> from PIL import Image\n+        >>> import requests\n+        >>> from transformers import AutoProcessor, Gemma3ForConditionalGeneration\n+\n+        >>> model = Gemma3ForConditionalGeneration.from_pretrained(\"google/Gemma3-test-224px-hf\")\n+        >>> processor = AutoProcessor.from_pretrained(\"google/Gemma3-test-224px-hf\")\n+\n+        >>> prompt = \"answer en Where is the cow standing?\"\n+        >>> url = \"https://huggingface.co/gv-hf/Gemma3-test-224px-hf/resolve/main/cow_beach_1.png\"\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> inputs = processor(images=image, text=prompt,  return_tensors=\"pt\")\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(**inputs, max_length=30)\n+        >>> processor.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"answer en Where is the cow standing?\\nbeach\"\n+        ```\"\"\"\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        is_training = token_type_ids is not None and labels is not None\n+\n+        # Replace image id woth PAD if the image token if OOV, to avoid index-errors\n+        if input_ids is not None and self.config.image_token_index >= self.vocab_size:\n+            special_image_mask = input_ids == self.config.image_token_index\n+            llm_input_ids = input_ids.clone()\n+            llm_input_ids[special_image_mask] = 0\n+        else:\n+            llm_input_ids = input_ids\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.get_input_embeddings()(llm_input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0) + 1  # Gemma3 positions are 1-indexed\n+\n+        # Merge text and images\n+        if pixel_values is not None:\n+            image_features = self.get_image_features(pixel_values)\n+\n+            if input_ids is None:\n+                special_image_mask = inputs_embeds == self.get_input_embeddings()(\n+                    torch.tensor(self.config.image_token_index, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            else:\n+                special_image_mask = (input_ids == self.config.image_token_index).unsqueeze(-1)\n+                special_image_mask = special_image_mask.expand_as(inputs_embeds).to(inputs_embeds.device)\n+\n+            if not is_torchdynamo_compiling() and inputs_embeds[special_image_mask].numel() != image_features.numel():\n+                image_tokens_in_text = (special_image_mask).sum(dim=1).sum(dim=0)[0]\n+                raise ValueError(\n+                    f\"Number of images does not match number of special image tokens in the input text. \"\n+                    f\"Got {image_tokens_in_text} image tokens in the text but {image_features.shape[0] * image_features.shape[1]} \"\n+                    \"tokens from image embeddings.\"\n+                )\n+            image_features = image_features.to(inputs_embeds.device, inputs_embeds.dtype)\n+            inputs_embeds = inputs_embeds.masked_scatter(special_image_mask, image_features)\n+\n+        # mask out pad-token-ids in labels for BC\n+        if labels is not None and self.pad_token_id in labels:\n+            logger.warning_once(\n+                \"`labels` contains `pad_token_id` which will be masked with `config.ignore_index`. \"\n+                \"You have to mask out `pad_token_id` when preparing `labels`, this behavior will be removed in v.4.46.\",\n+            )\n+            labels = torch.where(input_ids == self.pad_token_id, self.config.ignore_index, labels)\n+\n+        causal_mask = self._update_causal_mask(\n+            attention_mask, token_type_ids, past_key_values, cache_position, inputs_embeds, is_training\n+        )\n+        outputs = self.language_model(\n+            attention_mask=causal_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+            cache_position=cache_position,\n+            logits_to_keep=logits_to_keep,\n+            **lm_kwargs,\n+        )\n+\n+        logits = outputs.logits\n+        loss = None\n+        if labels is not None:\n+            # Upcast to float if we need to compute the loss to avoid potential precision issues\n+            logits = logits.float()\n+            shift_logits = logits[..., :-1, :]\n+            shift_labels = labels[..., 1:]\n+            if attention_mask is not None:\n+                # we use the input attention mask to shift the logits and labels, because it is 2D.\n+                # we also crop attn mask in case it is longer, which happens in PrefixTuning with peft\n+                shift_attention_mask = attention_mask[:, -shift_logits.shape[1] :].to(logits.device)\n+                shift_logits = shift_logits[shift_attention_mask.to(logits.device) != 0].contiguous()\n+                shift_labels = shift_labels[shift_attention_mask.to(shift_labels.device) != 0].contiguous()\n+            else:\n+                shift_logits = shift_logits.contiguous()\n+                shift_labels = shift_labels.contiguous()\n+            # Flatten the tokens\n+            loss_fct = nn.CrossEntropyLoss()\n+\n+            flat_logits = shift_logits.view(-1, self.config.text_config.vocab_size)\n+            flat_labels = shift_labels.view(-1).to(shift_logits.device)\n+            loss = loss_fct(flat_logits, flat_labels)\n+        if not return_dict:\n+            output = (logits,) + outputs[1:]\n+            return (loss,) + output if loss is not None else output\n+\n+        return Gemma3CausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            image_hidden_states=image_features if pixel_values is not None else None,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        position_ids=None,\n+        pixel_values=None,\n+        attention_mask=None,\n+        token_type_ids=None,\n+        use_cache=True,\n+        logits_to_keep=None,\n+        labels=None,\n+        **kwargs,\n+    ):\n+        # Overwritten -- custom `position_ids` and `pixel_values` handling\n+        model_inputs = self.language_model.prepare_inputs_for_generation(\n+            input_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            cache_position=cache_position,\n+            use_cache=use_cache,\n+            logits_to_keep=logits_to_keep,\n+            token_type_ids=token_type_ids,\n+            **kwargs,\n+        )\n+\n+        # position_ids in Gemma3 are 1-indexed\n+        if model_inputs.get(\"position_ids\") is not None:\n+            model_inputs[\"position_ids\"] += 1\n+        # If we're in cached decoding stage, pixel values should be None because input ids do not contain special image token anymore\n+        # Otherwise we need pixel values to be passed to model. NOTE: use_cache=False needs pixel_values always\n+        if cache_position[0] == 0:\n+            model_inputs[\"pixel_values\"] = pixel_values\n+        is_training = token_type_ids is not None and labels is not None\n+        if cache_position[0] == 0 and isinstance(past_key_values, HybridCache):\n+            input_tensor = inputs_embeds if inputs_embeds is not None else input_ids\n+            causal_mask = self._update_causal_mask(\n+                attention_mask, token_type_ids, past_key_values, cache_position, input_tensor, is_training\n+            )\n+            model_inputs[\"attention_mask\"] = causal_mask\n+\n+        return model_inputs\n+\n+    def tie_weights(self):\n+        return self.language_model.tie_weights()\n+\n+\n+__all__ = [\"Gemma3PreTrainedModel\", \"Gemma3TextModel\", \"Gemma3ForCausalLM\", \"Gemma3ForConditionalGeneration\"]"
        },
        {
            "sha": "2626e958326e2a34b23572a975653272ef7e3010",
            "filename": "src/transformers/models/gemma3/modular_gemma3.py",
            "status": "added",
            "additions": 848,
            "deletions": 0,
            "changes": 848,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fmodular_gemma3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fmodular_gemma3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3%2Fmodular_gemma3.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -0,0 +1,848 @@\n+# coding=utf-8\n+# Copyright 2025 Google Inc. HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import copy\n+from collections.abc import Callable\n+from dataclasses import dataclass\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+import torch.nn as nn\n+import torch.utils.checkpoint\n+\n+from ...cache_utils import Cache, HybridCache, StaticCache\n+from ...configuration_utils import PretrainedConfig\n+from ...modeling_flash_attention_utils import FlashAttentionKwargs\n+from ...modeling_outputs import (\n+    BaseModelOutputWithPast,\n+    ModelOutput,\n+)\n+from ...modeling_rope_utils import rope_config_validation\n+from ...modeling_utils import ALL_ATTENTION_FUNCTIONS\n+from ...processing_utils import Unpack\n+from ...utils import (\n+    logging,\n+)\n+from ..bart.modeling_bart import BartScaledWordEmbedding\n+from ..gemma2.configuration_gemma2 import Gemma2Config\n+from ..gemma2.modeling_gemma2 import (\n+    Gemma2Attention,\n+    Gemma2ForCausalLM,\n+    Gemma2MLP,\n+    Gemma2Model,\n+    Gemma2PreTrainedModel,\n+    Gemma2RMSNorm,\n+    Gemma2RotaryEmbedding,\n+    apply_rotary_pos_emb,\n+    eager_attention_forward,\n+)\n+from ..paligemma.modeling_paligemma import PaliGemmaForConditionalGeneration\n+from ..siglip import SiglipVisionConfig\n+\n+\n+_CHECKPOINT_FOR_DOC = \"google/gemma-3-4b\"\n+_CONFIG_FOR_DOC = \"Gemma3Config\"\n+\n+logger = logging.get_logger(__name__)\n+\n+GEMMA3_INPUTS_DOCSTRING = \"\"\n+\n+\n+class Gemma3TextConfig(Gemma2Config):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Gemma3TextModel`]. It is used to instantiate an Gemma3Text\n+    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n+    defaults will yield a similar configuration to that of the Gemma3Text-7B.\n+    e.g. [google/gemma3_text-7b](https://huggingface.co/google/gemma3_text-7b)\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 262208):\n+            Vocabulary size of the Gemma3Text model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Gemma3TextModel`]\n+        hidden_size (`int`, *optional*, defaults to 2304):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 9216):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 26):\n+            Number of hidden layers in the Transformer decoder.\n+        num_attention_heads (`int`, *optional*, defaults to 8):\n+            Number of attention heads for each attention layer in the Transformer decoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 4):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to\n+            `num_attention_heads`.\n+        head_dim (`int`, *optional*, defaults to 256):\n+            The attention head dimension.\n+        hidden_activation (`str` or `function`, *optional*, defaults to `\"gelu_pytorch_tanh\"`):\n+            The non-linear activation function (function or string) in the decoder. Will default to `\"gelu_pytorch_tanh\"`\n+            if not specified. `\"gelu_pytorch_tanh\"` uses an approximation of the `\"gelu\"` activation function.\n+        max_position_embeddings (`int`, *optional*, defaults to 131072):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        pad_token_id (`int`, *optional*, defaults to 0):\n+            Padding token id.\n+        eos_token_id (`int`, *optional*, defaults to 1):\n+            End of stream token id.\n+        bos_token_id (`int`, *optional*, defaults to 2):\n+            Beginning of stream token id.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `True`):\n+            Whether to tie weight embeddings\n+        rope_theta (`float`, *optional*, defaults to 1000000.0):\n+            The base period of the RoPE embeddings.\n+        attention_bias (`bool`, defaults to `False`, *optional*, defaults to `False`):\n+            Whether to use a bias in the query, key, value and output projection layers during self-attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        query_pre_attn_scalar (`float`, *optional*, defaults to 256):\n+            Scaling factor used on the attention scores\n+        sliding_window (`int`, *optional*, defaults to 4096): in Gemma3Text, every other layer uses sliding window attention. This is the\n+            size of the sliding window.\n+        final_logit_softcapping (`float`, *optional*):\n+            Scaling factor when applying tanh softcapping on the logits.\n+        attn_logit_softcapping (`float`, *optional*):\n+            Scaling factor when applying tanh softcapping on the attention scores.\n+        cache_implementation (`str`, *optional*, defaults to `\"hybrid\"`): the cache type to be used with `generate`.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings used in gloabl attention. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n+                    'llama3'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n+                    pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n+                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n+                    `factor` field to infer the suggested value.\n+                `beta_fast` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for extrapolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 32.\n+                `beta_slow` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for interpolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 1.\n+                `short_factor` (`List[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to short contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `long_factor` (`List[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to long contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `low_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to low frequency components of the RoPE\n+                `high_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to high frequency components of the RoPE\n+        rope_local_base_freq (float, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings for local attention.\n+        sliding_window_pattern (`int`, *optional*, defaults to 6):\n+            Pattern for the sliding window attention.\n+\n+    ```python\n+    >>> from transformers import Gemma3TextModel, Gemma3TextConfig\n+    >>> # Initializing a Gemma3Text gemma3_text-7b style configuration\n+    >>> configuration = Gemma3TextConfig()\n+    >>> # Initializing a model from the gemma3_text-7b style configuration\n+    >>> model = Gemma3TextModel(configuration)\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\n+        rope_local_base_freq (float, *optional*, defaults to 10000.0):\n+            The base period of the RoPE embeddings for local attention.\n+        sliding_window_pattern (`int`, *optional*, defaults to 6):\n+            Pattern for the sliding window attention.\n+    \"\"\"\n+\n+    model_type = \"gemma3_text\"\n+\n+    def __init__(\n+        self,\n+        vocab_size=262_208,\n+        rope_theta=1_000_000.0,\n+        rope_scaling=None,\n+        rope_local_base_freq=10_000.0,\n+        sliding_window_pattern=6,\n+        max_position_embeddings=131_072,\n+        final_logit_softcapping=None,\n+        attn_logit_softcapping=None,\n+        **super_kwargs,\n+    ):\n+        super().__init__(self, **super_kwargs)\n+\n+        self.rope_local_base_freq = rope_local_base_freq\n+        # For configuring HybridCache to work with 5:1 attention pattern\n+        self.sliding_window_pattern = sliding_window_pattern\n+        self.rope_scaling = rope_scaling\n+        rope_config_validation(self)\n+\n+\n+class Gemma3Config(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Gemma3ForConditionalGeneration`]. It is used to instantiate an\n+    Gemma3ForConditionalGeneration according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of the PaliGemma-2B.\n+\n+    e.g. [google/gemma-3-4b](https://huggingface.co/google/gemma-3-4b)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        text_config (`Union[Gemma3TextConfig, dict]`, *optional*):\n+            The config object of the text backbone.\n+        vision_config (`Union[AutoConfig, dict]`,  *optional*):\n+            Custom vision config or dict.\n+        mm_tokens_per_image (`int`, *optional*, defaults to 256):\n+            The number of tokens per image embedding.\n+        boi_token_index (`int`, *optional*, defaults to 255999):\n+            The begin-of-image token index to wrap the image prompt.\n+        eoi_token_index (`int`, *optional*, defaults to 256000):\n+            The end-of-image token index to wrap the image prompt.\n+        image_token_index (`int`, *optional*, defaults to 262144):\n+            The image token index to encode the image prompt.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import Gemma3ForConditionalGeneration, Gemma3Config, SiglipVisionConfig, Gemma3TextConfig\n+\n+    >>> # Initializing a Siglip-like vision config\n+    >>> vision_config = SiglipVisionConfig()\n+\n+    >>> # Initializing a Gemma3 Text config\n+    >>> text_config = Gemma3TextConfig()\n+\n+    >>> # Initializing a Gemma3 gemma-3-4b style configuration\n+    >>> configuration = Gemma3Config(vision_config, text_config)\n+\n+    >>> # Initializing a model from the gemma-3-4b style configuration\n+    >>> model = Gemma3TextConfig(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"gemma3\"\n+    sub_configs = {\n+        \"text_config\": Gemma3TextConfig,\n+        \"vision_config\": SiglipVisionConfig,\n+    }\n+\n+    def __init__(\n+        self,\n+        text_config: Optional[Gemma3TextConfig] = None,\n+        vision_config: Optional[SiglipVisionConfig] = None,\n+        mm_tokens_per_image: int = 256,\n+        boi_token_index: int = 255_999,\n+        eoi_token_index: int = 256_000,\n+        image_token_index: int = 262_144,\n+        initializer_range: float = 0.02,\n+        **kwargs,\n+    ):\n+        if text_config is None:\n+            text_config = Gemma3TextConfig()\n+            logger.info(\"text_config is None, using default Gemma3TextConfig vision config.\")\n+        elif isinstance(text_config, dict):\n+            text_config = Gemma3TextConfig(**text_config)\n+\n+        if isinstance(vision_config, dict):\n+            vision_config = SiglipVisionConfig(**vision_config)\n+        else:\n+            vision_config = SiglipVisionConfig()\n+            logger.info(\n+                \"vision_config is None or incompatible with Gemma3VisionConfig intialization. Gemma3 will be limited \"\n+                \"to text tasks.\"\n+            )\n+\n+        self.text_config = text_config\n+        self.vision_config = vision_config\n+        self.mm_tokens_per_image = mm_tokens_per_image\n+        self.boi_token_index = boi_token_index\n+        self.eoi_token_index = eoi_token_index\n+        self.image_token_index = image_token_index\n+        self.initializer_range = initializer_range\n+\n+        super().__init__(**kwargs)\n+\n+\n+@dataclass\n+class Gemma3CausalLMOutputWithPast(ModelOutput):\n+    \"\"\"\n+    Base class for Gemma3 causal language model (or autoregressive) outputs.\n+\n+    Args:\n+        loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+            Language modeling loss (for next-token prediction).\n+        logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.text_config.vocab_size)`):\n+            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+            `past_key_values` input) to speed up sequential decoding.\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        image_hidden_states (`torch.FloatTensor`, *optional*):\n+            A `torch.FloatTensor` of size `(batch_size, sequence_length, hidden_size)`.\n+            image_hidden_states of the model produced by the vision encoder after projecting last hidden state.\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: torch.FloatTensor = None\n+    past_key_values: Optional[Union[List[torch.FloatTensor], Cache]] = None\n+    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+    attentions: Optional[Tuple[torch.FloatTensor]] = None\n+    image_hidden_states: Optional[torch.FloatTensor] = None\n+\n+\n+class Gemma3TextScaledWordEmbedding(BartScaledWordEmbedding):\n+    pass\n+\n+\n+class Gemma3MLP(Gemma2MLP):\n+    def __init__(self, config: Gemma3TextConfig):\n+        super().__init__(config)\n+\n+\n+class Gemma3RMSNorm(Gemma2RMSNorm):\n+    def __init__(self, dim: int, eps: float = 1e-6):\n+        super().__init__()\n+\n+\n+class Gemma3RotaryEmbedding(Gemma2RotaryEmbedding):\n+    def __init__(self, config: Gemma3TextConfig, device=None):\n+        super().__init__(config)\n+\n+\n+# Weird way to inherit but otherwise the sliding window gets defined first and can't access `is_sliding`\n+class Gemma3Attention(Gemma2Attention):\n+    def __init__(self, config: Gemma3TextConfig, layer_idx: int):\n+        self.is_sliding = bool((layer_idx + 1) % config.sliding_window_pattern)\n+\n+        super().__init__()\n+        self.sliding_window = config.sliding_window if self.is_sliding else None\n+\n+        self.q_norm = Gemma3RMSNorm(dim=config.head_dim, eps=config.rms_norm_eps)\n+        self.k_norm = Gemma3RMSNorm(dim=config.head_dim, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor],\n+        past_key_value: Optional[Cache] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> tuple[torch.Tensor, Optional[torch.Tensor], Optional[tuple[torch.Tensor]]]:\n+        input_shape = hidden_states.shape[:-1]\n+        hidden_shape = (*input_shape, -1, self.head_dim)\n+\n+        query_states = self.q_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        key_states = self.k_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+        value_states = self.v_proj(hidden_states).view(hidden_shape).transpose(1, 2)\n+\n+        query_states = self.q_norm(query_states)\n+        key_states = self.k_norm(key_states)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_rotary_pos_emb(query_states, key_states, cos, sin)\n+\n+        if past_key_value is not None:\n+            # sin and cos are specific to RoPE models; cache_position needed for the static cache\n+            cache_kwargs = {\n+                \"sin\": sin,\n+                \"cos\": cos,\n+                \"cache_position\": cache_position,\n+                \"sliding_window\": self.sliding_window,\n+            }\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+            # Here we need to slice as we use a static cache by default, but FA2 does not support it\n+            if attention_mask is not None and self.config._attn_implementation == \"flash_attention_2\":\n+                seq_len = attention_mask.shape[-1]\n+                key_states, value_states = key_states[:, :, :seq_len, :], value_states[:, :, :seq_len, :]\n+\n+        attention_interface: Callable = eager_attention_forward\n+        if self.config._attn_implementation != \"eager\":\n+            if self.config._attn_implementation == \"sdpa\" and kwargs.get(\"output_attentions\", False):\n+                logger.warning_once(\n+                    \"`torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. \"\n+                    \"Falling back to eager attention. This warning can be removed using the argument \"\n+                    '`attn_implementation=\"eager\"` when loading the model.'\n+                )\n+            else:\n+                attention_interface = ALL_ATTENTION_FUNCTIONS[self.config._attn_implementation]\n+\n+        attn_output, attn_weights = attention_interface(\n+            self,\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask.to(query_states),\n+            dropout=self.attention_dropout if self.training else 0.0,\n+            scaling=self.scaling,\n+            sliding_window=self.sliding_window,\n+            **kwargs,\n+        )\n+\n+        attn_output = attn_output.reshape(*input_shape, -1).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+        return attn_output, attn_weights\n+\n+\n+class Gemma3DecoderLayer(nn.Module):\n+    def __init__(self, config: Gemma3TextConfig, layer_idx: int):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.layer_idx = layer_idx\n+        self.self_attn = Gemma3Attention(config=config, layer_idx=layer_idx)\n+        self.mlp = Gemma3MLP(config)\n+        self.input_layernorm = Gemma3RMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = Gemma3RMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+        self.pre_feedforward_layernorm = Gemma3RMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+        self.post_feedforward_layernorm = Gemma3RMSNorm(self.hidden_size, eps=config.rms_norm_eps)\n+        self.is_sliding = self.self_attn.is_sliding\n+        self.sliding_window = config.sliding_window\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        position_embeddings_global: torch.Tensor,\n+        position_embeddings_local: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: Optional[bool] = False,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        last_cache_position: int = 0,\n+        **kwargs,\n+    ) -> tuple[torch.FloatTensor, Optional[tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        if self.is_sliding and attention_mask is not None:  # efficient SDPA and no padding\n+            # In prefill, we may be larger than sliding window\n+            effective_seq_len = max(cache_position.shape[0], self.sliding_window)\n+            # For FA2, the mask is 2D and is of shape [bs, processed_tokens] (not [bs, max_cache_len]),\n+            # thus we must slice from the right (at most `effective_seq_len` elements)\n+            if self.config._attn_implementation == \"flash_attention_2\":\n+                attention_mask = attention_mask[:, -effective_seq_len:]\n+            # Otherwise, the mask is 4D of shape [bs, 1, query_len, max_cache_len] thus we must slice\n+            # from the left, with an offset if we are beyond the sliding window\n+            else:\n+                min_dtype = torch.finfo(attention_mask.dtype).min\n+                sliding_window_mask = torch.tril(\n+                    torch.ones_like(attention_mask, dtype=torch.bool), diagonal=-self.sliding_window\n+                )\n+                attention_mask = torch.where(sliding_window_mask, min_dtype, attention_mask)\n+                # In case we are beyond the sliding window, we need to correctly offset the mask slicing\n+                # `last_cache_position` is equivalent to `cache_position[-1]` but without breaking dynamo\n+                offset = last_cache_position - effective_seq_len\n+                # Should only be used when beyond the sliding window (i.e. offset > 0)\n+                offset = max(0, offset)\n+                attention_mask = attention_mask[:, :, :, offset : offset + effective_seq_len]\n+\n+        residual = hidden_states\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # apply global RoPE to non-sliding layer only\n+        if self.self_attn.is_sliding:\n+            position_embeddings = position_embeddings_local\n+        else:\n+            position_embeddings = position_embeddings_global\n+\n+        hidden_states, self_attn_weights = self.self_attn(\n+            hidden_states=hidden_states,\n+            position_embeddings=position_embeddings,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        residual = hidden_states\n+        hidden_states = self.pre_feedforward_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = self.post_feedforward_layernorm(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        outputs = (hidden_states,)\n+\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        return outputs\n+\n+\n+GEMMA3_START_DOCSTRING = None\n+\n+\n+class Gemma3PreTrainedModel(Gemma2PreTrainedModel):\n+    base_model_prefix = \"language_model\"\n+    _no_split_modules = [\n+        \"Gemma3DecoderLayer\",\n+        \"SiglipVisionEmbeddings\",\n+        \"SiglipEncoderLayer\",\n+        \"SiglipMultiheadAttentionPoolingHead\",\n+    ]\n+\n+    def _init_weights(self, module):\n+        # important: this ported version of Gemma2 isn't meant for training from scratch - only\n+        # inference and fine-tuning - so the proper init weights code has been removed\n+        std = (\n+            self.config.initializer_range\n+            if hasattr(self.config, \"initializer_range\")\n+            else self.config.text_config.initializer_range\n+        )\n+\n+        if isinstance(module, (nn.Linear, nn.Conv2d)):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+\n+\n+class Gemma3TextModel(Gemma2Model):\n+    config_class = Gemma3TextConfig\n+\n+    def __init__(self, config: Gemma3TextConfig):\n+        super().__init__(config)\n+\n+        # Gemma3 downcasts the below to float16, causing sqrt(3072)=55.4256 to become 55.5. See https://github.com/huggingface/transformers/pull/29402\n+        self.embed_tokens = Gemma3TextScaledWordEmbedding(\n+            config.vocab_size, config.hidden_size, self.padding_idx, embed_scale=self.config.hidden_size**0.5\n+        )\n+\n+        # TODO: raushan fix this after RoPE refactor. For now we hack it by reassigning thetas\n+        # when we want to create a local RoPE layer. Config defaults should hold values for global RoPE\n+        config = copy.deepcopy(config)\n+        config.rope_theta = config.rope_local_base_freq\n+        config.rope_scaling = {\"rope_type\": \"default\"}\n+        self.rotary_emb_local = Gemma3RotaryEmbedding(config=config)\n+\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[HybridCache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        last_cache_position: Optional[int] = None,\n+        **flash_attn_kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> Union[tuple, BaseModelOutputWithPast]:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if self.gradient_checkpointing and self.training and use_cache:\n+            logger.warning_once(\n+                \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`.\"\n+            )\n+            use_cache = False\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if use_cache and past_key_values is None and not self.training:\n+            batch_size, seq_len, _ = inputs_embeds.shape\n+            past_key_values = HybridCache(\n+                self.config,\n+                max_batch_size=batch_size,\n+                max_cache_len=seq_len,\n+                dtype=inputs_embeds.dtype,\n+            )\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens,\n+                past_seen_tokens + inputs_embeds.shape[1],\n+                device=inputs_embeds.device,\n+            )\n+\n+        if position_ids is None:\n+            position_ids = cache_position.unsqueeze(0)\n+\n+        # This is needed to correctly slice the mask without data-dependent slicing later on if using dynamo tracing\n+        # (retrieving the same value from `cache_position` later on would crash dynamo)\n+        if last_cache_position is None:\n+            last_cache_position = 0\n+            if attention_mask is not None:\n+                # In case a 4d mask is passed directly without using `generate`, we have to rely on cache_position\n+                # It will break dynamo tracing but there are no way around it (and it should never happen in practice)\n+                last_cache_position = (\n+                    attention_mask.shape[-1] if attention_mask.dim() == 2 else cache_position[-1].item()\n+                )\n+        causal_mask = self._update_causal_mask(\n+            attention_mask,\n+            inputs_embeds,\n+            cache_position,\n+            past_key_values,\n+            output_attentions,\n+        )\n+\n+        # embed positions\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings_global = self.rotary_emb(hidden_states, position_ids)\n+        position_embeddings_local = self.rotary_emb_local(hidden_states, position_ids)\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+\n+        for decoder_layer in self.layers[: self.config.num_hidden_layers]:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            if self.gradient_checkpointing and self.training:\n+                layer_outputs = self._gradient_checkpointing_func(\n+                    decoder_layer.__call__,\n+                    hidden_states,\n+                    position_embeddings_global,\n+                    position_embeddings_local,\n+                    causal_mask,\n+                    position_ids,\n+                    past_key_values,\n+                    output_attentions,\n+                    use_cache,\n+                    cache_position,\n+                    last_cache_position,\n+                )\n+            else:\n+                layer_outputs = decoder_layer(\n+                    hidden_states,\n+                    position_embeddings_global=position_embeddings_global,\n+                    position_embeddings_local=position_embeddings_local,\n+                    attention_mask=causal_mask,\n+                    position_ids=position_ids,\n+                    past_key_value=past_key_values,\n+                    output_attentions=output_attentions,\n+                    use_cache=use_cache,\n+                    cache_position=cache_position,\n+                    last_cache_position=last_cache_position,\n+                    **flash_attn_kwargs,\n+                )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        output = BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+        )\n+        return output if return_dict else output.to_tuple()\n+\n+\n+class Gemma3ForCausalLM(Gemma2ForCausalLM):\n+    config_class = Gemma3TextConfig\n+    base_model_prefix = \"language_model\"\n+\n+    def __init__(self, config: Gemma3TextConfig):\n+        super().__init__(config)\n+        self.model = Gemma3TextModel(config)\n+\n+\n+class Gemma3MultiModalProjector(nn.Module):\n+    def __init__(self, config: Gemma3Config):\n+        super().__init__()\n+\n+        self.mm_input_projection_weight = nn.Parameter(\n+            torch.zeros(config.vision_config.hidden_size, config.text_config.hidden_size)\n+        )\n+\n+        self.mm_soft_emb_norm = Gemma3RMSNorm(\n+            config.vision_config.hidden_size, eps=config.vision_config.layer_norm_eps\n+        )\n+\n+        self.patches_per_image = int(config.vision_config.image_size // config.vision_config.patch_size)\n+        self.tokens_per_side = int(config.mm_tokens_per_image**0.5)\n+        self.kernel_size = self.patches_per_image // self.tokens_per_side\n+        self.avg_pool = nn.AvgPool2d(kernel_size=self.kernel_size, stride=self.kernel_size)\n+\n+    def forward(self, vision_outputs: torch.Tensor):\n+        batch_size, _, seq_length = vision_outputs.shape\n+\n+        reshaped_vision_outputs = vision_outputs.transpose(1, 2)\n+        reshaped_vision_outputs = reshaped_vision_outputs.reshape(\n+            batch_size, seq_length, self.patches_per_image, self.patches_per_image\n+        )\n+        reshaped_vision_outputs = reshaped_vision_outputs.contiguous()\n+\n+        pooled_vision_outputs = self.avg_pool(reshaped_vision_outputs)\n+        pooled_vision_outputs = pooled_vision_outputs.flatten(2)\n+        pooled_vision_outputs = pooled_vision_outputs.transpose(1, 2)\n+\n+        normed_vision_outputs = self.mm_soft_emb_norm(pooled_vision_outputs)\n+\n+        projected_vision_outputs = torch.matmul(normed_vision_outputs, self.mm_input_projection_weight)\n+        return projected_vision_outputs.type_as(vision_outputs)\n+\n+\n+class Gemma3ForConditionalGeneration(PaliGemmaForConditionalGeneration):\n+    def tie_weights(self):\n+        return self.language_model.tie_weights()\n+\n+    def get_image_features(self, pixel_values: torch.Tensor) -> torch.Tensor:\n+        \"\"\"\n+        Projects the last hidden state from the vision model into language model space.\n+\n+        Args:\n+            pixel_values (`torch.FloatTensor]` of shape `(batch_size, channels, height, width)`)\n+               The tensors corresponding to the input images.\n+        Returns:\n+            image_features (`torch.Tensor`): Image feature tensor of shape `(num_images, image_length, embed_dim)`).\n+        \"\"\"\n+        vision_outputs = self.vision_tower(pixel_values=pixel_values).last_hidden_state\n+        image_features = self.multi_modal_projector(vision_outputs)\n+        return image_features\n+\n+    def _update_causal_mask(\n+        self,\n+        attention_mask,\n+        token_type_ids,\n+        past_key_values,\n+        cache_position,\n+        input_tensor,\n+        is_training: bool = False,\n+    ):\n+        if self.config.text_config._attn_implementation == \"flash_attention_2\":\n+            return attention_mask\n+\n+        if attention_mask is not None and attention_mask.dim() == 4:\n+            # In this case we assume that the mask comes already in inverted\n+            # form and requires no inversion or slicing.\n+            return attention_mask\n+\n+        using_static_cache = isinstance(past_key_values, StaticCache)\n+        min_dtype = torch.finfo(self.dtype).min\n+        inputs_lead_dim, sequence_length = input_tensor.shape[:2]\n+        if using_static_cache:\n+            target_length = past_key_values.get_max_cache_shape()\n+        elif isinstance(past_key_values, HybridCache):\n+            target_length = past_key_values.get_max_cache_shape()\n+        else:\n+            target_length = (\n+                attention_mask.shape[-1]\n+                if isinstance(attention_mask, torch.Tensor)\n+                else cache_position[0] + sequence_length + 1\n+            )\n+\n+        if attention_mask is not None and attention_mask.dim() == 4:\n+            # In this case we assume that the mask comes already in inverted form and requires no inversion or slicing.\n+            return attention_mask\n+\n+        causal_mask = torch.full(\n+            (sequence_length, target_length), fill_value=min_dtype, dtype=self.dtype, device=cache_position.device\n+        )\n+\n+        # Causal diagonal mask only if training, otherwise attend to the whole prefix. Training-specific attn for prefix is handled below\n+        if sequence_length != 1:\n+            causal_mask = torch.triu(causal_mask, diagonal=1)\n+\n+        causal_mask *= torch.arange(target_length, device=cache_position.device) > cache_position.reshape(-1, 1)\n+        causal_mask = causal_mask[None, None, :, :].expand(inputs_lead_dim, 1, -1, -1)\n+\n+        # Apply bidirectional mask on images if token type ids are provided\n+        if token_type_ids is not None and sequence_length != 1:\n+            token_type_mask = token_type_ids.unsqueeze(1) == token_type_ids.unsqueeze(2)\n+            token_type_mask[token_type_ids == 0] = False  # if text token do not change anything\n+            token_type_mask = token_type_mask.unsqueeze(1).to(causal_mask.device, dtype=torch.bool)\n+            causal_mask = causal_mask.clone()\n+            causal_mask[:, :, :, :sequence_length] = causal_mask[:, :, :, :sequence_length].masked_fill(\n+                token_type_mask, 0.0\n+            )\n+\n+        if attention_mask is not None:\n+            causal_mask = causal_mask.clone()  # copy to contiguous memory for in-place edit\n+            mask_length = attention_mask.shape[-1]\n+\n+            # Then apply padding mask (will mask pad tokens)\n+            padding_mask = causal_mask[:, :, :, :mask_length] + attention_mask[:, None, None, :].to(causal_mask.device)\n+            padding_mask = padding_mask == 0\n+            causal_mask[:, :, :, :mask_length] = causal_mask[:, :, :, :mask_length].masked_fill(\n+                padding_mask, min_dtype\n+            )\n+\n+        return causal_mask\n+\n+\n+__all__ = [\n+    \"Gemma3Config\",\n+    \"Gemma3TextConfig\",\n+    \"Gemma3PreTrainedModel\",  # noqa: F822\n+    \"Gemma3TextModel\",\n+    \"Gemma3ForCausalLM\",\n+    \"Gemma3ForConditionalGeneration\",\n+]"
        },
        {
            "sha": "e82b609bdb10aa207efb0a2ac306778a07647f45",
            "filename": "src/transformers/models/gemma3/processing_gemma3.py",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fprocessing_gemma3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fgemma3%2Fprocessing_gemma3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fgemma3%2Fprocessing_gemma3.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -0,0 +1,172 @@\n+# coding=utf-8\n+# Copyright 2025 Google Inc. HuggingFace Inc. team. All rights reserved.\n+#\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import re\n+from typing import List, Optional, Union\n+\n+import numpy as np\n+\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_utils import ImageInput, make_nested_list_of_images\n+from ...processing_utils import ImagesKwargs, ProcessingKwargs, ProcessorMixin, Unpack\n+from ...tokenization_utils_base import PreTokenizedInput, TextInput\n+from ...utils import to_py_obj\n+\n+\n+class Gemma3ImagesKwargs(ImagesKwargs):\n+    do_pan_and_scan: Optional[bool]\n+    pan_and_scan_min_crop_size: Optional[int]\n+    pan_and_scan_max_num_crops: Optional[int]\n+    pan_and_scan_min_ratio_to_activate: Optional[float]\n+    do_convert_rgb: Optional[bool]\n+\n+\n+class Gemma3ProcessorKwargs(ProcessingKwargs, total=False):\n+    images_kwargs: Gemma3ImagesKwargs\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": False,\n+        },\n+        \"images_kwargs\": {\n+            \"do_pan_and_scan\": False,\n+            \"pan_and_scan_min_crop_size\": 256,\n+            \"pan_and_scan_max_num_crops\": 4,\n+            \"pan_and_scan_min_ratio_to_activate\": 1.2,\n+        },\n+    }\n+\n+\n+class Gemma3Processor(ProcessorMixin):\n+    attributes = [\"image_processor\", \"tokenizer\"]\n+    valid_kwargs = [\"chat_template\", \"image_seq_length\"]\n+    image_processor_class = \"AutoImageProcessor\"\n+    tokenizer_class = \"AutoTokenizer\"\n+\n+    def __init__(\n+        self,\n+        image_processor,\n+        tokenizer,\n+        chat_template=None,\n+        image_seq_length: int = 256,\n+        **kwargs,\n+    ):\n+        self.image_seq_length = image_seq_length\n+        self.image_token_id = tokenizer.image_token_id\n+        self.boi_token = tokenizer.boi_token\n+        image_tokens_expanded = \"\".join([tokenizer.image_token] * image_seq_length)\n+        self.full_image_sequence = f\"\\n\\n{tokenizer.boi_token}{image_tokens_expanded}{tokenizer.eoi_token}\\n\\n\"\n+\n+        super().__init__(\n+            image_processor=image_processor,\n+            tokenizer=tokenizer,\n+            chat_template=chat_template,\n+            **kwargs,\n+        )\n+\n+    def __call__(\n+        self,\n+        images: ImageInput = None,\n+        text: Union[TextInput, PreTokenizedInput, List[TextInput], List[PreTokenizedInput]] = None,\n+        videos=None,\n+        audio=None,\n+        **kwargs: Unpack[Gemma3ProcessorKwargs],\n+    ) -> BatchFeature:\n+        if text is None and images is None:\n+            raise ValueError(\"Provide at least one of `text` or `images`.\")\n+\n+        output_kwargs = self._merge_kwargs(\n+            Gemma3ProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+\n+        if isinstance(text, str):\n+            text = [text]\n+        elif not isinstance(text, list) and not isinstance(text[0], str):\n+            raise ValueError(\"Invalid input text. Please provide a string, or a list of strings\")\n+\n+        image_inputs = {}\n+        if images is not None:\n+            batched_images = make_nested_list_of_images(images)\n+            image_inputs = self.image_processor(batched_images, **output_kwargs[\"images_kwargs\"])\n+\n+            # Create empty text to be replaced with placeholders\n+            if not text:\n+                text = [\" \".join([self.boi_token] * len(images)) for images in batched_images]\n+\n+            if len(batched_images) != len(text):\n+                raise ValueError(\n+                    f\"Received inconsistently sized batches of images ({len(batched_images)}) and text ({len(text)}).\"\n+                )\n+\n+            # Replace image tokens by the full expanded sequence\n+            batch_num_crops = to_py_obj(image_inputs.pop(\"num_crops\"))\n+            text_with_crops = text\n+            for batch_idx, (prompt, images, num_crops) in enumerate(zip(text, batched_images, batch_num_crops)):\n+                image_indexes = [m.start() for m in re.finditer(self.boi_token, prompt)]\n+\n+                if len(images) != len(image_indexes):\n+                    raise ValueError(\n+                        f\"Prompt contained {len(image_indexes)} image tokens but received {len(images)} images.\"\n+                    )\n+\n+                # Insert additional image tokens for Pan-and-Scan crops\n+                for num, idx in reversed(list(zip(num_crops, image_indexes))):\n+                    if num:\n+                        formatted_image_text = (\n+                            f\"Here is the original image {self.boi_token} and here are some crops to help you see better \"\n+                            + \" \".join([self.boi_token] * num)\n+                        )\n+                        prompt = prompt[:idx] + formatted_image_text + prompt[idx + len(self.boi_token) :]\n+                        text_with_crops[batch_idx] = prompt\n+\n+            # Expand placeholder image tokens to the full image token sequence\n+            text = [prompt.replace(self.boi_token, self.full_image_sequence) for prompt in text]\n+\n+        return_tensors = output_kwargs[\"text_kwargs\"].pop(\"return_tensors\", None)\n+        text_inputs = self.tokenizer(text=text, **output_kwargs[\"text_kwargs\"], return_tensors=\"np\")\n+\n+        # Add token type ids manually, as tokenizer can't do arbitrary position token types\n+        array_ids = np.array(text_inputs[\"input_ids\"])\n+        mm_token_type_ids = np.zeros_like(text_inputs[\"input_ids\"])\n+        mm_token_type_ids[array_ids == self.image_token_id] = 1\n+        text_inputs = {k: v.tolist() for k, v in text_inputs.items()}  # in case user requested list inputs\n+        text_inputs[\"token_type_ids\"] = mm_token_type_ids.tolist()\n+        return BatchFeature(data={**text_inputs, **image_inputs}, tensor_type=return_tensors)\n+\n+    # Copied from transformers.models.clip.processing_clip.CLIPProcessor.batch_decode with CLIP->Gemma\n+    def batch_decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to GemmaTokenizerFast's [`~PreTrainedTokenizer.batch_decode`]. Please\n+        refer to the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.batch_decode(*args, **kwargs)\n+\n+    # Copied from transformers.models.clip.processing_clip.CLIPProcessor.decode with CLIP->Gemma\n+    def decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to GemmaTokenizerFast's [`~PreTrainedTokenizer.decode`]. Please refer to\n+        the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.decode(*args, **kwargs)\n+\n+    @property\n+    def model_input_names(self):\n+        tokenizer_input_names = self.tokenizer.model_input_names + [\"token_type_ids\"]\n+        image_processor_input_names = self.image_processor.model_input_names\n+        return list(dict.fromkeys(tokenizer_input_names + image_processor_input_names))\n+\n+\n+__all__ = [\"Gemma3Processor\"]"
        },
        {
            "sha": "c49e91b2820a3fb4d08ea64d7ff82087c58ccb3e",
            "filename": "src/transformers/models/paligemma/modeling_paligemma.py",
            "status": "modified",
            "additions": 18,
            "deletions": 9,
            "changes": 27,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fpaligemma%2Fmodeling_paligemma.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Fmodels%2Fpaligemma%2Fmodeling_paligemma.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fpaligemma%2Fmodeling_paligemma.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -477,11 +477,6 @@ def forward(\n         if (input_ids is None) ^ (inputs_embeds is not None):\n             raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n \n-        if pixel_values is not None and inputs_embeds is not None:\n-            raise ValueError(\n-                \"You cannot specify both pixel_values and inputs_embeds at the same time, and must specify either one\"\n-            )\n-\n         output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n         output_hidden_states = (\n             output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n@@ -490,8 +485,16 @@ def forward(\n \n         is_training = token_type_ids is not None and labels is not None\n \n+        # Replace image id woth PAD if the image token if OOV, to avoid index-errors\n+        if input_ids is not None and self.config.image_token_index >= self.vocab_size:\n+            special_image_mask = input_ids == self.config.image_token_index\n+            llm_input_ids = input_ids.clone()\n+            llm_input_ids[special_image_mask] = 0\n+        else:\n+            llm_input_ids = input_ids\n+\n         if inputs_embeds is None:\n-            inputs_embeds = self.get_input_embeddings()(input_ids)\n+            inputs_embeds = self.get_input_embeddings()(llm_input_ids)\n \n         if cache_position is None:\n             past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n@@ -506,10 +509,16 @@ def forward(\n         if pixel_values is not None:\n             image_features = self.get_image_features(pixel_values)\n \n-            special_image_mask = (input_ids == self.config.image_token_index).unsqueeze(-1)\n-            special_image_mask = special_image_mask.expand_as(inputs_embeds).to(inputs_embeds.device)\n+            if input_ids is None:\n+                special_image_mask = inputs_embeds == self.get_input_embeddings()(\n+                    torch.tensor(self.config.image_token_index, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            else:\n+                special_image_mask = (input_ids == self.config.image_token_index).unsqueeze(-1)\n+                special_image_mask = special_image_mask.expand_as(inputs_embeds).to(inputs_embeds.device)\n+\n             if not is_torchdynamo_compiling() and inputs_embeds[special_image_mask].numel() != image_features.numel():\n-                image_tokens_in_text = torch.sum(input_ids == self.config.image_token_index)\n+                image_tokens_in_text = (special_image_mask).sum(dim=1).sum(dim=0)[0]\n                 raise ValueError(\n                     f\"Number of images does not match number of special image tokens in the input text. \"\n                     f\"Got {image_tokens_in_text} image tokens in the text but {image_features.shape[0] * image_features.shape[1]} \""
        },
        {
            "sha": "76bcf6fc1c3006fa1468b2e7f590873fda8d1cc8",
            "filename": "src/transformers/utils/dummy_pt_objects.py",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -4609,6 +4609,34 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torch\"])\n \n \n+class Gemma3ForCausalLM(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class Gemma3ForConditionalGeneration(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class Gemma3PreTrainedModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class Gemma3TextModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n class GitForCausalLM(metaclass=DummyObject):\n     _backends = [\"torch\"]\n "
        },
        {
            "sha": "23a55f33b0457936d7ecad83e680766d853591ef",
            "filename": "src/transformers/utils/dummy_torchvision_objects.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Futils%2Fdummy_torchvision_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Futils%2Fdummy_torchvision_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_torchvision_objects.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -58,6 +58,13 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torchvision\"])\n \n \n+class Gemma3ImageProcessorFast(metaclass=DummyObject):\n+    _backends = [\"torchvision\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torchvision\"])\n+\n+\n class GotOcr2ImageProcessorFast(metaclass=DummyObject):\n     _backends = [\"torchvision\"]\n "
        },
        {
            "sha": "f3594e1ed08750020c122391c03d208e5497d8ae",
            "filename": "src/transformers/utils/dummy_vision_objects.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -289,6 +289,13 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"vision\"])\n \n \n+class Gemma3ImageProcessor(metaclass=DummyObject):\n+    _backends = [\"vision\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"vision\"])\n+\n+\n class GLPNFeatureExtractor(metaclass=DummyObject):\n     _backends = [\"vision\"]\n "
        },
        {
            "sha": "00ac78a94d3fb581e6baf975c623b724137bf420",
            "filename": "tests/generation/test_utils.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fgeneration%2Ftest_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fgeneration%2Ftest_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_utils.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -124,6 +124,7 @@\n     \"qwen2vl\",\n     \"qwen2_5_vl\",\n     \"ayavision\",\n+    \"gemma3\",\n ]\n \n "
        },
        {
            "sha": "0b4abb85e051162e4754090e248c10a4ffa39e1d",
            "filename": "tests/models/gemma/test_modeling_gemma.py",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fmodels%2Fgemma%2Ftest_modeling_gemma.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fmodels%2Fgemma%2Ftest_modeling_gemma.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgemma%2Ftest_modeling_gemma.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -353,7 +353,6 @@ def test_model_various_embeddings(self):\n \n     def test_Gemma_sequence_classification_model(self):\n         config, input_dict = self.model_tester.prepare_config_and_inputs_for_common()\n-        print(config)\n         config.num_labels = 3\n         input_ids = input_dict[\"input_ids\"]\n         attention_mask = input_ids.ne(1).to(torch_device)"
        },
        {
            "sha": "e384db8423a78f0811f04074b985b929e3ffcca5",
            "filename": "tests/models/gemma2/test_modeling_gemma2.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fmodels%2Fgemma2%2Ftest_modeling_gemma2.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fmodels%2Fgemma2%2Ftest_modeling_gemma2.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgemma2%2Ftest_modeling_gemma2.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -153,6 +153,13 @@ def test_generate_continue_from_inputs_embeds(self):\n     def test_sdpa_equivalence(self):\n         pass\n \n+    @unittest.skip(\n+        reason=\"HybridCache can't be gathered because it is not iterable. Adding a simple iter and dumping `distributed_iterator`\"\n+        \" as in Dynamic Cache doesnt work. NOTE: @gante all cache objects would need better compatibility with multi gpu setting\"\n+    )\n+    def test_multi_gpu_data_parallel_forward(self):\n+        pass\n+\n \n @slow\n @require_torch_gpu"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/gemma3/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fmodels%2Fgemma3%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fmodels%2Fgemma3%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgemma3%2F__init__.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357"
        },
        {
            "sha": "4a26ff87adb587ef12612d6b1ea0457ca60bf93c",
            "filename": "tests/models/gemma3/test_image_processing_gemma3.py",
            "status": "added",
            "additions": 229,
            "deletions": 0,
            "changes": 229,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fmodels%2Fgemma3%2Ftest_image_processing_gemma3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fmodels%2Fgemma3%2Ftest_image_processing_gemma3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgemma3%2Ftest_image_processing_gemma3.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -0,0 +1,229 @@\n+# coding=utf-8\n+# Copyright 2025 HuggingFace Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+import numpy as np\n+\n+from transformers.image_utils import IMAGENET_STANDARD_MEAN, IMAGENET_STANDARD_STD\n+from transformers.testing_utils import require_torch, require_vision\n+from transformers.utils import is_torch_available, is_torchvision_available, is_vision_available\n+\n+from ...test_image_processing_common import ImageProcessingTestMixin, prepare_image_inputs\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+    from transformers import Gemma3ImageProcessor\n+\n+    if is_torchvision_available():\n+        from transformers import Gemma3ImageProcessorFast\n+\n+\n+class Gemma3ImageProcessingTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=7,\n+        num_channels=3,\n+        image_size=18,\n+        min_resolution=30,\n+        max_resolution=400,\n+        do_resize=True,\n+        size=None,\n+        do_normalize=True,\n+        image_mean=IMAGENET_STANDARD_MEAN,\n+        image_std=IMAGENET_STANDARD_STD,\n+        do_convert_rgb=True,\n+        do_pan_and_scan=True,\n+        pan_and_scan_min_crop_size=10,\n+        pan_and_scan_max_num_crops=2,\n+        pan_and_scan_min_ratio_to_activate=1.2,\n+    ):\n+        super().__init__()\n+        size = size if size is not None else {\"height\": 18, \"width\": 18}\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.image_size = image_size\n+        self.min_resolution = min_resolution\n+        self.max_resolution = max_resolution\n+        self.do_resize = do_resize\n+        self.size = size\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean\n+        self.image_std = image_std\n+        self.do_convert_rgb = do_convert_rgb\n+        self.do_pan_and_scan = do_pan_and_scan\n+        self.pan_and_scan_min_crop_size = pan_and_scan_min_crop_size\n+        self.pan_and_scan_max_num_crops = pan_and_scan_max_num_crops\n+        self.pan_and_scan_min_ratio_to_activate = pan_and_scan_min_ratio_to_activate\n+\n+    def prepare_image_processor_dict(self):\n+        return {\n+            \"do_resize\": self.do_resize,\n+            \"size\": self.size,\n+            \"do_normalize\": self.do_normalize,\n+            \"image_mean\": self.image_mean,\n+            \"image_std\": self.image_std,\n+            \"do_convert_rgb\": self.do_convert_rgb,\n+            \"do_pan_and_scan\": self.do_pan_and_scan,\n+            \"pan_and_scan_min_crop_size\": self.pan_and_scan_min_crop_size,\n+            \"pan_and_scan_max_num_crops\": self.pan_and_scan_max_num_crops,\n+            \"pan_and_scan_min_ratio_to_activate\": self.pan_and_scan_min_ratio_to_activate,\n+        }\n+\n+    def expected_output_image_shape(self, images):\n+        return self.num_channels, self.size[\"height\"], self.size[\"width\"]\n+\n+    # Copied from tests.models.clip.test_image_processing_clip.CLIPImageProcessingTester.prepare_image_inputs\n+    def prepare_image_inputs(self, equal_resolution=False, numpify=False, torchify=False):\n+        return prepare_image_inputs(\n+            batch_size=self.batch_size,\n+            num_channels=self.num_channels,\n+            min_resolution=self.min_resolution,\n+            max_resolution=self.max_resolution,\n+            equal_resolution=equal_resolution,\n+            numpify=numpify,\n+            torchify=torchify,\n+        )\n+\n+\n+@require_torch\n+@require_vision\n+class Gemma3ImageProcessingTest(ImageProcessingTestMixin, unittest.TestCase):\n+    image_processing_class = Gemma3ImageProcessor if is_vision_available() else None\n+    fast_image_processing_class = Gemma3ImageProcessorFast if is_torchvision_available() else None\n+\n+    # Copied from tests.models.clip.test_image_processing_clip.CLIPImageProcessingTest.setUp with CLIP->Gemma3\n+    def setUp(self):\n+        super().setUp()\n+        self.image_processor_tester = Gemma3ImageProcessingTester(self)\n+\n+    @property\n+    # Copied from tests.models.clip.test_image_processing_clip.CLIPImageProcessingTest.image_processor_dict\n+    def image_processor_dict(self):\n+        return self.image_processor_tester.prepare_image_processor_dict()\n+\n+    def test_image_processor_properties(self):\n+        for image_processing_class in self.image_processor_list:\n+            image_processing = image_processing_class(**self.image_processor_dict)\n+            self.assertTrue(hasattr(image_processing, \"do_resize\"))\n+            self.assertTrue(hasattr(image_processing, \"size\"))\n+            self.assertTrue(hasattr(image_processing, \"do_normalize\"))\n+            self.assertTrue(hasattr(image_processing, \"image_mean\"))\n+            self.assertTrue(hasattr(image_processing, \"image_std\"))\n+            self.assertTrue(hasattr(image_processing, \"do_convert_rgb\"))\n+            self.assertTrue(hasattr(image_processing, \"do_pan_and_scan\"))\n+            self.assertTrue(hasattr(image_processing, \"pan_and_scan_min_crop_size\"))\n+            self.assertTrue(hasattr(image_processing, \"pan_and_scan_max_num_crops\"))\n+            self.assertTrue(hasattr(image_processing, \"pan_and_scan_min_ratio_to_activate\"))\n+\n+    def test_image_processor_from_dict_with_kwargs(self):\n+        for image_processing_class in self.image_processor_list:\n+            image_processor = image_processing_class.from_dict(self.image_processor_dict)\n+            self.assertEqual(image_processor.size, {\"height\": 18, \"width\": 18})\n+\n+            image_processor = image_processing_class.from_dict(self.image_processor_dict, size=84)\n+            self.assertEqual(image_processor.size, {\"height\": 84, \"width\": 84})\n+\n+    def test_pan_and_scan(self):\n+        \"\"\"\n+        Enables Pan and Scan path by choosing the correct input image resolution. If you are changing\n+        image processor attributes for PaS, please update this test.\n+        \"\"\"\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = image_processing_class(**self.image_processor_dict)\n+            # create random numpy tensors\n+            \"\"\"This function prepares a list of PIL images\"\"\"\n+            image_inputs = [np.random.randint(255, size=(3, 300, 600), dtype=np.uint8)] * 3\n+            image_inputs = [Image.fromarray(np.moveaxis(x, 0, -1)) for x in image_inputs]\n+\n+            # Test not batched input, 3 images because we have base image + 2 crops\n+            encoded_images = image_processing(image_inputs[0], return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = (3, 3, 18, 18)\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+\n+            # Test batched, 9 images because we have base image + 2 crops per each item\n+            encoded_images = image_processing(image_inputs, return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = (9, 3, 18, 18)\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+\n+    def test_call_pil(self):\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = image_processing_class(**self.image_processor_dict)\n+            # create random PIL images\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True)\n+            for image in image_inputs:\n+                self.assertIsInstance(image, Image.Image)\n+\n+            # Test not batched input\n+            encoded_images = image_processing(image_inputs[0], return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = (1, 3, 18, 18)\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+\n+            # Test batched\n+            encoded_images = image_processing(image_inputs, return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = (7, 3, 18, 18)\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+\n+    def test_call_numpy(self):\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = image_processing_class(**self.image_processor_dict)\n+            # create random numpy tensors\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True, numpify=True)\n+            for image in image_inputs:\n+                self.assertIsInstance(image, np.ndarray)\n+\n+            # Test not batched input\n+            encoded_images = image_processing(image_inputs[0], return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = (1, 3, 18, 18)\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+\n+            # Test batched\n+            encoded_images = image_processing(image_inputs, return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = (7, 3, 18, 18)\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+\n+    def test_call_pytorch(self):\n+        for image_processing_class in self.image_processor_list:\n+            # Initialize image_processing\n+            image_processing = image_processing_class(**self.image_processor_dict)\n+            # create random PyTorch tensors\n+            image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True, torchify=True)\n+\n+            for image in image_inputs:\n+                self.assertIsInstance(image, torch.Tensor)\n+\n+            # Test not batched input\n+            encoded_images = image_processing(image_inputs[0], return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = (1, 3, 18, 18)\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+\n+            # Test batched\n+            encoded_images = image_processing(image_inputs, return_tensors=\"pt\").pixel_values\n+            expected_output_image_shape = (7, 3, 18, 18)\n+            self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+\n+    @unittest.skip(\"Gemma3 doesn't work with 4 channels due to pan and scan method\")\n+    def test_call_numpy_4_channels(self):\n+        pass"
        },
        {
            "sha": "6787f5ad5856df87c6bfb98f2460b9a6b4396c78",
            "filename": "tests/models/gemma3/test_modeling_gemma3.py",
            "status": "added",
            "additions": 520,
            "deletions": 0,
            "changes": 520,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fmodels%2Fgemma3%2Ftest_modeling_gemma3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fmodels%2Fgemma3%2Ftest_modeling_gemma3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgemma3%2Ftest_modeling_gemma3.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -0,0 +1,520 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch Gemma3 model.\"\"\"\n+\n+import unittest\n+\n+from parameterized import parameterized\n+\n+from transformers import (\n+    AutoModelForCausalLM,\n+    AutoTokenizer,\n+    Gemma3Config,\n+    Gemma3TextConfig,\n+    is_torch_available,\n+)\n+from transformers.testing_utils import (\n+    cleanup,\n+    require_torch,\n+    require_torch_gpu,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...models.gemma.test_modeling_gemma import GemmaModelTester\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import ModelTesterMixin, floats_tensor, ids_tensor\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import (\n+        Gemma3ForCausalLM,\n+        Gemma3ForConditionalGeneration,\n+        Gemma3Processor,\n+        Gemma3TextModel,\n+    )\n+\n+\n+class Gemma3ModelTester(GemmaModelTester):\n+    if is_torch_available():\n+        config_class = Gemma3TextConfig\n+        model_class = Gemma3TextModel\n+        for_causal_lm_class = Gemma3ForCausalLM\n+\n+\n+@require_torch\n+class Gemma3ModelTest(ModelTesterMixin, GenerationTesterMixin, unittest.TestCase):\n+    all_model_classes = (Gemma3TextModel, Gemma3ForCausalLM) if is_torch_available() else ()\n+    all_generative_model_classes = (Gemma3ForCausalLM,) if is_torch_available() else ()\n+    test_headmasking = False\n+    test_pruning = False\n+    _is_stateful = True\n+    model_split_percents = [0.5, 0.6]\n+\n+    def setUp(self):\n+        self.model_tester = Gemma3ModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Gemma3Config, hidden_size=37)\n+\n+    @unittest.skip(\"Failing because of unique cache (HybridCache)\")\n+    def test_model_outputs_equivalence(self, **kwargs):\n+        pass\n+\n+    @parameterized.expand([(\"random\",), (\"same\",)])\n+    @unittest.skip(\"Gemma3 has HybridCache which is not compatible with assisted decoding\")\n+    def test_assisted_decoding_matches_greedy_search(self, assistant_type):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache which is not compatible with assisted decoding\")\n+    def test_prompt_lookup_decoding_matches_greedy_search(self, assistant_type):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache which is not compatible with assisted decoding\")\n+    def test_assisted_decoding_sample(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache which is not compatible with dola decoding\")\n+    def test_dola_decoding_sample(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support continue from past kv\")\n+    def test_generate_continue_from_past_key_values(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support low_memory generation\")\n+    def test_beam_search_low_memory(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support contrastive generation\")\n+    def test_contrastive_generate(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support contrastive generation\")\n+    def test_contrastive_generate_dict_outputs_use_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support contrastive generation\")\n+    def test_contrastive_generate_low_memory(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support StaticCache. Though it could, it shouldn't support.\")\n+    def test_generate_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support StaticCache. Though it could, it shouldn't support.\")\n+    def test_generate_from_inputs_embeds_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support StaticCache. Though it could, it shouldn't support.\")\n+    def test_generate_continue_from_inputs_embeds(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache which auto-compiles. Compile and FA2 don't work together.\")\n+    def test_eager_matches_fa2_generate(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"HybridCache can't be gathered because it is not iterable. Adding a simple iter and dumping `distributed_iterator`\"\n+        \" as in Dynamic Cache doesnt work. NOTE: @gante all cache objects would need better compatibility with multi gpu setting\"\n+    )\n+    def test_multi_gpu_data_parallel_forward(self):\n+        pass\n+\n+\n+class Gemma3Vision2TextModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        mm_tokens_per_image=2,\n+        image_token_index=1,\n+        boi_token_index=2,\n+        eoi_token_index=3,\n+        seq_length=25,\n+        is_training=True,\n+        vision_config={\n+            \"use_labels\": True,\n+            \"image_size\": 20,\n+            \"patch_size\": 5,\n+            \"num_channels\": 3,\n+            \"is_training\": True,\n+            \"hidden_size\": 32,\n+            \"num_key_value_heads\": 1,\n+            \"num_hidden_layers\": 2,\n+            \"num_attention_heads\": 4,\n+            \"intermediate_size\": 37,\n+            \"dropout\": 0.1,\n+            \"attention_dropout\": 0.1,\n+            \"initializer_range\": 0.02,\n+        },\n+        use_cache=False,\n+    ):\n+        self.parent = parent\n+        # `image_token_index` is set to 0 to pass \"resize_embeddings\" test, do not modify\n+        self.mm_tokens_per_image = mm_tokens_per_image\n+        self.image_token_index = image_token_index\n+        self.boi_token_index = boi_token_index\n+        self.eoi_token_index = eoi_token_index\n+        self.llm_tester = Gemma3ModelTester(self.parent)\n+        self.text_config = self.llm_tester.get_config()\n+        self.vision_config = vision_config\n+        self.seq_length = seq_length\n+        self.pad_token_id = self.text_config.pad_token_id\n+\n+        self.num_hidden_layers = self.text_config.num_hidden_layers\n+        self.vocab_size = self.text_config.vocab_size\n+        self.hidden_size = self.text_config.hidden_size\n+        self.num_attention_heads = self.text_config.num_attention_heads\n+        self.is_training = is_training\n+\n+        self.batch_size = 3\n+        self.num_channels = vision_config[\"num_channels\"]\n+        self.image_size = vision_config[\"image_size\"]\n+        self.encoder_seq_length = seq_length\n+        self.use_cache = use_cache\n+\n+    def get_config(self):\n+        return Gemma3Config(\n+            text_config=self.text_config,\n+            vision_config=self.vision_config,\n+            image_token_index=self.image_token_index,\n+            boi_token_index=self.boi_token_index,\n+            eoi_token_index=self.eoi_token_index,\n+            mm_tokens_per_image=self.mm_tokens_per_image,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        pixel_values = floats_tensor(\n+            [\n+                self.batch_size,\n+                self.vision_config[\"num_channels\"],\n+                self.vision_config[\"image_size\"],\n+                self.vision_config[\"image_size\"],\n+            ]\n+        )\n+        config = self.get_config()\n+\n+        return config, pixel_values\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], config.text_config.vocab_size - 1) + 1\n+        attention_mask = input_ids.ne(self.pad_token_id).to(torch_device)\n+\n+        # set the 3 first tokens to be image, and ensure that no other tokens are image tokens\n+        # do not change this unless you modified image size or patch size\n+        input_ids[input_ids == config.image_token_index] = self.pad_token_id\n+        input_ids[:, :1] = config.image_token_index\n+\n+        token_type_ids = torch.zeros_like(input_ids)\n+        token_type_ids[input_ids == config.image_token_index] = 1\n+\n+        inputs_dict = {\n+            \"pixel_values\": pixel_values,\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+            \"token_type_ids\": token_type_ids,\n+        }\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class Gemma3Vision2TextModelTest(ModelTesterMixin, GenerationTesterMixin, unittest.TestCase):\n+    all_model_classes = (Gemma3ForConditionalGeneration,) if is_torch_available() else ()\n+    all_generative_model_classes = (Gemma3ForConditionalGeneration,) if is_torch_available() else ()\n+    test_headmasking = False\n+    test_pruning = False\n+    test_missing_keys = False\n+    _is_stateful = True\n+    model_split_percents = [0.5, 0.6]\n+\n+    # MP works but offload doesn't work when the SigLIP MultiheadAttention is offloaded\n+    # TODO: One potential solution would be to add to set preload_module_classes = [\"SiglipMultiheadAttentionPoolingHead\"]\n+    # in the dispatch_model function\n+    test_cpu_offload = False\n+    test_disk_offload_safetensors = False\n+    test_disk_offload_bin = False\n+\n+    def setUp(self):\n+        self.model_tester = Gemma3Vision2TextModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Gemma3Config, hidden_size=37)\n+\n+    @unittest.skip(reason=\"SiglipVisionModel (vision backbone) does not support standalone training\")\n+    def test_training_gradient_checkpointing(self):\n+        pass\n+\n+    @unittest.skip(reason=\"SiglipVisionModel (vision backbone) does not support standalone training\")\n+    def test_training_gradient_checkpointing_use_reentrant(self):\n+        pass\n+\n+    @unittest.skip(reason=\"SiglipVisionModel (vision backbone) does not support standalone training\")\n+    def test_training_gradient_checkpointing_use_reentrant_false(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"HybridCache can't be gathered because it is not iterable. Adding a simple iter and dumping `distributed_iterator`\"\n+        \" as in Dynamic Cache doesnt work. NOTE: @gante all cache objects would need better compatibility with multi gpu setting\"\n+    )\n+    def test_multi_gpu_data_parallel_forward(self):\n+        pass\n+\n+    @unittest.skip(\"Failing because of unique cache (HybridCache)\")\n+    def test_model_outputs_equivalence(self, **kwargs):\n+        pass\n+\n+    @parameterized.expand([(\"random\",), (\"same\",)])\n+    @unittest.skip(\"Gemma3 has HybridCache which is not compatible with assisted decoding\")\n+    def test_assisted_decoding_matches_greedy_search(self, assistant_type):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache which is not compatible with assisted decoding\")\n+    def test_prompt_lookup_decoding_matches_greedy_search(self, assistant_type):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache which is not compatible with assisted decoding\")\n+    def test_assisted_decoding_sample(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache which is not compatible with dola decoding\")\n+    def test_dola_decoding_sample(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support continue from past kv\")\n+    def test_generate_continue_from_past_key_values(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support low_memory generation\")\n+    def test_beam_search_low_memory(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support contrastive generation\")\n+    def test_contrastive_generate(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support contrastive generation\")\n+    def test_contrastive_generate_dict_outputs_use_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support contrastive generation\")\n+    def test_contrastive_generate_low_memory(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support StaticCache. Though it could, it shouldn't support.\")\n+    def test_generate_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Gemma3 has HybridCache and doesn't support StaticCache. Though it could, it shouldn't support.\")\n+    def test_generate_from_inputs_embeds_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"Siglip (vision backbone) uses the same initialization scheme as the Flax original implementation\"\n+    )\n+    def test_initialization(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"Siglip has no FLEX attention, and we don't have a proper way to set/test attn in VLMs. TODO @raushan\"\n+    )\n+    def test_flex_attention_with_grads(self):\n+        pass\n+\n+\n+@slow\n+@require_torch_gpu\n+# @require_read_token\n+class Gemma3IntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = Gemma3Processor.from_pretrained(\"gg-hf-g/gemma-3-4b-it\", padding_side=\"left\")\n+\n+        url = \"https://huggingface.co/datasets/hf-internal-testing/fixtures-captioning/resolve/main/cow_beach_1.png\"\n+        self.messages = [\n+            {\"role\": \"system\", \"content\": [{\"type\": \"text\", \"text\": \"You are a helpful assistant.\"}]},\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\", \"url\": url},\n+                    {\"type\": \"text\", \"text\": \"What is shown in this image?\"},\n+                ],\n+            },\n+        ]\n+\n+    def tearDown(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    def test_model_4b_bf16(self):\n+        model_id = \"gg-hf-g/gemma-3-4b-it\"\n+\n+        model = Gemma3ForConditionalGeneration.from_pretrained(\n+            model_id, low_cpu_mem_usage=True, torch_dtype=torch.bfloat16\n+        ).to(torch_device)\n+\n+        inputs = self.processor.apply_chat_template(\n+            self.messages,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            add_generation_prompt=True,\n+        ).to(torch_device)\n+\n+        output = model.generate(**inputs, max_new_tokens=30, do_sample=False)\n+        output_text = self.processor.batch_decode(output, skip_special_tokens=True)\n+\n+        EXPECTED_TEXTS = ['user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\nWhat is shown in this image?\\nmodel\\nCertainly! \\n\\nThe image shows a brown cow standing on a sandy beach with clear blue water and a blue sky in the background. It looks like']  # fmt: skip\n+        self.assertEqual(output_text, EXPECTED_TEXTS)\n+\n+    def test_model_4b_batch(self):\n+        model_id = \"gg-hf-g/gemma-3-4b-it\"\n+\n+        model = Gemma3ForConditionalGeneration.from_pretrained(\n+            model_id, low_cpu_mem_usage=True, torch_dtype=torch.bfloat16\n+        ).to(torch_device)\n+\n+        messages_2 = [\n+            {\"role\": \"system\", \"content\": [{\"type\": \"text\", \"text\": \"You are a helpful assistant.\"}]},\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"image\",\n+                        \"url\": \"https://huggingface.co/datasets/hf-internal-testing/fixtures-captioning/resolve/main/cow_beach_1.png\",\n+                    },\n+                    {\"type\": \"image\", \"url\": \"https://www.ilankelman.org/stopsigns/australia.jpg\"},\n+                    {\"type\": \"text\", \"text\": \"Are these images identical?\"},\n+                ],\n+            },\n+        ]\n+\n+        inputs = self.processor.apply_chat_template(\n+            [self.messages, messages_2],\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+            add_generation_prompt=True,\n+        ).to(torch_device)\n+\n+        output = model.generate(**inputs, max_new_tokens=30, do_sample=False)\n+        output_text = self.processor.batch_decode(output, skip_special_tokens=True)\n+\n+        EXPECTED_TEXTS = [\n+            'user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\nWhat is shown in this image?\\nmodel\\nCertainly! \\n\\nThe image shows a brown cow standing on a sandy beach with clear turquoise water and a blue sky in the background. It looks like',\n+            \"user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nAre these images identical?\\nmodel\\nNo, these images are not identical. \\n\\nHere's a breakdown of the differences:\\n\\n*   **Image 1:** Shows a cow\"\n+        ]  # fmt: skip\n+        self.assertEqual(output_text, EXPECTED_TEXTS)\n+\n+    def test_model_4b_multiimage(self):\n+        model_id = \"gg-hf-g/gemma-3-4b-it\"\n+\n+        model = Gemma3ForConditionalGeneration.from_pretrained(\n+            model_id, low_cpu_mem_usage=True, torch_dtype=torch.bfloat16\n+        ).to(torch_device)\n+\n+        messages = [\n+            {\"role\": \"system\", \"content\": [{\"type\": \"text\", \"text\": \"You are a helpful assistant.\"}]},\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\", \"url\": \"https://www.ilankelman.org/stopsigns/australia.jpg\"},\n+                    {\"type\": \"text\", \"text\": \"What do you see here?\"},\n+                ],\n+            },\n+        ]\n+\n+        inputs = self.processor.apply_chat_template(\n+            messages,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+            add_generation_prompt=True,\n+        ).to(torch_device)\n+\n+        output = model.generate(**inputs, max_new_tokens=30, do_sample=False)\n+        output_text = self.processor.batch_decode(output, skip_special_tokens=True)\n+\n+        EXPECTED_TEXTS = [\"user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\nWhat do you see here?\\nmodel\\nOkay, let's break down what I see in this image:\\n\\n**Overall Scene:**\\n\\nIt looks like a street scene in a vibrant,\"]  # fmt: skip\n+        self.assertEqual(output_text, EXPECTED_TEXTS)\n+\n+    def test_model_1b_text_only(self):\n+        model_id = \"gg-hf-g/gemma-3-1b-it\"\n+\n+        model = Gemma3ForCausalLM.from_pretrained(model_id, low_cpu_mem_usage=True, torch_dtype=torch.bfloat16).to(\n+            torch_device\n+        )\n+        tokenizer = AutoTokenizer.from_pretrained(model_id, padding_side=\"left\")\n+        inputs = tokenizer(\"Write a poem about Machine Learning.\", return_tensors=\"pt\").to(torch_device)\n+\n+        output = model.generate(**inputs, max_new_tokens=30, do_sample=False)\n+        output_text = tokenizer.batch_decode(output, skip_special_tokens=True)\n+\n+        EXPECTED_TEXTS = ['Write a poem about Machine Learning.\\n\\n---\\n\\nThe data flows, a river deep,\\nWith patterns hidden, secrets sleep.\\nA neural net, a watchful eye,\\nLearning']  # fmt: skip\n+        self.assertEqual(output_text, EXPECTED_TEXTS)\n+\n+    # TODO: raushan FA2 generates gibberish for no reason, check later\n+    # @require_flash_attn\n+    # @require_torch_gpu\n+    # @mark.flash_attn_test\n+    # def test_model_4b_flash_attn(self):\n+    #     model_id = \"gg-hf-g/gemma-3-4b-it\"\n+    #\n+    #     model = Gemma3ForConditionalGeneration.from_pretrained(\n+    #         model_id, torch_dtype=torch.bfloat16, attn_implementation=\"flash_attention_2\"\n+    #     ).to(torch_device)\n+    #\n+    #     inputs = self.processor.apply_chat_template(\n+    #         self.messages,\n+    #         tokenize=True,\n+    #         return_dict=True,\n+    #         return_tensors=\"pt\",\n+    #         add_generation_prompt=True,\n+    #     ).to(torch_device)\n+    #\n+    #     output = model.generate(**inputs, max_new_tokens=30, do_sample=False)\n+    #     output_text = self.processor.batch_decode(output, skip_special_tokens=True)\n+    #\n+    #     EXPECTED_TEXTS = ['user\\nYou are a helpful assistant.\\n\\n\\n\\n\\n\\nWhat is shown in this image?\\nmodel\\nPlease look out that you are what Grammy and Vi- ||.xfairesr--ith alerts themselves are||ÙÙ‘\\n\\n**General Note:**']  # fmt: skip\n+    #     self.assertEqual(output_text, EXPECTED_TEXTS)\n+\n+    @parameterized.expand([(\"flash_attention_2\",), (\"sdpa\",), (\"eager\",)])\n+    def test_generation_beyond_sliding_window(self, attn_implementation: str):\n+        \"\"\"Test that we can correctly generate beyond the sliding window. This is non trivial as\n+        we need to correctly slice the attention mask in all cases (because we use a HybridCache).\n+        Outputs for every attention functions should be coherent and identical.\n+        \"\"\"\n+        model_id = \"gg-hf-g/gemma-3-1b-it\"\n+\n+        input_text = [\n+            \"This is a nice place. \" * 800 + \"I really enjoy the scenery,\",  # This is larger than 4096 tokens\n+            \"A list of colors: red, blue\",  # This will almost all be padding tokens\n+        ]\n+        tokenizer = AutoTokenizer.from_pretrained(model_id, padding=\"left\")\n+        inputs = tokenizer(input_text, padding=True, return_tensors=\"pt\").to(torch_device)\n+\n+        model = AutoModelForCausalLM.from_pretrained(\n+            model_id, attn_implementation=attn_implementation, torch_dtype=torch.float16\n+        ).to(torch_device)\n+\n+        # Make sure prefill is larger than sliding window\n+        input_size = inputs.input_ids.shape[-1]\n+        self.assertTrue(input_size > model.config.sliding_window)\n+\n+        out = model.generate(**inputs, max_new_tokens=20)[:, input_size:]\n+        output_text = tokenizer.batch_decode(out)\n+\n+        EXPECTED_COMPLETIONS = [\" and I'm going to take a walk.\\n\\nI really enjoy the scenery, and I'\", \", green, yellow, orange, purple, brown, black, white, gray.\\n\\nI'\"]  # fmt: skip\n+        self.assertEqual(output_text, EXPECTED_COMPLETIONS)"
        },
        {
            "sha": "e72ca9c2bf197d87ac3e4511aa46d36b8272a426",
            "filename": "tests/models/gemma3/test_processing_gemma3.py",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fmodels%2Fgemma3%2Ftest_processing_gemma3.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Fmodels%2Fgemma3%2Ftest_processing_gemma3.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fgemma3%2Ftest_processing_gemma3.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -0,0 +1,136 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import shutil\n+import tempfile\n+import unittest\n+from typing import Optional\n+\n+from transformers import Gemma3Processor, GemmaTokenizer\n+from transformers.testing_utils import get_tests_dir, require_vision\n+from transformers.utils import is_vision_available\n+\n+from ...test_processing_common import ProcessorTesterMixin\n+\n+\n+if is_vision_available():\n+    from transformers import Gemma3ImageProcessor\n+\n+SAMPLE_VOCAB = get_tests_dir(\"fixtures/test_sentencepiece.model\")\n+\n+\n+@require_vision\n+class Gemma3ProcessorTest(ProcessorTesterMixin, unittest.TestCase):\n+    processor_class = Gemma3Processor\n+\n+    def setUp(self):\n+        self.tmpdirname = tempfile.mkdtemp()\n+        gemma3_image_processor_kwargs = {\n+            \"do_pan_and_scan\": True,\n+            \"pan_and_scan_min_crop_size\": 256,\n+            \"pan_and_scan_max_num_crops\": 4,\n+            \"pan_and_scan_min_ratio_to_activate\": 1.2,\n+        }\n+        image_processor = Gemma3ImageProcessor.from_pretrained(\n+            \"google/siglip-so400m-patch14-384\", **gemma3_image_processor_kwargs\n+        )\n+\n+        extra_special_tokens = {\n+            \"image_token\": \"<image_soft_token>\",\n+            \"boi_token\": \"<start_of_image>\",\n+            \"eoi_token\": \"<end_of_image>\",\n+        }\n+        tokenizer = GemmaTokenizer(SAMPLE_VOCAB, keep_accents=True, extra_special_tokens=extra_special_tokens)\n+        processor_kwargs = self.prepare_processor_dict()\n+        processor = Gemma3Processor(image_processor=image_processor, tokenizer=tokenizer, **processor_kwargs)\n+        processor.save_pretrained(self.tmpdirname)\n+\n+    def tearDown(self):\n+        shutil.rmtree(self.tmpdirname)\n+\n+    # TODO: raushan or arthur: add the real chat template\n+    def prepare_processor_dict(self):\n+        return {\n+            \"chat_template\": \"{{ bos_token }}\\n{%- if messages[0]['role'] == 'system' -%}\\n    {%- set first_user_prefix = messages[0]['content'][0]['text'] + '\\n\\n' -%}\\n    {%- set loop_messages = messages[1:] -%}\\n{%- else -%}\\n    {%- set first_user_prefix = \\\"\\\" -%}\\n    {%- set loop_messages = messages -%}\\n{%- endif -%}\\n{%- for message in loop_messages -%}\\n    {%- if (message['role'] == 'user') != (loop.index0 % 2 == 0) -%}\\n        {{ raise_exception(\\\"Conversation roles must alternate user/assistant/user/assistant/...\\\") }}\\n    {%- endif -%}\\n    {%- if (message['role'] == 'assistant') -%}\\n        {%- set role = \\\"model\\\" -%}\\n    {%- else -%}\\n        {%- set role = message['role'] -%}\\n    {%- endif -%}\\n    {{ '<start_of_turn>' + role + '\\n' + (first_user_prefix if loop.first else \\\"\\\") }}\\n    {%- if message['content'] is string -%}\\n        {{ message['content'] | trim }}\\n    {%- elif message['content'] is iterable -%}\\n        {%- for item in message['content'] -%}\\n            {%- if item['type'] == 'image' -%}\\n                {{ '<start_of_image>' }}\\n            {%- elif item['type'] == 'text' -%}\\n                {{ item['text'] | trim }}\\n            {%- endif -%}\\n        {%- endfor -%}\\n    {%- else -%}\\n        {{ raise_exception(\\\"Invalid content type\\\") }}\\n    {%- endif -%}\\n    {{ '<end_of_turn>\\n' }}\\n{%- endfor -%}\\n{%- if add_generation_prompt -%}\\n    {{'<start_of_turn>model\\n'}}\\n{%- endif -%}\\n\",            \"image_seq_length\": 3,\n+        }  # fmt: skip\n+\n+    # Override as VLMs need image tokens in prompts\n+    def prepare_text_inputs(self, batch_size: Optional[int] = None):\n+        if batch_size is None:\n+            return \"lower newer <start_of_image>\"\n+\n+        if batch_size < 1:\n+            raise ValueError(\"batch_size must be greater than 0\")\n+\n+        if batch_size == 1:\n+            return [\"lower newer <start_of_image>\"]\n+        return [\"lower newer <start_of_image>\", \"<start_of_image> upper older longer string\"] + [\n+            \"<start_of_image> lower newer\"\n+        ] * (batch_size - 2)\n+\n+    # Override as Gemma3 needs images to be an explicitly nested batch\n+    def prepare_image_inputs(self, batch_size: Optional[int] = None):\n+        \"\"\"This function prepares a list of PIL images for testing\"\"\"\n+        images = super().prepare_image_inputs(batch_size)\n+        if isinstance(images, (list, tuple)):\n+            images = [[image] for image in images]\n+        return images\n+\n+    def test_text_with_image_tokens(self):\n+        image_processor = self.get_component(\"image_processor\")\n+        tokenizer = self.get_component(\"tokenizer\")\n+\n+        processor = self.processor_class(tokenizer=tokenizer, image_processor=image_processor)\n+        text_multi_images = f\"{processor.boi_token}{processor.boi_token}Dummy text!\"\n+        text_single_image = f\"{processor.boi_token}Dummy text!\"\n+        text_no_image = \"Dummy text!\"\n+\n+        image = self.prepare_image_inputs()\n+\n+        # If text has no image tokens, iamge should be `None`\n+        with self.assertRaises(ValueError):\n+            _ = processor(text=text_no_image, images=image, return_tensors=\"np\")\n+\n+        # We can't be sure what is users intention: if user wants one image per text OR two images for first text and no image for second text\n+        with self.assertRaises(ValueError):\n+            _ = processor(text=[text_single_image, text_single_image], images=[image, image], return_tensors=\"np\")\n+\n+        # The users is expected to be explicit about which image belong to which text by nesting the images list\n+        out_multiimages = processor(text=text_multi_images, images=[image, image], return_tensors=\"np\")\n+        out_batch_oneimage = processor(\n+            text=[text_single_image, text_single_image], images=[[image], [image]], return_tensors=\"np\"\n+        )\n+        self.assertListEqual(\n+            out_batch_oneimage[self.images_input_name].tolist(), out_multiimages[self.images_input_name].tolist()\n+        )\n+\n+    def test_pan_and_scan(self):\n+        processor_components = self.prepare_components()\n+        processor_kwargs = self.prepare_processor_dict()\n+        processor = self.processor_class(**processor_components, **processor_kwargs)\n+\n+        input_str = self.prepare_text_inputs()\n+        image_input = self.prepare_image_inputs()\n+        inputs = processor(\n+            text=input_str,\n+            images=image_input,\n+            return_tensors=\"np\",\n+            do_pan_and_scan=True,\n+            image_seq_length=2,\n+            pan_and_scan_min_crop_size=10,\n+        )\n+\n+        # base image + 4 crops\n+        self.assertEqual(len(inputs[self.images_input_name]), 5)\n+        self.assertEqual(len(inputs[self.text_input_name][0]), 67)"
        },
        {
            "sha": "8d5124b0d8a2f856f0d7ff967e324b5714da70fd",
            "filename": "tests/test_processing_common.py",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Ftest_processing_common.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/tests%2Ftest_processing_common.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Ftest_processing_common.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -783,7 +783,7 @@ def test_chat_template_single(self):\n         self.assertListEqual(expected_output, formatted_prompt_tokenized)\n \n         out_dict = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=True, return_dict=True)\n-        self.assertListEqual(list(out_dict.keys()), [\"input_ids\", \"attention_mask\"])\n+        self.assertTrue(all(key in out_dict for key in [\"input_ids\", \"attention_mask\"]))\n \n         # Now test the ability to return dict\n         messages[0][0][\"content\"].append(\n@@ -845,7 +845,7 @@ def test_chat_template_batched(self):\n             return_dict=True,\n             padding=True,\n         )\n-        self.assertListEqual(list(out_dict.keys()), [\"input_ids\", \"attention_mask\"])\n+        self.assertTrue(all(key in out_dict for key in [\"input_ids\", \"attention_mask\"]))\n \n         # Now test the ability to return dict\n         batched_messages[0][0][\"content\"].append(\n@@ -885,6 +885,7 @@ def test_chat_template_accepts_processing_kwargs(self):\n             add_generation_prompt=True,\n             tokenize=True,\n             padding=\"max_length\",\n+            truncation=True,\n             max_length=50,\n         )\n         self.assertEqual(len(formatted_prompt_tokenized[0]), 50)\n@@ -982,7 +983,7 @@ def test_chat_template_video(self):\n         self.assertListEqual(expected_output, formatted_prompt_tokenized)\n \n         out_dict = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=True, return_dict=True)\n-        self.assertListEqual(list(out_dict.keys()), [\"input_ids\", \"attention_mask\"])\n+        self.assertTrue(all(key in out_dict for key in [\"input_ids\", \"attention_mask\"]))\n \n         # Add video URL for return dict and load with `num_frames` arg\n         messages[0][0][\"content\"][0] = {"
        },
        {
            "sha": "68fd6434ee8f4936791229783aeec8dadfbdf7ec",
            "filename": "utils/check_config_attributes.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/50d3530aa04e7a7d003e6b255a98f79fd0447357/utils%2Fcheck_config_attributes.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/50d3530aa04e7a7d003e6b255a98f79fd0447357/utils%2Fcheck_config_attributes.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_config_attributes.py?ref=50d3530aa04e7a7d003e6b255a98f79fd0447357",
            "patch": "@@ -226,6 +226,8 @@\n         \"giou_loss_coefficient\",\n     ],\n     \"GPTNeoXConfig\": [\"rotary_emb_base\"],\n+    \"Gemma3Config\": [\"boi_token_index\", \"eoi_token_index\"],\n+    \"Gemma3TextConfig\": [\"cache_implementation\", \"tie_word_embeddings\"],\n }\n \n "
        }
    ],
    "stats": {
        "total": 5585,
        "additions": 5469,
        "deletions": 116
    }
}