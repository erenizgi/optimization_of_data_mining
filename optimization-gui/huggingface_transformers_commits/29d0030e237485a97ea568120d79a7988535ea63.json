{
    "author": "qubvel",
    "message": "Refactor `PretrainedConfig.__init__` method to make it more explicit (#39158)\n\n* cleanup\n\n* fix no `__init__` test\n\n* fix missing inits",
    "sha": "29d0030e237485a97ea568120d79a7988535ea63",
    "files": [
        {
            "sha": "e0f71dce134ef7256bc17d4ee868a5c5adf28c8b",
            "filename": "src/transformers/configuration_utils.py",
            "status": "modified",
            "additions": 133,
            "deletions": 102,
            "changes": 235,
            "blob_url": "https://github.com/huggingface/transformers/blob/29d0030e237485a97ea568120d79a7988535ea63/src%2Ftransformers%2Fconfiguration_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/29d0030e237485a97ea568120d79a7988535ea63/src%2Ftransformers%2Fconfiguration_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fconfiguration_utils.py?ref=29d0030e237485a97ea568120d79a7988535ea63",
            "patch": "@@ -18,7 +18,7 @@\n import json\n import os\n import warnings\n-from typing import Any, Optional, TypeVar, Union\n+from typing import TYPE_CHECKING, Any, Optional, TypeVar, Union\n \n from packaging import version\n \n@@ -39,6 +39,10 @@\n from .utils.generic import is_timm_config_dict\n \n \n+if TYPE_CHECKING:\n+    import torch\n+\n+\n logger = logging.get_logger(__name__)\n \n \n@@ -108,8 +112,9 @@ class PretrainedConfig(PushToHubMixin):\n         is_encoder_decoder (`bool`, *optional*, defaults to `False`):\n             Whether the model is used as an encoder/decoder or not.\n         is_decoder (`bool`, *optional*, defaults to `False`):\n-            Whether to only use the decoder in an encoder-decoder architecture, otherwise it has no effect on decoder-only or encoder-only architectures.\n-        cross_attention_hidden_size** (`bool`, *optional*):\n+            Whether to only use the decoder in an encoder-decoder architecture, otherwise it has no effect on\n+            decoder-only or encoder-only architectures.\n+        cross_attention_hidden_size (`bool`, *optional*):\n             The hidden size of the cross-attention layer in case the model is used as a decoder in an encoder-decoder\n             setting and the cross-attention hidden dimension differs from `self.config.hidden_size`.\n         add_cross_attention (`bool`, *optional*, defaults to `False`):\n@@ -139,7 +144,8 @@ class PretrainedConfig(PushToHubMixin):\n             or PyTorch) checkpoint.\n         id2label (`dict[int, str]`, *optional*):\n             A map from index (for instance prediction index, or target index) to label.\n-        label2id (`dict[str, int]`, *optional*): A map from label to index for the model.\n+        label2id (`dict[str, int]`, *optional*):\n+            A map from label to index for the model.\n         num_labels (`int`, *optional*):\n             Number of labels to use in the last layer added to the model, typically for a classification task.\n         task_specific_params (`dict[str, Any]`, *optional*):\n@@ -155,12 +161,16 @@ class PretrainedConfig(PushToHubMixin):\n             model by default).\n         prefix (`str`, *optional*):\n             A specific prompt that should be added at the beginning of each text before calling the model.\n-        bos_token_id (`int`, *optional*): The id of the _beginning-of-stream_ token.\n-        pad_token_id (`int`, *optional*): The id of the _padding_ token.\n-        eos_token_id (`int`, *optional*): The id of the _end-of-stream_ token.\n+        bos_token_id (`int`, *optional*):\n+            The id of the _beginning-of-stream_ token.\n+        pad_token_id (`int`, *optional*):\n+            The id of the _padding_ token.\n+        eos_token_id (`int`, *optional*):\n+            The id of the _end-of-stream_ token.\n         decoder_start_token_id (`int`, *optional*):\n             If an encoder-decoder model starts decoding with a different token than _bos_, the id of that token.\n-        sep_token_id (`int`, *optional*): The id of the _separation_ token.\n+        sep_token_id (`int`, *optional*):\n+            The id of the _separation_ token.\n \n         > PyTorch specific parameters\n \n@@ -179,18 +189,6 @@ class PretrainedConfig(PushToHubMixin):\n \n             This attribute is currently not being used during model loading time, but this may change in the future\n             versions. But we can already start preparing for the future by saving the dtype with save_pretrained.\n-\n-        > TensorFlow specific parameters\n-\n-        use_bfloat16 (`bool`, *optional*, defaults to `False`):\n-            Whether or not the model should use BFloat16 scalars (only used by some TensorFlow models).\n-        tf_legacy_loss (`bool`, *optional*, defaults to `False`):\n-            Whether the model should use legacy TensorFlow losses. Legacy losses have variable output shapes and may\n-            not be XLA-compatible. This option is here for backward compatibility and will be removed in Transformers\n-            v5.\n-        loss_type (`str`, *optional*):\n-            The type of loss that the model should use. It should be in `LOSS_MAPPING`'s keys, otherwise the loss will\n-            be automatically inferred from the model architecture.\n     \"\"\"\n \n     model_type: str = \"\"\n@@ -212,93 +210,117 @@ def __getattribute__(self, key):\n             key = super().__getattribute__(\"attribute_map\")[key]\n         return super().__getattribute__(key)\n \n-    def __init__(self, **kwargs):\n-        # Attributes with defaults\n-        self.return_dict = kwargs.pop(\"return_dict\", True)\n-        self.output_hidden_states = kwargs.pop(\"output_hidden_states\", False)\n-        self._output_attentions = kwargs.pop(\"output_attentions\", False)\n-        self.torchscript = kwargs.pop(\"torchscript\", False)  # Only used by PyTorch models\n-        self.torch_dtype = kwargs.pop(\"torch_dtype\", None)  # Only used by PyTorch models\n-        self.use_bfloat16 = kwargs.pop(\"use_bfloat16\", False)\n-        self.tf_legacy_loss = kwargs.pop(\"tf_legacy_loss\", False)  # Only used by TensorFlow models\n-        self.pruned_heads = kwargs.pop(\"pruned_heads\", {})\n-        self.tie_word_embeddings = kwargs.pop(\n-            \"tie_word_embeddings\", True\n-        )  # Whether input and output word embeddings should be tied for all MLM, LM and Seq2Seq models.\n-        self.chunk_size_feed_forward = kwargs.pop(\"chunk_size_feed_forward\", 0)\n-\n-        # Is decoder is used in encoder-decoder models to differentiate encoder from decoder\n-        self.is_encoder_decoder = kwargs.pop(\"is_encoder_decoder\", False)\n-        self.is_decoder = kwargs.pop(\"is_decoder\", False)\n-        self.cross_attention_hidden_size = kwargs.pop(\"cross_attention_hidden_size\", None)\n-        self.add_cross_attention = kwargs.pop(\"add_cross_attention\", False)\n-        self.tie_encoder_decoder = kwargs.pop(\"tie_encoder_decoder\", False)\n-\n-        # Retrocompatibility: Parameters for sequence generation. While we will keep the ability to load these\n-        # parameters, saving them will be deprecated. In a distant future, we won't need to load them.\n-        for parameter_name, default_value in self._get_global_generation_defaults().items():\n-            setattr(self, parameter_name, kwargs.pop(parameter_name, default_value))\n-\n+    def __init__(\n+        self,\n+        *,\n+        # All models common arguments\n+        output_hidden_states: bool = False,\n+        output_attentions: bool = False,\n+        return_dict: bool = True,\n+        torchscript: bool = False,\n+        torch_dtype: Optional[Union[str, \"torch.dtype\"]] = None,\n+        # Common arguments\n+        pruned_heads: Optional[dict[int, list[int]]] = None,\n+        tie_word_embeddings: bool = True,\n+        chunk_size_feed_forward: int = 0,\n+        is_encoder_decoder: bool = False,\n+        is_decoder: bool = False,\n+        cross_attention_hidden_size: Optional[int] = None,\n+        add_cross_attention: bool = False,\n+        tie_encoder_decoder: bool = False,\n         # Fine-tuning task arguments\n-        self.architectures = kwargs.pop(\"architectures\", None)\n-        self.finetuning_task = kwargs.pop(\"finetuning_task\", None)\n-        self.id2label = kwargs.pop(\"id2label\", None)\n-        self.label2id = kwargs.pop(\"label2id\", None)\n-        if self.label2id is not None and not isinstance(self.label2id, dict):\n+        architectures: Optional[list[str]] = None,\n+        finetuning_task: Optional[str] = None,\n+        id2label: Optional[dict[int, str]] = None,\n+        label2id: Optional[dict[str, int]] = None,\n+        num_labels: Optional[int] = None,\n+        task_specific_params: Optional[dict[str, Any]] = None,\n+        problem_type: Optional[str] = None,\n+        # Tokenizer kwargs\n+        tokenizer_class: Optional[str] = None,\n+        prefix: Optional[str] = None,\n+        bos_token_id: Optional[int] = None,\n+        pad_token_id: Optional[int] = None,\n+        eos_token_id: Optional[int] = None,\n+        sep_token_id: Optional[int] = None,\n+        decoder_start_token_id: Optional[int] = None,\n+        **kwargs,\n+    ):\n+        # Validation for some arguments\n+        if label2id is not None and not isinstance(label2id, dict):\n             raise ValueError(\"Argument label2id should be a dictionary.\")\n-        if self.id2label is not None:\n-            if not isinstance(self.id2label, dict):\n-                raise ValueError(\"Argument id2label should be a dictionary.\")\n-            num_labels = kwargs.pop(\"num_labels\", None)\n-            if num_labels is not None and len(self.id2label) != num_labels:\n-                logger.warning(\n-                    f\"You passed along `num_labels={num_labels}` with an incompatible id to label map: \"\n-                    f\"{self.id2label}. The number of labels will be overwritten to {self.num_labels}.\"\n-                )\n-            self.id2label = {int(key): value for key, value in self.id2label.items()}\n-            # Keys are always strings in JSON so convert ids to int here.\n-        else:\n-            self.num_labels = kwargs.pop(\"num_labels\", 2)\n-\n-        if self.torch_dtype is not None and isinstance(self.torch_dtype, str):\n-            # we will start using self.torch_dtype in v5, but to be consistent with\n-            # from_pretrained's torch_dtype arg convert it to an actual torch.dtype object\n-            if is_torch_available():\n-                import torch\n-\n-                self.torch_dtype = getattr(torch, self.torch_dtype)\n-\n-        # Tokenizer arguments TODO: eventually tokenizer and models should share the same config\n-        self.tokenizer_class = kwargs.pop(\"tokenizer_class\", None)\n-        self.prefix = kwargs.pop(\"prefix\", None)\n-        self.bos_token_id = kwargs.pop(\"bos_token_id\", None)\n-        self.pad_token_id = kwargs.pop(\"pad_token_id\", None)\n-        self.eos_token_id = kwargs.pop(\"eos_token_id\", None)\n-        self.sep_token_id = kwargs.pop(\"sep_token_id\", None)\n-        self.decoder_start_token_id = kwargs.pop(\"decoder_start_token_id\", None)\n-\n-        # task specific arguments\n-        self.task_specific_params = kwargs.pop(\"task_specific_params\", None)\n-\n-        # regression / multi-label classification\n-        self.problem_type = kwargs.pop(\"problem_type\", None)\n-        allowed_problem_types = (\"regression\", \"single_label_classification\", \"multi_label_classification\")\n-        if self.problem_type is not None and self.problem_type not in allowed_problem_types:\n+        if id2label is not None and not isinstance(id2label, dict):\n+            raise ValueError(\"Argument id2label should be a dictionary.\")\n+        if num_labels is not None and id2label is not None and len(id2label) != num_labels:\n+            logger.warning(\n+                f\"You passed `num_labels={num_labels}` which is incompatible to \"\n+                f\"the `id2label` map of length `{len(id2label)}`.\"\n+            )\n+        if problem_type is not None and problem_type not in (\n+            \"regression\",\n+            \"single_label_classification\",\n+            \"multi_label_classification\",\n+        ):\n             raise ValueError(\n-                f\"The config parameter `problem_type` was not understood: received {self.problem_type} \"\n+                f\"The config parameter `problem_type` was not understood: received {problem_type} \"\n                 \"but only 'regression', 'single_label_classification' and 'multi_label_classification' are valid.\"\n             )\n+        if torch_dtype is not None and isinstance(torch_dtype, str) and is_torch_available():\n+            # we will start using self.torch_dtype in v5, but to be consistent with\n+            # from_pretrained's torch_dtype arg convert it to an actual torch.dtype object\n+            import torch\n+\n+            torch_dtype = getattr(torch, torch_dtype)\n+\n+        # Attributes common for all models\n+        self.return_dict = return_dict\n+        self.output_hidden_states = output_hidden_states\n+        self.torchscript = torchscript\n+        self.torch_dtype = torch_dtype\n+        self._output_attentions = output_attentions  # has public property\n+\n+        # Less common kwargs, only used by some models\n+        self.pruned_heads = pruned_heads if pruned_heads is not None else {}\n+        self.tie_word_embeddings = tie_word_embeddings\n+        self.chunk_size_feed_forward = chunk_size_feed_forward\n+\n+        # Encoder-decoder models attributes\n+        self.is_encoder_decoder = is_encoder_decoder\n+        self.is_decoder = is_decoder  # used in encoder-decoder models to differentiate encoder from decoder\n+        self.cross_attention_hidden_size = cross_attention_hidden_size\n+        self.add_cross_attention = add_cross_attention\n+        self.tie_encoder_decoder = tie_encoder_decoder\n+\n+        # Fine-tuning task attributes\n+        self.architectures = architectures\n+        self.finetuning_task = finetuning_task\n+        self.id2label = id2label\n+        self.label2id = label2id\n+        self.task_specific_params = task_specific_params\n+        self.problem_type = problem_type\n+\n+        if self.id2label is None:\n+            self._create_id_label_maps(num_labels if num_labels is not None else 2)\n+        else:\n+            # Keys are always strings in JSON so convert ids to int here.\n+            self.id2label = {int(key): value for key, value in self.id2label.items()}\n \n-        # TPU arguments\n-        if kwargs.pop(\"xla_device\", None) is not None:\n-            logger.warning(\n-                \"The `xla_device` argument has been deprecated in v4.4.0 of Transformers. It is ignored and you can \"\n-                \"safely remove it from your `config.json` file.\"\n-            )\n+        # Tokenizer attributes\n+        self.tokenizer_class = tokenizer_class\n+        self.prefix = prefix\n+        self.bos_token_id = bos_token_id\n+        self.pad_token_id = pad_token_id\n+        self.eos_token_id = eos_token_id\n+        self.sep_token_id = sep_token_id\n+        self.decoder_start_token_id = decoder_start_token_id\n+\n+        # Retrocompatibility: Parameters for sequence generation. While we will keep the ability to load these\n+        # parameters, saving them will be deprecated. In a distant future, we won't need to load them.\n+        for parameter_name, default_value in self._get_global_generation_defaults().items():\n+            setattr(self, parameter_name, kwargs.pop(parameter_name, default_value))\n \n         # Name or path to the pretrained checkpoint\n         self._name_or_path = str(kwargs.pop(\"name_or_path\", \"\"))\n-        # Config hash\n         self._commit_hash = kwargs.pop(\"_commit_hash\", None)\n \n         # Attention implementation to use, if relevant.\n@@ -324,8 +346,16 @@ def __init__(self, **kwargs):\n                 logger.error(f\"Can't set {key} with value {value} for {self}\")\n                 raise err\n \n+        # TODO: remove later, deprecated arguments for TF models\n+        self.tf_legacy_loss = kwargs.pop(\"tf_legacy_loss\", False)\n+        self.use_bfloat16 = kwargs.pop(\"use_bfloat16\", False)\n+\n+    def _create_id_label_maps(self, num_labels: int):\n+        self.id2label = {i: f\"LABEL_{i}\" for i in range(num_labels)}\n+        self.label2id = dict(zip(self.id2label.values(), self.id2label.keys()))\n+\n     @property\n-    def name_or_path(self) -> str:\n+    def name_or_path(self) -> Optional[str]:\n         return getattr(self, \"_name_or_path\", None)\n \n     @name_or_path.setter\n@@ -365,9 +395,10 @@ def num_labels(self) -> int:\n \n     @num_labels.setter\n     def num_labels(self, num_labels: int):\n-        if not hasattr(self, \"id2label\") or self.id2label is None or len(self.id2label) != num_labels:\n-            self.id2label = {i: f\"LABEL_{i}\" for i in range(num_labels)}\n-            self.label2id = dict(zip(self.id2label.values(), self.id2label.keys()))\n+        # we do not store `num_labels` attribute in config, but instead\n+        # compute it based on the length of the `id2label` map\n+        if self.id2label is None or self.num_labels != num_labels:\n+            self._create_id_label_maps(num_labels)\n \n     @property\n     def _attn_implementation(self):"
        },
        {
            "sha": "9bb2e3da54aa232bf934a7922f731796a7146937",
            "filename": "src/transformers/models/deprecated/jukebox/configuration_jukebox.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/29d0030e237485a97ea568120d79a7988535ea63/src%2Ftransformers%2Fmodels%2Fdeprecated%2Fjukebox%2Fconfiguration_jukebox.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/29d0030e237485a97ea568120d79a7988535ea63/src%2Ftransformers%2Fmodels%2Fdeprecated%2Fjukebox%2Fconfiguration_jukebox.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fdeprecated%2Fjukebox%2Fconfiguration_jukebox.py?ref=29d0030e237485a97ea568120d79a7988535ea63",
            "patch": "@@ -298,6 +298,7 @@ def __init__(\n         zero_out=False,\n         **kwargs,\n     ):\n+        super().__init__(**kwargs)\n         self.act_fn = act_fn\n         self.alignment_head = alignment_head\n         self.alignment_layer = alignment_layer\n@@ -444,6 +445,7 @@ def __init__(\n         zero_out=False,\n         **kwargs,\n     ):\n+        super().__init__(**kwargs)\n         self.hop_fraction = hop_fraction\n         self.conv_input_shape = conv_input_shape\n         self.sample_length = sample_length"
        }
    ],
    "stats": {
        "total": 237,
        "additions": 135,
        "deletions": 102
    }
}