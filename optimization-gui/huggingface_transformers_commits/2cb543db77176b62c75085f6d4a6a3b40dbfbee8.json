{
    "author": "aymeric-roucher",
    "message": "Multi agents with manager (#32687)\n\n* Add Multi agents with a hierarchical system",
    "sha": "2cb543db77176b62c75085f6d4a6a3b40dbfbee8",
    "files": [
        {
            "sha": "438bd313b5e46ef11f034a8a70054668f4431066",
            "filename": "src/transformers/agents/__init__.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/2cb543db77176b62c75085f6d4a6a3b40dbfbee8/src%2Ftransformers%2Fagents%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/2cb543db77176b62c75085f6d4a6a3b40dbfbee8/src%2Ftransformers%2Fagents%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fagents%2F__init__.py?ref=2cb543db77176b62c75085f6d4a6a3b40dbfbee8",
            "patch": "@@ -24,7 +24,7 @@\n \n \n _import_structure = {\n-    \"agents\": [\"Agent\", \"CodeAgent\", \"ReactAgent\", \"ReactCodeAgent\", \"ReactJsonAgent\", \"Toolbox\"],\n+    \"agents\": [\"Agent\", \"CodeAgent\", \"ManagedAgent\", \"ReactAgent\", \"ReactCodeAgent\", \"ReactJsonAgent\", \"Toolbox\"],\n     \"llm_engine\": [\"HfApiEngine\", \"TransformersEngine\"],\n     \"monitoring\": [\"stream_to_gradio\"],\n     \"tools\": [\"PipelineTool\", \"Tool\", \"ToolCollection\", \"launch_gradio_demo\", \"load_tool\"],\n@@ -45,7 +45,7 @@\n     _import_structure[\"translation\"] = [\"TranslationTool\"]\n \n if TYPE_CHECKING:\n-    from .agents import Agent, CodeAgent, ReactAgent, ReactCodeAgent, ReactJsonAgent, Toolbox\n+    from .agents import Agent, CodeAgent, ManagedAgent, ReactAgent, ReactCodeAgent, ReactJsonAgent, Toolbox\n     from .llm_engine import HfApiEngine, TransformersEngine\n     from .monitoring import stream_to_gradio\n     from .tools import PipelineTool, Tool, ToolCollection, launch_gradio_demo, load_tool"
        },
        {
            "sha": "5a4aea28d97061a68458e6bd235ba74baa90d72f",
            "filename": "src/transformers/agents/agents.py",
            "status": "modified",
            "additions": 155,
            "deletions": 41,
            "changes": 196,
            "blob_url": "https://github.com/huggingface/transformers/blob/2cb543db77176b62c75085f6d4a6a3b40dbfbee8/src%2Ftransformers%2Fagents%2Fagents.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/2cb543db77176b62c75085f6d4a6a3b40dbfbee8/src%2Ftransformers%2Fagents%2Fagents.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fagents%2Fagents.py?ref=2cb543db77176b62c75085f6d4a6a3b40dbfbee8",
            "patch": "@@ -57,20 +57,26 @@ class CustomFormatter(logging.Formatter):\n     bold_yellow = \"\\x1b[33;1m\"\n     red = \"\\x1b[31;20m\"\n     green = \"\\x1b[32;20m\"\n+    bold_green = \"\\x1b[32;20;1m\"\n     bold_red = \"\\x1b[31;1m\"\n     bold_white = \"\\x1b[37;1m\"\n+    orange = \"\\x1b[38;5;214m\"\n+    bold_orange = \"\\x1b[38;5;214;1m\"\n     reset = \"\\x1b[0m\"\n     format = \"%(message)s\"\n \n     FORMATS = {\n         logging.DEBUG: grey + format + reset,\n         logging.INFO: format,\n         logging.WARNING: bold_yellow + format + reset,\n-        31: reset + format + reset,\n-        32: green + format + reset,\n-        33: bold_white + format + reset,\n         logging.ERROR: red + format + reset,\n         logging.CRITICAL: bold_red + format + reset,\n+        31: reset + format + reset,\n+        32: green + format + reset,\n+        33: bold_green + format + reset,\n+        34: bold_white + format + reset,\n+        35: orange + format + reset,\n+        36: bold_orange + format + reset,\n     }\n \n     def format(self, record):\n@@ -311,12 +317,32 @@ class AgentGenerationError(AgentError):\n def format_prompt_with_tools(toolbox: Toolbox, prompt_template: str, tool_description_template: str) -> str:\n     tool_descriptions = toolbox.show_tool_descriptions(tool_description_template)\n     prompt = prompt_template.replace(\"<<tool_descriptions>>\", tool_descriptions)\n+\n     if \"<<tool_names>>\" in prompt:\n         tool_names = [f\"'{tool_name}'\" for tool_name in toolbox.tools.keys()]\n         prompt = prompt.replace(\"<<tool_names>>\", \", \".join(tool_names))\n+\n     return prompt\n \n \n+def show_agents_descriptions(managed_agents: list):\n+    managed_agents_descriptions = \"\"\"\n+You can also give requests to team members.\n+Calling a team member works the same as for calling a tool: simply, the only argument you can give in the call is 'request', a long string explaning your request.\n+Given that this team member is a real human, you should be very verbose in your request.\n+Here is a list of the team members that you can call:\"\"\"\n+    for agent in managed_agents.values():\n+        managed_agents_descriptions += f\"\\n- {agent.name}: {agent.description}\"\n+    return managed_agents_descriptions\n+\n+\n+def format_prompt_with_managed_agents_descriptions(prompt_template, managed_agents=None) -> str:\n+    if managed_agents is not None:\n+        return prompt_template.replace(\"<<managed_agents_descriptions>>\", show_agents_descriptions(managed_agents))\n+    else:\n+        return prompt_template.replace(\"<<managed_agents_descriptions>>\", \"\")\n+\n+\n def format_prompt_with_imports(prompt_template: str, authorized_imports: List[str]) -> str:\n     if \"<<authorized_imports>>\" not in prompt_template:\n         raise AgentError(\"Tag '<<authorized_imports>>' should be provided in the prompt.\")\n@@ -335,8 +361,8 @@ def __init__(\n         tool_parser=parse_json_tool_call,\n         add_base_tools: bool = False,\n         verbose: int = 0,\n-        memory_verbose: bool = False,\n         grammar: Dict[str, str] = None,\n+        managed_agents: List = None,\n     ):\n         self.agent_name = self.__class__.__name__\n         self.llm_engine = llm_engine\n@@ -350,6 +376,10 @@ def __init__(\n         self.tool_parser = tool_parser\n         self.grammar = grammar\n \n+        self.managed_agents = None\n+        if managed_agents is not None:\n+            self.managed_agents = {agent.name: agent for agent in managed_agents}\n+\n         if isinstance(tools, Toolbox):\n             self._toolbox = tools\n             if add_base_tools:\n@@ -364,10 +394,10 @@ def __init__(\n         self.system_prompt = format_prompt_with_tools(\n             self._toolbox, self.system_prompt_template, self.tool_description_template\n         )\n+        self.system_prompt = format_prompt_with_managed_agents_descriptions(self.system_prompt, self.managed_agents)\n         self.prompt = None\n         self.logs = []\n         self.task = None\n-        self.memory_verbose = memory_verbose\n \n         if verbose == 0:\n             logger.setLevel(logging.WARNING)\n@@ -388,13 +418,14 @@ def initialize_for_run(self):\n             self.system_prompt_template,\n             self.tool_description_template,\n         )\n+        self.system_prompt = format_prompt_with_managed_agents_descriptions(self.system_prompt, self.managed_agents)\n         if hasattr(self, \"authorized_imports\"):\n             self.system_prompt = format_prompt_with_imports(\n                 self.system_prompt, list(set(LIST_SAFE_MODULES) | set(self.authorized_imports))\n             )\n         self.logs = [{\"system_prompt\": self.system_prompt, \"task\": self.task}]\n-        self.logger.warn(\"======== New task ========\")\n-        self.logger.log(33, self.task)\n+        self.logger.log(33, \"======== New task ========\")\n+        self.logger.log(34, self.task)\n         self.logger.debug(\"System prompt is as follows:\")\n         self.logger.debug(self.system_prompt)\n \n@@ -444,12 +475,12 @@ def write_inner_memory_from_logs(self, summary_mode: Optional[bool] = False) ->\n             if \"error\" in step_log or \"observation\" in step_log:\n                 if \"error\" in step_log:\n                     message_content = (\n-                        f\"[OUTPUT OF STEP {i}] Error: \"\n+                        f\"[OUTPUT OF STEP {i}] -> Error:\\n\"\n                         + str(step_log[\"error\"])\n                         + \"\\nNow let's retry: take care not to repeat previous errors! If you have retried several times, try a completely different approach.\\n\"\n                     )\n                 elif \"observation\" in step_log:\n-                    message_content = f\"[OUTPUT OF STEP {i}] Observation:\\n{step_log['observation']}\"\n+                    message_content = f\"[OUTPUT OF STEP {i}] -> Observation:\\n{step_log['observation']}\"\n                 tool_response_message = {\"role\": MessageRole.TOOL_RESPONSE, \"content\": message_content}\n                 memory.append(tool_response_message)\n \n@@ -477,7 +508,7 @@ def extract_action(self, llm_output: str, split_token: str) -> str:\n             raise AgentParsingError(\n                 f\"Error: No '{split_token}' token provided in your output.\\nYour output:\\n{llm_output}\\n. Be sure to include an action, prefaced with '{split_token}'!\"\n             )\n-        return rationale, action\n+        return rationale.strip(), action.strip()\n \n     def execute_tool_call(self, tool_name: str, arguments: Dict[str, str]) -> Any:\n         \"\"\"\n@@ -488,29 +519,44 @@ def execute_tool_call(self, tool_name: str, arguments: Dict[str, str]) -> Any:\n             tool_name (`str`): Name of the Tool to execute (should be one from self.toolbox).\n             arguments (Dict[str, str]): Arguments passed to the Tool.\n         \"\"\"\n-        if tool_name not in self.toolbox.tools:\n-            error_msg = f\"Error: unknown tool {tool_name}, should be instead one of {list(self.toolbox.tools.keys())}.\"\n+        available_tools = self.toolbox.tools\n+        if self.managed_agents is not None:\n+            available_tools = {**available_tools, **self.managed_agents}\n+        if tool_name not in available_tools:\n+            error_msg = f\"Error: unknown tool {tool_name}, should be instead one of {list(available_tools.keys())}.\"\n             self.logger.error(error_msg, exc_info=1)\n             raise AgentExecutionError(error_msg)\n \n         try:\n             if isinstance(arguments, str):\n-                observation = self.toolbox.tools[tool_name](arguments)\n-            else:\n+                observation = available_tools[tool_name](arguments)\n+            elif isinstance(arguments, dict):\n                 for key, value in arguments.items():\n                     # if the value is the name of a state variable like \"image.png\", replace it with the actual value\n                     if isinstance(value, str) and value in self.state:\n                         arguments[key] = self.state[value]\n-                observation = self.toolbox.tools[tool_name](**arguments)\n+                observation = available_tools[tool_name](**arguments)\n+            else:\n+                raise AgentExecutionError(\n+                    f\"Arguments passed to tool should be a dict or string: got a {type(arguments)}.\"\n+                )\n             return observation\n         except Exception as e:\n-            raise AgentExecutionError(\n-                f\"Error in tool call execution: {e}\\nYou should only use this tool with a correct input.\\n\"\n-                f\"As a reminder, this tool's description is the following:\\n{get_tool_description_with_args(self.toolbox.tools[tool_name])}\"\n-            )\n-\n-    def log_code_action(self, code_action: str) -> None:\n-        self.logger.warning(\"==== Agent is executing the code below:\")\n+            if tool_name in self.toolbox.tools:\n+                raise AgentExecutionError(\n+                    f\"Error in tool call execution: {e}\\nYou should only use this tool with a correct input.\\n\"\n+                    f\"As a reminder, this tool's description is the following:\\n{get_tool_description_with_args(available_tools[tool_name])}\"\n+                )\n+            elif tool_name in self.managed_agents:\n+                raise AgentExecutionError(\n+                    f\"Error in calling team member: {e}\\nYou should only ask this team member with a correct request.\\n\"\n+                    f\"As a reminder, this team member's description is the following:\\n{available_tools[tool_name]}\"\n+                )\n+\n+    def log_rationale_code_action(self, rationale: str, code_action: str) -> None:\n+        self.logger.warning(\"=== Agent thoughts:\")\n+        self.logger.log(31, rationale)\n+        self.logger.warning(\">>> Agent is executing the code below:\")\n         if is_pygments_available():\n             self.logger.log(\n                 31, highlight(code_action, PythonLexer(ensurenl=False), Terminal256Formatter(style=\"nord\"))\n@@ -612,12 +658,12 @@ def run(self, task: str, return_generated_code: bool = False, **kwargs):\n \n         # Parse\n         try:\n-            _, code_action = self.extract_action(llm_output=llm_output, split_token=\"Code:\")\n+            rationale, code_action = self.extract_action(llm_output=llm_output, split_token=\"Code:\")\n         except Exception as e:\n             self.logger.debug(\n                 f\"Error in extracting action, trying to parse the whole output as code. Error trace: {e}\"\n             )\n-            code_action = llm_output\n+            rationale, code_action = \"\", llm_output\n \n         try:\n             code_action = self.parse_code_blob(code_action)\n@@ -627,7 +673,7 @@ def run(self, task: str, return_generated_code: bool = False, **kwargs):\n             return error_msg\n \n         # Execute\n-        self.log_code_action(code_action)\n+        self.log_rationale_code_action(rationale, code_action)\n         try:\n             available_tools = {**BASE_PYTHON_TOOLS.copy(), **self.toolbox.tools}\n             output = self.python_evaluator(\n@@ -813,6 +859,9 @@ def planning_step(self, task, is_first_step: bool = False, iteration: int = None\n                 \"content\": PROMPTS_FOR_INITIAL_PLAN[self.plan_type][\"user\"].format(\n                     task=task,\n                     tool_descriptions=self._toolbox.show_tool_descriptions(self.tool_description_template),\n+                    managed_agents_descriptions=(\n+                        show_agents_descriptions(self.managed_agents) if self.managed_agents is not None else \"\"\n+                    ),\n                     answer_facts=answer_facts,\n                 ),\n             }\n@@ -829,8 +878,8 @@ def planning_step(self, task, is_first_step: bool = False, iteration: int = None\n {answer_facts}\n ```\"\"\".strip()\n             self.logs.append({\"plan\": final_plan_redaction, \"facts\": final_facts_redaction})\n-            self.logger.debug(\"===== Initial plan: =====\")\n-            self.logger.debug(final_plan_redaction)\n+            self.logger.log(36, \"===== Initial plan =====\")\n+            self.logger.log(35, final_plan_redaction)\n         else:  # update plan\n             agent_memory = self.write_inner_memory_from_logs(\n                 summary_mode=False\n@@ -857,6 +906,9 @@ def planning_step(self, task, is_first_step: bool = False, iteration: int = None\n                 \"content\": PROMPTS_FOR_PLAN_UPDATE[self.plan_type][\"user\"].format(\n                     task=task,\n                     tool_descriptions=self._toolbox.show_tool_descriptions(self.tool_description_template),\n+                    managed_agents_descriptions=(\n+                        show_agents_descriptions(self.managed_agents) if self.managed_agents is not None else \"\"\n+                    ),\n                     facts_update=facts_update,\n                     remaining_steps=(self.max_iterations - iteration),\n                 ),\n@@ -872,8 +924,8 @@ def planning_step(self, task, is_first_step: bool = False, iteration: int = None\n {facts_update}\n ```\"\"\"\n             self.logs.append({\"plan\": final_plan_redaction, \"facts\": final_facts_redaction})\n-            self.logger.debug(\"===== Updated plan: =====\")\n-            self.logger.debug(final_plan_redaction)\n+            self.logger.log(36, \"===== Updated plan =====\")\n+            self.logger.log(35, final_plan_redaction)\n \n \n class ReactJsonAgent(ReactAgent):\n@@ -945,7 +997,9 @@ def step(self):\n         current_step_logs[\"tool_call\"] = {\"tool_name\": tool_name, \"tool_arguments\": arguments}\n \n         # Execute\n-        self.logger.warning(f\"Calling tool: '{tool_name}' with arguments: {arguments}\")\n+        self.logger.warning(\"=== Agent thoughts:\")\n+        self.logger.log(31, rationale)\n+        self.logger.warning(f\">>> Calling tool: '{tool_name}' with arguments: {arguments}\")\n         if tool_name == \"final_answer\":\n             if isinstance(arguments, dict):\n                 if \"answer\" in arguments:\n@@ -961,6 +1015,8 @@ def step(self):\n             current_step_logs[\"final_answer\"] = answer\n             return current_step_logs\n         else:\n+            if arguments is None:\n+                arguments = {}\n             observation = self.execute_tool_call(tool_name, arguments)\n             observation_type = type(observation)\n             if observation_type == AgentText:\n@@ -1050,12 +1106,12 @@ def step(self):\n         except Exception as e:\n             raise AgentGenerationError(f\"Error in generating llm output: {e}.\")\n \n-        self.logger.debug(\"===== Output message of the LLM: =====\")\n+        self.logger.debug(\"=== Output message of the LLM:\")\n         self.logger.debug(llm_output)\n         current_step_logs[\"llm_output\"] = llm_output\n \n         # Parse\n-        self.logger.debug(\"===== Extracting action =====\")\n+        self.logger.debug(\"=== Extracting action ===\")\n         try:\n             rationale, raw_code_action = self.extract_action(llm_output=llm_output, split_token=\"Code:\")\n         except Exception as e:\n@@ -1072,30 +1128,88 @@ def step(self):\n         current_step_logs[\"tool_call\"] = {\"tool_name\": \"code interpreter\", \"tool_arguments\": code_action}\n \n         # Execute\n-        self.log_code_action(code_action)\n+        self.log_rationale_code_action(rationale, code_action)\n         try:\n+            static_tools = {\n+                **BASE_PYTHON_TOOLS.copy(),\n+                **self.toolbox.tools,\n+            }\n+            if self.managed_agents is not None:\n+                static_tools = {**static_tools, **self.managed_agents}\n             result = self.python_evaluator(\n                 code_action,\n-                static_tools={\n-                    **BASE_PYTHON_TOOLS.copy(),\n-                    **self.toolbox.tools,\n-                },\n+                static_tools=static_tools,\n                 custom_tools=self.custom_tools,\n                 state=self.state,\n                 authorized_imports=self.authorized_imports,\n             )\n-            information = self.state[\"print_outputs\"]\n             self.logger.warning(\"Print outputs:\")\n-            self.logger.log(32, information)\n-            current_step_logs[\"observation\"] = information\n+            self.logger.log(32, self.state[\"print_outputs\"])\n+            if result is not None:\n+                self.logger.warning(\"Last output from code snippet:\")\n+                self.logger.log(32, str(result))\n+            observation = \"Print outputs:\\n\" + self.state[\"print_outputs\"]\n+            if result is not None:\n+                observation += \"Last output from code snippet:\\n\" + str(result)[:100000]\n+            current_step_logs[\"observation\"] = observation\n         except Exception as e:\n             error_msg = f\"Code execution failed due to the following error:\\n{str(e)}\"\n             if \"'dict' object has no attribute 'read'\" in str(e):\n                 error_msg += \"\\nYou get this error because you passed a dict as input for one of the arguments instead of a string.\"\n             raise AgentExecutionError(error_msg)\n         for line in code_action.split(\"\\n\"):\n             if line[: len(\"final_answer\")] == \"final_answer\":\n-                self.logger.warning(\">>> Final answer:\")\n+                self.logger.log(33, \"Final answer:\")\n                 self.logger.log(32, result)\n                 current_step_logs[\"final_answer\"] = result\n         return current_step_logs\n+\n+\n+class ManagedAgent:\n+    def __init__(self, agent, name, description, additional_prompting=None, provide_run_summary=False):\n+        self.agent = agent\n+        self.name = name\n+        self.description = description\n+        self.additional_prompting = additional_prompting\n+        self.provide_run_summary = provide_run_summary\n+\n+    def write_full_task(self, task):\n+        full_task = f\"\"\"You're a helpful agent named '{self.name}'.\n+You have been submitted this task by your manager.\n+---\n+Task:\n+{task}\n+---\n+You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible so that they have a clear understanding of the answer.\n+\n+Your final_answer WILL HAVE to contain these parts:\n+### 1. Task outcome (short version):\n+### 2. Task outcome (extremely detailed version):\n+### 3. Additional context (if relevant):\n+\n+Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.\n+And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.\n+<<additional_prompting>>\"\"\"\n+        if self.additional_prompting:\n+            full_task = full_task.replace(\"\\n<<additional_prompting>>\", self.additional_prompting).strip()\n+        else:\n+            full_task = full_task.replace(\"\\n<<additional_prompting>>\", \"\").strip()\n+        return full_task\n+\n+    def __call__(self, request, **kwargs):\n+        full_task = self.write_full_task(request)\n+        output = self.agent.run(full_task, **kwargs)\n+        if self.provide_run_summary:\n+            answer = f\"Here is the final answer from your managed agent '{self.name}':\\n\"\n+            answer += str(output)\n+            answer += f\"\\n\\nFor more detail, find below a summary of this agent's work:\\nSUMMARY OF WORK FROM AGENT '{self.name}':\\n\"\n+            for message in self.agent.write_inner_memory_from_logs(summary_mode=True):\n+                content = message[\"content\"]\n+                if len(str(content)) < 1000 or \"[FACTS LIST]\" in str(content):\n+                    answer += \"\\n\" + str(content) + \"\\n---\"\n+                else:\n+                    answer += \"\\n\" + str(content)[:1000] + \"\\n(...Step was truncated because too long)...\\n---\"\n+            answer += f\"\\nEND OF SUMMARY OF WORK FROM AGENT '{self.name}'.\"\n+            return answer\n+        else:\n+            return output"
        },
        {
            "sha": "b02b12d5287ceca2327de52f1ee963041406e14f",
            "filename": "src/transformers/agents/default_tools.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/2cb543db77176b62c75085f6d4a6a3b40dbfbee8/src%2Ftransformers%2Fagents%2Fdefault_tools.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/2cb543db77176b62c75085f6d4a6a3b40dbfbee8/src%2Ftransformers%2Fagents%2Fdefault_tools.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fagents%2Fdefault_tools.py?ref=2cb543db77176b62c75085f6d4a6a3b40dbfbee8",
            "patch": "@@ -29,7 +29,7 @@\n \n \n def custom_print(*args):\n-    return \" \".join(map(str, args))\n+    return None\n \n \n BASE_PYTHON_TOOLS = {"
        },
        {
            "sha": "de8ad1d284901337df20cf7714607f36f8c9ad8b",
            "filename": "src/transformers/agents/prompts.py",
            "status": "modified",
            "additions": 10,
            "deletions": 6,
            "changes": 16,
            "blob_url": "https://github.com/huggingface/transformers/blob/2cb543db77176b62c75085f6d4a6a3b40dbfbee8/src%2Ftransformers%2Fagents%2Fprompts.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/2cb543db77176b62c75085f6d4a6a3b40dbfbee8/src%2Ftransformers%2Fagents%2Fprompts.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fagents%2Fprompts.py?ref=2cb543db77176b62c75085f6d4a6a3b40dbfbee8",
            "patch": "@@ -332,10 +332,10 @@ def download_prompt(prompt_or_repo_id, agent_name, mode=\"run\"):\n ---\n Task: \"What is the current age of the pope, raised to the power 0.36?\"\n \n-Thought: I will use the tool `search` to get the age of the pope, then raise it to the power 0.36.\n+Thought: I will use the tool `wiki` to get the age of the pope, then raise it to the power 0.36.\n Code:\n ```py\n-pope_age = search(query=\"current pope age\")\n+pope_age = wiki(query=\"current pope age\")\n print(\"Pope age:\", pope_age)\n ```<end_action>\n Observation:\n@@ -348,16 +348,16 @@ def download_prompt(prompt_or_repo_id, agent_name, mode=\"run\"):\n final_answer(pope_current_age)\n ```<end_action>\n \n-Above example were using notional tools that might not exist for you. You only have acces to those tools:\n+Above example were using notional tools that might not exist for you. On top of performing computations in the Python code snippets that you create, you have acces to those tools (and no other tool):\n \n <<tool_descriptions>>\n \n-You also can perform computations in the Python code that you generate.\n+<<managed_agents_descriptions>>\n \n Here are the rules you should always follow to solve your task:\n 1. Always provide a 'Thought:' sequence, and a 'Code:\\n```py' sequence ending with '```<end_action>' sequence, else you will fail.\n 2. Use only variables that you have defined!\n-3. Always use the right arguments for the tools. DO NOT pass the arguments as a dict as in 'answer = ask_search_agent({'query': \"What is the place where James Bond lives?\"})', but use the arguments directly as in 'answer = ask_search_agent(query=\"What is the place where James Bond lives?\")'.\n+3. Always use the right arguments for the tools. DO NOT pass the arguments as a dict as in 'answer = wiki({'query': \"What is the place where James Bond lives?\"})', but use the arguments directly as in 'answer = wiki(query=\"What is the place where James Bond lives?\")'.\n 4. Take care to not chain too many sequential tool calls in the same code block, especially when the output format is unpredictable. For instance, a call to search has an unpredictable return format, so do not have another tool call that depends on its output in the same block: rather output results with print() to use them in the next block.\n 5. Call a tool only when needed, and never re-do a tool call that you previously did with the exact same parameters.\n 6. Don't name any new variable with the same name as a tool: for instance don't name a variable 'final_answer'.\n@@ -410,6 +410,8 @@ def download_prompt(prompt_or_repo_id, agent_name, mode=\"run\"):\n Your plan can leverage any of these tools:\n {tool_descriptions}\n \n+{managed_agents_descriptions}\n+\n List of facts that you know:\n ```\n {answer_facts}\n@@ -453,9 +455,11 @@ def download_prompt(prompt_or_repo_id, agent_name, mode=\"run\"):\n {task}\n ```\n \n-You have access to these tools:\n+You have access to these tools and only these:\n {tool_descriptions}\n \n+{managed_agents_descriptions}\n+\n Here is the up to date list of facts that you know:\n ```\n {facts_update}"
        },
        {
            "sha": "fbece2bebd350fcac50dfd7217406cb3faeec8d8",
            "filename": "src/transformers/agents/python_interpreter.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/2cb543db77176b62c75085f6d4a6a3b40dbfbee8/src%2Ftransformers%2Fagents%2Fpython_interpreter.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/2cb543db77176b62c75085f6d4a6a3b40dbfbee8/src%2Ftransformers%2Fagents%2Fpython_interpreter.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fagents%2Fpython_interpreter.py?ref=2cb543db77176b62c75085f6d4a6a3b40dbfbee8",
            "patch": "@@ -434,7 +434,7 @@ def evaluate_call(call, state, static_tools, custom_tools):\n                 global PRINT_OUTPUTS\n                 PRINT_OUTPUTS += output + \"\\n\"\n                 # cap the number of lines\n-                return output\n+                return None\n             else:  # Assume it's a callable object\n                 output = func(*args, **kwargs)\n                 return output"
        },
        {
            "sha": "67cb31b7dac33436635e1270ec4e9a623db38ed9",
            "filename": "tests/agents/test_agents.py",
            "status": "modified",
            "additions": 24,
            "deletions": 1,
            "changes": 25,
            "blob_url": "https://github.com/huggingface/transformers/blob/2cb543db77176b62c75085f6d4a6a3b40dbfbee8/tests%2Fagents%2Ftest_agents.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/2cb543db77176b62c75085f6d4a6a3b40dbfbee8/tests%2Fagents%2Ftest_agents.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fagents%2Ftest_agents.py?ref=2cb543db77176b62c75085f6d4a6a3b40dbfbee8",
            "patch": "@@ -20,7 +20,14 @@\n import pytest\n \n from transformers.agents.agent_types import AgentText\n-from transformers.agents.agents import AgentMaxIterationsError, CodeAgent, ReactCodeAgent, ReactJsonAgent, Toolbox\n+from transformers.agents.agents import (\n+    AgentMaxIterationsError,\n+    CodeAgent,\n+    ManagedAgent,\n+    ReactCodeAgent,\n+    ReactJsonAgent,\n+    Toolbox,\n+)\n from transformers.agents.default_tools import PythonInterpreterTool\n from transformers.testing_utils import require_torch\n \n@@ -235,3 +242,19 @@ def test_function_persistence_across_steps(self):\n         )\n         res = agent.run(\"ok\")\n         assert res[0] == 0.5\n+\n+    def test_init_managed_agent(self):\n+        agent = ReactCodeAgent(tools=[], llm_engine=fake_react_code_functiondef)\n+        managed_agent = ManagedAgent(agent, name=\"managed_agent\", description=\"Empty\")\n+        assert managed_agent.name == \"managed_agent\"\n+        assert managed_agent.description == \"Empty\"\n+\n+    def test_agent_description_gets_correctly_inserted_in_system_prompt(self):\n+        agent = ReactCodeAgent(tools=[], llm_engine=fake_react_code_functiondef)\n+        managed_agent = ManagedAgent(agent, name=\"managed_agent\", description=\"Empty\")\n+        manager_agent = ReactCodeAgent(\n+            tools=[], llm_engine=fake_react_code_functiondef, managed_agents=[managed_agent]\n+        )\n+        assert \"You can also give requests to team members.\" not in agent.system_prompt\n+        assert \"<<managed_agents_descriptions>>\" not in agent.system_prompt\n+        assert \"You can also give requests to team members.\" in manager_agent.system_prompt"
        }
    ],
    "stats": {
        "total": 245,
        "additions": 193,
        "deletions": 52
    }
}