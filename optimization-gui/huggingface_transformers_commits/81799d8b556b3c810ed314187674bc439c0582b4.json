{
    "author": "yanamis",
    "message": "Standardize ByT5 model card format (#38699)\n\n* Standardize ByT5 model card format\n\n* Apply review feedback from @stevhliu\n\n* Fix Notes formatting and wording\n\n* Fix `aya_vision` test (#38674)\n\n* fix 1: load_in_4bit=True,\n\n* fix 2: decorateor\n\n* fixfix 2: breakpoint\n\n* fixfix 3: update\n\n* fixfix 4: fast\n\n* fixfix 5: cond\n\n* fixfix 5: cond\n\n* fixfix 6: cuda 8\n\n* ruff\n\n* breakpoint\n\n* dtype\n\n* a10\n\n* a10\n\n---------\n\nCo-authored-by: ydshieh <ydshieh@users.noreply.github.com>\n\n* Fix autodoc formatting for ByT5Tokenizer\n\n---------\n\nCo-authored-by: Yih-Dar <2521628+ydshieh@users.noreply.github.com>\nCo-authored-by: ydshieh <ydshieh@users.noreply.github.com>",
    "sha": "81799d8b556b3c810ed314187674bc439c0582b4",
    "files": [
        {
            "sha": "25340f15c5f0625574320c61473f22022cfd8f6b",
            "filename": "docs/source/en/model_doc/byt5.md",
            "status": "modified",
            "additions": 98,
            "deletions": 120,
            "changes": 218,
            "blob_url": "https://github.com/huggingface/transformers/blob/81799d8b556b3c810ed314187674bc439c0582b4/docs%2Fsource%2Fen%2Fmodel_doc%2Fbyt5.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/81799d8b556b3c810ed314187674bc439c0582b4/docs%2Fsource%2Fen%2Fmodel_doc%2Fbyt5.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fbyt5.md?ref=81799d8b556b3c810ed314187674bc439c0582b4",
            "patch": "@@ -13,150 +13,128 @@ specific language governing permissions and limitations under the License.\n rendered properly in your Markdown viewer.\n \n -->\n-\n-# ByT5\n-\n-<div class=\"flex flex-wrap space-x-1\">\n-<img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n-<img alt=\"TensorFlow\" src=\"https://img.shields.io/badge/TensorFlow-FF6F00?style=flat&logo=tensorflow&logoColor=white\">\n-<img alt=\"Flax\" src=\"https://img.shields.io/badge/Flax-29a79b.svg?style=flat&logo=data:image/png;base64,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\n-\">\n+<div style=\"float: right;\">\n+  <div class=\"flex flex-wrap space-x-1\">\n+    <img alt=\"PyTorch\" src=\"https://img.shields.io/badge/PyTorch-DE3412?style=flat&logo=pytorch&logoColor=white\">\n+    <img alt=\"TensorFlow\" src=\"https://img.shields.io/badge/TensorFlow-FF6F00?style=flat&logo=tensorflow&logoColor=white\">\n+    <img alt=\"Flax\" src=\"https://img.shields.io/badge/Flax-29a79b.svg?style=flat&logo=flax&logoColor=white\">\n+  </div>\n </div>\n \n-## Overview\n-\n-The ByT5 model was presented in [ByT5: Towards a token-free future with pre-trained byte-to-byte models](https://arxiv.org/abs/2105.13626) by Linting Xue, Aditya Barua, Noah Constant, Rami Al-Rfou, Sharan Narang, Mihir\n-Kale, Adam Roberts, Colin Raffel.\n-\n-The abstract from the paper is the following:\n-\n-*Most widely-used pre-trained language models operate on sequences of tokens corresponding to word or subword units.\n-Encoding text as a sequence of tokens requires a tokenizer, which is typically created as an independent artifact from\n-the model. Token-free models that instead operate directly on raw text (bytes or characters) have many benefits: they\n-can process text in any language out of the box, they are more robust to noise, and they minimize technical debt by\n-removing complex and error-prone text preprocessing pipelines. Since byte or character sequences are longer than token\n-sequences, past work on token-free models has often introduced new model architectures designed to amortize the cost of\n-operating directly on raw text. In this paper, we show that a standard Transformer architecture can be used with\n-minimal modifications to process byte sequences. We carefully characterize the trade-offs in terms of parameter count,\n-training FLOPs, and inference speed, and show that byte-level models are competitive with their token-level\n-counterparts. We also demonstrate that byte-level models are significantly more robust to noise and perform better on\n-tasks that are sensitive to spelling and pronunciation. As part of our contribution, we release a new set of\n-pre-trained byte-level Transformer models based on the T5 architecture, as well as all code and data used in our\n-experiments.*\n-\n-This model was contributed by [patrickvonplaten](https://huggingface.co/patrickvonplaten). The original code can be\n-found [here](https://github.com/google-research/byt5).\n+# ByT5\n \n-<Tip>\n+[ByT5](https://huggingface.co/papers/2105.13626) is tokenizer-free version of the [T5](./t5) model designed to works directly on raw UTF-8 bytes. This means it can process any language, more robust to noise like typos, and simpler to use because it doesn't require a preprocessing pipeline.\n \n-ByT5's architecture is based on the T5v1.1 model, refer to [T5v1.1's documentation page](t5v1.1) for the API reference. They\n-only differ in how inputs should be prepared for the model, see the code examples below.\n+You can find all the original ByT5 checkpoints under the [Google](https://huggingface.co/google?search_models=byt5) organization.\n \n-</Tip>\n+> [!TIP]\n+> Refer to the [T5](./t5) docs for more examples of how to apply ByT5 to different language tasks.\n \n-Since ByT5 was pre-trained unsupervisedly, there's no real advantage to using a task prefix during single-task\n-fine-tuning. If you are doing multi-task fine-tuning, you should use a prefix.\n+The example below demonstrates how to generate text with [`Pipeline`], [`AutoModel`] and from the command line.\n \n+<hfoptions id=\"usage\">\n+<hfoption id=\"Pipeline\">\n \n-## Usage example\n+```python\n+import torch\n+from transformers import pipeline\n+\n+pipeline = pipeline(\n+    task=\"text2text-generation\",\n+    model=\"google/byt5-small\",\n+    torch_dtype=torch.float16,\n+    device=0\n+)\n+pipeline(\"translate English to French: The weather is nice today\")\n+```\n \n-ByT5 works on raw UTF-8 bytes, so it can be used without a tokenizer:\n+</hfoption>\n+<hfoption id=\"AutoModel\">\n \n ```python\n->>> from transformers import T5ForConditionalGeneration\n->>> import torch\n+import torch\n+from transformers import AutoModelForSeq2SeqLM, AutoTokenizer\n+\n+tokenizer = AutoTokenizer.from_pretrained(\n+    \"google/byt5-small\"\n+)\n+model = AutoModelForSeq2SeqLM.from_pretrained(\n+    \"google/byt5-small\",\n+    torch_dtype=torch.float16,\n+    device_map=\"auto\"\n+)\n+\n+input_ids = tokenizer(\"summarize: Photosynthesis is the process by which plants, algae, and some bacteria convert light energy into chemical energy.\", return_tensors=\"pt\").to(\"cuda\")\n+\n+output = model.generate(**input_ids)\n+print(tokenizer.decode(output[0], skip_special_tokens=True))\n+```\n \n->>> model = T5ForConditionalGeneration.from_pretrained(\"google/byt5-small\")\n+</hfoption>\n+<hfoption id=\"transformers-cli\">\n \n->>> num_special_tokens = 3\n->>> # Model has 3 special tokens which take up the input ids 0,1,2 of ByT5.\n->>> # => Need to shift utf-8 character encodings by 3 before passing ids to model.\n+```bash\n+echo -e \"translate English to French: Life is beautiful.\" | transformers-cli run --task text2text-generation --model google/byt5-small --device 0\n+```\n \n->>> input_ids = torch.tensor([list(\"Life is like a box of chocolates.\".encode(\"utf-8\"))]) + num_special_tokens\n+</hfoption>\n+</hfoptions>\n \n->>> labels = torch.tensor([list(\"La vie est comme une boîte de chocolat.\".encode(\"utf-8\"))]) + num_special_tokens\n+## Quantization\n \n->>> loss = model(input_ids, labels=labels).loss\n->>> loss.item()\n-2.66\n-```\n+Quantization reduces the memory burden of large models by representing the weights in a lower precision. Refer to the [Quantization](../quantization/overview) overview for more available quantization backends. \n \n-For batched inference and training it is however recommended to make use of the tokenizer:\n+The example below uses [torchao](../quantization/torchao) to only quantize the weights to int4.\n \n ```python\n->>> from transformers import T5ForConditionalGeneration, AutoTokenizer\n-\n->>> model = T5ForConditionalGeneration.from_pretrained(\"google/byt5-small\")\n->>> tokenizer = AutoTokenizer.from_pretrained(\"google/byt5-small\")\n-\n->>> model_inputs = tokenizer(\n-...     [\"Life is like a box of chocolates.\", \"Today is Monday.\"], padding=\"longest\", return_tensors=\"pt\"\n-... )\n->>> labels_dict = tokenizer(\n-...     [\"La vie est comme une boîte de chocolat.\", \"Aujourd'hui c'est lundi.\"], padding=\"longest\", return_tensors=\"pt\"\n-... )\n->>> labels = labels_dict.input_ids\n-\n->>> loss = model(**model_inputs, labels=labels).loss\n->>> loss.item()\n-17.9\n-```\n+# pip install torchao\n+import torch\n+from transformers import TorchAoConfig, AutoModelForSeq2SeqLM, AutoTokenizer\n \n-Similar to [T5](t5), ByT5 was trained on the span-mask denoising task. However, \n-since the model works directly on characters, the pretraining task is a bit \n-different. Let's corrupt some characters of the \n-input sentence `\"The dog chases a ball in the park.\"` and ask ByT5 to predict them \n-for us.\n+quantization_config = TorchAoConfig(\"int4_weight_only\", group_size=128)\n \n-```python\n->>> from transformers import AutoTokenizer, AutoModelForSeq2SeqLM\n->>> import torch\n-\n->>> tokenizer = AutoTokenizer.from_pretrained(\"google/byt5-base\")\n->>> model = AutoModelForSeq2SeqLM.from_pretrained(\"google/byt5-base\")\n-\n->>> input_ids_prompt = \"The dog chases a ball in the park.\"\n->>> input_ids = tokenizer(input_ids_prompt).input_ids\n-\n->>> # Note that we cannot add \"{extra_id_...}\" to the string directly\n->>> # as the Byte tokenizer would incorrectly merge the tokens\n->>> # For ByT5, we need to work directly on the character level\n->>> # Contrary to T5, ByT5 does not use sentinel tokens for masking, but instead\n->>> # uses final utf character ids.\n->>> # UTF-8 is represented by 8 bits and ByT5 has 3 special tokens.\n->>> # => There are 2**8+2 = 259 input ids and mask tokens count down from index 258.\n->>> # => mask to \"The dog [258]a ball [257]park.\"\n-\n->>> input_ids = torch.tensor([input_ids[:8] + [258] + input_ids[14:21] + [257] + input_ids[28:]])\n->>> input_ids\n-tensor([[ 87, 107, 104,  35, 103, 114, 106,  35, 258,  35, 100,  35, 101, 100, 111, 111, 257,  35, 115, 100, 117, 110,  49,   1]])\n-\n->>> # ByT5 produces only one char at a time so we need to produce many more output characters here -> set `max_length=100`.\n->>> output_ids = model.generate(input_ids, max_length=100)[0].tolist()\n->>> output_ids\n-[0, 258, 108, 118,  35, 119, 107, 104,  35, 114, 113, 104,  35, 122, 107, 114,  35, 103, 114, 104, 118, 257,  35, 108, 113,  35, 119, 107, 104,  35, 103, 108, 118, 102, 114, 256, 108, 113,  35, 119, 107, 104, 35, 115, 100, 117, 110,  49,  35,  87, 107, 104,  35, 103, 114, 106, 35, 108, 118,  35, 119, 107, 104,  35, 114, 113, 104,  35, 122, 107, 114,  35, 103, 114, 104, 118,  35, 100,  35, 101, 100, 111, 111,  35, 108, 113, 255,  35, 108, 113,  35, 119, 107, 104,  35, 115, 100, 117, 110,  49]\n-\n->>> # ^- Note how 258 descends to 257, 256, 255\n-\n->>> # Now we need to split on the sentinel tokens, let's write a short loop for this\n->>> output_ids_list = []\n->>> start_token = 0\n->>> sentinel_token = 258\n->>> while sentinel_token in output_ids:\n-...     split_idx = output_ids.index(sentinel_token)\n-...     output_ids_list.append(output_ids[start_token:split_idx])\n-...     start_token = split_idx\n-...     sentinel_token -= 1\n-\n->>> output_ids_list.append(output_ids[start_token:])\n->>> output_string = tokenizer.batch_decode(output_ids_list)\n->>> output_string\n-['<pad>', 'is the one who does', ' in the disco', 'in the park. The dog is the one who does a ball in', ' in the park.']\n+model = AutoModelForSeq2SeqLM.from_pretrained(\n+    \"google/byt5-xl\",\n+    torch_dtype=torch.bfloat16,\n+    device_map=\"auto\",\n+    quantization_config=quantization_config\n+)\n+\n+tokenizer = AutoTokenizer.from_pretrained(\"google/byt5-xl\")\n+input_ids = tokenizer(\"translate English to French: The weather is nice today.\", return_tensors=\"pt\").to(\"cuda\")\n+\n+output = model.generate(**input_ids)\n+print(tokenizer.decode(output[0], skip_special_tokens=True))\n ```\n \n+## Notes\n+\n+- It is recommended to use the tokenizer for batched inference and training.\n+- The example below shows how to use the model without a tokenizer.\n+\n+    ```python\n+    import torch\n+    from transformers import AutoModelForSeq2SeqLM\n+    \n+    model = AutoModelForSeq2SeqLM.from_pretrained(\"google/byt5-small\")\n+    \n+    num_special_tokens = 3\n+    \n+    input_ids = torch.tensor([list(\"Life is like a box of chocolates.\".encode(\"utf-8\"))]) + num_special_tokens\n+    labels = torch.tensor([list(\"La vie est comme une boîte de chocolat.\".encode(\"utf-8\"))]) + num_special_tokens\n+    loss = model(input_ids, labels=labels).loss\n+    loss.item()\n+    ```\n+\n+- ByT5 uses the top byte values (258, 257, etc.) for masking instead of sentinel tokens like `{extra_id_0}`.\n+\n+    ```python\n+    # Example: character-level denoising with mask tokens\n+    input_ids = tokenizer(\"The dog chases a ball in the park.\").input_ids\n+    masked_input = torch.tensor([input_ids[:8] + [258] + input_ids[14:21] + [257] + input_ids[28:]])\n+    output = model.generate(masked_input, max_length=100)\n+    ```\n \n ## ByT5Tokenizer\n \n [[autodoc]] ByT5Tokenizer\n-\n-See [`ByT5Tokenizer`] for all details."
        }
    ],
    "stats": {
        "total": 218,
        "additions": 98,
        "deletions": 120
    }
}