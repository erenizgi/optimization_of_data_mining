{
    "author": "BenjaminBossan",
    "message": "FIX: Bug in PEFT integration delete_adapter method (#41252)\n\nThe main content of this PR is to fix a bug in the delete_adapter method\nof the PeftAdapterMixin. Previously, it did not take into account\nauxiliary modules from PEFT, e.g. those added by modules_to_save. This\nPR fixes this oversight.\n\nNote that the PR uses a new functionality from PEFT that exposes\nintegration functions like delete_adapter. Those will be contained in\nthe next PEFT release, 0.18.0 (yet unreleased). Therefore, the bug is\nonly fixed when users have a PEFT version fullfilling this requirement.\nI ensured that with old PEFT versions, the integration still works the\nsame as previously. The newly added test for this is skipped if the PEFT\nversion is too low.\n\n(Note: I tested locally with that the test will pass with PEFT 0.18.0)\n\nWhile working on this, I also cleaned up the following:\n\n- The active_adapter property has been deprecated for more than 2 years\n  (#26407). It is safe to remove it now.\n- There were numerous small errors or outdated pieces of information in\n  the docstrings, which have been addressed.\n\nWhen PEFT < 0.18.0 is used, although we cannot delete modules_to_save,\nwe can still detect them and warn about it.",
    "sha": "41e5abac5cb49983a08ddef3e8645d6efd23c8f3",
    "files": [
        {
            "sha": "22261eecad0b189706fdb38660469fa9625bc27a",
            "filename": "src/transformers/integrations/peft.py",
            "status": "modified",
            "additions": 47,
            "deletions": 55,
            "changes": 102,
            "blob_url": "https://github.com/huggingface/transformers/blob/41e5abac5cb49983a08ddef3e8645d6efd23c8f3/src%2Ftransformers%2Fintegrations%2Fpeft.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/41e5abac5cb49983a08ddef3e8645d6efd23c8f3/src%2Ftransformers%2Fintegrations%2Fpeft.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fintegrations%2Fpeft.py?ref=41e5abac5cb49983a08ddef3e8645d6efd23c8f3",
            "patch": "@@ -15,7 +15,6 @@\n import importlib\n import inspect\n import re\n-import warnings\n from typing import Any, Optional, Union\n \n from packaging import version\n@@ -70,14 +69,9 @@ class PeftAdapterMixin:\n     more details about adapters and injecting them on a transformer-based model, check out the documentation of PEFT\n     library: https://huggingface.co/docs/peft/index\n \n-    Currently supported PEFT methods are all non-prefix tuning methods. Below is the list of supported PEFT methods\n-    that anyone can load, train and run with this mixin class:\n-    - Low Rank Adapters (LoRA): https://huggingface.co/docs/peft/conceptual_guides/lora\n-    - IA3: https://huggingface.co/docs/peft/conceptual_guides/ia3\n-    - AdaLora: https://huggingface.co/papers/2303.10512\n-\n-    Other PEFT models such as prompt tuning, prompt learning are out of scope as these adapters are not \"injectable\"\n-    into a torch module. For using these methods, please refer to the usage guide of PEFT library.\n+    Currently supported PEFT methods are all non-prompt learning methods (LoRA, IA³, etc.). Other PEFT models such as\n+    prompt tuning, prompt learning are out of scope as these adapters are not \"injectable\" into a torch module. For\n+    using these methods, please refer to the usage guide of PEFT library.\n \n     With this mixin, if the correct PEFT version is installed, it is possible to:\n \n@@ -110,24 +104,21 @@ def load_adapter(\n         Load adapter weights from file or remote Hub folder. If you are not familiar with adapters and PEFT methods, we\n         invite you to read more about them on PEFT official documentation: https://huggingface.co/docs/peft\n \n-        Requires peft as a backend to load the adapter weights.\n+        Requires PEFT to be installed as a backend to load the adapter weights.\n \n         Args:\n             peft_model_id (`str`, *optional*):\n                 The identifier of the model to look for on the Hub, or a local path to the saved adapter config file\n                 and adapter weights.\n             adapter_name (`str`, *optional*):\n-                The adapter name to use. If not set, will use the default adapter.\n+                The adapter name to use. If not set, will use the name \"default\".\n             revision (`str`, *optional*, defaults to `\"main\"`):\n                 The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a\n                 git-based system for storing models and other artifacts on huggingface.co, so `revision` can be any\n                 identifier allowed by git.\n \n-                <Tip>\n-\n-                To test a pull request you made on the Hub, you can pass `revision=\"refs/pr/<pr_number>\"`.\n-\n-                </Tip>\n+                > [!TIP]\n+                > To test a pull request you made on the Hub, you can pass `revision=\"refs/pr/<pr_number>\"`.\n \n             token (`str`, `optional`):\n                 Whether to use authentication token to load the remote folder. Useful to load private repositories\n@@ -151,11 +142,11 @@ def load_adapter(\n             offload_index (`int`, `optional`):\n                 `offload_index` argument to be passed to `accelerate.dispatch_model` method.\n             peft_config (`dict[str, Any]`, *optional*):\n-                The configuration of the adapter to add, supported adapters are non-prefix tuning and adaption prompts\n-                methods. This argument is used in case users directly pass PEFT state dicts\n+                The configuration of the adapter to add, supported adapters are all non-prompt learning configs (LoRA,\n+                IA³, etc). This argument is used in case users directly pass PEFT state dicts.\n             adapter_state_dict (`dict[str, torch.Tensor]`, *optional*):\n                 The state dict of the adapter to load. This argument is used in case users directly pass PEFT state\n-                dicts\n+                dicts.\n             low_cpu_mem_usage (`bool`, *optional*, defaults to `False`):\n                 Reduce memory usage while loading the PEFT adapter. This should also speed up the loading process.\n                 Requires PEFT version 0.13.0 or higher.\n@@ -320,10 +311,12 @@ def add_adapter(self, adapter_config, adapter_name: Optional[str] = None) -> Non\n         name is assigned to the adapter to follow the convention of PEFT library (in PEFT we use \"default\" as the\n         default adapter name).\n \n+        Note that the newly added adapter is not automatically activated. To activate it, use `model.set_adapter`.\n+\n         Args:\n             adapter_config (`~peft.PeftConfig`):\n-                The configuration of the adapter to add, supported adapters are non-prefix tuning and adaption prompts\n-                methods\n+                The configuration of the adapter to add, supported adapters are non-prompt learning methods (LoRA,\n+                IA³, etc.).\n             adapter_name (`str`, *optional*, defaults to `\"default\"`):\n                 The name of the adapter to add. If no name is passed, a default name is assigned to the adapter.\n         \"\"\"\n@@ -470,13 +463,6 @@ def active_adapters(self) -> list[str]:\n \n         return active_adapters\n \n-    def active_adapter(self) -> str:\n-        warnings.warn(\n-            \"The `active_adapter` method is deprecated and will be removed in a future version.\", FutureWarning\n-        )\n-\n-        return self.active_adapters()[0]\n-\n     def get_adapter_state_dict(self, adapter_name: Optional[str] = None, state_dict: Optional[dict] = None) -> dict:\n         \"\"\"\n         If you are not familiar with adapters and PEFT methods, we invite you to read more about them on the PEFT\n@@ -564,34 +550,47 @@ def _dispatch_accelerate_model(\n \n     def delete_adapter(self, adapter_names: Union[list[str], str]) -> None:\n         \"\"\"\n-        Delete an adapter's LoRA layers from the underlying model.\n+        Delete a PEFT adapter from the underlying model.\n \n         Args:\n             adapter_names (`Union[list[str], str]`):\n                 The name(s) of the adapter(s) to delete.\n-\n-        Example:\n-\n-        ```py\n-        from diffusers import AutoPipelineForText2Image\n-        import torch\n-\n-        pipeline = AutoPipelineForText2Image.from_pretrained(\n-            \"stabilityai/stable-diffusion-xl-base-1.0\", dtype=torch.float16\n-        ).to(\"cuda\")\n-        pipeline.load_lora_weights(\n-            \"jbilcke-hf/sdxl-cinematic-1\", weight_name=\"pytorch_lora_weights.safetensors\", adapter_names=\"cinematic\"\n-        )\n-        pipeline.delete_adapters(\"cinematic\")\n-        ```\n         \"\"\"\n \n         check_peft_version(min_version=MIN_PEFT_VERSION)\n+        min_version_delete_adapter = \"0.18.0\"\n \n         if not self._hf_peft_config_loaded:\n             raise ValueError(\"No adapter loaded. Please load an adapter first.\")\n \n-        from peft.tuners.tuners_utils import BaseTunerLayer\n+        # TODO: delete old version once support for PEFT < 0.18.0 is dropped\n+        def old_delete_adapter(model, adapter_name, prefix=None):\n+            from peft.tuners.tuners_utils import BaseTunerLayer\n+            from peft.utils import ModulesToSaveWrapper\n+\n+            has_modules_to_save = False\n+            for module in model.modules():\n+                if isinstance(module, ModulesToSaveWrapper):\n+                    has_modules_to_save |= True\n+                    continue\n+                if isinstance(module, BaseTunerLayer):\n+                    if hasattr(module, \"delete_adapter\"):\n+                        module.delete_adapter(adapter_name)\n+                    else:\n+                        raise ValueError(\n+                            \"The version of PEFT you are using is not compatible, please use a version that is greater than 0.6.1\"\n+                        )\n+\n+            if has_modules_to_save:\n+                logger.warning(\n+                    \"The deleted adapter contains modules_to_save, which could not be deleted. For this to work, PEFT version \"\n+                    f\">= {min_version_delete_adapter} is required.\"\n+                )\n+\n+        if version.parse(importlib.metadata.version(\"peft\")) >= version.parse(min_version_delete_adapter):\n+            from peft.functional import delete_adapter\n+        else:\n+            delete_adapter = old_delete_adapter\n \n         if isinstance(adapter_names, str):\n             adapter_names = [adapter_names]\n@@ -603,16 +602,9 @@ def delete_adapter(self, adapter_names: Union[list[str], str]) -> None:\n                 f\"The following adapter(s) are not present and cannot be deleted: {', '.join(missing_adapters)}\"\n             )\n \n-        for adapter_name in adapter_names:\n-            for module in self.modules():\n-                if isinstance(module, BaseTunerLayer):\n-                    if hasattr(module, \"delete_adapter\"):\n-                        module.delete_adapter(adapter_name)\n-                    else:\n-                        raise ValueError(\n-                            \"The version of PEFT you are using is not compatible, please use a version that is greater than 0.6.1\"\n-                        )\n-\n+        prefixes = [f\"{self.peft_config[adapter_name].peft_type.value.lower()}_\" for adapter_name in adapter_names]\n+        for adapter_name, prefix in zip(adapter_names, prefixes):\n+            delete_adapter(self, adapter_name=adapter_name, prefix=prefix)\n             # For transformers integration - we need to pop the adapter from the config\n             if getattr(self, \"_hf_peft_config_loaded\", False) and hasattr(self, \"peft_config\"):\n                 self.peft_config.pop(adapter_name, None)"
        },
        {
            "sha": "ad0978164043b6423d1040a9b6bb205b6d3be8cb",
            "filename": "tests/peft_integration/test_peft_integration.py",
            "status": "modified",
            "additions": 63,
            "deletions": 3,
            "changes": 66,
            "blob_url": "https://github.com/huggingface/transformers/blob/41e5abac5cb49983a08ddef3e8645d6efd23c8f3/tests%2Fpeft_integration%2Ftest_peft_integration.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/41e5abac5cb49983a08ddef3e8645d6efd23c8f3/tests%2Fpeft_integration%2Ftest_peft_integration.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fpeft_integration%2Ftest_peft_integration.py?ref=41e5abac5cb49983a08ddef3e8645d6efd23c8f3",
            "patch": "@@ -20,6 +20,7 @@\n from datasets import Dataset, DatasetDict\n from huggingface_hub import hf_hub_download\n from packaging import version\n+from torch import nn\n \n from transformers import (\n     AutoModelForCausalLM,\n@@ -337,11 +338,9 @@ def test_peft_add_multi_adapter(self):\n \n                 model.set_adapter(\"default\")\n                 self.assertTrue(model.active_adapters() == [\"default\"])\n-                self.assertTrue(model.active_adapter() == \"default\")\n \n                 model.set_adapter(\"adapter-2\")\n                 self.assertTrue(model.active_adapters() == [\"adapter-2\"])\n-                self.assertTrue(model.active_adapter() == \"adapter-2\")\n \n                 # Logits comparison\n                 self.assertFalse(\n@@ -351,7 +350,6 @@ def test_peft_add_multi_adapter(self):\n \n                 model.set_adapter([\"adapter-2\", \"default\"])\n                 self.assertTrue(model.active_adapters() == [\"adapter-2\", \"default\"])\n-                self.assertTrue(model.active_adapter() == \"adapter-2\")\n \n                 logits_adapter_mixed = model(dummy_input)\n                 self.assertFalse(\n@@ -429,6 +427,68 @@ def test_delete_adapter(self):\n                 self.assertNotIn(\"adapter_1\", model.peft_config)\n                 self.assertIn(\"adapter_2\", model.peft_config)\n \n+    def test_delete_adapter_with_modules_to_save(self):\n+        \"\"\"\n+        Ensure that modules_to_save is accounted for when deleting an adapter.\n+        \"\"\"\n+        min_version_delete_adapter = \"0.18.0\"\n+        if version.parse(importlib.metadata.version(\"peft\")) < version.parse(min_version_delete_adapter):\n+            self.skipTest(\"Correctly deleting modules_to_save only works with PEFT >= 0.18.0\")\n+\n+        from peft import LoraConfig\n+\n+        # the test assumes a specific model architecture, so only test this one:\n+        model_id = \"hf-internal-testing/tiny-random-OPTForCausalLM\"\n+        model = AutoModelForCausalLM.from_pretrained(model_id).to(torch_device)\n+        peft_config = LoraConfig(init_lora_weights=False, modules_to_save=[\"lm_head\"])\n+        model.add_adapter(peft_config, adapter_name=\"adapter_1\")\n+\n+        # sanity checks\n+        self.assertIn(\"adapter_1\", model.peft_config)\n+        self.assertNotIsInstance(model.lm_head, nn.Linear)  # a ModulesToSaveWrapper\n+        self.assertTrue(hasattr(model.lm_head, \"modules_to_save\"))\n+        self.assertTrue(\"adapter_1\" in model.lm_head.modules_to_save)\n+\n+        # now delete the adapter\n+        model.delete_adapter(\"adapter_1\")\n+        self.assertFalse(hasattr(model, \"peft_config\"))\n+        self.assertFalse(\"adapter_1\" in model.lm_head.modules_to_save)\n+        self.assertFalse(model.lm_head.modules_to_save)  # i.e. empty ModuleDict\n+\n+    def test_delete_adapter_with_modules_to_save_old_peft_warns(self):\n+        \"\"\"\n+        When PEFT < 0.18.0 is being used, modules_to_save are not deleted but the user should get a warning.\n+        \"\"\"\n+        from peft import LoraConfig\n+\n+        peft_ge_018 = version.parse(importlib.metadata.version(\"peft\")) >= version.parse(\"0.18.0\")\n+        logger = logging.get_logger(\"transformers.integrations.peft\")\n+        warn_msg = \"The deleted adapter contains modules_to_save\"\n+        # the test assumes a specific model architecture, so only test this one:\n+        model_id = \"hf-internal-testing/tiny-random-OPTForCausalLM\"\n+\n+        # first a sanity check: when there is no modules_to_save, there is also no warning\n+        model = AutoModelForCausalLM.from_pretrained(model_id).to(torch_device)\n+        peft_config_0 = LoraConfig(init_lora_weights=False)\n+        model.add_adapter(peft_config_0, adapter_name=\"adapter_1\")\n+        with CaptureLogger(logger) as cl:\n+            model.delete_adapter(\"adapter_1\")\n+        assert warn_msg not in cl.out\n+\n+        # now test a model with modules_to_save\n+        model = AutoModelForCausalLM.from_pretrained(model_id).to(torch_device)\n+        peft_config_1 = LoraConfig(init_lora_weights=False, modules_to_save=[\"lm_head\"])\n+        model.add_adapter(peft_config_1, adapter_name=\"adapter_1\")\n+        with CaptureLogger(logger) as cl:\n+            model.delete_adapter(\"adapter_1\")\n+\n+        if peft_ge_018:\n+            self.assertTrue(\"adapter_1\" not in model.lm_head.modules_to_save)\n+            assert warn_msg not in cl.out\n+        else:\n+            self.assertTrue(\"adapter_1\" in model.lm_head.modules_to_save)\n+            assert warn_msg in cl.out\n+\n     @require_torch_accelerator\n     @require_bitsandbytes\n     def test_peft_from_pretrained_kwargs(self):"
        }
    ],
    "stats": {
        "total": 168,
        "additions": 110,
        "deletions": 58
    }
}