{
    "author": "gante",
    "message": "[generate] Run custom generation code from the Hub (#36405)\n\n* mvp\n\n* remove trust_remote_code\n\n* generate_from_hub\n\n* handle requirements; docs\n\n* english\n\n* doc PR suggestions\n\n* Apply suggestions from code review\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* changed remote code path to generate/generate.py\n\n* model repo has custom generate -> override base generate\n\n* check for proper inheritance\n\n* some doc updates (missing: tag-related docs)\n\n* update docs to model repo\n\n* nit\n\n* nit\n\n* nits\n\n* Update src/transformers/dynamic_module_utils.py\n\n* Apply suggestions from code review\n\n* Update docs/source/en/generation_strategies.md\n\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\n\n* trust remote code is required\n\n* use new import utils for requirements version parsing\n\n* use  org examples\n\n* add tests\n\n* Apply suggestions from code review\n\nCo-authored-by: Manuel de Prada Corral <6536835+manueldeprada@users.noreply.github.com>\n\n* ascii file structure; tag instructions on readme.md\n\n---------\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\nCo-authored-by: Pedro Cuenca <pedro@huggingface.co>\nCo-authored-by: Manuel de Prada Corral <6536835+manueldeprada@users.noreply.github.com>",
    "sha": "0e0e5c10441e807d55cc675900d3debf81834025",
    "files": [
        {
            "sha": "c6cb322e882b8e0ff3812fdf17460ee8d78c299d",
            "filename": "docs/source/en/generation_strategies.md",
            "status": "modified",
            "additions": 244,
            "deletions": 71,
            "changes": 315,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e0e5c10441e807d55cc675900d3debf81834025/docs%2Fsource%2Fen%2Fgeneration_strategies.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e0e5c10441e807d55cc675900d3debf81834025/docs%2Fsource%2Fen%2Fgeneration_strategies.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fgeneration_strategies.md?ref=0e0e5c10441e807d55cc675900d3debf81834025",
            "patch": "@@ -20,11 +20,15 @@ A decoding strategy informs how a model should select the next generated token.\n \n This guide will help you understand the different decoding strategies available in Transformers and how and when to use them.\n \n-## Greedy search\n+## Basic decoding methods\n \n-Greedy search is the default decoding strategy. It selects the next most likely token at each step. Unless specified in [`GenerationConfig`], this strategy generates a maximum of 20 tokens.\n+These are well established decoding methods, and should be your starting point for text generation tasks.\n \n-Greedy search works well for tasks with relatively short outputs. However, it breaks down when generating longer sequences because it begins to repeat itself.\n+### Greedy search\n+\n+Greedy search is the default decoding strategy. It selects the next most likely token at each step. Unless specified in [`GenerationConfig`], this strategy generates a maximum of 20 new tokens.\n+\n+Greedy search works well for tasks with relatively short outputs where creativity is not a priority. However, it breaks down when generating longer sequences because it begins to repeat itself.\n \n ```py\n import torch\n@@ -40,11 +44,11 @@ tokenizer.batch_decode(outputs, skip_special_tokens=True)\n 'Hugging Face is an open-source company that provides a suite of tools and services for building, deploying, and maintaining natural language processing'\n ```\n \n-## Contrastive search\n+### Sampling\n \n-[Contrastive search](https://huggingface.co/papers/2202.06417) is a decoding strategy that aims to reduce repetition even while generating longer sequences. This strategy compares how similar a generated token is against previous tokens, and if they're more similar, a penalty is applied.\n+Sampling, or multinomial sampling, randomly selects a token based on the probability distribution over the entire model's vocabulary (as opposed to the most likely token, as in greedy search). This means every token with a non-zero probability has a chance to be selected. Sampling strategies reduce repetition and can generate more creative and diverse outputs.\n \n-Enable contrastive search with the `penalty_alpha` and `top_k` parameters. The `penalty_alpha` manages the penalty applied and `top_k` is the number of most likely tokens to return.\n+Enable multinomial sampling with `do_sample=True` and `num_beams=1`.\n \n ```py\n import torch\n@@ -55,14 +59,14 @@ inputs = tokenizer(\"Hugging Face is an open-source company\", return_tensors=\"pt\"\n \n model = AutoModelForCausalLM.from_pretrained(\"meta-llama/Llama-2-7b-hf\", torch_dtype=torch.float16).to(\"cuda\")\n # explicitly set to 100 because Llama2 generation length is 4096\n-outputs = model.generate(**inputs, max_new_tokens=100, penalty_alpha=0.6, top_k=4)\n+outputs = model.generate(**inputs, max_new_tokens=50, do_sample=True, num_beams=1)\n tokenizer.batch_decode(outputs, skip_special_tokens=True)\n-'Hugging Face is an open-source company that provides a platform for building and deploying AI models.\\nHugging Face is an open-source company that provides a platform for building and deploying AI models. The platform allows developers to build and deploy AI models, as well as collaborate with other developers.\\nHugging Face was founded in 2019 by Thibault Wittemberg and ClÃ©ment Delangue. The company is based in Paris, France.\\nHugging Face has'\n+'Hugging Face is an open-source company ðŸ¤—\\nWe are open-source and believe that open-source is the best way to build technology. Our mission is to make AI accessible to everyone, and we believe that open-source is the best way to achieve that.'\n ```\n \n-## Beam search\n+### Beam search\n \n-Beam search keeps track of several generated sequences (beams) at each time step. After a certain number of steps, it selects the sequence with the highest *overall* probability. Unlike greedy search, this strategy can \"look ahead\" and pick a sequence with a higher probability overall even if the initial tokens have a lower probability.\n+Beam search keeps track of several generated sequences (beams) at each time step. After a certain number of steps, it selects the sequence with the highest *overall* probability. Unlike greedy search, this strategy can \"look ahead\" and pick a sequence with a higher probability overall even if the initial tokens have a lower probability. It is best suited for input-grounded tasks, like describing an image or speech recognition. You can also use `do_sample=True` with beam search to sample at each step, but beam search will still greedily prune out low probability sequences between steps.\n \n > [!TIP]\n > Check out the [beam search visualizer](https://huggingface.co/spaces/m-ric/beam_search_visualizer) to see how beam search works.\n@@ -83,66 +87,11 @@ tokenizer.batch_decode(outputs, skip_special_tokens=True)\n \"['Hugging Face is an open-source company that develops and maintains the Hugging Face platform, which is a collection of tools and libraries for building and deploying natural language processing (NLP) models. Hugging Face was founded in 2018 by Thomas Wolf']\"\n ```\n \n-## Diverse beam search\n-\n-[Diverse beam search](https://hf.co/papers/1610.02424) is a variant of beam search that produces more diverse output candidates to choose from. This strategy measures the dissimilarity of sequences and a penalty is applied if sequences are too similar. To avoid high computation costs, the number of beams is divided into groups.\n-\n-Enable diverse beam search with the `num_beams`, `num_beam_groups` and `diversity_penalty` parameters (the `num_beams` parameter should be divisible by `num_beam_groups`).\n-\n-```py\n-import torch\n-from transformers import AutoModelForCausalLM, AutoTokenizer\n-\n-tokenizer = AutoTokenizer.from_pretrained(\"meta-llama/Llama-2-7b-hf\")\n-inputs = tokenizer(\"Hugging Face is an open-source company\", return_tensors=\"pt\").to(\"cuda\")\n-\n-model = AutoModelForCausalLM.from_pretrained(\"meta-llama/Llama-2-7b-hf\", torch_dtype=torch.float16).to(\"cuda\")\n-# explicitly set to 100 because Llama2 generation length is 4096\n-outputs = model.generate(**inputs, max_new_tokens=50, num_beams=6, num_beam_groups=3, diversity_penalty=1.0, do_sample=False)\n-tokenizer.batch_decode(outputs, skip_special_tokens=True)\n-'Hugging Face is an open-source company ðŸ¤—\\nWe are an open-source company. Our mission is to democratize AI and make it accessible to everyone. We believe that AI should be used for the benefit of humanity, not for the benefit of a'\n-```\n-\n-## Multinomial sampling\n-\n-Search methods selects the most likely tokens. Sampling, or multinomial sampling, randomly selects a token based on the probability distribution over the entire models vocabulary. This means every token with a non-zero probability has a chance to be selected. Sampling strategies reduce repetition and can generate more creative and diverse outputs.\n-\n-Enable multinomial sampling with `do_sample=True` and `num_beams=1`.\n-\n-```py\n-import torch\n-from transformers import AutoModelForCausalLM, AutoTokenizer\n-\n-tokenizer = AutoTokenizer.from_pretrained(\"meta-llama/Llama-2-7b-hf\")\n-inputs = tokenizer(\"Hugging Face is an open-source company\", return_tensors=\"pt\").to(\"cuda\")\n-\n-model = AutoModelForCausalLM.from_pretrained(\"meta-llama/Llama-2-7b-hf\", torch_dtype=torch.float16).to(\"cuda\")\n-# explicitly set to 100 because Llama2 generation length is 4096\n-outputs = model.generate(**inputs, max_new_tokens=50, do_sample=True, num_beams=1)\n-tokenizer.batch_decode(outputs, skip_special_tokens=True)\n-'Hugging Face is an open-source company ðŸ¤—\\nWe are open-source and believe that open-source is the best way to build technology. Our mission is to make AI accessible to everyone, and we believe that open-source is the best way to achieve that.'\n-```\n-\n-## Beam search multinomial sampling\n+## Advanced decoding methods\n \n-This decoding strategy is a combination of beam search and multinomial sampling. It generates multiple beams and uses a sampling strategy for each beam.\n+Advanced decoding methods aim at either tackling specific generation quality issues (e.g. repetition) or at improving the generation throughput in certain situations. These techniques are more complex, and may not work correctly with all models.\n \n-Enable beam search multinomial sampling by setting `num_beams` to a value greater than 1 and `do_sample=True`.\n-\n-```py\n-import torch\n-from transformers import AutoModelForCausalLM, AutoTokenizer\n-\n-tokenizer = AutoTokenizer.from_pretrained(\"meta-llama/Llama-2-7b-hf\")\n-inputs = tokenizer(\"Hugging Face is an open-source company\", return_tensors=\"pt\").to(\"cuda\")\n-\n-model = AutoModelForCausalLM.from_pretrained(\"meta-llama/Llama-2-7b-hf\", torch_dtype=torch.float16).to(\"cuda\")\n-# explicitly set to 100 because Llama2 generation length is 4096\n-outputs = model.generate(**inputs, max_new_tokens=50, do_sample=True, num_beams=4)\n-'Hugging Face is an open-source company 100% dedicated to making AI more accessible. We believe that AI should be available to everyone, and weâ€™re working hard to make that a reality.\\nWeâ€™re a team of passionate engineers, designers,'\n-```\n-\n-## Speculative decoding\n+### Speculative decoding\n \n [Speculative](https://hf.co/papers/2211.17192) or assistive decoding isn't a search or sampling strategy. Instead, speculative decoding adds a second smaller model to generate candidate tokens. The main model verifies the candidate tokens in a single `forward` pass, which speeds up the decoding process overall. This method is especially useful for LLMs where it can be more costly and slower to generate tokens. Refer to the [speculative decoding](./llm_optims#speculative-decoding) guide to learn more.\n \n@@ -203,7 +152,7 @@ tokenizer.batch_decode(outputs, skip_special_tokens=True)\n </hfoption>\n </hfoptions>\n \n-### Prompt lookup decoding\n+#### Prompt lookup decoding\n \n [Prompt lookup decoding](./llm_optims#prompt-lookup-decoding) is a variant of speculative decoding that uses overlapping n-grams as the candidate tokens. It works well for input-grounded tasks such as summarization. Refer to the [prompt lookup decoding](./llm_optims#prompt-lookup-decoding) guide to learn more.\n \n@@ -245,7 +194,7 @@ outputs = model.generate(**inputs, assistant_early_exit=4, do_sample=False, max_\n tokenizer.batch_decode(outputs, skip_special_tokens=True)\n ```\n \n-### Universal assisted decoding\n+#### Universal assisted decoding\n \n Universal assisted decoding (UAD) enables the main and assistant models to use different tokenizers. The main models input tokens are re-encoded into assistant model tokens. Candidate tokens are generated in the assistant encoding which are re-encoded into the main model candidate tokens. The candidate tokens are verified as explained in [speculative decoding](#speculative-decoding).\n \n@@ -269,7 +218,27 @@ tokenizer.batch_decode(outputs, skip_special_tokens=True)\n ['Alice and Bob are sitting in a bar. Alice is drinking a beer and Bob is drinking a']\n ```\n \n-## DoLa\n+### Contrastive search\n+\n+[Contrastive search](https://huggingface.co/papers/2202.06417) is a decoding strategy that aims to reduce repetition even while generating longer sequences. This strategy compares how similar a generated token is against previous tokens, and if they're more similar, a penalty is applied.\n+\n+Enable contrastive search with the `penalty_alpha` and `top_k` parameters. The `penalty_alpha` manages the penalty applied and `top_k` is the number of most likely tokens to return.\n+\n+```py\n+import torch\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+tokenizer = AutoTokenizer.from_pretrained(\"meta-llama/Llama-2-7b-hf\")\n+inputs = tokenizer(\"Hugging Face is an open-source company\", return_tensors=\"pt\").to(\"cuda\")\n+\n+model = AutoModelForCausalLM.from_pretrained(\"meta-llama/Llama-2-7b-hf\", torch_dtype=torch.float16).to(\"cuda\")\n+# explicitly set to 100 because Llama2 generation length is 4096\n+outputs = model.generate(**inputs, max_new_tokens=100, penalty_alpha=0.6, top_k=4)\n+tokenizer.batch_decode(outputs, skip_special_tokens=True)\n+'Hugging Face is an open-source company that provides a platform for building and deploying AI models.\\nHugging Face is an open-source company that provides a platform for building and deploying AI models. The platform allows developers to build and deploy AI models, as well as collaborate with other developers.\\nHugging Face was founded in 2019 by Thibault Wittemberg and ClÃ©ment Delangue. The company is based in Paris, France.\\nHugging Face has'\n+```\n+\n+### DoLa\n \n [Decoding by Contrasting Layers (DoLa)](https://hf.co/papers/2309.03883) is a contrastive decoding strategy for improving factuality and reducing hallucination. This strategy works by contrasting the logit differences between the final and early layers. As a result, factual knowledge localized to particular layers are amplified. DoLa is not recommended for smaller models like GPT-2.\n \n@@ -325,6 +294,210 @@ tokenizer.batch_decode(outputs[:, inputs.input_ids.shape[-1]:], skip_special_tok\n </hfoption>\n </hfoptions>\n \n+### Diverse beam search\n+\n+[Diverse beam search](https://hf.co/papers/1610.02424) is a variant of beam search that produces more diverse output candidates to choose from. This strategy measures the dissimilarity of sequences and a penalty is applied if sequences are too similar. To avoid high computation costs, the number of beams is divided into groups.\n+\n+Enable diverse beam search with the `num_beams`, `num_beam_groups` and `diversity_penalty` parameters (the `num_beams` parameter should be divisible by `num_beam_groups`).\n+\n+```py\n+import torch\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+tokenizer = AutoTokenizer.from_pretrained(\"meta-llama/Llama-2-7b-hf\")\n+inputs = tokenizer(\"Hugging Face is an open-source company\", return_tensors=\"pt\").to(\"cuda\")\n+\n+model = AutoModelForCausalLM.from_pretrained(\"meta-llama/Llama-2-7b-hf\", torch_dtype=torch.float16).to(\"cuda\")\n+# explicitly set to 100 because Llama2 generation length is 4096\n+outputs = model.generate(**inputs, max_new_tokens=50, num_beams=6, num_beam_groups=3, diversity_penalty=1.0, do_sample=False)\n+tokenizer.batch_decode(outputs, skip_special_tokens=True)\n+'Hugging Face is an open-source company ðŸ¤—\\nWe are an open-source company. Our mission is to democratize AI and make it accessible to everyone. We believe that AI should be used for the benefit of humanity, not for the benefit of a'\n+```\n+\n+\n+## Custom decoding methods\n+\n+Custom decoding methods enable specialized generation behavior such as the following:\n+- have the model continue thinking if it is uncertain;\n+- roll back generation if the model gets stuck;\n+- handle special tokens with custom logic;\n+- enhanced input preparation for advanced models;\n+\n+We enable custom decoding methods through model repositories, assuming a specific model tag and file structure (see subsection below). This feature is an extension of [custom modeling code](./models.md#custom-models) and, like such, requires setting `trust_remote_code=True`.\n+\n+If a model repository holds a custom decoding method, the easiest way to try it out is to load the model and generate with it:\n+\n+<!-- TODO before merging: 1) better repo name (use a `generate-community` org?) 2) prettify the repo -->\n+```py\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+# `transformers-community/custom_generate_example` holds a copy of `Qwen/Qwen2.5-0.5B-Instruct`, but\n+# with custom generation code -> calling `generate` uses the custom decoding method!\n+tokenizer = AutoTokenizer.from_pretrained(\"transformers-community/custom_generate_example\")\n+model = AutoModelForCausalLM.from_pretrained(\n+    \"transformers-community/custom_generate_example\", device_map=\"auto\", trust_remote_code=True\n+)\n+\n+inputs = tokenizer([\"The quick brown\"], return_tensors=\"pt\").to(model.device)\n+# The custom decoding method is a minimal greedy decoding implementation. It also prints a custom message at run time.\n+gen_out = model.generate(**inputs)\n+# you should now see its custom message, \"âœ¨ using a custom generation method âœ¨\"\n+print(tokenizer.batch_decode(gen_out, skip_special_tokens=True))\n+'The quick brown fox jumps over a lazy dog, and the dog is a type of animal. Is'\n+```\n+\n+Model repositories with custom decoding methods have a special property: their decoding method can be loaded from **any** model through [`~GenerationMixin.generate`]'s `custom_generate` argument. This means anyone can create and share their custom generation method to potentially work with any Transformers model, without requiring users to install additional Python packages.\n+\n+```py\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+tokenizer = AutoTokenizer.from_pretrained(\"Qwen/Qwen2.5-0.5B-Instruct\")\n+model = AutoModelForCausalLM.from_pretrained(\"Qwen/Qwen2.5-0.5B-Instruct\", device_map=\"auto\")\n+\n+inputs = tokenizer([\"The quick brown\"], return_tensors=\"pt\").to(model.device)\n+# `custom_generate` replaces the original `generate` by the custom decoding method defined in\n+# `transformers-community/custom_generate_example`\n+gen_out = model.generate(**inputs, custom_generate=\"transformers-community/custom_generate_example\", trust_remote_code=True)\n+print(tokenizer.batch_decode(gen_out, skip_special_tokens=True)[0])\n+'The quick brown fox jumps over a lazy dog, and the dog is a type of animal. Is'\n+```\n+\n+You should read the `README.md` file of the repository containing the custom generation strategy to see what the new arguments and output type differences are, if they exist. Otherwise, you can assume it works like the base [`~GenerationMixin.generate`] method.\n+\n+> [!TIP]\n+> You can find all custom decoding methods by [searching for their custom tag.](https://huggingface.co/models?other=custom_generate), `custom_generate`\n+\n+Consider the Hub repository [transformers-community/custom_generate_example](https://huggingface.co/transformers-community/custom_generate_example) as an example. The `README.md` states that it has an additional input argument, `left_padding`, which adds a number of padding tokens before the prompt.\n+\n+```py\n+gen_out = model.generate(\n+    **inputs, custom_generate=\"transformers-community/custom_generate_example\", trust_remote_code=True, left_padding=5\n+)\n+print(tokenizer.batch_decode(gen_out)[0])\n+'<|endoftext|><|endoftext|><|endoftext|><|endoftext|><|endoftext|>The quick brown fox jumps over the lazy dog.\\n\\nThe sentence \"The quick'\n+```\n+\n+If the custom method has pinned Python requirements that your environment doesn't meet, you'll get an exception about missing requirements. For instance, [transformers-community/custom_generate_bad_requirements](https://huggingface.co/transformers-community/custom_generate_bad_requirements) has an impossible set of requirements defined in its `custom_generate/requirements.txt` file, and you'll see the error message below if you try to run it.\n+\n+```\n+ImportError: Missing requirements in your local environment for `transformers-community/custom_generate_bad_requirements`:\n+foo (installed: None)\n+bar==0.0.0 (installed: None)\n+torch>=99.0 (installed: 2.6.0)\n+```\n+\n+Updating your Python requirements accordingly will remove this error message.\n+\n+### Creating a custom decoding method\n+\n+To create a new decoding method, you need to create a new [**Model**](https://huggingface.co/new) repository and push a few files into it.\n+1. The model you've designed your decoding method with.\n+2. `custom_generate/generate.py`, which contains all the logic for your custom decoding method.\n+3. `custom_generate/requirements.txt`, used to optionally add new Python requirements and/or lock specific versions to correctly use your method.\n+4. `README.md`, where you should add the `custom_generate` tag and document any new arguments or output type differences of your custom method here.\n+\n+After you've added all required files, your repository should look like this\n+\n+```\n+your_repo/\n+â”œâ”€â”€ README.md          # include the 'custom_generate' tag\n+â”œâ”€â”€ config.json\n+â”œâ”€â”€ ...\n+â””â”€â”€ custom_generate/\n+    â”œâ”€â”€ generate.py\n+    â””â”€â”€ requirements.txt\n+```\n+\n+#### Adding the base model\n+\n+The starting point for your custom decoding method is a model repository just like any other. The model to add to this repository should be the model you've designed your method with, and it is meant to be part of a working self-contained model-generate pair. When the model in this repository is loaded, your custom decoding method will override `generate`. Don't worry -- your decoding method can still be loaded with any other Transformers model, as explained in the section above.\n+\n+If you simply want to copy an existing model, you can do\n+\n+```py\n+from transformers import AutoModelForCausalLM, AutoTokenizer\n+\n+tokenizer = AutoTokenizer.from_pretrained(\"source/model_repo\")\n+model = AutoModelForCausalLM.from_pretrained(\"source/model_repo\")\n+tokenizer.save_pretrained(\"your/decoding_method\", push_to_hub=True)\n+model.save_pretrained(\"your/decoding_method\", push_to_hub=True)\n+```\n+\n+#### generate.py\n+\n+This is the core of your decoding method. It *must* contain a method named `generate`, and this method *must* contain a `model` argument as its first argument. `model` is the model instance, which means you have access to all attributes and methods in the model, including the ones defined in [`GenerationMixin`] (like the base `generate` method).\n+\n+> [!WARNING]\n+> `generate.py` must be placed in a folder named `custom_generate`, and not at the root level of the repository. The file paths for this feature are hardcoded.\n+\n+Under the hood, when the base [`~GenerationMixin.generate`] method is called with a `custom_generate` argument, it first checks its Python requirements (if any), then locates the custom `generate` method in `generate.py`, and finally calls the custom `generate`. All received arguments and `model` are forwarded to your custom `generate` method.\n+\n+This means your `generate` can have a mix of original and custom arguments (as well as a different output type) as shown below.\n+\n+```py\n+import torch\n+\n+def generate(model, input_ids, generation_config=None, left_padding=None, **kwargs):\n+    generation_config = generation_config or model.generation_config  # default to the model generation config\n+    cur_length = input_ids.shape[1]\n+    max_length = generation_config.max_length or cur_length + generation_config.max_new_tokens\n+\n+    # Example of custom argument: add `left_padding` (integer) pad tokens before the prompt\n+    if left_padding is not None:\n+        if not isinstance(left_padding, int) or left_padding < 0:\n+            raise ValueError(f\"left_padding must be an integer larger than 0, but is {left_padding}\")\n+\n+        pad_token = kwargs.pop(\"pad_token\", None) or generation_config.pad_token_id or model.config.pad_token_id\n+        if pad_token is None:\n+            raise ValueError(\"pad_token is not defined\")\n+        batch_size = input_ids.shape[0]\n+        pad_tensor = torch.full(size=(batch_size, left_padding), fill_value=pad_token).to(input_ids.device)\n+        input_ids = torch.cat((pad_tensor, input_ids), dim=1)\n+        cur_length = input_ids.shape[1]\n+\n+    # Simple greedy decoding loop\n+    while cur_length < max_length:\n+        logits = model(input_ids).logits\n+        next_token_logits = logits[:, -1, :]\n+        next_tokens = torch.argmax(next_token_logits, dim=-1)\n+        input_ids = torch.cat((input_ids, next_tokens[:, None]), dim=-1)\n+        cur_length += 1\n+\n+    return input_ids\n+```\n+\n+Follow the recommended practices below to ensure your custom decoding method works as expected.\n+- Feel free to reuse the logic for validation and input preparation in the original [`~GenerationMixin.generate`].\n+- Pin the `transformers` version in the requirements if you use any private method/attribute in `model`.\n+- You can add other files in the `custom_generate` folder, and use relative imports.\n+- Consider adding model validation, input validation, or even a separate test file to help users sanity-check your code in their environment.\n+\n+#### requirements.txt\n+\n+You can optionally specify additional Python requirements in a `requirements.txt` file inside the `custom_generate` folder. These are checked at runtime and an exception will be thrown if they're missing, nudging users to update their environment accordingly.\n+\n+#### README.md\n+\n+The root level `README.md` in the model repository usually describes the model therein. However, since the focus of the repository is the custom decoding method, we highly recommend to shift its focus towards describing the custom decoding method. In addition to a description of the method, we recommend documenting any input and/or output differences to the original [`~GenerationMixin.generate`]. This way, users can focus on what's new, and rely on Transformers docs for generic implementation details.\n+\n+For discoverability, we highly recommend you to add the `custom_generate` tag to your repository. To do so, the top of your `README.md` file should look like the example below. After you push the file, you should see the tag in your repository!\n+\n+```\n+---\n+library_name: transformers\n+tags:\n+  - custom_generate\n+---\n+\n+(your markdown content here)\n+```\n+\n+Recommended practices:\n+- Document input and output differences in [`~GenerationMixin.generate`].\n+- Add self-contained examples to enable quick experimentation.\n+- Describe soft-requirements such as if the method only works well with a certain family of models.\n+\n+\n ## Resources\n \n Read the [How to generate text: using different decoding methods for language generation with Transformers](https://huggingface.co/blog/how-to-generate) blog post for an explanation of how common decoding strategies work."
        },
        {
            "sha": "eec01749b65368dbbf35f3382801b2a3e2c1e3dc",
            "filename": "src/transformers/dynamic_module_utils.py",
            "status": "modified",
            "additions": 93,
            "deletions": 10,
            "changes": 103,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e0e5c10441e807d55cc675900d3debf81834025/src%2Ftransformers%2Fdynamic_module_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e0e5c10441e807d55cc675900d3debf81834025/src%2Ftransformers%2Fdynamic_module_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fdynamic_module_utils.py?ref=0e0e5c10441e807d55cc675900d3debf81834025",
            "patch": "@@ -17,6 +17,7 @@\n import filecmp\n import hashlib\n import importlib\n+import importlib.metadata\n import importlib.util\n import os\n import re\n@@ -30,6 +31,7 @@\n from typing import Any, Optional, Union\n \n from huggingface_hub import try_to_load_from_cache\n+from packaging import version\n \n from .utils import (\n     HF_MODULES_CACHE,\n@@ -39,6 +41,7 @@\n     is_offline_mode,\n     logging,\n )\n+from .utils.import_utils import VersionComparison, split_package_version\n \n \n logger = logging.get_logger(__name__)  # pylint: disable=invalid-name\n@@ -383,7 +386,7 @@ def get_cached_module_file(\n             new_files.append(module_file)\n \n     except OSError:\n-        logger.error(f\"Could not locate the {module_file} inside {pretrained_model_name_or_path}.\")\n+        logger.info(f\"Could not locate the {module_file} inside {pretrained_model_name_or_path}.\")\n         raise\n \n     # Check we have all the requirements in our environment\n@@ -417,7 +420,8 @@ def get_cached_module_file(\n         # benefit of versioning.\n         submodule_path = submodule_path / commit_hash\n         full_submodule = full_submodule + os.path.sep + commit_hash\n-        create_dynamic_module(full_submodule)\n+        full_submodule_module_file_path = os.path.join(full_submodule, module_file)\n+        create_dynamic_module(Path(full_submodule_module_file_path).parent)\n \n         if not (submodule_path / module_file).exists():\n             shutil.copy(resolved_module_file, submodule_path / module_file)\n@@ -663,7 +667,33 @@ def _raise_timeout_error(signum, frame):\n TIME_OUT_REMOTE_CODE = 15\n \n \n-def resolve_trust_remote_code(trust_remote_code, model_name, has_local_code, has_remote_code):\n+def resolve_trust_remote_code(trust_remote_code, model_name, has_local_code, has_remote_code, error_message=None):\n+    \"\"\"\n+    Resolves the `trust_remote_code` argument. If there is remote code to be loaded, the user must opt-in to loading\n+    it.\n+\n+    Args:\n+        trust_remote_code (`bool` or `None`):\n+            User-defined `trust_remote_code` value.\n+        model_name (`str`):\n+            The name of the model repository in huggingface.co.\n+        has_local_code (`bool`):\n+            Whether the model has local code.\n+        has_remote_code (`bool`):\n+            Whether the model has remote code.\n+        error_message (`str`, *optional*):\n+            Custom error message to display if there is remote code to load and the user didn't opt-in. If unset, the error\n+            message will be regarding loading a model with custom code.\n+\n+    Returns:\n+        The resolved `trust_remote_code` value.\n+    \"\"\"\n+    # Originally, `trust_remote_code` was used to load models with custom code.\n+    error_message = (\n+        error_message\n+        or f\"The repository `{model_name}` contains custom code which must be executed to correctly load the model.\"\n+    )\n+\n     if trust_remote_code is None:\n         if has_local_code:\n             trust_remote_code = False\n@@ -674,8 +704,7 @@ def resolve_trust_remote_code(trust_remote_code, model_name, has_local_code, has\n                 signal.alarm(TIME_OUT_REMOTE_CODE)\n                 while trust_remote_code is None:\n                     answer = input(\n-                        f\"The repository for {model_name} contains custom code which must be executed to correctly \"\n-                        f\"load the model. You can inspect the repository content at https://hf.co/{model_name}.\\n\"\n+                        f\"{error_message} You can inspect the repository content at https://hf.co/{model_name}.\\n\"\n                         f\"You can avoid this prompt in future by passing the argument `trust_remote_code=True`.\\n\\n\"\n                         f\"Do you wish to run the custom code? [y/N] \"\n                     )\n@@ -687,8 +716,7 @@ def resolve_trust_remote_code(trust_remote_code, model_name, has_local_code, has\n             except Exception:\n                 # OS which does not support signal.SIGALRM\n                 raise ValueError(\n-                    f\"The repository for {model_name} contains custom code which must be executed to correctly \"\n-                    f\"load the model. You can inspect the repository content at https://hf.co/{model_name}.\\n\"\n+                    f\"{error_message} You can inspect the repository content at https://hf.co/{model_name}.\\n\"\n                     f\"Please pass the argument `trust_remote_code=True` to allow custom code to be run.\"\n                 )\n             finally:\n@@ -701,9 +729,64 @@ def resolve_trust_remote_code(trust_remote_code, model_name, has_local_code, has\n \n     if has_remote_code and not has_local_code and not trust_remote_code:\n         raise ValueError(\n-            f\"Loading {model_name} requires you to execute the configuration file in that\"\n-            \" repo on your local machine. Make sure you have read the code there to avoid malicious use, then\"\n-            \" set the option `trust_remote_code=True` to remove this error.\"\n+            f\"{error_message} You can inspect the repository content at https://hf.co/{model_name}.\\n\"\n+            f\"Please pass the argument `trust_remote_code=True` to allow custom code to be run.\"\n         )\n \n     return trust_remote_code\n+\n+\n+def check_python_requirements(path_or_repo_id, requirements_file=\"requirements.txt\", **kwargs):\n+    \"\"\"\n+    Tries to locate `requirements_file` in a local folder or repo, and confirms that the environment has all the\n+    python dependencies installed.\n+\n+    Args:\n+        path_or_repo_id (`str` or `os.PathLike`):\n+            This can be either:\n+            - a string, the *model id* of a model repo on huggingface.co.\n+            - a path to a *directory* potentially containing the file.\n+        kwargs (`Dict[str, Any]`, *optional*):\n+            Additional arguments to pass to `cached_file`.\n+    \"\"\"\n+    failed = []  # error messages regarding requirements\n+    try:\n+        requirements = cached_file(path_or_repo_id=path_or_repo_id, filename=requirements_file, **kwargs)\n+        with open(requirements, \"r\") as f:\n+            requirements = f.readlines()\n+\n+        for requirement in requirements:\n+            requirement = requirement.strip()\n+            if not requirement or requirement.startswith(\"#\"):  # skip empty lines and comments\n+                continue\n+\n+            try:\n+                # e.g. \"torch>2.6.0\" -> \"torch\", \">\", \"2.6.0\"\n+                package_name, delimiter, version_number = split_package_version(requirement)\n+            except ValueError:  # e.g. \"torch\", as opposed to \"torch>2.6.0\"\n+                package_name = requirement\n+                delimiter, version_number = None, None\n+\n+            try:\n+                local_package_version = importlib.metadata.version(package_name)\n+            except importlib.metadata.PackageNotFoundError:\n+                failed.append(f\"{requirement} (installed: None)\")\n+                continue\n+\n+            if delimiter is not None and version_number is not None:\n+                is_satisfied = VersionComparison.from_string(delimiter)(\n+                    version.parse(local_package_version), version.parse(version_number)\n+                )\n+            else:\n+                is_satisfied = True\n+\n+            if not is_satisfied:\n+                failed.append(f\"{requirement} (installed: {local_package_version})\")\n+\n+    except OSError:  # no requirements.txt\n+        pass\n+\n+    if failed:\n+        raise ImportError(\n+            f\"Missing requirements in your local environment for `{path_or_repo_id}`:\\n\" + \"\\n\".join(failed)\n+        )"
        },
        {
            "sha": "3d02212cdafa992d831d3cd1a025bdc8f65c6f47",
            "filename": "src/transformers/generation/utils.py",
            "status": "modified",
            "additions": 95,
            "deletions": 2,
            "changes": 97,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e0e5c10441e807d55cc675900d3debf81834025/src%2Ftransformers%2Fgeneration%2Futils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e0e5c10441e807d55cc675900d3debf81834025/src%2Ftransformers%2Fgeneration%2Futils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Futils.py?ref=0e0e5c10441e807d55cc675900d3debf81834025",
            "patch": "@@ -23,12 +23,11 @@\n import numpy as np\n import torch\n import torch.distributed as dist\n+from huggingface_hub import file_exists\n from packaging import version\n from torch import nn\n from torch.nn import functional as F\n \n-from transformers.generation.candidate_generator import AssistantVocabTranslatorCache\n-\n from ..cache_utils import (\n     Cache,\n     DynamicCache,\n@@ -39,6 +38,12 @@\n     QuantizedCacheConfig,\n )\n from ..configuration_utils import PretrainedConfig\n+from ..dynamic_module_utils import (\n+    check_python_requirements,\n+    get_cached_module_file,\n+    get_class_in_module,\n+    resolve_trust_remote_code,\n+)\n from ..integrations.deepspeed import is_deepspeed_zero3_enabled\n from ..integrations.fsdp import is_fsdp_managed_module\n from ..modeling_outputs import CausalLMOutputWithPast, Seq2SeqLMOutput\n@@ -55,6 +60,7 @@\n from .beam_constraints import DisjunctiveConstraint, PhrasalConstraint\n from .beam_search import BeamScorer, BeamSearchScorer, ConstrainedBeamSearchScorer\n from .candidate_generator import (\n+    AssistantVocabTranslatorCache,\n     AssistedCandidateGenerator,\n     AssistedCandidateGeneratorDifferentTokenizers,\n     CandidateGenerator,\n@@ -376,6 +382,73 @@ class GenerationMixin:\n     To learn more about decoding strategies refer to the [text generation strategies guide](../generation_strategies).\n     \"\"\"\n \n+    def load_custom_generate(\n+        self,\n+        pretrained_model_name_or_path: Optional[Union[str, os.PathLike]] = None,\n+        trust_remote_code: Optional[bool] = None,\n+        **kwargs,\n+    ) -> Callable:\n+        \"\"\"\n+        Loads and returns a custom generate function, given a model repo.\n+\n+        Args:\n+            pretrained_model_name_or_path (`str` or `os.PathLike`):\n+                 Can be either:\n+                    - A string, the *model id* of a pretrained model hosted inside a model repo on huggingface.co.\n+                    - A path to a *directory* containing model weights saved using\n+                      [`~PreTrainedModel.save_pretrained`], e.g., `./my_model_directory/`.\n+            trust_remote_code (`bool`, *optional*):\n+                Whether or not to allow for custom models defined on the Hub in their own modeling files. This option\n+                should only be set to `True` for repositories you trust and in which you have read the code, as it will\n+                execute code present on the Hub on your local machine.\n+            **kwargs:\n+                Additional keyword arguments for remote code loading.\n+\n+        Raises:\n+            OSError: If `pretrained_model_name_or_path` does not contain a `custom_generate` subdirectory.\n+\n+        Returns:\n+            A callable that can be used to generate text.\n+        \"\"\"\n+        # Does `pretrained_model_name_or_path` have a `custom_generate` subdirectory? If not -> OSError\n+        is_local_code = os.path.exists(pretrained_model_name_or_path)\n+        has_custom_generate_folder = True\n+        if is_local_code:\n+            if not os.path.exists(os.path.join(pretrained_model_name_or_path, \"custom_generate/generate.py\")):\n+                has_custom_generate_folder = False\n+        else:\n+            if not file_exists(pretrained_model_name_or_path, \"custom_generate/generate.py\"):\n+                has_custom_generate_folder = False\n+\n+        if not has_custom_generate_folder:\n+            raise OSError(\n+                f\"`{pretrained_model_name_or_path}` does not contain a `custom_generate` subdirectory with a \"\n+                \"`generate.py` file, can't load the custom generate function.\"\n+            )\n+\n+        # Handle opt-in `trust_remote_code` and related exceptions\n+        error_message = (\n+            f\"The repository `{pretrained_model_name_or_path}` contains custom generation code that will override \"\n+            \"the default `generate` method.\"\n+        )\n+        resolve_trust_remote_code(\n+            trust_remote_code,\n+            pretrained_model_name_or_path,\n+            has_local_code=is_local_code,\n+            has_remote_code=not is_local_code,\n+            error_message=error_message,\n+        )\n+\n+        # Load the custom generate function\n+        check_python_requirements(\n+            pretrained_model_name_or_path, requirements_file=\"custom_generate/requirements.txt\", **kwargs\n+        )\n+        module = get_cached_module_file(\n+            pretrained_model_name_or_path, module_file=\"custom_generate/generate.py\", **kwargs\n+        )\n+        custom_generate_function = get_class_in_module(\"generate\", module)\n+        return custom_generate_function\n+\n     def _cache_dependant_input_preparation(\n         self,\n         input_ids: torch.LongTensor,\n@@ -2158,6 +2231,7 @@ def generate(\n         negative_prompt_ids: Optional[torch.Tensor] = None,\n         negative_prompt_attention_mask: Optional[torch.Tensor] = None,\n         use_model_defaults: Optional[bool] = None,\n+        custom_generate: Optional[str] = None,\n         **kwargs,\n     ) -> Union[GenerateOutput, torch.LongTensor]:\n         r\"\"\"\n@@ -2227,6 +2301,11 @@ def generate(\n                 generation configuration (`model.generation_config`), as opposed to the global defaults\n                 (`GenerationConfig()`). If unset, models saved starting from `v4.50` will consider this flag to be\n                 `True`.\n+            custom_generate (`str`, *optional*):\n+                A string containing the name of a huggingface.co repository. If provided, the custom `generate`\n+                function defined in that reposity's `custom_generate/generate.py` file will be executed instead of the\n+                standard `generate` method. Note that the logic is for generation is entirely defined in that\n+                repository, and the return type may be different from the standard `generate` method.\n             kwargs (`Dict[str, Any]`, *optional*):\n                 Ad hoc parametrization of `generation_config` and/or additional model-specific kwargs that will be\n                 forwarded to the `forward` function of the model. If the model is an encoder-decoder model, encoder\n@@ -2248,6 +2327,20 @@ def generate(\n                     - [`~generation.GenerateEncoderDecoderOutput`],\n                     - [`~generation.GenerateBeamEncoderDecoderOutput`]\n         \"\"\"\n+        # 0. If requested, load an arbitrary generation recipe from the Hub and run it instead\n+        if custom_generate is not None:\n+            trust_remote_code = kwargs.pop(\"trust_remote_code\", None)\n+            # Get all `generate` arguments in a single variable. Custom functions are responsible for handling them:\n+            # they receive the same inputs as `generate`, only with `model` instead of `self`. They can access to\n+            # methods from `GenerationMixin` through `model`.\n+            global_keys_to_exclude = {\"self\", \"kwargs\"}\n+            generate_arguments = {key: value for key, value in locals().items() if key not in global_keys_to_exclude}\n+            generate_arguments.update(kwargs)\n+\n+            custom_generate_function = self.load_custom_generate(\n+                custom_generate, trust_remote_code=trust_remote_code, **kwargs\n+            )\n+            return custom_generate_function(model=self, **generate_arguments)\n \n         # 1. Handle `generation_config` and kwargs that might update it, and validate the `.generate()` call\n         tokenizer = kwargs.pop(\"tokenizer\", None)  # Pull this out first, we only use it for stopping criteria"
        },
        {
            "sha": "7f9751ab57b40234876705755600771c575d18e6",
            "filename": "src/transformers/modeling_utils.py",
            "status": "modified",
            "additions": 24,
            "deletions": 10,
            "changes": 34,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e0e5c10441e807d55cc675900d3debf81834025/src%2Ftransformers%2Fmodeling_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e0e5c10441e807d55cc675900d3debf81834025/src%2Ftransformers%2Fmodeling_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodeling_utils.py?ref=0e0e5c10441e807d55cc675900d3debf81834025",
            "patch": "@@ -4104,6 +4104,7 @@ def from_pretrained(\n         gguf_file = kwargs.pop(\"gguf_file\", None)\n         tp_plan = kwargs.pop(\"tp_plan\", None)\n         tp_size = kwargs.pop(\"tp_size\", None)\n+        trust_remote_code = kwargs.pop(\"trust_remote_code\", None)\n \n         # Load models with hardcoded key mapping on class for VLMs only,  to keep BC and standardize model\n         if any(allowed_name in cls.__name__.lower() for allowed_name in VLMS):\n@@ -4113,7 +4114,6 @@ def from_pretrained(\n \n         # Not used anymore -- remove them from the kwargs\n         _ = kwargs.pop(\"resume_download\", None)\n-        _ = kwargs.pop(\"trust_remote_code\", None)\n         _ = kwargs.pop(\"mirror\", None)\n         _ = kwargs.pop(\"_fast_init\", True)\n         _ = kwargs.pop(\"low_cpu_mem_usage\", None)\n@@ -4591,30 +4591,44 @@ def _assign_original_dtype(module):\n         # Set model in evaluation mode to deactivate DropOut modules by default\n         model.eval()\n \n-        # If it is a model with generation capabilities, attempt to load the generation config\n+        # If it is a model with generation capabilities, attempt to load generation files (generation config,\n+        # custom generate function)\n         if model.can_generate() and generation_config is not None:\n             logger.info(\"The user-defined `generation_config` will be used to override the default generation config.\")\n             model.generation_config = model.generation_config.from_dict(generation_config.to_dict())\n         elif model.can_generate() and pretrained_model_name_or_path is not None:\n+            repo_loading_kwargs = {\n+                \"cache_dir\": cache_dir,\n+                \"force_download\": force_download,\n+                \"proxies\": proxies,\n+                \"local_files_only\": local_files_only,\n+                \"token\": token,\n+                \"revision\": revision,\n+                \"subfolder\": subfolder,\n+                **kwargs,\n+            }\n+            # Load generation config\n             try:\n                 model.generation_config = GenerationConfig.from_pretrained(\n                     pretrained_model_name_or_path,\n-                    cache_dir=cache_dir,\n-                    force_download=force_download,\n-                    proxies=proxies,\n-                    local_files_only=local_files_only,\n-                    token=token,\n-                    revision=revision,\n-                    subfolder=subfolder,\n                     _from_auto=from_auto_class,\n                     _from_pipeline=from_pipeline,\n-                    **kwargs,\n+                    **repo_loading_kwargs,\n                 )\n             except OSError:\n                 logger.info(\n                     \"Generation config file not found, using a generation config created from the model config.\"\n                 )\n                 pass\n+            # Load custom generate function if `pretrained_model_name_or_path` defines it (and override `generate`)\n+            if hasattr(model, \"load_custom_generate\"):\n+                try:\n+                    custom_generate = model.load_custom_generate(\n+                        pretrained_model_name_or_path, trust_remote_code=trust_remote_code, **repo_loading_kwargs\n+                    )\n+                    model.generate = functools.partial(custom_generate, model=model)\n+                except OSError:  # there is no custom generate function\n+                    pass\n \n         # Dispatch model with hooks on all devices if necessary (not needed with a tp_plan, so we skip it as it slightly\n         # harm performances)"
        },
        {
            "sha": "3b4ead5013402ffc0d308c8ae3b4fcb23cc33cfe",
            "filename": "src/transformers/models/auto/auto_factory.py",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e0e5c10441e807d55cc675900d3debf81834025/src%2Ftransformers%2Fmodels%2Fauto%2Fauto_factory.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e0e5c10441e807d55cc675900d3debf81834025/src%2Ftransformers%2Fmodels%2Fauto%2Fauto_factory.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fauto_factory.py?ref=0e0e5c10441e807d55cc675900d3debf81834025",
            "patch": "@@ -452,7 +452,7 @@ def _prepare_config_for_auto_class(cls, config: PretrainedConfig) -> PretrainedC\n     @classmethod\n     def from_pretrained(cls, pretrained_model_name_or_path, *model_args, **kwargs):\n         config = kwargs.pop(\"config\", None)\n-        trust_remote_code = kwargs.pop(\"trust_remote_code\", None)\n+        trust_remote_code = kwargs.get(\"trust_remote_code\", None)\n         kwargs[\"_from_auto\"] = True\n         hub_kwargs_names = [\n             \"cache_dir\",\n@@ -531,7 +531,6 @@ def from_pretrained(cls, pretrained_model_name_or_path, *model_args, **kwargs):\n             config, kwargs = AutoConfig.from_pretrained(\n                 pretrained_model_name_or_path,\n                 return_unused_kwargs=True,\n-                trust_remote_code=trust_remote_code,\n                 code_revision=code_revision,\n                 _commit_hash=commit_hash,\n                 **hub_kwargs,\n@@ -549,6 +548,7 @@ def from_pretrained(cls, pretrained_model_name_or_path, *model_args, **kwargs):\n         trust_remote_code = resolve_trust_remote_code(\n             trust_remote_code, pretrained_model_name_or_path, has_local_code, has_remote_code\n         )\n+        kwargs[\"trust_remote_code\"] = trust_remote_code\n \n         # Set the adapter kwargs\n         kwargs[\"adapter_kwargs\"] = adapter_kwargs\n@@ -730,13 +730,13 @@ def add_generation_mixin_to_remote_model(model_class):\n \n     # 3. Prior to v4.45, we could detect whether a model was `generate`-compatible if it had its own `generate` and/or\n     # `prepare_inputs_for_generation` method.\n-    has_custom_generate = hasattr(model_class, \"generate\") and \"GenerationMixin\" not in str(\n+    has_custom_generate_in_class = hasattr(model_class, \"generate\") and \"GenerationMixin\" not in str(\n         getattr(model_class, \"generate\")\n     )\n     has_custom_prepare_inputs = hasattr(model_class, \"prepare_inputs_for_generation\") and \"GenerationMixin\" not in str(\n         getattr(model_class, \"prepare_inputs_for_generation\")\n     )\n-    if has_custom_generate or has_custom_prepare_inputs:\n+    if has_custom_generate_in_class or has_custom_prepare_inputs:\n         model_class_with_generation_mixin = type(\n             model_class.__name__, (model_class, GenerationMixin), {**model_class.__dict__}\n         )"
        },
        {
            "sha": "bd673d796a629f8450e90f26bfb14b96de28059b",
            "filename": "tests/generation/test_utils.py",
            "status": "modified",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/huggingface/transformers/blob/0e0e5c10441e807d55cc675900d3debf81834025/tests%2Fgeneration%2Ftest_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/0e0e5c10441e807d55cc675900d3debf81834025/tests%2Fgeneration%2Ftest_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_utils.py?ref=0e0e5c10441e807d55cc675900d3debf81834025",
            "patch": "@@ -4954,6 +4954,68 @@ def test_cpu_offload_doesnt_compile(self):\n         _ = model_cpu.generate(input_ids, **generate_kwargs)\n         self.assertFalse(hasattr(model_cpu, \"_compiled_call\"))\n \n+    def test_custom_generate_from_argument_in_generate(self):\n+        \"\"\"Tests that the `custom_generate` argument is used when passed to `generate`\"\"\"\n+        model = AutoModelForCausalLM.from_pretrained(\n+            \"hf-internal-testing/tiny-random-MistralForCausalLM\", device_map=\"auto\"\n+        )\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-MistralForCausalLM\")\n+        model_inputs = tokenizer(\"Hello, world!\", return_tensors=\"pt\").to(model.device)\n+        # Note: `transformers-community/custom_generate_example` has a custom decoding method with a `left_padding`\n+        # argument (int), which prepends as many pad tokens.\n+        gen_out = model.generate(\n+            **model_inputs,\n+            left_padding=5,\n+            max_new_tokens=5,\n+            custom_generate=\"transformers-community/custom_generate_example\",\n+            trust_remote_code=True,\n+        )\n+        text_output = tokenizer.decode(gen_out[0])\n+        self.assertTrue(text_output.startswith(\"<unk><unk><unk><unk><unk>\"))  # <unk> is the pad token\n+\n+    def test_custom_generate_from_model_repo_with_custom_generate_code(self):\n+        \"\"\"\n+        Tests that models from model repos containing custom generation code override `generate` with the custom code\n+        \"\"\"\n+        model = AutoModelForCausalLM.from_pretrained(\n+            \"transformers-community/custom_generate_example\", device_map=\"auto\", trust_remote_code=True\n+        )\n+        generate_signature = inspect.signature(model.generate)\n+        # `left_padding` is a custom argument, doesn't exist in the base `generate` method\n+        self.assertTrue(generate_signature.parameters.get(\"left_padding\"))\n+\n+    def test_custom_generate_bad_requirements(self):\n+        \"\"\"Tests that we check the `requirements.txt` file from custom generation repos\"\"\"\n+        model = AutoModelForCausalLM.from_pretrained(\n+            \"hf-internal-testing/tiny-random-MistralForCausalLM\", device_map=\"auto\"\n+        )\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-MistralForCausalLM\")\n+        model_inputs = tokenizer(\"Hello, world!\", return_tensors=\"pt\").to(model.device)\n+        with self.assertRaises(ImportError):\n+            # Note: `transformers-community/custom_generate_bad_requirements` has a `requirements.txt` with\n+            # impossible requirements\n+            model.generate(\n+                **model_inputs,\n+                custom_generate=\"transformers-community/custom_generate_bad_requirements\",\n+                trust_remote_code=True,\n+            )\n+\n+    def test_custom_generate_requires_trust_remote_code(self):\n+        \"\"\"Tests that `trust_remote_code` is required when using `custom_generate`\"\"\"\n+        # Case 1: A model from a repo containing custom generation code must be loaded with `trust_remote_code`\n+        with self.assertRaises(ValueError):\n+            AutoModelForCausalLM.from_pretrained(\"transformers-community/custom_generate_example\", device_map=\"auto\")\n+\n+        # Case 2: Using the `custom_generate` argument in `generate` requires `trust_remote_code` if the code is not\n+        # local\n+        model = AutoModelForCausalLM.from_pretrained(\n+            \"hf-internal-testing/tiny-random-MistralForCausalLM\", device_map=\"auto\"\n+        )\n+        tokenizer = AutoTokenizer.from_pretrained(\"hf-internal-testing/tiny-random-MistralForCausalLM\")\n+        model_inputs = tokenizer(\"Hello, world!\", return_tensors=\"pt\").to(model.device)\n+        with self.assertRaises(ValueError):\n+            model.generate(**model_inputs, custom_generate=\"transformers-community/custom_generate_example\")\n+\n \n @require_torch\n class TokenHealingTestCase(unittest.TestCase):"
        }
    ],
    "stats": {
        "total": 619,
        "additions": 522,
        "deletions": 97
    }
}