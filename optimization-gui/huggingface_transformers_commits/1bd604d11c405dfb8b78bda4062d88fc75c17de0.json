{
    "author": "tomlimi",
    "message": "[WIP] Add Tokenizer for MyT5 Model (#31286)\n\n* Initial commit for MyT5 model\r\n\r\n* custom implementation of MyT5 tokenizer, unused files deleted\r\n\r\n* unittest for myt5 tokenizer\r\n\r\n* upadate of import structure and style\r\n\r\n* removed remmanents of MyT5Config\r\n\r\n* fixed docstrings\r\n\r\n* Updates after review: filled documentaion file, new docstrings and tests added\r\n\r\n* Fixed code style issues\r\n\r\n* fixed copied from to refer to function\r\n\r\n* updated loading myt5 tokenizer in tests, added sample byte map file to fixtures\r\n\r\n* changes after review\r\n\r\n* removed redundant copied from\r\n\r\n* removed redundant copied from\r\n\r\n* optimalization and loading model from hf\r\n\r\n* [run_slow] myt5\r\n\r\n* [run-slow] myt5\r\n\r\n* Updated en documentation for myt5\r\n\r\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>\r\n\r\n---------\r\n\r\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>",
    "sha": "1bd604d11c405dfb8b78bda4062d88fc75c17de0",
    "files": [
        {
            "sha": "7d72e234ab3a352490ae7f693c8b41803efec0aa",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/1bd604d11c405dfb8b78bda4062d88fc75c17de0/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/1bd604d11c405dfb8b78bda4062d88fc75c17de0/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=1bd604d11c405dfb8b78bda4062d88fc75c17de0",
            "patch": "@@ -494,6 +494,8 @@\n         title: MT5\n       - local: model_doc/mvp\n         title: MVP\n+      - local: model_doc/myt5\n+        title: myt5\n       - local: model_doc/nemotron\n         title: Nemotron\n       - local: model_doc/nezha"
        },
        {
            "sha": "c8b46f43512b6edcee329b1d4537e26802cebb2a",
            "filename": "docs/source/en/model_doc/myt5.md",
            "status": "added",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/huggingface/transformers/blob/1bd604d11c405dfb8b78bda4062d88fc75c17de0/docs%2Fsource%2Fen%2Fmodel_doc%2Fmyt5.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/1bd604d11c405dfb8b78bda4062d88fc75c17de0/docs%2Fsource%2Fen%2Fmodel_doc%2Fmyt5.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fmyt5.md?ref=1bd604d11c405dfb8b78bda4062d88fc75c17de0",
            "patch": "@@ -0,0 +1,46 @@\n+<!--Copyright 2024 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# myt5\n+\n+## Overview\n+\n+The myt5 model was proposed in [MYTE: Morphology-Driven Byte Encoding for Better and Fairer Multilingual Language Modeling](https://arxiv.org/pdf/2403.10691.pdf) by Tomasz Limisiewicz, Terra Blevins, Hila Gonen, Orevaoghene Ahia, and Luke Zettlemoyer.\n+MyT5 (**My**te **T5**) is a multilingual language model based on T5 architecture.\n+The model uses a **m**orphologically-driven **byte** (**MYTE**) representation described in our paper.\n+**MYTE** uses codepoints corresponding to morphemes in contrast to characters used in UTF-8 encoding.\n+As a pre-requisite, we used unsupervised morphological segmentation ([Morfessor](https://aclanthology.org/E14-2006.pdf)) to obtain morpheme inventories for 99 languages.\n+However, the morphological segmentation step is not needed when using the pre-defined morpheme inventory from the hub (see: [Tomli/myt5-base](https://huggingface.co/Tomlim/myt5-base)).\n+\n+The abstract from the paper is the following:\n+\n+*A major consideration in multilingual language modeling is how to best represent languages with diverse vocabularies and scripts. Although contemporary text encoding methods cover most of the world’s writing systems, they exhibit bias towards the high-resource languages of the Global West. As a result, texts of underrepresented languages tend to be segmented into long sequences of linguistically meaningless units. To address the disparities, we introduce a new paradigm that encodes the same information with segments of consistent size across diverse languages. Our encoding convention (MYTE) is based on morphemes, as their inventories are more balanced across languages than characters, which are used in previous methods. We show that MYTE produces shorter encodings for all 99 analyzed languages, with the most notable improvements for non-European languages and non-Latin scripts. This, in turn, improves multilingual LM performance and diminishes the perplexity gap throughout diverse languages.*\n+\n+This model was contributed by [Tomasz Limisiewicz](https://huggingface.co/Tomlim).\n+The original code can be found [here](https://github.com/tomlimi/MYTE).\n+\n+## MyT5Tokenizer\n+\n+[[autodoc]] MyT5Tokenizer\n+    - build_inputs_with_special_tokens\n+    - get_special_tokens_mask\n+    - create_token_type_ids_from_sequences\n+    - save_vocabulary\n+\n+## MyT5Tokenizer\n+\n+[[autodoc]] MyT5Tokenizer\n+"
        },
        {
            "sha": "e4382e04c37b292ebfeb4c2e1fe290209255576f",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=1bd604d11c405dfb8b78bda4062d88fc75c17de0",
            "patch": "@@ -607,6 +607,7 @@\n         \"MusicgenMelodyDecoderConfig\",\n     ],\n     \"models.mvp\": [\"MvpConfig\", \"MvpTokenizer\"],\n+    \"models.myt5\": [\"MyT5Tokenizer\"],\n     \"models.nemotron\": [\"NemotronConfig\"],\n     \"models.nllb\": [],\n     \"models.nllb_moe\": [\"NllbMoeConfig\"],\n@@ -5457,6 +5458,7 @@\n         MusicgenMelodyDecoderConfig,\n     )\n     from .models.mvp import MvpConfig, MvpTokenizer\n+    from .models.myt5 import MyT5Tokenizer\n     from .models.nemotron import NemotronConfig\n     from .models.nllb_moe import NllbMoeConfig\n     from .models.nougat import NougatProcessor"
        },
        {
            "sha": "804957c0a551ae69df6544ad7983bde26b3b15d3",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=1bd604d11c405dfb8b78bda4062d88fc75c17de0",
            "patch": "@@ -168,6 +168,7 @@\n     musicgen,\n     musicgen_melody,\n     mvp,\n+    myt5,\n     nemotron,\n     nllb,\n     nllb_moe,"
        },
        {
            "sha": "17219570684d53a4b496422f2c22eb32bea3cb9f",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=1bd604d11c405dfb8b78bda4062d88fc75c17de0",
            "patch": "@@ -497,6 +497,7 @@\n         (\"musicgen\", \"MusicGen\"),\n         (\"musicgen_melody\", \"MusicGen Melody\"),\n         (\"mvp\", \"MVP\"),\n+        (\"myt5\", \"myt5\"),\n         (\"nat\", \"NAT\"),\n         (\"nemotron\", \"Nemotron\"),\n         (\"nezha\", \"Nezha\"),"
        },
        {
            "sha": "8c3a7a82a60a51906314ccbc786d7594f9d24073",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=1bd604d11c405dfb8b78bda4062d88fc75c17de0",
            "patch": "@@ -322,6 +322,7 @@\n             (\"musicgen\", (\"T5Tokenizer\", \"T5TokenizerFast\" if is_tokenizers_available() else None)),\n             (\"musicgen_melody\", (\"T5Tokenizer\", \"T5TokenizerFast\" if is_tokenizers_available() else None)),\n             (\"mvp\", (\"MvpTokenizer\", \"MvpTokenizerFast\" if is_tokenizers_available() else None)),\n+            (\"myt5\", (\"MyT5Tokenizer\", None)),\n             (\"nezha\", (\"BertTokenizer\", \"BertTokenizerFast\" if is_tokenizers_available() else None)),\n             (\n                 \"nllb\","
        },
        {
            "sha": "9579f723a00ef3152a24232e268a8a7f49ee18c2",
            "filename": "src/transformers/models/myt5/__init__.py",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/huggingface/transformers/blob/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2Fmodels%2Fmyt5%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2Fmodels%2Fmyt5%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmyt5%2F__init__.py?ref=1bd604d11c405dfb8b78bda4062d88fc75c17de0",
            "patch": "@@ -0,0 +1,29 @@\n+# Copyright 2024 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+\n+\n+_import_structure = {\"tokenization_myt5\": [\"MyT5Tokenizer\"]}\n+\n+\n+if TYPE_CHECKING:\n+    from .tokenization_myt5 import MyT5Tokenizer\n+\n+else:\n+    import sys\n+\n+    sys.modules[__name__] = _LazyModule(__name__, globals()[\"__file__\"], _import_structure, module_spec=__spec__)"
        },
        {
            "sha": "39653e4b1c77d0383e11645c4763b3ef53e9d851",
            "filename": "src/transformers/models/myt5/convert_myt5_original_tf_checkpoint_to_pytorch.py",
            "status": "added",
            "additions": 60,
            "deletions": 0,
            "changes": 60,
            "blob_url": "https://github.com/huggingface/transformers/blob/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2Fmodels%2Fmyt5%2Fconvert_myt5_original_tf_checkpoint_to_pytorch.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2Fmodels%2Fmyt5%2Fconvert_myt5_original_tf_checkpoint_to_pytorch.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmyt5%2Fconvert_myt5_original_tf_checkpoint_to_pytorch.py?ref=1bd604d11c405dfb8b78bda4062d88fc75c17de0",
            "patch": "@@ -0,0 +1,60 @@\n+# coding=utf-8\n+# Copyright 2024 The MyT5 authors and HuggingFace Inc. team.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Convert MyT5 checkpoint.\"\"\"\n+\n+import argparse\n+\n+from transformers import T5Config, T5ForConditionalGeneration, load_tf_weights_in_t5\n+from transformers.utils import logging\n+\n+\n+logging.set_verbosity_info()\n+\n+\n+# Copied from transformers.models.t5.convert_t5_original_tf_checkpoint_to_pytorch.convert_tf_checkpoint_to_pytorch\n+def convert_tf_checkpoint_to_pytorch(tf_checkpoint_path, config_file, pytorch_dump_path):\n+    # Initialise PyTorch model\n+    config = T5Config.from_json_file(config_file)\n+    print(f\"Building PyTorch model from configuration: {config}\")\n+    model = T5ForConditionalGeneration(config)\n+\n+    # Load weights from tf checkpoint\n+    load_tf_weights_in_t5(model, config, tf_checkpoint_path)\n+\n+    # Save pytorch-model\n+    print(f\"Save PyTorch model to {pytorch_dump_path}\")\n+    model.save_pretrained(pytorch_dump_path)\n+\n+\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser()\n+    # Required parameters\n+    parser.add_argument(\n+        \"--tf_checkpoint_path\", default=None, type=str, required=True, help=\"Path to the TensorFlow checkpoint path.\"\n+    )\n+    parser.add_argument(\n+        \"--config_file\",\n+        default=None,\n+        type=str,\n+        required=True,\n+        help=(\n+            \"The config json file corresponding to the pre-trained MyT5 model. \\nThis specifies the model architecture.\"\n+        ),\n+    )\n+    parser.add_argument(\n+        \"--pytorch_dump_path\", default=None, type=str, required=True, help=\"Path to the output PyTorch model.\"\n+    )\n+    args = parser.parse_args()\n+    convert_tf_checkpoint_to_pytorch(args.tf_checkpoint_path, args.config_file, args.pytorch_dump_path)"
        },
        {
            "sha": "69cb14b0cc9d022f152c192655e8902ef2f3188c",
            "filename": "src/transformers/models/myt5/tokenization_myt5.py",
            "status": "added",
            "additions": 377,
            "deletions": 0,
            "changes": 377,
            "blob_url": "https://github.com/huggingface/transformers/blob/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2Fmodels%2Fmyt5%2Ftokenization_myt5.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/1bd604d11c405dfb8b78bda4062d88fc75c17de0/src%2Ftransformers%2Fmodels%2Fmyt5%2Ftokenization_myt5.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fmyt5%2Ftokenization_myt5.py?ref=1bd604d11c405dfb8b78bda4062d88fc75c17de0",
            "patch": "@@ -0,0 +1,377 @@\n+# coding=utf-8\n+# Copyright 2024\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Tokenization class for model MyT5.\"\"\"\n+\n+import json\n+import os\n+import warnings\n+from collections import defaultdict\n+from typing import Dict, List, Optional, Tuple, Union\n+\n+from ...tokenization_utils import AddedToken, PreTrainedTokenizer\n+from ...utils import logging\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+VOCAB_FILES_NAMES = {\"vocab_file\": \"byte_maps.json\"}\n+\n+\n+class ByteRewriter:\n+    \"\"\"\n+    Byte rewriter class for MyT5 tokenizer.\n+    This class is used to rewrite bytes using a hash tree. The hash tree is constructed from a set of rewriting rules.\n+\n+    Args:\n+        rewriting_rules (`str` or `Dict[str, str]`):\n+            A path to a json file containing the rewriting rules or a dictionary containing the rewriting rules.\n+\n+    \"\"\"\n+\n+    LEAF = \"[LEAF]\"\n+\n+    def __init__(self, rewriting_rules: Union[str, Dict[str, str]]):\n+        if isinstance(rewriting_rules, str):\n+            with open(rewriting_rules, \"r\") as f:\n+                rewriting_rules = json.load(f)\n+        elif not isinstance(rewriting_rules, dict):\n+            raise ValueError(\n+                f\"rewriting_rules should be either a path to json file or a dict, got {type(rewriting_rules)}\"\n+            )\n+\n+        self.hash_tree = self.construct_hash_tree(rewriting_rules)\n+        reverse_rewriting_rules = {v: k for k, v in rewriting_rules.items()}\n+        self.reverse_hash_tree = self.construct_hash_tree(reverse_rewriting_rules)\n+\n+    def add_leaf(self, hash_tree: Dict[str, Union[dict, List[str]]], byte_in_sequence: str, byte_out_sequence: str):\n+        \"\"\"\n+        Add a leaf with the output byte sequence to the hash tree.\n+        \"\"\"\n+        byte_in_list = byte_in_sequence.split(\" \")\n+        byte_out_list = byte_out_sequence.split(\" \")\n+\n+        tree_pointer = hash_tree\n+        for b in byte_in_list:\n+            if b not in tree_pointer:\n+                tree_pointer[b] = {}\n+            tree_pointer = tree_pointer[b]\n+\n+        tree_pointer[self.LEAF] = byte_out_list\n+\n+    def construct_hash_tree(self, rewriting_rules: Dict[str, str]) -> Dict[str, Union[dict, List[str]]]:\n+        \"\"\"\n+        Construct a hash tree for rewritten byte sequences.\n+        \"\"\"\n+        hash_tree = defaultdict(dict)\n+        for b in (f\"{x:02x}\" for x in range(256)):\n+            hash_tree[b][self.LEAF] = [b]\n+\n+        for in_sequence, out_sequence in rewriting_rules.items():\n+            self.add_leaf(hash_tree, in_sequence, out_sequence)\n+\n+        return hash_tree\n+\n+    def search_hash_tree(self, byte_sequence: List[str]) -> Union[None, List[str]]:\n+        \"\"\"\n+        Search the hash tree and return the rewritten byte sequence if found.\n+        \"\"\"\n+        tree_pointer = self.hash_tree\n+        for b in byte_sequence:\n+            if b in tree_pointer:\n+                tree_pointer = tree_pointer[b]\n+            else:\n+                return None\n+\n+        return tree_pointer[self.LEAF]\n+\n+    def rewrite_bytes(self, in_bytes: List[str], reverse=False) -> List[str]:\n+        \"\"\"\n+        Rewrite a sequence of bytes using the hash tree.\n+\n+        Args:\n+            in_bytes (`List[str]`): A list of bytes to be rewritten.\n+            reverse (`bool`): If True, decoding is performed with the reverse hash tree.\n+        Returns:\n+            `List[str]`: The rewritten byte sequence.\n+        \"\"\"\n+        out_bytes = []\n+        b_start = 0\n+        b_end = 0\n+\n+        while b_start < len(in_bytes):\n+            tree_pointer = self.hash_tree if not reverse else self.reverse_hash_tree\n+            for j in range(b_start, len(in_bytes)):\n+                b = in_bytes[j]\n+                if b in tree_pointer:\n+                    tree_pointer = tree_pointer[b]\n+                elif j == b_start:\n+                    cur_leaf = [b]\n+                    b_end = j\n+                    break\n+                else:\n+                    break\n+                if self.LEAF in tree_pointer:\n+                    cur_leaf = tree_pointer[self.LEAF]\n+                    b_end = j\n+            out_bytes.extend(cur_leaf)\n+            b_start = b_end + 1\n+\n+        return out_bytes\n+\n+\n+class MyT5Tokenizer(PreTrainedTokenizer):\n+    \"\"\"\n+    Construct a MyT5 tokenizer.\n+\n+    This tokenizer inherits from [`PreTrainedTokenizer`] which contains most of the main methods. Users should refer to\n+    this superclass for more information regarding those methods.\n+\n+    Args:\n+        vocab_file (`str`): The file containing the byte rewriting rules.\n+        eos_token (`str`, *optional*, defaults to `\"</s>\"`):\n+            The end of sequence token.\n+\n+        unk_token (`str`, *optional*, defaults to `\"<unk>\"`):\n+            The unknown token. A token that is not in the vocabulary cannot be converted to an ID and is set to be this\n+            token instead.\n+        pad_token (`str`, *optional*, defaults to `\"<pad>\"`):\n+            The token used for padding, for example when batching sequences of different lengths.\n+        extra_ids (`int`, *optional*, defaults to 125):\n+            Add a number of extra ids added to the end of the vocabulary for use as sentinels. These tokens are\n+            accessible as \"<extra_id_{%d}>\" where \"{%d}\" is a number between 0 and extra_ids-1. Extra tokens are\n+            indexed from the end of the vocabulary up to beginning (\"<extra_id_0>\" is the last token in the vocabulary\n+            like in ByT5 preprocessing see\n+            [here](https://github.com/google-research/text-to-text-transfer-transformer/blob/9fd7b14a769417be33bc6c850f9598764913c833/t5/data/preprocessors.py#L2117)).\n+        additional_special_tokens (`List[str]`, *optional*):\n+            Additional special tokens used by the tokenizer.\n+    \"\"\"\n+\n+    model_input_names = [\"input_ids\", \"attention_mask\"]\n+    vocab_files_names = VOCAB_FILES_NAMES\n+\n+    def __init__(\n+        self,\n+        vocab_file,\n+        eos_token=\"</s>\",\n+        unk_token=\"<unk>\",\n+        pad_token=\"<pad>\",\n+        extra_ids=125,\n+        additional_special_tokens=None,\n+        **kwargs,\n+    ) -> None:\n+        # Add extra_ids to the special token list\n+        if extra_ids > 0 and additional_special_tokens is None:\n+            additional_special_tokens = [f\"<extra_id_{i}>\" for i in range(extra_ids)]\n+        elif extra_ids > 0 and additional_special_tokens is not None and len(additional_special_tokens) > 0:\n+            # Check that we have the right number of extra_id special tokens\n+            extra_tokens = len(set(filter(lambda x: bool(\"extra_id\" in str(x)), additional_special_tokens)))\n+            if extra_tokens != extra_ids:\n+                raise ValueError(\n+                    f\"Both extra_ids ({extra_ids}) and additional_special_tokens ({additional_special_tokens}) are\"\n+                    \" provided to MyT5Tokenizer. In this case the additional_special_tokens must include the\"\n+                    \" extra_ids tokens\"\n+                )\n+\n+        pad_token = AddedToken(pad_token, lstrip=True, rstrip=True) if isinstance(pad_token, str) else pad_token\n+        eos_token = AddedToken(eos_token, lstrip=True, rstrip=True) if isinstance(eos_token, str) else eos_token\n+        unk_token = AddedToken(unk_token, lstrip=True, rstrip=True) if isinstance(unk_token, str) else unk_token\n+        # unk token needs to be in the vocab with correct index\n+        self._added_tokens_decoder = {0: pad_token, 1: eos_token, 2: unk_token}\n+        self.offset = len(self._added_tokens_decoder)\n+        self._utf_vocab_size = 2**8  # utf is 8 bits\n+\n+        # Load byte maps\n+        self.byte_maps = json.load(open(vocab_file, \"r\"))\n+\n+        self.decompose_rewriter = ByteRewriter(self.byte_maps[\"decompose_map\"])\n+        self.merge_rewriter = ByteRewriter(self.byte_maps[\"merge_map\"])\n+\n+        super().__init__(\n+            eos_token=eos_token,\n+            unk_token=unk_token,\n+            pad_token=pad_token,\n+            extra_ids=0,\n+            additional_special_tokens=additional_special_tokens,\n+            **kwargs,\n+        )\n+\n+    @property\n+    def vocab_size(self):\n+        return self._utf_vocab_size\n+\n+    # Copied from transformers.models.byt5.tokenization_byt5.ByT5Tokenizer.get_vocab\n+    def get_vocab(self):\n+        vocab = {self.convert_ids_to_tokens(i): i for i in range(self.vocab_size + self.offset)}\n+        vocab.update(self.added_tokens_encoder)\n+        return vocab\n+\n+    # Copied from transformers.models.byt5.tokenization_byt5.ByT5Tokenizer.get_special_tokens_mask\n+    def get_special_tokens_mask(\n+        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None, already_has_special_tokens: bool = False\n+    ) -> List[int]:\n+        \"\"\"\n+        Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding\n+        special tokens using the tokenizer `prepare_for_model` method.\n+\n+        Args:\n+            token_ids_0 (`List[int]`):\n+                List of IDs.\n+            token_ids_1 (`List[int]`, *optional*):\n+                Optional second list of IDs for sequence pairs.\n+            already_has_special_tokens (`bool`, *optional*, defaults to `False`):\n+                Whether or not the token list is already formatted with special tokens for the model.\n+\n+        Returns:\n+            `List[int]`: A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.\n+        \"\"\"\n+        if already_has_special_tokens:\n+            return super().get_special_tokens_mask(\n+                token_ids_0=token_ids_0, token_ids_1=token_ids_1, already_has_special_tokens=True\n+            )\n+\n+        # normal case: some special tokens\n+        if token_ids_1 is None:\n+            return ([0] * len(token_ids_0)) + [1]\n+        return ([0] * len(token_ids_0)) + [1] + ([0] * len(token_ids_1)) + [1]\n+\n+    def _add_eos_if_not_present(self, token_ids: List[int]) -> List[int]:\n+        \"\"\"Do not add eos again if user already added it.\"\"\"\n+        if len(token_ids) > 0 and token_ids[-1] == self.eos_token_id:\n+            warnings.warn(\n+                f\"This sequence already has {self.eos_token}. In future versions this behavior may lead to duplicated\"\n+                \" eos tokens being added.\"\n+            )\n+            return token_ids\n+        else:\n+            return token_ids + [self.eos_token_id]\n+\n+    def create_token_type_ids_from_sequences(\n+        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None\n+    ) -> List[int]:\n+        \"\"\"\n+        Create a mask from the two sequences passed to be used in a sequence-pair classification task. MyT5 does not\n+        make use of token type ids, therefore a list of zeros is returned.\n+\n+        Args:\n+            token_ids_0 (`List[int]`):\n+                List of IDs.\n+            token_ids_1 (`List[int]`, *optional*):\n+                Optional second list of IDs for sequence pairs.\n+\n+        Returns:\n+            `List[int]`: List of zeros.\n+        \"\"\"\n+        eos = [self.eos_token_id]\n+\n+        if token_ids_1 is None:\n+            return len(token_ids_0 + eos) * [0]\n+        return len(token_ids_0 + eos + token_ids_1 + eos) * [0]\n+\n+    # Copied from transformers.models.byt5.tokenization_byt5.ByT5Tokenizer.build_inputs_with_special_tokens\n+    def build_inputs_with_special_tokens(\n+        self, token_ids_0: List[int], token_ids_1: Optional[List[int]] = None\n+    ) -> List[int]:\n+        \"\"\"\n+        Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and\n+        adding special tokens. A sequence has the following format:\n+\n+        - single sequence: `X </s>`\n+        - pair of sequences: `A </s> B </s>`\n+\n+        Args:\n+            token_ids_0 (`List[int]`):\n+                List of IDs to which the special tokens will be added.\n+            token_ids_1 (`List[int]`, *optional*):\n+                Optional second list of IDs for sequence pairs.\n+\n+        Returns:\n+            `List[int]`: List of [input IDs](../glossary#input-ids) with the appropriate special tokens.\n+        \"\"\"\n+        token_ids_0 = self._add_eos_if_not_present(token_ids_0)\n+        if token_ids_1 is None:\n+            return token_ids_0\n+        else:\n+            token_ids_1 = self._add_eos_if_not_present(token_ids_1)\n+            return token_ids_0 + token_ids_1\n+\n+    def _tokenize(self, text: str, **kwargs) -> List[str]:\n+        \"\"\"Take as input a string and return a list of strings (tokens) for words/sub-words.\n+        Represents tokens in two character hex format\"\"\"\n+\n+        tokens = [f\"{i:02x}\" for i in text.encode(\"utf-8\")]\n+        tokens = self.morphological_encode(tokens)\n+        return tokens\n+\n+    def _convert_token_to_id(self, token):\n+        \"\"\"Converts a token (str) in an id using the vocab.\"\"\"\n+\n+        if len(token) != 2:\n+            token_id = None\n+        else:\n+            token_id = int(token, 16) + self.offset\n+\n+        return token_id\n+\n+    def _convert_id_to_token(self, index):\n+        \"\"\"Converts an index (integer) in a token (str) using the vocab.\"\"\"\n+        token = f\"{index - self.offset:02x}\"\n+        return token\n+\n+    def morphological_encode(self, indices: List[str]) -> List[str]:\n+        # Decompose and merge morphological sequences\n+        indices = self.decompose_rewriter.rewrite_bytes(indices, reverse=False)\n+        indices = self.merge_rewriter.rewrite_bytes(indices, reverse=False)\n+        return indices\n+\n+    def morphological_decode(self, indices: List[str]) -> List[str]:\n+        # Demerge and compose morphological sequences\n+        indices = self.merge_rewriter.rewrite_bytes(indices, reverse=True)\n+        indices = self.decompose_rewriter.rewrite_bytes(indices, reverse=True)\n+        return indices\n+\n+    def convert_tokens_to_string(self, tokens):\n+        \"\"\"Converts a sequence of tokens (string) in a single string.\"\"\"\n+        bstring = b\"\"\n+\n+        out_tokens = []\n+        for token in tokens:\n+            if token in self.added_tokens_decoder:\n+                out_tokens.append(self.added_tokens_decoder[token])\n+            elif token in self.added_tokens_encoder:\n+                out_tokens.append(token)\n+            else:\n+                out_tokens.append(token)\n+\n+        out_tokens = self.morphological_decode(out_tokens)\n+        _added_tokens = set(self.added_tokens_decoder.values()) | set(self.added_tokens_encoder)\n+        for token in out_tokens:\n+            if token in _added_tokens:\n+                bstring += bytes(token, \"utf-8\")\n+            else:\n+                bstring += bytes.fromhex(token)\n+        string = bstring.decode(\"utf-8\", errors=\"ignore\")\n+        return string\n+\n+    def save_vocabulary(self, save_directory: str, filename_prefix: Optional[str] = None) -> Tuple[str]:\n+        if os.path.isdir(save_directory):\n+            vocab_file = os.path.join(\n+                save_directory, (filename_prefix + \"-\" if filename_prefix else \"\") + VOCAB_FILES_NAMES[\"vocab_file\"]\n+            )\n+        else:\n+            vocab_file = (filename_prefix + \"-\" if filename_prefix else \"\") + save_directory\n+        with open(vocab_file, \"w\", encoding=\"utf-8\") as writer:\n+            writer.write(json.dumps(self.byte_maps, indent=2, ensure_ascii=False))\n+        return (vocab_file,)"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/myt5/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/1bd604d11c405dfb8b78bda4062d88fc75c17de0/tests%2Fmodels%2Fmyt5%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/1bd604d11c405dfb8b78bda4062d88fc75c17de0/tests%2Fmodels%2Fmyt5%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmyt5%2F__init__.py?ref=1bd604d11c405dfb8b78bda4062d88fc75c17de0"
        },
        {
            "sha": "49e765ee3ea34f6645e06a715b85988a86f8de32",
            "filename": "tests/models/myt5/test_tokenization_myt5.py",
            "status": "added",
            "additions": 187,
            "deletions": 0,
            "changes": 187,
            "blob_url": "https://github.com/huggingface/transformers/blob/1bd604d11c405dfb8b78bda4062d88fc75c17de0/tests%2Fmodels%2Fmyt5%2Ftest_tokenization_myt5.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/1bd604d11c405dfb8b78bda4062d88fc75c17de0/tests%2Fmodels%2Fmyt5%2Ftest_tokenization_myt5.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fmyt5%2Ftest_tokenization_myt5.py?ref=1bd604d11c405dfb8b78bda4062d88fc75c17de0",
            "patch": "@@ -0,0 +1,187 @@\n+# coding=utf-8\n+# Copyright 2024\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import binascii\n+import unittest\n+\n+from transformers import MyT5Tokenizer\n+from transformers.utils import is_tf_available, is_torch_available\n+\n+from ...test_tokenization_common import TokenizerTesterMixin\n+\n+\n+if is_torch_available():\n+    FRAMEWORK = \"pt\"\n+elif is_tf_available():\n+    FRAMEWORK = \"tf\"\n+else:\n+    FRAMEWORK = \"jax\"\n+\n+\n+def bytes_to_hex(bline: bytes, sep: str = \" \") -> str:\n+    return str(binascii.hexlify(bline, sep), \"utf-8\")\n+\n+\n+def str_to_hex(line: str, sep: str = \" \") -> str:\n+    return bytes_to_hex(bytes(line, \"utf-8\"), sep)\n+\n+\n+class TestByteRewriter(unittest.TestCase):\n+    tokenizer = MyT5Tokenizer.from_pretrained(\"Tomlim/myt5-base\")\n+\n+    def test_simple_decompose(self):\n+        decompose_rewriter = self.tokenizer.decompose_rewriter\n+\n+        # test rewriting\n+        in_str = \"Hello WorlD\"\n+        out_str = \"hAello wAorldA\"\n+\n+        in_hex = str_to_hex(in_str).split(\" \")\n+        out_hex = str_to_hex(out_str).split(\" \")\n+\n+        self.assertEqual(decompose_rewriter.rewrite_bytes(in_hex), out_hex)\n+\n+    def test_simple_decompose_reversible(self):\n+        decompose_rewriter = self.tokenizer.decompose_rewriter\n+\n+        in_str = \"Hello WorlD\"\n+        out_str = \"Hello WorlD\"\n+\n+        in_hex = str_to_hex(in_str).split(\" \")\n+        out_hex = str_to_hex(out_str).split(\" \")\n+\n+        self.assertEqual(\n+            decompose_rewriter.rewrite_bytes(decompose_rewriter.rewrite_bytes(in_hex), reverse=True), out_hex\n+        )\n+\n+    def test_simple_decompose_non_latin(self):\n+        decompose_rewriter = self.tokenizer.decompose_rewriter\n+\n+        in_str = \"你好世界 Hello WorlD\"\n+        out_str = \"你好世界 hAello wAorldA\"\n+\n+        in_hex = str_to_hex(in_str).split(\" \")\n+        out_hex = str_to_hex(out_str).split(\" \")\n+\n+        self.assertEqual(decompose_rewriter.rewrite_bytes(in_hex), out_hex)\n+\n+    def test_unrecognized_byte(self):\n+        decompose_rewriter = self.tokenizer.decompose_rewriter\n+\n+        in_hex = [\"00\", \"01\", \"xx\", \"03\", \"61\"]\n+        out_hex = [\"00\", \"01\", \"xx\", \"03\", \"61\"]\n+\n+        self.assertEqual(decompose_rewriter.rewrite_bytes(in_hex), out_hex)\n+\n+\n+class MyT5TokenizationTest(TokenizerTesterMixin, unittest.TestCase):\n+    tokenizer_class = MyT5Tokenizer\n+    test_rust_tokenizer = False\n+\n+    def setUp(self):\n+        super().setUp()\n+\n+    def get_tokenizer(self, **kwargs) -> MyT5Tokenizer:\n+        return self.tokenizer_class.from_pretrained(\"Tomlim/myt5-base\", **kwargs)\n+\n+    @unittest.skip(reason=\"inputs cannot be pretokenized as ids depend on whole input string\")\n+    def test_pretokenized_inputs(self):\n+        pass\n+\n+    def test_convert_tokens_to_string_format(self):\n+        tokenizer = self.get_tokenizer()\n+        with self.subTest(f\"{tokenizer.__class__.__name__}\"):\n+            tokens = [\"52\", \"85\", \"91\", \"9f\", \"6f\", \"20\", \"52\", \"85\", \"9f\", \"90\", \"</s>\"]\n+            string = tokenizer.convert_tokens_to_string(tokens)\n+\n+            self.assertIsInstance(string, str)\n+\n+    def test_simple_tokenize(self):\n+        tokenizer = self.get_tokenizer()\n+\n+        in_str = \"Hello World\"\n+        out_tokens = [\"52\", \"85\", \"91\", \"9f\", \"6f\", \"20\", \"52\", \"85\", \"9f\", \"90\"]\n+\n+        self.assertEqual(tokenizer.tokenize(in_str), out_tokens)\n+\n+        in_pl_str = \"Witaj świecie\"\n+        out_tokens = [\"77\", \"41\", \"69\", \"74\", \"61\", \"6a\", \"20\", \"4b\", \"a5\", \"97\", \"63\", \"69\", \"65\"]\n+\n+        self.assertEqual(tokenizer.tokenize(in_pl_str), out_tokens)\n+\n+        in_jp_str = \"こんにちは世界\"\n+        out_tokens = [\"58\", \"80\", \"91\", \"a1\", \"e4\", \"b8\", \"96\", \"e7\", \"95\", \"8c\"]\n+\n+        self.assertEqual(tokenizer.tokenize(in_jp_str), out_tokens)\n+\n+    def test_batch_tokenize(self):\n+        tokenizer = self.get_tokenizer()\n+\n+        in_batch = [\"Hello World\", \"Witaj świecie\", \"こんにちは世界\"]\n+\n+        out_tokens = [\n+            [\"52\", \"85\", \"91\", \"9f\", \"6f\", \"20\", \"52\", \"85\", \"9f\", \"90\", \"</s>\"],\n+            [\"77\", \"41\", \"69\", \"74\", \"61\", \"6a\", \"20\", \"4b\", \"a5\", \"97\", \"63\", \"69\", \"65\", \"</s>\"],\n+            [\"58\", \"80\", \"91\", \"a1\", \"e4\", \"b8\", \"96\", \"e7\", \"95\", \"8c\", \"</s>\"],\n+        ]\n+\n+        self.assertListEqual(\n+            [tokenizer.convert_ids_to_tokens(ids) for ids in tokenizer(in_batch)[\"input_ids\"]], out_tokens\n+        )\n+\n+    def test_special_bytes(self):\n+        tokenizer = self.get_tokenizer()\n+\n+        in_str_special = \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\"\n+        out_tokens = [\"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\"]\n+\n+        self.assertEqual(tokenizer.tokenize(in_str_special), out_tokens)\n+\n+        in_str_mixed = \"\\x00Hello\\x01 World\\x02\"\n+        out_tokens = [\"00\", \"52\", \"85\", \"91\", \"9f\", \"6f\", \"01\", \"20\", \"52\", \"85\", \"9f\", \"90\", \"02\"]\n+\n+        self.assertEqual(tokenizer.tokenize(in_str_mixed), out_tokens)\n+\n+    def test_special_tokens(self):\n+        tokenizer = self.get_tokenizer()\n+\n+        in_str_special = \"<unk></s><pad>\"\n+        out_tokens = [\"<unk>\", \"</s>\", \"<pad>\"]\n+\n+        self.assertEqual(tokenizer.tokenize(in_str_special), out_tokens)\n+\n+        in_str_not_special = \"<s>\"\n+        out_tokens = [\"3c\", \"73\", \"3e\"]\n+\n+        self.assertEqual(tokenizer.tokenize(in_str_not_special), out_tokens)\n+\n+        in_str_mixed = \"<s>Hello World</s>\"\n+        out_tokens = [\"3c\", \"73\", \"3e\", \"52\", \"85\", \"91\", \"9f\", \"6f\", \"20\", \"52\", \"85\", \"9f\", \"90\", \"</s>\"]\n+\n+        self.assertEqual(tokenizer.tokenize(in_str_mixed), out_tokens)\n+\n+    def test_token_ids_conversion(self):\n+        tokenizer = self.get_tokenizer()\n+\n+        tokens_range = [f\"{x:02x}\" for x in range(256)]\n+        indices_range = list(range(3, 256 + 3))\n+\n+        self.assertListEqual(tokenizer.convert_tokens_to_ids(tokens_range), indices_range)\n+        self.assertListEqual(tokenizer.convert_ids_to_tokens(indices_range), tokens_range)\n+\n+        special_tokens = [\"<pad>\", \"</s>\", \"<unk>\"]\n+        special_indices = [0, 1, 2]\n+\n+        self.assertListEqual(tokenizer.convert_tokens_to_ids(special_tokens), special_indices)\n+        self.assertListEqual(tokenizer.convert_ids_to_tokens(special_indices), special_tokens)"
        }
    ],
    "stats": {
        "total": 706,
        "additions": 706,
        "deletions": 0
    }
}