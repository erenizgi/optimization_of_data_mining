{
    "author": "inf3rnus",
    "message": "Enhance Model Loading By Providing Parallelism, Uses Optional Env Flag (#36835)\n\n* Get parallel loader working. Include tests.\n\n* Update the tests for parallel loading\n\n* Rename env variables.\n\n* Add docs for parallel model weight loading.\n\n* Touch up parallel model loading docs.\n\n* Touch up parallel model loading docs again.\n\n* Edit comment in test_modeling_utils_parallel_loading.py\n\n* Make sure HF_PARALLEL_LOADING_WORKERS is spelled correctly in modeling_utils.py\n\n* Correct times for parallelized loading, previous times were for a \"hot\" filesystem\n\n* Update parallel model loading so the spawn method is encapsulated. DRY up the code by leveraging get_submodule.\n\n* Update docs on model loading parallelism so that details on setting the multiprocessing start method are removed, now that the package handles this step internally.\n\n* Fix style on model loading parallelism changes.\n\n* Merge latest version of master's modeling_utils.\n\n* Removed unused variable.\n\n* Fix argument packing for the parallel loader.\n\n* Fix state dict being undefined in the parallel model loader.\n\n* Rename variables used in parallel model loading for clarity. Use get_module_from_name().\n\n* Switch to the use of threads for parallel model loading.\n\n* Update docs for parallel loading.\n\n* Remove the use of json.loads when evaluating HF_ENABLE_PARALLEL_LOADING. Prefer simple casting.\n\n* Move parallelized shard loading into its own function.\n\n* Remove use of is_true(). Favor checking env var true values for HF_ENABLE_PARALLEL_LOADING.\n\n* Update copyright to 2025 in readme for paralell model loading.\n\n* Remove garbage collection line in load_shard_file, implicit garbage collection already occurs.\n\n* Run formatter on modeling_utils.py\n\n* Apply style fixes\n\n* Delete tests/utils/test_modeling_utils_parallel_loading.py\n\n---------\n\nCo-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>\nCo-authored-by: Cyril Vallez <cyril.vallez@huggingface.co>",
    "sha": "d5f992f5e67e8ced64a90fe01dfc50796fd2933d",
    "files": [
        {
            "sha": "9e03a234b771f3fc9e71e4c07c7af04e30eaf0b0",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/d5f992f5e67e8ced64a90fe01dfc50796fd2933d/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/d5f992f5e67e8ced64a90fe01dfc50796fd2933d/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=d5f992f5e67e8ced64a90fe01dfc50796fd2933d",
            "patch": "@@ -1121,4 +1121,9 @@\n     - local: internal/time_series_utils\n       title: Utilities for Time Series\n     title: Internal helpers\n+  - sections:\n+    - local: reference/environment_variables\n+      title: Environment Variables\n+    title: Reference\n   title: API\n+"
        },
        {
            "sha": "fc20c08f9e6a359e103cc285b7426e684fca08dd",
            "filename": "docs/source/en/reference/environment_variables.md",
            "status": "added",
            "additions": 58,
            "deletions": 0,
            "changes": 58,
            "blob_url": "https://github.com/huggingface/transformers/blob/d5f992f5e67e8ced64a90fe01dfc50796fd2933d/docs%2Fsource%2Fen%2Freference%2Fenvironment_variables.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/d5f992f5e67e8ced64a90fe01dfc50796fd2933d/docs%2Fsource%2Fen%2Freference%2Fenvironment_variables.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Freference%2Fenvironment_variables.md?ref=d5f992f5e67e8ced64a90fe01dfc50796fd2933d",
            "patch": "@@ -0,0 +1,58 @@\n+<!--Copyright 2025 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# Environment Variables\n+\n+## HF_ENABLE_PARALLEL_LOADING\n+\n+By default this is disabled. Enables the loading of torch and safetensor based weights to be loaded in parallel. Can decrease the time to load large models significantly, often times producing speed ups around ~50%.\n+\n+Can be set to a string equal to `\"false\"` or `\"true\"`. e.g. `os.environ[\"HF_ENABLE_PARALLEL_LOADING\"] = \"true\"`.\n+\n+e.g. `facebook/opt-30b` on an AWS EC2 g4dn.metal instance can be made to load in ~30s with this enabled vs ~55s without it.\n+\n+Profile before committing to using this environment variable, this will not produce speed ups for smaller models.\n+\n+```py\n+import os\n+\n+os.environ[\"HF_ENABLE_PARALLEL_LOADING\"] = \"true\"\n+\n+from transformers import pipeline\n+\n+model = pipeline(task=\"text-generation\", model=\"facebook/opt-30b\", device_map=\"auto\")\n+```\n+\n+## HF_PARALLEL_LOADING_WORKERS\n+\n+Determines how many threads should be used when parallel loading is enabled. Default is `8`.\n+\n+If the number of files that are being loaded is less than the number of threads specified, the number that is actually spawned will be equal to the number of files.\n+\n+e.g. If you specify 8 workers, and there are only 2 files, only 2 workers will be spawned.\n+\n+Tune as you see fit.\n+\n+```py\n+import os\n+\n+os.environ[\"HF_ENABLE_PARALLEL_LOADING\"] = \"true\"\n+os.environ[\"HF_PARALLEL_LOADING_WORKERS\"] = \"4\"\n+\n+from transformers import pipeline\n+\n+model = pipeline(task=\"text-generation\", model=\"facebook/opt-30b\", device_map=\"auto\")\n+```"
        },
        {
            "sha": "58d422b37b820dbbb2607ace1d73ae98b9c15018",
            "filename": "src/transformers/modeling_utils.py",
            "status": "modified",
            "additions": 150,
            "deletions": 58,
            "changes": 208,
            "blob_url": "https://github.com/huggingface/transformers/blob/d5f992f5e67e8ced64a90fe01dfc50796fd2933d/src%2Ftransformers%2Fmodeling_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/d5f992f5e67e8ced64a90fe01dfc50796fd2933d/src%2Ftransformers%2Fmodeling_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodeling_utils.py?ref=d5f992f5e67e8ced64a90fe01dfc50796fd2933d",
            "patch": "@@ -27,6 +27,7 @@\n import tempfile\n import warnings\n from collections import defaultdict\n+from concurrent.futures import ThreadPoolExecutor, as_completed\n from contextlib import contextmanager\n from dataclasses import dataclass\n from enum import Enum\n@@ -870,6 +871,116 @@ def _load_state_dict_into_meta_model(\n     return disk_offload_index, cpu_offload_index\n \n \n+def load_shard_file(args):\n+    (\n+        shard_file,\n+        state_dict,\n+        disk_only_shard_files,\n+        is_hqq_or_bnb,\n+        is_quantized,\n+        device_map,\n+        hf_quantizer,\n+        key_renaming_mapping,\n+        weights_only,\n+        model_to_load,\n+        expected_keys,\n+        reverse_key_renaming_mapping,\n+        disk_offload_folder,\n+        disk_offload_index,\n+        cpu_offload_folder,\n+        cpu_offload_index,\n+        is_offloaded_safetensors,\n+        keep_in_fp32_regex,\n+        unexpected_keys,\n+        device_mesh,\n+    ) = args\n+\n+    # Skip the load for shards that only contain disk-offloaded weights\n+    if shard_file in disk_only_shard_files:\n+        return [], disk_offload_index, cpu_offload_index\n+\n+    map_location = \"cpu\"\n+    if (\n+        shard_file.endswith(\".safetensors\")\n+        and not is_hqq_or_bnb\n+        and not (is_deepspeed_zero3_enabled() and not is_quantized)\n+    ):\n+        map_location = \"meta\"\n+    elif (\n+        device_map is not None\n+        and hf_quantizer is not None\n+        and hf_quantizer.quantization_config.quant_method == QuantizationMethod.TORCHAO\n+        and (\n+            hf_quantizer.quantization_config.quant_type in [\"int4_weight_only\", \"autoquant\"]\n+            or isinstance(hf_quantizer.quantization_config.quant_type, Int4WeightOnlyConfig)\n+        )\n+    ):\n+        map_location = torch.device([d for d in device_map.values() if d not in [\"cpu\", \"disk\"]][0])\n+\n+    # If shard_file is \"\", we use the existing state_dict instead of loading it\n+    if shard_file != \"\":\n+        state_dict = load_state_dict(\n+            shard_file, is_quantized=is_quantized, map_location=map_location, weights_only=weights_only\n+        )\n+\n+    # Fix the key names\n+    state_dict = {key_renaming_mapping[k]: v for k, v in state_dict.items() if k in key_renaming_mapping}\n+\n+    error_msgs = []\n+\n+    if is_deepspeed_zero3_enabled() and not is_quantized:\n+        error_msgs += _load_state_dict_into_zero3_model(model_to_load, state_dict)\n+    # Skip it with fsdp on ranks other than 0\n+    elif not (is_fsdp_enabled() and not is_local_dist_rank_0() and not is_quantized):\n+        disk_offload_index, cpu_offload_index = _load_state_dict_into_meta_model(\n+            model_to_load,\n+            state_dict,\n+            shard_file,\n+            expected_keys,\n+            reverse_key_renaming_mapping,\n+            device_map=device_map,\n+            disk_offload_folder=disk_offload_folder,\n+            disk_offload_index=disk_offload_index,\n+            cpu_offload_folder=cpu_offload_folder,\n+            cpu_offload_index=cpu_offload_index,\n+            hf_quantizer=hf_quantizer,\n+            is_safetensors=is_offloaded_safetensors,\n+            keep_in_fp32_regex=keep_in_fp32_regex,\n+            unexpected_keys=unexpected_keys,\n+            device_mesh=device_mesh,\n+        )\n+\n+    return error_msgs, disk_offload_index, cpu_offload_index\n+\n+\n+def load_shard_files_with_threadpool(args_list):\n+    num_workers = int(os.environ.get(\"HF_PARALLEL_LOADING_WORKERS\", \"8\"))\n+\n+    # Do not spawn anymore workers than you need\n+    num_workers = min(len(args_list), num_workers)\n+\n+    logger.info(f\"Loading model weights in parallel with {num_workers} workers...\")\n+\n+    error_msgs = []\n+\n+    with ThreadPoolExecutor(max_workers=num_workers) as executor:\n+        with logging.tqdm(total=len(args_list), desc=\"Loading checkpoint shards\") as pbar:\n+            futures = [executor.submit(load_shard_file, arg) for arg in args_list]\n+            for future in as_completed(futures):\n+                result = future.result()\n+                (\n+                    _error_msgs,\n+                    disk_offload_index,\n+                    cpu_offload_index,\n+                ) = result\n+\n+                error_msgs += _error_msgs\n+\n+                pbar.update(1)\n+\n+    return error_msgs, disk_offload_index, cpu_offload_index\n+\n+\n def _add_variant(weights_name: str, variant: Optional[str] = None) -> str:\n     if variant is not None:\n         path, name = weights_name.rsplit(\".\", 1)\n@@ -4973,9 +5084,6 @@ def _load_pretrained_model(\n             cpu_offload_folder = tempfile.mkdtemp()\n             cpu_offload_index = {}\n \n-        # For nice tqdm bars\n-        if checkpoint_files is not None and len(checkpoint_files) > 1:\n-            checkpoint_files = logging.tqdm(checkpoint_files, desc=\"Loading checkpoint shards\")\n         # To be able to iterate, even if we don't use it if the state_dict is already provided\n         elif state_dict is not None:\n             checkpoint_files = [\"\"]\n@@ -4993,64 +5101,48 @@ def _load_pretrained_model(\n             expanded_device_map = expand_device_map(device_map, expected_keys)\n             caching_allocator_warmup(model_to_load, expanded_device_map, hf_quantizer)\n \n-        error_msgs = []\n-        # Iterate on all the shards to load the weights\n-        for shard_file in checkpoint_files:\n-            # Skip the load for shards that only contain disk-offloaded weights\n-            if shard_file in disk_only_shard_files:\n-                continue\n-\n-            map_location = \"cpu\"\n-            if (\n-                shard_file.endswith(\".safetensors\")\n-                and not is_hqq_or_bnb\n-                and not (is_deepspeed_zero3_enabled() and not is_quantized)\n-            ):\n-                map_location = \"meta\"\n-            elif (\n-                device_map is not None\n-                and hf_quantizer is not None\n-                and hf_quantizer.quantization_config.quant_method == QuantizationMethod.TORCHAO\n-                and (\n-                    hf_quantizer.quantization_config.quant_type in [\"int4_weight_only\", \"autoquant\"]\n-                    or isinstance(hf_quantizer.quantization_config.quant_type, Int4WeightOnlyConfig)\n-                )\n-            ):\n-                map_location = torch.device([d for d in device_map.values() if d not in [\"cpu\", \"disk\"]][0])\n-\n-            # If shard_file is \"\", we use the existing state_dict instead of loading it\n-            if shard_file != \"\":\n-                state_dict = load_state_dict(\n-                    shard_file, is_quantized=is_quantized, map_location=map_location, weights_only=weights_only\n-                )\n+        # Prepare and compatabilize arguments for serial and parallel shard loading\n+        args_list = [\n+            (\n+                shard_file,\n+                state_dict,\n+                disk_only_shard_files,\n+                is_hqq_or_bnb,\n+                is_quantized,\n+                device_map,\n+                hf_quantizer,\n+                key_renaming_mapping,\n+                weights_only,\n+                model_to_load,\n+                expected_keys,\n+                reverse_key_renaming_mapping,\n+                disk_offload_folder,\n+                disk_offload_index,\n+                cpu_offload_folder,\n+                cpu_offload_index,\n+                is_offloaded_safetensors,\n+                keep_in_fp32_regex,\n+                unexpected_keys,\n+                device_mesh,\n+            )\n+            for shard_file in checkpoint_files\n+        ]\n \n-            # Fix the key names\n-            state_dict = {key_renaming_mapping[k]: v for k, v in state_dict.items() if k in key_renaming_mapping}\n+        error_msgs = []\n \n-            if is_deepspeed_zero3_enabled() and not is_quantized:\n-                error_msgs += _load_state_dict_into_zero3_model(model_to_load, state_dict)\n-            # Skip it with fsdp on ranks other than 0\n-            elif not (is_fsdp_enabled() and not is_local_dist_rank_0() and not is_quantized):\n-                disk_offload_index, cpu_offload_index = _load_state_dict_into_meta_model(\n-                    model_to_load,\n-                    state_dict,\n-                    shard_file,\n-                    expected_keys,\n-                    reverse_key_renaming_mapping,\n-                    device_map=device_map,\n-                    disk_offload_folder=disk_offload_folder,\n-                    disk_offload_index=disk_offload_index,\n-                    cpu_offload_folder=cpu_offload_folder,\n-                    cpu_offload_index=cpu_offload_index,\n-                    hf_quantizer=hf_quantizer,\n-                    is_safetensors=is_offloaded_safetensors,\n-                    keep_in_fp32_regex=keep_in_fp32_regex,\n-                    unexpected_keys=unexpected_keys,\n-                    device_mesh=device_mesh,\n-                )\n+        if (\n+            os.environ.get(\"HF_ENABLE_PARALLEL_LOADING\", \"\").upper() in ENV_VARS_TRUE_VALUES\n+            and not is_deepspeed_zero3_enabled()\n+        ):\n+            _error_msgs, disk_offload_index, cpu_offload_index = load_shard_files_with_threadpool(args_list)\n+            error_msgs += _error_msgs\n+        else:\n+            if len(args_list) > 1:\n+                args_list = logging.tqdm(args_list, desc=\"Loading checkpoint shards\")\n \n-            # force memory release if loading multiple shards, to avoid having 2 state dicts in memory in next loop\n-            del state_dict\n+            for args in args_list:\n+                _error_msgs, disk_offload_index, cpu_offload_index = load_shard_file(args)\n+                error_msgs += _error_msgs\n \n         # Adjust offloaded weights name and save if needed\n         if disk_offload_index is not None and len(disk_offload_index) > 0:"
        },
        {
            "sha": "ca4e1cc3d427c018154ed54aa4715b7eb9ad08c4",
            "filename": "tests/utils/test_modeling_utils.py",
            "status": "modified",
            "additions": 21,
            "deletions": 18,
            "changes": 39,
            "blob_url": "https://github.com/huggingface/transformers/blob/d5f992f5e67e8ced64a90fe01dfc50796fd2933d/tests%2Futils%2Ftest_modeling_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/d5f992f5e67e8ced64a90fe01dfc50796fd2933d/tests%2Futils%2Ftest_modeling_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Futils%2Ftest_modeling_utils.py?ref=d5f992f5e67e8ced64a90fe01dfc50796fd2933d",
            "patch": "@@ -297,6 +297,27 @@ def test_local_files_only(self):\n                 hub.TRANSFORMERS_CACHE = transformers_cache\n \n \n+# Need to be serializable, which means they cannot be in a test class method\n+class TestGammaBetaNorm(torch.nn.Module):\n+    def __init__(self):\n+        super().__init__()\n+        self.gamma = torch.nn.Parameter(torch.ones(1))\n+        self.beta = torch.nn.Parameter(torch.zeros(1))\n+\n+    def forward(self):\n+        return self.gamma.sum() + self.beta.sum()\n+\n+\n+class TestModelGammaBeta(PreTrainedModel):\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.LayerNorm = TestGammaBetaNorm()\n+        self.post_init()\n+\n+    def forward(self):\n+        return self.LayerNorm()\n+\n+\n if is_flax_available():\n     from transformers import FlaxBertModel\n \n@@ -1636,24 +1657,6 @@ def test_model_from_pretrained_from_mlx(self):\n             torch.testing.assert_close(outputs_from_saved[\"logits\"], outputs[\"logits\"])\n \n     def test_warning_for_beta_gamma_parameters(self):\n-        class TestGammaBetaNorm(torch.nn.Module):\n-            def __init__(self):\n-                super().__init__()\n-                self.gamma = torch.nn.Parameter(torch.ones(1))\n-                self.beta = torch.nn.Parameter(torch.zeros(1))\n-\n-            def forward(self):\n-                return self.gamma.sum() + self.beta.sum()\n-\n-        class TestModelGammaBeta(PreTrainedModel):\n-            def __init__(self, config):\n-                super().__init__(config)\n-                self.LayerNorm = TestGammaBetaNorm()\n-                self.post_init()\n-\n-            def forward(self):\n-                return self.LayerNorm()\n-\n         logger = logging.get_logger(\"transformers.modeling_utils\")\n         config = PretrainedConfig()\n         warning_msg_gamma = \"`LayerNorm.gamma` -> `LayerNorm.weight`\""
        }
    ],
    "stats": {
        "total": 310,
        "additions": 234,
        "deletions": 76
    }
}