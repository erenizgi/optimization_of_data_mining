{
    "author": "haotongl",
    "message": "Add Prompt Depth Anything Model (#35401)\n\n* add prompt depth anything model by modular transformer\n\n* add prompt depth anything docs and imports\n\n* update code style according transformers doc\n\n* update code style: import order issue is fixed by custom_init_isort\n\n* fix depth shape from B,1,H,W to B,H,W which is as the same as Depth Anything\n\n* move prompt depth anything to vision models in _toctree.yml\n\n* update backbone test; there is no need for resnet18 backbone test\n\n* update init file & pass RUN_SLOW tests\n\n* update len(prompt_depth) to prompt_depth.shape[0]\n\nCo-authored-by: Joshua Lochner <admin@xenova.com>\n\n* fix torch_int/model_doc\n\n* fix typo\n\n* update PromptDepthAnythingImageProcessor\n\n* fix typo\n\n* fix typo for prompt depth anything doc\n\n* update promptda overview image link of huggingface repo\n\n* fix some typos in promptda doc\n\n* Update image processing to include pad_image, prompt depth position, and related explanations for better clarity and functionality.\n\n* add copy disclaimer for prompt depth anything image processing\n\n* fix some format typos in image processing and conversion scripts\n\n* fix nn.ReLU(False) to nn.ReLU()\n\n* rename residual layer as it's a sequential layer\n\n* move size compute to a separate line/variable for easier debug in modular prompt depth anything\n\n* fix modular format for prompt depth anything\n\n* update modular prompt depth anything\n\n* fix scale to meter and some internal funcs warp\n\n* fix code style in image_processing_prompt_depth_anything.py\n\n* fix issues in image_processing_prompt_depth_anything.py\n\n* fix issues in image_processing_prompt_depth_anything.py\n\n* fix issues in prompt depth anything\n\n* update converting script similar to mllamma\n\n* update testing for modeling prompt depth anything\n\n* update testing for image_processing_prompt_depth_anything\n\n* fix assertion in image_processing_prompt_depth_anything\n\n* Update src/transformers/models/prompt_depth_anything/modular_prompt_depth_anything.py\n\nCo-authored-by: Pavel Iakubovskii <qubvel@gmail.com>\n\n* Update src/transformers/models/prompt_depth_anything/modular_prompt_depth_anything.py\n\nCo-authored-by: Pavel Iakubovskii <qubvel@gmail.com>\n\n* Update src/transformers/models/prompt_depth_anything/image_processing_prompt_depth_anything.py\n\nCo-authored-by: Pavel Iakubovskii <qubvel@gmail.com>\n\n* Update src/transformers/models/prompt_depth_anything/image_processing_prompt_depth_anything.py\n\nCo-authored-by: Pavel Iakubovskii <qubvel@gmail.com>\n\n* Update src/transformers/models/prompt_depth_anything/image_processing_prompt_depth_anything.py\n\nCo-authored-by: Pavel Iakubovskii <qubvel@gmail.com>\n\n* Update docs/source/en/model_doc/prompt_depth_anything.md\n\nCo-authored-by: Pavel Iakubovskii <qubvel@gmail.com>\n\n* Update docs/source/en/model_doc/prompt_depth_anything.md\n\nCo-authored-by: Pavel Iakubovskii <qubvel@gmail.com>\n\n* update some testing\n\n* fix testing\n\n* fix\n\n* add return doc for forward of prompt depth anything\n\n* Update src/transformers/models/prompt_depth_anything/modular_prompt_depth_anything.py\n\nCo-authored-by: Pavel Iakubovskii <qubvel@gmail.com>\n\n* Update tests/models/prompt_depth_anything/test_modeling_prompt_depth_anything.py\n\nCo-authored-by: Pavel Iakubovskii <qubvel@gmail.com>\n\n* fix prompt depth order\n\n* fix format for testing prompt depth anything\n\n* fix minor issues in prompt depth anything doc\n\n* fix format for modular prompt depth anything\n\n* revert format for modular prompt depth anything\n\n* revert format for modular prompt depth anything\n\n* update format for modular prompt depth anything\n\n* fix parallel testing errors\n\n* fix doc for prompt depth anything\n\n* Add header\n\n* Fix imports\n\n* Licence header\n\n---------\n\nCo-authored-by: Joshua Lochner <admin@xenova.com>\nCo-authored-by: Pavel Iakubovskii <qubvel@gmail.com>",
    "sha": "6515c259532d50ee022f211eab8afbd765a5f89c",
    "files": [
        {
            "sha": "701875d22f19cbdc71a7af26115933bc8ed62d04",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -735,6 +735,8 @@\n         title: NAT\n       - local: model_doc/poolformer\n         title: PoolFormer\n+      - local: model_doc/prompt_depth_anything\n+        title: Prompt Depth Anything\n       - local: model_doc/pvt\n         title: Pyramid Vision Transformer (PVT)\n       - local: model_doc/pvt_v2"
        },
        {
            "sha": "910298fa8c71f8473e40c26ddc466a1d2283e3ff",
            "filename": "docs/source/en/model_doc/prompt_depth_anything.md",
            "status": "added",
            "additions": 96,
            "deletions": 0,
            "changes": 96,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/docs%2Fsource%2Fen%2Fmodel_doc%2Fprompt_depth_anything.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/docs%2Fsource%2Fen%2Fmodel_doc%2Fprompt_depth_anything.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fprompt_depth_anything.md?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -0,0 +1,96 @@\n+<!--Copyright 2024 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# Prompt Depth Anything\n+\n+## Overview\n+\n+The Prompt Depth Anything model was introduced in [Prompting Depth Anything for 4K Resolution Accurate Metric Depth Estimation](https://arxiv.org/abs/2412.14015) by Haotong Lin, Sida Peng, Jingxiao Chen, Songyou Peng, Jiaming Sun, Minghuan Liu, Hujun Bao, Jiashi Feng, Xiaowei Zhou, Bingyi Kang. \n+\n+\n+The abstract from the paper is as follows:\n+\n+*Prompts play a critical role in unleashing the power of language and vision foundation models for specific tasks. For the first time, we introduce prompting into depth foundation models, creating a new paradigm for metric depth estimation termed Prompt Depth Anything. Specifically, we use a low-cost LiDAR as the prompt to guide the Depth Anything model for accurate metric depth output, achieving up to 4K resolution. Our approach centers on a concise prompt fusion design that integrates the LiDAR at multiple scales within the depth decoder. To address training challenges posed by limited datasets containing both LiDAR depth and precise GT depth, we propose a scalable data pipeline that includes synthetic data LiDAR simulation and real data pseudo GT depth generation. Our approach sets new state-of-the-arts on the ARKitScenes and ScanNet++ datasets and benefits downstream applications, including 3D reconstruction and generalized robotic grasping.*\n+\n+<img src=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/model_doc/prompt_depth_anything_architecture.jpg\"\n+alt=\"drawing\" width=\"600\"/>\n+\n+<small> Prompt Depth Anything overview. Taken from the <a href=\"https://arxiv.org/pdf/2412.14015\">original paper</a>.</small>\n+\n+## Usage example\n+\n+The Transformers library allows you to use the model with just a few lines of code:\n+\n+```python\n+>>> import torch\n+>>> import requests\n+>>> import numpy as np\n+\n+>>> from PIL import Image\n+>>> from transformers import AutoImageProcessor, AutoModelForDepthEstimation\n+\n+>>> url = \"https://github.com/DepthAnything/PromptDA/blob/main/assets/example_images/image.jpg?raw=true\"\n+>>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+>>> image_processor = AutoImageProcessor.from_pretrained(\"depth-anything/prompt-depth-anything-vits-hf\")\n+>>> model = AutoModelForDepthEstimation.from_pretrained(\"depth-anything/prompt-depth-anything-vits-hf\")\n+\n+>>> prompt_depth_url = \"https://github.com/DepthAnything/PromptDA/blob/main/assets/example_images/arkit_depth.png?raw=true\"\n+>>> prompt_depth = Image.open(requests.get(prompt_depth_url, stream=True).raw)\n+>>> # the prompt depth can be None, and the model will output a monocular relative depth.\n+\n+>>> # prepare image for the model\n+>>> inputs = image_processor(images=image, return_tensors=\"pt\", prompt_depth=prompt_depth)\n+\n+>>> with torch.no_grad():\n+...     outputs = model(**inputs)\n+\n+>>> # interpolate to original size\n+>>> post_processed_output = image_processor.post_process_depth_estimation(\n+...     outputs,\n+...     target_sizes=[(image.height, image.width)],\n+... )\n+\n+>>> # visualize the prediction\n+>>> predicted_depth = post_processed_output[0][\"predicted_depth\"]\n+>>> depth = predicted_depth * 1000 \n+>>> depth = depth.detach().cpu().numpy()\n+>>> depth = Image.fromarray(depth.astype(\"uint16\")) # mm\n+```\n+\n+## Resources\n+\n+A list of official Hugging Face and community (indicated by ðŸŒŽ) resources to help you get started with Prompt Depth Anything.\n+\n+- [Prompt Depth Anything Demo](https://huggingface.co/spaces/depth-anything/PromptDA)\n+- [Prompt Depth Anything Interactive Results](https://promptda.github.io/interactive.html)\n+\n+If you are interested in submitting a resource to be included here, please feel free to open a Pull Request and we'll review it! The resource should ideally demonstrate something new instead of duplicating an existing resource.\n+\n+## PromptDepthAnythingConfig\n+\n+[[autodoc]] PromptDepthAnythingConfig\n+\n+## PromptDepthAnythingForDepthEstimation\n+\n+[[autodoc]] PromptDepthAnythingForDepthEstimation\n+    - forward\n+\n+## PromptDepthAnythingImageProcessor\n+\n+[[autodoc]] PromptDepthAnythingImageProcessor\n+    - preprocess\n+    - post_process_depth_estimation\n\\ No newline at end of file"
        },
        {
            "sha": "8c7a608b09008262196508e1d7ed01b46cfb617a",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -711,6 +711,7 @@\n     \"models.plbart\": [\"PLBartConfig\"],\n     \"models.poolformer\": [\"PoolFormerConfig\"],\n     \"models.pop2piano\": [\"Pop2PianoConfig\"],\n+    \"models.prompt_depth_anything\": [\"PromptDepthAnythingConfig\"],\n     \"models.prophetnet\": [\n         \"ProphetNetConfig\",\n         \"ProphetNetTokenizer\",\n@@ -1299,6 +1300,7 @@\n     _import_structure[\"models.pix2struct\"].extend([\"Pix2StructImageProcessor\"])\n     _import_structure[\"models.pixtral\"].append(\"PixtralImageProcessor\")\n     _import_structure[\"models.poolformer\"].extend([\"PoolFormerFeatureExtractor\", \"PoolFormerImageProcessor\"])\n+    _import_structure[\"models.prompt_depth_anything\"].extend([\"PromptDepthAnythingImageProcessor\"])\n     _import_structure[\"models.pvt\"].extend([\"PvtImageProcessor\"])\n     _import_structure[\"models.qwen2_vl\"].extend([\"Qwen2VLImageProcessor\"])\n     _import_structure[\"models.rt_detr\"].extend([\"RTDetrImageProcessor\"])\n@@ -3335,6 +3337,12 @@\n             \"Pop2PianoPreTrainedModel\",\n         ]\n     )\n+    _import_structure[\"models.prompt_depth_anything\"].extend(\n+        [\n+            \"PromptDepthAnythingForDepthEstimation\",\n+            \"PromptDepthAnythingPreTrainedModel\",\n+        ]\n+    )\n     _import_structure[\"models.prophetnet\"].extend(\n         [\n             \"ProphetNetDecoder\",\n@@ -5921,6 +5929,7 @@\n     from .models.pop2piano import (\n         Pop2PianoConfig,\n     )\n+    from .models.prompt_depth_anything import PromptDepthAnythingConfig\n     from .models.prophetnet import (\n         ProphetNetConfig,\n         ProphetNetTokenizer,\n@@ -6530,6 +6539,7 @@\n             PoolFormerFeatureExtractor,\n             PoolFormerImageProcessor,\n         )\n+        from .models.prompt_depth_anything import PromptDepthAnythingImageProcessor\n         from .models.pvt import PvtImageProcessor\n         from .models.qwen2_vl import Qwen2VLImageProcessor\n         from .models.rt_detr import RTDetrImageProcessor\n@@ -8166,6 +8176,10 @@\n             Pop2PianoForConditionalGeneration,\n             Pop2PianoPreTrainedModel,\n         )\n+        from .models.prompt_depth_anything import (\n+            PromptDepthAnythingForDepthEstimation,\n+            PromptDepthAnythingPreTrainedModel,\n+        )\n         from .models.prophetnet import (\n             ProphetNetDecoder,\n             ProphetNetEncoder,"
        },
        {
            "sha": "06575ffceba4fd534171ce5997dac974ee5bc569",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -219,6 +219,7 @@\n     plbart,\n     poolformer,\n     pop2piano,\n+    prompt_depth_anything,\n     prophetnet,\n     pvt,\n     pvt_v2,"
        },
        {
            "sha": "712450e166aa2a604f0e28660977b39b124446ad",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -241,6 +241,7 @@\n         (\"plbart\", \"PLBartConfig\"),\n         (\"poolformer\", \"PoolFormerConfig\"),\n         (\"pop2piano\", \"Pop2PianoConfig\"),\n+        (\"prompt_depth_anything\", \"PromptDepthAnythingConfig\"),\n         (\"prophetnet\", \"ProphetNetConfig\"),\n         (\"pvt\", \"PvtConfig\"),\n         (\"pvt_v2\", \"PvtV2Config\"),\n@@ -593,6 +594,7 @@\n         (\"plbart\", \"PLBart\"),\n         (\"poolformer\", \"PoolFormer\"),\n         (\"pop2piano\", \"Pop2Piano\"),\n+        (\"prompt_depth_anything\", \"PromptDepthAnything\"),\n         (\"prophetnet\", \"ProphetNet\"),\n         (\"pvt\", \"PVT\"),\n         (\"pvt_v2\", \"PVTv2\"),"
        },
        {
            "sha": "2c9b6a266db4e672b3000e47f41fc4f235805bff",
            "filename": "src/transformers/models/auto/image_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -127,6 +127,7 @@\n             (\"pix2struct\", (\"Pix2StructImageProcessor\",)),\n             (\"pixtral\", (\"PixtralImageProcessor\", \"PixtralImageProcessorFast\")),\n             (\"poolformer\", (\"PoolFormerImageProcessor\",)),\n+            (\"prompt_depth_anything\", (\"PromptDepthAnythingImageProcessor\",)),\n             (\"pvt\", (\"PvtImageProcessor\",)),\n             (\"pvt_v2\", (\"PvtImageProcessor\",)),\n             (\"qwen2_5_vl\", (\"Qwen2VLImageProcessor\", \"Qwen2VLImageProcessorFast\")),"
        },
        {
            "sha": "7bf2180b2d8544f2ff25cc1d34e053509bff4ade",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -942,6 +942,7 @@\n         (\"depth_pro\", \"DepthProForDepthEstimation\"),\n         (\"dpt\", \"DPTForDepthEstimation\"),\n         (\"glpn\", \"GLPNForDepthEstimation\"),\n+        (\"prompt_depth_anything\", \"PromptDepthAnythingForDepthEstimation\"),\n         (\"zoedepth\", \"ZoeDepthForDepthEstimation\"),\n     ]\n )"
        },
        {
            "sha": "3cb05f8e378874693b225823050dee69c206f946",
            "filename": "src/transformers/models/prompt_depth_anything/__init__.py",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2F__init__.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -0,0 +1,31 @@\n+# Copyright 2024 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_prompt_depth_anything import PromptDepthAnythingConfig\n+    from .image_processing_prompt_depth_anything import PromptDepthAnythingImageProcessor\n+    from .modeling_prompt_depth_anything import (\n+        PromptDepthAnythingForDepthEstimation,\n+        PromptDepthAnythingPreTrainedModel,\n+    )\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "cf213133c1424d185b7b38ca5f84d1f7e1526522",
            "filename": "src/transformers/models/prompt_depth_anything/configuration_prompt_depth_anything.py",
            "status": "added",
            "additions": 171,
            "deletions": 0,
            "changes": 171,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fconfiguration_prompt_depth_anything.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fconfiguration_prompt_depth_anything.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fconfiguration_prompt_depth_anything.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -0,0 +1,171 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/prompt_depth_anything/modular_prompt_depth_anything.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_prompt_depth_anything.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import copy\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...utils import logging\n+from ...utils.backbone_utils import verify_backbone_config_arguments\n+from ..auto.configuration_auto import CONFIG_MAPPING\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class PromptDepthAnythingConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`PromptDepthAnythingModel`]. It is used to instantiate a PromptDepthAnything\n+    model according to the specified arguments, defining the model architecture. Instantiating a configuration with the\n+    defaults will yield a similar configuration to that of the PromptDepthAnything\n+    [LiheYoung/depth-anything-small-hf](https://huggingface.co/LiheYoung/depth-anything-small-hf) architecture.\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        backbone_config (`Union[Dict[str, Any], PretrainedConfig]`, *optional*):\n+            The configuration of the backbone model. Only used in case `is_hybrid` is `True` or in case you want to\n+            leverage the [`AutoBackbone`] API.\n+        backbone (`str`, *optional*):\n+            Name of backbone to use when `backbone_config` is `None`. If `use_pretrained_backbone` is `True`, this\n+            will load the corresponding pretrained weights from the timm or transformers library. If `use_pretrained_backbone`\n+            is `False`, this loads the backbone's config and uses that to initialize the backbone with random weights.\n+        use_pretrained_backbone (`bool`, *optional*, defaults to `False`):\n+            Whether to use pretrained weights for the backbone.\n+        use_timm_backbone (`bool`, *optional*, defaults to `False`):\n+            Whether or not to use the `timm` library for the backbone. If set to `False`, will use the [`AutoBackbone`]\n+            API.\n+        backbone_kwargs (`dict`, *optional*):\n+            Keyword arguments to be passed to AutoBackbone when loading from a checkpoint\n+            e.g. `{'out_indices': (0, 1, 2, 3)}`. Cannot be specified if `backbone_config` is set.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The size of the patches to extract from the backbone features.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        reassemble_hidden_size (`int`, *optional*, defaults to 384):\n+            The number of input channels of the reassemble layers.\n+        reassemble_factors (`List[int]`, *optional*, defaults to `[4, 2, 1, 0.5]`):\n+            The up/downsampling factors of the reassemble layers.\n+        neck_hidden_sizes (`List[str]`, *optional*, defaults to `[48, 96, 192, 384]`):\n+            The hidden sizes to project to for the feature maps of the backbone.\n+        fusion_hidden_size (`int`, *optional*, defaults to 64):\n+            The number of channels before fusion.\n+        head_in_index (`int`, *optional*, defaults to -1):\n+            The index of the features to use in the depth estimation head.\n+        head_hidden_size (`int`, *optional*, defaults to 32):\n+            The number of output channels in the second convolution of the depth estimation head.\n+        depth_estimation_type (`str`, *optional*, defaults to `\"relative\"`):\n+            The type of depth estimation to use. Can be one of `[\"relative\", \"metric\"]`.\n+        max_depth (`float`, *optional*):\n+            The maximum depth to use for the \"metric\" depth estimation head. 20 should be used for indoor models\n+            and 80 for outdoor models. For \"relative\" depth estimation, this value is ignored.\n+\n+    Example:\n+\n+    ```python\n+    >>> from transformers import PromptDepthAnythingConfig, PromptDepthAnythingForDepthEstimation\n+\n+    >>> # Initializing a PromptDepthAnything small style configuration\n+    >>> configuration = PromptDepthAnythingConfig()\n+\n+    >>> # Initializing a model from the PromptDepthAnything small style configuration\n+    >>> model = PromptDepthAnythingForDepthEstimation(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"prompt_depth_anything\"\n+\n+    def __init__(\n+        self,\n+        backbone_config=None,\n+        backbone=None,\n+        use_pretrained_backbone=False,\n+        use_timm_backbone=False,\n+        backbone_kwargs=None,\n+        patch_size=14,\n+        initializer_range=0.02,\n+        reassemble_hidden_size=384,\n+        reassemble_factors=[4, 2, 1, 0.5],\n+        neck_hidden_sizes=[48, 96, 192, 384],\n+        fusion_hidden_size=64,\n+        head_in_index=-1,\n+        head_hidden_size=32,\n+        depth_estimation_type=\"relative\",\n+        max_depth=None,\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        if backbone_config is None and backbone is None:\n+            logger.info(\"`backbone_config` is `None`. Initializing the config with the default `Dinov2` backbone.\")\n+            backbone_config = CONFIG_MAPPING[\"dinov2\"](\n+                image_size=518,\n+                hidden_size=384,\n+                num_attention_heads=6,\n+                out_indices=[9, 10, 11, 12],\n+                apply_layernorm=True,\n+                reshape_hidden_states=False,\n+            )\n+        elif isinstance(backbone_config, dict):\n+            backbone_model_type = backbone_config.get(\"model_type\")\n+            config_class = CONFIG_MAPPING[backbone_model_type]\n+            backbone_config = config_class.from_dict(backbone_config)\n+\n+        verify_backbone_config_arguments(\n+            use_timm_backbone=use_timm_backbone,\n+            use_pretrained_backbone=use_pretrained_backbone,\n+            backbone=backbone,\n+            backbone_config=backbone_config,\n+            backbone_kwargs=backbone_kwargs,\n+        )\n+\n+        self.backbone_config = backbone_config\n+        self.backbone = backbone\n+        self.use_pretrained_backbone = use_pretrained_backbone\n+        self.use_timm_backbone = use_timm_backbone\n+        self.backbone_kwargs = backbone_kwargs\n+        self.reassemble_hidden_size = reassemble_hidden_size\n+        self.patch_size = patch_size\n+        self.initializer_range = initializer_range\n+        self.reassemble_factors = reassemble_factors\n+        self.neck_hidden_sizes = neck_hidden_sizes\n+        self.fusion_hidden_size = fusion_hidden_size\n+        self.head_in_index = head_in_index\n+        self.head_hidden_size = head_hidden_size\n+        if depth_estimation_type not in [\"relative\", \"metric\"]:\n+            raise ValueError(\"depth_estimation_type must be one of ['relative', 'metric']\")\n+        self.depth_estimation_type = depth_estimation_type\n+        self.max_depth = max_depth if max_depth else 1\n+\n+    def to_dict(self):\n+        \"\"\"\n+        Serializes this instance to a Python dictionary. Override the default [`~PretrainedConfig.to_dict`]. Returns:\n+            `Dict[str, any]`: Dictionary of all the attributes that make up this configuration instance,\n+        \"\"\"\n+        output = copy.deepcopy(self.__dict__)\n+\n+        if output[\"backbone_config\"] is not None:\n+            output[\"backbone_config\"] = self.backbone_config.to_dict()\n+\n+        output[\"model_type\"] = self.__class__.model_type\n+        return output\n+\n+\n+__all__ = [\"PromptDepthAnythingConfig\"]"
        },
        {
            "sha": "8dfeff03ad270634d76505ea56e875f025116b87",
            "filename": "src/transformers/models/prompt_depth_anything/convert_prompt_depth_anything_to_hf.py",
            "status": "added",
            "additions": 292,
            "deletions": 0,
            "changes": 292,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fconvert_prompt_depth_anything_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fconvert_prompt_depth_anything_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fconvert_prompt_depth_anything_to_hf.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -0,0 +1,292 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Convert Prompt Depth Anything checkpoints from the original repository. URL:\n+https://github.com/DepthAnything/PromptDA\"\"\"\n+\n+import argparse\n+import re\n+from pathlib import Path\n+\n+import requests\n+import torch\n+from huggingface_hub import hf_hub_download\n+from PIL import Image\n+\n+from transformers import (\n+    Dinov2Config,\n+    PromptDepthAnythingConfig,\n+    PromptDepthAnythingForDepthEstimation,\n+    PromptDepthAnythingImageProcessor,\n+)\n+from transformers.utils import logging\n+\n+\n+logging.set_verbosity_info()\n+logger = logging.get_logger(__name__)\n+\n+\n+def get_dpt_config(model_name):\n+    if \"small\" in model_name or \"vits\" in model_name:\n+        out_indices = [3, 6, 9, 12]\n+        backbone_config = Dinov2Config.from_pretrained(\n+            \"facebook/dinov2-small\", out_indices=out_indices, apply_layernorm=True, reshape_hidden_states=False\n+        )\n+        fusion_hidden_size = 64\n+        neck_hidden_sizes = [48, 96, 192, 384]\n+    elif \"base\" in model_name or \"vitb\" in model_name:\n+        out_indices = [3, 6, 9, 12]\n+        backbone_config = Dinov2Config.from_pretrained(\n+            \"facebook/dinov2-base\", out_indices=out_indices, apply_layernorm=True, reshape_hidden_states=False\n+        )\n+        fusion_hidden_size = 128\n+        neck_hidden_sizes = [96, 192, 384, 768]\n+    elif \"large\" in model_name or \"vitl\" in model_name:\n+        out_indices = [5, 12, 18, 24]\n+        backbone_config = Dinov2Config.from_pretrained(\n+            \"facebook/dinov2-large\", out_indices=out_indices, apply_layernorm=True, reshape_hidden_states=False\n+        )\n+        fusion_hidden_size = 256\n+        neck_hidden_sizes = [256, 512, 1024, 1024]\n+    else:\n+        raise NotImplementedError(f\"Model not supported: {model_name}\")\n+\n+    depth_estimation_type = \"metric\"\n+    max_depth = None\n+\n+    config = PromptDepthAnythingConfig(\n+        reassemble_hidden_size=backbone_config.hidden_size,\n+        patch_size=backbone_config.patch_size,\n+        backbone_config=backbone_config,\n+        fusion_hidden_size=fusion_hidden_size,\n+        neck_hidden_sizes=neck_hidden_sizes,\n+        depth_estimation_type=depth_estimation_type,\n+        max_depth=max_depth,\n+    )\n+\n+    return config\n+\n+\n+def transform_qkv_weights(key, value, config):\n+    if not key.startswith(\"qkv_transform\"):\n+        return value\n+\n+    layer_idx = int(key.split(\"_\")[-1])\n+    hidden_size = config.backbone_config.hidden_size\n+\n+    suffix = \"bias\" if \"bias\" in key else \"weight\"\n+    return {\n+        f\"backbone.encoder.layer.{layer_idx}.attention.attention.query.{suffix}\": value[:hidden_size],\n+        f\"backbone.encoder.layer.{layer_idx}.attention.attention.key.{suffix}\": value[hidden_size : hidden_size * 2],\n+        f\"backbone.encoder.layer.{layer_idx}.attention.attention.value.{suffix}\": value[-hidden_size:],\n+    }\n+\n+\n+ORIGINAL_TO_CONVERTED_KEY_MAPPING = {\n+    # Stem\n+    r\"pretrained.cls_token\": r\"backbone.embeddings.cls_token\",\n+    r\"pretrained.mask_token\": r\"backbone.embeddings.mask_token\",\n+    r\"pretrained.pos_embed\": r\"backbone.embeddings.position_embeddings\",\n+    r\"pretrained.patch_embed.proj.(weight|bias)\": r\"backbone.embeddings.patch_embeddings.projection.\\1\",\n+    # Backbone\n+    r\"pretrained.norm.(weight|bias)\": r\"backbone.layernorm.\\1\",\n+    # Transformer layers\n+    r\"pretrained.blocks.(\\d+).ls1.gamma\": r\"backbone.encoder.layer.\\1.layer_scale1.lambda1\",\n+    r\"pretrained.blocks.(\\d+).ls2.gamma\": r\"backbone.encoder.layer.\\1.layer_scale2.lambda1\",\n+    r\"pretrained.blocks.(\\d+).norm1.(weight|bias)\": r\"backbone.encoder.layer.\\1.norm1.\\2\",\n+    r\"pretrained.blocks.(\\d+).norm2.(weight|bias)\": r\"backbone.encoder.layer.\\1.norm2.\\2\",\n+    r\"pretrained.blocks.(\\d+).mlp.fc1.(weight|bias)\": r\"backbone.encoder.layer.\\1.mlp.fc1.\\2\",\n+    r\"pretrained.blocks.(\\d+).mlp.fc2.(weight|bias)\": r\"backbone.encoder.layer.\\1.mlp.fc2.\\2\",\n+    r\"pretrained.blocks.(\\d+).attn.proj.(weight|bias)\": r\"backbone.encoder.layer.\\1.attention.output.dense.\\2\",\n+    r\"pretrained.blocks.(\\d+).attn.qkv.(weight|bias)\": r\"qkv_transform_\\2_\\1\",\n+    # Neck\n+    r\"depth_head.projects.(\\d+).(weight|bias)\": r\"neck.reassemble_stage.layers.\\1.projection.\\2\",\n+    r\"depth_head.scratch.layer(\\d+)_rn.weight\": lambda m: f\"neck.convs.{int(m.group(1))-1}.weight\",\n+    r\"depth_head.resize_layers.(\\d+).(weight|bias)\": r\"neck.reassemble_stage.layers.\\1.resize.\\2\",\n+    # Refinenet (with reversed indices)\n+    r\"depth_head.scratch.refinenet(\\d+).out_conv.(weight|bias)\": lambda m: f\"neck.fusion_stage.layers.{4-int(m.group(1))}.projection.{m.group(2)}\",\n+    r\"depth_head.scratch.refinenet(\\d+).resConfUnit1.conv1.(weight|bias)\": lambda m: f\"neck.fusion_stage.layers.{4-int(m.group(1))}.residual_layer1.convolution1.{m.group(2)}\",\n+    r\"depth_head.scratch.refinenet(\\d+).resConfUnit1.conv2.(weight|bias)\": lambda m: f\"neck.fusion_stage.layers.{4-int(m.group(1))}.residual_layer1.convolution2.{m.group(2)}\",\n+    r\"depth_head.scratch.refinenet(\\d+).resConfUnit2.conv1.(weight|bias)\": lambda m: f\"neck.fusion_stage.layers.{4-int(m.group(1))}.residual_layer2.convolution1.{m.group(2)}\",\n+    r\"depth_head.scratch.refinenet(\\d+).resConfUnit2.conv2.(weight|bias)\": lambda m: f\"neck.fusion_stage.layers.{4-int(m.group(1))}.residual_layer2.convolution2.{m.group(2)}\",\n+    r\"depth_head.scratch.refinenet(\\d+).resConfUnit_depth.0.(weight|bias)\": lambda m: f\"neck.fusion_stage.layers.{4-int(m.group(1))}.prompt_depth_layer.convolution1.{m.group(2)}\",\n+    r\"depth_head.scratch.refinenet(\\d+).resConfUnit_depth.2.(weight|bias)\": lambda m: f\"neck.fusion_stage.layers.{4-int(m.group(1))}.prompt_depth_layer.convolution2.{m.group(2)}\",\n+    r\"depth_head.scratch.refinenet(\\d+).resConfUnit_depth.4.(weight|bias)\": lambda m: f\"neck.fusion_stage.layers.{4-int(m.group(1))}.prompt_depth_layer.convolution3.{m.group(2)}\",\n+    # Head\n+    r\"depth_head.scratch.output_conv1.(weight|bias)\": r\"head.conv1.\\1\",\n+    r\"depth_head.scratch.output_conv2.0.(weight|bias)\": r\"head.conv2.\\1\",\n+    r\"depth_head.scratch.output_conv2.2.(weight|bias)\": r\"head.conv3.\\1\",\n+}\n+\n+\n+def convert_old_keys_to_new_keys(state_dict_keys: dict = None):\n+    \"\"\"\n+    Convert old state dict keys to new keys using regex patterns.\n+    \"\"\"\n+    output_dict = {}\n+    if state_dict_keys is not None:\n+        for old_key in state_dict_keys:\n+            new_key = old_key\n+            for pattern, replacement in ORIGINAL_TO_CONVERTED_KEY_MAPPING.items():\n+                match = re.match(pattern, old_key)\n+                if match:\n+                    if callable(replacement):\n+                        new_key = replacement(match)\n+                    else:\n+                        new_key = re.sub(pattern, replacement, old_key)\n+                    break\n+            output_dict[old_key] = new_key\n+    return output_dict\n+\n+\n+@torch.no_grad()\n+def convert_dpt_checkpoint(model_name, pytorch_dump_folder_path, push_to_hub, verify_logits):\n+    \"\"\"\n+    Copy/paste/tweak model's weights to our DPT structure.\n+    \"\"\"\n+\n+    # define DPT configuration\n+    config = get_dpt_config(model_name)\n+\n+    model_name_to_repo = {\n+        \"prompt-depth-anything-vits\": \"depth-anything/prompt-depth-anything-vits\",\n+        \"prompt-depth-anything-vits-transparent\": \"depth-anything/prompt-depth-anything-vits-transparent\",\n+        \"prompt-depth-anything-vitl\": \"depth-anything/prompt-depth-anything-vitl\",\n+    }\n+\n+    # load original state_dict\n+    repo_id = model_name_to_repo[model_name]\n+    filename = name_to_checkpoint[model_name]\n+    filepath = hf_hub_download(\n+        repo_id=repo_id,\n+        filename=f\"{filename}\",\n+    )\n+\n+    state_dict = torch.load(filepath, map_location=\"cpu\")[\"state_dict\"]\n+    state_dict = {key[9:]: state_dict[key] for key in state_dict}\n+\n+    # Convert state dict using mappings\n+    key_mapping = convert_old_keys_to_new_keys(state_dict.keys())\n+    new_state_dict = {}\n+    for key, value in state_dict.items():\n+        new_key = key_mapping[key]\n+        transformed_value = transform_qkv_weights(new_key, value, config)\n+        if isinstance(transformed_value, dict):\n+            new_state_dict.update(transformed_value)\n+        else:\n+            new_state_dict[new_key] = transformed_value\n+\n+    # load HuggingFace model\n+    model = PromptDepthAnythingForDepthEstimation(config)\n+    model.load_state_dict(new_state_dict, strict=False)\n+    model.eval()\n+\n+    processor = PromptDepthAnythingImageProcessor(\n+        do_resize=True,\n+        size=756,\n+        ensure_multiple_of=14,\n+        keep_aspect_ratio=True,\n+        do_rescale=True,\n+        do_normalize=True,\n+        image_mean=[0.485, 0.456, 0.406],\n+        image_std=[0.229, 0.224, 0.225],\n+    )\n+    url = \"https://github.com/DepthAnything/PromptDA/blob/main/assets/example_images/image.jpg?raw=true\"\n+    image = Image.open(requests.get(url, stream=True).raw)\n+\n+    prompt_depth_url = (\n+        \"https://github.com/DepthAnything/PromptDA/blob/main/assets/example_images/arkit_depth.png?raw=true\"\n+    )\n+    prompt_depth = Image.open(requests.get(prompt_depth_url, stream=True).raw)\n+\n+    inputs = processor(image, return_tensors=\"pt\", prompt_depth=prompt_depth)\n+\n+    # Verify forward pass\n+    with torch.no_grad():\n+        outputs = model(**inputs)\n+        predicted_depth = outputs.predicted_depth\n+\n+    print(\"Shape of predicted depth:\", predicted_depth.shape)\n+    print(\"First values:\", predicted_depth[0, :3, :3])\n+\n+    # assert logits\n+    if verify_logits:\n+        expected_shape = torch.Size([1, 756, 1008])\n+        if model_name == \"prompt-depth-anything-vits\":\n+            expected_slice = torch.tensor(\n+                [[3.0100, 3.0016, 3.0219], [3.0046, 3.0137, 3.0275], [3.0083, 3.0191, 3.0292]]\n+            )\n+        elif model_name == \"prompt-depth-anything-vits-transparent\":\n+            expected_slice = torch.tensor(\n+                [[3.0058, 3.0397, 3.0460], [3.0314, 3.0393, 3.0504], [3.0326, 3.0465, 3.0545]]\n+            )\n+        elif model_name == \"prompt-depth-anything-vitl\":\n+            expected_slice = torch.tensor(\n+                [[3.1336, 3.1358, 3.1363], [3.1368, 3.1267, 3.1414], [3.1397, 3.1385, 3.1448]]\n+            )\n+        else:\n+            raise ValueError(\"Not supported\")\n+        assert predicted_depth.shape == torch.Size(expected_shape)\n+        assert torch.allclose(predicted_depth[0, :3, :3], expected_slice, atol=5e-3)  # 5mm tolerance\n+        print(\"Looks ok!\")\n+\n+    if pytorch_dump_folder_path is not None:\n+        Path(pytorch_dump_folder_path).mkdir(exist_ok=True)\n+        print(f\"Saving model and processor to {pytorch_dump_folder_path}\")\n+        model.save_pretrained(pytorch_dump_folder_path)\n+        processor.save_pretrained(pytorch_dump_folder_path)\n+\n+    if push_to_hub:\n+        print(\"Pushing model and processor to hub...\")\n+        model.push_to_hub(repo_id=f\"{model_name.title()}-hf\")\n+        processor.push_to_hub(repo_id=f\"{model_name.title()}-hf\")\n+\n+\n+name_to_checkpoint = {\n+    \"prompt-depth-anything-vits\": \"model.ckpt\",\n+    \"prompt-depth-anything-vits-transparent\": \"model.ckpt\",\n+    \"prompt-depth-anything-vitl\": \"model.ckpt\",\n+}\n+\n+\n+if __name__ == \"__main__\":\n+    parser = argparse.ArgumentParser()\n+    # Required parameters\n+    parser.add_argument(\n+        \"--model_name\",\n+        default=\"prompt_depth_anything_vits\",\n+        type=str,\n+        choices=name_to_checkpoint.keys(),\n+        help=\"Name of the model you'd like to convert.\",\n+    )\n+    parser.add_argument(\n+        \"--pytorch_dump_folder_path\",\n+        default=None,\n+        type=str,\n+        help=\"Path to the output PyTorch model directory.\",\n+    )\n+    parser.add_argument(\n+        \"--push_to_hub\",\n+        action=\"store_true\",\n+        help=\"Whether to push the model to the hub after conversion.\",\n+    )\n+    parser.add_argument(\n+        \"--verify_logits\",\n+        action=\"store_false\",\n+        required=False,\n+        help=\"Whether to verify the logits after conversion.\",\n+    )\n+\n+    args = parser.parse_args()\n+    convert_dpt_checkpoint(args.model_name, args.pytorch_dump_folder_path, args.push_to_hub, args.verify_logits)"
        },
        {
            "sha": "b4fdea0d4c11455cde0f345627430a873b00b22d",
            "filename": "src/transformers/models/prompt_depth_anything/image_processing_prompt_depth_anything.py",
            "status": "added",
            "additions": 504,
            "deletions": 0,
            "changes": 504,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fimage_processing_prompt_depth_anything.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fimage_processing_prompt_depth_anything.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fimage_processing_prompt_depth_anything.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -0,0 +1,504 @@\n+# Copyright 2024 The HuggingFace Team. All rights reserved.\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Image processor class for PromptDepthAnything.\"\"\"\n+\n+import math\n+from typing import TYPE_CHECKING, Dict, Iterable, List, Optional, Tuple, Union\n+\n+\n+if TYPE_CHECKING:\n+    from ...modeling_outputs import DepthEstimatorOutput\n+\n+import numpy as np\n+\n+from ...image_processing_utils import BaseImageProcessor, BatchFeature, get_size_dict\n+from ...image_transforms import pad, resize, to_channel_dimension_format\n+from ...image_utils import (\n+    IMAGENET_STANDARD_MEAN,\n+    IMAGENET_STANDARD_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    is_scaled_image,\n+    is_torch_available,\n+    make_list_of_images,\n+    to_numpy_array,\n+    valid_images,\n+    validate_preprocess_arguments,\n+)\n+from ...utils import (\n+    TensorType,\n+    filter_out_non_signature_kwargs,\n+    logging,\n+    requires_backends,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+def _constrain_to_multiple_of(val, multiple, min_val=0, max_val=None):\n+    x = round(val / multiple) * multiple\n+\n+    if max_val is not None and x > max_val:\n+        x = math.floor(val / multiple) * multiple\n+\n+    if x < min_val:\n+        x = math.ceil(val / multiple) * multiple\n+\n+    return x\n+\n+\n+def _get_resize_output_image_size(\n+    input_image: np.ndarray,\n+    output_size: Union[int, Iterable[int]],\n+    keep_aspect_ratio: bool,\n+    multiple: int,\n+    input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+) -> Tuple[int, int]:\n+    output_size = (output_size, output_size) if isinstance(output_size, int) else output_size\n+\n+    input_height, input_width = get_image_size(input_image, input_data_format)\n+    output_height, output_width = output_size\n+\n+    # determine new height and width\n+    scale_height = output_height / input_height\n+    scale_width = output_width / input_width\n+\n+    if keep_aspect_ratio:\n+        # scale as little as possible\n+        if abs(1 - scale_width) < abs(1 - scale_height):\n+            # fit width\n+            scale_height = scale_width\n+        else:\n+            # fit height\n+            scale_width = scale_height\n+\n+    new_height = _constrain_to_multiple_of(scale_height * input_height, multiple=multiple)\n+    new_width = _constrain_to_multiple_of(scale_width * input_width, multiple=multiple)\n+\n+    return (new_height, new_width)\n+\n+\n+class PromptDepthAnythingImageProcessor(BaseImageProcessor):\n+    r\"\"\"\n+    Constructs a PromptDepthAnything image processor.\n+\n+    Args:\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image's (height, width) dimensions. Can be overidden by `do_resize` in `preprocess`.\n+        size (`Dict[str, int]` *optional*, defaults to `{\"height\": 384, \"width\": 384}`):\n+            Size of the image after resizing. Can be overidden by `size` in `preprocess`.\n+        resample (`PILImageResampling`, *optional*, defaults to `Resampling.BICUBIC`):\n+            Defines the resampling filter to use if resizing the image. Can be overidden by `resample` in `preprocess`.\n+        keep_aspect_ratio (`bool`, *optional*, defaults to `False`):\n+            If `True`, the image is resized to the largest possible size such that the aspect ratio is preserved. Can\n+            be overidden by `keep_aspect_ratio` in `preprocess`.\n+        ensure_multiple_of (`int`, *optional*, defaults to 1):\n+            If `do_resize` is `True`, the image is resized to a size that is a multiple of this value. Can be overidden\n+            by `ensure_multiple_of` in `preprocess`.\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image by the specified scale `rescale_factor`. Can be overidden by `do_rescale` in\n+            `preprocess`.\n+        rescale_factor (`int` or `float`, *optional*, defaults to `1/255`):\n+            Scale factor to use if rescaling the image. Can be overidden by `rescale_factor` in `preprocess`.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image. Can be overridden by the `do_normalize` parameter in the `preprocess`\n+            method.\n+        image_mean (`float` or `List[float]`, *optional*, defaults to `IMAGENET_STANDARD_MEAN`):\n+            Mean to use if normalizing the image. This is a float or list of floats the length of the number of\n+            channels in the image. Can be overridden by the `image_mean` parameter in the `preprocess` method.\n+        image_std (`float` or `List[float]`, *optional*, defaults to `IMAGENET_STANDARD_STD`):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats the length of the\n+            number of channels in the image. Can be overridden by the `image_std` parameter in the `preprocess` method.\n+        do_pad (`bool`, *optional*, defaults to `False`):\n+            Whether to apply center padding. This was introduced in the DINOv2 paper, which uses the model in\n+            combination with DPT.\n+        size_divisor (`int`, *optional*):\n+            If `do_pad` is `True`, pads the image dimensions to be divisible by this value. This was introduced in the\n+            DINOv2 paper, which uses the model in combination with DPT.\n+        prompt_scale_to_meter (`float`, *optional*, defaults to 0.001):\n+            Scale factor to convert the prompt depth to meters.\n+    \"\"\"\n+\n+    model_input_names = [\"pixel_values\", \"prompt_depth\"]\n+\n+    def __init__(\n+        self,\n+        do_resize: bool = True,\n+        size: Dict[str, int] = None,\n+        resample: PILImageResampling = PILImageResampling.BICUBIC,\n+        keep_aspect_ratio: bool = False,\n+        ensure_multiple_of: int = 1,\n+        do_rescale: bool = True,\n+        rescale_factor: Union[int, float] = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_pad: bool = False,\n+        size_divisor: int = None,\n+        prompt_scale_to_meter: float = 0.001,  # default unit is mm\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+        size = size if size is not None else {\"height\": 384, \"width\": 384}\n+        size = get_size_dict(size)\n+        self.do_resize = do_resize\n+        self.size = size\n+        self.keep_aspect_ratio = keep_aspect_ratio\n+        self.ensure_multiple_of = ensure_multiple_of\n+        self.resample = resample\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean if image_mean is not None else IMAGENET_STANDARD_MEAN\n+        self.image_std = image_std if image_std is not None else IMAGENET_STANDARD_STD\n+        self.do_pad = do_pad\n+        self.size_divisor = size_divisor\n+        self.prompt_scale_to_meter = prompt_scale_to_meter\n+\n+    def resize(\n+        self,\n+        image: np.ndarray,\n+        size: Dict[str, int],\n+        keep_aspect_ratio: bool = False,\n+        ensure_multiple_of: int = 1,\n+        resample: PILImageResampling = PILImageResampling.BICUBIC,\n+        data_format: Optional[Union[str, ChannelDimension]] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+        **kwargs,\n+    ) -> np.ndarray:\n+        \"\"\"\n+        Resize an image to target size `(size[\"height\"], size[\"width\"])`. If `keep_aspect_ratio` is `True`, the image\n+        is resized to the largest possible size such that the aspect ratio is preserved. If `ensure_multiple_of` is\n+        set, the image is resized to a size that is a multiple of this value.\n+\n+        Args:\n+            image (`np.ndarray`):\n+                Image to resize.\n+            size (`Dict[str, int]`):\n+                Target size of the output image.\n+            keep_aspect_ratio (`bool`, *optional*, defaults to `False`):\n+                If `True`, the image is resized to the largest possible size such that the aspect ratio is preserved.\n+            ensure_multiple_of (`int`, *optional*, defaults to 1):\n+                The image is resized to a size that is a multiple of this value.\n+            resample (`PILImageResampling`, *optional*, defaults to `PILImageResampling.BICUBIC`):\n+                Resampling filter to use when resiizing the image.\n+            data_format (`str` or `ChannelDimension`, *optional*):\n+                The channel dimension format of the image. If not provided, it will be the same as the input image.\n+            input_data_format (`str` or `ChannelDimension`, *optional*):\n+                The channel dimension format of the input image. If not provided, it will be inferred.\n+        \"\"\"\n+        size = get_size_dict(size)\n+        if \"height\" not in size or \"width\" not in size:\n+            raise ValueError(f\"The size dictionary must contain the keys 'height' and 'width'. Got {size.keys()}\")\n+\n+        output_size = _get_resize_output_image_size(\n+            image,\n+            output_size=(size[\"height\"], size[\"width\"]),\n+            keep_aspect_ratio=keep_aspect_ratio,\n+            multiple=ensure_multiple_of,\n+            input_data_format=input_data_format,\n+        )\n+        return resize(\n+            image,\n+            size=output_size,\n+            resample=resample,\n+            data_format=data_format,\n+            input_data_format=input_data_format,\n+            **kwargs,\n+        )\n+\n+    def pad_image(\n+        self,\n+        image: np.ndarray,\n+        size_divisor: int,\n+        data_format: Optional[Union[str, ChannelDimension]] = None,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Center pad an image to be a multiple of `multiple`.\n+\n+        Args:\n+            image (`np.ndarray`):\n+                Image to pad.\n+            size_divisor (`int`):\n+                The width and height of the image will be padded to a multiple of this number.\n+            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n+                from the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+\n+        def _get_pad(size, size_divisor):\n+            new_size = math.ceil(size / size_divisor) * size_divisor\n+            pad_size = new_size - size\n+            pad_size_left = pad_size // 2\n+            pad_size_right = pad_size - pad_size_left\n+            return pad_size_left, pad_size_right\n+\n+        if input_data_format is None:\n+            input_data_format = infer_channel_dimension_format(image)\n+\n+        height, width = get_image_size(image, input_data_format)\n+\n+        pad_size_left, pad_size_right = _get_pad(height, size_divisor)\n+        pad_size_top, pad_size_bottom = _get_pad(width, size_divisor)\n+\n+        padded_image = pad(\n+            image, ((pad_size_left, pad_size_right), (pad_size_top, pad_size_bottom)), data_format=data_format\n+        )\n+        return padded_image\n+\n+    @filter_out_non_signature_kwargs()\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        prompt_depth: Optional[ImageInput] = None,\n+        do_resize: Optional[bool] = None,\n+        size: Optional[int] = None,\n+        keep_aspect_ratio: Optional[bool] = None,\n+        ensure_multiple_of: Optional[int] = None,\n+        resample: Optional[PILImageResampling] = None,\n+        do_rescale: Optional[bool] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_pad: Optional[bool] = None,\n+        size_divisor: Optional[int] = None,\n+        prompt_scale_to_meter: Optional[float] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        data_format: ChannelDimension = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Preprocess an image or batch of images.\n+\n+        Args:\n+            images (`ImageInput`):\n+                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n+                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n+            prompt_depth (`ImageInput`, *optional*):\n+                Prompt depth to preprocess, which can be sparse depth obtained from multi-view geometry or\n+                low-resolution depth from a depth sensor. Generally has shape (height, width), where height\n+                and width can be smaller than those of the images. It's optional and can be None, which means no prompt depth\n+                is used. If it is None, the output depth will be a monocular relative depth.\n+                It is recommended to provide a prompt_scale_to_meter value, which is the scale factor to convert the prompt depth\n+                to meters. This is useful when the prompt depth is not in meters.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. If `keep_aspect_ratio` is `True`, the image is resized to the largest\n+                possible size such that the aspect ratio is preserved. If `ensure_multiple_of` is set, the image is\n+                resized to a size that is a multiple of this value.\n+            keep_aspect_ratio (`bool`, *optional*, defaults to `self.keep_aspect_ratio`):\n+                Whether to keep the aspect ratio of the image. If False, the image will be resized to (size, size). If\n+                True, the image will be resized to keep the aspect ratio and the size will be the maximum possible.\n+            ensure_multiple_of (`int`, *optional*, defaults to `self.ensure_multiple_of`):\n+                Ensure that the image size is a multiple of this value.\n+            resample (`int`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`, Only\n+                has an effect if `do_resize` is set to `True`.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image values between [0 - 1].\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Image mean.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Image standard deviation.\n+            prompt_scale_to_meter (`float`, *optional*, defaults to `self.prompt_scale_to_meter`):\n+                Scale factor to convert the prompt depth to meters.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                    - Unset: Return a list of `np.ndarray`.\n+                    - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n+                    - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                    - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+                    - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n+            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                    - `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                    - `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n+                from the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+        do_resize = do_resize if do_resize is not None else self.do_resize\n+        size = size if size is not None else self.size\n+        size = get_size_dict(size)\n+        keep_aspect_ratio = keep_aspect_ratio if keep_aspect_ratio is not None else self.keep_aspect_ratio\n+        ensure_multiple_of = ensure_multiple_of if ensure_multiple_of is not None else self.ensure_multiple_of\n+        resample = resample if resample is not None else self.resample\n+        do_rescale = do_rescale if do_rescale is not None else self.do_rescale\n+        rescale_factor = rescale_factor if rescale_factor is not None else self.rescale_factor\n+        do_normalize = do_normalize if do_normalize is not None else self.do_normalize\n+        image_mean = image_mean if image_mean is not None else self.image_mean\n+        image_std = image_std if image_std is not None else self.image_std\n+        do_pad = do_pad if do_pad is not None else self.do_pad\n+        size_divisor = size_divisor if size_divisor is not None else self.size_divisor\n+\n+        images = make_list_of_images(images)\n+\n+        if not valid_images(images):\n+            raise ValueError(\n+                \"Invalid image type. Must be of type PIL.Image.Image, numpy.ndarray, \"\n+                \"torch.Tensor, tf.Tensor or jax.ndarray.\"\n+            )\n+        validate_preprocess_arguments(\n+            do_rescale=do_rescale,\n+            rescale_factor=rescale_factor,\n+            do_normalize=do_normalize,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            do_pad=do_pad,\n+            size_divisibility=size_divisor,\n+            do_resize=do_resize,\n+            size=size,\n+            resample=resample,\n+        )\n+        # All transformations expect numpy arrays.\n+        images = [to_numpy_array(image) for image in images]\n+\n+        if is_scaled_image(images[0]) and do_rescale:\n+            logger.warning_once(\n+                \"It looks like you are trying to rescale already rescaled images. If the input\"\n+                \" images have pixel values between 0 and 1, set `do_rescale=False` to avoid rescaling them again.\"\n+            )\n+\n+        if input_data_format is None:\n+            # We assume that all images have the same channel dimension format.\n+            input_data_format = infer_channel_dimension_format(images[0])\n+\n+        preprocessed_images = []\n+        for image in images:\n+            if do_resize:\n+                image = self.resize(\n+                    image=image,\n+                    size=size,\n+                    resample=resample,\n+                    keep_aspect_ratio=keep_aspect_ratio,\n+                    ensure_multiple_of=ensure_multiple_of,\n+                    input_data_format=input_data_format,\n+                )\n+\n+            if do_rescale:\n+                image = self.rescale(image=image, scale=rescale_factor, input_data_format=input_data_format)\n+\n+            if do_normalize:\n+                image = self.normalize(\n+                    image=image, mean=image_mean, std=image_std, input_data_format=input_data_format\n+                )\n+\n+            if do_pad:\n+                image = self.pad_image(image=image, size_divisor=size_divisor, input_data_format=input_data_format)\n+\n+            image = to_channel_dimension_format(image, data_format, input_channel_dim=input_data_format)\n+            preprocessed_images.append(image)\n+\n+        images = preprocessed_images\n+\n+        data = {\"pixel_values\": images}\n+        if prompt_depth is not None:\n+            # prompt_depth is a list of images with shape (height, width)\n+            # we need to convert it to a list of images with shape (1, height, width)\n+            prompt_depths = make_list_of_images(prompt_depth, expected_ndims=2)\n+\n+            # Validate prompt_depths has same length as images\n+            if len(prompt_depths) != len(images):\n+                raise ValueError(\n+                    f\"Number of prompt depth images ({len(prompt_depths)}) does not match number of input images ({len(images)})\"\n+                )\n+\n+            if prompt_scale_to_meter is None:\n+                prompt_scale_to_meter = self.prompt_scale_to_meter\n+\n+            processed_prompt_depths = []\n+            for depth in prompt_depths:\n+                depth = to_numpy_array(depth)\n+                depth = depth * prompt_scale_to_meter\n+                if depth.min() == depth.max():\n+                    # Prompt depth is invalid, min and max are the same.\n+                    # We can simply select one pixel and set it to a small value.\n+                    depth[0, 0] = depth[0, 0] + 1e-6\n+                depth = depth[..., None].astype(np.float32)\n+                depth = to_channel_dimension_format(depth, data_format, input_channel_dim=input_data_format)\n+\n+                processed_prompt_depths.append(depth)\n+            prompt_depths = processed_prompt_depths\n+            data[\"prompt_depth\"] = prompt_depths\n+        return BatchFeature(data=data, tensor_type=return_tensors)\n+\n+    # Copied from transformers.models.dpt.image_processing_dpt.DPTImageProcessor.post_process_depth_estimation with DPT->PromptDepthAnything\n+    def post_process_depth_estimation(\n+        self,\n+        outputs: \"DepthEstimatorOutput\",\n+        target_sizes: Optional[Union[TensorType, List[Tuple[int, int]], None]] = None,\n+    ) -> List[Dict[str, TensorType]]:\n+        \"\"\"\n+        Converts the raw output of [`DepthEstimatorOutput`] into final depth predictions and depth PIL images.\n+        Only supports PyTorch.\n+\n+        Args:\n+            outputs ([`DepthEstimatorOutput`]):\n+                Raw outputs of the model.\n+            target_sizes (`TensorType` or `List[Tuple[int, int]]`, *optional*):\n+                Tensor of shape `(batch_size, 2)` or list of tuples (`Tuple[int, int]`) containing the target size\n+                (height, width) of each image in the batch. If left to None, predictions will not be resized.\n+\n+        Returns:\n+            `List[Dict[str, TensorType]]`: A list of dictionaries of tensors representing the processed depth\n+            predictions.\n+        \"\"\"\n+        requires_backends(self, \"torch\")\n+\n+        predicted_depth = outputs.predicted_depth\n+\n+        if (target_sizes is not None) and (len(predicted_depth) != len(target_sizes)):\n+            raise ValueError(\n+                \"Make sure that you pass in as many target sizes as the batch dimension of the predicted depth\"\n+            )\n+\n+        results = []\n+        target_sizes = [None] * len(predicted_depth) if target_sizes is None else target_sizes\n+        for depth, target_size in zip(predicted_depth, target_sizes):\n+            if target_size is not None:\n+                depth = torch.nn.functional.interpolate(\n+                    depth.unsqueeze(0).unsqueeze(1), size=target_size, mode=\"bicubic\", align_corners=False\n+                ).squeeze()\n+\n+            results.append({\"predicted_depth\": depth})\n+\n+        return results\n+\n+\n+__all__ = [\"PromptDepthAnythingImageProcessor\"]"
        },
        {
            "sha": "7653a72f06955b81fbaa60037205bb7881deb989",
            "filename": "src/transformers/models/prompt_depth_anything/modeling_prompt_depth_anything.py",
            "status": "added",
            "additions": 546,
            "deletions": 0,
            "changes": 546,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fmodeling_prompt_depth_anything.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fmodeling_prompt_depth_anything.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fmodeling_prompt_depth_anything.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -0,0 +1,546 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/prompt_depth_anything/modular_prompt_depth_anything.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_prompt_depth_anything.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+import torch.nn as nn\n+\n+from transformers.utils.generic import torch_int\n+\n+from ...file_utils import add_start_docstrings, add_start_docstrings_to_model_forward, replace_return_docstrings\n+from ...modeling_outputs import DepthEstimatorOutput\n+from ...modeling_utils import PreTrainedModel\n+from ...utils.backbone_utils import load_backbone\n+from .configuration_prompt_depth_anything import PromptDepthAnythingConfig\n+\n+\n+_CONFIG_FOR_DOC = \"PromptDepthAnythingConfig\"\n+\n+\n+class PromptDepthAnythingLayer(nn.Module):\n+    def __init__(self, config: PromptDepthAnythingConfig):\n+        super().__init__()\n+        self.convolution1 = nn.Conv2d(\n+            1,\n+            config.fusion_hidden_size,\n+            kernel_size=3,\n+            stride=1,\n+            padding=1,\n+            bias=True,\n+        )\n+        self.activation1 = nn.ReLU()\n+\n+        self.convolution2 = nn.Conv2d(\n+            config.fusion_hidden_size,\n+            config.fusion_hidden_size,\n+            kernel_size=3,\n+            stride=1,\n+            padding=1,\n+            bias=True,\n+        )\n+        self.activation2 = nn.ReLU()\n+\n+        self.convolution3 = nn.Conv2d(\n+            config.fusion_hidden_size,\n+            config.fusion_hidden_size,\n+            kernel_size=3,\n+            stride=1,\n+            padding=1,\n+            bias=True,\n+        )\n+\n+    def forward(self, prompt_depth: torch.Tensor) -> torch.Tensor:\n+        hidden_state = self.convolution1(prompt_depth)\n+        hidden_state = self.activation1(hidden_state)\n+        hidden_state = self.convolution2(hidden_state)\n+        hidden_state = self.activation2(hidden_state)\n+        hidden_state = self.convolution3(hidden_state)\n+        return hidden_state\n+\n+\n+class PromptDepthAnythingPreActResidualLayer(nn.Module):\n+    \"\"\"\n+    ResidualConvUnit, pre-activate residual unit.\n+\n+    Args:\n+        config (`[PromptDepthAnythingConfig]`):\n+            Model configuration class defining the model architecture.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+\n+        self.activation1 = nn.ReLU()\n+        self.convolution1 = nn.Conv2d(\n+            config.fusion_hidden_size,\n+            config.fusion_hidden_size,\n+            kernel_size=3,\n+            stride=1,\n+            padding=1,\n+            bias=True,\n+        )\n+\n+        self.activation2 = nn.ReLU()\n+        self.convolution2 = nn.Conv2d(\n+            config.fusion_hidden_size,\n+            config.fusion_hidden_size,\n+            kernel_size=3,\n+            stride=1,\n+            padding=1,\n+            bias=True,\n+        )\n+\n+    def forward(self, hidden_state: torch.Tensor) -> torch.Tensor:\n+        residual = hidden_state\n+        hidden_state = self.activation1(hidden_state)\n+        hidden_state = self.convolution1(hidden_state)\n+        hidden_state = self.activation2(hidden_state)\n+        hidden_state = self.convolution2(hidden_state)\n+\n+        return hidden_state + residual\n+\n+\n+class PromptDepthAnythingFeatureFusionLayer(nn.Module):\n+    \"\"\"Feature fusion layer, merges feature maps from different stages.\n+\n+    Args:\n+        config (`[PromptDepthAnythingConfig]`):\n+            Model configuration class defining the model architecture.\n+    \"\"\"\n+\n+    def __init__(self, config: PromptDepthAnythingConfig):\n+        super().__init__()\n+\n+        self.projection = nn.Conv2d(config.fusion_hidden_size, config.fusion_hidden_size, kernel_size=1, bias=True)\n+\n+        self.residual_layer1 = PromptDepthAnythingPreActResidualLayer(config)\n+        self.residual_layer2 = PromptDepthAnythingPreActResidualLayer(config)\n+        self.prompt_depth_layer = PromptDepthAnythingLayer(config)\n+\n+    def forward(self, hidden_state, residual=None, size=None, prompt_depth=None):\n+        if residual is not None:\n+            if hidden_state.shape != residual.shape:\n+                residual = nn.functional.interpolate(\n+                    residual, size=hidden_state.shape[2:], mode=\"bilinear\", align_corners=False\n+                )\n+            hidden_state = hidden_state + self.residual_layer1(residual)\n+\n+        hidden_state = self.residual_layer2(hidden_state)\n+\n+        if prompt_depth is not None:\n+            prompt_depth = nn.functional.interpolate(\n+                prompt_depth, size=hidden_state.shape[2:], mode=\"bilinear\", align_corners=False\n+            )\n+            res = self.prompt_depth_layer(prompt_depth)\n+            hidden_state = hidden_state + res\n+\n+        modifier = {\"scale_factor\": 2} if size is None else {\"size\": size}\n+\n+        hidden_state = nn.functional.interpolate(\n+            hidden_state,\n+            **modifier,\n+            mode=\"bilinear\",\n+            align_corners=True,\n+        )\n+        hidden_state = self.projection(hidden_state)\n+\n+        return hidden_state\n+\n+\n+class PromptDepthAnythingFeatureFusionStage(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.layers = nn.ModuleList()\n+        for _ in range(len(config.neck_hidden_sizes)):\n+            self.layers.append(PromptDepthAnythingFeatureFusionLayer(config))\n+\n+    def forward(self, hidden_states, size=None, prompt_depth=None):\n+        # reversing the hidden_states, we start from the last\n+        hidden_states = hidden_states[::-1]\n+\n+        fused_hidden_states = []\n+        fused_hidden_state = None\n+\n+        for idx, (hidden_state, layer) in enumerate(zip(hidden_states, self.layers)):\n+            size = hidden_states[idx + 1].shape[2:] if idx != (len(hidden_states) - 1) else None\n+\n+            if fused_hidden_state is None:\n+                # first layer only uses the last hidden_state\n+                fused_hidden_state = layer(hidden_state, size=size, prompt_depth=prompt_depth)\n+            else:\n+                fused_hidden_state = layer(fused_hidden_state, hidden_state, size=size, prompt_depth=prompt_depth)\n+\n+            fused_hidden_states.append(fused_hidden_state)\n+\n+        return fused_hidden_states\n+\n+\n+class PromptDepthAnythingDepthEstimationHead(nn.Module):\n+    \"\"\"\n+    Output head consisting of 3 convolutional layers. It progressively halves the feature dimension and upsamples\n+    the predictions to the input resolution after the first convolutional layer (details can be found in the DPT paper's\n+    supplementary material). The final activation function is either ReLU or Sigmoid, depending on the depth estimation\n+    type (relative or metric). For metric depth estimation, the output is scaled by the maximum depth used during pretraining.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+\n+        self.head_in_index = config.head_in_index\n+        self.patch_size = config.patch_size\n+\n+        features = config.fusion_hidden_size\n+        self.conv1 = nn.Conv2d(features, features // 2, kernel_size=3, stride=1, padding=1)\n+        self.conv2 = nn.Conv2d(features // 2, config.head_hidden_size, kernel_size=3, stride=1, padding=1)\n+        self.activation1 = nn.ReLU()\n+        self.conv3 = nn.Conv2d(config.head_hidden_size, 1, kernel_size=1, stride=1, padding=0)\n+        if config.depth_estimation_type == \"relative\":\n+            self.activation2 = nn.ReLU()\n+        elif config.depth_estimation_type == \"metric\":\n+            self.activation2 = nn.Sigmoid()\n+        else:\n+            raise ValueError(f\"Unknown depth estimation type: {config.depth_estimation_type}\")\n+        self.max_depth = config.max_depth\n+\n+    def forward(self, hidden_states: List[torch.Tensor], patch_height: int, patch_width: int) -> torch.Tensor:\n+        hidden_states = hidden_states[-1]\n+\n+        predicted_depth = self.conv1(hidden_states)\n+        target_height = torch_int(patch_height * self.patch_size)\n+        target_width = torch_int(patch_width * self.patch_size)\n+        predicted_depth = nn.functional.interpolate(\n+            predicted_depth,\n+            (target_height, target_width),\n+            mode=\"bilinear\",\n+            align_corners=True,\n+        )\n+        predicted_depth = self.conv2(predicted_depth)\n+        predicted_depth = self.activation1(predicted_depth)\n+        predicted_depth = self.conv3(predicted_depth)\n+        predicted_depth = self.activation2(predicted_depth)\n+        # (batch_size, 1, height, width) -> (batch_size, height, width), which\n+        # keeps the same behavior as Depth Anything v1 & v2\n+        predicted_depth = predicted_depth.squeeze(dim=1)\n+\n+        return predicted_depth\n+\n+\n+class PromptDepthAnythingPreTrainedModel(PreTrainedModel):\n+    \"\"\"\n+    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n+    models.\n+    \"\"\"\n+\n+    config_class = PromptDepthAnythingConfig\n+    base_model_prefix = \"prompt_depth_anything\"\n+    main_input_name = \"pixel_values\"\n+    supports_gradient_checkpointing = True\n+\n+    def _init_weights(self, module):\n+        \"\"\"Initialize the weights\"\"\"\n+        if isinstance(module, (nn.Linear, nn.Conv2d, nn.ConvTranspose2d)):\n+            # Slightly different from the TF version which uses truncated_normal for initialization\n+            # cf https://github.com/pytorch/pytorch/pull/5617\n+            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.LayerNorm):\n+            module.bias.data.zero_()\n+            module.weight.data.fill_(1.0)\n+\n+\n+class PromptDepthAnythingReassembleLayer(nn.Module):\n+    def __init__(self, config: PromptDepthAnythingConfig, channels: int, factor: int):\n+        super().__init__()\n+        self.projection = nn.Conv2d(in_channels=config.reassemble_hidden_size, out_channels=channels, kernel_size=1)\n+\n+        # up/down sampling depending on factor\n+        if factor > 1:\n+            self.resize = nn.ConvTranspose2d(channels, channels, kernel_size=factor, stride=factor, padding=0)\n+        elif factor == 1:\n+            self.resize = nn.Identity()\n+        elif factor < 1:\n+            # so should downsample\n+            stride = torch_int(1 / factor)\n+            self.resize = nn.Conv2d(channels, channels, kernel_size=3, stride=stride, padding=1)\n+\n+    def forward(self, hidden_state):\n+        hidden_state = self.projection(hidden_state)\n+        hidden_state = self.resize(hidden_state)\n+\n+        return hidden_state\n+\n+\n+class PromptDepthAnythingReassembleStage(nn.Module):\n+    \"\"\"\n+    This class reassembles the hidden states of the backbone into image-like feature representations at various\n+    resolutions.\n+\n+    This happens in 3 stages:\n+    1. Take the patch embeddings and reshape them to image-like feature representations.\n+    2. Project the channel dimension of the hidden states according to `config.neck_hidden_sizes`.\n+    3. Resizing the spatial dimensions (height, width).\n+\n+    Args:\n+        config (`[PromptDepthAnythingConfig]`):\n+            Model configuration class defining the model architecture.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+\n+        self.config = config\n+        self.layers = nn.ModuleList()\n+        for channels, factor in zip(config.neck_hidden_sizes, config.reassemble_factors):\n+            self.layers.append(PromptDepthAnythingReassembleLayer(config, channels=channels, factor=factor))\n+\n+    def forward(self, hidden_states: List[torch.Tensor], patch_height=None, patch_width=None) -> List[torch.Tensor]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`List[torch.FloatTensor]`, each of shape `(batch_size, sequence_length + 1, hidden_size)`):\n+                List of hidden states from the backbone.\n+        \"\"\"\n+        out = []\n+\n+        for i, hidden_state in enumerate(hidden_states):\n+            # reshape to (batch_size, num_channels, height, width)\n+            hidden_state = hidden_state[:, 1:]\n+            batch_size, _, num_channels = hidden_state.shape\n+            hidden_state = hidden_state.reshape(batch_size, patch_height, patch_width, num_channels)\n+            hidden_state = hidden_state.permute(0, 3, 1, 2).contiguous()\n+            hidden_state = self.layers[i](hidden_state)\n+            out.append(hidden_state)\n+\n+        return out\n+\n+\n+class PromptDepthAnythingNeck(nn.Module):\n+    \"\"\"\n+    PromptDepthAnythingNeck. A neck is a module that is normally used between the backbone and the head. It takes a list of tensors as\n+    input and produces another list of tensors as output. For PromptDepthAnything, it includes 2 stages:\n+\n+    * PromptDepthAnythingReassembleStage\n+    * PromptDepthAnythingFeatureFusionStage.\n+\n+    Args:\n+        config (dict): config dict.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+        self.config = config\n+\n+        self.reassemble_stage = PromptDepthAnythingReassembleStage(config)\n+\n+        self.convs = nn.ModuleList()\n+        for channel in config.neck_hidden_sizes:\n+            self.convs.append(nn.Conv2d(channel, config.fusion_hidden_size, kernel_size=3, padding=1, bias=False))\n+\n+        # fusion\n+        self.fusion_stage = PromptDepthAnythingFeatureFusionStage(config)\n+\n+    def forward(\n+        self,\n+        hidden_states: List[torch.Tensor],\n+        patch_height: Optional[int] = None,\n+        patch_width: Optional[int] = None,\n+        prompt_depth: Optional[torch.Tensor] = None,\n+    ) -> List[torch.Tensor]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`List[torch.FloatTensor]`, each of shape `(batch_size, sequence_length, hidden_size)` or `(batch_size, hidden_size, height, width)`):\n+                List of hidden states from the backbone.\n+        \"\"\"\n+        if not isinstance(hidden_states, (tuple, list)):\n+            raise TypeError(\"hidden_states should be a tuple or list of tensors\")\n+\n+        if len(hidden_states) != len(self.config.neck_hidden_sizes):\n+            raise ValueError(\"The number of hidden states should be equal to the number of neck hidden sizes.\")\n+\n+        # postprocess hidden states\n+        hidden_states = self.reassemble_stage(hidden_states, patch_height, patch_width)\n+\n+        features = [self.convs[i](feature) for i, feature in enumerate(hidden_states)]\n+\n+        # fusion blocks\n+        output = self.fusion_stage(features, prompt_depth=prompt_depth)\n+\n+        return output\n+\n+\n+PROMPT_DEPTH_ANYTHING_START_DOCSTRING = r\"\"\"\n+    This model is a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass. Use it\n+    as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and\n+    behavior.\n+\n+    Parameters:\n+        config ([`PromptDepthAnythingConfig`]): Model configuration class with all the parameters of the model.\n+            Initializing with a config file does not load the weights associated with the model, only the\n+            configuration. Check out the [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+PROMPT_DEPTH_ANYTHING_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, height, width)`):\n+            Pixel values. Pixel values can be obtained using [`AutoImageProcessor`]. See [`DPTImageProcessor.__call__`]\n+            for details.\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+        prompt_depth (`torch.FloatTensor` of shape `(batch_size, 1, height, width)`, *optional*):\n+            Prompt depth is the sparse or low-resolution depth obtained from multi-view geometry or a\n+            low-resolution depth sensor. It generally has shape (height, width), where height\n+            and width can be smaller than those of the images. It is optional and can be None, which means no prompt depth\n+            will be used. If it is None, the output will be a monocular relative depth.\n+            The values are recommended to be in meters, but this is not necessary.\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~file_utils.ModelOutput`] instead of a plain tuple.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"\"\"\n+    Prompt Depth Anything Model with a depth estimation head on top (consisting of 3 convolutional layers) e.g. for KITTI, NYUv2.\n+    \"\"\",\n+    PROMPT_DEPTH_ANYTHING_START_DOCSTRING,\n+)\n+class PromptDepthAnythingForDepthEstimation(PromptDepthAnythingPreTrainedModel):\n+    _no_split_modules = [\"DPTViTEmbeddings\"]\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+\n+        self.backbone = load_backbone(config)\n+        self.neck = PromptDepthAnythingNeck(config)\n+        self.head = PromptDepthAnythingDepthEstimationHead(config)\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @add_start_docstrings_to_model_forward(PROMPT_DEPTH_ANYTHING_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=DepthEstimatorOutput, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        pixel_values: torch.FloatTensor,\n+        prompt_depth: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Union[Tuple[torch.Tensor], DepthEstimatorOutput]:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, height, width)`, *optional*):\n+            Ground truth depth estimation maps for computing the loss.\n+\n+        Returns:\n+\n+        Examples:\n+\n+        ```python\n+        >>> from transformers import AutoImageProcessor, AutoModelForDepthEstimation\n+        >>> import torch\n+        >>> import numpy as np\n+        >>> from PIL import Image\n+        >>> import requests\n+\n+        >>> url = \"https://github.com/DepthAnything/PromptDA/blob/main/assets/example_images/image.jpg?raw=true\"\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> image_processor = AutoImageProcessor.from_pretrained(\"depth-anything/prompt-depth-anything-vits-hf\")\n+        >>> model = AutoModelForDepthEstimation.from_pretrained(\"depth-anything/prompt-depth-anything-vits-hf\")\n+\n+        >>> prompt_depth_url = \"https://github.com/DepthAnything/PromptDA/blob/main/assets/example_images/arkit_depth.png?raw=true\"\n+        >>> prompt_depth = Image.open(requests.get(prompt_depth_url, stream=True).raw)\n+\n+        >>> # prepare image for the model\n+        >>> inputs = image_processor(images=image, return_tensors=\"pt\", prompt_depth=prompt_depth)\n+\n+        >>> with torch.no_grad():\n+        ...     outputs = model(**inputs)\n+\n+        >>> # interpolate to original size\n+        >>> post_processed_output = image_processor.post_process_depth_estimation(\n+        ...     outputs,\n+        ...     target_sizes=[(image.height, image.width)],\n+        ... )\n+\n+        >>> # visualize the prediction\n+        >>> predicted_depth = post_processed_output[0][\"predicted_depth\"]\n+        >>> depth = predicted_depth * 1000.\n+        >>> depth = depth.detach().cpu().numpy()\n+        >>> depth = Image.fromarray(depth.astype(\"uint16\")) # mm\n+        ```\"\"\"\n+        loss = None\n+        if labels is not None:\n+            raise NotImplementedError(\"Training is not implemented yet\")\n+\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+\n+        outputs = self.backbone.forward_with_filtered_kwargs(\n+            pixel_values, output_hidden_states=output_hidden_states, output_attentions=output_attentions\n+        )\n+        hidden_states = outputs.feature_maps\n+\n+        _, _, height, width = pixel_values.shape\n+        patch_size = self.config.patch_size\n+        patch_height = height // patch_size\n+        patch_width = width // patch_size\n+\n+        if prompt_depth is not None:\n+            # normalize prompt depth\n+            batch_size = prompt_depth.shape[0]\n+            depth_min = torch.min(prompt_depth.reshape(batch_size, -1), dim=1).values\n+            depth_max = torch.max(prompt_depth.reshape(batch_size, -1), dim=1).values\n+            depth_min, depth_max = depth_min.view(batch_size, 1, 1, 1), depth_max.view(batch_size, 1, 1, 1)\n+            prompt_depth = (prompt_depth - depth_min) / (depth_max - depth_min)\n+            # normalize done\n+\n+        hidden_states = self.neck(hidden_states, patch_height, patch_width, prompt_depth=prompt_depth)\n+\n+        predicted_depth = self.head(hidden_states, patch_height, patch_width)\n+        if prompt_depth is not None:\n+            # denormalize predicted depth\n+            depth_min = depth_min.squeeze(1).to(predicted_depth.device)\n+            depth_max = depth_max.squeeze(1).to(predicted_depth.device)\n+            predicted_depth = predicted_depth * (depth_max - depth_min) + depth_min\n+            # denormalize done\n+\n+        if not return_dict:\n+            if output_hidden_states:\n+                output = (predicted_depth,) + outputs[1:]\n+            else:\n+                output = (predicted_depth,) + outputs[2:]\n+            return ((loss,) + output) if loss is not None else output\n+\n+        return DepthEstimatorOutput(\n+            loss=loss,\n+            predicted_depth=predicted_depth,\n+            hidden_states=outputs.hidden_states if output_hidden_states else None,\n+            attentions=outputs.attentions,\n+        )\n+\n+\n+__all__ = [\"PromptDepthAnythingForDepthEstimation\", \"PromptDepthAnythingPreTrainedModel\"]"
        },
        {
            "sha": "ad9b254a8a267d703e775aef532d0005e36bb5b6",
            "filename": "src/transformers/models/prompt_depth_anything/modular_prompt_depth_anything.py",
            "status": "added",
            "additions": 391,
            "deletions": 0,
            "changes": 391,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fmodular_prompt_depth_anything.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fmodular_prompt_depth_anything.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fprompt_depth_anything%2Fmodular_prompt_depth_anything.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -0,0 +1,391 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+import torch.nn as nn\n+\n+from transformers.models.depth_anything.configuration_depth_anything import DepthAnythingConfig\n+from transformers.models.depth_anything.modeling_depth_anything import (\n+    DepthAnythingDepthEstimationHead,\n+    DepthAnythingFeatureFusionLayer,\n+    DepthAnythingFeatureFusionStage,\n+    DepthAnythingForDepthEstimation,\n+    DepthAnythingNeck,\n+    DepthAnythingReassembleStage,\n+)\n+from transformers.utils.generic import torch_int\n+\n+from ...file_utils import (\n+    add_start_docstrings,\n+    add_start_docstrings_to_model_forward,\n+    replace_return_docstrings,\n+)\n+from ...modeling_outputs import DepthEstimatorOutput\n+from ...modeling_utils import PreTrainedModel\n+\n+\n+_CONFIG_FOR_DOC = \"PromptDepthAnythingConfig\"\n+\n+\n+class PromptDepthAnythingConfig(DepthAnythingConfig):\n+    model_type = \"prompt_depth_anything\"\n+\n+\n+class PromptDepthAnythingLayer(nn.Module):\n+    def __init__(self, config: PromptDepthAnythingConfig):\n+        super().__init__()\n+        self.convolution1 = nn.Conv2d(\n+            1,\n+            config.fusion_hidden_size,\n+            kernel_size=3,\n+            stride=1,\n+            padding=1,\n+            bias=True,\n+        )\n+        self.activation1 = nn.ReLU()\n+\n+        self.convolution2 = nn.Conv2d(\n+            config.fusion_hidden_size,\n+            config.fusion_hidden_size,\n+            kernel_size=3,\n+            stride=1,\n+            padding=1,\n+            bias=True,\n+        )\n+        self.activation2 = nn.ReLU()\n+\n+        self.convolution3 = nn.Conv2d(\n+            config.fusion_hidden_size,\n+            config.fusion_hidden_size,\n+            kernel_size=3,\n+            stride=1,\n+            padding=1,\n+            bias=True,\n+        )\n+\n+    def forward(self, prompt_depth: torch.Tensor) -> torch.Tensor:\n+        hidden_state = self.convolution1(prompt_depth)\n+        hidden_state = self.activation1(hidden_state)\n+        hidden_state = self.convolution2(hidden_state)\n+        hidden_state = self.activation2(hidden_state)\n+        hidden_state = self.convolution3(hidden_state)\n+        return hidden_state\n+\n+\n+class PromptDepthAnythingFeatureFusionLayer(DepthAnythingFeatureFusionLayer):\n+    def __init__(self, config: PromptDepthAnythingConfig):\n+        super().__init__(config)\n+        self.prompt_depth_layer = PromptDepthAnythingLayer(config)\n+\n+    def forward(self, hidden_state, residual=None, size=None, prompt_depth=None):\n+        if residual is not None:\n+            if hidden_state.shape != residual.shape:\n+                residual = nn.functional.interpolate(\n+                    residual, size=hidden_state.shape[2:], mode=\"bilinear\", align_corners=False\n+                )\n+            hidden_state = hidden_state + self.residual_layer1(residual)\n+\n+        hidden_state = self.residual_layer2(hidden_state)\n+\n+        if prompt_depth is not None:\n+            prompt_depth = nn.functional.interpolate(\n+                prompt_depth, size=hidden_state.shape[2:], mode=\"bilinear\", align_corners=False\n+            )\n+            res = self.prompt_depth_layer(prompt_depth)\n+            hidden_state = hidden_state + res\n+\n+        modifier = {\"scale_factor\": 2} if size is None else {\"size\": size}\n+\n+        hidden_state = nn.functional.interpolate(\n+            hidden_state,\n+            **modifier,\n+            mode=\"bilinear\",\n+            align_corners=True,\n+        )\n+        hidden_state = self.projection(hidden_state)\n+\n+        return hidden_state\n+\n+\n+class PromptDepthAnythingFeatureFusionStage(DepthAnythingFeatureFusionStage):\n+    def forward(self, hidden_states, size=None, prompt_depth=None):\n+        # reversing the hidden_states, we start from the last\n+        hidden_states = hidden_states[::-1]\n+\n+        fused_hidden_states = []\n+        fused_hidden_state = None\n+\n+        for idx, (hidden_state, layer) in enumerate(zip(hidden_states, self.layers)):\n+            size = hidden_states[idx + 1].shape[2:] if idx != (len(hidden_states) - 1) else None\n+\n+            if fused_hidden_state is None:\n+                # first layer only uses the last hidden_state\n+                fused_hidden_state = layer(hidden_state, size=size, prompt_depth=prompt_depth)\n+            else:\n+                fused_hidden_state = layer(fused_hidden_state, hidden_state, size=size, prompt_depth=prompt_depth)\n+\n+            fused_hidden_states.append(fused_hidden_state)\n+\n+        return fused_hidden_states\n+\n+\n+class PromptDepthAnythingDepthEstimationHead(DepthAnythingDepthEstimationHead):\n+    def forward(self, hidden_states: List[torch.Tensor], patch_height: int, patch_width: int) -> torch.Tensor:\n+        hidden_states = hidden_states[-1]\n+\n+        predicted_depth = self.conv1(hidden_states)\n+        target_height = torch_int(patch_height * self.patch_size)\n+        target_width = torch_int(patch_width * self.patch_size)\n+        predicted_depth = nn.functional.interpolate(\n+            predicted_depth,\n+            (target_height, target_width),\n+            mode=\"bilinear\",\n+            align_corners=True,\n+        )\n+        predicted_depth = self.conv2(predicted_depth)\n+        predicted_depth = self.activation1(predicted_depth)\n+        predicted_depth = self.conv3(predicted_depth)\n+        predicted_depth = self.activation2(predicted_depth)\n+        # (batch_size, 1, height, width) -> (batch_size, height, width), which\n+        # keeps the same behavior as Depth Anything v1 & v2\n+        predicted_depth = predicted_depth.squeeze(dim=1)\n+\n+        return predicted_depth\n+\n+\n+PROMPT_DEPTH_ANYTHING_START_DOCSTRING = r\"\"\"\n+    This model is a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass. Use it\n+    as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and\n+    behavior.\n+\n+    Parameters:\n+        config ([`PromptDepthAnythingConfig`]): Model configuration class with all the parameters of the model.\n+            Initializing with a config file does not load the weights associated with the model, only the\n+            configuration. Check out the [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+PROMPT_DEPTH_ANYTHING_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, height, width)`):\n+            Pixel values. Pixel values can be obtained using [`AutoImageProcessor`]. See [`DPTImageProcessor.__call__`]\n+            for details.\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+        prompt_depth (`torch.FloatTensor` of shape `(batch_size, 1, height, width)`, *optional*):\n+            Prompt depth is the sparse or low-resolution depth obtained from multi-view geometry or a\n+            low-resolution depth sensor. It generally has shape (height, width), where height\n+            and width can be smaller than those of the images. It is optional and can be None, which means no prompt depth\n+            will be used. If it is None, the output will be a monocular relative depth.\n+            The values are recommended to be in meters, but this is not necessary.\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~file_utils.ModelOutput`] instead of a plain tuple.\n+\"\"\"\n+\n+\n+class PromptDepthAnythingPreTrainedModel(PreTrainedModel):\n+    \"\"\"\n+    An abstract class to handle weights initialization and a simple interface for downloading and loading pretrained\n+    models.\n+    \"\"\"\n+\n+    config_class = PromptDepthAnythingConfig\n+    base_model_prefix = \"prompt_depth_anything\"\n+    main_input_name = \"pixel_values\"\n+    supports_gradient_checkpointing = True\n+\n+    def _init_weights(self, module):\n+        \"\"\"Initialize the weights\"\"\"\n+        if isinstance(module, (nn.Linear, nn.Conv2d, nn.ConvTranspose2d)):\n+            # Slightly different from the TF version which uses truncated_normal for initialization\n+            # cf https://github.com/pytorch/pytorch/pull/5617\n+            module.weight.data.normal_(mean=0.0, std=self.config.initializer_range)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.LayerNorm):\n+            module.bias.data.zero_()\n+            module.weight.data.fill_(1.0)\n+\n+\n+class PromptDepthAnythingReassembleLayer(nn.Module):\n+    def __init__(self, config: PromptDepthAnythingConfig, channels: int, factor: int):\n+        super().__init__()\n+        self.projection = nn.Conv2d(in_channels=config.reassemble_hidden_size, out_channels=channels, kernel_size=1)\n+\n+        # up/down sampling depending on factor\n+        if factor > 1:\n+            self.resize = nn.ConvTranspose2d(channels, channels, kernel_size=factor, stride=factor, padding=0)\n+        elif factor == 1:\n+            self.resize = nn.Identity()\n+        elif factor < 1:\n+            # so should downsample\n+            stride = torch_int(1 / factor)\n+            self.resize = nn.Conv2d(channels, channels, kernel_size=3, stride=stride, padding=1)\n+\n+    def forward(self, hidden_state):\n+        hidden_state = self.projection(hidden_state)\n+        hidden_state = self.resize(hidden_state)\n+\n+        return hidden_state\n+\n+\n+class PromptDepthAnythingReassembleStage(DepthAnythingReassembleStage):\n+    pass\n+\n+\n+class PromptDepthAnythingNeck(DepthAnythingNeck):\n+    def forward(\n+        self,\n+        hidden_states: List[torch.Tensor],\n+        patch_height: Optional[int] = None,\n+        patch_width: Optional[int] = None,\n+        prompt_depth: Optional[torch.Tensor] = None,\n+    ) -> List[torch.Tensor]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`List[torch.FloatTensor]`, each of shape `(batch_size, sequence_length, hidden_size)` or `(batch_size, hidden_size, height, width)`):\n+                List of hidden states from the backbone.\n+        \"\"\"\n+        if not isinstance(hidden_states, (tuple, list)):\n+            raise TypeError(\"hidden_states should be a tuple or list of tensors\")\n+\n+        if len(hidden_states) != len(self.config.neck_hidden_sizes):\n+            raise ValueError(\"The number of hidden states should be equal to the number of neck hidden sizes.\")\n+\n+        # postprocess hidden states\n+        hidden_states = self.reassemble_stage(hidden_states, patch_height, patch_width)\n+\n+        features = [self.convs[i](feature) for i, feature in enumerate(hidden_states)]\n+\n+        # fusion blocks\n+        output = self.fusion_stage(features, prompt_depth=prompt_depth)\n+\n+        return output\n+\n+\n+@add_start_docstrings(\n+    \"\"\"\n+    Prompt Depth Anything Model with a depth estimation head on top (consisting of 3 convolutional layers) e.g. for KITTI, NYUv2.\n+    \"\"\",\n+    PROMPT_DEPTH_ANYTHING_START_DOCSTRING,\n+)\n+class PromptDepthAnythingForDepthEstimation(DepthAnythingForDepthEstimation):\n+    @add_start_docstrings_to_model_forward(PROMPT_DEPTH_ANYTHING_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=DepthEstimatorOutput, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        pixel_values: torch.FloatTensor,\n+        prompt_depth: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+    ) -> Union[Tuple[torch.Tensor], DepthEstimatorOutput]:\n+        r\"\"\"\n+        ```python\n+        >>> from transformers import AutoImageProcessor, AutoModelForDepthEstimation\n+        >>> import torch\n+        >>> import numpy as np\n+        >>> from PIL import Image\n+        >>> import requests\n+\n+        >>> url = \"https://github.com/DepthAnything/PromptDA/blob/main/assets/example_images/image.jpg?raw=true\"\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> image_processor = AutoImageProcessor.from_pretrained(\"depth-anything/prompt-depth-anything-vits-hf\")\n+        >>> model = AutoModelForDepthEstimation.from_pretrained(\"depth-anything/prompt-depth-anything-vits-hf\")\n+\n+        >>> prompt_depth_url = \"https://github.com/DepthAnything/PromptDA/blob/main/assets/example_images/arkit_depth.png?raw=true\"\n+        >>> prompt_depth = Image.open(requests.get(prompt_depth_url, stream=True).raw)\n+\n+        >>> # prepare image for the model\n+        >>> inputs = image_processor(images=image, return_tensors=\"pt\", prompt_depth=prompt_depth)\n+\n+        >>> with torch.no_grad():\n+        ...     outputs = model(**inputs)\n+\n+        >>> # interpolate to original size\n+        >>> post_processed_output = image_processor.post_process_depth_estimation(\n+        ...     outputs,\n+        ...     target_sizes=[(image.height, image.width)],\n+        ... )\n+\n+        >>> # visualize the prediction\n+        >>> predicted_depth = post_processed_output[0][\"predicted_depth\"]\n+        >>> depth = predicted_depth * 1000.\n+        >>> depth = depth.detach().cpu().numpy()\n+        >>> depth = Image.fromarray(depth.astype(\"uint16\")) # mm\n+        ```\"\"\"\n+        loss = None\n+        if labels is not None:\n+            raise NotImplementedError(\"Training is not implemented yet\")\n+\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+\n+        outputs = self.backbone.forward_with_filtered_kwargs(\n+            pixel_values, output_hidden_states=output_hidden_states, output_attentions=output_attentions\n+        )\n+        hidden_states = outputs.feature_maps\n+\n+        _, _, height, width = pixel_values.shape\n+        patch_size = self.config.patch_size\n+        patch_height = height // patch_size\n+        patch_width = width // patch_size\n+\n+        if prompt_depth is not None:\n+            # normalize prompt depth\n+            batch_size = prompt_depth.shape[0]\n+            depth_min = torch.min(prompt_depth.reshape(batch_size, -1), dim=1).values\n+            depth_max = torch.max(prompt_depth.reshape(batch_size, -1), dim=1).values\n+            depth_min, depth_max = depth_min.view(batch_size, 1, 1, 1), depth_max.view(batch_size, 1, 1, 1)\n+            prompt_depth = (prompt_depth - depth_min) / (depth_max - depth_min)\n+            # normalize done\n+\n+        hidden_states = self.neck(hidden_states, patch_height, patch_width, prompt_depth=prompt_depth)\n+\n+        predicted_depth = self.head(hidden_states, patch_height, patch_width)\n+        if prompt_depth is not None:\n+            # denormalize predicted depth\n+            depth_min = depth_min.squeeze(1).to(predicted_depth.device)\n+            depth_max = depth_max.squeeze(1).to(predicted_depth.device)\n+            predicted_depth = predicted_depth * (depth_max - depth_min) + depth_min\n+            # denormalize done\n+\n+        if not return_dict:\n+            if output_hidden_states:\n+                output = (predicted_depth,) + outputs[1:]\n+            else:\n+                output = (predicted_depth,) + outputs[2:]\n+            return ((loss,) + output) if loss is not None else output\n+\n+        return DepthEstimatorOutput(\n+            loss=loss,\n+            predicted_depth=predicted_depth,\n+            hidden_states=outputs.hidden_states if output_hidden_states else None,\n+            attentions=outputs.attentions,\n+        )\n+\n+\n+__all__ = [\n+    \"PromptDepthAnythingConfig\",\n+    \"PromptDepthAnythingForDepthEstimation\",\n+    \"PromptDepthAnythingPreTrainedModel\",\n+]"
        },
        {
            "sha": "dc48c13706eeab75c6008567a02372fbdef5ce02",
            "filename": "src/transformers/utils/dummy_pt_objects.py",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -7878,6 +7878,20 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torch\"])\n \n \n+class PromptDepthAnythingForDepthEstimation(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class PromptDepthAnythingPreTrainedModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n class ProphetNetDecoder(metaclass=DummyObject):\n     _backends = [\"torch\"]\n "
        },
        {
            "sha": "ffd15d64ac40289478e0b6ef590e9db3db3979fa",
            "filename": "src/transformers/utils/dummy_vision_objects.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -590,6 +590,13 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"vision\"])\n \n \n+class PromptDepthAnythingImageProcessor(metaclass=DummyObject):\n+    _backends = [\"vision\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"vision\"])\n+\n+\n class PvtImageProcessor(metaclass=DummyObject):\n     _backends = [\"vision\"]\n "
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/prompt_depth_anything/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/tests%2Fmodels%2Fprompt_depth_anything%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/tests%2Fmodels%2Fprompt_depth_anything%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fprompt_depth_anything%2F__init__.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c"
        },
        {
            "sha": "7becbe5dfa50917cc3a777372ae0cd23ac00f206",
            "filename": "tests/models/prompt_depth_anything/test_image_processing_prompt_depth_anything.py",
            "status": "added",
            "additions": 139,
            "deletions": 0,
            "changes": 139,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/tests%2Fmodels%2Fprompt_depth_anything%2Ftest_image_processing_prompt_depth_anything.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/tests%2Fmodels%2Fprompt_depth_anything%2Ftest_image_processing_prompt_depth_anything.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fprompt_depth_anything%2Ftest_image_processing_prompt_depth_anything.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -0,0 +1,139 @@\n+# coding=utf-8\n+# Copyright 2024 HuggingFace Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+import unittest\n+\n+import numpy as np\n+\n+from transformers.file_utils import is_vision_available\n+from transformers.testing_utils import require_torch, require_vision\n+\n+from ...test_image_processing_common import ImageProcessingTestMixin, prepare_image_inputs\n+\n+\n+if is_vision_available():\n+    from transformers import PromptDepthAnythingImageProcessor\n+\n+\n+class PromptDepthAnythingImageProcessingTester(unittest.TestCase):\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=7,\n+        num_channels=3,\n+        image_size=18,\n+        min_resolution=30,\n+        max_resolution=400,\n+        do_resize=True,\n+        size=None,\n+        do_normalize=True,\n+        image_mean=[0.5, 0.5, 0.5],\n+        image_std=[0.5, 0.5, 0.5],\n+    ):\n+        super().__init__()\n+        size = size if size is not None else {\"height\": 18, \"width\": 18}\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.image_size = image_size\n+        self.min_resolution = min_resolution\n+        self.max_resolution = max_resolution\n+        self.do_resize = do_resize\n+        self.size = size\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean\n+        self.image_std = image_std\n+\n+    def prepare_image_processor_dict(self):\n+        return {\n+            \"image_mean\": self.image_mean,\n+            \"image_std\": self.image_std,\n+            \"do_normalize\": self.do_normalize,\n+            \"do_resize\": self.do_resize,\n+            \"size\": self.size,\n+        }\n+\n+    def expected_output_image_shape(self, images):\n+        return self.num_channels, self.size[\"height\"], self.size[\"width\"]\n+\n+    def prepare_image_inputs(self, equal_resolution=False, numpify=False, torchify=False):\n+        return prepare_image_inputs(\n+            batch_size=self.batch_size,\n+            num_channels=self.num_channels,\n+            min_resolution=self.min_resolution,\n+            max_resolution=self.max_resolution,\n+            equal_resolution=equal_resolution,\n+            numpify=numpify,\n+            torchify=torchify,\n+        )\n+\n+\n+@require_torch\n+@require_vision\n+class PromptDepthAnythingImageProcessingTest(ImageProcessingTestMixin, unittest.TestCase):\n+    image_processing_class = PromptDepthAnythingImageProcessor if is_vision_available() else None\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.image_processor_tester = PromptDepthAnythingImageProcessingTester(self)\n+\n+    @property\n+    def image_processor_dict(self):\n+        return self.image_processor_tester.prepare_image_processor_dict()\n+\n+    def test_image_processor_properties(self):\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        self.assertTrue(hasattr(image_processing, \"image_mean\"))\n+        self.assertTrue(hasattr(image_processing, \"image_std\"))\n+        self.assertTrue(hasattr(image_processing, \"do_normalize\"))\n+        self.assertTrue(hasattr(image_processing, \"do_resize\"))\n+        self.assertTrue(hasattr(image_processing, \"size\"))\n+        self.assertTrue(hasattr(image_processing, \"do_rescale\"))\n+        self.assertTrue(hasattr(image_processing, \"rescale_factor\"))\n+        self.assertTrue(hasattr(image_processing, \"do_pad\"))\n+        self.assertTrue(hasattr(image_processing, \"size_divisor\"))\n+        self.assertTrue(hasattr(image_processing, \"prompt_scale_to_meter\"))\n+\n+    def test_image_processor_from_dict_with_kwargs(self):\n+        image_processor = self.image_processing_class.from_dict(self.image_processor_dict)\n+        self.assertEqual(image_processor.size, {\"height\": 18, \"width\": 18})\n+\n+        image_processor = self.image_processing_class.from_dict(self.image_processor_dict, size=42)\n+        self.assertEqual(image_processor.size, {\"height\": 42, \"width\": 42})\n+\n+    def test_keep_aspect_ratio(self):\n+        size = {\"height\": 512, \"width\": 512}\n+        image_processor = PromptDepthAnythingImageProcessor(size=size, keep_aspect_ratio=True, ensure_multiple_of=32)\n+\n+        image = np.zeros((489, 640, 3))\n+\n+        pixel_values = image_processor(image, return_tensors=\"pt\").pixel_values\n+\n+        self.assertEqual(list(pixel_values.shape), [1, 3, 512, 672])\n+\n+    def test_prompt_depth_processing(self):\n+        size = {\"height\": 756, \"width\": 756}\n+        image_processor = PromptDepthAnythingImageProcessor(size=size, keep_aspect_ratio=True, ensure_multiple_of=32)\n+\n+        image = np.zeros((756, 1008, 3))\n+        prompt_depth = np.random.random((192, 256))\n+\n+        outputs = image_processor(image, prompt_depth=prompt_depth, return_tensors=\"pt\")\n+        pixel_values = outputs.pixel_values\n+        prompt_depth_values = outputs.prompt_depth\n+\n+        self.assertEqual(list(pixel_values.shape), [1, 3, 768, 1024])\n+        self.assertEqual(list(prompt_depth_values.shape), [1, 1, 192, 256])"
        },
        {
            "sha": "77cb96ccea020f0b112c9e46c69da2fb4a2edfca",
            "filename": "tests/models/prompt_depth_anything/test_modeling_prompt_depth_anything.py",
            "status": "added",
            "additions": 325,
            "deletions": 0,
            "changes": 325,
            "blob_url": "https://github.com/huggingface/transformers/blob/6515c259532d50ee022f211eab8afbd765a5f89c/tests%2Fmodels%2Fprompt_depth_anything%2Ftest_modeling_prompt_depth_anything.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/6515c259532d50ee022f211eab8afbd765a5f89c/tests%2Fmodels%2Fprompt_depth_anything%2Ftest_modeling_prompt_depth_anything.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fprompt_depth_anything%2Ftest_modeling_prompt_depth_anything.py?ref=6515c259532d50ee022f211eab8afbd765a5f89c",
            "patch": "@@ -0,0 +1,325 @@\n+# coding=utf-8\n+# Copyright 2024 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch Prompt Depth Anything model.\"\"\"\n+\n+import unittest\n+\n+import requests\n+\n+from transformers import Dinov2Config, PromptDepthAnythingConfig\n+from transformers.file_utils import is_torch_available, is_vision_available\n+from transformers.pytorch_utils import is_torch_greater_or_equal_than_2_4\n+from transformers.testing_utils import require_torch, require_vision, slow, torch_device\n+\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import ModelTesterMixin, floats_tensor, ids_tensor\n+from ...test_pipeline_mixin import PipelineTesterMixin\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import PromptDepthAnythingForDepthEstimation\n+\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+    from transformers import AutoImageProcessor\n+\n+\n+class PromptDepthAnythingModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=2,\n+        num_channels=3,\n+        image_size=32,\n+        patch_size=16,\n+        use_labels=True,\n+        num_labels=3,\n+        is_training=True,\n+        hidden_size=4,\n+        num_hidden_layers=2,\n+        num_attention_heads=2,\n+        intermediate_size=8,\n+        out_features=[\"stage1\", \"stage2\"],\n+        apply_layernorm=False,\n+        reshape_hidden_states=False,\n+        neck_hidden_sizes=[2, 2],\n+        fusion_hidden_size=6,\n+    ):\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.image_size = image_size\n+        self.patch_size = patch_size\n+        self.hidden_size = hidden_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.intermediate_size = intermediate_size\n+        self.out_features = out_features\n+        self.apply_layernorm = apply_layernorm\n+        self.reshape_hidden_states = reshape_hidden_states\n+        self.use_labels = use_labels\n+        self.num_labels = num_labels\n+        self.is_training = is_training\n+        self.neck_hidden_sizes = neck_hidden_sizes\n+        self.fusion_hidden_size = fusion_hidden_size\n+        self.seq_length = (self.image_size // self.patch_size) ** 2 + 1\n+\n+    def prepare_config_and_inputs(self):\n+        pixel_values = floats_tensor([self.batch_size, self.num_channels, self.image_size, self.image_size])\n+\n+        labels = None\n+        if self.use_labels:\n+            labels = ids_tensor([self.batch_size, self.image_size, self.image_size], self.num_labels)\n+\n+        prompt_depth = floats_tensor([self.batch_size, 1, self.image_size // 4, self.image_size // 4])\n+\n+        config = self.get_config()\n+\n+        return config, pixel_values, labels, prompt_depth\n+\n+    def get_config(self):\n+        return PromptDepthAnythingConfig(\n+            backbone_config=self.get_backbone_config(),\n+            reassemble_hidden_size=self.hidden_size,\n+            patch_size=self.patch_size,\n+            neck_hidden_sizes=self.neck_hidden_sizes,\n+            fusion_hidden_size=self.fusion_hidden_size,\n+        )\n+\n+    def get_backbone_config(self):\n+        return Dinov2Config(\n+            image_size=self.image_size,\n+            patch_size=self.patch_size,\n+            num_channels=self.num_channels,\n+            hidden_size=self.hidden_size,\n+            num_hidden_layers=self.num_hidden_layers,\n+            num_attention_heads=self.num_attention_heads,\n+            intermediate_size=self.intermediate_size,\n+            is_training=self.is_training,\n+            out_features=self.out_features,\n+            reshape_hidden_states=self.reshape_hidden_states,\n+        )\n+\n+    def create_and_check_for_depth_estimation(self, config, pixel_values, labels, prompt_depth):\n+        config.num_labels = self.num_labels\n+        model = PromptDepthAnythingForDepthEstimation(config)\n+        model.to(torch_device)\n+        model.eval()\n+        result = model(pixel_values, prompt_depth=prompt_depth)\n+        self.parent.assertEqual(result.predicted_depth.shape, (self.batch_size, self.image_size, self.image_size))\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values, labels, prompt_depth = config_and_inputs\n+        inputs_dict = {\"pixel_values\": pixel_values, \"prompt_depth\": prompt_depth}\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class PromptDepthAnythingModelTest(ModelTesterMixin, PipelineTesterMixin, unittest.TestCase):\n+    \"\"\"\n+    Here we also overwrite some of the tests of test_modeling_common.py, as Prompt Depth Anything does not use input_ids, inputs_embeds,\n+    attention_mask and seq_length.\n+    \"\"\"\n+\n+    all_model_classes = (PromptDepthAnythingForDepthEstimation,) if is_torch_available() else ()\n+    pipeline_model_mapping = (\n+        {\"depth-estimation\": PromptDepthAnythingForDepthEstimation} if is_torch_available() else {}\n+    )\n+\n+    test_pruning = False\n+    test_resize_embeddings = False\n+    test_head_masking = False\n+\n+    def setUp(self):\n+        self.model_tester = PromptDepthAnythingModelTester(self)\n+        self.config_tester = ConfigTester(\n+            self,\n+            config_class=PromptDepthAnythingConfig,\n+            has_text_modality=False,\n+            hidden_size=37,\n+            common_properties=[\"patch_size\"],\n+        )\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    @unittest.skip(\n+        reason=\"Prompt Depth Anything with AutoBackbone does not have a base model and hence no input_embeddings\"\n+    )\n+    def test_inputs_embeds(self):\n+        pass\n+\n+    def test_for_depth_estimation(self):\n+        config_and_inputs = self.model_tester.prepare_config_and_inputs()\n+        self.model_tester.create_and_check_for_depth_estimation(*config_and_inputs)\n+\n+    @unittest.skip(reason=\"Prompt Depth Anything does not support training yet\")\n+    def test_training(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Prompt Depth Anything does not support training yet\")\n+    def test_training_gradient_checkpointing(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"Prompt Depth Anything with AutoBackbone does not have a base model and hence no input_embeddings\"\n+    )\n+    def test_model_get_set_embeddings(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Prompt Depth Anything with AutoBackbone does not have a base model\")\n+    def test_save_load_fast_init_from_base(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Prompt Depth Anything with AutoBackbone does not have a base model\")\n+    def test_save_load_fast_init_to_base(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"This architecture seems to not compute gradients properly when using GC, check: https://github.com/huggingface/transformers/pull/27124\"\n+    )\n+    def test_training_gradient_checkpointing_use_reentrant(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"This architecture seems to not compute gradients properly when using GC, check: https://github.com/huggingface/transformers/pull/27124\"\n+    )\n+    def test_training_gradient_checkpointing_use_reentrant_false(self):\n+        pass\n+\n+    @slow\n+    def test_model_from_pretrained(self):\n+        model_name = \"depth-anything/prompt-depth-anything-vits-hf\"\n+        model = PromptDepthAnythingForDepthEstimation.from_pretrained(model_name)\n+        self.assertIsNotNone(model)\n+\n+    def test_backbone_selection(self):\n+        def _validate_backbone_init():\n+            for model_class in self.all_model_classes:\n+                model = model_class(config)\n+                model.to(torch_device)\n+                model.eval()\n+\n+                self.assertEqual(len(model.backbone.out_indices), 2)\n+\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        config.backbone = \"facebook/dinov2-small\"\n+        config.use_pretrained_backbone = True\n+        config.use_timm_backbone = False\n+        config.backbone_config = None\n+        config.backbone_kwargs = {\"out_indices\": [-2, -1]}\n+        _validate_backbone_init()\n+\n+\n+def prepare_img():\n+    url = \"https://github.com/DepthAnything/PromptDA/blob/main/assets/example_images/image.jpg?raw=true\"\n+    image = Image.open(requests.get(url, stream=True).raw)\n+    return image\n+\n+\n+def prepare_prompt_depth():\n+    prompt_depth_url = (\n+        \"https://github.com/DepthAnything/PromptDA/blob/main/assets/example_images/arkit_depth.png?raw=true\"\n+    )\n+    prompt_depth = Image.open(requests.get(prompt_depth_url, stream=True).raw)\n+    return prompt_depth\n+\n+\n+@require_torch\n+@require_vision\n+@slow\n+class PromptDepthAnythingModelIntegrationTest(unittest.TestCase):\n+    def test_inference_wo_prompt_depth(self):\n+        image_processor = AutoImageProcessor.from_pretrained(\"depth-anything/prompt-depth-anything-vits-hf\")\n+        model = PromptDepthAnythingForDepthEstimation.from_pretrained(\n+            \"depth-anything/prompt-depth-anything-vits-hf\"\n+        ).to(torch_device)\n+\n+        image = prepare_img()\n+        inputs = image_processor(images=image, return_tensors=\"pt\").to(torch_device)\n+\n+        with torch.no_grad():\n+            outputs = model(**inputs)\n+            predicted_depth = outputs.predicted_depth\n+\n+        expected_shape = torch.Size([1, 756, 1008])\n+        self.assertEqual(predicted_depth.shape, expected_shape)\n+\n+        expected_slice = torch.tensor(\n+            [[0.5029, 0.5120, 0.5176], [0.4998, 0.5147, 0.5197], [0.4973, 0.5201, 0.5241]]\n+        ).to(torch_device)\n+\n+        self.assertTrue(torch.allclose(predicted_depth[0, :3, :3], expected_slice, atol=1e-3))\n+\n+    def test_inference(self):\n+        image_processor = AutoImageProcessor.from_pretrained(\"depth-anything/prompt-depth-anything-vits-hf\")\n+        model = PromptDepthAnythingForDepthEstimation.from_pretrained(\n+            \"depth-anything/prompt-depth-anything-vits-hf\"\n+        ).to(torch_device)\n+\n+        image = prepare_img()\n+        prompt_depth = prepare_prompt_depth()\n+        inputs = image_processor(images=image, return_tensors=\"pt\", prompt_depth=prompt_depth).to(torch_device)\n+\n+        with torch.no_grad():\n+            outputs = model(**inputs)\n+            predicted_depth = outputs.predicted_depth\n+\n+        expected_shape = torch.Size([1, 756, 1008])\n+        self.assertEqual(predicted_depth.shape, expected_shape)\n+\n+        expected_slice = torch.tensor(\n+            [[3.0100, 3.0016, 3.0219], [3.0046, 3.0137, 3.0275], [3.0083, 3.0191, 3.0292]]\n+        ).to(torch_device)\n+\n+        self.assertTrue(torch.allclose(predicted_depth[0, :3, :3], expected_slice, atol=1e-3))\n+\n+    def test_export(self):\n+        for strict in [True, False]:\n+            with self.subTest(strict=strict):\n+                if not is_torch_greater_or_equal_than_2_4:\n+                    self.skipTest(reason=\"This test requires torch >= 2.4 to run.\")\n+                model = (\n+                    PromptDepthAnythingForDepthEstimation.from_pretrained(\n+                        \"depth-anything/prompt-depth-anything-vits-hf\"\n+                    )\n+                    .to(torch_device)\n+                    .eval()\n+                )\n+                image_processor = AutoImageProcessor.from_pretrained(\"depth-anything/prompt-depth-anything-vits-hf\")\n+                image = prepare_img()\n+                prompt_depth = prepare_prompt_depth()\n+                inputs = image_processor(images=image, prompt_depth=prompt_depth, return_tensors=\"pt\").to(torch_device)\n+\n+                exported_program = torch.export.export(\n+                    model,\n+                    args=(inputs[\"pixel_values\"], inputs[\"prompt_depth\"]),\n+                    strict=strict,\n+                )\n+                with torch.no_grad():\n+                    eager_outputs = model(**inputs)\n+                    exported_outputs = exported_program.module().forward(\n+                        inputs[\"pixel_values\"], inputs[\"prompt_depth\"]\n+                    )\n+                self.assertEqual(eager_outputs.predicted_depth.shape, exported_outputs.predicted_depth.shape)\n+                self.assertTrue(\n+                    torch.allclose(eager_outputs.predicted_depth, exported_outputs.predicted_depth, atol=1e-4)\n+                )"
        }
    ],
    "stats": {
        "total": 2537,
        "additions": 2537,
        "deletions": 0
    }
}