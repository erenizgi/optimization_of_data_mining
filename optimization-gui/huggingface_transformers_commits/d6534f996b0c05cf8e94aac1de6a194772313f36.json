{
    "author": "gante",
    "message": "Repo checks: check documented methods exist (#32320)",
    "sha": "d6534f996b0c05cf8e94aac1de6a194772313f36",
    "files": [
        {
            "sha": "2f0e12c9cf51beb339250559d020201d19928c11",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 61,
            "deletions": 73,
            "changes": 134,
            "blob_url": "https://github.com/huggingface/transformers/blob/d6534f996b0c05cf8e94aac1de6a194772313f36/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/d6534f996b0c05cf8e94aac1de6a194772313f36/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=d6534f996b0c05cf8e94aac1de6a194772313f36",
            "patch": "@@ -31,7 +31,6 @@\n It has no auto-fix mode.\n \"\"\"\n \n-import inspect\n import os\n import re\n import sys\n@@ -421,22 +420,15 @@ def get_model_modules() -> List[str]:\n         \"modeling_auto\",\n         \"modeling_encoder_decoder\",\n         \"modeling_marian\",\n-        \"modeling_mmbt\",\n-        \"modeling_outputs\",\n         \"modeling_retribert\",\n-        \"modeling_utils\",\n         \"modeling_flax_auto\",\n         \"modeling_flax_encoder_decoder\",\n-        \"modeling_flax_utils\",\n         \"modeling_speech_encoder_decoder\",\n         \"modeling_flax_speech_encoder_decoder\",\n         \"modeling_flax_vision_encoder_decoder\",\n         \"modeling_timm_backbone\",\n         \"modeling_tf_auto\",\n         \"modeling_tf_encoder_decoder\",\n-        \"modeling_tf_outputs\",\n-        \"modeling_tf_pytorch_utils\",\n-        \"modeling_tf_utils\",\n         \"modeling_tf_vision_encoder_decoder\",\n         \"modeling_vision_encoder_decoder\",\n     ]\n@@ -450,8 +442,7 @@ def get_model_modules() -> List[str]:\n         for submodule in dir(model_module):\n             if submodule.startswith(\"modeling\") and submodule not in _ignore_modules:\n                 modeling_module = getattr(model_module, submodule)\n-                if inspect.ismodule(modeling_module):\n-                    modules.append(modeling_module)\n+                modules.append(modeling_module)\n     return modules\n \n \n@@ -913,19 +904,26 @@ def find_all_documented_objects() -> List[str]:\n \n     Returns:\n         `List[str]`: The list of all object names being documented.\n+        `Dict[str, List[str]]`: A dictionary mapping the object name (full import path, e.g.\n+            `integrations.PeftAdapterMixin`) to its documented methods\n     \"\"\"\n     documented_obj = []\n-    for doc_file in Path(PATH_TO_DOC).glob(\"**/*.rst\"):\n-        with open(doc_file, \"r\", encoding=\"utf-8\", newline=\"\\n\") as f:\n-            content = f.read()\n-        raw_doc_objs = re.findall(r\"(?:autoclass|autofunction):: transformers.(\\S+)\\s+\", content)\n-        documented_obj += [obj.split(\".\")[-1] for obj in raw_doc_objs]\n+    documented_methods_map = {}\n     for doc_file in Path(PATH_TO_DOC).glob(\"**/*.md\"):\n         with open(doc_file, \"r\", encoding=\"utf-8\", newline=\"\\n\") as f:\n             content = f.read()\n         raw_doc_objs = re.findall(r\"\\[\\[autodoc\\]\\]\\s+(\\S+)\\s+\", content)\n         documented_obj += [obj.split(\".\")[-1] for obj in raw_doc_objs]\n-    return documented_obj\n+\n+        for obj in raw_doc_objs:\n+            obj_public_methods = re.findall(rf\"\\[\\[autodoc\\]\\] {obj}((\\n\\s+-.*)+)\", content)\n+            # Some objects have no methods documented\n+            if len(obj_public_methods) == 0:\n+                continue\n+            else:\n+                documented_methods_map[obj] = re.findall(r\"(?<=-\\s).*\", obj_public_methods[0][0])\n+\n+    return documented_obj, documented_methods_map\n \n \n # One good reason for not being documented is to be deprecated. Put in this list deprecated objects.\n@@ -1063,7 +1061,7 @@ def ignore_undocumented(name: str) -> bool:\n \n def check_all_objects_are_documented():\n     \"\"\"Check all models are properly documented.\"\"\"\n-    documented_objs = find_all_documented_objects()\n+    documented_objs, documented_methods_map = find_all_documented_objects()\n     modules = transformers._modules\n     objects = [c for c in dir(transformers) if c not in modules and not c.startswith(\"_\")]\n     undocumented_objs = [c for c in objects if c not in documented_objs and not ignore_undocumented(c)]\n@@ -1072,8 +1070,41 @@ def check_all_objects_are_documented():\n             \"The following objects are in the public init so should be documented:\\n - \"\n             + \"\\n - \".join(undocumented_objs)\n         )\n-    check_docstrings_are_in_md()\n     check_model_type_doc_match()\n+    check_public_method_exists(documented_methods_map)\n+\n+\n+def check_public_method_exists(documented_methods_map):\n+    \"\"\"Check that all explicitly documented public methods are defined in the corresponding class.\"\"\"\n+    failures = []\n+    for obj, methods in documented_methods_map.items():\n+        # Let's ensure there is no repetition\n+        if len(set(methods)) != len(methods):\n+            failures.append(f\"Error in the documentation of {obj}: there are repeated documented methods.\")\n+\n+        # Navigates into the object, given the full import path\n+        nested_path = obj.split(\".\")\n+        submodule = transformers\n+        if len(nested_path) > 1:\n+            nested_submodules = nested_path[:-1]\n+            for submodule_name in nested_submodules:\n+                if submodule_name == \"transformers\":\n+                    continue\n+                submodule = getattr(submodule, submodule_name)\n+        class_name = nested_path[-1]\n+        obj_class = getattr(submodule, class_name)\n+        # Checks that all explicitly documented methods are defined in the class\n+        for method in methods:\n+            if method == \"all\":  # Special keyword to document all public methods\n+                continue\n+            if not hasattr(obj_class, method):\n+                failures.append(\n+                    \"The following public method is explicitly documented but not defined in the corresponding \"\n+                    f\"class. class: {obj}, method: {method}\"\n+                )\n+\n+    if len(failures) > 0:\n+        raise Exception(\"\\n\".join(failures))\n \n \n def check_model_type_doc_match():\n@@ -1103,50 +1134,6 @@ def check_model_type_doc_match():\n         )\n \n \n-# Re pattern to catch :obj:`xx`, :class:`xx`, :func:`xx` or :meth:`xx`.\n-_re_rst_special_words = re.compile(r\":(?:obj|func|class|meth):`([^`]+)`\")\n-# Re pattern to catch things between double backquotes.\n-_re_double_backquotes = re.compile(r\"(^|[^`])``([^`]+)``([^`]|$)\")\n-# Re pattern to catch example introduction.\n-_re_rst_example = re.compile(r\"^\\s*Example.*::\\s*$\", flags=re.MULTILINE)\n-\n-\n-def is_rst_docstring(docstring: str) -> True:\n-    \"\"\"\n-    Returns `True` if `docstring` is written in rst.\n-    \"\"\"\n-    if _re_rst_special_words.search(docstring) is not None:\n-        return True\n-    if _re_double_backquotes.search(docstring) is not None:\n-        return True\n-    if _re_rst_example.search(docstring) is not None:\n-        return True\n-    return False\n-\n-\n-def check_docstrings_are_in_md():\n-    \"\"\"Check all docstrings are written in md and nor rst.\"\"\"\n-    files_with_rst = []\n-    for file in Path(PATH_TO_TRANSFORMERS).glob(\"**/*.py\"):\n-        with open(file, encoding=\"utf-8\") as f:\n-            code = f.read()\n-        docstrings = code.split('\"\"\"')\n-\n-        for idx, docstring in enumerate(docstrings):\n-            if idx % 2 == 0 or not is_rst_docstring(docstring):\n-                continue\n-            files_with_rst.append(file)\n-            break\n-\n-    if len(files_with_rst) > 0:\n-        raise ValueError(\n-            \"The following files have docstrings written in rst:\\n\"\n-            + \"\\n\".join([f\"- {f}\" for f in files_with_rst])\n-            + \"\\nTo fix this run `doc-builder convert path_to_py_file` after installing `doc-builder`\\n\"\n-            \"(`pip install git+https://github.com/huggingface/doc-builder`)\"\n-        )\n-\n-\n def check_deprecated_constant_is_up_to_date():\n     \"\"\"\n     Check if the constant `DEPRECATED_MODELS` in `models/auto/configuration_auto.py` is up to date.\n@@ -1177,27 +1164,28 @@ def check_deprecated_constant_is_up_to_date():\n \n \n def check_repo_quality():\n-    \"\"\"Check all models are properly tested and documented.\"\"\"\n-    print(\"Checking all models are included.\")\n+    \"\"\"Check all models are tested and documented.\"\"\"\n+    print(\"Repository-wide checks:\")\n+    print(\"    - checking all models are included.\")\n     check_model_list()\n-    print(\"Checking all models are public.\")\n+    print(\"    - checking all models are public.\")\n     check_models_are_in_init()\n-    print(\"Checking all models are properly tested.\")\n+    print(\"    - checking all models have tests.\")\n     check_all_decorator_order()\n     check_all_models_are_tested()\n-    print(\"Checking all objects are properly documented.\")\n+    print(\"    - checking all objects have documentation.\")\n     check_all_objects_are_documented()\n-    print(\"Checking all models are in at least one auto class.\")\n+    print(\"    - checking all models are in at least one auto class.\")\n     check_all_models_are_auto_configured()\n-    print(\"Checking all names in auto name mappings are defined.\")\n+    print(\"    - checking all names in auto name mappings are defined.\")\n     check_all_auto_object_names_being_defined()\n-    print(\"Checking all keys in auto name mappings are defined in `CONFIG_MAPPING_NAMES`.\")\n+    print(\"    - checking all keys in auto name mappings are defined in `CONFIG_MAPPING_NAMES`.\")\n     check_all_auto_mapping_names_in_config_mapping_names()\n-    print(\"Checking all auto mappings could be imported.\")\n+    print(\"    - checking all auto mappings could be imported.\")\n     check_all_auto_mappings_importable()\n-    print(\"Checking all objects are equally (across frameworks) in the main __init__.\")\n+    print(\"    - checking all objects are equally (across frameworks) in the main __init__.\")\n     check_objects_being_equally_in_main_init()\n-    print(\"Checking the DEPRECATED_MODELS constant is up to date.\")\n+    print(\"    - checking the DEPRECATED_MODELS constant is up to date.\")\n     check_deprecated_constant_is_up_to_date()\n \n "
        }
    ],
    "stats": {
        "total": 134,
        "additions": 61,
        "deletions": 73
    }
}