{
    "author": "LysandreJik",
    "message": "Split `transformers chat` and `transformers serve`  (#38443)\n\n* Next token\n\n* Split chat and serve\n\n* Support both generation methods\n\n* Style\n\n* Generation Config\n\n* temp\n\n* temp\n\n* Finalize serving.py\n\nCo-authored-by: =?UTF-8?q?c=C3=A9lina?= <hanouticelina@gmail.com>\n\n* Finalize chat.py\n\n* Update src/transformers/commands/serving.py\n\nCo-authored-by: célina <hanouticelina@gmail.com>\n\n* Lucain's comments\n\nCo-authored-by: Lucain <lucain@huggingface.co>\n\n* Update\n\n* Last comments on PR\n\n* Better error handling\n\n* Better error handling\n\n* CI errors\n\n* CI errors\n\n* Add tests\n\n* Fix tests\n\n* Fix tests\n\n* [chat] Split chat/serve (built on top of lysandre's PR) (#39031)\n\n* Next token\n\n* Split chat and serve\n\n* Support both generation methods\n\n* Style\n\n* Generation Config\n\n* temp\n\n* temp\n\n* Finalize serving.py\n\nCo-authored-by: =?UTF-8?q?c=C3=A9lina?= <hanouticelina@gmail.com>\n\n* Finalize chat.py\n\n* Update src/transformers/commands/serving.py\n\nCo-authored-by: célina <hanouticelina@gmail.com>\n\n* Lucain's comments\n\nCo-authored-by: Lucain <lucain@huggingface.co>\n\n* Update\n\n* Last comments on PR\n\n* Better error handling\n\n* Better error handling\n\n* CI errors\n\n* CI errors\n\n* Add tests\n\n* Fix tests\n\n* Fix tests\n\n* streaming tool call\n\n* abstract tool state; set tool start as eos\n\n* todos\n\n* server working on models without tools\n\n* rm chat's deprecated flags\n\n* chat defaults\n\n* kv cache persists across calls\n\n* add server docs\n\n* link\n\n* Update src/transformers/commands/serving.py\n\n* Apply suggestions from code review\n\n* i love merge conflicts\n\n* solve multi turn with tiny-agents\n\n* On the fly switching of the models\n\n* Remove required positional arg\n\n---------\n\nCo-authored-by: Lysandre <hi@lysand.re>\nCo-authored-by: =?UTF-8?q?c=C3=A9lina?= <hanouticelina@gmail.com>\nCo-authored-by: Lucain <lucain@huggingface.co>\n\n* Protect names\n\n* Fix tests\n\n---------\n\nCo-authored-by: =?UTF-8?q?c=C3=A9lina?= <hanouticelina@gmail.com>\nCo-authored-by: Lucain <lucain@huggingface.co>\nCo-authored-by: Joao Gante <joaofranciscocardosogante@gmail.com>",
    "sha": "e8f90b5397df419f211498ef399f9255790b8428",
    "files": [
        {
            "sha": "f661eb91e58f6a0cc886643b611747942aa51ca9",
            "filename": "docs/source/en/conversations.md",
            "status": "modified",
            "additions": 65,
            "deletions": 0,
            "changes": 65,
            "blob_url": "https://github.com/huggingface/transformers/blob/e8f90b5397df419f211498ef399f9255790b8428/docs%2Fsource%2Fen%2Fconversations.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/e8f90b5397df419f211498ef399f9255790b8428/docs%2Fsource%2Fen%2Fconversations.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fconversations.md?ref=e8f90b5397df419f211498ef399f9255790b8428",
            "patch": "@@ -27,6 +27,9 @@ This guide shows you how to quickly start chatting with Transformers from the co\n \n ## transformers CLI\n \n+\n+### Interactive chat session\n+\n After you've [installed Transformers](./installation.md), chat with a model directly from the command line as shown below. It launches an interactive session with a model, with a few base commands listed at the start of the session.\n \n ```bash\n@@ -51,6 +54,68 @@ transformers chat -h\n \n The chat is implemented on top of the [AutoClass](./model_doc/auto), using tooling from [text generation](./llm_tutorial) and [chat](./chat_templating).\n \n+\n+### Serving a model and using MCP tools\n+\n+> [!WARNING]\n+> This section is experimental and subject to changes in future versions\n+\n+Powering the `chat` interface, we have a server that takes user messages and returns completions. The server has a chat completion API compatible with the OpenAI SDK, so you can also quickly experiment with `transformers` models on existing aplications. To launch a server separately, use the `transformers serve` CLI:\n+\n+```bash\n+transformers serve Menlo/Jan-nano\n+```\n+\n+Under the hood, the `chat` CLI launches and uses `transformers serve`. This server is also an MCP client, which can receive information available MCP servers (i.e. tools), massage their information into the model prompt, and prepare calls to these tools when the model commands to do so. Naturally, this requires a model that is trained to use tools.\n+\n+At the moment, MCP tool usage in `transformers` has the following constraints:\n+- `chat` can't handle tools, but the [`tiny-agents`](https://huggingface.co/blog/python-tiny-agents) CLI can;\n+- Only the `qwen` family of models is supported.\n+\n+The first step to use MCP tools is to let the model know which tools are available. As an example, let's consider a `tiny-agents` configuration file with a reference to an [image generation MCP server](https://evalstate-flux1-schnell.hf.space/).\n+\n+> [!TIP]\n+> Many Hugging Face Spaces can be used as MCP servers. You can find all compatible Spaces [here](https://huggingface.co/spaces?filter=mcp-server).\n+\n+```json\n+{\n+    \"model\": \"http://localhost:8000\",\n+    \"provider\": \"local\",\n+    \"servers\": [\n+        {\n+            \"type\": \"sse\",\n+            \"config\": {\n+                \"url\": \"https://evalstate-flux1-schnell.hf.space/gradio_api/mcp/sse\"\n+            }\n+        }\n+    ]\n+}\n+```\n+\n+You can then launch your `tiny-agents` chat interface with the following command.\n+\n+```bash\n+tiny-agents run path/to/your/config.json\n+```\n+\n+If you have a server (from `transformers serve`) running in the background, you're ready to use MCP tools from a local model! For instance, here's the example of a chat session:\n+\n+```bash\n+Agent loaded with 1 tools:\n+ • flux1_schnell_infer\n+»  Generate an image of a cat on the moon\n+<Tool req_0_tool_call>flux1_schnell_infer {\"prompt\": \"a cat on the moon\", \"seed\": 42, \"randomize_seed\": true, \"width\": 1024, \"height\": 1024, \"num_inference_steps\": 4}\n+\n+Tool req_0_tool_call\n+[Binary Content: Image image/webp, 57732 bytes]\n+The task is complete and the content accessible to the User\n+Image URL: https://evalstate-flux1-schnell.hf.space/gradio_api/file=/tmp/gradio/3dbddc0e53b5a865ed56a4e3dbdd30f3f61cf3b8aabf1b456f43e5241bd968b8/image.webp\n+380576952\n+\n+I have generated an image of a cat on the moon using the Flux 1 Schnell Image Generator. The image is 1024x1024 pixels and was created with 4 inference steps. Let me know if you would like to make any changes or need further assistance!\n+```\n+\n+\n ## TextGenerationPipeline\n \n [`TextGenerationPipeline`] is a high-level text generation class with a \"chat mode\". Chat mode is enabled when a conversational model is detected and the chat prompt is [properly formatted](./llm_tutorial#wrong-prompt-format)."
        },
        {
            "sha": "a38814188411e5cad86b5bcaf36e3a918951f03f",
            "filename": "setup.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/e8f90b5397df419f211498ef399f9255790b8428/setup.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e8f90b5397df419f211498ef399f9255790b8428/setup.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/setup.py?ref=e8f90b5397df419f211498ef399f9255790b8428",
            "patch": "@@ -148,7 +148,7 @@\n     \"protobuf\",\n     \"psutil\",\n     \"pyyaml>=5.1\",\n-    \"pydantic\",\n+    \"pydantic>=2\",\n     \"pytest>=7.2.0\",\n     \"pytest-asyncio\",\n     \"pytest-rerunfailures\","
        },
        {
            "sha": "b965a5727299624f9572d9e7884c95b468fbc7bc",
            "filename": "src/transformers/commands/chat.py",
            "status": "modified",
            "additions": 120,
            "deletions": 148,
            "changes": 268,
            "blob_url": "https://github.com/huggingface/transformers/blob/e8f90b5397df419f211498ef399f9255790b8428/src%2Ftransformers%2Fcommands%2Fchat.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e8f90b5397df419f211498ef399f9255790b8428/src%2Ftransformers%2Fcommands%2Fchat.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fcommands%2Fchat.py?ref=e8f90b5397df419f211498ef399f9255790b8428",
            "patch": "@@ -13,33 +13,30 @@\n # limitations under the License.\n \n \n-import copy\n+import asyncio\n import json\n import os\n import platform\n import re\n import string\n import time\n-import warnings\n from argparse import ArgumentParser, Namespace\n from dataclasses import dataclass, field\n from threading import Thread\n-from typing import Optional\n+from typing import AsyncIterator, Optional\n \n import yaml\n-from huggingface_hub.utils import disable_progress_bars\n+from huggingface_hub import AsyncInferenceClient, ChatCompletionStreamOutput\n \n from transformers import (\n     AutoTokenizer,\n     GenerationConfig,\n     PreTrainedTokenizer,\n-    TextIteratorStreamer,\n-    logging,\n )\n+from transformers.commands import BaseTransformersCLICommand\n+from transformers.commands.serving import ServeArguments, ServeCommand\n from transformers.utils import is_rich_available, is_torch_available\n \n-from . import BaseTransformersCLICommand\n-\n \n if platform.system() != \"Windows\":\n     import pwd\n@@ -52,8 +49,12 @@\n if is_torch_available():\n     import torch\n \n-    from transformers import AutoModelForCausalLM, BitsAndBytesConfig, PreTrainedModel\n-\n+    from transformers import (\n+        AutoModelForCausalLM,\n+        AutoTokenizer,\n+        BitsAndBytesConfig,\n+        GenerationConfig,\n+    )\n \n ALLOWED_KEY_CHARS = set(string.ascii_letters + string.whitespace)\n ALLOWED_VALUE_CHARS = set(\n@@ -107,19 +108,6 @@\n - **!exit**: closes the interface\n \"\"\"\n \n-# format: (optional CLI arg being deprecated, its current default, corresponding `generate` flag)\n-_DEPRECATION_MAP = [\n-    (\"max_new_tokens\", 256, \"max_new_tokens\"),\n-    (\"do_sample\", True, \"do_sample\"),\n-    (\"num_beams\", 1, \"num_beams\"),\n-    (\"temperature\", 1.0, \"temperature\"),\n-    (\"top_k\", 50, \"top_k\"),\n-    (\"top_p\", 1.0, \"top_p\"),\n-    (\"repetition_penalty\", 1.0, \"repetition_penalty\"),\n-    (\"eos_tokens\", None, \"eos_token_id\"),\n-    (\"eos_token_ids\", None, \"eos_token_id\"),\n-]\n-\n \n class RichInterface:\n     def __init__(self, model_name: Optional[str] = None, user_name: Optional[str] = None):\n@@ -133,21 +121,21 @@ def __init__(self, model_name: Optional[str] = None, user_name: Optional[str] =\n         else:\n             self.user_name = user_name\n \n-    def stream_output(self, output_stream: TextIteratorStreamer) -> str:\n-        \"\"\"Stream output from a role, and return the generated text after it's done steaming.\"\"\"\n-        # This method is originally from the FastChat CLI:\n-        # https://github.com/lm-sys/FastChat/blob/main/fastchat/serve/cli.py\n-        # Create a Live context for updating the console output\n-        text = \"\"\n+    async def stream_output(self, stream: AsyncIterator[ChatCompletionStreamOutput]) -> tuple[str, int]:\n         self._console.print(f\"[bold blue]<{self.model_name}>:\")\n         with Live(console=self._console, refresh_per_second=4) as live:\n-            # Read lines from the stream\n-            for i, outputs in enumerate(output_stream):\n-                if not outputs or i == 0:\n+            text = \"\"\n+            async for token in await stream:\n+                outputs = token.choices[0].delta.content\n+                request_id = token.id\n+\n+                if not outputs:\n                     continue\n+\n                 # Escapes single words encased in <>, e.g. <think> -> \\<think\\>, for proper rendering in Markdown.\n                 # It only escapes single words that may have `_`, optionally following a `/` (e.g. </think>)\n                 outputs = re.sub(r\"<(/*)(\\w*)>\", r\"\\<\\1\\2\\>\", outputs)\n+\n                 text += outputs\n                 # Render the accumulated text as Markdown\n                 # NOTE: this is a workaround for the rendering \"unstandard markdown\"\n@@ -160,6 +148,7 @@ def stream_output(self, output_stream: TextIteratorStreamer) -> str:\n                 #  introduce trailing spaces (only) in code block, but it works well\n                 #  especially for console output, because in general the console does not\n                 #  care about trailing spaces.\n+\n                 lines = []\n                 for line in text.splitlines():\n                     lines.append(line)\n@@ -169,11 +158,15 @@ def stream_output(self, output_stream: TextIteratorStreamer) -> str:\n                         lines.append(\"\\n\")\n                     else:\n                         lines.append(\"  \\n\")\n+\n                 markdown = Markdown(\"\".join(lines).strip(), code_theme=\"github-dark\")\n+\n                 # Update the Live console output\n-                live.update(markdown)\n+                live.update(markdown, refresh=True)\n+\n         self._console.print()\n-        return text\n+\n+        return text, request_id\n \n     def input(self) -> str:\n         \"\"\"Gets user input from the console.\"\"\"\n@@ -245,25 +238,6 @@ class ChatArguments:\n             ),\n         },\n     )\n-    # Deprecated CLI args start here\n-    max_new_tokens: int = field(default=256, metadata={\"help\": \"Maximum number of tokens to generate.\"})\n-    do_sample: bool = field(default=True, metadata={\"help\": \"Whether to sample outputs during generation.\"})\n-    num_beams: int = field(default=1, metadata={\"help\": \"Number of beams for beam search.\"})\n-    temperature: float = field(default=1.0, metadata={\"help\": \"Temperature parameter for generation.\"})\n-    top_k: int = field(default=50, metadata={\"help\": \"Value of k for top-k sampling.\"})\n-    top_p: float = field(default=1.0, metadata={\"help\": \"Value of p for nucleus sampling.\"})\n-    repetition_penalty: float = field(default=1.0, metadata={\"help\": \"Repetition penalty.\"})\n-    eos_tokens: Optional[str] = field(\n-        default=None,\n-        metadata={\n-            \"help\": \"EOS tokens (text format) to stop the generation. If multiple they should be comma separated.\"\n-        },\n-    )\n-    eos_token_ids: Optional[str] = field(\n-        default=None,\n-        metadata={\"help\": \"EOS token IDs to stop the generation. If multiple they should be comma separated.\"},\n-    )\n-    # Deprecated CLI args end here\n \n     # Model loading\n     model_revision: str = field(\n@@ -300,6 +274,10 @@ class ChatArguments:\n     bnb_4bit_quant_type: str = field(default=\"nf4\", metadata={\"help\": \"Quantization type.\", \"choices\": [\"fp4\", \"nf4\"]})\n     use_bnb_nested_quant: bool = field(default=False, metadata={\"help\": \"Whether to use nested quantization.\"})\n \n+    # Serving settings\n+    host: str = field(default=\"localhost\", metadata={\"help\": \"Interface the server will listen to..\"})\n+    port: int = field(default=8000, metadata={\"help\": \"Port the server will listen to.\"})\n+\n \n def chat_command_factory(args: Namespace):\n     \"\"\"\n@@ -322,7 +300,10 @@ def register_subcommand(parser: ArgumentParser):\n \n         group = chat_parser.add_argument_group(\"Positional arguments\")\n         group.add_argument(\n-            \"model_name_or_path_positional\", type=str, default=None, help=\"Name of the pre-trained model.\"\n+            \"model_name_or_path_or_address\",\n+            type=str,\n+            default=None,\n+            help=\"Name of the pre-trained model or address to connect to.\",\n         )\n         group.add_argument(\n             \"generate_flags\",\n@@ -332,56 +313,44 @@ def register_subcommand(parser: ArgumentParser):\n                 \"Flags to pass to `generate`, using a space as a separator between flags. Accepts booleans, numbers, \"\n                 \"and lists of integers, more advanced parameterization should be set through --generation-config. \"\n                 \"Example: `transformers chat <model_repo> max_new_tokens=100 do_sample=False eos_token_id=[1,2]`. \"\n-                \"If you're a new user, check this basic flag guide: https://huggingface.co/docs/transformers/llm_tutorial#common-options\"\n+                \"If you're a new user, check this basic flag guide: \"\n+                \"https://huggingface.co/docs/transformers/llm_tutorial#common-options\"\n             ),\n             nargs=\"*\",\n         )\n         chat_parser.set_defaults(func=chat_command_factory)\n \n     def __init__(self, args):\n-        args = self._handle_deprecated_args(args)\n-        self.args = args\n+        if args.model_name_or_path_or_address is not None:\n+            name = args.model_name_or_path_or_address\n+            if name.startswith(\"http\") or name.startswith(\"https\") or name.startswith(\"localhost\"):\n+                self.spawn_backend = False\n+\n+                if args.host != \"localhost\" or args.port != 8000:\n+                    raise ValueError(\n+                        \"Looks like you’ve set both a server address and a custom host/port. \"\n+                        \"Please pick just one way to specify the server.\"\n+                    )\n \n-    def _handle_deprecated_args(self, args: ChatArguments) -> ChatArguments:\n-        \"\"\"\n-        Handles deprecated arguments and their deprecation cycle. To be removed after we fully migrated to the new\n-        args.\n-        \"\"\"\n-        has_warnings = False\n+                args.host, args.port = args.model_name_or_path_or_address.rsplit(\":\", 1)\n+            else:\n+                self.spawn_backend = True\n+                args.model_name_or_path = args.model_name_or_path_or_address\n \n-        # 1. Model as a positional argument\n-        args.model_name_or_path_positional = args.model_name_or_path_positional or args.model_name_or_path\n-        if args.model_name_or_path_positional is None:\n-            raise ValueError(\n-                \"One of the following must be provided:\"\n-                \"\\n- The positional argument containing the model repo, e.g. `transformers chat <model_repo>`\"\n-                \"\\n- the optional --model_name_or_path argument, containing the model repo (deprecated)\"\n+        if not is_rich_available() and (not is_torch_available() and self.spawn_backend):\n+            raise ImportError(\n+                \"You need to install rich to use the chat interface. Additionally, you have not specified a remote \"\n+                \"endpoint and are therefore spawning a backend. Torch is required for this: (`pip install rich torch`)\"\n             )\n-        elif args.model_name_or_path is not None:\n-            has_warnings = True\n-            warnings.warn(\n-                \"The --model_name_or_path argument is deprecated will be removed in v4.54.0. Use the positional \"\n-                \"argument instead, e.g. `transformers chat <model_repo>`.\",\n-                FutureWarning,\n+        elif not is_rich_available():\n+            raise ImportError(\"You need to install rich to use the chat interface. (`pip install rich`)\")\n+        elif not is_torch_available() and self.spawn_backend:\n+            raise ImportError(\n+                \"You have not specified a remote endpoint and are therefore spawning a backend. Torch is required \"\n+                \"for this: (`pip install rich torch`)\"\n             )\n-        # 2. Named generate option args\n-        for deprecated_arg, default_value, new_arg in _DEPRECATION_MAP:\n-            value = getattr(args, deprecated_arg)\n-            if value != default_value:\n-                has_warnings = True\n-                warnings.warn(\n-                    f\"The --{deprecated_arg} argument is deprecated will be removed in v4.54.0. There are two \"\n-                    \"alternative solutions to specify this generation option: \\n\"\n-                    \"1. Pass `--generation-config <path_to_file/Hub repo>` to specify a generation config.\\n\"\n-                    \"2. Pass `generate` flags through positional arguments, e.g. `transformers chat <model_repo> \"\n-                    f\"{new_arg}={value}`\",\n-                    FutureWarning,\n-                )\n \n-        if has_warnings:\n-            print(\"\\n(Press enter to continue)\")\n-            input()\n-        return args\n+        self.args = args\n \n     # -----------------------------------------------------------------------------------------------------------------\n     # Chat session methods\n@@ -404,7 +373,7 @@ def save_chat(chat, args: ChatArguments, filename: Optional[str] = None) -> str:\n \n         if filename is None:\n             time_str = time.strftime(\"%Y-%m-%d_%H-%M-%S\")\n-            filename = f\"{args.model_name_or_path_positional}/chat_{time_str}.json\"\n+            filename = f\"{args.model_name_or_path_or_address}/chat_{time_str}.json\"\n             filename = os.path.join(folder, filename)\n \n         os.makedirs(os.path.dirname(filename), exist_ok=True)\n@@ -477,40 +446,23 @@ def is_number(s: str) -> bool:\n             )\n         return processed_generate_flags\n \n-    def get_generation_parameterization(\n-        self, args: ChatArguments, tokenizer: AutoTokenizer, model: PreTrainedModel\n-    ) -> tuple[GenerationConfig, dict]:\n+    def get_generation_parameterization(self, args: ChatArguments) -> tuple[GenerationConfig, dict]:\n         \"\"\"\n         Returns a GenerationConfig object holding the generation parameters for the CLI command.\n         \"\"\"\n-        # No generation config arg provided -> use default generation config, apply CLI defaults\n-        if args.generation_config is None:\n-            # We start off from the checkpoint's generation config\n-            generation_config = copy.deepcopy(model.generation_config)\n-            # Apply deprecated CLI args on top of the default generation config\n-            pad_token_id, eos_token_ids = self.parse_eos_tokens(\n-                tokenizer, generation_config, args.eos_tokens, args.eos_token_ids\n-            )\n-            deprecated_kwargs = {\n-                \"max_new_tokens\": args.max_new_tokens,\n-                \"do_sample\": args.do_sample,\n-                \"num_beams\": args.num_beams,\n-                \"temperature\": args.temperature,\n-                \"top_k\": args.top_k,\n-                \"top_p\": args.top_p,\n-                \"repetition_penalty\": args.repetition_penalty,\n-                \"pad_token_id\": pad_token_id,\n-                \"eos_token_id\": eos_token_ids,\n-            }\n-            generation_config.update(**deprecated_kwargs)\n-        # generation config arg provided -> use it as the base parameterization\n-        else:\n+        # No generation config arg provided -> use base generation config, apply CLI defaults\n+        if args.generation_config is not None:\n             if \".json\" in args.generation_config:  # is a local file\n                 dirname = os.path.dirname(args.generation_config)\n                 filename = os.path.basename(args.generation_config)\n                 generation_config = GenerationConfig.from_pretrained(dirname, filename)\n             else:\n                 generation_config = GenerationConfig.from_pretrained(args.generation_config)\n+        else:\n+            # !!!!!!!!!\n+            # This is a chat session, so we have a few non-standard defaults\n+            # !!!!!!!!!\n+            generation_config = GenerationConfig(do_sample=True, max_new_tokens=256)\n \n         # Finally: parse and apply `generate_flags`\n         parsed_generate_flags = self.parse_generate_flags(args.generate_flags)\n@@ -664,7 +616,7 @@ def handle_non_exit_user_commands(\n \n         elif user_input == \"!status\":\n             interface.print_status(\n-                model_name=args.model_name_or_path_positional,\n+                model_name=args.model_name_or_path,\n                 generation_config=generation_config,\n                 model_kwargs=model_kwargs,\n             )\n@@ -679,10 +631,33 @@ def handle_non_exit_user_commands(\n     # -----------------------------------------------------------------------------------------------------------------\n     # Main logic\n     def run(self):\n-        if not is_rich_available():\n-            raise ImportError(\"You need to install rich to use the chat interface. (`pip install rich`)\")\n-        if not is_torch_available():\n-            raise ImportError(\"You need to install torch to use the chat interface. (`pip install torch`)\")\n+        asyncio.run(self._inner_run())\n+\n+    async def _inner_run(self):\n+        if self.spawn_backend:\n+            serve_args = ServeArguments(\n+                model_revision=self.args.model_revision,\n+                device=self.args.device,\n+                torch_dtype=self.args.torch_dtype,\n+                trust_remote_code=self.args.trust_remote_code,\n+                attn_implementation=self.args.attn_implementation,\n+                load_in_8bit=self.args.load_in_8bit,\n+                load_in_4bit=self.args.load_in_4bit,\n+                bnb_4bit_quant_type=self.args.bnb_4bit_quant_type,\n+                use_bnb_nested_quant=self.args.use_bnb_nested_quant,\n+                host=self.args.host,\n+                port=self.args.port,\n+                log_level=\"error\",\n+            )\n+            serve_args.model_name_or_path = self.args.model_name_or_path\n+            serve_command = ServeCommand(serve_args)\n+\n+            thread = Thread(target=serve_command.run)\n+            thread.daemon = True\n+            thread.start()\n+\n+        host = \"http://localhost\" if self.args.host == \"localhost\" else self.args.host\n+        client = AsyncInferenceClient(f\"{host}:{self.args.port}\")\n \n         args = self.args\n         if args.examples_path is None:\n@@ -696,19 +671,14 @@ def run(self):\n         else:\n             user = args.user\n \n-        model, tokenizer = self.load_model_and_tokenizer(args)\n-        generation_streamer = TextIteratorStreamer(tokenizer, skip_special_tokens=True, skip_prompt=True)\n-        generation_config, model_kwargs = self.get_generation_parameterization(args, tokenizer, model)\n-\n-        # if not verbose -> disable warnings, progress bars, etc in the chat interface\n-        if not args.verbose:\n-            logging.set_verbosity_error()\n-            disable_progress_bars()\n+        generation_config, model_kwargs = self.get_generation_parameterization(args)\n \n-        interface = RichInterface(model_name=args.model_name_or_path_positional, user_name=user)\n+        interface = RichInterface(model_name=args.model_name_or_path, user_name=user)\n         interface.clear()\n         chat = self.clear_chat_history(args.system_prompt)\n \n+        request_id = None\n+\n         # Starts the session with a minimal help message at the top, so that a user doesn't get stuck\n         interface.print_help(minimal=True)\n         while True:\n@@ -736,23 +706,25 @@ def run(self):\n                 else:\n                     chat.append({\"role\": \"user\", \"content\": user_input})\n \n-                inputs = tokenizer.apply_chat_template(chat, return_tensors=\"pt\", add_generation_prompt=True).to(\n-                    model.device\n+                stream = client.chat_completion(\n+                    chat,\n+                    stream=True,\n+                    extra_body={\"request_id\": request_id, \"generation_config\": {**generation_config.to_dict()}},\n                 )\n-                attention_mask = torch.ones_like(inputs)\n-                generation_kwargs = {\n-                    \"inputs\": inputs,\n-                    \"attention_mask\": attention_mask,\n-                    \"streamer\": generation_streamer,\n-                    \"generation_config\": generation_config,\n-                    **model_kwargs,\n-                }\n-\n-                thread = Thread(target=model.generate, kwargs=generation_kwargs)\n-                thread.start()\n-                model_output = interface.stream_output(generation_streamer)\n-                thread.join()\n+\n+                model_output, request_id = await interface.stream_output(stream)\n+\n                 chat.append({\"role\": \"assistant\", \"content\": model_output})\n \n             except KeyboardInterrupt:\n                 break\n+            finally:\n+                await client.close()\n+\n+\n+if __name__ == \"__main__\":\n+    args = ChatArguments()\n+    args.model_name_or_path_or_address = \"meta-llama/Llama-3.2-3b-Instruct\"\n+    args.model_name_or_path_or_address = \"http://localhost:8000\"\n+    chat = ChatCommand(args)\n+    chat.run()"
        },
        {
            "sha": "2d0ec77f4b47c84100f57d355eb5811554a787a0",
            "filename": "src/transformers/commands/serving.py",
            "status": "modified",
            "additions": 563,
            "deletions": 159,
            "changes": 722,
            "blob_url": "https://github.com/huggingface/transformers/blob/e8f90b5397df419f211498ef399f9255790b8428/src%2Ftransformers%2Fcommands%2Fserving.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e8f90b5397df419f211498ef399f9255790b8428/src%2Ftransformers%2Fcommands%2Fserving.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fcommands%2Fserving.py?ref=e8f90b5397df419f211498ef399f9255790b8428",
            "patch": "@@ -11,33 +11,95 @@\n # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n # See the License for the specific language governing permissions and\n # limitations under the License.\n-\n+import functools\n+import json\n+import re\n+import time\n from argparse import ArgumentParser, Namespace\n+from dataclasses import dataclass, field\n+from threading import Thread\n from typing import Any, Optional\n \n-from ..pipelines import Pipeline, get_supported_tasks, pipeline\n-from ..utils import logging\n-from . import BaseTransformersCLICommand\n+from huggingface_hub import (\n+    ChatCompletionStreamOutputChoice,\n+    ChatCompletionStreamOutputDelta,\n+    ChatCompletionStreamOutputDeltaToolCall,\n+    ChatCompletionStreamOutputFunction,\n+    ModelInfo,\n+    model_info,\n+)\n \n+from transformers.utils.import_utils import is_fastapi_available, is_pydantic_available, is_uvicorn_available\n \n-try:\n-    from fastapi import Body, FastAPI, HTTPException\n-    from fastapi.routing import APIRoute\n-    from pydantic import BaseModel\n-    from starlette.responses import JSONResponse\n-    from uvicorn import run\n+from .. import PreTrainedTokenizerFast, TextIteratorStreamer\n+from ..generation.continuous_batching import ContinuousBatchingManager, RequestStatus\n+from ..utils import is_torch_available, logging\n+from . import BaseTransformersCLICommand\n \n-    _serve_dependencies_installed = True\n-except (ImportError, AttributeError):\n-    BaseModel = object\n \n-    def Body(*x, **y):\n-        pass\n+if is_torch_available():\n+    import torch\n \n-    _serve_dependencies_installed = False\n+    from transformers import (\n+        AutoModelForCausalLM,\n+        AutoTokenizer,\n+        BitsAndBytesConfig,\n+        GenerationConfig,\n+        PreTrainedModel,\n+    )\n \n \n-logger = logging.get_logger(\"transformers/serving\")\n+if is_pydantic_available() and is_fastapi_available() and is_uvicorn_available():\n+    import uvicorn\n+    from fastapi import FastAPI\n+    from fastapi.responses import JSONResponse, StreamingResponse\n+    from pydantic import BaseModel\n+\n+    class Message(BaseModel):\n+        role: str\n+        content: str\n+\n+    class ChatCompletionInput(BaseModel):\n+        messages: list[Message]\n+\n+        stream: Optional[bool] = False\n+        model: Optional[str] = None\n+        request_id: Optional[str] = None\n+        extra_body: Optional[dict] = None\n+        frequency_penalty: Optional[float] = None\n+        logit_bias: Optional[list[float]] = None\n+        max_tokens: Optional[int] = None\n+        stop: Optional[list[str]] = None\n+        temperature: Optional[float] = None\n+        top_p: Optional[float] = None\n+        seed: Optional[int] = None\n+\n+        # Additional options supported by the HFH InferenceClient\n+        # that aren't yet supported here.\n+\n+        # logprobs: Optional[bool] = None\n+        tools: Any = None\n+        # n: Optional[int] = None\n+        # presence_penalty: Optional[float] = None\n+        # response_format: Optional[ChatCompletionInputGrammarType] = None\n+        # stream_options: Optional[ChatCompletionInputStreamOptions] = None\n+        # tool_choice: Optional[Union[ChatCompletionInputToolChoiceClass, \"ChatCompletionInputToolChoiceEnum\"]] = None\n+        # tool_prompt: Optional[str] = None\n+        # top_logprobs: Optional[int] = None\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+# Possible tokens that indicate the start/end of a tool call\n+# TODO (joao, matt): streamline tool token detection logic\n+_TOOL_CALL_TOKENS = {\n+    \"qwen\": {\n+        \"start\": \"<tool_call>\",\n+        \"end\": \"</tool_call>\",\n+    },\n+}\n+_MODELS_WITH_TOOL_SUPPORT = list(_TOOL_CALL_TOKENS.keys())\n \n \n def serve_command_factory(args: Namespace):\n@@ -46,50 +108,114 @@ def serve_command_factory(args: Namespace):\n \n     Returns: ServeCommand\n     \"\"\"\n-    nlp = pipeline(\n-        task=args.task,\n-        model=args.model if args.model else None,\n-        config=args.config,\n-        tokenizer=args.tokenizer,\n-        device=args.device,\n-    )\n-    return ServeCommand(nlp, args.host, args.port, args.workers)\n+    return ServeCommand(args)\n \n \n-class ServeModelInfoResult(BaseModel):\n-    \"\"\"\n-    Expose model information\n+def create_generation_config_from_req(req: \"ChatCompletionInput\") -> \"GenerationConfig\":\n     \"\"\"\n+    Creates a generation config from the parameters of the request. Note that we can pass a `GenerationConfig`\n+    (serialized into a `dict`) in `extra_body`, for full `generate` parameterization.\n \n-    infos: dict\n+    Args:\n+        req (`ChatCompletionInput`): The request which may optionally contain generation parameters.\n \n-\n-class ServeTokenizeResult(BaseModel):\n+    Returns:\n+        The prepared `GenerationConfig` object.\n     \"\"\"\n-    Tokenize result model\n+    if req.extra_body is not None and \"generation_config\" in req.extra_body:\n+        for key in req.extra_body[\"generation_config\"].keys():\n+            if key in ChatCompletionInput.base_field_names.keys():\n+                return {\"error\": \"Duplicated key in the root request and in the passed generation config.\"}\n+\n+    if req.extra_body is not None and \"generation_config\" in req.extra_body:\n+        generation_config = GenerationConfig(**(req.extra_body[\"generation_config\"]))\n+    else:\n+        generation_config = GenerationConfig()\n+\n+    if req.frequency_penalty is not None:\n+        generation_config.repetition_penalty = req.frequency_penalty\n+    if req.logit_bias is not None:\n+        generation_config.sequence_bias = req.logit_bias\n+    if req.stop is not None:\n+        generation_config.stop_strings = req.stop\n+    if req.temperature is not None:\n+        generation_config.temperature = req.temperature\n+    if req.top_p is not None:\n+        generation_config.top_p = req.top_p\n+    if req.seed is not None:\n+        torch.manual_seed(req.seed)\n+\n+    return generation_config\n+\n+\n+class ToolState:\n+    \"\"\"Lightweight class to keep track of the tool call state.\"\"\"\n+\n+    def __init__(self):\n+        self.reset()\n+\n+    def reset(self):\n+        \"\"\"Reset the tool call state (assumes we're outside a tool call).\"\"\"\n+        self.inside_tool_call = False\n+        self.has_tool_name_defined = False\n+        self.arg_nesting_level = 0\n+        self.buffer = \"\"\n+\n+\n+@dataclass\n+class ServeArguments:\n+    r\"\"\"\n+    Arguments for the serve CLI.\n+\n+    See the metadata arg for each argument's description -- the metadata will be printed with\n+    `transformers serve --help`\n     \"\"\"\n \n-    tokens: list[str]\n-    tokens_ids: Optional[list[int]]\n-\n-\n-class ServeDeTokenizeResult(BaseModel):\n-    \"\"\"\n-    DeTokenize result model\n-    \"\"\"\n-\n-    text: str\n+    device: str = field(default=\"cpu\", metadata={\"help\": \"Device to use for inference.\"})\n+    torch_dtype: Optional[str] = field(\n+        default=\"auto\",\n+        metadata={\n+            \"help\": \"Override the default `torch.dtype` and load the model under this dtype. If `'auto'` is passed, \"\n+            \"the dtype will be automatically derived from the model's weights.\",\n+            \"choices\": [\"auto\", \"bfloat16\", \"float16\", \"float32\"],\n+        },\n+    )\n+    trust_remote_code: bool = field(\n+        default=False, metadata={\"help\": \"Whether to trust remote code when loading a model.\"}\n+    )\n+    attn_implementation: Optional[str] = field(\n+        default=None,\n+        metadata={\n+            \"help\": \"Which attention implementation to use; you can run --attn_implementation=flash_attention_2, in \"\n+            \"which case you must install this manually by running `pip install flash-attn --no-build-isolation`.\"\n+        },\n+    )\n+    load_in_8bit: bool = field(\n+        default=False,\n+        metadata={\"help\": \"Whether to use 8 bit precision for the base model - works only with LoRA.\"},\n+    )\n+    load_in_4bit: bool = field(\n+        default=False,\n+        metadata={\"help\": \"Whether to use 4 bit precision for the base model - works only with LoRA.\"},\n+    )\n+    bnb_4bit_quant_type: str = field(default=\"nf4\", metadata={\"help\": \"Quantization type.\", \"choices\": [\"fp4\", \"nf4\"]})\n+    use_bnb_nested_quant: bool = field(default=False, metadata={\"help\": \"Whether to use nested quantization.\"})\n \n+    # Serving settings\n+    host: str = field(default=\"localhost\", metadata={\"help\": \"Interface the server will listen to..\"})\n+    port: int = field(default=8000, metadata={\"help\": \"Port the server will listen to.\"})\n \n-class ServeForwardResult(BaseModel):\n-    \"\"\"\n-    Forward result model\n-    \"\"\"\n-\n-    output: Any\n+    # Other settings\n+    log_level: str = field(\n+        default=\"info\", metadata={\"help\": \"Logging level as a string. Example: 'info' or 'warning'.\"}\n+    )\n \n \n class ServeCommand(BaseTransformersCLICommand):\n+    loaded_model: Optional[str] = None\n+    model: PreTrainedModel\n+    tokenizer: PreTrainedTokenizerFast\n+\n     @staticmethod\n     def register_subcommand(parser: ArgumentParser):\n         \"\"\"\n@@ -98,131 +224,409 @@ def register_subcommand(parser: ArgumentParser):\n         Args:\n             parser: Root parser to register command-specific arguments\n         \"\"\"\n-        serve_parser = parser.add_parser(\n-            \"serve\", help=\"CLI tool to run inference requests through REST and GraphQL endpoints.\"\n-        )\n-        serve_parser.add_argument(\n-            \"--task\",\n-            type=str,\n-            choices=get_supported_tasks(),\n-            help=\"The task to run the pipeline on\",\n-        )\n-        serve_parser.add_argument(\"--host\", type=str, default=\"localhost\", help=\"Interface the server will listen on.\")\n-        serve_parser.add_argument(\"--port\", type=int, default=8888, help=\"Port the serving will listen to.\")\n-        serve_parser.add_argument(\"--workers\", type=int, default=1, help=\"Number of http workers\")\n-        serve_parser.add_argument(\"--model\", type=str, help=\"Model's name or path to stored model.\")\n-        serve_parser.add_argument(\"--config\", type=str, help=\"Model's config name or path to stored model.\")\n-        serve_parser.add_argument(\"--tokenizer\", type=str, help=\"Tokenizer name to use.\")\n-        serve_parser.add_argument(\n-            \"--device\",\n-            type=int,\n-            default=-1,\n-            help=\"Indicate the device to run onto, -1 indicates CPU, >= 0 indicates GPU (default: -1)\",\n-        )\n+        dataclass_types = (ServeArguments,)\n+        serve_parser = parser.add_parser(\"serve\", dataclass_types=dataclass_types)\n         serve_parser.set_defaults(func=serve_command_factory)\n \n-    def __init__(self, pipeline: Pipeline, host: str, port: int, workers: int):\n-        self._pipeline = pipeline\n+    def __init__(self, args: ServeArguments):\n+        if not is_pydantic_available() or not is_fastapi_available() or not is_uvicorn_available():\n+            raise ImportError(\n+                \"Missing dependencies for the serving CLI. Please install with `pip install transformers[serving]`\"\n+            )\n \n-        self.host = host\n-        self.port = port\n-        self.workers = workers\n+        self.args = args\n+        self.use_continuous_batching = self.args.attn_implementation == \"sdpa_paged\"\n \n-        if not _serve_dependencies_installed:\n-            raise RuntimeError(\n-                \"Using serve command requires FastAPI and uvicorn. \"\n-                'Please install transformers with [serving]: pip install \"transformers[serving]\". '\n-                \"Or install FastAPI and uvicorn separately.\"\n-            )\n-        else:\n-            logger.info(f\"Serving model over {host}:{port}\")\n-            self._app = FastAPI(\n-                routes=[\n-                    APIRoute(\n-                        \"/\",\n-                        self.model_info,\n-                        response_model=ServeModelInfoResult,\n-                        response_class=JSONResponse,\n-                        methods=[\"GET\"],\n-                    ),\n-                    APIRoute(\n-                        \"/tokenize\",\n-                        self.tokenize,\n-                        response_model=ServeTokenizeResult,\n-                        response_class=JSONResponse,\n-                        methods=[\"POST\"],\n-                    ),\n-                    APIRoute(\n-                        \"/detokenize\",\n-                        self.detokenize,\n-                        response_model=ServeDeTokenizeResult,\n-                        response_class=JSONResponse,\n-                        methods=[\"POST\"],\n-                    ),\n-                    APIRoute(\n-                        \"/forward\",\n-                        self.forward,\n-                        response_model=ServeForwardResult,\n-                        response_class=JSONResponse,\n-                        methods=[\"POST\"],\n+        # State: preserves information about the last call and last KV cache, to determine whether we can reuse the KV\n+        # cache and avoid re-running prefil\n+        self.last_messages = None\n+        self.last_kv_cache = None\n+\n+        transformers_logger = logging.get_logger(\"transformers\")\n+        transformers_logger.setLevel(logging.log_levels[self.args.log_level.lower()])\n+\n+        cb_logger = logging.get_logger(\"transformers.generation.continuous_batching\")\n+        cb_logger.setLevel(logging.log_levels[self.args.log_level.lower()])\n+\n+    def build_chunk(\n+        self,\n+        content: str,\n+        request_id: str,\n+        role: Optional[str] = None,\n+        finish_reason: Optional[str] = None,\n+        tool_calls: Optional[list[ChatCompletionStreamOutputDeltaToolCall]] = None,\n+    ) -> str:\n+        payload = {\n+            \"object\": \"chat.completion.chunk\",\n+            \"id\": request_id,\n+            \"created\": int(time.time()),\n+            \"model\": self.loaded_model,\n+            \"system_fingerprint\": \"\",\n+            \"choices\": [\n+                ChatCompletionStreamOutputChoice(\n+                    delta=ChatCompletionStreamOutputDelta(\n+                        role=role,\n+                        content=content,\n+                        tool_calls=tool_calls,\n                     ),\n-                ],\n-                timeout=600,\n-            )\n+                    index=0,\n+                    logprobs=None,\n+                    finish_reason=finish_reason,\n+                ),\n+            ],\n+        }\n+        return f\"data: {json.dumps(payload)}\\n\\n\"\n \n     def run(self):\n-        run(self._app, host=self.host, port=self.port, workers=self.workers)\n+        app = FastAPI()\n+\n+        if self.use_continuous_batching:\n+            self.continuous_batching(app)\n+        else:\n+            self.generate(app)\n+\n+        @functools.lru_cache(maxsize=None)\n+        def get_text_gen_models() -> list[ModelInfo]:\n+            \"\"\"\n+            This is by no means a limit to which models may be instantiated with `transformers serve`: any chat-based\n+            model working with generate can work.\n+\n+            This is a limited list of models to ensure we have a discoverable /v1/models endpoint for third-party\n+            integrations.\n+            \"\"\"\n+            return [\n+                model_info(\"Menlo/Jan-nano\"),\n+                model_info(\"Menlo/Jan-nano-128k\"),\n+                model_info(\"Qwen/Qwen2.5-0.5B-Instruct\"),\n+                model_info(\"Qwen/Qwen2.5-3B-Instruct\"),\n+                model_info(\"Qwen/Qwen2.5-7B-Instruct\"),\n+                model_info(\"Qwen/Qwen2.5-14B-Instruct\"),\n+                model_info(\"meta-llama/Llama-3.1-8B-Instruct\"),\n+                model_info(\"meta-llama/Llama-3.2-1B-Instruct\"),\n+                model_info(\"meta-llama/Llama-3.3-70B-Instruct\"),\n+            ]\n+\n+        @app.get(\"/v1/models\")\n+        def get_all_models():\n+            return JSONResponse(\n+                {\n+                    \"object\": \"list\",\n+                    \"data\": [\n+                        {\n+                            \"id\": model.id,\n+                            \"object\": \"model\",\n+                            \"crated\": model.created_at.timestamp(),\n+                            \"owned_by\": model.author,\n+                        }\n+                        for model in get_text_gen_models()\n+                    ],\n+                }\n+            )\n \n-    def model_info(self):\n-        return ServeModelInfoResult(infos=vars(self._pipeline.model.config))\n+        uvicorn.run(app, host=self.args.host, port=self.args.port, log_level=self.args.log_level)\n+\n+    def continuous_batching(self, app):\n+        generation_config = GenerationConfig(\n+            eos_token_id=self.tokenizer.eos_token_id,\n+            pad_token_id=self.tokenizer.pad_token_id,\n+            use_cache=False,\n+            num_blocks=1,\n+            block_size=1024,\n+            do_sample=False,\n+            max_batch_tokens=10,\n+            scheduler=\"fifo\",\n+        )\n \n-    def tokenize(self, text_input: str = Body(None, embed=True), return_ids: bool = Body(False, embed=True)):\n-        \"\"\"\n-        Tokenize the provided input and eventually returns corresponding tokens id: - **text_input**: String to\n-        tokenize - **return_ids**: Boolean flags indicating if the tokens have to be converted to their integer\n-        mapping.\n-        \"\"\"\n-        try:\n-            tokens_txt = self._pipeline.tokenizer.tokenize(text_input)\n+        manager: ContinuousBatchingManager = self.model.init_continuous_batching(\n+            generation_config=generation_config, streaming=True\n+        )\n+        manager.start()\n \n-            if return_ids:\n-                tokens_ids = self._pipeline.tokenizer.convert_tokens_to_ids(tokens_txt)\n-                return ServeTokenizeResult(tokens=tokens_txt, tokens_ids=tokens_ids)\n-            else:\n-                return ServeTokenizeResult(tokens=tokens_txt)\n+        @app.post(\"/v1/chat/completions\")\n+        def _serve(req: \"ChatCompletionInput\"):\n+            if not req.stream:\n+                return {\"error\": \"Only streaming mode is supported.\"}\n \n-        except Exception as e:\n-            raise HTTPException(status_code=500, detail={\"model\": \"\", \"error\": str(e)})\n+            update_model = req.model != self.loaded_model\n \n-    def detokenize(\n-        self,\n-        tokens_ids: list[int] = Body(None, embed=True),\n-        skip_special_tokens: bool = Body(False, embed=True),\n-        cleanup_tokenization_spaces: bool = Body(True, embed=True),\n-    ):\n-        \"\"\"\n-        Detokenize the provided tokens ids to readable text: - **tokens_ids**: List of tokens ids -\n-        **skip_special_tokens**: Flag indicating to not try to decode special tokens - **cleanup_tokenization_spaces**:\n-        Flag indicating to remove all leading/trailing spaces and intermediate ones.\n-        \"\"\"\n-        try:\n-            decoded_str = self._pipeline.tokenizer.decode(tokens_ids, skip_special_tokens, cleanup_tokenization_spaces)\n-            return ServeDeTokenizeResult(model=\"\", text=decoded_str)\n-        except Exception as e:\n-            raise HTTPException(status_code=500, detail={\"model\": \"\", \"error\": str(e)})\n+            if update_model:\n+                self.model, self.tokenizer = self.load_model_and_tokenizer(req.model, self.args)\n+\n+            chat = req.messages\n+            inputs = self.tokenizer.apply_chat_template(chat, return_tensors=\"pt\", add_generation_prompt=True).to(\n+                self.model.device\n+            )\n \n-    async def forward(self, inputs=Body(None, embed=True)):\n+            generation_config = create_generation_config_from_req(req)\n+\n+            def stream_response(_inputs):\n+                try:\n+                    max_new_tokens = req.max_tokens or generation_config.max_new_tokens or 256\n+                    request_id = manager.add_request(_inputs, request_id=req.request_id, max_new_tokens=max_new_tokens)\n+                    queue_is_flushed = False\n+\n+                    for result in manager:\n+                        if req.request_id is not None and not queue_is_flushed:\n+                            if result.status == RequestStatus.FINISHED:\n+                                continue\n+                            else:\n+                                queue_is_flushed = True\n+\n+                        finish_reason = \"stop\" if result.status == RequestStatus.FINISHED else None\n+                        yield self.build_chunk(result.next_token, request_id=request_id, finish_reason=finish_reason)\n+\n+                        if result.status == RequestStatus.FINISHED:\n+                            break\n+\n+                    yield \"data: [DONE]\\n\\n\"\n+                except Exception as e:\n+                    logger.error(str(e))\n+                    yield f'data: {{\"error\": \"{str(e)}\"}}'\n+\n+            return StreamingResponse(stream_response(inputs[0]), media_type=\"text/event-stream\")\n+\n+    def is_continuation(self, req: \"ChatCompletionInput\") -> bool:\n         \"\"\"\n-        **inputs**: **attention_mask**: **tokens_type_ids**:\n+        Determines whether the current request is a continuation of the last request. In other words, if it is the\n+        same chat session.\n+\n+        Args:\n+            req (`ChatCompletionInput`): The request to check.\n+\n+        Returns:\n+            `True` if the request is a continuation of the last request, `False` otherwise.\n         \"\"\"\n+        req_continues_last_messages = True\n+\n+        # No cached messages: this is a new request\n+        if self.last_messages is None:\n+            req_continues_last_messages = False\n+        # The new request has fewer rounds of conversation: this is a new request\n+        elif len(self.last_messages) > len(req.messages):\n+            req_continues_last_messages = False\n+        # Otherwise, check that the last messages are a subset of the new request\n+        else:\n+            for i in range(len(self.last_messages)):\n+                if self.last_messages[i] != req.messages[i]:\n+                    req_continues_last_messages = False\n+                    break\n+\n+        self.last_messages = req.messages\n+        return req_continues_last_messages\n+\n+    def generate(self, app):\n+        @app.post(\"/v1/chat/completions\")\n+        def _serve(req: \"ChatCompletionInput\"):\n+            update_model = req.model != self.loaded_model\n+\n+            if update_model:\n+                self.model, self.tokenizer = self.load_model_and_tokenizer(req.model, self.args)\n+\n+            if not req.stream:\n+                return {\"error\": \"Only streaming mode is supported.\"}\n+\n+            # HACK for tiny-agents: it sends a request after the assistant message (???). Let's assume we can't have a\n+            # request whose last message is from the assistant.\n+            if req.messages[-1].role == \"assistant\":\n+                return\n+\n+            # ====== TOOL PREPROCESSING LOGIC ======\n+            tool_model_family = None\n+            for supported_model_families in _MODELS_WITH_TOOL_SUPPORT:\n+                if supported_model_families in self.model.config.architectures[0].lower():\n+                    tool_model_family = supported_model_families\n+                    break\n+            # TODO: trigger 2 constrained generations after the tool call start token is emitted:\n+            # 1. force generation to pick from the tool names\n+            # 2. force generation to pick from that tool's arguments\n+            # ====== END OF TOOL PREPROCESSING LOGIC ======\n+\n+            if tool_model_family is not None:\n+                text = self.tokenizer.apply_chat_template(\n+                    req.messages, add_generation_prompt=True, tokenize=False, tools=req.tools\n+                )\n+            else:\n+                text = self.tokenizer.apply_chat_template(req.messages, add_generation_prompt=True, tokenize=False)\n+\n+            inputs = self.tokenizer(text, return_tensors=\"pt\").to(self.model.device)[\"input_ids\"]\n+            request_id = req.request_id if req.request_id is not None else \"req_0\"\n+\n+            generation_streamer = TextIteratorStreamer(self.tokenizer, skip_special_tokens=True, skip_prompt=True)\n+\n+            generation_config = create_generation_config_from_req(req)\n+            max_new_tokens = req.max_tokens or generation_config.max_new_tokens or 256\n+            generation_config.max_new_tokens = max_new_tokens\n+\n+            last_kv_cache = None\n+            if self.is_continuation(req) and not update_model:\n+                last_kv_cache = self.last_kv_cache\n+\n+            generation_kwargs = {\n+                \"inputs\": inputs,\n+                \"attention_mask\": torch.ones_like(inputs),\n+                \"streamer\": generation_streamer,\n+                \"generation_config\": generation_config,\n+                \"return_dict_in_generate\": True,\n+                \"past_key_values\": last_kv_cache,\n+            }\n+\n+            def stream_response(streamer, _request_id):\n+                # Thin wrapper to save the KV cache after generation\n+                def generate_with_cache(**kwargs):\n+                    generate_output = self.model.generate(**kwargs)\n+                    self.last_kv_cache = generate_output.past_key_values\n+\n+                thread = Thread(target=generate_with_cache, kwargs=generation_kwargs)\n+\n+                try:\n+                    thread.start()\n+                    tool_state = ToolState()\n+\n+                    for result in streamer:\n+                        # ====== TOOL CALL LOGIC ======\n+                        if tool_model_family is not None:\n+                            # Start of a tool call: reset state variables, set `inside_tool_call`\n+                            if result.strip() == _TOOL_CALL_TOKENS[tool_model_family][\"start\"]:\n+                                tool_state.inside_tool_call = True\n+                                continue\n+\n+                            # End of tool call: reset `inside_tool_call`, emit a `finish_reason`\n+                            if result.strip() == _TOOL_CALL_TOKENS[tool_model_family][\"end\"]:\n+                                tool_state.reset()\n+                                yield self.build_chunk(\"\", _request_id, role=None, finish_reason=\"tool_calls\")\n+                                continue\n+\n+                            # Inside a tool call\n+                            if tool_state.inside_tool_call:\n+                                tool_state.buffer += result\n+\n+                                # First step: extract the tool name (may need several tokens, and we can't emit a delta\n+                                # until we have the full name)\n+                                if not tool_state.has_tool_name_defined:\n+                                    tool_name = re.search(r\"\\\"name\\\": \\\"(.*?)\\\"\", tool_state.buffer)\n+                                    if tool_name is None:\n+                                        continue\n+                                    else:\n+                                        tool_name = tool_name.group(1)\n+                                    tool_state.has_tool_name_defined = True\n+                                    tool = ChatCompletionStreamOutputDeltaToolCall(\n+                                        function=ChatCompletionStreamOutputFunction(\n+                                            name=tool_name,\n+                                            arguments=None,\n+                                        ),\n+                                        index=0,\n+                                        type=\"function\",\n+                                        id=_request_id + \"_tool_call\",  # Only the first tool call delta has an id\n+                                    )\n+\n+                                # Second step: extract tool arguments. The tool arguments can be seen as a json string\n+                                # within the tool json string. We emit a delta for the arguments.\n+                                else:\n+                                    # Empty text: skip\n+                                    if result == \"\":\n+                                        continue\n+                                    # Until we see the `\"arguments\": {` in the buffer, we skip\n+                                    # TODO: other models will likely need more elaborate processing here\n+                                    if '\"arguments\": {' not in tool_state.buffer:\n+                                        continue\n+\n+                                    # Handle nesting. We want to exclude the last } from the emitted arguments (it's\n+                                    # closing the outermost nesting level, outside the arguments block)\n+                                    tool_state.arg_nesting_level += result.count(\"{\")\n+                                    tool_state.arg_nesting_level -= result.count(\"}\")\n+                                    if tool_state.arg_nesting_level < 0:\n+                                        result = \"\".join(result.split(\"}\")[:-2]) + \"}\"  # e.g. \"4}}\\n\" -> \"4}\"\n+\n+                                    tool = ChatCompletionStreamOutputDeltaToolCall(\n+                                        function=ChatCompletionStreamOutputFunction(\n+                                            arguments=result,\n+                                        ),\n+                                        index=0,\n+                                        type=\"function\",\n+                                        id=None,\n+                                    )\n+\n+                                yield self.build_chunk(None, _request_id, role=None, tool_calls=[tool])\n+                                continue\n+                        # ====== END OF TOOL CALL LOGIC ======\n+\n+                        # All non-tool related tokens are emitted as assistant messages\n+                        yield self.build_chunk(result, _request_id, role=\"assistant\")\n+                    yield self.build_chunk(None, _request_id, role=None, finish_reason=\"stop\")\n+\n+                    thread.join()\n+                except Exception as e:\n+                    logger.error(str(e))\n+                    raise\n+                    yield f'data: {{\"error\": \"{str(e)}\"}}'\n+\n+                finally:\n+                    thread.join()\n+\n+            return StreamingResponse(stream_response(generation_streamer, request_id), media_type=\"text/event-stream\")\n+\n+    @staticmethod\n+    def get_quantization_config(model_args: ServeArguments) -> Optional[\"BitsAndBytesConfig\"]:\n+        if model_args.load_in_4bit:\n+            quantization_config = BitsAndBytesConfig(\n+                load_in_4bit=True,\n+                # For consistency with model weights, we use the same value as `torch_dtype`\n+                bnb_4bit_compute_dtype=model_args.torch_dtype,\n+                bnb_4bit_quant_type=model_args.bnb_4bit_quant_type,\n+                bnb_4bit_use_double_quant=model_args.use_bnb_nested_quant,\n+                bnb_4bit_quant_storage=model_args.torch_dtype,\n+            )\n+        elif model_args.load_in_8bit:\n+            quantization_config = BitsAndBytesConfig(\n+                load_in_8bit=True,\n+            )\n+        else:\n+            quantization_config = None\n+\n+        return quantization_config\n+\n+    def load_model_and_tokenizer(\n+        self, model_id_and_revision: str, args: ServeArguments\n+    ) -> tuple[PreTrainedModel, PreTrainedTokenizerFast]:\n+        logger.warning(f\"Loading {model_id_and_revision}\")\n+\n+        if \"@\" in model_id_and_revision:\n+            model_id, revision = model_id_and_revision.split(\"@\", 1)\n+        else:\n+            model_id, revision = model_id_and_revision, \"main\"\n+\n+        tokenizer = AutoTokenizer.from_pretrained(\n+            model_id,\n+            revision=revision,\n+            trust_remote_code=args.trust_remote_code,\n+        )\n+\n+        torch_dtype = args.torch_dtype if args.torch_dtype in [\"auto\", None] else getattr(torch, args.torch_dtype)\n+        quantization_config = self.get_quantization_config(args)\n+\n+        model_kwargs = {\n+            \"revision\": revision,\n+            \"attn_implementation\": args.attn_implementation,\n+            \"torch_dtype\": torch_dtype,\n+            \"device_map\": \"auto\",\n+            \"quantization_config\": quantization_config,\n+            \"trust_remote_code\": args.trust_remote_code,\n+        }\n+\n+        model = AutoModelForCausalLM.from_pretrained(model_id, **model_kwargs)\n+\n+        if model.generation_config.max_new_tokens is not None and model.generation_config.max_new_tokens < 256:\n+            model.generation_config.max_new_tokens = 256\n+\n+        if getattr(model, \"hf_device_map\", None) is None:\n+            model = model.to(args.device)\n+\n+        self.loaded_model = model_id_and_revision\n+\n+        print(\"Loaded model\", model_id_and_revision)\n+        return model, tokenizer\n \n-        # Check we don't have empty string\n-        if len(inputs) == 0:\n-            return ServeForwardResult(output=[], attention=[])\n \n-        try:\n-            # Forward through the model\n-            output = self._pipeline(inputs)\n-            return ServeForwardResult(output=output)\n-        except Exception as e:\n-            raise HTTPException(500, {\"error\": str(e)})\n+if __name__ == \"__main__\":\n+    serve = ServeCommand()\n+    serve.run()"
        },
        {
            "sha": "5e8b2b6598bc8b4d814829579706b2d18e6aa9fd",
            "filename": "src/transformers/dependency_versions_table.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/e8f90b5397df419f211498ef399f9255790b8428/src%2Ftransformers%2Fdependency_versions_table.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e8f90b5397df419f211498ef399f9255790b8428/src%2Ftransformers%2Fdependency_versions_table.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fdependency_versions_table.py?ref=e8f90b5397df419f211498ef399f9255790b8428",
            "patch": "@@ -54,7 +54,7 @@\n     \"protobuf\": \"protobuf\",\n     \"psutil\": \"psutil\",\n     \"pyyaml\": \"pyyaml>=5.1\",\n-    \"pydantic\": \"pydantic\",\n+    \"pydantic\": \"pydantic>=2\",\n     \"pytest\": \"pytest>=7.2.0\",\n     \"pytest-asyncio\": \"pytest-asyncio\",\n     \"pytest-rerunfailures\": \"pytest-rerunfailures\","
        },
        {
            "sha": "eae1ee919881e4affb537a16e3de944c31d42c20",
            "filename": "src/transformers/generation/continuous_batching.py",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/huggingface/transformers/blob/e8f90b5397df419f211498ef399f9255790b8428/src%2Ftransformers%2Fgeneration%2Fcontinuous_batching.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e8f90b5397df419f211498ef399f9255790b8428/src%2Ftransformers%2Fgeneration%2Fcontinuous_batching.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fgeneration%2Fcontinuous_batching.py?ref=e8f90b5397df419f211498ef399f9255790b8428",
            "patch": "@@ -27,6 +27,8 @@\n \n import torch\n import torch.nn as nn\n+from tokenizers import Tokenizer\n+from tokenizers.decoders import DecodeStream\n from torch.profiler import profile, schedule, tensorboard_trace_handler\n from tqdm import tqdm\n \n@@ -72,6 +74,7 @@ class GenerationOutput:\n     error: Optional[str] = None\n     status: RequestStatus = RequestStatus.PENDING\n     created_time: float = field(default_factory=time.time)\n+    next_token: Optional[int] = field(default_factory=int)\n \n \n @dataclass\n@@ -96,6 +99,7 @@ class RequestState:\n     eos_token_id: int = -1\n     created_time: float = field(default_factory=time.time)\n     error: Optional[str] = None\n+    next_token: Optional[str] = None\n \n     def current_len(self) -> int:\n         \"\"\"Get the current length of the sequence (prompt + generated tokens).\"\"\"\n@@ -139,6 +143,7 @@ def to_generation_output(self):\n             generated_tokens=self.static_outputs,\n             logprobs=[],\n             error=self.error,\n+            next_token=self.next_token,\n         )\n \n \n@@ -764,6 +769,9 @@ def __init__(\n \n         self.setup_static_tensors()\n \n+        self.tokenizer = Tokenizer.from_pretrained(self.config._name_or_path)\n+        self.decode_stream = DecodeStream(skip_special_tokens=True)\n+\n     @traced(standalone=True)\n     def setup_static_tensors(self):\n         T = self.max_batch_tokens\n@@ -995,7 +1003,7 @@ def _sync(self):\n     def _maybe_send_output(self, state: RequestState, token: int):\n         \"\"\"Send output to the queue based on streaming mode and request state.\"\"\"\n         if self.streaming:\n-            state.next_token = token\n+            state.next_token = self.decode_stream.step(self.tokenizer, state.static_outputs[-1])\n             self.output_queue.put(state.to_generation_output())\n         elif state.status == RequestStatus.FINISHED:\n             self.output_queue.put(state.to_generation_output())\n@@ -1102,6 +1110,7 @@ def __init__(\n         self.profile = getattr(generation_config, \"profile\", False)\n         self.manual_eviction = manual_eviction\n         self.batch_processor: Optional[ContinuousBatchProcessor] = None\n+        self.decode_stream = DecodeStream(skip_special_tokens=True)\n \n     @traced\n     def start(self):"
        },
        {
            "sha": "9f90f9e17b195c683639b1c7b8f294ce540b3435",
            "filename": "src/transformers/utils/import_utils.py",
            "status": "modified",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/huggingface/transformers/blob/e8f90b5397df419f211498ef399f9255790b8428/src%2Ftransformers%2Futils%2Fimport_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e8f90b5397df419f211498ef399f9255790b8428/src%2Ftransformers%2Futils%2Fimport_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fimport_utils.py?ref=e8f90b5397df419f211498ef399f9255790b8428",
            "patch": "@@ -292,6 +292,30 @@ def _is_package_available(pkg_name: str, return_version: bool = False) -> Union[\n     _essentia_version = False\n \n \n+_pydantic_available = importlib.util.find_spec(\"pydantic\") is not None\n+try:\n+    _pydantic_version = importlib.metadata.version(\"pydantic\")\n+    logger.debug(f\"Successfully imported pydantic version {_pydantic_version}\")\n+except importlib.metadata.PackageNotFoundError:\n+    _pydantic_available = False\n+\n+\n+_fastapi_available = importlib.util.find_spec(\"fastapi\") is not None\n+try:\n+    _fastapi_version = importlib.metadata.version(\"fastapi\")\n+    logger.debug(f\"Successfully imported pydantic version {_fastapi_version}\")\n+except importlib.metadata.PackageNotFoundError:\n+    _fastapi_available = False\n+\n+\n+_uvicorn_available = importlib.util.find_spec(\"uvicorn\") is not None\n+try:\n+    _uvicorn_version = importlib.metadata.version(\"uvicorn\")\n+    logger.debug(f\"Successfully imported pydantic version {_uvicorn_version}\")\n+except importlib.metadata.PackageNotFoundError:\n+    _uvicorn_available = False\n+\n+\n _pretty_midi_available = importlib.util.find_spec(\"pretty_midi\") is not None\n try:\n     _pretty_midi_version = importlib.metadata.version(\"pretty_midi\")\n@@ -473,6 +497,18 @@ def is_essentia_available():\n     return _essentia_available\n \n \n+def is_pydantic_available():\n+    return _pydantic_available\n+\n+\n+def is_fastapi_available():\n+    return _fastapi_available\n+\n+\n+def is_uvicorn_available():\n+    return _uvicorn_available\n+\n+\n def is_pretty_midi_available():\n     return _pretty_midi_available\n \n@@ -1843,6 +1879,23 @@ def check_torch_load_is_safe():\n `pip install pillow`. Please note that you may need to restart your runtime after installation.\n \"\"\"\n \n+# docstyle-ignore\n+PYDANTIC_IMPORT_ERROR = \"\"\"\n+{0} requires the pydantic library but it was not found in your environment. You can install it with pip:\n+`pip install pydantic`. Please note that you may need to restart your runtime after installation.\n+\"\"\"\n+\n+# docstyle-ignore\n+FASTAPI_IMPORT_ERROR = \"\"\"\n+{0} requires the fastapi library but it was not found in your environment. You can install it with pip:\n+`pip install fastapi`. Please note that you may need to restart your runtime after installation.\n+\"\"\"\n+\n+# docstyle-ignore\n+UVICORN_IMPORT_ERROR = \"\"\"\n+{0} requires the uvicorn library but it was not found in your environment. You can install it with pip:\n+`pip install uvicorn`. Please note that you may need to restart your runtime after installation.\n+\"\"\"\n \n # docstyle-ignore\n PYTESSERACT_IMPORT_ERROR = \"\"\"\n@@ -1966,6 +2019,9 @@ def check_torch_load_is_safe():\n         (\"yt_dlp\", (is_yt_dlp_available, YT_DLP_IMPORT_ERROR)),\n         (\"rich\", (is_rich_available, RICH_IMPORT_ERROR)),\n         (\"keras_nlp\", (is_keras_nlp_available, KERAS_NLP_IMPORT_ERROR)),\n+        (\"pydantic\", (is_pydantic_available, PYDANTIC_IMPORT_ERROR)),\n+        (\"fastapi\", (is_fastapi_available, FASTAPI_IMPORT_ERROR)),\n+        (\"uvicorn\", (is_uvicorn_available, UVICORN_IMPORT_ERROR)),\n     ]\n )\n "
        },
        {
            "sha": "b1b32d7cc3ff8585fc4255a67c9e56bd82f9b6df",
            "filename": "tests/commands/test_chat.py",
            "status": "added",
            "additions": 65,
            "deletions": 0,
            "changes": 65,
            "blob_url": "https://github.com/huggingface/transformers/blob/e8f90b5397df419f211498ef399f9255790b8428/tests%2Fcommands%2Ftest_chat.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e8f90b5397df419f211498ef399f9255790b8428/tests%2Fcommands%2Ftest_chat.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fcommands%2Ftest_chat.py?ref=e8f90b5397df419f211498ef399f9255790b8428",
            "patch": "@@ -0,0 +1,65 @@\n+import os\n+import tempfile\n+import unittest\n+from unittest.mock import patch\n+\n+import transformers.commands.transformers_cli as cli\n+from transformers.commands.chat import ChatArguments, ChatCommand\n+from transformers.testing_utils import CaptureStd\n+\n+\n+class ChatCLITest(unittest.TestCase):\n+    def test_help(self):\n+        with patch(\"sys.argv\", [\"transformers\", \"chat\", \"--help\"]), CaptureStd() as cs:\n+            with self.assertRaises(SystemExit):\n+                cli.main()\n+        self.assertIn(\"chat interface\", cs.out.lower())\n+\n+    @patch.object(ChatCommand, \"run\")\n+    def test_cli_dispatch(self, run_mock):\n+        args = [\"transformers\", \"chat\", \"hf-internal-testing/tiny-random-gpt2\"]\n+        with patch(\"sys.argv\", args):\n+            cli.main()\n+        run_mock.assert_called_once()\n+\n+    def test_parsed_args(self):\n+        with (\n+            patch.object(ChatCommand, \"__init__\", return_value=None) as init_mock,\n+            patch.object(ChatCommand, \"run\") as run_mock,\n+            patch(\n+                \"sys.argv\",\n+                [\n+                    \"transformers\",\n+                    \"chat\",\n+                    \"test-model\",\n+                    \"max_new_tokens=64\",\n+                ],\n+            ),\n+        ):\n+            cli.main()\n+        init_mock.assert_called_once()\n+        run_mock.assert_called_once()\n+        parsed_args = init_mock.call_args[0][0]\n+        self.assertEqual(parsed_args.model_name_or_path_or_address, \"test-model\")\n+        self.assertEqual(parsed_args.generate_flags, [\"max_new_tokens=64\"])\n+\n+\n+class ChatUtilitiesTest(unittest.TestCase):\n+    def test_save_and_clear_chat(self):\n+        tmp_path = tempfile.mkdtemp()\n+\n+        args = ChatArguments(save_folder=str(tmp_path))\n+        args.model_name_or_path_or_address = \"test-model\"\n+\n+        chat_history = [{\"role\": \"user\", \"content\": \"hi\"}]\n+        filename = ChatCommand.save_chat(chat_history, args)\n+        self.assertTrue(os.path.isfile(filename))\n+\n+        cleared = ChatCommand.clear_chat_history()\n+        self.assertEqual(cleared, [])\n+\n+    def test_parse_generate_flags(self):\n+        dummy = ChatCommand.__new__(ChatCommand)\n+        parsed = ChatCommand.parse_generate_flags(dummy, [\"temperature=0.5\", \"max_new_tokens=10\"])\n+        self.assertEqual(parsed[\"temperature\"], 0.5)\n+        self.assertEqual(parsed[\"max_new_tokens\"], 10)"
        },
        {
            "sha": "4e2c545e0b57a878093c510553ee6f6a525190a0",
            "filename": "tests/commands/test_serving.py",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/huggingface/transformers/blob/e8f90b5397df419f211498ef399f9255790b8428/tests%2Fcommands%2Ftest_serving.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/e8f90b5397df419f211498ef399f9255790b8428/tests%2Fcommands%2Ftest_serving.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fcommands%2Ftest_serving.py?ref=e8f90b5397df419f211498ef399f9255790b8428",
            "patch": "@@ -0,0 +1,34 @@\n+import unittest\n+from unittest.mock import patch\n+\n+import transformers.commands.transformers_cli as cli\n+from transformers.commands.serving import ServeCommand\n+from transformers.testing_utils import CaptureStd\n+\n+\n+class ServeCLITest(unittest.TestCase):\n+    def test_help(self):\n+        with patch(\"sys.argv\", [\"transformers\", \"serve\", \"--help\"]), CaptureStd() as cs:\n+            with self.assertRaises(SystemExit):\n+                cli.main()\n+        self.assertIn(\"serve\", cs.out.lower())\n+\n+    def test_parsed_args(self):\n+        with (\n+            patch.object(ServeCommand, \"__init__\", return_value=None) as init_mock,\n+            patch.object(ServeCommand, \"run\") as run_mock,\n+            patch(\"sys.argv\", [\"transformers\", \"serve\", \"--host\", \"0.0.0.0\", \"--port\", \"9000\"]),\n+        ):\n+            cli.main()\n+        init_mock.assert_called_once()\n+        run_mock.assert_called_once()\n+        parsed_args = init_mock.call_args[0][0]\n+        self.assertEqual(parsed_args.host, \"0.0.0.0\")\n+        self.assertEqual(parsed_args.port, 9000)\n+\n+    def test_build_chunk(self):\n+        dummy = ServeCommand.__new__(ServeCommand)\n+        dummy.args = type(\"Args\", (), {})()\n+        chunk = ServeCommand.build_chunk(dummy, \"hello\", \"req0\", finish_reason=\"stop\")\n+        self.assertIn(\"chat.completion.chunk\", chunk)\n+        self.assertIn(\"data:\", chunk)"
        }
    ],
    "stats": {
        "total": 1225,
        "additions": 915,
        "deletions": 310
    }
}