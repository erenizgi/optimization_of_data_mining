{
    "author": "ShuaiBai623",
    "message": "add qwen2.5vl (#35569)\n\n* add qwen2.5vl\n\n* fix\n\n* pass check table\n\n* add modular file\n\n* fix style\n\n* Update src/transformers/models/qwen2_5_vl/modeling_qwen2_5_vl.py\n\nCo-authored-by: Minho Shim <6764739+minostauros@users.noreply.github.com>\n\n* Update src/transformers/models/qwen2_5_vl/modeling_qwen2_5_vl.py\n\nCo-authored-by: Minho Shim <6764739+minostauros@users.noreply.github.com>\n\n* Update src/transformers/models/qwen2_5_vl/modeling_qwen2_5_vl.py\n\nCo-authored-by: Minho Shim <6764739+minostauros@users.noreply.github.com>\n\n* padd copy check\n\n* use modular\n\n* fix\n\n* fix\n\n* fix\n\n* update flashatt2&sdpa support_list\n\n* Update docs/source/en/_toctree.yml\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/qwen2_5_vl.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/qwen2_5_vl.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/qwen2_5_vl.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update docs/source/en/model_doc/qwen2_5_vl.md\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* Update src/transformers/models/qwen2_5_vl/modular_qwen2_5_vl.py\n\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\n\n* update config\n\n* update\n\n* fix hf path\n\n* rename Qwen2_5_VLVideosKwargs\n\n* fix\n\n* fix\n\n* update\n\n* excuted modular\n\n* rollback init\n\n* fix\n\n* formated\n\n* simpler init\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* fix\n\n* update docs\n\n* fix\n\n* fix\n\n* update Qwen2VLRotaryEmbedding for yarn\n\n* fix\n\n---------\n\nCo-authored-by: Minho Shim <6764739+minostauros@users.noreply.github.com>\nCo-authored-by: Steven Liu <59462357+stevhliu@users.noreply.github.com>\nCo-authored-by: gewenbin0992 <gewenbin292@163.com>\nCo-authored-by: gewenbin0992 <67409248+gewenbin0992@users.noreply.github.com>",
    "sha": "f3f6c86582611976e72be054675e2bf0abb5f775",
    "files": [
        {
            "sha": "4eb5b14e237837ad50136aa81011568dcdd39e6b",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -928,6 +928,8 @@\n         title: Pix2Struct\n       - local: model_doc/pixtral\n         title: Pixtral\n+      - local: model_doc/qwen2_5_vl\n+        title: Qwen2.5-VL\n       - local: model_doc/qwen2_audio\n         title: Qwen2Audio\n       - local: model_doc/qwen2_vl"
        },
        {
            "sha": "7d6a9c188d40dc0b61bcbab7b2600c042da58591",
            "filename": "docs/source/en/index.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/docs%2Fsource%2Fen%2Findex.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/docs%2Fsource%2Fen%2Findex.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Findex.md?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -285,6 +285,7 @@ Flax), PyTorch, and/or TensorFlow.\n |                        [PVTv2](model_doc/pvt_v2)                         |       âœ…        |         âŒ         |      âŒ      |\n |                       [QDQBert](model_doc/qdqbert)                       |       âœ…        |         âŒ         |      âŒ      |\n |                         [Qwen2](model_doc/qwen2)                         |       âœ…        |         âŒ         |      âŒ      |\n+|                    [Qwen2_5_VL](model_doc/qwen2_5_vl)                    |       âœ…        |         âŒ         |      âŒ      |\n |                   [Qwen2Audio](model_doc/qwen2_audio)                    |       âœ…        |         âŒ         |      âŒ      |\n |                     [Qwen2MoE](model_doc/qwen2_moe)                      |       âœ…        |         âŒ         |      âŒ      |\n |                      [Qwen2VL](model_doc/qwen2_vl)                       |       âœ…        |         âŒ         |      âŒ      |"
        },
        {
            "sha": "9bfcb6ae0f62f5ec0f50f88ce7723a95cf75737f",
            "filename": "docs/source/en/model_doc/qwen2_5_vl.md",
            "status": "added",
            "additions": 300,
            "deletions": 0,
            "changes": 300,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen2_5_vl.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen2_5_vl.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fqwen2_5_vl.md?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -0,0 +1,300 @@\n+<!--Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# Qwen2.5-VL\n+\n+## Overview\n+\n+The [Qwen2.5-VL](https://qwenlm.github.io/blog/qwen2_5-vl/) model is an update to [Qwen2-VL](https://arxiv.org/abs/2409.12191) from Qwen team, Alibaba Group. \n+\n+The abstract from this update is the following:\n+\n+*Qwen2.5-VL marks a major step forward from Qwen2-VL, built upon the latest Qwen2.5 LLM. We've accelerated training and testing through the strategic implementation of window attention within the ViT. The ViT architecture itself has been refined with SwiGLU and RMSNorm, aligning it more closely with the LLM's structure. A key innovation is the expansion of native dynamic resolution to encompass the temporal dimension, in addition to spatial aspects. Furthermore, we've upgraded MRoPE, incorporating absolute time alignment on the time axis to allow the model to effectively capture temporal dynamics, regardless of frame rate, leading to superior video understanding.*\n+\n+## Usage example\n+\n+### Single Media inference\n+\n+The model can accept both images and videos as input. Here's an example code for inference.\n+\n+```python\n+\n+from PIL import Image\n+import requests\n+import torch\n+from torchvision import io\n+from typing import Dict\n+from transformers.image_utils import load_images, load_video\n+from transformers import Qwen2_5_VLForConditionalGeneration, AutoTokenizer, AutoProcessor\n+\n+# Load the model in half-precision on the available device(s)\n+model = Qwen2_5_VLForConditionalGeneration.from_pretrained(\"Qwen/Qwen2.5-VL-7B-Instruct\", device_map=\"auto\")\n+processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2.5-VL-7B-Instruct\")\n+\n+# Image\n+url = \"https://qianwen-res.oss-cn-beijing.aliyuncs.com/Qwen-VL/assets/demo.jpeg\"\n+image = Image.open(requests.get(url, stream=True).raw)\n+\n+conversation = [\n+    {\n+        \"role\":\"user\",\n+        \"content\":[\n+            {\n+                \"type\":\"image\",\n+            },\n+            {\n+                \"type\":\"text\",\n+                \"text\":\"Describe this image.\"\n+            }\n+        ]\n+    }\n+]\n+\n+\n+# Preprocess the inputs\n+text_prompt = processor.apply_chat_template(conversation, add_generation_prompt=True)\n+# Excepted output: '<|im_start|>system\\nYou are a helpful assistant.<|im_end|>\\n<|im_start|>user\\n<|vision_start|><|image_pad|><|vision_end|>Describe this image.<|im_end|>\\n<|im_start|>assistant\\n'\n+\n+inputs = processor(text=[text_prompt], images=[image], padding=True, return_tensors=\"pt\")\n+inputs = inputs.to('cuda')\n+\n+# Inference: Generation of the output\n+output_ids = model.generate(**inputs, max_new_tokens=128)\n+generated_ids = [output_ids[len(input_ids):] for input_ids, output_ids in zip(inputs.input_ids, output_ids)]\n+output_text = processor.batch_decode(generated_ids, skip_special_tokens=True, clean_up_tokenization_spaces=True)\n+print(output_text)\n+\n+# Video\n+video = load_video(video=\"/path/to/video.mp4\")\n+conversation = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"video\"},\n+            {\"type\": \"text\", \"text\": \"What happened in the video?\"},\n+        ],\n+    }\n+]\n+\n+# Preprocess the inputs\n+text_prompt = processor.apply_chat_template(conversation, add_generation_prompt=True)\n+# Excepted output: '<|im_start|>system\\nYou are a helpful assistant.<|im_end|>\\n<|im_start|>user\\n<|vision_start|><|video_pad|><|vision_end|>What happened in the video?<|im_end|>\\n<|im_start|>assistant\\n'\n+\n+# Qwen2.5VL modifies the time positional encoding (MRoPE) according to the video's frame rate (FPS).\n+# Therefore, the video's FPS information needs to be provided as input.\n+inputs = processor(text=[text_prompt], videos=[video], fps=[1.0], padding=True, return_tensors=\"pt\")\n+inputs = inputs.to('cuda')\n+\n+# Inference: Generation of the output\n+output_ids = model.generate(**inputs, max_new_tokens=128)\n+generated_ids = [output_ids[len(input_ids):] for input_ids, output_ids in zip(inputs.input_ids, output_ids)]\n+output_text = processor.batch_decode(generated_ids, skip_special_tokens=True, clean_up_tokenization_spaces=True)\n+print(output_text)\n+```\n+\n+### Batch Mixed Media Inference\n+\n+The model can batch inputs composed of mixed samples of various types such as images, videos, and text. Here is an example.\n+\n+```python\n+images = load_images([\n+    \"/path/to/image1.jpg\",\n+    \"/path/to/image2.jpg\",\n+    \"/path/to/image3.jpg\",\n+    \"/path/to/image4.jpg\",\n+    \"/path/to/image5.jpg\",\n+])\n+video = load_video(video=\"/path/to/video.mp4\")\n+\n+# Conversation for the first image\n+conversation1 = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\"},\n+            {\"type\": \"text\", \"text\": \"Describe this image.\"}\n+        ]\n+    }\n+]\n+\n+# Conversation with two images\n+conversation2 = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\"},\n+            {\"type\": \"image\"},\n+            {\"type\": \"text\", \"text\": \"What is written in the pictures?\"}\n+        ]\n+    }\n+]\n+\n+# Conversation with pure text\n+conversation3 = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": \"who are you?\"\n+    }\n+]\n+\n+\n+# Conversation with mixed midia\n+conversation4 = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\"},\n+            {\"type\": \"image\"},\n+            {\"type\": \"video\"},\n+            {\"type\": \"text\", \"text\": \"What are the common elements in these medias?\"},\n+        ],\n+    }\n+]\n+\n+conversations = [conversation1, conversation2, conversation3, conversation4]\n+# Preparation for batch inference\n+texts = [processor.apply_chat_template(msg, add_generation_prompt=True) for msg in conversations]\n+inputs = processor(\n+    text=texts,\n+    images=images,\n+    videos=[video],\n+    padding=True,\n+    return_tensors=\"pt\",\n+)\n+inputs = inputs.to('cuda')\n+\n+# Batch Inference\n+output_ids = model.generate(**inputs, max_new_tokens=128)\n+generated_ids = [output_ids[len(input_ids):] for input_ids, output_ids in zip(inputs.input_ids, output_ids)]\n+output_text = processor.batch_decode(generated_ids, skip_special_tokens=True, clean_up_tokenization_spaces=True)\n+print(output_text)\n+```\n+\n+### Usage Tips\n+\n+#### Image Resolution trade-off\n+\n+The model supports a wide range of resolution inputs. By default, it uses the native resolution for input, but higher resolutions can enhance performance at the cost of more computation. Users can set the minimum and maximum number of pixels to achieve an optimal configuration for their needs.\n+\n+```python\n+min_pixels = 224*224\n+max_pixels = 2048*2048\n+processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2.5-VL-7B-Instruct\", min_pixels=min_pixels, max_pixels=max_pixels)\n+```\n+\n+In case of limited GPU RAM, one can reduce the resolution as follows:\n+\n+```python\n+min_pixels = 256*28*28\n+max_pixels = 1024*28*28 \n+processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2.5-VL-7B-Instruct\", min_pixels=min_pixels, max_pixels=max_pixels)\n+```\n+This ensures each image gets encoded using a number between 256-1024 tokens. The 28 comes from the fact that the model uses a patch size of 14 and a temporal patch size of 2 (14 x 2 = 28).\n+\n+#### Multiple Image Inputs\n+\n+By default, images and video content are directly included in the conversation. When handling multiple images, it's helpful to add labels to the images and videos for better reference. Users can control this behavior with the following settings:\n+\n+```python\n+conversation = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"image\"}, \n+            {\"type\": \"text\", \"text\": \"Hello, how are you?\"}\n+        ]\n+    },\n+    {\n+        \"role\": \"assistant\",\n+        \"content\": \"I'm doing well, thank you for asking. How can I assist you today?\"\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\"type\": \"text\", \"text\": \"Can you describe these images and video?\"}, \n+            {\"type\": \"image\"}, \n+            {\"type\": \"image\"}, \n+            {\"type\": \"video\"}, \n+            {\"type\": \"text\", \"text\": \"These are from my vacation.\"}\n+        ]\n+    },\n+    {\n+        \"role\": \"assistant\",\n+        \"content\": \"I'd be happy to describe the images and video for you. Could you please provide more context about your vacation?\"\n+    },\n+    {\n+        \"role\": \"user\",\n+        \"content\": \"It was a trip to the mountains. Can you see the details in the images and video?\"\n+    }\n+]\n+\n+# default:\n+prompt_without_id = processor.apply_chat_template(conversation, add_generation_prompt=True)\n+# Excepted output: '<|im_start|>system\\nYou are a helpful assistant.<|im_end|>\\n<|im_start|>user\\n<|vision_start|><|image_pad|><|vision_end|>Hello, how are you?<|im_end|>\\n<|im_start|>assistant\\nI'm doing well, thank you for asking. How can I assist you today?<|im_end|>\\n<|im_start|>user\\nCan you describe these images and video?<|vision_start|><|image_pad|><|vision_end|><|vision_start|><|image_pad|><|vision_end|><|vision_start|><|video_pad|><|vision_end|>These are from my vacation.<|im_end|>\\n<|im_start|>assistant\\nI'd be happy to describe the images and video for you. Could you please provide more context about your vacation?<|im_end|>\\n<|im_start|>user\\nIt was a trip to the mountains. Can you see the details in the images and video?<|im_end|>\\n<|im_start|>assistant\\n'\n+\n+\n+# add ids\n+prompt_with_id = processor.apply_chat_template(conversation, add_generation_prompt=True, add_vision_id=True)\n+# Excepted output: '<|im_start|>system\\nYou are a helpful assistant.<|im_end|>\\n<|im_start|>user\\nPicture 1: <|vision_start|><|image_pad|><|vision_end|>Hello, how are you?<|im_end|>\\n<|im_start|>assistant\\nI'm doing well, thank you for asking. How can I assist you today?<|im_end|>\\n<|im_start|>user\\nCan you describe these images and video?Picture 2: <|vision_start|><|image_pad|><|vision_end|>Picture 3: <|vision_start|><|image_pad|><|vision_end|>Video 1: <|vision_start|><|video_pad|><|vision_end|>These are from my vacation.<|im_end|>\\n<|im_start|>assistant\\nI'd be happy to describe the images and video for you. Could you please provide more context about your vacation?<|im_end|>\\n<|im_start|>user\\nIt was a trip to the mountains. Can you see the details in the images and video?<|im_end|>\\n<|im_start|>assistant\\n'\n+\n+```\n+\n+#### Flash-Attention 2 to speed up generation\n+\n+First, make sure to install the latest version of Flash Attention 2:\n+\n+```bash\n+pip install -U flash-attn --no-build-isolation\n+```\n+\n+Also, you should have hardware that is compatible with FlashAttention 2. Read more about it in the official documentation of the [flash attention repository](https://github.com/Dao-AILab/flash-attention). FlashAttention-2 can only be used when a model is loaded in `torch.float16` or `torch.bfloat16`.\n+\n+To load and run a model using FlashAttention-2, add `attn_implementation=\"flash_attention_2\"` when loading the model:\n+\n+```python\n+from transformers import Qwen2_5_VLForConditionalGeneration\n+\n+model = Qwen2_5_VLForConditionalGeneration.from_pretrained(\n+    \"Qwen/Qwen2.5-VL-7B-Instruct\", \n+    torch_dtype=torch.bfloat16, \n+    attn_implementation=\"flash_attention_2\",\n+)\n+```\n+\n+\n+\n+## Qwen2_5_VLConfig\n+\n+[[autodoc]] Qwen2_5_VLConfig\n+\n+## Qwen2_5_VLImageProcessor\n+\n+[[autodoc]] Qwen2_5_VLImageProcessor\n+    - preprocess\n+\n+## Qwen2_5_VLProcessor\n+\n+[[autodoc]] Qwen2_5_VLProcessor\n+\n+## Qwen2_5_VLModel\n+\n+[[autodoc]] Qwen2_5_VLModel\n+    - forward\n+\n+## Qwen2_5_VLForConditionalGeneration\n+\n+[[autodoc]] Qwen2_5_VLForConditionalGeneration\n+    - forward"
        },
        {
            "sha": "0003784c585e830e7c6e8eba725fcea7337be68d",
            "filename": "docs/source/en/perf_infer_gpu_one.md",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fperf_infer_gpu_one.md?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -97,6 +97,7 @@ FlashAttention-2 is currently supported for the following architectures:\n * [Qwen2Audio](https://huggingface.co/docs/transformers/model_doc/qwen2_audio#transformers.Qwen2AudioEncoder)\n * [Qwen2MoE](https://huggingface.co/docs/transformers/model_doc/qwen2_moe#transformers.Qwen2MoeModel)\n * [Qwen2VL](https://huggingface.co/docs/transformers/model_doc/qwen2_vl#transformers.Qwen2VLModel)\n+* [Qwen2.5VL](https://huggingface.co/docs/transformers/model_doc/qwen2_5_vl#transformers.Qwen2_5_VLModel)\n * [RAG](https://huggingface.co/docs/transformers/model_doc/rag#transformers.RagModel)\n * [SpeechEncoderDecoder](https://huggingface.co/docs/transformers/model_doc/speech_encoder_decoder#transformers.SpeechEncoderDecoderModel)\n * [VisionEncoderDecoder](https://huggingface.co/docs/transformers/model_doc/vision_encoder_decoder#transformers.VisionEncoderDecoderModel)\n@@ -297,6 +298,7 @@ For now, Transformers supports SDPA inference and training for the following arc\n * [Qwen2](https://huggingface.co/docs/transformers/model_doc/qwen2#transformers.Qwen2Model)\n * [Qwen2Audio](https://huggingface.co/docs/transformers/model_doc/qwen2_audio#transformers.Qwen2AudioEncoder)\n * [Qwen2MoE](https://huggingface.co/docs/transformers/model_doc/qwen2_moe#transformers.Qwen2MoeModel)\n+* [Qwen2.5VL](https://huggingface.co/docs/transformers/model_doc/qwen2_5_vl#transformers.Qwen2_5_VLModel)\n * [RoBERTa](https://huggingface.co/docs/transformers/model_doc/roberta#transformers.RobertaModel)\n * [Sew](https://huggingface.co/docs/transformers/main/en/model_doc/sew#transformers.SEWModel)\n * [SigLIP](https://huggingface.co/docs/transformers/model_doc/siglip)"
        },
        {
            "sha": "3493634db5162c2bd04cba0af4cd8a3561e7b232",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -708,6 +708,10 @@\n         \"Qwen2Config\",\n         \"Qwen2Tokenizer\",\n     ],\n+    \"models.qwen2_5_vl\": [\n+        \"Qwen2_5_VLConfig\",\n+        \"Qwen2_5_VLProcessor\",\n+    ],\n     \"models.qwen2_audio\": [\n         \"Qwen2AudioConfig\",\n         \"Qwen2AudioEncoderConfig\",\n@@ -1263,6 +1267,7 @@\n     _import_structure[\"models.pixtral\"].append(\"PixtralImageProcessor\")\n     _import_structure[\"models.poolformer\"].extend([\"PoolFormerFeatureExtractor\", \"PoolFormerImageProcessor\"])\n     _import_structure[\"models.pvt\"].extend([\"PvtImageProcessor\"])\n+    _import_structure[\"models.qwen2_5_vl\"].extend([\"Qwen2_5_VLImageProcessor\"])\n     _import_structure[\"models.qwen2_vl\"].extend([\"Qwen2VLImageProcessor\"])\n     _import_structure[\"models.rt_detr\"].extend([\"RTDetrImageProcessor\"])\n     _import_structure[\"models.sam\"].extend([\"SamImageProcessor\"])\n@@ -3276,6 +3281,13 @@\n             \"Qwen2PreTrainedModel\",\n         ]\n     )\n+    _import_structure[\"models.qwen2_5_vl\"].extend(\n+        [\n+            \"Qwen2_5_VLForConditionalGeneration\",\n+            \"Qwen2_5_VLModel\",\n+            \"Qwen2_5_VLPreTrainedModel\",\n+        ]\n+    )\n     _import_structure[\"models.qwen2_audio\"].extend(\n         [\n             \"Qwen2AudioEncoder\",\n@@ -5783,6 +5795,10 @@\n     from .models.pvt import PvtConfig\n     from .models.pvt_v2 import PvtV2Config\n     from .models.qwen2 import Qwen2Config, Qwen2Tokenizer\n+    from .models.qwen2_5_vl import (\n+        Qwen2_5_VLConfig,\n+        Qwen2_5_VLProcessor,\n+    )\n     from .models.qwen2_audio import (\n         Qwen2AudioConfig,\n         Qwen2AudioEncoderConfig,\n@@ -6362,6 +6378,7 @@\n             PoolFormerImageProcessor,\n         )\n         from .models.pvt import PvtImageProcessor\n+        from .models.qwen2_5_vl import Qwen2_5_VLImageProcessor\n         from .models.qwen2_vl import Qwen2VLImageProcessor\n         from .models.rt_detr import RTDetrImageProcessor\n         from .models.sam import SamImageProcessor\n@@ -7980,6 +7997,11 @@\n             Qwen2Model,\n             Qwen2PreTrainedModel,\n         )\n+        from .models.qwen2_5_vl import (\n+            Qwen2_5_VLForConditionalGeneration,\n+            Qwen2_5_VLModel,\n+            Qwen2_5_VLPreTrainedModel,\n+        )\n         from .models.qwen2_audio import (\n             Qwen2AudioEncoder,\n             Qwen2AudioForConditionalGeneration,"
        },
        {
            "sha": "f196cedd3d236b7778856a95dfa47626d3b52b55",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -216,6 +216,7 @@\n     pvt,\n     pvt_v2,\n     qwen2,\n+    qwen2_5_vl,\n     qwen2_audio,\n     qwen2_moe,\n     qwen2_vl,"
        },
        {
            "sha": "aaac3551d62264675ab609ebbd882c3aa172f562",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -237,6 +237,7 @@\n         (\"pvt_v2\", \"PvtV2Config\"),\n         (\"qdqbert\", \"QDQBertConfig\"),\n         (\"qwen2\", \"Qwen2Config\"),\n+        (\"qwen2_5_vl\", \"Qwen2_5_VLConfig\"),\n         (\"qwen2_audio\", \"Qwen2AudioConfig\"),\n         (\"qwen2_audio_encoder\", \"Qwen2AudioEncoderConfig\"),\n         (\"qwen2_moe\", \"Qwen2MoeConfig\"),\n@@ -573,6 +574,7 @@\n         (\"pvt_v2\", \"PVTv2\"),\n         (\"qdqbert\", \"QDQBert\"),\n         (\"qwen2\", \"Qwen2\"),\n+        (\"qwen2_5_vl\", \"Qwen2_5_VL\"),\n         (\"qwen2_audio\", \"Qwen2Audio\"),\n         (\"qwen2_audio_encoder\", \"Qwen2AudioEncoder\"),\n         (\"qwen2_moe\", \"Qwen2MoE\"),"
        },
        {
            "sha": "a3029bf650a9be601141896e804e38780aeb9372",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -221,6 +221,7 @@\n         (\"pvt_v2\", \"PvtV2Model\"),\n         (\"qdqbert\", \"QDQBertModel\"),\n         (\"qwen2\", \"Qwen2Model\"),\n+        (\"qwen2_5_vl\", \"Qwen2_5_VLModel\"),\n         (\"qwen2_audio_encoder\", \"Qwen2AudioEncoder\"),\n         (\"qwen2_moe\", \"Qwen2MoeModel\"),\n         (\"qwen2_vl\", \"Qwen2VLModel\"),\n@@ -785,6 +786,7 @@\n         (\"mllama\", \"MllamaForConditionalGeneration\"),\n         (\"paligemma\", \"PaliGemmaForConditionalGeneration\"),\n         (\"pix2struct\", \"Pix2StructForConditionalGeneration\"),\n+        (\"qwen2_5_vl\", \"Qwen2_5_VLForConditionalGeneration\"),\n         (\"qwen2_vl\", \"Qwen2VLForConditionalGeneration\"),\n         (\"video_llava\", \"VideoLlavaForConditionalGeneration\"),\n         (\"vipllava\", \"VipLlavaForConditionalGeneration\"),\n@@ -819,6 +821,7 @@\n         (\"paligemma\", \"PaliGemmaForConditionalGeneration\"),\n         (\"pix2struct\", \"Pix2StructForConditionalGeneration\"),\n         (\"pixtral\", \"LlavaForConditionalGeneration\"),\n+        (\"qwen2_5_vl\", \"Qwen2_5_VLForConditionalGeneration\"),\n         (\"qwen2_vl\", \"Qwen2VLForConditionalGeneration\"),\n         (\"udop\", \"UdopForConditionalGeneration\"),\n         (\"vipllava\", \"VipLlavaForConditionalGeneration\"),"
        },
        {
            "sha": "678b66a397c6514190ea96f465498bad7229ec7a",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -90,6 +90,7 @@\n         (\"pix2struct\", \"Pix2StructProcessor\"),\n         (\"pixtral\", \"PixtralProcessor\"),\n         (\"pop2piano\", \"Pop2PianoProcessor\"),\n+        (\"qwen2_5_vl\", \"Qwen2_5_VLProcessor\"),\n         (\"qwen2_audio\", \"Qwen2AudioProcessor\"),\n         (\"qwen2_vl\", \"Qwen2VLProcessor\"),\n         (\"sam\", \"SamProcessor\"),"
        },
        {
            "sha": "ad273627efe838178ca38f96e2ea45059e55b2dc",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -422,6 +422,7 @@\n                     \"Qwen2TokenizerFast\" if is_tokenizers_available() else None,\n                 ),\n             ),\n+            (\"qwen2_5_vl\", (\"Qwen2Tokenizer\", \"Qwen2TokenizerFast\" if is_tokenizers_available() else None)),\n             (\"qwen2_audio\", (\"Qwen2Tokenizer\", \"Qwen2TokenizerFast\" if is_tokenizers_available() else None)),\n             (\n                 \"qwen2_moe\","
        },
        {
            "sha": "5d3cd215b070f5babd5ea3736ae92cbb6d26628b",
            "filename": "src/transformers/models/qwen2_5_vl/__init__.py",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2F__init__.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -0,0 +1,29 @@\n+# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_qwen2_5_vl import *\n+    from .image_processing_qwen2_5_vl import *\n+    from .modeling_qwen2_5_vl import *\n+    from .processing_qwen2_5_vl import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "a1cf06d94e87da81dac2db3b9ebcec83558872cc",
            "filename": "src/transformers/models/qwen2_5_vl/configuration_qwen2_5_vl.py",
            "status": "added",
            "additions": 253,
            "deletions": 0,
            "changes": 253,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fconfiguration_qwen2_5_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fconfiguration_qwen2_5_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fconfiguration_qwen2_5_vl.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -0,0 +1,253 @@\n+#                ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨\n+#           This file was automatically generated from src/transformers/models/qwen2_5_vl/modular_qwen2_5_vl.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_qwen2_5_vl.py file directly. One of our CI enforces this.\n+#                ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨\n+# coding=utf-8\n+# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from ...configuration_utils import PretrainedConfig\n+from ...modeling_rope_utils import rope_config_validation\n+\n+\n+class Qwen2_5_VLVisionConfig(PretrainedConfig):\n+    model_type = \"qwen2_5_vl\"\n+    base_config_key = \"vision_config\"\n+\n+    def __init__(\n+        self,\n+        depth=32,\n+        hidden_size=3584,\n+        hidden_act=\"silu\",\n+        intermediate_size=3420,\n+        num_heads=16,\n+        in_channels=3,\n+        patch_size=14,\n+        spatial_merge_size=2,\n+        temporal_patch_size=2,\n+        tokens_per_second=4,\n+        window_size=112,\n+        out_hidden_size=3584,\n+        fullatt_block_indexes=[7, 15, 23, 31],\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.depth = depth\n+        self.hidden_size = hidden_size\n+        self.hidden_act = hidden_act\n+        self.intermediate_size = intermediate_size\n+        self.num_heads = num_heads\n+        self.in_channels = in_channels\n+        self.patch_size = patch_size\n+        self.spatial_merge_size = spatial_merge_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.tokens_per_second = tokens_per_second\n+        self.window_size = window_size\n+        self.fullatt_block_indexes = fullatt_block_indexes\n+        self.out_hidden_size = out_hidden_size\n+\n+\n+class Qwen2_5_VLConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Qwen2_5_VLModel`]. It is used to instantiate a\n+    Qwen2-VL model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of\n+    Qwen2-VL-7B-Instruct [Qwen/Qwen2-VL-7B-Instruct](https://huggingface.co/Qwen/Qwen2-VL-7B-Instruct).\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+\n+    Args:\n+        vocab_size (`int`, *optional*, defaults to 152064):\n+            Vocabulary size of the Qwen2_5_VL model. Defines the number of different tokens that can be represented by the\n+            `inputs_ids` passed when calling [`Qwen2_5_VLModel`]\n+        hidden_size (`int`, *optional*, defaults to 8192):\n+            Dimension of the hidden representations.\n+        intermediate_size (`int`, *optional*, defaults to 29568):\n+            Dimension of the MLP representations.\n+        num_hidden_layers (`int`, *optional*, defaults to 80):\n+            Number of hidden layers in the Transformer encoder.\n+        num_attention_heads (`int`, *optional*, defaults to 64):\n+            Number of attention heads for each attention layer in the Transformer encoder.\n+        num_key_value_heads (`int`, *optional*, defaults to 8):\n+            This is the number of key_value heads that should be used to implement Grouped Query Attention. If\n+            `num_key_value_heads=num_attention_heads`, the model will use Multi Head Attention (MHA), if\n+            `num_key_value_heads=1` the model will use Multi Query Attention (MQA) otherwise GQA is used. When\n+            converting a multi-head checkpoint to a GQA checkpoint, each group key and value head should be constructed\n+            by meanpooling all the original heads within that group. For more details checkout [this\n+            paper](https://arxiv.org/pdf/2305.13245.pdf). If it is not specified, will default to `32`.\n+        hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+            The non-linear activation function (function or string) in the decoder.\n+        max_position_embeddings (`int`, *optional*, defaults to 32768):\n+            The maximum sequence length that this model might ever be used with.\n+        initializer_range (`float`, *optional*, defaults to 0.02):\n+            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n+        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+            The epsilon used by the rms normalization layers.\n+        use_cache (`bool`, *optional*, defaults to `True`):\n+            Whether or not the model should return the last key/values attentions (not used by all models). Only\n+            relevant if `config.is_decoder=True`.\n+        tie_word_embeddings (`bool`, *optional*, defaults to `False`):\n+            Whether the model's input and output word embeddings should be tied.\n+        rope_theta (`float`, *optional*, defaults to 1000000.0):\n+            The base period of the RoPE embeddings.\n+        use_sliding_window (`bool`, *optional*, defaults to `False`):\n+            Whether to use sliding window attention.\n+        sliding_window (`int`, *optional*, defaults to 4096):\n+            Sliding window attention (SWA) window size. If not specified, will default to `4096`.\n+        max_window_layers (`int`, *optional*, defaults to 80):\n+            The number of layers that use SWA (Sliding Window Attention). The bottom layers use SWA while the top use full attention.\n+        attention_dropout (`float`, *optional*, defaults to 0.0):\n+            The dropout ratio for the attention probabilities.\n+        vision_config (`Dict`, *optional*):\n+            The config for the visual encoder initialization.\n+        rope_scaling (`Dict`, *optional*):\n+            Dictionary containing the scaling configuration for the RoPE embeddings. NOTE: if you apply new rope type\n+            and you expect the model to work on longer `max_position_embeddings`, we recommend you to update this value\n+            accordingly.\n+            Expected contents:\n+                `rope_type` (`str`):\n+                    The sub-variant of RoPE to use. Can be one of ['default', 'linear', 'dynamic', 'yarn', 'longrope',\n+                    'llama3'], with 'default' being the original RoPE implementation.\n+                `factor` (`float`, *optional*):\n+                    Used with all rope types except 'default'. The scaling factor to apply to the RoPE embeddings. In\n+                    most scaling types, a `factor` of x will enable the model to handle sequences of length x *\n+                    original maximum pre-trained length.\n+                `original_max_position_embeddings` (`int`, *optional*):\n+                    Used with 'dynamic', 'longrope' and 'llama3'. The original max position embeddings used during\n+                    pretraining.\n+                `attention_factor` (`float`, *optional*):\n+                    Used with 'yarn' and 'longrope'. The scaling factor to be applied on the attention\n+                    computation. If unspecified, it defaults to value recommended by the implementation, using the\n+                    `factor` field to infer the suggested value.\n+                `beta_fast` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for extrapolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 32.\n+                `beta_slow` (`float`, *optional*):\n+                    Only used with 'yarn'. Parameter to set the boundary for interpolation (only) in the linear\n+                    ramp function. If unspecified, it defaults to 1.\n+                `short_factor` (`List[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to short contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `long_factor` (`List[float]`, *optional*):\n+                    Only used with 'longrope'. The scaling factor to be applied to long contexts (<\n+                    `original_max_position_embeddings`). Must be a list of numbers with the same length as the hidden\n+                    size divided by the number of attention heads divided by 2\n+                `low_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to low frequency components of the RoPE\n+                `high_freq_factor` (`float`, *optional*):\n+                    Only used with 'llama3'. Scaling factor applied to high frequency components of the RoPE\n+\n+    ```python\n+    >>> from transformers import Qwen2_5_VLForConditionalGeneration, Qwen2_5_VLConfig\n+\n+    >>> # Initializing a Qwen2_5_VL style configuration\n+    >>> configuration = Qwen2_5_VLConfig()\n+\n+    >>> # Initializing a model from the Qwen2-VL-7B style configuration\n+    >>> model = Qwen2_5_VLForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"qwen2_5_vl\"\n+    sub_configs = {\"vision_config\": Qwen2_5_VLVisionConfig}\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+    # Default tensor parallel plan for base model `Qwen2_5_VL`\n+    base_model_tp_plan = {\n+        \"layers.*.self_attn.q_proj\": \"colwise\",\n+        \"layers.*.self_attn.k_proj\": \"colwise\",\n+        \"layers.*.self_attn.v_proj\": \"colwise\",\n+        \"layers.*.self_attn.o_proj\": \"rowwise\",\n+        \"layers.*.mlp.gate_proj\": \"colwise\",\n+        \"layers.*.mlp.up_proj\": \"colwise\",\n+        \"layers.*.mlp.down_proj\": \"rowwise\",\n+    }\n+\n+    def __init__(\n+        self,\n+        vocab_size=152064,\n+        hidden_size=8192,\n+        intermediate_size=29568,\n+        num_hidden_layers=80,\n+        num_attention_heads=64,\n+        num_key_value_heads=8,\n+        hidden_act=\"silu\",\n+        max_position_embeddings=32768,\n+        initializer_range=0.02,\n+        rms_norm_eps=1e-05,\n+        use_cache=True,\n+        tie_word_embeddings=False,\n+        rope_theta=1000000.0,\n+        use_sliding_window=False,\n+        sliding_window=4096,\n+        max_window_layers=80,\n+        attention_dropout=0.0,\n+        vision_config=None,\n+        rope_scaling=None,\n+        **kwargs,\n+    ):\n+        if isinstance(vision_config, dict):\n+            self.vision_config = self.sub_configs[\"vision_config\"](**vision_config)\n+        elif vision_config is None:\n+            self.vision_config = self.sub_configs[\"vision_config\"]()\n+\n+        self.vocab_size = vocab_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_attention_heads = num_attention_heads\n+        self.use_sliding_window = use_sliding_window\n+        self.sliding_window = sliding_window\n+        self.max_window_layers = max_window_layers\n+\n+        # for backward compatibility\n+        if num_key_value_heads is None:\n+            num_key_value_heads = num_attention_heads\n+\n+        self.num_key_value_heads = num_key_value_heads\n+        self.hidden_act = hidden_act\n+        self.initializer_range = initializer_range\n+        self.rms_norm_eps = rms_norm_eps\n+        self.use_cache = use_cache\n+        self.rope_theta = rope_theta\n+        self.attention_dropout = attention_dropout\n+        self.rope_scaling = rope_scaling\n+\n+        # Validate the correctness of rotary position embeddings parameters\n+        # BC: if there is a 'type' field, move it to 'rope_type'.\n+        # and change type from 'mrope' to 'default' because `mrope` does defeault RoPE calculations\n+        # one can set it to \"linear\"/\"dynamic\" etc. to have scaled RoPE\n+        # TODO: @raushan update config in the hub\n+        if self.rope_scaling is not None and \"type\" in self.rope_scaling:\n+            if self.rope_scaling[\"type\"] == \"mrope\":\n+                self.rope_scaling[\"type\"] = \"default\"\n+            self.rope_scaling[\"rope_type\"] = self.rope_scaling[\"type\"]\n+        rope_config_validation(self, ignore_keys={\"mrope_section\"})\n+\n+        super().__init__(tie_word_embeddings=tie_word_embeddings, **kwargs)\n+\n+\n+__all__ = [\"Qwen2_5_VLConfig\"]"
        },
        {
            "sha": "7101ae603598b07cb77877264b250f88f80d2f29",
            "filename": "src/transformers/models/qwen2_5_vl/image_processing_qwen2_5_vl.py",
            "status": "added",
            "additions": 468,
            "deletions": 0,
            "changes": 468,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fimage_processing_qwen2_5_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fimage_processing_qwen2_5_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fimage_processing_qwen2_5_vl.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -0,0 +1,468 @@\n+#                ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨\n+#           This file was automatically generated from src/transformers/models/qwen2_5_vl/modular_qwen2_5_vl.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_qwen2_5_vl.py file directly. One of our CI enforces this.\n+#                ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨\n+# coding=utf-8\n+# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+import math\n+from typing import Dict, List, Optional, Union\n+\n+import numpy as np\n+\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_processing_utils import BaseImageProcessor\n+from ...image_transforms import convert_to_rgb, resize, to_channel_dimension_format\n+from ...image_utils import (\n+    OPENAI_CLIP_MEAN,\n+    OPENAI_CLIP_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    VideoInput,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    is_scaled_image,\n+    is_valid_image,\n+    make_list_of_images,\n+    to_numpy_array,\n+    valid_images,\n+    validate_preprocess_arguments,\n+)\n+from ...utils import TensorType, is_vision_available, logging\n+\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+def make_batched_images(images) -> List[List[ImageInput]]:\n+    \"\"\"\n+    Accepts images in list or nested list format, and makes a list of images for preprocessing.\n+\n+    Args:\n+        images (`Union[List[List[ImageInput]], List[ImageInput], ImageInput]`):\n+            The input image.\n+\n+    Returns:\n+        list: A list of images.\n+    \"\"\"\n+    if isinstance(images, (list, tuple)) and isinstance(images[0], (list, tuple)) and is_valid_image(images[0][0]):\n+        return [img for img_list in images for img in img_list]\n+\n+    elif isinstance(images, (list, tuple)) and is_valid_image(images[0]):\n+        return images\n+\n+    elif is_valid_image(images):\n+        return [images]\n+\n+    raise ValueError(f\"Could not make batched images from {images}\")\n+\n+\n+def make_batched_videos(videos) -> List[VideoInput]:\n+    if isinstance(videos, (list, tuple)) and isinstance(videos[0], (list, tuple)) and is_valid_image(videos[0][0]):\n+        return videos\n+\n+    elif isinstance(videos, (list, tuple)) and is_valid_image(videos[0]):\n+        if isinstance(videos[0], Image.Image):\n+            return [videos]\n+        elif len(videos[0].shape) == 4:\n+            return [list(video) for video in videos]\n+\n+    elif is_valid_image(videos) and len(videos.shape) == 4:\n+        return [list(videos)]\n+\n+    raise ValueError(f\"Could not make batched video from {videos}\")\n+\n+\n+def smart_resize(\n+    height: int, width: int, factor: int = 28, min_pixels: int = 56 * 56, max_pixels: int = 14 * 14 * 4 * 1280\n+):\n+    \"\"\"Rescales the image so that the following conditions are met:\n+\n+    1. Both dimensions (height and width) are divisible by 'factor'.\n+\n+    2. The total number of pixels is within the range ['min_pixels', 'max_pixels'].\n+\n+    3. The aspect ratio of the image is maintained as closely as possible.\n+\n+    \"\"\"\n+    if height < factor or width < factor:\n+        raise ValueError(f\"height:{height} or width:{width} must be larger than factor:{factor}\")\n+    elif max(height, width) / min(height, width) > 200:\n+        raise ValueError(\n+            f\"absolute aspect ratio must be smaller than 200, got {max(height, width) / min(height, width)}\"\n+        )\n+    h_bar = round(height / factor) * factor\n+    w_bar = round(width / factor) * factor\n+    if h_bar * w_bar > max_pixels:\n+        beta = math.sqrt((height * width) / max_pixels)\n+        h_bar = math.floor(height / beta / factor) * factor\n+        w_bar = math.floor(width / beta / factor) * factor\n+    elif h_bar * w_bar < min_pixels:\n+        beta = math.sqrt(min_pixels / (height * width))\n+        h_bar = math.ceil(height * beta / factor) * factor\n+        w_bar = math.ceil(width * beta / factor) * factor\n+    return h_bar, w_bar\n+\n+\n+class Qwen2_5_VLImageProcessor(BaseImageProcessor):\n+    r\"\"\"\n+    Constructs a Qwen2.5-VL image processor that dynamically resizes images based on the original images.\n+\n+    Args:\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image's (height, width) dimensions.\n+        resample (`PILImageResampling`, *optional*, defaults to `Resampling.BICUBIC`):\n+            Resampling filter to use when resizing the image.\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image by the specified scale `rescale_factor`.\n+        rescale_factor (`int` or `float`, *optional*, defaults to `1/255`):\n+            Scale factor to use if rescaling the image.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image.\n+        image_mean (`float` or `List[float]`, *optional*, defaults to `[0.48145466, 0.4578275, 0.40821073]`):\n+            Mean to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        image_std (`float` or `List[float]`, *optional*, defaults to `[0.26862954, 0.26130258, 0.27577711]`):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB.\n+        min_pixels (`int`, *optional*, defaults to `56 * 56`):\n+            The min pixels of the image to resize the image.\n+        max_pixels (`int`, *optional*, defaults to `28 * 28 * 1280`):\n+            The max pixels of the image to resize the image.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spacial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The temporal patch size of the vision encoder.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    model_input_names = [\n+        \"pixel_values\",\n+        \"image_grid_thw\",\n+        \"pixel_values_videos\",\n+        \"video_grid_thw\",\n+        \"second_per_grid_ts\",\n+    ]\n+\n+    def __init__(\n+        self,\n+        do_resize: bool = True,\n+        resample: PILImageResampling = PILImageResampling.BICUBIC,\n+        do_rescale: bool = True,\n+        rescale_factor: Union[int, float] = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_convert_rgb: bool = True,\n+        min_pixels: int = 56 * 56,\n+        max_pixels: int = 28 * 28 * 1280,\n+        patch_size: int = 14,\n+        temporal_patch_size: int = 2,\n+        merge_size: int = 2,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        self.do_resize = do_resize\n+        self.resample = resample\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean if image_mean is not None else OPENAI_CLIP_MEAN\n+        self.image_std = image_std if image_std is not None else OPENAI_CLIP_STD\n+        self.min_pixels = min_pixels\n+        self.max_pixels = max_pixels\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.merge_size = merge_size\n+        self.size = {\"min_pixels\": min_pixels, \"max_pixels\": max_pixels}\n+        self.do_convert_rgb = do_convert_rgb\n+\n+    def _preprocess(\n+        self,\n+        images: Union[ImageInput, VideoInput],\n+        do_resize: bool = None,\n+        resample: PILImageResampling = None,\n+        do_rescale: bool = None,\n+        rescale_factor: float = None,\n+        do_normalize: bool = None,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_convert_rgb: bool = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n+\n+        Args:\n+            images (`ImageInput`):\n+                Image or batch of images to preprocess. Expects pixel values ranging from 0 to 255. If pixel values range from 0 to 1, set `do_rescale=False`.\n+            vision_info (`List[Dict]`, *optional*):\n+                Optional list of dictionaries containing additional information about vision inputs.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the `PILImageResampling` enums.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Scale factor to use if rescaling the image.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Mean to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Standard deviation to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            data_format (`ChannelDimension`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.   - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+        images = make_list_of_images(images)\n+\n+        if do_convert_rgb:\n+            images = [convert_to_rgb(image) for image in images]\n+\n+        # All transformations expect numpy arrays.\n+        images = [to_numpy_array(image) for image in images]\n+\n+        if do_rescale and is_scaled_image(images[0]):\n+            logger.warning_once(\n+                \"It looks like you are trying to rescale already rescaled images. If the input\"\n+                \" images have pixel values between 0 and 1, set `do_rescale=False` to avoid rescaling them again.\"\n+            )\n+        if input_data_format is None:\n+            # We assume that all images have the same channel dimension format.\n+            input_data_format = infer_channel_dimension_format(images[0])\n+\n+        height, width = get_image_size(images[0], channel_dim=input_data_format)\n+        resized_height, resized_width = height, width\n+        processed_images = []\n+        for image in images:\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    height,\n+                    width,\n+                    factor=self.patch_size * self.merge_size,\n+                    min_pixels=self.min_pixels,\n+                    max_pixels=self.max_pixels,\n+                )\n+                image = resize(\n+                    image, size=(resized_height, resized_width), resample=resample, input_data_format=input_data_format\n+                )\n+\n+            if do_rescale:\n+                image = self.rescale(image, scale=rescale_factor, input_data_format=input_data_format)\n+\n+            if do_normalize:\n+                image = self.normalize(\n+                    image=image, mean=image_mean, std=image_std, input_data_format=input_data_format\n+                )\n+\n+            image = to_channel_dimension_format(image, data_format, input_channel_dim=input_data_format)\n+            processed_images.append(image)\n+\n+        patches = np.array(processed_images)\n+        if data_format == ChannelDimension.LAST:\n+            patches = patches.transpose(0, 3, 1, 2)\n+        if patches.shape[0] % self.temporal_patch_size != 0:\n+            repeats = np.repeat(patches[-1][np.newaxis], self.temporal_patch_size - 1, axis=0)\n+            patches = np.concatenate([patches, repeats], axis=0)\n+        channel = patches.shape[1]\n+        grid_t = patches.shape[0] // self.temporal_patch_size\n+        grid_h, grid_w = resized_height // self.patch_size, resized_width // self.patch_size\n+        patches = patches.reshape(\n+            grid_t,\n+            self.temporal_patch_size,\n+            channel,\n+            grid_h // self.merge_size,\n+            self.merge_size,\n+            self.patch_size,\n+            grid_w // self.merge_size,\n+            self.merge_size,\n+            self.patch_size,\n+        )\n+        patches = patches.transpose(0, 3, 6, 4, 7, 2, 1, 5, 8)\n+        flatten_patches = patches.reshape(\n+            grid_t * grid_h * grid_w, channel * self.temporal_patch_size * self.patch_size * self.patch_size\n+        )\n+\n+        return flatten_patches, (grid_t, grid_h, grid_w)\n+\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        videos: VideoInput = None,\n+        do_resize: bool = None,\n+        size: Dict[str, int] = None,\n+        resample: PILImageResampling = None,\n+        do_rescale: bool = None,\n+        rescale_factor: float = None,\n+        do_normalize: bool = None,\n+        image_mean: Optional[Union[float, List[float]]] = None,\n+        image_std: Optional[Union[float, List[float]]] = None,\n+        do_convert_rgb: bool = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Args:\n+            images (`ImageInput`):\n+                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n+                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n+            videos (`VideoInput`):\n+                Video to preprocess. Expects a single or batch of videos with pixel values ranging from 0 to 255. If\n+                passing in videos with pixel values between 0 and 1, set `do_rescale=False`.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n+                the longest edge resized to keep the input aspect ratio.\n+            resample (`int`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n+                has an effect if `do_resize` is set to `True`.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n+                `True`.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                - Unset: Return a list of `np.ndarray`.\n+                - `TensorType.TENSORFLOW` or `'tf'`: Return a batch of type `tf.Tensor`.\n+                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+                - `TensorType.JAX` or `'jax'`: Return a batch of type `jax.numpy.ndarray`.\n+            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n+                from the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+\n+        \"\"\"\n+        do_resize = do_resize if do_resize is not None else self.do_resize\n+        size = size if size is not None else self.size\n+        resample = resample if resample is not None else self.resample\n+        do_rescale = do_rescale if do_rescale is not None else self.do_rescale\n+        rescale_factor = rescale_factor if rescale_factor is not None else self.rescale_factor\n+        do_normalize = do_normalize if do_normalize is not None else self.do_normalize\n+        image_mean = image_mean if image_mean is not None else self.image_mean\n+        image_std = image_std if image_std is not None else self.image_std\n+        do_convert_rgb = do_convert_rgb if do_convert_rgb is not None else self.do_convert_rgb\n+\n+        if images is not None:\n+            images = make_batched_images(images)\n+        if videos is not None:\n+            videos = make_batched_videos(videos)\n+\n+        if images is not None and not valid_images(images):\n+            raise ValueError(\n+                \"Invalid image type. Must be of type PIL.Image.Image, numpy.ndarray, \"\n+                \"torch.Tensor, tf.Tensor or jax.ndarray.\"\n+            )\n+\n+        validate_preprocess_arguments(\n+            rescale_factor=rescale_factor,\n+            do_normalize=do_normalize,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            do_resize=do_resize,\n+            size=size,\n+            resample=resample,\n+        )\n+\n+        if images is not None:\n+            pixel_values, vision_grid_thws = [], []\n+            for image in images:\n+                patches, image_grid_thw = self._preprocess(\n+                    image,\n+                    do_resize=do_resize,\n+                    resample=resample,\n+                    do_rescale=do_rescale,\n+                    rescale_factor=rescale_factor,\n+                    do_normalize=do_normalize,\n+                    image_mean=image_mean,\n+                    image_std=image_std,\n+                    data_format=data_format,\n+                    do_convert_rgb=do_convert_rgb,\n+                    input_data_format=input_data_format,\n+                )\n+                pixel_values.extend(patches)\n+                vision_grid_thws.append(image_grid_thw)\n+            pixel_values = np.array(pixel_values)\n+            vision_grid_thws = np.array(vision_grid_thws)\n+            data = {\"pixel_values\": pixel_values, \"image_grid_thw\": vision_grid_thws}\n+\n+        if videos is not None:\n+            pixel_values, vision_grid_thws = [], []\n+            for images in videos:\n+                patches, video_grid_thw = self._preprocess(\n+                    images,\n+                    do_resize=do_resize,\n+                    resample=resample,\n+                    do_rescale=do_rescale,\n+                    rescale_factor=rescale_factor,\n+                    do_normalize=do_normalize,\n+                    image_mean=image_mean,\n+                    image_std=image_std,\n+                    data_format=data_format,\n+                    do_convert_rgb=do_convert_rgb,\n+                    input_data_format=input_data_format,\n+                )\n+                pixel_values.extend(patches)\n+                vision_grid_thws.append(video_grid_thw)\n+            pixel_values = np.array(pixel_values)\n+            vision_grid_thws = np.array(vision_grid_thws)\n+            data = {\"pixel_values_videos\": pixel_values, \"video_grid_thw\": vision_grid_thws}\n+\n+        return BatchFeature(data=data, tensor_type=return_tensors)\n+\n+\n+__all__ = [\"Qwen2_5_VLImageProcessor\"]"
        },
        {
            "sha": "2046deef0b3ecf7c0f14fa16e5d4d5a02379df7b",
            "filename": "src/transformers/models/qwen2_5_vl/modeling_qwen2_5_vl.py",
            "status": "added",
            "additions": 1921,
            "deletions": 0,
            "changes": 1921,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fmodeling_qwen2_5_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fmodeling_qwen2_5_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fmodeling_qwen2_5_vl.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -0,0 +1,1921 @@\n+#                ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨\n+#           This file was automatically generated from src/transformers/models/qwen2_5_vl/modular_qwen2_5_vl.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_qwen2_5_vl.py file directly. One of our CI enforces this.\n+#                ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨\n+# coding=utf-8\n+# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import math\n+from dataclasses import dataclass\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+import torch.nn as nn\n+import torch.nn.functional as F\n+from torch.nn import CrossEntropyLoss\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import Cache, DynamicCache, SlidingWindowCache, StaticCache\n+from ...generation import GenerationMixin\n+from ...modeling_attn_mask_utils import AttentionMaskConverter\n+from ...modeling_outputs import BaseModelOutputWithPast, ModelOutput\n+from ...modeling_rope_utils import ROPE_INIT_FUNCTIONS\n+from ...modeling_utils import PreTrainedModel\n+from ...utils import (\n+    add_start_docstrings,\n+    add_start_docstrings_to_model_forward,\n+    is_flash_attn_2_available,\n+    is_flash_attn_greater_or_equal_2_10,\n+    logging,\n+    replace_return_docstrings,\n+)\n+from .configuration_qwen2_5_vl import Qwen2_5_VLConfig, Qwen2_5_VLVisionConfig\n+\n+\n+if is_flash_attn_2_available():\n+    from flash_attn import flash_attn_varlen_func\n+    from flash_attn.layers.rotary import apply_rotary_emb\n+\n+else:\n+    flash_attn_varlen_func = None\n+    apply_rotary_emb = None\n+\n+\n+if is_flash_attn_2_available():\n+    from ...modeling_flash_attention_utils import _flash_attention_forward\n+else:\n+    flash_attn_varlen_func = None\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+_CONFIG_FOR_DOC = \"Qwen2_5_VLConfig\"\n+\n+\n+class Qwen2_5_VLMLP(nn.Module):\n+    def __init__(self, config, bias: bool = False):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=bias)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=bias)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=bias)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, hidden_state):\n+        return self.down_proj(self.act_fn(self.gate_proj(hidden_state)) * self.up_proj(hidden_state))\n+\n+\n+class Qwen2_5_VisionPatchEmbed(nn.Module):\n+    def __init__(\n+        self,\n+        patch_size: int = 14,\n+        temporal_patch_size: int = 2,\n+        in_channels: int = 3,\n+        embed_dim: int = 1152,\n+    ) -> None:\n+        super().__init__()\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.in_channels = in_channels\n+        self.embed_dim = embed_dim\n+\n+        kernel_size = [temporal_patch_size, patch_size, patch_size]\n+        self.proj = nn.Conv3d(in_channels, embed_dim, kernel_size=kernel_size, stride=kernel_size, bias=False)\n+\n+    def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n+        target_dtype = self.proj.weight.dtype\n+        hidden_states = hidden_states.view(\n+            -1, self.in_channels, self.temporal_patch_size, self.patch_size, self.patch_size\n+        )\n+        hidden_states = self.proj(hidden_states.to(dtype=target_dtype)).view(-1, self.embed_dim)\n+        return hidden_states\n+\n+\n+class Qwen2_5_VisionRotaryEmbedding(nn.Module):\n+    def __init__(self, dim: int, theta: float = 10000.0) -> None:\n+        super().__init__()\n+        inv_freq = 1.0 / (theta ** (torch.arange(0, dim, 2, dtype=torch.float) / dim))\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+\n+    def forward(self, seqlen: int) -> torch.Tensor:\n+        seq = torch.arange(seqlen, device=self.inv_freq.device, dtype=self.inv_freq.dtype)\n+        freqs = torch.outer(seq, self.inv_freq)\n+        return freqs\n+\n+\n+class Qwen2RMSNorm(nn.Module):\n+    def __init__(self, hidden_size, eps=1e-6):\n+        \"\"\"\n+        Qwen2RMSNorm is equivalent to T5LayerNorm\n+        \"\"\"\n+        super().__init__()\n+        self.weight = nn.Parameter(torch.ones(hidden_size))\n+        self.variance_epsilon = eps\n+\n+    def forward(self, hidden_states):\n+        input_dtype = hidden_states.dtype\n+        hidden_states = hidden_states.to(torch.float32)\n+        variance = hidden_states.pow(2).mean(-1, keepdim=True)\n+        hidden_states = hidden_states * torch.rsqrt(variance + self.variance_epsilon)\n+        return self.weight * hidden_states.to(input_dtype)\n+\n+    def extra_repr(self):\n+        return f\"{tuple(self.weight.shape)}, eps={self.variance_epsilon}\"\n+\n+\n+class Qwen2_5_VLPatchMerger(nn.Module):\n+    def __init__(self, dim: int, context_dim: int, spatial_merge_size: int = 2) -> None:\n+        super().__init__()\n+        self.hidden_size = context_dim * (spatial_merge_size**2)\n+        self.ln_q = Qwen2RMSNorm(context_dim, eps=1e-6)\n+        self.mlp = nn.Sequential(\n+            nn.Linear(self.hidden_size, self.hidden_size),\n+            nn.GELU(),\n+            nn.Linear(self.hidden_size, dim),\n+        )\n+\n+    def forward(self, x: torch.Tensor) -> torch.Tensor:\n+        x = self.mlp(self.ln_q(x).view(-1, self.hidden_size))\n+        return x\n+\n+\n+def apply_rotary_pos_emb_flashatt(tensor: torch.Tensor, freqs: torch.Tensor) -> torch.Tensor:\n+    tensor_ = tensor.float()\n+    cos = freqs.cos()\n+    sin = freqs.sin()\n+    output = apply_rotary_emb(tensor_, cos, sin).type_as(tensor)\n+    return output\n+\n+\n+class Qwen2_5_VLVisionFlashAttention2(nn.Module):\n+    def __init__(self, dim: int, num_heads: int = 16) -> None:\n+        super().__init__()\n+        self.num_heads = num_heads\n+        self.qkv = nn.Linear(dim, dim * 3, bias=True)\n+        self.proj = nn.Linear(dim, dim)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cu_seqlens: torch.Tensor,\n+        rotary_pos_emb: torch.Tensor = None,\n+    ) -> torch.Tensor:\n+        seq_length = hidden_states.shape[0]\n+        q, k, v = self.qkv(hidden_states).reshape(seq_length, 3, self.num_heads, -1).permute(1, 0, 2, 3).unbind(0)\n+        q = apply_rotary_pos_emb_flashatt(q.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+        k = apply_rotary_pos_emb_flashatt(k.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+\n+        max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max().item()\n+        attn_output = flash_attn_varlen_func(q, k, v, cu_seqlens, cu_seqlens, max_seqlen, max_seqlen).reshape(\n+            seq_length, -1\n+        )\n+        attn_output = self.proj(attn_output)\n+        return attn_output\n+\n+\n+def rotate_half(x):\n+    \"\"\"Rotates half the hidden dims of the input.\"\"\"\n+    x1 = x[..., : x.shape[-1] // 2]\n+    x2 = x[..., x.shape[-1] // 2 :]\n+    return torch.cat((-x2, x1), dim=-1)\n+\n+\n+def apply_rotary_pos_emb_vision(tensor: torch.Tensor, freqs: torch.Tensor) -> torch.Tensor:\n+    orig_dtype = tensor.dtype\n+    tensor = tensor.float()\n+    cos = freqs.cos()\n+    sin = freqs.sin()\n+    cos = cos.unsqueeze(1).repeat(1, 1, 2).unsqueeze(0).float()\n+    sin = sin.unsqueeze(1).repeat(1, 1, 2).unsqueeze(0).float()\n+    output = (tensor * cos) + (rotate_half(tensor) * sin)\n+    output = output.to(orig_dtype)\n+    return output\n+\n+\n+class Qwen2_5_VLVisionAttention(nn.Module):\n+    def __init__(self, dim: int, num_heads: int = 16) -> None:\n+        super().__init__()\n+        self.num_heads = num_heads\n+        self.head_dim = dim // num_heads\n+        self.qkv = nn.Linear(dim, dim * 3, bias=True)\n+        self.proj = nn.Linear(dim, dim)\n+\n+    def forward(\n+        self, hidden_states: torch.Tensor, cu_seqlens: torch.Tensor, rotary_pos_emb: torch.Tensor = None\n+    ) -> torch.Tensor:\n+        seq_length = hidden_states.shape[0]\n+        q, k, v = self.qkv(hidden_states).reshape(seq_length, 3, self.num_heads, -1).permute(1, 0, 2, 3).unbind(0)\n+        q = apply_rotary_pos_emb_vision(q.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+        k = apply_rotary_pos_emb_vision(k.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+\n+        attention_mask = torch.full(\n+            [1, seq_length, seq_length], torch.finfo(q.dtype).min, device=q.device, dtype=q.dtype\n+        )\n+        for i in range(1, len(cu_seqlens)):\n+            attention_mask[..., cu_seqlens[i - 1] : cu_seqlens[i], cu_seqlens[i - 1] : cu_seqlens[i]] = 0\n+\n+        q = q.transpose(0, 1)\n+        k = k.transpose(0, 1)\n+        v = v.transpose(0, 1)\n+        attn_weights = torch.matmul(q, k.transpose(1, 2)) / math.sqrt(self.head_dim)\n+        attn_weights = attn_weights + attention_mask\n+        attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(q.dtype)\n+        attn_output = torch.matmul(attn_weights, v)\n+        attn_output = attn_output.transpose(0, 1)\n+        attn_output = attn_output.reshape(seq_length, -1)\n+        attn_output = self.proj(attn_output)\n+        return attn_output\n+\n+\n+class Qwen2_5_VLVisionSdpaAttention(nn.Module):\n+    def __init__(self, dim: int, num_heads: int = 16) -> None:\n+        super().__init__()\n+        self.num_heads = num_heads\n+        self.qkv = nn.Linear(dim, dim * 3, bias=True)\n+        self.proj = nn.Linear(dim, dim)\n+\n+    def forward(\n+        self, hidden_states: torch.Tensor, cu_seqlens: torch.Tensor, rotary_pos_emb: torch.Tensor = None\n+    ) -> torch.Tensor:\n+        seq_length = hidden_states.shape[0]\n+        q, k, v = self.qkv(hidden_states).reshape(seq_length, 3, self.num_heads, -1).permute(1, 0, 2, 3).unbind(0)\n+        q = apply_rotary_pos_emb_vision(q.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+        k = apply_rotary_pos_emb_vision(k.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+\n+        attention_mask = torch.zeros([1, seq_length, seq_length], device=q.device, dtype=torch.bool)\n+        for i in range(1, len(cu_seqlens)):\n+            attention_mask[..., cu_seqlens[i - 1] : cu_seqlens[i], cu_seqlens[i - 1] : cu_seqlens[i]] = True\n+        q = q.transpose(0, 1)\n+        k = k.transpose(0, 1)\n+        v = v.transpose(0, 1)\n+        attn_output = F.scaled_dot_product_attention(q, k, v, attention_mask, dropout_p=0.0)\n+        attn_output = attn_output.transpose(0, 1)\n+        attn_output = attn_output.reshape(seq_length, -1)\n+        attn_output = self.proj(attn_output)\n+        return attn_output\n+\n+\n+QWEN2_5_VL_VISION_ATTENTION_CLASSES = {\n+    \"eager\": Qwen2_5_VLVisionAttention,\n+    \"flash_attention_2\": Qwen2_5_VLVisionFlashAttention2,\n+    \"sdpa\": Qwen2_5_VLVisionSdpaAttention,\n+}\n+\n+\n+class Qwen2_5_VLVisionBlock(nn.Module):\n+    def __init__(self, config, attn_implementation: str = \"sdpa\") -> None:\n+        super().__init__()\n+        self.norm1 = Qwen2RMSNorm(config.hidden_size, eps=1e-6)\n+        self.norm2 = Qwen2RMSNorm(config.hidden_size, eps=1e-6)\n+        self.attn = QWEN2_5_VL_VISION_ATTENTION_CLASSES[attn_implementation](\n+            config.hidden_size, num_heads=config.num_heads\n+        )\n+        self.mlp = Qwen2_5_VLMLP(config, bias=True)\n+\n+    def forward(self, hidden_states, cu_seqlens, rotary_pos_emb) -> torch.Tensor:\n+        hidden_states = hidden_states + self.attn(\n+            self.norm1(hidden_states),\n+            cu_seqlens=cu_seqlens,\n+            rotary_pos_emb=rotary_pos_emb,\n+        )\n+        hidden_states = hidden_states + self.mlp(self.norm2(hidden_states))\n+        return hidden_states\n+\n+\n+Qwen2_5_VL_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`Qwen2_5_VLConfig`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare Qwen2_5_VL Model outputting raw hidden-states without any specific head on top.\",\n+    Qwen2_5_VL_START_DOCSTRING,\n+)\n+class Qwen2_5_VLPreTrainedModel(PreTrainedModel):\n+    config_class = Qwen2_5_VLConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"Qwen2_5_VLDecoderLayer\", \"Qwen2_5_VLVisionBlock\"]\n+    _skip_keys_device_placement = \"past_key_values\"\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = True\n+    _supports_cache_class = True\n+    _supports_static_cache = True\n+\n+    def _init_weights(self, module):\n+        std = self.config.initializer_range\n+        if isinstance(module, (nn.Linear, nn.Conv3d)):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+\n+\n+class Qwen2_5_VisionTransformerPretrainedModel(Qwen2_5_VLPreTrainedModel):\n+    config_class = Qwen2_5_VLVisionConfig\n+    _no_split_modules = [\"Qwen2_5_VLVisionBlock\"]\n+\n+    def __init__(self, config, *inputs, **kwargs) -> None:\n+        super().__init__(config, *inputs, **kwargs)\n+        self.spatial_merge_size = config.spatial_merge_size\n+        self.patch_size = config.patch_size\n+        self.fullatt_block_indexes = config.fullatt_block_indexes\n+        self.window_size = config.window_size\n+        self.spatial_merge_unit = self.spatial_merge_size * self.spatial_merge_size\n+\n+        self.patch_embed = Qwen2_5_VisionPatchEmbed(\n+            patch_size=config.patch_size,\n+            temporal_patch_size=config.temporal_patch_size,\n+            in_channels=config.in_channels,\n+            embed_dim=config.hidden_size,\n+        )\n+\n+        head_dim = config.hidden_size // config.num_heads\n+        self.rotary_pos_emb = Qwen2_5_VisionRotaryEmbedding(head_dim // 2)\n+\n+        self.blocks = nn.ModuleList(\n+            [Qwen2_5_VLVisionBlock(config, config._attn_implementation) for _ in range(config.depth)]\n+        )\n+        self.merger = Qwen2_5_VLPatchMerger(\n+            dim=config.out_hidden_size,\n+            context_dim=config.hidden_size,\n+            spatial_merge_size=config.spatial_merge_size,\n+        )\n+        self.gradient_checkpointing = False\n+\n+    def rot_pos_emb(self, grid_thw):\n+        pos_ids = []\n+        for t, h, w in grid_thw:\n+            hpos_ids = torch.arange(h).unsqueeze(1).expand(-1, w)\n+            hpos_ids = hpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            hpos_ids = hpos_ids.permute(0, 2, 1, 3)\n+            hpos_ids = hpos_ids.flatten()\n+\n+            wpos_ids = torch.arange(w).unsqueeze(0).expand(h, -1)\n+            wpos_ids = wpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            wpos_ids = wpos_ids.permute(0, 2, 1, 3)\n+            wpos_ids = wpos_ids.flatten()\n+            pos_ids.append(torch.stack([hpos_ids, wpos_ids], dim=-1).repeat(t, 1))\n+        pos_ids = torch.cat(pos_ids, dim=0)\n+        max_grid_size = grid_thw[:, 1:].max()\n+        rotary_pos_emb_full = self.rotary_pos_emb(max_grid_size)\n+        rotary_pos_emb = rotary_pos_emb_full[pos_ids].flatten(1)\n+        return rotary_pos_emb\n+\n+    def get_window_index(self, grid_thw):\n+        window_index: list = []\n+        cu_window_seqlens: list = [0]\n+        window_index_id = 0\n+        vit_merger_window_size = self.window_size // self.spatial_merge_size // self.patch_size\n+\n+        for grid_t, grid_h, grid_w in grid_thw:\n+            llm_grid_h, llm_grid_w = (\n+                grid_h // self.spatial_merge_size,\n+                grid_w // self.spatial_merge_size,\n+            )\n+            index = torch.arange(grid_t * llm_grid_h * llm_grid_w).reshape(grid_t, llm_grid_h, llm_grid_w)\n+            pad_h = vit_merger_window_size - llm_grid_h % vit_merger_window_size\n+            pad_w = vit_merger_window_size - llm_grid_w % vit_merger_window_size\n+            num_windows_h = (llm_grid_h + pad_h) // vit_merger_window_size\n+            num_windows_w = (llm_grid_w + pad_w) // vit_merger_window_size\n+            index_padded = F.pad(index, (0, pad_w, 0, pad_h), \"constant\", -100)\n+            index_padded = index_padded.reshape(\n+                grid_t,\n+                num_windows_h,\n+                vit_merger_window_size,\n+                num_windows_w,\n+                vit_merger_window_size,\n+            )\n+            index_padded = index_padded.permute(0, 1, 3, 2, 4).reshape(\n+                grid_t,\n+                num_windows_h * num_windows_w,\n+                vit_merger_window_size,\n+                vit_merger_window_size,\n+            )\n+            seqlens = (index_padded != -100).sum([2, 3]).reshape(-1)\n+            index_padded = index_padded.reshape(-1)\n+            index_new = index_padded[index_padded != -100]\n+            window_index.append(index_new + window_index_id)\n+            cu_seqlens_tmp = seqlens.cumsum(0) * self.spatial_merge_unit + cu_window_seqlens[-1]\n+            cu_window_seqlens.extend(cu_seqlens_tmp.tolist())\n+            window_index_id += (grid_t * llm_grid_h * llm_grid_w).item()\n+        window_index = torch.cat(window_index, dim=0)\n+\n+        return window_index, cu_window_seqlens\n+\n+    def forward(self, hidden_states: torch.Tensor, grid_thw: torch.Tensor) -> torch.Tensor:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.Tensor` of shape `(batch_size, seq_len, hidden_size)`):\n+                The final hidden states of the model.\n+            grid_thw (`torch.Tensor` of shape `(num_images_or_videos, 3)`):\n+                The temporal, height and width of feature shape of each image in LLM.\n+\n+        Returns:\n+            `torch.Tensor`: hidden_states.\n+        \"\"\"\n+        hidden_states = self.patch_embed(hidden_states)\n+        rotary_pos_emb = self.rot_pos_emb(grid_thw)\n+        window_index, cu_window_seqlens = self.get_window_index(grid_thw)\n+        cu_window_seqlens = torch.tensor(\n+            cu_window_seqlens,\n+            device=hidden_states.device,\n+            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_window_seqlens = torch.unique_consecutive(cu_window_seqlens)\n+\n+        seq_len, _ = hidden_states.size()\n+        hidden_states = hidden_states.reshape(seq_len // self.spatial_merge_unit, self.spatial_merge_unit, -1)\n+        hidden_states = hidden_states[window_index, :, :]\n+        hidden_states = hidden_states.reshape(seq_len, -1)\n+        rotary_pos_emb = rotary_pos_emb.reshape(seq_len // self.spatial_merge_unit, self.spatial_merge_unit, -1)\n+        rotary_pos_emb = rotary_pos_emb[window_index, :, :]\n+        rotary_pos_emb = rotary_pos_emb.reshape(seq_len, -1)\n+\n+        cu_seqlens = torch.repeat_interleave(grid_thw[:, 1] * grid_thw[:, 2], grid_thw[:, 0]).cumsum(\n+            dim=0,\n+            # Select dtype based on the following factors:\n+            #  - FA2 requires that cu_seqlens_q must have dtype int32\n+            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n+            # See https://github.com/huggingface/transformers/pull/34852 for more information\n+            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_seqlens = F.pad(cu_seqlens, (1, 0), value=0)\n+\n+        for layer_num, blk in enumerate(self.blocks):\n+            if layer_num in self.fullatt_block_indexes:\n+                cu_seqlens_now = cu_seqlens\n+            else:\n+                cu_seqlens_now = cu_window_seqlens\n+            if self.gradient_checkpointing and self.training:\n+                hidden_states = self._gradient_checkpointing_func(\n+                    blk.__call__, hidden_states, cu_seqlens_now, rotary_pos_emb\n+                )\n+            else:\n+                hidden_states = blk(\n+                    hidden_states,\n+                    cu_seqlens=cu_seqlens_now,\n+                    rotary_pos_emb=rotary_pos_emb,\n+                )\n+\n+        hidden_states = self.merger(hidden_states)\n+        reverse_indices = torch.argsort(window_index)\n+        hidden_states = hidden_states[reverse_indices, :]\n+\n+        return hidden_states\n+\n+\n+class Qwen2_5_VLRotaryEmbedding(nn.Module):\n+    def __init__(self, config: Qwen2_5_VLConfig, device=None):\n+        super().__init__()\n+        # BC: \"rope_type\" was originally \"type\"\n+        if hasattr(config, \"rope_scaling\") and config.rope_scaling is not None:\n+            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n+        else:\n+            self.rope_type = \"default\"\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n+\n+        self.config = config\n+        self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n+\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n+        self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n+        self.original_inv_freq = self.inv_freq\n+\n+    def _dynamic_frequency_update(self, position_ids, device):\n+        \"\"\"\n+        dynamic RoPE layers should recompute `inv_freq` in the following situations:\n+        1 - growing beyond the cached sequence length (allow scaling)\n+        2 - the current sequence length is in the original scale (avoid losing precision with small sequences)\n+        \"\"\"\n+        seq_len = torch.max(position_ids) + 1\n+        if seq_len > self.max_seq_len_cached:  # growth\n+            inv_freq, self.attention_scaling = self.rope_init_fn(\n+                self.config, device, seq_len=seq_len, **self.rope_kwargs\n+            )\n+            self.register_buffer(\"inv_freq\", inv_freq, persistent=False)  # TODO joao: may break with compilation\n+            self.max_seq_len_cached = seq_len\n+\n+        if seq_len < self.original_max_seq_len and self.max_seq_len_cached > self.original_max_seq_len:  # reset\n+            self.register_buffer(\"inv_freq\", self.original_inv_freq, persistent=False)\n+            self.max_seq_len_cached = self.original_max_seq_len\n+\n+    @torch.no_grad()\n+    def forward(self, x, position_ids):\n+        if \"dynamic\" in self.rope_type:\n+            self._dynamic_frequency_update(position_ids, device=x.device)\n+\n+        # Core RoPE block. In contrast to other models, Qwen2_5_VL has different position ids for thw grids\n+        # So we expand the inv_freq to shape (3, ...)\n+        inv_freq_expanded = self.inv_freq[None, None, :, None].float().expand(3, position_ids.shape[1], -1, 1)\n+        position_ids_expanded = position_ids[:, :, None, :].float()  # shape (3, bs, 1, positions)\n+        # Force float32 (see https://github.com/huggingface/transformers/pull/29285)\n+        device_type = x.device.type\n+        device_type = device_type if isinstance(device_type, str) and device_type != \"mps\" else \"cpu\"\n+        with torch.autocast(device_type=device_type, enabled=False):\n+            freqs = (inv_freq_expanded.float() @ position_ids_expanded.float()).transpose(2, 3)\n+            emb = torch.cat((freqs, freqs), dim=-1)\n+            cos = emb.cos()\n+            sin = emb.sin()\n+\n+        # Advanced RoPE types (e.g. yarn) apply a post-processing scaling factor, equivalent to scaling attention\n+        cos = cos * self.attention_scaling\n+        sin = sin * self.attention_scaling\n+\n+        return cos.to(dtype=x.dtype), sin.to(dtype=x.dtype)\n+\n+\n+class Qwen2MLP(nn.Module):\n+    def __init__(self, config):\n+        super().__init__()\n+        self.config = config\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=False)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=False)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, x):\n+        down_proj = self.down_proj(self.act_fn(self.gate_proj(x)) * self.up_proj(x))\n+        return down_proj\n+\n+\n+def apply_multimodal_rotary_pos_emb(q, k, cos, sin, mrope_section, unsqueeze_dim=1):\n+    \"\"\"Applies Rotary Position Embedding with Multimodal Sections to the query and key tensors (https://qwenlm.github.io/blog/qwen2-vl/).\n+\n+    Explanation:\n+        Multimodal 3D rotary position embedding is an extension to 1D rotary position embedding. The input embedding\n+        sequence contains vision (images / videos) embedding and text embedding or just contains text embedding. For\n+        vision embedding part, we apply rotary position embedding on temporal, height and width dimension seperately.\n+        Here we split the channel dimension to 3 chunks for the temporal, height and width rotary position embedding.\n+        For text embedding part, we just apply 1D rotary position embedding. The three rotary position index (temporal,\n+        height and width) of text embedding is always the same, so the text embedding rotary position embedding has no\n+        difference with modern LLMs.\n+\n+    Args:\n+        q (`torch.Tensor`): The query tensor.\n+        k (`torch.Tensor`): The key tensor.\n+        cos (`torch.Tensor`): The cosine part of the rotary embedding.\n+        sin (`torch.Tensor`): The sine part of the rotary embedding.\n+        position_ids (`torch.Tensor`):\n+            The position indices of the tokens corresponding to the query and key tensors. For example, this can be\n+            used to pass offsetted position ids when working with a KV-cache.\n+        mrope_section(`List(int)`):\n+            Multimodal rope section is for channel dimension of temporal, height and width in rope calculation.\n+        unsqueeze_dim (`int`, *optional*, defaults to 1):\n+            The 'unsqueeze_dim' argument specifies the dimension along which to unsqueeze cos[position_ids] and\n+            sin[position_ids] so that they can be properly broadcasted to the dimensions of q and k. For example, note\n+            that cos[position_ids] and sin[position_ids] have the shape [batch_size, seq_len, head_dim]. Then, if q and\n+            k have the shape [batch_size, heads, seq_len, head_dim], then setting unsqueeze_dim=1 makes\n+            cos[position_ids] and sin[position_ids] broadcastable to the shapes of q and k. Similarly, if q and k have\n+            the shape [batch_size, seq_len, heads, head_dim], then set unsqueeze_dim=2.\n+    Returns:\n+        `tuple(torch.Tensor)` comprising of the query and key tensors rotated using the Rotary Position Embedding.\n+    \"\"\"\n+    mrope_section = mrope_section * 2\n+    cos = torch.cat([m[i % 3] for i, m in enumerate(cos.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+    sin = torch.cat([m[i % 3] for i, m in enumerate(sin.split(mrope_section, dim=-1))], dim=-1).unsqueeze(\n+        unsqueeze_dim\n+    )\n+\n+    q_embed = (q * cos) + (rotate_half(q) * sin)\n+    k_embed = (k * cos) + (rotate_half(k) * sin)\n+    return q_embed, k_embed\n+\n+\n+def repeat_kv(hidden_states: torch.Tensor, n_rep: int) -> torch.Tensor:\n+    \"\"\"\n+    This is the equivalent of torch.repeat_interleave(x, dim=1, repeats=n_rep). The hidden states go from (batch,\n+    num_key_value_heads, seqlen, head_dim) to (batch, num_attention_heads, seqlen, head_dim)\n+    \"\"\"\n+    batch, num_key_value_heads, slen, head_dim = hidden_states.shape\n+    if n_rep == 1:\n+        return hidden_states\n+    hidden_states = hidden_states[:, :, None, :, :].expand(batch, num_key_value_heads, n_rep, slen, head_dim)\n+    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)\n+\n+\n+class Qwen2_5_VLAttention(nn.Module):\n+    \"\"\"\n+    Multi-headed attention from 'Attention Is All You Need' paper. Modified to use sliding window attention: Longformer\n+    and \"Generating Long Sequences with Sparse Transformers\".\n+    \"\"\"\n+\n+    def __init__(self, config: Qwen2_5_VLConfig, layer_idx: Optional[int] = None):\n+        super().__init__()\n+        self.config = config\n+        self.layer_idx = layer_idx\n+        if layer_idx is None:\n+            logger.warning_once(\n+                f\"Instantiating {self.__class__.__name__} without passing `layer_idx` is not recommended and will \"\n+                \"to errors during the forward call, if caching is used. Please make sure to provide a `layer_idx` \"\n+                \"when creating this class.\"\n+            )\n+\n+        self.hidden_size = config.hidden_size\n+        self.num_heads = config.num_attention_heads\n+        self.head_dim = self.hidden_size // self.num_heads\n+        self.num_key_value_heads = config.num_key_value_heads\n+        self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n+        self.is_causal = True\n+        self.attention_dropout = config.attention_dropout\n+        self.rope_scaling = config.rope_scaling\n+\n+        if (self.head_dim * self.num_heads) != self.hidden_size:\n+            raise ValueError(\n+                f\"hidden_size must be divisible by num_heads (got `hidden_size`: {self.hidden_size}\"\n+                f\" and `num_heads`: {self.num_heads}).\"\n+            )\n+        self.q_proj = nn.Linear(self.hidden_size, self.num_heads * self.head_dim, bias=True)\n+        self.k_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=True)\n+        self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=True)\n+        self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=False)\n+\n+        self.rotary_emb = Qwen2_5_VLRotaryEmbedding(config=config)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,  # necessary, but kept here for BC\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_multimodal_rotary_pos_emb(\n+            query_states, key_states, cos, sin, self.rope_scaling[\"mrope_section\"]\n+        )\n+\n+        if past_key_value is not None:\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}  # Specific to RoPE models\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        # repeat k/v heads if n_kv_heads < n_heads\n+        key_states = repeat_kv(key_states, self.num_key_value_groups)\n+        value_states = repeat_kv(value_states, self.num_key_value_groups)\n+\n+        attn_weights = torch.matmul(query_states, key_states.transpose(2, 3)) / math.sqrt(self.head_dim)\n+\n+        if attention_mask is not None:  # no matter the length, we just slice it\n+            causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+            attn_weights = attn_weights + causal_mask\n+\n+        # Fix precision issues in Qwen2-VL float16 inference\n+        # Replace inf values with zeros in attention weights to prevent NaN propagation\n+        if query_states.dtype == torch.float16:\n+            attn_weights = torch.where(torch.isinf(attn_weights), torch.zeros_like(attn_weights), attn_weights)\n+\n+        # upcast attention to fp32\n+        attn_weights = nn.functional.softmax(attn_weights, dim=-1, dtype=torch.float32).to(query_states.dtype)\n+        attn_weights = nn.functional.dropout(attn_weights, p=self.attention_dropout, training=self.training)\n+        attn_output = torch.matmul(attn_weights, value_states)\n+\n+        if attn_output.size() != (bsz, self.num_heads, q_len, self.head_dim):\n+            raise ValueError(\n+                f\"`attn_output` should be of size {(bsz, self.num_heads, q_len, self.head_dim)}, but is\"\n+                f\" {attn_output.size()}\"\n+            )\n+\n+        attn_output = attn_output.transpose(1, 2).contiguous()\n+        attn_output = attn_output.reshape(bsz, q_len, -1)\n+\n+        attn_output = self.o_proj(attn_output)\n+\n+        if not output_attentions:\n+            attn_weights = None\n+\n+        return attn_output, attn_weights, past_key_value\n+\n+\n+class Qwen2_5_VLFlashAttention2(Qwen2_5_VLAttention):\n+    \"\"\"\n+    Qwen2_5_VL flash attention module, following Qwen2_5_VL attention module. This module inherits from `Qwen2_5_VLAttention`\n+    as the weights of the module stays untouched. The only required change would be on the forward pass\n+    where it needs to correctly call the public API of flash attention and deal with padding tokens\n+    in case the input contains any of them. Additionally, for sliding window attention, we apply SWA only to the bottom\n+    config.max_window_layers layers.\n+    \"\"\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        # TODO: Should be removed once Flash Attention for RoCm is bumped to 2.1.\n+        # flash_attn<2.1 generates top-left aligned causal mask, while what is needed here is bottom-right alignement, that was made default for flash_attn>=2.1. This attribute is used to handle this difference. Reference: https://github.com/Dao-AILab/flash-attention/releases/tag/v2.1.0.\n+        # Beware that with flash_attn<2.1, using q_seqlen != k_seqlen (except for the case q_seqlen == 1) produces a wrong mask (top-left).\n+        self._flash_attn_uses_top_left_mask = not is_flash_attn_greater_or_equal_2_10()\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,  # necessary, but kept here for BC\n+    ):\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+\n+        # Because the input can be padded, the absolute sequence length depends on the max position id.\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_multimodal_rotary_pos_emb(\n+            query_states, key_states, cos, sin, self.rope_scaling[\"mrope_section\"]\n+        )\n+\n+        if past_key_value is not None:\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}  # Specific to RoPE models\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        # repeat k/v heads if n_kv_heads < n_heads\n+        key_states = repeat_kv(key_states, self.num_key_value_groups)\n+        value_states = repeat_kv(value_states, self.num_key_value_groups)\n+        dropout_rate = 0.0 if not self.training else self.attention_dropout\n+\n+        # In PEFT, usually we cast the layer norms in float32 for training stability reasons\n+        # therefore the input hidden states gets silently casted in float32. Hence, we need\n+        # cast them back in float16 just to be sure everything works as expected.\n+        input_dtype = query_states.dtype\n+        if input_dtype == torch.float32:\n+            if torch.is_autocast_enabled():\n+                target_dtype = torch.get_autocast_gpu_dtype()\n+            # Handle the case where the model is quantized\n+            elif hasattr(self.config, \"_pre_quantization_dtype\"):\n+                target_dtype = self.config._pre_quantization_dtype\n+            else:\n+                target_dtype = self.q_proj.weight.dtype\n+\n+            logger.warning_once(\n+                f\"The input hidden states seems to be silently casted in float32, this might be related to\"\n+                f\" the fact you have upcasted embedding or layer norm layers in float32. We will cast back the input in\"\n+                f\" {target_dtype}.\"\n+            )\n+\n+            query_states = query_states.to(target_dtype)\n+            key_states = key_states.to(target_dtype)\n+            value_states = value_states.to(target_dtype)\n+\n+        # Reashape to the expected shape for Flash Attention\n+        query_states = query_states.transpose(1, 2)\n+        key_states = key_states.transpose(1, 2)\n+        value_states = value_states.transpose(1, 2)\n+\n+        if (\n+            self.config.use_sliding_window\n+            and getattr(self.config, \"sliding_window\", None) is not None\n+            and self.layer_idx >= self.config.max_window_layers\n+        ):\n+            sliding_window = self.config.sliding_window\n+        else:\n+            sliding_window = None\n+\n+        attn_output = _flash_attention_forward(\n+            query_states,\n+            key_states,\n+            value_states,\n+            attention_mask,\n+            q_len,\n+            dropout=dropout_rate,\n+            sliding_window=sliding_window,\n+            is_causal=self.is_causal,\n+            use_top_left_mask=self._flash_attn_uses_top_left_mask,\n+        )\n+\n+        attn_output = attn_output.reshape(bsz, q_len, self.hidden_size).contiguous()\n+        attn_output = self.o_proj(attn_output)\n+\n+        if not output_attentions:\n+            attn_weights = None\n+\n+        return attn_output, attn_weights, past_key_value\n+\n+\n+class Qwen2_5_VLSdpaAttention(Qwen2_5_VLAttention):\n+    \"\"\"\n+    Qwen2 attention module using torch.nn.functional.scaled_dot_product_attention. This module inherits from\n+    `Qwen2Attention` as the weights of the module stays untouched. The only changes are on the forward pass to adapt to\n+    SDPA API.\n+    \"\"\"\n+\n+    # Adapted from Qwen2Attention.forward\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Cache] = None,\n+        output_attentions: bool = False,\n+        use_cache: bool = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,  # necessary, but kept here for BC\n+    ) -> Tuple[torch.Tensor, Optional[torch.Tensor], Optional[Tuple[torch.Tensor]]]:\n+        if output_attentions:\n+            # TODO: Improve this warning with e.g. `model.config.attn_implementation = \"manual\"` once this is implemented.\n+            logger.warning_once(\n+                \"Qwen2_5_VLModel is using Qwen2_5_VLSdpaAttention, but `torch.nn.functional.scaled_dot_product_attention` does not support `output_attentions=True`. Falling back to the manual attention implementation, \"\n+                'but specifying the manual implementation will be required from Transformers version v5.0.0 onwards. This warning can be removed using the argument `attn_implementation=\"eager\"` when loading the model.'\n+            )\n+            return super().forward(\n+                hidden_states=hidden_states,\n+                attention_mask=attention_mask,\n+                position_ids=position_ids,\n+                past_key_value=past_key_value,\n+                output_attentions=output_attentions,\n+                use_cache=use_cache,\n+                cache_position=cache_position,\n+                position_embeddings=position_embeddings,\n+            )\n+\n+        bsz, q_len, _ = hidden_states.size()\n+\n+        query_states = self.q_proj(hidden_states)\n+        key_states = self.k_proj(hidden_states)\n+        value_states = self.v_proj(hidden_states)\n+\n+        query_states = query_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+        key_states = key_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+        value_states = value_states.view(bsz, q_len, -1, self.head_dim).transpose(1, 2)\n+\n+        cos, sin = position_embeddings\n+        query_states, key_states = apply_multimodal_rotary_pos_emb(\n+            query_states, key_states, cos, sin, self.rope_scaling[\"mrope_section\"]\n+        )\n+\n+        if past_key_value is not None:\n+            cache_kwargs = {\"sin\": sin, \"cos\": cos, \"cache_position\": cache_position}  # Specific to RoPE models\n+            key_states, value_states = past_key_value.update(key_states, value_states, self.layer_idx, cache_kwargs)\n+\n+        key_states = repeat_kv(key_states, self.num_key_value_groups)\n+        value_states = repeat_kv(value_states, self.num_key_value_groups)\n+\n+        causal_mask = attention_mask\n+        if attention_mask is not None:  # no matter the length, we just slice it\n+            causal_mask = attention_mask[:, :, :, : key_states.shape[-2]]\n+\n+        # SDPA with memory-efficient backend is currently (torch==2.1.2) bugged with non-contiguous inputs with custom attn_mask,\n+        # Reference: https://github.com/pytorch/pytorch/issues/112577.\n+        if query_states.device.type == \"cuda\" and attention_mask is not None:\n+            query_states = query_states.contiguous()\n+            key_states = key_states.contiguous()\n+            value_states = value_states.contiguous()\n+\n+        # We dispatch to SDPA's Flash Attention or Efficient kernels via this `is_causal` if statement instead of an inline conditional assignment\n+        # in SDPA to support both torch.compile's dynamic shapes and full graph options. An inline conditional prevents dynamic shapes from compiling.\n+        # The q_len > 1 is necessary to match with AttentionMaskConverter.to_causal_4d that does not create a causal mask in case q_len == 1.\n+        is_causal = True if causal_mask is None and q_len > 1 else False\n+\n+        attn_output = torch.nn.functional.scaled_dot_product_attention(\n+            query_states,\n+            key_states,\n+            value_states,\n+            attn_mask=causal_mask,\n+            dropout_p=self.attention_dropout if self.training else 0.0,\n+            is_causal=is_causal,\n+        )\n+\n+        attn_output = attn_output.transpose(1, 2).contiguous()\n+        attn_output = attn_output.view(bsz, q_len, self.hidden_size)\n+\n+        attn_output = self.o_proj(attn_output)\n+\n+        return attn_output, None, past_key_value\n+\n+\n+QWEN2_5_VL_ATTENTION_CLASSES = {\n+    \"eager\": Qwen2_5_VLAttention,\n+    \"flash_attention_2\": Qwen2_5_VLFlashAttention2,\n+    \"sdpa\": Qwen2_5_VLSdpaAttention,\n+}\n+\n+\n+class Qwen2_5_VLDecoderLayer(nn.Module):\n+    def __init__(self, config: Qwen2_5_VLConfig, layer_idx: int):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+\n+        if config.use_sliding_window and config._attn_implementation != \"flash_attention_2\":\n+            logger.warning_once(\n+                f\"Sliding Window Attention is enabled but not implemented for `{config._attn_implementation}`; \"\n+                \"unexpected results may be encountered.\"\n+            )\n+        self.self_attn = QWEN2_5_VL_ATTENTION_CLASSES[config._attn_implementation](config, layer_idx)\n+\n+        self.mlp = Qwen2MLP(config)\n+        self.input_layernorm = Qwen2RMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.post_attention_layernorm = Qwen2RMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_value: Optional[Tuple[torch.Tensor]] = None,\n+        output_attentions: Optional[bool] = False,\n+        use_cache: Optional[bool] = False,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        position_embeddings: Optional[Tuple[torch.Tensor, torch.Tensor]] = None,  # necessary, but kept here for BC\n+        **kwargs,\n+    ) -> Tuple[torch.FloatTensor, Optional[Tuple[torch.FloatTensor, torch.FloatTensor]]]:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.FloatTensor`): input to the layer of shape `(batch, seq_len, embed_dim)`\n+            attention_mask (`torch.FloatTensor`, *optional*): attention mask of size\n+                `(batch, sequence_length)` where padding elements are indicated by 0.\n+            output_attentions (`bool`, *optional*):\n+                Whether or not to return the attentions tensors of all attention layers. See `attentions` under\n+                returned tensors for more detail.\n+            use_cache (`bool`, *optional*):\n+                If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding\n+                (see `past_key_values`).\n+            past_key_value (`Tuple(torch.FloatTensor)`, *optional*): cached past key and value projection states\n+            cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n+                Indices depicting the position of the input sequence tokens in the sequence.\n+            position_embeddings (`Tuple[torch.FloatTensor, torch.FloatTensor]`, *optional*):\n+                Tuple containing the cosine and sine positional embeddings of shape `(batch_size, seq_len, head_dim)`,\n+                with `head_dim` being the embedding dimension of each attention head.\n+            kwargs (`dict`, *optional*):\n+                Arbitrary kwargs to be ignored, used for FSDP and other methods that injects code\n+                into the model\n+        \"\"\"\n+\n+        residual = hidden_states\n+\n+        hidden_states = self.input_layernorm(hidden_states)\n+\n+        # Self Attention\n+        hidden_states, self_attn_weights, present_key_value = self.self_attn(\n+            hidden_states=hidden_states,\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_value=past_key_value,\n+            output_attentions=output_attentions,\n+            use_cache=use_cache,\n+            cache_position=cache_position,\n+            position_embeddings=position_embeddings,\n+        )\n+        hidden_states = residual + hidden_states\n+\n+        # Fully Connected\n+        residual = hidden_states\n+        hidden_states = self.post_attention_layernorm(hidden_states)\n+        hidden_states = self.mlp(hidden_states)\n+        hidden_states = residual + hidden_states\n+\n+        outputs = (hidden_states,)\n+\n+        if output_attentions:\n+            outputs += (self_attn_weights,)\n+\n+        if use_cache:\n+            outputs += (present_key_value,)\n+\n+        return outputs\n+\n+\n+@add_start_docstrings(\n+    \"The bare Qwen2_5_VL Model outputting raw hidden-states without any specific head on top.\",\n+    Qwen2_5_VL_START_DOCSTRING,\n+)\n+class Qwen2_5_VLModel(Qwen2_5_VLPreTrainedModel):\n+    def __init__(self, config: Qwen2_5_VLConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [Qwen2_5_VLDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self._attn_implementation = config._attn_implementation\n+        self.norm = Qwen2RMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = Qwen2_5_VLRotaryEmbedding(config=config)\n+\n+        self.gradient_checkpointing = False\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.embed_tokens = value\n+\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+    ) -> Union[Tuple, BaseModelOutputWithPast]:\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        use_cache = use_cache if use_cache is not None else self.config.use_cache\n+\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if self.gradient_checkpointing and self.training:\n+            if use_cache:\n+                logger.warning_once(\n+                    \"`use_cache=True` is incompatible with gradient checkpointing. Setting `use_cache=False`...\"\n+                )\n+                use_cache = False\n+\n+        # torch.jit.trace() doesn't support cache objects in the output\n+        if use_cache and past_key_values is None and not torch.jit.is_tracing():\n+            past_key_values = DynamicCache()\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        # the hard coded `3` is for temporal, height and width.\n+        if position_ids is None:\n+            position_ids = cache_position.view(1, 1, -1).expand(3, inputs_embeds.shape[0], -1)\n+        elif position_ids.dim() == 2:\n+            position_ids = position_ids[None, ...].expand(3, position_ids.shape[0], -1)\n+\n+        causal_mask = self._update_causal_mask(\n+            attention_mask, inputs_embeds, cache_position, past_key_values, output_attentions\n+        )\n+\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        # decoder layers\n+        all_hidden_states = () if output_hidden_states else None\n+        all_self_attns = () if output_attentions else None\n+        next_decoder_cache = None\n+\n+        for decoder_layer in self.layers:\n+            if output_hidden_states:\n+                all_hidden_states += (hidden_states,)\n+\n+            if self.gradient_checkpointing and self.training:\n+                layer_outputs = self._gradient_checkpointing_func(\n+                    decoder_layer.__call__,\n+                    hidden_states,\n+                    causal_mask,\n+                    position_ids,\n+                    past_key_values,\n+                    output_attentions,\n+                    use_cache,\n+                    cache_position,\n+                    position_embeddings,\n+                )\n+            else:\n+                layer_outputs = decoder_layer(\n+                    hidden_states,\n+                    attention_mask=causal_mask,\n+                    position_ids=position_ids,\n+                    past_key_value=past_key_values,\n+                    output_attentions=output_attentions,\n+                    use_cache=use_cache,\n+                    cache_position=cache_position,\n+                    position_embeddings=position_embeddings,\n+                )\n+\n+            hidden_states = layer_outputs[0]\n+\n+            if use_cache:\n+                next_decoder_cache = layer_outputs[2 if output_attentions else 1]\n+\n+            if output_attentions:\n+                all_self_attns += (layer_outputs[1],)\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        # add hidden states from the last decoder layer\n+        if output_hidden_states:\n+            all_hidden_states += (hidden_states,)\n+\n+        next_cache = next_decoder_cache if use_cache else None\n+\n+        if not return_dict:\n+            return tuple(v for v in [hidden_states, next_cache, all_hidden_states, all_self_attns] if v is not None)\n+        return BaseModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=next_cache,\n+            hidden_states=all_hidden_states,\n+            attentions=all_self_attns,\n+        )\n+\n+    def _update_causal_mask(\n+        self,\n+        attention_mask: torch.Tensor,\n+        input_tensor: torch.Tensor,\n+        cache_position: torch.Tensor,\n+        past_key_values: Cache,\n+        output_attentions: bool,\n+    ):\n+        if self.config._attn_implementation == \"flash_attention_2\":\n+            if attention_mask is not None and past_key_values is not None:\n+                is_padding_right = attention_mask[:, -1].sum().item() != input_tensor.size()[0]\n+                if is_padding_right:\n+                    raise ValueError(\n+                        \"You are attempting to perform batched generation with padding_side='right'\"\n+                        \" this may lead to unexpected behaviour for Flash Attention version of Qwen2_5_VL. Make sure to \"\n+                        \" call `tokenizer.padding_side  = 'left'` before tokenizing the input. \"\n+                    )\n+            if attention_mask is not None and 0.0 in attention_mask:\n+                return attention_mask\n+            return None\n+\n+        # For SDPA, when possible, we will rely on its `is_causal` argument instead of its `attn_mask` argument, in\n+        # order to dispatch on Flash Attention 2. This feature is not compatible with static cache, as SDPA will fail\n+        # to infer the attention mask.\n+        past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+        using_static_cache = isinstance(past_key_values, StaticCache)\n+        using_sliding_window_cache = isinstance(past_key_values, SlidingWindowCache)\n+\n+        # When output attentions is True, sdpa implementation's forward method calls the eager implementation's forward\n+        if (\n+            self.config._attn_implementation == \"sdpa\"\n+            and not (using_static_cache or using_sliding_window_cache)\n+            and not output_attentions\n+        ):\n+            if AttentionMaskConverter._ignore_causal_mask_sdpa(\n+                attention_mask,\n+                inputs_embeds=input_tensor,\n+                past_key_values_length=past_seen_tokens,\n+                sliding_window=self.config.sliding_window,\n+                is_training=self.training,\n+            ):\n+                return None\n+\n+        dtype, device = input_tensor.dtype, input_tensor.device\n+        min_dtype = torch.finfo(dtype).min\n+        sequence_length = input_tensor.shape[1]\n+        # SlidingWindowCache or StaticCache\n+        if using_sliding_window_cache or using_static_cache:\n+            target_length = past_key_values.get_max_cache_shape()\n+        # DynamicCache or no cache\n+        else:\n+            target_length = (\n+                attention_mask.shape[-1]\n+                if isinstance(attention_mask, torch.Tensor)\n+                else past_seen_tokens + sequence_length + 1\n+            )\n+\n+        # In case the provided `attention` mask is 2D, we generate a causal mask here (4D).\n+        causal_mask = self._prepare_4d_causal_attention_mask_with_cache_position(\n+            attention_mask,\n+            sequence_length=sequence_length,\n+            target_length=target_length,\n+            dtype=dtype,\n+            device=device,\n+            cache_position=cache_position,\n+            batch_size=input_tensor.shape[0],\n+            config=self.config,\n+            past_key_values=past_key_values,\n+        )\n+\n+        if (\n+            self.config._attn_implementation == \"sdpa\"\n+            and attention_mask is not None\n+            and attention_mask.device.type == \"cuda\"\n+            and not output_attentions\n+        ):\n+            # Attend to all tokens in fully masked rows in the causal_mask, for example the relevant first rows when\n+            # using left padding. This is required by F.scaled_dot_product_attention memory-efficient attention path.\n+            # Details: https://github.com/pytorch/pytorch/issues/110213\n+            causal_mask = AttentionMaskConverter._unmask_unattended(causal_mask, min_dtype)\n+\n+        return causal_mask\n+\n+    @staticmethod\n+    def _prepare_4d_causal_attention_mask_with_cache_position(\n+        attention_mask: torch.Tensor,\n+        sequence_length: int,\n+        target_length: int,\n+        dtype: torch.dtype,\n+        device: torch.device,\n+        cache_position: torch.Tensor,\n+        batch_size: int,\n+        config: Qwen2_5_VLConfig,\n+        past_key_values: Cache,\n+    ):\n+        \"\"\"\n+        Creates a causal 4D mask of shape `(batch_size, 1, query_length, key_value_length)` from a 2D mask of shape\n+        `(batch_size, key_value_length)`, or if the input `attention_mask` is already 4D, do nothing.\n+\n+        Args:\n+            attention_mask (`torch.Tensor`):\n+                A 2D attention mask of shape `(batch_size, key_value_length)` or a 4D attention mask of shape `(batch_size, 1, query_length, key_value_length)`.\n+            sequence_length (`int`):\n+                The sequence length being processed.\n+            target_length (`int`):\n+                The target length: when generating with static cache, the mask should be as long as the static cache, to account for the 0 padding, the part of the cache that is not filled yet.\n+            dtype (`torch.dtype`):\n+                The dtype to use for the 4D attention mask.\n+            device (`torch.device`):\n+                The device to plcae the 4D attention mask on.\n+            cache_position (`torch.Tensor`):\n+                Indices depicting the position of the input sequence tokens in the sequence.\n+            batch_size (`torch.Tensor`):\n+                Batch size.\n+            config (`Qwen2_5_VLConfig`):\n+                The model's configuration class\n+            past_key_values (`Cache`):\n+                The cache class that is being used currently to generate\n+        \"\"\"\n+        if attention_mask is not None and attention_mask.dim() == 4:\n+            # In this case we assume that the mask comes already in inverted form and requires no inversion or slicing.\n+            causal_mask = attention_mask\n+        else:\n+            min_dtype = torch.finfo(dtype).min\n+            causal_mask = torch.full(\n+                (sequence_length, target_length), fill_value=min_dtype, dtype=dtype, device=device\n+            )\n+            diagonal_attend_mask = torch.arange(target_length, device=device) > cache_position.reshape(-1, 1)\n+            if config.sliding_window is not None:\n+                # if we have sliding window, we should not attend to tokens beyond sliding window length, so we mask them out also\n+                # the check is needed to verify is current checkpoint was trained with sliding window or not\n+                if not isinstance(past_key_values, SlidingWindowCache) or sequence_length > target_length:\n+                    sliding_attend_mask = torch.arange(target_length, device=device) <= (\n+                        cache_position.reshape(-1, 1) - config.sliding_window\n+                    )\n+                    diagonal_attend_mask.bitwise_or_(sliding_attend_mask)\n+            causal_mask *= diagonal_attend_mask\n+            causal_mask = causal_mask[None, None, :, :].expand(batch_size, 1, -1, -1)\n+            if attention_mask is not None:\n+                causal_mask = causal_mask.clone()  # copy to contiguous memory for in-place edit\n+                if attention_mask.shape[-1] > target_length:\n+                    attention_mask = attention_mask[:, :target_length]\n+                mask_length = attention_mask.shape[-1]\n+                padding_mask = causal_mask[:, :, :, :mask_length] + attention_mask[:, None, None, :]\n+                padding_mask = padding_mask == 0\n+                causal_mask[:, :, :, :mask_length] = causal_mask[:, :, :, :mask_length].masked_fill(\n+                    padding_mask, min_dtype\n+                )\n+        return causal_mask\n+\n+\n+@dataclass\n+class Qwen2_5_VLCausalLMOutputWithPast(ModelOutput):\n+    \"\"\"\n+    Base class for Qwen2_5_VL causal language model (or autoregressive) outputs.\n+\n+    Args:\n+        loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+            Language modeling loss (for next-token prediction).\n+        logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n+            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+            `past_key_values` input) to speed up sequential decoding.\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: torch.FloatTensor = None\n+    past_key_values: Optional[List[torch.FloatTensor]] = None\n+    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+    attentions: Optional[Tuple[torch.FloatTensor]] = None\n+    rope_deltas: Optional[torch.LongTensor] = None\n+\n+\n+QWEN2_5_VL_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+            it.\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            [What are input IDs?](../glossary#input-ids)\n+        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+            - 1 for tokens that are **not masked**,\n+            - 0 for tokens that are **masked**.\n+\n+            [What are attention masks?](../glossary#attention-mask)\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            If `past_key_values` is used, optionally only the last `decoder_input_ids` have to be input (see\n+            `past_key_values`).\n+\n+            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n+            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n+            information on the default strategy.\n+\n+            - 1 indicates the head is **not masked**,\n+            - 0 indicates the head is **masked**.\n+        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n+            config.n_positions - 1]`. [What are position IDs?](../glossary#position-ids)\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`) and 2 additional tensors of shape\n+            `(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`.\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n+            blocks) that can be used (see `past_key_values` input) to speed up sequential decoding.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n+            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n+            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n+        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n+            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n+            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n+            model's internal embedding lookup matrix.\n+        use_cache (`bool`, *optional*):\n+            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n+            `past_key_values`).\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+        pixel_values (`torch.FloatTensor` of shape `(seq_length, num_channels * image_size * image_size)):\n+            The tensors corresponding to the input images. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`Qwen2_5_VLImageProcessor.__call__`] for details. [`Qwen2_5_VLProcessor`] uses\n+            [`Qwen2_5_VLImageProcessor`] for processing images.\n+        pixel_values_videos (`torch.FloatTensor` of shape `(seq_length, num_channels * temporal_size * image_size * image_size)):\n+            The tensors corresponding to the input videos. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`Qwen2_5_VLImageProcessor.__call__`] for details. [`Qwen2_5_VLProcessor`] uses\n+            [`Qwen2_5_VLImageProcessor`] for processing videos.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+\"\"\"\n+\n+\n+class Qwen2_5_VLForConditionalGeneration(Qwen2_5_VLPreTrainedModel, GenerationMixin):\n+    _tied_weights_keys = [\"lm_head.weight\"]\n+    config_class = Qwen2_5_VLConfig\n+    _no_split_modules = [\"Qwen2VLDecoderLayer\", \"Qwen2_5_VLVisionBlock\"]\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.visual = Qwen2_5_VisionTransformerPretrainedModel._from_config(config.vision_config)\n+        self.model = Qwen2_5_VLModel(config)\n+        self.vocab_size = config.vocab_size\n+        self.lm_head = nn.Linear(config.hidden_size, config.vocab_size, bias=False)\n+        self.rope_deltas = None  # cache rope_deltas here\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.embed_tokens\n+\n+    def set_input_embeddings(self, value):\n+        self.model.embed_tokens = value\n+\n+    def get_output_embeddings(self):\n+        return self.lm_head\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.lm_head = new_embeddings\n+\n+    def set_decoder(self, decoder):\n+        self.model = decoder\n+\n+    def get_decoder(self):\n+        return self.model\n+\n+    def get_rope_index(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        second_per_grid_ts: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+    ) -> Tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Calculate the 3D rope index based on image and video's temporal, height and width in LLM.\n+\n+        Explanation:\n+            Each embedding sequence contains vision embedding and text embedding or just contains text embedding.\n+\n+            For pure text embedding sequence, the rotary position embedding has no difference with modern LLMs.\n+            Examples:\n+                input_ids: [T T T T T], here T is for text.\n+                temporal position_ids: [0, 1, 2, 3, 4]\n+                height position_ids: [0, 1, 2, 3, 4]\n+                width position_ids: [0, 1, 2, 3, 4]\n+\n+            For vision and text embedding sequence, we calculate 3D rotary position embedding for vision part\n+            and 1D rotary position embeddin for text part.\n+            Examples:\n+                Temporal (Time): 3 patches, representing different segments of the video in time.\n+                Height: 2 patches, dividing each frame vertically.\n+                Width: 2 patches, dividing each frame horizontally.\n+                We also have some important parameters:\n+                fps (Frames Per Second): The video's frame rate, set to 1. This means one frame is processed each second.\n+                tokens_per_second: This is a crucial parameter. It dictates how many \"time-steps\" or \"temporal tokens\" are conceptually packed into a one-second interval of the video. In this case, we have 25 tokens per second. So each second of the video will be represented with 25 separate time points. It essentially defines the temporal granularity.\n+                temporal_patch_size: The number of frames that compose one temporal patch. Here, it's 2 frames.\n+                interval: The step size for the temporal position IDs, calculated as tokens_per_second * temporal_patch_size / fps. In this case, 25 * 2 / 1 = 50. This means that each temporal patch will be have a difference of 50 in the temporal position IDs.\n+                input_ids: [V V V V V V V V V V V V T T T T T], here V is for vision.\n+                vision temporal position_ids: [0, 0, 0, 0, 50, 50, 50, 50, 100, 100, 100, 100]\n+                vision height position_ids: [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]\n+                vision width position_ids: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n+                text temporal position_ids: [101, 102, 103, 104, 105]\n+                text height position_ids: [101, 102, 103, 104, 105]\n+                text width position_ids: [101, 102, 103, 104, 105]\n+                Here we calculate the text start position_ids as the max vision position_ids plus 1.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+                it.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+            second_per_grid_ts (`torch.Tensor` of shape `(num_videos)`, *optional*):\n+                The time interval (in seconds) for each grid along the temporal dimension in the 3D position IDs.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+\n+        Returns:\n+            position_ids (`torch.LongTensor` of shape `(3, batch_size, sequence_length)`)\n+            mrope_position_deltas (`torch.Tensor` of shape `(batch_size)`)\n+        \"\"\"\n+        spatial_merge_size = self.config.vision_config.spatial_merge_size\n+        image_token_id = self.config.image_token_id\n+        video_token_id = self.config.video_token_id\n+        vision_start_token_id = self.config.vision_start_token_id\n+        mrope_position_deltas = []\n+        if input_ids is not None and (image_grid_thw is not None or video_grid_thw is not None):\n+            total_input_ids = input_ids\n+            if attention_mask is None:\n+                attention_mask = torch.ones_like(total_input_ids)\n+            position_ids = torch.ones(\n+                3,\n+                input_ids.shape[0],\n+                input_ids.shape[1],\n+                dtype=input_ids.dtype,\n+                device=input_ids.device,\n+            )\n+            image_index, video_index = 0, 0\n+            attention_mask = attention_mask.to(total_input_ids.device)\n+            for i, input_ids in enumerate(total_input_ids):\n+                input_ids = input_ids[attention_mask[i] == 1]\n+                image_nums, video_nums = 0, 0\n+                vision_start_indices = torch.argwhere(input_ids == vision_start_token_id).squeeze(1)\n+                vision_tokens = input_ids[vision_start_indices + 1]\n+                image_nums = (vision_tokens == image_token_id).sum()\n+                video_nums = (vision_tokens == video_token_id).sum()\n+                input_tokens = input_ids.tolist()\n+                llm_pos_ids_list: list = []\n+                st = 0\n+                remain_images, remain_videos = image_nums, video_nums\n+                for _ in range(image_nums + video_nums):\n+                    if image_token_id in input_tokens and remain_images > 0:\n+                        ed_image = input_tokens.index(image_token_id, st)\n+                    else:\n+                        ed_image = len(input_tokens) + 1\n+                    if video_token_id in input_tokens and remain_videos > 0:\n+                        ed_video = input_tokens.index(video_token_id, st)\n+                    else:\n+                        ed_video = len(input_tokens) + 1\n+                    if ed_image < ed_video:\n+                        t, h, w = (\n+                            image_grid_thw[image_index][0],\n+                            image_grid_thw[image_index][1],\n+                            image_grid_thw[image_index][2],\n+                        )\n+                        second_per_grid_t = 0\n+                        image_index += 1\n+                        remain_images -= 1\n+                        ed = ed_image\n+\n+                    else:\n+                        t, h, w = (\n+                            video_grid_thw[video_index][0],\n+                            video_grid_thw[video_index][1],\n+                            video_grid_thw[video_index][2],\n+                        )\n+                        if second_per_grid_ts is not None:\n+                            second_per_grid_t = second_per_grid_ts[video_index]\n+                        else:\n+                            second_per_grid_t = 1.0\n+                        video_index += 1\n+                        remain_videos -= 1\n+                        ed = ed_video\n+                    llm_grid_t, llm_grid_h, llm_grid_w = (\n+                        t.item(),\n+                        h.item() // spatial_merge_size,\n+                        w.item() // spatial_merge_size,\n+                    )\n+                    text_len = ed - st\n+\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+                    llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                    range_tensor = torch.arange(llm_grid_t).view(-1, 1)\n+                    expanded_range = range_tensor.expand(-1, llm_grid_h * llm_grid_w)\n+\n+                    time_tensor = expanded_range * second_per_grid_t * self.config.vision_config.tokens_per_second\n+\n+                    time_tensor_long = time_tensor.long()\n+                    t_index = time_tensor_long.flatten()\n+\n+                    h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(llm_grid_t, -1, llm_grid_w).flatten()\n+                    w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(llm_grid_t, llm_grid_h, -1).flatten()\n+                    llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + text_len + st_idx)\n+                    st = ed + llm_grid_t * llm_grid_h * llm_grid_w\n+\n+                if st < len(input_tokens):\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+                    text_len = len(input_tokens) - st\n+                    llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                llm_positions = torch.cat(llm_pos_ids_list, dim=1).reshape(3, -1)\n+                position_ids[..., i, attention_mask[i] == 1] = llm_positions.to(position_ids.device)\n+                mrope_position_deltas.append(llm_positions.max() + 1 - len(total_input_ids[i]))\n+            mrope_position_deltas = torch.tensor(mrope_position_deltas, device=input_ids.device).unsqueeze(1)\n+            return position_ids, mrope_position_deltas\n+        else:\n+            if attention_mask is not None:\n+                position_ids = attention_mask.long().cumsum(-1) - 1\n+                position_ids.masked_fill_(attention_mask == 0, 1)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1).to(attention_mask.device)\n+                max_position_ids = position_ids.max(0, keepdim=False)[0].max(-1, keepdim=True)[0]\n+                mrope_position_deltas = max_position_ids + 1 - attention_mask.shape[-1]\n+            else:\n+                position_ids = (\n+                    torch.arange(input_ids.shape[1], device=input_ids.device)\n+                    .view(1, 1, -1)\n+                    .expand(3, input_ids.shape[0], -1)\n+                )\n+                mrope_position_deltas = torch.zeros(\n+                    [input_ids.shape[0], 1],\n+                    device=input_ids.device,\n+                    dtype=input_ids.dtype,\n+                )\n+\n+            return position_ids, mrope_position_deltas\n+\n+    @add_start_docstrings_to_model_forward(QWEN2_5_VL_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=Qwen2_5_VLCausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        second_per_grid_ts: Optional[torch.Tensor] = None,\n+    ) -> Union[Tuple, Qwen2_5_VLCausalLMOutputWithPast]:\n+        r\"\"\"\n+        Args:\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> from PIL import Image\n+        >>> import requests\n+        >>> from transformers import AutoProcessor, Qwen2_5_VLForConditionalGeneration\n+\n+        >>> model = Qwen2_5_VLForConditionalGeneration.from_pretrained(\"Qwen/Qwen2.5-VL-7B-Instruct\")\n+        >>> processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2.5-VL-7B-Instruct\")\n+\n+        >>> messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\"},\n+                    {\"type\": \"text\", \"text\": \"What is shown in this image?\"},\n+                ],\n+            },\n+        ]\n+        >>> url = \"https://www.ilankelman.org/stopsigns/australia.jpg\"\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> text = processor.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\n+        >>> inputs = processor(text=[text], images=[image], vision_infos=[vision_infos])\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"The image shows a street scene with a red stop sign in the foreground. In the background, there is a large red gate with Chinese characters ...\"\n+        ```\"\"\"\n+\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.model.embed_tokens(input_ids)\n+            if pixel_values is not None:\n+                pixel_values = pixel_values.type(self.visual.dtype)\n+                image_embeds = self.visual(pixel_values, grid_thw=image_grid_thw)\n+                n_image_tokens = (input_ids == self.config.image_token_id).sum().item()\n+                n_image_features = image_embeds.shape[0]\n+                if n_image_tokens != n_image_features:\n+                    raise ValueError(\n+                        f\"Image features and image tokens do not match: tokens: {n_image_tokens}, features {n_image_features}\"\n+                    )\n+\n+                mask = input_ids == self.config.image_token_id\n+                mask_unsqueezed = mask.unsqueeze(-1)\n+                mask_expanded = mask_unsqueezed.expand_as(inputs_embeds)\n+                image_mask = mask_expanded.to(inputs_embeds.device)\n+\n+                image_embeds = image_embeds.to(inputs_embeds.device, inputs_embeds.dtype)\n+                inputs_embeds = inputs_embeds.masked_scatter(image_mask, image_embeds)\n+\n+            if pixel_values_videos is not None:\n+                pixel_values_videos = pixel_values_videos.type(self.visual.dtype)\n+                video_embeds = self.visual(pixel_values_videos, grid_thw=video_grid_thw)\n+                n_video_tokens = (input_ids == self.config.video_token_id).sum().item()\n+                n_video_features = video_embeds.shape[0]\n+                if n_video_tokens != n_video_features:\n+                    raise ValueError(\n+                        f\"Video features and video tokens do not match: tokens: {n_video_tokens}, features {n_video_features}\"\n+                    )\n+\n+                mask = input_ids == self.config.video_token_id\n+                mask_unsqueezed = mask.unsqueeze(-1)\n+                mask_expanded = mask_unsqueezed.expand_as(inputs_embeds)\n+                video_mask = mask_expanded.to(inputs_embeds.device)\n+\n+                video_embeds = video_embeds.to(inputs_embeds.device, inputs_embeds.dtype)\n+                inputs_embeds = inputs_embeds.masked_scatter(video_mask, video_embeds)\n+\n+            if attention_mask is not None:\n+                attention_mask = attention_mask.to(inputs_embeds.device)\n+\n+        # if we get 4D attention mask we cannot calculate rope deltas anymore. TODO @raushan fixme\n+        if position_ids is None and (attention_mask is None or attention_mask.ndim == 2):\n+            # calculate RoPE index once per generation in the pre-fill stage only\n+            if (cache_position is not None and cache_position[0] == 0) or self.rope_deltas is None:\n+                position_ids, rope_deltas = self.get_rope_index(\n+                    input_ids,\n+                    image_grid_thw,\n+                    video_grid_thw,\n+                    second_per_grid_ts,\n+                    attention_mask,\n+                )\n+                self.rope_deltas = rope_deltas\n+            # then use the prev pre-calculated rope-deltas to get the correct position ids\n+            else:\n+                batch_size, seq_length, _ = inputs_embeds.shape\n+                delta = (\n+                    (cache_position[0] + self.rope_deltas).to(inputs_embeds.device)\n+                    if cache_position is not None\n+                    else 0\n+                )\n+                position_ids = torch.arange(seq_length, device=inputs_embeds.device)\n+                position_ids = position_ids.view(1, -1).expand(batch_size, -1)\n+                if cache_position is not None:  # otherwise `deltas` is an int `0`\n+                    delta = delta.repeat_interleave(batch_size // delta.shape[0], dim=0)\n+                position_ids = position_ids.add(delta)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1)\n+\n+        outputs = self.model(\n+            input_ids=None,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+            cache_position=cache_position,\n+        )\n+\n+        hidden_states = outputs[0]\n+        logits = self.lm_head(hidden_states)\n+\n+        loss = None\n+        if labels is not None:\n+            # Upcast to float if we need to compute the loss to avoid potential precision issues\n+            logits = logits.float()\n+            # Shift so that tokens < n predict n\n+            shift_logits = logits[..., :-1, :].contiguous()\n+            shift_labels = labels[..., 1:].contiguous()\n+            # Flatten the tokens\n+            loss_fct = CrossEntropyLoss()\n+            shift_logits = shift_logits.view(-1, self.config.vocab_size)\n+            shift_labels = shift_labels.view(-1)\n+            # Enable model parallelism\n+            shift_labels = shift_labels.to(shift_logits.device)\n+            loss = loss_fct(shift_logits, shift_labels)\n+\n+        if not return_dict:\n+            output = (logits,) + outputs[1:]\n+            return (loss,) + output if loss is not None else output\n+\n+        return Qwen2_5_VLCausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=self.rope_deltas,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        attention_mask=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        position_ids=None,\n+        use_cache=True,\n+        pixel_values=None,\n+        pixel_values_videos=None,\n+        image_grid_thw=None,\n+        video_grid_thw=None,\n+        second_per_grid_ts=None,\n+        **kwargs,\n+    ):\n+        # Overwritten -- in specific circumstances we don't want to forward image inputs to the model\n+\n+        # If we have cache: let's slice `input_ids` through `cache_position`, to keep only the unprocessed tokens\n+        # Exception 1: when passing input_embeds, input_ids may be missing entries\n+        # Exception 2: some generation methods do special slicing of input_ids, so we don't need to do it here\n+        if past_key_values is not None:\n+            if inputs_embeds is not None:  # Exception 1\n+                input_ids = input_ids[:, -cache_position.shape[0] :]\n+            elif input_ids.shape[1] != cache_position.shape[0]:  # Default case (the \"else\", a no op, is Exception 2)\n+                input_ids = input_ids[:, cache_position]\n+\n+        if cache_position[0] != 0:\n+            pixel_values = None\n+            pixel_values_videos = None\n+\n+        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n+        if inputs_embeds is not None and cache_position[0] == 0:\n+            model_inputs = {\"inputs_embeds\": inputs_embeds, \"input_ids\": None}\n+        else:\n+            model_inputs = {\"input_ids\": input_ids, \"inputs_embeds\": None}\n+\n+        if isinstance(past_key_values, StaticCache) and attention_mask.ndim == 2:\n+            if model_inputs[\"inputs_embeds\"] is not None:\n+                batch_size, sequence_length, _ = inputs_embeds.shape\n+                device = inputs_embeds.device\n+            else:\n+                batch_size, sequence_length = input_ids.shape\n+                device = input_ids.device\n+\n+            attention_mask = self.model._prepare_4d_causal_attention_mask_with_cache_position(\n+                attention_mask,\n+                sequence_length=sequence_length,\n+                target_length=past_key_values.get_max_cache_shape(),\n+                dtype=self.lm_head.weight.dtype,\n+                device=device,\n+                cache_position=cache_position,\n+                batch_size=batch_size,\n+                config=self.config,\n+                past_key_values=past_key_values,\n+            )\n+\n+        model_inputs.update(\n+            {\n+                \"position_ids\": position_ids,\n+                \"past_key_values\": past_key_values,\n+                \"use_cache\": use_cache,\n+                \"attention_mask\": attention_mask,\n+                \"pixel_values\": pixel_values,\n+                \"pixel_values_videos\": pixel_values_videos,\n+                \"image_grid_thw\": image_grid_thw,\n+                \"video_grid_thw\": video_grid_thw,\n+                \"cache_position\": cache_position,\n+                \"second_per_grid_ts\": second_per_grid_ts,\n+            }\n+        )\n+        return model_inputs\n+\n+\n+__all__ = [\"Qwen2_5_VLForConditionalGeneration\", \"Qwen2_5_VLModel\", \"Qwen2_5_VLPreTrainedModel\"]"
        },
        {
            "sha": "1e155d6043e0436811e47f28d1baaa62c1436465",
            "filename": "src/transformers/models/qwen2_5_vl/modular_qwen2_5_vl.py",
            "status": "added",
            "additions": 1008,
            "deletions": 0,
            "changes": 1008,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fmodular_qwen2_5_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fmodular_qwen2_5_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fmodular_qwen2_5_vl.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -0,0 +1,1008 @@\n+# coding=utf-8\n+# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch Qwen2.5-VL model.\"\"\"\n+\n+from dataclasses import dataclass\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+import torch.nn as nn\n+import torch.nn.functional as F\n+import torch.utils.checkpoint\n+from torch.nn import CrossEntropyLoss\n+\n+from transformers.models.qwen2_vl.configuration_qwen2_vl import Qwen2VLConfig\n+from transformers.models.qwen2_vl.image_processing_qwen2_vl import Qwen2VLImageProcessor\n+from transformers.models.qwen2_vl.modeling_qwen2_vl import (\n+    PatchEmbed,\n+    PatchMerger,\n+    Qwen2RMSNorm,\n+    Qwen2VLCausalLMOutputWithPast,\n+    Qwen2VLForConditionalGeneration,\n+    Qwen2VLModel,\n+    Qwen2VLPreTrainedModel,\n+    VisionAttention,\n+    VisionRotaryEmbedding,\n+    VisionSdpaAttention,\n+)\n+from transformers.models.qwen2_vl.processing_qwen2_vl import Qwen2VLProcessor\n+\n+from ...activations import ACT2FN\n+from ...cache_utils import StaticCache\n+from ...configuration_utils import PretrainedConfig\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_utils import ImageInput, VideoInput\n+from ...processing_utils import ProcessingKwargs, Unpack, VideosKwargs\n+from ...tokenization_utils_base import PreTokenizedInput, TextInput\n+from ...utils import is_flash_attn_2_available\n+\n+\n+if is_flash_attn_2_available():\n+    from flash_attn import flash_attn_varlen_func\n+    from flash_attn.layers.rotary import apply_rotary_emb\n+\n+else:\n+    flash_attn_varlen_func = None\n+    apply_rotary_emb = None\n+\n+\n+def apply_rotary_pos_emb_flashatt(tensor: torch.Tensor, freqs: torch.Tensor) -> torch.Tensor:\n+    tensor_ = tensor.float()\n+    cos = freqs.cos()\n+    sin = freqs.sin()\n+    output = apply_rotary_emb(tensor_, cos, sin).type_as(tensor)\n+    return output\n+\n+\n+class Qwen2_5_VLVisionConfig(PretrainedConfig):\n+    model_type = \"qwen2_5_vl\"\n+    base_config_key = \"vision_config\"\n+\n+    def __init__(\n+        self,\n+        depth=32,\n+        hidden_size=3584,\n+        hidden_act=\"silu\",\n+        intermediate_size=3420,\n+        num_heads=16,\n+        in_channels=3,\n+        patch_size=14,\n+        spatial_merge_size=2,\n+        temporal_patch_size=2,\n+        tokens_per_second=4,\n+        window_size=112,\n+        out_hidden_size=3584,\n+        fullatt_block_indexes=[7, 15, 23, 31],\n+        **kwargs,\n+    ):\n+        super().__init__(**kwargs)\n+\n+        self.depth = depth\n+        self.hidden_size = hidden_size\n+        self.hidden_act = hidden_act\n+        self.intermediate_size = intermediate_size\n+        self.num_heads = num_heads\n+        self.in_channels = in_channels\n+        self.patch_size = patch_size\n+        self.spatial_merge_size = spatial_merge_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.tokens_per_second = tokens_per_second\n+        self.window_size = window_size\n+        self.fullatt_block_indexes = fullatt_block_indexes\n+        self.out_hidden_size = out_hidden_size\n+\n+\n+class Qwen2_5_VLConfig(Qwen2VLConfig):\n+    model_type = \"qwen2_5_vl\"\n+    sub_configs = {\"vision_config\": Qwen2_5_VLVisionConfig}\n+\n+\n+class Qwen2_5_VLMLP(nn.Module):\n+    def __init__(self, config, bias: bool = False):\n+        super().__init__()\n+        self.hidden_size = config.hidden_size\n+        self.intermediate_size = config.intermediate_size\n+        self.gate_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=bias)\n+        self.up_proj = nn.Linear(self.hidden_size, self.intermediate_size, bias=bias)\n+        self.down_proj = nn.Linear(self.intermediate_size, self.hidden_size, bias=bias)\n+        self.act_fn = ACT2FN[config.hidden_act]\n+\n+    def forward(self, hidden_state):\n+        return self.down_proj(self.act_fn(self.gate_proj(hidden_state)) * self.up_proj(hidden_state))\n+\n+\n+class Qwen2_5_VisionPatchEmbed(PatchEmbed):\n+    pass\n+\n+\n+class Qwen2_5_VisionRotaryEmbedding(VisionRotaryEmbedding):\n+    pass\n+\n+\n+class Qwen2_5_VLPatchMerger(PatchMerger):\n+    def __init__(self, dim: int, context_dim: int, spatial_merge_size: int = 2) -> None:\n+        super().__init__(dim, context_dim, spatial_merge_size)\n+        self.ln_q = Qwen2RMSNorm(context_dim, eps=1e-6)\n+\n+\n+class Qwen2_5_VLVisionFlashAttention2(nn.Module):\n+    def __init__(self, dim: int, num_heads: int = 16) -> None:\n+        super().__init__()\n+        self.num_heads = num_heads\n+        self.qkv = nn.Linear(dim, dim * 3, bias=True)\n+        self.proj = nn.Linear(dim, dim)\n+\n+    def forward(\n+        self,\n+        hidden_states: torch.Tensor,\n+        cu_seqlens: torch.Tensor,\n+        rotary_pos_emb: torch.Tensor = None,\n+    ) -> torch.Tensor:\n+        seq_length = hidden_states.shape[0]\n+        q, k, v = self.qkv(hidden_states).reshape(seq_length, 3, self.num_heads, -1).permute(1, 0, 2, 3).unbind(0)\n+        q = apply_rotary_pos_emb_flashatt(q.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+        k = apply_rotary_pos_emb_flashatt(k.unsqueeze(0), rotary_pos_emb).squeeze(0)\n+\n+        max_seqlen = (cu_seqlens[1:] - cu_seqlens[:-1]).max().item()\n+        attn_output = flash_attn_varlen_func(q, k, v, cu_seqlens, cu_seqlens, max_seqlen, max_seqlen).reshape(\n+            seq_length, -1\n+        )\n+        attn_output = self.proj(attn_output)\n+        return attn_output\n+\n+\n+class Qwen2_5_VLVisionAttention(VisionAttention):\n+    pass\n+\n+\n+class Qwen2_5_VLVisionSdpaAttention(VisionSdpaAttention):\n+    pass\n+\n+\n+QWEN2_5_VL_VISION_ATTENTION_CLASSES = {\n+    \"eager\": Qwen2_5_VLVisionAttention,\n+    \"flash_attention_2\": Qwen2_5_VLVisionFlashAttention2,\n+    \"sdpa\": Qwen2_5_VLVisionSdpaAttention,\n+}\n+\n+\n+class Qwen2_5_VLVisionBlock(nn.Module):\n+    def __init__(self, config, attn_implementation: str = \"sdpa\") -> None:\n+        super().__init__()\n+        self.norm1 = Qwen2RMSNorm(config.hidden_size, eps=1e-6)\n+        self.norm2 = Qwen2RMSNorm(config.hidden_size, eps=1e-6)\n+        self.attn = QWEN2_5_VL_VISION_ATTENTION_CLASSES[attn_implementation](\n+            config.hidden_size, num_heads=config.num_heads\n+        )\n+        self.mlp = Qwen2_5_VLMLP(config, bias=True)\n+\n+    def forward(self, hidden_states, cu_seqlens, rotary_pos_emb) -> torch.Tensor:\n+        hidden_states = hidden_states + self.attn(\n+            self.norm1(hidden_states),\n+            cu_seqlens=cu_seqlens,\n+            rotary_pos_emb=rotary_pos_emb,\n+        )\n+        hidden_states = hidden_states + self.mlp(self.norm2(hidden_states))\n+        return hidden_states\n+\n+\n+class Qwen2_5_VLPreTrainedModel(Qwen2VLPreTrainedModel):\n+    pass\n+\n+\n+class Qwen2_5_VisionTransformerPretrainedModel(Qwen2_5_VLPreTrainedModel):\n+    config_class = Qwen2_5_VLVisionConfig\n+    _no_split_modules = [\"Qwen2_5_VLVisionBlock\"]\n+\n+    def __init__(self, config, *inputs, **kwargs) -> None:\n+        super().__init__(config, *inputs, **kwargs)\n+        self.spatial_merge_size = config.spatial_merge_size\n+        self.patch_size = config.patch_size\n+        self.fullatt_block_indexes = config.fullatt_block_indexes\n+        self.window_size = config.window_size\n+        self.spatial_merge_unit = self.spatial_merge_size * self.spatial_merge_size\n+\n+        self.patch_embed = Qwen2_5_VisionPatchEmbed(\n+            patch_size=config.patch_size,\n+            temporal_patch_size=config.temporal_patch_size,\n+            in_channels=config.in_channels,\n+            embed_dim=config.hidden_size,\n+        )\n+\n+        head_dim = config.hidden_size // config.num_heads\n+        self.rotary_pos_emb = Qwen2_5_VisionRotaryEmbedding(head_dim // 2)\n+\n+        self.blocks = nn.ModuleList(\n+            [Qwen2_5_VLVisionBlock(config, config._attn_implementation) for _ in range(config.depth)]\n+        )\n+        self.merger = Qwen2_5_VLPatchMerger(\n+            dim=config.out_hidden_size,\n+            context_dim=config.hidden_size,\n+            spatial_merge_size=config.spatial_merge_size,\n+        )\n+        self.gradient_checkpointing = False\n+\n+    def rot_pos_emb(self, grid_thw):\n+        pos_ids = []\n+        for t, h, w in grid_thw:\n+            hpos_ids = torch.arange(h).unsqueeze(1).expand(-1, w)\n+            hpos_ids = hpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            hpos_ids = hpos_ids.permute(0, 2, 1, 3)\n+            hpos_ids = hpos_ids.flatten()\n+\n+            wpos_ids = torch.arange(w).unsqueeze(0).expand(h, -1)\n+            wpos_ids = wpos_ids.reshape(\n+                h // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+                w // self.spatial_merge_size,\n+                self.spatial_merge_size,\n+            )\n+            wpos_ids = wpos_ids.permute(0, 2, 1, 3)\n+            wpos_ids = wpos_ids.flatten()\n+            pos_ids.append(torch.stack([hpos_ids, wpos_ids], dim=-1).repeat(t, 1))\n+        pos_ids = torch.cat(pos_ids, dim=0)\n+        max_grid_size = grid_thw[:, 1:].max()\n+        rotary_pos_emb_full = self.rotary_pos_emb(max_grid_size)\n+        rotary_pos_emb = rotary_pos_emb_full[pos_ids].flatten(1)\n+        return rotary_pos_emb\n+\n+    def get_window_index(self, grid_thw):\n+        window_index: list = []\n+        cu_window_seqlens: list = [0]\n+        window_index_id = 0\n+        vit_merger_window_size = self.window_size // self.spatial_merge_size // self.patch_size\n+\n+        for grid_t, grid_h, grid_w in grid_thw:\n+            llm_grid_h, llm_grid_w = (\n+                grid_h // self.spatial_merge_size,\n+                grid_w // self.spatial_merge_size,\n+            )\n+            index = torch.arange(grid_t * llm_grid_h * llm_grid_w).reshape(grid_t, llm_grid_h, llm_grid_w)\n+            pad_h = vit_merger_window_size - llm_grid_h % vit_merger_window_size\n+            pad_w = vit_merger_window_size - llm_grid_w % vit_merger_window_size\n+            num_windows_h = (llm_grid_h + pad_h) // vit_merger_window_size\n+            num_windows_w = (llm_grid_w + pad_w) // vit_merger_window_size\n+            index_padded = F.pad(index, (0, pad_w, 0, pad_h), \"constant\", -100)\n+            index_padded = index_padded.reshape(\n+                grid_t,\n+                num_windows_h,\n+                vit_merger_window_size,\n+                num_windows_w,\n+                vit_merger_window_size,\n+            )\n+            index_padded = index_padded.permute(0, 1, 3, 2, 4).reshape(\n+                grid_t,\n+                num_windows_h * num_windows_w,\n+                vit_merger_window_size,\n+                vit_merger_window_size,\n+            )\n+            seqlens = (index_padded != -100).sum([2, 3]).reshape(-1)\n+            index_padded = index_padded.reshape(-1)\n+            index_new = index_padded[index_padded != -100]\n+            window_index.append(index_new + window_index_id)\n+            cu_seqlens_tmp = seqlens.cumsum(0) * self.spatial_merge_unit + cu_window_seqlens[-1]\n+            cu_window_seqlens.extend(cu_seqlens_tmp.tolist())\n+            window_index_id += (grid_t * llm_grid_h * llm_grid_w).item()\n+        window_index = torch.cat(window_index, dim=0)\n+\n+        return window_index, cu_window_seqlens\n+\n+    def forward(self, hidden_states: torch.Tensor, grid_thw: torch.Tensor) -> torch.Tensor:\n+        \"\"\"\n+        Args:\n+            hidden_states (`torch.Tensor` of shape `(batch_size, seq_len, hidden_size)`):\n+                The final hidden states of the model.\n+            grid_thw (`torch.Tensor` of shape `(num_images_or_videos, 3)`):\n+                The temporal, height and width of feature shape of each image in LLM.\n+\n+        Returns:\n+            `torch.Tensor`: hidden_states.\n+        \"\"\"\n+        hidden_states = self.patch_embed(hidden_states)\n+        rotary_pos_emb = self.rot_pos_emb(grid_thw)\n+        window_index, cu_window_seqlens = self.get_window_index(grid_thw)\n+        cu_window_seqlens = torch.tensor(\n+            cu_window_seqlens,\n+            device=hidden_states.device,\n+            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_window_seqlens = torch.unique_consecutive(cu_window_seqlens)\n+\n+        seq_len, _ = hidden_states.size()\n+        hidden_states = hidden_states.reshape(seq_len // self.spatial_merge_unit, self.spatial_merge_unit, -1)\n+        hidden_states = hidden_states[window_index, :, :]\n+        hidden_states = hidden_states.reshape(seq_len, -1)\n+        rotary_pos_emb = rotary_pos_emb.reshape(seq_len // self.spatial_merge_unit, self.spatial_merge_unit, -1)\n+        rotary_pos_emb = rotary_pos_emb[window_index, :, :]\n+        rotary_pos_emb = rotary_pos_emb.reshape(seq_len, -1)\n+\n+        cu_seqlens = torch.repeat_interleave(grid_thw[:, 1] * grid_thw[:, 2], grid_thw[:, 0]).cumsum(\n+            dim=0,\n+            # Select dtype based on the following factors:\n+            #  - FA2 requires that cu_seqlens_q must have dtype int32\n+            #  - torch.onnx.export requires that cu_seqlens_q must have same dtype as grid_thw\n+            # See https://github.com/huggingface/transformers/pull/34852 for more information\n+            dtype=grid_thw.dtype if torch.jit.is_tracing() else torch.int32,\n+        )\n+        cu_seqlens = F.pad(cu_seqlens, (1, 0), value=0)\n+\n+        for layer_num, blk in enumerate(self.blocks):\n+            if layer_num in self.fullatt_block_indexes:\n+                cu_seqlens_now = cu_seqlens\n+            else:\n+                cu_seqlens_now = cu_window_seqlens\n+            if self.gradient_checkpointing and self.training:\n+                hidden_states = self._gradient_checkpointing_func(\n+                    blk.__call__, hidden_states, cu_seqlens_now, rotary_pos_emb\n+                )\n+            else:\n+                hidden_states = blk(\n+                    hidden_states,\n+                    cu_seqlens=cu_seqlens_now,\n+                    rotary_pos_emb=rotary_pos_emb,\n+                )\n+\n+        hidden_states = self.merger(hidden_states)\n+        reverse_indices = torch.argsort(window_index)\n+        hidden_states = hidden_states[reverse_indices, :]\n+\n+        return hidden_states\n+\n+\n+class Qwen2_5_VLModel(Qwen2VLModel):\n+    pass\n+\n+\n+@dataclass\n+class Qwen2_5_VLCausalLMOutputWithPast(Qwen2VLCausalLMOutputWithPast):\n+    pass\n+\n+\n+class Qwen2_5_VLForConditionalGeneration(Qwen2VLForConditionalGeneration):\n+    config_class = Qwen2_5_VLConfig\n+    _no_split_modules = [\"Qwen2VLDecoderLayer\", \"Qwen2_5_VLVisionBlock\"]\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.visual = Qwen2_5_VisionTransformerPretrainedModel._from_config(config.vision_config)\n+\n+    def get_rope_index(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        second_per_grid_ts: Optional[torch.Tensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+    ) -> Tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Calculate the 3D rope index based on image and video's temporal, height and width in LLM.\n+\n+        Explanation:\n+            Each embedding sequence contains vision embedding and text embedding or just contains text embedding.\n+\n+            For pure text embedding sequence, the rotary position embedding has no difference with modern LLMs.\n+            Examples:\n+                input_ids: [T T T T T], here T is for text.\n+                temporal position_ids: [0, 1, 2, 3, 4]\n+                height position_ids: [0, 1, 2, 3, 4]\n+                width position_ids: [0, 1, 2, 3, 4]\n+\n+            For vision and text embedding sequence, we calculate 3D rotary position embedding for vision part\n+            and 1D rotary position embeddin for text part.\n+            Examples:\n+                Temporal (Time): 3 patches, representing different segments of the video in time.\n+                Height: 2 patches, dividing each frame vertically.\n+                Width: 2 patches, dividing each frame horizontally.\n+                We also have some important parameters:\n+                fps (Frames Per Second): The video's frame rate, set to 1. This means one frame is processed each second.\n+                tokens_per_second: This is a crucial parameter. It dictates how many \"time-steps\" or \"temporal tokens\" are conceptually packed into a one-second interval of the video. In this case, we have 25 tokens per second. So each second of the video will be represented with 25 separate time points. It essentially defines the temporal granularity.\n+                temporal_patch_size: The number of frames that compose one temporal patch. Here, it's 2 frames.\n+                interval: The step size for the temporal position IDs, calculated as tokens_per_second * temporal_patch_size / fps. In this case, 25 * 2 / 1 = 50. This means that each temporal patch will be have a difference of 50 in the temporal position IDs.\n+                input_ids: [V V V V V V V V V V V V T T T T T], here V is for vision.\n+                vision temporal position_ids: [0, 0, 0, 0, 50, 50, 50, 50, 100, 100, 100, 100]\n+                vision height position_ids: [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]\n+                vision width position_ids: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n+                text temporal position_ids: [101, 102, 103, 104, 105]\n+                text height position_ids: [101, 102, 103, 104, 105]\n+                text width position_ids: [101, 102, 103, 104, 105]\n+                Here we calculate the text start position_ids as the max vision position_ids plus 1.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+                it.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+            second_per_grid_ts (`torch.Tensor` of shape `(num_videos)`, *optional*):\n+                The time interval (in seconds) for each grid along the temporal dimension in the 3D position IDs.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+\n+        Returns:\n+            position_ids (`torch.LongTensor` of shape `(3, batch_size, sequence_length)`)\n+            mrope_position_deltas (`torch.Tensor` of shape `(batch_size)`)\n+        \"\"\"\n+        spatial_merge_size = self.config.vision_config.spatial_merge_size\n+        image_token_id = self.config.image_token_id\n+        video_token_id = self.config.video_token_id\n+        vision_start_token_id = self.config.vision_start_token_id\n+        mrope_position_deltas = []\n+        if input_ids is not None and (image_grid_thw is not None or video_grid_thw is not None):\n+            total_input_ids = input_ids\n+            if attention_mask is None:\n+                attention_mask = torch.ones_like(total_input_ids)\n+            position_ids = torch.ones(\n+                3,\n+                input_ids.shape[0],\n+                input_ids.shape[1],\n+                dtype=input_ids.dtype,\n+                device=input_ids.device,\n+            )\n+            image_index, video_index = 0, 0\n+            attention_mask = attention_mask.to(total_input_ids.device)\n+            for i, input_ids in enumerate(total_input_ids):\n+                input_ids = input_ids[attention_mask[i] == 1]\n+                image_nums, video_nums = 0, 0\n+                vision_start_indices = torch.argwhere(input_ids == vision_start_token_id).squeeze(1)\n+                vision_tokens = input_ids[vision_start_indices + 1]\n+                image_nums = (vision_tokens == image_token_id).sum()\n+                video_nums = (vision_tokens == video_token_id).sum()\n+                input_tokens = input_ids.tolist()\n+                llm_pos_ids_list: list = []\n+                st = 0\n+                remain_images, remain_videos = image_nums, video_nums\n+                for _ in range(image_nums + video_nums):\n+                    if image_token_id in input_tokens and remain_images > 0:\n+                        ed_image = input_tokens.index(image_token_id, st)\n+                    else:\n+                        ed_image = len(input_tokens) + 1\n+                    if video_token_id in input_tokens and remain_videos > 0:\n+                        ed_video = input_tokens.index(video_token_id, st)\n+                    else:\n+                        ed_video = len(input_tokens) + 1\n+                    if ed_image < ed_video:\n+                        t, h, w = (\n+                            image_grid_thw[image_index][0],\n+                            image_grid_thw[image_index][1],\n+                            image_grid_thw[image_index][2],\n+                        )\n+                        second_per_grid_t = 0\n+                        image_index += 1\n+                        remain_images -= 1\n+                        ed = ed_image\n+\n+                    else:\n+                        t, h, w = (\n+                            video_grid_thw[video_index][0],\n+                            video_grid_thw[video_index][1],\n+                            video_grid_thw[video_index][2],\n+                        )\n+                        if second_per_grid_ts is not None:\n+                            second_per_grid_t = second_per_grid_ts[video_index]\n+                        else:\n+                            second_per_grid_t = 1.0\n+                        video_index += 1\n+                        remain_videos -= 1\n+                        ed = ed_video\n+                    llm_grid_t, llm_grid_h, llm_grid_w = (\n+                        t.item(),\n+                        h.item() // spatial_merge_size,\n+                        w.item() // spatial_merge_size,\n+                    )\n+                    text_len = ed - st\n+\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+                    llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                    range_tensor = torch.arange(llm_grid_t).view(-1, 1)\n+                    expanded_range = range_tensor.expand(-1, llm_grid_h * llm_grid_w)\n+\n+                    time_tensor = expanded_range * second_per_grid_t * self.config.vision_config.tokens_per_second\n+\n+                    time_tensor_long = time_tensor.long()\n+                    t_index = time_tensor_long.flatten()\n+\n+                    h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(llm_grid_t, -1, llm_grid_w).flatten()\n+                    w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(llm_grid_t, llm_grid_h, -1).flatten()\n+                    llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + text_len + st_idx)\n+                    st = ed + llm_grid_t * llm_grid_h * llm_grid_w\n+\n+                if st < len(input_tokens):\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+                    text_len = len(input_tokens) - st\n+                    llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                llm_positions = torch.cat(llm_pos_ids_list, dim=1).reshape(3, -1)\n+                position_ids[..., i, attention_mask[i] == 1] = llm_positions.to(position_ids.device)\n+                mrope_position_deltas.append(llm_positions.max() + 1 - len(total_input_ids[i]))\n+            mrope_position_deltas = torch.tensor(mrope_position_deltas, device=input_ids.device).unsqueeze(1)\n+            return position_ids, mrope_position_deltas\n+        else:\n+            if attention_mask is not None:\n+                position_ids = attention_mask.long().cumsum(-1) - 1\n+                position_ids.masked_fill_(attention_mask == 0, 1)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1).to(attention_mask.device)\n+                max_position_ids = position_ids.max(0, keepdim=False)[0].max(-1, keepdim=True)[0]\n+                mrope_position_deltas = max_position_ids + 1 - attention_mask.shape[-1]\n+            else:\n+                position_ids = (\n+                    torch.arange(input_ids.shape[1], device=input_ids.device)\n+                    .view(1, 1, -1)\n+                    .expand(3, input_ids.shape[0], -1)\n+                )\n+                mrope_position_deltas = torch.zeros(\n+                    [input_ids.shape[0], 1],\n+                    device=input_ids.device,\n+                    dtype=input_ids.dtype,\n+                )\n+\n+            return position_ids, mrope_position_deltas\n+\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        second_per_grid_ts: Optional[torch.Tensor] = None,\n+    ) -> Union[Tuple, Qwen2_5_VLCausalLMOutputWithPast]:\n+        r\"\"\"\n+        Args:\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+        Returns:\n+\n+        Example:\n+\n+        ```python\n+        >>> from PIL import Image\n+        >>> import requests\n+        >>> from transformers import AutoProcessor, Qwen2_5_VLForConditionalGeneration\n+\n+        >>> model = Qwen2_5_VLForConditionalGeneration.from_pretrained(\"Qwen/Qwen2.5-VL-7B-Instruct\")\n+        >>> processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2.5-VL-7B-Instruct\")\n+\n+        >>> messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\"},\n+                    {\"type\": \"text\", \"text\": \"What is shown in this image?\"},\n+                ],\n+            },\n+        ]\n+        >>> url = \"https://www.ilankelman.org/stopsigns/australia.jpg\"\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> text = processor.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\n+        >>> inputs = processor(text=[text], images=[image], vision_infos=[vision_infos])\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"The image shows a street scene with a red stop sign in the foreground. In the background, there is a large red gate with Chinese characters ...\"\n+        ```\"\"\"\n+\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.model.embed_tokens(input_ids)\n+            if pixel_values is not None:\n+                pixel_values = pixel_values.type(self.visual.dtype)\n+                image_embeds = self.visual(pixel_values, grid_thw=image_grid_thw)\n+                n_image_tokens = (input_ids == self.config.image_token_id).sum().item()\n+                n_image_features = image_embeds.shape[0]\n+                if n_image_tokens != n_image_features:\n+                    raise ValueError(\n+                        f\"Image features and image tokens do not match: tokens: {n_image_tokens}, features {n_image_features}\"\n+                    )\n+\n+                mask = input_ids == self.config.image_token_id\n+                mask_unsqueezed = mask.unsqueeze(-1)\n+                mask_expanded = mask_unsqueezed.expand_as(inputs_embeds)\n+                image_mask = mask_expanded.to(inputs_embeds.device)\n+\n+                image_embeds = image_embeds.to(inputs_embeds.device, inputs_embeds.dtype)\n+                inputs_embeds = inputs_embeds.masked_scatter(image_mask, image_embeds)\n+\n+            if pixel_values_videos is not None:\n+                pixel_values_videos = pixel_values_videos.type(self.visual.dtype)\n+                video_embeds = self.visual(pixel_values_videos, grid_thw=video_grid_thw)\n+                n_video_tokens = (input_ids == self.config.video_token_id).sum().item()\n+                n_video_features = video_embeds.shape[0]\n+                if n_video_tokens != n_video_features:\n+                    raise ValueError(\n+                        f\"Video features and video tokens do not match: tokens: {n_video_tokens}, features {n_video_features}\"\n+                    )\n+\n+                mask = input_ids == self.config.video_token_id\n+                mask_unsqueezed = mask.unsqueeze(-1)\n+                mask_expanded = mask_unsqueezed.expand_as(inputs_embeds)\n+                video_mask = mask_expanded.to(inputs_embeds.device)\n+\n+                video_embeds = video_embeds.to(inputs_embeds.device, inputs_embeds.dtype)\n+                inputs_embeds = inputs_embeds.masked_scatter(video_mask, video_embeds)\n+\n+            if attention_mask is not None:\n+                attention_mask = attention_mask.to(inputs_embeds.device)\n+\n+        # if we get 4D attention mask we cannot calculate rope deltas anymore. TODO @raushan fixme\n+        if position_ids is None and (attention_mask is None or attention_mask.ndim == 2):\n+            # calculate RoPE index once per generation in the pre-fill stage only\n+            if (cache_position is not None and cache_position[0] == 0) or self.rope_deltas is None:\n+                position_ids, rope_deltas = self.get_rope_index(\n+                    input_ids,\n+                    image_grid_thw,\n+                    video_grid_thw,\n+                    second_per_grid_ts,\n+                    attention_mask,\n+                )\n+                self.rope_deltas = rope_deltas\n+            # then use the prev pre-calculated rope-deltas to get the correct position ids\n+            else:\n+                batch_size, seq_length, _ = inputs_embeds.shape\n+                delta = (\n+                    (cache_position[0] + self.rope_deltas).to(inputs_embeds.device)\n+                    if cache_position is not None\n+                    else 0\n+                )\n+                position_ids = torch.arange(seq_length, device=inputs_embeds.device)\n+                position_ids = position_ids.view(1, -1).expand(batch_size, -1)\n+                if cache_position is not None:  # otherwise `deltas` is an int `0`\n+                    delta = delta.repeat_interleave(batch_size // delta.shape[0], dim=0)\n+                position_ids = position_ids.add(delta)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1)\n+\n+        outputs = self.model(\n+            input_ids=None,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+            cache_position=cache_position,\n+        )\n+\n+        hidden_states = outputs[0]\n+        logits = self.lm_head(hidden_states)\n+\n+        loss = None\n+        if labels is not None:\n+            # Upcast to float if we need to compute the loss to avoid potential precision issues\n+            logits = logits.float()\n+            # Shift so that tokens < n predict n\n+            shift_logits = logits[..., :-1, :].contiguous()\n+            shift_labels = labels[..., 1:].contiguous()\n+            # Flatten the tokens\n+            loss_fct = CrossEntropyLoss()\n+            shift_logits = shift_logits.view(-1, self.config.vocab_size)\n+            shift_labels = shift_labels.view(-1)\n+            # Enable model parallelism\n+            shift_labels = shift_labels.to(shift_logits.device)\n+            loss = loss_fct(shift_logits, shift_labels)\n+\n+        if not return_dict:\n+            output = (logits,) + outputs[1:]\n+            return (loss,) + output if loss is not None else output\n+\n+        return Qwen2_5_VLCausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=self.rope_deltas,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        attention_mask=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        position_ids=None,\n+        use_cache=True,\n+        pixel_values=None,\n+        pixel_values_videos=None,\n+        image_grid_thw=None,\n+        video_grid_thw=None,\n+        second_per_grid_ts=None,\n+        **kwargs,\n+    ):\n+        # Overwritten -- in specific circumstances we don't want to forward image inputs to the model\n+\n+        # If we have cache: let's slice `input_ids` through `cache_position`, to keep only the unprocessed tokens\n+        # Exception 1: when passing input_embeds, input_ids may be missing entries\n+        # Exception 2: some generation methods do special slicing of input_ids, so we don't need to do it here\n+        if past_key_values is not None:\n+            if inputs_embeds is not None:  # Exception 1\n+                input_ids = input_ids[:, -cache_position.shape[0] :]\n+            elif input_ids.shape[1] != cache_position.shape[0]:  # Default case (the \"else\", a no op, is Exception 2)\n+                input_ids = input_ids[:, cache_position]\n+\n+        if cache_position[0] != 0:\n+            pixel_values = None\n+            pixel_values_videos = None\n+\n+        # if `inputs_embeds` are passed, we only want to use them in the 1st generation step\n+        if inputs_embeds is not None and cache_position[0] == 0:\n+            model_inputs = {\"inputs_embeds\": inputs_embeds, \"input_ids\": None}\n+        else:\n+            model_inputs = {\"input_ids\": input_ids, \"inputs_embeds\": None}\n+\n+        if isinstance(past_key_values, StaticCache) and attention_mask.ndim == 2:\n+            if model_inputs[\"inputs_embeds\"] is not None:\n+                batch_size, sequence_length, _ = inputs_embeds.shape\n+                device = inputs_embeds.device\n+            else:\n+                batch_size, sequence_length = input_ids.shape\n+                device = input_ids.device\n+\n+            attention_mask = self.model._prepare_4d_causal_attention_mask_with_cache_position(\n+                attention_mask,\n+                sequence_length=sequence_length,\n+                target_length=past_key_values.get_max_cache_shape(),\n+                dtype=self.lm_head.weight.dtype,\n+                device=device,\n+                cache_position=cache_position,\n+                batch_size=batch_size,\n+                config=self.config,\n+                past_key_values=past_key_values,\n+            )\n+\n+        model_inputs.update(\n+            {\n+                \"position_ids\": position_ids,\n+                \"past_key_values\": past_key_values,\n+                \"use_cache\": use_cache,\n+                \"attention_mask\": attention_mask,\n+                \"pixel_values\": pixel_values,\n+                \"pixel_values_videos\": pixel_values_videos,\n+                \"image_grid_thw\": image_grid_thw,\n+                \"video_grid_thw\": video_grid_thw,\n+                \"cache_position\": cache_position,\n+                \"second_per_grid_ts\": second_per_grid_ts,\n+            }\n+        )\n+        return model_inputs\n+\n+\n+class Qwen2_5_VLImageProcessor(Qwen2VLImageProcessor):\n+    r\"\"\"\n+    Constructs a Qwen2.5-VL image processor that dynamically resizes images based on the original images.\n+\n+    Args:\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image's (height, width) dimensions.\n+        resample (`PILImageResampling`, *optional*, defaults to `Resampling.BICUBIC`):\n+            Resampling filter to use when resizing the image.\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image by the specified scale `rescale_factor`.\n+        rescale_factor (`int` or `float`, *optional*, defaults to `1/255`):\n+            Scale factor to use if rescaling the image.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image.\n+        image_mean (`float` or `List[float]`, *optional*, defaults to `[0.48145466, 0.4578275, 0.40821073]`):\n+            Mean to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        image_std (`float` or `List[float]`, *optional*, defaults to `[0.26862954, 0.26130258, 0.27577711]`):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB.\n+        min_pixels (`int`, *optional*, defaults to `56 * 56`):\n+            The min pixels of the image to resize the image.\n+        max_pixels (`int`, *optional*, defaults to `28 * 28 * 1280`):\n+            The max pixels of the image to resize the image.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spacial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The temporal patch size of the vision encoder.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    model_input_names = [\n+        \"pixel_values\",\n+        \"image_grid_thw\",\n+        \"pixel_values_videos\",\n+        \"video_grid_thw\",\n+        \"second_per_grid_ts\",\n+    ]\n+\n+\n+class Qwen2_5_VLVideosProcessorKwargs(VideosKwargs, total=False):\n+    fps: Union[List[float], float]\n+\n+\n+class Qwen2_5_VLProcessorKwargs(ProcessingKwargs, total=False):\n+    videos_kwargs: Qwen2_5_VLVideosProcessorKwargs\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": False,\n+        },\n+        \"videos_kwargs\": {\"fps\": 2.0},\n+    }\n+\n+\n+class Qwen2_5_VLProcessor(Qwen2VLProcessor):\n+    r\"\"\"\n+    Constructs a Qwen2.5-VL processor which wraps a Qwen2.5-VL image processor and a Qwen2 tokenizer into a single processor.\n+    [`Qwen2_5_VLProcessor`] offers all the functionalities of [`Qwen2_5_VLImageProcessor`] and [`Qwen2TokenizerFast`]. See the\n+    [`~Qwen2_5_VLProcessor.__call__`] and [`~Qwen2_5_VLProcessor.decode`] for more information.\n+    Args:\n+        image_processor ([`Qwen2_5_VLImageProcessor`], *optional*):\n+            The image processor is a required input.\n+        tokenizer ([`Qwen2TokenizerFast`], *optional*):\n+            The tokenizer is a required input.\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    image_processor_class = \"Qwen2_5_VLImageProcessor\"\n+\n+    def __call__(\n+        self,\n+        images: ImageInput = None,\n+        text: Union[TextInput, PreTokenizedInput, List[TextInput], List[PreTokenizedInput]] = None,\n+        videos: VideoInput = None,\n+        **kwargs: Unpack[Qwen2_5_VLProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`\n+        and `kwargs` arguments to Qwen2TokenizerFast's [`~Qwen2TokenizerFast.__call__`] if `text` is not `None` to encode\n+        the text. To prepare the vision inputs, this method forwards the `vision_infos` and `kwrags` arguments to\n+        Qwen2_5_VLImageProcessor's [`~Qwen2_5_VLImageProcessor.__call__`] if `vision_infos` is not `None`.\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. Both channels-first and channels-last formats are supported.\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            videos (`np.ndarray`, `torch.Tensor`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n+                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+            - **pixel_values_videos** -- Pixel values of videos to be fed to a model. Returned when `videos` is not `None`.\n+            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n+            - **video_grid_thw** -- List of video 3D grid in LLM. Returned when `videos` is not `None`.\n+            - **second_per_grid_ts** -- List of video seconds per time grid. Returned when `videos` is not `None`.\n+        \"\"\"\n+        output_kwargs = self._merge_kwargs(\n+            Qwen2_5_VLProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+        if images is not None:\n+            image_inputs = self.image_processor(images=images, videos=None, **output_kwargs[\"images_kwargs\"])\n+            image_grid_thw = image_inputs[\"image_grid_thw\"]\n+        else:\n+            image_inputs = {}\n+            image_grid_thw = None\n+\n+        if videos is not None:\n+            videos_inputs = self.image_processor(images=None, videos=videos, **output_kwargs[\"images_kwargs\"])\n+            video_grid_thw = videos_inputs[\"video_grid_thw\"]\n+\n+            fps = output_kwargs[\"videos_kwargs\"].pop(\"fps\", 2.0)\n+            if isinstance(fps, (int, float)):\n+                second_per_grid_ts = [self.image_processor.temporal_patch_size / fps] * len(video_grid_thw)\n+            elif hasattr(fps, \"__len__\") and len(fps) == len(video_grid_thw):\n+                second_per_grid_ts = [self.image_processor.temporal_patch_size / tmp for tmp in fps]\n+            else:\n+                raise ValueError(\n+                    f\"The length of fps ({len(fps) if hasattr(fps, '__len__') else fps}) must be equal to the length of video_grid_thw ({len(video_grid_thw)}) or fps should be a single number.\"\n+                )\n+            videos_inputs.update({\"second_per_grid_ts\": second_per_grid_ts})\n+\n+        else:\n+            videos_inputs = {}\n+            video_grid_thw = None\n+\n+        if not isinstance(text, list):\n+            text = [text]\n+\n+        if image_grid_thw is not None:\n+            merge_length = self.image_processor.merge_size**2\n+            index = 0\n+            for i in range(len(text)):\n+                while self.image_token in text[i]:\n+                    text[i] = text[i].replace(\n+                        self.image_token,\n+                        \"<|placeholder|>\" * (image_grid_thw[index].prod() // merge_length),\n+                        1,\n+                    )\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.image_token)\n+\n+        if video_grid_thw is not None:\n+            merge_length = self.image_processor.merge_size**2\n+            index = 0\n+            for i in range(len(text)):\n+                while self.video_token in text[i]:\n+                    text[i] = text[i].replace(\n+                        self.video_token,\n+                        \"<|placeholder|>\" * (video_grid_thw[index].prod() // merge_length),\n+                        1,\n+                    )\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.video_token)\n+\n+        text_inputs = self.tokenizer(text, **output_kwargs[\"text_kwargs\"])\n+\n+        return BatchFeature(data={**text_inputs, **image_inputs, **videos_inputs})\n+\n+\n+__all__ = [\n+    \"Qwen2_5_VLConfig\",\n+    \"Qwen2_5_VLForConditionalGeneration\",\n+    \"Qwen2_5_VLModel\",\n+    \"Qwen2_5_VLPreTrainedModel\",\n+    \"Qwen2_5_VLImageProcessor\",\n+    \"Qwen2_5_VLProcessor\",\n+]"
        },
        {
            "sha": "88c383d8e7e154ad1d9c4d9aa83dab2856e2b636",
            "filename": "src/transformers/models/qwen2_5_vl/processing_qwen2_5_vl.py",
            "status": "added",
            "additions": 218,
            "deletions": 0,
            "changes": 218,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fprocessing_qwen2_5_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fprocessing_qwen2_5_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_5_vl%2Fprocessing_qwen2_5_vl.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -0,0 +1,218 @@\n+#                ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨\n+#           This file was automatically generated from src/transformers/models/qwen2_5_vl/modular_qwen2_5_vl.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_qwen2_5_vl.py file directly. One of our CI enforces this.\n+#                ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨\n+# coding=utf-8\n+# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX\n+# and OPT implementations in this library. It has been modified from its\n+# original forms to accommodate minor architectural differences compared\n+# to GPT-NeoX and OPT used by the Meta AI team that trained the model.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import List, Union\n+\n+from ...feature_extraction_utils import BatchFeature\n+from ...image_utils import ImageInput, VideoInput\n+from ...processing_utils import ProcessingKwargs, ProcessorMixin, Unpack, VideosKwargs\n+from ...tokenization_utils_base import PreTokenizedInput, TextInput\n+\n+\n+class Qwen2_5_VLVideosProcessorKwargs(VideosKwargs, total=False):\n+    fps: Union[List[float], float]\n+\n+\n+class Qwen2_5_VLProcessorKwargs(ProcessingKwargs, total=False):\n+    videos_kwargs: Qwen2_5_VLVideosProcessorKwargs\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": False,\n+        },\n+        \"videos_kwargs\": {\"fps\": 2.0},\n+    }\n+\n+\n+class Qwen2_5_VLProcessor(ProcessorMixin):\n+    r\"\"\"\n+    Constructs a Qwen2.5-VL processor which wraps a Qwen2.5-VL image processor and a Qwen2 tokenizer into a single processor.\n+    [`Qwen2_5_VLProcessor`] offers all the functionalities of [`Qwen2_5_VLImageProcessor`] and [`Qwen2TokenizerFast`]. See the\n+    [`~Qwen2_5_VLProcessor.__call__`] and [`~Qwen2_5_VLProcessor.decode`] for more information.\n+    Args:\n+        image_processor ([`Qwen2_5_VLImageProcessor`], *optional*):\n+            The image processor is a required input.\n+        tokenizer ([`Qwen2TokenizerFast`], *optional*):\n+            The tokenizer is a required input.\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    attributes = [\"image_processor\", \"tokenizer\"]\n+    valid_kwargs = [\"chat_template\"]\n+\n+    image_processor_class = \"Qwen2_5_VLImageProcessor\"\n+    tokenizer_class = (\"Qwen2Tokenizer\", \"Qwen2TokenizerFast\")\n+\n+    def __init__(self, image_processor=None, tokenizer=None, chat_template=None, **kwargs):\n+        self.image_token = \"<|image_pad|>\" if not hasattr(tokenizer, \"image_token\") else tokenizer.image_token\n+        self.video_token = \"<|video_pad|>\" if not hasattr(tokenizer, \"video_token\") else tokenizer.video_token\n+        super().__init__(image_processor, tokenizer, chat_template=chat_template)\n+\n+    def __call__(\n+        self,\n+        images: ImageInput = None,\n+        text: Union[TextInput, PreTokenizedInput, List[TextInput], List[PreTokenizedInput]] = None,\n+        videos: VideoInput = None,\n+        **kwargs: Unpack[Qwen2_5_VLProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`\n+        and `kwargs` arguments to Qwen2TokenizerFast's [`~Qwen2TokenizerFast.__call__`] if `text` is not `None` to encode\n+        the text. To prepare the vision inputs, this method forwards the `vision_infos` and `kwrags` arguments to\n+        Qwen2_5_VLImageProcessor's [`~Qwen2_5_VLImageProcessor.__call__`] if `vision_infos` is not `None`.\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. Both channels-first and channels-last formats are supported.\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            videos (`np.ndarray`, `torch.Tensor`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n+                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+            - **pixel_values_videos** -- Pixel values of videos to be fed to a model. Returned when `videos` is not `None`.\n+            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n+            - **video_grid_thw** -- List of video 3D grid in LLM. Returned when `videos` is not `None`.\n+            - **second_per_grid_ts** -- List of video seconds per time grid. Returned when `videos` is not `None`.\n+        \"\"\"\n+        output_kwargs = self._merge_kwargs(\n+            Qwen2_5_VLProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+        if images is not None:\n+            image_inputs = self.image_processor(images=images, videos=None, **output_kwargs[\"images_kwargs\"])\n+            image_grid_thw = image_inputs[\"image_grid_thw\"]\n+        else:\n+            image_inputs = {}\n+            image_grid_thw = None\n+\n+        if videos is not None:\n+            videos_inputs = self.image_processor(images=None, videos=videos, **output_kwargs[\"images_kwargs\"])\n+            video_grid_thw = videos_inputs[\"video_grid_thw\"]\n+\n+            fps = output_kwargs[\"videos_kwargs\"].pop(\"fps\", 2.0)\n+            if isinstance(fps, (int, float)):\n+                second_per_grid_ts = [self.image_processor.temporal_patch_size / fps] * len(video_grid_thw)\n+            elif hasattr(fps, \"__len__\") and len(fps) == len(video_grid_thw):\n+                second_per_grid_ts = [self.image_processor.temporal_patch_size / tmp for tmp in fps]\n+            else:\n+                raise ValueError(\n+                    f\"The length of fps ({len(fps) if hasattr(fps, '__len__') else fps}) must be equal to the length of video_grid_thw ({len(video_grid_thw)}) or fps should be a single number.\"\n+                )\n+            videos_inputs.update({\"second_per_grid_ts\": second_per_grid_ts})\n+\n+        else:\n+            videos_inputs = {}\n+            video_grid_thw = None\n+\n+        if not isinstance(text, list):\n+            text = [text]\n+\n+        if image_grid_thw is not None:\n+            merge_length = self.image_processor.merge_size**2\n+            index = 0\n+            for i in range(len(text)):\n+                while self.image_token in text[i]:\n+                    text[i] = text[i].replace(\n+                        self.image_token,\n+                        \"<|placeholder|>\" * (image_grid_thw[index].prod() // merge_length),\n+                        1,\n+                    )\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.image_token)\n+\n+        if video_grid_thw is not None:\n+            merge_length = self.image_processor.merge_size**2\n+            index = 0\n+            for i in range(len(text)):\n+                while self.video_token in text[i]:\n+                    text[i] = text[i].replace(\n+                        self.video_token,\n+                        \"<|placeholder|>\" * (video_grid_thw[index].prod() // merge_length),\n+                        1,\n+                    )\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.video_token)\n+\n+        text_inputs = self.tokenizer(text, **output_kwargs[\"text_kwargs\"])\n+\n+        return BatchFeature(data={**text_inputs, **image_inputs, **videos_inputs})\n+\n+    def batch_decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to Qwen2TokenizerFast's [`~PreTrainedTokenizer.batch_decode`]. Please\n+        refer to the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.batch_decode(*args, **kwargs)\n+\n+    def decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to Qwen2TokenizerFast's [`~PreTrainedTokenizer.decode`]. Please refer to\n+        the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.decode(*args, **kwargs)\n+\n+    def post_process_image_text_to_text(self, generated_outputs):\n+        \"\"\"\n+        Post-process the output of the model to decode the text.\n+\n+        Args:\n+            generated_outputs (`torch.Tensor` or `np.ndarray`):\n+                The output of the model `generate` function. The output is expected to be a tensor of shape `(batch_size, sequence_length)`\n+                or `(sequence_length,)`.\n+\n+        Returns:\n+            `List[str]`: The decoded text.\n+        \"\"\"\n+        return self.tokenizer.batch_decode(\n+            generated_outputs, skip_special_tokens=True, clean_up_tokenization_spaces=False\n+        )\n+\n+    @property\n+    def model_input_names(self):\n+        tokenizer_input_names = self.tokenizer.model_input_names\n+        image_processor_input_names = self.image_processor.model_input_names\n+        return list(dict.fromkeys(tokenizer_input_names + image_processor_input_names))\n+\n+\n+__all__ = [\"Qwen2_5_VLProcessor\"]"
        },
        {
            "sha": "49a0836cf96aa732bfe9a78139302fad1874e837",
            "filename": "src/transformers/models/qwen2_vl/configuration_qwen2_vl.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fconfiguration_qwen2_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fconfiguration_qwen2_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fconfiguration_qwen2_vl.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -198,9 +198,9 @@ def __init__(\n         **kwargs,\n     ):\n         if isinstance(vision_config, dict):\n-            self.vision_config = Qwen2VLVisionConfig(**vision_config)\n+            self.vision_config = self.sub_configs[\"vision_config\"](**vision_config)\n         elif vision_config is None:\n-            self.vision_config = Qwen2VLVisionConfig()\n+            self.vision_config = self.sub_configs[\"vision_config\"]()\n \n         self.vocab_size = vocab_size\n         self.max_position_embeddings = max_position_embeddings"
        },
        {
            "sha": "c680201f192365fe3ab84ec0429c4c739311871d",
            "filename": "src/transformers/models/qwen2_vl/modeling_qwen2_vl.py",
            "status": "modified",
            "additions": 9,
            "deletions": 42,
            "changes": 51,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fmodeling_qwen2_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fmodeling_qwen2_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fqwen2_vl%2Fmodeling_qwen2_vl.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -100,47 +100,20 @@ class Qwen2VLCausalLMOutputWithPast(ModelOutput):\n \n \n class Qwen2VLRotaryEmbedding(nn.Module):\n-    def __init__(\n-        self,\n-        dim=None,\n-        max_position_embeddings=2048,\n-        base=10000,\n-        device=None,\n-        scaling_factor=1.0,\n-        rope_type=\"default\",\n-        config: Optional[Qwen2VLConfig] = None,\n-    ):\n+    def __init__(self, config: Qwen2VLConfig, device=None):\n         super().__init__()\n-        # TODO (joao): remove the `if` below, only used for BC\n-        self.rope_kwargs = {}\n-        if config is None:\n-            logger.warning_once(\n-                \"`Qwen2VLRotaryEmbedding` can now be fully parameterized by passing the model config through the \"\n-                \"`config` argument. All other arguments will be removed in v4.46\"\n-            )\n-            self.rope_kwargs = {\n-                \"rope_type\": rope_type,\n-                \"factor\": scaling_factor,\n-                \"dim\": dim,\n-                \"base\": base,\n-                \"max_position_embeddings\": max_position_embeddings,\n-            }\n-            self.rope_type = rope_type\n-            self.max_seq_len_cached = max_position_embeddings\n-            self.original_max_seq_len = max_position_embeddings\n+        # BC: \"rope_type\" was originally \"type\"\n+        if hasattr(config, \"rope_scaling\") and config.rope_scaling is not None:\n+            self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n         else:\n-            # BC: \"rope_type\" was originally \"type\"\n-            if config.rope_scaling is not None:\n-                self.rope_type = config.rope_scaling.get(\"rope_type\", config.rope_scaling.get(\"type\"))\n-            else:\n-                self.rope_type = \"default\"\n-            self.max_seq_len_cached = config.max_position_embeddings\n-            self.original_max_seq_len = config.max_position_embeddings\n+            self.rope_type = \"default\"\n+        self.max_seq_len_cached = config.max_position_embeddings\n+        self.original_max_seq_len = config.max_position_embeddings\n \n         self.config = config\n         self.rope_init_fn = ROPE_INIT_FUNCTIONS[self.rope_type]\n \n-        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device, **self.rope_kwargs)\n+        inv_freq, self.attention_scaling = self.rope_init_fn(self.config, device)\n         self.register_buffer(\"inv_freq\", inv_freq, persistent=False)\n         self.original_inv_freq = self.inv_freq\n \n@@ -503,8 +476,6 @@ def __init__(self, config: Qwen2VLConfig, layer_idx: Optional[int] = None):\n         self.head_dim = self.hidden_size // self.num_heads\n         self.num_key_value_heads = config.num_key_value_heads\n         self.num_key_value_groups = self.num_heads // self.num_key_value_heads\n-        self.max_position_embeddings = config.max_position_embeddings\n-        self.rope_theta = config.rope_theta\n         self.is_causal = True\n         self.attention_dropout = config.attention_dropout\n         self.rope_scaling = config.rope_scaling\n@@ -519,11 +490,7 @@ def __init__(self, config: Qwen2VLConfig, layer_idx: Optional[int] = None):\n         self.v_proj = nn.Linear(self.hidden_size, self.num_key_value_heads * self.head_dim, bias=True)\n         self.o_proj = nn.Linear(self.num_heads * self.head_dim, self.hidden_size, bias=False)\n \n-        self.rotary_emb = Qwen2VLRotaryEmbedding(\n-            self.head_dim,\n-            max_position_embeddings=self.max_position_embeddings,\n-            base=self.rope_theta,\n-        )\n+        self.rotary_emb = Qwen2VLRotaryEmbedding(config=config)\n \n     def forward(\n         self,"
        },
        {
            "sha": "f49d65941c7b2298d75b810c189344b7296181da",
            "filename": "src/transformers/utils/dummy_pt_objects.py",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -7878,6 +7878,27 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torch\"])\n \n \n+class Qwen2_5_VLForConditionalGeneration(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class Qwen2_5_VLModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class Qwen2_5_VLPreTrainedModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n class Qwen2AudioEncoder(metaclass=DummyObject):\n     _backends = [\"torch\"]\n "
        },
        {
            "sha": "96eca67f399ad210c6b6b328cbe915ce5eea35d1",
            "filename": "src/transformers/utils/dummy_vision_objects.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_vision_objects.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -569,6 +569,13 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"vision\"])\n \n \n+class Qwen2_5_VLImageProcessor(metaclass=DummyObject):\n+    _backends = [\"vision\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"vision\"])\n+\n+\n class Qwen2VLImageProcessor(metaclass=DummyObject):\n     _backends = [\"vision\"]\n "
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/qwen2_5_vl/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/tests%2Fmodels%2Fqwen2_5_vl%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/tests%2Fmodels%2Fqwen2_5_vl%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen2_5_vl%2F__init__.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775"
        },
        {
            "sha": "4c991ec710ef7c1274c15875e63f93e4c36c4e6a",
            "filename": "tests/models/qwen2_5_vl/test_image_processing_qwen2_5_vl.py",
            "status": "added",
            "additions": 252,
            "deletions": 0,
            "changes": 252,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/tests%2Fmodels%2Fqwen2_5_vl%2Ftest_image_processing_qwen2_5_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/tests%2Fmodels%2Fqwen2_5_vl%2Ftest_image_processing_qwen2_5_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen2_5_vl%2Ftest_image_processing_qwen2_5_vl.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -0,0 +1,252 @@\n+# coding=utf-8\n+# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+import numpy as np\n+\n+from transformers.image_utils import OPENAI_CLIP_MEAN, OPENAI_CLIP_STD\n+from transformers.models.qwen2_5_vl.image_processing_qwen2_5_vl import smart_resize\n+from transformers.testing_utils import require_torch, require_vision\n+from transformers.utils import is_torch_available, is_vision_available\n+\n+from ...test_image_processing_common import (\n+    ImageProcessingTestMixin,\n+    prepare_image_inputs,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+    from transformers import Qwen2_5_VLImageProcessor\n+\n+\n+class Qwen2_5_VLImageProcessingTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=7,\n+        num_channels=3,\n+        min_resolution=56,\n+        max_resolution=1024,\n+        min_pixels=56 * 56,\n+        max_pixels=28 * 28 * 1280,\n+        do_normalize=True,\n+        image_mean=OPENAI_CLIP_MEAN,\n+        image_std=OPENAI_CLIP_STD,\n+        do_resize=True,\n+        patch_size=14,\n+        temporal_patch_size=2,\n+        merge_size=2,\n+        do_convert_rgb=True,\n+    ):\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.min_resolution = min_resolution\n+        self.max_resolution = max_resolution\n+        self.num_channels = num_channels\n+        self.image_mean = OPENAI_CLIP_MEAN\n+        self.image_std = OPENAI_CLIP_STD\n+        self.min_pixels = min_pixels\n+        self.max_pixels = max_pixels\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.merge_size = merge_size\n+        self.do_resize = do_resize\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean\n+        self.image_std = image_std\n+        self.do_convert_rgb = do_convert_rgb\n+\n+    def prepare_image_processor_dict(self):\n+        return {\n+            \"do_resize\": self.do_resize,\n+            \"image_mean\": self.image_mean,\n+            \"image_std\": self.image_std,\n+            \"min_pixels\": self.min_pixels,\n+            \"max_pixels\": self.max_pixels,\n+            \"patch_size\": self.patch_size,\n+            \"temporal_patch_size\": self.temporal_patch_size,\n+            \"merge_size\": self.merge_size,\n+        }\n+\n+    def prepare_image_inputs(self, equal_resolution=False, numpify=False, torchify=False):\n+        images = prepare_image_inputs(\n+            batch_size=self.batch_size,\n+            num_channels=self.num_channels,\n+            min_resolution=self.min_resolution,\n+            max_resolution=self.max_resolution,\n+            equal_resolution=equal_resolution,\n+            numpify=numpify,\n+            torchify=torchify,\n+        )\n+        return [[image] for image in images]\n+\n+\n+@require_torch\n+@require_vision\n+class Qwen2_5_VLImageProcessingTest(ImageProcessingTestMixin, unittest.TestCase):\n+    image_processing_class = Qwen2_5_VLImageProcessor if is_vision_available() else None\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.image_processor_tester = Qwen2_5_VLImageProcessingTester(self)\n+\n+    @property\n+    def image_processor_dict(self):\n+        return self.image_processor_tester.prepare_image_processor_dict()\n+\n+    def test_image_processor_properties(self):\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        self.assertTrue(hasattr(image_processing, \"do_normalize\"))\n+        self.assertTrue(hasattr(image_processing, \"image_mean\"))\n+        self.assertTrue(hasattr(image_processing, \"image_std\"))\n+        self.assertTrue(hasattr(image_processing, \"do_resize\"))\n+        self.assertTrue(hasattr(image_processing, \"min_pixels\"))\n+        self.assertTrue(hasattr(image_processing, \"max_pixels\"))\n+        self.assertTrue(hasattr(image_processing, \"do_convert_rgb\"))\n+        self.assertTrue(hasattr(image_processing, \"patch_size\"))\n+        self.assertTrue(hasattr(image_processing, \"temporal_patch_size\"))\n+        self.assertTrue(hasattr(image_processing, \"merge_size\"))\n+\n+    def test_image_processor_from_dict_with_kwargs(self):\n+        image_processor = self.image_processing_class.from_dict(self.image_processor_dict)\n+        self.assertEqual(image_processor.min_pixels, 56 * 56)\n+        self.assertEqual(image_processor.max_pixels, 28 * 28 * 1280)\n+\n+        image_processor = self.image_processing_class.from_dict(\n+            self.image_processor_dict, min_pixels=256 * 256, max_pixels=640 * 640\n+        )\n+        self.assertEqual(image_processor.min_pixels, 256 * 256)\n+        self.assertEqual(image_processor.max_pixels, 640 * 640)\n+\n+    def test_select_best_resolution(self):\n+        # Test with a final resize resolution\n+        best_resolution = smart_resize(561, 278, factor=28)\n+        self.assertEqual(best_resolution, (560, 280))\n+\n+    def test_call_pil(self):\n+        # Initialize image_processing\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        # create random PIL images\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True)\n+        for image in image_inputs:\n+            self.assertIsInstance(image[0], Image.Image)\n+\n+        # Test not batched input\n+        prcocess_out = image_processing(image_inputs[0], return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (4900, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]])\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+        # Test batched\n+        prcocess_out = image_processing(image_inputs, return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (34300, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]] * 7)\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+    def test_call_numpy(self):\n+        # Initialize image_processing\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        # create random numpy tensors\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True, numpify=True)\n+        for image in image_inputs:\n+            self.assertIsInstance(image[0], np.ndarray)\n+\n+        # Test not batched input\n+        prcocess_out = image_processing(image_inputs[0], return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (4900, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]])\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+        # Test batched\n+        prcocess_out = image_processing(image_inputs, return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (34300, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]] * 7)\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+    def test_call_pytorch(self):\n+        # Initialize image_processing\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        # create random PyTorch tensors\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True, torchify=True)\n+\n+        for image in image_inputs:\n+            self.assertIsInstance(image[0], torch.Tensor)\n+\n+        # Test not batched input\n+        prcocess_out = image_processing(image_inputs[0], return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (4900, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]])\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+        # Test batched\n+        prcocess_out = image_processing(image_inputs, return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (34300, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]] * 7)\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+    @unittest.skip(reason=\"Qwen2_5_VLImageProcessor doesn't treat 4 channel PIL and numpy consistently yet\")\n+    def test_call_numpy_4_channels(self):\n+        pass\n+\n+    def test_nested_input(self):\n+        image_processing = self.image_processing_class(**self.image_processor_dict)\n+        image_inputs = self.image_processor_tester.prepare_image_inputs(equal_resolution=True)\n+\n+        # Test batched as a list of images\n+        prcocess_out = image_processing(image_inputs, return_tensors=\"pt\")\n+        encoded_images = prcocess_out.pixel_values\n+        image_grid_thws = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (34300, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]] * 7)\n+        self.assertEqual(tuple(encoded_images.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+        # Test batched as a nested list of images, where each sublist is one batch\n+        image_inputs_nested = image_inputs[:3] + image_inputs[3:]\n+        prcocess_out = image_processing(image_inputs_nested, return_tensors=\"pt\")\n+        encoded_images_nested = prcocess_out.pixel_values\n+        image_grid_thws_nested = prcocess_out.image_grid_thw\n+        expected_output_image_shape = (34300, 1176)\n+        expected_image_grid_thws = torch.Tensor([[1, 70, 70]] * 7)\n+        self.assertEqual(tuple(encoded_images_nested.shape), expected_output_image_shape)\n+        self.assertTrue((image_grid_thws == expected_image_grid_thws).all())\n+\n+        # Image processor should return same pixel values, independently of ipnut format\n+        self.assertTrue((encoded_images_nested == encoded_images).all())\n+        self.assertTrue((image_grid_thws_nested == expected_image_grid_thws).all())"
        },
        {
            "sha": "d76a7ba1e20cb5bf76be8e5502e43cc3e9f88197",
            "filename": "tests/models/qwen2_5_vl/test_modeling_qwen2_5_vl.py",
            "status": "added",
            "additions": 546,
            "deletions": 0,
            "changes": 546,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/tests%2Fmodels%2Fqwen2_5_vl%2Ftest_modeling_qwen2_5_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/tests%2Fmodels%2Fqwen2_5_vl%2Ftest_modeling_qwen2_5_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen2_5_vl%2Ftest_modeling_qwen2_5_vl.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -0,0 +1,546 @@\n+# coding=utf-8\n+# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch Qwen2.5-VL model.\"\"\"\n+\n+import gc\n+import unittest\n+\n+import requests\n+\n+from transformers import (\n+    AutoProcessor,\n+    Qwen2_5_VLConfig,\n+    Qwen2_5_VLForConditionalGeneration,\n+    is_torch_available,\n+    is_vision_available,\n+)\n+from transformers.testing_utils import (\n+    require_flash_attn,\n+    require_torch,\n+    require_torch_gpu,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import (\n+    ModelTesterMixin,\n+    _config_zero_init,\n+    floats_tensor,\n+    ids_tensor,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+else:\n+    is_torch_greater_or_equal_than_2_0 = False\n+\n+if is_vision_available():\n+    from PIL import Image\n+\n+\n+class Qwen2_5_VLVisionText2TextModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=3,\n+        seq_length=7,\n+        num_channels=3,\n+        ignore_index=-100,\n+        image_size=14,\n+        bos_token_id=0,\n+        eos_token_id=1,\n+        pad_token_id=2,\n+        vision_start_token_id=3,\n+        image_token_id=4,\n+        video_token_id=5,\n+        hidden_act=\"silu\",\n+        hidden_size=32,\n+        vocab_size=99,\n+        intermediate_size=37,\n+        max_position_embeddings=512,\n+        max_window_layers=3,\n+        model_type=\"qwen2_5_vl\",\n+        num_attention_heads=4,\n+        num_hidden_layers=4,\n+        num_key_value_heads=2,\n+        rope_theta=10000,\n+        tie_word_embeddings=True,\n+        is_training=True,\n+        vision_config={\n+            \"depth\": 2,\n+            \"in_chans\": 3,\n+            \"hidden_act\": \"silu\",\n+            \"intermediate_size\": 32,\n+            \"out_hidden_size\": 32,\n+            \"hidden_size\": 32,\n+            \"num_heads\": 4,\n+            \"patch_size\": 14,\n+            \"spatial_patch_size\": 14,\n+            \"spatial_merge_size\": 1,\n+            \"temporal_patch_size\": 2,\n+        },\n+        rope_scaling={\"type\": \"mrope\", \"mrope_section\": [2, 1, 1]},\n+    ):\n+        self.parent = parent\n+        self.ignore_index = ignore_index\n+        self.bos_token_id = bos_token_id\n+        self.eos_token_id = eos_token_id\n+        self.pad_token_id = pad_token_id\n+        self.vision_start_token_id = vision_start_token_id\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.hidden_act = hidden_act\n+        self.hidden_size = hidden_size\n+        self.intermediate_size = intermediate_size\n+        self.max_position_embeddings = max_position_embeddings\n+        self.max_window_layers = max_window_layers\n+        self.model_type = model_type\n+        self.num_attention_heads = num_attention_heads\n+        self.num_hidden_layers = num_hidden_layers\n+        self.num_key_value_heads = num_key_value_heads\n+        self.rope_theta = rope_theta\n+        self.tie_word_embeddings = tie_word_embeddings\n+        self.vision_config = vision_config\n+        self.rope_scaling = rope_scaling\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.image_size = image_size\n+        self.is_training = is_training\n+        self.vocab_size = vocab_size\n+        self.num_image_tokens = 32\n+        self.seq_length = seq_length + self.num_image_tokens\n+\n+    def get_config(self):\n+        return Qwen2_5_VLConfig(\n+            hidden_size=self.hidden_size,\n+            intermediate_size=self.intermediate_size,\n+            num_hidden_layers=self.num_hidden_layers,\n+            num_attention_heads=self.num_attention_heads,\n+            num_key_value_heads=self.num_key_value_heads,\n+            hidden_act=self.hidden_act,\n+            max_position_embeddings=self.max_position_embeddings,\n+            vision_config=self.vision_config,\n+            model_type=self.model_type,\n+            max_window_layers=self.max_window_layers,\n+            rope_scaling=self.rope_scaling,\n+            tie_word_embeddings=self.tie_word_embeddings,\n+            bos_token_id=self.bos_token_id,\n+            eos_token_id=self.eos_token_id,\n+            pad_token_id=self.pad_token_id,\n+            vision_start_token_id=self.vision_start_token_id,\n+            image_token_id=self.image_token_id,\n+            video_token_id=self.video_token_id,\n+            vocab_size=self.vocab_size,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        config = self.get_config()\n+        patch_size = config.vision_config.patch_size\n+        temporal_patch_size = config.vision_config.temporal_patch_size\n+        pixel_values = floats_tensor(\n+            [\n+                self.batch_size * (self.image_size**2) // (patch_size**2),\n+                self.num_channels * (patch_size**2) * temporal_patch_size,\n+            ]\n+        )\n+\n+        return config, pixel_values\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], self.vocab_size)\n+        attention_mask = torch.ones(input_ids.shape, dtype=torch.long, device=torch_device)\n+\n+        input_ids[:, -1] = self.pad_token_id\n+        input_ids[input_ids == self.video_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_token_id] = self.pad_token_id\n+        input_ids[:, self.num_image_tokens] = self.image_token_id\n+        labels = torch.zeros(\n+            (self.batch_size, self.seq_length),\n+            dtype=torch.long,\n+            device=torch_device,\n+        )\n+        inputs_dict = {\n+            \"pixel_values\": pixel_values,\n+            \"image_grid_thw\": torch.tensor([[1, 1, 1]] * self.batch_size),\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+            \"labels\": labels,\n+        }\n+        return config, inputs_dict\n+\n+    def create_and_check_qwen2_5_vl_model_fp16_forward(\n+        self, config, input_ids, pixel_values, attention_mask, image_grid_thw\n+    ):\n+        model = Qwen2_5_VLForConditionalGeneration(config=config)\n+        model.to(torch_device)\n+        model.half()\n+        model.eval()\n+        logits = model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            image_grid_thw=image_grid_thw,\n+            pixel_values=pixel_values.to(torch.bfloat16),\n+            return_dict=True,\n+        )[\"logits\"]\n+        self.parent.assertFalse(torch.isnan(logits).any().item())\n+\n+    def create_and_check_qwen2_5_vl_model_fp16_autocast_forward(\n+        self, config, input_ids, pixel_values, attention_mask, image_grid_thw\n+    ):\n+        config.torch_dtype = torch.float16\n+        model = Qwen2_5_VLForConditionalGeneration(config=config)\n+        model.to(torch_device)\n+        model.eval()\n+        with torch.autocast(device_type=\"cuda\", dtype=torch.float16):\n+            logits = model(\n+                input_ids=input_ids,\n+                attention_mask=attention_mask,\n+                image_grid_thw=image_grid_thw,\n+                pixel_values=pixel_values.to(torch.bfloat16),\n+                return_dict=True,\n+            )[\"logits\"]\n+        self.parent.assertFalse(torch.isnan(logits).any().item())\n+\n+\n+@require_torch\n+class Qwen2_5_VLModelTest(ModelTesterMixin, GenerationTesterMixin, unittest.TestCase):\n+    \"\"\"\n+    Model tester for `Qwen2_5_VLForConditionalGeneration`.\n+    \"\"\"\n+\n+    all_model_classes = (Qwen2_5_VLForConditionalGeneration,) if is_torch_available() else ()\n+    all_generative_model_classes = (Qwen2_5_VLForConditionalGeneration,) if is_torch_available() else ()\n+    test_pruning = False\n+    test_head_masking = False\n+\n+    def setUp(self):\n+        self.model_tester = Qwen2_5_VLVisionText2TextModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Qwen2_5_VLConfig, has_text_modality=False)\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    def test_initialization(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        configs_no_init = _config_zero_init(config)\n+        for model_class in self.all_model_classes:\n+            model = model_class(config=configs_no_init)\n+            for name, param in model.named_parameters():\n+                if param.requires_grad:\n+                    self.assertIn(\n+                        ((param.data.mean() * 1e9).round() / 1e9).item(),\n+                        [0.0, 1.0],\n+                        msg=f\"Parameter {name} of model {model_class} seems not properly initialized\",\n+                    )\n+\n+    def test_mismatching_num_image_tokens(self):\n+        \"\"\"\n+        Tests that VLMs through an error with explicit message saying what is wrong\n+        when number of images don't match number of image tokens in the text.\n+        Also we need to test multi-image cases when one prompr has multiple image tokens.\n+        \"\"\"\n+        config, input_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+        for model_class in self.all_model_classes:\n+            model = model_class(config).to(torch_device)\n+            _ = model(**input_dict)  # successfull forward with no modifications\n+\n+            # remove one image but leave the image token in text\n+            patch_size = config.vision_config.patch_size\n+            one_img_length = (self.model_tester.image_size**2) // (patch_size**2)\n+            input_dict[\"pixel_values\"] = input_dict[\"pixel_values\"][-one_img_length:, ...]\n+            input_dict[\"image_grid_thw\"] = input_dict[\"image_grid_thw\"][-1:, ...]\n+            with self.assertRaises(ValueError):\n+                _ = model(**input_dict)\n+\n+            # simulate multi-image case by concatenating inputs where each has exactly one image/image-token\n+            input_ids = input_dict[\"input_ids\"][:1]\n+            pixel_values = input_dict[\"pixel_values\"][:one_img_length]\n+            image_grid_thw = input_dict[\"image_grid_thw\"][:1]\n+            input_ids = torch.cat([input_ids, input_ids], dim=0)\n+\n+            # one image and two image tokens raise an error\n+            with self.assertRaises(ValueError):\n+                _ = model(\n+                    input_ids=input_ids,\n+                    pixel_values=pixel_values,\n+                    image_grid_thw=image_grid_thw,\n+                )\n+\n+            # two images and two image tokens don't raise an error\n+            pixel_values = torch.cat([pixel_values, pixel_values], dim=0)\n+            image_grid_thw = torch.cat([image_grid_thw, image_grid_thw], dim=0)\n+            _ = model(\n+                input_ids=input_ids,\n+                pixel_values=pixel_values,\n+                image_grid_thw=image_grid_thw,\n+            )\n+\n+    @unittest.skip(reason=\"Feedforward chunking is not yet supported\")\n+    def test_feed_forward_chunking(self):\n+        pass\n+\n+    @unittest.skip(reason=\"CPU offload is not yet supported\")\n+    def test_cpu_offload(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Some undefined behavior encountered with test versions of this model. Skip for now.\")\n+    def test_disk_offload_bin(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Some undefined behavior encountered with test versions of this model. Skip for now.\")\n+    def test_disk_offload_safetensors(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Some undefined behavior encountered with test versions of this model. Skip for now.\")\n+    def test_model_parallelism(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Compile not yet supported because in Qwen2_5_VL models\")\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Compile not yet supported because in Qwen2_5_VL models\")\n+    def test_sdpa_can_dispatch_on_flash(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Got `CUDA error: misaligned address` with PyTorch 2.0.0.\")\n+    def test_multi_gpu_data_parallel_forward(self):\n+        pass\n+\n+    @unittest.skip(reason=\"We cannot configure to output a smaller model.\")\n+    def test_model_is_small(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"Qwen2.5-VL can't do low-memory generation because position IDs have extra dimension and split function doesn't work for that\"\n+    )\n+    def test_beam_search_low_memory(self):\n+        pass\n+\n+    @unittest.skip(\n+        reason=\"VLMs can't generate from inputs embeds and pixels. This can be tested as part of bacbone LM, no need to run the tes for VLMs\"\n+    )\n+    def test_generate_from_inputs_embeds_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Can't compile fullgraph due to dynamic control flow in `prepare_inputs_for_generate`\")\n+    def test_generate_compile_fullgraph(self):\n+        pass\n+\n+\n+@require_torch\n+class Qwen2_5_VLIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.processor = AutoProcessor.from_pretrained(\"Qwen/Qwen2.5-VL-7B-Instruct\")\n+        self.messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\"},\n+                    {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+                ],\n+            }\n+        ]\n+        url = \"https://qianwen-res.oss-accelerate-overseas.aliyuncs.com/Qwen2-VL/demo_small.jpg\"\n+        self.image = Image.open(requests.get(url, stream=True).raw)\n+\n+    def tearDown(self):\n+        gc.collect()\n+        torch.cuda.empty_cache()\n+\n+    @slow\n+    def test_small_model_integration_test(self):\n+        model = Qwen2_5_VLForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-VL-7B-Instruct\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text], images=[self.image], return_tensors=\"pt\")\n+\n+        expected_input_ids = [151644, 8948, 198, 2610, 525, 264, 10950, 17847, 13, 151645, 198, 151644, 872, 198, 151652, 151655, 151655]  # fmt: skip\n+        assert torch.allclose(expected_input_ids, inputs.input_ids[0].tolist()[:17], atol=3e-3)\n+\n+        expected_pixel_slice = torch.tensor(\n+            [\n+                [0.8792, 0.8792, 0.9084],\n+                [1.1858, 1.1858, 1.2296],\n+                [1.2004, 1.2004, 1.2150],\n+                [1.4340, 1.4340, 1.4194],\n+                [1.3902, 1.4048, 1.4194],\n+                [1.5216, 1.5362, 1.5362],\n+            ],\n+            dtype=torch.float32,\n+            device=\"cpu\",\n+        )\n+        assert torch.allclose(expected_pixel_slice, inputs.pixel_values[:6, :3], atol=3e-3)\n+\n+        # verify generation\n+        inputs = inputs.to(torch_device)\n+\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        EXPECTED_DECODED_TEXT = \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular pets\"\n+\n+        self.assertEqual(\n+            self.processor.decode(output[0], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_batch(self):\n+        model = Qwen2_5_VLForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-VL-7B-Instruct\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text, text], images=[self.image, self.image], return_tensors=\"pt\").to(\n+            torch_device\n+        )\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            'system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular choices',\n+            'system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular pets'\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_batch_wo_image(self):\n+        model = Qwen2_5_VLForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-VL-7B-Instruct\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        messages2 = [\n+            {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n+            {\"role\": \"user\", \"content\": \"Who are you?\"},\n+        ]\n+        text2 = self.processor.apply_chat_template(messages2, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text, text2], images=[self.image], padding=True, return_tensors=\"pt\").to(\n+            torch_device\n+        )\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            'system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular pets',\n+            'system\\nYou are a helpful assistant.\\nuser\\nWho are you?\\nassistant\\nI am Qwen, a large language model created by Alibaba Cloud. I am designed to assist with various tasks and answer questions to the best of my'\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_batch_different_resolutions(self):\n+        model = Qwen2_5_VLForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-VL-7B-Instruct\", torch_dtype=\"auto\", device_map=\"auto\"\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        text2 = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        image2 = self.image.resize((224, 224))\n+        inputs = self.processor(\n+            text=[text, text2],\n+            images=[self.image, image2],\n+            padding=True,\n+            return_tensors=\"pt\",\n+        ).to(torch_device)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular pets\",\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular pets\",\n+        ]\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    @require_flash_attn\n+    @require_torch_gpu\n+    def test_small_model_integration_test_batch_flashatt2(self):\n+        model = Qwen2_5_VLForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-VL-7B-Instruct\",\n+            torch_dtype=torch.bfloat16,\n+            attn_implementation=\"flash_attention_2\",\n+            device_map=\"auto\",\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text, text], images=[self.image, self.image], return_tensors=\"pt\").to(\n+            torch_device\n+        )\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular pets\",\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular pets\",\n+        ]\n+\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True)[0],\n+            self.processor.batch_decode(output, skip_special_tokens=True)[1],\n+        )\n+\n+    @slow\n+    @require_flash_attn\n+    @require_torch_gpu\n+    def test_small_model_integration_test_batch_wo_image_flashatt2(self):\n+        model = Qwen2_5_VLForConditionalGeneration.from_pretrained(\n+            \"Qwen/Qwen2.5-VL-7B-Instruct\",\n+            torch_dtype=torch.bfloat16,\n+            attn_implementation=\"flash_attention_2\",\n+            device_map=\"auto\",\n+        )\n+        text = self.processor.apply_chat_template(self.messages, tokenize=False, add_generation_prompt=True)\n+        messages2 = [\n+            {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n+            {\"role\": \"user\", \"content\": \"Who are you?\"},\n+        ]\n+        text2 = self.processor.apply_chat_template(messages2, tokenize=False, add_generation_prompt=True)\n+        inputs = self.processor(text=[text, text2], images=[self.image], padding=True, return_tensors=\"pt\").to(\n+            torch_device\n+        )\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWhat kind of dog is this?\\nassistant\\nThe dog in the picture appears to be a Labrador Retriever. Labradors are known for their friendly and intelligent nature, making them popular pets\",\n+            \"system\\nYou are a helpful assistant.\\nuser\\nWho are you?\\nassistant\\nI am Qwen, a large language model created by Alibaba Cloud. I am designed to answer a wide range of questions and provide information on various topics\",\n+        ]\n+\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )"
        },
        {
            "sha": "2bc47d76acd4afdebbe1a83128c6b4d893149c12",
            "filename": "tests/models/qwen2_5_vl/test_processor_qwen2_5_vl.py",
            "status": "added",
            "additions": 113,
            "deletions": 0,
            "changes": 113,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/tests%2Fmodels%2Fqwen2_5_vl%2Ftest_processor_qwen2_5_vl.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/tests%2Fmodels%2Fqwen2_5_vl%2Ftest_processor_qwen2_5_vl.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fqwen2_5_vl%2Ftest_processor_qwen2_5_vl.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -0,0 +1,113 @@\n+# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import shutil\n+import tempfile\n+import unittest\n+\n+import pytest\n+\n+from transformers import AutoProcessor, Qwen2Tokenizer\n+from transformers.testing_utils import require_torch, require_vision\n+from transformers.utils import is_vision_available\n+\n+from ...test_processing_common import ProcessorTesterMixin\n+\n+\n+if is_vision_available():\n+    from transformers import Qwen2_5_VLImageProcessor, Qwen2_5_VLProcessor\n+\n+\n+@require_vision\n+@require_torch\n+class Qwen2_5_VLProcessorTest(ProcessorTesterMixin, unittest.TestCase):\n+    processor_class = Qwen2_5_VLProcessor\n+\n+    def setUp(self):\n+        self.tmpdirname = tempfile.mkdtemp()\n+        processor = Qwen2_5_VLProcessor.from_pretrained(\"Qwen/Qwen2-VL-7B-Instruct\", patch_size=4)\n+        processor.save_pretrained(self.tmpdirname)\n+\n+    def get_tokenizer(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).tokenizer\n+\n+    def get_image_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).image_processor\n+\n+    def tearDown(self):\n+        shutil.rmtree(self.tmpdirname)\n+\n+    def test_save_load_pretrained_default(self):\n+        tokenizer = self.get_tokenizer()\n+        image_processor = self.get_image_processor()\n+\n+        processor = Qwen2_5_VLProcessor(tokenizer=tokenizer, image_processor=image_processor)\n+        processor.save_pretrained(self.tmpdirname)\n+        processor = Qwen2_5_VLProcessor.from_pretrained(self.tmpdirname, use_fast=False)\n+\n+        self.assertEqual(processor.tokenizer.get_vocab(), tokenizer.get_vocab())\n+        self.assertEqual(processor.image_processor.to_json_string(), image_processor.to_json_string())\n+        self.assertIsInstance(processor.tokenizer, Qwen2Tokenizer)\n+        self.assertIsInstance(processor.image_processor, Qwen2_5_VLImageProcessor)\n+\n+    def test_image_processor(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+\n+        processor = Qwen2_5_VLProcessor(tokenizer=tokenizer, image_processor=image_processor)\n+\n+        image_input = self.prepare_image_inputs()\n+\n+        input_image_proc = image_processor(image_input, return_tensors=\"np\")\n+        input_processor = processor(images=image_input, text=\"dummy\", return_tensors=\"np\")\n+\n+        for key in input_image_proc.keys():\n+            self.assertAlmostEqual(input_image_proc[key].sum(), input_processor[key].sum(), delta=1e-2)\n+\n+    def test_processor(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+\n+        processor = Qwen2_5_VLProcessor(tokenizer=tokenizer, image_processor=image_processor)\n+\n+        input_str = \"lower newer\"\n+        image_input = self.prepare_image_inputs()\n+        inputs = processor(text=input_str, images=image_input)\n+\n+        self.assertListEqual(\n+            list(inputs.keys()),\n+            [\"input_ids\", \"attention_mask\", \"pixel_values\", \"image_grid_thw\"],\n+        )\n+\n+        # test if it raises when no input is passed\n+        with pytest.raises(ValueError):\n+            processor()\n+\n+        # test if it raises when no text is passed\n+        with pytest.raises(TypeError):\n+            processor(images=image_input)\n+\n+    def test_model_input_names(self):\n+        image_processor = self.get_image_processor()\n+        tokenizer = self.get_tokenizer()\n+\n+        processor = Qwen2_5_VLProcessor(tokenizer=tokenizer, image_processor=image_processor)\n+\n+        input_str = \"lower newer\"\n+        image_input = self.prepare_image_inputs()\n+        video_inputs = self.prepare_video_inputs()\n+\n+        inputs = processor(text=input_str, images=image_input, videos=video_inputs)\n+\n+        self.assertListEqual(list(inputs.keys()), processor.model_input_names)"
        },
        {
            "sha": "c91edc52cb4911f279caeb44a4c337138ce74a5d",
            "filename": "utils/check_repo.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/f3f6c86582611976e72be054675e2bf0abb5f775/utils%2Fcheck_repo.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/f3f6c86582611976e72be054675e2bf0abb5f775/utils%2Fcheck_repo.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_repo.py?ref=f3f6c86582611976e72be054675e2bf0abb5f775",
            "patch": "@@ -70,6 +70,7 @@\n     \"Pop2PianoStack\",\n     \"Qwen2AudioEncoder\",\n     \"Qwen2VisionTransformerPretrainedModel\",\n+    \"Qwen2_5_VisionTransformerPretrainedModel\",\n     \"SwitchTransformersStack\",\n     \"TFDPRSpanPredictor\",\n     \"MaskFormerSwinModel\",\n@@ -137,6 +138,7 @@\n         \"SeamlessM4TTextToUnitForConditionalGeneration\",  # Building part of bigger (tested) model.\n         \"ChameleonVQVAE\",  # VQVAE here is used only for encoding (discretizing) and is tested as part of bigger model\n         \"Qwen2VLModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2VLForConditionalGeneration.\n+        \"Qwen2_5_VLModel\",  # Building part of bigger (tested) model. Tested implicitly through Qwen2_5_VLForConditionalGeneration.\n         \"MllamaTextModel\",  # Building part of bigger (tested) model. # TODO: add tests\n         \"MllamaVisionModel\",  # Building part of bigger (tested) model. # TODO: add tests\n         \"Emu3VQVAE\",  # Building part of bigger (tested) model"
        }
    ],
    "stats": {
        "total": 5228,
        "additions": 5184,
        "deletions": 44
    }
}