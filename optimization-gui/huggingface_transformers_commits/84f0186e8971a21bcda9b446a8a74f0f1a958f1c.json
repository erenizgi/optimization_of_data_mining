{
    "author": "ArthurZucker",
    "message": "Add aya (#36521)\n\n* initial commit\n\n* small fix\n\n* move stuff to image processing file\n\n* remove stuff in validate turn and fix return tensor\n\n* remove liquid stuff\n\n* in the process of addressing comments\n\n* changes to get the right tokenization\n\n* new __init__ works\n\n* fixing defulat std and mean\n\n* works\n\n* small testing scipt -- to be deleted before merge\n\n* remove redundant code\n\n* addressing comments\n\n* fix inits, add docs templates\n\n* refactor processor, switch to gotocr image processor\n\n* remove image proc from init\n\n* refactor to working llava-style architecture\n\n* Change AyaVisionModel to AyaVisionForConditionalGeneration\n\n* add tests\n\n* fixups\n\n* update doc\n\n* Adding logits_to_keep explicitly in ayavision forward to enable compatibility with cohere model\n\n* better variable names + remove code paths\n\n* Updates to aya_vision.md\n\n* address comments\n\n* adding copied from\n\n* make style and remove unused projector_hidden_act from config\n\n* sort init\n\n* include usage of fast image proc and proc on cuda in doc\n\n* update checkpoint iin test processor\n\n* update checkpoint in test processor 2\n\n* remove test_model and update docstring\n\n* skip failing tests\n\n---------\n\nCo-authored-by: Saurabh Dash <saurabh@cohere.com>\nCo-authored-by: yonigozlan <yoni.gozlan@huggingface.co>",
    "sha": "84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
    "files": [
        {
            "sha": "624f4d7352ecbf0ff794e765d3af4c5fb1574175",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -874,6 +874,8 @@\n         title: AltCLIP\n       - local: model_doc/aria\n         title: Aria\n+      - local: model_doc/aya_vision\n+        title: AyaVision\n       - local: model_doc/blip\n         title: BLIP\n       - local: model_doc/blip-2"
        },
        {
            "sha": "17daf4949206578f9805ef7b1e1fa2494cc6a48f",
            "filename": "docs/source/en/model_doc/aya_vision.md",
            "status": "added",
            "additions": 243,
            "deletions": 0,
            "changes": 243,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/docs%2Fsource%2Fen%2Fmodel_doc%2Faya_vision.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/docs%2Fsource%2Fen%2Fmodel_doc%2Faya_vision.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Faya_vision.md?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -0,0 +1,243 @@\n+<!--Copyright 2025 The HuggingFace Team. All rights reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+the License. You may obtain a copy of the License at\n+\n+http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+specific language governing permissions and limitations under the License.\n+\n+⚠️ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\n+rendered properly in your Markdown viewer.\n+\n+-->\n+\n+# AyaVision\n+\n+## Overview\n+\n+The Aya Vision 8B and 32B models is a state-of-the-art multilingual multimodal models developed by Cohere For AI. They build on the Aya Expanse recipe to handle both visual and textual information without compromising on the strong multilingual textual performance of the original model.\n+\n+Aya Vision 8B combines the `Siglip2-so400-384-14` vision encoder with the Cohere CommandR-7B language model further post-trained with the Aya Expanse recipe, creating a powerful vision-language model capable of understanding images and generating text across 23 languages. Whereas, Aya Vision 32B uses Aya Expanse 32B as the language model.\n+\n+Key features of Aya Vision include:\n+- Multimodal capabilities in 23 languages\n+- Strong text-only multilingual capabilities inherited from CommandR-7B post-trained with the Aya Expanse recipe and Aya Expanse 32B\n+- High-quality visual understanding using the Siglip2-so400-384-14 vision encoder\n+- Seamless integration of visual and textual information in 23 languages.\n+\n+<!-- <img src=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/model_doc/aya_vision_architecture.webp\"\n+alt=\"drawing\" width=\"600\"/>\n+\n+<small> Aya Vision architecture. </small> -->\n+\n+Tips:\n+\n+- Aya Vision is a multimodal model that takes images and text as input and produces text as output.\n+- Images are represented using the `<image>` tag in the templated input.\n+- For best results, use the `apply_chat_template` method of the processor to format your inputs correctly.\n+- The model can process multiple images in a single conversation.\n+- Aya Vision can understand and generate text in 23 languages, making it suitable for multilingual multimodal applications.\n+\n+This model was contributed by [saurabhdash](https://huggingface.co/saurabhdash) and [yonigozlan](https://huggingface.co/yonigozlan).\n+\n+\n+## Usage\n+\n+Here's how to use Aya Vision for inference:\n+\n+```python\n+from transformers import AutoProcessor, AutoModelForImageTextToText\n+import torch\n+\n+model_id = \"CohereForAI/aya-vision-8b\"\n+torch_device = \"cuda:0\"\n+\n+# Use fast image processor\n+processor = AutoProcessor.from_pretrained(model_id, use_fast=True)\n+model = AutoModelForImageTextToText.from_pretrained(\n+    model_id, device_map=torch_device, torch_dtype=torch.float16\n+)\n+\n+# Format message with the aya-vision chat template\n+messages = [\n+    {\"role\": \"user\",\n+     \"content\": [\n+       {\"type\": \"image\", \"url\": \"https://pbs.twimg.com/media/Fx7YvfQWYAIp6rZ?format=jpg&name=medium\"},\n+        {\"type\": \"text\", \"text\": \"चित्र में लिखा पाठ क्या कहता है?\"},\n+    ]},\n+    ]\n+\n+# Process image on CUDA\n+inputs = processor.apply_chat_template(\n+    messages, padding=True, add_generation_prompt=True, tokenize=True, return_dict=True, return_tensors=\"pt\", device=torch_device\n+).to(model.device)\n+\n+gen_tokens = model.generate(\n+    **inputs, \n+    max_new_tokens=300, \n+    do_sample=True, \n+    temperature=0.3,\n+)\n+\n+gen_text = print(processor.tokenizer.decode(gen_tokens[0][inputs.input_ids.shape[1]:], skip_special_tokens=True))\n+```\n+### Pipeline\n+\n+```python\n+from transformers import pipeline\n+\n+pipe = pipeline(model=\"CohereForAI/aya-vision-8b\", task=\"image-text-to-text\", device_map=\"auto\")\n+\n+# Format message with the aya-vision chat template\n+messages = [\n+    {\"role\": \"user\",\n+     \"content\": [\n+       {\"type\": \"image\", \"url\": \"https://media.istockphoto.com/id/458012057/photo/istanbul-turkey.jpg?s=612x612&w=0&k=20&c=qogAOVvkpfUyqLUMr_XJQyq-HkACXyYUSZbKhBlPrxo=\"},\n+        {\"type\": \"text\", \"text\": \"Bu resimde hangi anıt gösterilmektedir?\"},\n+    ]},\n+    ]\n+outputs = pipe(text=messages, max_new_tokens=300, return_full_text=False)\n+\n+print(outputs)\n+```\n+\n+### Multiple Images and Batched Inputs\n+\n+Aya Vision can process multiple images in a single conversation. Here's how to use it with multiple images:\n+\n+```python\n+from transformers import AutoProcessor, AutoModelForImageTextToText\n+import torch\n+\n+model_id = \"CohereForAI/aya-vision-8b\"\n+\n+processor = AutoProcessor.from_pretrained(model_id)\n+model = AutoModelForImageTextToText.from_pretrained(\n+    model_id, device_map=\"cuda:0\", torch_dtype=torch.float16\n+)\n+\n+# Example with multiple images in a single message\n+messages = [\n+    {\n+        \"role\": \"user\",\n+        \"content\": [\n+            {\n+                \"type\": \"image\",\n+                \"url\": \"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\",\n+            },\n+            {\n+                \"type\": \"image\",\n+                \"url\": \"https://thumbs.dreamstime.com/b/golden-gate-bridge-san-francisco-purple-flowers-california-echium-candicans-36805947.jpg\",\n+            },\n+            {\n+                \"type\": \"text\",\n+                \"text\": \"These images depict two different landmarks. Can you identify them?\",\n+            },\n+        ],\n+    },\n+]\n+\n+inputs = processor.apply_chat_template(\n+    messages, padding=True, add_generation_prompt=True, tokenize=True, return_dict=True, return_tensors=\"pt\"\n+).to(model.device)\n+\n+gen_tokens = model.generate(\n+    **inputs, \n+    max_new_tokens=300, \n+    do_sample=True, \n+    temperature=0.3,\n+)\n+\n+gen_text = processor.tokenizer.decode(gen_tokens[0][inputs.input_ids.shape[1]:], skip_special_tokens=True)\n+print(gen_text)\n+```\n+\n+For processing batched inputs (multiple conversations at once):\n+\n+```python\n+from transformers import AutoProcessor, AutoModelForImageTextToText\n+import torch\n+\n+model_id = \"CohereForAI/aya-vision-8b\"\n+\n+processor = AutoProcessor.from_pretrained(model_id)\n+model = AutoModelForImageTextToText.from_pretrained(\n+    model_id, device_map=\"cuda:0\", torch_dtype=torch.float16\n+)\n+\n+# Prepare two different conversations\n+batch_messages = [\n+    # First conversation with a single image\n+    [\n+        {\n+            \"role\": \"user\",\n+            \"content\": [\n+                {\"type\": \"image\", \"url\": \"https://llava-vl.github.io/static/images/view.jpg\"},\n+                {\"type\": \"text\", \"text\": \"Write a haiku for this image\"},\n+            ],\n+        },\n+    ],\n+    # Second conversation with multiple images\n+    [\n+        {\n+            \"role\": \"user\",\n+            \"content\": [\n+                {\n+                    \"type\": \"image\",\n+                    \"url\": \"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\",\n+                },\n+                {\n+                    \"type\": \"image\",\n+                    \"url\": \"https://thumbs.dreamstime.com/b/golden-gate-bridge-san-francisco-purple-flowers-california-echium-candicans-36805947.jpg\",\n+                },\n+                {\n+                    \"type\": \"text\",\n+                    \"text\": \"These images depict two different landmarks. Can you identify them?\",\n+                },\n+            ],\n+        },\n+    ],\n+]\n+\n+# Process each conversation separately and combine into a batch\n+batch_inputs = processor.apply_chat_template(\n+    batch_messages, \n+    padding=True, \n+    add_generation_prompt=True, \n+    tokenize=True, \n+    return_dict=True, \n+    return_tensors=\"pt\"\n+).to(model.device)\n+\n+# Generate responses for the batch\n+batch_outputs = model.generate(\n+    **batch_inputs,\n+    max_new_tokens=300,\n+    do_sample=True,\n+    temperature=0.3,\n+)\n+\n+# Decode the generated responses\n+for i, output in enumerate(batch_outputs):\n+    response = processor.tokenizer.decode(\n+        output[batch_inputs.input_ids.shape[1]:], \n+        skip_special_tokens=True\n+    )\n+    print(f\"Response {i+1}:\\n{response}\\n\")\n+```\n+\n+## AyaVisionProcessor\n+\n+[[autodoc]] AyaVisionProcessor\n+\n+## AyaVisionConfig\n+\n+[[autodoc]] AyaVisionConfig\n+\n+## AyaVisionForConditionalGeneration\n+\n+[[autodoc]] AyaVisionForConditionalGeneration\n+    - forward"
        },
        {
            "sha": "4b69946548320c150ea54a7373b552ec8007e205",
            "filename": "src/transformers/__init__.py",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2F__init__.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -194,6 +194,7 @@\n         \"AutoTokenizer\",\n     ],\n     \"models.autoformer\": [\"AutoformerConfig\"],\n+    \"models.aya_vision\": [\"AyaVisionConfig\", \"AyaVisionProcessor\"],\n     \"models.bamba\": [\"BambaConfig\"],\n     \"models.bark\": [\n         \"BarkCoarseConfig\",\n@@ -1600,6 +1601,7 @@\n             \"AutoformerPreTrainedModel\",\n         ]\n     )\n+    _import_structure[\"models.aya_vision\"].extend([\"AyaVisionForConditionalGeneration\", \"AyaVisionPreTrainedModel\"])\n     _import_structure[\"models.bamba\"].extend(\n         [\n             \"BambaForCausalLM\",\n@@ -5320,6 +5322,10 @@\n     from .models.autoformer import (\n         AutoformerConfig,\n     )\n+    from .models.aya_vision import (\n+        AyaVisionConfig,\n+        AyaVisionProcessor,\n+    )\n     from .models.bamba import BambaConfig\n     from .models.bark import (\n         BarkCoarseConfig,\n@@ -6765,6 +6771,7 @@\n             AutoformerModel,\n             AutoformerPreTrainedModel,\n         )\n+        from .models.aya_vision import AyaVisionForConditionalGeneration, AyaVisionPreTrainedModel\n         from .models.bamba import BambaForCausalLM, BambaModel, BambaPreTrainedModel\n         from .models.bark import (\n             BarkCausalModel,"
        },
        {
            "sha": "3884daabd97380f0758f338ded0f69fae6461587",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -20,6 +20,7 @@\n     audio_spectrogram_transformer,\n     auto,\n     autoformer,\n+    aya_vision,\n     bamba,\n     bark,\n     bart,"
        },
        {
            "sha": "fa4de19554304e35deead65fbc018ba3bed349e5",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -39,6 +39,7 @@\n         (\"aria_text\", \"AriaTextConfig\"),\n         (\"audio-spectrogram-transformer\", \"ASTConfig\"),\n         (\"autoformer\", \"AutoformerConfig\"),\n+        (\"aya_vision\", \"AyaVisionConfig\"),\n         (\"bamba\", \"BambaConfig\"),\n         (\"bark\", \"BarkConfig\"),\n         (\"bart\", \"BartConfig\"),\n@@ -359,6 +360,7 @@\n         (\"aria_text\", \"AriaText\"),\n         (\"audio-spectrogram-transformer\", \"Audio Spectrogram Transformer\"),\n         (\"autoformer\", \"Autoformer\"),\n+        (\"aya_vision\", \"AyaVision\"),\n         (\"bamba\", \"Bamba\"),\n         (\"bark\", \"Bark\"),\n         (\"bart\", \"BART\"),"
        },
        {
            "sha": "d9fd502c1faeb6064a1bedfba6edb201a61149e7",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -818,6 +818,7 @@\n MODEL_FOR_IMAGE_TEXT_TO_TEXT_MAPPING_NAMES = OrderedDict(\n     [\n         (\"aria\", \"AriaForConditionalGeneration\"),\n+        (\"aya_vision\", \"AyaVisionForConditionalGeneration\"),\n         (\"blip\", \"BlipForConditionalGeneration\"),\n         (\"blip-2\", \"Blip2ForConditionalGeneration\"),\n         (\"chameleon\", \"ChameleonForConditionalGeneration\"),"
        },
        {
            "sha": "2d6da5ac13b40d5ca396ccad06f161048e793828",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -48,6 +48,7 @@\n         (\"align\", \"AlignProcessor\"),\n         (\"altclip\", \"AltCLIPProcessor\"),\n         (\"aria\", \"AriaProcessor\"),\n+        (\"aya_vision\", \"AyaVisionProcessor\"),\n         (\"bark\", \"BarkProcessor\"),\n         (\"blip\", \"BlipProcessor\"),\n         (\"blip-2\", \"Blip2Processor\"),"
        },
        {
            "sha": "57bcd31296cc5ba80671e342fdbad9d2bdcb669a",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -69,6 +69,7 @@\n             ),\n             (\"align\", (\"BertTokenizer\", \"BertTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"aria\", (\"LlamaTokenizer\", \"LlamaTokenizerFast\" if is_tokenizers_available() else None)),\n+            (\"aya_vision\", (None, \"CohereTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"bark\", (\"BertTokenizer\", \"BertTokenizerFast\" if is_tokenizers_available() else None)),\n             (\"bart\", (\"BartTokenizer\", \"BartTokenizerFast\")),\n             ("
        },
        {
            "sha": "f8be47cb228b19f02b87d195747e78c2a87de752",
            "filename": "src/transformers/models/aya_vision/__init__.py",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Faya_vision%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Faya_vision%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Faya_vision%2F__init__.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -0,0 +1,28 @@\n+# Copyright 2024 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_aya_vision import *\n+    from .modeling_aya_vision import *\n+    from .processing_aya_vision import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "574a5755abd62163a280817bd7fb002613ae48d4",
            "filename": "src/transformers/models/aya_vision/configuration_aya_vision.py",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Faya_vision%2Fconfiguration_aya_vision.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Faya_vision%2Fconfiguration_aya_vision.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Faya_vision%2Fconfiguration_aya_vision.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -0,0 +1,109 @@\n+# coding=utf-8\n+# Copyright 2025 Cohere team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"AyaVision model configuration\"\"\"\n+\n+from ...configuration_utils import PretrainedConfig\n+from ...utils import logging\n+from ..auto import CONFIG_MAPPING, AutoConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class AyaVisionConfig(PretrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`AyaVisionForConditionalGeneration`]. It is used to instantiate an\n+    AyaVision model according to the specified arguments, defining the model architecture. Instantiating a configuration\n+    with the defaults will yield a similar configuration to that of AyaVision.\n+    e.g. [CohereForAI/aya-vision-8b](https://huggingface.co/CohereForAI/aya-vision-8b)\n+\n+    Configuration objects inherit from [`PretrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PretrainedConfig`] for more information.\n+\n+    Args:\n+        vision_config (`Union[AutoConfig, dict]`,  *optional*, defaults to `CLIPVisionConfig`):\n+            The config object or dictionary of the vision backbone.\n+        text_config (`Union[AutoConfig, dict]`, *optional*, defaults to `LlamaConfig`):\n+            The config object or dictionary of the text backbone.\n+        vision_feature_select_strategy (`str`, *optional*, defaults to `\"full\"`):\n+            The feature selection strategy used to select the vision feature from the vision backbone.\n+            Can be one of `\"default\"` or `\"full\"`. If `\"default\"`, the CLS token is removed from the vision features.\n+            If `\"full\"`, the full vision features are used.\n+        vision_feature_layer (`int`, *optional*, defaults to -1):\n+            The index of the layer to select the vision feature.\n+        downsample_factor (`int`, *optional*, defaults to 2):\n+            The downsample factor to apply to the vision features.\n+        adapter_layer_norm_eps (`float`, *optional*, defaults to 1e-06):\n+            The epsilon value used for layer normalization in the adapter.\n+        image_token_index (`int`, *optional*, defaults to 255036):\n+            The image token index to encode the image prompt.\n+    \"\"\"\n+\n+    model_type = \"aya_vision\"\n+    sub_configs = {\"text_config\": AutoConfig, \"vision_config\": AutoConfig}\n+\n+    def __init__(\n+        self,\n+        vision_config=None,\n+        text_config=None,\n+        vision_feature_select_strategy=\"full\",\n+        vision_feature_layer=-1,\n+        downsample_factor=2,\n+        adapter_layer_norm_eps=1e-6,\n+        image_token_index=255036,\n+        **kwargs,\n+    ):\n+        self.image_token_index = image_token_index\n+        self.downsample_factor = downsample_factor\n+        self.adapter_layer_norm_eps = adapter_layer_norm_eps\n+        if vision_feature_select_strategy not in [\"default\", \"full\"]:\n+            raise ValueError(\n+                \"vision_feature_select_strategy should be one of 'default', 'full'.\"\n+                f\"Got: {vision_feature_select_strategy}\"\n+            )\n+\n+        self.vision_feature_select_strategy = vision_feature_select_strategy\n+        self.vision_feature_layer = vision_feature_layer\n+\n+        if isinstance(vision_config, dict):\n+            vision_config[\"model_type\"] = (\n+                vision_config[\"model_type\"] if \"model_type\" in vision_config else \"clip_vision_model\"\n+            )\n+            vision_config = CONFIG_MAPPING[vision_config[\"model_type\"]](**vision_config)\n+        elif vision_config is None:\n+            vision_config = CONFIG_MAPPING[\"siglip_vision_model\"](\n+                hidden_size=1152,\n+                intermediate_size=4304,\n+                patch_size=14,\n+                image_size=384,\n+                num_hidden_layers=26,\n+                num_attention_heads=14,\n+                vision_use_head=False,\n+            )\n+\n+        self.vision_config = vision_config\n+\n+        if isinstance(text_config, dict):\n+            text_config[\"model_type\"] = text_config[\"model_type\"] if \"model_type\" in text_config else \"llama\"\n+            text_config = CONFIG_MAPPING[text_config[\"model_type\"]](**text_config)\n+        elif text_config is None:\n+            text_config = CONFIG_MAPPING[\"cohere2\"]()\n+\n+        self.text_config = text_config\n+\n+        super().__init__(**kwargs)\n+\n+\n+__all__ = [\"AyaVisionConfig\"]"
        },
        {
            "sha": "f2ae7b8858e3519d47c18ef70c4a50b47cb8b8fd",
            "filename": "src/transformers/models/aya_vision/modeling_aya_vision.py",
            "status": "added",
            "additions": 503,
            "deletions": 0,
            "changes": 503,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Faya_vision%2Fmodeling_aya_vision.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Faya_vision%2Fmodeling_aya_vision.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Faya_vision%2Fmodeling_aya_vision.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -0,0 +1,503 @@\n+# coding=utf-8\n+# Copyright 2025 the Cohere Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"PyTorch AyaVision model.\"\"\"\n+\n+from dataclasses import dataclass\n+from typing import List, Optional, Tuple, Union\n+\n+import torch\n+import torch.utils.checkpoint\n+from torch import nn\n+\n+from ...activations import ACT2FN\n+from ...generation import GenerationMixin\n+from ...modeling_outputs import ModelOutput\n+from ...modeling_utils import PreTrainedModel\n+from ...utils import (\n+    add_start_docstrings,\n+    add_start_docstrings_to_model_forward,\n+    is_torchdynamo_compiling,\n+    logging,\n+    replace_return_docstrings,\n+)\n+from ..auto import AutoModel, AutoModelForCausalLM\n+from .configuration_aya_vision import AyaVisionConfig\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+_CONFIG_FOR_DOC = \"AyaVisionConfig\"\n+\n+\n+# copied from transformers.models.Llava.modeling_llava.LlavaCausalLMOutputWithPast\n+@dataclass\n+class AyaVisionCausalLMOutputWithPast(ModelOutput):\n+    \"\"\"\n+    Base class for AyaVision causal language model (or autoregressive) outputs.\n+\n+    Args:\n+        loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+            Language modeling loss (for next-token prediction).\n+        logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n+            Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`)\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+            `past_key_values` input) to speed up sequential decoding.\n+        hidden_states (`tuple(torch.FloatTensor)`, *optional*, returned when `output_hidden_states=True` is passed or when `config.output_hidden_states=True`):\n+            Tuple of `torch.FloatTensor` (one for the output of the embeddings, if the model has an embedding layer, +\n+            one for the output of each layer) of shape `(batch_size, sequence_length, hidden_size)`.\n+\n+            Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.\n+        attentions (`tuple(torch.FloatTensor)`, *optional*, returned when `output_attentions=True` is passed or when `config.output_attentions=True`):\n+            Tuple of `torch.FloatTensor` (one for each layer) of shape `(batch_size, num_heads, sequence_length,\n+            sequence_length)`.\n+\n+            Attentions weights after the attention softmax, used to compute the weighted average in the self-attention\n+            heads.\n+        image_hidden_states (`torch.FloatTensor`, *optional*):\n+            A `torch.FloatTensor` of size (batch_size * num_patches, num_images, sequence_length, hidden_size)`.\n+            image_hidden_states of the model produced by the vision encoder and after projecting the last hidden state.\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: torch.FloatTensor = None\n+    past_key_values: Optional[List[torch.FloatTensor]] = None\n+    hidden_states: Optional[Tuple[torch.FloatTensor]] = None\n+    attentions: Optional[Tuple[torch.FloatTensor]] = None\n+    image_hidden_states: Optional[torch.FloatTensor] = None\n+\n+\n+class AyaVisionMultiModalProjector(nn.Module):\n+    def __init__(self, config: AyaVisionConfig):\n+        super().__init__()\n+        self.config = config\n+        self.downsample_factor = config.downsample_factor\n+        self.alignment_intermediate_size = getattr(\n+            config, \"alignment_intermediate_size\", config.text_config.hidden_size\n+        )\n+        self.layernorm = nn.LayerNorm(\n+            config.vision_config.hidden_size * (config.downsample_factor**2), eps=config.adapter_layer_norm_eps\n+        )\n+\n+        self.linear_1 = nn.Linear(\n+            config.vision_config.hidden_size * (config.downsample_factor**2),\n+            self.alignment_intermediate_size,\n+            bias=True,\n+        )\n+\n+        self.act = ACT2FN[\"silu\"]  # SwiGLU uses SiLU activation\n+        # For SwiGLU, project down to half size since we split intermediate dim\n+        self.linear_2 = nn.Linear(self.alignment_intermediate_size // 2, config.text_config.hidden_size, bias=True)\n+\n+    def forward(self, image_features):\n+        image_features = self.pixel_shuffle(image_features)\n+        image_features = self.layernorm(image_features)\n+        hidden_states = self.linear_1(image_features)\n+\n+        # Split along last dimension and apply SwiGLU\n+        x, gate = hidden_states.chunk(2, dim=-1)\n+        hidden_states = self.act(gate) * x\n+\n+        hidden_states = self.linear_2(hidden_states)\n+        return hidden_states\n+\n+    def pixel_shuffle(self, image_features):  # B, S, D\n+        batch_size, seq_length, feature_dim = image_features.shape\n+        height = width = int(seq_length**0.5)\n+        image_features = image_features.reshape(image_features.shape[0], width, height, -1)\n+        channels = image_features.shape[-1]\n+        image_features = image_features.reshape(\n+            batch_size, width, int(height / self.downsample_factor), int(channels * self.downsample_factor)\n+        )\n+        image_features = image_features.permute(0, 2, 1, 3)\n+        image_features = image_features.reshape(\n+            batch_size, int(height / self.downsample_factor), int(width / self.downsample_factor), -1\n+        )\n+        image_features = image_features.permute(0, 2, 1, 3)\n+        return image_features\n+\n+\n+AYA_VISION_START_DOCSTRING = r\"\"\"\n+    This model inherits from [`PreTrainedModel`]. Check the superclass documentation for the generic methods the\n+    library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads\n+    etc.)\n+\n+    This model is also a PyTorch [torch.nn.Module](https://pytorch.org/docs/stable/nn.html#torch.nn.Module) subclass.\n+    Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage\n+    and behavior.\n+\n+    Parameters:\n+        config ([`AyaVisionConfig`] or [`AyaVisionVisionConfig`]):\n+            Model configuration class with all the parameters of the model. Initializing with a config file does not\n+            load the weights associated with the model, only the configuration. Check out the\n+            [`~PreTrainedModel.from_pretrained`] method to load the model weights.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"The bare Aya Vision Model outputting raw hidden-states without any specific head on top.\",\n+    AYA_VISION_START_DOCSTRING,\n+)\n+class AyaVisionPreTrainedModel(PreTrainedModel):\n+    config_class = AyaVisionConfig\n+    base_model_prefix = \"model\"\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = [\"AyaVisionVisionAttention\"]\n+    _skip_keys_device_placement = \"past_key_values\"\n+    _supports_cache_class = True\n+    _supports_flash_attn_2 = True\n+    _supports_sdpa = True\n+\n+    def _init_weights(self, module):\n+        # important: this ported version of AyaVision isn't meant for training from scratch - only\n+        # inference and fine-tuning - so the proper init weights code has been removed - the original codebase\n+        std = (\n+            self.config.initializer_range\n+            if hasattr(self.config, \"initializer_range\")\n+            else self.config.text_config.initializer_range\n+        )\n+\n+        if hasattr(module, \"class_embedding\"):\n+            module.class_embedding.data.normal_(mean=0.0, std=std)\n+\n+        if isinstance(module, (nn.Linear, nn.Conv2d)):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.bias is not None:\n+                module.bias.data.zero_()\n+        elif isinstance(module, nn.Embedding):\n+            module.weight.data.normal_(mean=0.0, std=std)\n+            if module.padding_idx is not None:\n+                module.weight.data[module.padding_idx].zero_()\n+\n+\n+AYA_VISION_INPUTS_DOCSTRING = r\"\"\"\n+    Args:\n+        input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+            Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+            it.\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            [What are input IDs?](../glossary#input-ids)\n+        pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)):\n+            The tensors corresponding to the input images. Pixel values can be obtained using\n+            [`AutoImageProcessor`]. See [`GotOcr2ImageProcessor.__call__`] for details. [`CohereProcessor`] uses\n+            [`GotOcr2ImageProcessor`] for processing images.\n+        attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+            - 1 for tokens that are **not masked**,\n+            - 0 for tokens that are **masked**.\n+\n+            [What are attention masks?](../glossary#attention-mask)\n+\n+            Indices can be obtained using [`AutoTokenizer`]. See [`PreTrainedTokenizer.encode`] and\n+            [`PreTrainedTokenizer.__call__`] for details.\n+\n+            If `past_key_values` is used, optionally only the last `decoder_input_ids` have to be input (see\n+            `past_key_values`).\n+\n+            If you want to change padding behavior, you should read [`modeling_opt._prepare_decoder_attention_mask`]\n+            and modify to your needs. See diagram 1 in [the paper](https://arxiv.org/abs/1910.13461) for more\n+            information on the default strategy.\n+\n+            - 1 indicates the head is **not masked**,\n+            - 0 indicates the head is **masked**.\n+        position_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0,\n+            config.n_positions - 1]`. [What are position IDs?](../glossary#position-ids)\n+        past_key_values (`tuple(tuple(torch.FloatTensor))`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+            Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of shape\n+            `(batch_size, num_heads, sequence_length, embed_size_per_head)`) and 2 additional tensors of shape\n+            `(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)`.\n+\n+            Contains pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n+            blocks) that can be used (see `past_key_values` input) to speed up sequential decoding.\n+\n+            If `past_key_values` are used, the user can optionally input only the last `decoder_input_ids` (those that\n+            don't have their past key value states given to this model) of shape `(batch_size, 1)` instead of all\n+            `decoder_input_ids` of shape `(batch_size, sequence_length)`.\n+        inputs_embeds (`torch.FloatTensor` of shape `(batch_size, sequence_length, hidden_size)`, *optional*):\n+            Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n+            is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n+            model's internal embedding lookup matrix.\n+        vision_feature_layer (`int`, *optional*, defaults to -2):\n+            The index of the layer to select the vision feature.\n+        vision_feature_select_strategy (`str`, *optional*, defaults to `\"default\"`):\n+            The feature selection strategy used to select the vision feature from the vision backbone.\n+            Can be one of `\"default\"` or `\"full\"`. If `\"default\"`, the CLS token is removed from the vision features.\n+            If `\"full\"`, the full vision features are used.\n+        use_cache (`bool`, *optional*):\n+            If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n+            `past_key_values`).\n+        output_attentions (`bool`, *optional*):\n+            Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n+            tensors for more detail.\n+        output_hidden_states (`bool`, *optional*):\n+            Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n+            more detail.\n+        return_dict (`bool`, *optional*):\n+            Whether or not to return a [`~utils.ModelOutput`] instead of a plain tuple.\n+        cache_position (`torch.LongTensor` of shape `(sequence_length)`, *optional*):\n+            Indices depicting the position of the input sequence tokens in the sequence. Contrarily to `position_ids`,\n+            this tensor is not affected by padding. It is used to update the cache in the correct position and to infer\n+            the complete sequence length.\n+\"\"\"\n+\n+\n+@add_start_docstrings(\n+    \"\"\"The AyaVision model which consists of a vision backbone and a language model.\"\"\",\n+    AYA_VISION_START_DOCSTRING,\n+)\n+class AyaVisionForConditionalGeneration(AyaVisionPreTrainedModel, GenerationMixin):\n+    def __init__(self, config: AyaVisionConfig):\n+        super().__init__(config)\n+        self.vision_tower = AutoModel.from_config(config.vision_config)\n+\n+        self.multi_modal_projector = AyaVisionMultiModalProjector(config)\n+\n+        self.vocab_size = config.text_config.vocab_size\n+        self.language_model = AutoModelForCausalLM.from_config(config.text_config)\n+        if self.language_model._tied_weights_keys is not None:\n+            self._tied_weights_keys = [f\"language_model.{key}\" for key in self.language_model._tied_weights_keys]\n+\n+        self.pad_token_id = self.config.pad_token_id if self.config.pad_token_id is not None else -1\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.language_model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.language_model.set_input_embeddings(value)\n+\n+    def get_output_embeddings(self):\n+        return self.language_model.get_output_embeddings()\n+\n+    def set_output_embeddings(self, new_embeddings):\n+        self.language_model.set_output_embeddings(new_embeddings)\n+\n+    def set_decoder(self, decoder):\n+        self.language_model.set_decoder(decoder)\n+\n+    def get_decoder(self):\n+        return self.language_model.get_decoder()\n+\n+    def tie_weights(self):\n+        return self.language_model.tie_weights()\n+\n+    def resize_token_embeddings(self, new_num_tokens: Optional[int] = None, pad_to_multiple_of=None) -> nn.Embedding:\n+        model_embeds = self.language_model.resize_token_embeddings(new_num_tokens, pad_to_multiple_of)\n+        # update vocab size\n+        self.config.text_config.vocab_size = model_embeds.num_embeddings\n+        self.vocab_size = model_embeds.num_embeddings\n+        return model_embeds\n+\n+    def get_image_features(\n+        self,\n+        pixel_values: torch.FloatTensor,\n+        vision_feature_layer: int,\n+        vision_feature_select_strategy: str,\n+    ):\n+        \"\"\"\n+        Obtains image last hidden states from the vision tower and apply multimodal projection.\n+\n+        Args:\n+            pixel_values (`torch.FloatTensor]` of shape `(batch_size, num_patches, channels, height, width)`)\n+               The tensors corresponding to the input images.\n+            vision_feature_layer (`int`):\n+                The index of the layer to select the vision feature.\n+            vision_feature_select_strategy (`str`):\n+                The feature selection strategy used to select the vision feature from the vision backbone.\n+                Can be one of `\"default\"` or `\"full\"`\n+        Returns:\n+            image_features (List[`torch.Tensor`]): List of image feature tensor, each contains all the visual feature of all patches\n+            and are of shape `(num_patches, image_length, embed_dim)`).\n+        \"\"\"\n+\n+        image_features = self.vision_tower(pixel_values, output_hidden_states=True)\n+        selected_image_feature = image_features.hidden_states[vision_feature_layer]\n+        if vision_feature_select_strategy == \"default\":\n+            selected_image_feature = selected_image_feature[:, 1:]\n+        elif vision_feature_select_strategy == \"full\":\n+            selected_image_feature = selected_image_feature\n+        image_features = self.multi_modal_projector(selected_image_feature)\n+\n+        return image_features\n+\n+    @add_start_docstrings_to_model_forward(AYA_VISION_INPUTS_DOCSTRING)\n+    @replace_return_docstrings(output_type=AyaVisionCausalLMOutputWithPast, config_class=_CONFIG_FOR_DOC)\n+    def forward(\n+        self,\n+        input_ids: torch.LongTensor = None,\n+        pixel_values: torch.FloatTensor = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[List[torch.FloatTensor]] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        vision_feature_layer: Optional[int] = None,\n+        vision_feature_select_strategy: Optional[str] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        output_attentions: Optional[bool] = None,\n+        output_hidden_states: Optional[bool] = None,\n+        return_dict: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        last_cache_position: int = 0,\n+        num_logits_to_keep: int = 0,\n+        **lm_kwargs,\n+    ) -> Union[Tuple, AyaVisionCausalLMOutputWithPast]:\n+        r\"\"\"\n+        Args:\n+            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+                config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+                (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+\n+            num_logits_to_keep (`int`, *optional*):\n+                Calculate logits for the last `num_logits_to_keep` tokens. If `0`, calculate logits for all\n+                `input_ids` (special case). Only last token logits are needed for generation, and calculating them only for that\n+                token can save memory, which becomes pretty significant for long sequences or large vocabulary size.\n+\n+            Returns:\n+        \"\"\"\n+\n+        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions\n+        output_hidden_states = (\n+            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states\n+        )\n+        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n+        vision_feature_layer = (\n+            vision_feature_layer if vision_feature_layer is not None else self.config.vision_feature_layer\n+        )\n+        vision_feature_select_strategy = (\n+            vision_feature_select_strategy\n+            if vision_feature_select_strategy is not None\n+            else self.config.vision_feature_select_strategy\n+        )\n+\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if pixel_values is not None and inputs_embeds is not None:\n+            raise ValueError(\n+                \"You cannot specify both pixel_values and inputs_embeds at the same time, and must specify either one\"\n+            )\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.get_input_embeddings()(input_ids)\n+\n+        if pixel_values is not None:\n+            image_features = self.get_image_features(\n+                pixel_values=pixel_values,\n+                vision_feature_layer=vision_feature_layer,\n+                vision_feature_select_strategy=vision_feature_select_strategy,\n+            )\n+\n+            special_image_mask = (input_ids == self.config.image_token_index).unsqueeze(-1)\n+            special_image_mask = special_image_mask.expand_as(inputs_embeds).to(inputs_embeds.device)\n+            if not is_torchdynamo_compiling() and inputs_embeds[special_image_mask].numel() != image_features.numel():\n+                n_image_tokens = (input_ids == self.config.image_token_index).sum()\n+                n_image_features = image_features.shape[0] * image_features.shape[1]\n+                raise ValueError(\n+                    f\"Image features and image tokens do not match: tokens: {n_image_tokens}, features {n_image_features}\"\n+                )\n+            image_features = image_features.to(inputs_embeds.device, inputs_embeds.dtype)\n+            inputs_embeds = inputs_embeds.masked_scatter(special_image_mask, image_features)\n+\n+        outputs = self.language_model(\n+            attention_mask=attention_mask,\n+            position_ids=position_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            use_cache=use_cache,\n+            output_attentions=output_attentions,\n+            output_hidden_states=output_hidden_states,\n+            return_dict=return_dict,\n+            cache_position=cache_position,\n+            last_cache_position=last_cache_position,\n+            num_logits_to_keep=num_logits_to_keep,\n+            logits_to_keep=0,\n+            **lm_kwargs,\n+        )\n+\n+        logits = outputs[0]\n+\n+        loss = None\n+        if labels is not None:\n+            # Shift so that tokens < n predict n\n+            if attention_mask is not None:\n+                # we use the input attention mask to shift the logits and labels, because it is 2D.\n+                # we also crop attn mask in case it is longer, which happens in PrefixTuning with peft\n+                shift_attention_mask = attention_mask[:, -(logits.shape[1] - 1) :].to(logits.device)\n+                shift_logits = logits[..., :-1, :][shift_attention_mask.to(logits.device) != 0].contiguous()\n+                shift_labels = labels[..., 1:][shift_attention_mask.to(labels.device) != 0].contiguous()\n+            else:\n+                shift_logits = logits[..., :-1, :].contiguous()\n+                shift_labels = labels[..., 1:].contiguous()\n+            # Flatten the tokens\n+            loss_fct = nn.CrossEntropyLoss()\n+            loss = loss_fct(\n+                shift_logits.view(-1, shift_logits.size(-1)), shift_labels.view(-1).to(shift_logits.device)\n+            )\n+\n+        if not return_dict:\n+            output = (logits,) + outputs[1:]\n+            return (loss,) + output if loss is not None else output\n+\n+        return AyaVisionCausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            image_hidden_states=image_features if pixel_values is not None else None,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        inputs_embeds=None,\n+        pixel_values=None,\n+        attention_mask=None,\n+        cache_position=None,\n+        num_logits_to_keep=None,\n+        **kwargs,\n+    ):\n+        # Overwritten -- in specific circumstances we don't want to forward image inputs to the model\n+\n+        model_inputs = self.language_model.prepare_inputs_for_generation(\n+            input_ids,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            attention_mask=attention_mask,\n+            cache_position=cache_position,\n+            num_logits_to_keep=num_logits_to_keep,\n+            **kwargs,\n+        )\n+\n+        # If we're in cached decoding stage, pixel values should be None because input ids do not contain special image token anymore\n+        # Otherwise we need pixel values to be passed to model\n+        if cache_position[0] == 0:\n+            model_inputs[\"pixel_values\"] = pixel_values\n+\n+        return model_inputs\n+\n+\n+__all__ = [\"AyaVisionForConditionalGeneration\", \"AyaVisionPreTrainedModel\"]"
        },
        {
            "sha": "392c44993c544b7623cc0274671dbda9c1758d3e",
            "filename": "src/transformers/models/aya_vision/processing_aya_vision.py",
            "status": "added",
            "additions": 264,
            "deletions": 0,
            "changes": 264,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Faya_vision%2Fprocessing_aya_vision.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Fmodels%2Faya_vision%2Fprocessing_aya_vision.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Faya_vision%2Fprocessing_aya_vision.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -0,0 +1,264 @@\n+# coding=utf-8\n+# Copyright 2025 HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+from typing import List, Optional, Union\n+\n+from transformers.processing_utils import (\n+    ImagesKwargs,\n+    ProcessingKwargs,\n+    ProcessorMixin,\n+    Unpack,\n+)\n+from transformers.tokenization_utils_base import PreTokenizedInput, TextInput\n+\n+from ...image_processing_utils import BatchFeature\n+from ...image_utils import (\n+    ImageInput,\n+    make_flat_list_of_images,\n+)\n+\n+\n+class AyaVisionImagesKwargs(ImagesKwargs, total=False):\n+    crop_to_patches: Optional[bool]\n+    min_patches: Optional[int]\n+    max_patches: Optional[int]\n+\n+\n+class AyaVisionProcessorKwargs(ProcessingKwargs, total=False):\n+    images_kwargs: AyaVisionImagesKwargs\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding_side\": \"left\",\n+            \"padding\": True,\n+        },\n+        \"images_kwargs\": {\n+            \"crop_to_patches\": True,\n+        },\n+    }\n+\n+\n+class AyaVisionProcessor(ProcessorMixin):\n+    r\"\"\"\n+    Constructs a AyaVision processor which wraps a [`AutoImageProcessor`] and\n+    [`PretrainedTokenizerFast`] tokenizer into a single processor that inherits both the image processor and\n+    tokenizer functionalities. See the [`~AyaVisionProcessor.__call__`] and [`~AyaVisionProcessor.decode`] for more information.\n+    Args:\n+        image_processor ([`AutoImageProcessor`], *optional*):\n+            The image processor is a required input.\n+        tokenizer ([`PreTrainedTokenizer`, `PreTrainedTokenizerFast`], *optional*):\n+            The tokenizer is a required input.\n+        patch_size (`int`, *optional*, defaults to 28):\n+            The size of image patches for tokenization.\n+        img_size (`int`, *optional*, defaults to 364):\n+            The size of the image to be tokenized. This should correspond to the size given to the image processor.\n+        vision_feature_select_strategy (`str`, *optional*, defaults to `\"full\"`):\n+            The feature selection strategy used to select the vision feature from the vision backbone.\n+        image_token (`str`, *optional*, defaults to `\"<image>\"`):\n+            The token to be used to represent an image in the text.\n+        downsample_factor (`int`, *optional*, defaults to 1):\n+            The factor by which to scale the patch size.\n+        start_of_img_token (`str`, *optional*, defaults to `\"<|START_OF_IMG|>\"`):\n+            The token to be used to represent the start of an image in the text.\n+        end_of_img_token (`str`, *optional*, defaults to `\"<|END_OF_IMG|>\"`):\n+            The token to be used to represent the end of an image in the text.\n+        img_patch_token (`str`, *optional*, defaults to `\"<|IMG_PATCH|>\"`):\n+            The token to be used to represent an image patch in the text.\n+        img_line_break_token (`str`, *optional*, defaults to `\"<|IMG_LINE_BREAK|>\"`):\n+            The token to be used to represent a line break in the text.\n+        tile_token (`str`, *optional*, defaults to `\"TILE\"`):\n+            The token to be used to represent an image patch in the text.\n+        tile_global_token (`str`, *optional*, defaults to `\"TILE_GLOBAL\"`):\n+            The token to be used to represent the cover image in the text.\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    attributes = [\"image_processor\", \"tokenizer\"]\n+    valid_kwargs = [\n+        \"chat_template\",\n+        \"image_token\",\n+        \"patch_size\",\n+        \"img_size\",\n+        \"downsample_factor\",\n+        \"vision_feature_select_strategy\",\n+        \"start_of_img_token\",\n+        \"end_of_img_token\",\n+        \"img_patch_token\",\n+        \"img_line_break_token\",\n+        \"tile_token\",\n+        \"tile_global_token\",\n+    ]\n+    image_processor_class = \"AutoImageProcessor\"\n+    tokenizer_class = \"AutoTokenizer\"\n+\n+    def __init__(\n+        self,\n+        image_processor=None,\n+        tokenizer=None,\n+        patch_size: int = 28,\n+        img_size: int = 364,\n+        vision_feature_select_strategy=\"full\",\n+        image_token=\"<image>\",  # set the default and let users change if they have peculiar special tokens in rare cases\n+        downsample_factor: int = 1,\n+        start_of_img_token=\"<|START_OF_IMG|>\",\n+        end_of_img_token=\"<|END_OF_IMG|>\",\n+        img_patch_token=\"<|IMG_PATCH|>\",\n+        img_line_break_token=\"<|IMG_LINE_BREAK|>\",\n+        tile_token=\"TILE\",\n+        tile_global_token=\"TILE_GLOBAL\",\n+        chat_template=None,\n+        **kwargs,\n+    ):\n+        super().__init__(image_processor, tokenizer, chat_template=chat_template)\n+\n+        self.image_token = image_token\n+        self.patch_size = patch_size * downsample_factor\n+        self.img_size = img_size\n+        self.vision_feature_select_strategy = vision_feature_select_strategy\n+\n+        self.start_of_img_token = start_of_img_token\n+        self.end_of_img_token = end_of_img_token\n+        self.img_patch_token = img_patch_token\n+        self.img_line_break_token = img_line_break_token\n+        self.tile_token = tile_token\n+        self.tile_global_token = tile_global_token\n+\n+    def _prompt_split_image(self, num_patches):\n+        \"\"\"\n+        Create a structured string representation of image tokens\n+\n+        Args:\n+           num_patches: Number of patches in the image\n+\n+        Returns:\n+            String with appropriate image tokens\n+        \"\"\"\n+\n+        img_patches_per_tile = (self.img_size // self.patch_size) ** 2\n+        img_string = f\"{self.start_of_img_token}\"\n+        if num_patches > 1:\n+            for idx in range(1, num_patches):\n+                img_string += f\"{self.tile_token}_{idx}\" + f\"{self.img_patch_token}\" * img_patches_per_tile\n+\n+        img_string += f\"{self.tile_global_token}\" + f\"{self.img_patch_token}\" * img_patches_per_tile\n+        img_string += f\"{self.end_of_img_token}\"\n+        return img_string\n+\n+    def __call__(\n+        self,\n+        images: Optional[ImageInput] = None,\n+        text: Optional[Union[TextInput, PreTokenizedInput, List[TextInput], List[PreTokenizedInput]]] = None,\n+        audio=None,\n+        videos=None,\n+        **kwargs: Unpack[AyaVisionProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`\n+        and `kwargs` arguments to PreTrainedTokenizerFast's [`~PreTrainedTokenizerFast.__call__`] to encode the text.\n+        To prepare the vision inputs, this method forwards the `images` and `kwargs` arguments to\n+        GotOcr2ImageProcessor's [`~GotOcr2ImageProcessor.__call__`] if `images` is not `None`.\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. Both channels-first and channels-last formats are supported.\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+                - `'tf'`: Return TensorFlow `tf.constant` objects.\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+                - `'jax'`: Return JAX `jnp.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+        \"\"\"\n+        if text is None:\n+            raise ValueError(\"You have to specify text.\")\n+\n+        output_kwargs = self._merge_kwargs(\n+            AyaVisionProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+\n+        if not isinstance(text, (list, tuple)):\n+            text = [text]\n+\n+        # Process images\n+        image_inputs = {}\n+        if images is not None:\n+            images = make_flat_list_of_images(images)\n+            image_inputs = self.image_processor(images=images, **output_kwargs[\"images_kwargs\"])\n+            num_patches = image_inputs.pop(\"num_patches\")\n+            image_index = 0\n+            img_start_idx = 0\n+            processed_text = []\n+            image_num_patches = []\n+            for prompt in text:\n+                new_prompt = prompt\n+                curr_num_image_patches = 0\n+                while \"<image>\" in new_prompt:\n+                    # Replace the image placeholder with structured image tokens\n+                    image_tokens = self._prompt_split_image(num_patches[image_index])\n+                    new_prompt = new_prompt.replace(\"<image>\", image_tokens, 1)\n+                    curr_num_image_patches += num_patches[image_index]\n+                    image_index += 1\n+\n+                processed_text.append(new_prompt)\n+                image_num_patches.append(curr_num_image_patches.item())\n+                img_start_idx += curr_num_image_patches\n+\n+            if image_index != len(images):\n+                raise ValueError(\"Number of image placeholders in the prompt does not match the number of images.\")\n+\n+            text = processed_text\n+\n+        text_inputs = self.tokenizer(text, **output_kwargs[\"text_kwargs\"])\n+\n+        return BatchFeature(data={**text_inputs, **image_inputs})\n+\n+    def batch_decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to PreTrainedTokenizerFast's [`~PreTrainedTokenizer.batch_decode`]. Please\n+        refer to the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.batch_decode(*args, **kwargs)\n+\n+    def decode(self, *args, **kwargs):\n+        \"\"\"\n+        This method forwards all its arguments to PreTrainedTokenizerFast's [`~PreTrainedTokenizer.decode`]. Please refer to\n+        the docstring of this method for more information.\n+        \"\"\"\n+        return self.tokenizer.decode(*args, **kwargs)\n+\n+    @property\n+    def model_input_names(self):\n+        tokenizer_input_names = self.tokenizer.model_input_names\n+        image_processor_input_names = self.image_processor.model_input_names\n+        return list(tokenizer_input_names) + list(image_processor_input_names)\n+\n+\n+__all__ = [\"AyaVisionProcessor\"]"
        },
        {
            "sha": "5b43469abe5f3835fd0f7fef4e779ed987dfa7d5",
            "filename": "src/transformers/utils/dummy_pt_objects.py",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Futils%2Fdummy_pt_objects.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -1146,6 +1146,20 @@ def __init__(self, *args, **kwargs):\n         requires_backends(self, [\"torch\"])\n \n \n+class AyaVisionForConditionalGeneration(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n+class AyaVisionPreTrainedModel(metaclass=DummyObject):\n+    _backends = [\"torch\"]\n+\n+    def __init__(self, *args, **kwargs):\n+        requires_backends(self, [\"torch\"])\n+\n+\n class BambaForCausalLM(metaclass=DummyObject):\n     _backends = [\"torch\"]\n "
        },
        {
            "sha": "f66dca2125d8e22ab707bb932a016e71013277e3",
            "filename": "tests/generation/test_utils.py",
            "status": "modified",
            "additions": 12,
            "deletions": 1,
            "changes": 13,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/tests%2Fgeneration%2Ftest_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/tests%2Fgeneration%2Ftest_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fgeneration%2Ftest_utils.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -113,7 +113,18 @@\n \n \n # TODO: raushan remove this when VLMs start accepting input embeds\n-VLM_CLASS_NAMES = [\"llava\", \"idefics2\", \"idefics3\", \"mllama\", \"paligemma\", \"emu3\", \"gotocr2\", \"qwen2vl\", \"qwen2_5_vl\"]\n+VLM_CLASS_NAMES = [\n+    \"llava\",\n+    \"idefics2\",\n+    \"idefics3\",\n+    \"mllama\",\n+    \"paligemma\",\n+    \"emu3\",\n+    \"gotocr2\",\n+    \"qwen2vl\",\n+    \"qwen2_5_vl\",\n+    \"ayavision\",\n+]\n \n \n class GenerationTesterMixin:"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/aya_vision/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/tests%2Fmodels%2Faya_vision%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/tests%2Fmodels%2Faya_vision%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Faya_vision%2F__init__.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c"
        },
        {
            "sha": "dc8fe2503df1c9c2e3553f54d4353bcc8e30d2b5",
            "filename": "tests/models/aya_vision/test_modeling_aya_vision.py",
            "status": "added",
            "additions": 576,
            "deletions": 0,
            "changes": 576,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/tests%2Fmodels%2Faya_vision%2Ftest_modeling_aya_vision.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/tests%2Fmodels%2Faya_vision%2Ftest_modeling_aya_vision.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Faya_vision%2Ftest_modeling_aya_vision.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -0,0 +1,576 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch GotOcr2 model.\"\"\"\n+\n+import unittest\n+\n+from parameterized import parameterized\n+\n+from transformers import (\n+    AutoProcessor,\n+    AyaVisionConfig,\n+    is_torch_available,\n+    is_vision_available,\n+)\n+from transformers.testing_utils import (\n+    cleanup,\n+    require_read_token,\n+    require_torch,\n+    require_torch_gpu,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import ModelTesterMixin, floats_tensor, ids_tensor\n+from ...test_pipeline_mixin import PipelineTesterMixin\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+    from transformers import (\n+        AyaVisionForConditionalGeneration,\n+    )\n+\n+\n+if is_vision_available():\n+    pass\n+\n+\n+class AyaVisionVisionText2TextModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=3,\n+        seq_length=7,\n+        vision_feature_layer=-1,\n+        downsample_factor=2,\n+        ignore_index=-100,\n+        bos_token_id=0,\n+        eos_token_id=0,\n+        pad_token_id=0,\n+        image_token_index=1,\n+        num_channels=3,\n+        image_size=64,\n+        model_type=\"aya_vision\",\n+        is_training=True,\n+        text_config={\n+            \"model_type\": \"cohere2\",\n+            \"vocab_size\": 99,\n+            \"hidden_size\": 128,\n+            \"intermediate_size\": 37,\n+            \"num_hidden_layers\": 4,\n+            \"num_attention_heads\": 4,\n+            \"output_channels\": 64,\n+            \"hidden_act\": \"silu\",\n+            \"max_position_embeddings\": 512,\n+            \"tie_word_embeddings\": True,\n+            \"bos_token_id\": 0,\n+            \"eos_token_id\": 0,\n+            \"pad_token_id\": 0,\n+        },\n+        vision_config={\n+            \"model_type\": \"siglip_vision_model\",\n+            \"hidden_size\": 32,\n+            \"num_hidden_layers\": 2,\n+            \"num_attention_heads\": 4,\n+            \"intermediate_size\": 128,\n+            \"image_size\": 64,\n+            \"patch_size\": 8,\n+            \"vision_use_head\": False,\n+        },\n+    ):\n+        self.parent = parent\n+        self.ignore_index = ignore_index\n+        self.bos_token_id = bos_token_id\n+        self.eos_token_id = eos_token_id\n+        self.pad_token_id = pad_token_id\n+        self.image_token_index = image_token_index\n+        self.model_type = model_type\n+        self.text_config = text_config\n+        self.vision_config = vision_config\n+        self.batch_size = batch_size\n+        self.vision_feature_layer = vision_feature_layer\n+        self.downsample_factor = downsample_factor\n+        self.is_training = is_training\n+        self.num_channels = num_channels\n+        self.image_size = image_size\n+        self.image_seq_length = (image_size // (vision_config[\"patch_size\"] * downsample_factor)) ** 2\n+        self.seq_length = seq_length + self.image_seq_length\n+\n+        self.num_hidden_layers = text_config[\"num_hidden_layers\"]\n+        self.vocab_size = text_config[\"vocab_size\"]\n+        self.hidden_size = text_config[\"hidden_size\"]\n+        self.num_attention_heads = text_config[\"num_attention_heads\"]\n+\n+    def get_config(self):\n+        return AyaVisionConfig(\n+            text_config=self.text_config,\n+            vision_config=self.vision_config,\n+            model_type=self.model_type,\n+            bos_token_id=self.bos_token_id,\n+            eos_token_id=self.eos_token_id,\n+            pad_token_id=self.pad_token_id,\n+            image_token_index=self.image_token_index,\n+            vision_feature_layer=self.vision_feature_layer,\n+            downsample_factor=self.downsample_factor,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        config = self.get_config()\n+        pixel_values = floats_tensor([self.batch_size, self.num_channels, self.image_size, self.image_size])\n+\n+        return config, pixel_values\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], self.vocab_size)\n+        attention_mask = torch.ones(input_ids.shape, dtype=torch.long, device=torch_device)\n+        print(\"attention_mask\", attention_mask.shape)\n+        # input_ids[:, -1] = self.pad_token_id\n+        input_ids[input_ids == self.image_token_index] = self.pad_token_id\n+        input_ids[:, : self.image_seq_length] = self.image_token_index\n+\n+        inputs_dict = {\n+            \"pixel_values\": pixel_values,\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+        }\n+        return config, inputs_dict\n+\n+    def create_and_check_model_fp16_forward(self, config, input_ids, pixel_values, attention_mask):\n+        model = AyaVisionForConditionalGeneration(config=config)\n+        model.to(torch_device)\n+        model.half()\n+        model.eval()\n+        logits = model(\n+            input_ids=input_ids,\n+            attention_mask=attention_mask,\n+            pixel_values=pixel_values,\n+            return_dict=True,\n+        )[\"logits\"]\n+        self.parent.assertFalse(torch.isnan(logits).any().item())\n+\n+    def create_and_check_model_fp16_autocast_forward(self, config, input_ids, pixel_values, attention_mask):\n+        config.torch_dtype = torch.float16\n+        model = AyaVisionForConditionalGeneration(config=config)\n+        model.to(torch_device)\n+        model.eval()\n+        with torch.autocast(device_type=\"cuda\", dtype=torch.float16):\n+            logits = model(\n+                input_ids=input_ids,\n+                attention_mask=attention_mask,\n+                pixel_values=pixel_values,\n+                return_dict=True,\n+            )[\"logits\"]\n+        self.parent.assertFalse(torch.isnan(logits).any().item())\n+\n+\n+@require_torch\n+class AyaVisionModelTest(ModelTesterMixin, GenerationTesterMixin, PipelineTesterMixin, unittest.TestCase):\n+    all_model_classes = (AyaVisionForConditionalGeneration,) if is_torch_available() else ()\n+    all_generative_model_classes = (AyaVisionForConditionalGeneration,) if is_torch_available() else ()\n+    pipeline_model_mapping = (\n+        {\n+            \"image-text-to-text\": AyaVisionForConditionalGeneration,\n+        }\n+        if is_torch_available()\n+        else {}\n+    )\n+    fx_compatible = False\n+    test_pruning = False\n+    test_torchscript = False\n+    test_head_masking = False\n+    _is_composite = True\n+\n+    def setUp(self):\n+        self.model_tester = AyaVisionVisionText2TextModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=AyaVisionConfig, has_text_modality=False)\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    # overwrite inputs_embeds tests because we need to delete \"pixel values\" for LVLMs\n+    def test_inputs_embeds(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            inputs = self._prepare_for_class(inputs_dict, model_class)\n+\n+            input_ids = inputs[\"input_ids\"]\n+            del inputs[\"input_ids\"]\n+            del inputs[\"pixel_values\"]\n+\n+            wte = model.get_input_embeddings()\n+            inputs[\"inputs_embeds\"] = wte(input_ids)\n+\n+            with torch.no_grad():\n+                model(**inputs)\n+\n+    # overwrite inputs_embeds tests because we need to delete \"pixel values\" for LVLMs\n+    # while some other models require pixel_values to be present\n+    def test_inputs_embeds_matches_input_ids(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            inputs = self._prepare_for_class(inputs_dict, model_class)\n+            input_ids = inputs[\"input_ids\"]\n+            del inputs[\"input_ids\"]\n+            del inputs[\"pixel_values\"]\n+\n+            inputs_embeds = model.get_input_embeddings()(input_ids)\n+\n+            with torch.no_grad():\n+                out_ids = model(input_ids=input_ids, **inputs)[0]\n+                out_embeds = model(inputs_embeds=inputs_embeds, **inputs)[0]\n+            torch.testing.assert_close(out_embeds, out_ids)\n+\n+    @unittest.skip(\"Failing because of unique cache (HybridCache)\")\n+    def test_model_outputs_equivalence(self, **kwargs):\n+        pass\n+\n+    @unittest.skip(\"Cohere2's forcefully disables sdpa due to softcapping\")\n+    def test_sdpa_can_dispatch_non_composite_models(self):\n+        pass\n+\n+    @parameterized.expand([(\"float16\",), (\"bfloat16\",), (\"float32\",)])\n+    @unittest.skip(\"Cohere2's eager attn/sdpa attn outputs are expected to be different\")\n+    def test_eager_matches_sdpa_inference(self):\n+        pass\n+\n+    @unittest.skip(\"Cohere2's eager attn/sdpa attn outputs are expected to be different\")\n+    def test_eager_matches_sdpa_generate(self):\n+        pass\n+\n+    @parameterized.expand([(\"random\",), (\"same\",)])\n+    @unittest.skip(\"Cohere2 has HybridCache which is not compatible with assisted decoding\")\n+    def test_assisted_decoding_matches_greedy_search(self, assistant_type):\n+        pass\n+\n+    @unittest.skip(\"Cohere2 has HybridCache which is not compatible with assisted decoding\")\n+    def test_prompt_lookup_decoding_matches_greedy_search(self, assistant_type):\n+        pass\n+\n+    @unittest.skip(\"Cohere2 has HybridCache which is not compatible with assisted decoding\")\n+    def test_assisted_decoding_sample(self):\n+        pass\n+\n+    @unittest.skip(\"Cohere2 has HybridCache which is not compatible with dola decoding\")\n+    def test_dola_decoding_sample(self):\n+        pass\n+\n+    @unittest.skip(\"Cohere2 has HybridCache and doesn't support continue from past kv\")\n+    def test_generate_continue_from_past_key_values(self):\n+        pass\n+\n+    @unittest.skip(\"Cohere2 has HybridCache and doesn't support low_memory generation\")\n+    def test_beam_search_low_memory(self):\n+        pass\n+\n+    @unittest.skip(\"Cohere2 has HybridCache and doesn't support contrastive generation\")\n+    def test_contrastive_generate(self):\n+        pass\n+\n+    @unittest.skip(\"Cohere2 has HybridCache and doesn't support contrastive generation\")\n+    def test_contrastive_generate_dict_outputs_use_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Cohere2 has HybridCache and doesn't support contrastive generation\")\n+    def test_contrastive_generate_low_memory(self):\n+        pass\n+\n+    @unittest.skip(\"Cohere2 has HybridCache and doesn't support StaticCache. Though it could, it shouldn't support.\")\n+    def test_generate_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Cohere2 has HybridCache and doesn't support StaticCache. Though it could, it shouldn't support.\")\n+    def test_generate_from_inputs_embeds_with_static_cache(self):\n+        pass\n+\n+    @unittest.skip(\"Cohere2 has HybridCache and doesn't support progressive generation using input embeds.\")\n+    def test_generate_continue_from_inputs_embeds(self):\n+        pass\n+\n+    @unittest.skip(\"Failing because of unique cache (HybridCache)\")\n+    def test_multi_gpu_data_parallel_forward(self):\n+        pass\n+\n+    @unittest.skip(\"Cohere2's eager attn/sdpa attn outputs are expected to be different\")\n+    def test_sdpa_equivalence(self):\n+        pass\n+\n+    @unittest.skip(reason=\"SiglipVisionModel does not support standalone training\")\n+    def test_training(self):\n+        pass\n+\n+    @unittest.skip(reason=\"SiglipVisionModel does not support standalone training\")\n+    def test_training_gradient_checkpointing(self):\n+        pass\n+\n+    @unittest.skip(reason=\"SiglipVisionModel does not support standalone training\")\n+    def test_training_gradient_checkpointing_use_reentrant(self):\n+        pass\n+\n+    @unittest.skip(reason=\"SiglipVisionModel does not support standalone training\")\n+    def test_training_gradient_checkpointing_use_reentrant_false(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Siglip uses the same initialization scheme as the Flax original implementation\")\n+    def test_initialization(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Compile not yet supported because in LLava models\")\n+    def test_sdpa_can_compile_dynamic(self):\n+        pass\n+\n+    @unittest.skip(\"FlashAttention only support fp16 and bf16 data type\")\n+    def test_flash_attn_2_fp32_ln(self):\n+        pass\n+\n+    # todo: yoni - fix or improve the test\n+    @unittest.skip(\"Difference is slightly higher than the threshold\")\n+    def test_batching_equivalence(self):\n+        pass\n+\n+\n+@require_read_token\n+@require_torch\n+class AyaVisionIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.model_checkpoint = \"CohereForAI/aya-vision-8b\"\n+\n+    def tearDown(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    @slow\n+    @require_torch_gpu\n+    def test_small_model_integration_forward(self):\n+        processor = AutoProcessor.from_pretrained(self.model_checkpoint)\n+        model = AyaVisionForConditionalGeneration.from_pretrained(\n+            self.model_checkpoint, device_map=torch_device, torch_dtype=torch.float16\n+        )\n+        messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\", \"url\": \"http://images.cocodataset.org/val2017/000000039769.jpg\"},\n+                    {\"type\": \"text\", \"text\": \"Please describe the image explicitly.\"},\n+                ],\n+            }\n+        ]\n+\n+        inputs = processor.apply_chat_template(\n+            messages, add_generation_prompt=True, tokenize=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(torch_device, dtype=torch.float16)\n+        # Forward\n+        with torch.inference_mode():\n+            output = model(**inputs)\n+\n+        actual_logits = output.logits[0, -1, :5].cpu()\n+        print(\"actual_logits\", actual_logits)\n+        expected_logits = torch.tensor([0.4109, 0.1532, 0.8018, 2.1328, 0.5483], dtype=torch.float16)\n+        self.assertTrue(\n+            torch.allclose(actual_logits, expected_logits, atol=0.1),\n+            f\"Actual logits: {actual_logits}\"\n+            f\"\\nExpected logits: {expected_logits}\"\n+            f\"\\nDifference: {torch.abs(actual_logits - expected_logits)}\",\n+        )\n+\n+    @slow\n+    @require_torch_gpu\n+    def test_small_model_integration_generate_text_only(self):\n+        processor = AutoProcessor.from_pretrained(self.model_checkpoint)\n+        model = AyaVisionForConditionalGeneration.from_pretrained(\n+            self.model_checkpoint, device_map=torch_device, torch_dtype=torch.float16\n+        )\n+        messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"text\", \"text\": \"Write a haiku\"},\n+                ],\n+            }\n+        ]\n+\n+        inputs = processor.apply_chat_template(\n+            messages, add_generation_prompt=True, tokenize=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(torch_device, dtype=torch.float16)\n+        with torch.no_grad():\n+            generate_ids = model.generate(**inputs, max_new_tokens=25, do_sample=False)\n+            decoded_output = processor.decode(\n+                generate_ids[0, inputs[\"input_ids\"].shape[1] :], skip_special_tokens=True\n+            )\n+        print(\"decoded_output\", decoded_output)\n+        expected_output = \"Whispers on the breeze,\\nLeaves dance under moonlit skies,\\nNature's quiet song.\"\n+        self.assertEqual(decoded_output, expected_output)\n+\n+    @slow\n+    @require_torch_gpu\n+    def test_small_model_integration_generate_chat_template(self):\n+        processor = AutoProcessor.from_pretrained(self.model_checkpoint)\n+        model = AyaVisionForConditionalGeneration.from_pretrained(\n+            self.model_checkpoint, device_map=torch_device, torch_dtype=torch.float16\n+        )\n+        messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\", \"url\": \"http://images.cocodataset.org/val2017/000000039769.jpg\"},\n+                    {\"type\": \"text\", \"text\": \"Please describe the image explicitly.\"},\n+                ],\n+            }\n+        ]\n+\n+        inputs = processor.apply_chat_template(\n+            messages, add_generation_prompt=True, tokenize=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(torch_device, dtype=torch.float16)\n+        with torch.no_grad():\n+            generate_ids = model.generate(**inputs, max_new_tokens=20, do_sample=False)\n+            decoded_output = processor.decode(\n+                generate_ids[0, inputs[\"input_ids\"].shape[1] :], skip_special_tokens=True\n+            )\n+        print(\"decoded_output\", decoded_output)\n+        expected_output = \"The image depicts a cozy scene of two cats resting on a bright pink blanket. The cats,\"  # fmt: skip\n+        self.assertEqual(decoded_output, expected_output)\n+\n+    @slow\n+    @require_torch_gpu\n+    def test_small_model_integration_batched_generate(self):\n+        processor = AutoProcessor.from_pretrained(self.model_checkpoint)\n+        model = AyaVisionForConditionalGeneration.from_pretrained(\n+            self.model_checkpoint, device_map=torch_device, torch_dtype=torch.float16\n+        )\n+        # Prepare inputs\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\"type\": \"image\", \"url\": \"https://llava-vl.github.io/static/images/view.jpg\"},\n+                        {\"type\": \"text\", \"text\": \"Write a haiku for this image\"},\n+                    ],\n+                },\n+            ],\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\"type\": \"image\", \"url\": \"https://www.ilankelman.org/stopsigns/australia.jpg\"},\n+                        {\"type\": \"text\", \"text\": \"Describe this image\"},\n+                    ],\n+                },\n+            ],\n+        ]\n+        inputs = processor.apply_chat_template(\n+            messages, padding=True, add_generation_prompt=True, tokenize=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(model.device, dtype=torch.float16)\n+\n+        output = model.generate(**inputs, do_sample=False, max_new_tokens=25)\n+\n+        # Check first output\n+        decoded_output = processor.decode(output[0, inputs[\"input_ids\"].shape[1] :], skip_special_tokens=True)\n+        print(\"decoded_output\", decoded_output)\n+        expected_output = \"Wooden path to water,\\nMountains echo in stillness,\\nPeaceful forest scene.\"  # fmt: skip\n+        self.assertEqual(\n+            decoded_output,\n+            expected_output,\n+            f\"Decoded output: {decoded_output}\\nExpected output: {expected_output}\",\n+        )\n+\n+        # Check second output\n+        decoded_output = processor.decode(output[1, inputs[\"input_ids\"].shape[1] :], skip_special_tokens=True)\n+        print(\"decoded_output\", decoded_output)\n+        expected_output = 'This image captures a vibrant street scene in a bustling urban area, likely in an Asian city. The focal point is a'  # fmt: skip\n+\n+        self.assertEqual(\n+            decoded_output,\n+            expected_output,\n+            f\"Decoded output: {decoded_output}\\nExpected output: {expected_output}\",\n+        )\n+\n+    @slow\n+    @require_torch_gpu\n+    def test_small_model_integration_batched_generate_multi_image(self):\n+        processor = AutoProcessor.from_pretrained(self.model_checkpoint)\n+        model = AyaVisionForConditionalGeneration.from_pretrained(\n+            self.model_checkpoint, device_map=torch_device, torch_dtype=torch.float16\n+        )\n+        # Prepare inputs\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\"type\": \"image\", \"url\": \"https://llava-vl.github.io/static/images/view.jpg\"},\n+                        {\"type\": \"text\", \"text\": \"Write a haiku for this image\"},\n+                    ],\n+                },\n+            ],\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\n+                            \"type\": \"image\",\n+                            \"url\": \"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\",\n+                        },\n+                        {\n+                            \"type\": \"image\",\n+                            \"url\": \"https://thumbs.dreamstime.com/b/golden-gate-bridge-san-francisco-purple-flowers-california-echium-candicans-36805947.jpg\",\n+                        },\n+                        {\n+                            \"type\": \"text\",\n+                            \"text\": \"These images depict two different landmarks. Can you identify them?\",\n+                        },\n+                    ],\n+                },\n+            ],\n+        ]\n+        inputs = processor.apply_chat_template(\n+            messages, padding=True, add_generation_prompt=True, tokenize=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(model.device, dtype=torch.float16)\n+        output = model.generate(**inputs, do_sample=False, max_new_tokens=25)\n+\n+        # Check first output\n+        decoded_output = processor.decode(output[0, inputs[\"input_ids\"].shape[1] :], skip_special_tokens=True)\n+        # Batching seems to alter the output slightly, but it is also the case in the original implementation. This seems to be expected: https://github.com/huggingface/transformers/issues/23017#issuecomment-1649630232\n+        expected_output = \"Wooden path to water,\\nMountains echo in stillness,\\nPeaceful forest scene.\"  # fmt: skip\n+        print(\"decoded_output\", decoded_output)\n+        self.assertEqual(\n+            decoded_output,\n+            expected_output,\n+            f\"Decoded output: {decoded_output}\\nExpected output: {expected_output}\",\n+        )\n+\n+        # Check second output\n+        decoded_output = processor.decode(output[1, inputs[\"input_ids\"].shape[1] :], skip_special_tokens=True)\n+        print(\"decoded_output\", decoded_output)\n+        expected_output = \"The first image showcases the Statue of Liberty, a colossal neoclassical sculpture on Liberty Island in New York Harbor. Standing at a\"  # fmt: skip\n+        self.assertEqual(\n+            decoded_output,\n+            expected_output,\n+            f\"Decoded output: {decoded_output}\\nExpected output: {expected_output}\",\n+        )"
        },
        {
            "sha": "8830f85c50c1e2e439d35b362dddc20d7ea780e9",
            "filename": "tests/models/aya_vision/test_processor_aya_vision.py",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/huggingface/transformers/blob/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/tests%2Fmodels%2Faya_vision%2Ftest_processor_aya_vision.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/84f0186e8971a21bcda9b446a8a74f0f1a958f1c/tests%2Fmodels%2Faya_vision%2Ftest_processor_aya_vision.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Faya_vision%2Ftest_processor_aya_vision.py?ref=84f0186e8971a21bcda9b446a8a74f0f1a958f1c",
            "patch": "@@ -0,0 +1,164 @@\n+# coding=utf-8\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import shutil\n+import tempfile\n+import unittest\n+from typing import Optional\n+\n+from transformers import AutoProcessor, AutoTokenizer, AyaVisionProcessor\n+from transformers.testing_utils import require_read_token, require_torch, require_vision\n+from transformers.utils import is_torch_available, is_vision_available\n+\n+from ...test_processing_common import ProcessorTesterMixin\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+if is_vision_available():\n+    from transformers import GotOcr2ImageProcessor\n+\n+\n+@require_read_token\n+@require_vision\n+class AyaVisionProcessorTest(ProcessorTesterMixin, unittest.TestCase):\n+    processor_class = AyaVisionProcessor\n+\n+    def setUp(self):\n+        self.tmpdirname = tempfile.mkdtemp()\n+\n+        image_processor = GotOcr2ImageProcessor(\n+            do_resize=True,\n+            size={\"height\": 20, \"width\": 20},\n+            max_patches=2,\n+            do_rescale=True,\n+            rescale_factor=1 / 255,\n+            do_normalize=True,\n+            image_mean=[0.485, 0.456, 0.406],\n+            image_std=[0.229, 0.224, 0.225],\n+            do_convert_rgb=True,\n+        )\n+        tokenizer = AutoTokenizer.from_pretrained(\"CohereForAI/aya-vision-8b\", padding_side=\"left\")\n+        processor_kwargs = self.prepare_processor_dict()\n+        processor = AyaVisionProcessor.from_pretrained(\n+            \"CohereForAI/aya-vision-8b\",\n+            image_processor=image_processor,\n+            tokenizer=tokenizer,\n+            **processor_kwargs,\n+        )\n+        processor.save_pretrained(self.tmpdirname)\n+\n+    def prepare_processor_dict(self):\n+        return {\"patch_size\": 10, \"img_size\": 20}\n+\n+    def get_tokenizer(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).tokenizer\n+\n+    def get_image_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).image_processor\n+\n+    def get_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs)\n+\n+    def tearDown(self):\n+        shutil.rmtree(self.tmpdirname)\n+\n+    # todo: yoni, fix this test\n+    @unittest.skip(\"Chat template has long system prompt\")\n+    def test_chat_template_accepts_processing_kwargs(self, **kwargs):\n+        pass\n+\n+    # Override as AyaVisionProcessor needs image tokens in prompts\n+    def prepare_text_inputs(self, batch_size: Optional[int] = None):\n+        if batch_size is None:\n+            return \"lower newer <image>\"\n+\n+        if batch_size < 1:\n+            raise ValueError(\"batch_size must be greater than 0\")\n+\n+        if batch_size == 1:\n+            return [\"lower newer <image>\"]\n+        return [\"lower newer <image>\", \"<image> upper older longer string\"] + [\"<image> lower newer\"] * (\n+            batch_size - 2\n+        )\n+\n+    @require_torch\n+    def test_process_interleaved_images_videos(self):\n+        processor = self.get_processor()\n+\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\n+                            \"type\": \"image\",\n+                            \"url\": \"https://cdn.britannica.com/61/93061-050-99147DCE/Statue-of-Liberty-Island-New-York-Bay.jpg\",\n+                        },\n+                        {\n+                            \"type\": \"image\",\n+                            \"url\": \"https://thumbs.dreamstime.com/b/golden-gate-bridge-san-francisco-purple-flowers-california-echium-candicans-36805947.jpg\",\n+                        },\n+                        {\"type\": \"text\", \"text\": \"What are the differences between these two images?\"},\n+                    ],\n+                },\n+            ],\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\n+                            \"type\": \"image\",\n+                            \"url\": \"https://llava-vl.github.io/static/images/view.jpg\",\n+                        },\n+                        {\"type\": \"text\", \"text\": \"Write a haiku for this image\"},\n+                    ],\n+                }\n+            ],\n+        ]\n+\n+        inputs_batched = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        )\n+\n+        # Process non batched inputs to check if the pixel_values and input_ids are reconstructed in the correct order when batched together\n+        images_patches_index = 0\n+        for i, message in enumerate(messages):\n+            inputs = processor.apply_chat_template(\n+                message,\n+                add_generation_prompt=True,\n+                tokenize=True,\n+                return_dict=True,\n+                return_tensors=\"pt\",\n+                padding=True,\n+            )\n+            # We slice with [-inputs[\"input_ids\"].shape[1] :] as the input_ids are left padded\n+            torch.testing.assert_close(\n+                inputs[\"input_ids\"][0], inputs_batched[\"input_ids\"][i][-inputs[\"input_ids\"].shape[1] :]\n+            )\n+            torch.testing.assert_close(\n+                inputs[\"pixel_values\"],\n+                inputs_batched[\"pixel_values\"][\n+                    images_patches_index : images_patches_index + inputs[\"pixel_values\"].shape[0]\n+                ],\n+            )\n+            images_patches_index += inputs[\"pixel_values\"].shape[0]"
        }
    ],
    "stats": {
        "total": 1929,
        "additions": 1928,
        "deletions": 1
    }
}