{
    "author": "zRzRzRzRzRzRzR",
    "message": "GLM-V update with new processor (#42122)\n\n* init\n\n* update\n\n* add\n\n* Update video_processing_glm46v.py\n\n* update doc\n\n* Update modular_glm46v.py\n\n* 2\n\n* Update processing_glm46v.py\n\n* 21\n\n* Update check_repo.py\n\n* Update check_repo.py\n\n* Update test_processor_glm46v.py\n\n* Update modeling_auto.py\n\n* update\n\n* Update glm46v.md\n\n* Update configuration_auto.py\n\n* 2\n\n* update with glm46v import\n\n* uppercase\n\n* upload\n\n* upload\n\n* upload with modular\n\n* 1\n\n* -\n\n* update\n\n* 1\n\n* 2\n\n* 1\n\n* 2\n\n* 2\n\n* 1\n\n* update config\n\n* 1\n\n* update as automoel\n\n* 1\n\n* try remove\n\n* delete\n\n* delete\n\n* test\n\n* update\n\n* 1\n\n* Update modular_glm46v.py\n\n* Update test_modeling_glm46v.py\n\n* update 1513\n\n* 1\n\n* use PreTrainedConfig\n\n* Update modular_glm46v.py\n\n* Update configuration_glm46v.py\n\n* model_type = \"glm46v\"\n\n* remove glm46v_text\n\n* Update image_processing_auto.py\n\n* 1\n\n* update readme\n\n* GLM-4.6V\n\n* update\n\n* update\n\n* Update __init__.py\n\n* update\n\n* update doc\n\n* Update check_docstrings.py\n\n* update doc\n\n* fix copies for tied weight keys!\n\n* more fixup\n\n---------\n\nCo-authored-by: Raushan Turganbay <raushan@huggingface.co>\nCo-authored-by: Arthur <48595927+ArthurZucker@users.noreply.github.com>\nCo-authored-by: Arthur <arthur.zucker@gmail.com>",
    "sha": "66d57110f089789ae285cc9d54d3bf051123246b",
    "files": [
        {
            "sha": "19180a7ef7f67ab9226770f10015e28907c90254",
            "filename": "docs/source/en/_toctree.yml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/docs%2Fsource%2Fen%2F_toctree.yml",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/docs%2Fsource%2Fen%2F_toctree.yml",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2F_toctree.yml?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -1066,6 +1066,8 @@\n         title: Gemma3n\n       - local: model_doc/git\n         title: GIT\n+      - local: model_doc/glm46v\n+        title: Glm46V\n       - local: model_doc/glm4v\n         title: glm4v\n       - local: model_doc/glm4v_moe"
        },
        {
            "sha": "6e099d7aaef672f2cbd897cfb537913ecda3438a",
            "filename": "docs/source/en/model_doc/glm46v.md",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm46v.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm46v.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm46v.md?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -0,0 +1,34 @@\n+# GLM-4.6V\n+\n+## Glm46VConfig\n+\n+[[autodoc]] Glm46VConfig\n+\n+## Glm46VImageProcessor\n+\n+[[autodoc]] Glm46VImageProcessor\n+    - preprocess\n+\n+## Glm46VVideoProcessor\n+\n+[[autodoc]] Glm46VVideoProcessor\n+    - preprocess\n+\n+## Glm46VImageProcessorFast\n+\n+[[autodoc]] Glm46VImageProcessorFast\n+    - preprocess\n+\n+## Glm46VProcessor\n+\n+[[autodoc]] Glm46VProcessor\n+\n+## Glm46VModel\n+\n+[[autodoc]] Glm46VModel\n+    - forward\n+\n+## Glm46VForConditionalGeneration\n+\n+[[autodoc]] Glm46VForConditionalGeneration\n+    - forward"
        },
        {
            "sha": "98f6d8e761c57ea643905baec32766a00b9ebd5a",
            "filename": "docs/source/en/model_doc/glm4v.md",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm4v.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm4v.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm4v.md?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -170,6 +170,11 @@ print(output_text)\n \n [[autodoc]] Glm4vConfig\n \n+\n+## Glm4vVisionConfig\n+\n+[[autodoc]] Glm4vVisionConfig\n+\n ## Glm4vTextConfig\n \n [[autodoc]] Glm4vTextConfig\n@@ -193,6 +198,11 @@ print(output_text)\n \n [[autodoc]] Glm4vProcessor\n \n+## Glm4vVisionModel\n+\n+[[autodoc]] Glm4vVisionModel\n+    - forward\n+\n ## Glm4vTextModel\n \n [[autodoc]] Glm4vTextModel"
        },
        {
            "sha": "8fab75298dfcb6f5cb75b4b5717ce16c51178f18",
            "filename": "docs/source/en/model_doc/glm4v_moe.md",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm4v_moe.md",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm4v_moe.md",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/docs%2Fsource%2Fen%2Fmodel_doc%2Fglm4v_moe.md?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -22,7 +22,7 @@ rendered properly in your Markdown viewer.\n <img alt=\"SDPA\" src=\"https://img.shields.io/badge/SDPA-DE3412?style=flat&logo=pytorch&logoColor=white\">    </div>\n </div>\n \n-# Glm4vMoe\n+# Glm4vMoeMoe\n \n ## Overview\n \n@@ -48,10 +48,20 @@ The model also introduces a **Thinking Mode** switch, allowing users to balance\n \n [[autodoc]] Glm4vMoeConfig\n \n+\n+## Glm4vMoeVisionConfig\n+\n+[[autodoc]] Glm4vMoeVisionConfig\n+\n ## Glm4vMoeTextConfig\n \n [[autodoc]] Glm4vMoeTextConfig\n \n+## Glm4vMoeVisionModel\n+\n+[[autodoc]] Glm4vMoeVisionModel\n+    - forward\n+\n ## Glm4vMoeTextModel\n \n [[autodoc]] Glm4vMoeTextModel\n@@ -65,4 +75,4 @@ The model also introduces a **Thinking Mode** switch, allowing users to balance\n ## Glm4vMoeForConditionalGeneration\n \n [[autodoc]] Glm4vMoeForConditionalGeneration\n-    - forward\n+    - forward\n\\ No newline at end of file"
        },
        {
            "sha": "76b7a9a32ac69d7ac4ad71bfce31de88cf67172c",
            "filename": "src/transformers/models/__init__.py",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2F__init__.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -142,6 +142,9 @@\n     from .git import *\n     from .glm import *\n     from .glm4 import *\n+    from .glm4v import *\n+    from .glm4v_moe import *\n+    from .glm46v import *\n     from .glpn import *\n     from .got_ocr2 import *\n     from .gpt2 import *"
        },
        {
            "sha": "e17a41263504e7c3faa3b5275c145144b988b00c",
            "filename": "src/transformers/models/auto/configuration_auto.py",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fconfiguration_auto.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -172,11 +172,14 @@\n         (\"git\", \"GitConfig\"),\n         (\"glm\", \"GlmConfig\"),\n         (\"glm4\", \"Glm4Config\"),\n+        (\"glm46v\", \"Glm46VConfig\"),\n         (\"glm4_moe\", \"Glm4MoeConfig\"),\n         (\"glm4v\", \"Glm4vConfig\"),\n         (\"glm4v_moe\", \"Glm4vMoeConfig\"),\n         (\"glm4v_moe_text\", \"Glm4vMoeTextConfig\"),\n+        (\"glm4v_moe_vision\", \"Glm4vMoeVisionConfig\"),\n         (\"glm4v_text\", \"Glm4vTextConfig\"),\n+        (\"glm4v_vision\", \"Glm4vVisionConfig\"),\n         (\"glpn\", \"GLPNConfig\"),\n         (\"got_ocr2\", \"GotOcr2Config\"),\n         (\"gpt-sw3\", \"GPT2Config\"),\n@@ -620,11 +623,14 @@\n         (\"git\", \"GIT\"),\n         (\"glm\", \"GLM\"),\n         (\"glm4\", \"GLM4\"),\n+        (\"glm46v\", \"Glm46V\"),\n         (\"glm4_moe\", \"Glm4MoE\"),\n         (\"glm4v\", \"GLM4V\"),\n         (\"glm4v_moe\", \"GLM4VMOE\"),\n         (\"glm4v_moe_text\", \"GLM4VMOE\"),\n+        (\"glm4v_moe_vision\", \"Glm4vMoeVisionModel\"),\n         (\"glm4v_text\", \"GLM4V\"),\n+        (\"glm4v_vision\", \"Glm4vVisionModel\"),\n         (\"glpn\", \"GLPN\"),\n         (\"got_ocr2\", \"GOT-OCR2\"),\n         (\"gpt-sw3\", \"GPT-Sw3\"),\n@@ -983,6 +989,8 @@\n         (\"gemma3n_audio\", \"gemma3n\"),\n         (\"gemma3n_text\", \"gemma3n\"),\n         (\"gemma3n_vision\", \"gemma3n\"),\n+        (\"glm4v_vision\", \"glm4v\"),\n+        (\"glm4v_moe_vision\", \"glm4v_moe\"),\n         (\"glm4v_text\", \"glm4v\"),\n         (\"glm4v_moe_text\", \"glm4v_moe\"),\n         (\"idefics3_vision\", \"idefics3\"),"
        },
        {
            "sha": "1de08b72934c5f4139c251791a526de09cafedae",
            "filename": "src/transformers/models/auto/image_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fimage_processing_auto.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -109,6 +109,7 @@\n             (\"gemma3\", (\"Gemma3ImageProcessor\", \"Gemma3ImageProcessorFast\")),\n             (\"gemma3n\", (\"SiglipImageProcessor\", \"SiglipImageProcessorFast\")),\n             (\"git\", (\"CLIPImageProcessor\", \"CLIPImageProcessorFast\")),\n+            (\"glm46v\", (\"Glm46VImageProcessor\", \"Glm46VImageProcessorFast\")),\n             (\"glm4v\", (\"Glm4vImageProcessor\", \"Glm4vImageProcessorFast\")),\n             (\"glpn\", (\"GLPNImageProcessor\", \"GLPNImageProcessorFast\")),\n             (\"got_ocr2\", (\"GotOcr2ImageProcessor\", \"GotOcr2ImageProcessorFast\")),"
        },
        {
            "sha": "acdf6c9db280a4544d1d4b42c53509fd2fc982eb",
            "filename": "src/transformers/models/auto/modeling_auto.py",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fmodeling_auto.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -175,11 +175,14 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"git\", \"GitModel\"),\n         (\"glm\", \"GlmModel\"),\n         (\"glm4\", \"Glm4Model\"),\n+        (\"glm46v\", \"Glm46VModel\"),\n         (\"glm4_moe\", \"Glm4MoeModel\"),\n         (\"glm4v\", \"Glm4vModel\"),\n         (\"glm4v_moe\", \"Glm4vMoeModel\"),\n         (\"glm4v_moe_text\", \"Glm4vMoeTextModel\"),\n+        (\"glm4v_moe_vision\", \"Glm4vMoeVisionModel\"),\n         (\"glm4v_text\", \"Glm4vTextModel\"),\n+        (\"glm4v_vision\", \"Glm4vVisionModel\"),\n         (\"glpn\", \"GLPNModel\"),\n         (\"got_ocr2\", \"GotOcr2Model\"),\n         (\"gpt-sw3\", \"GPT2Model\"),\n@@ -1032,6 +1035,7 @@ class _BaseModelWithGenerate(PreTrainedModel, GenerationMixin):\n         (\"gemma3\", \"Gemma3ForConditionalGeneration\"),\n         (\"gemma3n\", \"Gemma3nForConditionalGeneration\"),\n         (\"git\", \"GitForCausalLM\"),\n+        (\"glm46v\", \"Glm46VForConditionalGeneration\"),\n         (\"glm4v\", \"Glm4vForConditionalGeneration\"),\n         (\"glm4v_moe\", \"Glm4vMoeForConditionalGeneration\"),\n         (\"got_ocr2\", \"GotOcr2ForConditionalGeneration\"),"
        },
        {
            "sha": "eac5f695aa2567e350a09fa630b422bc77db0231",
            "filename": "src/transformers/models/auto/processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fprocessing_auto.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -75,6 +75,7 @@\n         (\"gemma3\", \"Gemma3Processor\"),\n         (\"gemma3n\", \"Gemma3nProcessor\"),\n         (\"git\", \"GitProcessor\"),\n+        (\"glm46v\", \"Glm46VProcessor\"),\n         (\"glm4v\", \"Glm4vProcessor\"),\n         (\"glm4v_moe\", \"Glm4vProcessor\"),\n         (\"got_ocr2\", \"GotOcr2Processor\"),"
        },
        {
            "sha": "afd9069f17ff0260f96004d83905bbde670c415c",
            "filename": "src/transformers/models/auto/tokenization_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Ftokenization_auto.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -308,6 +308,7 @@\n         (\"git\", (\"BertTokenizer\", \"BertTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"glm\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"glm4\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n+        (\"glm46v\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"glm4_moe\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"glm4v\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),\n         (\"glm4v_moe\", (None, \"PreTrainedTokenizerFast\" if is_tokenizers_available() else None)),"
        },
        {
            "sha": "217687e7fce1937593056e686e38fc3c696dcdda",
            "filename": "src/transformers/models/auto/video_processing_auto.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fauto%2Fvideo_processing_auto.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fauto%2Fvideo_processing_auto.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fauto%2Fvideo_processing_auto.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -53,6 +53,7 @@\n else:\n     VIDEO_PROCESSOR_MAPPING_NAMES = OrderedDict(\n         [\n+            (\"glm46v\", \"Glm46VVideoProcessor\"),\n             (\"glm4v\", \"Glm4vVideoProcessor\"),\n             (\"instructblip\", \"InstructBlipVideoVideoProcessor\"),\n             (\"instructblipvideo\", \"InstructBlipVideoVideoProcessor\"),"
        },
        {
            "sha": "c5bb0c40f19daf875bd6c95ccdf0ddd4366e2222",
            "filename": "src/transformers/models/glm46v/__init__.py",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm46v%2F__init__.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -0,0 +1,31 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+from typing import TYPE_CHECKING\n+\n+from ...utils import _LazyModule\n+from ...utils.import_utils import define_import_structure\n+\n+\n+if TYPE_CHECKING:\n+    from .configuration_glm46v import *\n+    from .image_processing_glm46v import *\n+    from .image_processing_glm46v_fast import *\n+    from .modeling_glm46v import *\n+    from .processing_glm46v import *\n+    from .video_processing_glm46v import *\n+else:\n+    import sys\n+\n+    _file = globals()[\"__file__\"]\n+    sys.modules[__name__] = _LazyModule(__name__, _file, define_import_structure(_file), module_spec=__spec__)"
        },
        {
            "sha": "125019940f13c9f8f4d9f33101a5ab0e4364ea1e",
            "filename": "src/transformers/models/glm46v/configuration_glm46v.py",
            "status": "added",
            "additions": 106,
            "deletions": 0,
            "changes": 106,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fconfiguration_glm46v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fconfiguration_glm46v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm46v%2Fconfiguration_glm46v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -0,0 +1,106 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/glm46v/modular_glm46v.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_glm46v.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\n+from ...configuration_utils import PreTrainedConfig\n+from ..auto import CONFIG_MAPPING, AutoConfig\n+\n+\n+class Glm46VConfig(PreTrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vModel`]. It is used to instantiate a\n+    GLM-4.6V model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of\n+    GLM-4.1V-9B-Thinking [zai-org/GLM-4.1V-9B-Thinking](https://huggingface.co/zai-org/GLM-4.1V-9B-Thinking).\n+\n+    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PreTrainedConfig`] for more information.\n+\n+    Args:\n+        text_config (`Union[PreTrainedConfig, dict]`, *optional*, defaults to `Glm4vTextConfig`):\n+            The config object or dictionary of the text backbone.\n+        vision_config (`Union[PreTrainedConfig, dict]`,  *optional*, defaults to `Glm4vVisionConfig`):\n+            The config object or dictionary of the vision backbone.\n+        image_token_id (`int`, *optional*, defaults to 151343):\n+            The image token index to encode the image prompt.\n+        video_token_id (`int`, *optional*, defaults to 151344):\n+            The video token index to encode the image prompt.\n+        image_start_token_id (`int`, *optional*, defaults to 151339):\n+            The image start token index to encode the start of image.\n+        image_end_token_id (`int`, *optional*, defaults to 151340):\n+            The image end token index to encode the end of image.\n+        video_start_token_id (`int`, *optional*, defaults to 151361):\n+            The video start token index to encode the start of video.\n+        video_end_token_id (`int`, *optional*, defaults to 151362):\n+            The video end token index to encode the end of video.\n+\n+    ```python\n+    >>> from transformers import Glm46VForConditionalGeneration, Glm46VConfig\n+\n+    >>> # Initializing a GLM-4.6V style configuration\n+    >>> configuration = Glm46VConfig()\n+\n+    >>> # Initializing a model from the GLM-4.6V style configuration\n+    >>> model = Glm4vForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"glm46v\"\n+    sub_configs = {\"text_config\": AutoConfig, \"vision_config\": AutoConfig}\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        text_config=None,\n+        vision_config=None,\n+        image_token_id=151343,\n+        video_token_id=151344,\n+        image_start_token_id=151339,\n+        image_end_token_id=151340,\n+        video_start_token_id=151361,\n+        video_end_token_id=151362,\n+        **kwargs,\n+    ):\n+        if isinstance(vision_config, dict):\n+            vision_config[\"model_type\"] = vision_config.get(\"model_type\", \"glm4v_vision\")\n+            self.vision_config = CONFIG_MAPPING[vision_config[\"model_type\"]](**vision_config)\n+        elif vision_config is None:\n+            self.vision_config = CONFIG_MAPPING[\"glm4v_vision\"]()\n+\n+        if isinstance(text_config, dict):\n+            text_config[\"model_type\"] = text_config.get(\"model_type\", \"glm4v_text\")\n+            self.text_config = CONFIG_MAPPING[text_config[\"model_type\"]](**text_config)\n+        elif text_config is None:\n+            self.text_config = CONFIG_MAPPING[\"glm4v_text\"]()\n+\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.video_start_token_id = video_start_token_id\n+        self.video_end_token_id = video_end_token_id\n+        self.image_start_token_id = image_start_token_id\n+        self.image_end_token_id = image_end_token_id\n+\n+        super().__init__(**kwargs)\n+\n+\n+__all__ = [\"Glm46VConfig\"]"
        },
        {
            "sha": "bb0f46f8b05207ff36eea10207c143a1f3ff3daa",
            "filename": "src/transformers/models/glm46v/image_processing_glm46v.py",
            "status": "added",
            "additions": 481,
            "deletions": 0,
            "changes": 481,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fimage_processing_glm46v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fimage_processing_glm46v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm46v%2Fimage_processing_glm46v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -0,0 +1,481 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/glm46v/modular_glm46v.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_glm46v.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import math\n+from typing import Optional, Union\n+\n+import numpy as np\n+\n+from ...image_processing_utils import BaseImageProcessor, BatchFeature\n+from ...image_transforms import convert_to_rgb, resize, to_channel_dimension_format\n+from ...image_utils import (\n+    OPENAI_CLIP_MEAN,\n+    OPENAI_CLIP_STD,\n+    ChannelDimension,\n+    ImageInput,\n+    PILImageResampling,\n+    get_image_size,\n+    infer_channel_dimension_format,\n+    is_scaled_image,\n+    make_flat_list_of_images,\n+    to_numpy_array,\n+    valid_images,\n+    validate_preprocess_arguments,\n+)\n+from ...processing_utils import ImagesKwargs\n+from ...utils import TensorType, logging\n+from ...video_utils import VideoInput\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Glm46VImageProcessorKwargs(ImagesKwargs, total=False):\n+    \"\"\"\n+    patch_size (`int`, *optional*, defaults to 14):\n+        The spatial patch size of the vision encoder.\n+    temporal_patch_size (`int`, *optional*, defaults to 2):\n+        The temporal patch size of the vision encoder.\n+    merge_size (`int`, *optional*, defaults to 2):\n+        The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    patch_size: int\n+    temporal_patch_size: int\n+    merge_size: int\n+\n+\n+def smart_resize(\n+    num_frames: int,\n+    height: int,\n+    width: int,\n+    temporal_factor: int = 2,\n+    factor: int = 28,\n+    min_pixels: int = 112 * 112,\n+    max_pixels: int = 14 * 14 * 2 * 2 * 2 * 6144,\n+):\n+    if num_frames < temporal_factor:\n+        raise ValueError(f\"t:{num_frames} must be larger than temporal_factor:{temporal_factor}\")\n+    if height < factor or width < factor:\n+        raise ValueError(f\"height:{height} or width:{width} must be larger than factor:{factor}\")\n+    elif max(height, width) / min(height, width) > 200:\n+        raise ValueError(\n+            f\"absolute aspect ratio must be smaller than 200, got {max(height, width) / min(height, width)}\"\n+        )\n+    h_bar = round(height / factor) * factor\n+    w_bar = round(width / factor) * factor\n+    t_bar = round(num_frames / temporal_factor) * temporal_factor\n+\n+    if t_bar * h_bar * w_bar > max_pixels:\n+        beta = math.sqrt((num_frames * height * width) / max_pixels)\n+        h_bar = max(factor, math.floor(height / beta / factor) * factor)\n+        w_bar = max(factor, math.floor(width / beta / factor) * factor)\n+    elif t_bar * h_bar * w_bar < min_pixels:\n+        beta = math.sqrt(min_pixels / (num_frames * height * width))\n+        h_bar = math.ceil(height * beta / factor) * factor\n+        w_bar = math.ceil(width * beta / factor) * factor\n+\n+    return h_bar, w_bar\n+\n+\n+class Glm46VImageProcessor(BaseImageProcessor):\n+    r\"\"\"\n+    Constructs a GLM-4V image processor that dynamically resizes images based on the original images.\n+\n+    Args:\n+        do_resize (`bool`, *optional*, defaults to `True`):\n+            Whether to resize the image's (height, width) dimensions.\n+        size (`Dict[str, int]` *optional*, defaults to `{\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 15000}`):\n+            Size of the image's `(height, width)` dimensions after resizing. Can be overridden by the `size` parameter\n+            in the `preprocess` method. Available options are:\n+                - `{\"height\": int, \"width\": int}`: The image will be resized to the exact size `(height, width)`.\n+                    Do NOT keep the aspect ratio.\n+                - `{\"shortest_edge\": int, \"longest_edge\": int}`: The image will be resized to a maximum size respecting\n+                    the aspect ratio and keeping the shortest edge less or equal to `shortest_edge` and the longest edge\n+                    less or equal to `longest_edge`.\n+                - `{\"max_height\": int, \"max_width\": int}`: The image will be resized to the maximum size respecting the\n+                    aspect ratio and keeping the height less or equal to `max_height` and the width less or equal to\n+                    `max_width`.\n+        resample (`PILImageResampling`, *optional*, defaults to `Resampling.BICUBIC`):\n+            Resampling filter to use when resizing the image.\n+        do_rescale (`bool`, *optional*, defaults to `True`):\n+            Whether to rescale the image by the specified scale `rescale_factor`.\n+        rescale_factor (`int` or `float`, *optional*, defaults to `1/255`):\n+            Scale factor to use if rescaling the image.\n+        do_normalize (`bool`, *optional*, defaults to `True`):\n+            Whether to normalize the image.\n+        image_mean (`float` or `List[float]`, *optional*, defaults to `[0.48145466, 0.4578275, 0.40821073]`):\n+            Mean to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        image_std (`float` or `List[float]`, *optional*, defaults to `[0.26862954, 0.26130258, 0.27577711]`):\n+            Standard deviation to use if normalizing the image. This is a float or list of floats for each channel in the image.\n+        do_convert_rgb (`bool`, *optional*, defaults to `True`):\n+            Whether to convert the image to RGB.\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spatial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The temporal patch size of the vision encoder.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+    \"\"\"\n+\n+    model_input_names = [\"pixel_values\", \"image_grid_thw\"]\n+    valid_kwargs = Glm46VImageProcessorKwargs\n+\n+    def __init__(\n+        self,\n+        do_resize: bool = True,\n+        size: Optional[dict[str, int]] = None,\n+        resample: PILImageResampling = PILImageResampling.BICUBIC,\n+        do_rescale: bool = True,\n+        rescale_factor: Union[int, float] = 1 / 255,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        do_convert_rgb: bool = True,\n+        patch_size: int = 14,\n+        temporal_patch_size: int = 2,\n+        merge_size: int = 2,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+        elif size is None:\n+            size = {\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 15000}\n+        self.size = size\n+\n+        self.do_resize = do_resize\n+        self.resample = resample\n+        self.do_rescale = do_rescale\n+        self.rescale_factor = rescale_factor\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean if image_mean is not None else OPENAI_CLIP_MEAN\n+        self.image_std = image_std if image_std is not None else OPENAI_CLIP_STD\n+\n+        self.patch_size = patch_size\n+        self.temporal_patch_size = temporal_patch_size\n+        self.merge_size = merge_size\n+        self.do_convert_rgb = do_convert_rgb\n+\n+    def _preprocess(\n+        self,\n+        images: Union[ImageInput, VideoInput],\n+        do_resize: Optional[bool] = None,\n+        size: Optional[dict[str, int]] = None,\n+        resample: Optional[PILImageResampling] = None,\n+        do_rescale: Optional[bool] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        do_convert_rgb: Optional[bool] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n+\n+        Args:\n+            images (`ImageInput`):\n+                Image or batch of images to preprocess. Expects pixel values ranging from 0 to 255. If pixel values range from 0 to 1, set `do_rescale=False`.\n+            vision_info (`List[Dict]`, *optional*):\n+                Optional list of dictionaries containing additional information about vision inputs.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. `shortest_edge` and `longest_edge` keys must be present.\n+            resample (`PILImageResampling`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the `PILImageResampling` enums.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Scale factor to use if rescaling the image.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Mean to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Standard deviation to use if normalizing the image. Can be a float or a list of floats corresponding to the number of channels in the image.\n+            patch_size (`int`, *optional*, defaults to `self.patch_size`):\n+                The spatial patch size of the vision encoder.\n+            temporal_patch_size (`int`, *optional*, defaults to `self.temporal_patch_size`):\n+                The temporal patch size of the vision encoder.\n+            merge_size (`int`, *optional*, defaults to `self.merge_size`):\n+                The merge size of the vision encoder to llm encoder.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            data_format (`ChannelDimension`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.   - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+        \"\"\"\n+        images = make_flat_list_of_images(images)\n+\n+        if do_convert_rgb:\n+            images = [convert_to_rgb(image) for image in images]\n+\n+        # All transformations expect numpy arrays.\n+        images = [to_numpy_array(image) for image in images]\n+\n+        if do_rescale and is_scaled_image(images[0]):\n+            logger.warning_once(\n+                \"It looks like you are trying to rescale already rescaled images. If the input\"\n+                \" images have pixel values between 0 and 1, set `do_rescale=False` to avoid rescaling them again.\"\n+            )\n+        if input_data_format is None:\n+            # We assume that all images have the same channel dimension format.\n+            input_data_format = infer_channel_dimension_format(images[0])\n+\n+        height, width = get_image_size(images[0], channel_dim=input_data_format)\n+        resized_height, resized_width = height, width\n+        processed_images = []\n+        for image in images:\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    num_frames=temporal_patch_size,\n+                    height=height,\n+                    width=width,\n+                    temporal_factor=temporal_patch_size,\n+                    factor=patch_size * merge_size,\n+                    min_pixels=size[\"shortest_edge\"],\n+                    max_pixels=size[\"longest_edge\"],\n+                )\n+                image = resize(\n+                    image, size=(resized_height, resized_width), resample=resample, input_data_format=input_data_format\n+                )\n+\n+            if do_rescale:\n+                image = self.rescale(image, scale=rescale_factor, input_data_format=input_data_format)\n+\n+            if do_normalize:\n+                image = self.normalize(\n+                    image=image, mean=image_mean, std=image_std, input_data_format=input_data_format\n+                )\n+\n+            image = to_channel_dimension_format(image, data_format, input_channel_dim=input_data_format)\n+            processed_images.append(image)\n+\n+        patches = np.array(processed_images)\n+        if data_format == ChannelDimension.LAST:\n+            patches = patches.transpose(0, 3, 1, 2)\n+        if patches.shape[0] % temporal_patch_size != 0:\n+            repeats = np.repeat(\n+                patches[-1][np.newaxis], temporal_patch_size - (patches.shape[0] % temporal_patch_size), axis=0\n+            )\n+            patches = np.concatenate([patches, repeats], axis=0)\n+        channel = patches.shape[1]\n+        grid_t = patches.shape[0] // temporal_patch_size\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+        patches = patches.reshape(\n+            grid_t,\n+            temporal_patch_size,\n+            channel,\n+            grid_h // merge_size,\n+            merge_size,\n+            patch_size,\n+            grid_w // merge_size,\n+            merge_size,\n+            patch_size,\n+        )\n+        patches = patches.transpose(0, 3, 6, 4, 7, 2, 1, 5, 8)\n+        flatten_patches = patches.reshape(\n+            grid_t * grid_h * grid_w, channel * temporal_patch_size * patch_size * patch_size\n+        )\n+\n+        return flatten_patches, (grid_t, grid_h, grid_w)\n+\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        do_resize: Optional[bool] = None,\n+        size: Optional[dict[str, int]] = None,\n+        resample: Optional[PILImageResampling] = None,\n+        do_rescale: Optional[bool] = None,\n+        rescale_factor: Optional[float] = None,\n+        do_normalize: Optional[bool] = None,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        do_convert_rgb: Optional[bool] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        data_format: Optional[ChannelDimension] = ChannelDimension.FIRST,\n+        input_data_format: Optional[Union[str, ChannelDimension]] = None,\n+    ):\n+        \"\"\"\n+        Args:\n+            images (`ImageInput`):\n+                Image to preprocess. Expects a single or batch of images with pixel values ranging from 0 to 255. If\n+                passing in images with pixel values between 0 and 1, set `do_rescale=False`.\n+            do_resize (`bool`, *optional*, defaults to `self.do_resize`):\n+                Whether to resize the image.\n+            size (`Dict[str, int]`, *optional*, defaults to `self.size`):\n+                Size of the image after resizing. Shortest edge of the image is resized to size[\"shortest_edge\"], with\n+                the longest edge resized to keep the input aspect ratio.\n+            resample (`int`, *optional*, defaults to `self.resample`):\n+                Resampling filter to use if resizing the image. This can be one of the enum `PILImageResampling`. Only\n+                has an effect if `do_resize` is set to `True`.\n+            do_rescale (`bool`, *optional*, defaults to `self.do_rescale`):\n+                Whether to rescale the image.\n+            rescale_factor (`float`, *optional*, defaults to `self.rescale_factor`):\n+                Rescale factor to rescale the image by if `do_rescale` is set to `True`.\n+            do_normalize (`bool`, *optional*, defaults to `self.do_normalize`):\n+                Whether to normalize the image.\n+            image_mean (`float` or `List[float]`, *optional*, defaults to `self.image_mean`):\n+                Image mean to use for normalization. Only has an effect if `do_normalize` is set to `True`.\n+            image_std (`float` or `List[float]`, *optional*, defaults to `self.image_std`):\n+                Image standard deviation to use for normalization. Only has an effect if `do_normalize` is set to\n+                `True`.\n+                The max pixels of the image to resize the image.\n+            patch_size (`int`, *optional*, defaults to `self.patch_size`):\n+                The spatial patch size of the vision encoder.\n+            temporal_patch_size (`int`, *optional*, defaults to `self.temporal_patch_size`):\n+                The temporal patch size of the vision encoder.\n+            merge_size (`int`, *optional*, defaults to `self.merge_size`):\n+                The merge size of the vision encoder to llm encoder.\n+            do_convert_rgb (`bool`, *optional*, defaults to `self.do_convert_rgb`):\n+                Whether to convert the image to RGB.\n+            return_tensors (`str` or `TensorType`, *optional*):\n+                The type of tensors to return. Can be one of:\n+                - Unset: Return a list of `np.ndarray`.\n+                - `TensorType.PYTORCH` or `'pt'`: Return a batch of type `torch.Tensor`.\n+                - `TensorType.NUMPY` or `'np'`: Return a batch of type `np.ndarray`.\n+            data_format (`ChannelDimension` or `str`, *optional*, defaults to `ChannelDimension.FIRST`):\n+                The channel dimension format for the output image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - Unset: Use the channel dimension format of the input image.\n+            input_data_format (`ChannelDimension` or `str`, *optional*):\n+                The channel dimension format for the input image. If unset, the channel dimension format is inferred\n+                from the input image. Can be one of:\n+                - `\"channels_first\"` or `ChannelDimension.FIRST`: image in (num_channels, height, width) format.\n+                - `\"channels_last\"` or `ChannelDimension.LAST`: image in (height, width, num_channels) format.\n+                - `\"none\"` or `ChannelDimension.NONE`: image in (height, width) format.\n+\n+        \"\"\"\n+        # Try to use config values if set, otherwise fallback to global defaults\n+        size = size if size is not None else self.size\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+        elif size is None:\n+            size = {\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 15000}\n+\n+        do_resize = do_resize if do_resize is not None else self.do_resize\n+        resample = resample if resample is not None else self.resample\n+        do_rescale = do_rescale if do_rescale is not None else self.do_rescale\n+        rescale_factor = rescale_factor if rescale_factor is not None else self.rescale_factor\n+        do_normalize = do_normalize if do_normalize is not None else self.do_normalize\n+        image_mean = image_mean if image_mean is not None else self.image_mean\n+        image_std = image_std if image_std is not None else self.image_std\n+        patch_size = patch_size if patch_size is not None else self.patch_size\n+        temporal_patch_size = temporal_patch_size if temporal_patch_size is not None else self.temporal_patch_size\n+        merge_size = merge_size if merge_size is not None else self.merge_size\n+        do_convert_rgb = do_convert_rgb if do_convert_rgb is not None else self.do_convert_rgb\n+\n+        if images is not None:\n+            images = self.fetch_images(images)\n+            images = make_flat_list_of_images(images)\n+\n+        if images is not None and not valid_images(images):\n+            raise ValueError(\"Invalid image type. Must be of type PIL.Image.Image, numpy.ndarray, or torch.Tensor\")\n+\n+        validate_preprocess_arguments(\n+            rescale_factor=rescale_factor,\n+            do_normalize=do_normalize,\n+            image_mean=image_mean,\n+            image_std=image_std,\n+            do_resize=do_resize,\n+            size=size,\n+            resample=resample,\n+        )\n+\n+        data = {}\n+        if images is not None:\n+            pixel_values, vision_grid_thws = [], []\n+            for image in images:\n+                patches, image_grid_thw = self._preprocess(\n+                    image,\n+                    do_resize=do_resize,\n+                    size=size,\n+                    resample=resample,\n+                    do_rescale=do_rescale,\n+                    rescale_factor=rescale_factor,\n+                    do_normalize=do_normalize,\n+                    image_mean=image_mean,\n+                    image_std=image_std,\n+                    patch_size=patch_size,\n+                    temporal_patch_size=temporal_patch_size,\n+                    merge_size=merge_size,\n+                    data_format=data_format,\n+                    do_convert_rgb=do_convert_rgb,\n+                    input_data_format=input_data_format,\n+                )\n+                pixel_values.extend(patches)\n+                vision_grid_thws.append(image_grid_thw)\n+            pixel_values = np.array(pixel_values)\n+            vision_grid_thws = np.array(vision_grid_thws)\n+            data.update({\"pixel_values\": pixel_values, \"image_grid_thw\": vision_grid_thws})\n+\n+        return BatchFeature(data=data, tensor_type=return_tensors)\n+\n+    def get_number_of_image_patches(self, height: int, width: int, images_kwargs=None):\n+        \"\"\"\n+        A utility that returns number of image patches for a given image size.\n+\n+        Args:\n+            height (`int`):\n+                Height of the input image.\n+            width (`int`):\n+                Width of the input image.\n+            images_kwargs (`dict`, *optional*)\n+                Any kwargs to override defaults of the image processor.\n+        Returns:\n+            `int`: Number of image patches per image.\n+        \"\"\"\n+        patch_size = images_kwargs.get(\"patch_size\", self.patch_size)\n+        merge_size = images_kwargs.get(\"merge_size\", self.merge_size)\n+        size = images_kwargs.get(\"size\", {\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 15000})\n+\n+        factor = patch_size * merge_size\n+        resized_height, resized_width = smart_resize(\n+            num_frames=self.temporal_patch_size,\n+            height=height,\n+            width=width,\n+            factor=factor,\n+            min_pixels=size[\"shortest_edge\"],\n+            max_pixels=size[\"longest_edge\"],\n+            temporal_factor=self.temporal_patch_size,\n+        )\n+        grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+        return grid_h * grid_w\n+\n+\n+__all__ = [\"Glm46VImageProcessor\"]"
        },
        {
            "sha": "f86b78153783370d3f75a31c292146285f337abb",
            "filename": "src/transformers/models/glm46v/image_processing_glm46v_fast.py",
            "status": "added",
            "additions": 183,
            "deletions": 0,
            "changes": 183,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fimage_processing_glm46v_fast.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fimage_processing_glm46v_fast.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm46v%2Fimage_processing_glm46v_fast.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -0,0 +1,183 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/glm46v/modular_glm46v.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_glm46v.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import Optional, Union\n+\n+import torch\n+from torchvision.transforms.v2 import functional as F\n+\n+from ...image_processing_utils import BatchFeature\n+from ...image_processing_utils_fast import BaseImageProcessorFast, group_images_by_shape, reorder_images\n+from ...image_utils import OPENAI_CLIP_MEAN, OPENAI_CLIP_STD, ImageInput, PILImageResampling, SizeDict\n+from ...processing_utils import Unpack\n+from ...utils import TensorType, auto_docstring\n+from .image_processing_glm46v import Glm46VImageProcessorKwargs, smart_resize\n+\n+\n+@auto_docstring\n+class Glm46VImageProcessorFast(BaseImageProcessorFast):\n+    do_resize = True\n+    resample = PILImageResampling.BICUBIC\n+    size = {\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 15000}\n+    do_rescale = True\n+    do_normalize = True\n+    image_mean = OPENAI_CLIP_MEAN\n+    image_std = OPENAI_CLIP_STD\n+    do_convert_rgb = True\n+    patch_size = 14\n+    temporal_patch_size = 2\n+    merge_size = 2\n+    valid_kwargs = Glm46VImageProcessorKwargs\n+    model_input_names = [\"pixel_values\", \"image_grid_thw\"]\n+\n+    def __init__(self, **kwargs: Unpack[Glm46VImageProcessorKwargs]):\n+        super().__init__(**kwargs)\n+        if self.size is not None and (\n+            self.size.get(\"shortest_edge\", None) is None or self.size.get(\"longest_edge\", None) is None\n+        ):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+\n+    def _further_process_kwargs(\n+        self,\n+        size: Optional[SizeDict] = None,\n+        **kwargs,\n+    ) -> dict:\n+        \"\"\"\n+        Update kwargs that need further processing before being validated\n+        Can be overridden by subclasses to customize the processing of kwargs.\n+        \"\"\"\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+\n+        return super()._further_process_kwargs(size=size, **kwargs)\n+\n+    def _preprocess(\n+        self,\n+        images: list[\"torch.Tensor\"],\n+        do_resize: bool,\n+        size: SizeDict,\n+        interpolation: Optional[\"F.InterpolationMode\"],\n+        do_rescale: bool,\n+        rescale_factor: float,\n+        do_normalize: bool,\n+        image_mean: Optional[Union[float, list[float]]],\n+        image_std: Optional[Union[float, list[float]]],\n+        patch_size: int,\n+        temporal_patch_size: int,\n+        merge_size: int,\n+        disable_grouping: Optional[bool],\n+        return_tensors: Optional[Union[str, TensorType]],\n+        **kwargs,\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Preprocess an image or batch of images. Copy of the `preprocess` method from `CLIPImageProcessor`.\n+        \"\"\"\n+\n+        grouped_images, grouped_images_index = group_images_by_shape(images, disable_grouping=disable_grouping)\n+        resized_images_grouped = {}\n+        for shape, stacked_images in grouped_images.items():\n+            height, width = stacked_images.shape[-2:]\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    num_frames=temporal_patch_size,\n+                    height=height,\n+                    width=width,\n+                    temporal_factor=temporal_patch_size,\n+                    factor=patch_size * merge_size,\n+                    min_pixels=size.shortest_edge,\n+                    max_pixels=size.longest_edge,\n+                )\n+                stacked_images = self.resize(\n+                    stacked_images,\n+                    size=SizeDict(height=resized_height, width=resized_width),\n+                    interpolation=interpolation,\n+                )\n+            resized_images_grouped[shape] = stacked_images\n+\n+        resized_images = reorder_images(resized_images_grouped, grouped_images_index)\n+\n+        grouped_images, grouped_images_index = group_images_by_shape(resized_images, disable_grouping=disable_grouping)\n+        processed_images_grouped = {}\n+        processed_grids = {}\n+\n+        for shape, stacked_images in grouped_images.items():\n+            resized_height, resized_width = stacked_images.shape[-2:]\n+\n+            patches = self.rescale_and_normalize(\n+                stacked_images, do_rescale, rescale_factor, do_normalize, image_mean, image_std\n+            )\n+            if patches.ndim == 4:  # (B, C, H, W)\n+                patches = patches.unsqueeze(1)  # (B, T=1, C, H, W)\n+\n+            if patches.shape[1] % temporal_patch_size != 0:\n+                repeats = patches[:, -1:].repeat(\n+                    1, temporal_patch_size - (patches.shape[1] % temporal_patch_size), 1, 1, 1\n+                )\n+                patches = torch.cat([patches, repeats], dim=1)\n+\n+            batch_size, t_len, channel = patches.shape[:3]\n+            grid_t = t_len // temporal_patch_size\n+            grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+\n+            patches = patches.view(\n+                batch_size,\n+                grid_t,\n+                temporal_patch_size,\n+                channel,\n+                grid_h // merge_size,\n+                merge_size,\n+                patch_size,\n+                grid_w // merge_size,\n+                merge_size,\n+                patch_size,\n+            )\n+            # (B, grid_t, gh, gw, mh, mw, C, tp, ph, pw)\n+            patches = patches.permute(0, 1, 4, 7, 5, 8, 3, 2, 6, 9)\n+\n+            flatten_patches = patches.reshape(\n+                batch_size,\n+                grid_t * grid_h * grid_w,\n+                channel * temporal_patch_size * patch_size * patch_size,\n+            )\n+\n+            processed_images_grouped[shape] = flatten_patches\n+            processed_grids[shape] = [[grid_t, grid_h, grid_w]] * batch_size\n+\n+        processed_images = reorder_images(processed_images_grouped, grouped_images_index)\n+        processed_grids = reorder_images(processed_grids, grouped_images_index)\n+\n+        pixel_values = torch.cat(processed_images, dim=0)\n+        image_grid_thw = torch.tensor(processed_grids)\n+\n+        return BatchFeature(\n+            data={\"pixel_values\": pixel_values, \"image_grid_thw\": image_grid_thw}, tensor_type=return_tensors\n+        )\n+\n+    @auto_docstring\n+    def preprocess(\n+        self,\n+        images: ImageInput,\n+        **kwargs: Unpack[Glm46VImageProcessorKwargs],\n+    ) -> BatchFeature:\n+        return super().preprocess(images, **kwargs)\n+\n+\n+__all__ = [\"Glm46VImageProcessorFast\"]"
        },
        {
            "sha": "7fc18482c4da11099e3b8952059ca11e7366d712",
            "filename": "src/transformers/models/glm46v/modeling_glm46v.py",
            "status": "added",
            "additions": 835,
            "deletions": 0,
            "changes": 835,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fmodeling_glm46v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fmodeling_glm46v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm46v%2Fmodeling_glm46v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -0,0 +1,835 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/glm46v/modular_glm46v.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_glm46v.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import itertools\n+from dataclasses import dataclass\n+from typing import Any, Optional, Union\n+\n+import torch\n+import torch.nn as nn\n+\n+from ...cache_utils import Cache\n+from ...generation import GenerationMixin\n+from ...modeling_outputs import ModelOutput\n+from ...modeling_utils import PreTrainedModel\n+from ...processing_utils import Unpack\n+from ...utils import TransformersKwargs, auto_docstring, can_return_tuple, is_torchdynamo_compiling\n+from ..auto import AutoModel\n+from .configuration_glm46v import Glm46VConfig\n+\n+\n+@auto_docstring\n+class Glm46VPreTrainedModel(PreTrainedModel):\n+    config: Glm46VConfig\n+    base_model_prefix = \"model\"\n+    input_modalities = [\"image\", \"video\", \"text\"]\n+    supports_gradient_checkpointing = True\n+    _no_split_modules = None\n+    _skip_keys_device_placement = \"past_key_values\"\n+    _supports_flash_attn = True\n+    _supports_sdpa = True\n+\n+    _can_compile_fullgraph = True\n+    _supports_attention_backend = True\n+    _can_record_outputs = None\n+\n+\n+@dataclass\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    Base class for Llava outputs, with hidden states and attentions.\n+    \"\"\"\n+)\n+class Glm46VModelOutputWithPast(ModelOutput):\n+    r\"\"\"\n+    past_key_values (`Cache`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+        It is a [`~cache_utils.Cache`] instance. For more details, see our [kv cache guide](https://huggingface.co/docs/transformers/en/kv_cache).\n+\n+        Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+        `past_key_values` input) to speed up sequential decoding.\n+    rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+        The rope index difference between sequence length and multimodal rope.\n+    \"\"\"\n+\n+    last_hidden_state: Optional[torch.FloatTensor] = None\n+    past_key_values: Optional[Cache] = None\n+    hidden_states: Optional[tuple[torch.FloatTensor]] = None\n+    attentions: Optional[tuple[torch.FloatTensor]] = None\n+    rope_deltas: Optional[torch.LongTensor] = None\n+\n+\n+@auto_docstring\n+class Glm46VModel(Glm46VPreTrainedModel):\n+    base_model_prefix = \"\"\n+    _checkpoint_conversion_mapping = {}\n+    # Reference: fix gemma3 grad acc #37208\n+    accepts_loss_kwargs = False\n+    config: Glm46VConfig\n+    _no_split_modules = None\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.visual = AutoModel.from_config(config.vision_config)\n+        self.language_model = AutoModel.from_config(config.text_config)\n+        self.rope_deltas = None  # cache rope_deltas here\n+\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.language_model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.language_model.set_input_embeddings(value)\n+\n+    def set_decoder(self, decoder):\n+        self.language_model = decoder\n+\n+    def get_decoder(self):\n+        return self.language_model\n+\n+    def get_rope_index(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Calculate the 3D rope index based on image and video's temporal, height and width in LLM.\n+\n+        Explanation:\n+            Each embedding sequence contains vision embedding and text embedding or just contains text embedding.\n+\n+            For pure text embedding sequence, the rotary position embedding has no difference with modern LLMs.\n+            Examples:\n+                input_ids: [T T T T T], here T is for text.\n+                temporal position_ids: [0, 1, 2, 3, 4]\n+                height position_ids: [0, 1, 2, 3, 4]\n+                width position_ids: [0, 1, 2, 3, 4]\n+\n+            For vision and text embedding sequence, we calculate 3D rotary position embedding for vision part\n+            and 1D rotary position embedding for text part.\n+            Examples:\n+                Temporal (Time): 3 patches, representing different segments of the video in time.\n+                Height: 2 patches, dividing each frame vertically.\n+                Width: 2 patches, dividing each frame horizontally.\n+                We also have some important parameters:\n+                fps (Frames Per Second): The video's frame rate, set to 1. This means one frame is processed each second.\n+                tokens_per_second: This is a crucial parameter. It dictates how many \"time-steps\" or \"temporal tokens\" are conceptually packed into a one-second interval of the video. In this case, we have 25 tokens per second. So each second of the video will be represented with 25 separate time points. It essentially defines the temporal granularity.\n+                temporal_patch_size: The number of frames that compose one temporal patch. Here, it's 2 frames.\n+                interval: The step size for the temporal position IDs, calculated as tokens_per_second * temporal_patch_size / fps. In this case, 25 * 2 / 1 = 50. This means that each temporal patch will be have a difference of 50 in the temporal position IDs.\n+                input_ids: [V V V V V V V V V V V V T T T T T], here V is for vision.\n+                vision temporal position_ids: [0, 0, 0, 0, 50, 50, 50, 50, 100, 100, 100, 100]\n+                vision height position_ids: [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]\n+                vision width position_ids: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n+                text temporal position_ids: [101, 102, 103, 104, 105]\n+                text height position_ids: [101, 102, 103, 104, 105]\n+                text width position_ids: [101, 102, 103, 104, 105]\n+                Here we calculate the text start position_ids as the max vision position_ids plus 1.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary. Padding will be ignored by default should you provide\n+                it.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+            attention_mask (`torch.Tensor` of shape `(batch_size, sequence_length)`, *optional*):\n+                Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n+\n+                - 1 for tokens that are **not masked**,\n+                - 0 for tokens that are **masked**.\n+\n+        Returns:\n+            position_ids (`torch.LongTensor` of shape `(3, batch_size, sequence_length)`)\n+            mrope_position_deltas (`torch.Tensor` of shape `(batch_size)`)\n+        \"\"\"\n+\n+        spatial_merge_size = self.config.vision_config.spatial_merge_size\n+        image_token_id = self.config.image_token_id\n+        video_start_token_id = self.config.video_start_token_id\n+        video_end_token_id = self.config.video_end_token_id\n+\n+        mrope_position_deltas = []\n+        if input_ids is not None and (image_grid_thw is not None or video_grid_thw is not None):\n+            total_input_ids = input_ids\n+            if attention_mask is None:\n+                attention_mask = torch.ones_like(total_input_ids)\n+            position_ids = torch.ones(\n+                3,\n+                input_ids.shape[0],\n+                input_ids.shape[1],\n+                dtype=input_ids.dtype,\n+                device=input_ids.device,\n+            )\n+            image_index, video_index = 0, 0\n+            video_group_index = 0\n+            attention_mask = attention_mask.to(total_input_ids.device)\n+            for i, input_ids in enumerate(total_input_ids):\n+                input_ids = input_ids[attention_mask[i] == 1]\n+                input_tokens = input_ids.tolist()\n+\n+                input_token_type = []\n+                video_check_flg = False\n+                for token in input_tokens:\n+                    if token == video_start_token_id:\n+                        video_check_flg = True\n+                    elif token == video_end_token_id:\n+                        video_check_flg = False\n+\n+                    if token == image_token_id and not video_check_flg:\n+                        input_token_type.append(\"image\")\n+                    elif token == image_token_id and video_check_flg:\n+                        input_token_type.append(\"video\")\n+                    else:\n+                        input_token_type.append(\"text\")\n+\n+                input_type_group = []\n+                for key, group in itertools.groupby(enumerate(input_token_type), lambda x: x[1]):\n+                    group = list(group)\n+                    start_index = group[0][0]\n+                    end_index = group[-1][0] + 1\n+                    input_type_group.append((key, start_index, end_index))\n+\n+                llm_pos_ids_list = []\n+                video_frame_num = 1\n+                for modality_type, start_idx, end_idx in input_type_group:\n+                    st_idx = llm_pos_ids_list[-1].max() + 1 if len(llm_pos_ids_list) > 0 else 0\n+\n+                    if modality_type == \"image\":\n+                        t, h, w = (\n+                            image_grid_thw[image_index][0],\n+                            image_grid_thw[image_index][1],\n+                            image_grid_thw[image_index][2],\n+                        )\n+                        llm_grid_t, llm_grid_h, llm_grid_w = (\n+                            t.item(),\n+                            h.item() // spatial_merge_size,\n+                            w.item() // spatial_merge_size,\n+                        )\n+\n+                        t_index = torch.arange(llm_grid_t).view(-1, 1).expand(-1, llm_grid_h * llm_grid_w).flatten()\n+                        h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(llm_grid_t, -1, llm_grid_w).flatten()\n+                        w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(llm_grid_t, llm_grid_h, -1).flatten()\n+                        llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + st_idx)\n+\n+                        image_index += 1\n+                        video_frame_num = 1\n+\n+                    elif modality_type == \"video\":\n+                        t, h, w = (\n+                            video_frame_num,\n+                            video_grid_thw[video_index][1],\n+                            video_grid_thw[video_index][2],\n+                        )\n+\n+                        llm_grid_t, llm_grid_h, llm_grid_w = (\n+                            t,\n+                            h.item() // spatial_merge_size,\n+                            w.item() // spatial_merge_size,\n+                        )\n+\n+                        for t_idx in range(llm_grid_t):\n+                            t_index = torch.tensor(t_idx).view(-1, 1).expand(-1, llm_grid_h * llm_grid_w).flatten()\n+\n+                            h_index = torch.arange(llm_grid_h).view(1, -1, 1).expand(1, -1, llm_grid_w).flatten()\n+                            w_index = torch.arange(llm_grid_w).view(1, 1, -1).expand(1, llm_grid_h, -1).flatten()\n+                            llm_pos_ids_list.append(torch.stack([t_index, h_index, w_index]) + st_idx)\n+\n+                        video_group_index += 1\n+\n+                        if video_group_index >= video_grid_thw[video_index][0]:\n+                            video_index += 1\n+                            video_group_index = 0\n+\n+                        video_frame_num += 1\n+\n+                    else:\n+                        text_len = end_idx - start_idx\n+                        llm_pos_ids_list.append(torch.arange(text_len).view(1, -1).expand(3, -1) + st_idx)\n+\n+                        video_frame_num = 1\n+\n+                llm_positions = torch.cat(llm_pos_ids_list, dim=1).reshape(3, -1)\n+                position_ids[..., i, attention_mask[i] == 1] = llm_positions.to(position_ids.device)\n+                mrope_position_deltas.append(llm_positions.max() + 1 - len(total_input_ids[i]))\n+            mrope_position_deltas = torch.tensor(mrope_position_deltas, device=input_ids.device).unsqueeze(1)\n+            return position_ids, mrope_position_deltas\n+        else:\n+            if attention_mask is not None:\n+                position_ids = attention_mask.long().cumsum(-1) - 1\n+                position_ids.masked_fill_(attention_mask == 0, 1)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1).to(attention_mask.device)\n+                max_position_ids = position_ids.max(0, keepdim=False)[0].max(-1, keepdim=True)[0]\n+                mrope_position_deltas = max_position_ids + 1 - attention_mask.shape[-1]\n+            else:\n+                position_ids = (\n+                    torch.arange(input_ids.shape[1], device=input_ids.device)\n+                    .view(1, 1, -1)\n+                    .expand(3, input_ids.shape[0], -1)\n+                )\n+                mrope_position_deltas = torch.zeros(\n+                    [input_ids.shape[0], 1],\n+                    device=input_ids.device,\n+                    dtype=input_ids.dtype,\n+                )\n+\n+            return position_ids, mrope_position_deltas\n+\n+    def get_video_features(\n+        self, pixel_values_videos: torch.FloatTensor, video_grid_thw: Optional[torch.LongTensor] = None\n+    ):\n+        \"\"\"\n+        Encodes videos into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values_videos (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input videos.\n+            video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each video in LLM.\n+        \"\"\"\n+        pixel_values_videos = pixel_values_videos.type(self.visual.dtype)\n+        # reshape video_grid_thw -> [b, 3] -> [1, h, w] * frames\n+        temp_frames_hw = []\n+        for t, h, w in video_grid_thw:\n+            repeated_row = torch.tensor([1, h.item(), w.item()]).unsqueeze(0).repeat(t, 1)\n+            temp_frames_hw.append(repeated_row)\n+        flattened_video_grid_thw = torch.cat(temp_frames_hw, dim=0)\n+        video_embeds = self.visual(pixel_values_videos, grid_thw=flattened_video_grid_thw)\n+        split_sizes = (video_grid_thw.prod(-1) // self.visual.spatial_merge_size**2).tolist()\n+        video_embeds = torch.split(video_embeds, split_sizes)\n+        return video_embeds\n+\n+    def get_image_features(self, pixel_values: torch.FloatTensor, image_grid_thw: Optional[torch.LongTensor] = None):\n+        \"\"\"\n+        Encodes images into continuous embeddings that can be forwarded to the language model.\n+\n+        Args:\n+            pixel_values (`torch.FloatTensor` of shape `(batch_size, num_channels, image_size, image_size)`):\n+                The tensors corresponding to the input images.\n+            image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+                The temporal, height and width of feature shape of each image in LLM.\n+        \"\"\"\n+        pixel_values = pixel_values.type(self.visual.dtype)\n+        image_embeds = self.visual(pixel_values, grid_thw=image_grid_thw)\n+        split_sizes = (image_grid_thw.prod(-1) // self.visual.spatial_merge_size**2).tolist()\n+        image_embeds = torch.split(image_embeds, split_sizes)\n+        return image_embeds\n+\n+    def get_placeholder_mask(\n+        self,\n+        input_ids: torch.LongTensor,\n+        inputs_embeds: torch.FloatTensor,\n+        image_features: Optional[torch.FloatTensor] = None,\n+        video_features: Optional[torch.FloatTensor] = None,\n+    ):\n+        \"\"\"\n+        Obtains multimodal placeholder mask from `input_ids` or `inputs_embeds`, and checks that the placeholder token count is\n+        equal to the length of multimodal features. If the lengths are different, an error is raised.\n+        \"\"\"\n+        if input_ids is None:\n+            special_image_mask = inputs_embeds == self.get_input_embeddings()(\n+                torch.tensor(self.config.image_token_id, dtype=torch.long, device=inputs_embeds.device)\n+            )\n+            special_image_mask = special_image_mask.all(-1)\n+            special_video_mask = inputs_embeds == self.get_input_embeddings()(\n+                torch.tensor(self.config.video_token_id, dtype=torch.long, device=inputs_embeds.device)\n+            )\n+            special_video_mask = special_video_mask.all(-1)\n+        else:\n+            # GLM-4.1V and GLM-4.5V special_video_mask is special_image_mask\n+            special_image_mask = input_ids == self.config.image_token_id\n+            special_video_mask = input_ids == self.config.image_token_id\n+\n+        n_image_tokens = special_image_mask.sum()\n+        special_image_mask = special_image_mask.unsqueeze(-1).expand_as(inputs_embeds).to(inputs_embeds.device)\n+        if image_features is not None and inputs_embeds[special_image_mask].numel() != image_features.numel():\n+            raise ValueError(\n+                f\"Image features and image tokens do not match: tokens: {n_image_tokens}, features {image_features.shape[0]}\"\n+            )\n+\n+        n_video_tokens = special_video_mask.sum()\n+        special_video_mask = special_video_mask.unsqueeze(-1).expand_as(inputs_embeds).to(inputs_embeds.device)\n+        if video_features is not None and inputs_embeds[special_video_mask].numel() != video_features.numel():\n+            raise ValueError(\n+                f\"Videos features and video tokens do not match: tokens: {n_video_tokens}, features {video_features.shape[0]}\"\n+            )\n+\n+        return special_image_mask, special_video_mask\n+\n+    @auto_docstring\n+    @can_return_tuple\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        rope_deltas: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, Glm46VModelOutputWithPast]:\n+        r\"\"\"\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+        rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+            The rope index difference between sequence length and multimodal rope.\n+        \"\"\"\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.get_input_embeddings()(input_ids)\n+\n+        if pixel_values is not None:\n+            image_embeds = self.get_image_features(pixel_values, image_grid_thw)\n+            image_embeds = torch.cat(image_embeds, dim=0).to(inputs_embeds.device, inputs_embeds.dtype)\n+            image_mask, _ = self.get_placeholder_mask(input_ids, inputs_embeds, image_features=image_embeds)\n+            inputs_embeds = inputs_embeds.masked_scatter(image_mask, image_embeds)\n+\n+        if pixel_values_videos is not None:\n+            video_embeds = self.get_video_features(pixel_values_videos, video_grid_thw)\n+            video_embeds = torch.cat(video_embeds, dim=0).to(inputs_embeds.device, inputs_embeds.dtype)\n+            _, video_mask = self.get_placeholder_mask(input_ids, inputs_embeds, video_features=video_embeds)\n+            inputs_embeds = inputs_embeds.masked_scatter(video_mask, video_embeds)\n+\n+        if position_ids is None:\n+            attention_mask_tensor = (\n+                attention_mask if not isinstance(attention_mask, dict) else attention_mask[\"full_attention\"]\n+            )\n+            if attention_mask_tensor is not None and attention_mask_tensor.ndim == 4:\n+                attention_mask_tensor = torch.diagonal(attention_mask_tensor[:, 0], dim1=1, dim2=2)\n+                # Only apply conversion for floating point tensors (inverted masks)\n+                if attention_mask_tensor.dtype.is_floating_point:\n+                    attention_mask_tensor = attention_mask_tensor / torch.finfo(attention_mask_tensor.dtype).min\n+                    attention_mask_tensor = (1.0 - attention_mask_tensor).int()\n+\n+            # Calculate RoPE index once per generation in the pre-fill stage only.\n+            # When compiling, we can't check tensor values thus we check only input length\n+            # It is safe to assume that `length!=1` means we're in pre-fill because compiled\n+            # models currently cannot do asssisted decoding\n+            prefill_compiled_stage = is_torchdynamo_compiling() and (\n+                (input_ids is not None and input_ids.shape[1] != 1)\n+                or (inputs_embeds is not None and inputs_embeds.shape[1] != 1)\n+            )\n+            prefill_noncompiled_stage = not is_torchdynamo_compiling() and (\n+                (cache_position is not None and cache_position[0] == 0)\n+                or (past_key_values is None or past_key_values.get_seq_length() == 0)\n+            )\n+            if (prefill_compiled_stage or prefill_noncompiled_stage) or self.rope_deltas is None:\n+                position_ids, rope_deltas = self.get_rope_index(\n+                    input_ids,\n+                    image_grid_thw,\n+                    video_grid_thw,\n+                    attention_mask=attention_mask_tensor,\n+                )\n+                self.rope_deltas = rope_deltas\n+            # then use the prev pre-calculated rope-deltas to get the correct position ids\n+            else:\n+                batch_size, seq_length, _ = inputs_embeds.shape\n+                delta = (\n+                    (cache_position[0] + self.rope_deltas).to(inputs_embeds.device)\n+                    if cache_position is not None\n+                    else 0\n+                )\n+                position_ids = torch.arange(seq_length, device=inputs_embeds.device)\n+                position_ids = position_ids.view(1, -1).expand(batch_size, -1)\n+                if cache_position is not None:  # otherwise `deltas` is an int `0`\n+                    delta = delta.repeat_interleave(batch_size // delta.shape[0], dim=0)\n+                position_ids = position_ids.add(delta)\n+                position_ids = position_ids.unsqueeze(0).expand(3, -1, -1)\n+\n+        outputs = self.language_model(\n+            input_ids=None,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        return Glm46VModelOutputWithPast(\n+            last_hidden_state=outputs.last_hidden_state,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=self.rope_deltas,\n+        )\n+\n+\n+@dataclass\n+@auto_docstring(\n+    custom_intro=\"\"\"\n+    Base class for Glm46V causal language model (or autoregressive) outputs.\n+    \"\"\"\n+)\n+class Glm46VCausalLMOutputWithPast(ModelOutput):\n+    r\"\"\"\n+    loss (`torch.FloatTensor` of shape `(1,)`, *optional*, returned when `labels` is provided):\n+        Language modeling loss (for next-token prediction).\n+    logits (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`):\n+        Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n+    past_key_values (`Cache`, *optional*, returned when `use_cache=True` is passed or when `config.use_cache=True`):\n+        It is a [`~cache_utils.Cache`] instance. For more details, see our [kv cache guide](https://huggingface.co/docs/transformers/en/kv_cache).\n+\n+        Contains pre-computed hidden-states (key and values in the self-attention blocks) that can be used (see\n+        `past_key_values` input) to speed up sequential decoding.\n+    rope_deltas (`torch.LongTensor` of shape `(batch_size, )`, *optional*):\n+        The rope index difference between sequence length and multimodal rope.\n+    \"\"\"\n+\n+    loss: Optional[torch.FloatTensor] = None\n+    logits: Optional[torch.FloatTensor] = None\n+    past_key_values: Optional[Cache] = None\n+    hidden_states: Optional[tuple[torch.FloatTensor]] = None\n+    attentions: Optional[tuple[torch.FloatTensor]] = None\n+    rope_deltas: Optional[torch.LongTensor] = None\n+\n+\n+class Glm46VForConditionalGeneration(Glm46VPreTrainedModel, GenerationMixin):\n+    _checkpoint_conversion_mapping = {}\n+    _tied_weights_keys = {\"lm_head.weight\": \"model.language_model.embed_tokens.weight\"}\n+    # Reference: fix gemma3 grad acc #37208\n+    accepts_loss_kwargs = False\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.model = Glm46VModel(config)\n+        self.lm_head = nn.Linear(config.text_config.hidden_size, config.text_config.vocab_size, bias=False)\n+\n+        self.post_init()\n+\n+    def get_input_embeddings(self):\n+        return self.model.get_input_embeddings()\n+\n+    def set_input_embeddings(self, value):\n+        self.model.set_input_embeddings(value)\n+\n+    def set_decoder(self, decoder):\n+        self.model.set_decoder(decoder)\n+\n+    def get_decoder(self):\n+        return self.model.get_decoder()\n+\n+    def get_video_features(\n+        self, pixel_values_videos: torch.FloatTensor, video_grid_thw: Optional[torch.LongTensor] = None\n+    ):\n+        return self.model.get_video_features(pixel_values_videos, video_grid_thw)\n+\n+    def get_image_features(self, pixel_values: torch.FloatTensor, image_grid_thw: Optional[torch.LongTensor] = None):\n+        return self.model.get_image_features(pixel_values, image_grid_thw)\n+\n+    # Make modules available through conditional class for BC\n+    @property\n+    def language_model(self):\n+        return self.model.language_model\n+\n+    @property\n+    def visual(self):\n+        return self.model.visual\n+\n+    @can_return_tuple\n+    @auto_docstring\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        labels: Optional[torch.LongTensor] = None,\n+        pixel_values: Optional[torch.Tensor] = None,\n+        pixel_values_videos: Optional[torch.FloatTensor] = None,\n+        image_grid_thw: Optional[torch.LongTensor] = None,\n+        video_grid_thw: Optional[torch.LongTensor] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        logits_to_keep: Union[int, torch.Tensor] = 0,\n+        **kwargs: Unpack[TransformersKwargs],\n+    ) -> Union[tuple, Glm46VCausalLMOutputWithPast]:\n+        r\"\"\"\n+        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n+            Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n+            config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n+            (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n+        image_grid_thw (`torch.LongTensor` of shape `(num_images, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each image in LLM.\n+        video_grid_thw (`torch.LongTensor` of shape `(num_videos, 3)`, *optional*):\n+            The temporal, height and width of feature shape of each video in LLM.\n+\n+        Example:\n+\n+        ```python\n+        >>> from PIL import Image\n+        >>> import requests\n+        >>> from transformers import AutoProcessor, Glm46VForConditionalGeneration\n+\n+        >>> model = Glm46VForConditionalGeneration.from_pretrained(\"THUDM/GLM-4.1V-9B-Thinking\")\n+        >>> processor = AutoProcessor.from_pretrained(\"THUDM/GLM-4.1V-9B-Thinking\")\n+\n+        >>> messages = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\"type\": \"image\"},\n+                    {\"type\": \"text\", \"text\": \"What is shown in this image?\"},\n+                ],\n+            },\n+        ]\n+        >>> url = \"https://www.ilankelman.org/stopsigns/australia.jpg\"\n+        >>> image = Image.open(requests.get(url, stream=True).raw)\n+\n+        >>> text = processor.apply_chat_template(messages, tokenize=False, add_generation_prompt=True)\n+        >>> inputs = processor(text=[text], images=[image], vision_infos=[vision_infos])\n+\n+        >>> # Generate\n+        >>> generate_ids = model.generate(inputs.input_ids, max_length=30)\n+        >>> tokenizer.batch_decode(generate_ids, skip_special_tokens=True, clean_up_tokenization_spaces=False)[0]\n+        \"The image shows a street scene with a red stop sign in the foreground. In the background, there is a large red gate with Chinese characters ...\"\n+        ```\"\"\"\n+        outputs = self.model(\n+            input_ids=input_ids,\n+            pixel_values=pixel_values,\n+            pixel_values_videos=pixel_values_videos,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            position_ids=position_ids,\n+            attention_mask=attention_mask,\n+            past_key_values=past_key_values,\n+            inputs_embeds=inputs_embeds,\n+            cache_position=cache_position,\n+            **kwargs,\n+        )\n+\n+        hidden_states = outputs[0]\n+\n+        # Only compute necessary logits, and do not upcast them to float if we are not computing the loss\n+        slice_indices = slice(-logits_to_keep, None) if isinstance(logits_to_keep, int) else logits_to_keep\n+        logits = self.lm_head(hidden_states[:, slice_indices, :])\n+\n+        loss = None\n+        if labels is not None:\n+            loss = self.loss_function(logits=logits, labels=labels, vocab_size=self.config.text_config.vocab_size)\n+\n+        return Glm46VCausalLMOutputWithPast(\n+            loss=loss,\n+            logits=logits,\n+            past_key_values=outputs.past_key_values,\n+            hidden_states=outputs.hidden_states,\n+            attentions=outputs.attentions,\n+            rope_deltas=outputs.rope_deltas,\n+        )\n+\n+    def prepare_inputs_for_generation(\n+        self,\n+        input_ids,\n+        past_key_values=None,\n+        attention_mask=None,\n+        inputs_embeds=None,\n+        cache_position=None,\n+        position_ids=None,\n+        use_cache=True,\n+        pixel_values=None,\n+        pixel_values_videos=None,\n+        image_grid_thw=None,\n+        video_grid_thw=None,\n+        **kwargs,\n+    ):\n+        # Overwritten -- in specific circumstances we don't want to forward image inputs to the model\n+\n+        model_inputs = super().prepare_inputs_for_generation(\n+            input_ids,\n+            past_key_values=past_key_values,\n+            attention_mask=attention_mask,\n+            inputs_embeds=inputs_embeds,\n+            cache_position=cache_position,\n+            position_ids=position_ids,\n+            pixel_values=pixel_values,\n+            pixel_values_videos=pixel_values_videos,\n+            image_grid_thw=image_grid_thw,\n+            video_grid_thw=video_grid_thw,\n+            use_cache=use_cache,\n+            **kwargs,\n+        )\n+\n+        # GLM-4.1V position_ids are prepareed with rope_deltas in forward\n+        model_inputs[\"position_ids\"] = None\n+\n+        if cache_position[0] != 0:\n+            model_inputs[\"pixel_values\"] = None\n+            model_inputs[\"pixel_values_videos\"] = None\n+\n+        return model_inputs\n+\n+    def _get_image_nums_and_video_nums(\n+        self,\n+        input_ids: Optional[torch.LongTensor],\n+        inputs_embeds: Optional[torch.Tensor] = None,\n+    ) -> tuple[torch.Tensor, torch.Tensor]:\n+        \"\"\"\n+        Get the number of images and videos for each sample to calculate the separation length of the sample tensor.\n+        These parameters are not passed through the processor to avoid unpredictable impacts from interface modifications.\n+\n+        Args:\n+            input_ids (`torch.LongTensor` of shape `(batch_size, sequence_length)`):\n+                Indices of input sequence tokens in the vocabulary.\n+\n+        Returns:\n+            image_nums (`torch.LongTensor` of shape `(batch_size, num_images_sample)`)\n+            video_nums (`torch.LongTensor` of shape `(batch_size, num_videos_sample)`)\n+        \"\"\"\n+\n+        if inputs_embeds is not None:\n+            is_image = (\n+                inputs_embeds\n+                == self.get_input_embeddings()(\n+                    torch.tensor(self.config.image_start_token_id, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            )[..., 0]\n+            is_video_start = (\n+                inputs_embeds\n+                == self.get_input_embeddings()(\n+                    torch.tensor(self.config.video_start_token_id, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            )[..., 0]\n+            is_video_end = (\n+                inputs_embeds\n+                == self.get_input_embeddings()(\n+                    torch.tensor(self.config.video_end_token_id, dtype=torch.long, device=inputs_embeds.device)\n+                )\n+            )[..., 0]\n+        else:\n+            is_image = input_ids == self.config.image_start_token_id\n+            is_video_start = input_ids == self.config.video_start_token_id\n+            is_video_end = input_ids == self.config.video_end_token_id\n+\n+        # Cumulative sum to track if we're inside a video span\n+        # We'll assume well-formed video tags (i.e. matching starts and ends)\n+        video_level = torch.cumsum(is_video_start.int() - is_video_end.int(), dim=1)\n+        inside_video = video_level > 0  # shape (batch_size, seq_length)\n+\n+        # Mask out image tokens that are inside video spans\n+        standalone_images = is_image & (~inside_video)\n+\n+        # Count per batch\n+        image_counts = standalone_images.sum(dim=1)\n+        video_counts = is_video_start.sum(dim=1)\n+\n+        return image_counts, video_counts\n+\n+    def _expand_inputs_for_generation(\n+        self,\n+        expand_size: int = 1,\n+        is_encoder_decoder: bool = False,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        **model_kwargs,\n+    ) -> tuple[torch.LongTensor, dict[str, Any]]:\n+        # Overwritten -- Support for expanding tensors without a batch size dimension\n+        # e.g., pixel_values, image_grid_thw, pixel_values_videos, video_grid_thw, second_per_grid_t\n+        # pixel_values.shape[0] is sum(seqlen_images for samples)\n+        # image_grid_thw.shape[0] is sum(num_images for samples)\n+\n+        if expand_size == 1:\n+            return input_ids, model_kwargs\n+\n+        visual_keys = [\"pixel_values\", \"image_grid_thw\", \"pixel_values_videos\", \"video_grid_thw\", \"second_per_grid_ts\"]\n+\n+        def _expand_dict_for_generation_visual(dict_to_expand):\n+            image_grid_thw = model_kwargs.get(\"image_grid_thw\", None)\n+            video_grid_thw = model_kwargs.get(\"video_grid_thw\", None)\n+            image_nums, video_nums = self._get_image_nums_and_video_nums(\n+                input_ids, inputs_embeds=model_kwargs.get(\"inputs_embeds\", None)\n+            )\n+\n+            def _repeat_interleave_samples(x, lengths, repeat_times):\n+                samples = torch.split(x, lengths)\n+                repeat_args = [repeat_times] + [1] * (x.dim() - 1)\n+                result = torch.cat([sample.repeat(*repeat_args) for sample in samples], dim=0)\n+                return result\n+\n+            for key in dict_to_expand:\n+                if key == \"pixel_values\":\n+                    # split images into samples\n+                    samples = torch.split(image_grid_thw, list(image_nums))\n+                    # compute the sequence length of images for each sample\n+                    lengths = [torch.prod(sample, dim=1).sum() for sample in samples]\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"image_grid_thw\":\n+                    # get the num of images for each sample\n+                    lengths = list(image_nums)\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"pixel_values_videos\":\n+                    samples = torch.split(video_grid_thw, list(video_nums))\n+                    lengths = [torch.prod(sample, dim=1).sum() for sample in samples]\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"video_grid_thw\":\n+                    lengths = list(video_nums)\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=lengths, repeat_times=expand_size\n+                    )\n+                elif key == \"second_per_grid_ts\":\n+                    dict_to_expand[key] = _repeat_interleave_samples(\n+                        dict_to_expand[key], lengths=list(video_nums), repeat_times=expand_size\n+                    )\n+            return dict_to_expand\n+\n+        def _expand_dict_for_generation(dict_to_expand):\n+            for key in dict_to_expand:\n+                if (\n+                    key != \"cache_position\"\n+                    and dict_to_expand[key] is not None\n+                    and isinstance(dict_to_expand[key], torch.Tensor)\n+                    and key not in visual_keys\n+                ):\n+                    dict_to_expand[key] = dict_to_expand[key].repeat_interleave(expand_size, dim=0)\n+            return dict_to_expand\n+\n+        model_kwargs = _expand_dict_for_generation_visual(model_kwargs)\n+\n+        if input_ids is not None:\n+            input_ids = input_ids.repeat_interleave(expand_size, dim=0)\n+\n+        model_kwargs = _expand_dict_for_generation(model_kwargs)\n+\n+        if is_encoder_decoder:\n+            if model_kwargs.get(\"encoder_outputs\") is None:\n+                raise ValueError(\"If `is_encoder_decoder` is True, make sure that `encoder_outputs` is defined.\")\n+            model_kwargs[\"encoder_outputs\"] = _expand_dict_for_generation(model_kwargs[\"encoder_outputs\"])\n+\n+        return input_ids, model_kwargs\n+\n+\n+__all__ = [\"Glm46VModel\", \"Glm46VPreTrainedModel\", \"Glm46VForConditionalGeneration\"]"
        },
        {
            "sha": "0bb86b0aacf7ad75e65931250dd1035a8fac6046",
            "filename": "src/transformers/models/glm46v/modular_glm46v.py",
            "status": "added",
            "additions": 217,
            "deletions": 0,
            "changes": 217,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fmodular_glm46v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fmodular_glm46v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm46v%2Fmodular_glm46v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -0,0 +1,217 @@\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import Optional, Union\n+\n+import numpy as np\n+\n+from ...configuration_utils import PreTrainedConfig\n+from ...video_utils import VideoMetadata\n+from ..auto import CONFIG_MAPPING, AutoConfig, AutoModel\n+from ..glm4v.image_processing_glm4v import Glm4vImageProcessor\n+from ..glm4v.image_processing_glm4v_fast import Glm4vImageProcessorFast\n+from ..glm4v.modeling_glm4v import Glm4vForConditionalGeneration, Glm4vModel, Glm4vPreTrainedModel\n+from ..glm4v.processing_glm4v import Glm4vProcessor\n+from ..glm4v.video_processing_glm4v import Glm4vVideoProcessor\n+\n+\n+class Glm46VConfig(PreTrainedConfig):\n+    r\"\"\"\n+    This is the configuration class to store the configuration of a [`Glm4vModel`]. It is used to instantiate a\n+    GLM-4.6V model according to the specified arguments, defining the model architecture. Instantiating a\n+    configuration with the defaults will yield a similar configuration to that of\n+    GLM-4.1V-9B-Thinking [zai-org/GLM-4.1V-9B-Thinking](https://huggingface.co/zai-org/GLM-4.1V-9B-Thinking).\n+\n+    Configuration objects inherit from [`PreTrainedConfig`] and can be used to control the model outputs. Read the\n+    documentation from [`PreTrainedConfig`] for more information.\n+\n+    Args:\n+        text_config (`Union[PreTrainedConfig, dict]`, *optional*, defaults to `Glm4vTextConfig`):\n+            The config object or dictionary of the text backbone.\n+        vision_config (`Union[PreTrainedConfig, dict]`,  *optional*, defaults to `Glm4vVisionConfig`):\n+            The config object or dictionary of the vision backbone.\n+        image_token_id (`int`, *optional*, defaults to 151343):\n+            The image token index to encode the image prompt.\n+        video_token_id (`int`, *optional*, defaults to 151344):\n+            The video token index to encode the image prompt.\n+        image_start_token_id (`int`, *optional*, defaults to 151339):\n+            The image start token index to encode the start of image.\n+        image_end_token_id (`int`, *optional*, defaults to 151340):\n+            The image end token index to encode the end of image.\n+        video_start_token_id (`int`, *optional*, defaults to 151361):\n+            The video start token index to encode the start of video.\n+        video_end_token_id (`int`, *optional*, defaults to 151362):\n+            The video end token index to encode the end of video.\n+\n+    ```python\n+    >>> from transformers import Glm46VForConditionalGeneration, Glm46VConfig\n+\n+    >>> # Initializing a GLM-4.6V style configuration\n+    >>> configuration = Glm46VConfig()\n+\n+    >>> # Initializing a model from the GLM-4.6V style configuration\n+    >>> model = Glm4vForConditionalGeneration(configuration)\n+\n+    >>> # Accessing the model configuration\n+    >>> configuration = model.config\n+    ```\"\"\"\n+\n+    model_type = \"glm46v\"\n+    sub_configs = {\"text_config\": AutoConfig, \"vision_config\": AutoConfig}\n+    keys_to_ignore_at_inference = [\"past_key_values\"]\n+\n+    def __init__(\n+        self,\n+        text_config=None,\n+        vision_config=None,\n+        image_token_id=151343,\n+        video_token_id=151344,\n+        image_start_token_id=151339,\n+        image_end_token_id=151340,\n+        video_start_token_id=151361,\n+        video_end_token_id=151362,\n+        **kwargs,\n+    ):\n+        if isinstance(vision_config, dict):\n+            vision_config[\"model_type\"] = vision_config.get(\"model_type\", \"glm4v_vision\")\n+            self.vision_config = CONFIG_MAPPING[vision_config[\"model_type\"]](**vision_config)\n+        elif vision_config is None:\n+            self.vision_config = CONFIG_MAPPING[\"glm4v_vision\"]()\n+\n+        if isinstance(text_config, dict):\n+            text_config[\"model_type\"] = text_config.get(\"model_type\", \"glm4v_text\")\n+            self.text_config = CONFIG_MAPPING[text_config[\"model_type\"]](**text_config)\n+        elif text_config is None:\n+            self.text_config = CONFIG_MAPPING[\"glm4v_text\"]()\n+\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.video_start_token_id = video_start_token_id\n+        self.video_end_token_id = video_end_token_id\n+        self.image_start_token_id = image_start_token_id\n+        self.image_end_token_id = image_end_token_id\n+\n+        super().__init__(**kwargs)\n+\n+\n+class Glm46VPreTrainedModel(Glm4vPreTrainedModel):\n+    _can_record_outputs = None\n+    _no_split_modules = None\n+\n+\n+class Glm46VModel(Glm4vModel):\n+    _no_split_modules = None\n+\n+    def __init__(self, config):\n+        super().__init__(config)\n+        self.visual = AutoModel.from_config(config.vision_config)\n+        self.language_model = AutoModel.from_config(config.text_config)\n+\n+\n+class Glm46VForConditionalGeneration(Glm4vForConditionalGeneration):\n+    pass\n+\n+\n+class Glm46VProcessor(Glm4vProcessor):\n+    def replace_frame_token_id(self, timestamp_sec):\n+        return f\"<|begin_of_image|>{self.image_token}<|end_of_image|>{timestamp_sec:.1f} seconds\"\n+\n+\n+class Glm46VImageProcessor(Glm4vImageProcessor):\n+    pass\n+\n+\n+class Glm46VImageProcessorFast(Glm4vImageProcessorFast):\n+    pass\n+\n+\n+class Glm46VVideoProcessor(Glm4vVideoProcessor):\n+    def sample_frames(\n+        self,\n+        metadata: VideoMetadata,\n+        fps: Optional[Union[int, float]] = None,\n+        **kwargs,\n+    ):\n+        if metadata is None or getattr(metadata, \"fps\", None) is None:\n+            raise ValueError(\n+                \"Asked to sample frames per second but no video metadata was provided which is required when sampling in Glm46V. \"\n+                \"Please pass in `VideoMetadata` object or set `do_sample_frames=False`\"\n+            )\n+\n+        total_frames = metadata.total_num_frames\n+        max_frame_idx = total_frames - 1\n+        duration = metadata.duration or round(max_frame_idx / metadata.fps) + 1\n+\n+        DYNAMIC_FPS_THRES = {30: 3, 300: 1, 2400: 0.5}\n+        MAX_FRAME_COUNT_DYNAMIC = 640\n+        MAX_DURATION = 2400\n+        effective_duration = min(duration, MAX_DURATION)\n+        if effective_duration <= 30:\n+            target_fps = DYNAMIC_FPS_THRES[30]\n+        elif effective_duration <= 300:\n+            target_fps = DYNAMIC_FPS_THRES[300]\n+        else:\n+            target_fps = DYNAMIC_FPS_THRES[2400]\n+        extract_t = int(effective_duration * target_fps * self.temporal_patch_size)\n+        extract_t = min(extract_t, MAX_FRAME_COUNT_DYNAMIC)\n+\n+        duration_per_frame = 1 / metadata.fps\n+        timestamps = [i * duration_per_frame for i in range(total_frames)]\n+        max_second = int(duration)\n+\n+        if total_frames < extract_t:\n+            frame_indices = np.linspace(0, total_frames - 1, extract_t, dtype=int).tolist()\n+        else:\n+            frame_indices = []\n+            current_second = 0\n+            inv_fps = 1 / (self.temporal_patch_size * target_fps)\n+            for frame_index in range(total_frames):\n+                if timestamps[frame_index] >= current_second:\n+                    current_second += inv_fps\n+                    frame_indices.append(frame_index)\n+                    if current_second >= max_second:\n+                        break\n+\n+        if len(frame_indices) < extract_t:\n+            if len(frame_indices) == 0:\n+                start, end = 0, max(total_frames - 1, 0)\n+            else:\n+                start, end = frame_indices[0], frame_indices[-1]\n+            frame_indices = np.linspace(start, end, extract_t, dtype=int).tolist()\n+        elif len(frame_indices) > extract_t:\n+            frame_indices = np.linspace(0, total_frames - 1, extract_t, dtype=int).tolist()\n+\n+        seen, uniq = set(), []\n+        for idx in frame_indices:\n+            if idx not in seen:\n+                seen.add(idx)\n+                uniq.append(idx)\n+\n+        if len(uniq) & 1:\n+            uniq.append(uniq[-1])\n+\n+        return np.array(uniq)\n+\n+\n+__all__ = [\n+    \"Glm46VConfig\",\n+    \"Glm46VModel\",\n+    \"Glm46VPreTrainedModel\",\n+    \"Glm46VForConditionalGeneration\",\n+    \"Glm46VProcessor\",\n+    \"Glm46VImageProcessor\",\n+    \"Glm46VImageProcessorFast\",\n+    \"Glm46VVideoProcessor\",\n+]"
        },
        {
            "sha": "ce6a17d3178b9c327ddd99d79a15d30a3432daf3",
            "filename": "src/transformers/models/glm46v/processing_glm46v.py",
            "status": "added",
            "additions": 279,
            "deletions": 0,
            "changes": 279,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fprocessing_glm46v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fprocessing_glm46v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm46v%2Fprocessing_glm46v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -0,0 +1,279 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/glm46v/modular_glm46v.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_glm46v.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import Optional, Union\n+\n+import numpy as np\n+\n+from ...image_processing_utils import BatchFeature\n+from ...image_utils import ImageInput\n+from ...processing_utils import MultiModalData, ProcessingKwargs, ProcessorMixin, Unpack\n+from ...tokenization_utils_base import PreTokenizedInput, TextInput\n+from ...utils import logging\n+from ...video_utils import VideoInput\n+\n+\n+logger = logging.get_logger(__name__)\n+\n+\n+class Glm46VProcessorKwargs(ProcessingKwargs, total=False):\n+    _defaults = {\n+        \"text_kwargs\": {\n+            \"padding\": False,\n+            \"return_token_type_ids\": False,\n+            \"return_mm_token_type_ids\": False,\n+        },\n+        \"videos_kwargs\": {\"return_metadata\": True},\n+    }\n+\n+\n+class Glm46VProcessor(ProcessorMixin):\n+    r\"\"\"\n+    Constructs a GLM-4V processor which wraps a GLM-4V image processor and a GLM-4 tokenizer into a single processor.\n+    [`~Glm46VProcessor.__call__`] and [`~Glm46VProcessor.decode`] for more information.\n+    Args:\n+        image_processor ([`Glm46VProcessor`], *optional*):\n+            The image processor is a required input.\n+        tokenizer ([`PreTrainedTokenizerFast`], *optional*):\n+            The tokenizer is a required input.\n+        video_processor ([`Glm46VVideoProcessor`], *optional*):\n+            The video processor is a required input.\n+        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages\n+            in a chat into a tokenizable string.\n+    \"\"\"\n+\n+    def __init__(self, image_processor=None, tokenizer=None, video_processor=None, chat_template=None, **kwargs):\n+        self.image_token = \"<|image|>\" if not hasattr(tokenizer, \"image_token\") else tokenizer.image_token\n+        self.video_token = \"<|video|>\" if not hasattr(tokenizer, \"video_token\") else tokenizer.video_token\n+        self.image_token_id = (\n+            tokenizer.image_token_id\n+            if getattr(tokenizer, \"image_token_id\", None)\n+            else tokenizer.convert_tokens_to_ids(self.image_token)\n+        )\n+        self.video_token_id = (\n+            tokenizer.video_token_id\n+            if getattr(tokenizer, \"video_token_id\", None)\n+            else tokenizer.convert_tokens_to_ids(self.video_token)\n+        )\n+        super().__init__(image_processor, tokenizer, video_processor, chat_template=chat_template)\n+\n+    def __call__(\n+        self,\n+        images: Optional[ImageInput] = None,\n+        text: Union[TextInput, PreTokenizedInput, list[TextInput], list[PreTokenizedInput]] = None,\n+        videos: Optional[VideoInput] = None,\n+        **kwargs: Unpack[Glm46VProcessorKwargs],\n+    ) -> BatchFeature:\n+        \"\"\"\n+        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`\n+        and `kwargs` arguments to PreTrainedTokenizerFast's [`~PreTrainedTokenizerFast.__call__`] if `text` is not `None` to encode\n+        the text.\n+\n+        Args:\n+            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch\n+                tensor. Both channels-first and channels-last formats are supported.\n+            text (`str`, `List[str]`, `List[List[str]]`):\n+                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings\n+                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set\n+                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).\n+            videos (`np.ndarray`, `torch.Tensor`, `List[np.ndarray]`, `List[torch.Tensor]`):\n+                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch\n+                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.\n+            return_tensors (`str` or [`~utils.TensorType`], *optional*):\n+                If set, will return tensors of a particular framework. Acceptable values are:\n+                - `'pt'`: Return PyTorch `torch.Tensor` objects.\n+                - `'np'`: Return NumPy `np.ndarray` objects.\n+\n+        Returns:\n+            [`BatchFeature`]: A [`BatchFeature`] with the following fields:\n+\n+            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.\n+            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when\n+              `return_attention_mask=True` or if *\"attention_mask\"* is in `self.model_input_names` and if `text` is not\n+              `None`).\n+            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.\n+            - **pixel_values_videos** -- Pixel values of videos to be fed to a model. Returned when `videos` is not `None`.\n+            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.\n+            - **video_grid_thw** -- List of video 3D grid in LLM. Returned when `videos` is not `None`.\n+        \"\"\"\n+        output_kwargs = self._merge_kwargs(\n+            Glm46VProcessorKwargs,\n+            tokenizer_init_kwargs=self.tokenizer.init_kwargs,\n+            **kwargs,\n+        )\n+        if images is not None:\n+            image_inputs = self.image_processor(images=images, **output_kwargs[\"images_kwargs\"])\n+            image_grid_thw = image_inputs[\"image_grid_thw\"]\n+        else:\n+            image_inputs = {}\n+            image_grid_thw = None\n+\n+        if videos is not None:\n+            videos_inputs = self.video_processor(videos=videos, **output_kwargs[\"videos_kwargs\"])\n+            # If user has not requested video metadata, pop it\n+            if not kwargs.get(\"return_metadata\"):\n+                video_metadata = videos_inputs.pop(\"video_metadata\")\n+            else:\n+                video_metadata = videos_inputs[\"video_metadata\"]\n+            video_grid_thw = videos_inputs[\"video_grid_thw\"]\n+        else:\n+            videos_inputs = {}\n+            video_grid_thw = None\n+\n+        if not isinstance(text, list):\n+            text = [text]\n+\n+        text = text.copy()  # below lines change text in-place\n+        if image_grid_thw is not None:\n+            merge_length = self.image_processor.merge_size**2\n+            index = 0\n+            for i in range(len(text)):\n+                while self.image_token in text[i]:\n+                    num_image_tokens = image_grid_thw[index].prod() // merge_length\n+                    text[i] = text[i].replace(self.image_token, \"<|placeholder|>\" * num_image_tokens, 1)\n+                    index += 1\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.image_token)\n+\n+        if video_grid_thw is not None:\n+            merge_length = self.video_processor.merge_size**2\n+            video_index = 0\n+            for i in range(len(text)):\n+                while self.video_token in text[i]:\n+                    num_frames = video_grid_thw[video_index][0]\n+                    video_structure = \"\"\n+\n+                    metadata = video_metadata[video_index]\n+                    if metadata.fps is None:\n+                        logger.warning_once(\n+                            \"SmolVLM requires frame timestamps to construct prompts, but the `fps` of the input video could not be inferred. \"\n+                            \"Probably `video_metadata` was missing from inputs and you passed pre-sampled frames. \"\n+                            \"Defaulting to `fps=24`. Please provide `video_metadata` for more accurate results.\"\n+                        )\n+                    metadata.fps = 24 if metadata.fps is None else metadata.fps\n+                    timestamps = metadata.timestamps[::2]  # mrope\n+\n+                    unique_timestamps = []\n+                    for idx in range(0, len(timestamps)):\n+                        unique_timestamps.append(timestamps[idx])\n+\n+                    selected_timestamps = unique_timestamps[:num_frames]\n+                    while len(selected_timestamps) < num_frames:\n+                        selected_timestamps.append(selected_timestamps[-1] if selected_timestamps else 0)\n+\n+                    for frame_idx in range(num_frames):\n+                        timestamp_sec = selected_timestamps[frame_idx]\n+                        frame_structure = self.replace_frame_token_id(timestamp_sec)\n+                        video_structure += frame_structure\n+\n+                    text[i] = text[i].replace(self.video_token, video_structure, 1)\n+                    num_image_tokens = (\n+                        video_grid_thw[video_index].prod() // merge_length // video_grid_thw[video_index][0]\n+                    )\n+                    for frame_idx in range(num_frames):\n+                        if self.image_token in text[i]:\n+                            text[i] = text[i].replace(self.image_token, \"<|placeholder|>\" * num_image_tokens, 1)\n+\n+                    video_index += 1\n+\n+                text[i] = text[i].replace(\"<|placeholder|>\", self.image_token)\n+        return_tensors = output_kwargs[\"text_kwargs\"].pop(\"return_tensors\", None)\n+        return_mm_token_type_ids = output_kwargs[\"text_kwargs\"].pop(\"return_mm_token_type_ids\", False)\n+        text_inputs = self.tokenizer(text, **output_kwargs[\"text_kwargs\"])\n+        self._check_special_mm_tokens(text, text_inputs, modalities=[\"image\", \"video\"])\n+\n+        if return_mm_token_type_ids:\n+            array_ids = np.array(text_inputs[\"input_ids\"])\n+            mm_token_type_ids = np.zeros_like(text_inputs[\"input_ids\"])\n+            mm_token_type_ids[array_ids == self.image_token_id] = 1\n+            text_inputs[\"mm_token_type_ids\"] = mm_token_type_ids.tolist()\n+        return BatchFeature(data={**text_inputs, **image_inputs, **videos_inputs}, tensor_type=return_tensors)\n+\n+    def _get_num_multimodal_tokens(self, image_sizes=None, video_sizes=None, **kwargs):\n+        \"\"\"\n+        Computes the number of placeholder tokens needed for multimodal inputs with the given sizes.\n+        Args:\n+            image_sizes (`list[list[int]]`, *optional*):\n+                The input sizes formatted as (height, width) per each image.\n+            video_sizes (`list[list[int]]`, *optional*):\n+                The input sizes formatted as (num_frames, height, width) per each video.\n+        Returns:\n+            `MultiModalData`: A `MultiModalData` object holding number of tokens per each of the provided\n+            input modalities, along with other useful data.\n+        \"\"\"\n+\n+        vision_data = {}\n+        if image_sizes is not None:\n+            images_kwargs = Glm46VProcessorKwargs._defaults.get(\"images_kwargs\", {})\n+            images_kwargs.update(kwargs)\n+            merge_size = images_kwargs.get(\"merge_size\", None) or self.image_processor.merge_size\n+\n+            num_image_patches = [\n+                self.image_processor.get_number_of_image_patches(*image_size, images_kwargs)\n+                for image_size in image_sizes\n+            ]\n+            num_image_tokens = [(num_patches // merge_size**2) for num_patches in num_image_patches]\n+            vision_data.update({\"num_image_tokens\": num_image_tokens, \"num_image_patches\": num_image_patches})\n+\n+        if video_sizes is not None:\n+            videos_kwargs = Glm46VProcessorKwargs._defaults.get(\"videos_kwargs\", {})\n+            videos_kwargs.update(kwargs)\n+            num_video_patches = [\n+                self.video_processor.get_number_of_video_patches(*video_size, videos_kwargs)\n+                for video_size in video_sizes\n+            ]\n+            num_video_tokens = [(num_patches // merge_size**2) for num_patches in num_video_patches]\n+            vision_data[\"num_video_tokens\"] = num_video_tokens\n+\n+        return MultiModalData(**vision_data)\n+\n+    def post_process_image_text_to_text(\n+        self, generated_outputs, skip_special_tokens=True, clean_up_tokenization_spaces=False, **kwargs\n+    ):\n+        \"\"\"\n+        Post-process the output of the model to decode the text.\n+\n+        Args:\n+            generated_outputs (`torch.Tensor` or `np.ndarray`):\n+                The output of the model `generate` function. The output is expected to be a tensor of shape `(batch_size, sequence_length)`\n+                or `(sequence_length,)`.\n+            skip_special_tokens (`bool`, *optional*, defaults to `True`):\n+                Whether or not to remove special tokens in the output. Argument passed to the tokenizer's `batch_decode` method.\n+            clean_up_tokenization_spaces (`bool`, *optional*, defaults to `False`):\n+                Whether or not to clean up the tokenization spaces. Argument passed to the tokenizer's `batch_decode` method.\n+            **kwargs:\n+                Additional arguments to be passed to the tokenizer's `batch_decode method`.\n+\n+        Returns:\n+            `list[str]`: The decoded text.\n+        \"\"\"\n+        return self.tokenizer.batch_decode(\n+            generated_outputs,\n+            skip_special_tokens=skip_special_tokens,\n+            clean_up_tokenization_spaces=clean_up_tokenization_spaces,\n+            **kwargs,\n+        )\n+\n+    def replace_frame_token_id(self, timestamp_sec):\n+        return f\"<|begin_of_image|>{self.image_token}<|end_of_image|>{timestamp_sec:.1f} seconds\"\n+\n+\n+__all__ = [\"Glm46VProcessor\"]"
        },
        {
            "sha": "f8e6d248502b5d407ac8b2dfce53f04d3d476a23",
            "filename": "src/transformers/models/glm46v/video_processing_glm46v.py",
            "status": "added",
            "additions": 281,
            "deletions": 0,
            "changes": 281,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fvideo_processing_glm46v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm46v%2Fvideo_processing_glm46v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm46v%2Fvideo_processing_glm46v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -0,0 +1,281 @@\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+#           This file was automatically generated from src/transformers/models/glm46v/modular_glm46v.py.\n+#               Do NOT edit this file manually as any edits will be overwritten by the generation of\n+#             the file from the modular. If any change should be done, please apply the change to the\n+#                          modular_glm46v.py file directly. One of our CI enforces this.\n+#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨\n+# coding=utf-8\n+# Copyright 2025 the HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+from typing import Optional, Union\n+\n+import numpy as np\n+import torch\n+\n+from ...image_processing_utils import BatchFeature\n+from ...image_utils import (\n+    OPENAI_CLIP_MEAN,\n+    OPENAI_CLIP_STD,\n+    ChannelDimension,\n+    PILImageResampling,\n+    SizeDict,\n+    get_image_size,\n+)\n+from ...processing_utils import Unpack, VideosKwargs\n+from ...utils import TensorType, add_start_docstrings\n+from ...video_processing_utils import BASE_VIDEO_PROCESSOR_DOCSTRING, BaseVideoProcessor\n+from ...video_utils import VideoMetadata, group_videos_by_shape, reorder_videos\n+from .image_processing_glm46v import smart_resize\n+\n+\n+class Glm46VVideoProcessorInitKwargs(VideosKwargs, total=False):\n+    max_image_size: dict[str, int]\n+    patch_size: int\n+    temporal_patch_size: int\n+    merge_size: int\n+    max_duration: int\n+\n+\n+@add_start_docstrings(\n+    \"Constructs a fast GLM-4V image processor that dynamically resizes videos based on the original videos.\",\n+    BASE_VIDEO_PROCESSOR_DOCSTRING,\n+    \"\"\"\n+        patch_size (`int`, *optional*, defaults to 14):\n+            The spacial patch size of the vision encoder.\n+        temporal_patch_size (`int`, *optional*, defaults to 2):\n+            The temporal patch size of the vision encoder.\n+        merge_size (`int`, *optional*, defaults to 2):\n+            The merge size of the vision encoder to llm encoder.\n+    \"\"\",\n+)\n+class Glm46VVideoProcessor(BaseVideoProcessor):\n+    resample = PILImageResampling.BICUBIC\n+    size = {\"shortest_edge\": 112 * 112, \"longest_edge\": 28 * 28 * 2 * 30000}\n+    max_image_size = {\"longest_edge\": 28 * 28 * 2 * 30000}\n+    image_mean = OPENAI_CLIP_MEAN\n+    image_std = OPENAI_CLIP_STD\n+    do_resize = True\n+    do_rescale = True\n+    do_normalize = True\n+    do_convert_rgb = True\n+    do_sample_frames = True\n+    patch_size = 14\n+    temporal_patch_size = 2\n+    max_duration = 300\n+    merge_size = 2\n+    valid_kwargs = Glm46VVideoProcessorInitKwargs\n+    num_frames = 16\n+    fps = 2\n+\n+    model_input_names = [\"pixel_values_videos\", \"video_grid_thw\"]\n+\n+    def __init__(self, **kwargs: Unpack[Glm46VVideoProcessorInitKwargs]):\n+        super().__init__(**kwargs)\n+        if self.size is not None and (\n+            self.size.get(\"shortest_edge\", None) is None or self.size.get(\"longest_edge\", None) is None\n+        ):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+\n+    def _further_process_kwargs(\n+        self,\n+        size: Optional[SizeDict] = None,\n+        **kwargs,\n+    ) -> dict:\n+        \"\"\"\n+        Update kwargs that need further processing before being validated\n+        Can be overridden by subclasses to customize the processing of kwargs.\n+        \"\"\"\n+        if size is not None and (\"shortest_edge\" not in size or \"longest_edge\" not in size):\n+            raise ValueError(\"size must contain 'shortest_edge' and 'longest_edge' keys.\")\n+\n+        return super()._further_process_kwargs(size=size, **kwargs)\n+\n+    def sample_frames(\n+        self,\n+        metadata: VideoMetadata,\n+        fps: Optional[Union[int, float]] = None,\n+        **kwargs,\n+    ):\n+        \"\"\"\n+        Args:\n+            metadata (`VideoMetadata`):\n+                Metadata of the video containing information about total duration, fps and total number of frames.\n+            fps (`int` or `float`, *optional*):\n+                Target frames to sample per second. Defaults to `self.fps`.\n+        Returns:\n+            np.ndarray:\n+                Indices to sample video frames.\n+        \"\"\"\n+        if metadata is None or getattr(metadata, \"fps\", None) is None:\n+            raise ValueError(\n+                \"Asked to sample frames per second but no video metadata was provided which is required when sampling in Glm46V. \"\n+                \"Please pass in `VideoMetadata` object or set `do_sample_frames=False`\"\n+            )\n+\n+        total_frames = metadata.total_num_frames\n+        max_frame_idx = total_frames - 1\n+        duration = metadata.duration or round(max_frame_idx / metadata.fps) + 1\n+\n+        DYNAMIC_FPS_THRES = {30: 3, 300: 1, 2400: 0.5}\n+        MAX_FRAME_COUNT_DYNAMIC = 640\n+        MAX_DURATION = 2400\n+        effective_duration = min(duration, MAX_DURATION)\n+        if effective_duration <= 30:\n+            target_fps = DYNAMIC_FPS_THRES[30]\n+        elif effective_duration <= 300:\n+            target_fps = DYNAMIC_FPS_THRES[300]\n+        else:\n+            target_fps = DYNAMIC_FPS_THRES[2400]\n+        extract_t = int(effective_duration * target_fps * self.temporal_patch_size)\n+        extract_t = min(extract_t, MAX_FRAME_COUNT_DYNAMIC)\n+\n+        duration_per_frame = 1 / metadata.fps\n+        timestamps = [i * duration_per_frame for i in range(total_frames)]\n+        max_second = int(duration)\n+\n+        if total_frames < extract_t:\n+            frame_indices = np.linspace(0, total_frames - 1, extract_t, dtype=int).tolist()\n+        else:\n+            frame_indices = []\n+            current_second = 0\n+            inv_fps = 1 / (self.temporal_patch_size * target_fps)\n+            for frame_index in range(total_frames):\n+                if timestamps[frame_index] >= current_second:\n+                    current_second += inv_fps\n+                    frame_indices.append(frame_index)\n+                    if current_second >= max_second:\n+                        break\n+\n+        if len(frame_indices) < extract_t:\n+            if len(frame_indices) == 0:\n+                start, end = 0, max(total_frames - 1, 0)\n+            else:\n+                start, end = frame_indices[0], frame_indices[-1]\n+            frame_indices = np.linspace(start, end, extract_t, dtype=int).tolist()\n+        elif len(frame_indices) > extract_t:\n+            frame_indices = np.linspace(0, total_frames - 1, extract_t, dtype=int).tolist()\n+\n+        seen, uniq = set(), []\n+        for idx in frame_indices:\n+            if idx not in seen:\n+                seen.add(idx)\n+                uniq.append(idx)\n+\n+        if len(uniq) & 1:\n+            uniq.append(uniq[-1])\n+\n+        return np.array(uniq)\n+\n+    def _preprocess(\n+        self,\n+        videos: list[torch.Tensor],\n+        do_convert_rgb: bool = True,\n+        do_resize: bool = True,\n+        size: Optional[SizeDict] = None,\n+        interpolation: PILImageResampling = PILImageResampling.BICUBIC,\n+        do_rescale: bool = True,\n+        rescale_factor: float = 1 / 255.0,\n+        do_normalize: bool = True,\n+        image_mean: Optional[Union[float, list[float]]] = None,\n+        image_std: Optional[Union[float, list[float]]] = None,\n+        patch_size: Optional[int] = None,\n+        temporal_patch_size: Optional[int] = None,\n+        merge_size: Optional[int] = None,\n+        return_tensors: Optional[Union[str, TensorType]] = None,\n+        **kwargs,\n+    ):\n+        grouped_videos, grouped_videos_index = group_videos_by_shape(videos)\n+        resized_videos_grouped = {}\n+\n+        for shape, stacked_videos in grouped_videos.items():\n+            B, T, C, H, W = stacked_videos.shape\n+            num_frames, height, width = T, H, W\n+            if do_resize:\n+                resized_height, resized_width = smart_resize(\n+                    num_frames=num_frames,\n+                    height=height,\n+                    width=width,\n+                    temporal_factor=temporal_patch_size,\n+                    factor=patch_size * merge_size,\n+                    min_pixels=size.shortest_edge,\n+                    max_pixels=size.longest_edge,\n+                )\n+                stacked_videos = stacked_videos.view(B * T, C, H, W)\n+                stacked_videos = self.resize(\n+                    stacked_videos,\n+                    size=SizeDict(height=resized_height, width=resized_width),\n+                    interpolation=interpolation,\n+                )\n+                stacked_videos = stacked_videos.view(B, T, C, resized_height, resized_width)\n+            resized_videos_grouped[shape] = stacked_videos\n+        resized_videos = reorder_videos(resized_videos_grouped, grouped_videos_index)\n+\n+        # Group videos by size for further processing\n+        # Needed in case do_resize is False, or resize returns videos with different sizes\n+        grouped_videos, grouped_videos_index = group_videos_by_shape(resized_videos)\n+        processed_videos_grouped = {}\n+        processed_grids = {}\n+        for shape, stacked_videos in grouped_videos.items():\n+            resized_height, resized_width = get_image_size(stacked_videos[0], channel_dim=ChannelDimension.FIRST)\n+\n+            # Fused rescale and normalize\n+            stacked_videos = self.rescale_and_normalize(\n+                stacked_videos, do_rescale, rescale_factor, do_normalize, image_mean, image_std\n+            )\n+            patches = stacked_videos\n+\n+            # Check that videos have `num_frames` divisible by `temporal_patch_size`\n+            if patches.shape[1] % temporal_patch_size != 0:\n+                repeats = patches[:, -1:].repeat(1, temporal_patch_size - 1, 1, 1, 1)\n+                patches = torch.cat([patches, repeats], dim=1)\n+            batch_size, grid_t, channel = patches.shape[:3]\n+            grid_t = grid_t // temporal_patch_size\n+            grid_h, grid_w = resized_height // patch_size, resized_width // patch_size\n+\n+            patches = patches.view(\n+                batch_size,\n+                grid_t,\n+                temporal_patch_size,\n+                channel,\n+                grid_h // merge_size,\n+                merge_size,\n+                patch_size,\n+                grid_w // merge_size,\n+                merge_size,\n+                patch_size,\n+            )\n+            patches = patches.permute(0, 1, 4, 7, 5, 8, 3, 2, 6, 9)\n+            flatten_patches = patches.reshape(\n+                batch_size,\n+                grid_t * grid_h * grid_w,\n+                channel * temporal_patch_size * patch_size * patch_size,\n+            )\n+\n+            processed_videos_grouped[shape] = flatten_patches\n+            processed_grids[shape] = [[grid_t, grid_h, grid_w]] * batch_size\n+\n+        processed_videos = reorder_videos(processed_videos_grouped, grouped_videos_index)\n+        processed_grids = reorder_videos(processed_grids, grouped_videos_index)\n+        pixel_values_videos = torch.cat(processed_videos, dim=0)\n+        video_grid_thw = torch.tensor(processed_grids)\n+        data = {\n+            \"pixel_values_videos\": pixel_values_videos,\n+            \"video_grid_thw\": video_grid_thw,\n+        }\n+\n+        return BatchFeature(data=data, tensor_type=return_tensors)\n+\n+\n+__all__ = [\"Glm46VVideoProcessor\"]"
        },
        {
            "sha": "65d56c9a646740ae262bb85c7d1fda68c2f78a45",
            "filename": "src/transformers/models/glm4v/__init__.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2F__init__.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -19,8 +19,10 @@\n \n if TYPE_CHECKING:\n     from .configuration_glm4v import *\n+    from .image_processing_glm4v import *\n     from .modeling_glm4v import *\n     from .processing_glm4v import *\n+    from .video_processing_glm4v import *\n else:\n     import sys\n "
        },
        {
            "sha": "7370a80b52f294b28937ae504a9ee59b3f2889d3",
            "filename": "src/transformers/models/glm4v/configuration_glm4v.py",
            "status": "modified",
            "additions": 31,
            "deletions": 35,
            "changes": 66,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconfiguration_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconfiguration_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconfiguration_glm4v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -32,39 +32,35 @@ class Glm4vVisionConfig(PreTrainedConfig):\n     GLM-4.1V-9B-Thinking [THUDM/GLM-4.1V-9B-Thinking](https://huggingface.co/THUDM/GLM-4.1V-9B-Thinking).\n \n     Args:\n-        hidden_size (`int`, *optional*, defaults to 1536):\n-            Dimensionality of the encoder layers and the pooler layer.\n-        depth (`int`, *optional*, defaults to 24):\n-            Number of layers (depth) in the model.\n-        attention_bias (`bool`, *optional*, defaults to `False`):\n-            Whether to add a bias to the queries, keys and values.\n-        intermediate_size (`int`, *optional*, defaults to 13696):\n-            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n-        hidden_act (`str` or `function`, *optional*, defaults to `\"selu\"`):\n-            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n-            `\"relu\"`, `\"selu\"` and `\"gelu_new\"` are supported.\n-        hidden_dropout_prob (`float`, *optional*, defaults to 0.0):\n-            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n-        attention_dropout (`float`, *optional*, defaults to 0.0):\n-            Dropout probability for attention weights.\n-        projection_dropout (`float`, *optional*, defaults to 0.0):\n-            Dropout probability for the projection layer.\n-        initializer_range (`float`, *optional*, defaults to 0.02):\n-            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n-        image_size (`int` or `list[int]`, *optional*, defaults to `[336, 336]`):\n-            The size (resolution) of each image.\n-        patch_size (`int`, *optional*, defaults to `14`):\n-            The size (resolution) of each patch.\n-        num_channels (`int`, *optional*, defaults to 3):\n-            The number of input channels.\n-        out_hidden_size (`int`, *optional*, defaults to 4096):\n-            The output hidden size of the vision model.\n-        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n-            The epsilon used by the rms normalization layers.\n-        spatial_merge_size (`int`, *optional*, defaults to 2):\n-            The size used for merging spatial dimensions.\n-        temporal_patch_size (`int`, *optional*, defaults to 2):\n-            The size used for patches along the temporal dimension.\n+            depth (`int`, *optional*, defaults to 24):\n+                Number of layers (depth) in the model.\n+            hidden_size (`int`, *optional*, defaults to 1536):\n+                Dimensionality of the encoder layers and the pooler layer.\n+            hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+                The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+                `\"relu\"`, `\"selu\"` and `\"gelu_new\"` are supported.\n+            attention_bias (`bool`, *optional*, defaults to `False`):\n+                Whether to add a bias to the queries, keys and values.\n+            attention_dropout (`float`, *optional*, defaults to 0.0):\n+                Dropout probability for attention weights.\n+            num_heads (`<fill_type>`, *optional*, defaults to 12): <fill_docstring>\n+            in_channels (`<fill_type>`, *optional*, defaults to 3): <fill_docstring>\n+            image_size (`int` or `list[int]`, *optional*, defaults to 336):\n+                The size (resolution) of each image.\n+            patch_size (`int`, *optional*, defaults to 14):\n+                The size (resolution) of each patch.\n+            rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+                The epsilon used by the rms normalization layers.\n+            spatial_merge_size (`int`, *optional*, defaults to 2):\n+                The size used for merging spatial dimensions.\n+            temporal_patch_size (`int`, *optional*, defaults to 2):\n+                The size used for patches along the temporal dimension.\n+            out_hidden_size (`int`, *optional*, defaults to 4096):\n+                The output hidden size of the vision model.\n+            intermediate_size (`int`, *optional*, defaults to 13696):\n+                Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+            initializer_range (`float`, *optional*, defaults to 0.02):\n+                The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n     Example:\n \n     ```python\n@@ -80,7 +76,7 @@ class Glm4vVisionConfig(PreTrainedConfig):\n     >>> configuration = model.config\n     ```\"\"\"\n \n-    model_type = \"glm4v\"\n+    model_type = \"glm4v_vision\"\n     base_config_key = \"vision_config\"\n \n     def __init__(\n@@ -334,4 +330,4 @@ def __init__(\n         super().__init__(**kwargs)\n \n \n-__all__ = [\"Glm4vConfig\", \"Glm4vTextConfig\"]\n+__all__ = [\"Glm4vConfig\", \"Glm4vTextConfig\", \"Glm4vVisionConfig\"]"
        },
        {
            "sha": "fb57f66a9ae0d8328db5fd02728684257d226f56",
            "filename": "src/transformers/models/glm4v/convert_glm4v_mgt_weights_to_hf.py",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconvert_glm4v_mgt_weights_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconvert_glm4v_mgt_weights_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fconvert_glm4v_mgt_weights_to_hf.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -710,6 +710,7 @@ def offset_layer(x, offset=llm_layer_offset):\n \n     if \"vision_config\" in model_config:\n         vision_config = {\n+            \"model_type\": \"glm4v_vision\",\n             \"hidden_size\": model_config[\"vision_config\"].get(\"hidden_size\", 1536),\n             \"depth\": model_config[\"vision_config\"].get(\"num_layers\", 24),\n             \"num_heads\": model_config[\"vision_config\"].get(\"num_attention_heads\", 12),"
        },
        {
            "sha": "47ad72ac96ce7628b214ff481976fb9880b51506",
            "filename": "src/transformers/models/glm4v/modeling_glm4v.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodeling_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodeling_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodeling_glm4v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -1680,4 +1680,4 @@ def _expand_dict_for_generation(dict_to_expand):\n         return input_ids, model_kwargs\n \n \n-__all__ = [\"Glm4vForConditionalGeneration\", \"Glm4vModel\", \"Glm4vPreTrainedModel\", \"Glm4vTextModel\"]\n+__all__ = [\"Glm4vForConditionalGeneration\", \"Glm4vModel\", \"Glm4vPreTrainedModel\", \"Glm4vTextModel\", \"Glm4vVisionModel\"]"
        },
        {
            "sha": "2df8b6f9d04a44690dc1df18d9f419c7b8401f57",
            "filename": "src/transformers/models/glm4v/modular_glm4v.py",
            "status": "modified",
            "additions": 36,
            "deletions": 35,
            "changes": 71,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodular_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodular_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fmodular_glm4v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -69,39 +69,35 @@ class Glm4vVisionConfig(PreTrainedConfig):\n     GLM-4.1V-9B-Thinking [THUDM/GLM-4.1V-9B-Thinking](https://huggingface.co/THUDM/GLM-4.1V-9B-Thinking).\n \n     Args:\n-        hidden_size (`int`, *optional*, defaults to 1536):\n-            Dimensionality of the encoder layers and the pooler layer.\n-        depth (`int`, *optional*, defaults to 24):\n-            Number of layers (depth) in the model.\n-        attention_bias (`bool`, *optional*, defaults to `False`):\n-            Whether to add a bias to the queries, keys and values.\n-        intermediate_size (`int`, *optional*, defaults to 13696):\n-            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n-        hidden_act (`str` or `function`, *optional*, defaults to `\"selu\"`):\n-            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n-            `\"relu\"`, `\"selu\"` and `\"gelu_new\"` are supported.\n-        hidden_dropout_prob (`float`, *optional*, defaults to 0.0):\n-            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n-        attention_dropout (`float`, *optional*, defaults to 0.0):\n-            Dropout probability for attention weights.\n-        projection_dropout (`float`, *optional*, defaults to 0.0):\n-            Dropout probability for the projection layer.\n-        initializer_range (`float`, *optional*, defaults to 0.02):\n-            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n-        image_size (`int` or `list[int]`, *optional*, defaults to `[336, 336]`):\n-            The size (resolution) of each image.\n-        patch_size (`int`, *optional*, defaults to `14`):\n-            The size (resolution) of each patch.\n-        num_channels (`int`, *optional*, defaults to 3):\n-            The number of input channels.\n-        out_hidden_size (`int`, *optional*, defaults to 4096):\n-            The output hidden size of the vision model.\n-        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n-            The epsilon used by the rms normalization layers.\n-        spatial_merge_size (`int`, *optional*, defaults to 2):\n-            The size used for merging spatial dimensions.\n-        temporal_patch_size (`int`, *optional*, defaults to 2):\n-            The size used for patches along the temporal dimension.\n+            depth (`int`, *optional*, defaults to 24):\n+                Number of layers (depth) in the model.\n+            hidden_size (`int`, *optional*, defaults to 1536):\n+                Dimensionality of the encoder layers and the pooler layer.\n+            hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+                The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+                `\"relu\"`, `\"selu\"` and `\"gelu_new\"` are supported.\n+            attention_bias (`bool`, *optional*, defaults to `False`):\n+                Whether to add a bias to the queries, keys and values.\n+            attention_dropout (`float`, *optional*, defaults to 0.0):\n+                Dropout probability for attention weights.\n+            num_heads (`<fill_type>`, *optional*, defaults to 12): <fill_docstring>\n+            in_channels (`<fill_type>`, *optional*, defaults to 3): <fill_docstring>\n+            image_size (`int` or `list[int]`, *optional*, defaults to 336):\n+                The size (resolution) of each image.\n+            patch_size (`int`, *optional*, defaults to 14):\n+                The size (resolution) of each patch.\n+            rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+                The epsilon used by the rms normalization layers.\n+            spatial_merge_size (`int`, *optional*, defaults to 2):\n+                The size used for merging spatial dimensions.\n+            temporal_patch_size (`int`, *optional*, defaults to 2):\n+                The size used for patches along the temporal dimension.\n+            out_hidden_size (`int`, *optional*, defaults to 4096):\n+                The output hidden size of the vision model.\n+            intermediate_size (`int`, *optional*, defaults to 13696):\n+                Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+            initializer_range (`float`, *optional*, defaults to 0.02):\n+                The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n     Example:\n \n     ```python\n@@ -117,7 +113,7 @@ class Glm4vVisionConfig(PreTrainedConfig):\n     >>> configuration = model.config\n     ```\"\"\"\n \n-    model_type = \"glm4v\"\n+    model_type = \"glm4v_vision\"\n     base_config_key = \"vision_config\"\n \n     def __init__(\n@@ -1653,7 +1649,7 @@ def __call__(\n \n                     for frame_idx in range(num_frames):\n                         timestamp_sec = selected_timestamps[frame_idx]\n-                        frame_structure = f\"<|begin_of_image|>{self.image_token}<|end_of_image|>{int(timestamp_sec)}\"\n+                        frame_structure = self.replace_frame_token_id(timestamp_sec)\n                         video_structure += frame_structure\n \n                     text[i] = text[i].replace(self.video_token, video_structure, 1)\n@@ -1679,13 +1675,18 @@ def __call__(\n             text_inputs[\"mm_token_type_ids\"] = mm_token_type_ids.tolist()\n         return BatchFeature(data={**text_inputs, **image_inputs, **videos_inputs}, tensor_type=return_tensors)\n \n+    def replace_frame_token_id(self, timestamp_sec):\n+        return f\"<|begin_of_image|>{self.image_token}<|end_of_image|>{int(timestamp_sec)}\"\n+\n \n __all__ = [\n     \"Glm4vConfig\",\n     \"Glm4vTextConfig\",\n+    \"Glm4vVisionConfig\",\n     \"Glm4vForConditionalGeneration\",\n     \"Glm4vModel\",\n     \"Glm4vPreTrainedModel\",\n     \"Glm4vProcessor\",\n     \"Glm4vTextModel\",\n+    \"Glm4vVisionModel\",\n ]"
        },
        {
            "sha": "73202f073f9b69a1c4338bf2188df562f4529d1a",
            "filename": "src/transformers/models/glm4v/processing_glm4v.py",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fprocessing_glm4v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v%2Fprocessing_glm4v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v%2Fprocessing_glm4v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -180,7 +180,7 @@ def __call__(\n \n                     for frame_idx in range(num_frames):\n                         timestamp_sec = selected_timestamps[frame_idx]\n-                        frame_structure = f\"<|begin_of_image|>{self.image_token}<|end_of_image|>{int(timestamp_sec)}\"\n+                        frame_structure = self.replace_frame_token_id(timestamp_sec)\n                         video_structure += frame_structure\n \n                     text[i] = text[i].replace(self.video_token, video_structure, 1)\n@@ -271,5 +271,8 @@ def post_process_image_text_to_text(\n             **kwargs,\n         )\n \n+    def replace_frame_token_id(self, timestamp_sec):\n+        return f\"<|begin_of_image|>{self.image_token}<|end_of_image|>{int(timestamp_sec)}\"\n+\n \n __all__ = [\"Glm4vProcessor\"]"
        },
        {
            "sha": "3d158e1b19cb571294a4941de21984a40e053db5",
            "filename": "src/transformers/models/glm4v_moe/configuration_glm4v_moe.py",
            "status": "modified",
            "additions": 32,
            "deletions": 36,
            "changes": 68,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fconfiguration_glm4v_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fconfiguration_glm4v_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fconfiguration_glm4v_moe.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -32,39 +32,35 @@ class Glm4vMoeVisionConfig(PreTrainedConfig):\n     GLM-4.1V-9B-Thinking [THUDM/GLM-4.1V-9B-Thinking](https://huggingface.co/THUDM/GLM-4.1V-9B-Thinking).\n \n     Args:\n-        hidden_size (`int`, *optional*, defaults to 1536):\n-            Dimensionality of the encoder layers and the pooler layer.\n-        depth (`int`, *optional*, defaults to 24):\n-            Number of layers (depth) in the model.\n-        attention_bias (`bool`, *optional*, defaults to `False`):\n-            Whether to add a bias to the queries, keys and values.\n-        intermediate_size (`int`, *optional*, defaults to 13696):\n-            Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n-        hidden_act (`str` or `function`, *optional*, defaults to `\"selu\"`):\n-            The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n-            `\"relu\"`, `\"selu\"` and `\"gelu_new\"` are supported.\n-        hidden_dropout_prob (`float`, *optional*, defaults to 0.0):\n-            The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.\n-        attention_dropout (`float`, *optional*, defaults to 0.0):\n-            Dropout probability for attention weights.\n-        projection_dropout (`float`, *optional*, defaults to 0.0):\n-            Dropout probability for the projection layer.\n-        initializer_range (`float`, *optional*, defaults to 0.02):\n-            The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n-        image_size (`int` or `list[int]`, *optional*, defaults to `[336, 336]`):\n-            The size (resolution) of each image.\n-        patch_size (`int`, *optional*, defaults to `14`):\n-            The size (resolution) of each patch.\n-        num_channels (`int`, *optional*, defaults to 3):\n-            The number of input channels.\n-        out_hidden_size (`int`, *optional*, defaults to 4096):\n-            The output hidden size of the vision model.\n-        rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n-            The epsilon used by the rms normalization layers.\n-        spatial_merge_size (`int`, *optional*, defaults to 2):\n-            The size used for merging spatial dimensions.\n-        temporal_patch_size (`int`, *optional*, defaults to 2):\n-            The size used for patches along the temporal dimension.\n+            depth (`int`, *optional*, defaults to 24):\n+                Number of layers (depth) in the model.\n+            hidden_size (`int`, *optional*, defaults to 1536):\n+                Dimensionality of the encoder layers and the pooler layer.\n+            hidden_act (`str` or `function`, *optional*, defaults to `\"silu\"`):\n+                The non-linear activation function (function or string) in the encoder and pooler. If string, `\"gelu\"`,\n+                `\"relu\"`, `\"selu\"` and `\"gelu_new\"` are supported.\n+            attention_bias (`bool`, *optional*, defaults to `False`):\n+                Whether to add a bias to the queries, keys and values.\n+            attention_dropout (`float`, *optional*, defaults to 0.0):\n+                Dropout probability for attention weights.\n+            num_heads (`<fill_type>`, *optional*, defaults to 12): <fill_docstring>\n+            in_channels (`<fill_type>`, *optional*, defaults to 3): <fill_docstring>\n+            image_size (`int` or `list[int]`, *optional*, defaults to 336):\n+                The size (resolution) of each image.\n+            patch_size (`int`, *optional*, defaults to 14):\n+                The size (resolution) of each patch.\n+            rms_norm_eps (`float`, *optional*, defaults to 1e-05):\n+                The epsilon used by the rms normalization layers.\n+            spatial_merge_size (`int`, *optional*, defaults to 2):\n+                The size used for merging spatial dimensions.\n+            temporal_patch_size (`int`, *optional*, defaults to 2):\n+                The size used for patches along the temporal dimension.\n+            out_hidden_size (`int`, *optional*, defaults to 4096):\n+                The output hidden size of the vision model.\n+            intermediate_size (`int`, *optional*, defaults to 13696):\n+                Dimensionality of the \"intermediate\" (i.e., feed-forward) layer in the Transformer encoder.\n+            initializer_range (`float`, *optional*, defaults to 0.02):\n+                The standard deviation of the truncated_normal_initializer for initializing all weight matrices.\n     Example:\n \n     ```python\n@@ -80,7 +76,7 @@ class Glm4vMoeVisionConfig(PreTrainedConfig):\n     >>> configuration = model.config\n     ```\"\"\"\n \n-    model_type = \"glm4v_moe\"\n+    model_type = \"glm4v_moe_vision\"\n     base_config_key = \"vision_config\"\n \n     def __init__(\n@@ -206,7 +202,7 @@ class Glm4vMoeTextConfig(PreTrainedConfig):\n     >>> configuration = model.config\n     ```\"\"\"\n \n-    model_type = \"Glm4vMoe_text\"\n+    model_type = \"glm4v_moe_text\"\n     keys_to_ignore_at_inference = [\"past_key_values\"]\n     # Default tensor parallel plan for base model `Glm4vMoe`\n     base_model_tp_plan = {\n@@ -374,4 +370,4 @@ def __init__(\n         super().__init__(**kwargs)\n \n \n-__all__ = [\"Glm4vMoeConfig\", \"Glm4vMoeTextConfig\"]\n+__all__ = [\"Glm4vMoeConfig\", \"Glm4vMoeTextConfig\", \"Glm4vMoeVisionConfig\"]"
        },
        {
            "sha": "d8b08716b6c4253dc4c2b702eff7f0ae1b026671",
            "filename": "src/transformers/models/glm4v_moe/convert_glm4v_moe_mgt_weights_to_hf.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fconvert_glm4v_moe_mgt_weights_to_hf.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fconvert_glm4v_moe_mgt_weights_to_hf.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fconvert_glm4v_moe_mgt_weights_to_hf.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -713,7 +713,7 @@ def offset_layer(x, offset=llm_layer_offset):\n \n     if \"vision_config\" in model_config:\n         vision_config = {\n-            \"model_type\": \"glm4v_moe\",\n+            \"model_type\": \"glm4v_moe_vision\",\n             \"hidden_size\": model_config[\"vision_config\"].get(\"hidden_size\", 1536),\n             \"depth\": model_config[\"vision_config\"].get(\"num_layers\", 24),\n             \"num_heads\": model_config[\"vision_config\"].get(\"num_attention_heads\", 12),"
        },
        {
            "sha": "631505562bc6e28511e808cab0d39f913db0e07a",
            "filename": "src/transformers/models/glm4v_moe/modeling_glm4v_moe.py",
            "status": "modified",
            "additions": 117,
            "deletions": 110,
            "changes": 227,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodeling_glm4v_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodeling_glm4v_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodeling_glm4v_moe.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -591,115 +591,6 @@ class Glm4vMoeCausalLMOutputWithPast(ModelOutput):\n     aux_loss: Optional[torch.FloatTensor] = None\n \n \n-@auto_docstring\n-class Glm4vMoeTextModel(Glm4vMoePreTrainedModel):\n-    config: Glm4vMoeTextConfig\n-    input_modalities = \"text\"\n-\n-    def __init__(self, config: Glm4vMoeTextConfig):\n-        super().__init__(config)\n-        self.padding_idx = config.pad_token_id\n-        self.vocab_size = config.vocab_size\n-\n-        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n-        self.layers = nn.ModuleList(\n-            [Glm4vMoeTextDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n-        )\n-        self.norm = Glm4vMoeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n-        self.rotary_emb = Glm4vMoeTextRotaryEmbedding(config=config)\n-\n-        self.gradient_checkpointing = False\n-        # Initialize weights and apply final processing\n-        self.post_init()\n-\n-    @auto_docstring\n-    @check_model_inputs()\n-    def forward(\n-        self,\n-        input_ids: Optional[torch.LongTensor] = None,\n-        attention_mask: Optional[torch.Tensor] = None,\n-        position_ids: Optional[torch.LongTensor] = None,\n-        past_key_values: Optional[Cache] = None,\n-        inputs_embeds: Optional[torch.FloatTensor] = None,\n-        use_cache: Optional[bool] = None,\n-        cache_position: Optional[torch.LongTensor] = None,\n-        **kwargs: Unpack[FlashAttentionKwargs],\n-    ) -> MoeModelOutputWithPast:\n-        if (input_ids is None) ^ (inputs_embeds is not None):\n-            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n-\n-        # torch.jit.trace() doesn't support cache objects in the output\n-        if use_cache and past_key_values is None and not torch.jit.is_tracing():\n-            past_key_values = DynamicCache(config=self.config)\n-\n-        if inputs_embeds is None:\n-            inputs_embeds = self.embed_tokens(input_ids)\n-\n-        if cache_position is None:\n-            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n-            cache_position = torch.arange(\n-                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n-            )\n-\n-        # the hard coded `3` is for temporal, height and width.\n-        if position_ids is None:\n-            position_ids = cache_position.view(1, 1, -1).expand(3, inputs_embeds.shape[0], -1)\n-        elif position_ids.ndim == 2:\n-            position_ids = position_ids[None, ...].expand(3, position_ids.shape[0], -1)\n-\n-        # NOTE: we need to pass text position ids for packing. Qwen2-VL uses 3D positions\n-        # where each dim indicates visual spatial positions for temporal/height/width grids.\n-        # There are two scenarios when FA2-like packed masking might be activated.\n-        # 1. User specifically passed packed `position_ids` and no attention mask.\n-        #    In this case we expect the useer to create correct position ids for all 3 grids\n-        #    and prepend text-only position ids to it. The final tensor will be [4, bs, seq-len]\n-        # 2. User runs forward with no attention mask and no position ids. In this case, position ids\n-        #    are prepared by the model (`get_rope_index`) as `[4, bs, seq-len]` tensor. Text-only positions are\n-        #    prepended by us when creating positions so that the mask is constructed correctly. NOTE: failing to pass\n-        #    text-only positions will cause incorrect mask construction, do not change `prepare_input_for_generation`\n-        if position_ids.ndim == 3 and position_ids.shape[0] == 4:\n-            text_position_ids = position_ids[0]\n-            position_ids = position_ids[1:]\n-        else:\n-            # If inputs are not packed (usual 3D positions), do not prepare mask from position_ids\n-            text_position_ids = None\n-\n-        mask_kwargs = {\n-            \"config\": self.config,\n-            \"input_embeds\": inputs_embeds,\n-            \"attention_mask\": attention_mask,\n-            \"cache_position\": cache_position,\n-            \"past_key_values\": past_key_values,\n-            \"position_ids\": text_position_ids,\n-        }\n-        # Create the masks\n-        causal_mask = create_causal_mask(**mask_kwargs)\n-\n-        hidden_states = inputs_embeds\n-\n-        # create position embeddings to be shared across the decoder layers\n-        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n-\n-        for i, decoder_layer in enumerate(self.layers[: self.config.num_hidden_layers]):\n-            layer_outputs = decoder_layer(\n-                hidden_states,\n-                position_embeddings=position_embeddings,\n-                attention_mask=causal_mask,\n-                position_ids=position_ids,\n-                past_key_values=past_key_values,\n-                cache_position=cache_position,\n-                **kwargs,\n-            )\n-            hidden_states = layer_outputs\n-\n-        hidden_states = self.norm(hidden_states)\n-\n-        return MoeModelOutputWithPast(\n-            last_hidden_state=hidden_states,\n-            past_key_values=past_key_values,\n-        )\n-\n-\n class Glm4vMoeisionMlp(nn.Module):\n     def __init__(self, config, bias: bool = False):\n         super().__init__()\n@@ -976,6 +867,7 @@ def forward(\n         return hidden_states\n \n \n+@auto_docstring\n class Glm4vMoeVisionModel(Glm4vMoePreTrainedModel):\n     config: Glm4vMoeVisionConfig\n     input_modalities = [\"image\", \"video\"]\n@@ -1087,6 +979,115 @@ def forward(self, hidden_states: torch.Tensor, grid_thw: torch.Tensor) -> torch.\n         return hidden_states\n \n \n+@auto_docstring\n+class Glm4vMoeTextModel(Glm4vMoePreTrainedModel):\n+    config: Glm4vMoeTextConfig\n+    input_modalities = \"text\"\n+\n+    def __init__(self, config: Glm4vMoeTextConfig):\n+        super().__init__(config)\n+        self.padding_idx = config.pad_token_id\n+        self.vocab_size = config.vocab_size\n+\n+        self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)\n+        self.layers = nn.ModuleList(\n+            [Glm4vMoeTextDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]\n+        )\n+        self.norm = Glm4vMoeRMSNorm(config.hidden_size, eps=config.rms_norm_eps)\n+        self.rotary_emb = Glm4vMoeTextRotaryEmbedding(config=config)\n+\n+        self.gradient_checkpointing = False\n+        # Initialize weights and apply final processing\n+        self.post_init()\n+\n+    @auto_docstring\n+    @check_model_inputs()\n+    def forward(\n+        self,\n+        input_ids: Optional[torch.LongTensor] = None,\n+        attention_mask: Optional[torch.Tensor] = None,\n+        position_ids: Optional[torch.LongTensor] = None,\n+        past_key_values: Optional[Cache] = None,\n+        inputs_embeds: Optional[torch.FloatTensor] = None,\n+        use_cache: Optional[bool] = None,\n+        cache_position: Optional[torch.LongTensor] = None,\n+        **kwargs: Unpack[FlashAttentionKwargs],\n+    ) -> MoeModelOutputWithPast:\n+        if (input_ids is None) ^ (inputs_embeds is not None):\n+            raise ValueError(\"You must specify exactly one of input_ids or inputs_embeds\")\n+\n+        # torch.jit.trace() doesn't support cache objects in the output\n+        if use_cache and past_key_values is None and not torch.jit.is_tracing():\n+            past_key_values = DynamicCache(config=self.config)\n+\n+        if inputs_embeds is None:\n+            inputs_embeds = self.embed_tokens(input_ids)\n+\n+        if cache_position is None:\n+            past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0\n+            cache_position = torch.arange(\n+                past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device\n+            )\n+\n+        # the hard coded `3` is for temporal, height and width.\n+        if position_ids is None:\n+            position_ids = cache_position.view(1, 1, -1).expand(3, inputs_embeds.shape[0], -1)\n+        elif position_ids.ndim == 2:\n+            position_ids = position_ids[None, ...].expand(3, position_ids.shape[0], -1)\n+\n+        # NOTE: we need to pass text position ids for packing. Qwen2-VL uses 3D positions\n+        # where each dim indicates visual spatial positions for temporal/height/width grids.\n+        # There are two scenarios when FA2-like packed masking might be activated.\n+        # 1. User specifically passed packed `position_ids` and no attention mask.\n+        #    In this case we expect the useer to create correct position ids for all 3 grids\n+        #    and prepend text-only position ids to it. The final tensor will be [4, bs, seq-len]\n+        # 2. User runs forward with no attention mask and no position ids. In this case, position ids\n+        #    are prepared by the model (`get_rope_index`) as `[4, bs, seq-len]` tensor. Text-only positions are\n+        #    prepended by us when creating positions so that the mask is constructed correctly. NOTE: failing to pass\n+        #    text-only positions will cause incorrect mask construction, do not change `prepare_input_for_generation`\n+        if position_ids.ndim == 3 and position_ids.shape[0] == 4:\n+            text_position_ids = position_ids[0]\n+            position_ids = position_ids[1:]\n+        else:\n+            # If inputs are not packed (usual 3D positions), do not prepare mask from position_ids\n+            text_position_ids = None\n+\n+        mask_kwargs = {\n+            \"config\": self.config,\n+            \"input_embeds\": inputs_embeds,\n+            \"attention_mask\": attention_mask,\n+            \"cache_position\": cache_position,\n+            \"past_key_values\": past_key_values,\n+            \"position_ids\": text_position_ids,\n+        }\n+        # Create the masks\n+        causal_mask = create_causal_mask(**mask_kwargs)\n+\n+        hidden_states = inputs_embeds\n+\n+        # create position embeddings to be shared across the decoder layers\n+        position_embeddings = self.rotary_emb(hidden_states, position_ids)\n+\n+        for i, decoder_layer in enumerate(self.layers[: self.config.num_hidden_layers]):\n+            layer_outputs = decoder_layer(\n+                hidden_states,\n+                position_embeddings=position_embeddings,\n+                attention_mask=causal_mask,\n+                position_ids=position_ids,\n+                past_key_values=past_key_values,\n+                cache_position=cache_position,\n+                **kwargs,\n+            )\n+            hidden_states = layer_outputs\n+\n+        hidden_states = self.norm(hidden_states)\n+\n+        return MoeModelOutputWithPast(\n+            last_hidden_state=hidden_states,\n+            past_key_values=past_key_values,\n+        )\n+\n+\n @auto_docstring\n class Glm4vMoeModel(Glm4vMoePreTrainedModel):\n     base_model_prefix = \"\"\n@@ -1909,4 +1910,10 @@ def _expand_dict_for_generation(dict_to_expand):\n         return input_ids, model_kwargs\n \n \n-__all__ = [\"Glm4vMoeForConditionalGeneration\", \"Glm4vMoeModel\", \"Glm4vMoePreTrainedModel\", \"Glm4vMoeTextModel\"]\n+__all__ = [\n+    \"Glm4vMoeForConditionalGeneration\",\n+    \"Glm4vMoeModel\",\n+    \"Glm4vMoePreTrainedModel\",\n+    \"Glm4vMoeTextModel\",\n+    \"Glm4vMoeVisionModel\",\n+]"
        },
        {
            "sha": "c69ca84393159e18745cf5837d24318ca635d968",
            "filename": "src/transformers/models/glm4v_moe/modular_glm4v_moe.py",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodular_glm4v_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodular_glm4v_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Fmodels%2Fglm4v_moe%2Fmodular_glm4v_moe.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -45,6 +45,7 @@\n     Glm4vForConditionalGeneration,\n     Glm4vTextModel,\n     Glm4vTextRotaryEmbedding,\n+    Glm4vVisionModel,\n     rotate_half,\n )\n from ..qwen3_vl_moe.modeling_qwen3_vl_moe import (\n@@ -150,7 +151,7 @@ class Glm4vMoeTextConfig(Glm4MoeConfig):\n     >>> configuration = model.config\n     ```\"\"\"\n \n-    model_type = \"Glm4vMoe_text\"\n+    model_type = \"glm4v_moe_text\"\n     base_config_key = \"text_config\"\n     keys_to_ignore_at_inference = [\"past_key_values\"]\n     # Default tensor parallel plan for base model `Glm4vMoe`\n@@ -490,6 +491,11 @@ class Glm4vMoeCausalLMOutputWithPast(Qwen3VLMoeCausalLMOutputWithPast):\n     pass\n \n \n+@auto_docstring\n+class Glm4vMoeVisionModel(Glm4vVisionModel):\n+    pass\n+\n+\n @auto_docstring\n class Glm4vMoeTextModel(Glm4vTextModel):\n     def forward(\n@@ -647,8 +653,10 @@ def forward(\n __all__ = [\n     \"Glm4vMoeConfig\",\n     \"Glm4vMoeTextConfig\",\n+    \"Glm4vMoeVisionConfig\",\n     \"Glm4vMoeForConditionalGeneration\",\n     \"Glm4vMoeModel\",  # noqa: F822\n     \"Glm4vMoePreTrainedModel\",\n-    \"Glm4vMoeTextModel\",  # noqa: F822\n+    \"Glm4vMoeTextModel\",\n+    \"Glm4vMoeVisionModel\",\n ]"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "tests/models/glm46v/__init__.py",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/tests%2Fmodels%2Fglm46v%2F__init__.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/tests%2Fmodels%2Fglm46v%2F__init__.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fglm46v%2F__init__.py?ref=66d57110f089789ae285cc9d54d3bf051123246b"
        },
        {
            "sha": "6034a3dbde3d0bdbcd7dcd5ca5bc3e8e152aae48",
            "filename": "tests/models/glm46v/test_modeling_glm46v.py",
            "status": "added",
            "additions": 585,
            "deletions": 0,
            "changes": 585,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/tests%2Fmodels%2Fglm46v%2Ftest_modeling_glm46v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/tests%2Fmodels%2Fglm46v%2Ftest_modeling_glm46v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fglm46v%2Ftest_modeling_glm46v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -0,0 +1,585 @@\n+# Copyright 2025 The HuggingFace Inc. team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\"\"\"Testing suite for the PyTorch GLM-4.6V model.\"\"\"\n+\n+import copy\n+import unittest\n+\n+from transformers import (\n+    AutoProcessor,\n+    Glm46VConfig,\n+    Glm46VForConditionalGeneration,\n+    Glm46VModel,\n+    is_torch_available,\n+)\n+from transformers.testing_utils import (\n+    Expectations,\n+    cleanup,\n+    require_deterministic_for_xpu,\n+    require_flash_attn,\n+    require_torch,\n+    require_torch_gpu,\n+    slow,\n+    torch_device,\n+)\n+\n+from ...generation.test_utils import GenerationTesterMixin\n+from ...test_configuration_common import ConfigTester\n+from ...test_modeling_common import (\n+    ModelTesterMixin,\n+    floats_tensor,\n+    ids_tensor,\n+)\n+\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+class Glm46VVisionText2TextModelTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=3,\n+        seq_length=7,\n+        num_channels=3,\n+        ignore_index=-100,\n+        image_size=112,\n+        video_start_token_id=3,\n+        video_end_token_id=4,\n+        image_start_token_id=5,\n+        image_end_token_id=6,\n+        image_token_id=7,\n+        video_token_id=8,\n+        is_training=True,\n+        text_config={\n+            \"vocab_size\": 99,\n+            \"hidden_size\": 16,\n+            \"intermediate_size\": 22,\n+            \"num_hidden_layers\": 2,\n+            \"num_attention_heads\": 2,\n+            \"num_key_value_heads\": 1,\n+            \"output_channels\": 64,\n+            \"hidden_act\": \"silu\",\n+            \"max_position_embeddings\": 512,\n+            \"rope_parameters\": {\"type\": \"default\", \"mrope_section\": [2, 1, 1]},\n+            \"rope_theta\": 10000,\n+            \"tie_word_embeddings\": True,\n+            \"bos_token_id\": 0,\n+            \"eos_token_id\": 0,\n+            \"pad_token_id\": 0,\n+        },\n+        vision_config={\n+            \"depth\": 2,\n+            \"hidden_act\": \"silu\",\n+            \"hidden_size\": 48,\n+            \"out_hidden_size\": 16,\n+            \"intermediate_size\": 22,\n+            \"patch_size\": 14,\n+            \"spatial_merge_size\": 1,\n+            \"temporal_patch_size\": 2,\n+        },\n+    ):\n+        self.parent = parent\n+        self.ignore_index = ignore_index\n+        self.bos_token_id = text_config[\"bos_token_id\"]\n+        self.eos_token_id = text_config[\"eos_token_id\"]\n+        self.pad_token_id = text_config[\"pad_token_id\"]\n+        self.video_start_token_id = video_start_token_id\n+        self.video_end_token_id = video_end_token_id\n+        self.image_start_token_id = image_start_token_id\n+        self.image_end_token_id = image_end_token_id\n+        self.image_token_id = image_token_id\n+        self.video_token_id = video_token_id\n+        self.text_config = text_config\n+        self.vision_config = vision_config\n+        self.batch_size = batch_size\n+        self.num_channels = num_channels\n+        self.image_size = image_size\n+        self.is_training = is_training\n+        self.hidden_size = text_config[\"hidden_size\"]\n+        self.num_hidden_layers = text_config[\"num_hidden_layers\"]\n+        self.num_attention_heads = text_config[\"num_attention_heads\"]\n+        self.vocab_size = text_config[\"vocab_size\"]\n+        self.num_image_tokens = 64\n+        self.seq_length = seq_length + self.num_image_tokens\n+\n+    def get_config(self):\n+        return Glm46VConfig(\n+            text_config=self.text_config,\n+            vision_config=self.vision_config,\n+            image_token_id=self.image_token_id,\n+            video_token_id=self.video_token_id,\n+            video_start_token_id=self.video_start_token_id,\n+            video_end_token_id=self.video_end_token_id,\n+            image_start_token_id=self.image_start_token_id,\n+            image_end_token_id=self.image_end_token_id,\n+        )\n+\n+    def prepare_config_and_inputs(self):\n+        config = self.get_config()\n+        patch_size = config.vision_config.patch_size\n+        temporal_patch_size = config.vision_config.temporal_patch_size\n+        pixel_values = floats_tensor(\n+            [\n+                self.batch_size * (self.image_size**2) // (patch_size**2),\n+                self.num_channels * (patch_size**2) * temporal_patch_size,\n+            ]\n+        )\n+\n+        return config, pixel_values\n+\n+    def prepare_config_and_inputs_for_common(self):\n+        config_and_inputs = self.prepare_config_and_inputs()\n+        config, pixel_values = config_and_inputs\n+        input_ids = ids_tensor([self.batch_size, self.seq_length], self.vocab_size)\n+        attention_mask = torch.ones(input_ids.shape, dtype=torch.long, device=torch_device)\n+\n+        input_ids[input_ids == self.video_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.video_start_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_start_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.video_end_token_id] = self.pad_token_id\n+        input_ids[input_ids == self.image_end_token_id] = self.pad_token_id\n+\n+        input_ids[:, 0] = self.image_start_token_id\n+        input_ids[:, 1 : 1 + self.num_image_tokens] = self.image_token_id\n+        input_ids[:, 1 + self.num_image_tokens] = self.image_end_token_id\n+        patch_size = config.vision_config.patch_size\n+        patches_per_side = self.image_size // patch_size\n+\n+        inputs_dict = {\n+            \"pixel_values\": pixel_values,\n+            \"image_grid_thw\": torch.tensor(\n+                [[1, patches_per_side, patches_per_side]] * self.batch_size, device=torch_device\n+            ),\n+            \"input_ids\": input_ids,\n+            \"attention_mask\": attention_mask,\n+        }\n+        return config, inputs_dict\n+\n+\n+@require_torch\n+class Glm46VModelTest(ModelTesterMixin, GenerationTesterMixin, unittest.TestCase):\n+    all_model_classes = (Glm46VModel, Glm46VForConditionalGeneration) if is_torch_available() else ()\n+\n+    model_split_percents = [0.7, 0.9]  # model too big to split at 0.5\n+    _is_composite = True\n+\n+    def setUp(self):\n+        self.model_tester = Glm46VVisionText2TextModelTester(self)\n+        self.config_tester = ConfigTester(self, config_class=Glm46VConfig, has_text_modality=False)\n+\n+    def test_config(self):\n+        self.config_tester.run_common_tests()\n+\n+    # GLM4V has images shaped as (bs*patch_len, dim) so we can't slice to batches in generate\n+    def prepare_config_and_inputs_for_generate(self, batch_size=2):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        # We don't want a few model inputs in our model input dictionary for generation tests\n+        input_keys_to_ignore = [\n+            # we don't want to mask attention heads\n+            # we don't want encoder-decoder models to start from filled decoder ids\n+            \"decoder_input_ids\",\n+            \"decoder_attention_mask\",\n+            # we'll set cache use in each test differently\n+            \"use_cache\",\n+            # Ignore labels if it is in the input dict\n+            \"labels\",\n+            # model-specific exceptions should overload/overwrite this function\n+        ]\n+\n+        # The diff from the general `prepare_config_and_inputs_for_generate` lies here\n+        patch_size = config.vision_config.patch_size\n+        filtered_image_length = batch_size * (self.model_tester.image_size**2) // (patch_size**2)\n+        filtered_inputs_dict = {\n+            k: v[:batch_size, ...] if isinstance(v, torch.Tensor) else v\n+            for k, v in inputs_dict.items()\n+            if k not in input_keys_to_ignore\n+        }\n+        filtered_inputs_dict[\"pixel_values\"] = inputs_dict[\"pixel_values\"][:filtered_image_length]\n+\n+        # It is important set `eos_token_id` to `None` to avoid early stopping (would break for length-based checks)\n+        text_gen_config = config.get_text_config(decoder=True)\n+        if text_gen_config.eos_token_id is not None and text_gen_config.pad_token_id is None:\n+            text_gen_config.pad_token_id = (\n+                text_gen_config.eos_token_id\n+                if isinstance(text_gen_config.eos_token_id, int)\n+                else text_gen_config.eos_token_id[0]\n+            )\n+        text_gen_config.eos_token_id = None\n+        text_gen_config.forced_eos_token_id = None\n+\n+        return config, filtered_inputs_dict\n+\n+    @unittest.skip(reason=\"No available kernels - not supported\")\n+    def test_sdpa_can_dispatch_on_flash(self):\n+        pass\n+\n+    @unittest.skip(reason=\"Size mismatch\")\n+    def test_multi_gpu_data_parallel_forward(self):\n+        pass\n+\n+    @unittest.skip(\"Error with compilation\")\n+    def test_generate_from_inputs_embeds_with_static_cache(self):\n+        pass\n+\n+    def test_inputs_embeds(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            inputs = copy.deepcopy(self._prepare_for_class(inputs_dict, model_class))\n+\n+            input_ids = inputs[\"input_ids\"]\n+            del inputs[\"input_ids\"]\n+            del inputs[\"pixel_values\"]\n+            del inputs[\"image_grid_thw\"]\n+\n+            wte = model.get_input_embeddings()\n+            inputs[\"inputs_embeds\"] = wte(input_ids)\n+            with torch.no_grad():\n+                model(**inputs)[0]\n+\n+    def test_inputs_embeds_matches_input_ids(self):\n+        config, inputs_dict = self.model_tester.prepare_config_and_inputs_for_common()\n+\n+        for model_class in self.all_model_classes:\n+            model = model_class(config)\n+            model.to(torch_device)\n+            model.eval()\n+\n+            inputs = self._prepare_for_class(inputs_dict, model_class)\n+            input_ids = inputs[\"input_ids\"]\n+            del inputs[\"input_ids\"]\n+            del inputs[\"pixel_values\"]\n+            del inputs[\"image_grid_thw\"]\n+\n+            inputs_embeds = model.get_input_embeddings()(input_ids)\n+\n+            with torch.no_grad():\n+                out_ids = model(input_ids=input_ids, **inputs)[0]\n+                out_embeds = model(inputs_embeds=inputs_embeds, **inputs)[0]\n+            torch.testing.assert_close(out_embeds, out_ids)\n+\n+\n+@require_torch\n+class Glm46VIntegrationTest(unittest.TestCase):\n+    def setUp(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+        self.processor = AutoProcessor.from_pretrained(\"THUDM/GLM-4.1V-9B-Thinking\")\n+        self.message = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"image\",\n+                        \"url\": \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/pipeline-cat-chonk.jpeg\",\n+                    },\n+                    {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+                ],\n+            }\n+        ]\n+        self.message2 = [\n+            {\n+                \"role\": \"user\",\n+                \"content\": [\n+                    {\n+                        \"type\": \"image\",\n+                        \"url\": \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/coco_sample.png\",\n+                    },\n+                    {\"type\": \"text\", \"text\": \"What kind of dog is this?\"},\n+                ],\n+            }\n+        ]\n+\n+    def tearDown(self):\n+        cleanup(torch_device, gc_collect=True)\n+\n+    @slow\n+    def test_small_model_integration_test(self):\n+        model = Glm46VForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\", dtype=\"auto\", device_map=\"auto\"\n+        )\n+\n+        inputs = self.processor.apply_chat_template(\n+            self.message, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\"\n+        )\n+        expected_input_ids = [151331, 151333, 151336, 198, 151339, 151343, 151343, 151343, 151343, 151343, 151343, 151343, 151343, 151343, 151343, 151343, 151343]  # fmt: skip\n+        assert expected_input_ids == inputs.input_ids[0].tolist()[:17]\n+\n+        expected_pixel_slice = torch.tensor(\n+            [\n+                [-0.0988, -0.0842, -0.0842],\n+                [-0.5660, -0.5514, -0.4200],\n+                [-0.0259, -0.0259, -0.0259],\n+                [-0.1280, -0.0988, -0.2010],\n+                [-0.4638, -0.5806, -0.6974],\n+                [-1.2083, -1.2229, -1.2083],\n+            ],\n+            dtype=torch.float32,\n+            device=\"cpu\",\n+        )\n+        assert torch.allclose(expected_pixel_slice, inputs.pixel_values[:6, :3], atol=3e-3)\n+\n+        # verify generation\n+        inputs = inputs.to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        EXPECTED_DECODED_TEXT = \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture doesn't look like a dog; it's actually a cat. Specifically\"\n+        self.assertEqual(\n+            self.processor.decode(output[0], skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_batch(self):\n+        model = Glm46VForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\", dtype=\"auto\", device_map=\"auto\"\n+        )\n+        batch_messages = [self.message] * 2\n+        inputs = self.processor.apply_chat_template(\n+            batch_messages, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture doesn't look like a dog; it's actually a cat. Specifically\",\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture has a stocky body, thick fur, and a face that's\"\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_with_video(self):\n+        processor = AutoProcessor.from_pretrained(\"THUDM/GLM-4.1V-9B-Thinking\", max_image_size={\"longest_edge\": 50176})\n+        model = Glm46VForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\", dtype=torch.float16, device_map=\"auto\"\n+        )\n+        questions = [\"Describe this video.\"]\n+        video_urls = [\"https://huggingface.co/datasets/hf-internal-testing/fixtures_videos/resolve/main/tennis.mp4\"]\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\n+                            \"type\": \"video\",\n+                            \"video\": video_url,\n+                        },\n+                        {\"type\": \"text\", \"text\": question},\n+                    ],\n+                }\n+            ]\n+            for question, video_url in zip(questions, video_urls)\n+        ]\n+        inputs = processor.apply_chat_template(\n+            messages, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\", padding=True\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        output = model.generate(**inputs, max_new_tokens=30)\n+        EXPECTED_DECODED_TEXT = [\"\\n012345Describe this video.\\n<think>Got it, let's analyze the video. First, the scene is an indoor tennis court. There are two players: one in a white shirt\"]  # fmt: skip\n+\n+        self.assertEqual(\n+            processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    @require_deterministic_for_xpu\n+    def test_small_model_integration_test_expand(self):\n+        model = Glm46VForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\", dtype=\"auto\", device_map=\"auto\"\n+        )\n+        inputs = self.processor.apply_chat_template(\n+            self.message, tokenize=True, add_generation_prompt=True, return_dict=True, return_tensors=\"pt\"\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        output = model.generate(**inputs, max_new_tokens=30, do_sample=False, num_beams=2, num_return_sequences=2)\n+\n+        # fmt: off\n+        EXPECTED_DECODED_TEXTS = Expectations(\n+            {\n+\n+                (None, None): [\"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture doesn't look like a dog; it's actually a cat. Specifically\",\n+                               \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture doesn't look like a dog; it's actually a cat, specifically\"\n+                              ],\n+                (\"xpu\", None): [\"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture is not a dog; it's a cat. Specifically, it looks\",\n+                                \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture is not a dog; it's a cat, specifically a Pallas\"\n+                               ],\n+            }\n+        )\n+        # fmt: on\n+        EXPECTED_DECODED_TEXT = EXPECTED_DECODED_TEXTS.get_expectation()\n+\n+        decoded_text = self.processor.batch_decode(output, skip_special_tokens=True)\n+        self.assertEqual(decoded_text, EXPECTED_DECODED_TEXT)\n+\n+    @slow\n+    def test_small_model_integration_test_batch_wo_image(self):\n+        model = Glm46VForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\", dtype=\"auto\", device_map=\"auto\"\n+        )\n+        message_wo_image = [\n+            {\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"Who are you?\"}]},\n+        ]\n+        batched_messages = [self.message, message_wo_image]\n+        inputs = self.processor.apply_chat_template(\n+            batched_messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture doesn't look like a dog; it's actually a cat. Specifically\",\n+            \"\\nWho are you?\\n<think>Got it, let's look at the user's question: \\\"Who are you?\\\" This is a common question when someone is just starting a conversation\"\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    def test_small_model_integration_test_batch_different_resolutions(self):\n+        model = Glm46VForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\", dtype=\"auto\", device_map=\"auto\"\n+        )\n+        batched_messages = [self.message, self.message2]\n+        inputs = self.processor.apply_chat_template(\n+            batched_messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture doesn't look like a dog; it's actually a cat. Specifically\",\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. Wait, the animals here are cats, not dogs. The question is about a dog, but\",\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    @require_flash_attn\n+    @require_torch_gpu\n+    def test_small_model_integration_test_batch_flashatt2(self):\n+        model = Glm46VForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\",\n+            dtype=torch.bfloat16,\n+            attn_implementation=\"flash_attention_2\",\n+            device_map=\"auto\",\n+        )\n+        batched_messages = [self.message, self.message2]\n+        inputs = self.processor.apply_chat_template(\n+            batched_messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture doesn't look like a dog. Wait, it's a cat,\",\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. Wait, the animals here are cats, not dogs. The question is about a dog, but\"\n+        ]  # fmt: skip\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )\n+\n+    @slow\n+    @require_flash_attn\n+    @require_torch_gpu\n+    def test_small_model_integration_test_batch_wo_image_flashatt2(self):\n+        model = Glm46VForConditionalGeneration.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\",\n+            dtype=torch.bfloat16,\n+            attn_implementation=\"flash_attention_2\",\n+            device_map=\"auto\",\n+        )\n+        message_wo_image = [\n+            {\"role\": \"user\", \"content\": [{\"type\": \"text\", \"text\": \"Who are you?\"}]},\n+        ]\n+        batched_messages = [self.message, message_wo_image]\n+        inputs = self.processor.apply_chat_template(\n+            batched_messages,\n+            tokenize=True,\n+            add_generation_prompt=True,\n+            return_dict=True,\n+            return_tensors=\"pt\",\n+            padding=True,\n+        ).to(torch_device)\n+\n+        # This model on the hub has `do_sample=True`.\n+        torch.manual_seed(42)\n+\n+        # it should not matter whether two images are the same size or not\n+        output = model.generate(**inputs, max_new_tokens=30)\n+\n+        EXPECTED_DECODED_TEXT = [\n+            \"\\nWhat kind of dog is this?\\n<think>Got it, let's look at the image. The animal in the picture doesn't look like a dog; it's actually a cat. Specifically\",\n+            \"\\nWho are you?\\n<think>Got it, let's look at the user's question: \\\"Who are you?\\\" This is a common question when someone is just starting a conversation\"\n+        ]  # fmt: skip\n+\n+        self.assertEqual(\n+            self.processor.batch_decode(output, skip_special_tokens=True),\n+            EXPECTED_DECODED_TEXT,\n+        )"
        },
        {
            "sha": "4e9fb4449d67108d9972204a05db6c2fc00f2504",
            "filename": "tests/models/glm46v/test_processor_glm46v.py",
            "status": "added",
            "additions": 279,
            "deletions": 0,
            "changes": 279,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/tests%2Fmodels%2Fglm46v%2Ftest_processor_glm46v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/tests%2Fmodels%2Fglm46v%2Ftest_processor_glm46v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fglm46v%2Ftest_processor_glm46v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -0,0 +1,279 @@\n+# Copyright 2025 The HuggingFace Team. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import inspect\n+import shutil\n+import tempfile\n+import unittest\n+\n+import numpy as np\n+\n+from transformers import AutoProcessor\n+from transformers.testing_utils import require_av, require_torch, require_vision\n+from transformers.utils import is_torch_available, is_vision_available\n+\n+from ...test_processing_common import ProcessorTesterMixin, url_to_local_path\n+\n+\n+if is_vision_available():\n+    from transformers import Glm46VProcessor\n+\n+if is_torch_available():\n+    import torch\n+\n+\n+@require_vision\n+@require_torch\n+class Glm46VProcessorTest(ProcessorTesterMixin, unittest.TestCase):\n+    processor_class = Glm46VProcessor\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.tmpdirname = tempfile.mkdtemp()\n+        processor = Glm46VProcessor.from_pretrained(\n+            \"THUDM/GLM-4.1V-9B-Thinking\", patch_size=4, size={\"shortest_edge\": 12 * 12, \"longest_edge\": 18 * 18}\n+        )\n+        processor.save_pretrained(cls.tmpdirname)\n+        cls.image_token = processor.image_token\n+\n+    def get_tokenizer(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).tokenizer\n+\n+    def get_image_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).image_processor\n+\n+    def get_video_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs).video_processor\n+\n+    def get_processor(self, **kwargs):\n+        return AutoProcessor.from_pretrained(self.tmpdirname, **kwargs)\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        shutil.rmtree(cls.tmpdirname, ignore_errors=True)\n+\n+    @require_torch\n+    @require_av\n+    def _test_apply_chat_template(\n+        self,\n+        modality: str,\n+        batch_size: int,\n+        return_tensors: str,\n+        input_name: str,\n+        processor_name: str,\n+        input_data: list[str],\n+    ):\n+        processor = self.get_processor()\n+        if processor.chat_template is None:\n+            self.skipTest(\"Processor has no chat template\")\n+\n+        if processor_name not in self.processor_class.get_attributes():\n+            self.skipTest(f\"{processor_name} attribute not present in {self.processor_class}\")\n+\n+        batch_messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [{\"type\": \"text\", \"text\": \"Describe this.\"}],\n+                },\n+            ]\n+        ] * batch_size\n+\n+        # Test that jinja can be applied\n+        formatted_prompt = processor.apply_chat_template(batch_messages, add_generation_prompt=True, tokenize=False)\n+        self.assertEqual(len(formatted_prompt), batch_size)\n+\n+        # Test that tokenizing with template and directly with `self.tokenizer` gives same output\n+        formatted_prompt_tokenized = processor.apply_chat_template(\n+            batch_messages, add_generation_prompt=True, tokenize=True, return_tensors=return_tensors\n+        )\n+        add_special_tokens = True\n+        if processor.tokenizer.bos_token is not None and formatted_prompt[0].startswith(processor.tokenizer.bos_token):\n+            add_special_tokens = False\n+        tok_output = processor.tokenizer(\n+            formatted_prompt, return_tensors=return_tensors, add_special_tokens=add_special_tokens\n+        )\n+        expected_output = tok_output.input_ids\n+        self.assertListEqual(expected_output.tolist(), formatted_prompt_tokenized.tolist())\n+\n+        # Test that kwargs passed to processor's `__call__` are actually used\n+        tokenized_prompt_100 = processor.apply_chat_template(\n+            batch_messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            padding=\"max_length\",\n+            truncation=True,\n+            return_tensors=return_tensors,\n+            max_length=100,\n+        )\n+        self.assertEqual(len(tokenized_prompt_100[0]), 100)\n+\n+        # Test that `return_dict=True` returns text related inputs in the dict\n+        out_dict_text = processor.apply_chat_template(\n+            batch_messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=return_tensors,\n+        )\n+        self.assertTrue(all(key in out_dict_text for key in [\"input_ids\", \"attention_mask\"]))\n+        self.assertEqual(len(out_dict_text[\"input_ids\"]), batch_size)\n+        self.assertEqual(len(out_dict_text[\"attention_mask\"]), batch_size)\n+\n+        # Test that with modality URLs and `return_dict=True`, we get modality inputs in the dict\n+        for idx, url in enumerate(input_data[:batch_size]):\n+            batch_messages[idx][0][\"content\"] = [batch_messages[idx][0][\"content\"][0], {\"type\": modality, \"url\": url}]\n+\n+        out_dict = processor.apply_chat_template(\n+            batch_messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            return_tensors=return_tensors,\n+            fps=2\n+            if isinstance(input_data[0], str)\n+            else None,  # by default no more than 2 frames per second, otherwise too slow\n+            do_sample_frames=bool(isinstance(input_data[0], str)),  # don't sample frames if decoded video is used\n+        )\n+        input_name = getattr(self, input_name)\n+        self.assertTrue(input_name in out_dict)\n+        self.assertEqual(len(out_dict[\"input_ids\"]), batch_size)\n+        self.assertEqual(len(out_dict[\"attention_mask\"]), batch_size)\n+\n+        if modality == \"video\":\n+            # qwen pixels don't scale with bs same way as other models, calculate expected video token count based on video_grid_thw\n+            expected_video_token_count = 0\n+            for thw in out_dict[\"video_grid_thw\"]:\n+                expected_video_token_count += thw[0] * thw[1] * thw[2]\n+            mm_len = expected_video_token_count\n+        else:\n+            mm_len = batch_size * 4\n+        self.assertEqual(len(out_dict[input_name]), mm_len)\n+\n+        return_tensor_to_type = {\"pt\": torch.Tensor, \"np\": np.ndarray, None: list}\n+        for k in out_dict:\n+            self.assertIsInstance(out_dict[k], return_tensor_to_type[return_tensors])\n+\n+    @require_av\n+    def test_apply_chat_template_video_frame_sampling(self):\n+        processor = self.get_processor()\n+        if processor.chat_template is None:\n+            self.skipTest(\"Processor has no chat template\")\n+\n+        signature = inspect.signature(processor.__call__)\n+        if \"videos\" not in {*signature.parameters.keys()} or (\n+            signature.parameters.get(\"videos\") is not None\n+            and signature.parameters[\"videos\"].annotation == inspect._empty\n+        ):\n+            self.skipTest(\"Processor doesn't accept videos at input\")\n+\n+        messages = [\n+            [\n+                {\n+                    \"role\": \"user\",\n+                    \"content\": [\n+                        {\"type\": \"video\"},\n+                        {\"type\": \"text\", \"text\": \"What is shown in this video?\"},\n+                    ],\n+                },\n+            ]\n+        ]\n+\n+        formatted_prompt = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=False)\n+        self.assertEqual(len(formatted_prompt), 1)\n+\n+        formatted_prompt_tokenized = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=True)\n+        expected_output = processor.tokenizer(formatted_prompt, return_tensors=None).input_ids\n+        self.assertListEqual(expected_output, formatted_prompt_tokenized)\n+\n+        out_dict = processor.apply_chat_template(messages, add_generation_prompt=True, tokenize=True, return_dict=True)\n+        self.assertListEqual(list(out_dict.keys()), [\"input_ids\", \"attention_mask\"])\n+\n+        # Add video URL for return dict and load with `num_frames` arg\n+        messages[0][0][\"content\"][0] = {\n+            \"type\": \"video\",\n+            \"url\": url_to_local_path(\n+                \"https://huggingface.co/datasets/raushan-testing-hf/videos-test/resolve/main/tiny_video.mp4\"\n+            ),\n+        }\n+\n+        # Load with `video_fps` arg\n+        video_fps = 10\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            video_fps=video_fps,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 8)\n+\n+        # Load the whole video\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            do_sample_frames=False,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 24)\n+\n+        # Load video as a list of frames (i.e. images). NOTE: each frame should have same size\n+        # because we assume they come from one video\n+        messages[0][0][\"content\"][0] = {\n+            \"type\": \"video\",\n+            \"url\": [\n+                url_to_local_path(\n+                    \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/tasks/australia.jpg\"\n+                ),\n+                url_to_local_path(\n+                    \"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/tasks/australia.jpg\"\n+                ),\n+            ],\n+        }\n+        out_dict_with_video = processor.apply_chat_template(\n+            messages,\n+            add_generation_prompt=True,\n+            tokenize=True,\n+            return_dict=True,\n+            do_sample_frames=False,\n+        )\n+        self.assertTrue(self.videos_input_name in out_dict_with_video)\n+        self.assertEqual(len(out_dict_with_video[self.videos_input_name]), 4)\n+\n+        # When the inputs are frame URLs/paths we expect that those are already\n+        # sampled and will raise an error is asked to sample again.\n+        with self.assertRaisesRegex(\n+            ValueError, \"Sampling frames from a list of images is not supported! Set `do_sample_frames=False`\"\n+        ):\n+            out_dict_with_video = processor.apply_chat_template(\n+                messages,\n+                add_generation_prompt=True,\n+                tokenize=True,\n+                return_dict=True,\n+                do_sample_frames=True,\n+            )\n+\n+    def test_model_input_names(self):\n+        processor = self.get_processor()\n+\n+        text = self.prepare_text_inputs(modalities=[\"image\", \"video\"])\n+        image_input = self.prepare_image_inputs()\n+        video_inputs = self.prepare_video_inputs()\n+        inputs_dict = {\"text\": text, \"images\": image_input, \"videos\": video_inputs}\n+        inputs = processor(**inputs_dict, return_tensors=\"pt\", do_sample_frames=False)\n+\n+        self.assertSetEqual(set(inputs.keys()), set(processor.model_input_names))"
        },
        {
            "sha": "fc62901a71be6ec02e9440f951e4856fb7f89caf",
            "filename": "tests/models/glm46v/test_video_processing_glm46v.py",
            "status": "added",
            "additions": 334,
            "deletions": 0,
            "changes": 334,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/tests%2Fmodels%2Fglm46v%2Ftest_video_processing_glm46v.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/tests%2Fmodels%2Fglm46v%2Ftest_video_processing_glm46v.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fglm46v%2Ftest_video_processing_glm46v.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -0,0 +1,334 @@\n+# coding=utf-8\n+# Copyright 2025 HuggingFace Inc.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+import numpy as np\n+\n+from transformers.image_utils import IMAGENET_STANDARD_MEAN, IMAGENET_STANDARD_STD\n+from transformers.testing_utils import require_torch, require_vision\n+from transformers.utils import is_torch_available, is_torchvision_available, is_vision_available\n+\n+from ...test_video_processing_common import VideoProcessingTestMixin, prepare_video_inputs\n+\n+\n+if is_torch_available():\n+    from PIL import Image\n+\n+if is_vision_available():\n+    if is_torchvision_available():\n+        from transformers import Glm46VVideoProcessor\n+        from transformers.models.glm46v.video_processing_glm46v import smart_resize\n+\n+\n+class Glm46VVideoProcessingTester:\n+    def __init__(\n+        self,\n+        parent,\n+        batch_size=5,\n+        num_frames=8,\n+        num_channels=3,\n+        min_resolution=30,\n+        max_resolution=80,\n+        temporal_patch_size=2,\n+        patch_size=14,\n+        merge_size=2,\n+        do_resize=True,\n+        size=None,\n+        do_normalize=True,\n+        image_mean=IMAGENET_STANDARD_MEAN,\n+        image_std=IMAGENET_STANDARD_STD,\n+        do_convert_rgb=True,\n+    ):\n+        size = size if size is not None else {\"longest_edge\": 20, \"shortest_edge\": 10}\n+        self.parent = parent\n+        self.batch_size = batch_size\n+        self.num_frames = num_frames\n+        self.num_channels = num_channels\n+        self.min_resolution = min_resolution\n+        self.max_resolution = max_resolution\n+        self.do_resize = do_resize\n+        self.size = size\n+        self.do_normalize = do_normalize\n+        self.image_mean = image_mean\n+        self.image_std = image_std\n+        self.do_convert_rgb = do_convert_rgb\n+        self.temporal_patch_size = temporal_patch_size\n+        self.patch_size = patch_size\n+        self.merge_size = merge_size\n+\n+    def prepare_video_processor_dict(self):\n+        return {\n+            \"do_resize\": self.do_resize,\n+            \"size\": self.size,\n+            \"do_normalize\": self.do_normalize,\n+            \"image_mean\": self.image_mean,\n+            \"image_std\": self.image_std,\n+            \"do_convert_rgb\": self.do_convert_rgb,\n+            \"do_sample_frames\": True,\n+        }\n+\n+    def prepare_video_metadata(self, videos):\n+        video_metadata = []\n+        for video in videos:\n+            if isinstance(video, list):\n+                num_frames = len(video)\n+            elif hasattr(video, \"shape\"):\n+                if len(video.shape) == 4:  # (T, H, W, C)\n+                    num_frames = video.shape[0]\n+                else:\n+                    num_frames = 1\n+            else:\n+                num_frames = self.num_frames\n+\n+            metadata = {\n+                \"fps\": 2,\n+                \"duration\": num_frames / 2,\n+                \"total_num_frames\": num_frames,\n+            }\n+            video_metadata.append(metadata)\n+        return video_metadata\n+\n+    def expected_output_video_shape(self, videos):\n+        grid_t = self.num_frames // self.temporal_patch_size\n+        hidden_dim = self.num_channels * self.temporal_patch_size * self.patch_size * self.patch_size\n+        seq_len = 0\n+        for video in videos:\n+            if isinstance(video, list) and isinstance(video[0], Image.Image):\n+                video = np.stack([np.array(frame) for frame in video])\n+            elif hasattr(video, \"shape\"):\n+                pass\n+            else:\n+                video = np.array(video)\n+\n+            if hasattr(video, \"shape\") and len(video.shape) >= 3:\n+                if len(video.shape) == 4:\n+                    t, height, width = video.shape[:3]\n+                elif len(video.shape) == 3:\n+                    height, width = video.shape[:2]\n+                    t = 1\n+                else:\n+                    t, height, width = self.num_frames, self.min_resolution, self.min_resolution\n+            else:\n+                t, height, width = self.num_frames, self.min_resolution, self.min_resolution\n+\n+            resized_height, resized_width = smart_resize(\n+                t,\n+                height,\n+                width,\n+                factor=self.patch_size * self.merge_size,\n+                min_pixels=self.size[\"shortest_edge\"],\n+                max_pixels=self.size[\"longest_edge\"],\n+            )\n+            grid_h, grid_w = resized_height // self.patch_size, resized_width // self.patch_size\n+            seq_len += grid_t * grid_h * grid_w\n+        return [seq_len, hidden_dim]\n+\n+    def prepare_video_inputs(self, equal_resolution=False, return_tensors=\"pil\"):\n+        videos = prepare_video_inputs(\n+            batch_size=self.batch_size,\n+            num_frames=self.num_frames,\n+            num_channels=self.num_channels,\n+            min_resolution=self.min_resolution,\n+            max_resolution=self.max_resolution,\n+            equal_resolution=equal_resolution,\n+            return_tensors=return_tensors,\n+        )\n+        return videos\n+\n+\n+@require_torch\n+@require_vision\n+class Glm46VVideoProcessingTest(VideoProcessingTestMixin, unittest.TestCase):\n+    fast_video_processing_class = Glm46VVideoProcessor if is_torchvision_available() else None\n+    input_name = \"pixel_values_videos\"\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.video_processor_tester = Glm46VVideoProcessingTester(self)\n+\n+    @property\n+    def video_processor_dict(self):\n+        return self.video_processor_tester.prepare_video_processor_dict()\n+\n+    def test_video_processor_from_dict_with_kwargs(self):\n+        video_processor = self.fast_video_processing_class.from_dict(self.video_processor_dict)\n+        self.assertEqual(video_processor.size, {\"longest_edge\": 20, \"shortest_edge\": 10})\n+\n+        video_processor = self.fast_video_processing_class.from_dict(\n+            self.video_processor_dict, size={\"longest_edge\": 42, \"shortest_edge\": 42}\n+        )\n+        self.assertEqual(video_processor.size, {\"longest_edge\": 42, \"shortest_edge\": 42})\n+\n+    def test_call_pil(self):\n+        for video_processing_class in self.video_processor_list:\n+            video_processing = video_processing_class(**self.video_processor_dict)\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"pil\"\n+            )\n+\n+            for video in video_inputs:\n+                self.assertIsInstance(video[0], Image.Image)\n+\n+            video_metadata = self.video_processor_tester.prepare_video_metadata(video_inputs)\n+            encoded_videos = video_processing(\n+                video_inputs[0], video_metadata=[video_metadata[0]], return_tensors=\"pt\"\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+            encoded_videos = video_processing(video_inputs, video_metadata=video_metadata, return_tensors=\"pt\")[\n+                self.input_name\n+            ]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    def test_call_numpy(self):\n+        for video_processing_class in self.video_processor_list:\n+            video_processing = video_processing_class(**self.video_processor_dict)\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"np\"\n+            )\n+\n+            video_metadata = self.video_processor_tester.prepare_video_metadata(video_inputs)\n+            encoded_videos = video_processing(\n+                video_inputs[0], video_metadata=[video_metadata[0]], return_tensors=\"pt\"\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+            encoded_videos = video_processing(video_inputs, video_metadata=video_metadata, return_tensors=\"pt\")[\n+                self.input_name\n+            ]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    def test_call_pytorch(self):\n+        for video_processing_class in self.video_processor_list:\n+            video_processing = video_processing_class(**self.video_processor_dict)\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"pt\"\n+            )\n+            video_metadata = self.video_processor_tester.prepare_video_metadata(video_inputs)\n+            encoded_videos = video_processing(\n+                video_inputs[0], video_metadata=[video_metadata[0]], return_tensors=\"pt\"\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+            encoded_videos = video_processing(video_inputs, video_metadata=video_metadata, return_tensors=\"pt\")[\n+                self.input_name\n+            ]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    @unittest.skip(\"Skip for now, the test needs adjustment for GLM-4.1V\")\n+    def test_call_numpy_4_channels(self):\n+        for video_processing_class in self.video_processor_list:\n+            # Test that can process videos which have an arbitrary number of channels\n+            # Initialize video_processing\n+            video_processor = video_processing_class(**self.video_processor_dict)\n+\n+            # create random numpy tensors\n+            self.video_processor_tester.num_channels = 4\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"np\"\n+            )\n+\n+            # Test not batched input\n+            encoded_videos = video_processor(\n+                video_inputs[0],\n+                return_tensors=\"pt\",\n+                input_data_format=\"channels_last\",\n+                image_mean=(0.0, 0.0, 0.0, 0.0),\n+                image_std=(1.0, 1.0, 1.0, 1.0),\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+            # Test batched\n+            encoded_videos = video_processor(\n+                video_inputs,\n+                return_tensors=\"pt\",\n+                input_data_format=\"channels_last\",\n+                image_mean=(0.0, 0.0, 0.0, 0.0),\n+                image_std=(1.0, 1.0, 1.0, 1.0),\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    def test_nested_input(self):\n+        \"\"\"Tests that the processor can work with nested list where each video is a list of arrays\"\"\"\n+        for video_processing_class in self.video_processor_list:\n+            video_processing = video_processing_class(**self.video_processor_dict)\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False, return_tensors=\"np\"\n+            )\n+\n+            video_inputs_nested = [list(video) for video in video_inputs]\n+            video_metadata = self.video_processor_tester.prepare_video_metadata(video_inputs)\n+\n+            # Test not batched input\n+            encoded_videos = video_processing(\n+                video_inputs_nested[0], video_metadata=[video_metadata[0]], return_tensors=\"pt\"\n+            )[self.input_name]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape([video_inputs[0]])\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+            # Test batched\n+            encoded_videos = video_processing(video_inputs_nested, video_metadata=video_metadata, return_tensors=\"pt\")[\n+                self.input_name\n+            ]\n+            expected_output_video_shape = self.video_processor_tester.expected_output_video_shape(video_inputs)\n+            self.assertEqual(list(encoded_videos.shape), expected_output_video_shape)\n+\n+    def test_call_sample_frames(self):\n+        for video_processing_class in self.video_processor_list:\n+            video_processor_dict = self.video_processor_dict.copy()\n+            video_processing = video_processing_class(**video_processor_dict)\n+\n+            prev_num_frames = self.video_processor_tester.num_frames\n+            self.video_processor_tester.num_frames = 8\n+            prev_min_resolution = getattr(self.video_processor_tester, \"min_resolution\", None)\n+            prev_max_resolution = getattr(self.video_processor_tester, \"max_resolution\", None)\n+            self.video_processor_tester.min_resolution = 56\n+            self.video_processor_tester.max_resolution = 112\n+\n+            video_inputs = self.video_processor_tester.prepare_video_inputs(\n+                equal_resolution=False,\n+                return_tensors=\"torch\",\n+            )\n+\n+            metadata = [[{\"total_num_frames\": 8, \"fps\": 4}]]\n+            batched_metadata = metadata * len(video_inputs)\n+\n+            encoded_videos = video_processing(video_inputs[0], return_tensors=\"pt\", video_metadata=metadata)[\n+                self.input_name\n+            ]\n+            encoded_videos_batched = video_processing(\n+                video_inputs, return_tensors=\"pt\", video_metadata=batched_metadata\n+            )[self.input_name]\n+\n+            self.assertIsNotNone(encoded_videos)\n+            self.assertIsNotNone(encoded_videos_batched)\n+            self.assertEqual(len(encoded_videos.shape), 2)\n+            self.assertEqual(len(encoded_videos_batched.shape), 2)\n+\n+            with self.assertRaises(ValueError):\n+                video_processing(video_inputs[0], return_tensors=\"pt\")[self.input_name]\n+\n+            self.video_processor_tester.num_frames = prev_num_frames\n+            if prev_min_resolution is not None:\n+                self.video_processor_tester.min_resolution = prev_min_resolution\n+            if prev_max_resolution is not None:\n+                self.video_processor_tester.max_resolution = prev_max_resolution"
        },
        {
            "sha": "afae9ef118a8223e3651720d076100717f8dd7f7",
            "filename": "tests/models/glm4v_moe/test_modeling_glm4v_moe.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/tests%2Fmodels%2Fglm4v_moe%2Ftest_modeling_glm4v_moe.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/tests%2Fmodels%2Fglm4v_moe%2Ftest_modeling_glm4v_moe.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/tests%2Fmodels%2Fglm4v_moe%2Ftest_modeling_glm4v_moe.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -11,7 +11,7 @@\n # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n # See the License for the specific language governing permissions and\n # limitations under the License.\n-\"\"\"Testing suite for the PyTorch GLM-4.1V model.\"\"\"\n+\"\"\"Testing suite for the PyTorch GLM-4.5V model.\"\"\"\n \n import copy\n import unittest"
        },
        {
            "sha": "293fb722b705cbfe7b533cd14c814b465998227d",
            "filename": "utils/check_docstrings.py",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/utils%2Fcheck_docstrings.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/utils%2Fcheck_docstrings.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fcheck_docstrings.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -235,6 +235,8 @@ class DecoratedItem:\n     \"GPTSanJapaneseConfig\",\n     \"GitConfig\",\n     \"GitVisionConfig\",\n+    \"Glm4vVisionConfig\",\n+    \"Glm4vMoeVisionConfig\",\n     \"GraphormerConfig\",\n     \"GroupViTTextConfig\",\n     \"GroupViTVisionConfig\","
        },
        {
            "sha": "14565904d7e31ea30785ddd618269a957eaa7dc5",
            "filename": "utils/models_to_deprecate.py",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/huggingface/transformers/blob/66d57110f089789ae285cc9d54d3bf051123246b/utils%2Fmodels_to_deprecate.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/66d57110f089789ae285cc9d54d3bf051123246b/utils%2Fmodels_to_deprecate.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/utils%2Fmodels_to_deprecate.py?ref=66d57110f089789ae285cc9d54d3bf051123246b",
            "patch": "@@ -92,8 +92,8 @@\n     \"gemma3\": [\"gemma3_text\"],\n     \"gemma3n\": [\"gemma3n_audio\", \"gemma3n_text\", \"gemma3n_vision\"],\n     \"gpt2\": [\"cpm\", \"dialogpt\", \"gpt-sw3\", \"megatron_gpt2\"],\n-    \"glm4v_moe\": [\"glm4v_moe_text\"],\n-    \"glm4v\": [\"glm4v_text\"],\n+    \"glm4v_moe\": [\"glm4v_moe_text\", \"glm4v_moe_vision\"],\n+    \"glm4v\": [\"glm4v_text\", \"glm4v_vision\"],\n     \"idefics3\": [\"idefics3_vision\"],\n     \"internvl\": [\"internvl_vision\"],\n     \"layoutlmv2\": [\"layoutxlm\"],"
        }
    ],
    "stats": {
        "total": 4154,
        "additions": 3928,
        "deletions": 226
    }
}