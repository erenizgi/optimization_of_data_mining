{
    "author": "ydshieh",
    "message": "Minor fix for #40727 (#40929)\n\n* fix\n\n* fix\n\n---------\n\nCo-authored-by: ydshieh <ydshieh@users.noreply.github.com>",
    "sha": "89949c5d2d70f8b8a2bc6cd36677a920ba756103",
    "files": [
        {
            "sha": "d8ec621245567837efd05bec9ae84cd57e108a12",
            "filename": "src/transformers/testing_utils.py",
            "status": "modified",
            "additions": 18,
            "deletions": 6,
            "changes": 24,
            "blob_url": "https://github.com/huggingface/transformers/blob/89949c5d2d70f8b8a2bc6cd36677a920ba756103/src%2Ftransformers%2Ftesting_utils.py",
            "raw_url": "https://github.com/huggingface/transformers/raw/89949c5d2d70f8b8a2bc6cd36677a920ba756103/src%2Ftransformers%2Ftesting_utils.py",
            "contents_url": "https://api.github.com/repos/huggingface/transformers/contents/src%2Ftransformers%2Ftesting_utils.py?ref=89949c5d2d70f8b8a2bc6cd36677a920ba756103",
            "patch": "@@ -3466,15 +3466,21 @@ def _get_test_info():\n     if test_frame is not None:\n         line_number = test_frame.lineno\n \n-    # most inner (recent) to most outer () frames\n+    # The frame of `patched` being called (the one and the only one calling `_get_test_info`)\n+    # This is used to get the original method being patched in order to get the context.\n+    frame_of_patched_obj = None\n+\n     captured_frames = []\n     to_capture = False\n-    # up to the test method being called\n+    # From the most outer (i.e. python's `runpy.py`) frame to most inner frame (i.e. the frame of this method)\n+    # Between `the test method being called` and `before entering `patched``.\n     for frame in reversed(stack_from_inspect):\n         if test_file in str(frame).replace(r\"\\\\\", \"/\"):\n             if \"self\" in frame.frame.f_locals and test_name == frame.frame.f_locals[\"self\"]._testMethodName:\n                 to_capture = True\n-        elif \"patched\" in frame.frame.f_code.co_name:\n+        # TODO: check simply with the name is not robust.\n+        elif \"patched\" == frame.frame.f_code.co_name:\n+            frame_of_patched_obj = frame\n             to_capture = False\n             break\n         if to_capture:\n@@ -3486,11 +3492,17 @@ def _get_test_info():\n         tb_next = tb\n     test_traceback = tb\n \n+    origin_method_being_patched = frame_of_patched_obj.frame.f_locals[\"orig_method\"]\n+\n+    # An iterable of type `traceback.StackSummary` with each element of type `FrameSummary`\n     stack = traceback.extract_stack()\n+    # The frame which calls `the original method being patched`\n+    caller_frame = None\n+    # From the most inner (i.e. recent) frame to the most outer frame\n+    for frame in reversed(stack):\n+        if origin_method_being_patched.__name__ in frame.line:\n+            caller_frame = frame\n \n-    # The frame that calls this patched method (it may not be the test method)\n-    # -1: `_get_test_info`; -2: `patched_xxx`; -3: the caller to `patched_xxx`\n-    caller_frame = stack[-3]\n     caller_path = os.path.relpath(caller_frame.filename)\n     caller_lineno = caller_frame.lineno\n "
        }
    ],
    "stats": {
        "total": 24,
        "additions": 18,
        "deletions": 6
    }
}