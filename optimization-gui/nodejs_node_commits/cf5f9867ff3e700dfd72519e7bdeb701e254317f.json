{
    "author": "mcollina",
    "message": "stream: 'readable' have precedence over flowing\n\nIn Streams3 the 'readable' event/.read() method had a lower precedence\nthan the `'data'` event that made them impossible to use them together.\nThis make `.resume()` a no-op if there is a listener for the\n`'readable'` event, making the stream non-flowing if there is a\n`'data'`Â  listener.\n\nFixes: https://github.com/nodejs/node/issues/18058\n\nPR-URL: https://github.com/nodejs/node/pull/18994\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "cf5f9867ff3e700dfd72519e7bdeb701e254317f",
    "files": [
        {
            "sha": "86286906b7f297e2004a9537d28e4b8126d5e2f6",
            "filename": "doc/api/stream.md",
            "status": "modified",
            "additions": 21,
            "deletions": 1,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/cf5f9867ff3e700dfd72519e7bdeb701e254317f/doc%2Fapi%2Fstream.md",
            "raw_url": "https://github.com/nodejs/node/raw/cf5f9867ff3e700dfd72519e7bdeb701e254317f/doc%2Fapi%2Fstream.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fstream.md?ref=cf5f9867ff3e700dfd72519e7bdeb701e254317f",
            "patch": "@@ -762,6 +762,9 @@ changes:\n     description: >\n       'readable' is always emitted in the next tick after\n       .push() is called\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18994\n+    description: Using 'readable' requires calling .read().\n -->\n \n The `'readable'` event is emitted when there is data available to be read from\n@@ -770,10 +773,16 @@ cause some amount of data to be read into an internal buffer.\n \n ```javascript\n const readable = getReadableStreamSomehow();\n-readable.on('readable', () => {\n+readable.on('readable', function() {\n   // there is some data to read now\n+  let data;\n+\n+  while (data = this.read()) {\n+    console.log(data);\n+  }\n });\n ```\n+\n The `'readable'` event will also be emitted once the end of the stream data\n has been reached but before the `'end'` event is emitted.\n \n@@ -806,6 +815,10 @@ In general, the `readable.pipe()` and `'data'` event mechanisms are easier to\n understand than the `'readable'` event. However, handling `'readable'` might\n result in increased throughput.\n \n+If both `'readable'` and [`'data'`][]  are used at the same time, `'readable'`\n+takes precedence in controlling the flow, i.e. `'data'` will be emitted\n+only when [`stream.read()`][stream-read] is called.\n+\n ##### readable.destroy([error])\n <!-- YAML\n added: v8.0.0\n@@ -997,6 +1010,10 @@ the status of the `highWaterMark`.\n ##### readable.resume()\n <!-- YAML\n added: v0.9.4\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/18994\n+    description: Resume has no effect if there is a 'readable' event listening\n -->\n \n * Returns: {this}\n@@ -1016,6 +1033,9 @@ getReadableStreamSomehow()\n   });\n ```\n \n+The `readable.resume()` method has no effect if there is a `'readable'`\n+event listener.\n+\n ##### readable.setEncoding(encoding)\n <!-- YAML\n added: v0.9.4"
        },
        {
            "sha": "5b044e79c1b18d29a687dcb61b95ffdba189db7a",
            "filename": "lib/_stream_readable.js",
            "status": "modified",
            "additions": 50,
            "deletions": 7,
            "changes": 57,
            "blob_url": "https://github.com/nodejs/node/blob/cf5f9867ff3e700dfd72519e7bdeb701e254317f/lib%2F_stream_readable.js",
            "raw_url": "https://github.com/nodejs/node/raw/cf5f9867ff3e700dfd72519e7bdeb701e254317f/lib%2F_stream_readable.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_stream_readable.js?ref=cf5f9867ff3e700dfd72519e7bdeb701e254317f",
            "patch": "@@ -223,6 +223,7 @@ Readable.prototype.unshift = function(chunk) {\n };\n \n function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n+  debug('readableAddChunk', chunk);\n   var state = stream._readableState;\n   if (chunk === null) {\n     state.reading = false;\n@@ -799,20 +800,24 @@ Readable.prototype.unpipe = function(dest) {\n // Ensure readable listeners eventually get something\n Readable.prototype.on = function(ev, fn) {\n   const res = Stream.prototype.on.call(this, ev, fn);\n+  const state = this._readableState;\n \n   if (ev === 'data') {\n-    // Start flowing on next tick if stream isn't explicitly paused\n-    if (this._readableState.flowing !== false)\n+    // update readableListening so that resume() may be a no-op\n+    // a few lines down. This is needed to support once('readable').\n+    state.readableListening = this.listenerCount('readable') > 0;\n+\n+    // Try start flowing on next tick if stream isn't explicitly paused\n+    if (state.flowing !== false)\n       this.resume();\n   } else if (ev === 'readable') {\n-    const state = this._readableState;\n     if (!state.endEmitted && !state.readableListening) {\n       state.readableListening = state.needReadable = true;\n       state.emittedReadable = false;\n-      if (!state.reading) {\n-        process.nextTick(nReadingNextTick, this);\n-      } else if (state.length) {\n+      if (state.length) {\n         emitReadable(this);\n+      } else if (!state.reading) {\n+        process.nextTick(nReadingNextTick, this);\n       }\n     }\n   }\n@@ -821,6 +826,42 @@ Readable.prototype.on = function(ev, fn) {\n };\n Readable.prototype.addListener = Readable.prototype.on;\n \n+Readable.prototype.removeListener = function(ev, fn) {\n+  const res = Stream.prototype.removeListener.call(this, ev, fn);\n+\n+  if (ev === 'readable') {\n+    // We need to check if there is someone still listening to\n+    // to readable and reset the state. However this needs to happen\n+    // after readable has been emitted but before I/O (nextTick) to\n+    // support once('readable', fn) cycles. This means that calling\n+    // resume within the same tick will have no\n+    // effect.\n+    process.nextTick(updateReadableListening, this);\n+  }\n+\n+  return res;\n+};\n+\n+Readable.prototype.removeAllListeners = function(ev) {\n+  const res = Stream.prototype.removeAllListeners.call(this, ev);\n+\n+  if (ev === 'readable' || ev === undefined) {\n+    // We need to check if there is someone still listening to\n+    // to readable and reset the state. However this needs to happen\n+    // after readable has been emitted but before I/O (nextTick) to\n+    // support once('readable', fn) cycles. This means that calling\n+    // resume within the same tick will have no\n+    // effect.\n+    process.nextTick(updateReadableListening, this);\n+  }\n+\n+  return res;\n+};\n+\n+function updateReadableListening(self) {\n+  self._readableState.readableListening = self.listenerCount('readable') > 0;\n+}\n+\n function nReadingNextTick(self) {\n   debug('readable nexttick read 0');\n   self.read(0);\n@@ -832,7 +873,9 @@ Readable.prototype.resume = function() {\n   var state = this._readableState;\n   if (!state.flowing) {\n     debug('resume');\n-    state.flowing = true;\n+    // we flow only if there is no one listening\n+    // for readable\n+    state.flowing = !state.readableListening;\n     resume(this, state);\n   }\n   return this;"
        },
        {
            "sha": "74c9a59b26808370f748f3f9bfc485eb9ac48a42",
            "filename": "test/parallel/test-http-readable-data-event.js",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/nodejs/node/blob/cf5f9867ff3e700dfd72519e7bdeb701e254317f/test%2Fparallel%2Ftest-http-readable-data-event.js",
            "raw_url": "https://github.com/nodejs/node/raw/cf5f9867ff3e700dfd72519e7bdeb701e254317f/test%2Fparallel%2Ftest-http-readable-data-event.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http-readable-data-event.js?ref=cf5f9867ff3e700dfd72519e7bdeb701e254317f",
            "patch": "@@ -0,0 +1,52 @@\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const http = require('http');\n+const helloWorld = 'Hello World!';\n+const helloAgainLater = 'Hello again later!';\n+\n+const server = http.createServer((req, res) => {\n+  res.writeHead(200, {\n+    'Content-Length': '' + (helloWorld.length + helloAgainLater.length)\n+  });\n+  res.write(helloWorld);\n+\n+  // we need to make sure the data is flushed\n+  setTimeout(() => {\n+    res.end(helloAgainLater);\n+  }, common.platformTimeout(10));\n+}).listen(0, function() {\n+  const opts = {\n+    hostname: 'localhost',\n+    port: server.address().port,\n+    path: '/'\n+  };\n+\n+  const expectedData = [helloWorld, helloAgainLater];\n+  const expectedRead = [helloWorld, null, helloAgainLater, null];\n+\n+  const req = http.request(opts, (res) => {\n+    res.on('error', common.mustNotCall);\n+\n+    res.on('readable', common.mustCall(() => {\n+      let data;\n+\n+      do {\n+        data = res.read();\n+        assert.strictEqual(data, expectedRead.shift());\n+      } while (data !== null);\n+    }, 2));\n+\n+    res.setEncoding('utf8');\n+    res.on('data', common.mustCall((data) => {\n+      assert.strictEqual(data, expectedData.shift());\n+    }, 2));\n+\n+    res.on('end', common.mustCall(() => {\n+      server.close();\n+    }));\n+  });\n+\n+  req.end();\n+});"
        },
        {
            "sha": "21361abc346555ae91f89732576a1a07e3148a32",
            "filename": "test/parallel/test-stream-readable-reading-readingMore.js",
            "status": "modified",
            "additions": 143,
            "deletions": 41,
            "changes": 184,
            "blob_url": "https://github.com/nodejs/node/blob/cf5f9867ff3e700dfd72519e7bdeb701e254317f/test%2Fparallel%2Ftest-stream-readable-reading-readingMore.js",
            "raw_url": "https://github.com/nodejs/node/raw/cf5f9867ff3e700dfd72519e7bdeb701e254317f/test%2Fparallel%2Ftest-stream-readable-reading-readingMore.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-stream-readable-reading-readingMore.js?ref=cf5f9867ff3e700dfd72519e7bdeb701e254317f",
            "patch": "@@ -3,64 +3,166 @@ const common = require('../common');\n const assert = require('assert');\n const Readable = require('stream').Readable;\n \n-const readable = new Readable({\n-  read(size) {}\n-});\n+{\n+  const readable = new Readable({\n+    read(size) {}\n+  });\n \n-const state = readable._readableState;\n+  const state = readable._readableState;\n \n-// Starting off with false initially.\n-assert.strictEqual(state.reading, false);\n-assert.strictEqual(state.readingMore, false);\n+  // Starting off with false initially.\n+  assert.strictEqual(state.reading, false);\n+  assert.strictEqual(state.readingMore, false);\n \n-readable.on('data', common.mustCall((data) => {\n-  // while in a flowing state, should try to read more.\n-  if (readable.readableFlowing)\n+  readable.on('data', common.mustCall((data) => {\n+    // while in a flowing state with a 'readable' listener\n+    // we should not be reading more\n+    if (readable.readableFlowing)\n+      assert.strictEqual(state.readingMore, true);\n+\n+    // reading as long as we've not ended\n+    assert.strictEqual(state.reading, !state.ended);\n+  }, 2));\n+\n+  function onStreamEnd() {\n+    // End of stream; state.reading is false\n+    // And so should be readingMore.\n+    assert.strictEqual(state.readingMore, false);\n+    assert.strictEqual(state.reading, false);\n+  }\n+\n+  readable.on('readable', common.mustCall(() => {\n+    // 'readable' always gets called before 'end'\n+    // since 'end' hasn't been emitted, more data could be incoming\n     assert.strictEqual(state.readingMore, true);\n \n-  // reading as long as we've not ended\n-  assert.strictEqual(state.reading, !state.ended);\n-}, 2));\n+    // if the stream has ended, we shouldn't be reading\n+    assert.strictEqual(state.ended, !state.reading);\n+\n+    const data = readable.read();\n+    if (data === null) // reached end of stream\n+      process.nextTick(common.mustCall(onStreamEnd, 1));\n+  }, 2));\n+\n+  readable.on('end', common.mustCall(onStreamEnd));\n+  readable.push('pushed');\n+\n+  readable.read(6);\n+\n+  // reading\n+  assert.strictEqual(state.reading, true);\n+  assert.strictEqual(state.readingMore, true);\n+\n+  // add chunk to front\n+  readable.unshift('unshifted');\n \n-function onStreamEnd() {\n-  // End of stream; state.reading is false\n-  // And so should be readingMore.\n+  // end\n+  readable.push(null);\n+}\n+\n+{\n+  const readable = new Readable({\n+    read(size) {}\n+  });\n+\n+  const state = readable._readableState;\n+\n+  // Starting off with false initially.\n+  assert.strictEqual(state.reading, false);\n   assert.strictEqual(state.readingMore, false);\n+\n+  readable.on('data', common.mustCall((data) => {\n+    // while in a flowing state without a 'readable' listener\n+    // we should be reading more\n+    if (readable.readableFlowing)\n+      assert.strictEqual(state.readingMore, true);\n+\n+    // reading as long as we've not ended\n+    assert.strictEqual(state.reading, !state.ended);\n+  }, 2));\n+\n+  function onStreamEnd() {\n+    // End of stream; state.reading is false\n+    // And so should be readingMore.\n+    assert.strictEqual(state.readingMore, false);\n+    assert.strictEqual(state.reading, false);\n+  }\n+\n+  readable.on('end', common.mustCall(onStreamEnd));\n+  readable.push('pushed');\n+\n+  // stop emitting 'data' events\n+  assert.strictEqual(state.flowing, true);\n+  readable.pause();\n+\n+  // paused\n+  assert.strictEqual(state.reading, false);\n+  assert.strictEqual(state.flowing, false);\n+\n+  readable.resume();\n   assert.strictEqual(state.reading, false);\n+  assert.strictEqual(state.flowing, true);\n+\n+  // add chunk to front\n+  readable.unshift('unshifted');\n+\n+  // end\n+  readable.push(null);\n }\n \n-readable.on('readable', common.mustCall(() => {\n-  // 'readable' always gets called before 'end'\n-  // since 'end' hasn't been emitted, more data could be incoming\n-  assert.strictEqual(state.readingMore, true);\n+{\n+  const readable = new Readable({\n+    read(size) {}\n+  });\n \n-  // if the stream has ended, we shouldn't be reading\n-  assert.strictEqual(state.ended, !state.reading);\n+  const state = readable._readableState;\n \n-  const data = readable.read();\n-  if (data === null) // reached end of stream\n-    process.nextTick(common.mustCall(onStreamEnd, 1));\n-}, 2));\n+  // Starting off with false initially.\n+  assert.strictEqual(state.reading, false);\n+  assert.strictEqual(state.readingMore, false);\n+\n+  const onReadable = common.mustNotCall;\n+\n+  readable.on('readable', onReadable);\n \n-readable.on('end', common.mustCall(onStreamEnd));\n+  readable.on('data', common.mustCall((data) => {\n+    // reading as long as we've not ended\n+    assert.strictEqual(state.reading, !state.ended);\n+  }, 2));\n \n-readable.push('pushed');\n+  readable.removeListener('readable', onReadable);\n \n-// stop emitting 'data' events\n-readable.pause();\n+  function onStreamEnd() {\n+    // End of stream; state.reading is false\n+    // And so should be readingMore.\n+    assert.strictEqual(state.readingMore, false);\n+    assert.strictEqual(state.reading, false);\n+  }\n \n-// read() should only be called while operating in paused mode\n-readable.read(6);\n+  readable.on('end', common.mustCall(onStreamEnd));\n+  readable.push('pushed');\n \n-// reading\n-assert.strictEqual(state.reading, true);\n-assert.strictEqual(state.readingMore, true);\n+  // we are still not flowing, we will be resuming in the next tick\n+  assert.strictEqual(state.flowing, false);\n \n-// resume emitting 'data' events\n-readable.resume();\n+  // wait for nextTick, so the readableListener flag resets\n+  process.nextTick(function() {\n+    readable.resume();\n \n-// add chunk to front\n-readable.unshift('unshifted');\n+    // stop emitting 'data' events\n+    assert.strictEqual(state.flowing, true);\n+    readable.pause();\n \n-// end\n-readable.push(null);\n+    // paused\n+    assert.strictEqual(state.flowing, false);\n+\n+    readable.resume();\n+    assert.strictEqual(state.flowing, true);\n+\n+    // add chunk to front\n+    readable.unshift('unshifted');\n+\n+    // end\n+    readable.push(null);\n+  });\n+}"
        },
        {
            "sha": "5de8d8ec512c2ba0f01ef028051831c79521378b",
            "filename": "test/parallel/test-stream3-pause-then-read.js",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/cf5f9867ff3e700dfd72519e7bdeb701e254317f/test%2Fparallel%2Ftest-stream3-pause-then-read.js",
            "raw_url": "https://github.com/nodejs/node/raw/cf5f9867ff3e700dfd72519e7bdeb701e254317f/test%2Fparallel%2Ftest-stream3-pause-then-read.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-stream3-pause-then-read.js?ref=cf5f9867ff3e700dfd72519e7bdeb701e254317f",
            "patch": "@@ -35,6 +35,7 @@ let expectEndingData = expectTotalData;\n const r = new Readable({ highWaterMark: 1000 });\n let chunks = totalChunks;\n r._read = function(n) {\n+  console.log('_read called', chunks);\n   if (!(chunks % 2))\n     setImmediate(push);\n   else if (!(chunks % 3))\n@@ -49,6 +50,7 @@ function push() {\n   if (chunk) {\n     totalPushed += chunk.length;\n   }\n+  console.log('chunks', chunks);\n   r.push(chunk);\n }\n \n@@ -64,6 +66,7 @@ function readn(n, then) {\n   expectEndingData -= n;\n   (function read() {\n     const c = r.read(n);\n+    console.error('c', c);\n     if (!c)\n       r.once('readable', read);\n     else {"
        }
    ],
    "stats": {
        "total": 318,
        "additions": 269,
        "deletions": 49
    }
}