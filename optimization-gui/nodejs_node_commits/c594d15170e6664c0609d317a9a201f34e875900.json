{
    "author": "ChALkeR",
    "message": "fs: drop duplicate API in promises mode\n\nThis drops exporting duplicate methods that accept FileHandle as the\nfirst argument (to mirror callback-based methods accepting 'fd').\n\nThose methods were not adding actual value to the API because all of\nthose are already present as FileHandle methods, and they would\nprobably be confusing to the new users and making docs harder to read.\n\nAlso, the API was a bit inconsistent and lacked .close(handle).\n\nFixes: https://github.com/nodejs/node/issues/20548\nPR-URL: https://github.com/nodejs/node/pull/20559\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Franziska Hinkelmann <franziska.hinkelmann@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "c594d15170e6664c0609d317a9a201f34e875900",
    "files": [
        {
            "sha": "99a5da5799b7873a74973ea996d56d620e17071c",
            "filename": "benchmark/fs/bench-stat-promise.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/c594d15170e6664c0609d317a9a201f34e875900/benchmark%2Ffs%2Fbench-stat-promise.js",
            "raw_url": "https://github.com/nodejs/node/raw/c594d15170e6664c0609d317a9a201f34e875900/benchmark%2Ffs%2Fbench-stat-promise.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Ffs%2Fbench-stat-promise.js?ref=c594d15170e6664c0609d317a9a201f34e875900",
            "patch": "@@ -9,12 +9,12 @@ const bench = common.createBenchmark(main, {\n });\n \n async function run(n, statType) {\n-  const arg = statType === 'fstat' ?\n-    await fsPromises.open(__filename, 'r') : __filename;\n+  const handleMode = statType === 'fstat';\n+  const arg = handleMode ? await fsPromises.open(__filename, 'r') : __filename;\n   let remaining = n;\n   bench.start();\n   while (remaining-- > 0)\n-    await fsPromises[statType](arg);\n+    await (handleMode ? arg.stat() : fsPromises[statType](arg));\n   bench.end(n);\n \n   if (typeof arg.close === 'function')"
        },
        {
            "sha": "55691dedac19b0c77e99576290aa4de9fc5dce6e",
            "filename": "doc/api/fs.md",
            "status": "modified",
            "additions": 0,
            "deletions": 184,
            "changes": 184,
            "blob_url": "https://github.com/nodejs/node/blob/c594d15170e6664c0609d317a9a201f34e875900/doc%2Fapi%2Ffs.md",
            "raw_url": "https://github.com/nodejs/node/raw/c594d15170e6664c0609d317a9a201f34e875900/doc%2Fapi%2Ffs.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ffs.md?ref=c594d15170e6664c0609d317a9a201f34e875900",
            "patch": "@@ -3797,128 +3797,6 @@ fsPromises.copyFile('source.txt', 'destination.txt', COPYFILE_EXCL)\n   .catch(() => console.log('The file could not be copied'));\n ```\n \n-### fsPromises.fchmod(filehandle, mode)\n-<!-- YAML\n-added: v10.0.0\n--->\n-\n-* `filehandle` {FileHandle}\n-* `mode` {integer}\n-* Returns: {Promise}\n-\n-Asynchronous fchmod(2). The `Promise` is resolved with no arguments upon\n-success.\n-\n-### fsPromises.fchown(filehandle, uid, gid)\n-<!-- YAML\n-added: v10.0.0\n--->\n-\n-* `filehandle` {FileHandle}\n-* `uid` {integer}\n-* `gid` {integer}\n-* Returns: {Promise}\n-\n-Changes the ownership of the file represented by `filehandle` then resolves\n-the `Promise` with no arguments upon success.\n-\n-### fsPromises.fdatasync(filehandle)\n-<!-- YAML\n-added: v10.0.0\n--->\n-\n-* `filehandle` {FileHandle}\n-* Returns: {Promise}\n-\n-Asynchronous fdatasync(2). The `Promise` is resolved with no arguments upon\n-success.\n-\n-### fsPromises.fstat(filehandle)\n-<!-- YAML\n-added: v10.0.0\n--->\n-\n-* `filehandle` {FileHandle}\n-* Returns: {Promise}\n-\n-Retrieves the [`fs.Stats`][] for the given `filehandle`.\n-\n-### fsPromises.fsync(filehandle)\n-<!-- YAML\n-added: v10.0.0\n--->\n-\n-* `filehandle` {FileHandle}\n-* Returns: {Promise}\n-\n-Asynchronous fsync(2). The `Promise` is resolved with no arguments upon\n-success.\n-\n-### fsPromises.ftruncate(filehandle[, len])\n-<!-- YAML\n-added: v10.0.0\n--->\n-\n-* `filehandle` {FileHandle}\n-* `len` {integer} **Default:** `0`\n-* Returns: {Promise}\n-\n-Truncates the file represented by `filehandle` then resolves the `Promise`\n-with no arguments upon success.\n-\n-If the file referred to by the `FileHandle` was larger than `len` bytes, only\n-the first `len` bytes will be retained in the file.\n-\n-For example, the following program retains only the first four bytes of the\n-file:\n-\n-```js\n-console.log(fs.readFileSync('temp.txt', 'utf8'));\n-// Prints: Node.js\n-\n-async function doTruncate() {\n-  const fd = await fsPromises.open('temp.txt', 'r+');\n-  await fsPromises.ftruncate(fd, 4);\n-  console.log(fs.readFileSync('temp.txt', 'utf8'));  // Prints: Node\n-}\n-\n-doTruncate().catch(console.error);\n-```\n-\n-If the file previously was shorter than `len` bytes, it is extended, and the\n-extended part is filled with null bytes (`'\\0'`). For example,\n-\n-```js\n-console.log(fs.readFileSync('temp.txt', 'utf8'));\n-// Prints: Node.js\n-\n-async function doTruncate() {\n-  const fd = await fsPromises.open('temp.txt', 'r+');\n-  await fsPromises.ftruncate(fd, 10);\n-  console.log(fs.readFileSync('temp.txt', 'utf8'));  // Prints Node.js\\0\\0\\0\n-}\n-\n-doTruncate().catch(console.error);\n-```\n-\n-The last three bytes are null bytes (`'\\0'`), to compensate the over-truncation.\n-\n-### fsPromises.futimes(filehandle, atime, mtime)\n-<!-- YAML\n-added: v10.0.0\n--->\n-\n-* `filehandle` {FileHandle}\n-* `atime` {number|string|Date}\n-* `mtime` {number|string|Date}\n-* Returns: {Promise}\n-\n-Change the file system timestamps of the object referenced by the supplied\n-`FileHandle` then resolves the `Promise` with no arguments upon success.\n-\n-This function does not work on AIX versions before 7.1, it will resolve the\n-`Promise` with an error using code `UV_ENOSYS`.\n-\n ### fsPromises.lchmod(path, mode)\n <!-- YAML\n deprecated: v10.0.0\n@@ -4027,35 +3905,6 @@ by [Naming Files, Paths, and Namespaces][]. Under NTFS, if the filename contains\n a colon, Node.js will open a file system stream, as described by\n [this MSDN page][MSDN-Using-Streams].\n \n-### fsPromises.read(filehandle, buffer, offset, length, position)\n-<!-- YAML\n-added: v10.0.0\n--->\n-\n-* `filehandle` {FileHandle}\n-* `buffer` {Buffer|Uint8Array}\n-* `offset` {integer}\n-* `length` {integer}\n-* `position` {integer}\n-* Returns: {Promise}\n-\n-Read data from the file specified by `filehandle`.\n-\n-`buffer` is the buffer that the data will be written to.\n-\n-`offset` is the offset in the buffer to start writing at.\n-\n-`length` is an integer specifying the number of bytes to read.\n-\n-`position` is an argument specifying where to begin reading from in the file.\n-If `position` is `null`, data will be read from the current file position,\n-and the file position will be updated.\n-If `position` is an integer, the file position will remain unchanged.\n-\n-Following successful read, the `Promise` is resolved with an object with a\n-`bytesRead` property specifying the number of bytes read, and a `buffer`\n-property that is a reference to the passed in `buffer` argument.\n-\n ### fsPromises.readdir(path[, options])\n <!-- YAML\n added: v10.0.0\n@@ -4240,39 +4089,6 @@ The `atime` and `mtime` arguments follow these rules:\n - If the value can not be converted to a number, or is `NaN`, `Infinity` or\n   `-Infinity`, an `Error` will be thrown.\n \n-### fsPromises.write(filehandle, buffer[, offset[, length[, position]]])\n-<!-- YAML\n-added: v10.0.0\n--->\n-\n-* `filehandle` {FileHandle}\n-* `buffer` {Buffer|Uint8Array}\n-* `offset` {integer}\n-* `length` {integer}\n-* `position` {integer}\n-* Returns: {Promise}\n-\n-Write `buffer` to the file specified by `filehandle`.\n-\n-The `Promise` is resolved with an object containing a `bytesWritten` property\n-identifying the number of bytes written, and a `buffer` property containing\n-a reference to the `buffer` written.\n-\n-`offset` determines the part of the buffer to be written, and `length` is\n-an integer specifying the number of bytes to write.\n-\n-`position` refers to the offset from the beginning of the file where this data\n-should be written. If `typeof position !== 'number'`, the data will be written\n-at the current position. See pwrite(2).\n-\n-It is unsafe to use `fsPromises.write()` multiple times on the same file\n-without waiting for the `Promise` to be resolved (or rejected). For this\n-scenario, `fs.createWriteStream` is strongly recommended.\n-\n-On Linux, positional writes do not work when the file is opened in append mode.\n-The kernel ignores the position argument and always appends the data to\n-the end of the file.\n-\n ### fsPromises.writeFile(file, data[, options])\n <!-- YAML\n added: v10.0.0"
        },
        {
            "sha": "9700765f0857324680ff52d508fd0df03fd4a7ae",
            "filename": "lib/internal/fs/promises.js",
            "status": "modified",
            "additions": 0,
            "deletions": 9,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/c594d15170e6664c0609d317a9a201f34e875900/lib%2Finternal%2Ffs%2Fpromises.js",
            "raw_url": "https://github.com/nodejs/node/raw/c594d15170e6664c0609d317a9a201f34e875900/lib%2Finternal%2Ffs%2Fpromises.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Fpromises.js?ref=c594d15170e6664c0609d317a9a201f34e875900",
            "patch": "@@ -466,31 +466,22 @@ module.exports = {\n   access,\n   copyFile,\n   open,\n-  read,\n-  write,\n   rename,\n   truncate,\n-  ftruncate,\n   rmdir,\n-  fdatasync,\n-  fsync,\n   mkdir,\n   readdir,\n   readlink,\n   symlink,\n-  fstat,\n   lstat,\n   stat,\n   link,\n   unlink,\n-  fchmod,\n   chmod,\n   lchmod,\n   lchown,\n-  fchown,\n   chown,\n   utimes,\n-  futimes,\n   realpath,\n   mkdtemp,\n   writeFile,"
        },
        {
            "sha": "7dccdea9bc2fd88613ddc706e350aa55d5f42fce",
            "filename": "test/parallel/test-fs-promises.js",
            "status": "modified",
            "additions": 5,
            "deletions": 18,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/c594d15170e6664c0609d317a9a201f34e875900/test%2Fparallel%2Ftest-fs-promises.js",
            "raw_url": "https://github.com/nodejs/node/raw/c594d15170e6664c0609d317a9a201f34e875900/test%2Fparallel%2Ftest-fs-promises.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-promises.js?ref=c594d15170e6664c0609d317a9a201f34e875900",
            "patch": "@@ -11,26 +11,18 @@ const {\n   access,\n   chmod,\n   copyFile,\n-  fchmod,\n-  fdatasync,\n-  fstat,\n-  fsync,\n-  ftruncate,\n-  futimes,\n   link,\n   lstat,\n   mkdir,\n   mkdtemp,\n   open,\n-  read,\n   readdir,\n   readlink,\n   realpath,\n   rename,\n   rmdir,\n   stat,\n   symlink,\n-  write,\n   unlink,\n   utimes\n } = fsPromises;\n@@ -74,13 +66,13 @@ function verifyStatObject(stat) {\n     const handle = await open(dest, 'r+');\n     assert.strictEqual(typeof handle, 'object');\n \n-    let stats = await fstat(handle);\n+    let stats = await handle.stat();\n     verifyStatObject(stats);\n     assert.strictEqual(stats.size, 35);\n \n-    await ftruncate(handle, 1);\n+    await handle.truncate(1);\n \n-    stats = await fstat(handle);\n+    stats = await handle.stat();\n     verifyStatObject(stats);\n     assert.strictEqual(stats.size, 1);\n \n@@ -90,15 +82,13 @@ function verifyStatObject(stat) {\n     stats = await handle.stat();\n     verifyStatObject(stats);\n \n-    await fdatasync(handle);\n     await handle.datasync();\n-    await fsync(handle);\n     await handle.sync();\n \n     const buf = Buffer.from('hello fsPromises');\n     const bufLen = buf.length;\n-    await write(handle, buf);\n-    const ret = await read(handle, Buffer.alloc(bufLen), 0, bufLen, 0);\n+    await handle.write(buf);\n+    const ret = await handle.read(Buffer.alloc(bufLen), 0, bufLen, 0);\n     assert.strictEqual(ret.bytesRead, bufLen);\n     assert.deepStrictEqual(ret.buffer, buf);\n \n@@ -110,18 +100,15 @@ function verifyStatObject(stat) {\n     assert.deepStrictEqual(ret2.buffer, buf2);\n \n     await chmod(dest, 0o666);\n-    await fchmod(handle, 0o666);\n     await handle.chmod(0o666);\n \n     // Mode larger than 0o777 should be masked off.\n     await chmod(dest, (0o777 + 1));\n-    await fchmod(handle, 0o777 + 1);\n     await handle.chmod(0o777 + 1);\n \n     await utimes(dest, new Date(), new Date());\n \n     try {\n-      await futimes(handle, new Date(), new Date());\n       await handle.utimes(new Date(), new Date());\n     } catch (err) {\n       // Some systems do not have futimes. If there is an error,"
        }
    ],
    "stats": {
        "total": 222,
        "additions": 8,
        "deletions": 214
    }
}