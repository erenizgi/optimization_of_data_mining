{
    "author": "unknown",
    "message": "inspector: workers debugging\n\nIntroduce a NodeTarget inspector domain modelled after ChromeDevTools\nTarget domain. It notifies inspector frontend attached to a main V8\nisolate when workers are starting and allows passing messages to\ninspectors on their isolates. All inspector functionality is enabled on\nworker isolates.\n\nPR-URL: https://github.com/nodejs/node/pull/21364\nReviewed-By: Aleksei Koziatinskii <ak239spb@gmail.com>\nReviewed-By: Jan Krems <jan.krems@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "f28c6f7eef58e7c3133bb2cd457d05b986194ba3",
    "files": [
        {
            "sha": "d52748ec2bc56211a8dee0a66e3b98ee67fddac8",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=f28c6f7eef58e7c3133bb2cd457d05b986194ba3",
            "patch": "@@ -509,14 +509,18 @@\n             'src/inspector_socket.cc',\n             'src/inspector_socket_server.cc',\n             'src/inspector/main_thread_interface.cc',\n+            'src/inspector/worker_inspector.cc',\n             'src/inspector/node_string.cc',\n+            'src/inspector/worker_agent.cc',\n             'src/inspector/tracing_agent.cc',\n             'src/inspector_agent.h',\n             'src/inspector_io.h',\n             'src/inspector_socket.h',\n             'src/inspector_socket_server.h',\n             'src/inspector/main_thread_interface.h',\n+            'src/inspector/worker_inspector.h',\n             'src/inspector/node_string.h',\n+            'src/inspector/worker_agent.h',\n             'src/inspector/tracing_agent.h',\n             '<@(node_inspector_generated_sources)'\n           ],\n@@ -1066,6 +1070,8 @@\n           '<(SHARED_INTERMEDIATE_DIR)/src/node/inspector/protocol/Forward.h',\n           '<(SHARED_INTERMEDIATE_DIR)/src/node/inspector/protocol/Protocol.cpp',\n           '<(SHARED_INTERMEDIATE_DIR)/src/node/inspector/protocol/Protocol.h',\n+          '<(SHARED_INTERMEDIATE_DIR)/src/node/inspector/protocol/NodeWorker.cpp',\n+          '<(SHARED_INTERMEDIATE_DIR)/src/node/inspector/protocol/NodeWorker.h',\n           '<(SHARED_INTERMEDIATE_DIR)/src/node/inspector/protocol/NodeTracing.cpp',\n           '<(SHARED_INTERMEDIATE_DIR)/src/node/inspector/protocol/NodeTracing.h',\n         ],"
        },
        {
            "sha": "9fb9f1c55fa1915f07a9b87a60e28bdfee80d8d7",
            "filename": "src/inspector/node_protocol.pdl",
            "status": "modified",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector%2Fnode_protocol.pdl",
            "raw_url": "https://github.com/nodejs/node/raw/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector%2Fnode_protocol.pdl",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fnode_protocol.pdl?ref=f28c6f7eef58e7c3133bb2cd457d05b986194ba3",
            "patch": "@@ -37,3 +37,58 @@ experimental domain NodeTracing\n   # Signals that tracing is stopped and there is no trace buffers pending flush, all data were\n   # delivered via dataCollected events.\n   event tracingComplete\n+\n+# Support for sending messages to Node worker Inspector instances.\n+experimental domain NodeWorker\n+\n+  type WorkerID extends string\n+\n+  # Unique identifier of attached debugging session.\n+  type SessionID extends string\n+\n+  type WorkerInfo extends object\n+    properties\n+      WorkerID workerId\n+      string type\n+      string title\n+      string url\n+\n+  # Sends protocol message over session with given id.\n+  command sendMessageToWorker\n+    parameters\n+      string message\n+      # Identifier of the session.\n+      SessionID sessionId\n+\n+  # Instructs the inspector to attach to running workers. Will also attach to new workers\n+  # as they start\n+  command enable\n+    parameters\n+      # Whether to new workers should be paused until the frontend sends `Runtime.runIfWaitingForDebugger`\n+      # message to run them.\n+      boolean waitForDebuggerOnStart\n+\n+  # Detaches from all running workers and disables attaching to new workers as they are started.\n+  command disable\n+\n+  # Issued when attached to a worker.\n+  event attachedToWorker\n+    parameters\n+      # Identifier assigned to the session used to send/receive messages.\n+      SessionID sessionId\n+      WorkerInfo workerInfo\n+      boolean waitingForDebugger\n+\n+  # Issued when detached from the worker.\n+  event detachedFromWorker\n+    parameters\n+      # Detached session identifier.\n+      SessionID sessionId\n+\n+  # Notifies about a new protocol message received from the session\n+  # (session ID is provided in attachedToWorker notification).\n+  event receivedMessageFromWorker\n+    parameters\n+      # Identifier of a session which sends a message.\n+      SessionID sessionId\n+      string message"
        },
        {
            "sha": "4ef37856068093cd504bf8bc169b4812f4081000",
            "filename": "src/inspector/node_protocol_config.json",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector%2Fnode_protocol_config.json",
            "raw_url": "https://github.com/nodejs/node/raw/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector%2Fnode_protocol_config.json",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fnode_protocol_config.json?ref=f28c6f7eef58e7c3133bb2cd457d05b986194ba3",
            "patch": "@@ -3,12 +3,7 @@\n         \"path\": \"node_protocol.json\",\n         \"package\": \"src/node/inspector/protocol\",\n         \"output\": \"node/inspector/protocol\",\n-        \"namespace\": [\"node\", \"inspector\", \"protocol\"],\n-        \"options\": [\n-            {\n-                \"domain\": \"NodeTracing\"\n-            }\n-        ]\n+        \"namespace\": [\"node\", \"inspector\", \"protocol\"]\n     },\n     \"exported\": {\n         \"package\": \"include/inspector\","
        },
        {
            "sha": "fccd6d57a53c2aa0a58a8dadbb003ba0c48b5a95",
            "filename": "src/inspector/worker_agent.cc",
            "status": "added",
            "additions": 154,
            "deletions": 0,
            "changes": 154,
            "blob_url": "https://github.com/nodejs/node/blob/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector%2Fworker_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector%2Fworker_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fworker_agent.cc?ref=f28c6f7eef58e7c3133bb2cd457d05b986194ba3",
            "patch": "@@ -0,0 +1,154 @@\n+#include \"worker_agent.h\"\n+\n+#include \"main_thread_interface.h\"\n+#include \"worker_inspector.h\"\n+\n+namespace node {\n+namespace inspector {\n+namespace protocol {\n+\n+class NodeWorkers\n+    : public std::enable_shared_from_this<NodeWorkers> {\n+ public:\n+  explicit NodeWorkers(std::weak_ptr<NodeWorker::Frontend> frontend,\n+                      std::shared_ptr<MainThreadHandle> thread)\n+                      : frontend_(frontend), thread_(thread) {}\n+  void WorkerCreated(const std::string& title,\n+                     const std::string& url,\n+                     bool waiting,\n+                     std::shared_ptr<MainThreadHandle> target);\n+  void Receive(const std::string& id, const std::string& message);\n+  void Send(const std::string& id, const std::string& message);\n+  void Detached(const std::string& id);\n+\n+ private:\n+  std::weak_ptr<NodeWorker::Frontend> frontend_;\n+  std::shared_ptr<MainThreadHandle> thread_;\n+  std::unordered_map<std::string, std::unique_ptr<InspectorSession>> sessions_;\n+  int next_target_id_ = 0;\n+};\n+\n+namespace {\n+class AgentWorkerInspectorDelegate : public WorkerDelegate {\n+ public:\n+  explicit AgentWorkerInspectorDelegate(std::shared_ptr<NodeWorkers> workers)\n+                                        : workers_(workers) {}\n+\n+  void WorkerCreated(const std::string& title,\n+                     const std::string& url,\n+                     bool waiting,\n+                     std::shared_ptr<MainThreadHandle> target) override {\n+    workers_->WorkerCreated(title, url, waiting, target);\n+  }\n+\n+ private:\n+  std::shared_ptr<NodeWorkers> workers_;\n+};\n+\n+class ParentInspectorSessionDelegate : public InspectorSessionDelegate {\n+ public:\n+  ParentInspectorSessionDelegate(const std::string& id,\n+                                 std::shared_ptr<NodeWorkers> workers)\n+                                 : id_(id), workers_(workers) {}\n+\n+  ~ParentInspectorSessionDelegate() override {\n+    workers_->Detached(id_);\n+  }\n+\n+  void SendMessageToFrontend(const v8_inspector::StringView& msg) override {\n+    std::string message = protocol::StringUtil::StringViewToUtf8(msg);\n+    workers_->Send(id_, message);\n+  }\n+\n+ private:\n+  std::string id_;\n+  std::shared_ptr<NodeWorkers> workers_;\n+};\n+\n+std::unique_ptr<NodeWorker::WorkerInfo> WorkerInfo(const std::string& id,\n+                                                   const std::string& title,\n+                                                   const std::string& url) {\n+  return NodeWorker::WorkerInfo::create()\n+      .setWorkerId(id)\n+      .setTitle(title)\n+      .setUrl(url)\n+      .setType(\"worker\").build();\n+}\n+}  // namespace\n+\n+WorkerAgent::WorkerAgent(std::weak_ptr<WorkerManager> manager)\n+                         : manager_(manager) {}\n+\n+\n+void WorkerAgent::Wire(UberDispatcher* dispatcher) {\n+  frontend_.reset(new NodeWorker::Frontend(dispatcher->channel()));\n+  NodeWorker::Dispatcher::wire(dispatcher, this);\n+  auto manager = manager_.lock();\n+  CHECK_NOT_NULL(manager);\n+  workers_ =\n+      std::make_shared<NodeWorkers>(frontend_, manager->MainThread());\n+}\n+\n+DispatchResponse WorkerAgent::sendMessageToWorker(const String& message,\n+                                                  const String& sessionId) {\n+  workers_->Receive(sessionId, message);\n+  return DispatchResponse::OK();\n+}\n+\n+DispatchResponse WorkerAgent::enable(bool waitForDebuggerOnStart) {\n+  auto manager = manager_.lock();\n+  if (!manager) {\n+    return DispatchResponse::OK();\n+  }\n+  if (!event_handle_) {\n+    std::unique_ptr<AgentWorkerInspectorDelegate> delegate(\n+            new AgentWorkerInspectorDelegate(workers_));\n+    event_handle_ = manager->SetAutoAttach(std::move(delegate));\n+  }\n+  event_handle_->SetWaitOnStart(waitForDebuggerOnStart);\n+  return DispatchResponse::OK();\n+}\n+\n+DispatchResponse WorkerAgent::disable() {\n+  event_handle_.reset();\n+  return DispatchResponse::OK();\n+}\n+\n+void NodeWorkers::WorkerCreated(const std::string& title,\n+                                const std::string& url,\n+                                bool waiting,\n+                                std::shared_ptr<MainThreadHandle> target) {\n+  auto frontend = frontend_.lock();\n+  if (!frontend)\n+    return;\n+  std::string id = std::to_string(++next_target_id_);\n+  auto delegate = thread_->MakeDelegateThreadSafe(\n+      std::unique_ptr<InspectorSessionDelegate>(\n+          new ParentInspectorSessionDelegate(id, shared_from_this())));\n+  sessions_[id] = target->Connect(std::move(delegate), true);\n+  frontend->attachedToWorker(id, WorkerInfo(id, title, url), waiting);\n+}\n+\n+void NodeWorkers::Send(const std::string& id, const std::string& message) {\n+  auto frontend = frontend_.lock();\n+  if (frontend)\n+    frontend->receivedMessageFromWorker(id, message);\n+}\n+\n+void NodeWorkers::Receive(const std::string& id, const std::string& message) {\n+  auto it = sessions_.find(id);\n+  if (it != sessions_.end())\n+    it->second->Dispatch(Utf8ToStringView(message)->string());\n+}\n+\n+void NodeWorkers::Detached(const std::string& id) {\n+  if (sessions_.erase(id) == 0)\n+    return;\n+  auto frontend = frontend_.lock();\n+  if (frontend) {\n+    frontend->detachedFromWorker(id);\n+  }\n+}\n+}  // namespace protocol\n+}  // namespace inspector\n+}  // namespace node"
        },
        {
            "sha": "402c7194163967b85677753dedba4264e6cc4108",
            "filename": "src/inspector/worker_agent.h",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/nodejs/node/blob/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector%2Fworker_agent.h",
            "raw_url": "https://github.com/nodejs/node/raw/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector%2Fworker_agent.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fworker_agent.h?ref=f28c6f7eef58e7c3133bb2cd457d05b986194ba3",
            "patch": "@@ -0,0 +1,39 @@\n+#ifndef SRC_INSPECTOR_WORKER_AGENT_H_\n+#define SRC_INSPECTOR_WORKER_AGENT_H_\n+\n+#include \"node/inspector/protocol/NodeWorker.h\"\n+#include \"v8.h\"\n+\n+\n+namespace node {\n+namespace inspector {\n+class WorkerManagerEventHandle;\n+class WorkerManager;\n+\n+namespace protocol {\n+class NodeWorkers;\n+\n+class WorkerAgent : public NodeWorker::Backend {\n+ public:\n+  explicit WorkerAgent(std::weak_ptr<WorkerManager> manager);\n+  ~WorkerAgent() override = default;\n+\n+  void Wire(UberDispatcher* dispatcher);\n+\n+  DispatchResponse sendMessageToWorker(const String& message,\n+                                       const String& sessionId) override;\n+\n+  DispatchResponse enable(bool waitForDebuggerOnStart) override;\n+  DispatchResponse disable() override;\n+\n+ private:\n+  std::shared_ptr<NodeWorker::Frontend> frontend_;\n+  std::weak_ptr<WorkerManager> manager_;\n+  std::unique_ptr<WorkerManagerEventHandle> event_handle_;\n+  std::shared_ptr<NodeWorkers> workers_;\n+};\n+}  // namespace protocol\n+}  // namespace inspector\n+}  // namespace node\n+\n+#endif  // SRC_INSPECTOR_WORKER_AGENT_H_"
        },
        {
            "sha": "52e71a562daeb6b3bfe195c182af96562f291388",
            "filename": "src/inspector/worker_inspector.cc",
            "status": "added",
            "additions": 128,
            "deletions": 0,
            "changes": 128,
            "blob_url": "https://github.com/nodejs/node/blob/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector%2Fworker_inspector.cc",
            "raw_url": "https://github.com/nodejs/node/raw/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector%2Fworker_inspector.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fworker_inspector.cc?ref=f28c6f7eef58e7c3133bb2cd457d05b986194ba3",
            "patch": "@@ -0,0 +1,128 @@\n+#include \"worker_inspector.h\"\n+\n+#include \"main_thread_interface.h\"\n+\n+namespace node {\n+namespace inspector {\n+namespace {\n+\n+class WorkerStartedRequest : public Request {\n+ public:\n+  WorkerStartedRequest(\n+      int id,\n+      const std::string& url,\n+      std::shared_ptr<node::inspector::MainThreadHandle> worker_thread,\n+      bool waiting)\n+      : id_(id),\n+        info_(BuildWorkerTitle(id), url, worker_thread),\n+        waiting_(waiting) {}\n+  void Call(MainThreadInterface* thread) override {\n+    auto manager = thread->inspector_agent()->GetWorkerManager();\n+    manager->WorkerStarted(id_, info_, waiting_);\n+  }\n+\n+ private:\n+  static std::string BuildWorkerTitle(int id) {\n+    return \"Worker \" + std::to_string(id);\n+  }\n+\n+  int id_;\n+  WorkerInfo info_;\n+  bool waiting_;\n+};\n+\n+\n+void Report(const std::unique_ptr<WorkerDelegate>& delegate,\n+            const WorkerInfo& info, bool waiting) {\n+  if (info.worker_thread)\n+    delegate->WorkerCreated(info.title, info.url, waiting, info.worker_thread);\n+}\n+\n+class WorkerFinishedRequest : public Request {\n+ public:\n+  explicit WorkerFinishedRequest(int worker_id) : worker_id_(worker_id) {}\n+\n+  void Call(MainThreadInterface* thread) override {\n+    thread->inspector_agent()->GetWorkerManager()->WorkerFinished(worker_id_);\n+  }\n+\n+ private:\n+  int worker_id_;\n+};\n+}  // namespace\n+\n+\n+ParentInspectorHandle::ParentInspectorHandle(\n+    int id, const std::string& url,\n+    std::shared_ptr<MainThreadHandle> parent_thread, bool wait_for_connect)\n+    : id_(id), url_(url), parent_thread_(parent_thread),\n+      wait_(wait_for_connect) {}\n+\n+ParentInspectorHandle::~ParentInspectorHandle() {\n+  parent_thread_->Post(\n+      std::unique_ptr<Request>(new WorkerFinishedRequest(id_)));\n+}\n+\n+void ParentInspectorHandle::WorkerStarted(\n+    std::shared_ptr<MainThreadHandle> worker_thread, bool waiting) {\n+  std::unique_ptr<Request> request(\n+      new WorkerStartedRequest(id_, url_, worker_thread, waiting));\n+  parent_thread_->Post(std::move(request));\n+}\n+\n+void WorkerManager::WorkerFinished(int session_id) {\n+  children_.erase(session_id);\n+}\n+\n+void WorkerManager::WorkerStarted(int session_id,\n+                                  const WorkerInfo& info,\n+                                  bool waiting) {\n+  if (info.worker_thread->Expired())\n+    return;\n+  children_.emplace(session_id, info);\n+  for (const auto& delegate : delegates_) {\n+    Report(delegate.second, info, waiting);\n+  }\n+}\n+\n+std::unique_ptr<ParentInspectorHandle>\n+WorkerManager::NewParentHandle(int thread_id, const std::string& url) {\n+  bool wait = !delegates_waiting_on_start_.empty();\n+  return std::unique_ptr<ParentInspectorHandle>(\n+      new ParentInspectorHandle(thread_id, url, thread_, wait));\n+}\n+\n+void WorkerManager::RemoveAttachDelegate(int id) {\n+  delegates_.erase(id);\n+  delegates_waiting_on_start_.erase(id);\n+}\n+\n+std::unique_ptr<WorkerManagerEventHandle> WorkerManager::SetAutoAttach(\n+    std::unique_ptr<WorkerDelegate> attach_delegate) {\n+  int id = ++next_delegate_id_;\n+  delegates_[id] = std::move(attach_delegate);\n+  const auto& delegate = delegates_[id];\n+  for (const auto& worker : children_) {\n+    // Waiting is only reported when a worker is started, same as browser\n+    Report(delegate, worker.second, false);\n+  }\n+  return std::unique_ptr<WorkerManagerEventHandle>(\n+      new WorkerManagerEventHandle(shared_from_this(), id));\n+}\n+\n+void WorkerManager::SetWaitOnStartForDelegate(int id, bool wait) {\n+  if (wait)\n+    delegates_waiting_on_start_.insert(id);\n+  else\n+    delegates_waiting_on_start_.erase(id);\n+}\n+\n+void WorkerManagerEventHandle::SetWaitOnStart(bool wait_on_start) {\n+    manager_->SetWaitOnStartForDelegate(id_, wait_on_start);\n+}\n+\n+WorkerManagerEventHandle::~WorkerManagerEventHandle() {\n+  manager_->RemoveAttachDelegate(id_);\n+}\n+}  // namespace inspector\n+}  // namespace node"
        },
        {
            "sha": "e3c96cf62f01b0e1335990229da79af2784e6bfc",
            "filename": "src/inspector/worker_inspector.h",
            "status": "added",
            "additions": 98,
            "deletions": 0,
            "changes": 98,
            "blob_url": "https://github.com/nodejs/node/blob/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector%2Fworker_inspector.h",
            "raw_url": "https://github.com/nodejs/node/raw/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector%2Fworker_inspector.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector%2Fworker_inspector.h?ref=f28c6f7eef58e7c3133bb2cd457d05b986194ba3",
            "patch": "@@ -0,0 +1,98 @@\n+#ifndef SRC_INSPECTOR_WORKER_INSPECTOR_H_\n+#define SRC_INSPECTOR_WORKER_INSPECTOR_H_\n+\n+#if !HAVE_INSPECTOR\n+#error(\"This header can only be used when inspector is enabled\")\n+#endif\n+\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+namespace node {\n+namespace inspector {\n+class MainThreadHandle;\n+class WorkerManager;\n+\n+class WorkerDelegate {\n+ public:\n+  virtual void WorkerCreated(const std::string& title,\n+                             const std::string& url,\n+                             bool waiting,\n+                             std::shared_ptr<MainThreadHandle> worker) = 0;\n+};\n+\n+class WorkerManagerEventHandle {\n+ public:\n+  explicit WorkerManagerEventHandle(std::shared_ptr<WorkerManager> manager,\n+                                    int id)\n+                                    : manager_(manager), id_(id) {}\n+  void SetWaitOnStart(bool wait_on_start);\n+  ~WorkerManagerEventHandle();\n+\n+ private:\n+  std::shared_ptr<WorkerManager> manager_;\n+  int id_;\n+};\n+\n+struct WorkerInfo {\n+  WorkerInfo(const std::string& target_title,\n+             const std::string& target_url,\n+             std::shared_ptr<MainThreadHandle> worker_thread)\n+             : title(target_title),\n+               url(target_url),\n+               worker_thread(worker_thread) {}\n+  std::string title;\n+  std::string url;\n+  std::shared_ptr<MainThreadHandle> worker_thread;\n+};\n+\n+class ParentInspectorHandle {\n+ public:\n+  ParentInspectorHandle(int id, const std::string& url,\n+                        std::shared_ptr<MainThreadHandle> parent_thread,\n+                        bool wait_for_connect);\n+  ~ParentInspectorHandle();\n+  void WorkerStarted(std::shared_ptr<MainThreadHandle> worker_thread,\n+                     bool waiting);\n+  bool WaitForConnect() {\n+    return wait_;\n+  }\n+\n+ private:\n+  int id_;\n+  std::string url_;\n+  std::shared_ptr<MainThreadHandle> parent_thread_;\n+  bool wait_;\n+};\n+\n+class WorkerManager : public std::enable_shared_from_this<WorkerManager> {\n+ public:\n+  explicit WorkerManager(std::shared_ptr<MainThreadHandle> thread)\n+                         : thread_(thread) {}\n+\n+  std::unique_ptr<ParentInspectorHandle> NewParentHandle(\n+      int thread_id, const std::string& url);\n+  void WorkerStarted(int session_id, const WorkerInfo& info, bool waiting);\n+  void WorkerFinished(int session_id);\n+  std::unique_ptr<WorkerManagerEventHandle> SetAutoAttach(\n+      std::unique_ptr<WorkerDelegate> attach_delegate);\n+  void SetWaitOnStartForDelegate(int id, bool wait);\n+  void RemoveAttachDelegate(int id);\n+  std::shared_ptr<MainThreadHandle> MainThread() {\n+    return thread_;\n+  }\n+\n+ private:\n+  std::shared_ptr<MainThreadHandle> thread_;\n+  std::unordered_map<int, WorkerInfo> children_;\n+  std::unordered_map<int, std::unique_ptr<WorkerDelegate>> delegates_;\n+  // If any one needs it, workers stop for all\n+  std::unordered_set<int> delegates_waiting_on_start_;\n+  int next_delegate_id_ = 0;\n+};\n+}  // namespace inspector\n+}  // namespace node\n+\n+#endif  // SRC_INSPECTOR_WORKER_INSPECTOR_H_"
        },
        {
            "sha": "ebb7b7d5bc3e72a1d9aef16f010096e5a7c089ae",
            "filename": "src/inspector_agent.cc",
            "status": "modified",
            "additions": 44,
            "deletions": 4,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.cc?ref=f28c6f7eef58e7c3133bb2cd457d05b986194ba3",
            "patch": "@@ -4,6 +4,8 @@\n #include \"inspector/main_thread_interface.h\"\n #include \"inspector/node_string.h\"\n #include \"inspector/tracing_agent.h\"\n+#include \"inspector/worker_agent.h\"\n+#include \"inspector/worker_inspector.h\"\n #include \"node/inspector/protocol/Protocol.h\"\n #include \"node_internals.h\"\n #include \"node_url.h\"\n@@ -201,6 +203,7 @@ class ChannelImpl final : public v8_inspector::V8Inspector::Channel,\n  public:\n   explicit ChannelImpl(Environment* env,\n                        const std::unique_ptr<V8Inspector>& inspector,\n+                       std::shared_ptr<WorkerManager> worker_manager,\n                        std::unique_ptr<InspectorSessionDelegate> delegate,\n                        bool prevent_shutdown)\n                        : delegate_(std::move(delegate)),\n@@ -209,11 +212,15 @@ class ChannelImpl final : public v8_inspector::V8Inspector::Channel,\n     node_dispatcher_.reset(new protocol::UberDispatcher(this));\n     tracing_agent_.reset(new protocol::TracingAgent(env));\n     tracing_agent_->Wire(node_dispatcher_.get());\n+    worker_agent_.reset(new protocol::WorkerAgent(worker_manager));\n+    worker_agent_->Wire(node_dispatcher_.get());\n   }\n \n   virtual ~ChannelImpl() {\n     tracing_agent_->disable();\n     tracing_agent_.reset();  // Dispose before the dispatchers\n+    worker_agent_->disable();\n+    worker_agent_.reset();  // Dispose before the dispatchers\n   }\n \n   std::string dispatchProtocolMessage(const StringView& message) {\n@@ -273,6 +280,7 @@ class ChannelImpl final : public v8_inspector::V8Inspector::Channel,\n   }\n \n   std::unique_ptr<protocol::TracingAgent> tracing_agent_;\n+  std::unique_ptr<protocol::WorkerAgent> worker_agent_;\n   std::unique_ptr<InspectorSessionDelegate> delegate_;\n   std::unique_ptr<v8_inspector::V8InspectorSession> session_;\n   std::unique_ptr<protocol::UberDispatcher> node_dispatcher_;\n@@ -469,7 +477,8 @@ class NodeInspectorClient : public V8InspectorClient {\n     // TODO(addaleax): Revert back to using make_unique once we get issues\n     // with CI resolved (i.e. revert the patch that added this comment).\n     channels_[session_id].reset(\n-        new ChannelImpl(env_, client_, std::move(delegate), prevent_shutdown));\n+        new ChannelImpl(env_, client_, getWorkerManager(),\n+                        std::move(delegate), prevent_shutdown));\n     return session_id;\n   }\n \n@@ -589,6 +598,14 @@ class NodeInspectorClient : public V8InspectorClient {\n     return interface_->GetHandle();\n   }\n \n+  std::shared_ptr<WorkerManager> getWorkerManager() {\n+    if (worker_manager_ == nullptr) {\n+      worker_manager_ =\n+          std::make_shared<WorkerManager>(getThreadHandle());\n+    }\n+    return worker_manager_;\n+  }\n+\n   bool IsActive() {\n     return !channels_.empty();\n   }\n@@ -646,6 +663,7 @@ class NodeInspectorClient : public V8InspectorClient {\n   bool waiting_for_io_shutdown_ = false;\n   // Allows accessing Inspector from non-main threads\n   std::unique_ptr<MainThreadInterface> interface_;\n+  std::shared_ptr<WorkerManager> worker_manager_;\n };\n \n Agent::Agent(Environment* env)\n@@ -680,7 +698,10 @@ bool Agent::Start(const std::string& path,\n   }\n \n   bool wait_for_connect = options->wait_for_connect();\n-  if (!options->inspector_enabled || !StartIoThread()) {\n+  if (parent_handle_) {\n+    wait_for_connect = parent_handle_->WaitForConnect();\n+    parent_handle_->WorkerStarted(client_->getThreadHandle(), wait_for_connect);\n+  } else if (!options->inspector_enabled || !StartIoThread()) {\n     return false;\n   }\n   if (wait_for_connect) {\n@@ -727,7 +748,9 @@ std::unique_ptr<InspectorSession> Agent::Connect(\n \n void Agent::WaitForDisconnect() {\n   CHECK_NOT_NULL(client_);\n-  if (client_->hasConnectedSessions()) {\n+  bool is_worker = parent_handle_ != nullptr;\n+  parent_handle_.reset();\n+  if (client_->hasConnectedSessions() && !is_worker) {\n     fprintf(stderr, \"Waiting for the debugger to disconnect...\\n\");\n     fflush(stderr);\n   }\n@@ -842,7 +865,11 @@ void Agent::ContextCreated(Local<Context> context, const ContextInfo& info) {\n }\n \n bool Agent::WillWaitForConnect() {\n-  return debug_options_->wait_for_connect();\n+  if (debug_options_->wait_for_connect())\n+    return true;\n+  if (parent_handle_)\n+    return parent_handle_->WaitForConnect();\n+  return false;\n }\n \n bool Agent::IsActive() {\n@@ -851,11 +878,24 @@ bool Agent::IsActive() {\n   return io_ != nullptr || client_->IsActive();\n }\n \n+void Agent::AddWorkerInspector(int thread_id,\n+                               const std::string& url,\n+                               Agent* agent) {\n+  CHECK_NOT_NULL(client_);\n+  agent->parent_handle_ =\n+      client_->getWorkerManager()->NewParentHandle(thread_id, url);\n+}\n+\n void Agent::WaitForConnect() {\n   CHECK_NOT_NULL(client_);\n   client_->waitForFrontend();\n }\n \n+std::shared_ptr<WorkerManager> Agent::GetWorkerManager() {\n+  CHECK_NOT_NULL(client_);\n+  return client_->getWorkerManager();\n+}\n+\n SameThreadInspectorSession::~SameThreadInspectorSession() {\n   auto client = client_.lock();\n   if (client)"
        },
        {
            "sha": "e926ccaa926dab1d47629bc7ad1aa9276c6cda2a",
            "filename": "src/inspector_agent.h",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector_agent.h",
            "raw_url": "https://github.com/nodejs/node/raw/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Finspector_agent.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.h?ref=f28c6f7eef58e7c3133bb2cd457d05b986194ba3",
            "patch": "@@ -26,7 +26,9 @@ struct ContextInfo;\n \n namespace inspector {\n class InspectorIo;\n+class ParentInspectorHandle;\n class NodeInspectorClient;\n+class WorkerManager;\n \n class InspectorSession {\n  public:\n@@ -82,6 +84,8 @@ class Agent {\n   void EnableAsyncHook();\n   void DisableAsyncHook();\n \n+  void AddWorkerInspector(int thread_id, const std::string& url, Agent* agent);\n+\n   // Called to create inspector sessions that can be used from the main thread.\n   // The inspector responds by using the delegate to send messages back.\n   std::unique_ptr<InspectorSession> Connect(\n@@ -103,6 +107,9 @@ class Agent {\n   std::shared_ptr<DebugOptions> options() { return debug_options_; }\n   void ContextCreated(v8::Local<v8::Context> context, const ContextInfo& info);\n \n+  // Interface for interacting with inspectors in worker threads\n+  std::shared_ptr<WorkerManager> GetWorkerManager();\n+\n  private:\n   void ToggleAsyncHook(v8::Isolate* isolate,\n                        const node::Persistent<v8::Function>& fn);\n@@ -112,6 +119,7 @@ class Agent {\n   std::shared_ptr<NodeInspectorClient> client_;\n   // Interface for transports, e.g. WebSocket server\n   std::unique_ptr<InspectorIo> io_;\n+  std::unique_ptr<ParentInspectorHandle> parent_handle_;\n   std::string path_;\n   std::shared_ptr<DebugOptions> debug_options_;\n "
        },
        {
            "sha": "209b7a4d091490f3ad6e59065b8a058d2d80fdbb",
            "filename": "src/node_worker.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Fnode_worker.cc",
            "raw_url": "https://github.com/nodejs/node/raw/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/src%2Fnode_worker.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_worker.cc?ref=f28c6f7eef58e7c3133bb2cd457d05b986194ba3",
            "patch": "@@ -40,6 +40,14 @@ void StartWorkerInspector(Environment* child, const std::string& url) {\n   child->inspector_agent()->Start(url, nullptr, false);\n }\n \n+void AddWorkerInspector(Environment* parent,\n+                        Environment* child,\n+                        int id,\n+                        const std::string& url) {\n+  parent->inspector_agent()->AddWorkerInspector(id, url,\n+                                                child->inspector_agent());\n+}\n+\n void WaitForWorkerInspectorToStop(Environment* child) {\n   child->inspector_agent()->WaitForDisconnect();\n   child->inspector_agent()->Stop();\n@@ -48,6 +56,10 @@ void WaitForWorkerInspectorToStop(Environment* child) {\n #else\n // No-ops\n void StartWorkerInspector(Environment* child, const std::string& url) {}\n+void AddWorkerInspector(Environment* parent,\n+                        Environment* child,\n+                        int id,\n+                        const std::string& url) {}\n void WaitForWorkerInspectorToStop(Environment* child) {}\n #endif\n \n@@ -115,6 +127,8 @@ Worker::Worker(Environment* env, Local<Object> wrap, const std::string& url)\n     env_->Start(std::vector<std::string>{},\n                 std::vector<std::string>{},\n                 env->profiler_idle_notifier_started());\n+    // Done while on the parent thread\n+    AddWorkerInspector(env, env_.get(), thread_id_, url_);\n   }\n \n   // The new isolate won't be bothered on this thread again."
        },
        {
            "sha": "8691879f14e78f17e164a3e8e49e1bc4028cfdc9",
            "filename": "test/parallel/test-worker-debug.js",
            "status": "added",
            "additions": 228,
            "deletions": 0,
            "changes": 228,
            "blob_url": "https://github.com/nodejs/node/blob/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/test%2Fparallel%2Ftest-worker-debug.js",
            "raw_url": "https://github.com/nodejs/node/raw/f28c6f7eef58e7c3133bb2cd457d05b986194ba3/test%2Fparallel%2Ftest-worker-debug.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-debug.js?ref=f28c6f7eef58e7c3133bb2cd457d05b986194ba3",
            "patch": "@@ -0,0 +1,228 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+\n+common.skipIfInspectorDisabled();\n+\n+const assert = require('assert');\n+const EventEmitter = require('events');\n+const { Session } = require('inspector');\n+const { pathToFileURL } = require('url');\n+const {\n+  Worker, isMainThread, parentPort, workerData\n+} = require('worker_threads');\n+\n+\n+const workerMessage = 'This is a message from a worker';\n+\n+function waitForMessage() {\n+  return new Promise((resolve) => {\n+    parentPort.once('message', resolve);\n+  });\n+}\n+\n+// This is at the top so line numbers change less often\n+if (!isMainThread) {\n+  if (workerData === 1) {\n+    console.log(workerMessage);\n+    debugger;  // eslint-disable-line no-debugger\n+  } else if (workerData === 2) {\n+    parentPort.postMessage('running');\n+    waitForMessage();\n+  }\n+  return;\n+}\n+\n+function doPost(session, method, params) {\n+  return new Promise((resolve, reject) => {\n+    session.post(method, params, (error, result) => {\n+      if (error)\n+        reject(JSON.stringify(error));\n+      else\n+        resolve(result);\n+    });\n+  });\n+}\n+\n+function waitForEvent(emitter, event) {\n+  return new Promise((resolve) => emitter.once(event, resolve));\n+}\n+\n+function waitForWorkerAttach(session) {\n+  return waitForEvent(session, 'NodeWorker.attachedToWorker')\n+      .then(({ params }) => params);\n+}\n+\n+async function waitForWorkerDetach(session, id) {\n+  let sessionId;\n+  do {\n+    const { params } =\n+        await waitForEvent(session, 'NodeWorker.detachedFromWorker');\n+    sessionId = params.sessionId;\n+  } while (sessionId !== id);\n+}\n+\n+function runWorker(id, workerCallback = () => {}) {\n+  return new Promise((resolve, reject) => {\n+    const worker = new Worker(__filename, { workerData: id });\n+    workerCallback(worker);\n+    worker.on('error', reject);\n+    worker.on('exit', resolve);\n+  });\n+}\n+\n+class WorkerSession extends EventEmitter {\n+  constructor(parentSession, id) {\n+    super();\n+    this._parentSession = parentSession;\n+    this._id = id;\n+    this._requestCallbacks = new Map();\n+    this._nextCommandId = 1;\n+    this._parentSession.on('NodeWorker.receivedMessageFromWorker',\n+                           ({ params }) => {\n+                             if (params.sessionId === this._id)\n+                               this._processMessage(JSON.parse(params.message));\n+                           });\n+  }\n+\n+  _processMessage(message) {\n+    if (message.id === undefined) {\n+      // console.log(JSON.stringify(message));\n+      this.emit('inspectorNotification', message);\n+      this.emit(message.method, message);\n+      return;\n+    }\n+    const callback = this._requestCallbacks.get(message.id);\n+    if (callback) {\n+      this._requestCallbacks.delete(message.id);\n+      if (message.error)\n+        callback[1](message.error.message);\n+      else\n+        callback[0](message.result);\n+    }\n+  }\n+\n+  async waitForBreakAfterCommand(command, script, line) {\n+    const notificationPromise = waitForEvent(this, 'Debugger.paused');\n+    this.post(command);\n+    const notification = await notificationPromise;\n+    const callFrame = notification.params.callFrames[0];\n+    assert.strictEqual(callFrame.url, pathToFileURL(script).toString());\n+    assert.strictEqual(callFrame.location.lineNumber, line);\n+  }\n+\n+  post(method, parameters) {\n+    const msg = {\n+      id: this._nextCommandId++,\n+      method\n+    };\n+    if (parameters)\n+      msg.params = parameters;\n+\n+    return new Promise((resolve, reject) => {\n+      this._requestCallbacks.set(msg.id, [resolve, reject]);\n+      this._parentSession.post('NodeWorker.sendMessageToWorker', {\n+        sessionId: this._id, message: JSON.stringify(msg)\n+      });\n+    });\n+  }\n+}\n+\n+async function testBasicWorkerDebug(session, post) {\n+  /*\n+    1. Do 'enble' with waitForDebuggerOnStart = true\n+    2. Run worker. It should break on start.\n+    3. Enable Runtime (to get console message) and Debugger. Resume.\n+    4. Breaks on the 'debugger' statement. Resume.\n+    5. Console message recieved, worker runs to a completion.\n+    6. contextCreated/contextDestroyed had been properly dispatched\n+  */\n+  console.log('Test basic debug scenario');\n+  await post('NodeWorker.enable', { waitForDebuggerOnStart: true });\n+  const attached = waitForWorkerAttach(session);\n+  const worker = runWorker(1);\n+  const { sessionId, waitingForDebugger } = await attached;\n+  assert.strictEqual(waitingForDebugger, true);\n+  const detached = waitForWorkerDetach(session, sessionId);\n+  const workerSession = new WorkerSession(session, sessionId);\n+  const contextEvents = Promise.all([\n+    waitForEvent(workerSession, 'Runtime.executionContextCreated'),\n+    waitForEvent(workerSession, 'Runtime.executionContextDestroyed')\n+  ]);\n+  const consolePromise = waitForEvent(workerSession, 'Runtime.consoleAPICalled')\n+      .then((notification) => notification.params.args[0].value);\n+  await workerSession.post('Debugger.enable');\n+  await workerSession.post('Runtime.enable');\n+  await workerSession.waitForBreakAfterCommand(\n+    'Runtime.runIfWaitingForDebugger', __filename, 2);\n+  await workerSession.waitForBreakAfterCommand(\n+    'Debugger.resume', __filename, 27);  // V8 line number is zero-based\n+  assert.strictEqual(await consolePromise, workerMessage);\n+  workerSession.post('Debugger.resume');\n+  await Promise.all([worker, detached, contextEvents]);\n+}\n+\n+async function testNoWaitOnStart(session, post) {\n+  console.log('Test disabled waitForDebuggerOnStart');\n+  await post('NodeWorker.enable', { waitForDebuggerOnStart: false });\n+  let worker;\n+  const promise = waitForWorkerAttach(session);\n+  const exitPromise = runWorker(2, (w) => { worker = w; });\n+  const { waitingForDebugger } = await promise;\n+  assert.strictEqual(waitingForDebugger, false);\n+  worker.postMessage('resume');\n+  await exitPromise;\n+}\n+\n+async function testTwoWorkers(session, post) {\n+  console.log('Test attach to a running worker and then start a new one');\n+  await post('NodeWorker.disable');\n+  let okToAttach = false;\n+  const worker1attached = waitForWorkerAttach(session).then((notification) => {\n+    assert.strictEqual(okToAttach, true);\n+    return notification;\n+  });\n+\n+  let worker1Exited;\n+  const worker = await new Promise((resolve, reject) => {\n+    worker1Exited = runWorker(2, resolve);\n+  }).then((worker) => new Promise(\n+    (resolve) => worker.once('message', () => resolve(worker))));\n+  okToAttach = true;\n+  await post('NodeWorker.enable', { waitForDebuggerOnStart: true });\n+  const { waitingForDebugger: worker1Waiting } = await worker1attached;\n+  assert.strictEqual(worker1Waiting, false);\n+\n+  const worker2Attached = waitForWorkerAttach(session);\n+  let worker2Done = false;\n+  const worker2Exited = runWorker(1)\n+      .then(() => assert.strictEqual(worker2Done, true));\n+  const worker2AttachInfo = await worker2Attached;\n+  assert.strictEqual(worker2AttachInfo.waitingForDebugger, true);\n+  worker2Done = true;\n+\n+  const workerSession = new WorkerSession(session, worker2AttachInfo.sessionId);\n+  workerSession.post('Runtime.runIfWaitingForDebugger');\n+  worker.postMessage('resume');\n+  await Promise.all([worker1Exited, worker2Exited]);\n+}\n+\n+async function test() {\n+  const session = new Session();\n+  session.connect();\n+  const post = doPost.bind(null, session);\n+\n+  await testBasicWorkerDebug(session, post);\n+\n+  console.log('Test disabling attach to workers');\n+  await post('NodeWorker.disable');\n+  await runWorker(1);\n+\n+  await testNoWaitOnStart(session, post);\n+  await testTwoWorkers(session, post);\n+\n+  session.disconnect();\n+  console.log('Test done');\n+}\n+\n+test();"
        }
    ],
    "stats": {
        "total": 785,
        "additions": 775,
        "deletions": 10
    }
}