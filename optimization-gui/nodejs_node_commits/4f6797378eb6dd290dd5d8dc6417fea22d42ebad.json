{
    "author": "gireeshpunathil",
    "message": "src: merge into core\n\nMake node-report part of core runtime because:\n\n1. When enabled, node-report significantly helps root cause various\ntypes of problems, including support issues sent to the various repos\nof the Node.js organization.\n\n2. The requirement of explicitly adding the dependency to node-report\nin user applications often represents a blocker to adoption.\n\nMajor deviation from the module version of the node-report is that the\nreport is generated in JSON format, as opposed to human readable text.\n\nNo new functionalities have been added, changes that are required for\nmelding it as a built-in capability has been affected on the module\nversion of node-report (https://github.com/nodejs/node-report)\n\nCo-authored-by: Bidisha Pyne <bidipyne@in.ibm.com>\nCo-authored-by: Howard Hellyer <hhellyer@uk.ibm.com>\nCo-authored-by: Jeremiah Senkpiel <fishrock123@rocketmail.com>\nCo-authored-by: Julian Alimin <dmastag@yahoo.com>\nCo-authored-by: Lakshmi Swetha Gopireddy <lakshmigopireddy@in.ibm.com>\nCo-authored-by: Manusaporn Treerungroj <m.treerungroj@gmail.com>\nCo-authored-by: Michael Dawson <michael_dawson@ca.ibm.com>\nCo-authored-by: Richard Chamberlain <richard_chamberlain@uk.ibm.com>\nCo-authored-by: Richard Lau <riclau@uk.ibm.com>\nCo-authored-by: Sam Roberts <vieuxtech@gmail.com>\nCo-authored-by: Vipin Menon <vipinmv1@in.ibm.com>\n\nPR-URL: https://github.com/nodejs/node/pull/22712\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Michael Dawson <Michael_Dawson@ca.ibm.com>\nReviewed-By: Vse Mozhet Byt <vsemozhetbyt@gmail.com>",
    "sha": "4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
    "files": [
        {
            "sha": "aa104b298dc63f507d708d1d9265e822b1c8bb9c",
            "filename": "configure.py",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/configure.py",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/configure.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/configure.py?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -493,6 +493,11 @@\n     dest='without_npm',\n     help='do not install the bundled npm (package manager)')\n \n+parser.add_option('--without-report',\n+    action='store_true',\n+    dest='without_report',\n+    help='build without report')\n+\n # Dummy option for backwards compatibility\n parser.add_option('--with-snapshot',\n     action='store_true',\n@@ -938,6 +943,7 @@ def configure_node(o):\n     o['variables']['OS'] = 'android'\n   o['variables']['node_prefix'] = options.prefix\n   o['variables']['node_install_npm'] = b(not options.without_npm)\n+  o['variables']['node_report'] = b(not options.without_report)\n   o['default_configuration'] = 'Debug' if options.debug else 'Release'\n \n   host_arch = host_arch_win() if os.name == 'nt' else host_arch_cc()"
        },
        {
            "sha": "40ad964f68886626fe6df3634648235e1ba59fe0",
            "filename": "lib/internal/bootstrap/node.js",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/lib%2Finternal%2Fbootstrap%2Fnode.js",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/lib%2Finternal%2Fbootstrap%2Fnode.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbootstrap%2Fnode.js?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -363,6 +363,10 @@ function startup() {\n   } = perf.constants;\n   perf.markMilestone(NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE);\n \n+  if (getOptionValue('--experimental-report')) {\n+    NativeModule.require('internal/process/report').setup();\n+  }\n+\n   if (isMainThread) {\n     return startMainThreadExecution;\n   } else {"
        },
        {
            "sha": "d5cb86c3a5a4d892710c6e67caf888222df4c2b9",
            "filename": "lib/internal/errors.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/lib%2Finternal%2Ferrors.js",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/lib%2Finternal%2Ferrors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ferrors.js?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -709,6 +709,7 @@ E('ERR_INSPECTOR_CLOSED', 'Session was closed', Error);\n E('ERR_INSPECTOR_NOT_AVAILABLE', 'Inspector is not available', Error);\n E('ERR_INSPECTOR_NOT_CONNECTED', 'Session is not connected', Error);\n E('ERR_INVALID_ADDRESS_FAMILY', 'Invalid address family: %s', RangeError);\n+E('ERR_SYNTHETIC', 'JavaScript Callstack: %s', Error);\n E('ERR_INVALID_ARG_TYPE',\n   (name, expected, actual) => {\n     assert(typeof name === 'string', \"'name' must be a string\");"
        },
        {
            "sha": "b11f54b35d62535d11f4e809a7152d937ba5ce5a",
            "filename": "lib/internal/process/execution.js",
            "status": "modified",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/lib%2Finternal%2Fprocess%2Fexecution.js",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/lib%2Finternal%2Fprocess%2Fexecution.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fexecution.js?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -98,6 +98,31 @@ function createFatalException() {\n     // call that threw and was never cleared. So clear it now.\n     clearDefaultTriggerAsyncId();\n \n+    // If node-report is enabled, call into its handler to see\n+    // whether it is interested in handling the situation.\n+    // Ignore if the error is scoped inside a domain.\n+    // use == in the checks as we want to allow for null and undefined\n+    if (er == null || er.domain == null) {\n+      try {\n+        const report = internalBinding('report');\n+        if (report != null) {\n+          if (require('internal/options').getOptionValue(\n+            '--experimental-report')) {\n+            const config = {};\n+            report.syncConfig(config, false);\n+            if (Array.isArray(config.events) &&\n+                config.events.includes('exception')) {\n+              if (er) {\n+                report.onUnCaughtException(er.stack);\n+              } else {\n+                report.onUnCaughtException(undefined);\n+              }\n+            }\n+          }\n+        }\n+      } catch {}  // NOOP, node_report unavailable.\n+    }\n+\n     if (exceptionHandlerState.captureFn !== null) {\n       exceptionHandlerState.captureFn(er);\n     } else if (!process.emit('uncaughtException', er)) {"
        },
        {
            "sha": "2d0d3f392147939bde2b50bc2bfcf95ad60503aa",
            "filename": "lib/internal/process/report.js",
            "status": "added",
            "additions": 163,
            "deletions": 0,
            "changes": 163,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/lib%2Finternal%2Fprocess%2Freport.js",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/lib%2Finternal%2Fprocess%2Freport.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Freport.js?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -0,0 +1,163 @@\n+'use strict';\n+\n+const { emitExperimentalWarning } = require('internal/util');\n+const {\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_SYNTHETIC } = require('internal/errors').codes;\n+\n+exports.setup = function() {\n+  const REPORTEVENTS = 1;\n+  const REPORTSIGNAL = 2;\n+  const REPORTFILENAME = 3;\n+  const REPORTPATH = 4;\n+  const REPORTVERBOSE = 5;\n+  if (internalBinding('config').hasReport) {\n+    // If report is enabled, extract the binding and\n+    // wrap the APIs with thin layers, with some error checks.\n+    // user options can come in from CLI / ENV / API.\n+    // CLI and ENV is intercepted in C++ and the API call here (JS).\n+    // So sync up with both sides as appropriate - initially from\n+    // C++ to JS and from JS to C++ whenever the API is called.\n+    // Some events are controlled purely from JS (signal | exception)\n+    // and some from C++ (fatalerror) so this sync-up is essential for\n+    // correct behavior and alignment with the supplied tunables.\n+    const nr = internalBinding('report');\n+\n+    // Keep it un-exposed; lest programs play with it\n+    // leaving us with a lot of unwanted sanity checks.\n+    let config = {\n+      events: [],\n+      signal: 'SIGUSR2',\n+      filename: '',\n+      path: '',\n+      verbose: false\n+    };\n+    const report = {\n+      setDiagnosticReportOptions(options) {\n+        emitExperimentalWarning('report');\n+        // Reuse the null and undefined checks. Save\n+        // space when dealing with large number of arguments.\n+        const list = parseOptions(options);\n+\n+        // Flush the stale entries from report, as\n+        // we are refreshing it, items that the users did not\n+        // touch may be hanging around stale otherwise.\n+        config = {};\n+\n+        // The parseOption method returns an array that include\n+        // the indices at which valid params are present.\n+        list.forEach((i) => {\n+          switch (i) {\n+            case REPORTEVENTS:\n+              if (Array.isArray(options.events))\n+                config.events = options.events;\n+              else\n+                throw new ERR_INVALID_ARG_TYPE('events',\n+                                               'Array',\n+                                               options.events);\n+              break;\n+            case REPORTSIGNAL:\n+              if (typeof options.signal !== 'string') {\n+                throw new ERR_INVALID_ARG_TYPE('signal',\n+                                               'String',\n+                                               options.signal);\n+              }\n+              process.removeListener(config.signal, handleSignal);\n+              if (config.events.includes('signal'))\n+                process.on(options.signal, handleSignal);\n+              config.signal = options.signal;\n+              break;\n+            case REPORTFILENAME:\n+              if (typeof options.filename !== 'string') {\n+                throw new ERR_INVALID_ARG_TYPE('filename',\n+                                               'String',\n+                                               options.filename);\n+              }\n+              config.filename = options.filename;\n+              break;\n+            case REPORTPATH:\n+              if (typeof options.path !== 'string')\n+                throw new ERR_INVALID_ARG_TYPE('path', 'String', options.path);\n+              config.path = options.path;\n+              break;\n+            case REPORTVERBOSE:\n+              if (typeof options.verbose !== 'string' &&\n+                  typeof options.verbose !== 'boolean') {\n+                throw new ERR_INVALID_ARG_TYPE('verbose',\n+                                               'Booelan | String' +\n+                                               ' (true|false|yes|no)',\n+                                               options.verbose);\n+              }\n+              config.verbose = options.verbose;\n+              break;\n+          }\n+        });\n+        // Upload this new config to C++ land\n+        nr.syncConfig(config, true);\n+      },\n+\n+\n+      triggerReport(file, err) {\n+        emitExperimentalWarning('report');\n+        if (err == null) {\n+          if (file == null) {\n+            return nr.triggerReport(new ERR_SYNTHETIC(\n+              'JavaScript Callstack').stack);\n+          }\n+          if (typeof file !== 'string')\n+            throw new ERR_INVALID_ARG_TYPE('file', 'String', file);\n+          return nr.triggerReport(file, new ERR_SYNTHETIC(\n+            'JavaScript Callstack').stack);\n+        }\n+        if (typeof err !== 'object')\n+          throw new ERR_INVALID_ARG_TYPE('err', 'Object', err);\n+        if (file == null)\n+          return nr.triggerReport(err.stack);\n+        if (typeof file !== 'string')\n+          throw new ERR_INVALID_ARG_TYPE('file', 'String', file);\n+        return nr.triggerReport(file, err.stack);\n+      },\n+      getReport(err) {\n+        emitExperimentalWarning('report');\n+        if (err == null) {\n+          return nr.getReport(new ERR_SYNTHETIC('JavaScript Callstack').stack);\n+        } else if (typeof err !== 'object') {\n+          throw new ERR_INVALID_ARG_TYPE('err', 'Objct', err);\n+        } else {\n+          return nr.getReport(err.stack);\n+        }\n+      }\n+    };\n+\n+    // Download the CLI / ENV config into JS land.\n+    nr.syncConfig(config, false);\n+\n+    function handleSignal(signo) {\n+      if (typeof signo !== 'string')\n+        signo = config.signal;\n+      nr.onUserSignal(signo);\n+    }\n+\n+    if (config.events.includes('signal')) {\n+      process.on(config.signal, handleSignal);\n+    }\n+\n+    function parseOptions(obj) {\n+      const list = [];\n+      if (obj == null)\n+        return list;\n+      if (obj.events != null)\n+        list.push(REPORTEVENTS);\n+      if (obj.signal != null)\n+        list.push(REPORTSIGNAL);\n+      if (obj.filename != null)\n+        list.push(REPORTFILENAME);\n+      if (obj.path != null)\n+        list.push(REPORTPATH);\n+      if (obj.verbose != null)\n+        list.push(REPORTVERBOSE);\n+      return list;\n+    }\n+    process.report = report;\n+  }\n+};"
        },
        {
            "sha": "307f8ae603284080bcd8b9428e18f81af1652bfa",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -156,6 +156,7 @@\n       'lib/internal/process/stdio.js',\n       'lib/internal/process/warning.js',\n       'lib/internal/process/worker_thread_only.js',\n+      'lib/internal/process/report.js',\n       'lib/internal/querystring.js',\n       'lib/internal/queue_microtask.js',\n       'lib/internal/readline.js',\n@@ -314,6 +315,29 @@\n           # the executable and rename it back to node.exe later\n           'product_name': '<(node_core_target_name)-win',\n         }],\n+        [ 'node_report==\"true\"', {\n+          'defines': [\n+            'NODE_REPORT',\n+            'NODE_ARCH=\"<(target_arch)\"',\n+            'NODE_PLATFORM=\"<(OS)\"',\n+          ],\n+          'conditions': [\n+            ['OS==\"win\"', {\n+              'libraries': [\n+                'dbghelp.lib',\n+                'Netapi32.lib',\n+                'PsApi.lib',\n+                'Ws2_32.lib',\n+              ],\n+              'dll_files': [\n+                'dbghelp.dll',\n+                'Netapi32.dll',\n+                'PsApi.dll',\n+                'Ws2_32.dll',\n+              ],\n+            }],\n+          ],\n+        }],\n       ],\n     }, # node_core_target_name\n     {\n@@ -623,6 +647,34 @@\n             'src/tls_wrap.h'\n           ],\n         }],\n+        [ 'node_report==\"true\"', {\n+          'sources': [\n+            'src/node_report.cc',\n+            'src/node_report_module.cc',\n+            'src/node_report_utils.cc',\n+          ],\n+          'defines': [\n+            'NODE_REPORT',\n+            'NODE_ARCH=\"<(target_arch)\"',\n+            'NODE_PLATFORM=\"<(OS)\"',\n+          ],\n+          'conditions': [\n+            ['OS==\"win\"', {\n+              'libraries': [\n+                'dbghelp.lib',\n+                'Netapi32.lib',\n+                'PsApi.lib',\n+                'Ws2_32.lib',\n+              ],\n+              'dll_files': [\n+                'dbghelp.dll',\n+                'Netapi32.dll',\n+                'PsApi.dll',\n+                'Ws2_32.dll',\n+              ],\n+            }],\n+          ],\n+        }],\n         [ 'node_use_large_pages==\"true\" and OS==\"linux\"', {\n           'defines': [ 'NODE_ENABLE_LARGE_CODE_PAGES=1' ],\n           # The current implementation of Large Pages is under Linux.\n@@ -964,6 +1016,29 @@\n             'OTHER_LDFLAGS': [ '-Wl,-rpath,@loader_path', ],\n           },\n         }],\n+        [ 'node_report==\"true\"', {\n+          'defines': [\n+            'NODE_REPORT',\n+            'NODE_ARCH=\"<(target_arch)\"',\n+            'NODE_PLATFORM=\"<(OS)\"',\n+          ],\n+          'conditions': [\n+            ['OS==\"win\"', {\n+              'libraries': [\n+                'dbghelp.lib',\n+                'Netapi32.lib',\n+                'PsApi.lib',\n+                'Ws2_32.lib',\n+              ],\n+              'dll_files': [\n+                'dbghelp.dll',\n+                'Netapi32.dll',\n+                'PsApi.dll',\n+                'Ws2_32.dll',\n+              ],\n+            }],\n+          ],\n+        }],\n       ],\n     }, # cctest\n   ], # end targets"
        },
        {
            "sha": "2766654e9a06b9882012a9875512fa3ca13ccbbe",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -89,6 +89,10 @@\n #include <unicode/uvernum.h>\n #endif\n \n+#ifdef NODE_REPORT\n+#include \"node_report.h\"\n+#endif\n+\n #if defined(LEAK_SANITIZER)\n #include <sanitizer/lsan_interface.h>\n #endif\n@@ -733,6 +737,12 @@ void RunBootstrapping(Environment* env) {\n     return;\n   }\n \n+#ifdef NODE_REPORT\n+  if (env->options()->experimental_report) {\n+    report::InitializeReport(env->isolate(), env);\n+  }\n+#endif  // NODE_REPORT\n+\n   // process, loaderExports, isMainThread\n   std::vector<Local<String>> node_params = {\n       env->process_string(),\n@@ -963,6 +973,12 @@ int Init(std::vector<std::string>* argv,\n   // Make inherited handles noninheritable.\n   uv_disable_stdio_inheritance();\n \n+#ifdef NODE_REPORT\n+  // Cache the original command line to be\n+  // used in diagnostic reports.\n+  per_process::cli_options->cmdline = *argv;\n+#endif  //  NODE_REPORT\n+\n #if defined(NODE_V8_OPTIONS)\n   // Should come before the call to V8::SetFlagsFromCommandLine()\n   // so the user can disable a flag --foo at run-time by passing"
        },
        {
            "sha": "5ea8f01b41bb895e8276bbcf7278f5985b2aae54",
            "filename": "src/node_binding.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_binding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_binding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_binding.cc?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -14,6 +14,12 @@\n #define NODE_BUILTIN_ICU_MODULES(V)\n #endif\n \n+#if NODE_REPORT\n+#define NODE_BUILTIN_REPORT_MODULES(V) V(report)\n+#else\n+#define NODE_BUILTIN_REPORT_MODULES(V)\n+#endif\n+\n // A list of built-in modules. In order to do module registration\n // in node::Init(), need to add built-in modules in the following list.\n // Then in binding::RegisterBuiltinModules(), it calls modules' registration\n@@ -69,7 +75,8 @@\n #define NODE_BUILTIN_MODULES(V)                                                \\\n   NODE_BUILTIN_STANDARD_MODULES(V)                                             \\\n   NODE_BUILTIN_OPENSSL_MODULES(V)                                              \\\n-  NODE_BUILTIN_ICU_MODULES(V)\n+  NODE_BUILTIN_ICU_MODULES(V)                                                  \\\n+  NODE_BUILTIN_REPORT_MODULES(V)\n \n // This is used to load built-in modules. Instead of using\n // __attribute__((constructor)), we call the _register_<modname>"
        },
        {
            "sha": "af9403c1f9f854a10a43d01d2d39e50cd7dfefcf",
            "filename": "src/node_config.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_config.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_config.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_config.cc?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -1,7 +1,7 @@\n+#include \"env-inl.h\"\n #include \"node.h\"\n #include \"node_i18n.h\"\n #include \"node_options-inl.h\"\n-#include \"env-inl.h\"\n #include \"util-inl.h\"\n \n namespace node {\n@@ -69,6 +69,10 @@ static void Initialize(Local<Object> target,\n \n #endif  // NODE_HAVE_I18N_SUPPORT\n \n+#if defined(NODE_REPORT)\n+  READONLY_TRUE_PROPERTY(target, \"hasReport\");\n+#endif  //  NODE_REPORT\n+\n   if (env->abort_on_uncaught_exception())\n     READONLY_TRUE_PROPERTY(target, \"shouldAbortOnUncaughtException\");\n "
        },
        {
            "sha": "3d607db2a8871258e4538345b3aedc1756e2a67a",
            "filename": "src/node_errors.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_errors.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_errors.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_errors.cc?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -3,6 +3,9 @@\n \n #include \"node_errors.h\"\n #include \"node_internals.h\"\n+#ifdef NODE_REPORT\n+#include \"node_report.h\"\n+#endif\n \n namespace node {\n \n@@ -314,6 +317,21 @@ void OnFatalError(const char* location, const char* message) {\n   } else {\n     PrintErrorString(\"FATAL ERROR: %s\\n\", message);\n   }\n+#ifdef NODE_REPORT\n+  Isolate* isolate = Isolate::GetCurrent();\n+  std::string filename;\n+  Environment* env = Environment::GetCurrent(isolate);\n+  if (env != nullptr) {\n+    std::shared_ptr<PerIsolateOptions> options = env->isolate_data()->options();\n+    if (options->report_on_fatalerror) {\n+      report::TriggerNodeReport(\n+          isolate, env, message, __func__, filename, Local<String>());\n+    }\n+  } else {\n+    report::TriggerNodeReport(\n+        isolate, nullptr, message, __func__, filename, Local<String>());\n+  }\n+#endif  // NODE_REPORT\n   fflush(stderr);\n   ABORT();\n }"
        },
        {
            "sha": "667d7b6b9ddc605f0087e7118d011900c4b0ebc6",
            "filename": "src/node_options.cc",
            "status": "modified",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_options.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_options.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_options.cc?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -34,6 +34,31 @@ void PerProcessOptions::CheckOptions(std::vector<std::string>* errors) {\n \n void PerIsolateOptions::CheckOptions(std::vector<std::string>* errors) {\n   per_env->CheckOptions(errors);\n+#ifdef NODE_REPORT\n+  if (!report_directory.empty() && !per_env->experimental_report)\n+    errors->push_back(\"--diagnostic-report-directory option is valid only when \"\n+                      \"--experimental-report is set\");\n+  if (!report_filename.empty() && !per_env->experimental_report)\n+    errors->push_back(\"--diagnostic-report-filename option is valid only when \"\n+                      \"--experimental-report is set\");\n+  if (!report_signal.empty() && !per_env->experimental_report)\n+    errors->push_back(\"--diagnostic-report-signal option is valid only when \"\n+                      \"--experimental-report is set\");\n+  if (report_on_fatalerror && !per_env->experimental_report)\n+    errors->push_back(\n+        \"--diagnostic-report-on-fatalerror option is valid only when \"\n+        \"--experimental-report is set\");\n+  if (report_on_signal && !per_env->experimental_report)\n+    errors->push_back(\"--diagnostic-report-on-signal option is valid only when \"\n+                      \"--experimental-report is set\");\n+  if (report_uncaught_exception && !per_env->experimental_report)\n+    errors->push_back(\n+        \"--diagnostic-report-uncaught-exception option is valid only when \"\n+        \"--experimental-report is set\");\n+  if (report_verbose && !per_env->experimental_report)\n+    errors->push_back(\"--diagnostic-report-verbose option is valid only when \"\n+                      \"--experimental-report is set\");\n+#endif  // NODE_REPORT\n }\n \n void EnvironmentOptions::CheckOptions(std::vector<std::string>* errors) {\n@@ -119,6 +144,12 @@ EnvironmentOptionsParser::EnvironmentOptionsParser() {\n             &EnvironmentOptions::experimental_vm_modules,\n             kAllowedInEnvironment);\n   AddOption(\"--experimental-worker\", \"\", NoOp{}, kAllowedInEnvironment);\n+#ifdef NODE_REPORT\n+  AddOption(\"--experimental-report\",\n+            \"enable report generation\",\n+            &EnvironmentOptions::experimental_report,\n+            kAllowedInEnvironment);\n+#endif  // NODE_REPORT\n   AddOption(\"--expose-internals\", \"\", &EnvironmentOptions::expose_internals);\n   AddOption(\"--http-parser\",\n             \"Select which HTTP parser to use; either 'legacy' or 'llhttp' \"\n@@ -248,6 +279,42 @@ PerIsolateOptionsParser::PerIsolateOptionsParser() {\n   AddOption(\"--perf-prof\", \"\", V8Option{}, kAllowedInEnvironment);\n   AddOption(\"--stack-trace-limit\", \"\", V8Option{}, kAllowedInEnvironment);\n \n+#ifdef NODE_REPORT\n+  AddOption(\"--diagnostic-report-uncaught-exception\",\n+            \"generate diagnostic report on uncaught exceptions\",\n+            &PerIsolateOptions::report_uncaught_exception,\n+            kAllowedInEnvironment);\n+  AddOption(\"--diagnostic-report-on-signal\",\n+            \"generate diagnostic report upon receiving signals\",\n+            &PerIsolateOptions::report_on_signal,\n+            kAllowedInEnvironment);\n+  AddOption(\"--diagnostic-report-on-fatalerror\",\n+            \"generate diagnostic report on fatal (internal) errors\",\n+            &PerIsolateOptions::report_on_fatalerror,\n+            kAllowedInEnvironment);\n+  AddOption(\"--diagnostic-report-signal\",\n+            \"causes diagnostic report to be produced on provided signal,\"\n+            \" unsupported in Windows. (default: SIGUSR2)\",\n+            &PerIsolateOptions::report_signal,\n+            kAllowedInEnvironment);\n+  Implies(\"--diagnostic-report-signal\", \"--diagnostic-report-on-signal\");\n+  AddOption(\"--diagnostic-report-filename\",\n+            \"define custom report file name.\"\n+            \" (default: YYYYMMDD.HHMMSS.PID.SEQUENCE#.txt)\",\n+            &PerIsolateOptions::report_filename,\n+            kAllowedInEnvironment);\n+  AddOption(\"--diagnostic-report-directory\",\n+            \"define custom report pathname.\"\n+            \" (default: current working directory of Node.js process)\",\n+            &PerIsolateOptions::report_directory,\n+            kAllowedInEnvironment);\n+  AddOption(\"--diagnostic-report-verbose\",\n+            \"verbose option for report generation(true|false).\"\n+            \" (default: false)\",\n+            &PerIsolateOptions::report_verbose,\n+            kAllowedInEnvironment);\n+#endif  // NODE_REPORT\n+\n   Insert(&EnvironmentOptionsParser::instance,\n          &PerIsolateOptions::get_per_env_options);\n }"
        },
        {
            "sha": "d77c4fb80877e688d354511455f755f9af154b86",
            "filename": "src/node_options.h",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_options.h",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_options.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_options.h?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -116,6 +116,9 @@ class EnvironmentOptions : public Options {\n \n   bool syntax_check_only = false;\n   bool has_eval_string = false;\n+#ifdef NODE_REPORT\n+  bool experimental_report = false;\n+#endif  //  NODE_REPORT\n   std::string eval_string;\n   bool print_eval = false;\n   bool force_repl = false;\n@@ -142,6 +145,15 @@ class PerIsolateOptions : public Options {\n   std::shared_ptr<EnvironmentOptions> per_env { new EnvironmentOptions() };\n   bool track_heap_objects = false;\n \n+#ifdef NODE_REPORT\n+  bool report_uncaught_exception = false;\n+  bool report_on_signal = false;\n+  bool report_on_fatalerror = false;\n+  std::string report_signal;\n+  std::string report_filename;\n+  std::string report_directory;\n+  bool report_verbose;\n+#endif  //  NODE_REPORT\n   inline EnvironmentOptions* get_per_env_options();\n   void CheckOptions(std::vector<std::string>* errors);\n };\n@@ -184,6 +196,10 @@ class PerProcessOptions : public Options {\n #endif\n #endif\n \n+#ifdef NODE_REPORT\n+  std::vector<std::string> cmdline;\n+#endif  //  NODE_REPORT\n+\n   inline PerIsolateOptions* get_per_isolate_options();\n   void CheckOptions(std::vector<std::string>* errors);\n };"
        },
        {
            "sha": "276ce93095029d4db324e17094c4161ccbfb5ded",
            "filename": "src/node_report.cc",
            "status": "added",
            "additions": 833,
            "deletions": 0,
            "changes": 833,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_report.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_report.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_report.cc?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -0,0 +1,833 @@\n+\n+#include \"node_report.h\"\n+#include \"ares.h\"\n+#include \"debug_utils.h\"\n+#include \"http_parser.h\"\n+#include \"nghttp2/nghttp2ver.h\"\n+#include \"node_internals.h\"\n+#include \"node_metadata.h\"\n+#include \"zlib.h\"\n+\n+#include <atomic>\n+#include <fstream>\n+\n+#ifdef _WIN32\n+#include <Lm.h>\n+#include <Windows.h>\n+#include <dbghelp.h>\n+#include <process.h>\n+#include <psapi.h>\n+#include <tchar.h>\n+#include <cwctype>\n+#else\n+#include <sys/resource.h>\n+// Get the standard printf format macros for C99 stdint types.\n+#ifndef __STDC_FORMAT_MACROS\n+#define __STDC_FORMAT_MACROS\n+#endif\n+#include <cxxabi.h>\n+#include <dlfcn.h>\n+#include <inttypes.h>\n+#include <sys/utsname.h>\n+#endif\n+\n+#include <fcntl.h>\n+#include <string.h>\n+#include <time.h>\n+#include <iomanip>\n+\n+#ifndef _MSC_VER\n+#include <strings.h>\n+#endif\n+\n+#ifdef __APPLE__\n+#include <mach-o/dyld.h>\n+#endif\n+\n+#ifndef _WIN32\n+extern char** environ;\n+#endif\n+\n+namespace report {\n+using node::arraysize;\n+using node::Environment;\n+using node::Mutex;\n+using node::NativeSymbolDebuggingContext;\n+using node::PerIsolateOptions;\n+using v8::HeapSpaceStatistics;\n+using v8::HeapStatistics;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Number;\n+using v8::StackTrace;\n+using v8::String;\n+using v8::V8;\n+using v8::Value;\n+\n+// Internal/static function declarations\n+static void WriteNodeReport(Isolate* isolate,\n+                            Environment* env,\n+                            const char* message,\n+                            const char* location,\n+                            const std::string& filename,\n+                            std::ostream& out,\n+                            Local<String> stackstr,\n+                            TIME_TYPE* time);\n+static void PrintVersionInformation(JSONWriter* writer);\n+static void PrintJavaScriptStack(JSONWriter* writer,\n+                                 Isolate* isolate,\n+                                 Local<String> stackstr,\n+                                 const char* location);\n+static void PrintNativeStack(JSONWriter* writer);\n+#ifndef _WIN32\n+static void PrintResourceUsage(JSONWriter* writer);\n+#endif\n+static void PrintGCStatistics(JSONWriter* writer, Isolate* isolate);\n+static void PrintSystemInformation(JSONWriter* writer);\n+static void PrintLoadedLibraries(JSONWriter* writer);\n+static void PrintComponentVersions(JSONWriter* writer);\n+static void LocalTime(TIME_TYPE* tm_struct);\n+\n+// Global variables\n+static std::atomic_int seq = {0};  // sequence number for report filenames\n+\n+// External function to trigger a report, writing to file.\n+// The 'name' parameter is in/out: an input filename is used\n+// if supplied, and the actual filename is returned.\n+std::string TriggerNodeReport(Isolate* isolate,\n+                              Environment* env,\n+                              const char* message,\n+                              const char* location,\n+                              std::string name,\n+                              Local<String> stackstr) {\n+  std::ostringstream oss;\n+  std::string filename;\n+  std::shared_ptr<PerIsolateOptions> options;\n+  if (env != nullptr) options = env->isolate_data()->options();\n+\n+  // Obtain the current time and the pid (platform dependent)\n+  TIME_TYPE tm_struct;\n+  PID_TYPE pid;\n+  LocalTime(&tm_struct);\n+  pid = uv_os_getpid();\n+  // Determine the required report filename. In order of priority:\n+  //   1) supplied on API 2) configured on startup 3) default generated\n+  if (!name.empty()) {\n+    // Filename was specified as API parameter, use that\n+    oss << name;\n+  } else if (env != nullptr && options->report_filename.length() > 0) {\n+    // File name was supplied via start-up option, use that\n+    oss << options->report_filename;\n+  } else {\n+    // Construct the report filename, with timestamp, pid and sequence number\n+    oss << \"report\";\n+    seq++;\n+#ifdef _WIN32\n+    oss << \".\" << std::setfill('0') << std::setw(4) << tm_struct.wYear;\n+    oss << std::setfill('0') << std::setw(2) << tm_struct.wMonth;\n+    oss << std::setfill('0') << std::setw(2) << tm_struct.wDay;\n+    oss << \".\" << std::setfill('0') << std::setw(2) << tm_struct.wHour;\n+    oss << std::setfill('0') << std::setw(2) << tm_struct.wMinute;\n+    oss << std::setfill('0') << std::setw(2) << tm_struct.wSecond;\n+    oss << \".\" << pid;\n+    oss << \".\" << std::setfill('0') << std::setw(3) << seq.load();\n+#else  // UNIX, OSX\n+    oss << \".\" << std::setfill('0') << std::setw(4) << tm_struct.tm_year + 1900;\n+    oss << std::setfill('0') << std::setw(2) << tm_struct.tm_mon + 1;\n+    oss << std::setfill('0') << std::setw(2) << tm_struct.tm_mday;\n+    oss << \".\" << std::setfill('0') << std::setw(2) << tm_struct.tm_hour;\n+    oss << std::setfill('0') << std::setw(2) << tm_struct.tm_min;\n+    oss << std::setfill('0') << std::setw(2) << tm_struct.tm_sec;\n+    oss << \".\" << pid;\n+    oss << \".\" << std::setfill('0') << std::setw(3) << seq.load();\n+#endif\n+    oss << \".json\";\n+  }\n+\n+  filename = oss.str();\n+  // Open the report file stream for writing. Supports stdout/err,\n+  // user-specified or (default) generated name\n+  std::ofstream outfile;\n+  std::ostream* outstream = &std::cout;\n+  if (filename == \"stdout\") {\n+    outstream = &std::cout;\n+  } else if (filename == \"stderr\") {\n+    outstream = &std::cerr;\n+  } else {\n+    // Regular file. Append filename to directory path if one was specified\n+    if (env != nullptr && options->report_directory.length() > 0) {\n+      std::string pathname = options->report_directory;\n+      pathname += PATHSEP;\n+      pathname += filename;\n+      outfile.open(pathname, std::ios::out | std::ios::binary);\n+    } else {\n+      outfile.open(filename, std::ios::out | std::ios::binary);\n+    }\n+    // Check for errors on the file open\n+    if (!outfile.is_open()) {\n+      if (env != nullptr && options->report_directory.length() > 0) {\n+        std::cerr << std::endl\n+                  << \"Failed to open Node.js report file: \" << filename\n+                  << \" directory: \" << options->report_directory\n+                  << \" (errno: \" << errno << \")\" << std::endl;\n+      } else {\n+        std::cerr << std::endl\n+                  << \"Failed to open Node.js report file: \" << filename\n+                  << \" (errno: \" << errno << \")\" << std::endl;\n+      }\n+      return \"\";\n+    } else {\n+      std::cerr << std::endl\n+                << \"Writing Node.js report to file: \" << filename << std::endl;\n+    }\n+  }\n+\n+  // Pass our stream about by reference, not by copying it.\n+  std::ostream& out = outfile.is_open() ? outfile : *outstream;\n+\n+  WriteNodeReport(\n+      isolate, env, message, location, filename, out, stackstr, &tm_struct);\n+\n+  // Do not close stdout/stderr, only close files we opened.\n+  if (outfile.is_open()) {\n+    outfile.close();\n+  }\n+\n+  std::cerr << \"Node.js report completed\" << std::endl;\n+  if (name.empty()) return filename;\n+  return name;\n+}\n+\n+// External function to trigger a report, writing to a supplied stream.\n+void GetNodeReport(Isolate* isolate,\n+                   Environment* env,\n+                   const char* message,\n+                   const char* location,\n+                   Local<String> stackstr,\n+                   std::ostream& out) {\n+  // Obtain the current time and the pid (platform dependent)\n+  TIME_TYPE tm_struct;\n+  LocalTime(&tm_struct);\n+  std::string str = \"NA\";\n+  WriteNodeReport(\n+      isolate, env, message, location, str, out, stackstr, &tm_struct);\n+}\n+\n+// Internal function to coordinate and write the various\n+// sections of the report to the supplied stream\n+static void WriteNodeReport(Isolate* isolate,\n+                            Environment* env,\n+                            const char* message,\n+                            const char* location,\n+                            const std::string& filename,\n+                            std::ostream& out,\n+                            Local<String> stackstr,\n+                            TIME_TYPE* tm_struct) {\n+  std::ostringstream buf;\n+  PID_TYPE pid = uv_os_getpid();\n+\n+  // Save formatting for output stream.\n+  std::ios old_state(nullptr);\n+  old_state.copyfmt(out);\n+\n+  // File stream opened OK, now start printing the report content:\n+  // the title and header information (event, filename, timestamp and pid)\n+\n+  JSONWriter writer(out);\n+  writer.json_start();\n+  writer.json_objectstart(\"header\");\n+\n+  writer.json_keyvalue(\"event\", message);\n+  writer.json_keyvalue(\"location\", location);\n+  if (!filename.empty())\n+    writer.json_keyvalue(\"filename\", filename);\n+  else\n+    writer.json_keyvalue(\"filename\", std::string(\"''\"));\n+\n+  // Report dump event and module load date/time stamps\n+  char timebuf[64];\n+#ifdef _WIN32\n+  snprintf(timebuf,\n+           sizeof(timebuf),\n+           \"%4d/%02d/%02d %02d:%02d:%02d\",\n+           tm_struct->wYear,\n+           tm_struct->wMonth,\n+           tm_struct->wDay,\n+           tm_struct->wHour,\n+           tm_struct->wMinute,\n+           tm_struct->wSecond);\n+  writer.json_keyvalue(\"dumpEventTime\", timebuf);\n+#else  // UNIX, OSX\n+  snprintf(timebuf,\n+           sizeof(timebuf),\n+           \"%4d-%02d-%02dT%02d:%02d:%02dZ\",\n+           tm_struct->tm_year + 1900,\n+           tm_struct->tm_mon + 1,\n+           tm_struct->tm_mday,\n+           tm_struct->tm_hour,\n+           tm_struct->tm_min,\n+           tm_struct->tm_sec);\n+  writer.json_keyvalue(\"dumpEventTime\", timebuf);\n+  struct timeval ts;\n+  gettimeofday(&ts, nullptr);\n+  writer.json_keyvalue(\"dumpEventTimeStamp\",\n+                       std::to_string(ts.tv_sec * 1000 + ts.tv_usec / 1000));\n+#endif\n+  // Report native process ID\n+  buf << pid;\n+  writer.json_keyvalue(\"processId\", buf.str());\n+  buf.flush();\n+\n+  // Report out the command line.\n+  if (!node::per_process::cli_options->cmdline.empty()) {\n+    writer.json_arraystart(\"commandLine\");\n+    for (std::string arg : node::per_process::cli_options->cmdline) {\n+      writer.json_element(arg);\n+    }\n+    writer.json_arrayend();\n+  }\n+\n+  // Report Node.js and OS version information\n+  PrintVersionInformation(&writer);\n+  writer.json_objectend();\n+\n+  // Report summary JavaScript stack backtrace\n+  PrintJavaScriptStack(&writer, isolate, stackstr, location);\n+\n+  // Report native stack backtrace\n+  PrintNativeStack(&writer);\n+\n+  // Report V8 Heap and Garbage Collector information\n+  PrintGCStatistics(&writer, isolate);\n+\n+  // Report OS and current thread resource usage\n+#ifndef _WIN32\n+  PrintResourceUsage(&writer);\n+#endif\n+\n+  writer.json_arraystart(\"libuv\");\n+  if (env != nullptr)\n+    uv_walk(env->event_loop(), WalkHandle, static_cast<void*>(&writer));\n+  else\n+    uv_walk(uv_default_loop(), WalkHandle, static_cast<void*>(&writer));\n+\n+  writer.json_arrayend();\n+\n+  // Report operating system information\n+  PrintSystemInformation(&writer);\n+\n+  writer.json_objectend();\n+\n+  // Restore output stream formatting.\n+  out.copyfmt(old_state);\n+}\n+\n+// Report Node.js version, OS version and machine information.\n+static void PrintVersionInformation(JSONWriter* writer) {\n+  std::ostringstream buf;\n+  // Report Node version\n+  buf << \"v\" << NODE_VERSION_STRING;\n+  writer->json_keyvalue(\"nodejsVersion\", buf.str());\n+  buf.str(\"\");\n+#ifdef __GLIBC__\n+  buf << __GLIBC__ << \".\" << __GLIBC_MINOR__;\n+  writer->json_keyvalue(\"glibcVersion\", buf.str());\n+  buf.str(\"\");\n+#endif\n+  // Report Process word size\n+  buf << sizeof(void*) * 8 << \" bit\";\n+  writer->json_keyvalue(\"wordSize\", buf.str());\n+  buf.str(\"\");\n+\n+  // Report deps component versions\n+  PrintComponentVersions(writer);\n+\n+  // Report operating system and machine information (Windows)\n+#ifdef _WIN32\n+  {\n+    // Level 101 to obtain the server name, type, and associated details.\n+    // ref: https://docs.microsoft.com/en-us/windows/desktop/\n+    // api/lmserver/nf-lmserver-netservergetinfo\n+    const DWORD level = 101;\n+    LPSERVER_INFO_101 os_info = nullptr;\n+    NET_API_STATUS nStatus =\n+        NetServerGetInfo(nullptr, level, reinterpret_cast<LPBYTE*>(&os_info));\n+    if (nStatus == NERR_Success) {\n+      LPSTR os_name = \"Windows\";\n+      const DWORD major = os_info->sv101_version_major & MAJOR_VERSION_MASK;\n+      const DWORD type = os_info->sv101_type;\n+      const bool isServer = (type & SV_TYPE_DOMAIN_CTRL) ||\n+                            (type & SV_TYPE_DOMAIN_BAKCTRL) ||\n+                            (type & SV_TYPE_SERVER_NT);\n+      switch (major) {\n+        case 5:\n+          switch (os_info->sv101_version_minor) {\n+            case 0:\n+              os_name = \"Windows 2000\";\n+              break;\n+            default:\n+              os_name = (isServer ? \"Windows Server 2003\" : \"Windows XP\");\n+          }\n+          break;\n+        case 6:\n+          switch (os_info->sv101_version_minor) {\n+            case 0:\n+              os_name = (isServer ? \"Windows Server 2008\" : \"Windows Vista\");\n+              break;\n+            case 1:\n+              os_name = (isServer ? \"Windows Server 2008 R2\" : \"Windows 7\");\n+              break;\n+            case 2:\n+              os_name = (isServer ? \"Windows Server 2012\" : \"Windows 8\");\n+              break;\n+            case 3:\n+              os_name = (isServer ? \"Windows Server 2012 R2\" : \"Windows 8.1\");\n+              break;\n+            default:\n+              os_name = (isServer ? \"Windows Server\" : \"Windows Client\");\n+          }\n+          break;\n+        case 10:\n+          os_name = (isServer ? \"Windows Server 2016\" : \"Windows 10\");\n+          break;\n+        default:\n+          os_name = (isServer ? \"Windows Server\" : \"Windows Client\");\n+      }\n+      writer->json_keyvalue(\"osVersion\", os_name);\n+\n+      // Convert and report the machine name and comment fields\n+      // (these are LPWSTR types)\n+      size_t count;\n+      char name_buf[256];\n+      wcstombs_s(\n+          &count, name_buf, sizeof(name_buf), os_info->sv101_name, _TRUNCATE);\n+      if (os_info->sv101_comment != nullptr) {\n+        char comment_buf[256];\n+        wcstombs_s(&count,\n+                   comment_buf,\n+                   sizeof(comment_buf),\n+                   os_info->sv101_comment,\n+                   _TRUNCATE);\n+        buf << name_buf << \" \" << comment_buf;\n+        writer->json_keyvalue(\"machine\", buf.str());\n+        buf.flush();\n+      } else {\n+        writer->json_keyvalue(\"machine\", name_buf);\n+      }\n+\n+      if (os_info != nullptr) {\n+        NetApiBufferFree(os_info);\n+      }\n+    } else {\n+      // NetServerGetInfo() failed, fallback to use GetComputerName() instead\n+      TCHAR machine_name[256];\n+      DWORD machine_name_size = 256;\n+      writer->json_keyvalue(\"osVersion\", \"Windows\");\n+      if (GetComputerName(machine_name, &machine_name_size)) {\n+        writer->json_keyvalue(\"machine\", machine_name);\n+      }\n+    }\n+  }\n+#else\n+  // Report operating system and machine information (Unix/OSX)\n+  struct utsname os_info;\n+  if (uname(&os_info) >= 0) {\n+#ifdef _AIX\n+    buf << os_info.sysname << \" \" << os_info.version << \".\" << os_info.release;\n+    writer->json_keyvalue(\"osVersion\", buf.str());\n+    buf.flush();\n+#else\n+    buf << os_info.sysname << \" \" << os_info.release << \" \" << os_info.version;\n+    writer->json_keyvalue(\"osVersion\", buf.str());\n+    buf.flush();\n+#endif\n+    const char* (*libc_version)();\n+    *(reinterpret_cast<void**>(&libc_version)) =\n+        dlsym(RTLD_DEFAULT, \"gnu_get_libc_version\");\n+    if (libc_version != nullptr) {\n+      writer->json_keyvalue(\"glibc\", (*libc_version)());\n+    }\n+    buf << os_info.nodename << \" \" << os_info.machine;\n+    writer->json_keyvalue(\"machine\", buf.str());\n+    buf.flush();\n+  }\n+#endif\n+}\n+\n+// Report the JavaScript stack.\n+static void PrintJavaScriptStack(JSONWriter* writer,\n+                                 Isolate* isolate,\n+                                 Local<String> stackstr,\n+                                 const char* location) {\n+  writer->json_objectstart(\"javascriptStack\");\n+\n+  std::string ss;\n+  if ((!strcmp(location, \"OnFatalError\")) ||\n+      (!strcmp(location, \"OnUserSignal\"))) {\n+    ss = \"No stack.\\nUnavailable.\\n\";\n+  } else {\n+    String::Utf8Value sv(isolate, stackstr);\n+    ss = std::string(*sv, sv.length());\n+  }\n+  int line = ss.find(\"\\n\");\n+  if (line == -1) {\n+    writer->json_keyvalue(\"message\", ss.c_str());\n+    writer->json_objectend();\n+  } else {\n+    std::string l = ss.substr(0, line);\n+    writer->json_keyvalue(\"message\", l);\n+    writer->json_arraystart(\"stack\");\n+    ss = ss.substr(line + 1);\n+    line = ss.find(\"\\n\");\n+    while (line != -1) {\n+      l = ss.substr(0, line);\n+      l.erase(l.begin(), std::find_if(l.begin(), l.end(), [](int ch) {\n+                return !std::iswspace(ch);\n+              }));\n+      writer->json_element(l);\n+      ss = ss.substr(line + 1);\n+      line = ss.find(\"\\n\");\n+    }\n+  }\n+  writer->json_arrayend();\n+  writer->json_objectend();\n+}\n+\n+// Report a native stack backtrace\n+static void PrintNativeStack(JSONWriter* writer) {\n+  auto sym_ctx = NativeSymbolDebuggingContext::New();\n+  void* frames[256];\n+  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));\n+  writer->json_arraystart(\"nativeStack\");\n+  int i;\n+  std::ostringstream buf;\n+  for (i = 1; i < size - 1; i += 1) {\n+    void* frame = frames[i];\n+    buf.str(\"\");\n+    buf << \" [pc=\" << frame << \"] \";\n+    buf << sym_ctx->LookupSymbol(frame).Display().c_str();\n+    writer->json_element(buf.str());\n+  }\n+  buf.str(\"\");\n+  buf << \" [pc=\" << frames[i] << \"] \";\n+  buf << sym_ctx->LookupSymbol(frames[i]).Display().c_str();\n+  writer->json_element(buf.str());\n+  writer->json_arrayend();\n+}\n+\n+// Report V8 JavaScript heap information.\n+// This uses the existing V8 HeapStatistics and HeapSpaceStatistics APIs.\n+// The isolate->GetGCStatistics(&heap_stats) internal V8 API could potentially\n+// provide some more useful information - the GC history and the handle counts\n+static void PrintGCStatistics(JSONWriter* writer, Isolate* isolate) {\n+  HeapStatistics v8_heap_stats;\n+  isolate->GetHeapStatistics(&v8_heap_stats);\n+  HeapSpaceStatistics v8_heap_space_stats;\n+\n+  writer->json_objectstart(\"javascriptHeap\");\n+  writer->json_keyvalue(\"totalMemory\",\n+                        std::to_string(v8_heap_stats.total_heap_size()));\n+  writer->json_keyvalue(\"totalCommittedMemory\",\n+                        std::to_string(v8_heap_stats.total_physical_size()));\n+  writer->json_keyvalue(\"usedMemory\",\n+                        std::to_string(v8_heap_stats.used_heap_size()));\n+  writer->json_keyvalue(\"availableMemory\",\n+                        std::to_string(v8_heap_stats.total_available_size()));\n+  writer->json_keyvalue(\"memoryLimit\",\n+                        std::to_string(v8_heap_stats.heap_size_limit()));\n+\n+  writer->json_objectstart(\"heapSpaces\");\n+  // Loop through heap spaces\n+  size_t i;\n+  for (i = 0; i < isolate->NumberOfHeapSpaces() - 1; i++) {\n+    isolate->GetHeapSpaceStatistics(&v8_heap_space_stats, i);\n+    writer->json_objectstart(v8_heap_space_stats.space_name());\n+    writer->json_keyvalue(\"memorySize\",\n+                          std::to_string(v8_heap_space_stats.space_size()));\n+    writer->json_keyvalue(\n+        \"committedMemory\",\n+        std::to_string(v8_heap_space_stats.physical_space_size()));\n+    writer->json_keyvalue(\n+        \"capacity\",\n+        std::to_string(v8_heap_space_stats.space_used_size() +\n+                       v8_heap_space_stats.space_available_size()));\n+    writer->json_keyvalue(\n+        \"used\", std::to_string(v8_heap_space_stats.space_used_size()));\n+    writer->json_keyvalue(\n+        \"available\",\n+        std::to_string(v8_heap_space_stats.space_available_size()));\n+    writer->json_objectend();\n+  }\n+  isolate->GetHeapSpaceStatistics(&v8_heap_space_stats, i);\n+  writer->json_objectstart(v8_heap_space_stats.space_name());\n+  writer->json_keyvalue(\"memorySize\",\n+                        std::to_string(v8_heap_space_stats.space_size()));\n+  writer->json_keyvalue(\n+      \"committedMemory\",\n+      std::to_string(v8_heap_space_stats.physical_space_size()));\n+  writer->json_keyvalue(\n+      \"capacity\",\n+      std::to_string(v8_heap_space_stats.space_used_size() +\n+                     v8_heap_space_stats.space_available_size()));\n+  writer->json_keyvalue(\"used\",\n+                        std::to_string(v8_heap_space_stats.space_used_size()));\n+  writer->json_keyvalue(\n+      \"available\", std::to_string(v8_heap_space_stats.space_available_size()));\n+  writer->json_objectend();\n+  writer->json_objectend();\n+  writer->json_objectend();\n+}\n+\n+#ifndef _WIN32\n+// Report resource usage (Linux/OSX only).\n+static void PrintResourceUsage(JSONWriter* writer) {\n+  char buf[64];\n+  double cpu_abs;\n+  double cpu_percentage;\n+  time_t current_time;  // current time absolute\n+  time(&current_time);\n+  size_t boot_time = static_cast<time_t>(node::per_process::prog_start_time /\n+                                         (1000 * 1000 * 1000));\n+  auto uptime = difftime(current_time, boot_time);\n+  if (uptime == 0) uptime = 1;  // avoid division by zero.\n+\n+  // Process and current thread usage statistics\n+  struct rusage stats;\n+  writer->json_objectstart(\"resourceUsage\");\n+  if (getrusage(RUSAGE_SELF, &stats) == 0) {\n+#if defined(__APPLE__) || defined(_AIX)\n+    snprintf(buf,\n+             sizeof(buf),\n+             \"%ld.%06d\",\n+             stats.ru_utime.tv_sec,\n+             stats.ru_utime.tv_usec);\n+    writer->json_keyvalue(\"userCpuSeconds\", buf);\n+    snprintf(buf,\n+             sizeof(buf),\n+             \"%ld.%06d\",\n+             stats.ru_stime.tv_sec,\n+             stats.ru_stime.tv_usec);\n+    writer->json_keyvalue(\"kernelCpuSeconds\", buf);\n+#else\n+    snprintf(buf,\n+             sizeof(buf),\n+             \"%ld.%06ld\",\n+             stats.ru_utime.tv_sec,\n+             stats.ru_utime.tv_usec);\n+    writer->json_keyvalue(\"userCpuSeconds\", buf);\n+    snprintf(buf,\n+             sizeof(buf),\n+             \"%ld.%06ld\",\n+             stats.ru_stime.tv_sec,\n+             stats.ru_stime.tv_usec);\n+    writer->json_keyvalue(\"kernelCpuSeconds\", buf);\n+#endif\n+    cpu_abs = stats.ru_utime.tv_sec + 0.000001 * stats.ru_utime.tv_usec +\n+              stats.ru_stime.tv_sec + 0.000001 * stats.ru_stime.tv_usec;\n+    cpu_percentage = (cpu_abs / uptime) * 100.0;\n+    writer->json_keyvalue(\"cpuConsumptionPercent\",\n+                          std::to_string(cpu_percentage));\n+    writer->json_keyvalue(\"maxRss\", std::to_string(stats.ru_maxrss * 1024));\n+    writer->json_objectstart(\"pageFaults\");\n+    writer->json_keyvalue(\"IORequired\", std::to_string(stats.ru_majflt));\n+    writer->json_keyvalue(\"IONotRequired\", std::to_string(stats.ru_minflt));\n+    writer->json_objectend();\n+    writer->json_objectstart(\"fsActivity\");\n+    writer->json_keyvalue(\"reads\", std::to_string(stats.ru_inblock));\n+    writer->json_keyvalue(\"writes\", std::to_string(stats.ru_oublock));\n+    writer->json_objectend();\n+  }\n+  writer->json_objectend();\n+#ifdef RUSAGE_THREAD\n+  if (getrusage(RUSAGE_THREAD, &stats) == 0) {\n+    writer->json_objectstart(\"uvthreadResourceUsage\");\n+#if defined(__APPLE__) || defined(_AIX)\n+    snprintf(buf,\n+             sizeof(buf),\n+             \"%ld.%06d\",\n+             stats.ru_utime.tv_sec,\n+             stats.ru_utime.tv_usec);\n+    writer->json_keyvalue(\"userCpuSeconds\", buf);\n+    snprintf(buf,\n+             sizeof(buf),\n+             \"%ld.%06d\",\n+             stats.ru_stime.tv_sec,\n+             stats.ru_stime.tv_usec);\n+    writer->json_keyvalue(\"kernelCpuSeconds\", buf);\n+#else\n+    snprintf(buf,\n+             sizeof(buf),\n+             \"%ld.%06ld\",\n+             stats.ru_utime.tv_sec,\n+             stats.ru_utime.tv_usec);\n+    writer->json_keyvalue(\"userCpuSeconds\", buf);\n+    snprintf(buf,\n+             sizeof(buf),\n+             \"%ld.%06ld\",\n+             stats.ru_stime.tv_sec,\n+             stats.ru_stime.tv_usec);\n+    writer->json_keyvalue(\"kernelCpuSeconds\", buf);\n+#endif\n+    cpu_abs = stats.ru_utime.tv_sec + 0.000001 * stats.ru_utime.tv_usec +\n+              stats.ru_stime.tv_sec + 0.000001 * stats.ru_stime.tv_usec;\n+    cpu_percentage = (cpu_abs / uptime) * 100.0;\n+    writer->json_keyvalue(\"cpuConsumptionPercent\",\n+                          std::to_string(cpu_percentage));\n+    writer->json_objectstart(\"fsActivity\");\n+    writer->json_keyvalue(\"reads\", std::to_string(stats.ru_inblock));\n+    writer->json_keyvalue(\"writes\", std::to_string(stats.ru_oublock));\n+    writer->json_objectend();\n+    writer->json_objectend();\n+  }\n+#endif\n+}\n+#endif\n+\n+// Report operating system information.\n+static void PrintSystemInformation(JSONWriter* writer) {\n+#ifndef _WIN32\n+  static struct {\n+    const char* description;\n+    int id;\n+  } rlimit_strings[] = {\n+    {\"core_file_size_blocks\", RLIMIT_CORE},\n+    {\"data_seg_size_kbytes\", RLIMIT_DATA},\n+    {\"file_size_blocks\", RLIMIT_FSIZE},\n+#if !(defined(_AIX) || defined(__sun))\n+    {\"max_locked_memory_bytes\", RLIMIT_MEMLOCK},\n+#endif\n+#ifndef __sun\n+    {\"max_memory_size_kbytes\", RLIMIT_RSS},\n+#endif\n+    {\"open_files\", RLIMIT_NOFILE},\n+    {\"stack_size_bytes\", RLIMIT_STACK},\n+    {\"cpu_time_seconds\", RLIMIT_CPU},\n+#ifndef __sun\n+    {\"max_user_processes\", RLIMIT_NPROC},\n+#endif\n+    {\"virtual_memory_kbytes\", RLIMIT_AS}\n+  };\n+#endif  // _WIN32\n+  writer->json_objectstart(\"environmentVariables\");\n+  Mutex::ScopedLock lock(node::per_process::env_var_mutex);\n+#ifdef _WIN32\n+  LPWSTR lpszVariable;\n+  LPWCH lpvEnv;\n+\n+  // Get pointer to the environment block\n+  lpvEnv = GetEnvironmentStringsW();\n+  if (lpvEnv != nullptr) {\n+    // Variable strings are separated by null bytes,\n+    // and the block is terminated by a null byte.\n+    lpszVariable = reinterpret_cast<LPWSTR>(lpvEnv);\n+    while (*lpszVariable) {\n+      DWORD size = WideCharToMultiByte(\n+          CP_UTF8, 0, lpszVariable, -1, nullptr, 0, nullptr, nullptr);\n+      char* str = new char[size];\n+      WideCharToMultiByte(\n+          CP_UTF8, 0, lpszVariable, -1, str, size, nullptr, nullptr);\n+      std::string env(str);\n+      int sep = env.rfind(\"=\");\n+      std::string key = env.substr(0, sep);\n+      std::string value = env.substr(sep + 1);\n+      writer->json_keyvalue(key, value);\n+      lpszVariable += lstrlenW(lpszVariable) + 1;\n+    }\n+    FreeEnvironmentStringsW(lpvEnv);\n+  }\n+  writer->json_objectend();\n+#else\n+  std::string pair;\n+  for (char** env = environ; *env != nullptr; ++env) {\n+    std::string pair(*env);\n+    int separator = pair.find('=');\n+    std::string key = pair.substr(0, separator);\n+    std::string str = pair.substr(separator + 1);\n+    writer->json_keyvalue(key, str);\n+  }\n+  writer->json_objectend();\n+\n+  writer->json_objectstart(\"userLimits\");\n+  struct rlimit limit;\n+  char buf[64];\n+  std::string soft, hard;\n+\n+  for (size_t i = 0; i < arraysize(rlimit_strings); i++) {\n+    if (getrlimit(rlimit_strings[i].id, &limit) == 0) {\n+      if (limit.rlim_cur == RLIM_INFINITY) {\n+        soft = std::string(\"unlimited\");\n+      } else {\n+#if defined(_AIX) || defined(__sun)\n+        snprintf(buf, sizeof(buf), \"%ld\", limit.rlim_cur);\n+        soft = std::string(buf);\n+#elif defined(__linux__) && !defined(__GLIBC__)\n+        snprintf(buf, sizeof(buf), \"%ld\", limit.rlim_cur);\n+        soft = std::string(buf);\n+#else\n+        snprintf(buf, sizeof(buf), \"%16\" PRIu64, limit.rlim_cur);\n+        soft = std::string(soft);\n+#endif\n+      }\n+      if (limit.rlim_max == RLIM_INFINITY) {\n+        hard = std::string(\"unlimited\");\n+      } else {\n+#ifdef _AIX\n+        snprintf(buf, sizeof(buf), \"%lu\", limit.rlim_max);\n+        hard = std::string(buf);\n+#else\n+        snprintf(buf, sizeof(buf), \"%lu\", limit.rlim_max);\n+        hard = std::string(buf);\n+#endif\n+      }\n+      writer->json_objectstart(rlimit_strings[i].description);\n+      writer->json_keyvalue(\"soft\", soft);\n+      writer->json_keyvalue(\"hard\", hard);\n+      writer->json_objectend();\n+    }\n+  }\n+  writer->json_objectend();\n+#endif\n+\n+  PrintLoadedLibraries(writer);\n+}\n+\n+// Report a list of loaded native libraries.\n+static void PrintLoadedLibraries(JSONWriter* writer) {\n+  writer->json_arraystart(\"sharedObjects\");\n+  std::vector<std::string> modules =\n+      NativeSymbolDebuggingContext::GetLoadedLibraries();\n+  for (auto const& module_name : modules) writer->json_element(module_name);\n+  writer->json_arrayend();\n+}\n+\n+// Obtain and report the node and subcomponent version strings.\n+static void PrintComponentVersions(JSONWriter* writer) {\n+  std::stringstream buf;\n+\n+  writer->json_objectstart(\"componentVersions\");\n+\n+#define V(key)                                                                 \\\n+  writer->json_keyvalue(#key, node::per_process::metadata.versions.key.c_str());\n+  NODE_VERSIONS_KEYS(V)\n+#undef V\n+\n+  // Some extra information that is not present in node_metadata.\n+  writer->json_keyvalue(\"arch\", NODE_ARCH);\n+  writer->json_keyvalue(\"platform\", NODE_PLATFORM);\n+  writer->json_keyvalue(\"release\", NODE_RELEASE);\n+  if (NODE_VERSION_IS_LTS != 0)\n+    writer->json_keyvalue(\"lts\", NODE_VERSION_LTS_CODENAME);\n+  writer->json_objectend();\n+}\n+\n+static void LocalTime(TIME_TYPE* tm_struct) {\n+#ifdef _WIN32\n+  GetLocalTime(tm_struct);\n+#else  // UNIX, OSX\n+  struct timeval time_val;\n+  gettimeofday(&time_val, nullptr);\n+  localtime_r(&time_val.tv_sec, tm_struct);\n+#endif\n+}\n+\n+}  // namespace report"
        },
        {
            "sha": "c64b9c9a20c116e355c6046f12cd577e19d6cd6f",
            "filename": "src/node_report.h",
            "status": "added",
            "additions": 165,
            "deletions": 0,
            "changes": 165,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_report.h",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_report.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_report.h?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -0,0 +1,165 @@\n+#ifndef SRC_NODE_REPORT_H_\n+#define SRC_NODE_REPORT_H_\n+\n+#include <node.h>\n+#include <node_buffer.h>\n+#include <uv.h>\n+#include <algorithm>\n+#include <climits>\n+#include <cstdlib>\n+#include <cstring>\n+#include <queue>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+#include \"v8.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <iomanip>\n+#include <iostream>\n+#include <sstream>\n+\n+#ifdef _WIN32\n+#include <time.h>\n+#else\n+#include <sys/time.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+#endif\n+\n+namespace report {\n+\n+#ifdef _WIN32\n+typedef SYSTEMTIME TIME_TYPE;\n+typedef DWORD PID_TYPE;\n+#define PATHSEP \"\\\\\"\n+#else  // UNIX, OSX\n+typedef struct tm TIME_TYPE;\n+typedef pid_t PID_TYPE;\n+#define PATHSEP \"/\"\n+#endif\n+\n+void InitializeReport(v8::Isolate* isolate, node::Environment* env);\n+\n+// Function declarations - functions in src/node_report.cc\n+std::string TriggerNodeReport(v8::Isolate* isolate,\n+                              node::Environment* env,\n+                              const char* message,\n+                              const char* location,\n+                              std::string name,\n+                              v8::Local<v8::String> stackstr);\n+void GetNodeReport(v8::Isolate* isolate,\n+                   node::Environment* env,\n+                   const char* message,\n+                   const char* location,\n+                   v8::Local<v8::String> stackstr,\n+                   std::ostream& out);\n+\n+// Function declarations - utility functions in src/utilities.cc\n+void ReportEndpoints(uv_handle_t* h, std::ostringstream& out);\n+void WalkHandle(uv_handle_t* h, void* arg);\n+std::string EscapeJsonChars(const std::string& str);\n+\n+// Function declarations - export functions in src/node_report_module.cc\n+void TriggerReport(const v8::FunctionCallbackInfo<v8::Value>& info);\n+void GetReport(const v8::FunctionCallbackInfo<v8::Value>& info);\n+\n+// Node.js boot time - defined in src/node.cc\n+extern double prog_start_time;\n+\n+// JSON compiler definitions.\n+class JSONWriter {\n+ public:\n+  explicit JSONWriter(std::ostream& out)\n+      : out_(out), indent_(0), state_(JSONOBJECT) {}\n+\n+  inline void indent() { indent_ += 2; }\n+  inline void deindent() { indent_ -= 2; }\n+  inline void advance() {\n+    for (int i = 0; i < indent_; i++) out_ << \" \";\n+  }\n+\n+  inline void json_start() {\n+    if (state_ == JSONVALUE) out_ << \",\";\n+    out_ << \"\\n\";\n+    advance();\n+    out_ << \"{\";\n+    indent();\n+    state_ = JSONOBJECT;\n+  }\n+\n+  inline void json_end() {\n+    out_ << \"\\n\";\n+    deindent();\n+    advance();\n+    out_ << \"}\";\n+    state_ = JSONVALUE;\n+  }\n+  template <typename T>\n+  inline void json_objectstart(T key) {\n+    if (state_ == JSONVALUE) out_ << \",\";\n+    out_ << \"\\n\";\n+    advance();\n+    out_ << \"\\\"\" << key << \"\\\"\"\n+         << \": {\";\n+    indent();\n+    state_ = JSONOBJECT;\n+  }\n+\n+  template <typename T>\n+  inline void json_arraystart(T key) {\n+    if (state_ == JSONVALUE) out_ << \",\";\n+    out_ << \"\\n\";\n+    advance();\n+    out_ << \"\\\"\" << key << \"\\\"\"\n+         << \": [\";\n+    indent();\n+    state_ = JSONOBJECT;\n+  }\n+  inline void json_objectend() {\n+    out_ << \"\\n\";\n+    deindent();\n+    advance();\n+    out_ << \"}\";\n+    state_ = JSONVALUE;\n+  }\n+\n+  inline void json_arrayend() {\n+    out_ << \"\\n\";\n+    deindent();\n+    advance();\n+    out_ << \"]\";\n+    state_ = JSONVALUE;\n+  }\n+  template <typename T, typename U>\n+  inline void json_keyvalue(T key, U value) {\n+    if (state_ == JSONVALUE) out_ << \",\";\n+    out_ << \"\\n\";\n+    advance();\n+    out_ << \"\\\"\" << key << \"\\\"\"\n+         << \": \"\n+         << \"\\\"\";\n+    out_ << EscapeJsonChars(value) << \"\\\"\";\n+    state_ = JSONVALUE;\n+  }\n+\n+  template <typename U>\n+  inline void json_element(U value) {\n+    if (state_ == JSONVALUE) out_ << \",\";\n+    out_ << \"\\n\";\n+    advance();\n+    out_ << \"\\\"\" << EscapeJsonChars(value) << \"\\\"\";\n+    state_ = JSONVALUE;\n+  }\n+\n+ private:\n+  enum JSONState { JSONOBJECT, JSONVALUE };\n+  std::ostream& out_;\n+  int indent_;\n+  int state_;\n+};\n+\n+}  // namespace report\n+\n+#endif  // SRC_NODE_REPORT_H_"
        },
        {
            "sha": "522cf43a4516ddf75ee3c9e56f95b90d809d031c",
            "filename": "src/node_report_module.cc",
            "status": "added",
            "additions": 294,
            "deletions": 0,
            "changes": 294,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_report_module.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_report_module.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_report_module.cc?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -0,0 +1,294 @@\n+#include \"env.h\"\n+#include \"node_errors.h\"\n+#include \"node_internals.h\"\n+#include \"node_options.h\"\n+#include \"node_report.h\"\n+#include \"util.h\"\n+\n+#include \"env-inl.h\"\n+#include \"handle_wrap.h\"\n+#include \"node_buffer.h\"\n+#include \"stream_base-inl.h\"\n+#include \"stream_wrap.h\"\n+#include \"util-inl.h\"\n+\n+#include <v8.h>\n+#include <atomic>\n+#include <sstream>\n+\n+namespace report {\n+using node::Environment;\n+using node::FIXED_ONE_BYTE_STRING;\n+using node::PerIsolateOptions;\n+using node::Utf8Value;\n+using v8::Array;\n+using v8::Boolean;\n+using v8::Context;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Object;\n+using v8::String;\n+using v8::V8;\n+using v8::Value;\n+\n+// Internal/static function declarations\n+void OnUncaughtException(const FunctionCallbackInfo<Value>& info);\n+static void Initialize(Local<Object> exports,\n+                       Local<Value> unused,\n+                       Local<Context> context);\n+\n+// External JavaScript API for triggering a report\n+void TriggerReport(const FunctionCallbackInfo<Value>& info) {\n+  Environment* env = Environment::GetCurrent(info);\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n+  std::string filename;\n+  Local<String> stackstr;\n+\n+  if (info.Length() == 1) {\n+    stackstr = info[0].As<String>();\n+  } else {\n+    filename = *String::Utf8Value(isolate, info[0]);\n+    stackstr = info[1].As<String>();\n+  }\n+\n+  filename = TriggerNodeReport(\n+      isolate, env, \"JavaScript API\", __func__, filename, stackstr);\n+  // Return value is the report filename\n+  info.GetReturnValue().Set(\n+      String::NewFromUtf8(isolate, filename.c_str(), v8::NewStringType::kNormal)\n+          .ToLocalChecked());\n+}\n+\n+// External JavaScript API for returning a report\n+void GetReport(const FunctionCallbackInfo<Value>& info) {\n+  Environment* env = Environment::GetCurrent(info);\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n+  std::ostringstream out;\n+\n+  GetNodeReport(\n+      isolate, env, \"JavaScript API\", __func__, info[0].As<String>(), out);\n+\n+  // Return value is the contents of a report as a string.\n+  info.GetReturnValue().Set(String::NewFromUtf8(isolate,\n+                                                out.str().c_str(),\n+                                                v8::NewStringType::kNormal)\n+                                .ToLocalChecked());\n+}\n+\n+// Callbacks for triggering report on uncaught exception.\n+// Calls triggered from JS land.\n+void OnUncaughtException(const FunctionCallbackInfo<Value>& info) {\n+  Environment* env = Environment::GetCurrent(info);\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n+  std::string filename;\n+  std::shared_ptr<PerIsolateOptions> options = env->isolate_data()->options();\n+\n+  // Trigger report if requested\n+  if (options->report_uncaught_exception) {\n+    TriggerNodeReport(\n+        isolate, env, \"exception\", __func__, filename, info[0].As<String>());\n+  }\n+}\n+\n+// Signal handler for report action, called from JS land (util.js)\n+void OnUserSignal(const FunctionCallbackInfo<Value>& info) {\n+  Environment* env = Environment::GetCurrent(info);\n+  Isolate* isolate = env->isolate();\n+  CHECK(info[0]->IsString());\n+  Local<String> str = info[0].As<String>();\n+  String::Utf8Value value(isolate, str);\n+  std::string filename;\n+  TriggerNodeReport(\n+      isolate, env, *value, __func__, filename, info[0].As<String>());\n+}\n+\n+// Native module initializer function, called when the module is require'd\n+void InitializeReport(Isolate* isolate, Environment* env) {\n+  // Register the boot time of the process, for\n+  // computing resource consumption average etc.\n+  std::shared_ptr<PerIsolateOptions> options = env->isolate_data()->options();\n+\n+  if (options->report_signal == \"\") options->report_signal = \"SIGUSR2\";\n+}\n+\n+// A method to sync up data elements in the JS land with its\n+// corresponding elements in the C++ world. Required because\n+// (i) the tunables are first intercepted through the CLI but\n+// later modified via APIs. (ii) the report generation events\n+// are controlled partly from C++ and partly from JS.\n+void SyncConfig(const FunctionCallbackInfo<Value>& info) {\n+  Environment* env = Environment::GetCurrent(info);\n+  Local<Context> context = env->context();\n+  std::shared_ptr<PerIsolateOptions> options = env->isolate_data()->options();\n+\n+  CHECK_EQ(info.Length(), 2);\n+  Local<Object> obj;\n+  if (!info[0]->ToObject(context).ToLocal(&obj)) return;\n+  bool sync = info[1].As<Boolean>()->Value();\n+\n+  // Events array\n+  Local<String> eventskey = FIXED_ONE_BYTE_STRING(env->isolate(), \"events\");\n+  Local<Value> events_unchecked;\n+  if (!obj->Get(context, eventskey).ToLocal(&events_unchecked)) return;\n+  Local<Array> events;\n+  if (events_unchecked->IsUndefined() || events_unchecked->IsNull()) {\n+    events_unchecked = Array::New(env->isolate(), 0);\n+    if (obj->Set(context, eventskey, events_unchecked).IsNothing()) return;\n+  }\n+  events = events_unchecked.As<Array>();\n+\n+  // Signal\n+  Local<String> signalkey = env->signal_string();\n+  Local<Value> signal_unchecked;\n+  if (!obj->Get(context, signalkey).ToLocal(&signal_unchecked)) return;\n+  Local<String> signal;\n+  if (signal_unchecked->IsUndefined() || signal_unchecked->IsNull())\n+    signal_unchecked = signalkey;\n+  signal = signal_unchecked.As<String>();\n+\n+  Utf8Value signalstr(env->isolate(), signal);\n+\n+  // Report file\n+  Local<String> filekey = FIXED_ONE_BYTE_STRING(env->isolate(), \"filename\");\n+  Local<Value> file_unchecked;\n+  if (!obj->Get(context, filekey).ToLocal(&file_unchecked)) return;\n+  Local<String> file;\n+  if (file_unchecked->IsUndefined() || file_unchecked->IsNull())\n+    file_unchecked = filekey;\n+  file = file_unchecked.As<String>();\n+\n+  Utf8Value filestr(env->isolate(), file);\n+\n+  // Report file path\n+  Local<String> pathkey = FIXED_ONE_BYTE_STRING(env->isolate(), \"path\");\n+  Local<Value> path_unchecked;\n+  if (!obj->Get(context, pathkey).ToLocal(&path_unchecked)) return;\n+  Local<String> path;\n+  if (path_unchecked->IsUndefined() || path_unchecked->IsNull())\n+    path_unchecked = pathkey;\n+  path = path_unchecked.As<String>();\n+\n+  Utf8Value pathstr(env->isolate(), path);\n+\n+  // Report verbosity\n+  Local<String> verbosekey = FIXED_ONE_BYTE_STRING(env->isolate(), \"verbose\");\n+  Local<Value> verbose_unchecked;\n+  if (!obj->Get(context, verbosekey).ToLocal(&verbose_unchecked)) return;\n+  Local<Boolean> verbose;\n+  if (verbose_unchecked->IsUndefined() || verbose_unchecked->IsNull())\n+    verbose_unchecked = Boolean::New(env->isolate(), \"verbose\");\n+  verbose = verbose_unchecked.As<Boolean>();\n+\n+  bool verb = verbose->BooleanValue(env->isolate());\n+\n+  if (sync) {\n+    static const std::string e = \"exception\";\n+    static const std::string s = \"signal\";\n+    static const std::string f = \"fatalerror\";\n+    for (uint32_t i = 0; i < events->Length(); i++) {\n+      Local<Value> v;\n+      if (!events->Get(context, i).ToLocal(&v)) return;\n+      Local<String> elem;\n+      if (!v->ToString(context).ToLocal(&elem)) return;\n+      String::Utf8Value buf(env->isolate(), elem);\n+      if (*buf == e) {\n+        options->report_uncaught_exception = true;\n+      } else if (*buf == s) {\n+        options->report_on_signal = true;\n+      } else if (*buf == f) {\n+        options->report_on_fatalerror = true;\n+      }\n+    }\n+    CHECK_NOT_NULL(*signalstr);\n+    options->report_signal = *signalstr;\n+    CHECK_NOT_NULL(*filestr);\n+    options->report_filename = *filestr;\n+    CHECK_NOT_NULL(*pathstr);\n+    options->report_directory = *pathstr;\n+    options->report_verbose = verb;\n+  } else {\n+    int i = 0;\n+    if (options->report_uncaught_exception &&\n+        events\n+            ->Set(context,\n+                  i++,\n+                  FIXED_ONE_BYTE_STRING(env->isolate(), \"exception\"))\n+            .IsNothing())\n+      return;\n+    if (options->report_on_signal &&\n+        events\n+            ->Set(context, i++, FIXED_ONE_BYTE_STRING(env->isolate(), \"signal\"))\n+            .IsNothing())\n+      return;\n+    if (options->report_on_fatalerror &&\n+        events\n+            ->Set(\n+                context, i, FIXED_ONE_BYTE_STRING(env->isolate(), \"fatalerror\"))\n+            .IsNothing())\n+      return;\n+\n+    Local<Value> signal_value;\n+    Local<Value> file_value;\n+    Local<Value> path_value;\n+    if (!node::ToV8Value(context, options->report_signal)\n+             .ToLocal(&signal_value))\n+      return;\n+    if (!obj->Set(context, signalkey, signal_value).FromJust()) return;\n+\n+    if (!node::ToV8Value(context, options->report_filename)\n+             .ToLocal(&file_value))\n+      return;\n+    if (!obj->Set(context, filekey, file_value).FromJust()) return;\n+\n+    if (!node::ToV8Value(context, options->report_directory)\n+             .ToLocal(&path_value))\n+      return;\n+    if (!obj->Set(context, pathkey, path_value).FromJust()) return;\n+\n+    if (!obj->Set(context,\n+                  verbosekey,\n+                  Boolean::New(env->isolate(), options->report_verbose))\n+             .FromJust())\n+      return;\n+  }\n+}\n+\n+static void Initialize(Local<Object> exports,\n+                       Local<Value> unused,\n+                       Local<Context> context) {\n+  Environment* env = Environment::GetCurrent(context);\n+  std::shared_ptr<PerIsolateOptions> options = env->isolate_data()->options();\n+  Isolate* isolate = env->isolate();\n+  InitializeReport(isolate, env);\n+  env->SetMethod(exports, \"triggerReport\", TriggerReport);\n+  env->SetMethod(exports, \"getReport\", GetReport);\n+  env->SetMethod(exports, \"onUnCaughtException\", OnUncaughtException);\n+  env->SetMethod(exports, \"onUserSignal\", OnUserSignal);\n+  env->SetMethod(exports, \"syncConfig\", SyncConfig);\n+\n+  // TODO(gireeshpunathil) if we are retaining this flag,\n+  // insert more verbose information at vital control flow\n+  // points. Right now, it is only this one.\n+  if (options->report_verbose) {\n+    std::cerr << \"report: initialization complete, event flags:\" << std::endl;\n+    std::cerr << \"report_uncaught_exception: \"\n+              << options->report_uncaught_exception << std::endl;\n+    std::cerr << \"report_on_signal: \" << options->report_on_signal << std::endl;\n+    std::cerr << \"report_on_fatalerror: \" << options->report_on_fatalerror\n+              << std::endl;\n+    std::cerr << \"report_signal: \" << options->report_signal << std::endl;\n+    std::cerr << \"report_filename: \" << options->report_filename << std::endl;\n+    std::cerr << \"report_directory: \" << options->report_directory << std::endl;\n+    std::cerr << \"report_verbose: \" << options->report_verbose << std::endl;\n+  }\n+}\n+\n+}  // namespace report\n+\n+NODE_MODULE_CONTEXT_AWARE_INTERNAL(report, report::Initialize)"
        },
        {
            "sha": "e93f230d318a6daa1fb7c8d0f34d55852baabe3a",
            "filename": "src/node_report_utils.cc",
            "status": "added",
            "additions": 299,
            "deletions": 0,
            "changes": 299,
            "blob_url": "https://github.com/nodejs/node/blob/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_report_utils.cc",
            "raw_url": "https://github.com/nodejs/node/raw/4f6797378eb6dd290dd5d8dc6417fea22d42ebad/src%2Fnode_report_utils.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_report_utils.cc?ref=4f6797378eb6dd290dd5d8dc6417fea22d42ebad",
            "patch": "@@ -0,0 +1,299 @@\n+#include <v8.h>\n+#include \"env.h\"\n+#include \"node_internals.h\"\n+#include \"node_options.h\"\n+#include \"node_report.h\"\n+#include \"util.h\"\n+#include \"v8.h\"\n+\n+namespace report {\n+\n+using node::MallocedBuffer;\n+\n+// Utility function to format libuv socket information.\n+void ReportEndpoints(uv_handle_t* h, std::ostringstream& out) {\n+  struct sockaddr_storage addr_storage;\n+  struct sockaddr* addr = reinterpret_cast<sockaddr*>(&addr_storage);\n+  char hostbuf[NI_MAXHOST];\n+  char portbuf[NI_MAXSERV];\n+  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);\n+  int addr_size = sizeof(addr_storage);\n+  int rc = -1;\n+\n+  switch (h->type) {\n+    case UV_UDP: {\n+      rc = uv_udp_getsockname(&(handle->udp), addr, &addr_size);\n+      break;\n+    }\n+    case UV_TCP: {\n+      rc = uv_tcp_getsockname(&(handle->tcp), addr, &addr_size);\n+      break;\n+    }\n+    default:\n+      break;\n+  }\n+  if (rc == 0) {\n+    // getnameinfo will format host and port and handle IPv4/IPv6.\n+    rc = getnameinfo(addr,\n+                     addr_size,\n+                     hostbuf,\n+                     sizeof(hostbuf),\n+                     portbuf,\n+                     sizeof(portbuf),\n+                     NI_NUMERICSERV);\n+    if (rc == 0) {\n+      out << std::string(hostbuf) << \":\" << std::string(portbuf);\n+    }\n+\n+    if (h->type == UV_TCP) {\n+      // Get the remote end of the connection.\n+      rc = uv_tcp_getpeername(&(handle->tcp), addr, &addr_size);\n+      if (rc == 0) {\n+        rc = getnameinfo(addr,\n+                         addr_size,\n+                         hostbuf,\n+                         sizeof(hostbuf),\n+                         portbuf,\n+                         sizeof(portbuf),\n+                         NI_NUMERICSERV);\n+        if (rc == 0) {\n+          out << \" connected to \";\n+          out << std::string(hostbuf) << \":\" << std::string(portbuf);\n+        }\n+      } else if (rc == UV_ENOTCONN) {\n+        out << \" (not connected)\";\n+      }\n+    }\n+  }\n+}\n+\n+// Utility function to format libuv path information.\n+void ReportPath(uv_handle_t* h, std::ostringstream& out) {\n+  MallocedBuffer<char> buffer(0);\n+  int rc = -1;\n+  size_t size = 0;\n+  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);\n+  // First call to get required buffer size.\n+  switch (h->type) {\n+    case UV_FS_EVENT: {\n+      rc = uv_fs_event_getpath(&(handle->fs_event), buffer.data, &size);\n+      break;\n+    }\n+    case UV_FS_POLL: {\n+      rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.data, &size);\n+      break;\n+    }\n+    default:\n+      break;\n+  }\n+  if (rc == UV_ENOBUFS) {\n+    buffer = MallocedBuffer<char>(size);\n+    switch (h->type) {\n+      case UV_FS_EVENT: {\n+        rc = uv_fs_event_getpath(&(handle->fs_event), buffer.data, &size);\n+        break;\n+      }\n+      case UV_FS_POLL: {\n+        rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.data, &size);\n+        break;\n+      }\n+      default:\n+        break;\n+    }\n+    if (rc == 0) {\n+      // buffer is not null terminated.\n+      std::string name(buffer.data, size);\n+      out << \"filename: \" << name;\n+    }\n+  }\n+}\n+\n+// Utility function to walk libuv handles.\n+void WalkHandle(uv_handle_t* h, void* arg) {\n+  std::string type;\n+  std::ostringstream data;\n+  JSONWriter* writer = reinterpret_cast<JSONWriter*>(arg);\n+  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);\n+\n+  // List all the types so we get a compile warning if we've missed one,\n+  // (using default: supresses the compiler warning).\n+  switch (h->type) {\n+    case UV_UNKNOWN_HANDLE:\n+      type = \"unknown\";\n+      break;\n+    case UV_ASYNC:\n+      type = \"async\";\n+      break;\n+    case UV_CHECK:\n+      type = \"check\";\n+      break;\n+    case UV_FS_EVENT: {\n+      type = \"fs_event\";\n+      ReportPath(h, data);\n+      break;\n+    }\n+    case UV_FS_POLL: {\n+      type = \"fs_poll\";\n+      ReportPath(h, data);\n+      break;\n+    }\n+    case UV_HANDLE:\n+      type = \"handle\";\n+      break;\n+    case UV_IDLE:\n+      type = \"idle\";\n+      break;\n+    case UV_NAMED_PIPE:\n+      type = \"pipe\";\n+      break;\n+    case UV_POLL:\n+      type = \"poll\";\n+      break;\n+    case UV_PREPARE:\n+      type = \"prepare\";\n+      break;\n+    case UV_PROCESS: {\n+      type = \"process\";\n+      data << \"pid: \" << handle->process.pid;\n+      break;\n+    }\n+    case UV_STREAM:\n+      type = \"stream\";\n+      break;\n+    case UV_TCP: {\n+      type = \"tcp\";\n+      ReportEndpoints(h, data);\n+      break;\n+    }\n+    case UV_TIMER: {\n+      uint64_t due = handle->timer.timeout;\n+      uint64_t now = uv_now(handle->timer.loop);\n+      type = \"timer\";\n+      data << \"repeat: \" << uv_timer_get_repeat(&(handle->timer));\n+      if (due > now) {\n+        data << \", timeout in: \" << (due - now) << \" ms\";\n+      } else {\n+        data << \", timeout expired: \" << (now - due) << \" ms ago\";\n+      }\n+      break;\n+    }\n+    case UV_TTY: {\n+      int height, width, rc;\n+      type = \"tty\";\n+      rc = uv_tty_get_winsize(&(handle->tty), &width, &height);\n+      if (rc == 0) {\n+        data << \"width: \" << width << \", height: \" << height;\n+      }\n+      break;\n+    }\n+    case UV_UDP: {\n+      type = \"udp\";\n+      ReportEndpoints(h, data);\n+      break;\n+    }\n+    case UV_SIGNAL: {\n+      // SIGWINCH is used by libuv so always appears.\n+      // See http://docs.libuv.org/en/v1.x/signal.html\n+      type = \"signal\";\n+      data << \"signum: \" << handle->signal.signum\n+#ifndef _WIN32\n+           << \" (\" << node::signo_string(handle->signal.signum) << \")\"\n+#endif\n+           << \"\";\n+      break;\n+    }\n+    case UV_FILE:\n+      type = \"file\";\n+      break;\n+    // We shouldn't see \"max\" type\n+    case UV_HANDLE_TYPE_MAX:\n+      type = \"max\";\n+      break;\n+  }\n+\n+  if (h->type == UV_TCP || h->type == UV_UDP\n+#ifndef _WIN32\n+      || h->type == UV_NAMED_PIPE\n+#endif\n+  ) {\n+    // These *must* be 0 or libuv will set the buffer sizes to the non-zero\n+    // values they contain.\n+    int send_size = 0;\n+    int recv_size = 0;\n+    if (h->type == UV_TCP || h->type == UV_UDP) {\n+      data << \", \";\n+    }\n+    uv_send_buffer_size(h, &send_size);\n+    uv_recv_buffer_size(h, &recv_size);\n+    data << \"send buffer size: \" << send_size\n+         << \", recv buffer size: \" << recv_size;\n+  }\n+\n+  if (h->type == UV_TCP || h->type == UV_NAMED_PIPE || h->type == UV_TTY ||\n+      h->type == UV_UDP || h->type == UV_POLL) {\n+    uv_os_fd_t fd_v;\n+    uv_os_fd_t* fd = &fd_v;\n+    int rc = uv_fileno(h, fd);\n+    // uv_os_fd_t is an int on Unix and HANDLE on Windows.\n+#ifndef _WIN32\n+    if (rc == 0) {\n+      switch (fd_v) {\n+        case 0:\n+          data << \", stdin\";\n+          break;\n+        case 1:\n+          data << \", stdout\";\n+          break;\n+        case 2:\n+          data << \", stderr\";\n+          break;\n+        default:\n+          data << \", file descriptor: \" << static_cast<int>(fd_v);\n+          break;\n+      }\n+    }\n+#endif\n+  }\n+\n+  if (h->type == UV_TCP || h->type == UV_NAMED_PIPE || h->type == UV_TTY) {\n+    data << \", write queue size: \" << handle->stream.write_queue_size;\n+    data << (uv_is_readable(&handle->stream) ? \", readable\" : \"\")\n+         << (uv_is_writable(&handle->stream) ? \", writable\" : \"\");\n+  }\n+\n+  writer->json_start();\n+  writer->json_keyvalue(\"type\", type);\n+  writer->json_keyvalue(\"is_active\", std::to_string(uv_is_active(h)));\n+  writer->json_keyvalue(\"is_referenced\", std::to_string(uv_has_ref(h)));\n+  writer->json_keyvalue(\"address\",\n+                        std::to_string(reinterpret_cast<int64_t>(h)));\n+  writer->json_keyvalue(\"details\", data.str());\n+  writer->json_end();\n+}\n+\n+static std::string findAndReplace(const std::string& str,\n+                                  const std::string& old,\n+                                  const std::string& neu) {\n+  std::string ret = str;\n+  size_t pos = 0;\n+  while ((pos = ret.find(old, pos)) != std::string::npos) {\n+    ret.replace(pos, old.length(), neu);\n+    pos += neu.length();\n+  }\n+  return ret;\n+}\n+\n+std::string EscapeJsonChars(const std::string& str) {\n+  std::string ret = str;\n+  ret = findAndReplace(ret, \"\\\\\", \"\\\\\\\\\");\n+  ret = findAndReplace(ret, \"\\\\u\", \"\\\\u\");\n+  ret = findAndReplace(ret, \"\\n\", \"\\\\n\");\n+  ret = findAndReplace(ret, \"\\f\", \"\\\\f\");\n+  ret = findAndReplace(ret, \"\\r\", \"\\\\r\");\n+  ret = findAndReplace(ret, \"\\b\", \"\\\\b\");\n+  ret = findAndReplace(ret, \"\\t\", \"\\\\t\");\n+  ret = findAndReplace(ret, \"\\\"\", \"\\\\\\\"\");\n+  return ret;\n+}\n+\n+}  // namespace report"
        }
    ],
    "stats": {
        "total": 1997,
        "additions": 1995,
        "deletions": 2
    }
}