{
    "author": "devsnek",
    "message": "src: flatten ContextifyContext\n\nFlattens ContextifyContext allows the context interface to be used in\nother parts of the code base.\n\nPR-URL: https://github.com/nodejs/node/pull/17560\nReviewed-By: MichaÃ«l Zasso <targos@protonmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>",
    "sha": "3bf34f27a1b231eec12ec999ca0f5d59bce9da14",
    "files": [
        {
            "sha": "95b32053a64ab9c16105b1ba02b5796d9fa05bb7",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/3bf34f27a1b231eec12ec999ca0f5d59bce9da14/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/3bf34f27a1b231eec12ec999ca0f5d59bce9da14/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=3bf34f27a1b231eec12ec999ca0f5d59bce9da14",
            "patch": "@@ -351,6 +351,7 @@\n         'src/node.h',\n         'src/node_buffer.h',\n         'src/node_constants.h',\n+        'src/node_contextify.h',\n         'src/node_debug_options.h',\n         'src/node_file.h',\n         'src/node_http2.h',"
        },
        {
            "sha": "c50cb19529c13d7a2ce4639345175f2b6a9384e1",
            "filename": "src/node_contextify.cc",
            "status": "modified",
            "additions": 417,
            "deletions": 435,
            "changes": 852,
            "blob_url": "https://github.com/nodejs/node/blob/3bf34f27a1b231eec12ec999ca0f5d59bce9da14/src%2Fnode_contextify.cc",
            "raw_url": "https://github.com/nodejs/node/raw/3bf34f27a1b231eec12ec999ca0f5d59bce9da14/src%2Fnode_contextify.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.cc?ref=3bf34f27a1b231eec12ec999ca0f5d59bce9da14",
            "patch": "@@ -22,8 +22,10 @@\n #include \"node_internals.h\"\n #include \"node_watchdog.h\"\n #include \"base_object-inl.h\"\n+#include \"node_contextify.h\"\n \n namespace node {\n+namespace contextify {\n \n using v8::Array;\n using v8::ArrayBuffer;\n@@ -90,519 +92,499 @@ Local<Name> Uint32ToName(Local<Context> context, uint32_t index) {\n       .ToLocalChecked();\n }\n \n-class ContextifyContext {\n- protected:\n-  // V8 reserves the first field in context objects for the debugger. We use the\n-  // second field to hold a reference to the sandbox object.\n-  enum { kSandboxObjectIndex = 1 };\n-\n-  Environment* const env_;\n-  Persistent<Context> context_;\n-\n- public:\n-  ContextifyContext(Environment* env,\n-                    Local<Object> sandbox_obj,\n-                    Local<Object> options_obj)\n-      : env_(env) {\n-    Local<Context> v8_context = CreateV8Context(env, sandbox_obj, options_obj);\n-    context_.Reset(env->isolate(), v8_context);\n-\n-    // Allocation failure or maximum call stack size reached\n-    if (context_.IsEmpty())\n-      return;\n-    context_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);\n-    context_.MarkIndependent();\n-  }\n-\n-\n-  ~ContextifyContext() {\n-    context_.Reset();\n-  }\n-\n+}  // anonymous namespace\n \n-  inline Environment* env() const {\n-    return env_;\n-  }\n+ContextifyContext::ContextifyContext(\n+    Environment* env,\n+    Local<Object> sandbox_obj, Local<Object> options_obj) : env_(env) {\n+  Local<Context> v8_context = CreateV8Context(env, sandbox_obj, options_obj);\n+  context_.Reset(env->isolate(), v8_context);\n+\n+  // Allocation failure or maximum call stack size reached\n+  if (context_.IsEmpty())\n+    return;\n+  context_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);\n+  context_.MarkIndependent();\n+}\n \n \n-  inline Local<Context> context() const {\n-    return PersistentToLocal(env()->isolate(), context_);\n-  }\n+ContextifyContext::~ContextifyContext() {\n+  context_.Reset();\n+}\n \n \n-  inline Local<Object> global_proxy() const {\n-    return context()->Global();\n-  }\n+// This is an object that just keeps an internal pointer to this\n+// ContextifyContext.  It's passed to the NamedPropertyHandler.  If we\n+// pass the main JavaScript context object we're embedded in, then the\n+// NamedPropertyHandler will store a reference to it forever and keep it\n+// from getting gc'd.\n+Local<Value> ContextifyContext::CreateDataWrapper(Environment* env) {\n+  EscapableHandleScope scope(env->isolate());\n+  Local<Object> wrapper =\n+      env->script_data_constructor_function()\n+          ->NewInstance(env->context()).FromMaybe(Local<Object>());\n+  if (wrapper.IsEmpty())\n+    return scope.Escape(Local<Value>::New(env->isolate(), Local<Value>()));\n+\n+  Wrap(wrapper, this);\n+  return scope.Escape(wrapper);\n+}\n \n \n-  inline Local<Object> sandbox() const {\n-    return Local<Object>::Cast(context()->GetEmbedderData(kSandboxObjectIndex));\n+Local<Context> ContextifyContext::CreateV8Context(\n+    Environment* env,\n+    Local<Object> sandbox_obj,\n+    Local<Object> options_obj) {\n+  EscapableHandleScope scope(env->isolate());\n+  Local<FunctionTemplate> function_template =\n+      FunctionTemplate::New(env->isolate());\n+\n+  function_template->SetClassName(sandbox_obj->GetConstructorName());\n+\n+  Local<ObjectTemplate> object_template =\n+      function_template->InstanceTemplate();\n+\n+  NamedPropertyHandlerConfiguration config(PropertyGetterCallback,\n+                                           PropertySetterCallback,\n+                                           PropertyDescriptorCallback,\n+                                           PropertyDeleterCallback,\n+                                           PropertyEnumeratorCallback,\n+                                           PropertyDefinerCallback,\n+                                           CreateDataWrapper(env));\n+\n+  IndexedPropertyHandlerConfiguration indexed_config(\n+      IndexedPropertyGetterCallback,\n+      IndexedPropertySetterCallback,\n+      IndexedPropertyDescriptorCallback,\n+      IndexedPropertyDeleterCallback,\n+      PropertyEnumeratorCallback,\n+      IndexedPropertyDefinerCallback,\n+      CreateDataWrapper(env));\n+\n+  object_template->SetHandler(config);\n+  object_template->SetHandler(indexed_config);\n+\n+  Local<Context> ctx = NewContext(env->isolate(), object_template);\n+\n+  if (ctx.IsEmpty()) {\n+    env->ThrowError(\"Could not instantiate context\");\n+    return Local<Context>();\n   }\n \n-  // This is an object that just keeps an internal pointer to this\n-  // ContextifyContext.  It's passed to the NamedPropertyHandler.  If we\n-  // pass the main JavaScript context object we're embedded in, then the\n-  // NamedPropertyHandler will store a reference to it forever and keep it\n-  // from getting gc'd.\n-  Local<Value> CreateDataWrapper(Environment* env) {\n-    EscapableHandleScope scope(env->isolate());\n-    Local<Object> wrapper =\n-        env->script_data_constructor_function()\n-            ->NewInstance(env->context()).FromMaybe(Local<Object>());\n-    if (wrapper.IsEmpty())\n-      return scope.Escape(Local<Value>::New(env->isolate(), Local<Value>()));\n-\n-    Wrap(wrapper, this);\n-    return scope.Escape(wrapper);\n+  ctx->SetSecurityToken(env->context()->GetSecurityToken());\n+\n+  // We need to tie the lifetime of the sandbox object with the lifetime of\n+  // newly created context. We do this by making them hold references to each\n+  // other. The context can directly hold a reference to the sandbox as an\n+  // embedder data field. However, we cannot hold a reference to a v8::Context\n+  // directly in an Object, we instead hold onto the new context's global\n+  // object instead (which then has a reference to the context).\n+  ctx->SetEmbedderData(kSandboxObjectIndex, sandbox_obj);\n+  sandbox_obj->SetPrivate(env->context(),\n+                          env->contextify_global_private_symbol(),\n+                          ctx->Global());\n+\n+  Local<Value> name =\n+      options_obj->Get(env->context(), env->name_string())\n+          .ToLocalChecked();\n+  CHECK(name->IsString());\n+  Utf8Value name_val(env->isolate(), name);\n+\n+  ContextInfo info(*name_val);\n+\n+  Local<Value> origin =\n+      options_obj->Get(env->context(),\n+                       FIXED_ONE_BYTE_STRING(env->isolate(), \"origin\"))\n+          .ToLocalChecked();\n+  if (!origin->IsUndefined()) {\n+    CHECK(origin->IsString());\n+    Utf8Value origin_val(env->isolate(), origin);\n+    info.origin = *origin_val;\n   }\n \n+  env->AssignToContext(ctx, info);\n \n-  Local<Context> CreateV8Context(Environment* env,\n-                                 Local<Object> sandbox_obj,\n-                                 Local<Object> options_obj) {\n-    EscapableHandleScope scope(env->isolate());\n-    Local<FunctionTemplate> function_template =\n-        FunctionTemplate::New(env->isolate());\n-\n-    function_template->SetClassName(sandbox_obj->GetConstructorName());\n-\n-    Local<ObjectTemplate> object_template =\n-        function_template->InstanceTemplate();\n-\n-    NamedPropertyHandlerConfiguration config(PropertyGetterCallback,\n-                                             PropertySetterCallback,\n-                                             PropertyDescriptorCallback,\n-                                             PropertyDeleterCallback,\n-                                             PropertyEnumeratorCallback,\n-                                             PropertyDefinerCallback,\n-                                             CreateDataWrapper(env));\n-\n-    IndexedPropertyHandlerConfiguration indexed_config(\n-        IndexedPropertyGetterCallback,\n-        IndexedPropertySetterCallback,\n-        IndexedPropertyDescriptorCallback,\n-        IndexedPropertyDeleterCallback,\n-        PropertyEnumeratorCallback,\n-        IndexedPropertyDefinerCallback,\n-        CreateDataWrapper(env));\n-\n-    object_template->SetHandler(config);\n-    object_template->SetHandler(indexed_config);\n-\n-    Local<Context> ctx = NewContext(env->isolate(), object_template);\n-\n-    if (ctx.IsEmpty()) {\n-      env->ThrowError(\"Could not instantiate context\");\n-      return Local<Context>();\n-    }\n+  return scope.Escape(ctx);\n+}\n \n-    ctx->SetSecurityToken(env->context()->GetSecurityToken());\n-\n-    // We need to tie the lifetime of the sandbox object with the lifetime of\n-    // newly created context. We do this by making them hold references to each\n-    // other. The context can directly hold a reference to the sandbox as an\n-    // embedder data field. However, we cannot hold a reference to a v8::Context\n-    // directly in an Object, we instead hold onto the new context's global\n-    // object instead (which then has a reference to the context).\n-    ctx->SetEmbedderData(kSandboxObjectIndex, sandbox_obj);\n-    sandbox_obj->SetPrivate(env->context(),\n-                            env->contextify_global_private_symbol(),\n-                            ctx->Global());\n-\n-    Local<Value> name =\n-        options_obj->Get(env->context(), env->name_string())\n-            .ToLocalChecked();\n-    CHECK(name->IsString());\n-    Utf8Value name_val(env->isolate(), name);\n-\n-    ContextInfo info(*name_val);\n-\n-    Local<Value> origin =\n-        options_obj->Get(env->context(),\n-                         FIXED_ONE_BYTE_STRING(env->isolate(), \"origin\"))\n-            .ToLocalChecked();\n-    if (!origin->IsUndefined()) {\n-      CHECK(origin->IsString());\n-      Utf8Value origin_val(env->isolate(), origin);\n-      info.origin = *origin_val;\n-    }\n \n-    env->AssignToContext(ctx, info);\n+void ContextifyContext::Init(Environment* env, Local<Object> target) {\n+  Local<FunctionTemplate> function_template =\n+      FunctionTemplate::New(env->isolate());\n+  function_template->InstanceTemplate()->SetInternalFieldCount(1);\n+  env->set_script_data_constructor_function(function_template->GetFunction());\n \n-    return scope.Escape(ctx);\n-  }\n+  env->SetMethod(target, \"makeContext\", MakeContext);\n+  env->SetMethod(target, \"isContext\", IsContext);\n+}\n \n \n-  static void Init(Environment* env, Local<Object> target) {\n-    Local<FunctionTemplate> function_template =\n-        FunctionTemplate::New(env->isolate());\n-    function_template->InstanceTemplate()->SetInternalFieldCount(1);\n-    env->set_script_data_constructor_function(function_template->GetFunction());\n+void ContextifyContext::MakeContext(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n \n-    env->SetMethod(target, \"makeContext\", MakeContext);\n-    env->SetMethod(target, \"isContext\", IsContext);\n+  if (!args[0]->IsObject()) {\n+    return env->ThrowTypeError(\"sandbox argument must be an object.\");\n   }\n+  Local<Object> sandbox = args[0].As<Object>();\n \n+  // Don't allow contextifying a sandbox multiple times.\n+  CHECK(\n+      !sandbox->HasPrivate(\n+          env->context(),\n+          env->contextify_context_private_symbol()).FromJust());\n \n-  static void MakeContext(const FunctionCallbackInfo<Value>& args) {\n-    Environment* env = Environment::GetCurrent(args);\n+  Local<Object> options = args[1].As<Object>();\n+  CHECK(options->IsObject());\n \n-    if (!args[0]->IsObject()) {\n-      return env->ThrowTypeError(\"sandbox argument must be an object.\");\n-    }\n-    Local<Object> sandbox = args[0].As<Object>();\n+  TryCatch try_catch(env->isolate());\n+  ContextifyContext* context = new ContextifyContext(env, sandbox, options);\n \n-    // Don't allow contextifying a sandbox multiple times.\n-    CHECK(\n-        !sandbox->HasPrivate(\n-            env->context(),\n-            env->contextify_context_private_symbol()).FromJust());\n+  if (try_catch.HasCaught()) {\n+    try_catch.ReThrow();\n+    return;\n+  }\n \n-    Local<Object> options = args[1].As<Object>();\n-    CHECK(options->IsObject());\n+  if (context->context().IsEmpty())\n+    return;\n \n-    TryCatch try_catch(env->isolate());\n-    ContextifyContext* context = new ContextifyContext(env, sandbox, options);\n+  sandbox->SetPrivate(\n+      env->context(),\n+      env->contextify_context_private_symbol(),\n+      External::New(env->isolate(), context));\n+}\n \n-    if (try_catch.HasCaught()) {\n-      try_catch.ReThrow();\n-      return;\n-    }\n \n-    if (context->context().IsEmpty())\n-      return;\n+void ContextifyContext::IsContext(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n \n-    sandbox->SetPrivate(\n-        env->context(),\n-        env->contextify_context_private_symbol(),\n-        External::New(env->isolate(), context));\n+  if (!args[0]->IsObject()) {\n+    env->ThrowTypeError(\"sandbox must be an object\");\n+    return;\n   }\n+  Local<Object> sandbox = args[0].As<Object>();\n \n+  Maybe<bool> result =\n+      sandbox->HasPrivate(env->context(),\n+                          env->contextify_context_private_symbol());\n+  args.GetReturnValue().Set(result.FromJust());\n+}\n \n-  static void IsContext(const FunctionCallbackInfo<Value>& args) {\n-    Environment* env = Environment::GetCurrent(args);\n \n-    if (!args[0]->IsObject()) {\n-      env->ThrowTypeError(\"sandbox must be an object\");\n-      return;\n-    }\n-    Local<Object> sandbox = args[0].As<Object>();\n+void ContextifyContext::WeakCallback(\n+    const WeakCallbackInfo<ContextifyContext>& data) {\n+  ContextifyContext* context = data.GetParameter();\n+  delete context;\n+}\n \n-    Maybe<bool> result =\n-        sandbox->HasPrivate(env->context(),\n-                            env->contextify_context_private_symbol());\n-    args.GetReturnValue().Set(result.FromJust());\n+// static\n+ContextifyContext* ContextifyContext::ContextFromContextifiedSandbox(\n+    Environment* env,\n+    const Local<Object>& sandbox) {\n+  MaybeLocal<Value> maybe_value =\n+      sandbox->GetPrivate(env->context(),\n+                          env->contextify_context_private_symbol());\n+  Local<Value> context_external_v;\n+  if (maybe_value.ToLocal(&context_external_v) &&\n+      context_external_v->IsExternal()) {\n+    Local<External> context_external = context_external_v.As<External>();\n+    return static_cast<ContextifyContext*>(context_external->Value());\n   }\n+  return nullptr;\n+}\n \n-\n-  static void WeakCallback(const WeakCallbackInfo<ContextifyContext>& data) {\n-    ContextifyContext* context = data.GetParameter();\n-    delete context;\n+// static\n+void ContextifyContext::PropertyGetterCallback(\n+    Local<Name> property,\n+    const PropertyCallbackInfo<Value>& args) {\n+  ContextifyContext* ctx;\n+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n+\n+  // Still initializing\n+  if (ctx->context_.IsEmpty())\n+    return;\n+\n+  Local<Context> context = ctx->context();\n+  Local<Object> sandbox = ctx->sandbox();\n+  MaybeLocal<Value> maybe_rv =\n+      sandbox->GetRealNamedProperty(context, property);\n+  if (maybe_rv.IsEmpty()) {\n+    maybe_rv =\n+        ctx->global_proxy()->GetRealNamedProperty(context, property);\n   }\n \n+  Local<Value> rv;\n+  if (maybe_rv.ToLocal(&rv)) {\n+    if (rv == sandbox)\n+      rv = ctx->global_proxy();\n \n-  static ContextifyContext* ContextFromContextifiedSandbox(\n-      Environment* env,\n-      const Local<Object>& sandbox) {\n-    MaybeLocal<Value> maybe_value =\n-        sandbox->GetPrivate(env->context(),\n-                            env->contextify_context_private_symbol());\n-    Local<Value> context_external_v;\n-    if (maybe_value.ToLocal(&context_external_v) &&\n-        context_external_v->IsExternal()) {\n-      Local<External> context_external = context_external_v.As<External>();\n-      return static_cast<ContextifyContext*>(context_external->Value());\n-    }\n-    return nullptr;\n+    args.GetReturnValue().Set(rv);\n   }\n+}\n \n-\n-  static void PropertyGetterCallback(\n-      Local<Name> property,\n-      const PropertyCallbackInfo<Value>& args) {\n-    ContextifyContext* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n-\n-    // Still initializing\n-    if (ctx->context_.IsEmpty())\n-      return;\n-\n-    Local<Context> context = ctx->context();\n-    Local<Object> sandbox = ctx->sandbox();\n-    MaybeLocal<Value> maybe_rv =\n-        sandbox->GetRealNamedProperty(context, property);\n-    if (maybe_rv.IsEmpty()) {\n-      maybe_rv =\n-          ctx->global_proxy()->GetRealNamedProperty(context, property);\n-    }\n-\n-    Local<Value> rv;\n-    if (maybe_rv.ToLocal(&rv)) {\n-      if (rv == sandbox)\n-        rv = ctx->global_proxy();\n-\n-      args.GetReturnValue().Set(rv);\n-    }\n-  }\n-\n-\n-  static void PropertySetterCallback(\n-      Local<Name> property,\n-      Local<Value> value,\n-      const PropertyCallbackInfo<Value>& args) {\n-    ContextifyContext* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n-\n-    // Still initializing\n-    if (ctx->context_.IsEmpty())\n-      return;\n-\n-    auto attributes = PropertyAttribute::None;\n-    bool is_declared_on_global_proxy = ctx->global_proxy()\n-        ->GetRealNamedPropertyAttributes(ctx->context(), property)\n-        .To(&attributes);\n-    bool read_only =\n-        static_cast<int>(attributes) &\n-        static_cast<int>(PropertyAttribute::ReadOnly);\n-\n-    bool is_declared_on_sandbox = ctx->sandbox()\n-        ->GetRealNamedPropertyAttributes(ctx->context(), property)\n-        .To(&attributes);\n-    read_only = read_only ||\n-        (static_cast<int>(attributes) &\n-        static_cast<int>(PropertyAttribute::ReadOnly));\n-\n-    if (read_only)\n-      return;\n-\n-    // true for x = 5\n-    // false for this.x = 5\n-    // false for Object.defineProperty(this, 'foo', ...)\n-    // false for vmResult.x = 5 where vmResult = vm.runInContext();\n-    bool is_contextual_store = ctx->global_proxy() != args.This();\n-\n-    // Indicator to not return before setting (undeclared) function declarations\n-    // on the sandbox in strict mode, i.e. args.ShouldThrowOnError() = true.\n-    // True for 'function f() {}', 'this.f = function() {}',\n-    // 'var f = function()'.\n-    // In effect only for 'function f() {}' because\n-    // var f = function(), is_declared = true\n-    // this.f = function() {}, is_contextual_store = false.\n-    bool is_function = value->IsFunction();\n-\n-    bool is_declared = is_declared_on_global_proxy || is_declared_on_sandbox;\n-    if (!is_declared && args.ShouldThrowOnError() && is_contextual_store &&\n-        !is_function)\n-      return;\n-\n-    if (!is_declared_on_global_proxy && is_declared_on_sandbox  &&\n-        args.ShouldThrowOnError() && is_contextual_store && !is_function) {\n-      // The property exists on the sandbox but not on the global\n-      // proxy. Setting it would throw because we are in strict mode.\n-      // Don't attempt to set it by signaling that the call was\n-      // intercepted. Only change the value on the sandbox.\n-      args.GetReturnValue().Set(false);\n-    }\n-\n-    ctx->sandbox()->Set(property, value);\n+// static\n+void ContextifyContext::PropertySetterCallback(\n+    Local<Name> property,\n+    Local<Value> value,\n+    const PropertyCallbackInfo<Value>& args) {\n+  ContextifyContext* ctx;\n+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n+\n+  // Still initializing\n+  if (ctx->context_.IsEmpty())\n+    return;\n+\n+  auto attributes = PropertyAttribute::None;\n+  bool is_declared_on_global_proxy = ctx->global_proxy()\n+      ->GetRealNamedPropertyAttributes(ctx->context(), property)\n+      .To(&attributes);\n+  bool read_only =\n+      static_cast<int>(attributes) &\n+      static_cast<int>(PropertyAttribute::ReadOnly);\n+\n+  bool is_declared_on_sandbox = ctx->sandbox()\n+      ->GetRealNamedPropertyAttributes(ctx->context(), property)\n+      .To(&attributes);\n+  read_only = read_only ||\n+      (static_cast<int>(attributes) &\n+      static_cast<int>(PropertyAttribute::ReadOnly));\n+\n+  if (read_only)\n+    return;\n+\n+  // true for x = 5\n+  // false for this.x = 5\n+  // false for Object.defineProperty(this, 'foo', ...)\n+  // false for vmResult.x = 5 where vmResult = vm.runInContext();\n+  bool is_contextual_store = ctx->global_proxy() != args.This();\n+\n+  // Indicator to not return before setting (undeclared) function declarations\n+  // on the sandbox in strict mode, i.e. args.ShouldThrowOnError() = true.\n+  // True for 'function f() {}', 'this.f = function() {}',\n+  // 'var f = function()'.\n+  // In effect only for 'function f() {}' because\n+  // var f = function(), is_declared = true\n+  // this.f = function() {}, is_contextual_store = false.\n+  bool is_function = value->IsFunction();\n+\n+  bool is_declared = is_declared_on_global_proxy || is_declared_on_sandbox;\n+  if (!is_declared && args.ShouldThrowOnError() && is_contextual_store &&\n+      !is_function)\n+    return;\n+\n+  if (!is_declared_on_global_proxy && is_declared_on_sandbox  &&\n+      args.ShouldThrowOnError() && is_contextual_store && !is_function) {\n+    // The property exists on the sandbox but not on the global\n+    // proxy. Setting it would throw because we are in strict mode.\n+    // Don't attempt to set it by signaling that the call was\n+    // intercepted. Only change the value on the sandbox.\n+    args.GetReturnValue().Set(false);\n   }\n \n+  ctx->sandbox()->Set(property, value);\n+}\n \n-  static void PropertyDescriptorCallback(\n-      Local<Name> property,\n-      const PropertyCallbackInfo<Value>& args) {\n-    ContextifyContext* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n+// static\n+void ContextifyContext::PropertyDescriptorCallback(\n+    Local<Name> property,\n+    const PropertyCallbackInfo<Value>& args) {\n+  ContextifyContext* ctx;\n+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n \n-    // Still initializing\n-    if (ctx->context_.IsEmpty())\n-      return;\n+  // Still initializing\n+  if (ctx->context_.IsEmpty())\n+    return;\n \n-    Local<Context> context = ctx->context();\n+  Local<Context> context = ctx->context();\n \n-    Local<Object> sandbox = ctx->sandbox();\n+  Local<Object> sandbox = ctx->sandbox();\n \n-    if (sandbox->HasOwnProperty(context, property).FromMaybe(false)) {\n-      args.GetReturnValue().Set(\n-          sandbox->GetOwnPropertyDescriptor(context, property)\n-              .ToLocalChecked());\n-    }\n+  if (sandbox->HasOwnProperty(context, property).FromMaybe(false)) {\n+    args.GetReturnValue().Set(\n+        sandbox->GetOwnPropertyDescriptor(context, property)\n+            .ToLocalChecked());\n   }\n+}\n \n-\n-  static void PropertyDefinerCallback(\n-      Local<Name> property,\n-      const PropertyDescriptor& desc,\n-      const PropertyCallbackInfo<Value>& args) {\n-    ContextifyContext* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n-\n-    // Still initializing\n-    if (ctx->context_.IsEmpty())\n-      return;\n-\n-    Local<Context> context = ctx->context();\n-    v8::Isolate* isolate = context->GetIsolate();\n-\n-    auto attributes = PropertyAttribute::None;\n-    bool is_declared =\n-        ctx->global_proxy()->GetRealNamedPropertyAttributes(ctx->context(),\n-                                                            property)\n-            .To(&attributes);\n-    bool read_only =\n-        static_cast<int>(attributes) &\n-            static_cast<int>(PropertyAttribute::ReadOnly);\n-\n-    // If the property is set on the global as read_only, don't change it on\n-    // the global or sandbox.\n-    if (is_declared && read_only)\n-      return;\n-\n-    Local<Object> sandbox = ctx->sandbox();\n-\n-    auto define_prop_on_sandbox =\n-        [&] (PropertyDescriptor* desc_for_sandbox) {\n-          if (desc.has_enumerable()) {\n-            desc_for_sandbox->set_enumerable(desc.enumerable());\n-          }\n-          if (desc.has_configurable()) {\n-            desc_for_sandbox->set_configurable(desc.configurable());\n-          }\n-          // Set the property on the sandbox.\n-          sandbox->DefineProperty(context, property, *desc_for_sandbox)\n-              .FromJust();\n-        };\n-\n-    if (desc.has_get() || desc.has_set()) {\n-      PropertyDescriptor desc_for_sandbox(\n-          desc.has_get() ? desc.get() : v8::Undefined(isolate).As<Value>(),\n-          desc.has_set() ? desc.set() : v8::Undefined(isolate).As<Value>());\n-\n+// static\n+void ContextifyContext::PropertyDefinerCallback(\n+    Local<Name> property,\n+    const PropertyDescriptor& desc,\n+    const PropertyCallbackInfo<Value>& args) {\n+  ContextifyContext* ctx;\n+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n+\n+  // Still initializing\n+  if (ctx->context_.IsEmpty())\n+    return;\n+\n+  Local<Context> context = ctx->context();\n+  v8::Isolate* isolate = context->GetIsolate();\n+\n+  auto attributes = PropertyAttribute::None;\n+  bool is_declared =\n+      ctx->global_proxy()->GetRealNamedPropertyAttributes(ctx->context(),\n+                                                          property)\n+          .To(&attributes);\n+  bool read_only =\n+      static_cast<int>(attributes) &\n+          static_cast<int>(PropertyAttribute::ReadOnly);\n+\n+  // If the property is set on the global as read_only, don't change it on\n+  // the global or sandbox.\n+  if (is_declared && read_only)\n+    return;\n+\n+  Local<Object> sandbox = ctx->sandbox();\n+\n+  auto define_prop_on_sandbox =\n+      [&] (PropertyDescriptor* desc_for_sandbox) {\n+        if (desc.has_enumerable()) {\n+          desc_for_sandbox->set_enumerable(desc.enumerable());\n+        }\n+        if (desc.has_configurable()) {\n+          desc_for_sandbox->set_configurable(desc.configurable());\n+        }\n+        // Set the property on the sandbox.\n+        sandbox->DefineProperty(context, property, *desc_for_sandbox)\n+            .FromJust();\n+      };\n+\n+  if (desc.has_get() || desc.has_set()) {\n+    PropertyDescriptor desc_for_sandbox(\n+        desc.has_get() ? desc.get() : v8::Undefined(isolate).As<Value>(),\n+        desc.has_set() ? desc.set() : v8::Undefined(isolate).As<Value>());\n+\n+    define_prop_on_sandbox(&desc_for_sandbox);\n+  } else {\n+    Local<Value> value =\n+        desc.has_value() ? desc.value() : v8::Undefined(isolate).As<Value>();\n+\n+    if (desc.has_writable()) {\n+      PropertyDescriptor desc_for_sandbox(value, desc.writable());\n       define_prop_on_sandbox(&desc_for_sandbox);\n     } else {\n-      Local<Value> value =\n-          desc.has_value() ? desc.value() : v8::Undefined(isolate).As<Value>();\n-\n-      if (desc.has_writable()) {\n-        PropertyDescriptor desc_for_sandbox(value, desc.writable());\n-        define_prop_on_sandbox(&desc_for_sandbox);\n-      } else {\n-        PropertyDescriptor desc_for_sandbox(value);\n-        define_prop_on_sandbox(&desc_for_sandbox);\n-      }\n+      PropertyDescriptor desc_for_sandbox(value);\n+      define_prop_on_sandbox(&desc_for_sandbox);\n     }\n   }\n+}\n \n-  static void PropertyDeleterCallback(\n-      Local<Name> property,\n-      const PropertyCallbackInfo<Boolean>& args) {\n-    ContextifyContext* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n-\n-    // Still initializing\n-    if (ctx->context_.IsEmpty())\n-      return;\n+// static\n+void ContextifyContext::PropertyDeleterCallback(\n+    Local<Name> property,\n+    const PropertyCallbackInfo<Boolean>& args) {\n+  ContextifyContext* ctx;\n+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n \n-    Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), property);\n+  // Still initializing\n+  if (ctx->context_.IsEmpty())\n+    return;\n \n-    if (success.FromMaybe(false))\n-      return;\n+  Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), property);\n \n-    // Delete failed on the sandbox, intercept and do not delete on\n-    // the global object.\n-    args.GetReturnValue().Set(false);\n-  }\n+  if (success.FromMaybe(false))\n+    return;\n \n+  // Delete failed on the sandbox, intercept and do not delete on\n+  // the global object.\n+  args.GetReturnValue().Set(false);\n+}\n \n-  static void PropertyEnumeratorCallback(\n-      const PropertyCallbackInfo<Array>& args) {\n-    ContextifyContext* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n+// static\n+void ContextifyContext::PropertyEnumeratorCallback(\n+    const PropertyCallbackInfo<Array>& args) {\n+  ContextifyContext* ctx;\n+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n \n-    // Still initializing\n-    if (ctx->context_.IsEmpty())\n-      return;\n+  // Still initializing\n+  if (ctx->context_.IsEmpty())\n+    return;\n \n-    args.GetReturnValue().Set(ctx->sandbox()->GetPropertyNames());\n-  }\n-\n-  static void IndexedPropertyGetterCallback(\n-      uint32_t index,\n-      const PropertyCallbackInfo<Value>& args) {\n-    ContextifyContext* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n+  args.GetReturnValue().Set(ctx->sandbox()->GetPropertyNames());\n+}\n \n-    // Still initializing\n-    if (ctx->context_.IsEmpty())\n-      return;\n+// static\n+void ContextifyContext::IndexedPropertyGetterCallback(\n+    uint32_t index,\n+    const PropertyCallbackInfo<Value>& args) {\n+  ContextifyContext* ctx;\n+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n \n-    PropertyGetterCallback(Uint32ToName(ctx->context(), index), args);\n-  }\n+  // Still initializing\n+  if (ctx->context_.IsEmpty())\n+    return;\n \n+  ContextifyContext::PropertyGetterCallback(\n+      Uint32ToName(ctx->context(), index), args);\n+}\n \n-  static void IndexedPropertySetterCallback(\n-      uint32_t index,\n-      Local<Value> value,\n-      const PropertyCallbackInfo<Value>& args) {\n-    ContextifyContext* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n \n-    // Still initializing\n-    if (ctx->context_.IsEmpty())\n-      return;\n+void ContextifyContext::IndexedPropertySetterCallback(\n+    uint32_t index,\n+    Local<Value> value,\n+    const PropertyCallbackInfo<Value>& args) {\n+  ContextifyContext* ctx;\n+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n \n-    PropertySetterCallback(Uint32ToName(ctx->context(), index), value, args);\n-  }\n+  // Still initializing\n+  if (ctx->context_.IsEmpty())\n+    return;\n \n+  ContextifyContext::PropertySetterCallback(\n+      Uint32ToName(ctx->context(), index), value, args);\n+}\n \n-  static void IndexedPropertyDescriptorCallback(\n-      uint32_t index,\n-      const PropertyCallbackInfo<Value>& args) {\n-    ContextifyContext* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n+// static\n+void ContextifyContext::IndexedPropertyDescriptorCallback(\n+    uint32_t index,\n+    const PropertyCallbackInfo<Value>& args) {\n+  ContextifyContext* ctx;\n+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n \n-    // Still initializing\n-    if (ctx->context_.IsEmpty())\n-      return;\n+  // Still initializing\n+  if (ctx->context_.IsEmpty())\n+    return;\n \n-    PropertyDescriptorCallback(Uint32ToName(ctx->context(), index), args);\n-  }\n+  ContextifyContext::PropertyDescriptorCallback(\n+      Uint32ToName(ctx->context(), index), args);\n+}\n \n \n-  static void IndexedPropertyDefinerCallback(\n-      uint32_t index,\n-      const PropertyDescriptor& desc,\n-      const PropertyCallbackInfo<Value>& args) {\n-    ContextifyContext* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n+void ContextifyContext::IndexedPropertyDefinerCallback(\n+    uint32_t index,\n+    const PropertyDescriptor& desc,\n+    const PropertyCallbackInfo<Value>& args) {\n+  ContextifyContext* ctx;\n+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n \n-    // Still initializing\n-    if (ctx->context_.IsEmpty())\n-      return;\n+  // Still initializing\n+  if (ctx->context_.IsEmpty())\n+    return;\n \n-    PropertyDefinerCallback(Uint32ToName(ctx->context(), index), desc, args);\n-  }\n+  ContextifyContext::PropertyDefinerCallback(\n+      Uint32ToName(ctx->context(), index), desc, args);\n+}\n \n-  static void IndexedPropertyDeleterCallback(\n-      uint32_t index,\n-      const PropertyCallbackInfo<Boolean>& args) {\n-    ContextifyContext* ctx;\n-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n+// static\n+void ContextifyContext::IndexedPropertyDeleterCallback(\n+    uint32_t index,\n+    const PropertyCallbackInfo<Boolean>& args) {\n+  ContextifyContext* ctx;\n+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Data().As<Object>());\n \n-    // Still initializing\n-    if (ctx->context_.IsEmpty())\n-      return;\n+  // Still initializing\n+  if (ctx->context_.IsEmpty())\n+    return;\n \n-    Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), index);\n+  Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), index);\n \n-    if (success.FromMaybe(false))\n-      return;\n+  if (success.FromMaybe(false))\n+    return;\n \n-    // Delete failed on the sandbox, intercept and do not delete on\n-    // the global object.\n-    args.GetReturnValue().Set(false);\n-  }\n-};\n+  // Delete failed on the sandbox, intercept and do not delete on\n+  // the global object.\n+  args.GetReturnValue().Set(false);\n+}\n \n class ContextifyScript : public BaseObject {\n  private:\n@@ -1161,7 +1143,7 @@ void InitContextify(Local<Object> target,\n   ContextifyScript::Init(env, target);\n }\n \n-}  // anonymous namespace\n+}  // namespace contextify\n }  // namespace node\n \n-NODE_BUILTIN_MODULE_CONTEXT_AWARE(contextify, node::InitContextify)\n+NODE_BUILTIN_MODULE_CONTEXT_AWARE(contextify, node::contextify::InitContextify)"
        },
        {
            "sha": "e8a54e1667cc3193e96daf20e4c4077082698baf",
            "filename": "src/node_contextify.h",
            "status": "added",
            "additions": 98,
            "deletions": 0,
            "changes": 98,
            "blob_url": "https://github.com/nodejs/node/blob/3bf34f27a1b231eec12ec999ca0f5d59bce9da14/src%2Fnode_contextify.h",
            "raw_url": "https://github.com/nodejs/node/raw/3bf34f27a1b231eec12ec999ca0f5d59bce9da14/src%2Fnode_contextify.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.h?ref=3bf34f27a1b231eec12ec999ca0f5d59bce9da14",
            "patch": "@@ -0,0 +1,98 @@\n+#ifndef SRC_NODE_CONTEXTIFY_H_\n+#define SRC_NODE_CONTEXTIFY_H_\n+\n+#include \"node_internals.h\"\n+#include \"node_watchdog.h\"\n+#include \"base_object-inl.h\"\n+\n+namespace node {\n+namespace contextify {\n+\n+class ContextifyContext {\n+ protected:\n+  // V8 reserves the first field in context objects for the debugger. We use the\n+  // second field to hold a reference to the sandbox object.\n+  enum { kSandboxObjectIndex = 1 };\n+\n+  Environment* const env_;\n+  v8::Persistent<v8::Context> context_;\n+\n+ public:\n+  ContextifyContext(Environment* env,\n+                    v8::Local<v8::Object> sandbox_obj,\n+                    v8::Local<v8::Object> options_obj);\n+  ~ContextifyContext();\n+\n+  v8::Local<v8::Value> CreateDataWrapper(Environment* env);\n+  v8::Local<v8::Context> CreateV8Context(Environment* env,\n+      v8::Local<v8::Object> sandbox_obj, v8::Local<v8::Object> options_obj);\n+  static void Init(Environment* env, v8::Local<v8::Object> target);\n+\n+  static ContextifyContext* ContextFromContextifiedSandbox(\n+      Environment* env,\n+      const v8::Local<v8::Object>& sandbox);\n+\n+  inline Environment* env() const {\n+    return env_;\n+  }\n+\n+  inline v8::Local<v8::Context> context() const {\n+    return PersistentToLocal(env()->isolate(), context_);\n+  }\n+\n+  inline v8::Local<v8::Object> global_proxy() const {\n+    return context()->Global();\n+  }\n+\n+  inline v8::Local<v8::Object> sandbox() const {\n+    return v8::Local<v8::Object>::Cast(\n+        context()->GetEmbedderData(kSandboxObjectIndex));\n+  }\n+\n+ private:\n+  static void MakeContext(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void IsContext(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void WeakCallback(\n+      const v8::WeakCallbackInfo<ContextifyContext>& data);\n+  static void PropertyGetterCallback(\n+      v8::Local<v8::Name> property,\n+      const v8::PropertyCallbackInfo<v8::Value>& args);\n+  static void PropertySetterCallback(\n+      v8::Local<v8::Name> property,\n+      v8::Local<v8::Value> value,\n+      const v8::PropertyCallbackInfo<v8::Value>& args);\n+  static void PropertyDescriptorCallback(\n+      v8::Local<v8::Name> property,\n+      const v8::PropertyCallbackInfo<v8::Value>& args);\n+  static void PropertyDefinerCallback(\n+      v8::Local<v8::Name> property,\n+      const v8::PropertyDescriptor& desc,\n+      const v8::PropertyCallbackInfo<v8::Value>& args);\n+  static void PropertyDeleterCallback(\n+      v8::Local<v8::Name> property,\n+      const v8::PropertyCallbackInfo<v8::Boolean>& args);\n+  static void PropertyEnumeratorCallback(\n+      const v8::PropertyCallbackInfo<v8::Array>& args);\n+  static void IndexedPropertyGetterCallback(\n+      uint32_t index,\n+      const v8::PropertyCallbackInfo<v8::Value>& args);\n+  static void IndexedPropertySetterCallback(\n+      uint32_t index,\n+      v8::Local<v8::Value> value,\n+      const v8::PropertyCallbackInfo<v8::Value>& args);\n+  static void IndexedPropertyDescriptorCallback(\n+      uint32_t index,\n+      const v8::PropertyCallbackInfo<v8::Value>& args);\n+  static void IndexedPropertyDefinerCallback(\n+      uint32_t index,\n+      const v8::PropertyDescriptor& desc,\n+      const v8::PropertyCallbackInfo<v8::Value>& args);\n+  static void IndexedPropertyDeleterCallback(\n+      uint32_t index,\n+      const v8::PropertyCallbackInfo<v8::Boolean>& args);\n+};\n+\n+}  // namespace contextify\n+}  // namespace node\n+\n+#endif  // SRC_NODE_CONTEXTIFY_H_"
        }
    ],
    "stats": {
        "total": 951,
        "additions": 516,
        "deletions": 435
    }
}