{
    "author": "oyyd",
    "message": "net,dgram: add ipv6Only option for net and dgram\n\nFor TCP servers, the dual-stack support is enable by default, i.e.\nbinding host \"::\" will also make \"0.0.0.0\" bound. This commit add\nipv6Only option in `net.Server.listen()` and `dgram.createSocket()`\nmethods which allows to disable dual-stack support. Support for\ncluster module is also provided in this commit.\n\nFixes: https://github.com/nodejs/node/issues/17664\n\nPR-URL: https://github.com/nodejs/node/pull/23798\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
    "files": [
        {
            "sha": "31abaf450c595b0c03a57f907ed664d37412702b",
            "filename": "doc/api/dgram.md",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/doc%2Fapi%2Fdgram.md",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/doc%2Fapi%2Fdgram.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fdgram.md?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -601,6 +601,9 @@ changes:\n     pr-url: https://github.com/nodejs/node/pull/13623\n     description: The `recvBufferSize` and `sendBufferSize` options are\n                  supported now.\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/23798\n+    description: The `ipv6Only` option is supported.\n -->\n \n * `options` {Object} Available options are:\n@@ -609,6 +612,9 @@ changes:\n   * `reuseAddr` {boolean} When `true` [`socket.bind()`][] will reuse the\n     address, even if another process has already bound a socket on it.\n     **Default:** `false`.\n+  * `ipv6Only` {boolean} Setting `ipv6Only` to `true` will\n+    disable dual-stack support, i.e., binding to address `::` won't make\n+    `0.0.0.0` be bound. **Default:** `false`.\n   * `recvBufferSize` {number} - Sets the `SO_RCVBUF` socket value.\n   * `sendBufferSize` {number} - Sets the `SO_SNDBUF` socket value.\n   * `lookup` {Function} Custom lookup function. **Default:** [`dns.lookup()`][]."
        },
        {
            "sha": "35fb0a6171382ef5fbb39d7c308d664a4bdd4de9",
            "filename": "doc/api/net.md",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/doc%2Fapi%2Fnet.md",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/doc%2Fapi%2Fnet.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fnet.md?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -252,6 +252,10 @@ Listening on a file descriptor is not supported on Windows.\n #### server.listen(options[, callback])\n <!-- YAML\n added: v0.11.14\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/23798\n+    description: The `ipv6Only` option is supported.\n -->\n \n * `options` {Object} Required. Supports the following properties:\n@@ -266,6 +270,9 @@ added: v0.11.14\n     for all users. **Default:** `false`\n   * `writableAll` {boolean} For IPC servers makes the pipe writable\n     for all users. **Default:** `false`\n+  * `ipv6Only` {boolean} For TCP servers, setting `ipv6Only` to `true` will\n+    disable dual-stack support, i.e., binding to host `::` won't make\n+    `0.0.0.0` be bound. **Default:** `false`.\n * `callback` {Function} Common parameter of [`server.listen()`][]\n   functions.\n * Returns: {net.Server}"
        },
        {
            "sha": "55662313d640cdef422f097a030c370f4da390de",
            "filename": "lib/dgram.js",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/lib%2Fdgram.js",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/lib%2Fdgram.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fdgram.js?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -54,7 +54,11 @@ const {\n } = require('internal/async_hooks');\n const { UV_UDP_REUSEADDR } = internalBinding('constants').os;\n \n-const { UDP, SendWrap } = internalBinding('udp_wrap');\n+const {\n+  constants: { UV_UDP_IPV6ONLY },\n+  UDP,\n+  SendWrap\n+} = internalBinding('udp_wrap');\n \n const BIND_STATE_UNBOUND = 0;\n const BIND_STATE_BINDING = 1;\n@@ -99,6 +103,7 @@ function Socket(type, listener) {\n     bindState: BIND_STATE_UNBOUND,\n     queue: undefined,\n     reuseAddr: options && options.reuseAddr, // Use UV_UDP_REUSEADDR if true.\n+    ipv6Only: options && options.ipv6Only,\n     recvBufferSize,\n     sendBufferSize\n   };\n@@ -270,6 +275,8 @@ Socket.prototype.bind = function(port_, address_ /* , callback */) {\n     var flags = 0;\n     if (state.reuseAddr)\n       flags |= UV_UDP_REUSEADDR;\n+    if (state.ipv6Only)\n+      flags |= UV_UDP_IPV6ONLY;\n \n     if (cluster.isWorker && !exclusive) {\n       bindServerHandle(this, {"
        },
        {
            "sha": "95f33ad1d09907cfa5d921465d5be0617b66cdb5",
            "filename": "lib/internal/cluster/round_robin_handle.js",
            "status": "modified",
            "additions": 10,
            "deletions": 4,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/lib%2Finternal%2Fcluster%2Fround_robin_handle.js",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/lib%2Finternal%2Fcluster%2Fround_robin_handle.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcluster%2Fround_robin_handle.js?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -3,10 +3,11 @@ const assert = require('assert');\n const net = require('net');\n const { sendHelper } = require('internal/cluster/utils');\n const uv = internalBinding('uv');\n+const { constants } = internalBinding('tcp_wrap');\n \n module.exports = RoundRobinHandle;\n \n-function RoundRobinHandle(key, address, port, addressType, fd) {\n+function RoundRobinHandle(key, address, port, addressType, fd, flags) {\n   this.key = key;\n   this.all = new Map();\n   this.free = [];\n@@ -16,9 +17,14 @@ function RoundRobinHandle(key, address, port, addressType, fd) {\n \n   if (fd >= 0)\n     this.server.listen({ fd });\n-  else if (port >= 0)\n-    this.server.listen(port, address);\n-  else\n+  else if (port >= 0) {\n+    this.server.listen({\n+      port,\n+      host: address,\n+      // Currently, net module only supports `ipv6Only` option in `flags`.\n+      ipv6Only: Boolean(flags & constants.UV_TCP_IPV6ONLY),\n+    });\n+  } else\n     this.server.listen(address);  // UNIX socket path.\n \n   this.server.once('listening', () => {"
        },
        {
            "sha": "0b5f1531931b6c80c0278090628ba6440539fd58",
            "filename": "lib/internal/cluster/shared_handle.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/lib%2Finternal%2Fcluster%2Fshared_handle.js",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/lib%2Finternal%2Fcluster%2Fshared_handle.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcluster%2Fshared_handle.js?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -15,7 +15,7 @@ function SharedHandle(key, address, port, addressType, fd, flags) {\n   if (addressType === 'udp4' || addressType === 'udp6')\n     rval = dgram._createSocketHandle(address, port, addressType, fd, flags);\n   else\n-    rval = net._createServerHandle(address, port, addressType, fd);\n+    rval = net._createServerHandle(address, port, addressType, fd, flags);\n \n   if (typeof rval === 'number')\n     this.errno = rval;"
        },
        {
            "sha": "25767b257416442dcc436cdbbfa01af97e53c83c",
            "filename": "lib/net.js",
            "status": "modified",
            "additions": 20,
            "deletions": 15,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/lib%2Fnet.js",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/lib%2Fnet.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fnet.js?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -97,6 +97,10 @@ const {\n \n function noop() {}\n \n+function getFlags(ipv6Only) {\n+  return ipv6Only === true ? TCPConstants.UV_TCP_IPV6ONLY : 0;\n+}\n+\n function createHandle(fd, is_server) {\n   validateInt32(fd, 'fd', 0);\n   const type = TTYWrap.guessHandleType(fd);\n@@ -798,7 +802,7 @@ function checkBindError(err, port, handle) {\n \n \n function internalConnect(\n-  self, address, port, addressType, localAddress, localPort) {\n+  self, address, port, addressType, localAddress, localPort, flags) {\n   // TODO return promise from Socket.prototype.connect which\n   // wraps _connectReq.\n \n@@ -812,7 +816,7 @@ function internalConnect(\n       err = self._handle.bind(localAddress, localPort);\n     } else { // addressType === 6\n       localAddress = localAddress || '::';\n-      err = self._handle.bind6(localAddress, localPort);\n+      err = self._handle.bind6(localAddress, localPort, flags);\n     }\n     debug('binding to localAddress: %s and localPort: %d (addressType: %d)',\n           localAddress, localPort, addressType);\n@@ -1148,7 +1152,7 @@ util.inherits(Server, EventEmitter);\n function toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n \n // Returns handle if it can be created, or error code if it can't\n-function createServerHandle(address, port, addressType, fd) {\n+function createServerHandle(address, port, addressType, fd, flags) {\n   var err = 0;\n   // assign handle in listen, and clean up if bind or listen fails\n   var handle;\n@@ -1187,14 +1191,14 @@ function createServerHandle(address, port, addressType, fd) {\n     debug('bind to', address || 'any');\n     if (!address) {\n       // Try binding to ipv6 first\n-      err = handle.bind6('::', port);\n+      err = handle.bind6('::', port, flags);\n       if (err) {\n         handle.close();\n         // Fallback to ipv4\n         return createServerHandle('0.0.0.0', port);\n       }\n     } else if (addressType === 6) {\n-      err = handle.bind6(address, port);\n+      err = handle.bind6(address, port, flags);\n     } else {\n       err = handle.bind(address, port);\n     }\n@@ -1208,7 +1212,7 @@ function createServerHandle(address, port, addressType, fd) {\n   return handle;\n }\n \n-function setupListenHandle(address, port, addressType, backlog, fd) {\n+function setupListenHandle(address, port, addressType, backlog, fd, flags) {\n   debug('setupListenHandle', address, port, addressType, backlog, fd);\n \n   // If there is not yet a handle, we need to create one and bind.\n@@ -1222,7 +1226,7 @@ function setupListenHandle(address, port, addressType, backlog, fd) {\n \n     // Try to bind to the unspecified IPv6 address, see if IPv6 is available\n     if (!address && typeof fd !== 'number') {\n-      rval = createServerHandle('::', port, 6, fd);\n+      rval = createServerHandle('::', port, 6, fd, flags);\n \n       if (typeof rval === 'number') {\n         rval = null;\n@@ -1235,7 +1239,7 @@ function setupListenHandle(address, port, addressType, backlog, fd) {\n     }\n \n     if (rval === null)\n-      rval = createServerHandle(address, port, addressType, fd);\n+      rval = createServerHandle(address, port, addressType, fd, flags);\n \n     if (typeof rval === 'number') {\n       var error = uvExceptionWithHostPort(rval, 'listen', address, port);\n@@ -1294,7 +1298,7 @@ function emitListeningNT(self) {\n \n \n function listenInCluster(server, address, port, addressType,\n-                         backlog, fd, exclusive) {\n+                         backlog, fd, exclusive, flags) {\n   exclusive = !!exclusive;\n \n   if (cluster === undefined) cluster = require('cluster');\n@@ -1303,7 +1307,7 @@ function listenInCluster(server, address, port, addressType,\n     // Will create a new handle\n     // _listen2 sets up the listened handle, it is still named like this\n     // to avoid breaking code that wraps this method\n-    server._listen2(address, port, addressType, backlog, fd);\n+    server._listen2(address, port, addressType, backlog, fd, flags);\n     return;\n   }\n \n@@ -1312,7 +1316,7 @@ function listenInCluster(server, address, port, addressType,\n     port: port,\n     addressType: addressType,\n     fd: fd,\n-    flags: 0\n+    flags,\n   };\n \n   // Get the master's server handle, and listen on it\n@@ -1330,7 +1334,7 @@ function listenInCluster(server, address, port, addressType,\n     server._handle = handle;\n     // _listen2 sets up the listened handle, it is still named like this\n     // to avoid breaking code that wraps this method\n-    server._listen2(address, port, addressType, backlog, fd);\n+    server._listen2(address, port, addressType, backlog, fd, flags);\n   }\n }\n \n@@ -1353,6 +1357,7 @@ Server.prototype.listen = function(...args) {\n     toNumber(args.length > 2 && args[2]);  // (port, host, backlog)\n \n   options = options._handle || options.handle || options;\n+  const flags = getFlags(options.ipv6Only);\n   // (handle[, backlog][, cb]) where handle is an object with a handle\n   if (options instanceof TCP) {\n     this._handle = options;\n@@ -1387,7 +1392,7 @@ Server.prototype.listen = function(...args) {\n     // start TCP server listening on host:port\n     if (options.host) {\n       lookupAndListen(this, options.port | 0, options.host, backlog,\n-                      options.exclusive);\n+                      options.exclusive, flags);\n     } else { // Undefined host, listens on unspecified address\n       // Default addressType 4 will be used to search for master server\n       listenInCluster(this, null, options.port | 0, 4,\n@@ -1434,15 +1439,15 @@ Server.prototype.listen = function(...args) {\n   throw new ERR_INVALID_OPT_VALUE('options', util.inspect(options));\n };\n \n-function lookupAndListen(self, port, address, backlog, exclusive) {\n+function lookupAndListen(self, port, address, backlog, exclusive, flags) {\n   if (dns === undefined) dns = require('dns');\n   dns.lookup(address, function doListen(err, ip, addressType) {\n     if (err) {\n       self.emit('error', err);\n     } else {\n       addressType = ip ? addressType : 4;\n       listenInCluster(self, ip, port, addressType,\n-                      backlog, undefined, exclusive);\n+                      backlog, undefined, exclusive, flags);\n     }\n   });\n }"
        },
        {
            "sha": "504fda3de6cf95313c9e6ac8e7997d2fe8025eee",
            "filename": "src/tcp_wrap.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/src%2Ftcp_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/src%2Ftcp_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftcp_wrap.cc?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -127,6 +127,7 @@ void TCPWrap::Initialize(Local<Object> target,\n   Local<Object> constants = Object::New(env->isolate());\n   NODE_DEFINE_CONSTANT(constants, SOCKET);\n   NODE_DEFINE_CONSTANT(constants, SERVER);\n+  NODE_DEFINE_CONSTANT(constants, UV_TCP_IPV6ONLY);\n   target->Set(context,\n               env->constants_string(),\n               constants).FromJust();\n@@ -252,13 +253,15 @@ void TCPWrap::Bind6(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = wrap->env();\n   node::Utf8Value ip6_address(env->isolate(), args[0]);\n   int port;\n+  unsigned int flags;\n   if (!args[1]->Int32Value(env->context()).To(&port)) return;\n+  if (!args[2]->Uint32Value(env->context()).To(&flags)) return;\n   sockaddr_in6 addr;\n   int err = uv_ip6_addr(*ip6_address, port, &addr);\n   if (err == 0) {\n     err = uv_tcp_bind(&wrap->handle_,\n                       reinterpret_cast<const sockaddr*>(&addr),\n-                      0);\n+                      flags);\n   }\n   args.GetReturnValue().Set(err);\n }"
        },
        {
            "sha": "b4c859e5947b806928dbf421efb1d31e0908baf4",
            "filename": "src/udp_wrap.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/src%2Fudp_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/src%2Fudp_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fudp_wrap.cc?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -149,6 +149,12 @@ void UDPWrap::Initialize(Local<Object> target,\n   target->Set(env->context(),\n               sendWrapString,\n               swt->GetFunction(env->context()).ToLocalChecked()).FromJust();\n+\n+  Local<Object> constants = Object::New(env->isolate());\n+  NODE_DEFINE_CONSTANT(constants, UV_UDP_IPV6ONLY);\n+  target->Set(context,\n+              env->constants_string(),\n+              constants).FromJust();\n }\n \n "
        },
        {
            "sha": "0906baec929d21de51f717e8cd95f661df3691b5",
            "filename": "test/parallel/test-cluster-dgram-ipv6only.js",
            "status": "added",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/test%2Fparallel%2Ftest-cluster-dgram-ipv6only.js",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/test%2Fparallel%2Ftest-cluster-dgram-ipv6only.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-cluster-dgram-ipv6only.js?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -0,0 +1,51 @@\n+'use strict';\n+\n+const common = require('../common');\n+if (!common.hasIPv6)\n+  common.skip('no IPv6 support');\n+if (common.isWindows)\n+  common.skip('dgram clustering is currently not supported on windows.');\n+\n+const assert = require('assert');\n+const cluster = require('cluster');\n+const dgram = require('dgram');\n+\n+// This test ensures that the `ipv6Only` option in `dgram.createSock()`\n+// works as expected.\n+if (cluster.isMaster) {\n+  cluster.fork().on('exit', common.mustCall((code) => {\n+    assert.strictEqual(code, 0);\n+  }));\n+} else {\n+  let waiting = 2;\n+  function close() {\n+    if (--waiting === 0)\n+      cluster.worker.disconnect();\n+  }\n+\n+  const socket1 = dgram.createSocket({\n+    type: 'udp6',\n+    ipv6Only: true\n+  });\n+  const socket2 = dgram.createSocket({\n+    type: 'udp4',\n+  });\n+  socket1.on('error', common.mustNotCall());\n+  socket2.on('error', common.mustNotCall());\n+\n+  socket1.bind({\n+    port: 0,\n+    address: '::',\n+  }, common.mustCall(() => {\n+    const { port } = socket1.address();\n+    socket2.bind({\n+      port,\n+      address: '0.0.0.0',\n+    }, common.mustCall(() => {\n+      process.nextTick(() => {\n+        socket1.close(close);\n+        socket2.close(close);\n+      });\n+    }));\n+  }));\n+}"
        },
        {
            "sha": "4d495d8faf6ddc952b662127b9e873395187c660",
            "filename": "test/parallel/test-cluster-net-listen-ipv6only-false.js",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/test%2Fparallel%2Ftest-cluster-net-listen-ipv6only-false.js",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/test%2Fparallel%2Ftest-cluster-net-listen-ipv6only-false.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-cluster-net-listen-ipv6only-false.js?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -0,0 +1,55 @@\n+'use strict';\n+\n+const common = require('../common');\n+if (!common.hasIPv6)\n+  common.skip('no IPv6 support');\n+\n+const assert = require('assert');\n+const cluster = require('cluster');\n+const net = require('net');\n+const Countdown = require('../common/countdown');\n+\n+// This test ensures that dual-stack support still works for cluster module\n+// when `ipv6Only` is not `true`.\n+const host = '::';\n+const WORKER_COUNT = 3;\n+\n+if (cluster.isMaster) {\n+  const workers = new Map();\n+  let address;\n+\n+  const countdown = new Countdown(WORKER_COUNT, () => {\n+    const socket = net.connect({\n+      port: address.port,\n+      host: '0.0.0.0',\n+    }, common.mustCall(() => {\n+      socket.destroy();\n+      workers.forEach((worker) => {\n+        worker.disconnect();\n+      });\n+    }));\n+    socket.on('error', common.mustNotCall());\n+  });\n+\n+  for (let i = 0; i < WORKER_COUNT; i += 1) {\n+    const worker = cluster.fork().on('exit', common.mustCall((statusCode) => {\n+      assert.strictEqual(statusCode, 0);\n+    })).on('listening', common.mustCall((workerAddress) => {\n+      if (!address) {\n+        address = workerAddress;\n+      } else {\n+        assert.strictEqual(address.addressType, workerAddress.addressType);\n+        assert.strictEqual(address.host, workerAddress.host);\n+        assert.strictEqual(address.port, workerAddress.port);\n+      }\n+      countdown.dec();\n+    }));\n+\n+    workers.set(i, worker);\n+  }\n+} else {\n+  net.createServer().listen({\n+    host,\n+    port: 0,\n+  }, common.mustCall());\n+}"
        },
        {
            "sha": "401afbc035e36ae8480af251b1e5c34df0873bce",
            "filename": "test/parallel/test-cluster-net-listen-ipv6only-none.js",
            "status": "added",
            "additions": 58,
            "deletions": 0,
            "changes": 58,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/test%2Fparallel%2Ftest-cluster-net-listen-ipv6only-none.js",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/test%2Fparallel%2Ftest-cluster-net-listen-ipv6only-none.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-cluster-net-listen-ipv6only-none.js?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -0,0 +1,58 @@\n+'use strict';\n+\n+const common = require('../common');\n+if (!common.hasIPv6)\n+  common.skip('no IPv6 support');\n+\n+const assert = require('assert');\n+const cluster = require('cluster');\n+const net = require('net');\n+const Countdown = require('../common/countdown');\n+\n+// This test ensures that the `ipv6Only` option in `net.Server.listen()`\n+// works as expected when we use cluster with `SCHED_NONE` schedulingPolicy.\n+cluster.schedulingPolicy = cluster.SCHED_NONE;\n+const host = '::';\n+const WORKER_ACCOUNT = 3;\n+\n+if (cluster.isMaster) {\n+  const workers = new Map();\n+  let address;\n+\n+  const countdown = new Countdown(WORKER_ACCOUNT, () => {\n+    // Make sure the `ipv6Only` option works.\n+    const server = net.createServer().listen({\n+      host: '0.0.0.0',\n+      port: address.port,\n+    }, common.mustCall(() => {\n+      // Exit.\n+      server.close();\n+      workers.forEach((worker) => {\n+        worker.disconnect();\n+      });\n+    }));\n+  });\n+\n+  for (let i = 0; i < WORKER_ACCOUNT; i += 1) {\n+    const worker = cluster.fork().on('exit', common.mustCall((statusCode) => {\n+      assert.strictEqual(statusCode, 0);\n+    })).on('listening', common.mustCall((workerAddress) => {\n+      if (!address) {\n+        address = workerAddress;\n+      } else {\n+        assert.strictEqual(address.addressType, workerAddress.addressType);\n+        assert.strictEqual(address.host, workerAddress.host);\n+        assert.strictEqual(address.port, workerAddress.port);\n+      }\n+      countdown.dec();\n+    }));\n+\n+    workers.set(i, worker);\n+  }\n+} else {\n+  net.createServer().listen({\n+    host,\n+    port: 0,\n+    ipv6Only: true,\n+  }, common.mustCall());\n+}"
        },
        {
            "sha": "de254a4fe9ecd963b26a9ff623c85b9e3f073667",
            "filename": "test/parallel/test-cluster-net-listen-ipv6only-rr.js",
            "status": "added",
            "additions": 58,
            "deletions": 0,
            "changes": 58,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/test%2Fparallel%2Ftest-cluster-net-listen-ipv6only-rr.js",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/test%2Fparallel%2Ftest-cluster-net-listen-ipv6only-rr.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-cluster-net-listen-ipv6only-rr.js?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -0,0 +1,58 @@\n+'use strict';\n+\n+const common = require('../common');\n+if (!common.hasIPv6)\n+  common.skip('no IPv6 support');\n+\n+const assert = require('assert');\n+const cluster = require('cluster');\n+const net = require('net');\n+const Countdown = require('../common/countdown');\n+\n+// This test ensures that the `ipv6Only` option in `net.Server.listen()`\n+// works as expected when we use cluster with `SCHED_RR` schedulingPolicy.\n+cluster.schedulingPolicy = cluster.SCHED_RR;\n+const host = '::';\n+const WORKER_ACCOUNT = 3;\n+\n+if (cluster.isMaster) {\n+  const workers = new Map();\n+  let address;\n+\n+  const countdown = new Countdown(WORKER_ACCOUNT, () => {\n+    // Make sure the `ipv6Only` option works.\n+    const server = net.createServer().listen({\n+      host: '0.0.0.0',\n+      port: address.port,\n+    }, common.mustCall(() => {\n+      // Exit.\n+      server.close();\n+      workers.forEach((worker) => {\n+        worker.disconnect();\n+      });\n+    }));\n+  });\n+\n+  for (let i = 0; i < WORKER_ACCOUNT; i += 1) {\n+    const worker = cluster.fork().on('exit', common.mustCall((statusCode) => {\n+      assert.strictEqual(statusCode, 0);\n+    })).on('listening', common.mustCall((workerAddress) => {\n+      if (!address) {\n+        address = workerAddress;\n+      } else {\n+        assert.strictEqual(address.addressType, workerAddress.addressType);\n+        assert.strictEqual(address.host, workerAddress.host);\n+        assert.strictEqual(address.port, workerAddress.port);\n+      }\n+      countdown.dec();\n+    }));\n+\n+    workers.set(i, worker);\n+  }\n+} else {\n+  net.createServer().listen({\n+    host,\n+    port: 0,\n+    ipv6Only: true,\n+  }, common.mustCall());\n+}"
        },
        {
            "sha": "1187f3084ad6f5d1cd06f762d6ad0844a0b49230",
            "filename": "test/parallel/test-dgram-ipv6only.js",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/test%2Fparallel%2Ftest-dgram-ipv6only.js",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/test%2Fparallel%2Ftest-dgram-ipv6only.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-dgram-ipv6only.js?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -0,0 +1,33 @@\n+'use strict';\n+\n+const common = require('../common');\n+if (!common.hasIPv6)\n+  common.skip('no IPv6 support');\n+\n+const dgram = require('dgram');\n+\n+// This test ensures that dual-stack support is disabled when\n+// we specify the `ipv6Only` option in `dgram.createSocket()`.\n+const socket = dgram.createSocket({\n+  type: 'udp6',\n+  ipv6Only: true,\n+});\n+\n+socket.bind({\n+  port: 0,\n+  address: '::',\n+}, common.mustCall(() => {\n+  const { port } = socket.address();\n+  const client = dgram.createSocket('udp4');\n+\n+  // We can still bind to '0.0.0.0'.\n+  client.bind({\n+    port,\n+    address: '0.0.0.0',\n+  }, common.mustCall(() => {\n+    client.close();\n+    socket.close();\n+  }));\n+\n+  client.on('error', common.mustNotCall());\n+}));"
        },
        {
            "sha": "a329011bcc8a2398d34e1f1e4ac951cbadbca9e2",
            "filename": "test/parallel/test-net-listen-ipv6only.js",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/test%2Fparallel%2Ftest-net-listen-ipv6only.js",
            "raw_url": "https://github.com/nodejs/node/raw/33a25b29a4d654f5c2a5c74725862bccb2fcccfb/test%2Fparallel%2Ftest-net-listen-ipv6only.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-net-listen-ipv6only.js?ref=33a25b29a4d654f5c2a5c74725862bccb2fcccfb",
            "patch": "@@ -0,0 +1,30 @@\n+'use strict';\n+\n+const common = require('../common');\n+if (!common.hasIPv6)\n+  common.skip('no IPv6 support');\n+\n+// This test ensures that dual-stack support is disabled when\n+// we specify the `ipv6Only` option in `net.Server.listen()`.\n+const assert = require('assert');\n+const net = require('net');\n+\n+const host = '::';\n+const server = net.createServer();\n+server.listen({\n+  host,\n+  port: 0,\n+  ipv6Only: true,\n+}, common.mustCall(() => {\n+  const { port } = server.address();\n+  const socket = net.connect({\n+    host: '0.0.0.0',\n+    port,\n+  });\n+\n+  socket.on('connect', common.mustNotCall());\n+  socket.on('error', common.mustCall((err) => {\n+    assert.strictEqual(err.code, 'ECONNREFUSED');\n+    server.close();\n+  }));\n+}));"
        }
    ],
    "stats": {
        "total": 369,
        "additions": 347,
        "deletions": 22
    }
}