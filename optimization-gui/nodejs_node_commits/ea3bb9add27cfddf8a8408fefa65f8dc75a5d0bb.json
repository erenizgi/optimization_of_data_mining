{
    "author": "gireeshpunathil",
    "message": "src: cache and resue isolate and contex pointers\n\nMany places these values are obtained through `env` pointer that\nincurs function calls. Source in once and re-use as much as possible.\nThere are more of this pattern in this file, but those are either\none-time use or used in conditional blocks which means sourcing-in\nthose data early may not be beneficial.\n\nPR-URL: https://github.com/nodejs/node/pull/23024\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>",
    "sha": "ea3bb9add27cfddf8a8408fefa65f8dc75a5d0bb",
    "files": [
        {
            "sha": "20cb4771bdfdbe718ff1f39f9021ae9102a308a2",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 83,
            "deletions": 66,
            "changes": 149,
            "blob_url": "https://github.com/nodejs/node/blob/ea3bb9add27cfddf8a8408fefa65f8dc75a5d0bb/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ea3bb9add27cfddf8a8408fefa65f8dc75a5d0bb/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=ea3bb9add27cfddf8a8408fefa65f8dc75a5d0bb",
            "patch": "@@ -191,24 +191,27 @@ inline void FileHandle::Close() {\n }\n \n void FileHandle::CloseReq::Resolve() {\n-  HandleScope scope(env()->isolate());\n+  Isolate* isolate = env()->isolate();\n+  HandleScope scope(isolate);\n   InternalCallbackScope callback_scope(this);\n-  Local<Promise> promise = promise_.Get(env()->isolate());\n+  Local<Promise> promise = promise_.Get(isolate);\n   Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();\n-  resolver->Resolve(env()->context(), Undefined(env()->isolate())).FromJust();\n+  resolver->Resolve(env()->context(), Undefined(isolate)).FromJust();\n }\n \n void FileHandle::CloseReq::Reject(Local<Value> reason) {\n-  HandleScope scope(env()->isolate());\n+  Isolate* isolate = env()->isolate();\n+  HandleScope scope(isolate);\n   InternalCallbackScope callback_scope(this);\n-  Local<Promise> promise = promise_.Get(env()->isolate());\n+  Local<Promise> promise = promise_.Get(isolate);\n   Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();\n   resolver->Reject(env()->context(), reason).FromJust();\n }\n \n FileHandle* FileHandle::CloseReq::file_handle() {\n-  HandleScope scope(env()->isolate());\n-  Local<Value> val = ref_.Get(env()->isolate());\n+  Isolate* isolate = env()->isolate();\n+  HandleScope scope(isolate);\n+  Local<Value> val = ref_.Get(isolate);\n   Local<Object> obj = val.As<Object>();\n   return Unwrap<FileHandle>(obj);\n }\n@@ -621,13 +624,14 @@ void AfterScanDirWithTypes(uv_fs_t* req) {\n   }\n \n   Environment* env = req_wrap->env();\n+  Isolate* isolate = env->isolate();\n   Local<Value> error;\n   int r;\n-  Local<Array> names = Array::New(env->isolate(), 0);\n+  Local<Array> names = Array::New(isolate, 0);\n   Local<Function> fn = env->push_values_to_array_function();\n   Local<Value> name_argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n   size_t name_idx = 0;\n-  Local<Value> types = Array::New(env->isolate(), 0);\n+  Local<Value> types = Array::New(isolate, 0);\n   Local<Value> type_argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n   size_t type_idx = 0;\n \n@@ -644,7 +648,7 @@ void AfterScanDirWithTypes(uv_fs_t* req) {\n     }\n \n     MaybeLocal<Value> filename =\n-      StringBytes::Encode(env->isolate(),\n+      StringBytes::Encode(isolate,\n           ent.name,\n           req_wrap->encoding(),\n           &error);\n@@ -662,7 +666,7 @@ void AfterScanDirWithTypes(uv_fs_t* req) {\n       name_idx = 0;\n     }\n \n-    type_argv[type_idx++] = Integer::New(env->isolate(), ent.type);\n+    type_argv[type_idx++] = Integer::New(isolate, ent.type);\n \n     if (type_idx >= arraysize(type_argv)) {\n       MaybeLocal<Value> ret = fn->Call(env->context(), types, type_idx,\n@@ -690,7 +694,7 @@ void AfterScanDirWithTypes(uv_fs_t* req) {\n     }\n   }\n \n-  Local<Array> result = Array::New(env->isolate(), 2);\n+  Local<Array> result = Array::New(isolate, 2);\n   result->Set(0, names);\n   result->Set(1, types);\n   req_wrap->Resolve(result);\n@@ -783,15 +787,16 @@ inline FSReqBase* GetReqWrap(Environment* env, Local<Value> value,\n \n void Access(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n-  HandleScope scope(env->isolate());\n+  Isolate* isolate = env->isolate();\n+  HandleScope scope(isolate);\n \n   const int argc = args.Length();\n   CHECK_GE(argc, 2);\n \n   CHECK(args[1]->IsInt32());\n   int mode = args[1].As<Int32>()->Value();\n \n-  BufferValue path(env->isolate(), args[0]);\n+  BufferValue path(isolate, args[0]);\n   CHECK_NOT_NULL(*path);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n@@ -836,10 +841,11 @@ void Close(const FunctionCallbackInfo<Value>& args) {\n // in the file.\n static void InternalModuleReadJSON(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n   uv_loop_t* loop = env->event_loop();\n \n   CHECK(args[0]->IsString());\n-  node::Utf8Value path(env->isolate(), args[0]);\n+  node::Utf8Value path(isolate, args[0]);\n \n   if (strlen(*path) != path.length())\n     return;  // Contains a nul byte.\n@@ -890,7 +896,7 @@ static void InternalModuleReadJSON(const FunctionCallbackInfo<Value>& args) {\n     return;\n   } else {\n     Local<String> chars_string =\n-        String::NewFromUtf8(env->isolate(),\n+        String::NewFromUtf8(isolate,\n                             &chars[start],\n                             v8::NewStringType::kNormal,\n                             size).ToLocalChecked();\n@@ -1011,13 +1017,14 @@ static void FStat(const FunctionCallbackInfo<Value>& args) {\n \n static void Symlink(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n \n   int argc = args.Length();\n   CHECK_GE(argc, 4);\n \n-  BufferValue target(env->isolate(), args[0]);\n+  BufferValue target(isolate, args[0]);\n   CHECK_NOT_NULL(*target);\n-  BufferValue path(env->isolate(), args[1]);\n+  BufferValue path(isolate, args[1]);\n   CHECK_NOT_NULL(*path);\n \n   CHECK(args[2]->IsInt32());\n@@ -1039,14 +1046,15 @@ static void Symlink(const FunctionCallbackInfo<Value>& args) {\n \n static void Link(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n \n   int argc = args.Length();\n   CHECK_GE(argc, 3);\n \n-  BufferValue src(env->isolate(), args[0]);\n+  BufferValue src(isolate, args[0]);\n   CHECK_NOT_NULL(*src);\n \n-  BufferValue dest(env->isolate(), args[1]);\n+  BufferValue dest(isolate, args[1]);\n   CHECK_NOT_NULL(*dest);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n@@ -1065,14 +1073,15 @@ static void Link(const FunctionCallbackInfo<Value>& args) {\n \n static void ReadLink(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n \n   int argc = args.Length();\n   CHECK_GE(argc, 3);\n \n-  BufferValue path(env->isolate(), args[0]);\n+  BufferValue path(isolate, args[0]);\n   CHECK_NOT_NULL(*path);\n \n-  const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n+  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n   if (req_wrap_async != nullptr) {  // readlink(path, encoding, req)\n@@ -1091,7 +1100,7 @@ static void ReadLink(const FunctionCallbackInfo<Value>& args) {\n     const char* link_path = static_cast<const char*>(req_wrap_sync.req.ptr);\n \n     Local<Value> error;\n-    MaybeLocal<Value> rc = StringBytes::Encode(env->isolate(),\n+    MaybeLocal<Value> rc = StringBytes::Encode(isolate,\n                                                link_path,\n                                                encoding,\n                                                &error);\n@@ -1107,13 +1116,14 @@ static void ReadLink(const FunctionCallbackInfo<Value>& args) {\n \n static void Rename(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n \n   int argc = args.Length();\n   CHECK_GE(argc, 3);\n \n-  BufferValue old_path(env->isolate(), args[0]);\n+  BufferValue old_path(isolate, args[0]);\n   CHECK_NOT_NULL(*old_path);\n-  BufferValue new_path(env->isolate(), args[1]);\n+  BufferValue new_path(isolate, args[1]);\n   CHECK_NOT_NULL(*new_path);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n@@ -1408,14 +1418,15 @@ static void MKDir(const FunctionCallbackInfo<Value>& args) {\n \n static void RealPath(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n \n   const int argc = args.Length();\n   CHECK_GE(argc, 3);\n \n-  BufferValue path(env->isolate(), args[0]);\n+  BufferValue path(isolate, args[0]);\n   CHECK_NOT_NULL(*path);\n \n-  const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n+  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n   if (req_wrap_async != nullptr) {  // realpath(path, encoding, req)\n@@ -1435,7 +1446,7 @@ static void RealPath(const FunctionCallbackInfo<Value>& args) {\n     const char* link_path = static_cast<const char*>(req_wrap_sync.req.ptr);\n \n     Local<Value> error;\n-    MaybeLocal<Value> rc = StringBytes::Encode(env->isolate(),\n+    MaybeLocal<Value> rc = StringBytes::Encode(isolate,\n                                                link_path,\n                                                encoding,\n                                                &error);\n@@ -1451,14 +1462,15 @@ static void RealPath(const FunctionCallbackInfo<Value>& args) {\n \n static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n \n   const int argc = args.Length();\n   CHECK_GE(argc, 3);\n \n-  BufferValue path(env->isolate(), args[0]);\n+  BufferValue path(isolate, args[0]);\n   CHECK_NOT_NULL(*path);\n \n-  const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n+  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);\n \n   bool with_types = args[2]->IsTrue();\n \n@@ -1484,7 +1496,7 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n \n     CHECK_GE(req_wrap_sync.req.result, 0);\n     int r;\n-    Local<Array> names = Array::New(env->isolate(), 0);\n+    Local<Array> names = Array::New(isolate, 0);\n     Local<Function> fn = env->push_values_to_array_function();\n     Local<Value> name_v[NODE_PUSH_VAL_TO_ARRAY_MAX];\n     size_t name_idx = 0;\n@@ -1493,7 +1505,7 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n     Local<Value> type_v[NODE_PUSH_VAL_TO_ARRAY_MAX];\n     size_t type_idx;\n     if (with_types) {\n-      types = Array::New(env->isolate(), 0);\n+      types = Array::New(isolate, 0);\n       type_idx = 0;\n     }\n \n@@ -1506,14 +1518,14 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n       if (r != 0) {\n         Local<Object> ctx = args[4].As<Object>();\n         ctx->Set(env->context(), env->errno_string(),\n-                 Integer::New(env->isolate(), r)).FromJust();\n+                 Integer::New(isolate, r)).FromJust();\n         ctx->Set(env->context(), env->syscall_string(),\n-                 OneByteString(env->isolate(), \"readdir\")).FromJust();\n+                 OneByteString(isolate, \"readdir\")).FromJust();\n         return;\n       }\n \n       Local<Value> error;\n-      MaybeLocal<Value> filename = StringBytes::Encode(env->isolate(),\n+      MaybeLocal<Value> filename = StringBytes::Encode(isolate,\n                                                        ent.name,\n                                                        encoding,\n                                                        &error);\n@@ -1536,7 +1548,7 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n       }\n \n       if (with_types) {\n-        type_v[type_idx++] = Integer::New(env->isolate(), ent.type);\n+        type_v[type_idx++] = Integer::New(isolate, ent.type);\n \n         if (type_idx >= arraysize(type_v)) {\n           MaybeLocal<Value> ret = fn->Call(env->context(), types, type_idx,\n@@ -1564,7 +1576,7 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n     }\n \n     if (with_types) {\n-      Local<Array> result = Array::New(env->isolate(), 2);\n+      Local<Array> result = Array::New(isolate, 2);\n       result->Set(0, names);\n       result->Set(1, types);\n       args.GetReturnValue().Set(result);\n@@ -1606,11 +1618,12 @@ static void Open(const FunctionCallbackInfo<Value>& args) {\n \n static void OpenFileHandle(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n \n   const int argc = args.Length();\n   CHECK_GE(argc, 3);\n \n-  BufferValue path(env->isolate(), args[0]);\n+  BufferValue path(isolate, args[0]);\n   CHECK_NOT_NULL(*path);\n \n   CHECK(args[1]->IsInt32());\n@@ -1633,22 +1646,23 @@ static void OpenFileHandle(const FunctionCallbackInfo<Value>& args) {\n     if (result < 0) {\n       return;  // syscall failed, no need to continue, error info is in ctx\n     }\n-    HandleScope scope(env->isolate());\n+    HandleScope scope(isolate);\n     FileHandle* fd = new FileHandle(env, result);\n     args.GetReturnValue().Set(fd->object());\n   }\n }\n \n static void CopyFile(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n \n   const int argc = args.Length();\n   CHECK_GE(argc, 3);\n \n-  BufferValue src(env->isolate(), args[0]);\n+  BufferValue src(isolate, args[0]);\n   CHECK_NOT_NULL(*src);\n \n-  BufferValue dest(env->isolate(), args[1]);\n+  BufferValue dest(isolate, args[1]);\n   CHECK_NOT_NULL(*dest);\n \n   CHECK(args[2]->IsInt32());\n@@ -1779,6 +1793,7 @@ static void WriteBuffers(const FunctionCallbackInfo<Value>& args) {\n // 3 enc       encoding of string\n static void WriteString(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n \n   const int argc = args.Length();\n   CHECK_GE(argc, 4);\n@@ -1788,7 +1803,7 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n \n   const int64_t pos = GET_OFFSET(args[2]);\n \n-  const auto enc = ParseEncoding(env->isolate(), args[3], UTF8);\n+  const auto enc = ParseEncoding(isolate, args[3], UTF8);\n \n   Local<Value> value = args[1];\n   char* buf = nullptr;\n@@ -1819,12 +1834,12 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n \n   if (is_async) {  // write(fd, string, pos, enc, req)\n     CHECK_NOT_NULL(req_wrap_async);\n-    if (!StringBytes::StorageSize(env->isolate(), value, enc).To(&len)) return;\n+    if (!StringBytes::StorageSize(isolate, value, enc).To(&len)) return;\n     FSReqBase::FSReqBuffer& stack_buffer =\n         req_wrap_async->Init(\"write\", len, enc);\n     // StorageSize may return too large a char, so correct the actual length\n     // by the write size\n-    len = StringBytes::Write(env->isolate(), *stack_buffer, len, args[1], enc);\n+    len = StringBytes::Write(isolate, *stack_buffer, len, args[1], enc);\n     stack_buffer.SetLengthAndZeroTerminate(len);\n     uv_buf_t uvbuf = uv_buf_init(*stack_buffer, len);\n     int err = req_wrap_async->Dispatch(uv_fs_write,\n@@ -1847,12 +1862,12 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n     FSReqWrapSync req_wrap_sync;\n     FSReqBase::FSReqBuffer stack_buffer;\n     if (buf == nullptr) {\n-      if (!StringBytes::StorageSize(env->isolate(), value, enc).To(&len))\n+      if (!StringBytes::StorageSize(isolate, value, enc).To(&len))\n         return;\n       stack_buffer.AllocateSufficientStorage(len + 1);\n       // StorageSize may return too large a char, so correct the actual length\n       // by the write size\n-      len = StringBytes::Write(env->isolate(), *stack_buffer,\n+      len = StringBytes::Write(isolate, *stack_buffer,\n                                len, args[1], enc);\n       stack_buffer.SetLengthAndZeroTerminate(len);\n       buf = *stack_buffer;\n@@ -2138,14 +2153,15 @@ static void FUTimes(const FunctionCallbackInfo<Value>& args) {\n \n static void Mkdtemp(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n \n   const int argc = args.Length();\n   CHECK_GE(argc, 2);\n \n-  BufferValue tmpl(env->isolate(), args[0]);\n+  BufferValue tmpl(isolate, args[0]);\n   CHECK_NOT_NULL(*tmpl);\n \n-  const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n+  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);\n \n   FSReqBase* req_wrap_async = GetReqWrap(env, args[2]);\n   if (req_wrap_async != nullptr) {  // mkdtemp(tmpl, encoding, req)\n@@ -2162,7 +2178,7 @@ static void Mkdtemp(const FunctionCallbackInfo<Value>& args) {\n \n     Local<Value> error;\n     MaybeLocal<Value> rc =\n-        StringBytes::Encode(env->isolate(), path, encoding, &error);\n+        StringBytes::Encode(isolate, path, encoding, &error);\n     if (rc.IsEmpty()) {\n       Local<Object> ctx = args[3].As<Object>();\n       ctx->Set(env->context(), env->error_string(), error).FromJust();\n@@ -2177,6 +2193,7 @@ void Initialize(Local<Object> target,\n                 Local<Context> context,\n                 void* priv) {\n   Environment* env = Environment::GetCurrent(context);\n+  Isolate* isolate = env->isolate();\n \n   env->SetMethod(target, \"access\", Access);\n   env->SetMethod(target, \"close\", Close);\n@@ -2218,17 +2235,17 @@ void Initialize(Local<Object> target,\n \n   env->SetMethod(target, \"mkdtemp\", Mkdtemp);\n \n-  target->Set(env->context(),\n-              FIXED_ONE_BYTE_STRING(env->isolate(), \"kFsStatsFieldsLength\"),\n-              Integer::New(env->isolate(), env->kFsStatsFieldsLength))\n+  target->Set(context,\n+              FIXED_ONE_BYTE_STRING(isolate, \"kFsStatsFieldsLength\"),\n+              Integer::New(isolate, env->kFsStatsFieldsLength))\n         .FromJust();\n \n   target->Set(context,\n-              FIXED_ONE_BYTE_STRING(env->isolate(), \"statValues\"),\n+              FIXED_ONE_BYTE_STRING(isolate, \"statValues\"),\n               env->fs_stats_field_array()->GetJSArray()).FromJust();\n \n   target->Set(context,\n-              FIXED_ONE_BYTE_STRING(env->isolate(), \"bigintStatValues\"),\n+              FIXED_ONE_BYTE_STRING(isolate, \"bigintStatValues\"),\n               env->fs_stats_field_bigint_array()->GetJSArray()).FromJust();\n \n   StatWatcher::Initialize(env, target);\n@@ -2238,7 +2255,7 @@ void Initialize(Local<Object> target,\n   fst->InstanceTemplate()->SetInternalFieldCount(1);\n   AsyncWrap::AddWrapMethods(env, fst);\n   Local<String> wrapString =\n-      FIXED_ONE_BYTE_STRING(env->isolate(), \"FSReqCallback\");\n+      FIXED_ONE_BYTE_STRING(isolate, \"FSReqCallback\");\n   fst->SetClassName(wrapString);\n   target\n       ->Set(context, wrapString,\n@@ -2247,20 +2264,20 @@ void Initialize(Local<Object> target,\n \n   // Create FunctionTemplate for FileHandleReadWrap. Thereâ€™s no need\n   // to do anything in the constructor, so we only store the instance template.\n-  Local<FunctionTemplate> fh_rw = FunctionTemplate::New(env->isolate());\n+  Local<FunctionTemplate> fh_rw = FunctionTemplate::New(isolate);\n   fh_rw->InstanceTemplate()->SetInternalFieldCount(1);\n   AsyncWrap::AddWrapMethods(env, fh_rw);\n   Local<String> fhWrapString =\n-      FIXED_ONE_BYTE_STRING(env->isolate(), \"FileHandleReqWrap\");\n+      FIXED_ONE_BYTE_STRING(isolate, \"FileHandleReqWrap\");\n   fh_rw->SetClassName(fhWrapString);\n   env->set_filehandlereadwrap_template(\n       fst->InstanceTemplate());\n \n   // Create Function Template for FSReqPromise\n-  Local<FunctionTemplate> fpt = FunctionTemplate::New(env->isolate());\n+  Local<FunctionTemplate> fpt = FunctionTemplate::New(isolate);\n   AsyncWrap::AddWrapMethods(env, fpt);\n   Local<String> promiseString =\n-      FIXED_ONE_BYTE_STRING(env->isolate(), \"FSReqPromise\");\n+      FIXED_ONE_BYTE_STRING(isolate, \"FSReqPromise\");\n   fpt->SetClassName(promiseString);\n   Local<ObjectTemplate> fpo = fpt->InstanceTemplate();\n   fpo->SetInternalFieldCount(1);\n@@ -2274,7 +2291,7 @@ void Initialize(Local<Object> target,\n   Local<ObjectTemplate> fdt = fd->InstanceTemplate();\n   fdt->SetInternalFieldCount(1);\n   Local<String> handleString =\n-       FIXED_ONE_BYTE_STRING(env->isolate(), \"FileHandle\");\n+       FIXED_ONE_BYTE_STRING(isolate, \"FileHandle\");\n   fd->SetClassName(handleString);\n   StreamBase::AddMethods<FileHandle>(env, fd);\n   target\n@@ -2284,20 +2301,20 @@ void Initialize(Local<Object> target,\n   env->set_fd_constructor_template(fdt);\n \n   // Create FunctionTemplate for FileHandle::CloseReq\n-  Local<FunctionTemplate> fdclose = FunctionTemplate::New(env->isolate());\n-  fdclose->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(),\n+  Local<FunctionTemplate> fdclose = FunctionTemplate::New(isolate);\n+  fdclose->SetClassName(FIXED_ONE_BYTE_STRING(isolate,\n                         \"FileHandleCloseReq\"));\n   AsyncWrap::AddWrapMethods(env, fdclose);\n   Local<ObjectTemplate> fdcloset = fdclose->InstanceTemplate();\n   fdcloset->SetInternalFieldCount(1);\n   env->set_fdclose_constructor_template(fdcloset);\n \n   Local<Symbol> use_promises_symbol =\n-    Symbol::New(env->isolate(),\n-                FIXED_ONE_BYTE_STRING(env->isolate(), \"use promises\"));\n+    Symbol::New(isolate,\n+                FIXED_ONE_BYTE_STRING(isolate, \"use promises\"));\n   env->set_fs_use_promises_symbol(use_promises_symbol);\n-  target->Set(env->context(),\n-              FIXED_ONE_BYTE_STRING(env->isolate(), \"kUsePromises\"),\n+  target->Set(context,\n+              FIXED_ONE_BYTE_STRING(isolate, \"kUsePromises\"),\n               use_promises_symbol).FromJust();\n }\n "
        }
    ],
    "stats": {
        "total": 149,
        "additions": 83,
        "deletions": 66
    }
}