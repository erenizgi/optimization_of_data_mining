{
    "author": "guybedford",
    "message": "module: support main w/o extension, pjson cache\n\nThis adds support for ensuring that the top-level main into Node is\nsupported loading when it has no extension for backwards-compat with\nNodeJS bin workflows.\n\nIn addition package.json caching is implemented in the module lookup\nprocess.\n\nPR-URL: https://github.com/nodejs/node/pull/18728\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>",
    "sha": "f1fc426cce9db230cb83866871f355afa0b92d3b",
    "files": [
        {
            "sha": "3ff2904488afc1bc535d11f19a6e516af3f7901e",
            "filename": "doc/api/esm.md",
            "status": "modified",
            "additions": 12,
            "deletions": 4,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/doc%2Fapi%2Fesm.md",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/doc%2Fapi%2Fesm.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fesm.md?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -117,17 +117,22 @@ The resolve hook returns the resolved file URL and module format for a\n given module specifier and parent file URL:\n \n ```js\n-import url from 'url';\n+const baseURL = new URL('file://');\n+baseURL.pathname = process.cwd() + '/';\n \n-export async function resolve(specifier, parentModuleURL, defaultResolver) {\n+export async function resolve(specifier,\n+                              parentModuleURL = baseURL,\n+                              defaultResolver) {\n   return {\n     url: new URL(specifier, parentModuleURL).href,\n     format: 'esm'\n   };\n }\n ```\n \n-The default NodeJS ES module resolution function is provided as a third\n+The parentURL is provided as `undefined` when performing main Node.js load itself.\n+\n+The default Node.js ES module resolution function is provided as a third\n argument to the resolver for easy compatibility workflows.\n \n In addition to returning the resolved file URL value, the resolve hook also\n@@ -155,7 +160,10 @@ import Module from 'module';\n const builtins = Module.builtinModules;\n const JS_EXTENSIONS = new Set(['.js', '.mjs']);\n \n-export function resolve(specifier, parentModuleURL/*, defaultResolve */) {\n+const baseURL = new URL('file://');\n+baseURL.pathname = process.cwd() + '/';\n+\n+export function resolve(specifier, parentModuleURL = baseURL, defaultResolve) {\n   if (builtins.includes(specifier)) {\n     return {\n       url: specifier,"
        },
        {
            "sha": "d815be87dd8954b28caaa40be9911eb60fb7b5d9",
            "filename": "lib/internal/loader/DefaultResolve.js",
            "status": "modified",
            "additions": 16,
            "deletions": 5,
            "changes": 21,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/lib%2Finternal%2Floader%2FDefaultResolve.js",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/lib%2Finternal%2Floader%2FDefaultResolve.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Floader%2FDefaultResolve.js?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -2,7 +2,6 @@\n \n const { URL } = require('url');\n const CJSmodule = require('module');\n-const internalURLModule = require('internal/url');\n const internalFS = require('internal/fs');\n const NativeModule = require('native_module');\n const { extname } = require('path');\n@@ -11,6 +10,7 @@ const preserveSymlinks = !!process.binding('config').preserveSymlinks;\n const errors = require('internal/errors');\n const { resolve: moduleWrapResolve } = internalBinding('module_wrap');\n const StringStartsWith = Function.call.bind(String.prototype.startsWith);\n+const { getURLFromFilePath, getPathFromURL } = require('internal/url');\n \n const realpathCache = new Map();\n \n@@ -57,7 +57,8 @@ function resolve(specifier, parentURL) {\n \n   let url;\n   try {\n-    url = search(specifier, parentURL);\n+    url = search(specifier,\n+                 parentURL || getURLFromFilePath(`${process.cwd()}/`).href);\n   } catch (e) {\n     if (typeof e.message === 'string' &&\n         StringStartsWith(e.message, 'Cannot find module'))\n@@ -66,17 +67,27 @@ function resolve(specifier, parentURL) {\n   }\n \n   if (!preserveSymlinks) {\n-    const real = realpathSync(internalURLModule.getPathFromURL(url), {\n+    const real = realpathSync(getPathFromURL(url), {\n       [internalFS.realpathCacheKey]: realpathCache\n     });\n     const old = url;\n-    url = internalURLModule.getURLFromFilePath(real);\n+    url = getURLFromFilePath(real);\n     url.search = old.search;\n     url.hash = old.hash;\n   }\n \n   const ext = extname(url.pathname);\n-  return { url: `${url}`, format: extensionFormatMap[ext] || ext };\n+\n+  let format = extensionFormatMap[ext];\n+  if (!format) {\n+    const isMain = parentURL === undefined;\n+    if (isMain)\n+      format = 'cjs';\n+    else\n+      throw new errors.Error('ERR_UNKNOWN_FILE_EXTENSION', url.pathname);\n+  }\n+\n+  return { url: `${url}`, format };\n }\n \n module.exports = resolve;"
        },
        {
            "sha": "f0edbbf921f40fe50b6dac6e663e6ff9e864367c",
            "filename": "lib/internal/loader/Loader.js",
            "status": "modified",
            "additions": 11,
            "deletions": 48,
            "changes": 59,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/lib%2Finternal%2Floader%2FLoader.js",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/lib%2Finternal%2Floader%2FLoader.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Floader%2FLoader.js?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -1,51 +1,21 @@\n 'use strict';\n \n-const path = require('path');\n-const { getURLFromFilePath, URL } = require('internal/url');\n const errors = require('internal/errors');\n-\n const ModuleMap = require('internal/loader/ModuleMap');\n const ModuleJob = require('internal/loader/ModuleJob');\n const defaultResolve = require('internal/loader/DefaultResolve');\n const createDynamicModule = require('internal/loader/CreateDynamicModule');\n const translators = require('internal/loader/Translators');\n-const { setImportModuleDynamicallyCallback } = internalBinding('module_wrap');\n+\n const FunctionBind = Function.call.bind(Function.prototype.bind);\n \n const debug = require('util').debuglog('esm');\n \n-// Returns a file URL for the current working directory.\n-function getURLStringForCwd() {\n-  try {\n-    return getURLFromFilePath(`${process.cwd()}/`).href;\n-  } catch (e) {\n-    e.stack;\n-    // If the current working directory no longer exists.\n-    if (e.code === 'ENOENT') {\n-      return undefined;\n-    }\n-    throw e;\n-  }\n-}\n-\n-function normalizeReferrerURL(referrer) {\n-  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n-    return getURLFromFilePath(referrer).href;\n-  }\n-  return new URL(referrer).href;\n-}\n-\n /* A Loader instance is used as the main entry point for loading ES modules.\n  * Currently, this is a singleton -- there is only one used for loading\n  * the main module and everything in its dependency graph. */\n class Loader {\n-  constructor(base = getURLStringForCwd()) {\n-    if (typeof base !== 'string')\n-      throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'base', 'string');\n-\n-    this.base = base;\n-    this.isMain = true;\n-\n+  constructor() {\n     // methods which translate input code or other information\n     // into es modules\n     this.translators = translators;\n@@ -71,8 +41,9 @@ class Loader {\n     this._dynamicInstantiate = undefined;\n   }\n \n-  async resolve(specifier, parentURL = this.base) {\n-    if (typeof parentURL !== 'string')\n+  async resolve(specifier, parentURL) {\n+    const isMain = parentURL === undefined;\n+    if (!isMain && typeof parentURL !== 'string')\n       throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'parentURL', 'string');\n \n     const { url, format } =\n@@ -93,7 +64,7 @@ class Loader {\n     return { url, format };\n   }\n \n-  async import(specifier, parent = this.base) {\n+  async import(specifier, parent) {\n     const job = await this.getModuleJob(specifier, parent);\n     const module = await job.run();\n     return module.namespace();\n@@ -107,7 +78,7 @@ class Loader {\n       this._dynamicInstantiate = FunctionBind(dynamicInstantiate, null);\n   }\n \n-  async getModuleJob(specifier, parentURL = this.base) {\n+  async getModuleJob(specifier, parentURL) {\n     const { url, format } = await this.resolve(specifier, parentURL);\n     let job = this.moduleMap.get(url);\n     if (job !== undefined)\n@@ -134,24 +105,16 @@ class Loader {\n     }\n \n     let inspectBrk = false;\n-    if (this.isMain) {\n-      if (process._breakFirstLine) {\n-        delete process._breakFirstLine;\n-        inspectBrk = true;\n-      }\n-      this.isMain = false;\n+    if (process._breakFirstLine) {\n+      delete process._breakFirstLine;\n+      inspectBrk = true;\n     }\n     job = new ModuleJob(this, url, loaderInstance, inspectBrk);\n     this.moduleMap.set(url, job);\n     return job;\n   }\n-\n-  static registerImportDynamicallyCallback(loader) {\n-    setImportModuleDynamicallyCallback(async (referrer, specifier) => {\n-      return loader.import(specifier, normalizeReferrerURL(referrer));\n-    });\n-  }\n }\n \n Object.setPrototypeOf(Loader.prototype, null);\n+\n module.exports = Loader;"
        },
        {
            "sha": "18b1b12fd1585450e8a84f1a13aebdcf24cc53ad",
            "filename": "lib/internal/loader/Translators.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/lib%2Finternal%2Floader%2FTranslators.js",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/lib%2Finternal%2Floader%2FTranslators.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Floader%2FTranslators.js?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -19,7 +19,7 @@ const JsonParse = JSON.parse;\n const translators = new SafeMap();\n module.exports = translators;\n \n-// Stragety for loading a standard JavaScript module\n+// Strategy for loading a standard JavaScript module\n translators.set('esm', async (url) => {\n   const source = `${await readFileAsync(new URL(url))}`;\n   debug(`Translating StandardModule ${url}`);\n@@ -62,7 +62,7 @@ translators.set('builtin', async (url) => {\n   });\n });\n \n-// Stragety for loading a node native module\n+// Strategy for loading a node native module\n translators.set('addon', async (url) => {\n   debug(`Translating NativeModule ${url}`);\n   return createDynamicModule(['default'], url, (reflect) => {\n@@ -74,7 +74,7 @@ translators.set('addon', async (url) => {\n   });\n });\n \n-// Stragety for loading a JSON file\n+// Strategy for loading a JSON file\n translators.set('json', async (url) => {\n   debug(`Translating JSONModule ${url}`);\n   return createDynamicModule(['default'], url, (reflect) => {"
        },
        {
            "sha": "f89278ddaa2d5279d4cec225df8d03d66dfb0aa2",
            "filename": "lib/internal/process/modules.js",
            "status": "modified",
            "additions": 41,
            "deletions": 4,
            "changes": 45,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/lib%2Finternal%2Fprocess%2Fmodules.js",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/lib%2Finternal%2Fprocess%2Fmodules.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fmodules.js?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -1,17 +1,54 @@\n 'use strict';\n \n const {\n+  setImportModuleDynamicallyCallback,\n   setInitializeImportMetaObjectCallback\n } = internalBinding('module_wrap');\n \n+const { getURLFromFilePath } = require('internal/url');\n+const Loader = require('internal/loader/Loader');\n+const path = require('path');\n+const { URL } = require('url');\n+\n+function normalizeReferrerURL(referrer) {\n+  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n+    return getURLFromFilePath(referrer).href;\n+  }\n+  return new URL(referrer).href;\n+}\n+\n function initializeImportMetaObject(wrap, meta) {\n   meta.url = wrap.url;\n }\n \n-function setupModules() {\n+let loaderResolve;\n+exports.loaderPromise = new Promise((resolve, reject) => {\n+  loaderResolve = resolve;\n+});\n+\n+exports.ESMLoader = undefined;\n+\n+exports.setup = function() {\n   setInitializeImportMetaObjectCallback(initializeImportMetaObject);\n-}\n \n-module.exports = {\n-  setup: setupModules\n+  let ESMLoader = new Loader();\n+  const loaderPromise = (async () => {\n+    const userLoader = process.binding('config').userLoader;\n+    if (userLoader) {\n+      const hooks = await ESMLoader.import(\n+        userLoader, getURLFromFilePath(`${process.cwd()}/`).href);\n+      ESMLoader = new Loader();\n+      ESMLoader.hook(hooks);\n+      exports.ESMLoader = ESMLoader;\n+    }\n+    return ESMLoader;\n+  })();\n+  loaderResolve(loaderPromise);\n+\n+  setImportModuleDynamicallyCallback(async (referrer, specifier) => {\n+    const loader = await loaderPromise;\n+    return loader.import(specifier, normalizeReferrerURL(referrer));\n+  });\n+\n+  exports.ESMLoader = ESMLoader;\n };"
        },
        {
            "sha": "c3250608ebe0f11b6834e72eb5cf6bd3c899239e",
            "filename": "lib/module.js",
            "status": "modified",
            "additions": 8,
            "deletions": 21,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/lib%2Fmodule.js",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/lib%2Fmodule.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fmodule.js?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -24,7 +24,6 @@\n const NativeModule = require('native_module');\n const util = require('util');\n const { decorateErrorStack } = require('internal/util');\n-const internalModule = require('internal/module');\n const { getURLFromFilePath } = require('internal/url');\n const vm = require('vm');\n const assert = require('assert').ok;\n@@ -35,6 +34,7 @@ const {\n   internalModuleReadJSON,\n   internalModuleStat\n } = process.binding('fs');\n+const internalModule = require('internal/module');\n const preserveSymlinks = !!process.binding('config').preserveSymlinks;\n const experimentalModules = !!process.binding('config').experimentalModules;\n \n@@ -43,10 +43,9 @@ const errors = require('internal/errors');\n module.exports = Module;\n \n // these are below module.exports for the circular reference\n-const Loader = require('internal/loader/Loader');\n+const internalESModule = require('internal/process/modules');\n const ModuleJob = require('internal/loader/ModuleJob');\n const createDynamicModule = require('internal/loader/CreateDynamicModule');\n-let ESMLoader;\n \n function stat(filename) {\n   filename = path.toNamespacedPath(filename);\n@@ -447,7 +446,6 @@ Module._resolveLookupPaths = function(request, parent, newReturn) {\n   return (newReturn ? parentDir : [id, parentDir]);\n };\n \n-\n // Check the cache for the requested file.\n // 1. If a module already exists in the cache: return its exports object.\n // 2. If the module is native: call `NativeModule.require()` with the\n@@ -460,22 +458,10 @@ Module._load = function(request, parent, isMain) {\n     debug('Module._load REQUEST %s parent: %s', request, parent.id);\n   }\n \n-  if (isMain && experimentalModules) {\n-    (async () => {\n-      // loader setup\n-      if (!ESMLoader) {\n-        ESMLoader = new Loader();\n-        const userLoader = process.binding('config').userLoader;\n-        if (userLoader) {\n-          ESMLoader.isMain = false;\n-          const hooks = await ESMLoader.import(userLoader);\n-          ESMLoader = new Loader();\n-          ESMLoader.hook(hooks);\n-        }\n-      }\n-      Loader.registerImportDynamicallyCallback(ESMLoader);\n-      await ESMLoader.import(getURLFromFilePath(request).pathname);\n-    })()\n+  if (experimentalModules && isMain) {\n+    internalESModule.loaderPromise.then((loader) => {\n+      return loader.import(getURLFromFilePath(request).pathname);\n+    })\n     .catch((e) => {\n       decorateErrorStack(e);\n       console.error(e);\n@@ -578,7 +564,8 @@ Module.prototype.load = function(filename) {\n   Module._extensions[extension](this, filename);\n   this.loaded = true;\n \n-  if (ESMLoader) {\n+  if (experimentalModules) {\n+    const ESMLoader = internalESModule.ESMLoader;\n     const url = getURLFromFilePath(filename);\n     const urlString = `${url}`;\n     const exports = this.exports;"
        },
        {
            "sha": "dedf821b24f5c123794dcd6d8979e8ba3d96b495",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 22,
            "deletions": 1,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -54,7 +54,26 @@ class performance_state;\n \n namespace loader {\n class ModuleWrap;\n-}\n+\n+struct Exists {\n+  enum Bool { Yes, No };\n+};\n+\n+struct IsValid {\n+  enum Bool { Yes, No };\n+};\n+\n+struct HasMain {\n+  enum Bool { Yes, No };\n+};\n+\n+struct PackageConfig {\n+  const Exists::Bool exists;\n+  const IsValid::Bool is_valid;\n+  const HasMain::Bool has_main;\n+  const std::string main;\n+};\n+}  // namespace loader\n \n // Pick an index that's hopefully out of the way when we're embedded inside\n // another application. Performance-wise or memory-wise it doesn't matter:\n@@ -609,6 +628,8 @@ class Environment {\n \n   std::unordered_multimap<int, loader::ModuleWrap*> module_map;\n \n+  std::unordered_map<std::string, loader::PackageConfig> package_json_cache;\n+\n   inline double* heap_statistics_buffer() const;\n   inline void set_heap_statistics_buffer(double* pointer);\n "
        },
        {
            "sha": "3d34da570a61a0450d212aab2cbd302338c001e7",
            "filename": "src/module_wrap.cc",
            "status": "modified",
            "additions": 77,
            "deletions": 48,
            "changes": 125,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/src%2Fmodule_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/src%2Fmodule_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fmodule_wrap.cc?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -461,10 +461,9 @@ enum CheckFileOptions {\n   CLOSE_AFTER_CHECK\n };\n \n-Maybe<uv_file> CheckFile(const URL& search,\n+Maybe<uv_file> CheckFile(const std::string& path,\n                          CheckFileOptions opt = CLOSE_AFTER_CHECK) {\n   uv_fs_t fs_req;\n-  std::string path = search.ToFilePath();\n   if (path.empty()) {\n     return Nothing<uv_file>();\n   }\n@@ -481,19 +480,74 @@ Maybe<uv_file> CheckFile(const URL& search,\n   uv_fs_req_cleanup(&fs_req);\n \n   if (is_directory) {\n-    uv_fs_close(nullptr, &fs_req, fd, nullptr);\n+    CHECK_EQ(0, uv_fs_close(nullptr, &fs_req, fd, nullptr));\n     uv_fs_req_cleanup(&fs_req);\n     return Nothing<uv_file>();\n   }\n \n   if (opt == CLOSE_AFTER_CHECK) {\n-    uv_fs_close(nullptr, &fs_req, fd, nullptr);\n+    CHECK_EQ(0, uv_fs_close(nullptr, &fs_req, fd, nullptr));\n     uv_fs_req_cleanup(&fs_req);\n   }\n \n   return Just(fd);\n }\n \n+const PackageConfig& GetPackageConfig(Environment* env,\n+                                                   const std::string path) {\n+  auto existing = env->package_json_cache.find(path);\n+  if (existing != env->package_json_cache.end()) {\n+    return existing->second;\n+  }\n+  Maybe<uv_file> check = CheckFile(path, LEAVE_OPEN_AFTER_CHECK);\n+  if (check.IsNothing()) {\n+    auto entry = env->package_json_cache.emplace(path,\n+        PackageConfig { Exists::No, IsValid::Yes, HasMain::No, \"\" });\n+    return entry.first->second;\n+  }\n+\n+  Isolate* isolate = env->isolate();\n+  v8::HandleScope handle_scope(isolate);\n+\n+  std::string pkg_src = ReadFile(check.FromJust());\n+  uv_fs_t fs_req;\n+  CHECK_EQ(0, uv_fs_close(nullptr, &fs_req, check.FromJust(), nullptr));\n+  uv_fs_req_cleanup(&fs_req);\n+\n+  Local<String> src;\n+  if (!String::NewFromUtf8(isolate,\n+                           pkg_src.c_str(),\n+                           v8::NewStringType::kNormal,\n+                           pkg_src.length()).ToLocal(&src)) {\n+    auto entry = env->package_json_cache.emplace(path,\n+        PackageConfig { Exists::No, IsValid::Yes, HasMain::No, \"\" });\n+    return entry.first->second;\n+  }\n+\n+  Local<Value> pkg_json_v;\n+  Local<Object> pkg_json;\n+\n+  if (!JSON::Parse(env->context(), src).ToLocal(&pkg_json_v) ||\n+      !pkg_json_v->ToObject(env->context()).ToLocal(&pkg_json)) {\n+    auto entry = env->package_json_cache.emplace(path,\n+        PackageConfig { Exists::Yes, IsValid::No, HasMain::No, \"\" });\n+    return entry.first->second;\n+  }\n+\n+  Local<Value> pkg_main;\n+  HasMain::Bool has_main = HasMain::No;\n+  std::string main_std;\n+  if (pkg_json->Get(env->context(), env->main_string()).ToLocal(&pkg_main)) {\n+    has_main = HasMain::Yes;\n+    Utf8Value main_utf8(isolate, pkg_main);\n+    main_std.assign(std::string(*main_utf8, main_utf8.length()));\n+  }\n+\n+  auto entry = env->package_json_cache.emplace(path,\n+      PackageConfig { Exists::Yes, IsValid::Yes, has_main, \"\" });\n+  return entry.first->second;\n+}\n+\n enum ResolveExtensionsOptions {\n   TRY_EXACT_NAME,\n   ONLY_VIA_EXTENSIONS\n@@ -502,15 +556,16 @@ enum ResolveExtensionsOptions {\n template<ResolveExtensionsOptions options>\n Maybe<URL> ResolveExtensions(const URL& search) {\n   if (options == TRY_EXACT_NAME) {\n-    Maybe<uv_file> check = CheckFile(search);\n+    std::string filePath = search.ToFilePath();\n+    Maybe<uv_file> check = CheckFile(filePath);\n     if (!check.IsNothing()) {\n       return Just(search);\n     }\n   }\n \n   for (const char* extension : EXTENSIONS) {\n     URL guess(search.path() + extension, &search);\n-    Maybe<uv_file> check = CheckFile(guess);\n+    Maybe<uv_file> check = CheckFile(guess.ToFilePath());\n     if (!check.IsNothing()) {\n       return Just(guess);\n     }\n@@ -525,44 +580,18 @@ inline Maybe<URL> ResolveIndex(const URL& search) {\n \n Maybe<URL> ResolveMain(Environment* env, const URL& search) {\n   URL pkg(\"package.json\", &search);\n-  Maybe<uv_file> check = CheckFile(pkg, LEAVE_OPEN_AFTER_CHECK);\n-  if (check.IsNothing()) {\n-    return Nothing<URL>();\n-  }\n-\n-  Isolate* isolate = env->isolate();\n-  Local<Context> context = isolate->GetCurrentContext();\n-  std::string pkg_src = ReadFile(check.FromJust());\n-  uv_fs_t fs_req;\n-  uv_fs_close(nullptr, &fs_req, check.FromJust(), nullptr);\n-  uv_fs_req_cleanup(&fs_req);\n-\n-  // It's not okay for the called of this method to not be able to tell\n-  // whether an exception is pending or not.\n-  TryCatch try_catch(isolate);\n \n-  Local<String> src;\n-  if (!String::NewFromUtf8(isolate,\n-                           pkg_src.c_str(),\n-                           v8::NewStringType::kNormal,\n-                           pkg_src.length()).ToLocal(&src)) {\n+  const PackageConfig& pjson =\n+      GetPackageConfig(env, pkg.ToFilePath());\n+  // Note invalid package.json should throw in resolver\n+  // currently we silently ignore which is incorrect\n+  if (!pjson.exists || !pjson.is_valid || !pjson.has_main) {\n     return Nothing<URL>();\n   }\n-\n-  Local<Value> pkg_json;\n-  if (!JSON::Parse(context, src).ToLocal(&pkg_json) || !pkg_json->IsObject())\n-    return Nothing<URL>();\n-  Local<Value> pkg_main;\n-  if (!pkg_json.As<Object>()->Get(context, env->main_string())\n-                              .ToLocal(&pkg_main) || !pkg_main->IsString()) {\n-    return Nothing<URL>();\n+  if (!ShouldBeTreatedAsRelativeOrAbsolutePath(pjson.main)) {\n+    return Resolve(env, \"./\" + pjson.main, search);\n   }\n-  Utf8Value main_utf8(isolate, pkg_main.As<String>());\n-  std::string main_std(*main_utf8, main_utf8.length());\n-  if (!ShouldBeTreatedAsRelativeOrAbsolutePath(main_std)) {\n-    main_std.insert(0, \"./\");\n-  }\n-  return Resolve(env, main_std, search);\n+  return Resolve(env, pjson.main, search);\n }\n \n Maybe<URL> ResolveModule(Environment* env,\n@@ -572,7 +601,8 @@ Maybe<URL> ResolveModule(Environment* env,\n   URL dir(\"\");\n   do {\n     dir = parent;\n-    Maybe<URL> check = Resolve(env, \"./node_modules/\" + specifier, dir, true);\n+    Maybe<URL> check =\n+        Resolve(env, \"./node_modules/\" + specifier, dir, IgnoreMain);\n     if (!check.IsNothing()) {\n       const size_t limit = specifier.find('/');\n       const size_t spec_len =\n@@ -594,8 +624,8 @@ Maybe<URL> ResolveModule(Environment* env,\n \n Maybe<URL> ResolveDirectory(Environment* env,\n                             const URL& search,\n-                            bool read_pkg_json) {\n-  if (read_pkg_json) {\n+                            PackageMainCheck check_pjson_main) {\n+  if (check_pjson_main) {\n     Maybe<URL> main = ResolveMain(env, search);\n     if (!main.IsNothing())\n       return main;\n@@ -605,15 +635,14 @@ Maybe<URL> ResolveDirectory(Environment* env,\n \n }  // anonymous namespace\n \n-\n Maybe<URL> Resolve(Environment* env,\n                    const std::string& specifier,\n                    const URL& base,\n-                   bool read_pkg_json) {\n+                   PackageMainCheck check_pjson_main) {\n   URL pure_url(specifier);\n   if (!(pure_url.flags() & URL_FLAGS_FAILED)) {\n     // just check existence, without altering\n-    Maybe<uv_file> check = CheckFile(pure_url);\n+    Maybe<uv_file> check = CheckFile(pure_url.ToFilePath());\n     if (check.IsNothing()) {\n       return Nothing<URL>();\n     }\n@@ -630,7 +659,7 @@ Maybe<URL> Resolve(Environment* env,\n     if (specifier.back() != '/') {\n       resolved = URL(specifier + \"/\", base);\n     }\n-    return ResolveDirectory(env, resolved, read_pkg_json);\n+    return ResolveDirectory(env, resolved, check_pjson_main);\n   } else {\n     return ResolveModule(env, specifier, base);\n   }\n@@ -667,7 +696,7 @@ void ModuleWrap::Resolve(const FunctionCallbackInfo<Value>& args) {\n     return;\n   }\n \n-  Maybe<URL> result = node::loader::Resolve(env, specifier_std, url, true);\n+  Maybe<URL> result = node::loader::Resolve(env, specifier_std, url);\n   if (result.IsNothing() || (result.FromJust().flags() & URL_FLAGS_FAILED)) {\n     std::string msg = \"Cannot find module \" + specifier_std;\n     env->ThrowError(msg.c_str());"
        },
        {
            "sha": "ee3740b56119f695a0bacff25c89861b9af36e8c",
            "filename": "src/module_wrap.h",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/src%2Fmodule_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/src%2Fmodule_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fmodule_wrap.h?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -12,10 +12,15 @@\n namespace node {\n namespace loader {\n \n+enum PackageMainCheck : bool {\n+    CheckMain = true,\n+    IgnoreMain = false\n+};\n+\n v8::Maybe<url::URL> Resolve(Environment* env,\n                             const std::string& specifier,\n                             const url::URL& base,\n-                            bool read_pkg_json = false);\n+                            PackageMainCheck read_pkg_json = CheckMain);\n \n class ModuleWrap : public BaseObject {\n  public:"
        },
        {
            "sha": "acb4486edc1288dcbbb6b04b2fcb7fdfe3e3fbaa",
            "filename": "test/fixtures/es-module-loaders/example-loader.mjs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/test%2Ffixtures%2Fes-module-loaders%2Fexample-loader.mjs",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/test%2Ffixtures%2Fes-module-loaders%2Fexample-loader.mjs",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Ffixtures%2Fes-module-loaders%2Fexample-loader.mjs?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -8,7 +8,10 @@ const builtins = new Set(\n );\n const JS_EXTENSIONS = new Set(['.js', '.mjs']);\n \n-export function resolve(specifier, parentModuleURL/*, defaultResolve */) {\n+const baseURL = new url.URL('file://');\n+baseURL.pathname = process.cwd() + '/';\n+\n+export function resolve(specifier, parentModuleURL = baseURL /*, defaultResolve */) {\n   if (builtins.has(specifier)) {\n     return {\n       url: specifier,"
        },
        {
            "sha": "2173b0b503ef4580c3395898cbff481902766da8",
            "filename": "test/fixtures/es-module-loaders/js-loader.mjs",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/test%2Ffixtures%2Fes-module-loaders%2Fjs-loader.mjs",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/test%2Ffixtures%2Fes-module-loaders%2Fjs-loader.mjs",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Ffixtures%2Fes-module-loaders%2Fjs-loader.mjs?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -3,7 +3,11 @@ const builtins = new Set(\n   Object.keys(process.binding('natives')).filter(str =>\n     /^(?!(?:internal|node|v8)\\/)/.test(str))\n )\n-export function resolve (specifier, base) {\n+\n+const baseURL = new _url.URL('file://');\n+baseURL.pathname = process.cwd() + '/';\n+\n+export function resolve (specifier, base = baseURL) {\n   if (builtins.has(specifier)) {\n     return {\n       url: specifier,"
        },
        {
            "sha": "f21c9bee6df46a7092f10265942a76cd6ec8ca88",
            "filename": "test/fixtures/es-modules/noext",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/test%2Ffixtures%2Fes-modules%2Fnoext",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/test%2Ffixtures%2Fes-modules%2Fnoext",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Ffixtures%2Fes-modules%2Fnoext?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -0,0 +1 @@\n+exports.cjs = true;\n\\ No newline at end of file"
        },
        {
            "sha": "6f7bc2eb1db6b2fc792a07fe032311c1b39a9626",
            "filename": "test/parallel/test-module-main-extension-lookup.js",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/f1fc426cce9db230cb83866871f355afa0b92d3b/test%2Fparallel%2Ftest-module-main-extension-lookup.js",
            "raw_url": "https://github.com/nodejs/node/raw/f1fc426cce9db230cb83866871f355afa0b92d3b/test%2Fparallel%2Ftest-module-main-extension-lookup.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-module-main-extension-lookup.js?ref=f1fc426cce9db230cb83866871f355afa0b92d3b",
            "patch": "@@ -5,3 +5,5 @@ const { execFileSync } = require('child_process');\n const node = process.argv[0];\n \n execFileSync(node, ['--experimental-modules', 'test/es-module/test-esm-ok']);\n+execFileSync(node, ['--experimental-modules',\n+                    'test/fixtures/es-modules/noext']);"
        }
    ],
    "stats": {
        "total": 345,
        "additions": 208,
        "deletions": 137
    }
}