{
    "author": "indutny",
    "message": "deps: introduce `llhttp`\n\nllhttp is modern, written in human-readable TypeScript, verifiable, and\nis very easy to maintain.\n\nSee: https://github.com/indutny/llhttp\n\nPR-URL: https://github.com/nodejs/node/pull/24059\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Rod Vagg <rod@vagg.org>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>",
    "sha": "d4654d89be0c20f8ca1e153d074a236348618b00",
    "files": [
        {
            "sha": "59958b20e24a066a7c88e806b920a19b5159b5da",
            "filename": "LICENSE",
            "status": "modified",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/LICENSE",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/LICENSE",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/LICENSE?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -606,6 +606,32 @@ The externally maintained libraries used by Node.js are:\n         nÂ° 289016). Three clause BSD license.\n   \"\"\"\n \n+- llhttp, located at deps/llhttp, is licensed as follows:\n+  \"\"\"\n+    This software is licensed under the MIT License.\n+\n+    Copyright Fedor Indutny, 2018.\n+\n+    Permission is hereby granted, free of charge, to any person obtaining a\n+    copy of this software and associated documentation files (the\n+    \"Software\"), to deal in the Software without restriction, including\n+    without limitation the rights to use, copy, modify, merge, publish,\n+    distribute, sublicense, and/or sell copies of the Software, and to permit\n+    persons to whom the Software is furnished to do so, subject to the\n+    following conditions:\n+\n+    The above copyright notice and this permission notice shall be included\n+    in all copies or substantial portions of the Software.\n+\n+    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n+    NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+    OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+    USE OR OTHER DEALINGS IN THE SOFTWARE.\n+  \"\"\"\n+\n - OpenSSL, located at deps/openssl, is licensed as follows:\n   \"\"\"\n     Copyright (c) 1998-2018 The OpenSSL Project.  All rights reserved."
        },
        {
            "sha": "0df8e12bf3a3c384fd6d22517d29bc5cd64bb69e",
            "filename": "configure.py",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/configure.py",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/configure.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/configure.py?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -182,6 +182,11 @@\n     help='Use the specified path to system CA (PEM format) in addition to '\n          'the OpenSSL supplied CA store or compiled-in Mozilla CA copy.')\n \n+parser.add_option('--experimental-http-parser',\n+    action='store_true',\n+    dest='experimental_http_parser',\n+    help='use llhttp instead of http_parser')\n+\n shared_optgroup.add_option('--shared-http-parser',\n     action='store_true',\n     dest='shared_http_parser',\n@@ -1106,6 +1111,9 @@ def configure_node(o):\n   else:\n     o['variables']['node_target_type'] = 'executable'\n \n+  o['variables']['node_experimental_http_parser'] = \\\n+      b(options.experimental_http_parser)\n+\n def configure_library(lib, output):\n   shared_lib = 'shared_' + lib\n   output['variables']['node_' + shared_lib] = b(getattr(options, shared_lib))"
        },
        {
            "sha": "6c1512dd6bcd6de314673f8c2c7ff3fd6139f28e",
            "filename": "deps/llhttp/LICENSE-MIT",
            "status": "added",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2FLICENSE-MIT",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2FLICENSE-MIT",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fllhttp%2FLICENSE-MIT?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -0,0 +1,22 @@\n+This software is licensed under the MIT License.\n+\n+Copyright Fedor Indutny, 2018.\n+\n+Permission is hereby granted, free of charge, to any person obtaining a\n+copy of this software and associated documentation files (the\n+\"Software\"), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to permit\n+persons to whom the Software is furnished to do so, subject to the\n+following conditions:\n+\n+The above copyright notice and this permission notice shall be included\n+in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n+NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+USE OR OTHER DEALINGS IN THE SOFTWARE."
        },
        {
            "sha": "bca973f80d0025e8a67ec27f0e0381e4fca36277",
            "filename": "deps/llhttp/README.md",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2FREADME.md",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2FREADME.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fllhttp%2FREADME.md?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -0,0 +1,129 @@\n+# llhttp\n+[![Build Status](https://secure.travis-ci.org/indutny/llhttp.svg)](http://travis-ci.org/indutny/llhttp)\n+\n+Port of [http_parser][0] to [llparse][1].\n+\n+## Why?\n+\n+Let's face it, [http_parser][0] is practically unmaintainable. Even\n+introduction of a single new method results in a significant code churn.\n+\n+This project aims to:\n+\n+* Make it maintainable\n+* Verifiable\n+* Improving benchmarks where possible\n+\n+## How?\n+\n+Over time, different approaches for improving [http_parser][0]'s code base\n+were tried. However, all of them failed due to resulting significant performance\n+degradation.\n+\n+This project is a port of [http_parser][0] to TypeScript. [llparse][1] is used\n+to generate the output C and/or bitcode artifacts, which could be compiled and\n+linked with the embedder's program (like [Node.js][7]).\n+\n+## Peformance\n+\n+So far llhttp outperforms http_parser:\n+\n+|                 | input size |  bandwidth   |  reqs/sec  |   time  |\n+|:----------------|-----------:|-------------:|-----------:|--------:|\n+| **llhttp** _(C)_ | 8192.00 mb | 1497.88 mb/s | 3020458.87 ops/sec | 5.47 s |\n+| **llhttp** _(bitcode)_ | 8192.00 mb | 1131.75 mb/s | 2282171.24 ops/sec | 7.24 s |\n+| **http_parser** | 8192.00 mb | 694.66 mb/s | 1406180.33 req/sec | 11.79 s |\n+\n+llhttp is faster by approximately **116%**.\n+\n+## Maintenance\n+\n+llhttp project has about 1400 lines of TypeScript code describing the parser\n+itself and around 450 lines of C code and headers providing the helper methods.\n+The whole [http_parser][0] is implemented in approximately 2500 lines of C, and\n+436 lines of headers.\n+\n+All optimizations and multi-character matching in llhttp are generated\n+automatically, and thus doesn't add any extra maintenance cost. On the contrary,\n+most of http_parser's code is hand-optimized and unrolled. Instead describing\n+\"how\" it should parse the HTTP requests/responses, a maintainer should\n+implement the new features in [http_parser][0] cautiously, considering\n+possible performance degradation and manually optimizing the new code.\n+\n+## Verification\n+\n+The state machine graph is encoded explicitly in llhttp. The [llparse][1]\n+automatically checks the graph for absence of loops and correct reporting of the\n+input ranges (spans) like header names and values. In the future, additional\n+checks could be performed to get even stricter verification of the llhttp.\n+\n+## Usage\n+\n+```C\n+#include \"llhttp.h\"\n+\n+llhttp_t parser;\n+llhttp_settings_t settings;\n+\n+/* Initialize user callbacks and settings */\n+llhttp_settings_init(&settings);\n+\n+/* Set user callback */\n+settings.on_message_complete = handle_on_message_complete;\n+\n+/* Initialize the parser in HTTP_BOTH mode, meaning that it will select between\n+ * HTTP_REQUEST and HTTP_RESPONSE parsing automatically while reading the first\n+ * input.\n+ */\n+llhttp_init(&parser, HTTP_BOTH, &settings);\n+\n+/* Use `llhttp_set_type(&parser, HTTP_REQUEST);` to override the mode */\n+\n+/* Parse request! */\n+const char* request = \"GET / HTTP/1.1\\r\\n\\r\\n\";\n+int request_len = strlen(request);\n+\n+enum llhttp_errno err = llhttp_execute(&parser, request, request_len);\n+if (err == HPE_OK) {\n+  /* Successfully parsed! */\n+} else {\n+  fprintf(stderr, \"Parse error: %s %s\\n\", llhttp_errno_name(err),\n+          parser.reason);\n+}\n+```\n+\n+---\n+\n+#### LICENSE\n+\n+This software is licensed under the MIT License.\n+\n+Copyright Fedor Indutny, 2018.\n+\n+Permission is hereby granted, free of charge, to any person obtaining a\n+copy of this software and associated documentation files (the\n+\"Software\"), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to permit\n+persons to whom the Software is furnished to do so, subject to the\n+following conditions:\n+\n+The above copyright notice and this permission notice shall be included\n+in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n+NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+USE OR OTHER DEALINGS IN THE SOFTWARE.\n+\n+[0]: https://github.com/nodejs/http-parser\n+[1]: https://github.com/indutny/llparse\n+[2]: https://en.wikipedia.org/wiki/Register_allocation#Spilling\n+[3]: https://en.wikipedia.org/wiki/Tail_call\n+[4]: https://llvm.org/docs/LangRef.html\n+[5]: https://llvm.org/docs/LangRef.html#call-instruction\n+[6]: https://clang.llvm.org/\n+[7]: https://github.com/nodejs/node"
        },
        {
            "sha": "ef7549f809df265560b2f5c57f8df9d76a63078c",
            "filename": "deps/llhttp/common.gypi",
            "status": "added",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2Fcommon.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2Fcommon.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fllhttp%2Fcommon.gypi?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -0,0 +1,46 @@\n+{\n+  'target_defaults': {\n+    'default_configuration': 'Debug',\n+    'configurations': {\n+      # TODO: hoist these out and put them somewhere common, because\n+      #       RuntimeLibrary MUST MATCH across the entire project\n+      'Debug': {\n+        'defines': [ 'DEBUG', '_DEBUG' ],\n+        'cflags': [ '-Wall', '-Wextra', '-O0', '-g', '-ftrapv' ],\n+        'msvs_settings': {\n+          'VCCLCompilerTool': {\n+            'RuntimeLibrary': 1, # static debug\n+          },\n+        },\n+      },\n+      'Release': {\n+        'defines': [ 'NDEBUG' ],\n+        'cflags': [ '-Wall', '-Wextra', '-O3' ],\n+        'msvs_settings': {\n+          'VCCLCompilerTool': {\n+            'RuntimeLibrary': 0, # static release\n+          },\n+        },\n+      }\n+    },\n+    'msvs_settings': {\n+      'VCCLCompilerTool': {\n+        # Compile as C++. llhttp.c is actually C99, but C++ is\n+        # close enough in this case.\n+        'CompileAs': 2,\n+      },\n+      'VCLibrarianTool': {\n+      },\n+      'VCLinkerTool': {\n+        'GenerateDebugInformation': 'true',\n+      },\n+    },\n+    'conditions': [\n+      ['OS == \"win\"', {\n+        'defines': [\n+          'WIN32'\n+        ],\n+      }]\n+    ],\n+  },\n+}"
        },
        {
            "sha": "c114d11ffa935328a9ac4db7c2df3a956789b71d",
            "filename": "deps/llhttp/include/llhttp.h",
            "status": "added",
            "additions": 353,
            "deletions": 0,
            "changes": 353,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2Finclude%2Fllhttp.h",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2Finclude%2Fllhttp.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fllhttp%2Finclude%2Fllhttp.h?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -0,0 +1,353 @@\n+#ifndef INCLUDE_LLHTTP_H_\n+#define INCLUDE_LLHTTP_H_\n+\n+#define LLHTTP_VERSION_MAJOR 1\n+#define LLHTTP_VERSION_MINOR 0\n+#define LLHTTP_VERSION_PATCH 0\n+\n+#ifndef INCLUDE_LLHTTP_ITSELF_H_\n+#define INCLUDE_LLHTTP_ITSELF_H_\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdint.h>\n+\n+typedef struct llhttp__internal_s llhttp__internal_t;\n+struct llhttp__internal_s {\n+  int32_t _index;\n+  void* _span_pos0;\n+  void* _span_cb0;\n+  int32_t error;\n+  const char* reason;\n+  const char* error_pos;\n+  void* data;\n+  void* _current;\n+  uint64_t content_length;\n+  uint8_t type;\n+  uint8_t method;\n+  uint8_t http_major;\n+  uint8_t http_minor;\n+  uint8_t header_state;\n+  uint8_t flags;\n+  uint8_t upgrade;\n+  uint16_t status_code;\n+  uint8_t finish;\n+  void* settings;\n+};\n+\n+int llhttp__internal_init(llhttp__internal_t* s);\n+int llhttp__internal_execute(llhttp__internal_t* s, const char* p, const char* endp);\n+\n+#ifdef __cplusplus\n+}  /* extern \"C\" */\n+#endif\n+#endif  /* INCLUDE_LLHTTP_ITSELF_H_ */\n+\n+#ifndef LLLLHTTP_C_HEADERS_\n+#define LLLLHTTP_C_HEADERS_\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+enum llhttp_errno {\n+  HPE_OK = 0,\n+  HPE_INTERNAL = 1,\n+  HPE_STRICT = 2,\n+  HPE_LF_EXPECTED = 3,\n+  HPE_UNEXPECTED_CONTENT_LENGTH = 4,\n+  HPE_CLOSED_CONNECTION = 5,\n+  HPE_INVALID_METHOD = 6,\n+  HPE_INVALID_URL = 7,\n+  HPE_INVALID_CONSTANT = 8,\n+  HPE_INVALID_VERSION = 9,\n+  HPE_INVALID_HEADER_TOKEN = 10,\n+  HPE_INVALID_CONTENT_LENGTH = 11,\n+  HPE_INVALID_CHUNK_SIZE = 12,\n+  HPE_INVALID_STATUS = 13,\n+  HPE_INVALID_EOF_STATE = 14,\n+  HPE_CB_MESSAGE_BEGIN = 15,\n+  HPE_CB_HEADERS_COMPLETE = 16,\n+  HPE_CB_MESSAGE_COMPLETE = 17,\n+  HPE_CB_CHUNK_HEADER = 18,\n+  HPE_CB_CHUNK_COMPLETE = 19,\n+  HPE_PAUSED = 20,\n+  HPE_PAUSED_UPGRADE = 21,\n+  HPE_USER = 22\n+};\n+typedef enum llhttp_errno llhttp_errno_t;\n+\n+enum llhttp_flags {\n+  F_CONNECTION_KEEP_ALIVE = 0x1,\n+  F_CONNECTION_CLOSE = 0x2,\n+  F_CONNECTION_UPGRADE = 0x4,\n+  F_CHUNKED = 0x8,\n+  F_UPGRADE = 0x10,\n+  F_CONTENT_LENGTH = 0x20,\n+  F_SKIPBODY = 0x40,\n+  F_TRAILING = 0x80\n+};\n+typedef enum llhttp_flags llhttp_flags_t;\n+\n+enum llhttp_type {\n+  HTTP_BOTH = 0,\n+  HTTP_REQUEST = 1,\n+  HTTP_RESPONSE = 2\n+};\n+typedef enum llhttp_type llhttp_type_t;\n+\n+enum llhttp_finish {\n+  HTTP_FINISH_SAFE = 0,\n+  HTTP_FINISH_SAFE_WITH_CB = 1,\n+  HTTP_FINISH_UNSAFE = 2\n+};\n+typedef enum llhttp_finish llhttp_finish_t;\n+\n+enum llhttp_method {\n+  HTTP_DELETE = 0,\n+  HTTP_GET = 1,\n+  HTTP_HEAD = 2,\n+  HTTP_POST = 3,\n+  HTTP_PUT = 4,\n+  HTTP_CONNECT = 5,\n+  HTTP_OPTIONS = 6,\n+  HTTP_TRACE = 7,\n+  HTTP_COPY = 8,\n+  HTTP_LOCK = 9,\n+  HTTP_MKCOL = 10,\n+  HTTP_MOVE = 11,\n+  HTTP_PROPFIND = 12,\n+  HTTP_PROPPATCH = 13,\n+  HTTP_SEARCH = 14,\n+  HTTP_UNLOCK = 15,\n+  HTTP_BIND = 16,\n+  HTTP_REBIND = 17,\n+  HTTP_UNBIND = 18,\n+  HTTP_ACL = 19,\n+  HTTP_REPORT = 20,\n+  HTTP_MKACTIVITY = 21,\n+  HTTP_CHECKOUT = 22,\n+  HTTP_MERGE = 23,\n+  HTTP_MSEARCH = 24,\n+  HTTP_NOTIFY = 25,\n+  HTTP_SUBSCRIBE = 26,\n+  HTTP_UNSUBSCRIBE = 27,\n+  HTTP_PATCH = 28,\n+  HTTP_PURGE = 29,\n+  HTTP_MKCALENDAR = 30,\n+  HTTP_LINK = 31,\n+  HTTP_UNLINK = 32,\n+  HTTP_SOURCE = 33\n+};\n+typedef enum llhttp_method llhttp_method_t;\n+\n+#define HTTP_ERRNO_MAP(XX) \\\n+  XX(0, OK, OK) \\\n+  XX(1, INTERNAL, INTERNAL) \\\n+  XX(2, STRICT, STRICT) \\\n+  XX(3, LF_EXPECTED, LF_EXPECTED) \\\n+  XX(4, UNEXPECTED_CONTENT_LENGTH, UNEXPECTED_CONTENT_LENGTH) \\\n+  XX(5, CLOSED_CONNECTION, CLOSED_CONNECTION) \\\n+  XX(6, INVALID_METHOD, INVALID_METHOD) \\\n+  XX(7, INVALID_URL, INVALID_URL) \\\n+  XX(8, INVALID_CONSTANT, INVALID_CONSTANT) \\\n+  XX(9, INVALID_VERSION, INVALID_VERSION) \\\n+  XX(10, INVALID_HEADER_TOKEN, INVALID_HEADER_TOKEN) \\\n+  XX(11, INVALID_CONTENT_LENGTH, INVALID_CONTENT_LENGTH) \\\n+  XX(12, INVALID_CHUNK_SIZE, INVALID_CHUNK_SIZE) \\\n+  XX(13, INVALID_STATUS, INVALID_STATUS) \\\n+  XX(14, INVALID_EOF_STATE, INVALID_EOF_STATE) \\\n+  XX(15, CB_MESSAGE_BEGIN, CB_MESSAGE_BEGIN) \\\n+  XX(16, CB_HEADERS_COMPLETE, CB_HEADERS_COMPLETE) \\\n+  XX(17, CB_MESSAGE_COMPLETE, CB_MESSAGE_COMPLETE) \\\n+  XX(18, CB_CHUNK_HEADER, CB_CHUNK_HEADER) \\\n+  XX(19, CB_CHUNK_COMPLETE, CB_CHUNK_COMPLETE) \\\n+  XX(20, PAUSED, PAUSED) \\\n+  XX(21, PAUSED_UPGRADE, PAUSED_UPGRADE) \\\n+  XX(22, USER, USER) \\\n+\n+\n+#define HTTP_METHOD_MAP(XX) \\\n+  XX(0, DELETE, DELETE) \\\n+  XX(1, GET, GET) \\\n+  XX(2, HEAD, HEAD) \\\n+  XX(3, POST, POST) \\\n+  XX(4, PUT, PUT) \\\n+  XX(5, CONNECT, CONNECT) \\\n+  XX(6, OPTIONS, OPTIONS) \\\n+  XX(7, TRACE, TRACE) \\\n+  XX(8, COPY, COPY) \\\n+  XX(9, LOCK, LOCK) \\\n+  XX(10, MKCOL, MKCOL) \\\n+  XX(11, MOVE, MOVE) \\\n+  XX(12, PROPFIND, PROPFIND) \\\n+  XX(13, PROPPATCH, PROPPATCH) \\\n+  XX(14, SEARCH, SEARCH) \\\n+  XX(15, UNLOCK, UNLOCK) \\\n+  XX(16, BIND, BIND) \\\n+  XX(17, REBIND, REBIND) \\\n+  XX(18, UNBIND, UNBIND) \\\n+  XX(19, ACL, ACL) \\\n+  XX(20, REPORT, REPORT) \\\n+  XX(21, MKACTIVITY, MKACTIVITY) \\\n+  XX(22, CHECKOUT, CHECKOUT) \\\n+  XX(23, MERGE, MERGE) \\\n+  XX(24, MSEARCH, M-SEARCH) \\\n+  XX(25, NOTIFY, NOTIFY) \\\n+  XX(26, SUBSCRIBE, SUBSCRIBE) \\\n+  XX(27, UNSUBSCRIBE, UNSUBSCRIBE) \\\n+  XX(28, PATCH, PATCH) \\\n+  XX(29, PURGE, PURGE) \\\n+  XX(30, MKCALENDAR, MKCALENDAR) \\\n+  XX(31, LINK, LINK) \\\n+  XX(32, UNLINK, UNLINK) \\\n+  XX(33, SOURCE, SOURCE) \\\n+\n+\n+\n+#ifdef __cplusplus\n+}  /* extern \"C\" */\n+#endif\n+#endif  /* LLLLHTTP_C_HEADERS_ */\n+\n+#ifndef INCLUDE_LLHTTP_API_H_\n+#define INCLUDE_LLHTTP_API_H_\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef llhttp__internal_t llhttp_t;\n+typedef struct llhttp_settings_s llhttp_settings_t;\n+\n+typedef int (*llhttp_data_cb)(llhttp_t*, const char *at, size_t length);\n+typedef int (*llhttp_cb)(llhttp_t*);\n+\n+struct llhttp_settings_s {\n+  /* Possible return values 0, -1, `HPE_PAUSED` */\n+  llhttp_cb      on_message_begin;\n+\n+  llhttp_data_cb on_url;\n+  llhttp_data_cb on_status;\n+  llhttp_data_cb on_header_field;\n+  llhttp_data_cb on_header_value;\n+\n+  /* Possible return values:\n+   * 0  - Proceed normally\n+   * 1  - Assume that request/response has no body, and proceed to parsing the\n+   *      next message\n+   * 2  - Assume absence of body (as above) and make `llhttp_execute()` return\n+   *      `HPE_PAUSED_UPGRADE`\n+   * -1 - Error\n+   * `HPE_PAUSED`\n+   */\n+  llhttp_cb      on_headers_complete;\n+\n+  llhttp_data_cb on_body;\n+\n+  /* Possible return values 0, -1, `HPE_PAUSED` */\n+  llhttp_cb      on_message_complete;\n+\n+  /* When on_chunk_header is called, the current chunk length is stored\n+   * in parser->content_length.\n+   * Possible return values 0, -1, `HPE_PAUSED`\n+   */\n+  llhttp_cb      on_chunk_header;\n+  llhttp_cb      on_chunk_complete;\n+};\n+\n+/* Initialize the parser with specific type and user settings */\n+void llhttp_init(llhttp_t* parser, llhttp_type_t type,\n+                 const llhttp_settings_t* settings);\n+\n+/* Initialize the settings object */\n+void llhttp_settings_init(llhttp_settings_t* settings);\n+\n+/* Parse full or partial request/response, invoking user callbacks along the\n+ * way.\n+ *\n+ * If any of `llhttp_data_cb` returns errno not equal to `HPE_OK` - the parsing\n+ * interrupts, and such errno is returned from `llhttp_execute()`. If\n+ * `HPE_PAUSED` was used as a errno, the execution can be resumed with\n+ * `llhttp_resume()` call.\n+ *\n+ * In a special case of CONNECT/Upgrade request/response `HPE_PAUSED_UPGRADE`\n+ * is returned after fully parsing the request/response. If the user wishes to\n+ * continue parsing, they need to invoke `llhttp_resume_after_upgrade()`.\n+ */\n+llhttp_errno_t llhttp_execute(llhttp_t* parser, const char* data, size_t len);\n+\n+/* This method should be called when the other side has no further bytes to\n+ * send (e.g. shutdown of readable side of the TCP connection.)\n+ *\n+ * Requests without `Content-Length` and other messages might require treating\n+ * all incoming bytes as the part of the body, up to the last byte of the\n+ * connection. This method will invoke `on_message_complete()` callback if the\n+ * request was terminated safely. Otherwise a error code would be returned.\n+ */\n+llhttp_errno_t llhttp_finish(llhttp_t* parser);\n+\n+/* Returns `1` if the incoming message is parsed until the last byte, and has\n+ * to be completed by calling `llhttp_finish()` on EOF\n+ */\n+int llhttp_message_needs_eof(const llhttp_t* parser);\n+\n+/* Returns `1` if there might be any other messages following the last that was\n+ * successfuly parsed.\n+ */\n+int llhttp_should_keep_alive(const llhttp_t* parser);\n+\n+/* Make further calls of `llhttp_execute()` return `HPE_PAUSED` and set\n+ * appropriate error reason.\n+ *\n+ * Important: do not call this from user callbacks! User callbacks must return\n+ * `HPE_PAUSED` if pausing is required.\n+ */\n+void llhttp_pause(llhttp_t* parser);\n+\n+/* Might be called to resume the execution after the pause in user's callback.\n+ * See `llhttp_execute()` above for details.\n+ *\n+ * Call this only if `llhttp_execute()` returns `HPE_PAUSED`.\n+ */\n+void llhttp_resume(llhttp_t* parser);\n+\n+/* Might be called to resume the execution after the pause in user's callback.\n+ * See `llhttp_execute()` above for details.\n+ *\n+ * Call this only if `llhttp_execute()` returns `HPE_PAUSED_UPGRADE`\n+ */\n+void llhttp_resume_after_upgrade(llhttp_t* parser);\n+\n+/* Returns the latest return error */\n+llhttp_errno_t llhttp_get_errno(const llhttp_t* parser);\n+\n+/* Returns the verbal explanation of the latest returned error.\n+ *\n+ * Note: User callback should set error reason when returning the error. See\n+ * `llhttp_set_error_reason()` for details.\n+ */\n+const char* llhttp_get_error_reason(const llhttp_t* parser);\n+\n+/* Assign verbal description to the returned error. Must be called in user\n+ * callbacks right before returning the errno.\n+ *\n+ * Note: `HPE_USER` error code might be useful in user callbacks.\n+ */\n+void llhttp_set_error_reason(llhttp_t* parser, const char* reason);\n+\n+/* Returns the pointer to the last parsed byte before the returned error. The\n+ * pointer is relative to the `data` argument of `llhttp_execute()`.\n+ *\n+ * Note: this method might be useful for counting the number of parsed bytes.\n+ */\n+const char* llhttp_get_error_pos(const llhttp_t* parser);\n+\n+/* Returns textual name of error code */\n+const char* llhttp_errno_name(llhttp_errno_t err);\n+\n+#ifdef __cplusplus\n+}  /* extern \"C\" */\n+#endif\n+#endif  /* INCLUDE_LLHTTP_API_H_ */\n+\n+#endif  /* INCLUDE_LLHTTP_H_ */"
        },
        {
            "sha": "4acc79bdf399fc95410ec350c3e175ef53088b38",
            "filename": "deps/llhttp/llhttp.gyp",
            "status": "added",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2Fllhttp.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2Fllhttp.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fllhttp%2Fllhttp.gyp?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -0,0 +1,13 @@\n+{\n+  'targets': [\n+    {\n+      'target_name': 'llhttp',\n+      'type': 'static_library',\n+      'include_dirs': [ '.', 'include' ],\n+      'direct_dependent_settings': {\n+        'include_dirs': [ 'include' ],\n+      },\n+      'sources': [ 'src/llhttp.c', 'src/api.c', 'src/http.c' ],\n+    },\n+  ]\n+}"
        },
        {
            "sha": "37a5dcd183e0f6d5512d1c4242a2f5829c6088e3",
            "filename": "deps/llhttp/src/api.c",
            "status": "added",
            "additions": 205,
            "deletions": 0,
            "changes": 205,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2Fsrc%2Fapi.c",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2Fsrc%2Fapi.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fllhttp%2Fsrc%2Fapi.c?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -0,0 +1,205 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"llhttp.h\"\n+\n+#define CALLBACK_MAYBE(PARSER, NAME, ...)                                     \\\n+  do {                                                                        \\\n+    llhttp_settings_t* settings;                                              \\\n+    settings = (llhttp_settings_t*) (PARSER)->settings;                       \\\n+    if (settings == NULL || settings->NAME == NULL) {                         \\\n+      err = 0;                                                                \\\n+      break;                                                                  \\\n+    }                                                                         \\\n+    err = settings->NAME(__VA_ARGS__);                                        \\\n+  } while (0)\n+\n+void llhttp_init(llhttp_t* parser, llhttp_type_t type,\n+                 const llhttp_settings_t* settings) {\n+  llhttp__internal_init(parser);\n+\n+  parser->type = type;\n+  parser->settings = (void*) settings;\n+}\n+\n+\n+llhttp_errno_t llhttp_execute(llhttp_t* parser, const char* data, size_t len) {\n+  return llhttp__internal_execute(parser, data, data + len);\n+}\n+\n+\n+void llhttp_settings_init(llhttp_settings_t* settings) {\n+  memset(settings, 0, sizeof(*settings));\n+}\n+\n+\n+llhttp_errno_t llhttp_finish(llhttp_t* parser) {\n+  int err;\n+\n+  /* We're in an error state. Don't bother doing anything. */\n+  if (parser->error != 0) {\n+    return 0;\n+  }\n+\n+  switch (parser->finish) {\n+    case HTTP_FINISH_SAFE_WITH_CB:\n+      CALLBACK_MAYBE(parser, on_message_complete, parser);\n+      if (err != HPE_OK) return err;\n+\n+    /* FALLTHROUGH */\n+    case HTTP_FINISH_SAFE:\n+      return HPE_OK;\n+    case HTTP_FINISH_UNSAFE:\n+      parser->reason = \"Invalid EOF state\";\n+      return HPE_INVALID_EOF_STATE;\n+    default:\n+      abort();\n+  }\n+}\n+\n+\n+void llhttp_pause(llhttp_t* parser) {\n+  if (parser->error != HPE_OK) {\n+    return;\n+  }\n+\n+  parser->error = HPE_PAUSED;\n+  parser->reason = \"Paused\";\n+}\n+\n+\n+void llhttp_resume(llhttp_t* parser) {\n+  if (parser->error != HPE_PAUSED) {\n+    return;\n+  }\n+\n+  parser->error = 0;\n+}\n+\n+\n+void llhttp_resume_after_upgrade(llhttp_t* parser) {\n+  if (parser->error != HPE_PAUSED_UPGRADE) {\n+    return;\n+  }\n+\n+  parser->error = 0;\n+}\n+\n+\n+llhttp_errno_t llhttp_get_errno(const llhttp_t* parser) {\n+  return parser->error;\n+}\n+\n+\n+const char* llhttp_get_error_reason(const llhttp_t* parser) {\n+  return parser->reason;\n+}\n+\n+\n+void llhttp_set_error_reason(llhttp_t* parser, const char* reason) {\n+  parser->reason = reason;\n+}\n+\n+\n+const char* llhttp_get_error_pos(const llhttp_t* parser) {\n+  return parser->error_pos;\n+}\n+\n+\n+const char* llhttp_errno_name(llhttp_errno_t err) {\n+#define HTTP_ERRNO_GEN(CODE, NAME, _) case HPE_##NAME: return \"HPE_\" #NAME;\n+  switch (err) {\n+    HTTP_ERRNO_MAP(HTTP_ERRNO_GEN)\n+    default: abort();\n+  }\n+#undef HTTP_ERRNO_GEN\n+}\n+\n+\n+/* Callbacks */\n+\n+\n+int llhttp__on_message_begin(llhttp_t* s, const char* p, const char* endp) {\n+  int err;\n+  CALLBACK_MAYBE(s, on_message_begin, s);\n+  return err;\n+}\n+\n+\n+int llhttp__on_url(llhttp_t* s, const char* p, const char* endp) {\n+  int err;\n+  CALLBACK_MAYBE(s, on_url, s, p, endp - p);\n+  return err;\n+}\n+\n+\n+int llhttp__on_status(llhttp_t* s, const char* p, const char* endp) {\n+  int err;\n+  CALLBACK_MAYBE(s, on_status, s, p, endp - p);\n+  return err;\n+}\n+\n+\n+int llhttp__on_header_field(llhttp_t* s, const char* p, const char* endp) {\n+  int err;\n+  CALLBACK_MAYBE(s, on_header_field, s, p, endp - p);\n+  return err;\n+}\n+\n+\n+int llhttp__on_header_value(llhttp_t* s, const char* p, const char* endp) {\n+  int err;\n+  CALLBACK_MAYBE(s, on_header_value, s, p, endp - p);\n+  return err;\n+}\n+\n+\n+int llhttp__on_headers_complete(llhttp_t* s, const char* p, const char* endp) {\n+  int err;\n+  CALLBACK_MAYBE(s, on_headers_complete, s);\n+  return err;\n+}\n+\n+\n+int llhttp__on_message_complete(llhttp_t* s, const char* p, const char* endp) {\n+  int err;\n+  CALLBACK_MAYBE(s, on_message_complete, s);\n+  return err;\n+}\n+\n+\n+int llhttp__on_body(llhttp_t* s, const char* p, const char* endp) {\n+  int err;\n+  CALLBACK_MAYBE(s, on_body, s, p, endp - p);\n+  return err;\n+}\n+\n+\n+int llhttp__on_chunk_header(llhttp_t* s, const char* p, const char* endp) {\n+  int err;\n+  CALLBACK_MAYBE(s, on_chunk_header, s);\n+  return err;\n+}\n+\n+\n+int llhttp__on_chunk_complete(llhttp_t* s, const char* p, const char* endp) {\n+  int err;\n+  CALLBACK_MAYBE(s, on_chunk_complete, s);\n+  return err;\n+}\n+\n+\n+/* Private */\n+\n+\n+void llhttp__debug(llhttp_t* s, const char* p, const char* endp,\n+                   const char* msg) {\n+  if (p == endp) {\n+    fprintf(stderr, \"p=%p type=%d flags=%02x next=null debug=%s\\n\", s, s->type,\n+            s->flags, msg);\n+  } else {\n+    fprintf(stderr, \"p=%p type=%d flags=%02x next=%02x   debug=%s\\n\", s,\n+            s->type, s->flags, *p, msg);\n+  }\n+}"
        },
        {
            "sha": "67834c2d377c49bc7ac89bf9bf7b3dc86b5ccea4",
            "filename": "deps/llhttp/src/http.c",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2Fsrc%2Fhttp.c",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2Fsrc%2Fhttp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fllhttp%2Fsrc%2Fhttp.c?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -0,0 +1,120 @@\n+#include <stdio.h>\n+#ifndef LLHTTP__TEST\n+# include \"llhttp.h\"\n+#else\n+# define llhttp_t llparse_t\n+#endif  /* */\n+\n+int llhttp_message_needs_eof(const llhttp_t* parser);\n+int llhttp_should_keep_alive(const llhttp_t* parser);\n+\n+int llhttp__before_headers_complete(llhttp_t* parser, const char* p,\n+                                    const char* endp) {\n+  /* Set this here so that on_headers_complete() callbacks can see it */\n+  if ((parser->flags & F_UPGRADE) &&\n+      (parser->flags & F_CONNECTION_UPGRADE)) {\n+    /* For responses, \"Upgrade: foo\" and \"Connection: upgrade\" are\n+     * mandatory only when it is a 101 Switching Protocols response,\n+     * otherwise it is purely informational, to announce support.\n+     */\n+    parser->upgrade =\n+        (parser->type == HTTP_REQUEST || parser->status_code == 101);\n+  } else {\n+    parser->upgrade = (parser->method == HTTP_CONNECT);\n+  }\n+  return 0;\n+}\n+\n+\n+/* Return values:\n+ * 0 - No body, `restart`, message_complete\n+ * 1 - CONNECT request, `restart`, message_complete, and pause\n+ * 2 - chunk_size_start\n+ * 3 - body_identity\n+ * 4 - body_identity_eof\n+ */\n+int llhttp__after_headers_complete(llhttp_t* parser, const char* p,\n+                                   const char* endp) {\n+  int hasBody;\n+\n+  hasBody = parser->flags & F_CHUNKED || parser->content_length > 0;\n+  if (parser->upgrade && (parser->method == HTTP_CONNECT ||\n+                          (parser->flags & F_SKIPBODY) || !hasBody)) {\n+    /* Exit, the rest of the message is in a different protocol. */\n+    return 1;\n+  }\n+\n+  if (parser->flags & F_SKIPBODY) {\n+    return 0;\n+  } else if (parser->flags & F_CHUNKED) {\n+    /* chunked encoding - ignore Content-Length header */\n+    return 2;\n+  } else {\n+    if (!(parser->flags & F_CONTENT_LENGTH)) {\n+      if (!llhttp_message_needs_eof(parser)) {\n+        /* Assume content-length 0 - read the next */\n+        return 0;\n+      } else {\n+        /* Read body until EOF */\n+        return 4;\n+      }\n+    } else if (parser->content_length == 0) {\n+      /* Content-Length header given but zero: Content-Length: 0\\r\\n */\n+      return 0;\n+    } else {\n+      /* Content-Length header given and non-zero */\n+      return 3;\n+    }\n+  }\n+}\n+\n+\n+int llhttp__after_message_complete(llhttp_t* parser, const char* p,\n+                                   const char* endp) {\n+  int should_keep_alive;\n+\n+  should_keep_alive = llhttp_should_keep_alive(parser);\n+  parser->flags = 0;\n+  parser->finish = HTTP_FINISH_SAFE;\n+\n+  /* NOTE: this is ignored in loose parsing mode */\n+  return should_keep_alive;\n+}\n+\n+\n+int llhttp_message_needs_eof(const llhttp_t* parser) {\n+  if (parser->type == HTTP_REQUEST) {\n+    return 0;\n+  }\n+\n+  /* See RFC 2616 section 4.4 */\n+  if (parser->status_code / 100 == 1 || /* 1xx e.g. Continue */\n+      parser->status_code == 204 ||     /* No Content */\n+      parser->status_code == 304 ||     /* Not Modified */\n+      (parser->flags & F_SKIPBODY)) {     /* response to a HEAD request */\n+    return 0;\n+  }\n+\n+  if (parser->flags & (F_CHUNKED | F_CONTENT_LENGTH)) {\n+    return 0;\n+  }\n+\n+  return 1;\n+}\n+\n+\n+int llhttp_should_keep_alive(const llhttp_t* parser) {\n+  if (parser->http_major > 0 && parser->http_minor > 0) {\n+    /* HTTP/1.1 */\n+    if (parser->flags & F_CONNECTION_CLOSE) {\n+      return 0;\n+    }\n+  } else {\n+    /* HTTP/1.0 or earlier */\n+    if (!(parser->flags & F_CONNECTION_KEEP_ALIVE)) {\n+      return 0;\n+    }\n+  }\n+\n+  return !llhttp_message_needs_eof(parser);\n+}"
        },
        {
            "sha": "cb12c8dfd0f1824f6175340707e7bf1a6a48b240",
            "filename": "deps/llhttp/src/llhttp.c",
            "status": "added",
            "additions": 6044,
            "deletions": 0,
            "changes": 6044,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2Fsrc%2Fllhttp.c",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/deps%2Fllhttp%2Fsrc%2Fllhttp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fllhttp%2Fsrc%2Fllhttp.c?ref=d4654d89be0c20f8ca1e153d074a236348618b00"
        },
        {
            "sha": "83bd412dea6c9de54621b79f67f3f257d5563b24",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -12,6 +12,7 @@\n     'force_dynamic_crt%': 0,\n     'node_module_version%': '',\n     'node_shared_zlib%': 'false',\n+    'node_experimental_http_parser%': 'false',\n     'node_shared_http_parser%': 'false',\n     'node_shared_cares%': 'false',\n     'node_shared_libuv%': 'false',"
        },
        {
            "sha": "fdf81b7465b906680354368583faf716d70603f8",
            "filename": "node.gypi",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/node.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/node.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gypi?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -163,9 +163,14 @@\n       ],\n     }],\n \n-    [ 'node_shared_http_parser==\"false\"', {\n-      'dependencies': [ 'deps/http_parser/http_parser.gyp:http_parser' ],\n-    }],\n+    [ 'node_experimental_http_parser==\"true\"', {\n+      'defines': [ 'NODE_EXPERIMENTAL_HTTP' ],\n+      'dependencies': [ 'deps/llhttp/llhttp.gyp:llhttp' ],\n+    }, {\n+      'conditions': [ [ 'node_shared_http_parser==\"false\"', {\n+        'dependencies': [ 'deps/http_parser/http_parser.gyp:http_parser' ],\n+      } ] ],\n+    } ],\n \n     [ 'node_shared_cares==\"false\"', {\n       'dependencies': [ 'deps/cares/cares.gyp:cares' ],"
        },
        {
            "sha": "aec2f8fde402139c92d2cb90b428a27beb54c50e",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -265,6 +265,7 @@ constexpr size_t kFsStatsBufferLength = kFsStatsFieldsNumber * 2;\n   V(raw_string, \"raw\")                                                        \\\n   V(read_host_object_string, \"_readHostObject\")                               \\\n   V(readable_string, \"readable\")                                              \\\n+  V(reason_string, \"reason\")                                                  \\\n   V(refresh_string, \"refresh\")                                                \\\n   V(regexp_string, \"regexp\")                                                  \\\n   V(rename_string, \"rename\")                                                  \\"
        },
        {
            "sha": "6d786bd09519b5d40705d1c9ff9fd012adb3d45d",
            "filename": "src/http_parser_adaptor.h",
            "status": "added",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/src%2Fhttp_parser_adaptor.h",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/src%2Fhttp_parser_adaptor.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fhttp_parser_adaptor.h?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -0,0 +1,24 @@\n+#ifndef SRC_HTTP_PARSER_ADAPTOR_H_\n+#define SRC_HTTP_PARSER_ADAPTOR_H_\n+\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+# include \"llhttp.h\"\n+\n+typedef llhttp_type_t parser_type_t;\n+typedef llhttp_errno_t parser_errno_t;\n+typedef llhttp_settings_t parser_settings_t;\n+typedef llhttp_t parser_t;\n+\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n+# include \"http_parser.h\"\n+\n+typedef enum http_parser_type parser_type_t;\n+typedef enum http_errno parser_errno_t;\n+typedef http_parser_settings parser_settings_t;\n+typedef http_parser parser_t;\n+\n+#define HPE_USER HPE_UNKNOWN\n+\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n+\n+#endif  /* SRC_HTTP_PARSER_ADAPTOR_H_ */"
        },
        {
            "sha": "8c2d0a5a22da28124d2d813aaa5960295b51986c",
            "filename": "src/inspector_socket.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 9,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/src%2Finspector_socket.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/src%2Finspector_socket.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_socket.cc?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -1,6 +1,6 @@\n #include \"inspector_socket.h\"\n \n-#include \"http_parser.h\"\n+#include \"http_parser_adaptor.h\"\n #include \"util-inl.h\"\n \n #define NODE_WANT_INTERNALS 1\n@@ -433,8 +433,13 @@ class HttpHandler : public ProtocolHandler {\n   explicit HttpHandler(InspectorSocket* inspector, TcpHolder::Pointer tcp)\n                        : ProtocolHandler(inspector, std::move(tcp)),\n                          parsing_value_(false) {\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+    llhttp_init(&parser_, HTTP_REQUEST, &parser_settings);\n+    llhttp_settings_init(&parser_settings);\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n     http_parser_init(&parser_, HTTP_REQUEST);\n     http_parser_settings_init(&parser_settings);\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n     parser_settings.on_header_field = OnHeaderField;\n     parser_settings.on_header_value = OnHeaderValue;\n     parser_settings.on_message_complete = OnMessageComplete;\n@@ -478,9 +483,20 @@ class HttpHandler : public ProtocolHandler {\n   }\n \n   void OnData(std::vector<char>* data) override {\n+    parser_errno_t err;\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+    err = llhttp_execute(&parser_, data->data(), data->size());\n+\n+    if (err == HPE_PAUSED_UPGRADE) {\n+      err = HPE_OK;\n+      llhttp_resume_after_upgrade(&parser_);\n+    }\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n     http_parser_execute(&parser_, &parser_settings, data->data(), data->size());\n+    err = HTTP_PARSER_ERRNO(&parser_);\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n     data->clear();\n-    if (parser_.http_errno != HPE_OK) {\n+    if (err != HPE_OK) {\n       CancelHandshake();\n     }\n     // Event handling may delete *this\n@@ -517,14 +533,14 @@ class HttpHandler : public ProtocolHandler {\n     handler->inspector()->SwitchProtocol(nullptr);\n   }\n \n-  static int OnHeaderValue(http_parser* parser, const char* at, size_t length) {\n+  static int OnHeaderValue(parser_t* parser, const char* at, size_t length) {\n     HttpHandler* handler = From(parser);\n     handler->parsing_value_ = true;\n     handler->headers_[handler->current_header_].append(at, length);\n     return 0;\n   }\n \n-  static int OnHeaderField(http_parser* parser, const char* at, size_t length) {\n+  static int OnHeaderField(parser_t* parser, const char* at, size_t length) {\n     HttpHandler* handler = From(parser);\n     if (handler->parsing_value_) {\n       handler->parsing_value_ = false;\n@@ -534,17 +550,17 @@ class HttpHandler : public ProtocolHandler {\n     return 0;\n   }\n \n-  static int OnPath(http_parser* parser, const char* at, size_t length) {\n+  static int OnPath(parser_t* parser, const char* at, size_t length) {\n     HttpHandler* handler = From(parser);\n     handler->path_.append(at, length);\n     return 0;\n   }\n \n-  static HttpHandler* From(http_parser* parser) {\n+  static HttpHandler* From(parser_t* parser) {\n     return node::ContainerOf(&HttpHandler::parser_, parser);\n   }\n \n-  static int OnMessageComplete(http_parser* parser) {\n+  static int OnMessageComplete(parser_t* parser) {\n     // Event needs to be fired after the parser is done.\n     HttpHandler* handler = From(parser);\n     handler->events_.push_back(\n@@ -581,8 +597,8 @@ class HttpHandler : public ProtocolHandler {\n   }\n \n   bool parsing_value_;\n-  http_parser parser_;\n-  http_parser_settings parser_settings;\n+  parser_t parser_;\n+  parser_settings_t parser_settings;\n   std::vector<HttpEvent> events_;\n   std::string current_header_;\n   std::map<std::string, std::string> headers_;"
        },
        {
            "sha": "0ee788460e8934acad2a95c0ad4097f15a298a2b",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 33,
            "deletions": 13,
            "changes": 46,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -53,7 +53,11 @@\n #include \"async_wrap-inl.h\"\n #include \"env-inl.h\"\n #include \"handle_wrap.h\"\n-#include \"http_parser.h\"\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+# include \"llhttp.h\"\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n+# include \"http_parser.h\"\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n #include \"nghttp2/nghttp2ver.h\"\n #include \"req_wrap-inl.h\"\n #include \"string_bytes.h\"\n@@ -179,6 +183,22 @@ static node_module* modlist_internal;\n static node_module* modlist_linked;\n static node_module* modlist_addon;\n \n+#ifdef NODE_EXPERIMENTAL_HTTP\n+static const char llhttp_version[] =\n+    NODE_STRINGIFY(LLHTTP_VERSION_MAJOR)\n+    \".\"\n+    NODE_STRINGIFY(LLHTTP_VERSION_MINOR)\n+    \".\"\n+    NODE_STRINGIFY(LLHTTP_VERSION_PATCH);\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n+static const char http_parser_version[] =\n+    NODE_STRINGIFY(HTTP_PARSER_VERSION_MAJOR)\n+    \".\"\n+    NODE_STRINGIFY(HTTP_PARSER_VERSION_MINOR)\n+    \".\"\n+    NODE_STRINGIFY(HTTP_PARSER_VERSION_PATCH);\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n+\n // Bit flag used to track security reverts (see node_revert.h)\n unsigned int reverted = 0;\n \n@@ -217,17 +237,15 @@ class NodeTraceStateObserver :\n     auto trace_process = tracing::TracedValue::Create();\n     trace_process->BeginDictionary(\"versions\");\n \n-    const char http_parser_version[] =\n-        NODE_STRINGIFY(HTTP_PARSER_VERSION_MAJOR)\n-        \".\"\n-        NODE_STRINGIFY(HTTP_PARSER_VERSION_MINOR)\n-        \".\"\n-        NODE_STRINGIFY(HTTP_PARSER_VERSION_PATCH);\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+    trace_process->SetString(\"llhttp\", llhttp_version);\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n+    trace_process->SetString(\"http_parser\", http_parser_version);\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n \n     const char node_napi_version[] = NODE_STRINGIFY(NAPI_VERSION);\n     const char node_modules_version[] = NODE_STRINGIFY(NODE_MODULE_VERSION);\n \n-    trace_process->SetString(\"http_parser\", http_parser_version);\n     trace_process->SetString(\"node\", NODE_VERSION_STRING);\n     trace_process->SetString(\"v8\", V8::GetVersion());\n     trace_process->SetString(\"uv\", uv_version_string());\n@@ -1344,14 +1362,16 @@ void SetupProcessObject(Environment* env,\n   Local<Object> versions = Object::New(env->isolate());\n   READONLY_PROPERTY(process, \"versions\", versions);\n \n-  const char http_parser_version[] = NODE_STRINGIFY(HTTP_PARSER_VERSION_MAJOR)\n-                                     \".\"\n-                                     NODE_STRINGIFY(HTTP_PARSER_VERSION_MINOR)\n-                                     \".\"\n-                                     NODE_STRINGIFY(HTTP_PARSER_VERSION_PATCH);\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+  READONLY_PROPERTY(versions,\n+                    \"llhttp\",\n+                    FIXED_ONE_BYTE_STRING(env->isolate(), llhttp_version));\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n   READONLY_PROPERTY(versions,\n                     \"http_parser\",\n                     FIXED_ONE_BYTE_STRING(env->isolate(), http_parser_version));\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n+\n   // +1 to get rid of the leading 'v'\n   READONLY_PROPERTY(versions,\n                     \"node\","
        },
        {
            "sha": "482c7263ca719c9bfdf22644d26a7d5812977e8d",
            "filename": "src/node_http_parser.cc",
            "status": "modified",
            "additions": 183,
            "deletions": 46,
            "changes": 229,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/src%2Fnode_http_parser.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/src%2Fnode_http_parser.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http_parser.cc?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -25,14 +25,15 @@\n \n #include \"async_wrap-inl.h\"\n #include \"env-inl.h\"\n-#include \"http_parser.h\"\n #include \"stream_base-inl.h\"\n #include \"util-inl.h\"\n #include \"v8.h\"\n \n #include <stdlib.h>  // free()\n #include <string.h>  // strdup()\n \n+#include \"http_parser_adaptor.h\"\n+\n // This is a binding to http_parser (https://github.com/nodejs/http-parser)\n // The goal is to decouple sockets from parsing for more javascript-level\n // agility. A Buffer is read from a socket and passed to parser.execute().\n@@ -148,7 +149,7 @@ struct StringPtr {\n \n class Parser : public AsyncWrap, public StreamListener {\n  public:\n-  Parser(Environment* env, Local<Object> wrap, enum http_parser_type type)\n+  Parser(Environment* env, Local<Object> wrap, parser_type_t type)\n       : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_HTTPPARSER),\n         current_buffer_len_(0),\n         current_buffer_data_(nullptr) {\n@@ -172,18 +173,33 @@ class Parser : public AsyncWrap, public StreamListener {\n \n \n   int on_url(const char* at, size_t length) {\n+    int rv = TrackHeader(length);\n+    if (rv != 0) {\n+      return rv;\n+    }\n+\n     url_.Update(at, length);\n     return 0;\n   }\n \n \n   int on_status(const char* at, size_t length) {\n+    int rv = TrackHeader(length);\n+    if (rv != 0) {\n+      return rv;\n+    }\n+\n     status_message_.Update(at, length);\n     return 0;\n   }\n \n \n   int on_header_field(const char* at, size_t length) {\n+    int rv = TrackHeader(length);\n+    if (rv != 0) {\n+      return rv;\n+    }\n+\n     if (num_fields_ == num_values_) {\n       // start of new field name\n       num_fields_++;\n@@ -206,6 +222,11 @@ class Parser : public AsyncWrap, public StreamListener {\n \n \n   int on_header_value(const char* at, size_t length) {\n+    int rv = TrackHeader(length);\n+    if (rv != 0) {\n+      return rv;\n+    }\n+\n     if (num_values_ != num_fields_) {\n       // start of new header value\n       num_values_++;\n@@ -222,6 +243,10 @@ class Parser : public AsyncWrap, public StreamListener {\n \n \n   int on_headers_complete() {\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+    header_nread_ = 0;\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n+\n     // Arguments for the on-headers-complete javascript callback. This\n     // list needs to be kept in sync with the actual argument list for\n     // `parserOnHeadersComplete` in lib/_http_common.js.\n@@ -279,8 +304,15 @@ class Parser : public AsyncWrap, public StreamListener {\n     argv[A_VERSION_MAJOR] = Integer::New(env()->isolate(), parser_.http_major);\n     argv[A_VERSION_MINOR] = Integer::New(env()->isolate(), parser_.http_minor);\n \n+    bool should_keep_alive;\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+    should_keep_alive = llhttp_should_keep_alive(&parser_);\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n+    should_keep_alive = http_should_keep_alive(&parser_);\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n+\n     argv[A_SHOULD_KEEP_ALIVE] =\n-        Boolean::New(env()->isolate(), http_should_keep_alive(&parser_));\n+        Boolean::New(env()->isolate(), should_keep_alive);\n \n     argv[A_UPGRADE] = Boolean::New(env()->isolate(), parser_.upgrade);\n \n@@ -332,7 +364,10 @@ class Parser : public AsyncWrap, public StreamListener {\n \n     if (r.IsEmpty()) {\n       got_exception_ = true;\n-      return -1;\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+      llhttp_set_error_reason(&parser_, \"JS Exception\");\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n+      return HPE_USER;\n     }\n \n     return 0;\n@@ -357,18 +392,33 @@ class Parser : public AsyncWrap, public StreamListener {\n \n     if (r.IsEmpty()) {\n       got_exception_ = true;\n-      return -1;\n+      return HPE_USER;\n     }\n \n     return 0;\n   }\n \n+#ifdef NODE_EXPERIMENTAL_HTTP\n+  // Reset nread for the next chunk\n+  int on_chunk_header() {\n+    header_nread_ = 0;\n+    return 0;\n+  }\n+\n+\n+  // Reset nread for the next chunk\n+  int on_chunk_complete() {\n+    header_nread_ = 0;\n+    return 0;\n+  }\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n+\n \n   static void New(const FunctionCallbackInfo<Value>& args) {\n     Environment* env = Environment::GetCurrent(args);\n     CHECK(args[0]->IsInt32());\n-    http_parser_type type =\n-        static_cast<http_parser_type>(args[0].As<Int32>()->Value());\n+    parser_type_t type =\n+        static_cast<parser_type_t>(args[0].As<Int32>()->Value());\n     CHECK(type == HTTP_REQUEST || type == HTTP_RESPONSE);\n     new Parser(env, args.This(), type);\n   }\n@@ -434,30 +484,11 @@ class Parser : public AsyncWrap, public StreamListener {\n \n \n   static void Finish(const FunctionCallbackInfo<Value>& args) {\n-    Environment* env = Environment::GetCurrent(args);\n-\n     Parser* parser;\n     ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());\n \n     CHECK(parser->current_buffer_.IsEmpty());\n-    parser->got_exception_ = false;\n-\n-    int rv = http_parser_execute(&(parser->parser_), &settings, nullptr, 0);\n-\n-    if (parser->got_exception_)\n-      return;\n-\n-    if (rv != 0) {\n-      enum http_errno err = HTTP_PARSER_ERRNO(&parser->parser_);\n-\n-      Local<Value> e = Exception::Error(env->parse_error_string());\n-      Local<Object> obj = e.As<Object>();\n-      obj->Set(env->bytes_parsed_string(), Integer::New(env->isolate(), 0));\n-      obj->Set(env->code_string(),\n-               OneByteString(env->isolate(), http_errno_name(err)));\n-\n-      args.GetReturnValue().Set(e);\n-    }\n+    parser->Execute(nullptr, 0);\n   }\n \n \n@@ -467,8 +498,8 @@ class Parser : public AsyncWrap, public StreamListener {\n     CHECK(args[0]->IsInt32());\n     CHECK(args[1]->IsBoolean());\n     bool isReused = args[1]->IsTrue();\n-    http_parser_type type =\n-        static_cast<http_parser_type>(args[0].As<Int32>()->Value());\n+    parser_type_t type =\n+        static_cast<parser_type_t>(args[0].As<Int32>()->Value());\n \n     CHECK(type == HTTP_REQUEST || type == HTTP_RESPONSE);\n     Parser* parser;\n@@ -492,7 +523,21 @@ class Parser : public AsyncWrap, public StreamListener {\n     ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());\n     // Should always be called from the same context.\n     CHECK_EQ(env, parser->env());\n+\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+    if (parser->execute_depth_) {\n+      parser->pending_pause_ = should_pause;\n+      return;\n+    }\n+\n+    if (should_pause) {\n+      llhttp_pause(&parser->parser_);\n+    } else {\n+      llhttp_resume(&parser->parser_);\n+    }\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n     http_parser_pause(&parser->parser_, should_pause);\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n   }\n \n \n@@ -602,10 +647,46 @@ class Parser : public AsyncWrap, public StreamListener {\n     current_buffer_data_ = data;\n     got_exception_ = false;\n \n-    size_t nparsed =\n-      http_parser_execute(&parser_, &settings, data, len);\n+    parser_errno_t err;\n+\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+    // Do not allow re-entering `http_parser_execute()`\n+    CHECK_EQ(execute_depth_, 0);\n+\n+    execute_depth_++;\n+    if (data == nullptr) {\n+      err = llhttp_finish(&parser_);\n+    } else {\n+      err = llhttp_execute(&parser_, data, len);\n+      Save();\n+    }\n+    execute_depth_--;\n+\n+    // Calculate bytes read and resume after Upgrade/CONNECT pause\n+    size_t nread = len;\n+    if (err != HPE_OK) {\n+      nread = llhttp_get_error_pos(&parser_) - data;\n+\n+      // This isn't a real pause, just a way to stop parsing early.\n+      if (err == HPE_PAUSED_UPGRADE) {\n+        err = HPE_OK;\n+        llhttp_resume_after_upgrade(&parser_);\n+      }\n+    }\n+\n+    // Apply pending pause\n+    if (pending_pause_) {\n+      pending_pause_ = false;\n+      llhttp_pause(&parser_);\n+    }\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n+    size_t nread = http_parser_execute(&parser_, &settings, data, len);\n+    if (data != nullptr) {\n+      Save();\n+    }\n \n-    Save();\n+    err = HTTP_PARSER_ERRNO(&parser_);\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n \n     // Unassign the 'buffer_' variable\n     current_buffer_.Clear();\n@@ -616,22 +697,29 @@ class Parser : public AsyncWrap, public StreamListener {\n     if (got_exception_)\n       return scope.Escape(Local<Value>());\n \n-    Local<Integer> nparsed_obj = Integer::New(env()->isolate(), nparsed);\n+    Local<Integer> nread_obj = Integer::New(env()->isolate(), nread);\n+\n     // If there was a parse error in one of the callbacks\n     // TODO(bnoordhuis) What if there is an error on EOF?\n-    if (!parser_.upgrade && nparsed != len) {\n-      enum http_errno err = HTTP_PARSER_ERRNO(&parser_);\n-\n+    if (!parser_.upgrade && err != HPE_OK) {\n       Local<Value> e = Exception::Error(env()->parse_error_string());\n       Local<Object> obj = e->ToObject(env()->isolate()->GetCurrentContext())\n         .ToLocalChecked();\n-      obj->Set(env()->bytes_parsed_string(), nparsed_obj);\n+      obj->Set(env()->bytes_parsed_string(), nread_obj);\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+      obj->Set(env()->code_string(),\n+               OneByteString(env()->isolate(), llhttp_errno_name(err)));\n+      obj->Set(env()->reason_string(),\n+               OneByteString(env()->isolate(), parser_.reason));\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n       obj->Set(env()->code_string(),\n                OneByteString(env()->isolate(), http_errno_name(err)));\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n \n       return scope.Escape(e);\n     }\n-    return scope.Escape(nparsed_obj);\n+\n+    return scope.Escape(nread_obj);\n   }\n \n   Local<Array> CreateHeaders() {\n@@ -684,8 +772,12 @@ class Parser : public AsyncWrap, public StreamListener {\n   }\n \n \n-  void Init(enum http_parser_type type) {\n+  void Init(parser_type_t type) {\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+    llhttp_init(&parser_, type, &settings);\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n     http_parser_init(&parser_, type);\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n     url_.Reset();\n     status_message_.Reset();\n     num_fields_ = 0;\n@@ -695,7 +787,35 @@ class Parser : public AsyncWrap, public StreamListener {\n   }\n \n \n-  http_parser parser_;\n+  int TrackHeader(size_t len) {\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+    header_nread_ += len;\n+    if (header_nread_ >= kMaxHeaderSize) {\n+      llhttp_set_error_reason(&parser_, \"Headers overflow\");\n+      return HPE_USER;\n+    }\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n+    return 0;\n+  }\n+\n+\n+  int MaybePause() {\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+    CHECK_NE(execute_depth_, 0);\n+\n+    if (!pending_pause_) {\n+      return 0;\n+    }\n+\n+    pending_pause_ = false;\n+    llhttp_set_error_reason(&parser_, \"Paused in callback\");\n+    return HPE_PAUSED;\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n+    return 0;\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n+  }\n+\n+  parser_t parser_;\n   StringPtr fields_[32];  // header fields\n   StringPtr values_[32];  // header values\n   StringPtr url_;\n@@ -707,25 +827,37 @@ class Parser : public AsyncWrap, public StreamListener {\n   Local<Object> current_buffer_;\n   size_t current_buffer_len_;\n   char* current_buffer_data_;\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+  unsigned int execute_depth_ = 0;\n+  bool pending_pause_ = false;\n+  uint64_t header_nread_ = 0;\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n \n   // These are helper functions for filling `http_parser_settings`, which turn\n   // a member function of Parser into a C-style HTTP parser callback.\n   template <typename Parser, Parser> struct Proxy;\n   template <typename Parser, typename ...Args, int (Parser::*Member)(Args...)>\n   struct Proxy<int (Parser::*)(Args...), Member> {\n-    static int Raw(http_parser* p, Args ... args) {\n+    static int Raw(parser_t* p, Args ... args) {\n       Parser* parser = ContainerOf(&Parser::parser_, p);\n-      return (parser->*Member)(std::forward<Args>(args)...);\n+      int rv = (parser->*Member)(std::forward<Args>(args)...);\n+      if (rv == 0) {\n+        rv = parser->MaybePause();\n+      }\n+      return rv;\n     }\n   };\n \n   typedef int (Parser::*Call)();\n   typedef int (Parser::*DataCall)(const char* at, size_t length);\n \n-  static const struct http_parser_settings settings;\n+  static const parser_settings_t settings;\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+  static const uint64_t kMaxHeaderSize = 80 * 1024;\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n };\n \n-const struct http_parser_settings Parser::settings = {\n+const parser_settings_t Parser::settings = {\n   Proxy<Call, &Parser::on_message_begin>::Raw,\n   Proxy<DataCall, &Parser::on_url>::Raw,\n   Proxy<DataCall, &Parser::on_status>::Raw,\n@@ -734,8 +866,13 @@ const struct http_parser_settings Parser::settings = {\n   Proxy<Call, &Parser::on_headers_complete>::Raw,\n   Proxy<DataCall, &Parser::on_body>::Raw,\n   Proxy<Call, &Parser::on_message_complete>::Raw,\n-  nullptr,  // on_chunk_header\n-  nullptr   // on_chunk_complete\n+#ifdef NODE_EXPERIMENTAL_HTTP\n+  Proxy<Call, &Parser::on_chunk_header>::Raw,\n+  Proxy<Call, &Parser::on_chunk_complete>::Raw,\n+#else  /* !NODE_EXPERIMENTAL_HTTP */\n+  nullptr,\n+  nullptr,\n+#endif  /* NODE_EXPERIMENTAL_HTTP */\n };\n \n "
        },
        {
            "sha": "5b002b2ce0e92632147d509d70a426833ca77502",
            "filename": "test/parallel/test-http-parser-bad-ref.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/test%2Fparallel%2Ftest-http-parser-bad-ref.js",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/test%2Fparallel%2Ftest-http-parser-bad-ref.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http-parser-bad-ref.js?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -25,7 +25,7 @@ function flushPool() {\n function demoBug(part1, part2) {\n   flushPool();\n \n-  const parser = new HTTPParser(0);\n+  const parser = new HTTPParser(HTTPParser.REQUEST);\n \n   parser.headers = [];\n   parser.url = '';"
        },
        {
            "sha": "ba7b9e70b2a9b87fb8363374f066a130a8d0a33b",
            "filename": "test/parallel/test-process-versions.js",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/test%2Fparallel%2Ftest-process-versions.js",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/test%2Fparallel%2Ftest-process-versions.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-process-versions.js?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -2,7 +2,7 @@\n const common = require('../common');\n const assert = require('assert');\n \n-const expected_keys = ['ares', 'http_parser', 'modules', 'node',\n+const expected_keys = ['ares', 'modules', 'node',\n                        'uv', 'v8', 'zlib', 'nghttp2', 'napi'];\n \n if (common.hasCrypto) {\n@@ -16,6 +16,9 @@ if (common.hasIntl) {\n   expected_keys.push('unicode');\n }\n \n+expected_keys.push(\n+  process.versions.llhttp === undefined ? 'http_parser' : 'llhttp');\n+\n expected_keys.sort();\n const actual_keys = Object.keys(process.versions).sort();\n \n@@ -24,7 +27,8 @@ assert.deepStrictEqual(actual_keys, expected_keys);\n const commonTemplate = /^\\d+\\.\\d+\\.\\d+(?:-.*)?$/;\n \n assert(commonTemplate.test(process.versions.ares));\n-assert(commonTemplate.test(process.versions.http_parser));\n+assert(commonTemplate.test(process.versions.llhttp === undefined ?\n+  process.versions.http_parser : process.versions.llhttp));\n assert(commonTemplate.test(process.versions.node));\n assert(commonTemplate.test(process.versions.uv));\n assert(commonTemplate.test(process.versions.zlib));"
        },
        {
            "sha": "0db8555838cd423c88fc23bfeef5183a1c777937",
            "filename": "test/parallel/test-trace-events-metadata.js",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/test%2Fparallel%2Ftest-trace-events-metadata.js",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/test%2Fparallel%2Ftest-trace-events-metadata.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-trace-events-metadata.js?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -36,8 +36,9 @@ proc.once('exit', common.mustCall(() => {\n \n     assert(traces.some((trace) =>\n       trace.name === 'node' &&\n-        trace.args.process.versions.http_parser ===\n-          process.versions.http_parser &&\n+        (trace.args.process.versions.http_parser ===\n+           process.versions.http_parser ||\n+         trace.args.process.versions.llhttp === process.versions.llhttp) &&\n         trace.args.process.versions.node ===\n           process.versions.node &&\n         trace.args.process.versions.v8 ==="
        },
        {
            "sha": "4ebe3e0472f4ee67bb48a773e407768de34b77b8",
            "filename": "test/sequential/test-async-wrap-getasyncid.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-async-wrap-getasyncid.js?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -149,7 +149,7 @@ if (common.hasCrypto) { // eslint-disable-line node-core/crypto-check\n \n {\n   const { HTTPParser } = internalBinding('http_parser');\n-  testInitialized(new HTTPParser(0), 'HTTPParser');\n+  testInitialized(new HTTPParser(HTTPParser.REQUEST), 'HTTPParser');\n }\n \n "
        },
        {
            "sha": "58a3b5a209b8c7c03336d70b63655147a3f0c916",
            "filename": "tools/license-builder.sh",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/d4654d89be0c20f8ca1e153d074a236348618b00/tools%2Flicense-builder.sh",
            "raw_url": "https://github.com/nodejs/node/raw/d4654d89be0c20f8ca1e153d074a236348618b00/tools%2Flicense-builder.sh",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Flicense-builder.sh?ref=d4654d89be0c20f8ca1e153d074a236348618b00",
            "patch": "@@ -58,6 +58,7 @@ else\n fi\n \n addlicense \"libuv\" \"deps/uv\" \"$(cat ${rootdir}/deps/uv/LICENSE)\"\n+addlicense \"llhttp\" \"deps/llhttp\" \"$(cat deps/llhttp/LICENSE-MIT)\"\n addlicense \"OpenSSL\" \"deps/openssl\" \\\n            \"$(sed -e '/^ \\*\\/$/,$d' -e '/^ [^*].*$/d' -e '/\\/\\*.*$/d' -e '/^$/d' -e 's/^[/ ]\\* *//' ${rootdir}/deps/openssl/openssl/LICENSE)\"\n addlicense \"Punycode.js\" \"lib/punycode.js\" \\"
        }
    ],
    "stats": {
        "total": 7330,
        "additions": 7253,
        "deletions": 77
    }
}