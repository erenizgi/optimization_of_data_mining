{
    "author": "sam-github",
    "message": "tls: include elliptic curve X.509 public key info\n\nX.509 certs are provided to the user in a parsed object form by a number\nof TLS APIs. Include public key info for elliptic curves as well, not\njust RSA.\n- pubkey: the public key\n- bits: the strength of the curve\n- asn1Curve: the ASN.1 OID for the curve\n- nistCurve: the NIST nickname for the curve, if it has one\n\nPR-URL: https://github.com/nodejs/node/pull/24358\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>",
    "sha": "fe303b9b2dd8224e368ed69d6b797bc34dd94d07",
    "files": [
        {
            "sha": "877aee128ec14a9181989657c60f4f0d041628f6",
            "filename": "doc/api/tls.md",
            "status": "modified",
            "additions": 18,
            "deletions": 1,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/fe303b9b2dd8224e368ed69d6b797bc34dd94d07/doc%2Fapi%2Ftls.md",
            "raw_url": "https://github.com/nodejs/node/raw/fe303b9b2dd8224e368ed69d6b797bc34dd94d07/doc%2Fapi%2Ftls.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ftls.md?ref=fe303b9b2dd8224e368ed69d6b797bc34dd94d07",
            "patch": "@@ -649,6 +649,12 @@ If the full certificate chain was requested, each certificate will include an\n certificate.\n \n #### Certificate Object\n+<!-- YAML\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/24358\n+    description: Support Elliptic Curve public key info.\n+-->\n \n A certificate object has properties corresponding to the fields of the\n certificate.\n@@ -688,7 +694,18 @@ For RSA keys, the following properties may be defined:\n    `'B56CE45CB7...'`.\n * `pubkey` {Buffer} The public key.\n \n-\n+For EC keys, the following properties may be defined:\n+* `pubkey` {Buffer} The public key.\n+* `bits` {number} The key size in bits. Example: `256`.\n+* `asn1Curve` {string} (Optional) The ASN.1 name of the OID of the elliptic\n+  curve. Well-known curves are identified by an OID. While it is unusual, it is\n+  possible that the curve is identified by its mathematical properties, in which\n+  case it will not have an OID. Example: `'prime256v1'`.\n+* `nistCurve` {string} (Optional) The NIST name for the elliptic curve, if it\n+  has one (not all well-known curves have been assigned names by NIST). Example:\n+  `'P-256'`.\n+\n+Example certificate:\n ```text\n { subject:\n    { OU: [ 'Domain Control Validated', 'PositiveSSL Wildcard' ],"
        },
        {
            "sha": "c99f1d68301b6fa156ebc5c0d2c196d2fe170343",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/fe303b9b2dd8224e368ed69d6b797bc34dd94d07/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/fe303b9b2dd8224e368ed69d6b797bc34dd94d07/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=fe303b9b2dd8224e368ed69d6b797bc34dd94d07",
            "patch": "@@ -124,7 +124,9 @@ constexpr size_t kFsStatsBufferLength = kFsStatsFieldsNumber * 2;\n   V(address_string, \"address\")                                                 \\\n   V(aliases_string, \"aliases\")                                                 \\\n   V(args_string, \"args\")                                                       \\\n+  V(asn1curve_string, \"asn1Curve\")                                             \\\n   V(async_ids_stack_string, \"async_ids_stack\")                                 \\\n+  V(bits_string, \"bits\")                                                       \\\n   V(buffer_string, \"buffer\")                                                   \\\n   V(bytes_parsed_string, \"bytesParsed\")                                        \\\n   V(bytes_read_string, \"bytesRead\")                                            \\\n@@ -207,6 +209,7 @@ constexpr size_t kFsStatsBufferLength = kFsStatsFieldsNumber * 2;\n   V(modulus_string, \"modulus\")                                                 \\\n   V(name_string, \"name\")                                                       \\\n   V(netmask_string, \"netmask\")                                                 \\\n+  V(nistcurve_string, \"nistCurve\")                                             \\\n   V(nsname_string, \"nsname\")                                                   \\\n   V(ocsp_request_string, \"OCSPRequest\")                                        \\\n   V(onaltsvc_string, \"onaltsvc\")                                               \\"
        },
        {
            "sha": "91583c18d975494e9037268fc8ba983e571408cd",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 63,
            "deletions": 2,
            "changes": 65,
            "blob_url": "https://github.com/nodejs/node/blob/fe303b9b2dd8224e368ed69d6b797bc34dd94d07/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/fe303b9b2dd8224e368ed69d6b797bc34dd94d07/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=fe303b9b2dd8224e368ed69d6b797bc34dd94d07",
            "patch": "@@ -52,6 +52,15 @@ static const int X509_NAME_FLAGS = ASN1_STRFLGS_ESC_CTRL\n                                  | XN_FLAG_FN_SN;\n \n namespace node {\n+namespace Buffer {\n+// OpenSSL uses `unsigned char*` for raw data, make this easier for us.\n+v8::MaybeLocal<v8::Object> New(Environment* env, unsigned char* udata,\n+                               size_t length) {\n+  char* data = reinterpret_cast<char*>(udata);\n+  return Buffer::New(env, data, length);\n+}\n+}  // namespace Buffer\n+\n namespace crypto {\n \n using v8::Array;\n@@ -1652,8 +1661,17 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n \n   EVPKeyPointer pkey(X509_get_pubkey(cert));\n   RSAPointer rsa;\n-  if (pkey)\n-    rsa.reset(EVP_PKEY_get1_RSA(pkey.get()));\n+  ECPointer ec;\n+  if (pkey) {\n+    switch (EVP_PKEY_id(pkey.get())) {\n+      case EVP_PKEY_RSA:\n+        rsa.reset(EVP_PKEY_get1_RSA(pkey.get()));\n+        break;\n+      case EVP_PKEY_EC:\n+        ec.reset(EVP_PKEY_get1_EC_KEY(pkey.get()));\n+        break;\n+    }\n+  }\n \n   if (rsa) {\n     const BIGNUM* n;\n@@ -1689,10 +1707,53 @@ static Local<Object> X509ToObject(Environment* env, X509* cert) {\n         reinterpret_cast<unsigned char*>(Buffer::Data(pubbuff));\n     i2d_RSA_PUBKEY(rsa.get(), &pubserialized);\n     info->Set(env->context(), env->pubkey_string(), pubbuff).FromJust();\n+  } else if (ec) {\n+    const EC_GROUP* group = EC_KEY_get0_group(ec.get());\n+    if (group != nullptr) {\n+      int bits = EC_GROUP_order_bits(group);\n+      if (bits > 0) {\n+        info->Set(context, env->bits_string(),\n+                  Integer::New(env->isolate(), bits)).FromJust();\n+      }\n+    }\n+\n+    unsigned char* pub = nullptr;\n+    size_t publen = EC_KEY_key2buf(ec.get(), EC_KEY_get_conv_form(ec.get()),\n+                                   &pub, nullptr);\n+    if (publen > 0) {\n+      Local<Object> buf = Buffer::New(env, pub, publen).ToLocalChecked();\n+      // Ownership of pub pointer accepted by Buffer.\n+      pub = nullptr;\n+      info->Set(context, env->pubkey_string(), buf).FromJust();\n+    } else {\n+      CHECK_NULL(pub);\n+    }\n+\n+    if (EC_GROUP_get_asn1_flag(group) != 0) {\n+      // Curve is well-known, get its OID and NIST nick-name (if it has one).\n+\n+      int nid = EC_GROUP_get_curve_name(group);\n+      if (nid != 0) {\n+        if (const char* sn = OBJ_nid2sn(nid)) {\n+          info->Set(context, env->asn1curve_string(),\n+                    OneByteString(env->isolate(), sn)).FromJust();\n+        }\n+      }\n+      if (nid != 0) {\n+        if (const char* nist = EC_curve_nid2nist(nid)) {\n+          info->Set(context, env->nistcurve_string(),\n+                    OneByteString(env->isolate(), nist)).FromJust();\n+        }\n+      }\n+    } else {\n+      // Unnamed curves can be described by their mathematical properties,\n+      // but aren't used much (at all?) with X.509/TLS. Support later if needed.\n+    }\n   }\n \n   pkey.reset();\n   rsa.reset();\n+  ec.reset();\n \n   ASN1_TIME_print(bio.get(), X509_get_notBefore(cert));\n   BIO_get_mem_ptr(bio.get(), &mem);"
        },
        {
            "sha": "5f98af754ea7270129e393b511df00988f7302ca",
            "filename": "src/node_crypto.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/fe303b9b2dd8224e368ed69d6b797bc34dd94d07/src%2Fnode_crypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/fe303b9b2dd8224e368ed69d6b797bc34dd94d07/src%2Fnode_crypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.h?ref=fe303b9b2dd8224e368ed69d6b797bc34dd94d07",
            "patch": "@@ -81,6 +81,7 @@ using EVPKeyPointer = DeleteFnPtr<EVP_PKEY, EVP_PKEY_free>;\n using EVPKeyCtxPointer = DeleteFnPtr<EVP_PKEY_CTX, EVP_PKEY_CTX_free>;\n using EVPMDPointer = DeleteFnPtr<EVP_MD_CTX, EVP_MD_CTX_free>;\n using RSAPointer = DeleteFnPtr<RSA, RSA_free>;\n+using ECPointer = DeleteFnPtr<EC_KEY, EC_KEY_free>;\n using BignumPointer = DeleteFnPtr<BIGNUM, BN_free>;\n using NetscapeSPKIPointer = DeleteFnPtr<NETSCAPE_SPKI, NETSCAPE_SPKI_free>;\n using ECGroupPointer = DeleteFnPtr<EC_GROUP, EC_GROUP_free>;"
        },
        {
            "sha": "2a48665e4d9357c4b967fb0c99ebac17cdbb2314",
            "filename": "test/parallel/test-tls-peer-certificate.js",
            "status": "modified",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/nodejs/node/blob/fe303b9b2dd8224e368ed69d6b797bc34dd94d07/test%2Fparallel%2Ftest-tls-peer-certificate.js",
            "raw_url": "https://github.com/nodejs/node/raw/fe303b9b2dd8224e368ed69d6b797bc34dd94d07/test%2Fparallel%2Ftest-tls-peer-certificate.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-peer-certificate.js?ref=fe303b9b2dd8224e368ed69d6b797bc34dd94d07",
            "patch": "@@ -86,3 +86,48 @@ connect({\n \n   return cleanup();\n });\n+\n+connect({\n+  client: { rejectUnauthorized: false },\n+  server: keys.ec,\n+}, function(err, pair, cleanup) {\n+  assert.ifError(err);\n+  const socket = pair.client.conn;\n+  let peerCert = socket.getPeerCertificate(true);\n+  assert.ok(peerCert.issuerCertificate);\n+\n+  peerCert = socket.getPeerCertificate(true);\n+  debug('peerCert:\\n', peerCert);\n+\n+  assert.ok(peerCert.issuerCertificate);\n+  assert.strictEqual(peerCert.subject.emailAddress, 'ry@tinyclouds.org');\n+  assert.strictEqual(peerCert.serialNumber, 'C1EA7B03D5956D52');\n+  assert.strictEqual(peerCert.exponent, undefined);\n+  assert.strictEqual(peerCert.pubKey, undefined);\n+  assert.strictEqual(peerCert.modulus, undefined);\n+  assert.strictEqual(\n+    peerCert.fingerprint,\n+    'DF:F0:D3:6B:C3:E7:74:7C:C7:F3:FB:1E:33:12:AE:6C:8D:53:5F:74'\n+  );\n+  assert.strictEqual(\n+    peerCert.fingerprint256,\n+    'AB:08:3C:40:C7:07:D7:D1:79:32:92:3B:96:52:D0:38:4C:22:ED:CD:23:51:D0:A1:' +\n+    '67:AA:33:A0:D5:26:5C:41'\n+  );\n+\n+  assert.strictEqual(\n+    sha256(peerCert.pubkey).digest('hex'),\n+    'ec68fc7d5e32cd4e1da5a7b59c0a2229be6f82fcc9bf8c8691a2262aacb14f53'\n+  );\n+  assert.strictEqual(peerCert.asn1Curve, 'prime256v1');\n+  assert.strictEqual(peerCert.nistCurve, 'P-256');\n+  assert.strictEqual(peerCert.bits, 256);\n+\n+  assert.deepStrictEqual(peerCert.infoAccess, undefined);\n+\n+  const issuer = peerCert.issuerCertificate;\n+  assert.strictEqual(issuer.issuerCertificate, issuer);\n+  assert.strictEqual(issuer.serialNumber, 'C1EA7B03D5956D52');\n+\n+  return cleanup();\n+});"
        }
    ],
    "stats": {
        "total": 133,
        "additions": 130,
        "deletions": 3
    }
}