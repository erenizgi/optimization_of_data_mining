{
    "author": "joyeecheung",
    "message": "worker: move worker thread setup code into the main script\n\nThis patch directly inlines `createMessageHandler()` and\n`createWorkerFatalExeception()` in the new\n`lib/internal/main/worker_thread.js` since the implementation\nof the two methods are related to the execution flow of\nworkers.\n\nPR-URL: https://github.com/nodejs/node/pull/25667\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "5e1d4462d232400b4e75247540aae863cb6877cf",
    "files": [
        {
            "sha": "94d0e613e8ce3825c154aa3b2c8f4c3087a30c7c",
            "filename": "lib/internal/main/worker_thread.js",
            "status": "modified",
            "additions": 102,
            "deletions": 14,
            "changes": 116,
            "blob_url": "https://github.com/nodejs/node/blob/5e1d4462d232400b4e75247540aae863cb6877cf/lib%2Finternal%2Fmain%2Fworker_thread.js",
            "raw_url": "https://github.com/nodejs/node/raw/5e1d4462d232400b4e75247540aae863cb6877cf/lib%2Finternal%2Fmain%2Fworker_thread.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fmain%2Fworker_thread.js?ref=5e1d4462d232400b4e75247540aae863cb6877cf",
            "patch": "@@ -10,30 +10,118 @@ const {\n } = require('internal/bootstrap/pre_execution');\n \n const {\n-  getEnvMessagePort,\n-  threadId\n+  threadId,\n+  getEnvMessagePort\n } = internalBinding('worker');\n \n const {\n-  createMessageHandler,\n-  createWorkerFatalExeception\n-} = require('internal/process/worker_thread_only');\n+  messageTypes: {\n+    // Messages that may be received by workers\n+    LOAD_SCRIPT,\n+    // Messages that may be posted from workers\n+    UP_AND_RUNNING,\n+    ERROR_MESSAGE,\n+    COULD_NOT_SERIALIZE_ERROR,\n+    // Messages that may be either received or posted\n+    STDIO_PAYLOAD,\n+    STDIO_WANTS_MORE_DATA,\n+  },\n+  kStdioWantsMoreDataCallback\n+} = require('internal/worker/io');\n \n+const {\n+  fatalException: originalFatalException\n+} = require('internal/process/execution');\n+\n+const publicWorker = require('worker_threads');\n const debug = require('util').debuglog('worker');\n-debug(`[${threadId}] is setting up worker child environment`);\n \n-function prepareUserCodeExecution() {\n-  initializeClusterIPC();\n-  initializeESMLoader();\n-  loadPreloadModules();\n-}\n+debug(`[${threadId}] is setting up worker child environment`);\n \n // Set up the message port and start listening\n const port = getEnvMessagePort();\n-port.on('message', createMessageHandler(port, prepareUserCodeExecution));\n-port.start();\n+\n+port.on('message', (message) => {\n+  if (message.type === LOAD_SCRIPT) {\n+    const {\n+      filename,\n+      doEval,\n+      workerData,\n+      publicPort,\n+      manifestSrc,\n+      manifestURL,\n+      hasStdin\n+    } = message;\n+    if (manifestSrc) {\n+      require('internal/process/policy').setup(manifestSrc, manifestURL);\n+    }\n+    initializeClusterIPC();\n+    initializeESMLoader();\n+    loadPreloadModules();\n+    publicWorker.parentPort = publicPort;\n+    publicWorker.workerData = workerData;\n+\n+    if (!hasStdin)\n+      process.stdin.push(null);\n+\n+    debug(`[${threadId}] starts worker script ${filename} ` +\n+          `(eval = ${eval}) at cwd = ${process.cwd()}`);\n+    port.unref();\n+    port.postMessage({ type: UP_AND_RUNNING });\n+    if (doEval) {\n+      const { evalScript } = require('internal/process/execution');\n+      evalScript('[worker eval]', filename);\n+    } else {\n+      process.argv[1] = filename; // script filename\n+      require('module').runMain();\n+    }\n+    return;\n+  } else if (message.type === STDIO_PAYLOAD) {\n+    const { stream, chunk, encoding } = message;\n+    process[stream].push(chunk, encoding);\n+    return;\n+  } else if (message.type === STDIO_WANTS_MORE_DATA) {\n+    const { stream } = message;\n+    process[stream][kStdioWantsMoreDataCallback]();\n+    return;\n+  }\n+\n+  require('assert').fail(`Unknown worker message type ${message.type}`);\n+});\n \n // Overwrite fatalException\n-process._fatalException = createWorkerFatalExeception(port);\n+process._fatalException = (error) => {\n+  debug(`[${threadId}] gets fatal exception`);\n+  let caught = false;\n+  try {\n+    caught = originalFatalException.call(this, error);\n+  } catch (e) {\n+    error = e;\n+  }\n+  debug(`[${threadId}] fatal exception caught = ${caught}`);\n+\n+  if (!caught) {\n+    let serialized;\n+    try {\n+      const { serializeError } = require('internal/error-serdes');\n+      serialized = serializeError(error);\n+    } catch {}\n+    debug(`[${threadId}] fatal exception serialized = ${!!serialized}`);\n+    if (serialized)\n+      port.postMessage({\n+        type: ERROR_MESSAGE,\n+        error: serialized\n+      });\n+    else\n+      port.postMessage({ type: COULD_NOT_SERIALIZE_ERROR });\n+\n+    const { clearAsyncIdStack } = require('internal/async_hooks');\n+    clearAsyncIdStack();\n+\n+    process.exit();\n+  }\n+};\n \n markBootstrapComplete();\n+\n+port.start();"
        },
        {
            "sha": "f05d5e932bebf25be42db74af31222e65959f6cd",
            "filename": "lib/internal/process/worker_thread_only.js",
            "status": "modified",
            "additions": 1,
            "deletions": 106,
            "changes": 107,
            "blob_url": "https://github.com/nodejs/node/blob/5e1d4462d232400b4e75247540aae863cb6877cf/lib%2Finternal%2Fprocess%2Fworker_thread_only.js",
            "raw_url": "https://github.com/nodejs/node/raw/5e1d4462d232400b4e75247540aae863cb6877cf/lib%2Finternal%2Fprocess%2Fworker_thread_only.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fworker_thread_only.js?ref=5e1d4462d232400b4e75247540aae863cb6877cf",
            "patch": "@@ -3,13 +3,10 @@\n // This file contains process bootstrappers that can only be\n // run in the worker thread.\n const {\n-  getEnvMessagePort,\n-  threadId\n+  getEnvMessagePort\n } = internalBinding('worker');\n \n const {\n-  messageTypes,\n-  kStdioWantsMoreDataCallback,\n   kWaitingStreams,\n   ReadableWorkerStdio,\n   WritableWorkerStdio\n@@ -18,15 +15,6 @@ const {\n const {\n   codes: { ERR_WORKER_UNSUPPORTED_OPERATION }\n } = require('internal/errors');\n-\n-let debuglog;\n-function debug(...args) {\n-  if (!debuglog) {\n-    debuglog = require('util').debuglog('worker');\n-  }\n-  return debuglog(...args);\n-}\n-\n const workerStdio = {};\n \n function initializeWorkerStdio() {\n@@ -43,97 +31,6 @@ function initializeWorkerStdio() {\n   };\n }\n \n-function createMessageHandler(port, prepareUserCodeExecution) {\n-  const publicWorker = require('worker_threads');\n-\n-  return function(message) {\n-    if (message.type === messageTypes.LOAD_SCRIPT) {\n-      const {\n-        filename,\n-        doEval,\n-        workerData,\n-        publicPort,\n-        manifestSrc,\n-        manifestURL,\n-        hasStdin\n-      } = message;\n-      if (manifestSrc) {\n-        require('internal/process/policy').setup(manifestSrc, manifestURL);\n-      }\n-      prepareUserCodeExecution();\n-      publicWorker.parentPort = publicPort;\n-      publicWorker.workerData = workerData;\n-\n-      if (!hasStdin)\n-        workerStdio.stdin.push(null);\n-\n-      debug(`[${threadId}] starts worker script ${filename} ` +\n-            `(eval = ${eval}) at cwd = ${process.cwd()}`);\n-      port.unref();\n-      port.postMessage({ type: messageTypes.UP_AND_RUNNING });\n-      if (doEval) {\n-        const { evalScript } = require('internal/process/execution');\n-        evalScript('[worker eval]', filename);\n-      } else {\n-        process.argv[1] = filename; // script filename\n-        require('module').runMain();\n-      }\n-      return;\n-    } else if (message.type === messageTypes.STDIO_PAYLOAD) {\n-      const { stream, chunk, encoding } = message;\n-      workerStdio[stream].push(chunk, encoding);\n-      return;\n-    } else if (message.type === messageTypes.STDIO_WANTS_MORE_DATA) {\n-      const { stream } = message;\n-      workerStdio[stream][kStdioWantsMoreDataCallback]();\n-      return;\n-    }\n-\n-    require('assert').fail(`Unknown worker message type ${message.type}`);\n-  };\n-}\n-\n-// XXX(joyeecheung): this has to be returned as an anonymous function\n-// wrapped in a closure, see the comment of the original\n-// process._fatalException in lib/internal/process/execution.js\n-function createWorkerFatalExeception(port) {\n-  const {\n-    fatalException: originalFatalException\n-  } = require('internal/process/execution');\n-\n-  return (error) => {\n-    debug(`[${threadId}] gets fatal exception`);\n-    let caught = false;\n-    try {\n-      caught = originalFatalException.call(this, error);\n-    } catch (e) {\n-      error = e;\n-    }\n-    debug(`[${threadId}] fatal exception caught = ${caught}`);\n-\n-    if (!caught) {\n-      let serialized;\n-      try {\n-        const { serializeError } = require('internal/error-serdes');\n-        serialized = serializeError(error);\n-      } catch {}\n-      debug(`[${threadId}] fatal exception serialized = ${!!serialized}`);\n-      if (serialized)\n-        port.postMessage({\n-          type: messageTypes.ERROR_MESSAGE,\n-          error: serialized\n-        });\n-      else\n-        port.postMessage({ type: messageTypes.COULD_NOT_SERIALIZE_ERROR });\n-\n-      const { clearAsyncIdStack } = require('internal/async_hooks');\n-      clearAsyncIdStack();\n-\n-      process.exit();\n-    }\n-  };\n-}\n-\n // The execution of this function itself should not cause any side effects.\n function wrapProcessMethods(binding) {\n   function umask(mask) {\n@@ -150,7 +47,5 @@ function wrapProcessMethods(binding) {\n \n module.exports = {\n   initializeWorkerStdio,\n-  createMessageHandler,\n-  createWorkerFatalExeception,\n   wrapProcessMethods\n };"
        }
    ],
    "stats": {
        "total": 223,
        "additions": 103,
        "deletions": 120
    }
}