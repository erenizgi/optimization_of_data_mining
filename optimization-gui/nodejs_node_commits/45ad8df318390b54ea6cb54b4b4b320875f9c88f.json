{
    "author": "addaleax",
    "message": "src: make heap snapshot & embedder graph accessible for tests\n\nAdd methods that allow inspection of heap snapshots and a JS\nversion of our own embedder graph.\n\nThese can be used in tests and might also prove useful for\nad-hoc debugging. Usage requires `--expose-internals` and\nprints a warning similar to our other modules whose primary\npurpose is test support.\n\nPR-URL: https://github.com/nodejs/node/pull/21741\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>",
    "sha": "45ad8df318390b54ea6cb54b4b4b320875f9c88f",
    "files": [
        {
            "sha": "a9260f651b9c1aa5e301de1b6624aa150c2a1a83",
            "filename": "lib/internal/test/heap.js",
            "status": "added",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/nodejs/node/blob/45ad8df318390b54ea6cb54b4b4b320875f9c88f/lib%2Finternal%2Ftest%2Fheap.js",
            "raw_url": "https://github.com/nodejs/node/raw/45ad8df318390b54ea6cb54b4b4b320875f9c88f/lib%2Finternal%2Ftest%2Fheap.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ftest%2Fheap.js?ref=45ad8df318390b54ea6cb54b4b4b320875f9c88f",
            "patch": "@@ -0,0 +1,87 @@\n+'use strict';\n+\n+process.emitWarning(\n+  'These APIs are exposed only for testing and are not ' +\n+  'tracked by any versioning system or deprecation process.',\n+  'internal/test/heap');\n+\n+const { internalBinding } = require('internal/bootstrap/loaders');\n+const { createHeapDump, buildEmbedderGraph } = internalBinding('heap_utils');\n+const assert = require('assert');\n+\n+// This is not suitable for production code. It creates a full V8 heap dump,\n+// parses it as JSON, and then creates complex objects from it, leading\n+// to significantly increased memory usage.\n+function createJSHeapDump() {\n+  const dump = createHeapDump();\n+  const meta = dump.snapshot.meta;\n+\n+  const nodes =\n+    readHeapInfo(dump.nodes, meta.node_fields, meta.node_types, dump.strings);\n+  const edges =\n+    readHeapInfo(dump.edges, meta.edge_fields, meta.edge_types, dump.strings);\n+\n+  for (const node of nodes) {\n+    node.incomingEdges = [];\n+    node.outgoingEdges = [];\n+  }\n+\n+  let fromNodeIndex = 0;\n+  let edgeIndex = 0;\n+  for (const { type, name_or_index, to_node } of edges) {\n+    while (edgeIndex === nodes[fromNodeIndex].edge_count) {\n+      edgeIndex = 0;\n+      fromNodeIndex++;\n+    }\n+    const toNode = nodes[to_node / meta.node_fields.length];\n+    const fromNode = nodes[fromNodeIndex];\n+    const edge = {\n+      type,\n+      toNode,\n+      fromNode,\n+      name: typeof name_or_index === 'string' ? name_or_index : null\n+    };\n+    toNode.incomingEdges.push(edge);\n+    fromNode.outgoingEdges.push(edge);\n+    edgeIndex++;\n+  }\n+\n+  for (const node of nodes)\n+    assert.strictEqual(node.edge_count, node.outgoingEdges.length);\n+\n+  return nodes;\n+}\n+\n+function readHeapInfo(raw, fields, types, strings) {\n+  const items = [];\n+\n+  for (var i = 0; i < raw.length; i += fields.length) {\n+    const item = {};\n+    for (var j = 0; j < fields.length; j++) {\n+      const name = fields[j];\n+      let type = types[j];\n+      if (Array.isArray(type)) {\n+        item[name] = type[raw[i + j]];\n+      } else if (name === 'name_or_index') {  // type === 'string_or_number'\n+        if (item.type === 'element' || item.type === 'hidden')\n+          type = 'number';\n+        else\n+          type = 'string';\n+      }\n+\n+      if (type === 'string') {\n+        item[name] = strings[raw[i + j]];\n+      } else if (type === 'number' || type === 'node') {\n+        item[name] = raw[i + j];\n+      }\n+    }\n+    items.push(item);\n+  }\n+\n+  return items;\n+}\n+\n+module.exports = {\n+  createJSHeapDump,\n+  buildEmbedderGraph\n+};"
        },
        {
            "sha": "75288114a8a4a1cab5bf60600dc89ec25b11c58c",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/45ad8df318390b54ea6cb54b4b4b320875f9c88f/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/45ad8df318390b54ea6cb54b4b4b320875f9c88f/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=45ad8df318390b54ea6cb54b4b4b320875f9c88f",
            "patch": "@@ -148,6 +148,7 @@\n       'lib/internal/repl/await.js',\n       'lib/internal/socket_list.js',\n       'lib/internal/test/binding.js',\n+      'lib/internal/test/heap.js',\n       'lib/internal/test/unicode.js',\n       'lib/internal/timers.js',\n       'lib/internal/tls.js',\n@@ -330,6 +331,7 @@\n         'src/exceptions.cc',\n         'src/fs_event_wrap.cc',\n         'src/handle_wrap.cc',\n+        'src/heap_utils.cc',\n         'src/js_stream.cc',\n         'src/module_wrap.cc',\n         'src/node.cc',"
        },
        {
            "sha": "2d339c580fa076d3fd0d7a1c765424c3a9ee9b3f",
            "filename": "src/heap_utils.cc",
            "status": "added",
            "additions": 232,
            "deletions": 0,
            "changes": 232,
            "blob_url": "https://github.com/nodejs/node/blob/45ad8df318390b54ea6cb54b4b4b320875f9c88f/src%2Fheap_utils.cc",
            "raw_url": "https://github.com/nodejs/node/raw/45ad8df318390b54ea6cb54b4b4b320875f9c88f/src%2Fheap_utils.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fheap_utils.cc?ref=45ad8df318390b54ea6cb54b4b4b320875f9c88f",
            "patch": "@@ -0,0 +1,232 @@\n+#include \"node_internals.h\"\n+#include \"env.h\"\n+\n+using v8::Array;\n+using v8::Boolean;\n+using v8::Context;\n+using v8::EmbedderGraph;\n+using v8::EscapableHandleScope;\n+using v8::FunctionCallbackInfo;\n+using v8::HandleScope;\n+using v8::HeapSnapshot;\n+using v8::Isolate;\n+using v8::JSON;\n+using v8::Local;\n+using v8::MaybeLocal;\n+using v8::Number;\n+using v8::Object;\n+using v8::String;\n+using v8::Value;\n+\n+namespace node {\n+namespace heap {\n+\n+class JSGraphJSNode : public EmbedderGraph::Node {\n+ public:\n+  const char* Name() override { return \"<JS Node>\"; }\n+  size_t SizeInBytes() override { return 0; }\n+  bool IsEmbedderNode() override { return false; }\n+  Local<Value> JSValue() { return StrongPersistentToLocal(persistent_); }\n+\n+  int IdentityHash() {\n+    Local<Value> v = JSValue();\n+    if (v->IsObject()) return v.As<Object>()->GetIdentityHash();\n+    if (v->IsName()) return v.As<v8::Name>()->GetIdentityHash();\n+    if (v->IsInt32()) return v.As<v8::Int32>()->Value();\n+    return 0;\n+  }\n+\n+  JSGraphJSNode(Isolate* isolate, Local<Value> val)\n+      : persistent_(isolate, val) {\n+    CHECK(!val.IsEmpty());\n+  }\n+\n+  struct Hash {\n+    inline size_t operator()(JSGraphJSNode* n) const {\n+      return n->IdentityHash();\n+    }\n+  };\n+\n+  struct Equal {\n+    inline bool operator()(JSGraphJSNode* a, JSGraphJSNode* b) const {\n+      return a->JSValue()->SameValue(b->JSValue());\n+    }\n+  };\n+\n+ private:\n+  Persistent<Value> persistent_;\n+};\n+\n+class JSGraph : public EmbedderGraph {\n+ public:\n+  explicit JSGraph(Isolate* isolate) : isolate_(isolate) {}\n+\n+  Node* V8Node(const Local<Value>& value) override {\n+    std::unique_ptr<JSGraphJSNode> n { new JSGraphJSNode(isolate_, value) };\n+    auto it = engine_nodes_.find(n.get());\n+    if (it != engine_nodes_.end())\n+      return *it;\n+    engine_nodes_.insert(n.get());\n+    return AddNode(std::unique_ptr<Node>(n.release()));\n+  }\n+\n+  Node* AddNode(std::unique_ptr<Node> node) override {\n+    Node* n = node.get();\n+    nodes_.emplace(std::move(node));\n+    return n;\n+  }\n+\n+  void AddEdge(Node* from, Node* to) override {\n+    edges_[from].insert(to);\n+  }\n+\n+  MaybeLocal<Array> CreateObject() const {\n+    EscapableHandleScope handle_scope(isolate_);\n+    Local<Context> context = isolate_->GetCurrentContext();\n+\n+    std::unordered_map<Node*, Local<Object>> info_objects;\n+    Local<Array> nodes = Array::New(isolate_, nodes_.size());\n+    Local<String> edges_string = FIXED_ONE_BYTE_STRING(isolate_, \"edges\");\n+    Local<String> is_root_string = FIXED_ONE_BYTE_STRING(isolate_, \"isRoot\");\n+    Local<String> name_string = FIXED_ONE_BYTE_STRING(isolate_, \"name\");\n+    Local<String> size_string = FIXED_ONE_BYTE_STRING(isolate_, \"size\");\n+    Local<String> value_string = FIXED_ONE_BYTE_STRING(isolate_, \"value\");\n+    Local<String> wraps_string = FIXED_ONE_BYTE_STRING(isolate_, \"wraps\");\n+\n+    for (const std::unique_ptr<Node>& n : nodes_)\n+      info_objects[n.get()] = Object::New(isolate_);\n+\n+    {\n+      HandleScope handle_scope(isolate_);\n+      size_t i = 0;\n+      for (const std::unique_ptr<Node>& n : nodes_) {\n+        Local<Object> obj = info_objects[n.get()];\n+        Local<Value> value;\n+        if (!String::NewFromUtf8(isolate_, n->Name(),\n+                                 v8::NewStringType::kNormal).ToLocal(&value) ||\n+            obj->Set(context, name_string, value).IsNothing() ||\n+            obj->Set(context, is_root_string,\n+                     Boolean::New(isolate_, n->IsRootNode())).IsNothing() ||\n+            obj->Set(context, size_string,\n+                     Number::New(isolate_, n->SizeInBytes())).IsNothing() ||\n+            obj->Set(context, edges_string,\n+                     Array::New(isolate_)).IsNothing()) {\n+          return MaybeLocal<Array>();\n+        }\n+        if (nodes->Set(context, i++, obj).IsNothing())\n+          return MaybeLocal<Array>();\n+        if (!n->IsEmbedderNode()) {\n+          value = static_cast<JSGraphJSNode*>(n.get())->JSValue();\n+          if (obj->Set(context, value_string, value).IsNothing())\n+            return MaybeLocal<Array>();\n+        }\n+      }\n+    }\n+\n+    for (const std::unique_ptr<Node>& n : nodes_) {\n+      Node* wraps = n->WrapperNode();\n+      if (wraps == nullptr) continue;\n+      Local<Object> from = info_objects[n.get()];\n+      Local<Object> to = info_objects[wraps];\n+      if (from->Set(context, wraps_string, to).IsNothing())\n+        return MaybeLocal<Array>();\n+    }\n+\n+    for (const auto& edge_info : edges_) {\n+      Node* source = edge_info.first;\n+      Local<Value> edges;\n+      if (!info_objects[source]->Get(context, edges_string).ToLocal(&edges) ||\n+          !edges->IsArray()) {\n+        return MaybeLocal<Array>();\n+      }\n+\n+      size_t i = 0;\n+      for (Node* target : edge_info.second) {\n+        if (edges.As<Array>()->Set(context,\n+                                   i++,\n+                                   info_objects[target]).IsNothing()) {\n+          return MaybeLocal<Array>();\n+        }\n+      }\n+    }\n+\n+    return handle_scope.Escape(nodes);\n+  }\n+\n+ private:\n+  Isolate* isolate_;\n+  std::unordered_set<std::unique_ptr<Node>> nodes_;\n+  std::unordered_set<JSGraphJSNode*, JSGraphJSNode::Hash, JSGraphJSNode::Equal>\n+      engine_nodes_;\n+  std::unordered_map<Node*, std::unordered_set<Node*>> edges_;\n+};\n+\n+void BuildEmbedderGraph(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  JSGraph graph(env->isolate());\n+  Environment::BuildEmbedderGraph(env->isolate(), &graph, env);\n+  Local<Array> ret;\n+  if (graph.CreateObject().ToLocal(&ret))\n+    args.GetReturnValue().Set(ret);\n+}\n+\n+\n+class BufferOutputStream : public v8::OutputStream {\n+ public:\n+  BufferOutputStream() : buffer_(new JSString()) {}\n+\n+  void EndOfStream() override {}\n+  int GetChunkSize() override { return 1024 * 1024; }\n+  WriteResult WriteAsciiChunk(char* data, int size) override {\n+    buffer_->Append(data, size);\n+    return kContinue;\n+  }\n+\n+  Local<String> ToString(Isolate* isolate) {\n+    return String::NewExternalOneByte(isolate,\n+                                      buffer_.release()).ToLocalChecked();\n+  }\n+\n+ private:\n+  class JSString : public String::ExternalOneByteStringResource {\n+   public:\n+    void Append(char* data, size_t count) {\n+      store_.append(data, count);\n+    }\n+\n+    const char* data() const override { return store_.data(); }\n+    size_t length() const override { return store_.size(); }\n+\n+   private:\n+    std::string store_;\n+  };\n+\n+  std::unique_ptr<JSString> buffer_;\n+};\n+\n+void CreateHeapDump(const FunctionCallbackInfo<Value>& args) {\n+  Isolate* isolate = args.GetIsolate();\n+  const HeapSnapshot* snapshot = isolate->GetHeapProfiler()->TakeHeapSnapshot();\n+  BufferOutputStream out;\n+  snapshot->Serialize(&out, HeapSnapshot::kJSON);\n+  const_cast<HeapSnapshot*>(snapshot)->Delete();\n+  Local<Value> ret;\n+  if (JSON::Parse(isolate->GetCurrentContext(),\n+                  out.ToString(isolate)).ToLocal(&ret)) {\n+    args.GetReturnValue().Set(ret);\n+  }\n+}\n+\n+void Initialize(Local<Object> target,\n+                Local<Value> unused,\n+                Local<Context> context) {\n+  Environment* env = Environment::GetCurrent(context);\n+\n+  env->SetMethodNoSideEffect(target, \"buildEmbedderGraph\", BuildEmbedderGraph);\n+  env->SetMethodNoSideEffect(target, \"createHeapDump\", CreateHeapDump);\n+}\n+\n+}  // namespace heap\n+}  // namespace node\n+\n+NODE_MODULE_CONTEXT_AWARE_INTERNAL(heap_utils, node::heap::Initialize)"
        },
        {
            "sha": "f29812e26e22988fecca66466bee80c8ce3fe0ef",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/45ad8df318390b54ea6cb54b4b4b320875f9c88f/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/45ad8df318390b54ea6cb54b4b4b320875f9c88f/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=45ad8df318390b54ea6cb54b4b4b320875f9c88f",
            "patch": "@@ -111,6 +111,7 @@ struct sockaddr;\n     V(domain)                                                                 \\\n     V(fs)                                                                     \\\n     V(fs_event_wrap)                                                          \\\n+    V(heap_utils)                                                             \\\n     V(http2)                                                                  \\\n     V(http_parser)                                                            \\\n     V(inspector)                                                              \\"
        }
    ],
    "stats": {
        "total": 322,
        "additions": 322,
        "deletions": 0
    }
}