{
    "author": "jasnell",
    "message": "fs: add initial set of fs.promises APIs\n\nInitial set of fs.promises APIs with documentation and one\nbenchmark.\n\nPR-URL: https://github.com/nodejs/node/pull/18297\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "329fc78e4919231bf76771797878f7b0db0f73ac",
    "files": [
        {
            "sha": "adc0ed4965fdfd0205b506d7892a004e190447c5",
            "filename": "benchmark/fs/bench-stat-promise.js",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/329fc78e4919231bf76771797878f7b0db0f73ac/benchmark%2Ffs%2Fbench-stat-promise.js",
            "raw_url": "https://github.com/nodejs/node/raw/329fc78e4919231bf76771797878f7b0db0f73ac/benchmark%2Ffs%2Fbench-stat-promise.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Ffs%2Fbench-stat-promise.js?ref=329fc78e4919231bf76771797878f7b0db0f73ac",
            "patch": "@@ -0,0 +1,28 @@\n+'use strict';\n+\n+const common = require('../common');\n+const fs = require('fs');\n+\n+const bench = common.createBenchmark(main, {\n+  n: [20e4],\n+  statType: ['fstat', 'lstat', 'stat']\n+});\n+\n+async function run(n, statType) {\n+  const arg = statType === 'fstat' ?\n+    await fs.promises.open(__filename, 'r') : __filename;\n+  let remaining = n;\n+  bench.start();\n+  while (remaining-- > 0)\n+    await fs.promises[statType](arg);\n+  bench.end(n);\n+\n+  if (typeof arg.close === 'function')\n+    await arg.close();\n+}\n+\n+function main(conf) {\n+  const n = conf.n >>> 0;\n+  const statType = conf.statType;\n+  run(n, statType).catch(console.log);\n+}"
        },
        {
            "sha": "6fe323081348b36dc423d5481b729c30942947a6",
            "filename": "doc/api/fs.md",
            "status": "modified",
            "additions": 992,
            "deletions": 0,
            "changes": 992,
            "blob_url": "https://github.com/nodejs/node/blob/329fc78e4919231bf76771797878f7b0db0f73ac/doc%2Fapi%2Ffs.md",
            "raw_url": "https://github.com/nodejs/node/raw/329fc78e4919231bf76771797878f7b0db0f73ac/doc%2Fapi%2Ffs.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ffs.md?ref=329fc78e4919231bf76771797878f7b0db0f73ac",
            "patch": "@@ -3212,6 +3212,997 @@ changes:\n \n Synchronous versions of [`fs.write()`][]. Returns the number of bytes written.\n \n+## fs Promises API\n+\n+> Stability: 1 - Experimental\n+\n+The `fs.promises` API provides an alternative set of asynchronous file system\n+methods that return `Promise` objects rather than using callbacks. The\n+API is accessible via `fs.promises`.\n+\n+### class: FileHandle\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+A `FileHandle` object is a wrapper for a numeric file descriptor.\n+Instances of `FileHandle` are distinct from numeric file descriptors\n+in that, if the `FileHandle` is not explicitly closed using the\n+`filehandle.close()` method, they will automatically close the file descriptor\n+and will emit a process warning, thereby helping to prevent memory leaks.\n+\n+Instances of the `FileHandle` object are created internally by the\n+`fs.promises.open()` method.\n+\n+Unlike callback-based such as `fs.fstat()`, `fs.fchown()`, `fs.fchmod()`,\n+`fs.ftruncate()`, `fs.read()`, and `fs.write()`, operations -- all of which\n+use a simple numeric file descriptor, all `fs.promises.*` variations use the\n+`FileHandle` class in order to help protect against accidental leaking of\n+unclosed file descriptors after a `Promise` is resolved or rejected.\n+\n+#### filehandle.fd\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+Value: {number} The numeric file descriptor managed by the `FileHandle` object.\n+\n+#### filehandle.appendFile(data, options)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `data` {string|Buffer}\n+* `options` {Object|string}\n+  * `encoding` {string|null} **Default:** `'utf8'`\n+  * `mode` {integer} **Default:** `0o666`\n+  * `flag` {string} **Default:** `'a'`\n+* Returns: {Promise}\n+\n+Asynchronously append data to this file, creating the file if it does not yet\n+exist. `data` can be a string or a [`Buffer`][]. The `Promise` will be\n+resolved with no arguments upon success.\n+\n+If `options` is a string, then it specifies the encoding.\n+\n+The `FileHandle` must have been opened for appending.\n+\n+#### filehandle.chmod(mode)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `mode` {integer}\n+* Returns: {Promise}\n+\n+Modifies the permissions on the file. The `Promise` is resolved with no\n+arguments upon success.\n+\n+#### filehandle.chown(uid, gid)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `uid` {integer}\n+* `gid` {integer}\n+* Returns: {Promise}\n+\n+Changes the ownership of the file then resolves the `Promise` with no arguments\n+upon success.\n+\n+#### filehandle.close()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* Returns: {Promise} A `Promise` that will be resolved once the underlying\n+  file descriptor is closed, or will be rejected if an error occurs while\n+  closing.\n+\n+Closes the file descriptor.\n+\n+```js\n+async function openAndClose() {\n+  let filehandle;\n+  try {\n+    filehandle = await fs.promises.open('thefile.txt', 'r');\n+  } finally {\n+    if (filehandle !== undefined)\n+      await filehandle.close();\n+  }\n+}\n+```\n+\n+#### filehandle.datasync()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* Returns: {Promise}\n+\n+Asynchronous fdatasync(2). The `Promise` is resolved with no arguments upon\n+success.\n+\n+#### filehandle.read(buffer, offset, length, position)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `buffer` {Buffer|Uint8Array}\n+* `offset` {integer}\n+* `length` {integer}\n+* `position` {integer}\n+* Returns: {Promise}\n+\n+Read data from the file.\n+\n+`buffer` is the buffer that the data will be written to.\n+\n+`offset` is the offset in the buffer to start writing at.\n+\n+`length` is an integer specifying the number of bytes to read.\n+\n+`position` is an argument specifying where to begin reading from in the file.\n+If `position` is `null`, data will be read from the current file position,\n+and the file position will be updated.\n+If `position` is an integer, the file position will remain unchanged.\n+\n+Following successful read, the `Promise` is resolved with an object with a\n+`bytesRead` property specifying the number of bytes read, and a `buffer` property\n+that is a reference to the passed in `buffer` argument.\n+\n+#### filehandle.readFile(options)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `options` {Object|string}\n+  * `encoding` {string|null} **Default:** `null`\n+  * `flag` {string} **Default:** `'r'`\n+* Returns: {Promise}\n+\n+Asynchronously reads the entire contents of a file.\n+\n+The `Promise` is resolved with the contents of the file. If no encoding is\n+specified (using `options.encoding`), the data is returned as a `Buffer`\n+object. Otherwise, the data will be a string.\n+\n+If `options` is a string, then it specifies the encoding.\n+\n+When the `path` is a directory, the behavior of `fs.promises.readFile()` is\n+platform-specific. On macOS, Linux, and Windows, the promise will be rejected\n+with an error. On FreeBSD, a representation of the directory's contents will be\n+returned.\n+\n+The `FileHandle` has to support reading.\n+\n+#### filehandle.stat()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* Returns: {Promise}\n+\n+Retrieves the [`fs.Stats`][] for the file.\n+\n+#### filehandle.sync()\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* Returns: {Promise}\n+\n+Asynchronous fsync(2). The `Promise` is resolved with no arguments upon\n+success.\n+\n+#### filehandle.truncate(len = 0)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `len` {integer} **Default:** `0`\n+* Returns: {Promise}\n+\n+Truncates the file then resolves the `Promise` with no arguments upon success.\n+\n+If the file was larger than `len` bytes, only the first `len` bytes will be\n+retained in the file.\n+\n+For example, the following program retains only the first four bytes of the\n+file:\n+\n+```js\n+console.log(fs.readFileSync('temp.txt', 'utf8'));\n+// Prints: Node.js\n+\n+async function doTruncate() {\n+  const fd = await fs.promises.open('temp.txt', 'r+');\n+  await fs.promises.ftruncate(fd, 4);\n+  console.log(fs.readFileSync('temp.txt', 'utf8'));  // Prints: Node\n+}\n+\n+doTruncate().catch(console.error);\n+```\n+\n+If the file previously was shorter than `len` bytes, it is extended, and the\n+extended part is filled with null bytes ('\\0'). For example,\n+\n+```js\n+console.log(fs.readFileSync('temp.txt', 'utf8'));\n+// Prints: Node.js\n+\n+async function doTruncate() {\n+  const fd = await fs.promises.open('temp.txt', 'r+');\n+  await fs.promises.ftruncate(fd, 10);\n+  console.log(fs.readFileSync('temp.txt', 'utf8'));  // Prints Node.js\\0\\0\\0\n+}\n+\n+doTruncate().catch(console.error);\n+```\n+\n+The last three bytes are null bytes ('\\0'), to compensate the over-truncation.\n+\n+#### filehandle.utimes(atime, mtime)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `atime` {number|string|Date}\n+* `mtime` {number|string|Date}`\n+* Returns: {Promise}\n+\n+Change the file system timestamps of the object referenced by the `FileHandle`\n+then resolves the `Promise` with no arguments upon success.\n+\n+This function does not work on AIX versions before 7.1, it will resolve the\n+`Promise` with an error using code `UV_ENOSYS`.\n+\n+#### filehandle.write(buffer, offset, length, position)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `buffer` {Buffer|Uint8Array}\n+* `offset` {integer}\n+* `length` {integer}\n+* `position` {integer}\n+* Returns: {Promise}\n+\n+Write `buffer` to the file.\n+\n+The `Promise` is resolved with an object containing a `bytesWritten` property\n+identifying the number of bytes written, and a `buffer` property containing\n+a reference to the `buffer` written.\n+\n+`offset` determines the part of the buffer to be written, and `length` is\n+an integer specifying the number of bytes to write.\n+\n+`position` refers to the offset from the beginning of the file where this data\n+should be written. If `typeof position !== 'number'`, the data will be written\n+at the current position. See pwrite(2).\n+\n+It is unsafe to use `filehandle.write()` multiple times on the same file\n+without waiting for the `Promise` to be resolved (or rejected). For this\n+scenario, `fs.createWriteStream` is strongly recommended.\n+\n+On Linux, positional writes do not work when the file is opened in append mode.\n+The kernel ignores the position argument and always appends the data to\n+the end of the file.\n+\n+#### filehandle.writeFile(data, options)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+* `data` {string|Buffer|Uint8Array}\n+* `options` {Object|string}\n+  * `encoding` {string|null} **Default:** `'utf8'`\n+  * `mode` {integer} **Default:** `0o666`\n+  * `flag` {string} **Default:** `'w'`\n+* Returns: {Promise}\n+\n+Asynchronously writes data to a file, replacing the file if it already exists.\n+`data` can be a string or a buffer. The `Promise` will be resolved with no\n+arguments upon success.\n+\n+The `encoding` option is ignored if `data` is a buffer. It defaults\n+to `'utf8'`.\n+\n+If `options` is a string, then it specifies the encoding.\n+\n+The `FileHandle` has to support writing.\n+\n+It is unsafe to use `filehandle.writeFile()` multiple times on the same file\n+without waiting for the `Promise` to be resolved (or rejected).\n+\n+### fs.promises.access(path[, mode])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* `mode` {integer} **Default:** `fs.constants.F_OK`\n+* Returns: {Promise}\n+\n+Tests a user's permissions for the file or directory specified by `path`.\n+The `mode` argument is an optional integer that specifies the accessibility\n+checks to be performed. The following constants define the possible values of\n+`mode`. It is possible to create a mask consisting of the bitwise OR of two or\n+more values (e.g. `fs.constants.W_OK | fs.constants.R_OK`).\n+\n+* `fs.constants.F_OK` - `path` is visible to the calling process. This is useful\n+for determining if a file exists, but says nothing about `rwx` permissions.\n+Default if no `mode` is specified.\n+* `fs.constants.R_OK` - `path` can be read by the calling process.\n+* `fs.constants.W_OK` - `path` can be written by the calling process.\n+* `fs.constants.X_OK` - `path` can be executed by the calling process. This has\n+no effect on Windows (will behave like `fs.constants.F_OK`).\n+\n+If the accessibility check is successful, the `Promise` is resolved with no\n+value. If any of the accessibility checks fail, the `Promise` is rejected\n+with an `Error` object. The following example checks if the file\n+`/etc/passwd` can be read and written by the current process.\n+\n+```js\n+fs.promises.access('/etc/passwd', fs.constants.R_OK | fs.constants.W_OK)\n+  .then(() => console.log('can access'))\n+  .catch(() => console.error('cannot access'));\n+```\n+\n+Using `fs.promises.access()` to check for the accessibility of a file before\n+calling `fs.promises.open()` is not recommended. Doing so introduces a race\n+condition, since other processes may change the file's state between the two\n+calls. Instead, user code should open/read/write the file directly and handle\n+the error raised if the file is not accessible.\n+\n+### fs.promises.appendFile(file, data[, options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `file` {string|Buffer|[FileHandle][]} filename or `FileHandle`\n+* `data` {string|Buffer}\n+* `options` {Object|string}\n+  * `encoding` {string|null} **Default:** `'utf8'`\n+  * `mode` {integer} **Default:** `0o666`\n+  * `flag` {string} **Default:** `'a'`\n+* Returns: {Promise}\n+\n+Asynchronously append data to a file, creating the file if it does not yet\n+exist. `data` can be a string or a [`Buffer`][]. The `Promise` will be\n+resolved with no arguments upon success.\n+\n+If `options` is a string, then it specifies the encoding.\n+\n+The `file` may be specified as a `FileHandle` that has been opened\n+for appending (using `fs.promises.open()`).\n+\n+### fs.promises.chmod(path, mode)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* `mode` {integer}\n+* Returns: {Promise}\n+\n+Changes the permissions of a file then resolves the `Promise` with no\n+arguments upon succces.\n+\n+### fs.promises.chown(path, uid, gid)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* `uid` {integer}\n+* `gid` {integer}\n+* Returns: {Promise}\n+\n+Changes the ownership of a file then resolves the `Promise` with no arguments\n+upon success.\n+\n+### fs.promises.copyFile(src, dest[, flags])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `src` {string|Buffer|URL} source filename to copy\n+* `dest` {string|Buffer|URL} destination filename of the copy operation\n+* `flags` {number} modifiers for copy operation. **Default:** `0`\n+* Returns: {Promise}\n+\n+Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it\n+already exists. The `Promise` will be resolved with no arguments upon success.\n+\n+Node.js makes no guarantees about the atomicity of the copy operation. If an\n+error occurs after the destination file has been opened for writing, Node.js\n+will attempt to remove the destination.\n+\n+`flags` is an optional integer that specifies the behavior\n+of the copy operation. The only supported flag is `fs.constants.COPYFILE_EXCL`,\n+which causes the copy operation to fail if `dest` already exists.\n+\n+Example:\n+\n+```js\n+const fs = require('fs');\n+\n+// destination.txt will be created or overwritten by default.\n+fs.promises.copyFile('source.txt', 'destination.txt')\n+  .then(() => console.log('source.txt was copied to destination.txt'))\n+  .catch(() => console.log('The file could not be copied'));\n+```\n+\n+If the third argument is a number, then it specifies `flags`, as shown in the\n+following example.\n+\n+```js\n+const fs = require('fs');\n+const { COPYFILE_EXCL } = fs.constants;\n+\n+// By using COPYFILE_EXCL, the operation will fail if destination.txt exists.\n+fs.promises.copyFile('source.txt', 'destination.txt', COPYFILE_EXCL)\n+  .then(() => console.log('source.txt was copied to destination.txt'))\n+  .catch(() => console.log('The file could not be copied'));\n+```\n+\n+### fs.promises.fchmod(filehandle, mode)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `filehandle` {[FileHandle][]}\n+* `mode` {integer}\n+* Returns: {Promise}\n+\n+Asynchronous fchmod(2). The `Promise` is resolved with no arguments upon\n+success.\n+\n+### fs.promises.fchown(filehandle, uid, gid)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `filehandle` {[FileHandle][]}\n+* `uid` {integer}\n+* `gid` {integer}\n+* Returns: {Promise}\n+\n+Changes the ownership of the file represented by `filehandle` then resolves\n+the `Promise` with no arguments upon success.\n+\n+### fs.promises.fdatasync(filehandle)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `filehandle` {[FileHandle][]}\n+* Returns: {Promise}\n+\n+Asynchronous fdatasync(2). The `Promise` is resolved with no arguments upon\n+success.\n+\n+### fs.promises.fstat(filehandle)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `filehandle` {[FileHandle][]}\n+* Returns: {Promise}\n+\n+Retrieves the [`fs.Stats`][] for the given `filehandle`.\n+\n+### fs.promises.fsync(filehandle)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `filehandle` {[FileHandle][]}\n+* Returns: {Promise}\n+\n+Asynchronous fsync(2). The `Promise` is resolved with no arguments upon\n+success.\n+\n+### fs.promises.ftruncate(filehandle[, len])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `filehandle` {[FileHandle][]}\n+* `len` {integer} **Default:** `0`\n+* Returns: {Promise}\n+\n+Truncates the file represented by `filehandle` then resolves the `Promise`\n+with no arguments upon success.\n+\n+If the file referred to by the `FileHandle` was larger than `len` bytes, only\n+the first `len` bytes will be retained in the file.\n+\n+For example, the following program retains only the first four bytes of the\n+file:\n+\n+```js\n+console.log(fs.readFileSync('temp.txt', 'utf8'));\n+// Prints: Node.js\n+\n+async function doTruncate() {\n+  const fd = await fs.promises.open('temp.txt', 'r+');\n+  await fs.promises.ftruncate(fd, 4);\n+  console.log(fs.readFileSync('temp.txt', 'utf8'));  // Prints: Node\n+}\n+\n+doTruncate().catch(console.error);\n+```\n+\n+If the file previously was shorter than `len` bytes, it is extended, and the\n+extended part is filled with null bytes ('\\0'). For example,\n+\n+```js\n+console.log(fs.readFileSync('temp.txt', 'utf8'));\n+// Prints: Node.js\n+\n+async function doTruncate() {\n+  const fd = await fs.promises.open('temp.txt', 'r+');\n+  await fs.promises.ftruncate(fd, 10);\n+  console.log(fs.readFileSync('temp.txt', 'utf8'));  // Prints Node.js\\0\\0\\0\n+}\n+\n+doTruncate().catch(console.error);\n+```\n+\n+The last three bytes are null bytes ('\\0'), to compensate the over-truncation.\n+\n+### fs.promises.futimes(filehandle, atime, mtime)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `filehandle` {[FileHandle][]}\n+* `atime` {number|string|Date}\n+* `mtime` {number|string|Date}`\n+* Returns: {Promise}\n+\n+Change the file system timestamps of the object referenced by the supplied\n+`FileHandle` then resolves the `Promise` with no arguments upon success.\n+\n+This function does not work on AIX versions before 7.1, it will resolve the\n+`Promise` with an error using code `UV_ENOSYS`.\n+\n+### fs.promises.lchmod(path, mode)\n+<!-- YAML\n+deprecated: REPLACEME\n+-->\n+\n+* `path` {string|Buffer}\n+* `mode` {integer}\n+* Returns: {Promise}\n+\n+Changes the permissions on a symbolic link then resolves the `Promise` with\n+no arguments upon success. This method is only implemented on macOS.\n+\n+### fs.promises.lchown(path, uid, gid)\n+<!-- YAML\n+deprecated: REPLACEME\n+-->\n+\n+* `path` {string|Buffer}\n+* `uid` {integer}\n+* `gid` {integer}\n+* Returns: {Promise}\n+\n+Changes the ownership on a symbolic link then resolves the `Promise` with\n+no arguments upon success. This method is only implemented on macOS.\n+\n+### fs.promises.link(existingPath, newPath)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `existingPath` {string|Buffer|URL}\n+* `newPath` {string|Buffer|URL}\n+* Returns: {Promise}\n+\n+Asynchronous link(2). The `Promise` is resolved with no arguments upon success.\n+\n+### fs.promises.lstat(path)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* Returns: {Promise}\n+\n+Asynchronous lstat(2). The `Promise` is resolved with the [`fs.Stats`][] object\n+for the given symbolic link `path`.\n+\n+### fs.promises.mkdir(path[, mode])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* `mode` {integer} **Default:** `0o777`\n+* Returns: {Promise}\n+\n+Asynchronously creates a directory then resolves the `Promise` with no\n+arguments upon success.\n+\n+### fs.promises.mkdtemp(prefix[, options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `prefix` {string}\n+* `options` {string|Object}\n+  * `encoding` {string} **Default:** `'utf8'`\n+* Returns: {Promise}\n+\n+Creates a unique temporary directory then resolves the `Promise` with the\n+created folder path. A unique directory name is generated by appending six\n+random characters to the end of the provided `prefix`.\n+\n+The optional `options` argument can be a string specifying an encoding, or an\n+object with an `encoding` property specifying the character encoding to use.\n+\n+Example:\n+\n+```js\n+fs.promises.mkdtemp(path.join(os.tmpdir(), 'foo-'))\n+  .catch(console.error);\n+```\n+\n+The `fs.mkdtemp()` method will append the six randomly selected characters\n+directly to the `prefix` string. For instance, given a directory `/tmp`, if the\n+intention is to create a temporary directory *within* `/tmp`, the `prefix`\n+*must* end with a trailing platform-specific path separator\n+(`require('path').sep`).\n+\n+### fs.promises.open(path, flags[, mode])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* `flags` {string|number}\n+* `mode` {integer} **Default:** `0o666`\n+* Return: {Promise}\n+\n+Asynchronous file open that returns a `Promise` that, when resolved, yields a\n+`FileHandle` object. See open(2).\n+\n+The `flags` argument can be:\n+\n+* `'r'` - Open file for reading.\n+An exception occurs if the file does not exist.\n+\n+* `'r+'` - Open file for reading and writing.\n+An exception occurs if the file does not exist.\n+\n+* `'rs+'` - Open file for reading and writing in synchronous mode. Instructs\n+  the operating system to bypass the local file system cache.\n+\n+  This is primarily useful for opening files on NFS mounts as it allows skipping\n+  the potentially stale local cache. It has a very real impact on I/O\n+  performance so using this flag is not recommended unless it is needed.\n+\n+  Note that this does not turn `fs.promises.open()` into a synchronous blocking\n+  call.\n+\n+* `'w'` - Open file for writing.\n+The file is created (if it does not exist) or truncated (if it exists).\n+\n+* `'wx'` - Like `'w'` but fails if `path` exists.\n+\n+* `'w+'` - Open file for reading and writing.\n+The file is created (if it does not exist) or truncated (if it exists).\n+\n+* `'wx+'` - Like `'w+'` but fails if `path` exists.\n+\n+* `'a'` - Open file for appending.\n+The file is created if it does not exist.\n+\n+* `'ax'` - Like `'a'` but fails if `path` exists.\n+\n+* `'a+'` - Open file for reading and appending.\n+The file is created if it does not exist.\n+\n+* `'ax+'` - Like `'a+'` but fails if `path` exists.\n+\n+`mode` sets the file mode (permission and sticky bits), but only if the file was\n+created. It defaults to `0o666` (readable and writable).\n+\n+The exclusive flag `'x'` (`O_EXCL` flag in open(2)) ensures that `path` is newly\n+created. On POSIX systems, `path` is considered to exist even if it is a symlink\n+to a non-existent file. The exclusive flag may or may not work with network file\n+systems.\n+\n+`flags` can also be a number as documented by open(2); commonly used constants\n+are available from `fs.constants`.  On Windows, flags are translated to\n+their equivalent ones where applicable, e.g. `O_WRONLY` to `FILE_GENERIC_WRITE`,\n+or `O_EXCL|O_CREAT` to `CREATE_NEW`, as accepted by CreateFileW.\n+\n+On Linux, positional writes don't work when the file is opened in append mode.\n+The kernel ignores the position argument and always appends the data to\n+the end of the file.\n+\n+The behavior of `fs.promises.open()` is platform-specific for some\n+flags. As such, opening a directory on macOS and Linux with the `'a+'` flag will\n+return an error. In contrast, on Windows and FreeBSD, a `FileHandle` will be\n+returned.\n+\n+Some characters (`< > : \" / \\ | ? *`) are reserved under Windows as documented\n+by [Naming Files, Paths, and Namespaces][]. Under NTFS, if the filename contains\n+a colon, Node.js will open a file system stream, as described by\n+[this MSDN page][MSDN-Using-Streams].\n+\n+*Note:* On Windows, opening an existing hidden file using the `w` flag (e.g.\n+using `fs.promises.open()`) will fail with `EPERM`. Existing hidden\n+files can be opened for writing with the `r+` flag. A call to\n+`fs.promises.ftruncate()` can be used to reset the file contents.\n+\n+### fs.promises.read(filehandle, buffer, offset, length, position)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `filehandle` {[FileHandle][]}\n+* `buffer` {Buffer|Uint8Array}\n+* `offset` {integer}\n+* `length` {integer}\n+* `position` {integer}\n+* Returns: {Promise}\n+\n+Read data from the file specified by `filehandle`.\n+\n+`buffer` is the buffer that the data will be written to.\n+\n+`offset` is the offset in the buffer to start writing at.\n+\n+`length` is an integer specifying the number of bytes to read.\n+\n+`position` is an argument specifying where to begin reading from in the file.\n+If `position` is `null`, data will be read from the current file position,\n+and the file position will be updated.\n+If `position` is an integer, the file position will remain unchanged.\n+\n+Following successful read, the `Promise` is resolved with an object with a\n+`bytesRead` property specifying the number of bytes read, and a `buffer` property\n+that is a reference to the passed in `buffer` argument.\n+\n+### fs.promises.readdir(path[, options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* `options` {string|Object}\n+  * `encoding` {string} **Default:** `'utf8'`\n+* Returns: {Promise}\n+\n+Reads the contents of a directory then resolves the `Promise` with an array\n+of the names of the files in the directory excludiing `'.'` and `'..'`.\n+\n+The optional `options` argument can be a string specifying an encoding, or an\n+object with an `encoding` property specifying the character encoding to use for\n+the filenames. If the `encoding` is set to `'buffer'`, the filenames returned\n+will be passed as `Buffer` objects.\n+\n+### fs.promises.readFile(path[, options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL|[FileHandle][]} filename or `FileHandle`\n+* `options` {Object|string}\n+  * `encoding` {string|null} **Default:** `null`\n+  * `flag` {string} **Default:** `'r'`\n+* Returns: {Promise}\n+\n+Asynchronously reads the entire contents of a file.\n+\n+The `Promise` is resolved with the contents of the file. If no encoding is\n+specified (using `options.encoding`), the data is returned as a `Buffer`\n+object. Otherwise, the data will be a string.\n+\n+If `options` is a string, then it specifies the encoding.\n+\n+When the `path` is a directory, the behavior of `fs.promises.readFile()` is\n+platform-specific. On macOS, Linux, and Windows, the promise will be rejected\n+with an error. On FreeBSD, a representation of the directory's contents will be\n+returned.\n+\n+Any specified `FileHandle` has to support reading.\n+\n+### fs.promises.readlink(path[, options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* `options` {string|Object}\n+  * `encoding` {string} **Default:** `'utf8'`\n+* Returns: {Promise}\n+\n+Asynchronous readlink(2). The `Promise` is resolved with the `linkString` upon\n+success.\n+\n+The optional `options` argument can be a string specifying an encoding, or an\n+object with an `encoding` property specifying the character encoding to use for\n+the link path returned. If the `encoding` is set to `'buffer'`, the link path\n+returned will be passed as a `Buffer` object.\n+\n+### fs.promises.realpath(path[, options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* `options` {string|Object}\n+  * `encoding` {string} **Default:** `'utf8'`\n+* Returns: {Promise}\n+\n+Determines the actual location of `path` using the same semantics as the\n+`fs.realpath.native()` function then resolves the `Promise` with the resolved\n+path.\n+\n+Only paths that can be converted to UTF8 strings are supported.\n+\n+The optional `options` argument can be a string specifying an encoding, or an\n+object with an `encoding` property specifying the character encoding to use for\n+the path. If the `encoding` is set to `'buffer'`, the path returned will be\n+passed as a `Buffer` object.\n+\n+On Linux, when Node.js is linked against musl libc, the procfs file system must\n+be mounted on `/proc` in order for this function to work.  Glibc does not have\n+this restriction.\n+\n+### fs.promises.rename(oldPath, newPath)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `oldPath` {string|Buffer|URL}\n+* `newPath` {string|Buffer|URL}\n+* Returns: {Promise}\n+\n+Renames `oldPath` to `newPath` and resolves the `Promise` with no arguments\n+upon success.\n+\n+### fs.promises.rmdir(path)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* Returns: {Promise}\n+\n+Removes the directory identified by `path` then resolves the `Promise` with\n+no arguments upon success.\n+\n+Using `fs.promises.rmdir()` on a file (not a directory) results in the\n+`Promise` being rejected with an `ENOENT` error on Windows and an `ENOTDIR`\n+error on POSIX.\n+\n+### fs.promises.stat(path)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* Returns: {Promise}\n+\n+The `Promise` is resolved with the [`fs.Stats`][] object for the given `path`.\n+\n+### fs.promises.symlink(target, path[, type])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `target` {string|Buffer|URL}\n+* `path` {string|Buffer|URL}\n+* `type` {string} **Default:** `'file'`\n+* Returns: {Promise}\n+\n+Creates a symbolic link then resolves the `Promise` with no arguments upon\n+success.\n+\n+The `type` argument is only used on Windows platforms and can be one of `'dir'`,\n+`'file'`, or `'junction'` (default is `'file'`). Note that Windows junction\n+points require the destination path to be absolute. When using `'junction'`,\n+the `target` argument will automatically be normalized to absolute path.\n+\n+### fs.promises.truncate(path[, len])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer}\n+* `len` {integer} **Default:** `0`\n+* Returns: {Promise}\n+\n+Truncates the `path` then resolves the `Promise` with no arguments upon\n+success. The `path` *must* be a string or `Buffer`.\n+\n+### fs.promises.unlink(path)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* Returns: {Promise}\n+\n+Asynchronous unlink(2). The `Promise` is resolved with no arguments upon\n+success.\n+\n+### fs.promises.utimes(path, atime, mtime)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `path` {string|Buffer|URL}\n+* `atime` {number|string|Date}\n+* `mtime` {number|string|Date}\n+* Returns: {Promise}\n+\n+Change the file system timestamps of the object referenced by `path` then\n+resolves the `Promise` with no arguments upon success.\n+\n+The `atime` and `mtime` arguments follow these rules:\n+- Values can be either numbers representing Unix epoch time, `Date`s, or a\n+  numeric string like `'123456789.0'`.\n+- If the value can not be converted to a number, or is `NaN`, `Infinity` or\n+  `-Infinity`, an `Error` will be thrown.\n+\n+### fs.promises.write(filehandle, buffer[, offset[, length[, position]]])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `filehandle` {[FileHandle][]}\n+* `buffer` {Buffer|Uint8Array}\n+* `offset` {integer}\n+* `length` {integer}\n+* `position` {integer}\n+* Returns: {Promise}\n+\n+Write `buffer` to the file specified by `filehandle`.\n+\n+The `Promise` is resolved with an object containing a `bytesWritten` property\n+identifying the number of bytes written, and a `buffer` property containing\n+a reference to the `buffer` written.\n+\n+`offset` determines the part of the buffer to be written, and `length` is\n+an integer specifying the number of bytes to write.\n+\n+`position` refers to the offset from the beginning of the file where this data\n+should be written. If `typeof position !== 'number'`, the data will be written\n+at the current position. See pwrite(2).\n+\n+It is unsafe to use `fs.promises.write()` multiple times on the same file\n+without waiting for the `Promise` to be resolved (or rejected). For this\n+scenario, `fs.createWriteStream` is strongly recommended.\n+\n+On Linux, positional writes do not work when the file is opened in append mode.\n+The kernel ignores the position argument and always appends the data to\n+the end of the file.\n+\n+### fs.promises.writeFile(file, data[, options])\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `file` {string|Buffer|[FileHandle][]} filename or `FileHandle`\n+* `data` {string|Buffer|Uint8Array}\n+* `options` {Object|string}\n+  * `encoding` {string|null} **Default:** `'utf8'`\n+  * `mode` {integer} **Default:** `0o666`\n+  * `flag` {string} **Default:** `'w'`\n+* Returns: {Promise}\n+\n+Asynchronously writes data to a file, replacing the file if it already exists.\n+`data` can be a string or a buffer. The `Promise` will be resolved with no\n+arguments upon success.\n+\n+The `encoding` option is ignored if `data` is a buffer. It defaults\n+to `'utf8'`.\n+\n+If `options` is a string, then it specifies the encoding.\n+\n+Any specified `FileHandle` has to support writing.\n+\n+It is unsafe to use `fs.promises.writeFile()` multiple times on the same file\n+without waiting for the `Promise` to be resolved (or rejected).\n+\n+\n ## FS Constants\n \n The following constants are exported by `fs.constants`.\n@@ -3478,6 +4469,7 @@ The following constants are meant for use with the [`fs.Stats`][] object's\n [`util.promisify()`]: util.html#util_util_promisify_original\n [Caveats]: #fs_caveats\n [Common System Errors]: errors.html#errors_common_system_errors\n+[FileHandle]: #fs_class_filehandle\n [FS Constants]: #fs_fs_constants_1\n [MDN-Date]: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date\n [MDN-Number]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type"
        },
        {
            "sha": "2bac855d0f3b4860dc2ae5906ffafd9290f3d57d",
            "filename": "lib/fs.js",
            "status": "modified",
            "additions": 485,
            "deletions": 7,
            "changes": 492,
            "blob_url": "https://github.com/nodejs/node/blob/329fc78e4919231bf76771797878f7b0db0f73ac/lib%2Ffs.js",
            "raw_url": "https://github.com/nodejs/node/raw/329fc78e4919231bf76771797878f7b0db0f73ac/lib%2Ffs.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ffs.js?ref=329fc78e4919231bf76771797878f7b0db0f73ac",
            "patch": "@@ -53,6 +53,9 @@ Object.defineProperty(exports, 'constants', {\n   value: constants\n });\n \n+const kHandle = Symbol('handle');\n+const { kUsePromises } = binding;\n+\n const kMinPoolSpace = 128;\n const { kMaxLength } = require('buffer');\n \n@@ -343,13 +346,11 @@ Stats.prototype.isSocket = function() {\n \n const statValues = binding.statValues;\n \n-function statsFromValues() {\n-  return new Stats(statValues[0], statValues[1], statValues[2], statValues[3],\n-                   statValues[4], statValues[5],\n-                   statValues[6] < 0 ? undefined : statValues[6], statValues[7],\n-                   statValues[8], statValues[9] < 0 ? undefined : statValues[9],\n-                   statValues[10], statValues[11], statValues[12],\n-                   statValues[13]);\n+function statsFromValues(stats = statValues) {\n+  return new Stats(stats[0], stats[1], stats[2], stats[3], stats[4], stats[5],\n+                   stats[6] < 0 ? undefined : stats[6], stats[7], stats[8],\n+                   stats[9] < 0 ? undefined : stats[9], stats[10], stats[11],\n+                   stats[12], stats[13]);\n }\n \n // Don't allow mode to accidentally be overwritten.\n@@ -2654,3 +2655,480 @@ Object.defineProperty(fs, 'SyncWriteStream', {\n   set: internalUtil.deprecate((val) => { SyncWriteStream = val; },\n                               'fs.SyncWriteStream is deprecated.', 'DEP0061')\n });\n+\n+// Promises API\n+\n+class FileHandle {\n+  constructor(filehandle) {\n+    this[kHandle] = filehandle;\n+  }\n+\n+  getAsyncId() {\n+    return this[kHandle].getAsyncId();\n+  }\n+\n+  get fd() {\n+    return this[kHandle].fd;\n+  }\n+\n+  appendFile(data, options) {\n+    return promises.appendFile(this, data, options);\n+  }\n+\n+  chmod(mode) {\n+    return promises.fchmod(this, mode);\n+  }\n+\n+  chown(uid, gid) {\n+    return promises.fchown(this, uid, gid);\n+  }\n+\n+  datasync() {\n+    return promises.fdatasync(this);\n+  }\n+\n+  sync() {\n+    return promises.fsync(this);\n+  }\n+\n+\n+  read(buffer, offset, length, position) {\n+    return promises.read(this, buffer, offset, length, position);\n+  }\n+\n+  readFile(options) {\n+    return promises.readFile(this, options);\n+  }\n+\n+  stat() {\n+    return promises.fstat(this);\n+  }\n+\n+  truncate(len = 0) {\n+    return promises.ftruncate(this, len);\n+  }\n+\n+  utimes(atime, mtime) {\n+    return promises.futimes(this, atime, mtime);\n+  }\n+\n+  write(buffer, offset, length, position) {\n+    return promises.write(this, buffer, offset, length, position);\n+  }\n+\n+  writeFile(data, options) {\n+    return promises.writeFile(this, data, options);\n+  }\n+\n+  close() {\n+    return this[kHandle].close();\n+  }\n+}\n+\n+\n+function validateFileHandle(handle) {\n+  if (!(handle instanceof FileHandle))\n+    throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n+                               'filehandle', 'FileHandle');\n+}\n+\n+async function writeFileHandle(filehandle, data, options) {\n+  let buffer = isUint8Array(data) ?\n+    data : Buffer.from('' + data, options.encoding || 'utf8');\n+  let remaining = buffer.length;\n+  if (remaining === 0) return;\n+  do {\n+    const { bytesWritten } =\n+      await promises.write(filehandle, buffer, 0,\n+                           Math.min(16384, buffer.length));\n+    remaining -= bytesWritten;\n+    buffer = buffer.slice(bytesWritten);\n+  } while (remaining > 0);\n+}\n+\n+async function readFileHandle(filehandle, options) {\n+  const statFields = await binding.fstat(filehandle.fd, kUsePromises);\n+\n+  let size;\n+  if ((statFields[1/*mode*/] & S_IFMT) === S_IFREG) {\n+    size = statFields[8/*size*/];\n+  } else {\n+    size = 0;\n+  }\n+\n+  if (size === 0)\n+    return Buffer.alloc(0);\n+\n+  if (size > kMaxLength)\n+    throw new errors.RangeError('ERR_BUFFER_TOO_LARGE');\n+\n+  const chunks = [];\n+  const chunkSize = Math.min(size, 16384);\n+  const buf = Buffer.alloc(chunkSize);\n+  let read = 0;\n+  do {\n+    const { bytesRead, buffer } =\n+      await promises.read(filehandle, buf, 0, buf.length);\n+    read = bytesRead;\n+    if (read > 0)\n+      chunks.push(buffer.slice(0, read));\n+  } while (read === chunkSize);\n+\n+  return Buffer.concat(chunks);\n+}\n+\n+// All of the functions in fs.promises are defined as async in order to\n+// ensure that errors thrown cause promise rejections rather than being\n+// thrown synchronously\n+const promises = {\n+  async access(path, mode = fs.F_OK) {\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path);\n+\n+    mode = mode | 0;\n+    return binding.access(pathModule.toNamespacedPath(path), mode,\n+                          kUsePromises);\n+  },\n+\n+  async copyFile(src, dest, flags) {\n+    handleError((src = getPathFromURL(src)));\n+    handleError((dest = getPathFromURL(dest)));\n+    nullCheck(src);\n+    nullCheck(dest);\n+    validatePath(src, 'src');\n+    validatePath(dest, 'dest');\n+    flags = flags | 0;\n+    return binding.copyFile(pathModule.toNamespacedPath(src),\n+                            pathModule.toNamespacedPath(dest),\n+                            flags, kUsePromises);\n+  },\n+\n+  // Note that unlike fs.open() which uses numeric file descriptors,\n+  // promises.open() uses the fs.FileHandle class.\n+  async open(path, flags, mode) {\n+    mode = modeNum(mode, 0o666);\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path);\n+    validateUint32(mode, 'mode');\n+    return new FileHandle(\n+      await binding.openFileHandle(pathModule.toNamespacedPath(path),\n+                                   stringToFlags(flags),\n+                                   mode, kUsePromises));\n+  },\n+\n+  async read(handle, buffer, offset, length, position) {\n+    validateFileHandle(handle);\n+    validateBuffer(buffer);\n+\n+    offset |= 0;\n+    length |= 0;\n+\n+    if (length === 0)\n+      return { bytesRead: length, buffer };\n+\n+    validateOffsetLengthRead(offset, length, buffer.length);\n+\n+    if (!isUint32(position))\n+      position = -1;\n+\n+    const bytesRead = (await binding.read(handle.fd, buffer, offset, length,\n+                                          position, kUsePromises)) || 0;\n+\n+    return { bytesRead, buffer };\n+  },\n+\n+  async write(handle, buffer, offset, length, position) {\n+    validateFileHandle(handle);\n+\n+    if (buffer.length === 0)\n+      return { bytesWritten: 0, buffer };\n+\n+    if (isUint8Array(buffer)) {\n+      if (typeof offset !== 'number')\n+        offset = 0;\n+      if (typeof length !== 'number')\n+        length = buffer.length - offset;\n+      if (typeof position !== 'number')\n+        position = null;\n+      validateOffsetLengthWrite(offset, length, buffer.byteLength);\n+      const bytesWritten =\n+        (await binding.writeBuffer(handle.fd, buffer, offset,\n+                                   length, position, kUsePromises)) || 0;\n+      return { bytesWritten, buffer };\n+    }\n+\n+    if (typeof buffer !== 'string')\n+      buffer += '';\n+    if (typeof position !== 'function') {\n+      if (typeof offset === 'function') {\n+        position = offset;\n+        offset = null;\n+      } else {\n+        position = length;\n+      }\n+      length = 'utf8';\n+    }\n+    const bytesWritten = (await binding.writeString(handle.fd, buffer, offset,\n+                                                    length, kUsePromises)) || 0;\n+    return { bytesWritten, buffer };\n+  },\n+\n+  async rename(oldPath, newPath) {\n+    handleError((oldPath = getPathFromURL(oldPath)));\n+    handleError((newPath = getPathFromURL(newPath)));\n+    nullCheck(oldPath);\n+    nullCheck(newPath);\n+    validatePath(oldPath, 'oldPath');\n+    validatePath(newPath, 'newPath');\n+    return binding.rename(pathModule.toNamespacedPath(oldPath),\n+                          pathModule.toNamespacedPath(newPath),\n+                          kUsePromises);\n+  },\n+\n+  async truncate(path, len = 0) {\n+    return promises.ftruncate(await promises.open(path, 'r+'), len);\n+  },\n+\n+  async ftruncate(handle, len = 0) {\n+    validateFileHandle(handle);\n+    validateLen(len);\n+    len = Math.max(0, len);\n+    return binding.ftruncate(handle.fd, len, kUsePromises);\n+  },\n+\n+  async rmdir(path) {\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path);\n+    return binding.rmdir(pathModule.toNamespacedPath(path), kUsePromises);\n+  },\n+\n+  async fdatasync(handle) {\n+    validateFileHandle(handle);\n+    return binding.fdatasync(handle.fd, kUsePromises);\n+  },\n+\n+  async fsync(handle) {\n+    validateFileHandle(handle);\n+    return binding.fsync(handle.fd, kUsePromises);\n+  },\n+\n+  async mkdir(path, mode) {\n+    mode = modeNum(mode, 0o777);\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path);\n+    validateUint32(mode, 'mode');\n+    return binding.mkdir(pathModule.toNamespacedPath(path), mode, kUsePromises);\n+  },\n+\n+  async readdir(path, options) {\n+    options = getOptions(options, {});\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path);\n+    return binding.readdir(pathModule.toNamespacedPath(path),\n+                           options.encoding, kUsePromises);\n+  },\n+\n+  async readlink(path, options) {\n+    options = getOptions(options, {});\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path, 'oldPath');\n+    return binding.readlink(pathModule.toNamespacedPath(path),\n+                            options.encoding, kUsePromises);\n+  },\n+\n+  async symlink(target, path, type_) {\n+    const type = (typeof type_ === 'string' ? type_ : null);\n+    handleError((target = getPathFromURL(target)));\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(target);\n+    nullCheck(path);\n+    validatePath(target, 'target');\n+    validatePath(path);\n+    return binding.symlink(preprocessSymlinkDestination(target, type, path),\n+                           pathModule.toNamespacedPath(path),\n+                           stringToSymlinkType(type),\n+                           kUsePromises);\n+  },\n+\n+  async fstat(handle) {\n+    validateFileHandle(handle);\n+    return statsFromValues(await binding.fstat(handle.fd, kUsePromises));\n+  },\n+\n+  async lstat(path) {\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path);\n+    return statsFromValues(\n+      await binding.lstat(pathModule.toNamespacedPath(path), kUsePromises));\n+  },\n+\n+  async stat(path) {\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path);\n+    return statsFromValues(\n+      await binding.stat(pathModule.toNamespacedPath(path), kUsePromises));\n+  },\n+\n+  async link(existingPath, newPath) {\n+    handleError((existingPath = getPathFromURL(existingPath)));\n+    handleError((newPath = getPathFromURL(newPath)));\n+    nullCheck(existingPath);\n+    nullCheck(newPath);\n+    validatePath(existingPath, 'existingPath');\n+    validatePath(newPath, 'newPath');\n+    return binding.link(pathModule.toNamespacedPath(existingPath),\n+                        pathModule.toNamespacedPath(newPath),\n+                        kUsePromises);\n+  },\n+\n+  async unlink(path) {\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path);\n+    return binding.unlink(pathModule.toNamespacedPath(path), kUsePromises);\n+  },\n+\n+  async fchmod(handle, mode) {\n+    mode = modeNum(mode);\n+    validateFileHandle(handle);\n+    validateUint32(mode, 'mode');\n+    if (mode < 0 || mode > 0o777)\n+      throw new errors.RangeError('ERR_OUT_OF_RANGE', 'mode');\n+    return binding.fchmod(handle.fd, mode, kUsePromises);\n+  },\n+\n+  async chmod(path, mode) {\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path);\n+    mode = modeNum(mode);\n+    validateUint32(mode, 'mode');\n+    return binding.chmod(pathModule.toNamespacedPath(path), mode, kUsePromises);\n+  },\n+\n+  async lchmod(path, mode) {\n+    if (constants.O_SYMLINK !== undefined) {\n+      const fd = await promises.open(path,\n+                                     constants.O_WRONLY | constants.O_SYMLINK);\n+      return promises.fschmod(fd, mode).finally(fd.close.bind(fd));\n+    }\n+    throw new errors.Error('ERR_METHOD_NOT_IMPLEMENTED');\n+  },\n+\n+  async lchown(path, uid, gid) {\n+    if (constants.O_SYMLINK !== undefined) {\n+      const fd = await promises.open(path,\n+                                     constants.O_WRONLY | constants.O_SYMLINK);\n+      return promises.fschmod(fd, uid, gid).finally(fd.close.bind(fd));\n+    }\n+    throw new errors.Error('ERR_METHOD_NOT_IMPLEMENTED');\n+  },\n+\n+  async fchown(handle, uid, gid) {\n+    validateFileHandle(handle);\n+    validateUint32(uid, 'uid');\n+    validateUint32(gid, 'gid');\n+    return binding.fchown(handle.fd, uid, gid, kUsePromises);\n+  },\n+\n+  async chown(path, uid, gid) {\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path);\n+    validateUint32(uid, 'uid');\n+    validateUint32(gid, 'gid');\n+    return binding.chown(pathModule.toNamespacedPath(path),\n+                         uid, gid, kUsePromises);\n+  },\n+\n+  async utimes(path, atime, mtime) {\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path);\n+    return binding.utimes(pathModule.toNamespacedPath(path),\n+                          toUnixTimestamp(atime),\n+                          toUnixTimestamp(mtime),\n+                          kUsePromises);\n+  },\n+\n+  async futimes(handle, atime, mtime) {\n+    validateFileHandle(handle);\n+    atime = toUnixTimestamp(atime, 'atime');\n+    mtime = toUnixTimestamp(mtime, 'mtime');\n+    return binding.futimes(handle.fd, atime, mtime, kUsePromises);\n+  },\n+\n+  async realpath(path, options) {\n+    options = getOptions(options, {});\n+    handleError((path = getPathFromURL(path)));\n+    nullCheck(path);\n+    validatePath(path);\n+    return binding.realpath(path, options.encoding, kUsePromises);\n+  },\n+\n+  async mkdtemp(prefix, options) {\n+    options = getOptions(options, {});\n+    if (!prefix || typeof prefix !== 'string') {\n+      throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n+                                 'prefix',\n+                                 'string',\n+                                 prefix);\n+    }\n+    nullCheck(prefix);\n+    return binding.mkdtemp(`${prefix}XXXXXX`, options.encoding, kUsePromises);\n+  },\n+\n+  async writeFile(path, data, options) {\n+    options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n+    const flag = options.flag || 'w';\n+\n+    if (path instanceof FileHandle)\n+      return writeFileHandle(path, data, options);\n+\n+    const fd = await promises.open(path, flag, options.mode);\n+    return writeFileHandle(fd, data, options).finally(fd.close.bind(fd));\n+  },\n+\n+  async appendFile(path, data, options) {\n+    options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n+    options = copyObject(options);\n+    options.flag = options.flag || 'a';\n+    return promises.writeFile(path, data, options);\n+  },\n+\n+  async readFile(path, options) {\n+    options = getOptions(options, { flag: 'r' });\n+\n+    if (path instanceof FileHandle)\n+      return readFileHandle(path, options);\n+\n+    const fd = await promises.open(path, options.flag, 0o666);\n+    return readFileHandle(fd, options).finally(fd.close.bind(fd));\n+  }\n+};\n+\n+let warn = true;\n+\n+// TODO(jasnell): Exposing this as a property with a getter works fine with\n+// commonjs but is going to be problematic for named imports support under\n+// ESM. A different approach will have to be followed there.\n+Object.defineProperty(fs, 'promises', {\n+  configurable: true,\n+  enumerable: true,\n+  get() {\n+    if (warn) {\n+      warn = false;\n+      process.emitWarning('The fs.promises API is experimental',\n+                          'ExperimentalWarning');\n+    }\n+    return promises;\n+  }\n+});"
        },
        {
            "sha": "0503c7f2477116fc9ef3598c6fb2d80f59d85465",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/329fc78e4919231bf76771797878f7b0db0f73ac/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/329fc78e4919231bf76771797878f7b0db0f73ac/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=329fc78e4919231bf76771797878f7b0db0f73ac",
            "patch": "@@ -242,7 +242,6 @@ class ModuleWrap;\n   V(sni_context_string, \"sni_context\")                                        \\\n   V(stack_string, \"stack\")                                                    \\\n   V(status_string, \"status\")                                                  \\\n-  V(statfields_string, \"statFields\")                                          \\\n   V(stdio_string, \"stdio\")                                                    \\\n   V(subject_string, \"subject\")                                                \\\n   V(subjectaltname_string, \"subjectaltname\")                                  \\\n@@ -284,6 +283,7 @@ class ModuleWrap;\n   V(context, v8::Context)                                                     \\\n   V(domain_callback, v8::Function)                                            \\\n   V(fd_constructor_template, v8::ObjectTemplate)                              \\\n+  V(fsreqpromise_constructor_template, v8::ObjectTemplate)                    \\\n   V(fdclose_constructor_template, v8::ObjectTemplate)                         \\\n   V(host_import_module_dynamically_callback, v8::Function)                    \\\n   V(host_initialize_import_meta_object_callback, v8::Function)                \\\n@@ -313,6 +313,7 @@ class ModuleWrap;\n   V(vm_parsing_context_symbol, v8::Symbol)                                    \\\n   V(url_constructor_function, v8::Function)                                   \\\n   V(write_wrap_constructor_function, v8::Function)                            \\\n+  V(fs_use_promises_symbol, v8::Symbol)\n \n class Environment;\n "
        },
        {
            "sha": "8f016ccf02695b29d3abb62b2647c79a2601d23a",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 217,
            "deletions": 175,
            "changes": 392,
            "blob_url": "https://github.com/nodejs/node/blob/329fc78e4919231bf76771797878f7b0db0f73ac/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/329fc78e4919231bf76771797878f7b0db0f73ac/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=329fc78e4919231bf76771797878f7b0db0f73ac",
            "patch": "@@ -85,6 +85,7 @@ namespace fs {\n \n using v8::Array;\n using v8::Context;\n+using v8::EscapableHandleScope;\n using v8::Float64Array;\n using v8::Function;\n using v8::FunctionCallbackInfo;\n@@ -100,6 +101,7 @@ using v8::Object;\n using v8::ObjectTemplate;\n using v8::Promise;\n using v8::String;\n+using v8::Symbol;\n using v8::Undefined;\n using v8::Value;\n \n@@ -169,7 +171,7 @@ inline void FileHandle::Close() {\n \n   // If the close was successful, we still want to emit a process warning\n   // to notify that the file descriptor was gc'd. We want to be noisy about\n-  // this because not explicitly closing the garbage collector is a bug.\n+  // this because not explicitly closing the FileHandle is a bug.\n   env()->SetUnrefImmediate([](Environment* env, void* data) {\n     char msg[70];\n     err_detail* detail = static_cast<err_detail*>(data);\n@@ -182,22 +184,22 @@ inline void FileHandle::Close() {\n }\n \n void FileHandle::CloseReq::Resolve() {\n-  InternalCallbackScope callback_scope(this);\n   HandleScope scope(env()->isolate());\n+  InternalCallbackScope callback_scope(this);\n   Local<Promise> promise = promise_.Get(env()->isolate());\n   Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();\n-  resolver->Resolve(env()->context(), Undefined(env()->isolate()));\n+  resolver->Resolve(env()->context(), Undefined(env()->isolate())).FromJust();\n }\n \n void FileHandle::CloseReq::Reject(Local<Value> reason) {\n-  InternalCallbackScope callback_scope(this);\n   HandleScope scope(env()->isolate());\n+  InternalCallbackScope callback_scope(this);\n   Local<Promise> promise = promise_.Get(env()->isolate());\n   Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();\n-  resolver->Reject(env()->context(), reason);\n+  resolver->Reject(env()->context(), reason).FromJust();\n }\n \n-FileHandle* FileHandle::CloseReq::fd() {\n+FileHandle* FileHandle::CloseReq::file_handle() {\n   HandleScope scope(env()->isolate());\n   Local<Value> val = ref_.Get(env()->isolate());\n   Local<Object> obj = val.As<Object>();\n@@ -209,9 +211,9 @@ FileHandle* FileHandle::CloseReq::fd() {\n // there was a problem closing the fd. This is the preferred mechanism for\n // closing the FD object even tho the object will attempt to close\n // automatically on gc.\n-inline Local<Promise> FileHandle::ClosePromise() {\n+inline MaybeLocal<Promise> FileHandle::ClosePromise() {\n   Isolate* isolate = env()->isolate();\n-  HandleScope scope(isolate);\n+  EscapableHandleScope scope(isolate);\n   Local<Context> context = env()->context();\n   auto maybe_resolver = Promise::Resolver::New(context);\n   CHECK(!maybe_resolver.IsEmpty());\n@@ -223,12 +225,12 @@ inline Local<Promise> FileHandle::ClosePromise() {\n     auto AfterClose = [](uv_fs_t* req) {\n       CloseReq* close = static_cast<CloseReq*>(req->data);\n       CHECK_NE(close, nullptr);\n-      close->fd()->closing_ = false;\n+      close->file_handle()->closing_ = false;\n       Isolate* isolate = close->env()->isolate();\n       if (req->result < 0) {\n         close->Reject(UVException(isolate, req->result, \"close\"));\n       } else {\n-        close->fd()->closed_ = true;\n+        close->file_handle()->closed_ = true;\n         close->Resolve();\n       }\n       delete close;\n@@ -241,15 +243,16 @@ inline Local<Promise> FileHandle::ClosePromise() {\n     }\n   } else {\n     // Already closed. Just reject the promise immediately\n-    resolver->Reject(context, UVException(isolate, UV_EBADF, \"close\"));\n+    resolver->Reject(context, UVException(isolate, UV_EBADF, \"close\"))\n+        .FromJust();\n   }\n-  return promise;\n+  return scope.Escape(promise);\n }\n \n void FileHandle::Close(const FunctionCallbackInfo<Value>& args) {\n   FileHandle* fd;\n   ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());\n-  args.GetReturnValue().Set(fd->ClosePromise());\n+  args.GetReturnValue().Set(fd->ClosePromise().ToLocalChecked());\n }\n \n \n@@ -273,24 +276,31 @@ void FSReqWrap::Resolve(Local<Value> value) {\n   MakeCallback(env()->oncomplete_string(), arraysize(argv), argv);\n }\n \n+void FSReqWrap::SetReturnValue(const FunctionCallbackInfo<Value>& args) {\n+  args.GetReturnValue().SetUndefined();\n+}\n+\n+void FSReqPromise::SetReturnValue(const FunctionCallbackInfo<Value>& args) {\n+  Local<Context> context = env()->context();\n+  args.GetReturnValue().Set(\n+    object()->Get(context, env()->promise_string()).ToLocalChecked());\n+}\n+\n void NewFSReqWrap(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args.IsConstructCall());\n   Environment* env = Environment::GetCurrent(args.GetIsolate());\n   new FSReqWrap(env, args.This());\n }\n \n-FSReqPromise::FSReqPromise(Environment* env, Local<Object> req)\n-    : FSReqBase(env, req, AsyncWrap::PROVIDER_FSREQPROMISE) {\n+FSReqPromise::FSReqPromise(Environment* env)\n+    : FSReqBase(env,\n+                env->fsreqpromise_constructor_template()\n+                    ->NewInstance(env->context()).ToLocalChecked(),\n+                AsyncWrap::PROVIDER_FSREQPROMISE),\n+      stats_field_array_(env->isolate(), 14) {\n   auto resolver = Promise::Resolver::New(env->context()).ToLocalChecked();\n-  req->Set(env->context(), env->promise_string(),\n-           resolver.As<Promise>()).FromJust();\n-\n-  Local<ArrayBuffer> ab =\n-      ArrayBuffer::New(env->isolate(), statFields_,\n-                       sizeof(double) * 14);\n-  object()->Set(env->context(),\n-                env->statfields_string(),\n-                Float64Array::New(ab, 0, 14)).FromJust();\n+  object()->Set(env->context(), env->promise_string(),\n+                resolver.As<Promise>()).FromJust();\n }\n \n FSReqPromise::~FSReqPromise() {\n@@ -300,44 +310,35 @@ FSReqPromise::~FSReqPromise() {\n \n void FSReqPromise::Reject(Local<Value> reject) {\n   finished_ = true;\n-  InternalCallbackScope callback_scope(this);\n   HandleScope scope(env()->isolate());\n+  InternalCallbackScope callback_scope(this);\n   Local<Value> value =\n       object()->Get(env()->context(),\n                     env()->promise_string()).ToLocalChecked();\n   CHECK(value->IsPromise());\n   Local<Promise> promise = value.As<Promise>();\n   Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();\n-  resolver->Reject(env()->context(), reject);\n+  resolver->Reject(env()->context(), reject).FromJust();\n }\n \n void FSReqPromise::FillStatsArray(const uv_stat_t* stat) {\n-  node::FillStatsArray(statFields_, stat);\n+  node::FillStatsArray(&stats_field_array_, stat);\n }\n \n void FSReqPromise::ResolveStat() {\n-  Resolve(\n-      object()->Get(env()->context(),\n-                    env()->statfields_string()).ToLocalChecked());\n+  Resolve(stats_field_array_.GetJSArray());\n }\n \n void FSReqPromise::Resolve(Local<Value> value) {\n   finished_ = true;\n-  InternalCallbackScope callback_scope(this);\n   HandleScope scope(env()->isolate());\n+  InternalCallbackScope callback_scope(this);\n   Local<Value> val =\n       object()->Get(env()->context(),\n                     env()->promise_string()).ToLocalChecked();\n   CHECK(val->IsPromise());\n-  Local<Promise> promise = val.As<Promise>();\n-  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();\n-  resolver->Resolve(env()->context(), value);\n-}\n-\n-void NewFSReqPromise(const FunctionCallbackInfo<Value>& args) {\n-  CHECK(args.IsConstructCall());\n-  Environment* env = Environment::GetCurrent(args.GetIsolate());\n-  new FSReqPromise(env, args.This());\n+  Local<Promise::Resolver> resolver = val.As<Promise::Resolver>();\n+  resolver->Resolve(env()->context(), value).FromJust();\n }\n \n FSReqAfterScope::FSReqAfterScope(FSReqBase* wrap, uv_fs_t* req)\n@@ -519,11 +520,10 @@ class fs_req_wrap {\n \n template <typename Func, typename... Args>\n inline FSReqBase* AsyncDestCall(Environment* env,\n+    FSReqBase* req_wrap,\n     const FunctionCallbackInfo<Value>& args,\n     const char* syscall, const char* dest, size_t len,\n     enum encoding enc, uv_fs_cb after, Func fn, Args... fn_args) {\n-  Local<Object> req = args[args.Length() - 1].As<Object>();\n-  FSReqBase* req_wrap = Unwrap<FSReqBase>(req);\n   CHECK_NE(req_wrap, nullptr);\n   req_wrap->Init(syscall, dest, len, enc);\n   int err = fn(env->event_loop(), req_wrap->req(), fn_args..., after);\n@@ -544,10 +544,11 @@ inline FSReqBase* AsyncDestCall(Environment* env,\n \n template <typename Func, typename... Args>\n inline FSReqBase* AsyncCall(Environment* env,\n+    FSReqBase* req_wrap,\n     const FunctionCallbackInfo<Value>& args,\n     const char* syscall, enum encoding enc,\n     uv_fs_cb after, Func fn, Args... fn_args) {\n-  return AsyncDestCall(env, args,\n+  return AsyncDestCall(env, req_wrap, args,\n                        syscall, nullptr, 0, enc,\n                        after, fn, fn_args...);\n }\n@@ -576,10 +577,10 @@ inline int SyncCall(Environment* env, Local<Value> ctx, fs_req_wrap* req_wrap,\n }\n \n #define SYNC_DEST_CALL(func, path, dest, ...)                                 \\\n-  fs_req_wrap req_wrap;                                                       \\\n+  fs_req_wrap sync_wrap;                                                      \\\n   env->PrintSyncTrace();                                                      \\\n   int err = uv_fs_ ## func(env->event_loop(),                                 \\\n-                         &req_wrap.req,                                       \\\n+                         &sync_wrap.req,                                      \\\n                          __VA_ARGS__,                                         \\\n                          nullptr);                                            \\\n   if (err < 0) {                                                              \\\n@@ -589,10 +590,19 @@ inline int SyncCall(Environment* env, Local<Value> ctx, fs_req_wrap* req_wrap,\n #define SYNC_CALL(func, path, ...)                                            \\\n   SYNC_DEST_CALL(func, path, nullptr, __VA_ARGS__)                            \\\n \n-#define SYNC_REQ req_wrap.req\n+#define SYNC_REQ sync_wrap.req\n \n #define SYNC_RESULT err\n \n+inline FSReqBase* GetReqWrap(Environment* env, Local<Value> value) {\n+  if (value->IsObject()) {\n+    return Unwrap<FSReqBase>(value.As<Object>());\n+  } else if (value->StrictEquals(env->fs_use_promises_symbol())) {\n+    return new FSReqPromise(env);\n+  }\n+  return nullptr;\n+}\n+\n void Access(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args.GetIsolate());\n   HandleScope scope(env->isolate());\n@@ -606,10 +616,11 @@ void Access(const FunctionCallbackInfo<Value>& args) {\n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NE(*path, nullptr);\n \n-  if (args[2]->IsObject()) {  // access(path, mode, req)\n-    CHECK_EQ(argc, 3);\n-    AsyncCall(env, args, \"access\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n+  if (req_wrap != nullptr) {  // access(path, mode, req)\n+    AsyncCall(env, req_wrap, args, \"access\", UTF8, AfterNoArgs,\n               uv_fs_access, *path, mode);\n+    req_wrap->SetReturnValue(args);\n   } else {  // access(path, mode, undefined, ctx)\n     CHECK_EQ(argc, 4);\n     fs_req_wrap req_wrap;\n@@ -627,10 +638,11 @@ void Close(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsInt32());\n   int fd = args[0].As<Int32>()->Value();\n \n-  if (args[1]->IsObject()) {  // close(fd, req)\n-    CHECK_EQ(argc, 2);\n-    AsyncCall(env, args, \"close\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n+  if (req_wrap != nullptr) {  // close(fd, req)\n+    AsyncCall(env, req_wrap, args, \"close\", UTF8, AfterNoArgs,\n               uv_fs_close, fd);\n+    req_wrap->SetReturnValue(args);\n   } else {  // close(fd, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     fs_req_wrap req_wrap;\n@@ -732,10 +744,11 @@ static void Stat(const FunctionCallbackInfo<Value>& args) {\n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NE(*path, nullptr);\n \n-  if (args[1]->IsObject()) {  // stat(path, req)\n-    CHECK_EQ(argc, 2);\n-    AsyncCall(env, args, \"stat\", UTF8, AfterStat,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n+  if (req_wrap != nullptr) {  // stat(path, req)\n+    AsyncCall(env, req_wrap, args, \"stat\", UTF8, AfterStat,\n               uv_fs_stat, *path);\n+    req_wrap->SetReturnValue(args);\n   } else {  // stat(path, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     fs_req_wrap req_wrap;\n@@ -756,10 +769,11 @@ static void LStat(const FunctionCallbackInfo<Value>& args) {\n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NE(*path, nullptr);\n \n-  if (args[1]->IsObject()) {  // lstat(path, req)\n-    CHECK_EQ(argc, 2);\n-    AsyncCall(env, args, \"lstat\", UTF8, AfterStat,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n+  if (req_wrap != nullptr) {  // lstat(path, req)\n+    AsyncCall(env, req_wrap, args, \"lstat\", UTF8, AfterStat,\n               uv_fs_lstat, *path);\n+    req_wrap->SetReturnValue(args);\n   } else {  // lstat(path, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     fs_req_wrap req_wrap;\n@@ -780,10 +794,11 @@ static void FStat(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsInt32());\n   int fd = args[0].As<Int32>()->Value();\n \n-  if (args[1]->IsObject()) {  // fstat(fd, req)\n-    CHECK_EQ(argc, 2);\n-    AsyncCall(env, args, \"fstat\", UTF8, AfterStat,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n+  if (req_wrap != nullptr) {  // fstat(fd, req)\n+    AsyncCall(env, req_wrap, args, \"fstat\", UTF8, AfterStat,\n               uv_fs_fstat, fd);\n+    req_wrap->SetReturnValue(args);\n   } else {  // fstat(fd, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     fs_req_wrap req_wrap;\n@@ -809,14 +824,14 @@ static void Symlink(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[2]->IsInt32());\n   int flags = args[2].As<Int32>()->Value();\n \n-  if (args[3]->IsObject()) {  // symlink(target, path, flags, req)\n-    CHECK_EQ(args.Length(), 4);\n-    AsyncDestCall(env, args, \"symlink\", *path, path.length(), UTF8,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n+  if (req_wrap != nullptr) {  // symlink(target, path, flags, req)\n+    AsyncDestCall(env, req_wrap, args, \"symlink\", *path, path.length(), UTF8,\n                   AfterNoArgs, uv_fs_symlink, *target, *path, flags);\n   } else {  // symlink(target, path, flags, undefinec, ctx)\n     CHECK_EQ(argc, 5);\n-    fs_req_wrap req_wrap;\n-    SyncCall(env, args[4], &req_wrap, \"symlink\",\n+    fs_req_wrap req;\n+    SyncCall(env, args[4], &req, \"symlink\",\n              uv_fs_symlink, *target, *path, flags);\n   }\n }\n@@ -833,14 +848,15 @@ static void Link(const FunctionCallbackInfo<Value>& args) {\n   BufferValue dest(env->isolate(), args[1]);\n   CHECK_NE(*dest, nullptr);\n \n-  if (args[2]->IsObject()) {  // link(src, dest, req)\n-    CHECK_EQ(argc, 3);\n-    AsyncDestCall(env, args, \"link\", *dest, dest.length(), UTF8,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n+  if (req_wrap != nullptr) {  // link(src, dest, req)\n+    AsyncDestCall(env, req_wrap, args, \"link\", *dest, dest.length(), UTF8,\n                   AfterNoArgs, uv_fs_link, *src, *dest);\n-  } else {  // link(src, dest, undefined, ctx)\n+    req_wrap->SetReturnValue(args);\n+  } else {  // link(src, dest)\n     CHECK_EQ(argc, 4);\n-    fs_req_wrap req_wrap;\n-    SyncCall(env, args[3], &req_wrap, \"link\",\n+    fs_req_wrap req;\n+    SyncCall(env, args[3], &req, \"link\",\n              uv_fs_link, *src, *dest);\n   }\n }\n@@ -856,19 +872,20 @@ static void ReadLink(const FunctionCallbackInfo<Value>& args) {\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n \n-  if (args[2]->IsObject()) {  // readlink(path, encoding, req)\n-    CHECK_EQ(argc, 3);\n-    AsyncCall(env, args, \"readlink\", encoding, AfterStringPtr,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n+  if (req_wrap != nullptr) {  // readlink(path, encoding, req)\n+    AsyncCall(env, req_wrap, args, \"readlink\", encoding, AfterStringPtr,\n               uv_fs_readlink, *path);\n-  } else {  // readlink(path, encoding, undefined, ctx)\n+    req_wrap->SetReturnValue(args);\n+  } else {\n     CHECK_EQ(argc, 4);\n-    fs_req_wrap req_wrap;\n-    int err = SyncCall(env, args[3], &req_wrap, \"readlink\",\n+    fs_req_wrap req;\n+    int err = SyncCall(env, args[3], &req, \"readlink\",\n                        uv_fs_readlink, *path);\n     if (err) {\n       return;  // syscall failed, no need to continue, error info is in ctx\n     }\n-    const char* link_path = static_cast<const char*>(req_wrap.req.ptr);\n+    const char* link_path = static_cast<const char*>(req.req.ptr);\n \n     Local<Value> error;\n     MaybeLocal<Value> rc = StringBytes::Encode(env->isolate(),\n@@ -896,15 +913,15 @@ static void Rename(const FunctionCallbackInfo<Value>& args) {\n   BufferValue new_path(env->isolate(), args[1]);\n   CHECK_NE(*new_path, nullptr);\n \n-  if (args[2]->IsObject()) {  // rename(old_path, new_path, req)\n-    CHECK_EQ(argc, 3);\n-    AsyncDestCall(env, args, \"rename\", *new_path, new_path.length(),\n+  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n+  if (req_wrap != nullptr) {\n+    AsyncDestCall(env, req_wrap, args, \"rename\", *new_path, new_path.length(),\n                   UTF8, AfterNoArgs, uv_fs_rename, *old_path, *new_path);\n-  } else {  // rename(old_path, new_path, undefined, ctx)\n+    req_wrap->SetReturnValue(args);\n+  } else {\n     CHECK_EQ(argc, 4);\n-    fs_req_wrap req_wrap;\n-    SyncCall(env, args[3], &req_wrap, \"rename\",\n-             uv_fs_rename, *old_path, *new_path);\n+    fs_req_wrap req;\n+    SyncCall(env, args[3], &req, \"rename\", uv_fs_rename, *old_path, *new_path);\n   }\n }\n \n@@ -920,15 +937,15 @@ static void FTruncate(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[1]->IsNumber());\n   const int64_t len = args[1].As<Integer>()->Value();\n \n-  if (args[2]->IsObject()) {  // ftruncate(fd, len, req)\n-    CHECK_EQ(argc, 3);\n-    AsyncCall(env, args, \"ftruncate\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"ftruncate\", UTF8, AfterNoArgs,\n               uv_fs_ftruncate, fd, len);\n-  } else {  // ftruncate(fd, len, undefined, ctx)\n+    req_wrap->SetReturnValue(args);\n+  } else {\n     CHECK_EQ(argc, 4);\n-    fs_req_wrap req_wrap;\n-    SyncCall(env, args[3], &req_wrap, \"ftruncate\",\n-             uv_fs_ftruncate, fd, len);\n+    fs_req_wrap req;\n+    SyncCall(env, args[3], &req, \"ftruncate\", uv_fs_ftruncate, fd, len);\n   }\n }\n \n@@ -941,15 +958,15 @@ static void Fdatasync(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsInt32());\n   const int fd = args[0].As<Int32>()->Value();\n \n-  if (args[1]->IsObject()) {  // fdatasync(fd, req)\n-    CHECK_EQ(argc, 2);\n-    AsyncCall(env, args, \"fdatasync\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"fdatasync\", UTF8, AfterNoArgs,\n               uv_fs_fdatasync, fd);\n-  } else {  // fdatasync(fd, undefined, ctx)\n+    req_wrap->SetReturnValue(args);\n+  } else {\n     CHECK_EQ(argc, 3);\n-    fs_req_wrap req_wrap;\n-    SyncCall(env, args[2], &req_wrap, \"fdatasync\",\n-             uv_fs_fdatasync, fd);\n+    fs_req_wrap req;\n+    SyncCall(env, args[2], &req, \"fdatasync\", uv_fs_fdatasync, fd);\n   }\n }\n \n@@ -962,15 +979,15 @@ static void Fsync(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsInt32());\n   const int fd = args[0].As<Int32>()->Value();\n \n-  if (args[1]->IsObject()) {  // fsync(fd, req)\n-    CHECK_EQ(argc, 2);\n-    AsyncCall(env, args, \"fsync\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"fsync\", UTF8, AfterNoArgs,\n               uv_fs_fsync, fd);\n-  } else {  // fsync(fd, undefined, ctx)\n+    req_wrap->SetReturnValue(args);\n+  } else {\n     CHECK_EQ(argc, 3);\n-    fs_req_wrap req_wrap;\n-    SyncCall(env, args[2], &req_wrap, \"fsync\",\n-             uv_fs_fsync, fd);\n+    fs_req_wrap req;\n+    SyncCall(env, args[2], &req, \"fsync\", uv_fs_fsync, fd);\n   }\n }\n \n@@ -983,15 +1000,15 @@ static void Unlink(const FunctionCallbackInfo<Value>& args) {\n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NE(*path, nullptr);\n \n-  if (args[1]->IsObject()) {  // unlink(fd, req)\n-    CHECK_EQ(argc, 2);\n-    AsyncCall(env, args, \"unlink\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"unlink\", UTF8, AfterNoArgs,\n               uv_fs_unlink, *path);\n-  } else {  // unlink(fd, undefined, ctx)\n+    req_wrap->SetReturnValue(args);\n+  } else {\n     CHECK_EQ(argc, 3);\n-    fs_req_wrap req_wrap;\n-    SyncCall(env, args[2], &req_wrap, \"unlink\",\n-             uv_fs_unlink, *path);\n+    fs_req_wrap req;\n+    SyncCall(env, args[2], &req, \"unlink\", uv_fs_unlink, *path);\n   }\n }\n \n@@ -1003,10 +1020,11 @@ static void RMDir(const FunctionCallbackInfo<Value>& args) {\n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NE(*path, nullptr);\n \n-  if (args[1]->IsObject()) {\n-    CHECK_EQ(args.Length(), 2);\n-    AsyncCall(env, args, \"rmdir\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[1]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"rmdir\", UTF8, AfterNoArgs,\n               uv_fs_rmdir, *path);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(rmdir, *path, *path)\n   }\n@@ -1023,10 +1041,11 @@ static void MKDir(const FunctionCallbackInfo<Value>& args) {\n \n   int mode = static_cast<int>(args[1]->Int32Value());\n \n-  if (args[2]->IsObject()) {\n-    CHECK_EQ(args.Length(), 3);\n-    AsyncCall(env, args, \"mkdir\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"mkdir\", UTF8, AfterNoArgs,\n               uv_fs_mkdir, *path, mode);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(mkdir, *path, *path, mode)\n   }\n@@ -1040,10 +1059,11 @@ static void RealPath(const FunctionCallbackInfo<Value>& args) {\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n \n-  if (args[2]->IsObject()) {\n-    CHECK_EQ(args.Length(), 3);\n-    AsyncCall(env, args, \"realpath\", encoding, AfterStringPtr,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"realpath\", encoding, AfterStringPtr,\n               uv_fs_realpath, *path);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(realpath, *path, *path);\n     const char* link_path = static_cast<const char*>(SYNC_REQ.ptr);\n@@ -1071,10 +1091,11 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n \n-  if (args[2]->IsObject()) {\n-    CHECK_EQ(args.Length(), 3);\n-    AsyncCall(env, args, \"scandir\", encoding, AfterScanDir,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"scandir\", encoding, AfterScanDir,\n               uv_fs_scandir, *path, 0 /*flags*/);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(scandir, *path, *path, 0 /*flags*/)\n \n@@ -1135,10 +1156,11 @@ static void Open(const FunctionCallbackInfo<Value>& args) {\n   int flags = args[1]->Int32Value(context).ToChecked();\n   int mode = args[2]->Int32Value(context).ToChecked();\n \n-  if (args[3]->IsObject()) {\n-    CHECK_EQ(args.Length(), 4);\n-    AsyncCall(env, args, \"open\", UTF8, AfterInteger,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"open\", UTF8, AfterInteger,\n               uv_fs_open, *path, flags, mode);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(open, *path, *path, flags, mode)\n     args.GetReturnValue().Set(SYNC_RESULT);\n@@ -1159,10 +1181,11 @@ static void OpenFileHandle(const FunctionCallbackInfo<Value>& args) {\n   int flags = args[1]->Int32Value(context).ToChecked();\n   int mode = args[2]->Int32Value(context).ToChecked();\n \n-  if (args[3]->IsObject()) {\n-    CHECK_EQ(args.Length(), 4);\n-    AsyncCall(env, args, \"open\", UTF8, AfterOpenFileHandle,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"open\", UTF8, AfterOpenFileHandle,\n               uv_fs_open, *path, flags, mode);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(open, *path, *path, flags, mode)\n     if (SYNC_RESULT < 0) {\n@@ -1187,10 +1210,11 @@ static void CopyFile(const FunctionCallbackInfo<Value>& args) {\n   CHECK_NE(*dest, nullptr);\n   int flags = args[2]->Int32Value();\n \n-  if (args[3]->IsObject()) {\n-    CHECK_EQ(args.Length(), 4);\n-    AsyncCall(env, args, \"copyfile\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"copyfile\", UTF8, AfterNoArgs,\n               uv_fs_copyfile, *src, *dest, flags);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_DEST_CALL(copyfile, *src, *dest, *src, *dest, flags)\n   }\n@@ -1229,11 +1253,11 @@ static void WriteBuffer(const FunctionCallbackInfo<Value>& args) {\n \n   uv_buf_t uvbuf = uv_buf_init(const_cast<char*>(buf), len);\n \n-  if (args[5]->IsObject()) {\n-    CHECK_EQ(args.Length(), 6);\n-    AsyncCall(env, args, \"write\", UTF8, AfterInteger,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[5]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"write\", UTF8, AfterInteger,\n               uv_fs_write, fd, &uvbuf, 1, pos);\n-    return;\n+    return req_wrap->SetReturnValue(args);\n   }\n \n   SYNC_CALL(write, nullptr, fd, &uvbuf, 1, pos)\n@@ -1266,11 +1290,11 @@ static void WriteBuffers(const FunctionCallbackInfo<Value>& args) {\n     iovs[i] = uv_buf_init(Buffer::Data(chunk), Buffer::Length(chunk));\n   }\n \n-  if (args[3]->IsObject()) {\n-    CHECK_EQ(args.Length(), 4);\n-    AsyncCall(env, args, \"write\", UTF8, AfterInteger,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"write\", UTF8, AfterInteger,\n               uv_fs_write, fd, *iovs, iovs.length(), pos);\n-    return;\n+    return req_wrap->SetReturnValue(args);\n   }\n \n   SYNC_CALL(write, nullptr, fd, *iovs, iovs.length(), pos)\n@@ -1299,7 +1323,9 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n   size_t len;\n   const int64_t pos = GET_OFFSET(args[2]);\n   const auto enc = ParseEncoding(env->isolate(), args[3], UTF8);\n-  const auto is_async = args[4]->IsObject();\n+\n+  FSReqBase* req_wrap = GetReqWrap(env, args[4]);\n+  const auto is_async = req_wrap != nullptr;\n \n   // Avoid copying the string when it is externalized but only when:\n   // 1. The target encoding is compatible with the string's encoding, and\n@@ -1333,10 +1359,10 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n \n   uv_buf_t uvbuf = uv_buf_init(buf, len);\n \n-  if (is_async) {\n-    CHECK_EQ(args.Length(), 5);\n-    AsyncCall(env, args, \"write\", UTF8, AfterInteger,\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"write\", UTF8, AfterInteger,\n               uv_fs_write, fd, &uvbuf, 1, pos);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(write, nullptr, fd, &uvbuf, 1, pos)\n     return args.GetReturnValue().Set(SYNC_RESULT);\n@@ -1387,10 +1413,11 @@ static void Read(const FunctionCallbackInfo<Value>& args) {\n \n   uv_buf_t uvbuf = uv_buf_init(const_cast<char*>(buf), len);\n \n-  if (args[5]->IsObject()) {\n-    CHECK_EQ(args.Length(), 6);\n-    AsyncCall(env, args, \"read\", UTF8, AfterInteger,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[5]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"read\", UTF8, AfterInteger,\n               uv_fs_read, fd, &uvbuf, 1, pos);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(read, 0, fd, &uvbuf, 1, pos)\n     args.GetReturnValue().Set(SYNC_RESULT);\n@@ -1412,10 +1439,11 @@ static void Chmod(const FunctionCallbackInfo<Value>& args) {\n \n   int mode = static_cast<int>(args[1]->Int32Value());\n \n-  if (args[2]->IsObject()) {\n-    CHECK_EQ(args.Length(), 3);\n-    AsyncCall(env, args, \"chmod\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"chmod\", UTF8, AfterNoArgs,\n               uv_fs_chmod, *path, mode);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(chmod, *path, *path, mode);\n   }\n@@ -1434,10 +1462,11 @@ static void FChmod(const FunctionCallbackInfo<Value>& args) {\n   int fd = args[0]->Int32Value();\n   int mode = static_cast<int>(args[1]->Int32Value());\n \n-  if (args[2]->IsObject()) {\n-    CHECK_EQ(args.Length(), 3);\n-    AsyncCall(env, args, \"fchmod\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"fchmod\", UTF8, AfterNoArgs,\n               uv_fs_fchmod, fd, mode);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(fchmod, 0, fd, mode);\n   }\n@@ -1461,10 +1490,11 @@ static void Chown(const FunctionCallbackInfo<Value>& args) {\n   uv_uid_t uid = static_cast<uv_uid_t>(args[1]->Uint32Value());\n   uv_gid_t gid = static_cast<uv_gid_t>(args[2]->Uint32Value());\n \n-  if (args[3]->IsObject()) {\n-    CHECK_EQ(args.Length(), 4);\n-    AsyncCall(env, args, \"chown\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"chown\", UTF8, AfterNoArgs,\n               uv_fs_chown, *path, uid, gid);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(chown, *path, *path, uid, gid);\n   }\n@@ -1485,10 +1515,11 @@ static void FChown(const FunctionCallbackInfo<Value>& args) {\n   uv_uid_t uid = static_cast<uv_uid_t>(args[1]->Uint32Value());\n   uv_gid_t gid = static_cast<uv_gid_t>(args[2]->Uint32Value());\n \n-  if (args[3]->IsObject()) {\n-    CHECK_EQ(args.Length(), 4);\n-    AsyncCall(env, args, \"fchown\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"fchown\", UTF8, AfterNoArgs,\n               uv_fs_fchown, fd, uid, gid);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(fchown, 0, fd, uid, gid);\n   }\n@@ -1508,10 +1539,11 @@ static void UTimes(const FunctionCallbackInfo<Value>& args) {\n   const double atime = static_cast<double>(args[1]->NumberValue());\n   const double mtime = static_cast<double>(args[2]->NumberValue());\n \n-  if (args[3]->IsObject()) {\n-    CHECK_EQ(args.Length(), 4);\n-    AsyncCall(env, args, \"utime\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"utime\", UTF8, AfterNoArgs,\n               uv_fs_utime, *path, atime, mtime);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(utime, *path, *path, atime, mtime);\n   }\n@@ -1528,10 +1560,11 @@ static void FUTimes(const FunctionCallbackInfo<Value>& args) {\n   const double atime = static_cast<double>(args[1]->NumberValue());\n   const double mtime = static_cast<double>(args[2]->NumberValue());\n \n-  if (args[3]->IsObject()) {\n-    CHECK_EQ(args.Length(), 4);\n-    AsyncCall(env, args, \"futime\", UTF8, AfterNoArgs,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[3]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"futime\", UTF8, AfterNoArgs,\n               uv_fs_futime, fd, atime, mtime);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(futime, 0, fd, atime, mtime);\n   }\n@@ -1547,10 +1580,11 @@ static void Mkdtemp(const FunctionCallbackInfo<Value>& args) {\n \n   const enum encoding encoding = ParseEncoding(env->isolate(), args[1], UTF8);\n \n-  if (args[2]->IsObject()) {\n-    CHECK_EQ(args.Length(), 3);\n-    AsyncCall(env, args, \"mkdtemp\", encoding, AfterStringPath,\n+  FSReqBase* req_wrap = GetReqWrap(env, args[2]);\n+  if (req_wrap != nullptr) {\n+    AsyncCall(env, req_wrap, args, \"mkdtemp\", encoding, AfterStringPath,\n               uv_fs_mkdtemp, *tmpl);\n+    req_wrap->SetReturnValue(args);\n   } else {\n     SYNC_CALL(mkdtemp, *tmpl, *tmpl);\n     const char* path = static_cast<const char*>(SYNC_REQ.path);\n@@ -1629,14 +1663,14 @@ void InitFs(Local<Object> target,\n   target->Set(context, wrapString, fst->GetFunction()).FromJust();\n \n   // Create Function Template for FSReqPromise\n-  Local<FunctionTemplate> fpt =\n-      FunctionTemplate::New(env->isolate(), NewFSReqPromise);\n-  fpt->InstanceTemplate()->SetInternalFieldCount(1);\n+  Local<FunctionTemplate> fpt = FunctionTemplate::New(env->isolate());\n   AsyncWrap::AddWrapMethods(env, fpt);\n   Local<String> promiseString =\n       FIXED_ONE_BYTE_STRING(env->isolate(), \"FSReqPromise\");\n   fpt->SetClassName(promiseString);\n-  target->Set(context, promiseString, fpt->GetFunction()).FromJust();\n+  Local<ObjectTemplate> fpo = fpt->InstanceTemplate();\n+  fpo->SetInternalFieldCount(1);\n+  env->set_fsreqpromise_constructor_template(fpo);\n \n   // Create FunctionTemplate for FileHandle\n   Local<FunctionTemplate> fd = FunctionTemplate::New(env->isolate());\n@@ -1658,6 +1692,14 @@ void InitFs(Local<Object> target,\n   Local<ObjectTemplate> fdcloset = fdclose->InstanceTemplate();\n   fdcloset->SetInternalFieldCount(1);\n   env->set_fdclose_constructor_template(fdcloset);\n+\n+  Local<Symbol> use_promises_symbol =\n+    Symbol::New(env->isolate(),\n+                FIXED_ONE_BYTE_STRING(env->isolate(), \"use promises\"));\n+  env->set_fs_use_promises_symbol(use_promises_symbol);\n+  target->Set(env->context(),\n+              FIXED_ONE_BYTE_STRING(env->isolate(), \"kUsePromises\"),\n+              use_promises_symbol).FromJust();\n }\n \n }  // namespace fs"
        },
        {
            "sha": "d49807f5294e01c10c6afea2efb462d6c956ec2b",
            "filename": "src/node_file.h",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/329fc78e4919231bf76771797878f7b0db0f73ac/src%2Fnode_file.h",
            "raw_url": "https://github.com/nodejs/node/raw/329fc78e4919231bf76771797878f7b0db0f73ac/src%2Fnode_file.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.h?ref=329fc78e4919231bf76771797878f7b0db0f73ac",
            "patch": "@@ -12,6 +12,7 @@ using v8::Context;\n using v8::FunctionCallbackInfo;\n using v8::HandleScope;\n using v8::Local;\n+using v8::MaybeLocal;\n using v8::Object;\n using v8::Persistent;\n using v8::Promise;\n@@ -51,6 +52,7 @@ class FSReqBase : public ReqWrap<uv_fs_t> {\n   virtual void Reject(Local<Value> reject) = 0;\n   virtual void Resolve(Local<Value> value) = 0;\n   virtual void ResolveStat() = 0;\n+  virtual void SetReturnValue(const FunctionCallbackInfo<Value>& args) = 0;\n \n   const char* syscall() const { return syscall_; }\n   const char* data() const { return data_; }\n@@ -77,25 +79,27 @@ class FSReqWrap : public FSReqBase {\n   void Reject(Local<Value> reject) override;\n   void Resolve(Local<Value> value) override;\n   void ResolveStat() override;\n+  void SetReturnValue(const FunctionCallbackInfo<Value>& args) override;\n \n  private:\n   DISALLOW_COPY_AND_ASSIGN(FSReqWrap);\n };\n \n class FSReqPromise : public FSReqBase {\n  public:\n-  FSReqPromise(Environment* env, Local<Object> req);\n+  explicit FSReqPromise(Environment* env);\n \n   ~FSReqPromise() override;\n \n   void FillStatsArray(const uv_stat_t* stat) override;\n   void Reject(Local<Value> reject) override;\n   void Resolve(Local<Value> value) override;\n   void ResolveStat() override;\n+  void SetReturnValue(const FunctionCallbackInfo<Value>& args) override;\n \n  private:\n   bool finished_ = false;\n-  double statFields_[14] {};\n+  AliasedBuffer<double, v8::Float64Array> stats_field_array_;\n   DISALLOW_COPY_AND_ASSIGN(FSReqPromise);\n };\n \n@@ -152,7 +156,7 @@ class FileHandle : public AsyncWrap {\n       ref_.Empty();\n     }\n \n-    FileHandle* fd();\n+    FileHandle* file_handle();\n \n     size_t self_size() const override { return sizeof(*this); }\n \n@@ -166,7 +170,7 @@ class FileHandle : public AsyncWrap {\n   };\n \n   // Asynchronous close\n-  inline Local<Promise> ClosePromise();\n+  inline MaybeLocal<Promise> ClosePromise();\n \n   int fd_;\n   bool closing_ = false;"
        },
        {
            "sha": "8b7de1a35b3ab26d37dea9915d2ed3a7b926c206",
            "filename": "test/parallel/test-fs-filehandle.js",
            "status": "added",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/329fc78e4919231bf76771797878f7b0db0f73ac/test%2Fparallel%2Ftest-fs-filehandle.js",
            "raw_url": "https://github.com/nodejs/node/raw/329fc78e4919231bf76771797878f7b0db0f73ac/test%2Fparallel%2Ftest-fs-filehandle.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-filehandle.js?ref=329fc78e4919231bf76771797878f7b0db0f73ac",
            "patch": "@@ -0,0 +1,25 @@\n+// Flags: --expose-gc --no-warnings --expose-internals\n+'use strict';\n+\n+const common = require('../common');\n+const path = require('path');\n+const fs = process.binding('fs');\n+const { stringToFlags } = require('internal/fs');\n+\n+// Verifies that the FileHandle object is garbage collected and that a\n+// warning is emitted if it is not closed.\n+\n+let fdnum;\n+{\n+  fdnum = fs.openFileHandle(path.toNamespacedPath(__filename),\n+                            stringToFlags('r'), 0o666).fd;\n+}\n+\n+common.expectWarning(\n+  'Warning',\n+  `Closing file descriptor ${fdnum} on garbage collection`\n+);\n+\n+gc();  // eslint-disable-line no-undef\n+\n+setTimeout(() => {}, 10);"
        },
        {
            "sha": "655dc73a1dfdb555315876fdd7ef94839967a173",
            "filename": "test/parallel/test-fs-promises-writefile.js",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/329fc78e4919231bf76771797878f7b0db0f73ac/test%2Fparallel%2Ftest-fs-promises-writefile.js",
            "raw_url": "https://github.com/nodejs/node/raw/329fc78e4919231bf76771797878f7b0db0f73ac/test%2Fparallel%2Ftest-fs-promises-writefile.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-promises-writefile.js?ref=329fc78e4919231bf76771797878f7b0db0f73ac",
            "patch": "@@ -0,0 +1,40 @@\n+'use strict';\n+\n+const common = require('../common');\n+const fs = require('fs');\n+const path = require('path');\n+const tmpdir = require('../common/tmpdir');\n+const assert = require('assert');\n+const tmpDir = tmpdir.path;\n+\n+tmpdir.refresh();\n+\n+common.crashOnUnhandledRejection();\n+\n+const dest = path.resolve(tmpDir, 'tmp.txt');\n+const buffer = Buffer.from('abc'.repeat(1000));\n+const buffer2 = Buffer.from('xyz'.repeat(1000));\n+\n+async function doWrite() {\n+  await fs.promises.writeFile(dest, buffer);\n+  const data = fs.readFileSync(dest);\n+  assert.deepStrictEqual(data, buffer);\n+}\n+\n+async function doAppend() {\n+  await fs.promises.appendFile(dest, buffer2);\n+  const data = fs.readFileSync(dest);\n+  const buf = Buffer.concat([buffer, buffer2]);\n+  assert.deepStrictEqual(buf, data);\n+}\n+\n+async function doRead() {\n+  const data = await fs.promises.readFile(dest);\n+  const buf = fs.readFileSync(dest);\n+  assert.deepStrictEqual(buf, data);\n+}\n+\n+doWrite()\n+  .then(doAppend)\n+  .then(doRead)\n+  .then(common.mustCall());"
        },
        {
            "sha": "5d493208ff85cb93bf78e126a667278b9520aaf2",
            "filename": "test/parallel/test-fs-promises.js",
            "status": "added",
            "additions": 150,
            "deletions": 0,
            "changes": 150,
            "blob_url": "https://github.com/nodejs/node/blob/329fc78e4919231bf76771797878f7b0db0f73ac/test%2Fparallel%2Ftest-fs-promises.js",
            "raw_url": "https://github.com/nodejs/node/raw/329fc78e4919231bf76771797878f7b0db0f73ac/test%2Fparallel%2Ftest-fs-promises.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-promises.js?ref=329fc78e4919231bf76771797878f7b0db0f73ac",
            "patch": "@@ -0,0 +1,150 @@\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const tmpdir = require('../common/tmpdir');\n+const fixtures = require('../common/fixtures');\n+const path = require('path');\n+const fs = require('fs');\n+const {\n+  access,\n+  chmod,\n+  copyFile,\n+  fchmod,\n+  fdatasync,\n+  fstat,\n+  fsync,\n+  ftruncate,\n+  futimes,\n+  link,\n+  lstat,\n+  mkdir,\n+  mkdtemp,\n+  open,\n+  read,\n+  readdir,\n+  readlink,\n+  realpath,\n+  rename,\n+  rmdir,\n+  stat,\n+  symlink,\n+  write,\n+  unlink,\n+  utimes\n+} = fs.promises;\n+\n+const tmpDir = tmpdir.path;\n+\n+common.crashOnUnhandledRejection();\n+\n+{\n+  access(__filename, 'r')\n+    .then(common.mustCall())\n+    .catch(common.mustNotCall());\n+\n+  access('this file does not exist', 'r')\n+    .then(common.mustNotCall())\n+    .catch(common.expectsError({\n+      code: 'ENOENT',\n+      type: Error,\n+      message:\n+        /^ENOENT: no such file or directory, access/\n+    }));\n+}\n+\n+function verifyStatObject(stat) {\n+  assert.strictEqual(typeof stat, 'object');\n+  assert.strictEqual(typeof stat.dev, 'number');\n+  assert.strictEqual(typeof stat.mode, 'number');\n+}\n+\n+{\n+  async function doTest() {\n+    tmpdir.refresh();\n+    const dest = path.resolve(tmpDir, 'baz.js');\n+    await copyFile(fixtures.path('baz.js'), dest);\n+    await access(dest, 'r');\n+\n+    const handle = await open(dest, 'r+');\n+    assert.strictEqual(typeof handle, 'object');\n+\n+    let stats = await fstat(handle);\n+    verifyStatObject(stats);\n+    assert.strictEqual(stats.size, 35);\n+\n+    await ftruncate(handle, 1);\n+\n+    stats = await fstat(handle);\n+    verifyStatObject(stats);\n+    assert.strictEqual(stats.size, 1);\n+\n+    stats = await stat(dest);\n+    verifyStatObject(stats);\n+\n+    await fdatasync(handle);\n+    await fsync(handle);\n+\n+    const buf = Buffer.from('hello world');\n+\n+    await write(handle, buf);\n+\n+    const ret = await read(handle, Buffer.alloc(11), 0, 11, 0);\n+    assert.strictEqual(ret.bytesRead, 11);\n+    assert.deepStrictEqual(ret.buffer, buf);\n+\n+    await chmod(dest, 0o666);\n+    await fchmod(handle, 0o666);\n+\n+    await utimes(dest, new Date(), new Date());\n+\n+    try {\n+      await futimes(handle, new Date(), new Date());\n+    } catch (err) {\n+      // Some systems do not have futimes. If there is an error,\n+      // expect it to be ENOSYS\n+      common.expectsError({\n+        code: 'ENOSYS',\n+        type: Error\n+      })(err);\n+    }\n+\n+    await handle.close();\n+\n+    const newPath = path.resolve(tmpDir, 'baz2.js');\n+    await rename(dest, newPath);\n+    stats = await stat(newPath);\n+    verifyStatObject(stats);\n+\n+    const newLink = path.resolve(tmpDir, 'baz3.js');\n+    await symlink(newPath, newLink);\n+\n+    const newLink2 = path.resolve(tmpDir, 'baz4.js');\n+    await link(newPath, newLink2);\n+\n+    stats = await lstat(newLink);\n+    verifyStatObject(stats);\n+\n+    assert.strictEqual(newPath.toLowerCase(),\n+                       (await realpath(newLink)).toLowerCase());\n+    assert.strictEqual(newPath.toLowerCase(),\n+                       (await readlink(newLink)).toLowerCase());\n+\n+    await unlink(newLink);\n+    await unlink(newLink2);\n+\n+    const newdir = path.resolve(tmpDir, 'dir');\n+    await mkdir(newdir);\n+    stats = await stat(newdir);\n+    assert(stats.isDirectory());\n+\n+    const list = await readdir(tmpDir);\n+    assert.deepStrictEqual(list, ['baz2.js', 'dir']);\n+\n+    await rmdir(newdir);\n+\n+    await mkdtemp(path.resolve(tmpDir, 'FOO'));\n+  }\n+\n+  doTest().then(common.mustCall());\n+}"
        },
        {
            "sha": "fb11f2d9e4630581c77d86a52b8e53bf19f1c0e7",
            "filename": "test/sequential/test-async-wrap-getasyncid.js",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/329fc78e4919231bf76771797878f7b0db0f73ac/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "raw_url": "https://github.com/nodejs/node/raw/329fc78e4919231bf76771797878f7b0db0f73ac/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-async-wrap-getasyncid.js?ref=329fc78e4919231bf76771797878f7b0db0f73ac",
            "patch": "@@ -9,6 +9,8 @@ const fixtures = require('../common/fixtures');\n const tmpdir = require('../common/tmpdir');\n const { getSystemErrorName } = require('util');\n \n+common.crashOnUnhandledRejection();\n+\n // Make sure that all Providers are tested.\n {\n   const hooks = require('async_hooks').createHook({\n@@ -167,6 +169,14 @@ if (common.hasCrypto) { // eslint-disable-line crypto-check\n   testInitialized(new Signal(), 'Signal');\n }\n \n+{\n+  async function openTest() {\n+    const fd = await fs.promises.open(__filename, 'r');\n+    testInitialized(fd, 'FileHandle');\n+    await fd.close();\n+  }\n+  openTest().then(common.mustCall()).catch(common.mustNotCall());\n+}\n \n {\n   const binding = process.binding('stream_wrap');"
        }
    ],
    "stats": {
        "total": 2144,
        "additions": 1957,
        "deletions": 187
    }
}