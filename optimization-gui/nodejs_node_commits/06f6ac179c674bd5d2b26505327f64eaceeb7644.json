{
    "author": "addaleax",
    "message": "string_decoder: fix number of replacement chars\n\nFixes: https://github.com/nodejs/node/issues/22626\n\nPR-URL: https://github.com/nodejs/node/pull/22709\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Rich Trott <rtrott@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>",
    "sha": "06f6ac179c674bd5d2b26505327f64eaceeb7644",
    "files": [
        {
            "sha": "cc38cd927a0f89f703ea67a2689585a712b5c3a2",
            "filename": "src/string_decoder.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/06f6ac179c674bd5d2b26505327f64eaceeb7644/src%2Fstring_decoder.cc",
            "raw_url": "https://github.com/nodejs/node/raw/06f6ac179c674bd5d2b26505327f64eaceeb7644/src%2Fstring_decoder.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstring_decoder.cc?ref=06f6ac179c674bd5d2b26505327f64eaceeb7644",
            "patch": "@@ -71,16 +71,17 @@ MaybeLocal<String> StringDecoder::DecodeData(Isolate* isolate,\n                kIncompleteCharactersEnd);\n       if (Encoding() == UTF8) {\n         // For UTF-8, we need special treatment to align with the V8 decoder:\n-        // If an incomplete character is found at a chunk boundary, we turn\n-        // that character into a single invalid one.\n+        // If an incomplete character is found at a chunk boundary, we use\n+        // its remainder and pass it to V8 as-is.\n         for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {\n           if ((data[i] & 0xC0) != 0x80) {\n             // This byte is not a continuation byte even though it should have\n-            // been one.\n-            // Act as if there was a 1-byte incomplete character, which does\n-            // not make sense but works here because we know it's invalid.\n+            // been one. We stop decoding of the incomplete character at this\n+            // point (but still use the rest of the incomplete bytes from this\n+            // chunk) and assume that the new, unexpected byte starts a new one.\n             state_[kMissingBytes] = 0;\n-            state_[kBufferedBytes] = 1;\n+            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);\n+            state_[kBufferedBytes] += i;\n             data += i;\n             nread -= i;\n             break;"
        },
        {
            "sha": "04e1d8c8fe2849556cda9af706388b6b78049c1d",
            "filename": "test/parallel/test-string-decoder.js",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/06f6ac179c674bd5d2b26505327f64eaceeb7644/test%2Fparallel%2Ftest-string-decoder.js",
            "raw_url": "https://github.com/nodejs/node/raw/06f6ac179c674bd5d2b26505327f64eaceeb7644/test%2Fparallel%2Ftest-string-decoder.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-string-decoder.js?ref=06f6ac179c674bd5d2b26505327f64eaceeb7644",
            "patch": "@@ -162,6 +162,17 @@ assert.strictEqual(decoder.write(Buffer.alloc(20)), '\\0'.repeat(10));\n assert.strictEqual(decoder.write(Buffer.alloc(48)), '\\0'.repeat(24));\n assert.strictEqual(decoder.end(), '');\n \n+// Regression tests for https://github.com/nodejs/node/issues/22626\n+// (not enough replacement chars when having seen more than one byte of an\n+// incomplete multibyte characters).\n+decoder = new StringDecoder('utf8');\n+assert.strictEqual(decoder.write(Buffer.from('f69b', 'hex')), '');\n+assert.strictEqual(decoder.write(Buffer.from('d1', 'hex')), '\\ufffd\\ufffd');\n+assert.strictEqual(decoder.end(), '\\ufffd');\n+assert.strictEqual(decoder.write(Buffer.from('f4', 'hex')), '');\n+assert.strictEqual(decoder.write(Buffer.from('bde5', 'hex')), '\\ufffd\\ufffd');\n+assert.strictEqual(decoder.end(), '\\ufffd');\n+\n common.expectsError(\n   () => new StringDecoder(1),\n   {"
        }
    ],
    "stats": {
        "total": 24,
        "additions": 18,
        "deletions": 6
    }
}