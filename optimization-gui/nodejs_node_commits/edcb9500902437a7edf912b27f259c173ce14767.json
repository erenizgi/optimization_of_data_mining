{
    "author": "joyeecheung",
    "message": "src: use NativeModuleLoader to compile all the bootstrappers\n\nThis patch moves all the bootstrapper compilation to use\nNativeModuleLoader::CompileAndCall(). With this we no longer\nneed to mess with the error decoration and handling any more -\nthere is no point in handling the JS error occurred during bootstrapping\nby ourselves, we should just crash or let the VM handle it.\n\nPR-URL: https://github.com/nodejs/node/pull/24775\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "edcb9500902437a7edf912b27f259c173ce14767",
    "files": [
        {
            "sha": "155d9c9239627e5cfd2afbce6df45ce3c426c163",
            "filename": "lib/internal/bootstrap/loaders.js",
            "status": "modified",
            "additions": 294,
            "deletions": 293,
            "changes": 587,
            "blob_url": "https://github.com/nodejs/node/blob/edcb9500902437a7edf912b27f259c173ce14767/lib%2Finternal%2Fbootstrap%2Floaders.js",
            "raw_url": "https://github.com/nodejs/node/raw/edcb9500902437a7edf912b27f259c173ce14767/lib%2Finternal%2Fbootstrap%2Floaders.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbootstrap%2Floaders.js?ref=edcb9500902437a7edf912b27f259c173ce14767",
            "patch": "@@ -39,335 +39,336 @@\n \n 'use strict';\n \n-(function bootstrapInternalLoaders(process, getBinding, getLinkedBinding,\n-                                   getInternalBinding, debugBreak) {\n-  if (debugBreak)\n-    debugger; // eslint-disable-line no-debugger\n-\n-  const {\n-    apply: ReflectApply,\n-    deleteProperty: ReflectDeleteProperty,\n-    get: ReflectGet,\n-    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n-    has: ReflectHas,\n-    set: ReflectSet,\n-  } = Reflect;\n-  const {\n-    prototype: {\n-      hasOwnProperty: ObjectHasOwnProperty,\n-    },\n-    create: ObjectCreate,\n-    defineProperty: ObjectDefineProperty,\n-    keys: ObjectKeys,\n-  } = Object;\n-\n-  // Set up process.moduleLoadList.\n-  const moduleLoadList = [];\n-  ObjectDefineProperty(process, 'moduleLoadList', {\n-    value: moduleLoadList,\n-    configurable: true,\n-    enumerable: true,\n-    writable: false\n-  });\n-\n-  // internalBindingWhitelist contains the name of internalBinding modules\n-  // that are whitelisted for access via process.binding()... This is used\n-  // to provide a transition path for modules that are being moved over to\n-  // internalBinding.\n-  const internalBindingWhitelist = [\n-    'async_wrap',\n-    'buffer',\n-    'cares_wrap',\n-    'constants',\n-    'contextify',\n-    'crypto',\n-    'fs',\n-    'fs_event_wrap',\n-    'http_parser',\n-    'icu',\n-    'js_stream',\n-    'natives',\n-    'pipe_wrap',\n-    'process_wrap',\n-    'signal_wrap',\n-    'spawn_sync',\n-    'stream_wrap',\n-    'tcp_wrap',\n-    'tls_wrap',\n-    'tty_wrap',\n-    'udp_wrap',\n-    'url',\n-    'util',\n-    'uv',\n-    'v8',\n-    'zlib'\n-  ];\n-  // We will use a lazy loaded SafeSet in internalBindingWhitelistHas\n-  // for checking existence in this list.\n-  let internalBindingWhitelistSet;\n-\n-  // Set up process.binding() and process._linkedBinding().\n-  {\n-    const bindingObj = ObjectCreate(null);\n-\n-    process.binding = function binding(module) {\n-      module = String(module);\n-      // Deprecated specific process.binding() modules, but not all, allow\n-      // selective fallback to internalBinding for the deprecated ones.\n-      if (internalBindingWhitelistHas(module)) {\n-        return internalBinding(module);\n-      }\n-      let mod = bindingObj[module];\n-      if (typeof mod !== 'object') {\n-        mod = bindingObj[module] = getBinding(module);\n-        moduleLoadList.push(`Binding ${module}`);\n-      }\n-      return mod;\n-    };\n-\n-    process._linkedBinding = function _linkedBinding(module) {\n-      module = String(module);\n-      let mod = bindingObj[module];\n-      if (typeof mod !== 'object')\n-        mod = bindingObj[module] = getLinkedBinding(module);\n-      return mod;\n-    };\n-  }\n+// This file is compiled as if it's wrapped in a function with arguments\n+// passed by node::LoadEnvironment()\n+/* global process, getBinding, getLinkedBinding, getInternalBinding */\n+/* global debugBreak */\n+\n+if (debugBreak)\n+  debugger; // eslint-disable-line no-debugger\n+\n+const {\n+  apply: ReflectApply,\n+  deleteProperty: ReflectDeleteProperty,\n+  get: ReflectGet,\n+  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n+  has: ReflectHas,\n+  set: ReflectSet,\n+} = Reflect;\n+const {\n+  prototype: {\n+    hasOwnProperty: ObjectHasOwnProperty,\n+  },\n+  create: ObjectCreate,\n+  defineProperty: ObjectDefineProperty,\n+  keys: ObjectKeys,\n+} = Object;\n+\n+// Set up process.moduleLoadList.\n+const moduleLoadList = [];\n+ObjectDefineProperty(process, 'moduleLoadList', {\n+  value: moduleLoadList,\n+  configurable: true,\n+  enumerable: true,\n+  writable: false\n+});\n \n-  // Set up internalBinding() in the closure.\n-  let internalBinding;\n-  {\n-    const bindingObj = ObjectCreate(null);\n-    internalBinding = function internalBinding(module) {\n-      let mod = bindingObj[module];\n-      if (typeof mod !== 'object') {\n-        mod = bindingObj[module] = getInternalBinding(module);\n-        moduleLoadList.push(`Internal Binding ${module}`);\n-      }\n-      return mod;\n-    };\n-  }\n+// internalBindingWhitelist contains the name of internalBinding modules\n+// that are whitelisted for access via process.binding()... This is used\n+// to provide a transition path for modules that are being moved over to\n+// internalBinding.\n+const internalBindingWhitelist = [\n+  'async_wrap',\n+  'buffer',\n+  'cares_wrap',\n+  'constants',\n+  'contextify',\n+  'crypto',\n+  'fs',\n+  'fs_event_wrap',\n+  'http_parser',\n+  'icu',\n+  'js_stream',\n+  'natives',\n+  'pipe_wrap',\n+  'process_wrap',\n+  'signal_wrap',\n+  'spawn_sync',\n+  'stream_wrap',\n+  'tcp_wrap',\n+  'tls_wrap',\n+  'tty_wrap',\n+  'udp_wrap',\n+  'url',\n+  'util',\n+  'uv',\n+  'v8',\n+  'zlib'\n+];\n+// We will use a lazy loaded SafeSet in internalBindingWhitelistHas\n+// for checking existence in this list.\n+let internalBindingWhitelistSet;\n+\n+// Set up process.binding() and process._linkedBinding().\n+{\n+  const bindingObj = ObjectCreate(null);\n+\n+  process.binding = function binding(module) {\n+    module = String(module);\n+    // Deprecated specific process.binding() modules, but not all, allow\n+    // selective fallback to internalBinding for the deprecated ones.\n+    if (internalBindingWhitelistHas(module)) {\n+      return internalBinding(module);\n+    }\n+    let mod = bindingObj[module];\n+    if (typeof mod !== 'object') {\n+      mod = bindingObj[module] = getBinding(module);\n+      moduleLoadList.push(`Binding ${module}`);\n+    }\n+    return mod;\n+  };\n \n-  // Create this WeakMap in js-land because V8 has no C++ API for WeakMap.\n-  internalBinding('module_wrap').callbackMap = new WeakMap();\n-\n-  // Set up NativeModule.\n-  function NativeModule(id) {\n-    this.filename = `${id}.js`;\n-    this.id = id;\n-    this.exports = {};\n-    this.reflect = undefined;\n-    this.exportKeys = undefined;\n-    this.loaded = false;\n-    this.loading = false;\n+  process._linkedBinding = function _linkedBinding(module) {\n+    module = String(module);\n+    let mod = bindingObj[module];\n+    if (typeof mod !== 'object')\n+      mod = bindingObj[module] = getLinkedBinding(module);\n+    return mod;\n+  };\n+}\n+\n+// Set up internalBinding() in the closure.\n+let internalBinding;\n+{\n+  const bindingObj = ObjectCreate(null);\n+  internalBinding = function internalBinding(module) {\n+    let mod = bindingObj[module];\n+    if (typeof mod !== 'object') {\n+      mod = bindingObj[module] = getInternalBinding(module);\n+      moduleLoadList.push(`Internal Binding ${module}`);\n+    }\n+    return mod;\n+  };\n+}\n+\n+// Create this WeakMap in js-land because V8 has no C++ API for WeakMap.\n+internalBinding('module_wrap').callbackMap = new WeakMap();\n+\n+// Set up NativeModule.\n+function NativeModule(id) {\n+  this.filename = `${id}.js`;\n+  this.id = id;\n+  this.exports = {};\n+  this.reflect = undefined;\n+  this.exportKeys = undefined;\n+  this.loaded = false;\n+  this.loading = false;\n+}\n+\n+NativeModule._source = getInternalBinding('natives');\n+NativeModule._cache = {};\n+\n+const config = getBinding('config');\n+\n+// Think of this as module.exports in this file even though it is not\n+// written in CommonJS style.\n+const loaderExports = { internalBinding, NativeModule };\n+const loaderId = 'internal/bootstrap/loaders';\n+\n+NativeModule.require = function(id) {\n+  if (id === loaderId) {\n+    return loaderExports;\n   }\n \n-  NativeModule._source = getInternalBinding('natives');\n-  NativeModule._cache = {};\n-\n-  const config = getBinding('config');\n+  const cached = NativeModule.getCached(id);\n+  if (cached && (cached.loaded || cached.loading)) {\n+    return cached.exports;\n+  }\n \n-  // Think of this as module.exports in this file even though it is not\n-  // written in CommonJS style.\n-  const loaderExports = { internalBinding, NativeModule };\n-  const loaderId = 'internal/bootstrap/loaders';\n+  if (!NativeModule.exists(id)) {\n+    // Model the error off the internal/errors.js model, but\n+    // do not use that module given that it could actually be\n+    // the one causing the error if there's a bug in Node.js.\n+    // eslint-disable-next-line no-restricted-syntax\n+    const err = new Error(`No such built-in module: ${id}`);\n+    err.code = 'ERR_UNKNOWN_BUILTIN_MODULE';\n+    err.name = 'Error [ERR_UNKNOWN_BUILTIN_MODULE]';\n+    throw err;\n+  }\n \n-  NativeModule.require = function(id) {\n-    if (id === loaderId) {\n-      return loaderExports;\n-    }\n+  moduleLoadList.push(`NativeModule ${id}`);\n \n-    const cached = NativeModule.getCached(id);\n-    if (cached && (cached.loaded || cached.loading)) {\n-      return cached.exports;\n-    }\n+  const nativeModule = new NativeModule(id);\n \n-    if (!NativeModule.exists(id)) {\n-      // Model the error off the internal/errors.js model, but\n-      // do not use that module given that it could actually be\n-      // the one causing the error if there's a bug in Node.js.\n-      // eslint-disable-next-line no-restricted-syntax\n-      const err = new Error(`No such built-in module: ${id}`);\n-      err.code = 'ERR_UNKNOWN_BUILTIN_MODULE';\n-      err.name = 'Error [ERR_UNKNOWN_BUILTIN_MODULE]';\n-      throw err;\n-    }\n+  nativeModule.cache();\n+  nativeModule.compile();\n \n-    moduleLoadList.push(`NativeModule ${id}`);\n+  return nativeModule.exports;\n+};\n \n-    const nativeModule = new NativeModule(id);\n+NativeModule.isDepsModule = function(id) {\n+  return id.startsWith('node-inspect/') || id.startsWith('v8/');\n+};\n \n-    nativeModule.cache();\n-    nativeModule.compile();\n+NativeModule.requireForDeps = function(id) {\n+  if (!NativeModule.exists(id) ||\n+      // TODO(TimothyGu): remove when DEP0084 reaches end of life.\n+      NativeModule.isDepsModule(id)) {\n+    id = `internal/deps/${id}`;\n+  }\n+  return NativeModule.require(id);\n+};\n \n-    return nativeModule.exports;\n-  };\n+NativeModule.getCached = function(id) {\n+  return NativeModule._cache[id];\n+};\n \n-  NativeModule.isDepsModule = function(id) {\n-    return id.startsWith('node-inspect/') || id.startsWith('v8/');\n-  };\n+NativeModule.exists = function(id) {\n+  return NativeModule._source.hasOwnProperty(id);\n+};\n \n-  NativeModule.requireForDeps = function(id) {\n-    if (!NativeModule.exists(id) ||\n-        // TODO(TimothyGu): remove when DEP0084 reaches end of life.\n-        NativeModule.isDepsModule(id)) {\n-      id = `internal/deps/${id}`;\n+if (config.exposeInternals) {\n+  NativeModule.nonInternalExists = function(id) {\n+    // Do not expose this to user land even with --expose-internals.\n+    if (id === loaderId) {\n+      return false;\n     }\n-    return NativeModule.require(id);\n+    return NativeModule.exists(id);\n   };\n \n-  NativeModule.getCached = function(id) {\n-    return NativeModule._cache[id];\n+  NativeModule.isInternal = function(id) {\n+    // Do not expose this to user land even with --expose-internals.\n+    return id === loaderId;\n   };\n-\n-  NativeModule.exists = function(id) {\n-    return NativeModule._source.hasOwnProperty(id);\n+} else {\n+  NativeModule.nonInternalExists = function(id) {\n+    return NativeModule.exists(id) && !NativeModule.isInternal(id);\n   };\n \n-  if (config.exposeInternals) {\n-    NativeModule.nonInternalExists = function(id) {\n-      // Do not expose this to user land even with --expose-internals.\n-      if (id === loaderId) {\n-        return false;\n-      }\n-      return NativeModule.exists(id);\n-    };\n-\n-    NativeModule.isInternal = function(id) {\n-      // Do not expose this to user land even with --expose-internals.\n-      return id === loaderId;\n-    };\n-  } else {\n-    NativeModule.nonInternalExists = function(id) {\n-      return NativeModule.exists(id) && !NativeModule.isInternal(id);\n-    };\n-\n-    NativeModule.isInternal = function(id) {\n-      return id.startsWith('internal/') ||\n-          (id === 'worker_threads' && !config.experimentalWorker);\n-    };\n-  }\n-\n-  NativeModule.getSource = function(id) {\n-    return NativeModule._source[id];\n+  NativeModule.isInternal = function(id) {\n+    return id.startsWith('internal/') ||\n+        (id === 'worker_threads' && !config.experimentalWorker);\n   };\n-\n-  NativeModule.wrap = function(script) {\n-    return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];\n+}\n+\n+NativeModule.getSource = function(id) {\n+  return NativeModule._source[id];\n+};\n+\n+NativeModule.wrap = function(script) {\n+  return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];\n+};\n+\n+NativeModule.wrapper = [\n+  '(function (exports, require, module, process, internalBinding) {',\n+  '\\n});'\n+];\n+\n+const getOwn = (target, property, receiver) => {\n+  return ReflectApply(ObjectHasOwnProperty, target, [property]) ?\n+    ReflectGet(target, property, receiver) :\n+    undefined;\n+};\n+\n+// Provide named exports for all builtin libraries so that the libraries\n+// may be imported in a nicer way for ESM users. The default export is left\n+// as the entire namespace (module.exports) and wrapped in a proxy such\n+// that APMs and other behavior are still left intact.\n+NativeModule.prototype.proxifyExports = function() {\n+  this.exportKeys = ObjectKeys(this.exports);\n+\n+  const update = (property, value) => {\n+    if (this.reflect !== undefined &&\n+        ReflectApply(ObjectHasOwnProperty,\n+                     this.reflect.exports, [property]))\n+      this.reflect.exports[property].set(value);\n   };\n \n-  NativeModule.wrapper = [\n-    '(function (exports, require, module, process, internalBinding) {',\n-    '\\n});'\n-  ];\n-\n-  const getOwn = (target, property, receiver) => {\n-    return ReflectApply(ObjectHasOwnProperty, target, [property]) ?\n-      ReflectGet(target, property, receiver) :\n-      undefined;\n-  };\n-\n-  // Provide named exports for all builtin libraries so that the libraries\n-  // may be imported in a nicer way for ESM users. The default export is left\n-  // as the entire namespace (module.exports) and wrapped in a proxy such\n-  // that APMs and other behavior are still left intact.\n-  NativeModule.prototype.proxifyExports = function() {\n-    this.exportKeys = ObjectKeys(this.exports);\n-\n-    const update = (property, value) => {\n-      if (this.reflect !== undefined &&\n-          ReflectApply(ObjectHasOwnProperty,\n-                       this.reflect.exports, [property]))\n-        this.reflect.exports[property].set(value);\n-    };\n-\n-    const handler = {\n-      __proto__: null,\n-      defineProperty: (target, prop, descriptor) => {\n-        // Use `Object.defineProperty` instead of `Reflect.defineProperty`\n-        // to throw the appropriate error if something goes wrong.\n-        ObjectDefineProperty(target, prop, descriptor);\n-        if (typeof descriptor.get === 'function' &&\n-            !ReflectHas(handler, 'get')) {\n-          handler.get = (target, prop, receiver) => {\n-            const value = ReflectGet(target, prop, receiver);\n-            if (ReflectApply(ObjectHasOwnProperty, target, [prop]))\n-              update(prop, value);\n-            return value;\n-          };\n-        }\n-        update(prop, getOwn(target, prop));\n+  const handler = {\n+    __proto__: null,\n+    defineProperty: (target, prop, descriptor) => {\n+      // Use `Object.defineProperty` instead of `Reflect.defineProperty`\n+      // to throw the appropriate error if something goes wrong.\n+      ObjectDefineProperty(target, prop, descriptor);\n+      if (typeof descriptor.get === 'function' &&\n+          !ReflectHas(handler, 'get')) {\n+        handler.get = (target, prop, receiver) => {\n+          const value = ReflectGet(target, prop, receiver);\n+          if (ReflectApply(ObjectHasOwnProperty, target, [prop]))\n+            update(prop, value);\n+          return value;\n+        };\n+      }\n+      update(prop, getOwn(target, prop));\n+      return true;\n+    },\n+    deleteProperty: (target, prop) => {\n+      if (ReflectDeleteProperty(target, prop)) {\n+        update(prop, undefined);\n         return true;\n-      },\n-      deleteProperty: (target, prop) => {\n-        if (ReflectDeleteProperty(target, prop)) {\n-          update(prop, undefined);\n-          return true;\n-        }\n-        return false;\n-      },\n-      set: (target, prop, value, receiver) => {\n-        const descriptor = ReflectGetOwnPropertyDescriptor(target, prop);\n-        if (ReflectSet(target, prop, value, receiver)) {\n-          if (descriptor && typeof descriptor.set === 'function') {\n-            for (const key of this.exportKeys) {\n-              update(key, getOwn(target, key, receiver));\n-            }\n-          } else {\n-            update(prop, getOwn(target, prop, receiver));\n+      }\n+      return false;\n+    },\n+    set: (target, prop, value, receiver) => {\n+      const descriptor = ReflectGetOwnPropertyDescriptor(target, prop);\n+      if (ReflectSet(target, prop, value, receiver)) {\n+        if (descriptor && typeof descriptor.set === 'function') {\n+          for (const key of this.exportKeys) {\n+            update(key, getOwn(target, key, receiver));\n           }\n-          return true;\n+        } else {\n+          update(prop, getOwn(target, prop, receiver));\n         }\n-        return false;\n+        return true;\n       }\n-    };\n-\n-    this.exports = new Proxy(this.exports, handler);\n+      return false;\n+    }\n   };\n \n-  const { compileFunction } = getInternalBinding('native_module');\n-  NativeModule.prototype.compile = function() {\n-    const id = this.id;\n+  this.exports = new Proxy(this.exports, handler);\n+};\n \n-    this.loading = true;\n+const { compileFunction } = getInternalBinding('native_module');\n+NativeModule.prototype.compile = function() {\n+  const id = this.id;\n \n-    try {\n-      const requireFn = this.id.startsWith('internal/deps/') ?\n-        NativeModule.requireForDeps :\n-        NativeModule.require;\n+  this.loading = true;\n \n-      const fn = compileFunction(id);\n-      fn(this.exports, requireFn, this, process, internalBinding);\n+  try {\n+    const requireFn = this.id.startsWith('internal/deps/') ?\n+      NativeModule.requireForDeps :\n+      NativeModule.require;\n \n-      if (config.experimentalModules && !NativeModule.isInternal(this.id)) {\n-        this.proxifyExports();\n-      }\n+    const fn = compileFunction(id);\n+    fn(this.exports, requireFn, this, process, internalBinding);\n \n-      this.loaded = true;\n-    } finally {\n-      this.loading = false;\n+    if (config.experimentalModules && !NativeModule.isInternal(this.id)) {\n+      this.proxifyExports();\n     }\n-  };\n \n-  NativeModule.prototype.cache = function() {\n-    NativeModule._cache[this.id] = this;\n-  };\n-\n-  // Coverage must be turned on early, so that we can collect\n-  // it for Node.js' own internal libraries.\n-  if (process.env.NODE_V8_COVERAGE) {\n-    NativeModule.require('internal/process/coverage').setup();\n+    this.loaded = true;\n+  } finally {\n+    this.loading = false;\n   }\n-\n-  function internalBindingWhitelistHas(name) {\n-    if (!internalBindingWhitelistSet) {\n-      const { SafeSet } = NativeModule.require('internal/safe_globals');\n-      internalBindingWhitelistSet = new SafeSet(internalBindingWhitelist);\n-    }\n-    return internalBindingWhitelistSet.has(name);\n+};\n+\n+NativeModule.prototype.cache = function() {\n+  NativeModule._cache[this.id] = this;\n+};\n+\n+// Coverage must be turned on early, so that we can collect\n+// it for Node.js' own internal libraries.\n+if (process.env.NODE_V8_COVERAGE) {\n+  NativeModule.require('internal/process/coverage').setup();\n+}\n+\n+function internalBindingWhitelistHas(name) {\n+  if (!internalBindingWhitelistSet) {\n+    const { SafeSet } = NativeModule.require('internal/safe_globals');\n+    internalBindingWhitelistSet = new SafeSet(internalBindingWhitelist);\n   }\n+  return internalBindingWhitelistSet.has(name);\n+}\n \n-  // This will be passed to the bootstrapNodeJSCore function in\n-  // bootstrap/node.js.\n-  return loaderExports;\n-});\n+// This will be passed to internal/bootstrap/node.js.\n+return loaderExports;"
        },
        {
            "sha": "cdc1f06010acfdadfafaabed9836402f79cfc80c",
            "filename": "lib/internal/bootstrap/node.js",
            "status": "modified",
            "additions": 617,
            "deletions": 617,
            "changes": 1234,
            "blob_url": "https://github.com/nodejs/node/blob/edcb9500902437a7edf912b27f259c173ce14767/lib%2Finternal%2Fbootstrap%2Fnode.js",
            "raw_url": "https://github.com/nodejs/node/raw/edcb9500902437a7edf912b27f259c173ce14767/lib%2Finternal%2Fbootstrap%2Fnode.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbootstrap%2Fnode.js?ref=edcb9500902437a7edf912b27f259c173ce14767",
            "patch": "@@ -12,696 +12,696 @@\n // into this bootstrapper to bootstrap Node.js core.\n 'use strict';\n \n-(function bootstrapNodeJSCore(process,\n-                              // bootstrapper properties... destructured to\n-                              // avoid retaining a reference to the bootstrap\n-                              // object.\n-                              { _setupTraceCategoryState,\n-                                _setupNextTick,\n-                                _setupPromises, _chdir, _cpuUsage,\n-                                _hrtime, _hrtimeBigInt,\n-                                _memoryUsage, _rawDebug,\n-                                _umask, _initgroups, _setegid, _seteuid,\n-                                _setgid, _setuid, _setgroups,\n-                                _shouldAbortOnUncaughtToggle },\n-                              { internalBinding, NativeModule },\n-                              triggerFatalException) {\n-  const exceptionHandlerState = { captureFn: null };\n-  const isMainThread = internalBinding('worker').threadId === 0;\n-\n-  function startup() {\n-    setupTraceCategoryState();\n-\n-    setupProcessObject();\n-\n-    // Do this good and early, since it handles errors.\n-    setupProcessFatal();\n-\n-    setupProcessICUVersions();\n-\n-    setupGlobalVariables();\n-\n-    // Bootstrappers for all threads, including worker threads and main thread\n-    const perThreadSetup = NativeModule.require('internal/process/per_thread');\n-    // Bootstrappers for the main thread only\n-    let mainThreadSetup;\n-    // Bootstrappers for the worker threads only\n-    let workerThreadSetup;\n-    if (isMainThread) {\n-      mainThreadSetup = NativeModule.require(\n-        'internal/process/main_thread_only'\n-      );\n-    } else {\n-      workerThreadSetup = NativeModule.require(\n-        'internal/process/worker_thread_only'\n-      );\n-    }\n-\n-    perThreadSetup.setupAssert();\n-    perThreadSetup.setupConfig(NativeModule._source);\n+// This file is compiled as if it's wrapped in a function with arguments\n+// passed by node::LoadEnvironment()\n+/* global process, bootstrappers, loaderExports, triggerFatalException */\n+const {\n+  _setupTraceCategoryState,\n+  _setupNextTick,\n+  _setupPromises, _chdir, _cpuUsage,\n+  _hrtime, _hrtimeBigInt,\n+  _memoryUsage, _rawDebug,\n+  _umask, _initgroups, _setegid, _seteuid,\n+  _setgid, _setuid, _setgroups,\n+  _shouldAbortOnUncaughtToggle\n+} = bootstrappers;\n+const { internalBinding, NativeModule } = loaderExports;\n+\n+const exceptionHandlerState = { captureFn: null };\n+const isMainThread = internalBinding('worker').threadId === 0;\n+\n+function startup() {\n+  setupTraceCategoryState();\n+\n+  setupProcessObject();\n+\n+  // Do this good and early, since it handles errors.\n+  setupProcessFatal();\n+\n+  setupProcessICUVersions();\n+\n+  setupGlobalVariables();\n+\n+  // Bootstrappers for all threads, including worker threads and main thread\n+  const perThreadSetup = NativeModule.require('internal/process/per_thread');\n+  // Bootstrappers for the main thread only\n+  let mainThreadSetup;\n+  // Bootstrappers for the worker threads only\n+  let workerThreadSetup;\n+  if (isMainThread) {\n+    mainThreadSetup = NativeModule.require(\n+      'internal/process/main_thread_only'\n+    );\n+  } else {\n+    workerThreadSetup = NativeModule.require(\n+      'internal/process/worker_thread_only'\n+    );\n+  }\n \n-    if (isMainThread) {\n-      mainThreadSetup.setupSignalHandlers(internalBinding);\n-    }\n+  perThreadSetup.setupAssert();\n+  perThreadSetup.setupConfig(NativeModule._source);\n \n-    perThreadSetup.setupUncaughtExceptionCapture(exceptionHandlerState,\n-                                                 _shouldAbortOnUncaughtToggle);\n+  if (isMainThread) {\n+    mainThreadSetup.setupSignalHandlers(internalBinding);\n+  }\n \n-    NativeModule.require('internal/process/warning').setup();\n-    NativeModule.require('internal/process/next_tick').setup(_setupNextTick,\n-                                                             _setupPromises);\n+  perThreadSetup.setupUncaughtExceptionCapture(exceptionHandlerState,\n+                                               _shouldAbortOnUncaughtToggle);\n+\n+  NativeModule.require('internal/process/warning').setup();\n+  NativeModule.require('internal/process/next_tick').setup(_setupNextTick,\n+                                                           _setupPromises);\n+\n+  if (isMainThread) {\n+    mainThreadSetup.setupStdio();\n+    mainThreadSetup.setupProcessMethods(\n+      _chdir, _umask, _initgroups, _setegid, _seteuid,\n+      _setgid, _setuid, _setgroups\n+    );\n+  } else {\n+    workerThreadSetup.setupStdio();\n+  }\n \n-    if (isMainThread) {\n-      mainThreadSetup.setupStdio();\n-      mainThreadSetup.setupProcessMethods(\n-        _chdir, _umask, _initgroups, _setegid, _seteuid,\n-        _setgid, _setuid, _setgroups\n-      );\n-    } else {\n-      workerThreadSetup.setupStdio();\n-    }\n+  const perf = internalBinding('performance');\n+  const {\n+    NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE,\n+  } = perf.constants;\n \n-    const perf = internalBinding('performance');\n-    const {\n-      NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE,\n-    } = perf.constants;\n+  perThreadSetup.setupRawDebug(_rawDebug);\n+  perThreadSetup.setupHrtime(_hrtime, _hrtimeBigInt);\n+  perThreadSetup.setupCpuUsage(_cpuUsage);\n+  perThreadSetup.setupMemoryUsage(_memoryUsage);\n+  perThreadSetup.setupKillAndExit();\n \n-    perThreadSetup.setupRawDebug(_rawDebug);\n-    perThreadSetup.setupHrtime(_hrtime, _hrtimeBigInt);\n-    perThreadSetup.setupCpuUsage(_cpuUsage);\n-    perThreadSetup.setupMemoryUsage(_memoryUsage);\n-    perThreadSetup.setupKillAndExit();\n+  if (global.__coverage__)\n+    NativeModule.require('internal/process/write-coverage').setup();\n \n-    if (global.__coverage__)\n-      NativeModule.require('internal/process/write-coverage').setup();\n-\n-    if (process.env.NODE_V8_COVERAGE) {\n-      NativeModule.require('internal/process/coverage').setupExitHooks();\n-    }\n+  if (process.env.NODE_V8_COVERAGE) {\n+    NativeModule.require('internal/process/coverage').setupExitHooks();\n+  }\n \n-    if (process.config.variables.v8_enable_inspector) {\n-      NativeModule.require('internal/inspector_async_hook').setup();\n-    }\n+  if (process.config.variables.v8_enable_inspector) {\n+    NativeModule.require('internal/inspector_async_hook').setup();\n+  }\n \n-    const { getOptionValue } = NativeModule.require('internal/options');\n+  const { getOptionValue } = NativeModule.require('internal/options');\n \n-    if (getOptionValue('--help')) {\n-      NativeModule.require('internal/print_help').print(process.stdout);\n-      return;\n-    }\n+  if (getOptionValue('--help')) {\n+    NativeModule.require('internal/print_help').print(process.stdout);\n+    return;\n+  }\n \n-    if (getOptionValue('--completion-bash')) {\n-      NativeModule.require('internal/bash_completion').print(process.stdout);\n-      return;\n-    }\n+  if (getOptionValue('--completion-bash')) {\n+    NativeModule.require('internal/bash_completion').print(process.stdout);\n+    return;\n+  }\n \n-    if (isMainThread) {\n-      mainThreadSetup.setupChildProcessIpcChannel();\n-    }\n+  if (isMainThread) {\n+    mainThreadSetup.setupChildProcessIpcChannel();\n+  }\n \n-    const browserGlobals = !process._noBrowserGlobals;\n-    if (browserGlobals) {\n-      setupGlobalTimeouts();\n-      setupGlobalConsole();\n-      setupGlobalURL();\n-      setupGlobalEncoding();\n-      setupQueueMicrotask();\n-    }\n+  const browserGlobals = !process._noBrowserGlobals;\n+  if (browserGlobals) {\n+    setupGlobalTimeouts();\n+    setupGlobalConsole();\n+    setupGlobalURL();\n+    setupGlobalEncoding();\n+    setupQueueMicrotask();\n+  }\n \n-    if (getOptionValue('--experimental-worker')) {\n-      setupDOMException();\n-    }\n+  if (getOptionValue('--experimental-worker')) {\n+    setupDOMException();\n+  }\n \n-    // On OpenBSD process.execPath will be relative unless we\n-    // get the full path before process.execPath is used.\n-    if (process.platform === 'openbsd') {\n-      const { realpathSync } = NativeModule.require('fs');\n-      process.execPath = realpathSync.native(process.execPath);\n-    }\n+  // On OpenBSD process.execPath will be relative unless we\n+  // get the full path before process.execPath is used.\n+  if (process.platform === 'openbsd') {\n+    const { realpathSync } = NativeModule.require('fs');\n+    process.execPath = realpathSync.native(process.execPath);\n+  }\n \n-    Object.defineProperty(process, 'argv0', {\n-      enumerable: true,\n-      configurable: false,\n-      value: process.argv[0]\n-    });\n-    process.argv[0] = process.execPath;\n+  Object.defineProperty(process, 'argv0', {\n+    enumerable: true,\n+    configurable: false,\n+    value: process.argv[0]\n+  });\n+  process.argv[0] = process.execPath;\n+\n+  // Handle `--debug*` deprecation and invalidation.\n+  if (process._invalidDebug) {\n+    process.emitWarning(\n+      '`node --debug` and `node --debug-brk` are invalid. ' +\n+      'Please use `node --inspect` or `node --inspect-brk` instead.',\n+      'DeprecationWarning', 'DEP0062', startup, true);\n+    process.exit(9);\n+  } else if (process._deprecatedDebugBrk) {\n+    process.emitWarning(\n+      '`node --inspect --debug-brk` is deprecated. ' +\n+      'Please use `node --inspect-brk` instead.',\n+      'DeprecationWarning', 'DEP0062', startup, true);\n+  }\n \n-    // Handle `--debug*` deprecation and invalidation.\n-    if (process._invalidDebug) {\n-      process.emitWarning(\n-        '`node --debug` and `node --debug-brk` are invalid. ' +\n-        'Please use `node --inspect` or `node --inspect-brk` instead.',\n-        'DeprecationWarning', 'DEP0062', startup, true);\n-      process.exit(9);\n-    } else if (process._deprecatedDebugBrk) {\n+  const experimentalModules = getOptionValue('--experimental-modules');\n+  const experimentalVMModules = getOptionValue('--experimental-vm-modules');\n+  if (experimentalModules || experimentalVMModules) {\n+    if (experimentalModules) {\n       process.emitWarning(\n-        '`node --inspect --debug-brk` is deprecated. ' +\n-        'Please use `node --inspect-brk` instead.',\n-        'DeprecationWarning', 'DEP0062', startup, true);\n+        'The ESM module loader is experimental.',\n+        'ExperimentalWarning', undefined);\n     }\n+    NativeModule.require('internal/process/esm_loader').setup();\n+  }\n \n-    const experimentalModules = getOptionValue('--experimental-modules');\n-    const experimentalVMModules = getOptionValue('--experimental-vm-modules');\n-    if (experimentalModules || experimentalVMModules) {\n-      if (experimentalModules) {\n-        process.emitWarning(\n-          'The ESM module loader is experimental.',\n-          'ExperimentalWarning', undefined);\n-      }\n-      NativeModule.require('internal/process/esm_loader').setup();\n+  const { deprecate } = NativeModule.require('internal/util');\n+  {\n+    // Install legacy getters on the `util` binding for typechecking.\n+    // TODO(addaleax): Turn into a full runtime deprecation.\n+    const { pendingDeprecation } = process.binding('config');\n+    const utilBinding = internalBinding('util');\n+    const types = internalBinding('types');\n+    for (const name of [\n+      'isArrayBuffer', 'isArrayBufferView', 'isAsyncFunction',\n+      'isDataView', 'isDate', 'isExternal', 'isMap', 'isMapIterator',\n+      'isNativeError', 'isPromise', 'isRegExp', 'isSet', 'isSetIterator',\n+      'isTypedArray', 'isUint8Array', 'isAnyArrayBuffer'\n+    ]) {\n+      utilBinding[name] = pendingDeprecation ?\n+        deprecate(types[name],\n+                  'Accessing native typechecking bindings of Node ' +\n+                  'directly is deprecated. ' +\n+                  `Please use \\`util.types.${name}\\` instead.`,\n+                  'DEP0103') :\n+        types[name];\n     }\n+  }\n \n-    const { deprecate } = NativeModule.require('internal/util');\n-    {\n-      // Install legacy getters on the `util` binding for typechecking.\n-      // TODO(addaleax): Turn into a full runtime deprecation.\n-      const { pendingDeprecation } = process.binding('config');\n-      const utilBinding = internalBinding('util');\n-      const types = internalBinding('types');\n-      for (const name of [\n-        'isArrayBuffer', 'isArrayBufferView', 'isAsyncFunction',\n-        'isDataView', 'isDate', 'isExternal', 'isMap', 'isMapIterator',\n-        'isNativeError', 'isPromise', 'isRegExp', 'isSet', 'isSetIterator',\n-        'isTypedArray', 'isUint8Array', 'isAnyArrayBuffer'\n-      ]) {\n-        utilBinding[name] = pendingDeprecation ?\n-          deprecate(types[name],\n-                    'Accessing native typechecking bindings of Node ' +\n-                    'directly is deprecated. ' +\n-                    `Please use \\`util.types.${name}\\` instead.`,\n-                    'DEP0103') :\n-          types[name];\n-      }\n+  // TODO(jasnell): The following have been globals since around 2012.\n+  // That's just silly. The underlying perfctr support has been removed\n+  // so these are now deprecated non-ops that can be removed after one\n+  // major release cycle.\n+  if (process.platform === 'win32') {\n+    function noop() {}\n+    const names = [\n+      'NET_SERVER_CONNECTION',\n+      'NET_SERVER_CONNECTION_CLOSE',\n+      'HTTP_SERVER_REQUEST',\n+      'HTTP_SERVER_RESPONSE',\n+      'HTTP_CLIENT_REQUEST',\n+      'HTTP_CLIENT_RESPONSE'\n+    ];\n+    for (var n = 0; n < names.length; n++) {\n+      Object.defineProperty(global, `COUNTER_${names[n]}`, {\n+        configurable: true,\n+        enumerable: false,\n+        value: deprecate(noop,\n+                         `COUNTER_${names[n]}() is deprecated.`,\n+                         'DEP0120')\n+      });\n     }\n+  }\n \n-    // TODO(jasnell): The following have been globals since around 2012.\n-    // That's just silly. The underlying perfctr support has been removed\n-    // so these are now deprecated non-ops that can be removed after one\n-    // major release cycle.\n-    if (process.platform === 'win32') {\n-      function noop() {}\n-      const names = [\n-        'NET_SERVER_CONNECTION',\n-        'NET_SERVER_CONNECTION_CLOSE',\n-        'HTTP_SERVER_REQUEST',\n-        'HTTP_SERVER_RESPONSE',\n-        'HTTP_CLIENT_REQUEST',\n-        'HTTP_CLIENT_RESPONSE'\n-      ];\n-      for (var n = 0; n < names.length; n++) {\n-        Object.defineProperty(global, `COUNTER_${names[n]}`, {\n-          configurable: true,\n-          enumerable: false,\n-          value: deprecate(noop,\n-                           `COUNTER_${names[n]}() is deprecated.`,\n-                           'DEP0120')\n-        });\n-      }\n-    }\n+  perf.markMilestone(NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE);\n \n-    perf.markMilestone(NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE);\n+  perThreadSetup.setupAllowedFlags();\n \n-    perThreadSetup.setupAllowedFlags();\n+  startExecution();\n+}\n \n-    startExecution();\n+// There are various modes that Node can run in. The most common two\n+// are running from a script and running the REPL - but there are a few\n+// others like the debugger or running --eval arguments. Here we decide\n+// which mode we run in.\n+function startExecution() {\n+  // This means we are in a Worker context, and any script execution\n+  // will be directed by the worker module.\n+  if (internalBinding('worker').getEnvMessagePort() !== undefined) {\n+    NativeModule.require('internal/worker').setupChild(evalScript);\n+    return;\n   }\n \n-  // There are various modes that Node can run in. The most common two\n-  // are running from a script and running the REPL - but there are a few\n-  // others like the debugger or running --eval arguments. Here we decide\n-  // which mode we run in.\n-  function startExecution() {\n-    // This means we are in a Worker context, and any script execution\n-    // will be directed by the worker module.\n-    if (internalBinding('worker').getEnvMessagePort() !== undefined) {\n-      NativeModule.require('internal/worker').setupChild(evalScript);\n-      return;\n-    }\n+  // To allow people to extend Node in different ways, this hook allows\n+  // one to drop a file lib/_third_party_main.js into the build\n+  // directory which will be executed instead of Node's normal loading.\n+  if (NativeModule.exists('_third_party_main')) {\n+    process.nextTick(() => {\n+      NativeModule.require('_third_party_main');\n+    });\n+    return;\n+  }\n \n-    // To allow people to extend Node in different ways, this hook allows\n-    // one to drop a file lib/_third_party_main.js into the build\n-    // directory which will be executed instead of Node's normal loading.\n-    if (NativeModule.exists('_third_party_main')) {\n-      process.nextTick(() => {\n-        NativeModule.require('_third_party_main');\n-      });\n-      return;\n+  // `node inspect ...` or `node debug ...`\n+  if (process.argv[1] === 'inspect' || process.argv[1] === 'debug') {\n+    if (process.argv[1] === 'debug') {\n+      process.emitWarning(\n+        '`node debug` is deprecated. Please use `node inspect` instead.',\n+        'DeprecationWarning', 'DEP0068');\n     }\n \n-    // `node inspect ...` or `node debug ...`\n-    if (process.argv[1] === 'inspect' || process.argv[1] === 'debug') {\n-      if (process.argv[1] === 'debug') {\n-        process.emitWarning(\n-          '`node debug` is deprecated. Please use `node inspect` instead.',\n-          'DeprecationWarning', 'DEP0068');\n-      }\n+    // Start the debugger agent.\n+    process.nextTick(() => {\n+      NativeModule.require('internal/deps/node-inspect/lib/_inspect').start();\n+    });\n+    return;\n+  }\n \n-      // Start the debugger agent.\n-      process.nextTick(() => {\n-        NativeModule.require('internal/deps/node-inspect/lib/_inspect').start();\n-      });\n-      return;\n-    }\n+  // `node --prof-process`\n+  // TODO(joyeecheung): use internal/options instead of process.profProcess\n+  if (process.profProcess) {\n+    NativeModule.require('internal/v8_prof_processor');\n+    return;\n+  }\n \n-    // `node --prof-process`\n-    // TODO(joyeecheung): use internal/options instead of process.profProcess\n-    if (process.profProcess) {\n-      NativeModule.require('internal/v8_prof_processor');\n-      return;\n-    }\n+  // There is user code to be run.\n+  prepareUserCodeExecution();\n+  executeUserCode();\n+}\n+\n+function prepareUserCodeExecution() {\n+  // If this is a worker in cluster mode, start up the communication\n+  // channel. This needs to be done before any user code gets executed\n+  // (including preload modules).\n+  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n+    const cluster = NativeModule.require('cluster');\n+    cluster._setupWorker();\n+    // Make sure it's not accidentally inherited by child processes.\n+    delete process.env.NODE_UNIQUE_ID;\n+  }\n \n-    // There is user code to be run.\n-    prepareUserCodeExecution();\n-    executeUserCode();\n+  // For user code, we preload modules if `-r` is passed\n+  // TODO(joyeecheung): use internal/options instead of\n+  // process._preload_modules\n+  if (process._preload_modules) {\n+    const {\n+      _preloadModules\n+    } = NativeModule.require('internal/modules/cjs/loader');\n+    _preloadModules(process._preload_modules);\n+  }\n+}\n+\n+function executeUserCode() {\n+  // User passed `-e` or `--eval` arguments to Node without `-i` or\n+  // `--interactive`.\n+  // Note that the name `forceRepl` is merely an alias of `interactive`\n+  // in code.\n+  // TODO(joyeecheung): use internal/options instead of\n+  // process._eval/process._forceRepl\n+  if (process._eval != null && !process._forceRepl) {\n+    const {\n+      addBuiltinLibsToObject\n+    } = NativeModule.require('internal/modules/cjs/helpers');\n+    addBuiltinLibsToObject(global);\n+    evalScript('[eval]', wrapForBreakOnFirstLine(process._eval));\n+    return;\n   }\n \n-  function prepareUserCodeExecution() {\n-    // If this is a worker in cluster mode, start up the communication\n-    // channel. This needs to be done before any user code gets executed\n-    // (including preload modules).\n-    if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n-      const cluster = NativeModule.require('cluster');\n-      cluster._setupWorker();\n-      // Make sure it's not accidentally inherited by child processes.\n-      delete process.env.NODE_UNIQUE_ID;\n-    }\n+  // If the first argument is a file name, run it as a main script\n+  if (process.argv[1] && process.argv[1] !== '-') {\n+    // Expand process.argv[1] into a full path.\n+    const path = NativeModule.require('path');\n+    process.argv[1] = path.resolve(process.argv[1]);\n \n-    // For user code, we preload modules if `-r` is passed\n-    // TODO(joyeecheung): use internal/options instead of\n-    // process._preload_modules\n-    if (process._preload_modules) {\n-      const {\n-        _preloadModules\n-      } = NativeModule.require('internal/modules/cjs/loader');\n-      _preloadModules(process._preload_modules);\n-    }\n-  }\n+    const CJSModule = NativeModule.require('internal/modules/cjs/loader');\n \n-  function executeUserCode() {\n-    // User passed `-e` or `--eval` arguments to Node without `-i` or\n-    // `--interactive`.\n-    // Note that the name `forceRepl` is merely an alias of `interactive`\n-    // in code.\n+    // If user passed `-c` or `--check` arguments to Node, check its syntax\n+    // instead of actually running the file.\n     // TODO(joyeecheung): use internal/options instead of\n-    // process._eval/process._forceRepl\n-    if (process._eval != null && !process._forceRepl) {\n-      const {\n-        addBuiltinLibsToObject\n-      } = NativeModule.require('internal/modules/cjs/helpers');\n-      addBuiltinLibsToObject(global);\n-      evalScript('[eval]', wrapForBreakOnFirstLine(process._eval));\n-      return;\n+    // process._syntax_check_only\n+    if (process._syntax_check_only != null) {\n+      const fs = NativeModule.require('fs');\n+      // Read the source.\n+      const filename = CJSModule._resolveFilename(process.argv[1]);\n+      const source = fs.readFileSync(filename, 'utf-8');\n+      checkScriptSyntax(source, filename);\n+      process.exit(0);\n     }\n \n-    // If the first argument is a file name, run it as a main script\n-    if (process.argv[1] && process.argv[1] !== '-') {\n-      // Expand process.argv[1] into a full path.\n-      const path = NativeModule.require('path');\n-      process.argv[1] = path.resolve(process.argv[1]);\n-\n-      const CJSModule = NativeModule.require('internal/modules/cjs/loader');\n-\n-      // If user passed `-c` or `--check` arguments to Node, check its syntax\n-      // instead of actually running the file.\n-      // TODO(joyeecheung): use internal/options instead of\n-      // process._syntax_check_only\n-      if (process._syntax_check_only != null) {\n-        const fs = NativeModule.require('fs');\n-        // Read the source.\n-        const filename = CJSModule._resolveFilename(process.argv[1]);\n-        const source = fs.readFileSync(filename, 'utf-8');\n-        checkScriptSyntax(source, filename);\n-        process.exit(0);\n-      }\n-\n-      // Note: this actually tries to run the module as a ESM first if\n-      // --experimental-modules is on.\n-      // TODO(joyeecheung): can we move that logic to here? Note that this\n-      // is an undocumented method available via `require('module').runMain`\n-      CJSModule.runMain();\n-      return;\n-    }\n+    // Note: this actually tries to run the module as a ESM first if\n+    // --experimental-modules is on.\n+    // TODO(joyeecheung): can we move that logic to here? Note that this\n+    // is an undocumented method available via `require('module').runMain`\n+    CJSModule.runMain();\n+    return;\n+  }\n \n-    // Create the REPL if `-i` or `--interactive` is passed, or if\n-    // stdin is a TTY.\n-    // Note that the name `forceRepl` is merely an alias of `interactive`\n-    // in code.\n-    if (process._forceRepl || NativeModule.require('tty').isatty(0)) {\n-      const cliRepl = NativeModule.require('internal/repl');\n-      cliRepl.createInternalRepl(process.env, (err, repl) => {\n-        if (err) {\n-          throw err;\n+  // Create the REPL if `-i` or `--interactive` is passed, or if\n+  // stdin is a TTY.\n+  // Note that the name `forceRepl` is merely an alias of `interactive`\n+  // in code.\n+  if (process._forceRepl || NativeModule.require('tty').isatty(0)) {\n+    const cliRepl = NativeModule.require('internal/repl');\n+    cliRepl.createInternalRepl(process.env, (err, repl) => {\n+      if (err) {\n+        throw err;\n+      }\n+      repl.on('exit', () => {\n+        if (repl._flushing) {\n+          repl.pause();\n+          return repl.once('flushHistory', () => {\n+            process.exit();\n+          });\n         }\n-        repl.on('exit', () => {\n-          if (repl._flushing) {\n-            repl.pause();\n-            return repl.once('flushHistory', () => {\n-              process.exit();\n-            });\n-          }\n-          process.exit();\n-        });\n+        process.exit();\n       });\n+    });\n \n-      // User passed '-e' or '--eval' along with `-i` or `--interactive`\n-      if (process._eval != null) {\n-        evalScript('[eval]', wrapForBreakOnFirstLine(process._eval));\n-      }\n-      return;\n+    // User passed '-e' or '--eval' along with `-i` or `--interactive`\n+    if (process._eval != null) {\n+      evalScript('[eval]', wrapForBreakOnFirstLine(process._eval));\n     }\n-\n-    // Stdin is not a TTY, we will read it and execute it.\n-    readAndExecuteStdin();\n+    return;\n   }\n \n-  function readAndExecuteStdin() {\n-    process.stdin.setEncoding('utf8');\n+  // Stdin is not a TTY, we will read it and execute it.\n+  readAndExecuteStdin();\n+}\n \n-    let code = '';\n-    process.stdin.on('data', (d) => {\n-      code += d;\n-    });\n+function readAndExecuteStdin() {\n+  process.stdin.setEncoding('utf8');\n \n-    process.stdin.on('end', () => {\n-      if (process._syntax_check_only != null) {\n-        checkScriptSyntax(code, '[stdin]');\n-      } else {\n-        process._eval = code;\n-        evalScript('[stdin]', wrapForBreakOnFirstLine(process._eval));\n-      }\n-    });\n-  }\n+  let code = '';\n+  process.stdin.on('data', (d) => {\n+    code += d;\n+  });\n \n-  function setupTraceCategoryState() {\n-    const { traceCategoryState } = internalBinding('trace_events');\n-    const kCategoryAsyncHooks = 0;\n-    let traceEventsAsyncHook;\n-\n-    function toggleTraceCategoryState() {\n-      // Dynamically enable/disable the traceEventsAsyncHook\n-      const asyncHooksEnabled = !!traceCategoryState[kCategoryAsyncHooks];\n-\n-      if (asyncHooksEnabled) {\n-        // Lazy load internal/trace_events_async_hooks only if the async_hooks\n-        // trace event category is enabled.\n-        if (!traceEventsAsyncHook) {\n-          traceEventsAsyncHook =\n-            NativeModule.require('internal/trace_events_async_hooks');\n-        }\n-        traceEventsAsyncHook.enable();\n-      } else if (traceEventsAsyncHook) {\n-        traceEventsAsyncHook.disable();\n+  process.stdin.on('end', () => {\n+    if (process._syntax_check_only != null) {\n+      checkScriptSyntax(code, '[stdin]');\n+    } else {\n+      process._eval = code;\n+      evalScript('[stdin]', wrapForBreakOnFirstLine(process._eval));\n+    }\n+  });\n+}\n+\n+function setupTraceCategoryState() {\n+  const { traceCategoryState } = internalBinding('trace_events');\n+  const kCategoryAsyncHooks = 0;\n+  let traceEventsAsyncHook;\n+\n+  function toggleTraceCategoryState() {\n+    // Dynamically enable/disable the traceEventsAsyncHook\n+    const asyncHooksEnabled = !!traceCategoryState[kCategoryAsyncHooks];\n+\n+    if (asyncHooksEnabled) {\n+      // Lazy load internal/trace_events_async_hooks only if the async_hooks\n+      // trace event category is enabled.\n+      if (!traceEventsAsyncHook) {\n+        traceEventsAsyncHook =\n+          NativeModule.require('internal/trace_events_async_hooks');\n       }\n+      traceEventsAsyncHook.enable();\n+    } else if (traceEventsAsyncHook) {\n+      traceEventsAsyncHook.disable();\n     }\n-\n-    toggleTraceCategoryState();\n-    _setupTraceCategoryState(toggleTraceCategoryState);\n   }\n \n-  function setupProcessObject() {\n-    const EventEmitter = NativeModule.require('events');\n-    const origProcProto = Object.getPrototypeOf(process);\n-    Object.setPrototypeOf(origProcProto, EventEmitter.prototype);\n-    EventEmitter.call(process);\n+  toggleTraceCategoryState();\n+  _setupTraceCategoryState(toggleTraceCategoryState);\n+}\n+\n+function setupProcessObject() {\n+  const EventEmitter = NativeModule.require('events');\n+  const origProcProto = Object.getPrototypeOf(process);\n+  Object.setPrototypeOf(origProcProto, EventEmitter.prototype);\n+  EventEmitter.call(process);\n+}\n+\n+function setupGlobalVariables() {\n+  Object.defineProperty(global, Symbol.toStringTag, {\n+    value: 'global',\n+    writable: false,\n+    enumerable: false,\n+    configurable: true\n+  });\n+  global.process = process;\n+  const util = NativeModule.require('util');\n+\n+  function makeGetter(name) {\n+    return util.deprecate(function() {\n+      return this;\n+    }, `'${name}' is deprecated, use 'global'`, 'DEP0016');\n   }\n \n-  function setupGlobalVariables() {\n-    Object.defineProperty(global, Symbol.toStringTag, {\n-      value: 'global',\n-      writable: false,\n-      enumerable: false,\n-      configurable: true\n-    });\n-    global.process = process;\n-    const util = NativeModule.require('util');\n-\n-    function makeGetter(name) {\n-      return util.deprecate(function() {\n-        return this;\n-      }, `'${name}' is deprecated, use 'global'`, 'DEP0016');\n-    }\n-\n-    function makeSetter(name) {\n-      return util.deprecate(function(value) {\n-        Object.defineProperty(this, name, {\n-          configurable: true,\n-          writable: true,\n-          enumerable: true,\n-          value: value\n-        });\n-      }, `'${name}' is deprecated, use 'global'`, 'DEP0016');\n-    }\n-\n-    Object.defineProperties(global, {\n-      GLOBAL: {\n-        configurable: true,\n-        get: makeGetter('GLOBAL'),\n-        set: makeSetter('GLOBAL')\n-      },\n-      root: {\n+  function makeSetter(name) {\n+    return util.deprecate(function(value) {\n+      Object.defineProperty(this, name, {\n         configurable: true,\n-        get: makeGetter('root'),\n-        set: makeSetter('root')\n-      }\n-    });\n-\n-    // This, as side effect, removes `setupBufferJS` from the buffer binding,\n-    // and exposes it on `internal/buffer`.\n-    NativeModule.require('internal/buffer');\n-\n-    global.Buffer = NativeModule.require('buffer').Buffer;\n-    process.domain = null;\n-    process._exiting = false;\n-  }\n-\n-  function setupGlobalTimeouts() {\n-    const timers = NativeModule.require('timers');\n-    global.clearImmediate = timers.clearImmediate;\n-    global.clearInterval = timers.clearInterval;\n-    global.clearTimeout = timers.clearTimeout;\n-    global.setImmediate = timers.setImmediate;\n-    global.setInterval = timers.setInterval;\n-    global.setTimeout = timers.setTimeout;\n+        writable: true,\n+        enumerable: true,\n+        value: value\n+      });\n+    }, `'${name}' is deprecated, use 'global'`, 'DEP0016');\n   }\n \n-  function setupGlobalConsole() {\n-    const consoleFromVM = global.console;\n-    const consoleFromNode =\n-      NativeModule.require('internal/console/global');\n-    // Override global console from the one provided by the VM\n-    // to the one implemented by Node.js\n-    Object.defineProperty(global, 'console', {\n+  Object.defineProperties(global, {\n+    GLOBAL: {\n       configurable: true,\n-      enumerable: false,\n-      value: consoleFromNode,\n-      writable: true\n-    });\n-    // TODO(joyeecheung): can we skip this if inspector is not active?\n-    if (process.config.variables.v8_enable_inspector) {\n-      const inspector =\n-        NativeModule.require('internal/console/inspector');\n-      inspector.addInspectorApis(consoleFromNode, consoleFromVM);\n-      // This will be exposed by `require('inspector').console` later.\n-      inspector.consoleFromVM = consoleFromVM;\n+      get: makeGetter('GLOBAL'),\n+      set: makeSetter('GLOBAL')\n+    },\n+    root: {\n+      configurable: true,\n+      get: makeGetter('root'),\n+      set: makeSetter('root')\n     }\n+  });\n+\n+  // This, as side effect, removes `setupBufferJS` from the buffer binding,\n+  // and exposes it on `internal/buffer`.\n+  NativeModule.require('internal/buffer');\n+\n+  global.Buffer = NativeModule.require('buffer').Buffer;\n+  process.domain = null;\n+  process._exiting = false;\n+}\n+\n+function setupGlobalTimeouts() {\n+  const timers = NativeModule.require('timers');\n+  global.clearImmediate = timers.clearImmediate;\n+  global.clearInterval = timers.clearInterval;\n+  global.clearTimeout = timers.clearTimeout;\n+  global.setImmediate = timers.setImmediate;\n+  global.setInterval = timers.setInterval;\n+  global.setTimeout = timers.setTimeout;\n+}\n+\n+function setupGlobalConsole() {\n+  const consoleFromVM = global.console;\n+  const consoleFromNode =\n+    NativeModule.require('internal/console/global');\n+  // Override global console from the one provided by the VM\n+  // to the one implemented by Node.js\n+  Object.defineProperty(global, 'console', {\n+    configurable: true,\n+    enumerable: false,\n+    value: consoleFromNode,\n+    writable: true\n+  });\n+  // TODO(joyeecheung): can we skip this if inspector is not active?\n+  if (process.config.variables.v8_enable_inspector) {\n+    const inspector =\n+      NativeModule.require('internal/console/inspector');\n+    inspector.addInspectorApis(consoleFromNode, consoleFromVM);\n+    // This will be exposed by `require('inspector').console` later.\n+    inspector.consoleFromVM = consoleFromVM;\n   }\n-\n-  function setupGlobalURL() {\n-    const { URL, URLSearchParams } = NativeModule.require('internal/url');\n-    Object.defineProperties(global, {\n-      URL: {\n-        value: URL,\n-        writable: true,\n-        configurable: true,\n-        enumerable: false\n-      },\n-      URLSearchParams: {\n-        value: URLSearchParams,\n-        writable: true,\n-        configurable: true,\n-        enumerable: false\n-      }\n-    });\n-  }\n-\n-  function setupGlobalEncoding() {\n-    const { TextEncoder, TextDecoder } = NativeModule.require('util');\n-    Object.defineProperties(global, {\n-      TextEncoder: {\n-        value: TextEncoder,\n+}\n+\n+function setupGlobalURL() {\n+  const { URL, URLSearchParams } = NativeModule.require('internal/url');\n+  Object.defineProperties(global, {\n+    URL: {\n+      value: URL,\n+      writable: true,\n+      configurable: true,\n+      enumerable: false\n+    },\n+    URLSearchParams: {\n+      value: URLSearchParams,\n+      writable: true,\n+      configurable: true,\n+      enumerable: false\n+    }\n+  });\n+}\n+\n+function setupGlobalEncoding() {\n+  const { TextEncoder, TextDecoder } = NativeModule.require('util');\n+  Object.defineProperties(global, {\n+    TextEncoder: {\n+      value: TextEncoder,\n+      writable: true,\n+      configurable: true,\n+      enumerable: false\n+    },\n+    TextDecoder: {\n+      value: TextDecoder,\n+      writable: true,\n+      configurable: true,\n+      enumerable: false\n+    }\n+  });\n+}\n+\n+function setupQueueMicrotask() {\n+  Object.defineProperty(global, 'queueMicrotask', {\n+    get: () => {\n+      process.emitWarning('queueMicrotask() is experimental.',\n+                          'ExperimentalWarning');\n+      const { setupQueueMicrotask } =\n+        NativeModule.require('internal/queue_microtask');\n+      const queueMicrotask = setupQueueMicrotask(triggerFatalException);\n+      Object.defineProperty(global, 'queueMicrotask', {\n+        value: queueMicrotask,\n         writable: true,\n+        enumerable: false,\n         configurable: true,\n-        enumerable: false\n-      },\n-      TextDecoder: {\n-        value: TextDecoder,\n+      });\n+      return queueMicrotask;\n+    },\n+    set: (v) => {\n+      Object.defineProperty(global, 'queueMicrotask', {\n+        value: v,\n         writable: true,\n+        enumerable: false,\n         configurable: true,\n-        enumerable: false\n-      }\n-    });\n-  }\n-\n-  function setupQueueMicrotask() {\n-    Object.defineProperty(global, 'queueMicrotask', {\n-      get: () => {\n-        process.emitWarning('queueMicrotask() is experimental.',\n-                            'ExperimentalWarning');\n-        const { setupQueueMicrotask } =\n-          NativeModule.require('internal/queue_microtask');\n-        const queueMicrotask = setupQueueMicrotask(triggerFatalException);\n-        Object.defineProperty(global, 'queueMicrotask', {\n-          value: queueMicrotask,\n-          writable: true,\n-          enumerable: false,\n-          configurable: true,\n-        });\n-        return queueMicrotask;\n-      },\n-      set: (v) => {\n-        Object.defineProperty(global, 'queueMicrotask', {\n-          value: v,\n-          writable: true,\n-          enumerable: false,\n-          configurable: true,\n-        });\n-      },\n-      enumerable: false,\n-      configurable: true,\n-    });\n-  }\n-\n-  function setupDOMException() {\n-    // Registers the constructor with C++.\n-    const DOMException = NativeModule.require('internal/domexception');\n-    const { registerDOMException } = internalBinding('messaging');\n-    registerDOMException(DOMException);\n-  }\n-\n-  function noop() {}\n-\n-  function setupProcessFatal() {\n-    const {\n-      executionAsyncId,\n-      clearDefaultTriggerAsyncId,\n-      clearAsyncIdStack,\n-      hasAsyncIdStack,\n-      afterHooksExist,\n-      emitAfter\n-    } = NativeModule.require('internal/async_hooks');\n-\n-    process._fatalException = (er) => {\n-      // It's possible that defaultTriggerAsyncId was set for a constructor\n-      // call that threw and was never cleared. So clear it now.\n-      clearDefaultTriggerAsyncId();\n-\n-      if (exceptionHandlerState.captureFn !== null) {\n-        exceptionHandlerState.captureFn(er);\n-      } else if (!process.emit('uncaughtException', er)) {\n-        // If someone handled it, then great.  otherwise, die in C++ land\n-        // since that means that we'll exit the process, emit the 'exit' event.\n-        try {\n-          if (!process._exiting) {\n-            process._exiting = true;\n-            process.exitCode = 1;\n-            process.emit('exit', 1);\n-          }\n-        } catch {\n-          // Nothing to be done about it at this point.\n-        }\n-        try {\n-          const { kExpandStackSymbol } = NativeModule.require('internal/util');\n-          if (typeof er[kExpandStackSymbol] === 'function')\n-            er[kExpandStackSymbol]();\n-        } catch {\n-          // Nothing to be done about it at this point.\n+      });\n+    },\n+    enumerable: false,\n+    configurable: true,\n+  });\n+}\n+\n+function setupDOMException() {\n+  // Registers the constructor with C++.\n+  const DOMException = NativeModule.require('internal/domexception');\n+  const { registerDOMException } = internalBinding('messaging');\n+  registerDOMException(DOMException);\n+}\n+\n+function noop() {}\n+\n+function setupProcessFatal() {\n+  const {\n+    executionAsyncId,\n+    clearDefaultTriggerAsyncId,\n+    clearAsyncIdStack,\n+    hasAsyncIdStack,\n+    afterHooksExist,\n+    emitAfter\n+  } = NativeModule.require('internal/async_hooks');\n+\n+  process._fatalException = (er) => {\n+    // It's possible that defaultTriggerAsyncId was set for a constructor\n+    // call that threw and was never cleared. So clear it now.\n+    clearDefaultTriggerAsyncId();\n+\n+    if (exceptionHandlerState.captureFn !== null) {\n+      exceptionHandlerState.captureFn(er);\n+    } else if (!process.emit('uncaughtException', er)) {\n+      // If someone handled it, then great.  otherwise, die in C++ land\n+      // since that means that we'll exit the process, emit the 'exit' event.\n+      try {\n+        if (!process._exiting) {\n+          process._exiting = true;\n+          process.exitCode = 1;\n+          process.emit('exit', 1);\n         }\n-        return false;\n+      } catch {\n+        // Nothing to be done about it at this point.\n       }\n-\n-      // If we handled an error, then make sure any ticks get processed\n-      // by ensuring that the next Immediate cycle isn't empty.\n-      NativeModule.require('timers').setImmediate(noop);\n-\n-      // Emit the after() hooks now that the exception has been handled.\n-      if (afterHooksExist()) {\n-        do {\n-          emitAfter(executionAsyncId());\n-        } while (hasAsyncIdStack());\n-      // Or completely empty the id stack.\n-      } else {\n-        clearAsyncIdStack();\n+      try {\n+        const { kExpandStackSymbol } = NativeModule.require('internal/util');\n+        if (typeof er[kExpandStackSymbol] === 'function')\n+          er[kExpandStackSymbol]();\n+      } catch {\n+        // Nothing to be done about it at this point.\n       }\n-\n-      return true;\n-    };\n-  }\n-\n-  function setupProcessICUVersions() {\n-    const icu = process.binding('config').hasIntl ?\n-      internalBinding('icu') : undefined;\n-    if (!icu) return;  // no Intl/ICU: nothing to add here.\n-    // With no argument, getVersion() returns a comma separated list\n-    // of possible types.\n-    const versionTypes = icu.getVersion().split(',');\n-\n-    for (var n = 0; n < versionTypes.length; n++) {\n-      const name = versionTypes[n];\n-      const version = icu.getVersion(name);\n-      Object.defineProperty(process.versions, name, {\n-        writable: false,\n-        enumerable: true,\n-        value: version\n-      });\n+      return false;\n     }\n-  }\n \n-  function wrapForBreakOnFirstLine(source) {\n-    if (!process._breakFirstLine)\n-      return source;\n-    const fn = `function() {\\n\\n${source};\\n\\n}`;\n-    return `process.binding('inspector').callAndPauseOnStart(${fn}, {})`;\n-  }\n-\n-  function evalScript(name, body) {\n-    const CJSModule = NativeModule.require('internal/modules/cjs/loader');\n-    const path = NativeModule.require('path');\n-    const { tryGetCwd } = NativeModule.require('internal/util');\n-    const cwd = tryGetCwd(path);\n-\n-    const module = new CJSModule(name);\n-    module.filename = path.join(cwd, name);\n-    module.paths = CJSModule._nodeModulePaths(cwd);\n-    const script = `global.__filename = ${JSON.stringify(name)};\\n` +\n-                   'global.exports = exports;\\n' +\n-                   'global.module = module;\\n' +\n-                   'global.__dirname = __dirname;\\n' +\n-                   'global.require = require;\\n' +\n-                   'return require(\"vm\").runInThisContext(' +\n-                   `${JSON.stringify(body)}, { filename: ` +\n-                   `${JSON.stringify(name)}, displayErrors: true });\\n`;\n-    const result = module._compile(script, `${name}-wrapper`);\n-    if (process._print_eval) console.log(result);\n-    // Handle any nextTicks added in the first tick of the program.\n-    process._tickCallback();\n-  }\n+    // If we handled an error, then make sure any ticks get processed\n+    // by ensuring that the next Immediate cycle isn't empty.\n+    NativeModule.require('timers').setImmediate(noop);\n \n-  function checkScriptSyntax(source, filename) {\n-    const CJSModule = NativeModule.require('internal/modules/cjs/loader');\n-    const vm = NativeModule.require('vm');\n-    const {\n-      stripShebang, stripBOM\n-    } = NativeModule.require('internal/modules/cjs/helpers');\n+    // Emit the after() hooks now that the exception has been handled.\n+    if (afterHooksExist()) {\n+      do {\n+        emitAfter(executionAsyncId());\n+      } while (hasAsyncIdStack());\n+    // Or completely empty the id stack.\n+    } else {\n+      clearAsyncIdStack();\n+    }\n \n-    // Remove Shebang.\n-    source = stripShebang(source);\n-    // Remove BOM.\n-    source = stripBOM(source);\n-    // Wrap it.\n-    source = CJSModule.wrap(source);\n-    // Compile the script, this will throw if it fails.\n-    new vm.Script(source, { displayErrors: true, filename });\n+    return true;\n+  };\n+}\n+\n+function setupProcessICUVersions() {\n+  const icu = process.binding('config').hasIntl ?\n+    internalBinding('icu') : undefined;\n+  if (!icu) return;  // no Intl/ICU: nothing to add here.\n+  // With no argument, getVersion() returns a comma separated list\n+  // of possible types.\n+  const versionTypes = icu.getVersion().split(',');\n+\n+  for (var n = 0; n < versionTypes.length; n++) {\n+    const name = versionTypes[n];\n+    const version = icu.getVersion(name);\n+    Object.defineProperty(process.versions, name, {\n+      writable: false,\n+      enumerable: true,\n+      value: version\n+    });\n   }\n-\n-  startup();\n-});\n+}\n+\n+function wrapForBreakOnFirstLine(source) {\n+  if (!process._breakFirstLine)\n+    return source;\n+  const fn = `function() {\\n\\n${source};\\n\\n}`;\n+  return `process.binding('inspector').callAndPauseOnStart(${fn}, {})`;\n+}\n+\n+function evalScript(name, body) {\n+  const CJSModule = NativeModule.require('internal/modules/cjs/loader');\n+  const path = NativeModule.require('path');\n+  const { tryGetCwd } = NativeModule.require('internal/util');\n+  const cwd = tryGetCwd(path);\n+\n+  const module = new CJSModule(name);\n+  module.filename = path.join(cwd, name);\n+  module.paths = CJSModule._nodeModulePaths(cwd);\n+  const script = `global.__filename = ${JSON.stringify(name)};\\n` +\n+                  'global.exports = exports;\\n' +\n+                  'global.module = module;\\n' +\n+                  'global.__dirname = __dirname;\\n' +\n+                  'global.require = require;\\n' +\n+                  'return require(\"vm\").runInThisContext(' +\n+                  `${JSON.stringify(body)}, { filename: ` +\n+                  `${JSON.stringify(name)}, displayErrors: true });\\n`;\n+  const result = module._compile(script, `${name}-wrapper`);\n+  if (process._print_eval) console.log(result);\n+  // Handle any nextTicks added in the first tick of the program.\n+  process._tickCallback();\n+}\n+\n+function checkScriptSyntax(source, filename) {\n+  const CJSModule = NativeModule.require('internal/modules/cjs/loader');\n+  const vm = NativeModule.require('vm');\n+  const {\n+    stripShebang, stripBOM\n+  } = NativeModule.require('internal/modules/cjs/helpers');\n+\n+  // Remove Shebang.\n+  source = stripShebang(source);\n+  // Remove BOM.\n+  source = stripBOM(source);\n+  // Wrap it.\n+  source = CJSModule.wrap(source);\n+  // Compile the script, this will throw if it fails.\n+  new vm.Script(source, { displayErrors: true, filename });\n+}\n+\n+startup();"
        },
        {
            "sha": "725ba403df2348dfb8cea6dc0c92553fa5ecb2ec",
            "filename": "lib/internal/per_context.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/edcb9500902437a7edf912b27f259c173ce14767/lib%2Finternal%2Fper_context.js",
            "raw_url": "https://github.com/nodejs/node/raw/edcb9500902437a7edf912b27f259c173ce14767/lib%2Finternal%2Fper_context.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fper_context.js?ref=edcb9500902437a7edf912b27f259c173ce14767",
            "patch": "@@ -1,9 +1,9 @@\n-// arguments: global\n+// This file is compiled as if it's wrapped in a function with arguments\n+// passed by node::NewContext()\n+/* global global */\n \n 'use strict';\n \n-// node::NewContext calls this script\n-\n // https://github.com/nodejs/node/issues/14909\n if (global.Intl) delete global.Intl.v8BreakIterator;\n "
        },
        {
            "sha": "24fe3a71e96dfef8b6d84481941236a373e6d25a",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 55,
            "deletions": 155,
            "changes": 210,
            "blob_url": "https://github.com/nodejs/node/blob/edcb9500902437a7edf912b27f259c173ce14767/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/edcb9500902437a7edf912b27f259c173ce14767/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=edcb9500902437a7edf912b27f259c173ce14767",
            "patch": "@@ -116,7 +116,6 @@ typedef int mode_t;\n \n namespace node {\n \n-using errors::TryCatchScope;\n using native_module::NativeModuleLoader;\n using options_parser::kAllowedInEnvironment;\n using options_parser::kDisallowedInEnvironment;\n@@ -144,7 +143,6 @@ using v8::NamedPropertyHandlerConfiguration;\n using v8::NewStringType;\n using v8::None;\n using v8::Nothing;\n-using v8::Null;\n using v8::Object;\n using v8::ObjectTemplate;\n using v8::PropertyAttribute;\n@@ -741,41 +739,6 @@ Local<Value> MakeCallback(Isolate* isolate,\n           .FromMaybe(Local<Value>()));\n }\n \n-// Executes a str within the current v8 context.\n-static MaybeLocal<Value> ExecuteString(Environment* env,\n-                                       Local<String> source,\n-                                       Local<String> filename) {\n-  EscapableHandleScope scope(env->isolate());\n-  TryCatchScope try_catch(env);\n-\n-  // try_catch must be nonverbose to disable FatalException() handler,\n-  // we will handle exceptions ourself.\n-  try_catch.SetVerbose(false);\n-\n-  ScriptOrigin origin(filename);\n-\n-  MaybeLocal<Script> script =\n-      Script::Compile(env->context(), source, &origin);\n-  if (script.IsEmpty()) {\n-    ReportException(env, try_catch);\n-    env->Exit(3);\n-    return MaybeLocal<Value>();\n-  }\n-\n-  MaybeLocal<Value> result = script.ToLocalChecked()->Run(env->context());\n-  if (result.IsEmpty()) {\n-    if (try_catch.HasTerminated()) {\n-      env->isolate()->CancelTerminateExecution();\n-      return MaybeLocal<Value>();\n-    }\n-    ReportException(env, try_catch);\n-    env->Exit(4);\n-    return MaybeLocal<Value>();\n-  }\n-\n-  return scope.Escape(result.ToLocalChecked());\n-}\n-\n static void WaitForInspectorDisconnect(Environment* env) {\n #if HAVE_INSPECTOR\n   if (env->inspector_agent()->IsActive()) {\n@@ -1334,39 +1297,13 @@ void SignalExit(int signo) {\n   raise(signo);\n }\n \n-\n-static MaybeLocal<Function> GetBootstrapper(\n+static MaybeLocal<Value> ExecuteBootstrapper(\n     Environment* env,\n-    Local<String> source,\n-    Local<String> script_name) {\n-  EscapableHandleScope scope(env->isolate());\n-\n-  TryCatchScope try_catch(env);\n-\n-  // Disable verbose mode to stop FatalException() handler from trying\n-  // to handle the exception. Errors this early in the start-up phase\n-  // are not safe to ignore.\n-  try_catch.SetVerbose(false);\n-\n-  // Execute the bootstrapper javascript file\n-  MaybeLocal<Value> bootstrapper_v = ExecuteString(env, source, script_name);\n-  if (bootstrapper_v.IsEmpty())  // This happens when execution was interrupted.\n-    return MaybeLocal<Function>();\n-\n-  if (try_catch.HasCaught())  {\n-    ReportException(env, try_catch);\n-    exit(10);\n-  }\n-\n-  CHECK(bootstrapper_v.ToLocalChecked()->IsFunction());\n-  return scope.Escape(bootstrapper_v.ToLocalChecked().As<Function>());\n-}\n-\n-static bool ExecuteBootstrapper(Environment* env, Local<Function> bootstrapper,\n-                                int argc, Local<Value> argv[],\n-                                Local<Value>* out) {\n-  bool ret = bootstrapper->Call(\n-      env->context(), Null(env->isolate()), argc, argv).ToLocal(out);\n+    const char* id,\n+    std::vector<Local<String>>* parameters,\n+    std::vector<Local<Value>>* arguments) {\n+  MaybeLocal<Value> ret = per_process_loader.CompileAndCall(\n+      env->context(), id, parameters, arguments, env);\n \n   // If there was an error during bootstrap then it was either handled by the\n   // FatalException handler or it's unrecoverable (e.g. max call stack\n@@ -1375,123 +1312,86 @@ static bool ExecuteBootstrapper(Environment* env, Local<Function> bootstrapper,\n   // There are only two ways to have a stack size > 1: 1) the user manually\n   // called MakeCallback or 2) user awaited during bootstrap, which triggered\n   // _tickCallback().\n-  if (!ret) {\n+  if (ret.IsEmpty()) {\n     env->async_hooks()->clear_async_id_stack();\n   }\n \n   return ret;\n }\n \n-\n void LoadEnvironment(Environment* env) {\n   HandleScope handle_scope(env->isolate());\n-\n-  TryCatchScope try_catch(env);\n-  // Disable verbose mode to stop FatalException() handler from trying\n-  // to handle the exception. Errors this early in the start-up phase\n-  // are not safe to ignore.\n-  try_catch.SetVerbose(false);\n-\n-  // The bootstrapper scripts are lib/internal/bootstrap/loaders.js and\n-  // lib/internal/bootstrap/node.js, each included as a static C string\n-  // generated in node_javascript.cc by node_js2c.\n-\n-  // TODO(joyeecheung): use NativeModuleLoader::Compile\n-  // We duplicate the string literals here since once we refactor the bootstrap\n-  // compilation out to NativeModuleLoader none of this is going to matter\n   Isolate* isolate = env->isolate();\n-  Local<String> loaders_name =\n-      FIXED_ONE_BYTE_STRING(isolate, \"internal/bootstrap/loaders.js\");\n-  Local<String> loaders_source =\n-      per_process_loader.GetSource(isolate, \"internal/bootstrap/loaders\");\n-  MaybeLocal<Function> loaders_bootstrapper =\n-      GetBootstrapper(env, loaders_source, loaders_name);\n-  Local<String> node_name =\n-      FIXED_ONE_BYTE_STRING(isolate, \"internal/bootstrap/node.js\");\n-  Local<String> node_source =\n-      per_process_loader.GetSource(isolate, \"internal/bootstrap/node\");\n-  MaybeLocal<Function> node_bootstrapper =\n-      GetBootstrapper(env, node_source, node_name);\n-\n-  if (loaders_bootstrapper.IsEmpty() || node_bootstrapper.IsEmpty()) {\n-    // Execution was interrupted.\n-    return;\n-  }\n+  Local<Context> context = env->context();\n \n   // Add a reference to the global object\n-  Local<Object> global = env->context()->Global();\n+  Local<Object> global = context->Global();\n \n #if defined HAVE_DTRACE || defined HAVE_ETW\n   InitDTrace(env, global);\n #endif\n \n-  // Enable handling of uncaught exceptions\n-  // (FatalException(), break on uncaught exception in debugger)\n-  //\n-  // This is not strictly necessary since it's almost impossible\n-  // to attach the debugger fast enough to break on exception\n-  // thrown during process startup.\n-  try_catch.SetVerbose(true);\n-\n-  env->SetMethod(env->process_object(), \"_rawDebug\", RawDebug);\n+  Local<Object> process = env->process_object();\n \n+  // Setting global properties for the bootstrappers to use:\n+  // - global\n+  // - process._rawDebug\n   // Expose the global object as a property on itself\n   // (Allows you to set stuff on `global` from anywhere in JavaScript.)\n-  global->Set(env->context(),\n-              FIXED_ONE_BYTE_STRING(env->isolate(), \"global\"),\n-              global).FromJust();\n+  global->Set(context, FIXED_ONE_BYTE_STRING(env->isolate(), \"global\"), global)\n+      .FromJust();\n+  env->SetMethod(process, \"_rawDebug\", RawDebug);\n \n   // Create binding loaders\n-  Local<Function> get_binding_fn = env->NewFunctionTemplate(binding::GetBinding)\n-                                       ->GetFunction(env->context())\n-                                       .ToLocalChecked();\n-\n-  Local<Function> get_linked_binding_fn =\n+  std::vector<Local<String>> loaders_params = {\n+      env->process_string(),\n+      FIXED_ONE_BYTE_STRING(isolate, \"getBinding\"),\n+      FIXED_ONE_BYTE_STRING(isolate, \"getLinkedBinding\"),\n+      FIXED_ONE_BYTE_STRING(isolate, \"getInternalBinding\"),\n+      FIXED_ONE_BYTE_STRING(isolate, \"debugBreak\")};\n+  std::vector<Local<Value>> loaders_args = {\n+      process,\n+      env->NewFunctionTemplate(binding::GetBinding)\n+          ->GetFunction(context)\n+          .ToLocalChecked(),\n       env->NewFunctionTemplate(binding::GetLinkedBinding)\n-          ->GetFunction(env->context())\n-          .ToLocalChecked();\n-\n-  Local<Function> get_internal_binding_fn =\n+          ->GetFunction(context)\n+          .ToLocalChecked(),\n       env->NewFunctionTemplate(binding::GetInternalBinding)\n-          ->GetFunction(env->context())\n-          .ToLocalChecked();\n-\n-  Local<Value> loaders_bootstrapper_args[] = {\n-    env->process_object(),\n-    get_binding_fn,\n-    get_linked_binding_fn,\n-    get_internal_binding_fn,\n-    Boolean::New(env->isolate(),\n-                 env->options()->debug_options->break_node_first_line)\n-  };\n+          ->GetFunction(context)\n+          .ToLocalChecked(),\n+      Boolean::New(isolate,\n+                   env->options()->debug_options->break_node_first_line)};\n \n+  MaybeLocal<Value> loader_exports;\n   // Bootstrap internal loaders\n-  Local<Value> bootstrapped_loaders;\n-  if (!ExecuteBootstrapper(env, loaders_bootstrapper.ToLocalChecked(),\n-                           arraysize(loaders_bootstrapper_args),\n-                           loaders_bootstrapper_args,\n-                           &bootstrapped_loaders)) {\n+  loader_exports = ExecuteBootstrapper(\n+      env, \"internal/bootstrap/loaders\", &loaders_params, &loaders_args);\n+  if (loader_exports.IsEmpty()) {\n     return;\n   }\n \n-  Local<Function> trigger_fatal_exception =\n-      env->NewFunctionTemplate(FatalException)->GetFunction(env->context())\n-          .ToLocalChecked();\n-\n   // Bootstrap Node.js\n   Local<Object> bootstrapper = Object::New(env->isolate());\n   SetupBootstrapObject(env, bootstrapper);\n-  Local<Value> bootstrapped_node;\n-  Local<Value> node_bootstrapper_args[] = {\n-    env->process_object(),\n-    bootstrapper,\n-    bootstrapped_loaders,\n-    trigger_fatal_exception,\n-  };\n-  if (!ExecuteBootstrapper(env, node_bootstrapper.ToLocalChecked(),\n-                           arraysize(node_bootstrapper_args),\n-                           node_bootstrapper_args,\n-                           &bootstrapped_node)) {\n+\n+  // process, bootstrappers, loaderExports, triggerFatalException\n+  std::vector<Local<String>> node_params = {\n+      env->process_string(),\n+      FIXED_ONE_BYTE_STRING(isolate, \"bootstrappers\"),\n+      FIXED_ONE_BYTE_STRING(isolate, \"loaderExports\"),\n+      FIXED_ONE_BYTE_STRING(isolate, \"triggerFatalException\")};\n+  std::vector<Local<Value>> node_args = {\n+      process,\n+      bootstrapper,\n+      loader_exports.ToLocalChecked(),\n+      env->NewFunctionTemplate(FatalException)\n+          ->GetFunction(context)\n+          .ToLocalChecked()};\n+\n+  if (ExecuteBootstrapper(\n+          env, \"internal/bootstrap/node\", &node_params, &node_args)\n+          .IsEmpty()) {\n     return;\n   }\n }"
        },
        {
            "sha": "dfa8ec0f7d400bdab0bf91029435cadb435dde2a",
            "filename": "test/message/eval_messages.out",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/edcb9500902437a7edf912b27f259c173ce14767/test%2Fmessage%2Feval_messages.out",
            "raw_url": "https://github.com/nodejs/node/raw/edcb9500902437a7edf912b27f259c173ce14767/test%2Fmessage%2Feval_messages.out",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fmessage%2Feval_messages.out?ref=edcb9500902437a7edf912b27f259c173ce14767",
            "patch": "@@ -12,7 +12,7 @@ SyntaxError: Strict mode code may not include a with statement\n     at executeUserCode (internal/bootstrap/node.js:*:*)\n     at startExecution (internal/bootstrap/node.js:*:*)\n     at startup (internal/bootstrap/node.js:*:*)\n-    at bootstrapNodeJSCore (internal/bootstrap/node.js:*:*)\n+    at internal/bootstrap/node.js:*:*\n 42\n 42\n [eval]:1\n@@ -29,7 +29,7 @@ Error: hello\n     at executeUserCode (internal/bootstrap/node.js:*:*)\n     at startExecution (internal/bootstrap/node.js:*:*)\n     at startup (internal/bootstrap/node.js:*:*)\n-    at bootstrapNodeJSCore (internal/bootstrap/node.js:*:*)\n+    at internal/bootstrap/node.js:*:*\n \n [eval]:1\n throw new Error(\"hello\")\n@@ -45,7 +45,7 @@ Error: hello\n     at executeUserCode (internal/bootstrap/node.js:*:*)\n     at startExecution (internal/bootstrap/node.js:*:*)\n     at startup (internal/bootstrap/node.js:*:*)\n-    at bootstrapNodeJSCore (internal/bootstrap/node.js:*:*)\n+    at internal/bootstrap/node.js:*:*\n 100\n [eval]:1\n var x = 100; y = x;\n@@ -61,7 +61,7 @@ ReferenceError: y is not defined\n     at executeUserCode (internal/bootstrap/node.js:*:*)\n     at startExecution (internal/bootstrap/node.js:*:*)\n     at startup (internal/bootstrap/node.js:*:*)\n-    at bootstrapNodeJSCore (internal/bootstrap/node.js:*:*)\n+    at internal/bootstrap/node.js:*:*\n \n [eval]:1\n var ______________________________________________; throw 10"
        },
        {
            "sha": "1c0ed6df9341fe55ddee064e4a0723a79995185e",
            "filename": "test/message/events_unhandled_error_nexttick.out",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/edcb9500902437a7edf912b27f259c173ce14767/test%2Fmessage%2Fevents_unhandled_error_nexttick.out",
            "raw_url": "https://github.com/nodejs/node/raw/edcb9500902437a7edf912b27f259c173ce14767/test%2Fmessage%2Fevents_unhandled_error_nexttick.out",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fmessage%2Fevents_unhandled_error_nexttick.out?ref=edcb9500902437a7edf912b27f259c173ce14767",
            "patch": "@@ -21,4 +21,4 @@ Emitted 'error' event at:\n     at executeUserCode (internal/bootstrap/node.js:*:*)\n     at startExecution (internal/bootstrap/node.js:*:*)\n     at startup (internal/bootstrap/node.js:*:*)\n-    at bootstrapNodeJSCore (internal/bootstrap/node.js:*:*)\n+    at internal/bootstrap/node.js:*:*"
        },
        {
            "sha": "2bf69e8146130a556b3c45a4ed7960bdbb719226",
            "filename": "test/message/nexttick_throw.out",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/edcb9500902437a7edf912b27f259c173ce14767/test%2Fmessage%2Fnexttick_throw.out",
            "raw_url": "https://github.com/nodejs/node/raw/edcb9500902437a7edf912b27f259c173ce14767/test%2Fmessage%2Fnexttick_throw.out",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fmessage%2Fnexttick_throw.out?ref=edcb9500902437a7edf912b27f259c173ce14767",
            "patch": "@@ -10,4 +10,4 @@ ReferenceError: undefined_reference_error_maker is not defined\n     at executeUserCode (internal/bootstrap/node.js:*:*)\n     at startExecution (internal/bootstrap/node.js:*:*)\n     at startup (internal/bootstrap/node.js:*:*)\n-    at bootstrapNodeJSCore (internal/bootstrap/node.js:*:*)\n+    at internal/bootstrap/node.js:*:*"
        }
    ],
    "stats": {
        "total": 2049,
        "additions": 975,
        "deletions": 1074
    }
}