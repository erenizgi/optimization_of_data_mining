{
    "author": "addaleax",
    "message": "src: simplify `TimerFunctionCall()` in `node_perf.cc`\n\nPicking a path according to a boolean is essentially free,\ncompared to the cost of a function call. Also, remove an\nunnecessary `TryCatch`.\n\nPR-URL: https://github.com/nodejs/node/pull/23782\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Matheus Marchini <mat@mmarchini.me>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "22ee5d920970bcbd3103b986be9b8f68394a5361",
    "files": [
        {
            "sha": "5f1b70a5c4db6c837df636941599332b25407f94",
            "filename": "src/node_perf.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 39,
            "changes": 59,
            "blob_url": "https://github.com/nodejs/node/blob/22ee5d920970bcbd3103b986be9b8f68394a5361/src%2Fnode_perf.cc",
            "raw_url": "https://github.com/nodejs/node/raw/22ee5d920970bcbd3103b986be9b8f68394a5361/src%2Fnode_perf.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_perf.cc?ref=22ee5d920970bcbd3103b986be9b8f68394a5361",
            "patch": "@@ -317,49 +317,30 @@ void TimerFunctionCall(const FunctionCallbackInfo<Value>& args) {\n   size_t idx;\n   SlicedArguments call_args(args);\n   Utf8Value name(isolate, GetName(fn));\n+  bool is_construct_call = args.IsConstructCall();\n \n-  uint64_t start;\n-  uint64_t end;\n-  v8::TryCatch try_catch(isolate);\n-  if (args.IsConstructCall()) {\n-    start = PERFORMANCE_NOW();\n-    TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0(\n-        TRACING_CATEGORY_NODE2(perf, timerify),\n-        *name, *name, start / 1000);\n-    v8::MaybeLocal<Object> ret = fn->NewInstance(context,\n-                                                 call_args.size(),\n-                                                 call_args.data());\n-    end = PERFORMANCE_NOW();\n-    TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TIMESTAMP0(\n-        TRACING_CATEGORY_NODE2(perf, timerify),\n-        *name, *name, end / 1000);\n-\n-    if (ret.IsEmpty()) {\n-      try_catch.ReThrow();\n-      return;\n-    }\n-    args.GetReturnValue().Set(ret.ToLocalChecked());\n+  uint64_t start = PERFORMANCE_NOW();\n+  TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0(\n+      TRACING_CATEGORY_NODE2(perf, timerify),\n+      *name, *name, start / 1000);\n+  v8::MaybeLocal<Value> ret;\n+\n+  if (is_construct_call) {\n+    ret = fn->NewInstance(context, call_args.size(), call_args.data())\n+        .FromMaybe(Local<Object>());\n   } else {\n-    start = PERFORMANCE_NOW();\n-    TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0(\n-        TRACING_CATEGORY_NODE2(perf, timerify),\n-        *name, *name, start / 1000);\n-    v8::MaybeLocal<Value> ret = fn->Call(context,\n-                                         args.This(),\n-                                         call_args.size(),\n-                                         call_args.data());\n-    end = PERFORMANCE_NOW();\n-    TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TIMESTAMP0(\n-        TRACING_CATEGORY_NODE2(perf, timerify),\n-        *name, *name, end / 1000);\n-\n-    if (ret.IsEmpty()) {\n-      try_catch.ReThrow();\n-      return;\n-    }\n-    args.GetReturnValue().Set(ret.ToLocalChecked());\n+    ret = fn->Call(context, args.This(), call_args.size(), call_args.data());\n   }\n \n+  uint64_t end = PERFORMANCE_NOW();\n+  TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TIMESTAMP0(\n+      TRACING_CATEGORY_NODE2(perf, timerify),\n+      *name, *name, end / 1000);\n+\n+  if (ret.IsEmpty())\n+    return;\n+  args.GetReturnValue().Set(ret.ToLocalChecked());\n+\n   AliasedBuffer<uint32_t, v8::Uint32Array>& observers =\n       env->performance_state()->observers;\n   if (!observers[NODE_PERFORMANCE_ENTRY_TYPE_FUNCTION])"
        }
    ],
    "stats": {
        "total": 59,
        "additions": 20,
        "deletions": 39
    }
}