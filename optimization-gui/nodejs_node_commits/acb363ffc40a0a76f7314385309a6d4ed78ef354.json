{
    "author": "uttampawar",
    "message": "src: memory management using smart pointer\n\nIntroduced use of smart pointers instead of MallocedBuffer to manage\nmemory allocated in the cares library.\n\nPR-URL: https://github.com/nodejs/node/pull/23628\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>",
    "sha": "acb363ffc40a0a76f7314385309a6d4ed78ef354",
    "files": [
        {
            "sha": "d9f6485edfb5078187f97ef9a6ff8a4c04598041",
            "filename": "src/cares_wrap.cc",
            "status": "modified",
            "additions": 54,
            "deletions": 55,
            "changes": 109,
            "blob_url": "https://github.com/nodejs/node/blob/acb363ffc40a0a76f7314385309a6d4ed78ef354/src%2Fcares_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/acb363ffc40a0a76f7314385309a6d4ed78ef354/src%2Fcares_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fcares_wrap.cc?ref=acb363ffc40a0a76f7314385309a6d4ed78ef354",
            "patch": "@@ -1061,118 +1061,117 @@ int ParseSoaReply(Environment* env,\n   EscapableHandleScope handle_scope(env->isolate());\n   auto context = env->context();\n \n-  /* Can't use ares_parse_soa_reply() here which can only parse single record */\n-  unsigned int ancount = cares_get_16bit(buf + 6);\n+  // Manage memory using standardard smart pointer std::unique_tr\n+  struct AresDeleter {\n+    void operator()(char* ptr) const noexcept { ares_free_string(ptr); }\n+  };\n+  using ares_unique_ptr = std::unique_ptr<char[], AresDeleter>;\n+\n+  // Can't use ares_parse_soa_reply() here which can only parse single record\n+  const unsigned int ancount = cares_get_16bit(buf + 6);\n   unsigned char* ptr = buf + NS_HFIXEDSZ;\n-  char* name;\n-  char* rr_name;\n+  char* name_temp;\n   long temp_len;  // NOLINT(runtime/int)\n-  int status = ares_expand_name(ptr, buf, len, &name, &temp_len);\n+  int status = ares_expand_name(ptr, buf, len, &name_temp, &temp_len);\n+  const ares_unique_ptr name(name_temp);\n   if (status != ARES_SUCCESS) {\n-    /* returns EBADRESP in case of invalid input */\n+    // returns EBADRESP in case of invalid input\n     return status == ARES_EBADNAME ? ARES_EBADRESP : status;\n   }\n \n   if (ptr + temp_len + NS_QFIXEDSZ > buf + len) {\n-    free(name);\n     return ARES_EBADRESP;\n   }\n   ptr += temp_len + NS_QFIXEDSZ;\n \n   for (unsigned int i = 0; i < ancount; i++) {\n-    status = ares_expand_name(ptr, buf, len, &rr_name, &temp_len);\n+    char* rr_name_temp;\n+    long rr_temp_len;  // NOLINT(runtime/int)\n+    int status2 = ares_expand_name(ptr, buf, len, &rr_name_temp, &rr_temp_len);\n+    const ares_unique_ptr rr_name(rr_name_temp);\n \n-    if (status != ARES_SUCCESS)\n-      break;\n+    if (status2 != ARES_SUCCESS)\n+      return status2 == ARES_EBADNAME ? ARES_EBADRESP : status2;\n \n-    ptr += temp_len;\n+    ptr += rr_temp_len;\n     if (ptr + NS_RRFIXEDSZ > buf + len) {\n-      free(rr_name);\n-      status = ARES_EBADRESP;\n-      break;\n+      return ARES_EBADRESP;\n     }\n \n     const int rr_type = cares_get_16bit(ptr);\n     const int rr_len = cares_get_16bit(ptr + 8);\n     ptr += NS_RRFIXEDSZ;\n \n-    /* only need SOA */\n+    // only need SOA\n     if (rr_type == ns_t_soa) {\n-      ares_soa_reply soa;\n-\n-      status = ares_expand_name(ptr, buf, len, &soa.nsname, &temp_len);\n-      if (status != ARES_SUCCESS) {\n-        free(rr_name);\n-        break;\n+      char* nsname_temp;\n+      long nsname_temp_len;  // NOLINT(runtime/int)\n+\n+      int status3 = ares_expand_name(ptr, buf, len,\n+                                     &nsname_temp,\n+                                     &nsname_temp_len);\n+      const ares_unique_ptr nsname(nsname_temp);\n+      if (status3 != ARES_SUCCESS) {\n+        return status3 == ARES_EBADNAME ? ARES_EBADRESP : status3;\n       }\n-      ptr += temp_len;\n-\n-      status = ares_expand_name(ptr, buf, len, &soa.hostmaster, &temp_len);\n-      if (status != ARES_SUCCESS) {\n-        free(rr_name);\n-        free(soa.nsname);\n-        break;\n+      ptr += nsname_temp_len;\n+\n+      char* hostmaster_temp;\n+      long hostmaster_temp_len;  // NOLINT(runtime/int)\n+      int status4 = ares_expand_name(ptr, buf, len,\n+                                     &hostmaster_temp,\n+                                     &hostmaster_temp_len);\n+      const ares_unique_ptr hostmaster(hostmaster_temp);\n+      if (status4 != ARES_SUCCESS) {\n+        return status4 == ARES_EBADNAME ? ARES_EBADRESP : status4;\n       }\n-      ptr += temp_len;\n+      ptr += hostmaster_temp_len;\n \n       if (ptr + 5 * 4 > buf + len) {\n-        free(rr_name);\n-        free(soa.nsname);\n-        free(soa.hostmaster);\n-        status = ARES_EBADRESP;\n-        break;\n+        return ARES_EBADRESP;\n       }\n \n-      soa.serial = cares_get_32bit(ptr + 0 * 4);\n-      soa.refresh = cares_get_32bit(ptr + 1 * 4);\n-      soa.retry = cares_get_32bit(ptr + 2 * 4);\n-      soa.expire = cares_get_32bit(ptr + 3 * 4);\n-      soa.minttl = cares_get_32bit(ptr + 4 * 4);\n+      const unsigned int serial = cares_get_32bit(ptr + 0 * 4);\n+      const unsigned int refresh = cares_get_32bit(ptr + 1 * 4);\n+      const unsigned int retry = cares_get_32bit(ptr + 2 * 4);\n+      const unsigned int expire = cares_get_32bit(ptr + 3 * 4);\n+      const unsigned int minttl = cares_get_32bit(ptr + 4 * 4);\n \n       Local<Object> soa_record = Object::New(env->isolate());\n       soa_record->Set(context,\n                       env->nsname_string(),\n-                      OneByteString(env->isolate(), soa.nsname)).FromJust();\n+                      OneByteString(env->isolate(), nsname.get())).FromJust();\n       soa_record->Set(context,\n                       env->hostmaster_string(),\n                       OneByteString(env->isolate(),\n-                                    soa.hostmaster)).FromJust();\n+                                    hostmaster.get())).FromJust();\n       soa_record->Set(context,\n                       env->serial_string(),\n-                      Integer::New(env->isolate(), soa.serial)).FromJust();\n+                      Integer::New(env->isolate(), serial)).FromJust();\n       soa_record->Set(context,\n                       env->refresh_string(),\n-                      Integer::New(env->isolate(), soa.refresh)).FromJust();\n+                      Integer::New(env->isolate(), refresh)).FromJust();\n       soa_record->Set(context,\n                       env->retry_string(),\n-                      Integer::New(env->isolate(), soa.retry)).FromJust();\n+                      Integer::New(env->isolate(), retry)).FromJust();\n       soa_record->Set(context,\n                       env->expire_string(),\n-                      Integer::New(env->isolate(), soa.expire)).FromJust();\n+                      Integer::New(env->isolate(), expire)).FromJust();\n       soa_record->Set(context,\n                       env->minttl_string(),\n-                      Integer::New(env->isolate(), soa.minttl)).FromJust();\n+                      Integer::New(env->isolate(), minttl)).FromJust();\n       soa_record->Set(context,\n                       env->type_string(),\n                       env->dns_soa_string()).FromJust();\n \n-      free(soa.nsname);\n-      free(soa.hostmaster);\n \n       *ret = handle_scope.Escape(soa_record);\n       break;\n     }\n \n-    free(rr_name);\n     ptr += rr_len;\n   }\n \n-  free(name);\n-\n-  if (status != ARES_SUCCESS) {\n-    return status == ARES_EBADNAME ? ARES_EBADRESP : status;\n-  }\n-\n   return ARES_SUCCESS;\n }\n "
        }
    ],
    "stats": {
        "total": 109,
        "additions": 54,
        "deletions": 55
    }
}