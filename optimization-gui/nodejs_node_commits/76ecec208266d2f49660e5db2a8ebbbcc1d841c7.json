{
    "author": "addaleax",
    "message": "buffer: fix crash for invalid index types\n\n2555cb4a4049dc4c41d8a2f4ce50909cc0a12a4a introduced a crash\nwhen a non-number value was passed to `ParseArrayIndex()`.\n\nWe do not always have JS typechecking for that in place, though.\nThis returns back to the previous behavior of coercing values\nto integers, which is certainly questionable.\n\nRefs: https://github.com/nodejs/node/pull/22129\nFixes: https://github.com/nodejs/node/issues/23668\n\nPR-URL: https://github.com/nodejs/node/pull/25154\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "76ecec208266d2f49660e5db2a8ebbbcc1d841c7",
    "files": [
        {
            "sha": "b46b458831dd5b8a045c917bd8b5fce7920d1b5c",
            "filename": "src/node_buffer.cc",
            "status": "modified",
            "additions": 34,
            "deletions": 25,
            "changes": 59,
            "blob_url": "https://github.com/nodejs/node/blob/76ecec208266d2f49660e5db2a8ebbbcc1d841c7/src%2Fnode_buffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/76ecec208266d2f49660e5db2a8ebbbcc1d841c7/src%2Fnode_buffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_buffer.cc?ref=76ecec208266d2f49660e5db2a8ebbbcc1d841c7",
            "patch": "@@ -40,17 +40,18 @@\n \n #define THROW_AND_RETURN_IF_OOB(r)                                          \\\n   do {                                                                      \\\n-    if (!(r))                                                               \\\n+    if ((r).IsNothing()) return;                                            \\\n+    if (!(r).FromJust())                                                    \\\n       return node::THROW_ERR_OUT_OF_RANGE(env, \"Index out of range\");       \\\n   } while (0)                                                               \\\n \n-#define SLICE_START_END(start_arg, end_arg, end_max)                        \\\n+#define SLICE_START_END(env, start_arg, end_arg, end_max)                   \\\n   size_t start;                                                             \\\n   size_t end;                                                               \\\n-  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(start_arg, 0, &start));           \\\n-  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(end_arg, end_max, &end));         \\\n+  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, start_arg, 0, &start));      \\\n+  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, end_arg, end_max, &end));    \\\n   if (end < start) end = start;                                             \\\n-  THROW_AND_RETURN_IF_OOB(end <= end_max);                                  \\\n+  THROW_AND_RETURN_IF_OOB(Just(end <= end_max));                            \\\n   size_t length = end - start;\n \n namespace node {\n@@ -75,9 +76,11 @@ using v8::EscapableHandleScope;\n using v8::FunctionCallbackInfo;\n using v8::Integer;\n using v8::Isolate;\n+using v8::Just;\n using v8::Local;\n using v8::Maybe;\n using v8::MaybeLocal;\n+using v8::Nothing;\n using v8::Object;\n using v8::String;\n using v8::Uint32;\n@@ -160,29 +163,32 @@ void CallbackInfo::WeakCallback(Isolate* isolate) {\n }\n \n \n-// Parse index for external array data.\n-inline MUST_USE_RESULT bool ParseArrayIndex(Local<Value> arg,\n-                                            size_t def,\n-                                            size_t* ret) {\n+// Parse index for external array data. An empty Maybe indicates\n+// a pending exception. `false` indicates that the index is out-of-bounds.\n+inline MUST_USE_RESULT Maybe<bool> ParseArrayIndex(Environment* env,\n+                                                   Local<Value> arg,\n+                                                   size_t def,\n+                                                   size_t* ret) {\n   if (arg->IsUndefined()) {\n     *ret = def;\n-    return true;\n+    return Just(true);\n   }\n \n-  CHECK(arg->IsNumber());\n-  int64_t tmp_i = arg.As<Integer>()->Value();\n+  int64_t tmp_i;\n+  if (!arg->IntegerValue(env->context()).To(&tmp_i))\n+    return Nothing<bool>();\n \n   if (tmp_i < 0)\n-    return false;\n+    return Just(false);\n \n   // Check that the result fits in a size_t.\n   const uint64_t kSizeMax = static_cast<uint64_t>(static_cast<size_t>(-1));\n   // coverity[pointless_expression]\n   if (static_cast<uint64_t>(tmp_i) > kSizeMax)\n-    return false;\n+    return Just(false);\n \n   *ret = static_cast<size_t>(tmp_i);\n-  return true;\n+  return Just(true);\n }\n \n }  // anonymous namespace\n@@ -467,7 +473,7 @@ void StringSlice(const FunctionCallbackInfo<Value>& args) {\n   if (ts_obj_length == 0)\n     return args.GetReturnValue().SetEmptyString();\n \n-  SLICE_START_END(args[0], args[1], ts_obj_length)\n+  SLICE_START_END(env, args[0], args[1], ts_obj_length)\n \n   Local<Value> error;\n   MaybeLocal<Value> ret =\n@@ -500,9 +506,10 @@ void Copy(const FunctionCallbackInfo<Value> &args) {\n   size_t source_start;\n   size_t source_end;\n \n-  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(args[2], 0, &target_start));\n-  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(args[3], 0, &source_start));\n-  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(args[4], ts_obj_length, &source_end));\n+  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start));\n+  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start));\n+  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], ts_obj_length,\n+                                          &source_end));\n \n   // Copy 0 bytes; we're done\n   if (target_start >= target_length || source_start >= source_end)\n@@ -633,13 +640,13 @@ void StringWrite(const FunctionCallbackInfo<Value>& args) {\n   size_t offset;\n   size_t max_length;\n \n-  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(args[1], 0, &offset));\n+  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], 0, &offset));\n   if (offset > ts_obj_length) {\n     return node::THROW_ERR_BUFFER_OUT_OF_BOUNDS(\n         env, \"\\\"offset\\\" is outside of buffer bounds\");\n   }\n \n-  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(args[2], ts_obj_length - offset,\n+  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], ts_obj_length - offset,\n                                           &max_length));\n \n   max_length = MIN(ts_obj_length - offset, max_length);\n@@ -694,10 +701,12 @@ void CompareOffset(const FunctionCallbackInfo<Value> &args) {\n   size_t source_end;\n   size_t target_end;\n \n-  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(args[2], 0, &target_start));\n-  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(args[3], 0, &source_start));\n-  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(args[4], target_length, &target_end));\n-  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(args[5], ts_obj_length, &source_end));\n+  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start));\n+  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start));\n+  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], target_length,\n+                                          &target_end));\n+  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[5], ts_obj_length,\n+                                          &source_end));\n \n   if (source_start > ts_obj_length)\n     return THROW_ERR_OUT_OF_RANGE("
        },
        {
            "sha": "82b71a1dd818e8fab5fd7f3554b03af5c2c7884f",
            "filename": "test/parallel/test-buffer-copy.js",
            "status": "modified",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/76ecec208266d2f49660e5db2a8ebbbcc1d841c7/test%2Fparallel%2Ftest-buffer-copy.js",
            "raw_url": "https://github.com/nodejs/node/raw/76ecec208266d2f49660e5db2a8ebbbcc1d841c7/test%2Fparallel%2Ftest-buffer-copy.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-copy.js?ref=76ecec208266d2f49660e5db2a8ebbbcc1d841c7",
            "patch": "@@ -25,6 +25,17 @@ let cntr = 0;\n   }\n }\n \n+{\n+  // Current behavior is to coerce values to integers.\n+  b.fill(++cntr);\n+  c.fill(++cntr);\n+  const copied = b.copy(c, '0', '0', '512');\n+  assert.strictEqual(copied, 512);\n+  for (let i = 0; i < c.length; i++) {\n+    assert.strictEqual(c[i], b[i]);\n+  }\n+}\n+\n {\n   // copy c into b, without specifying sourceEnd\n   b.fill(++cntr);\n@@ -152,3 +163,18 @@ assert.strictEqual(b.copy(c, 512, 0, 10), 0);\n     assert.strictEqual(c[i], e[i]);\n   }\n }\n+\n+// https://github.com/nodejs/node/issues/23668: Do not crash for invalid input.\n+c.fill('c');\n+b.copy(c, 'not a valid offset');\n+// Make sure this acted like a regular copy with `0` offset.\n+assert.deepStrictEqual(c, b.slice(0, c.length));\n+\n+{\n+  c.fill('C');\n+  assert.throws(() => {\n+    b.copy(c, { [Symbol.toPrimitive]() { throw new Error('foo'); } });\n+  }, /foo/);\n+  // No copying took place:\n+  assert.deepStrictEqual(c.toString(), 'C'.repeat(c.length));\n+}"
        }
    ],
    "stats": {
        "total": 85,
        "additions": 60,
        "deletions": 25
    }
}