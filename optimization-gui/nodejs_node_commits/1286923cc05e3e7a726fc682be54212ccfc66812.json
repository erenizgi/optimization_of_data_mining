{
    "author": "unknown",
    "message": "n-api: implement wrapping using private properties\n\nPR-URL: https://github.com/nodejs/node/pull/18311\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>\nFixes: https://github.com/nodejs/node/issues/14367",
    "sha": "1286923cc05e3e7a726fc682be54212ccfc66812",
    "files": [
        {
            "sha": "2ce7069f47f72eab68b00795c1be4d16e05e05b1",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/1286923cc05e3e7a726fc682be54212ccfc66812/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/1286923cc05e3e7a726fc682be54212ccfc66812/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=1286923cc05e3e7a726fc682be54212ccfc66812",
            "patch": "@@ -91,6 +91,8 @@ class ModuleWrap;\n   V(decorated_private_symbol, \"node:decorated\")                               \\\n   V(npn_buffer_private_symbol, \"node:npnBuffer\")                              \\\n   V(selected_npn_buffer_private_symbol, \"node:selectedNpnBuffer\")             \\\n+  V(napi_env, \"node:napi:env\")                                                \\\n+  V(napi_wrapper, \"node:napi:wrapper\")                                        \\\n \n // Strings are per-isolate primitives but Environment proxies them\n // for the sake of convenience.  Strings should be ASCII-only."
        },
        {
            "sha": "78841d14882eebf39a5a9f46bc887b36e665e3a6",
            "filename": "src/node_api.cc",
            "status": "modified",
            "additions": 50,
            "deletions": 110,
            "changes": 160,
            "blob_url": "https://github.com/nodejs/node/blob/1286923cc05e3e7a726fc682be54212ccfc66812/src%2Fnode_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1286923cc05e3e7a726fc682be54212ccfc66812/src%2Fnode_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api.cc?ref=1286923cc05e3e7a726fc682be54212ccfc66812",
            "patch": "@@ -17,6 +17,7 @@\n #include <vector>\n #include \"node_api.h\"\n #include \"node_internals.h\"\n+#include \"env.h\"\n \n static\n napi_status napi_set_last_error(napi_env env, napi_status error_code,\n@@ -46,6 +47,9 @@ struct napi_env__ {\n   uv_loop_t* loop = nullptr;\n };\n \n+#define NAPI_PRIVATE_KEY(context, suffix) \\\n+  (node::Environment::GetCurrent((context))->napi_ ## suffix())\n+\n #define ENV_OBJECT_TEMPLATE(env, prefix, destination, field_count) \\\n   do {                                                             \\\n     if ((env)->prefix ## _template.IsEmpty()) {                    \\\n@@ -373,6 +377,10 @@ class Reference : private Finalizer {\n   }\n \n  public:\n+  void* Data() {\n+    return _finalize_data;\n+  }\n+\n   static Reference* New(napi_env env,\n                         v8::Local<v8::Value> value,\n                         uint32_t initial_refcount,\n@@ -732,45 +740,6 @@ v8::Local<v8::Object> CreateAccessorCallbackData(napi_env env,\n   return cbdata;\n }\n \n-int kWrapperFields = 3;\n-\n-// Pointer used to identify items wrapped by N-API. Used by FindWrapper and\n-// napi_wrap().\n-const char napi_wrap_name[] = \"N-API Wrapper\";\n-\n-// Search the object's prototype chain for the wrapper object. Usually the\n-// wrapper would be the first in the chain, but it is OK for other objects to\n-// be inserted in the prototype chain.\n-static\n-bool FindWrapper(v8::Local<v8::Object> obj,\n-                 v8::Local<v8::Object>* result = nullptr,\n-                 v8::Local<v8::Object>* parent = nullptr) {\n-  v8::Local<v8::Object> wrapper = obj;\n-\n-  do {\n-    v8::Local<v8::Value> proto = wrapper->GetPrototype();\n-    if (proto.IsEmpty() || !proto->IsObject()) {\n-      return false;\n-    }\n-    if (parent != nullptr) {\n-      *parent = wrapper;\n-    }\n-    wrapper = proto.As<v8::Object>();\n-    if (wrapper->InternalFieldCount() == kWrapperFields) {\n-      v8::Local<v8::Value> external = wrapper->GetInternalField(1);\n-      if (external->IsExternal() &&\n-          external.As<v8::External>()->Value() == v8impl::napi_wrap_name) {\n-        break;\n-      }\n-    }\n-  } while (true);\n-\n-  if (result != nullptr) {\n-    *result = wrapper;\n-  }\n-  return true;\n-}\n-\n static void DeleteEnv(napi_env env, void* data, void* hint) {\n   delete env;\n }\n@@ -787,11 +756,8 @@ napi_env GetEnv(v8::Local<v8::Context> context) {\n   // because we need to stop hard if either of them is empty.\n   //\n   // Re https://github.com/nodejs/node/pull/14217#discussion_r128775149\n-  auto key = v8::Private::ForApi(isolate,\n-      v8::String::NewFromOneByte(isolate,\n-          reinterpret_cast<const uint8_t*>(\"N-API Environment\"),\n-          v8::NewStringType::kInternalized).ToLocalChecked());\n-  auto value = global->GetPrivate(context, key).ToLocalChecked();\n+  auto value = global->GetPrivate(context, NAPI_PRIVATE_KEY(context, env))\n+      .ToLocalChecked();\n \n   if (value->IsExternal()) {\n     result = static_cast<napi_env>(value.As<v8::External>()->Value());\n@@ -801,7 +767,8 @@ napi_env GetEnv(v8::Local<v8::Context> context) {\n \n     // We must also stop hard if the result of assigning the env to the global\n     // is either nothing or false.\n-    CHECK(global->SetPrivate(context, key, external).FromJust());\n+    CHECK(global->SetPrivate(context, NAPI_PRIVATE_KEY(context, env), external)\n+        .FromJust());\n \n     // Create a self-destructing reference to external that will get rid of the\n     // napi_env when external goes out of scope.\n@@ -811,28 +778,46 @@ napi_env GetEnv(v8::Local<v8::Context> context) {\n   return result;\n }\n \n+enum UnwrapAction {\n+  KeepWrap,\n+  RemoveWrap\n+};\n+\n static\n napi_status Unwrap(napi_env env,\n                    napi_value js_object,\n                    void** result,\n-                   v8::Local<v8::Object>* wrapper,\n-                   v8::Local<v8::Object>* parent = nullptr) {\n+                   UnwrapAction action) {\n+  NAPI_PREAMBLE(env);\n   CHECK_ARG(env, js_object);\n-  CHECK_ARG(env, result);\n+  if (action == KeepWrap) {\n+    CHECK_ARG(env, result);\n+  }\n+\n+  v8::Isolate* isolate = env->isolate;\n+  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n \n   v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);\n   RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);\n   v8::Local<v8::Object> obj = value.As<v8::Object>();\n \n-  RETURN_STATUS_IF_FALSE(\n-    env, v8impl::FindWrapper(obj, wrapper, parent), napi_invalid_arg);\n+  auto val = obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, wrapper))\n+      .ToLocalChecked();\n+  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);\n+  Reference* reference =\n+      static_cast<v8impl::Reference*>(val.As<v8::External>()->Value());\n \n-  v8::Local<v8::Value> unwrappedValue = (*wrapper)->GetInternalField(0);\n-  RETURN_STATUS_IF_FALSE(env, unwrappedValue->IsExternal(), napi_invalid_arg);\n+  if (result) {\n+    *result = reference->Data();\n+  }\n \n-  *result = unwrappedValue.As<v8::External>()->Value();\n+  if (action == RemoveWrap) {\n+    CHECK(obj->DeletePrivate(context, NAPI_PRIVATE_KEY(context, wrapper))\n+        .FromJust());\n+    Reference::Delete(reference);\n+  }\n \n-  return napi_ok;\n+  return GET_RETURN_STATUS(env);\n }\n \n static\n@@ -2391,26 +2376,9 @@ napi_status napi_wrap(napi_env env,\n   v8::Local<v8::Object> obj = value.As<v8::Object>();\n \n   // If we've already wrapped this object, we error out.\n-  RETURN_STATUS_IF_FALSE(env, !v8impl::FindWrapper(obj), napi_invalid_arg);\n-\n-  // Create a wrapper object with an internal field to hold the wrapped pointer\n-  // and a second internal field to identify the owner as N-API.\n-  v8::Local<v8::ObjectTemplate> wrapper_template;\n-  ENV_OBJECT_TEMPLATE(env, wrap, wrapper_template, v8impl::kWrapperFields);\n-\n-  auto maybe_object = wrapper_template->NewInstance(context);\n-  CHECK_MAYBE_EMPTY(env, maybe_object, napi_generic_failure);\n-  v8::Local<v8::Object> wrapper = maybe_object.ToLocalChecked();\n-\n-  // Store the pointer as an external in the wrapper.\n-  wrapper->SetInternalField(0, v8::External::New(isolate, native_object));\n-  wrapper->SetInternalField(1, v8::External::New(isolate,\n-    reinterpret_cast<void*>(const_cast<char*>(v8impl::napi_wrap_name))));\n-\n-  // Insert the wrapper into the object's prototype chain.\n-  v8::Local<v8::Value> proto = obj->GetPrototype();\n-  CHECK(wrapper->SetPrototype(context, proto).FromJust());\n-  CHECK(obj->SetPrototype(context, wrapper).FromJust());\n+  RETURN_STATUS_IF_FALSE(env,\n+      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),\n+      napi_invalid_arg);\n \n   v8impl::Reference* reference = nullptr;\n   if (result != nullptr) {\n@@ -2422,52 +2390,24 @@ napi_status napi_wrap(napi_env env,\n     reference = v8impl::Reference::New(\n         env, obj, 0, false, finalize_cb, native_object, finalize_hint);\n     *result = reinterpret_cast<napi_ref>(reference);\n-  } else if (finalize_cb != nullptr) {\n-    // Create a self-deleting reference just for the finalize callback.\n-    reference = v8impl::Reference::New(\n-        env, obj, 0, true, finalize_cb, native_object, finalize_hint);\n+  } else {\n+    // Create a self-deleting reference.\n+    reference = v8impl::Reference::New(env, obj, 0, true, finalize_cb,\n+        native_object, finalize_cb == nullptr ? nullptr : finalize_hint);\n   }\n \n-  if (reference != nullptr) {\n-    wrapper->SetInternalField(2, v8::External::New(isolate, reference));\n-  }\n+  CHECK(obj->SetPrivate(context, NAPI_PRIVATE_KEY(context, wrapper),\n+        v8::External::New(isolate, reference)).FromJust());\n \n   return GET_RETURN_STATUS(env);\n }\n \n napi_status napi_unwrap(napi_env env, napi_value obj, void** result) {\n-  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw\n-  // JS exceptions.\n-  CHECK_ENV(env);\n-  v8::Local<v8::Object> wrapper;\n-  return napi_set_last_error(env, v8impl::Unwrap(env, obj, result, &wrapper));\n+  return v8impl::Unwrap(env, obj, result, v8impl::KeepWrap);\n }\n \n napi_status napi_remove_wrap(napi_env env, napi_value obj, void** result) {\n-  NAPI_PREAMBLE(env);\n-  v8::Local<v8::Object> wrapper;\n-  v8::Local<v8::Object> parent;\n-  napi_status status = v8impl::Unwrap(env, obj, result, &wrapper, &parent);\n-  if (status != napi_ok) {\n-    return napi_set_last_error(env, status);\n-  }\n-\n-  v8::Local<v8::Value> external = wrapper->GetInternalField(2);\n-  if (external->IsExternal()) {\n-    v8impl::Reference::Delete(\n-        static_cast<v8impl::Reference*>(external.As<v8::External>()->Value()));\n-  }\n-\n-  if (!parent.IsEmpty()) {\n-    v8::Maybe<bool> maybe = parent->SetPrototype(\n-        env->isolate->GetCurrentContext(), wrapper->GetPrototype());\n-    CHECK_MAYBE_NOTHING(env, maybe, napi_generic_failure);\n-    if (!maybe.FromMaybe(false)) {\n-      return napi_set_last_error(env, napi_generic_failure);\n-    }\n-  }\n-\n-  return GET_RETURN_STATUS(env);\n+  return v8impl::Unwrap(env, obj, result, v8impl::RemoveWrap);\n }\n \n napi_status napi_create_external(napi_env env,"
        }
    ],
    "stats": {
        "total": 162,
        "additions": 52,
        "deletions": 110
    }
}