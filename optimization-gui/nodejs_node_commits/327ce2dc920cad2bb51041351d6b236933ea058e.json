{
    "author": "unknown",
    "message": "inspector: code cleanup\n\nRemove some unused code from the WS server implementation and switch to\nsmart pointers where possible.\n\nPR-URL: https://github.com/nodejs/node/pull/21070\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>",
    "sha": "327ce2dc920cad2bb51041351d6b236933ea058e",
    "files": [
        {
            "sha": "615fc975922fd9935764ec98b08bc49bf72c478b",
            "filename": "src/inspector_io.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 19,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/327ce2dc920cad2bb51041351d6b236933ea058e/src%2Finspector_io.cc",
            "raw_url": "https://github.com/nodejs/node/raw/327ce2dc920cad2bb51041351d6b236933ea058e/src%2Finspector_io.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_io.cc?ref=327ce2dc920cad2bb51041351d6b236933ea058e",
            "patch": "@@ -109,8 +109,12 @@ class IoSessionDelegate : public InspectorSessionDelegate {\n // mostly session start, message received, and session end.\n class InspectorIoDelegate: public node::inspector::SocketServerDelegate {\n  public:\n-  InspectorIoDelegate(InspectorIo* io, const std::string& script_path,\n+  InspectorIoDelegate(InspectorIo* io, const std::string& target_id,\n+                      const std::string& script_path,\n                       const std::string& script_name, bool wait);\n+  ~InspectorIoDelegate() {\n+    io_->ServerDone();\n+  }\n   // Calls PostIncomingMessage() with appropriate InspectorAction:\n   //   kStartSession\n   void StartSession(int session_id, const std::string& target_id) override;\n@@ -122,11 +126,8 @@ class InspectorIoDelegate: public node::inspector::SocketServerDelegate {\n   std::vector<std::string> GetTargetIds() override;\n   std::string GetTargetTitle(const std::string& id) override;\n   std::string GetTargetUrl(const std::string& id) override;\n-  void ServerDone() override {\n-    io_->ServerDone();\n-  }\n \n-  void AssignTransport(InspectorSocketServer* server) {\n+  void AssignServer(InspectorSocketServer* server) override {\n     server_ = server;\n   }\n \n@@ -163,11 +164,11 @@ class DispatchMessagesTask : public v8::Task {\n InspectorIo::InspectorIo(Environment* env, v8::Platform* platform,\n                          const std::string& path, const DebugOptions& options,\n                          bool wait_for_connect)\n-                         : options_(options), thread_(), delegate_(nullptr),\n-                           state_(State::kNew), parent_env_(env),\n-                           thread_req_(), platform_(platform),\n+                         : options_(options), thread_(), state_(State::kNew),\n+                           parent_env_(env), thread_req_(), platform_(platform),\n                            dispatching_messages_(false), script_name_(path),\n-                           wait_for_connect_(wait_for_connect), port_(-1) {\n+                           wait_for_connect_(wait_for_connect), port_(-1),\n+                           id_(GenerateID()) {\n   main_thread_req_ = new AsyncAndAgent({uv_async_t(), env->inspector_agent()});\n   CHECK_EQ(0, uv_async_init(env->event_loop(), &main_thread_req_->first,\n                             InspectorIo::MainThreadReqAsyncCb));\n@@ -244,7 +245,7 @@ void InspectorIo::IoThreadAsyncCb(uv_async_t* async) {\n       transport->TerminateConnections();\n       // Fallthrough\n     case TransportAction::kStop:\n-      transport->Stop(nullptr);\n+      transport->Stop();\n       break;\n     case TransportAction::kSendMessage:\n       transport->Send(session_id,\n@@ -271,11 +272,11 @@ void InspectorIo::ThreadMain() {\n   err = uv_async_init(&loop, &thread_req_, IoThreadAsyncCb<Transport>);\n   CHECK_EQ(err, 0);\n   std::string script_path = ScriptPath(&loop, script_name_);\n-  InspectorIoDelegate delegate(this, script_path, script_name_,\n-                               wait_for_connect_);\n-  delegate_ = &delegate;\n-  Transport server(&delegate, &loop, options_.host_name(), options_.port());\n-  delegate.AssignTransport(&server);\n+  auto delegate = std::unique_ptr<InspectorIoDelegate>(\n+      new InspectorIoDelegate(this, id_, script_path, script_name_,\n+                              wait_for_connect_));\n+  Transport server(std::move(delegate), &loop, options_.host_name(),\n+                   options_.port());\n   TransportAndIo<Transport> queue_transport(&server, this);\n   thread_req_.data = &queue_transport;\n   if (!server.Start()) {\n@@ -291,8 +292,6 @@ void InspectorIo::ThreadMain() {\n   uv_run(&loop, UV_RUN_DEFAULT);\n   thread_req_.data = nullptr;\n   CHECK_EQ(uv_loop_close(&loop), 0);\n-  delegate.AssignTransport(nullptr);\n-  delegate_ = nullptr;\n }\n \n template <typename ActionType>\n@@ -328,7 +327,7 @@ void InspectorIo::PostIncomingMessage(InspectorAction action, int session_id,\n }\n \n std::vector<std::string> InspectorIo::GetTargetIds() const {\n-  return delegate_ ? delegate_->GetTargetIds() : std::vector<std::string>();\n+  return { id_ };\n }\n \n TransportAction InspectorIo::Attach(int session_id) {\n@@ -416,14 +415,15 @@ bool InspectorIo::WaitForFrontendEvent() {\n }\n \n InspectorIoDelegate::InspectorIoDelegate(InspectorIo* io,\n+                                         const std::string& target_id,\n                                          const std::string& script_path,\n                                          const std::string& script_name,\n                                          bool wait)\n                                          : io_(io),\n                                            session_id_(0),\n                                            script_name_(script_name),\n                                            script_path_(script_path),\n-                                           target_id_(GenerateID()),\n+                                           target_id_(target_id),\n                                            waiting_(wait),\n                                            server_(nullptr) { }\n "
        },
        {
            "sha": "9d27fc557b7b259e8d1fa3c3b70fe8317f4ac4e4",
            "filename": "src/inspector_io.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/327ce2dc920cad2bb51041351d6b236933ea058e/src%2Finspector_io.h",
            "raw_url": "https://github.com/nodejs/node/raw/327ce2dc920cad2bb51041351d6b236933ea058e/src%2Finspector_io.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_io.h?ref=327ce2dc920cad2bb51041351d6b236933ea058e",
            "patch": "@@ -134,7 +134,6 @@ class InspectorIo {\n   // and receive a connection if wait_for_connect was requested.\n   uv_sem_t thread_start_sem_;\n \n-  InspectorIoDelegate* delegate_;\n   State state_;\n   node::Environment* parent_env_;\n \n@@ -161,6 +160,8 @@ class InspectorIo {\n   const bool wait_for_connect_;\n   int port_;\n   std::unordered_map<int, std::unique_ptr<InspectorSession>> sessions_;\n+  // May be accessed from any thread\n+  const std::string id_;\n \n   friend class DispatchMessagesTask;\n   friend class IoSessionDelegate;"
        },
        {
            "sha": "dc36359b5c927c0bcd44063730f68e6de42b2366",
            "filename": "src/inspector_socket.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 13,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/327ce2dc920cad2bb51041351d6b236933ea058e/src%2Finspector_socket.cc",
            "raw_url": "https://github.com/nodejs/node/raw/327ce2dc920cad2bb51041351d6b236933ea058e/src%2Finspector_socket.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_socket.cc?ref=327ce2dc920cad2bb51041351d6b236933ea058e",
            "patch": "@@ -22,7 +22,8 @@ namespace inspector {\n \n class TcpHolder {\n  public:\n-  using Pointer = std::unique_ptr<TcpHolder, void(*)(TcpHolder*)>;\n+  static void DisconnectAndDispose(TcpHolder* holder);\n+  using Pointer = DeleteFnPtr<TcpHolder, DisconnectAndDispose>;\n \n   static Pointer Accept(uv_stream_t* server,\n                         InspectorSocket::DelegatePointer delegate);\n@@ -41,7 +42,6 @@ class TcpHolder {\n   static void OnClosed(uv_handle_t* handle);\n   static void OnDataReceivedCb(uv_stream_t* stream, ssize_t nread,\n                                const uv_buf_t* buf);\n-  static void DisconnectAndDispose(TcpHolder* holder);\n   explicit TcpHolder(InspectorSocket::DelegatePointer delegate);\n   ~TcpHolder() = default;\n   void ReclaimUvBuf(const uv_buf_t* buf, ssize_t read);\n@@ -68,14 +68,10 @@ class ProtocolHandler {\n   InspectorSocket* inspector() {\n     return inspector_;\n   }\n-\n-  static void Shutdown(ProtocolHandler* handler) {\n-    handler->Shutdown();\n-  }\n+  virtual void Shutdown() = 0;\n \n  protected:\n   virtual ~ProtocolHandler() = default;\n-  virtual void Shutdown() = 0;\n   int WriteRaw(const std::vector<char>& buffer, uv_write_cb write_cb);\n   InspectorSocket::Delegate* delegate();\n \n@@ -653,10 +649,10 @@ TcpHolder::Pointer TcpHolder::Accept(\n     err = uv_read_start(tcp, allocate_buffer, OnDataReceivedCb);\n   }\n   if (err == 0) {\n-    return { result, DisconnectAndDispose };\n+    return TcpHolder::Pointer(result);\n   } else {\n     delete result;\n-    return { nullptr, nullptr };\n+    return nullptr;\n   }\n }\n \n@@ -721,12 +717,13 @@ void TcpHolder::ReclaimUvBuf(const uv_buf_t* buf, ssize_t read) {\n   delete[] buf->base;\n }\n \n-// Public interface\n-InspectorSocket::InspectorSocket()\n-    : protocol_handler_(nullptr, ProtocolHandler::Shutdown) { }\n-\n InspectorSocket::~InspectorSocket() = default;\n \n+// static\n+void InspectorSocket::Shutdown(ProtocolHandler* handler) {\n+  handler->Shutdown();\n+}\n+\n // static\n InspectorSocket::Pointer InspectorSocket::Accept(uv_stream_t* server,\n                                                  DelegatePointer delegate) {"
        },
        {
            "sha": "ae49d78ff3452ad610732f9974418a73f0bd1c45",
            "filename": "src/inspector_socket.h",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/327ce2dc920cad2bb51041351d6b236933ea058e/src%2Finspector_socket.h",
            "raw_url": "https://github.com/nodejs/node/raw/327ce2dc920cad2bb51041351d6b236933ea058e/src%2Finspector_socket.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_socket.h?ref=327ce2dc920cad2bb51041351d6b236933ea058e",
            "patch": "@@ -40,9 +40,10 @@ class InspectorSocket {\n   std::string GetHost();\n \n  private:\n-  InspectorSocket();\n+  static void Shutdown(ProtocolHandler*);\n+  InspectorSocket() = default;\n \n-  std::unique_ptr<ProtocolHandler, void(*)(ProtocolHandler*)> protocol_handler_;\n+  DeleteFnPtr<ProtocolHandler, Shutdown> protocol_handler_;\n \n   DISALLOW_COPY_AND_ASSIGN(InspectorSocket);\n };"
        },
        {
            "sha": "d5eb1b75c81ae0ba95b6f488f910b1290feea301",
            "filename": "src/inspector_socket_server.cc",
            "status": "modified",
            "additions": 34,
            "deletions": 112,
            "changes": 146,
            "blob_url": "https://github.com/nodejs/node/blob/327ce2dc920cad2bb51041351d6b236933ea058e/src%2Finspector_socket_server.cc",
            "raw_url": "https://github.com/nodejs/node/raw/327ce2dc920cad2bb51041351d6b236933ea058e/src%2Finspector_socket_server.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_socket_server.cc?ref=327ce2dc920cad2bb51041351d6b236933ea058e",
            "patch": "@@ -156,43 +156,6 @@ std::string FormatWsAddress(const std::string& host, int port,\n   return FormatAddress(FormatHostPort(host, port), target_id, include_protocol);\n }\n \n-class Closer {\n- public:\n-  explicit Closer(InspectorSocketServer* server) : server_(server),\n-                                                   close_count_(0) { }\n-\n-  void AddCallback(InspectorSocketServer::ServerCallback callback) {\n-    if (callback == nullptr)\n-      return;\n-    callbacks_.insert(callback);\n-  }\n-\n-  void DecreaseExpectedCount() {\n-    --close_count_;\n-    NotifyIfDone();\n-  }\n-\n-  void IncreaseExpectedCount() {\n-    ++close_count_;\n-  }\n-\n-  void NotifyIfDone() {\n-    if (close_count_ == 0) {\n-      for (auto callback : callbacks_) {\n-        callback(server_);\n-      }\n-      InspectorSocketServer* server = server_;\n-      delete server->closer_;\n-      server->closer_ = nullptr;\n-    }\n-  }\n-\n- private:\n-  InspectorSocketServer* server_;\n-  std::set<InspectorSocketServer::ServerCallback> callbacks_;\n-  int close_count_;\n-};\n-\n class SocketSession {\n  public:\n   SocketSession(InspectorSocketServer* server, int id, int server_port);\n@@ -250,45 +213,38 @@ class SocketSession {\n \n class ServerSocket {\n  public:\n-  static int Listen(InspectorSocketServer* inspector_server,\n-                    sockaddr* addr, uv_loop_t* loop);\n+  explicit ServerSocket(InspectorSocketServer* server)\n+                        : tcp_socket_(uv_tcp_t()), server_(server) {}\n+  int Listen(sockaddr* addr, uv_loop_t* loop);\n   void Close() {\n-    uv_close(reinterpret_cast<uv_handle_t*>(&tcp_socket_),\n-             SocketClosedCallback);\n+    uv_close(reinterpret_cast<uv_handle_t*>(&tcp_socket_), FreeOnCloseCallback);\n   }\n   int port() const { return port_; }\n \n  private:\n-  explicit ServerSocket(InspectorSocketServer* server)\n-      : tcp_socket_(uv_tcp_t()), server_(server), port_(-1) {}\n   template <typename UvHandle>\n   static ServerSocket* FromTcpSocket(UvHandle* socket) {\n     return node::ContainerOf(&ServerSocket::tcp_socket_,\n                              reinterpret_cast<uv_tcp_t*>(socket));\n   }\n   static void SocketConnectedCallback(uv_stream_t* tcp_socket, int status);\n-  static void SocketClosedCallback(uv_handle_t* tcp_socket);\n   static void FreeOnCloseCallback(uv_handle_t* tcp_socket_) {\n     delete FromTcpSocket(tcp_socket_);\n   }\n   int DetectPort();\n+  ~ServerSocket() = default;\n \n   uv_tcp_t tcp_socket_;\n   InspectorSocketServer* server_;\n-  int port_;\n+  int port_ = -1;\n };\n \n-InspectorSocketServer::InspectorSocketServer(SocketServerDelegate* delegate,\n-                                             uv_loop_t* loop,\n-                                             const std::string& host,\n-                                             int port,\n-                                             FILE* out) : loop_(loop),\n-                                                          delegate_(delegate),\n-                                                          host_(host),\n-                                                          port_(port),\n-                                                          closer_(nullptr),\n-                                                          next_session_id_(0),\n-                                                          out_(out) {\n+InspectorSocketServer::InspectorSocketServer(\n+    std::unique_ptr<SocketServerDelegate> delegate, uv_loop_t* loop,\n+    const std::string& host, int port, FILE* out)\n+    : loop_(loop), delegate_(std::move(delegate)), host_(host), port_(port),\n+      next_session_id_(0), out_(out) {\n+  delegate_->AssignServer(this);\n   state_ = ServerState::kNew;\n }\n \n@@ -328,7 +284,7 @@ void InspectorSocketServer::SessionTerminated(int session_id) {\n                                 delegate_->GetTargetIds(), out_);\n     }\n     if (state_ == ServerState::kStopped) {\n-      delegate_->ServerDone();\n+      delegate_.reset();\n     }\n   }\n }\n@@ -389,7 +345,11 @@ void InspectorSocketServer::SendListResponse(InspectorSocket* socket,\n }\n \n bool InspectorSocketServer::Start() {\n+  CHECK_NE(delegate_, nullptr);\n   CHECK_EQ(state_, ServerState::kNew);\n+  std::unique_ptr<SocketServerDelegate> delegate_holder;\n+  // We will return it if startup is successful\n+  delegate_.swap(delegate_holder);\n   struct addrinfo hints;\n   memset(&hints, 0, sizeof(hints));\n   hints.ai_flags = AI_NUMERICSERV;\n@@ -407,13 +367,13 @@ bool InspectorSocketServer::Start() {\n   }\n   for (addrinfo* address = req.addrinfo; address != nullptr;\n        address = address->ai_next) {\n-    err = ServerSocket::Listen(this, address->ai_addr, loop_);\n+    auto server_socket = ServerSocketPtr(new ServerSocket(this));\n+    err = server_socket->Listen(address->ai_addr, loop_);\n+    if (err == 0)\n+      server_sockets_.push_back(std::move(server_socket));\n   }\n   uv_freeaddrinfo(req.addrinfo);\n \n-  if (!connected_sessions_.empty()) {\n-    return true;\n-  }\n   // We only show error if we failed to start server on all addresses. We only\n   // show one error, for the last address.\n   if (server_sockets_.empty()) {\n@@ -424,24 +384,20 @@ bool InspectorSocketServer::Start() {\n     }\n     return false;\n   }\n+  delegate_.swap(delegate_holder);\n   state_ = ServerState::kRunning;\n   // getaddrinfo sorts the addresses, so the first port is most relevant.\n   PrintDebuggerReadyMessage(host_, server_sockets_[0]->port(),\n                             delegate_->GetTargetIds(), out_);\n   return true;\n }\n \n-void InspectorSocketServer::Stop(ServerCallback cb) {\n+void InspectorSocketServer::Stop() {\n   CHECK_EQ(state_, ServerState::kRunning);\n-  if (closer_ == nullptr) {\n-    closer_ = new Closer(this);\n-  }\n-  closer_->AddCallback(cb);\n-  closer_->IncreaseExpectedCount();\n-  state_ = ServerState::kStopping;\n-  for (ServerSocket* server_socket : server_sockets_)\n-    server_socket->Close();\n-  closer_->NotifyIfDone();\n+  state_ = ServerState::kStopped;\n+  server_sockets_.clear();\n+  if (done())\n+    delegate_.reset();\n }\n \n void InspectorSocketServer::TerminateConnections() {\n@@ -455,28 +411,6 @@ bool InspectorSocketServer::TargetExists(const std::string& id) {\n   return found != target_ids.end();\n }\n \n-void InspectorSocketServer::ServerSocketListening(ServerSocket* server_socket) {\n-  server_sockets_.push_back(server_socket);\n-}\n-\n-void InspectorSocketServer::ServerSocketClosed(ServerSocket* server_socket) {\n-  CHECK_EQ(state_, ServerState::kStopping);\n-\n-  server_sockets_.erase(std::remove(server_sockets_.begin(),\n-                                    server_sockets_.end(), server_socket),\n-                        server_sockets_.end());\n-  if (!server_sockets_.empty())\n-    return;\n-\n-  if (closer_ != nullptr) {\n-    closer_->DecreaseExpectedCount();\n-  }\n-  if (connected_sessions_.empty()) {\n-    delegate_->ServerDone();\n-  }\n-  state_ = ServerState::kStopped;\n-}\n-\n int InspectorSocketServer::Port() const {\n   if (!server_sockets_.empty()) {\n     return server_sockets_[0]->port();\n@@ -525,6 +459,10 @@ void InspectorSocketServer::Send(int session_id, const std::string& message) {\n   }\n }\n \n+void InspectorSocketServer::CloseServerSocket(ServerSocket* server) {\n+  server->Close();\n+}\n+\n // InspectorSession tracking\n SocketSession::SocketSession(InspectorSocketServer* server, int id,\n                              int server_port)\n@@ -569,11 +507,8 @@ int ServerSocket::DetectPort() {\n   return err;\n }\n \n-// static\n-int ServerSocket::Listen(InspectorSocketServer* inspector_server,\n-                         sockaddr* addr, uv_loop_t* loop) {\n-  ServerSocket* server_socket = new ServerSocket(inspector_server);\n-  uv_tcp_t* server = &server_socket->tcp_socket_;\n+int ServerSocket::Listen(sockaddr* addr, uv_loop_t* loop) {\n+  uv_tcp_t* server = &tcp_socket_;\n   CHECK_EQ(0, uv_tcp_init(loop, server));\n   int err = uv_tcp_bind(server, addr, 0);\n   if (err == 0) {\n@@ -582,12 +517,7 @@ int ServerSocket::Listen(InspectorSocketServer* inspector_server,\n                     ServerSocket::SocketConnectedCallback);\n   }\n   if (err == 0) {\n-    err = server_socket->DetectPort();\n-  }\n-  if (err == 0) {\n-    inspector_server->ServerSocketListening(server_socket);\n-  } else {\n-    uv_close(reinterpret_cast<uv_handle_t*>(server), FreeOnCloseCallback);\n+    err = DetectPort();\n   }\n   return err;\n }\n@@ -601,13 +531,5 @@ void ServerSocket::SocketConnectedCallback(uv_stream_t* tcp_socket,\n     server_socket->server_->Accept(server_socket->port_, tcp_socket);\n   }\n }\n-\n-// static\n-void ServerSocket::SocketClosedCallback(uv_handle_t* tcp_socket) {\n-  ServerSocket* server_socket = ServerSocket::FromTcpSocket(tcp_socket);\n-  server_socket->server_->ServerSocketClosed(server_socket);\n-  delete server_socket;\n-}\n-\n }  // namespace inspector\n }  // namespace node"
        },
        {
            "sha": "b8d98e13a26b62e2f0dbd1d9f27e8638483b623a",
            "filename": "src/inspector_socket_server.h",
            "status": "modified",
            "additions": 13,
            "deletions": 15,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/327ce2dc920cad2bb51041351d6b236933ea058e/src%2Finspector_socket_server.h",
            "raw_url": "https://github.com/nodejs/node/raw/327ce2dc920cad2bb51041351d6b236933ea058e/src%2Finspector_socket_server.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_socket_server.h?ref=327ce2dc920cad2bb51041351d6b236933ea058e",
            "patch": "@@ -16,28 +16,28 @@\n namespace node {\n namespace inspector {\n \n-class Closer;\n+class InspectorSocketServer;\n class SocketSession;\n class ServerSocket;\n \n class SocketServerDelegate {\n  public:\n+  virtual void AssignServer(InspectorSocketServer* server) = 0;\n   virtual void StartSession(int session_id, const std::string& target_id) = 0;\n   virtual void EndSession(int session_id) = 0;\n   virtual void MessageReceived(int session_id, const std::string& message) = 0;\n   virtual std::vector<std::string> GetTargetIds() = 0;\n   virtual std::string GetTargetTitle(const std::string& id) = 0;\n   virtual std::string GetTargetUrl(const std::string& id) = 0;\n-  virtual void ServerDone() = 0;\n+  virtual ~SocketServerDelegate() {}\n };\n \n // HTTP Server, writes messages requested as TransportActions, and responds\n // to HTTP requests and WS upgrades.\n \n class InspectorSocketServer {\n  public:\n-  using ServerCallback = void (*)(InspectorSocketServer*);\n-  InspectorSocketServer(SocketServerDelegate* delegate,\n+  InspectorSocketServer(std::unique_ptr<SocketServerDelegate> delegate,\n                         uv_loop_t* loop,\n                         const std::string& host,\n                         int port,\n@@ -49,7 +49,7 @@ class InspectorSocketServer {\n \n   // Called by the TransportAction sent with InspectorIo::Write():\n   //   kKill and kStop\n-  void Stop(ServerCallback callback);\n+  void Stop();\n   //   kSendMessage\n   void Send(int session_id, const std::string& message);\n   //   kKill\n@@ -58,13 +58,8 @@ class InspectorSocketServer {\n   void AcceptSession(int session_id);\n   //   kDeclineSession\n   void DeclineSession(int session_id);\n-\n   int Port() const;\n \n-  // Server socket lifecycle. There may be multiple sockets\n-  void ServerSocketListening(ServerSocket* server_socket);\n-  void ServerSocketClosed(ServerSocket* server_socket);\n-\n   // Session connection lifecycle\n   void Accept(int server_port, uv_stream_t* server_socket);\n   bool HandleGetRequest(int session_id, const std::string& host,\n@@ -76,27 +71,30 @@ class InspectorSocketServer {\n     delegate_->MessageReceived(session_id, message);\n   }\n   SocketSession* Session(int session_id);\n+  bool done() const {\n+    return server_sockets_.empty() && connected_sessions_.empty();\n+  }\n \n  private:\n+  static void CloseServerSocket(ServerSocket*);\n+  using ServerSocketPtr = DeleteFnPtr<ServerSocket, CloseServerSocket>;\n+\n   void SendListResponse(InspectorSocket* socket, const std::string& host,\n                         SocketSession* session);\n   bool TargetExists(const std::string& id);\n \n   enum class ServerState {kNew, kRunning, kStopping, kStopped};\n   uv_loop_t* loop_;\n-  SocketServerDelegate* const delegate_;\n+  std::unique_ptr<SocketServerDelegate> delegate_;\n   const std::string host_;\n   int port_;\n   std::string path_;\n-  std::vector<ServerSocket*> server_sockets_;\n-  Closer* closer_;\n+  std::vector<ServerSocketPtr> server_sockets_;\n   std::map<int, std::pair<std::string, std::unique_ptr<SocketSession>>>\n       connected_sessions_;\n   int next_session_id_;\n   FILE* out_;\n   ServerState state_;\n-\n-  friend class Closer;\n };\n \n }  // namespace inspector"
        },
        {
            "sha": "60b7eefc5e997febda838b35944fc330e64be328",
            "filename": "test/cctest/test_inspector_socket_server.cc",
            "status": "modified",
            "additions": 148,
            "deletions": 175,
            "changes": 323,
            "blob_url": "https://github.com/nodejs/node/blob/327ce2dc920cad2bb51041351d6b236933ea058e/test%2Fcctest%2Ftest_inspector_socket_server.cc",
            "raw_url": "https://github.com/nodejs/node/raw/327ce2dc920cad2bb51041351d6b236933ea058e/test%2Fcctest%2Ftest_inspector_socket_server.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fcctest%2Ftest_inspector_socket_server.cc?ref=327ce2dc920cad2bb51041351d6b236933ea058e",
            "patch": "@@ -84,78 +84,6 @@ class InspectorSocketServerTest : public ::testing::Test {\n   }\n };\n \n-class TestInspectorServerDelegate : public SocketServerDelegate {\n- public:\n-  TestInspectorServerDelegate() : connected(0), disconnected(0), done(false),\n-                                  targets_({ MAIN_TARGET_ID,\n-                                             UNCONNECTABLE_TARGET_ID }),\n-                                  session_id_(0) {}\n-\n-  void Connect(InspectorSocketServer* server) {\n-    server_ = server;\n-  }\n-\n-  void StartSession(int session_id, const std::string& target_id) override {\n-    buffer_.clear();\n-    CHECK_NE(targets_.end(),\n-             std::find(targets_.begin(), targets_.end(), target_id));\n-    if (target_id == UNCONNECTABLE_TARGET_ID) {\n-      server_->DeclineSession(session_id);\n-      return;\n-    }\n-    connected++;\n-    session_id_ = session_id;\n-    server_->AcceptSession(session_id);\n-  }\n-\n-  void MessageReceived(int session_id, const std::string& message) override {\n-    CHECK_EQ(session_id_, session_id);\n-    buffer_.insert(buffer_.end(), message.begin(), message.end());\n-  }\n-\n-  void EndSession(int session_id) override {\n-    CHECK_EQ(session_id_, session_id);\n-    disconnected++;\n-  }\n-\n-  std::vector<std::string> GetTargetIds() override {\n-    return targets_;\n-  }\n-\n-  std::string GetTargetTitle(const std::string& id) override {\n-    return id + \" Target Title\";\n-  }\n-\n-  std::string GetTargetUrl(const std::string& id) override {\n-    return \"file://\" + id + \"/script.js\";\n-  }\n-\n-  void Expect(const std::string& expects) {\n-    SPIN_WHILE(buffer_.size() < expects.length());\n-    ASSERT_STREQ(std::string(buffer_.data(), expects.length()).c_str(),\n-                 expects.c_str());\n-    buffer_.erase(buffer_.begin(), buffer_.begin() + expects.length());\n-  }\n-\n-  void Write(const std::string& message) {\n-    server_->Send(session_id_, message);\n-  }\n-\n-  void ServerDone() override {\n-    done = true;\n-  }\n-\n-  int connected;\n-  int disconnected;\n-  bool done;\n-\n- private:\n-  const std::vector<std::string> targets_;\n-  InspectorSocketServer* server_;\n-  int session_id_;\n-  std::vector<char> buffer_;\n-};\n-\n class SocketWrapper {\n  public:\n   explicit SocketWrapper(uv_loop_t* loop) : closed_(false),\n@@ -312,76 +240,136 @@ class SocketWrapper {\n \n class ServerHolder {\n  public:\n-  template <typename Delegate>\n-  ServerHolder(Delegate* delegate, uv_loop_t* loop, int port)\n-               : ServerHolder(delegate, loop, HOST, port, nullptr) { }\n+  ServerHolder(bool has_targets, uv_loop_t* loop, int port)\n+               : ServerHolder(has_targets, loop, HOST, port, nullptr) { }\n \n-  template <typename Delegate>\n-  ServerHolder(Delegate* delegate, uv_loop_t* loop, const std::string host,\n-               int port, FILE* out)\n-               : closed(false), paused(false),\n-                 server_(delegate, loop, host, port, out) {\n-    delegate->Connect(&server_);\n-  }\n+  ServerHolder(bool has_targets, uv_loop_t* loop,\n+               const std::string host, int port, FILE* out);\n \n   InspectorSocketServer* operator->() {\n-    return &server_;\n+    return server_.get();\n   }\n \n   int port() {\n-    return server_.Port();\n+    return server_->Port();\n   }\n \n-  static void CloseCallback(InspectorSocketServer* server) {\n-    ServerHolder* holder = node::ContainerOf(&ServerHolder::server_, server);\n-    holder->closed = true;\n+  bool done() {\n+    return server_->done();\n   }\n \n-  static void PausedCallback(InspectorSocketServer* server) {\n-    ServerHolder* holder = node::ContainerOf(&ServerHolder::server_, server);\n-    holder->paused = true;\n+  void Connected() {\n+    connected++;\n+  }\n+\n+  void Disconnected() {\n+    disconnected++;\n+  }\n+\n+  void Done() {\n+    delegate_done = true;\n+  }\n+\n+  void PrepareSession(int id) {\n+    buffer_.clear();\n+    session_id_ = id;\n+  }\n+\n+  void Received(const std::string& message) {\n+    buffer_.insert(buffer_.end(), message.begin(), message.end());\n   }\n \n-  bool closed;\n-  bool paused;\n+  void Write(const std::string& message) {\n+    server_->Send(session_id_, message);\n+  }\n+\n+  void Expect(const std::string& expects) {\n+    SPIN_WHILE(buffer_.size() < expects.length());\n+    ASSERT_STREQ(std::string(buffer_.data(), expects.length()).c_str(),\n+                 expects.c_str());\n+    buffer_.erase(buffer_.begin(), buffer_.begin() + expects.length());\n+  }\n+\n+  int connected = 0;\n+  int disconnected = 0;\n+  bool delegate_done = false;\n \n  private:\n-  InspectorSocketServer server_;\n+  std::unique_ptr<InspectorSocketServer> server_;\n+  std::vector<char> buffer_;\n+  int session_id_;\n };\n \n-class ServerDelegateNoTargets : public SocketServerDelegate {\n+class TestSocketServerDelegate : public SocketServerDelegate {\n  public:\n-  ServerDelegateNoTargets() : server_(nullptr) { }\n-  void Connect(InspectorSocketServer* server) { }\n-  void MessageReceived(int session_id, const std::string& message) override { }\n-  void EndSession(int session_id) override { }\n+  explicit TestSocketServerDelegate(\n+      ServerHolder* server,\n+      const std::vector<std::string>& target_ids)\n+      : harness_(server),\n+        targets_(target_ids),\n+        session_id_(0) {}\n+\n+  ~TestSocketServerDelegate() {\n+    harness_->Done();\n+  }\n+\n+  void AssignServer(InspectorSocketServer* server) override {\n+    server_ = server;\n+  }\n \n   void StartSession(int session_id, const std::string& target_id) override {\n-    server_->DeclineSession(session_id);\n+    session_id_ = session_id;\n+    harness_->PrepareSession(session_id_);\n+    CHECK_NE(targets_.end(),\n+             std::find(targets_.begin(), targets_.end(), target_id));\n+    if (target_id == UNCONNECTABLE_TARGET_ID) {\n+      server_->DeclineSession(session_id);\n+      return;\n+    }\n+    harness_->Connected();\n+    server_->AcceptSession(session_id);\n   }\n \n-  std::vector<std::string> GetTargetIds() override {\n-    return std::vector<std::string>();\n+  void MessageReceived(int session_id, const std::string& message) override {\n+    CHECK_EQ(session_id_, session_id);\n+    harness_->Received(message);\n   }\n \n-  std::string GetTargetTitle(const std::string& id) override {\n-    return \"\";\n+  void EndSession(int session_id) override {\n+    CHECK_EQ(session_id_, session_id);\n+    harness_->Disconnected();\n   }\n \n-  std::string GetTargetUrl(const std::string& id) override {\n-    return \"\";\n+  std::vector<std::string> GetTargetIds() override {\n+    return targets_;\n   }\n \n-  void ServerDone() override {\n-    done = true;\n+  std::string GetTargetTitle(const std::string& id) override {\n+    return id + \" Target Title\";\n   }\n \n-  bool done = false;\n+  std::string GetTargetUrl(const std::string& id) override {\n+    return \"file://\" + id + \"/script.js\";\n+  }\n \n  private:\n+  ServerHolder* harness_;\n+  const std::vector<std::string> targets_;\n   InspectorSocketServer* server_;\n+  int session_id_;\n };\n \n+ServerHolder::ServerHolder(bool has_targets, uv_loop_t* loop,\n+                           const std::string host, int port, FILE* out) {\n+  std::vector<std::string> targets;\n+  if (has_targets)\n+    targets = { MAIN_TARGET_ID, UNCONNECTABLE_TARGET_ID };\n+  std::unique_ptr<TestSocketServerDelegate> delegate(\n+      new TestSocketServerDelegate(this, targets));\n+  server_.reset(\n+      new InspectorSocketServer(std::move(delegate), loop, host, port, out));\n+}\n+\n static void TestHttpRequest(int port, const std::string& path,\n                             const std::string& expected_body) {\n   SocketWrapper socket(&loop);\n@@ -402,8 +390,7 @@ static const std::string WsHandshakeRequest(const std::string& target_id) {\n \n \n TEST_F(InspectorSocketServerTest, InspectorSessions) {\n-  TestInspectorServerDelegate delegate;\n-  ServerHolder server(&delegate, &loop, 0);\n+  ServerHolder server(true, &loop, 0);\n   ASSERT_TRUE(server->Start());\n \n   SocketWrapper well_behaved_socket(&loop);\n@@ -412,18 +399,18 @@ TEST_F(InspectorSocketServerTest, InspectorSessions) {\n   well_behaved_socket.Write(WsHandshakeRequest(MAIN_TARGET_ID));\n   well_behaved_socket.Expect(WS_HANDSHAKE_RESPONSE);\n \n-  EXPECT_EQ(1, delegate.connected);\n+  EXPECT_EQ(1, server.connected);\n \n   well_behaved_socket.Write(\"\\x81\\x84\\x7F\\xC2\\x66\\x31\\x4E\\xF0\\x55\\x05\");\n \n-  delegate.Expect(\"1234\");\n-  delegate.Write(\"5678\");\n+  server.Expect(\"1234\");\n+  server.Write(\"5678\");\n \n   well_behaved_socket.Expect(\"\\x81\\x4\" \"5678\");\n   well_behaved_socket.Write(CLIENT_CLOSE_FRAME);\n   well_behaved_socket.Expect(SERVER_CLOSE_FRAME);\n \n-  EXPECT_EQ(1, delegate.disconnected);\n+  EXPECT_EQ(1, server.disconnected);\n \n   well_behaved_socket.Close();\n \n@@ -433,73 +420,70 @@ TEST_F(InspectorSocketServerTest, InspectorSessions) {\n   declined_target_socket.Write(WsHandshakeRequest(UNCONNECTABLE_TARGET_ID));\n   declined_target_socket.Expect(\"HTTP/1.0 400 Bad Request\");\n   declined_target_socket.ExpectEOF();\n-  EXPECT_EQ(1, delegate.connected);\n-  EXPECT_EQ(1, delegate.disconnected);\n+  EXPECT_EQ(1, server.connected);\n+  EXPECT_EQ(1, server.disconnected);\n \n   // Bogus target - start session callback should not even be invoked\n   SocketWrapper bogus_target_socket(&loop);\n   bogus_target_socket.Connect(HOST, server.port());\n   bogus_target_socket.Write(WsHandshakeRequest(\"bogus_target\"));\n   bogus_target_socket.Expect(\"HTTP/1.0 400 Bad Request\");\n   bogus_target_socket.ExpectEOF();\n-  EXPECT_EQ(1, delegate.connected);\n-  EXPECT_EQ(1, delegate.disconnected);\n+  EXPECT_EQ(1, server.connected);\n+  EXPECT_EQ(1, server.disconnected);\n \n   // Drop connection (no proper close frames)\n   SocketWrapper dropped_connection_socket(&loop);\n   dropped_connection_socket.Connect(HOST, server.port());\n   dropped_connection_socket.Write(WsHandshakeRequest(MAIN_TARGET_ID));\n   dropped_connection_socket.Expect(WS_HANDSHAKE_RESPONSE);\n \n-  EXPECT_EQ(2, delegate.connected);\n+  EXPECT_EQ(2, server.connected);\n \n-  delegate.Write(\"5678\");\n+  server.Write(\"5678\");\n   dropped_connection_socket.Expect(\"\\x81\\x4\" \"5678\");\n \n   dropped_connection_socket.Close();\n-  SPIN_WHILE(delegate.disconnected < 2);\n+  SPIN_WHILE(server.disconnected < 2);\n \n   // Reconnect regular connection\n   SocketWrapper stays_till_termination_socket(&loop);\n   stays_till_termination_socket.Connect(HOST, server.port());\n   stays_till_termination_socket.Write(WsHandshakeRequest(MAIN_TARGET_ID));\n   stays_till_termination_socket.Expect(WS_HANDSHAKE_RESPONSE);\n \n-  SPIN_WHILE(3 != delegate.connected);\n+  SPIN_WHILE(3 != server.connected);\n \n-  delegate.Write(\"5678\");\n+  server.Write(\"5678\");\n   stays_till_termination_socket.Expect(\"\\x81\\x4\" \"5678\");\n \n   stays_till_termination_socket\n       .Write(\"\\x81\\x84\\x7F\\xC2\\x66\\x31\\x4E\\xF0\\x55\\x05\");\n-  delegate.Expect(\"1234\");\n+  server.Expect(\"1234\");\n \n-  server->Stop(ServerHolder::CloseCallback);\n+  server->Stop();\n   server->TerminateConnections();\n \n   stays_till_termination_socket.Write(CLIENT_CLOSE_FRAME);\n   stays_till_termination_socket.Expect(SERVER_CLOSE_FRAME);\n \n-  SPIN_WHILE(3 != delegate.disconnected);\n-\n-  SPIN_WHILE(!server.closed);\n+  SPIN_WHILE(3 != server.disconnected);\n+  SPIN_WHILE(!server.done());\n   stays_till_termination_socket.ExpectEOF();\n }\n \n TEST_F(InspectorSocketServerTest, ServerDoesNothing) {\n-  TestInspectorServerDelegate delegate;\n-  ServerHolder server(&delegate, &loop, 0);\n+  ServerHolder server(true, &loop, 0);\n   ASSERT_TRUE(server->Start());\n-\n-  server->Stop(ServerHolder::CloseCallback);\n+  server->Stop();\n   server->TerminateConnections();\n-  SPIN_WHILE(!server.closed);\n-  ASSERT_TRUE(delegate.done);\n+  SPIN_WHILE(!server.done());\n+  ASSERT_TRUE(server.delegate_done);\n+  SPIN_WHILE(uv_loop_alive(&loop));\n }\n \n TEST_F(InspectorSocketServerTest, ServerWithoutTargets) {\n-  ServerDelegateNoTargets delegate;\n-  ServerHolder server(&delegate, &loop, 0);\n+  ServerHolder server(false, &loop, 0);\n   ASSERT_TRUE(server->Start());\n   TestHttpRequest(server.port(), \"/json/list\", \"[ ]\");\n   TestHttpRequest(server.port(), \"/json\", \"[ ]\");\n@@ -510,89 +494,81 @@ TEST_F(InspectorSocketServerTest, ServerWithoutTargets) {\n   socket.Write(WsHandshakeRequest(UNCONNECTABLE_TARGET_ID));\n   socket.Expect(\"HTTP/1.0 400 Bad Request\");\n   socket.ExpectEOF();\n-  server->Stop(ServerHolder::CloseCallback);\n+  server->Stop();\n   server->TerminateConnections();\n-  SPIN_WHILE(!server.closed);\n+  SPIN_WHILE(!server.done());\n+  SPIN_WHILE(uv_loop_alive(&loop));\n }\n \n TEST_F(InspectorSocketServerTest, ServerCannotStart) {\n-  ServerDelegateNoTargets delegate1, delegate2;\n-  ServerHolder server1(&delegate1, &loop, 0);\n+  ServerHolder server1(false, &loop, 0);\n   ASSERT_TRUE(server1->Start());\n-  ServerHolder server2(&delegate2, &loop, server1.port());\n+  ServerHolder server2(false, &loop, server1.port());\n   ASSERT_FALSE(server2->Start());\n-  server1->Stop(ServerHolder::CloseCallback);\n+  server1->Stop();\n   server1->TerminateConnections();\n-  SPIN_WHILE(!server1.closed);\n-  ASSERT_TRUE(delegate1.done);\n+  SPIN_WHILE(!server1.done());\n+  ASSERT_TRUE(server1.delegate_done);\n+  SPIN_WHILE(uv_loop_alive(&loop));\n }\n \n TEST_F(InspectorSocketServerTest, StoppingServerDoesNotKillConnections) {\n-  ServerDelegateNoTargets delegate;\n-  ServerHolder server(&delegate, &loop, 0);\n+  ServerHolder server(false, &loop, 0);\n   ASSERT_TRUE(server->Start());\n   SocketWrapper socket1(&loop);\n   socket1.Connect(HOST, server.port());\n   socket1.TestHttpRequest(\"/json/list\", \"[ ]\");\n-  server->Stop(ServerHolder::CloseCallback);\n-  SPIN_WHILE(!server.closed);\n+  server->Stop();\n   socket1.TestHttpRequest(\"/json/list\", \"[ ]\");\n   socket1.Close();\n   uv_run(&loop, UV_RUN_DEFAULT);\n-  ASSERT_TRUE(delegate.done);\n+  ASSERT_TRUE(server.delegate_done);\n }\n \n TEST_F(InspectorSocketServerTest, ClosingConnectionReportsDone) {\n-  ServerDelegateNoTargets delegate;\n-  ServerHolder server(&delegate, &loop, 0);\n+  ServerHolder server(false, &loop, 0);\n   ASSERT_TRUE(server->Start());\n   SocketWrapper socket1(&loop);\n   socket1.Connect(HOST, server.port());\n   socket1.TestHttpRequest(\"/json/list\", \"[ ]\");\n-  server->Stop(ServerHolder::CloseCallback);\n-  SPIN_WHILE(!server.closed);\n+  server->Stop();\n   socket1.TestHttpRequest(\"/json/list\", \"[ ]\");\n   socket1.Close();\n   uv_run(&loop, UV_RUN_DEFAULT);\n-  ASSERT_TRUE(delegate.done);\n+  ASSERT_TRUE(server.delegate_done);\n }\n \n TEST_F(InspectorSocketServerTest, ClosingSocketReportsDone) {\n-  TestInspectorServerDelegate delegate;\n-  ServerHolder server(&delegate, &loop, 0);\n+  ServerHolder server(true, &loop, 0);\n   ASSERT_TRUE(server->Start());\n   SocketWrapper socket1(&loop);\n   socket1.Connect(HOST, server.port());\n   socket1.Write(WsHandshakeRequest(MAIN_TARGET_ID));\n   socket1.Expect(WS_HANDSHAKE_RESPONSE);\n-  server->Stop(ServerHolder::CloseCallback);\n-  SPIN_WHILE(!server.closed);\n-  ASSERT_FALSE(delegate.done);\n+  server->Stop();\n+  ASSERT_FALSE(server.delegate_done);\n   socket1.Close();\n-  SPIN_WHILE(!delegate.done);\n+  SPIN_WHILE(!server.delegate_done);\n }\n \n TEST_F(InspectorSocketServerTest, TerminatingSessionReportsDone) {\n-  TestInspectorServerDelegate delegate;\n-  ServerHolder server(&delegate, &loop, 0);\n+  ServerHolder server(true, &loop, 0);\n   ASSERT_TRUE(server->Start());\n   SocketWrapper socket1(&loop);\n   socket1.Connect(HOST, server.port());\n   socket1.Write(WsHandshakeRequest(MAIN_TARGET_ID));\n   socket1.Expect(WS_HANDSHAKE_RESPONSE);\n-  server->Stop(ServerHolder::CloseCallback);\n-  SPIN_WHILE(!server.closed);\n-  ASSERT_FALSE(delegate.done);\n+  server->Stop();\n+  ASSERT_FALSE(server.delegate_done);\n   server->TerminateConnections();\n   socket1.Expect(SERVER_CLOSE_FRAME);\n   socket1.Write(CLIENT_CLOSE_FRAME);\n   socket1.ExpectEOF();\n-  SPIN_WHILE(!delegate.done);\n+  SPIN_WHILE(!server.delegate_done);\n }\n \n TEST_F(InspectorSocketServerTest, FailsToBindToNodejsHost) {\n-  TestInspectorServerDelegate delegate;\n-  ServerHolder server(&delegate, &loop, \"nodejs.org\", 80, nullptr);\n+  ServerHolder server(true, &loop, \"nodejs.org\", 80, nullptr);\n   ASSERT_FALSE(server->Start());\n   SPIN_WHILE(uv_loop_alive(&loop));\n }\n@@ -619,17 +595,14 @@ TEST_F(InspectorSocketServerTest, BindsToIpV6) {\n     fprintf(stderr, \"No IPv6 network detected\\n\");\n     return;\n   }\n-  TestInspectorServerDelegate delegate;\n-  ServerHolder server(&delegate, &loop, \"::\", 0, nullptr);\n+  ServerHolder server(true, &loop, \"::\", 0, nullptr);\n   ASSERT_TRUE(server->Start());\n-\n   SocketWrapper socket1(&loop);\n   socket1.Connect(\"::1\", server.port(), true);\n   socket1.Write(WsHandshakeRequest(MAIN_TARGET_ID));\n   socket1.Expect(WS_HANDSHAKE_RESPONSE);\n-  server->Stop(ServerHolder::CloseCallback);\n-  SPIN_WHILE(!server.closed);\n-  ASSERT_FALSE(delegate.done);\n+  server->Stop();\n+  ASSERT_FALSE(server.delegate_done);\n   socket1.Close();\n-  SPIN_WHILE(!delegate.done);\n+  SPIN_WHILE(!server.delegate_done);\n }"
        }
    ],
    "stats": {
        "total": 566,
        "additions": 229,
        "deletions": 337
    }
}