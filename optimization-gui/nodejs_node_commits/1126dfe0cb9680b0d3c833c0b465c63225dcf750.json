{
    "author": "aks-",
    "message": "lib: merge onread handlers for http2 streams & net.Socket\n\nRefs: https://github.com/nodejs/node/pull/20993\nCo-authored-by: Anna Henningsen <anna@addaleax.net>\n\nPR-URL: https://github.com/nodejs/node/pull/22449\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>",
    "sha": "1126dfe0cb9680b0d3c833c0b465c63225dcf750",
    "files": [
        {
            "sha": "ad4f98593da2703814d17787cf3619d42c86ded4",
            "filename": "lib/internal/http2/core.js",
            "status": "modified",
            "additions": 5,
            "deletions": 33,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/1126dfe0cb9680b0d3c833c0b465c63225dcf750/lib%2Finternal%2Fhttp2%2Fcore.js",
            "raw_url": "https://github.com/nodejs/node/raw/1126dfe0cb9680b0d3c833c0b465c63225dcf750/lib%2Finternal%2Fhttp2%2Fcore.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fhttp2%2Fcore.js?ref=1126dfe0cb9680b0d3c833c0b465c63225dcf750",
            "patch": "@@ -105,7 +105,10 @@ const {\n const {\n   createWriteWrap,\n   writeGeneric,\n-  writevGeneric\n+  writevGeneric,\n+  onStreamRead,\n+  kMaybeDestroy,\n+  kUpdateTimer\n } = require('internal/stream_base_commons');\n const {\n   kTimeout,\n@@ -142,7 +145,6 @@ const kHandle = Symbol('handle');\n const kID = Symbol('id');\n const kInit = Symbol('init');\n const kInfoHeaders = Symbol('sent-info-headers');\n-const kMaybeDestroy = Symbol('maybe-destroy');\n const kLocalSettings = Symbol('local-settings');\n const kOptions = Symbol('options');\n const kOwner = owner_symbol;\n@@ -156,7 +158,6 @@ const kServer = Symbol('server');\n const kSession = Symbol('session');\n const kState = Symbol('state');\n const kType = Symbol('type');\n-const kUpdateTimer = Symbol('update-timer');\n const kWriteGeneric = Symbol('write-generic');\n \n const kDefaultSocketTimeout = 2 * 60 * 1000;\n@@ -374,36 +375,6 @@ function onStreamClose(code) {\n   }\n }\n \n-// Receives a chunk of data for a given stream and forwards it on\n-// to the Http2Stream Duplex for processing.\n-function onStreamRead(nread, buf) {\n-  const stream = this[kOwner];\n-  if (nread >= 0 && !stream.destroyed) {\n-    debug(`Http2Stream ${stream[kID]} [Http2Session ` +\n-          `${sessionName(stream[kSession][kType])}]: receiving data chunk ` +\n-          `of size ${nread}`);\n-    stream[kUpdateTimer]();\n-    if (!stream.push(buf)) {\n-      if (!stream.destroyed)  // we have to check a second time\n-        this.readStop();\n-    }\n-    return;\n-  }\n-\n-  // Last chunk was received. End the readable side.\n-  debug(`Http2Stream ${stream[kID]} [Http2Session ` +\n-        `${sessionName(stream[kSession][kType])}]: ending readable.`);\n-\n-  // defer this until we actually emit end\n-  if (!stream.readable) {\n-    stream[kMaybeDestroy]();\n-  } else {\n-    stream.on('end', stream[kMaybeDestroy]);\n-    stream.push(null);\n-    stream.read(0);\n-  }\n-}\n-\n // Called when the remote peer settings have been updated.\n // Resets the cached settings.\n function onSettings() {\n@@ -2145,6 +2116,7 @@ function afterOpen(session, options, headers, streamOptions, err, fd) {\n class ServerHttp2Stream extends Http2Stream {\n   constructor(session, handle, id, options, headers) {\n     super(session, options);\n+    handle.owner = this;\n     this[kInit](id, handle);\n     this[kProtocol] = headers[HTTP2_HEADER_SCHEME];\n     this[kAuthority] = headers[HTTP2_HEADER_AUTHORITY];"
        },
        {
            "sha": "5c49026e99e3fe4287040c76b35d1e0c768c6328",
            "filename": "lib/internal/stream_base_commons.js",
            "status": "modified",
            "additions": 52,
            "deletions": 3,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/1126dfe0cb9680b0d3c833c0b465c63225dcf750/lib%2Finternal%2Fstream_base_commons.js",
            "raw_url": "https://github.com/nodejs/node/raw/1126dfe0cb9680b0d3c833c0b465c63225dcf750/lib%2Finternal%2Fstream_base_commons.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fstream_base_commons.js?ref=1126dfe0cb9680b0d3c833c0b465c63225dcf750",
            "patch": "@@ -1,11 +1,14 @@\n 'use strict';\n \n const { Buffer } = require('buffer');\n-const errors = require('internal/errors');\n const { internalBinding } = require('internal/bootstrap/loaders');\n const { WriteWrap } = internalBinding('stream_wrap');\n+const { UV_EOF } = internalBinding('uv');\n+const { errnoException } = require('internal/errors');\n+const { owner_symbol } = require('internal/async_hooks').symbols;\n \n-const errnoException = errors.errnoException;\n+const kMaybeDestroy = Symbol('kMaybeDestroy');\n+const kUpdateTimer = Symbol('kUpdateTimer');\n \n function handleWriteReq(req, data, encoding) {\n   const { handle } = req;\n@@ -82,8 +85,54 @@ function afterWriteDispatched(self, req, err, cb) {\n   }\n }\n \n+function onStreamRead(nread, buf) {\n+  const handle = this;\n+  const stream = this[owner_symbol];\n+\n+  stream[kUpdateTimer]();\n+\n+  if (nread > 0 && !stream.destroyed) {\n+    if (!stream.push(buf)) {\n+      handle.reading = false;\n+      if (!stream.destroyed) {\n+        const err = handle.readStop();\n+        if (err)\n+          stream.destroy(errnoException(err, 'read'));\n+      }\n+    }\n+\n+    return;\n+  }\n+\n+  if (nread === 0) {\n+    return;\n+  }\n+\n+  if (nread !== UV_EOF) {\n+    return stream.destroy(errnoException(nread, 'read'));\n+  }\n+\n+  // defer this until we actually emit end\n+  if (stream._readableState.endEmitted) {\n+    if (stream[kMaybeDestroy])\n+      stream[kMaybeDestroy]();\n+  } else {\n+    if (stream[kMaybeDestroy])\n+      stream.on('end', stream[kMaybeDestroy]);\n+\n+    // push a null to signal the end of data.\n+    // Do it before `maybeDestroy` for correct order of events:\n+    // `end` -> `close`\n+    stream.push(null);\n+    stream.read(0);\n+  }\n+}\n+\n module.exports = {\n   createWriteWrap,\n   writevGeneric,\n-  writeGeneric\n+  writeGeneric,\n+  onStreamRead,\n+  kMaybeDestroy,\n+  kUpdateTimer,\n };"
        },
        {
            "sha": "981ee876ba0dbbaf97b8c4f8d0484eb2a58029e1",
            "filename": "lib/net.js",
            "status": "modified",
            "additions": 11,
            "deletions": 59,
            "changes": 70,
            "blob_url": "https://github.com/nodejs/node/blob/1126dfe0cb9680b0d3c833c0b465c63225dcf750/lib%2Fnet.js",
            "raw_url": "https://github.com/nodejs/node/raw/1126dfe0cb9680b0d3c833c0b465c63225dcf750/lib%2Fnet.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fnet.js?ref=1126dfe0cb9680b0d3c833c0b465c63225dcf750",
            "patch": "@@ -37,8 +37,7 @@ const assert = require('assert');\n const { internalBinding } = require('internal/bootstrap/loaders');\n const {\n   UV_EADDRINUSE,\n-  UV_EINVAL,\n-  UV_EOF\n+  UV_EINVAL\n } = internalBinding('uv');\n \n const { Buffer } = require('buffer');\n@@ -62,7 +61,9 @@ const {\n const {\n   createWriteWrap,\n   writevGeneric,\n-  writeGeneric\n+  writeGeneric,\n+  onStreamRead,\n+  kUpdateTimer\n } = require('internal/stream_base_commons');\n const errors = require('internal/errors');\n const {\n@@ -210,7 +211,7 @@ function initSocketHandle(self) {\n   // Handle creation may be deferred to bind() or connect() time.\n   if (self._handle) {\n     self._handle[owner_symbol] = self;\n-    self._handle.onread = onread;\n+    self._handle.onread = onStreamRead;\n     self[async_id_symbol] = getNewAsyncId(self._handle);\n   }\n }\n@@ -516,6 +517,12 @@ Object.defineProperty(Socket.prototype, 'bufferSize', {\n   }\n });\n \n+Object.defineProperty(Socket.prototype, kUpdateTimer, {\n+  get: function() {\n+    return this._unrefTimer;\n+  }\n+});\n+\n \n // Just call handle.readStart until we have enough in the buffer\n Socket.prototype._read = function(n) {\n@@ -617,61 +624,6 @@ Socket.prototype._destroy = function(exception, cb) {\n   }\n };\n \n-\n-// This function is called whenever the handle gets a\n-// buffer, or when there's an error reading.\n-function onread(nread, buffer) {\n-  var handle = this;\n-  var self = handle[owner_symbol];\n-  assert(handle === self._handle, 'handle != self._handle');\n-\n-  self._unrefTimer();\n-\n-  debug('onread', nread);\n-\n-  if (nread > 0) {\n-    debug('got data');\n-\n-    // read success.\n-    // In theory (and in practice) calling readStop right now\n-    // will prevent this from being called again until _read() gets\n-    // called again.\n-\n-    // Optimization: emit the original buffer with end points\n-    var ret = self.push(buffer);\n-\n-    if (handle.reading && !ret) {\n-      handle.reading = false;\n-      debug('readStop');\n-      var err = handle.readStop();\n-      if (err)\n-        self.destroy(errnoException(err, 'read'));\n-    }\n-    return;\n-  }\n-\n-  // if we didn't get any bytes, that doesn't necessarily mean EOF.\n-  // wait for the next one.\n-  if (nread === 0) {\n-    debug('not any data, keep waiting');\n-    return;\n-  }\n-\n-  // Error, possibly EOF.\n-  if (nread !== UV_EOF) {\n-    return self.destroy(errnoException(nread, 'read'));\n-  }\n-\n-  debug('EOF');\n-\n-  // push a null to signal the end of data.\n-  // Do it before `maybeDestroy` for correct order of events:\n-  // `end` -> `close`\n-  self.push(null);\n-  self.read(0);\n-}\n-\n-\n Socket.prototype._getpeername = function() {\n   if (!this._peername) {\n     if (!this._handle || !this._handle.getpeername) {"
        }
    ],
    "stats": {
        "total": 163,
        "additions": 68,
        "deletions": 95
    }
}