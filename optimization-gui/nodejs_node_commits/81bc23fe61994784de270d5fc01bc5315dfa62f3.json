{
    "author": "BridgeAR",
    "message": "util: improve display of iterators and weak entries\n\nThis adds the number of not visible elements when inspecting iterators\nwhile exceeding `maxArrayLength`.\nIt also fixes a edge case with `maxArrayLength` and the map.entries()\niterator. Now the whole entry will be visible instead of only the key\nbut not the value of the first entry.\nBesides that it uses a slighly better algorithm that improves the\nperformance by skipping unnecessary steps.\n\nPR-URL: https://github.com/nodejs/node/pull/20961\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "81bc23fe61994784de270d5fc01bc5315dfa62f3",
    "files": [
        {
            "sha": "a5b2265f58ff1311c9f691480052ec2e4f85f288",
            "filename": "lib/console.js",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/81bc23fe61994784de270d5fc01bc5315dfa62f3/lib%2Fconsole.js",
            "raw_url": "https://github.com/nodejs/node/raw/81bc23fe61994784de270d5fc01bc5315dfa62f3/lib%2Fconsole.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fconsole.js?ref=81bc23fe61994784de270d5fc01bc5315dfa62f3",
            "patch": "@@ -367,8 +367,11 @@ Console.prototype.table = function(tabularData, properties) {\n   const mapIter = isMapIterator(tabularData);\n   let isKeyValue = false;\n   let i = 0;\n-  if (mapIter)\n-    [ tabularData, isKeyValue ] = previewEntries(tabularData);\n+  if (mapIter) {\n+    const res = previewEntries(tabularData, true);\n+    tabularData = res[0];\n+    isKeyValue = res[1];\n+  }\n \n   if (isKeyValue || isMap(tabularData)) {\n     const keys = [];\n@@ -398,7 +401,7 @@ Console.prototype.table = function(tabularData, properties) {\n \n   const setIter = isSetIterator(tabularData);\n   if (setIter)\n-    [ tabularData ] = previewEntries(tabularData);\n+    tabularData = previewEntries(tabularData);\n \n   const setlike = setIter || (mapIter && !isKeyValue) || isSet(tabularData);\n   if (setlike) {"
        },
        {
            "sha": "3c4fdbb128ada53c1e90c6b9c34605567c2ee026",
            "filename": "lib/util.js",
            "status": "modified",
            "additions": 54,
            "deletions": 44,
            "changes": 98,
            "blob_url": "https://github.com/nodejs/node/blob/81bc23fe61994784de270d5fc01bc5315dfa62f3/lib%2Futil.js",
            "raw_url": "https://github.com/nodejs/node/raw/81bc23fe61994784de270d5fc01bc5315dfa62f3/lib%2Futil.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Futil.js?ref=81bc23fe61994784de270d5fc01bc5315dfa62f3",
            "patch": "@@ -118,6 +118,10 @@ const meta = [\n   '', '', '', '', '', '', '', '', '', '',\n   '', '', '', '', '', '', '', '\\\\\\\\'\n ];\n+// Constants to map the iterator state.\n+const kWeak = 0;\n+const kIterator = 1;\n+const kMapEntries = 2;\n \n function addQuotes(str, quotes) {\n   if (quotes === -1) {\n@@ -1017,77 +1021,83 @@ function formatMap(ctx, value, recurseTimes, keys) {\n   return output;\n }\n \n-function formatWeakSet(ctx, value, recurseTimes, keys) {\n+function formatSetIterInner(ctx, value, recurseTimes, keys, entries, state) {\n   const maxArrayLength = Math.max(ctx.maxArrayLength, 0);\n-  const [ entries ] = previewEntries(value).slice(0, maxArrayLength + 1);\n   const maxLength = Math.min(maxArrayLength, entries.length);\n   let output = new Array(maxLength);\n   for (var i = 0; i < maxLength; ++i)\n     output[i] = formatValue(ctx, entries[i], recurseTimes);\n-  // Sort all entries to have a halfway reliable output (if more entries than\n-  // retrieved ones exist, we can not reliably return the same output).\n-  output = output.sort();\n-  if (entries.length > maxArrayLength)\n-    output.push('... more items');\n+  if (state === kWeak) {\n+    // Sort all entries to have a halfway reliable output (if more entries than\n+    // retrieved ones exist, we can not reliably return the same output).\n+    output = output.sort();\n+  }\n+  const remaining = entries.length - maxLength;\n+  if (remaining > 0) {\n+    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n+  }\n   for (i = 0; i < keys.length; i++)\n     output.push(formatProperty(ctx, value, recurseTimes, keys[i], 0));\n   return output;\n }\n \n-function formatWeakMap(ctx, value, recurseTimes, keys) {\n+function formatMapIterInner(ctx, value, recurseTimes, keys, entries, state) {\n   const maxArrayLength = Math.max(ctx.maxArrayLength, 0);\n-  const [ entries ] = previewEntries(value).slice(0, (maxArrayLength + 1) * 2);\n   // Entries exist as [key1, val1, key2, val2, ...]\n-  const remainder = entries.length / 2 > maxArrayLength;\n-  const len = entries.length / 2 - (remainder ? 1 : 0);\n+  const len = entries.length / 2;\n+  const remaining = len - maxArrayLength;\n   const maxLength = Math.min(maxArrayLength, len);\n   let output = new Array(maxLength);\n-  for (var i = 0; i < maxLength; i++) {\n+  let start = '';\n+  let end = '';\n+  let middle = ' => ';\n+  let i = 0;\n+  if (state === kMapEntries) {\n+    start = '[ ';\n+    end = ' ]';\n+    middle = ', ';\n+  }\n+  for (; i < maxLength; i++) {\n     const pos = i * 2;\n-    output[i] = `${formatValue(ctx, entries[pos], recurseTimes)} => ` +\n-      formatValue(ctx, entries[pos + 1], recurseTimes);\n+    output[i] = `${start}${formatValue(ctx, entries[pos], recurseTimes)}` +\n+      `${middle}${formatValue(ctx, entries[pos + 1], recurseTimes)}${end}`;\n+  }\n+  if (state === kWeak) {\n+    // Sort all entries to have a halfway reliable output (if more entries\n+    // than retrieved ones exist, we can not reliably return the same output).\n+    output = output.sort();\n+  }\n+  if (remaining > 0) {\n+    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n   }\n-  // Sort all entries to have a halfway reliable output (if more entries than\n-  // retrieved ones exist, we can not reliably return the same output).\n-  output = output.sort();\n-  if (remainder > 0)\n-    output.push('... more items');\n   for (i = 0; i < keys.length; i++)\n     output.push(formatProperty(ctx, value, recurseTimes, keys[i], 0));\n   return output;\n }\n \n-function zip2(list) {\n-  const ret = Array(list.length / 2);\n-  for (var i = 0; i < ret.length; ++i)\n-    ret[i] = [list[2 * i], list[2 * i + 1]];\n-  return ret;\n+function formatWeakSet(ctx, value, recurseTimes, keys) {\n+  const entries = previewEntries(value);\n+  return formatSetIterInner(ctx, value, recurseTimes, keys, entries, kWeak);\n }\n \n-function formatCollectionIterator(ctx, value, recurseTimes, keys) {\n-  const output = [];\n-  var [ entries, isKeyValue ] = previewEntries(value);\n-  if (isKeyValue)\n-    entries = zip2(entries);\n-  for (const entry of entries) {\n-    if (ctx.maxArrayLength === output.length) {\n-      output.push('... more items');\n-      break;\n-    }\n-    output.push(formatValue(ctx, entry, recurseTimes));\n-  }\n-  for (var n = 0; n < keys.length; n++) {\n-    output.push(formatProperty(ctx, value, recurseTimes, keys[n], 0));\n-  }\n-  return output;\n+function formatWeakMap(ctx, value, recurseTimes, keys) {\n+  const entries = previewEntries(value);\n+  return formatMapIterInner(ctx, value, recurseTimes, keys, entries, kWeak);\n }\n \n-function formatMapIterator(ctx, value, recurseTimes, keys) {\n-  return formatCollectionIterator(ctx, value, recurseTimes, keys);\n+function formatSetIterator(ctx, value, recurseTimes, keys) {\n+  const entries = previewEntries(value);\n+  return formatSetIterInner(ctx, value, recurseTimes, keys, entries, kIterator);\n }\n \n-function formatSetIterator(ctx, value, recurseTimes, keys) {\n-  return formatCollectionIterator(ctx, value, recurseTimes, keys);\n+function formatMapIterator(ctx, value, recurseTimes, keys) {\n+  const [entries, isKeyValue] = previewEntries(value, true);\n+  if (isKeyValue) {\n+    return formatMapIterInner(\n+      ctx, value, recurseTimes, keys, entries, kMapEntries);\n+  }\n+\n+  return formatSetIterInner(ctx, value, recurseTimes, keys, entries, kIterator);\n }\n \n function formatPromise(ctx, value, recurseTimes, keys) {"
        },
        {
            "sha": "41b1307bb4912c1277d4c26f0c9e13b5b890a22d",
            "filename": "src/node_util.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/81bc23fe61994784de270d5fc01bc5315dfa62f3/src%2Fnode_util.cc",
            "raw_url": "https://github.com/nodejs/node/raw/81bc23fe61994784de270d5fc01bc5315dfa62f3/src%2Fnode_util.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_util.cc?ref=81bc23fe61994784de270d5fc01bc5315dfa62f3",
            "patch": "@@ -57,6 +57,9 @@ static void PreviewEntries(const FunctionCallbackInfo<Value>& args) {\n   Local<Array> entries;\n   if (!args[0].As<Object>()->PreviewEntries(&is_key_value).ToLocal(&entries))\n     return;\n+  // Fast path for WeakMap, WeakSet and Set iterators.\n+  if (args.Length() == 1)\n+    return args.GetReturnValue().Set(entries);\n   Local<Array> ret = Array::New(env->isolate(), 2);\n   ret->Set(env->context(), 0, entries).FromJust();\n   ret->Set(env->context(), 1, v8::Boolean::New(env->isolate(), is_key_value))"
        },
        {
            "sha": "c2b26fd5a4c9d8adae77642791a9f49700d42c5a",
            "filename": "test/parallel/test-util-inspect.js",
            "status": "modified",
            "additions": 26,
            "deletions": 23,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/81bc23fe61994784de270d5fc01bc5315dfa62f3/test%2Fparallel%2Ftest-util-inspect.js",
            "raw_url": "https://github.com/nodejs/node/raw/81bc23fe61994784de270d5fc01bc5315dfa62f3/test%2Fparallel%2Ftest-util-inspect.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-util-inspect.js?ref=81bc23fe61994784de270d5fc01bc5315dfa62f3",
            "patch": "@@ -447,13 +447,15 @@ assert.strictEqual(util.inspect(-5e-324), '-5e-324');\n {\n   const map = new Map();\n   map.set(1, 2);\n-  const [ vals ] = previewEntries(map.entries());\n-  const valsOutput = [];\n-  for (const o of vals) {\n-    valsOutput.push(o);\n-  }\n-\n-  assert.strictEqual(util.inspect(valsOutput), '[ 1, 2 ]');\n+  // Passing only a single argument to indicate a set iterator.\n+  const valsSetIterator = previewEntries(map.entries());\n+  // Passing through true to indicate a map iterator.\n+  const valsMapIterEntries = previewEntries(map.entries(), true);\n+  const valsMapIterKeys = previewEntries(map.keys(), true);\n+\n+  assert.strictEqual(util.inspect(valsSetIterator), '[ 1, 2 ]');\n+  assert.strictEqual(util.inspect(valsMapIterEntries), '[ [ 1, 2 ], true ]');\n+  assert.strictEqual(util.inspect(valsMapIterKeys), '[ [ 1 ], false ]');\n }\n \n // Test for other constructors in different context.\n@@ -913,18 +915,19 @@ if (typeof Symbol !== 'undefined') {\n // Test Map iterators.\n {\n   const map = new Map([['foo', 'bar']]);\n-  assert.strictEqual(util.inspect(map.keys()), \"[Map Iterator] { 'foo' }\");\n-  assert.strictEqual(util.inspect(map.values()), \"[Map Iterator] { 'bar' }\");\n-  assert.strictEqual(util.inspect(map.entries()),\n-                     \"[Map Iterator] { [ 'foo', 'bar' ] }\");\n+  assert.strictEqual(util.inspect(map.keys()), '[Map Iterator] { \\'foo\\' }');\n+  assert.strictEqual(util.inspect(map.values()), '[Map Iterator] { \\'bar\\' }');\n+  map.set('A', 'B!');\n+  assert.strictEqual(util.inspect(map.entries(), { maxArrayLength: 1 }),\n+                     \"[Map Iterator] { [ 'foo', 'bar' ], ... 1 more item }\");\n   // Make sure the iterator doesn't get consumed.\n   const keys = map.keys();\n-  assert.strictEqual(util.inspect(keys), \"[Map Iterator] { 'foo' }\");\n-  assert.strictEqual(util.inspect(keys), \"[Map Iterator] { 'foo' }\");\n+  assert.strictEqual(util.inspect(keys), \"[Map Iterator] { 'foo', 'A' }\");\n+  assert.strictEqual(util.inspect(keys), \"[Map Iterator] { 'foo', 'A' }\");\n   keys.extra = true;\n   assert.strictEqual(\n     util.inspect(keys, { maxArrayLength: 0 }),\n-    '[Map Iterator] { ... more items, extra: true }');\n+    '[Map Iterator] { ... 2 more items, extra: true }');\n }\n \n // Test Set iterators.\n@@ -940,7 +943,7 @@ if (typeof Symbol !== 'undefined') {\n   keys.extra = true;\n   assert.strictEqual(\n     util.inspect(keys, { maxArrayLength: 1 }),\n-    '[Set Iterator] { 1, ... more items, extra: true }');\n+    '[Set Iterator] { 1, ... 1 more item, extra: true }');\n }\n \n // Test alignment of items in container.\n@@ -1364,17 +1367,17 @@ util.inspect(process);\n   assert.strictEqual(out, expect);\n \n   out = util.inspect(weakMap, { maxArrayLength: 0, showHidden: true });\n-  expect = 'WeakMap { ... more items }';\n+  expect = 'WeakMap { ... 2 more items }';\n   assert.strictEqual(out, expect);\n \n   weakMap.extra = true;\n   out = util.inspect(weakMap, { maxArrayLength: 1, showHidden: true });\n   // It is not possible to determine the output reliable.\n-  expect = 'WeakMap { [ [length]: 0 ] => {}, ... more items, extra: true }';\n-  const expectAlt = 'WeakMap { {} => [ [length]: 0 ], ... more items, ' +\n+  expect = 'WeakMap { [ [length]: 0 ] => {}, ... 1 more item, extra: true }';\n+  const expectAlt = 'WeakMap { {} => [ [length]: 0 ], ... 1 more item, ' +\n                     'extra: true }';\n   assert(out === expect || out === expectAlt,\n-         `Found \"${out}\" rather than \"${expect}\" or \"${expectAlt}\"`);\n+         `Found: \"${out}\"\\nrather than: \"${expect}\"\\nor: \"${expectAlt}\"`);\n }\n \n { // Test WeakSet\n@@ -1388,17 +1391,17 @@ util.inspect(process);\n   assert.strictEqual(out, expect);\n \n   out = util.inspect(weakSet, { maxArrayLength: -2, showHidden: true });\n-  expect = 'WeakSet { ... more items }';\n+  expect = 'WeakSet { ... 2 more items }';\n   assert.strictEqual(out, expect);\n \n   weakSet.extra = true;\n   out = util.inspect(weakSet, { maxArrayLength: 1, showHidden: true });\n   // It is not possible to determine the output reliable.\n-  expect = 'WeakSet { {}, ... more items, extra: true }';\n-  const expectAlt = 'WeakSet { [ 1, [length]: 1 ], ... more items, ' +\n+  expect = 'WeakSet { {}, ... 1 more item, extra: true }';\n+  const expectAlt = 'WeakSet { [ 1, [length]: 1 ], ... 1 more item, ' +\n                     'extra: true }';\n   assert(out === expect || out === expectAlt,\n-         `Found \"${out}\" rather than \"${expect}\" or \"${expectAlt}\"`);\n+         `Found: \"${out}\"\\nrather than: \"${expect}\"\\nor: \"${expectAlt}\"`);\n }\n \n { // Test argument objects."
        }
    ],
    "stats": {
        "total": 159,
        "additions": 89,
        "deletions": 70
    }
}