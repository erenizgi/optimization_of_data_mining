{
    "author": "joyeecheung",
    "message": "fs: support BigInt in fs.*stat and fs.watchFile\n\nAdd the `bigint: true` option to all the `fs.*stat` methods and\n`fs.watchFile`.\n\nPR-URL: https://github.com/nodejs/node/pull/20220\nFixes: https://github.com/nodejs/node/issues/12115\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>",
    "sha": "1e7645c39ae5213a44267cff3d599264c2211f1a",
    "files": [
        {
            "sha": "f80bb6ac33c649659814567f5d25dc9f8473d667",
            "filename": "lib/fs.js",
            "status": "modified",
            "additions": 34,
            "deletions": 22,
            "changes": 56,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/lib%2Ffs.js",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/lib%2Ffs.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ffs.js?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -248,7 +248,7 @@ function readFileAfterOpen(err, fd) {\n   const req = new FSReqWrap();\n   req.oncomplete = readFileAfterStat;\n   req.context = context;\n-  binding.fstat(fd, req);\n+  binding.fstat(fd, false, req);\n }\n \n function readFileAfterStat(err, stats) {\n@@ -307,7 +307,7 @@ function readFile(path, options, callback) {\n \n function tryStatSync(fd, isUserFd) {\n   const ctx = {};\n-  const stats = binding.fstat(fd, undefined, ctx);\n+  const stats = binding.fstat(fd, false, undefined, ctx);\n   if (ctx.errno !== undefined && !isUserFd) {\n     fs.closeSync(fd);\n     throw errors.uvException(ctx);\n@@ -760,55 +760,67 @@ function readdirSync(path, options) {\n   return result;\n }\n \n-function fstat(fd, callback) {\n+function fstat(fd, options, callback) {\n+  if (arguments.length < 3) {\n+    callback = options;\n+    options = {};\n+  }\n   validateUint32(fd, 'fd');\n-  const req = new FSReqWrap();\n+  const req = new FSReqWrap(options.bigint);\n   req.oncomplete = makeStatsCallback(callback);\n-  binding.fstat(fd, req);\n+  binding.fstat(fd, options.bigint, req);\n }\n \n-function lstat(path, callback) {\n+function lstat(path, options, callback) {\n+  if (arguments.length < 3) {\n+    callback = options;\n+    options = {};\n+  }\n   callback = makeStatsCallback(callback);\n   path = getPathFromURL(path);\n   validatePath(path);\n-  const req = new FSReqWrap();\n+  const req = new FSReqWrap(options.bigint);\n   req.oncomplete = callback;\n-  binding.lstat(pathModule.toNamespacedPath(path), req);\n+  binding.lstat(pathModule.toNamespacedPath(path), options.bigint, req);\n }\n \n-function stat(path, callback) {\n+function stat(path, options, callback) {\n+  if (arguments.length < 3) {\n+    callback = options;\n+    options = {};\n+  }\n   callback = makeStatsCallback(callback);\n   path = getPathFromURL(path);\n   validatePath(path);\n-  const req = new FSReqWrap();\n+  const req = new FSReqWrap(options.bigint);\n   req.oncomplete = callback;\n-  binding.stat(pathModule.toNamespacedPath(path), req);\n+  binding.stat(pathModule.toNamespacedPath(path), options.bigint, req);\n }\n \n-function fstatSync(fd) {\n+function fstatSync(fd, options = {}) {\n   validateUint32(fd, 'fd');\n   const ctx = { fd };\n-  const stats = binding.fstat(fd, undefined, ctx);\n+  const stats = binding.fstat(fd, options.bigint, undefined, ctx);\n   handleErrorFromBinding(ctx);\n   return getStatsFromBinding(stats);\n }\n \n-function lstatSync(path) {\n+function lstatSync(path, options = {}) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   const ctx = { path };\n   const stats = binding.lstat(pathModule.toNamespacedPath(path),\n-                              undefined, ctx);\n+                              options.bigint, undefined, ctx);\n   handleErrorFromBinding(ctx);\n   return getStatsFromBinding(stats);\n }\n \n-function statSync(path) {\n+function statSync(path, options = {}) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   const ctx = { path };\n   const stats = binding.stat(pathModule.toNamespacedPath(path),\n-                             undefined, ctx);\n+                             options.bigint, undefined, ctx);\n   handleErrorFromBinding(ctx);\n   return getStatsFromBinding(stats);\n }\n@@ -1264,7 +1276,7 @@ function watchFile(filename, options, listener) {\n   if (stat === undefined) {\n     if (!watchers)\n       watchers = require('internal/fs/watchers');\n-    stat = new watchers.StatWatcher();\n+    stat = new watchers.StatWatcher(options.bigint);\n     stat.start(filename, options.persistent, options.interval);\n     statWatchers.set(filename, stat);\n   }\n@@ -1379,7 +1391,7 @@ function realpathSync(p, options) {\n   // On windows, check that the root exists. On unix there is no need.\n   if (isWindows && !knownHard[base]) {\n     const ctx = { path: base };\n-    binding.lstat(pathModule.toNamespacedPath(base), undefined, ctx);\n+    binding.lstat(pathModule.toNamespacedPath(base), false, undefined, ctx);\n     handleErrorFromBinding(ctx);\n     knownHard[base] = true;\n   }\n@@ -1421,7 +1433,7 @@ function realpathSync(p, options) {\n \n       const baseLong = pathModule.toNamespacedPath(base);\n       const ctx = { path: base };\n-      const stats = binding.lstat(baseLong, undefined, ctx);\n+      const stats = binding.lstat(baseLong, false, undefined, ctx);\n       handleErrorFromBinding(ctx);\n \n       if (!isFileType(stats, S_IFLNK)) {\n@@ -1444,7 +1456,7 @@ function realpathSync(p, options) {\n       }\n       if (linkTarget === null) {\n         const ctx = { path: base };\n-        binding.stat(baseLong, undefined, ctx);\n+        binding.stat(baseLong, false, undefined, ctx);\n         handleErrorFromBinding(ctx);\n         linkTarget = binding.readlink(baseLong, undefined, undefined, ctx);\n         handleErrorFromBinding(ctx);\n@@ -1465,7 +1477,7 @@ function realpathSync(p, options) {\n     // On windows, check that the root exists. On unix there is no need.\n     if (isWindows && !knownHard[base]) {\n       const ctx = { path: base };\n-      binding.lstat(pathModule.toNamespacedPath(base), undefined, ctx);\n+      binding.lstat(pathModule.toNamespacedPath(base), false, undefined, ctx);\n       handleErrorFromBinding(ctx);\n       knownHard[base] = true;\n     }"
        },
        {
            "sha": "750d0d7579706f91f76fb2954b708035e77abe2e",
            "filename": "lib/internal/fs/promises.js",
            "status": "modified",
            "additions": 9,
            "deletions": 10,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/lib%2Finternal%2Ffs%2Fpromises.js",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/lib%2Finternal%2Ffs%2Fpromises.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Fpromises.js?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -81,8 +81,8 @@ class FileHandle {\n     return readFile(this, options);\n   }\n \n-  stat() {\n-    return fstat(this);\n+  stat(options) {\n+    return fstat(this, options);\n   }\n \n   truncate(len = 0) {\n@@ -106,7 +106,6 @@ class FileHandle {\n   }\n }\n \n-\n function validateFileHandle(handle) {\n   if (!(handle instanceof FileHandle))\n     throw new ERR_INVALID_ARG_TYPE('filehandle', 'FileHandle', handle);\n@@ -127,7 +126,7 @@ async function writeFileHandle(filehandle, data, options) {\n }\n \n async function readFileHandle(filehandle, options) {\n-  const statFields = await binding.fstat(filehandle.fd, kUsePromises);\n+  const statFields = await binding.fstat(filehandle.fd, false, kUsePromises);\n \n   let size;\n   if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) {\n@@ -318,25 +317,25 @@ async function symlink(target, path, type_) {\n                          kUsePromises);\n }\n \n-async function fstat(handle) {\n+async function fstat(handle, options = { bigint: false }) {\n   validateFileHandle(handle);\n-  const result = await binding.fstat(handle.fd, kUsePromises);\n+  const result = await binding.fstat(handle.fd, options.bigint, kUsePromises);\n   return getStatsFromBinding(result);\n }\n \n-async function lstat(path) {\n+async function lstat(path, options = { bigint: false }) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   const result = await binding.lstat(pathModule.toNamespacedPath(path),\n-                                     kUsePromises);\n+                                     options.bigint, kUsePromises);\n   return getStatsFromBinding(result);\n }\n \n-async function stat(path) {\n+async function stat(path, options = { bigint: false }) {\n   path = getPathFromURL(path);\n   validatePath(path);\n   const result = await binding.stat(pathModule.toNamespacedPath(path),\n-                                    kUsePromises);\n+                                    options.bigint, kUsePromises);\n   return getStatsFromBinding(result);\n }\n "
        },
        {
            "sha": "7092bbcb633d81216fed8a7653608fb5772bb1af",
            "filename": "lib/internal/fs/utils.js",
            "status": "modified",
            "additions": 12,
            "deletions": 4,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/lib%2Finternal%2Ffs%2Futils.js",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/lib%2Finternal%2Ffs%2Futils.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Futils.js?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -114,7 +114,7 @@ function preprocessSymlinkDestination(path, type, linkPath) {\n }\n \n function dateFromNumeric(num) {\n-  return new Date(num + 0.5);\n+  return new Date(Number(num) + 0.5);\n }\n \n // Constructor for file stats.\n@@ -155,7 +155,15 @@ function Stats(\n }\n \n Stats.prototype._checkModeProperty = function(property) {\n-  return ((this.mode & S_IFMT) === property);\n+  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n+    property === S_IFSOCK)) {\n+    return false;  // Some types are not available on Windows\n+  }\n+  if (typeof this.mode === 'bigint') {  // eslint-disable-line valid-typeof\n+    // eslint-disable-next-line no-undef\n+    return (this.mode & BigInt(S_IFMT)) === BigInt(property);\n+  }\n+  return (this.mode & S_IFMT) === property;\n };\n \n Stats.prototype.isDirectory = function() {\n@@ -189,9 +197,9 @@ Stats.prototype.isSocket = function() {\n function getStatsFromBinding(stats, offset = 0) {\n   return new Stats(stats[0 + offset], stats[1 + offset], stats[2 + offset],\n                    stats[3 + offset], stats[4 + offset], stats[5 + offset],\n-                   stats[6 + offset] < 0 ? undefined : stats[6 + offset],\n+                   isWindows ? undefined : stats[6 + offset],  // blksize\n                    stats[7 + offset], stats[8 + offset],\n-                   stats[9 + offset] < 0 ? undefined : stats[9 + offset],\n+                   isWindows ? undefined : stats[9 + offset],  // blocks\n                    stats[10 + offset], stats[11 + offset],\n                    stats[12 + offset], stats[13 + offset]);\n }"
        },
        {
            "sha": "5fd6948f28b362ff826e97ae76100d31944e11fe",
            "filename": "lib/internal/fs/watchers.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/lib%2Finternal%2Ffs%2Fwatchers.js",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/lib%2Finternal%2Ffs%2Fwatchers.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Fwatchers.js?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -21,10 +21,10 @@ function emitStop(self) {\n   self.emit('stop');\n }\n \n-function StatWatcher() {\n+function StatWatcher(bigint) {\n   EventEmitter.call(this);\n \n-  this._handle = new _StatWatcher();\n+  this._handle = new _StatWatcher(bigint);\n \n   // uv_fs_poll is a little more powerful than ev_stat but we curb it for\n   // the sake of backwards compatibility"
        },
        {
            "sha": "c84fdf0bb8215b0de8036a3c8935883d9acfa049",
            "filename": "src/env-inl.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fenv-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fenv-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv-inl.h?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -546,6 +546,11 @@ Environment::fs_stats_field_array() {\n   return &fs_stats_field_array_;\n }\n \n+inline AliasedBuffer<uint64_t, v8::BigUint64Array>*\n+Environment::fs_stats_field_bigint_array() {\n+  return &fs_stats_field_bigint_array_;\n+}\n+\n inline std::vector<std::unique_ptr<fs::FileHandleReadWrap>>&\n Environment::file_handle_read_wrap_freelist() {\n   return file_handle_read_wrap_freelist_;"
        },
        {
            "sha": "6f6e9f3920f4b1851624adefba7efee974426695",
            "filename": "src/env.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fenv.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.cc?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -116,6 +116,7 @@ Environment::Environment(IsolateData* isolate_data,\n #endif\n       http_parser_buffer_(nullptr),\n       fs_stats_field_array_(isolate_, kFsStatsFieldsLength * 2),\n+      fs_stats_field_bigint_array_(isolate_, kFsStatsFieldsLength * 2),\n       context_(context->GetIsolate(), context) {\n   // We'll be creating new objects so make sure we've entered the context.\n   v8::HandleScope handle_scope(isolate());"
        },
        {
            "sha": "9ad316c063ea724028fca31e6dc379784ae478fe",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -694,6 +694,8 @@ class Environment {\n   void set_debug_categories(const std::string& cats, bool enabled);\n \n   inline AliasedBuffer<double, v8::Float64Array>* fs_stats_field_array();\n+  inline AliasedBuffer<uint64_t, v8::BigUint64Array>*\n+      fs_stats_field_bigint_array();\n \n   // stat fields contains twice the number of entries because `fs.StatWatcher`\n   // needs room to store data for *two* `fs.Stats` instances.\n@@ -914,6 +916,7 @@ class Environment {\n   bool debug_enabled_[static_cast<int>(DebugCategory::CATEGORY_COUNT)] = {0};\n \n   AliasedBuffer<double, v8::Float64Array> fs_stats_field_array_;\n+  AliasedBuffer<uint64_t, v8::BigUint64Array> fs_stats_field_bigint_array_;\n \n   std::vector<std::unique_ptr<fs::FileHandleReadWrap>>\n       file_handle_read_wrap_freelist_;"
        },
        {
            "sha": "a63e90fafb2926f52c7ccaffe708c01cb29d5af6",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 36,
            "deletions": 23,
            "changes": 59,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -49,6 +49,7 @@ namespace node {\n namespace fs {\n \n using v8::Array;\n+using v8::BigUint64Array;\n using v8::Context;\n using v8::EscapableHandleScope;\n using v8::Float64Array;\n@@ -413,7 +414,7 @@ void FSReqWrap::Reject(Local<Value> reject) {\n }\n \n void FSReqWrap::ResolveStat(const uv_stat_t* stat) {\n-  Resolve(node::FillGlobalStatsArray(env(), stat));\n+  Resolve(node::FillGlobalStatsArray(env(), stat, use_bigint()));\n }\n \n void FSReqWrap::Resolve(Local<Value> value) {\n@@ -433,7 +434,7 @@ void FSReqWrap::SetReturnValue(const FunctionCallbackInfo<Value>& args) {\n void NewFSReqWrap(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args.IsConstructCall());\n   Environment* env = Environment::GetCurrent(args.GetIsolate());\n-  new FSReqWrap(env, args.This());\n+  new FSReqWrap(env, args.This(), args[0]->IsTrue());\n }\n \n FSReqAfterScope::FSReqAfterScope(FSReqBase* wrap, uv_fs_t* req)\n@@ -670,11 +671,16 @@ inline int SyncCall(Environment* env, Local<Value> ctx, FSReqWrapSync* req_wrap,\n   return err;\n }\n \n-inline FSReqBase* GetReqWrap(Environment* env, Local<Value> value) {\n+inline FSReqBase* GetReqWrap(Environment* env, Local<Value> value,\n+                             bool use_bigint = false) {\n   if (value->IsObject()) {\n     return Unwrap<FSReqBase>(value.As<Object>());\n   } else if (value->StrictEquals(env->fs_use_promises_symbol())) {\n-    return new FSReqPromise<double, Float64Array>(env);\n+    if (use_bigint) {\n+      return new FSReqPromise<uint64_t, BigUint64Array>(env, use_bigint);\n+    } else {\n+      return new FSReqPromise<double, Float64Array>(env, use_bigint);\n+    }\n   }\n   return nullptr;\n }\n@@ -825,22 +831,23 @@ static void Stat(const FunctionCallbackInfo<Value>& args) {\n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NOT_NULL(*path);\n \n-  FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n-  if (req_wrap_async != nullptr) {  // stat(path, req)\n+  bool use_bigint = args[1]->IsTrue();\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2], use_bigint);\n+  if (req_wrap_async != nullptr) {  // stat(path, use_bigint, req)\n     AsyncCall(env, req_wrap_async, args, \"stat\", UTF8, AfterStat,\n               uv_fs_stat, *path);\n-  } else {  // stat(path, undefined, ctx)\n-    CHECK_EQ(argc, 3);\n+  } else {  // stat(path, use_bigint, undefined, ctx)\n+    CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n     FS_SYNC_TRACE_BEGIN(stat);\n-    int err = SyncCall(env, args[2], &req_wrap_sync, \"stat\", uv_fs_stat, *path);\n+    int err = SyncCall(env, args[3], &req_wrap_sync, \"stat\", uv_fs_stat, *path);\n     FS_SYNC_TRACE_END(stat);\n     if (err != 0) {\n       return;  // error info is in ctx\n     }\n \n     Local<Value> arr = node::FillGlobalStatsArray(env,\n-        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));\n+        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr), use_bigint);\n     args.GetReturnValue().Set(arr);\n   }\n }\n@@ -849,28 +856,29 @@ static void LStat(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n   const int argc = args.Length();\n-  CHECK_GE(argc, 2);\n+  CHECK_GE(argc, 3);\n \n   BufferValue path(env->isolate(), args[0]);\n   CHECK_NOT_NULL(*path);\n \n-  FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n-  if (req_wrap_async != nullptr) {  // lstat(path, req)\n+  bool use_bigint = args[1]->IsTrue();\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2], use_bigint);\n+  if (req_wrap_async != nullptr) {  // lstat(path, use_bigint, req)\n     AsyncCall(env, req_wrap_async, args, \"lstat\", UTF8, AfterStat,\n               uv_fs_lstat, *path);\n-  } else {  // lstat(path, undefined, ctx)\n-    CHECK_EQ(argc, 3);\n+  } else {  // lstat(path, use_bigint, undefined, ctx)\n+    CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n     FS_SYNC_TRACE_BEGIN(lstat);\n-    int err = SyncCall(env, args[2], &req_wrap_sync, \"lstat\", uv_fs_lstat,\n+    int err = SyncCall(env, args[3], &req_wrap_sync, \"lstat\", uv_fs_lstat,\n                        *path);\n     FS_SYNC_TRACE_END(lstat);\n     if (err != 0) {\n       return;  // error info is in ctx\n     }\n \n     Local<Value> arr = node::FillGlobalStatsArray(env,\n-        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));\n+        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr), use_bigint);\n     args.GetReturnValue().Set(arr);\n   }\n }\n@@ -884,22 +892,23 @@ static void FStat(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args[0]->IsInt32());\n   int fd = args[0].As<Int32>()->Value();\n \n-  FSReqBase* req_wrap_async = GetReqWrap(env, args[1]);\n-  if (req_wrap_async != nullptr) {  // fstat(fd, req)\n+  bool use_bigint = args[1]->IsTrue();\n+  FSReqBase* req_wrap_async = GetReqWrap(env, args[2], use_bigint);\n+  if (req_wrap_async != nullptr) {  // fstat(fd, use_bigint, req)\n     AsyncCall(env, req_wrap_async, args, \"fstat\", UTF8, AfterStat,\n               uv_fs_fstat, fd);\n-  } else {  // fstat(fd, undefined, ctx)\n-    CHECK_EQ(argc, 3);\n+  } else {  // fstat(fd, use_bigint, undefined, ctx)\n+    CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n     FS_SYNC_TRACE_BEGIN(fstat);\n-    int err = SyncCall(env, args[2], &req_wrap_sync, \"fstat\", uv_fs_fstat, fd);\n+    int err = SyncCall(env, args[3], &req_wrap_sync, \"fstat\", uv_fs_fstat, fd);\n     FS_SYNC_TRACE_END(fstat);\n     if (err != 0) {\n       return;  // error info is in ctx\n     }\n \n     Local<Value> arr = node::FillGlobalStatsArray(env,\n-        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));\n+        static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr), use_bigint);\n     args.GetReturnValue().Set(arr);\n   }\n }\n@@ -1911,6 +1920,10 @@ void Initialize(Local<Object> target,\n               FIXED_ONE_BYTE_STRING(env->isolate(), \"statValues\"),\n               env->fs_stats_field_array()->GetJSArray()).FromJust();\n \n+  target->Set(context,\n+              FIXED_ONE_BYTE_STRING(env->isolate(), \"bigintStatValues\"),\n+              env->fs_stats_field_bigint_array()->GetJSArray()).FromJust();\n+\n   StatWatcher::Initialize(env, target);\n \n   // Create FunctionTemplate for FSReqWrap"
        },
        {
            "sha": "a14a1b0f85e108b9cbeb52a73d4e4275cc17320a",
            "filename": "src/node_file.h",
            "status": "modified",
            "additions": 11,
            "deletions": 8,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fnode_file.h",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fnode_file.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.h?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -26,8 +26,9 @@ class FSReqBase : public ReqWrap<uv_fs_t> {\n  public:\n   typedef MaybeStackBuffer<char, 64> FSReqBuffer;\n \n-  FSReqBase(Environment* env, Local<Object> req, AsyncWrap::ProviderType type)\n-      : ReqWrap(env, req, type) {\n+  FSReqBase(Environment* env, Local<Object> req, AsyncWrap::ProviderType type,\n+            bool use_bigint)\n+      : ReqWrap(env, req, type), use_bigint_(use_bigint) {\n   }\n \n   void Init(const char* syscall,\n@@ -66,11 +67,13 @@ class FSReqBase : public ReqWrap<uv_fs_t> {\n   enum encoding encoding() const { return encoding_; }\n \n   size_t self_size() const override { return sizeof(*this); }\n+  bool use_bigint() const { return use_bigint_; }\n \n  private:\n   enum encoding encoding_ = UTF8;\n   bool has_data_ = false;\n   const char* syscall_ = nullptr;\n+  bool use_bigint_ = false;\n \n   // Typically, the content of buffer_ is something like a file name, so\n   // something around 64 bytes should be enough.\n@@ -81,8 +84,8 @@ class FSReqBase : public ReqWrap<uv_fs_t> {\n \n class FSReqWrap : public FSReqBase {\n  public:\n-  FSReqWrap(Environment* env, Local<Object> req)\n-      : FSReqBase(env, req, AsyncWrap::PROVIDER_FSREQWRAP) { }\n+  FSReqWrap(Environment* env, Local<Object> req, bool use_bigint)\n+      : FSReqBase(env, req, AsyncWrap::PROVIDER_FSREQWRAP, use_bigint) { }\n \n   void Reject(Local<Value> reject) override;\n   void Resolve(Local<Value> value) override;\n@@ -96,11 +99,12 @@ class FSReqWrap : public FSReqBase {\n template <typename NativeT = double, typename V8T = v8::Float64Array>\n class FSReqPromise : public FSReqBase {\n  public:\n-  explicit FSReqPromise(Environment* env)\n+  explicit FSReqPromise(Environment* env, bool use_bigint)\n       : FSReqBase(env,\n                   env->fsreqpromise_constructor_template()\n                       ->NewInstance(env->context()).ToLocalChecked(),\n-                  AsyncWrap::PROVIDER_FSREQPROMISE),\n+                  AsyncWrap::PROVIDER_FSREQPROMISE,\n+                  use_bigint),\n         stats_field_array_(env->isolate(), env->kFsStatsFieldsLength) {\n     auto resolver = Promise::Resolver::New(env->context()).ToLocalChecked();\n     object()->Set(env->context(), env->promise_string(),\n@@ -135,8 +139,7 @@ class FSReqPromise : public FSReqBase {\n   }\n \n   void ResolveStat(const uv_stat_t* stat) override {\n-    node::FillStatsArray(&stats_field_array_, stat);\n-    Resolve(stats_field_array_.GetJSArray());\n+    Resolve(node::FillStatsArray(&stats_field_array_, stat));\n   }\n \n   void SetReturnValue(const FunctionCallbackInfo<Value>& args) override {"
        },
        {
            "sha": "49f1d4f230b6d7b69bebfed5dd3e751523f9d227",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -337,14 +337,14 @@ v8::Local<v8::Value> FillStatsArray(AliasedBuffer<NativeT, V8T>* fields_ptr,\n #if defined(__POSIX__)\n   fields[offset + 6] = s->st_blksize;\n #else\n-  fields[offset + 6] = -1;\n+  fields[offset + 6] = 0;\n #endif\n   fields[offset + 7] = s->st_ino;\n   fields[offset + 8] = s->st_size;\n #if defined(__POSIX__)\n   fields[offset + 9] = s->st_blocks;\n #else\n-  fields[offset + 9] = -1;\n+  fields[offset + 9] = 0;\n #endif\n // Dates.\n // NO-LINT because the fields are 'long' and we just want to cast to `unsigned`\n@@ -365,8 +365,14 @@ v8::Local<v8::Value> FillStatsArray(AliasedBuffer<NativeT, V8T>* fields_ptr,\n \n inline v8::Local<v8::Value> FillGlobalStatsArray(Environment* env,\n                                                  const uv_stat_t* s,\n+                                                 bool use_bigint = false,\n                                                  int offset = 0) {\n-  return node::FillStatsArray(env->fs_stats_field_array(), s, offset);\n+  if (use_bigint) {\n+    return node::FillStatsArray(\n+        env->fs_stats_field_bigint_array(), s, offset);\n+  } else {\n+    return node::FillStatsArray(env->fs_stats_field_array(), s, offset);\n+  }\n }\n \n void SetupBootstrapObject(Environment* env,"
        },
        {
            "sha": "3f7da197b2a74d86c948d29ad3df2116befbbc43",
            "filename": "src/node_stat_watcher.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fnode_stat_watcher.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fnode_stat_watcher.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_stat_watcher.cc?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -75,9 +75,10 @@ void StatWatcher::Initialize(Environment* env, Local<Object> target) {\n }\n \n \n-StatWatcher::StatWatcher(Environment* env, Local<Object> wrap)\n+StatWatcher::StatWatcher(Environment* env, Local<Object> wrap, bool use_bigint)\n     : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_STATWATCHER),\n-      watcher_(new uv_fs_poll_t) {\n+      watcher_(new uv_fs_poll_t),\n+      use_bigint_(use_bigint) {\n   MakeWeak();\n   uv_fs_poll_init(env->event_loop(), watcher_);\n   watcher_->data = static_cast<void*>(this);\n@@ -102,8 +103,10 @@ void StatWatcher::Callback(uv_fs_poll_t* handle,\n   HandleScope handle_scope(env->isolate());\n   Context::Scope context_scope(env->context());\n \n-  Local<Value> arr = node::FillGlobalStatsArray(env, curr);\n-  node::FillGlobalStatsArray(env, prev, env->kFsStatsFieldsLength);\n+  Local<Value> arr = node::FillGlobalStatsArray(env, curr,\n+                                                wrap->use_bigint_);\n+  node::FillGlobalStatsArray(env, prev, wrap->use_bigint_,\n+                             env->kFsStatsFieldsLength);\n \n   Local<Value> argv[2] {\n     Integer::New(env->isolate(), status),\n@@ -116,7 +119,7 @@ void StatWatcher::Callback(uv_fs_poll_t* handle,\n void StatWatcher::New(const FunctionCallbackInfo<Value>& args) {\n   CHECK(args.IsConstructCall());\n   Environment* env = Environment::GetCurrent(args);\n-  new StatWatcher(env, args.This());\n+  new StatWatcher(env, args.This(), args[0]->IsTrue());\n }\n \n bool StatWatcher::IsActive() {"
        },
        {
            "sha": "0d0d263d5cc698c5c0f22e6083389f4e65c31a4d",
            "filename": "src/node_stat_watcher.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fnode_stat_watcher.h",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/src%2Fnode_stat_watcher.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_stat_watcher.h?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -39,7 +39,7 @@ class StatWatcher : public AsyncWrap {\n   static void Initialize(Environment* env, v8::Local<v8::Object> target);\n \n  protected:\n-  StatWatcher(Environment* env, v8::Local<v8::Object> wrap);\n+  StatWatcher(Environment* env, v8::Local<v8::Object> wrap, bool use_bigint);\n \n   static void New(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void Start(const v8::FunctionCallbackInfo<v8::Value>& args);\n@@ -57,6 +57,7 @@ class StatWatcher : public AsyncWrap {\n   bool IsActive();\n \n   uv_fs_poll_t* watcher_;\n+  const bool use_bigint_;\n };\n \n }  // namespace node"
        },
        {
            "sha": "4030a06fae3bc8a87d00e82d12dc8fdd2c3bc50f",
            "filename": "test/parallel/test-fs-stat-bigint.js",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/test%2Fparallel%2Ftest-fs-stat-bigint.js",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/test%2Fparallel%2Ftest-fs-stat-bigint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-stat-bigint.js?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -0,0 +1,145 @@\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const fs = require('fs');\n+const promiseFs = require('fs').promises;\n+const path = require('path');\n+const tmpdir = require('../common/tmpdir');\n+const { isDate } = require('util').types;\n+\n+common.crashOnUnhandledRejection();\n+tmpdir.refresh();\n+\n+const fn = path.join(tmpdir.path, 'test-file');\n+fs.writeFileSync(fn, 'test');\n+\n+let link;\n+if (!common.isWindows) {\n+  link = path.join(tmpdir.path, 'symbolic-link');\n+  fs.symlinkSync(fn, link);\n+}\n+\n+function verifyStats(bigintStats, numStats) {\n+  for (const key of Object.keys(numStats)) {\n+    const val = numStats[key];\n+    if (isDate(val)) {\n+      const time = val.getTime();\n+      const time2 = bigintStats[key].getTime();\n+      assert(\n+        Math.abs(time - time2) < 2,\n+        `difference of ${key}.getTime() should < 2.\\n` +\n+        `Number version ${time}, BigInt version ${time2}n`);\n+    } else if (key === 'mode') {\n+      // eslint-disable-next-line no-undef\n+      assert.strictEqual(bigintStats[key], BigInt(val));\n+      assert.strictEqual(\n+        bigintStats.isBlockDevice(),\n+        numStats.isBlockDevice()\n+      );\n+      assert.strictEqual(\n+        bigintStats.isCharacterDevice(),\n+        numStats.isCharacterDevice()\n+      );\n+      assert.strictEqual(\n+        bigintStats.isDirectory(),\n+        numStats.isDirectory()\n+      );\n+      assert.strictEqual(\n+        bigintStats.isFIFO(),\n+        numStats.isFIFO()\n+      );\n+      assert.strictEqual(\n+        bigintStats.isFile(),\n+        numStats.isFile()\n+      );\n+      assert.strictEqual(\n+        bigintStats.isSocket(),\n+        numStats.isSocket()\n+      );\n+      assert.strictEqual(\n+        bigintStats.isSymbolicLink(),\n+        numStats.isSymbolicLink()\n+      );\n+    } else if (common.isWindows && (key === 'blksize' || key === 'blocks')) {\n+      assert.strictEqual(bigintStats[key], undefined);\n+      assert.strictEqual(numStats[key], undefined);\n+    } else if (Number.isSafeInteger(val)) {\n+      // eslint-disable-next-line no-undef\n+      assert.strictEqual(bigintStats[key], BigInt(val));\n+    } else {\n+      assert(\n+        Math.abs(Number(bigintStats[key]) - val) < 1,\n+        `${key} is not a safe integer, difference should < 1.\\n` +\n+        `Number version ${val}, BigInt version ${bigintStats[key]}n`);\n+    }\n+  }\n+}\n+\n+{\n+  const bigintStats = fs.statSync(fn, { bigint: true });\n+  const numStats = fs.statSync(fn);\n+  verifyStats(bigintStats, numStats);\n+}\n+\n+if (!common.isWindows) {\n+  const bigintStats = fs.lstatSync(link, { bigint: true });\n+  const numStats = fs.lstatSync(link);\n+  verifyStats(bigintStats, numStats);\n+}\n+\n+{\n+  const fd = fs.openSync(fn, 'r');\n+  const bigintStats = fs.fstatSync(fd, { bigint: true });\n+  const numStats = fs.fstatSync(fd);\n+  verifyStats(bigintStats, numStats);\n+  fs.closeSync(fd);\n+}\n+\n+{\n+  fs.stat(fn, { bigint: true }, (err, bigintStats) => {\n+    fs.stat(fn, (err, numStats) => {\n+      verifyStats(bigintStats, numStats);\n+    });\n+  });\n+}\n+\n+if (!common.isWindows) {\n+  fs.lstat(link, { bigint: true }, (err, bigintStats) => {\n+    fs.lstat(link, (err, numStats) => {\n+      verifyStats(bigintStats, numStats);\n+    });\n+  });\n+}\n+\n+{\n+  const fd = fs.openSync(fn, 'r');\n+  fs.fstat(fd, { bigint: true }, (err, bigintStats) => {\n+    fs.fstat(fd, (err, numStats) => {\n+      verifyStats(bigintStats, numStats);\n+      fs.closeSync(fd);\n+    });\n+  });\n+}\n+\n+(async function() {\n+  const bigintStats = await promiseFs.stat(fn, { bigint: true });\n+  const numStats = await promiseFs.stat(fn);\n+  verifyStats(bigintStats, numStats);\n+})();\n+\n+if (!common.isWindows) {\n+  (async function() {\n+    const bigintStats = await promiseFs.lstat(link, { bigint: true });\n+    const numStats = await promiseFs.lstat(link);\n+    verifyStats(bigintStats, numStats);\n+  })();\n+}\n+\n+(async function() {\n+  const handle = await promiseFs.open(fn, 'r');\n+  const bigintStats = await handle.stat({ bigint: true });\n+  const numStats = await handle.stat();\n+  verifyStats(bigintStats, numStats);\n+  await handle.close();\n+})();"
        },
        {
            "sha": "52e40eb3901f4c403c5b2533c72c9d2a93bbdc5a",
            "filename": "test/parallel/test-fs-sync-fd-leak.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/test%2Fparallel%2Ftest-fs-sync-fd-leak.js",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/test%2Fparallel%2Ftest-fs-sync-fd-leak.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-sync-fd-leak.js?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -40,7 +40,7 @@ fs.writeSync = function() {\n   throw new Error('BAM');\n };\n \n-process.binding('fs').fstat = function(fd, _, ctx) {\n+process.binding('fs').fstat = function(fd, bigint, _, ctx) {\n   ctx.errno = uv.UV_EBADF;\n   ctx.syscall = 'fstat';\n };"
        },
        {
            "sha": "89cefd12e0443fc8ffc7d8ee572149d6c00a6f30",
            "filename": "test/parallel/test-fs-watchfile-bigint.js",
            "status": "added",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/nodejs/node/blob/1e7645c39ae5213a44267cff3d599264c2211f1a/test%2Fparallel%2Ftest-fs-watchfile-bigint.js",
            "raw_url": "https://github.com/nodejs/node/raw/1e7645c39ae5213a44267cff3d599264c2211f1a/test%2Fparallel%2Ftest-fs-watchfile-bigint.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-watchfile-bigint.js?ref=1e7645c39ae5213a44267cff3d599264c2211f1a",
            "patch": "@@ -0,0 +1,63 @@\n+'use strict';\n+const common = require('../common');\n+\n+const assert = require('assert');\n+const fs = require('fs');\n+const path = require('path');\n+\n+const tmpdir = require('../common/tmpdir');\n+\n+const enoentFile = path.join(tmpdir.path, 'non-existent-file');\n+const expectedStatObject = new fs.Stats(\n+  0n,                                        // dev\n+  0n,                                        // mode\n+  0n,                                        // nlink\n+  0n,                                        // uid\n+  0n,                                        // gid\n+  0n,                                        // rdev\n+  common.isWindows ? undefined : 0n,         // blksize\n+  0n,                                        // ino\n+  0n,                                        // size\n+  common.isWindows ? undefined : 0n,         // blocks\n+  0n,                                        // atim_msec\n+  0n,                                        // mtim_msec\n+  0n,                                        // ctim_msec\n+  0n                                         // birthtim_msec\n+);\n+\n+tmpdir.refresh();\n+\n+// If the file initially didn't exist, and gets created at a later point of\n+// time, the callback should be invoked again with proper values in stat object\n+let fileExists = false;\n+const options = { interval: 0, bigint: true };\n+\n+const watcher =\n+  fs.watchFile(enoentFile, options, common.mustCall((curr, prev) => {\n+    if (!fileExists) {\n+      // If the file does not exist, all the fields should be zero and the date\n+      // fields should be UNIX EPOCH time\n+      assert.deepStrictEqual(curr, expectedStatObject);\n+      assert.deepStrictEqual(prev, expectedStatObject);\n+      // Create the file now, so that the callback will be called back once the\n+      // event loop notices it.\n+      fs.closeSync(fs.openSync(enoentFile, 'w'));\n+      fileExists = true;\n+    } else {\n+      // If the ino (inode) value is greater than zero, it means that the file\n+      // is present in the filesystem and it has a valid inode number.\n+      assert(curr.ino > 0n);\n+      // As the file just got created, previous ino value should be lesser than\n+      // or equal to zero (non-existent file).\n+      assert(prev.ino <= 0n);\n+      // Stop watching the file\n+      fs.unwatchFile(enoentFile);\n+      watcher.stop();  // stopping a stopped watcher should be a noop\n+    }\n+  }, 2));\n+\n+// 'stop' should only be emitted once - stopping a stopped watcher should\n+// not trigger a 'stop' event.\n+watcher.on('stop', common.mustCall(function onStop() {}));\n+\n+watcher.start();  // starting a started watcher should be a noop"
        }
    ],
    "stats": {
        "total": 420,
        "additions": 341,
        "deletions": 79
    }
}