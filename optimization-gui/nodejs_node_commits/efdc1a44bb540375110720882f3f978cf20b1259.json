{
    "author": "jasnell",
    "message": "src: add node_encoding.cc\n\nContinue moving bits of code out of node.cc ... add node_encoding.cc\nas a home for `ParseEncoding` and related functions.\n\nPR-URL: https://github.com/nodejs/node/pull/21112\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "efdc1a44bb540375110720882f3f978cf20b1259",
    "files": [
        {
            "sha": "432b3ba565d8408cafb05f39b29c729d623a1e72",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/efdc1a44bb540375110720882f3f978cf20b1259/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/efdc1a44bb540375110720882f3f978cf20b1259/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=efdc1a44bb540375110720882f3f978cf20b1259",
            "patch": "@@ -333,6 +333,7 @@\n         'src/node_contextify.cc',\n         'src/node_debug_options.cc',\n         'src/node_domain.cc',\n+        'src/node_encoding.cc',\n         'src/node_errors.h',\n         'src/node_file.cc',\n         'src/node_http2.cc',"
        },
        {
            "sha": "ff3d149863927e188f6be41993de614ac706252e",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 123,
            "changes": 123,
            "blob_url": "https://github.com/nodejs/node/blob/efdc1a44bb540375110720882f3f978cf20b1259/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/efdc1a44bb540375110720882f3f978cf20b1259/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=efdc1a44bb540375110720882f3f978cf20b1259",
            "patch": "@@ -770,129 +770,6 @@ Local<Value> MakeCallback(Isolate* isolate,\n           .FromMaybe(Local<Value>()));\n }\n \n-\n-enum encoding ParseEncoding(const char* encoding,\n-                            enum encoding default_encoding) {\n-  switch (encoding[0]) {\n-    case 'u':\n-      // utf8, utf16le\n-      if (encoding[1] == 't' && encoding[2] == 'f') {\n-        // Skip `-`\n-        encoding += encoding[3] == '-' ? 4 : 3;\n-        if (encoding[0] == '8' && encoding[1] == '\\0')\n-          return UTF8;\n-        if (strncmp(encoding, \"16le\", 4) == 0)\n-          return UCS2;\n-\n-      // ucs2\n-      } else if (encoding[1] == 'c' && encoding[2] == 's') {\n-        encoding += encoding[3] == '-' ? 4 : 3;\n-        if (encoding[0] == '2' && encoding[1] == '\\0')\n-          return UCS2;\n-      }\n-      break;\n-    case 'l':\n-      // latin1\n-      if (encoding[1] == 'a') {\n-        if (strncmp(encoding + 2, \"tin1\", 4) == 0)\n-          return LATIN1;\n-      }\n-      break;\n-    case 'b':\n-      // binary\n-      if (encoding[1] == 'i') {\n-        if (strncmp(encoding + 2, \"nary\", 4) == 0)\n-          return LATIN1;\n-\n-      // buffer\n-      } else if (encoding[1] == 'u') {\n-        if (strncmp(encoding + 2, \"ffer\", 4) == 0)\n-          return BUFFER;\n-      }\n-      break;\n-    case '\\0':\n-      return default_encoding;\n-    default:\n-      break;\n-  }\n-\n-  if (StringEqualNoCase(encoding, \"utf8\")) {\n-    return UTF8;\n-  } else if (StringEqualNoCase(encoding, \"utf-8\")) {\n-    return UTF8;\n-  } else if (StringEqualNoCase(encoding, \"ascii\")) {\n-    return ASCII;\n-  } else if (StringEqualNoCase(encoding, \"base64\")) {\n-    return BASE64;\n-  } else if (StringEqualNoCase(encoding, \"ucs2\")) {\n-    return UCS2;\n-  } else if (StringEqualNoCase(encoding, \"ucs-2\")) {\n-    return UCS2;\n-  } else if (StringEqualNoCase(encoding, \"utf16le\")) {\n-    return UCS2;\n-  } else if (StringEqualNoCase(encoding, \"utf-16le\")) {\n-    return UCS2;\n-  } else if (StringEqualNoCase(encoding, \"latin1\")) {\n-    return LATIN1;\n-  } else if (StringEqualNoCase(encoding, \"binary\")) {\n-    return LATIN1;  // BINARY is a deprecated alias of LATIN1.\n-  } else if (StringEqualNoCase(encoding, \"buffer\")) {\n-    return BUFFER;\n-  } else if (StringEqualNoCase(encoding, \"hex\")) {\n-    return HEX;\n-  } else {\n-    return default_encoding;\n-  }\n-}\n-\n-\n-enum encoding ParseEncoding(Isolate* isolate,\n-                            Local<Value> encoding_v,\n-                            enum encoding default_encoding) {\n-  CHECK(!encoding_v.IsEmpty());\n-\n-  if (!encoding_v->IsString())\n-    return default_encoding;\n-\n-  node::Utf8Value encoding(isolate, encoding_v);\n-\n-  return ParseEncoding(*encoding, default_encoding);\n-}\n-\n-Local<Value> Encode(Isolate* isolate,\n-                    const char* buf,\n-                    size_t len,\n-                    enum encoding encoding) {\n-  CHECK_NE(encoding, UCS2);\n-  Local<Value> error;\n-  return StringBytes::Encode(isolate, buf, len, encoding, &error)\n-      .ToLocalChecked();\n-}\n-\n-Local<Value> Encode(Isolate* isolate, const uint16_t* buf, size_t len) {\n-  Local<Value> error;\n-  return StringBytes::Encode(isolate, buf, len, &error)\n-      .ToLocalChecked();\n-}\n-\n-// Returns -1 if the handle was not valid for decoding\n-ssize_t DecodeBytes(Isolate* isolate,\n-                    Local<Value> val,\n-                    enum encoding encoding) {\n-  HandleScope scope(isolate);\n-\n-  return StringBytes::Size(isolate, val, encoding);\n-}\n-\n-// Returns number of bytes written.\n-ssize_t DecodeWrite(Isolate* isolate,\n-                    char* buf,\n-                    size_t buflen,\n-                    Local<Value> val,\n-                    enum encoding encoding) {\n-  return StringBytes::Write(isolate, buf, buflen, val, encoding, nullptr);\n-}\n-\n bool IsExceptionDecorated(Environment* env, Local<Value> er) {\n   if (!er.IsEmpty() && er->IsObject()) {\n     Local<Object> err_obj = er.As<Object>();"
        },
        {
            "sha": "467f04e24568cb4be6d370ee3649464ea5eeafe4",
            "filename": "src/node_encoding.cc",
            "status": "added",
            "additions": 138,
            "deletions": 0,
            "changes": 138,
            "blob_url": "https://github.com/nodejs/node/blob/efdc1a44bb540375110720882f3f978cf20b1259/src%2Fnode_encoding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/efdc1a44bb540375110720882f3f978cf20b1259/src%2Fnode_encoding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_encoding.cc?ref=efdc1a44bb540375110720882f3f978cf20b1259",
            "patch": "@@ -0,0 +1,138 @@\n+#include \"node.h\"\n+#include \"env.h\"\n+#include \"env-inl.h\"\n+#include \"string_bytes.h\"\n+#include \"util.h\"\n+#include \"util-inl.h\"\n+#include \"v8.h\"\n+\n+namespace node {\n+\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Value;\n+\n+enum encoding ParseEncoding(const char* encoding,\n+                            enum encoding default_encoding) {\n+  switch (encoding[0]) {\n+    case 'u':\n+      // utf8, utf16le\n+      if (encoding[1] == 't' && encoding[2] == 'f') {\n+        // Skip `-`\n+        encoding += encoding[3] == '-' ? 4 : 3;\n+        if (encoding[0] == '8' && encoding[1] == '\\0')\n+          return UTF8;\n+        if (strncmp(encoding, \"16le\", 4) == 0)\n+          return UCS2;\n+\n+      // ucs2\n+      } else if (encoding[1] == 'c' && encoding[2] == 's') {\n+        encoding += encoding[3] == '-' ? 4 : 3;\n+        if (encoding[0] == '2' && encoding[1] == '\\0')\n+          return UCS2;\n+      }\n+      break;\n+    case 'l':\n+      // latin1\n+      if (encoding[1] == 'a') {\n+        if (strncmp(encoding + 2, \"tin1\", 4) == 0)\n+          return LATIN1;\n+      }\n+      break;\n+    case 'b':\n+      // binary\n+      if (encoding[1] == 'i') {\n+        if (strncmp(encoding + 2, \"nary\", 4) == 0)\n+          return LATIN1;\n+\n+      // buffer\n+      } else if (encoding[1] == 'u') {\n+        if (strncmp(encoding + 2, \"ffer\", 4) == 0)\n+          return BUFFER;\n+      }\n+      break;\n+    case '\\0':\n+      return default_encoding;\n+    default:\n+      break;\n+  }\n+\n+  if (StringEqualNoCase(encoding, \"utf8\")) {\n+    return UTF8;\n+  } else if (StringEqualNoCase(encoding, \"utf-8\")) {\n+    return UTF8;\n+  } else if (StringEqualNoCase(encoding, \"ascii\")) {\n+    return ASCII;\n+  } else if (StringEqualNoCase(encoding, \"base64\")) {\n+    return BASE64;\n+  } else if (StringEqualNoCase(encoding, \"ucs2\")) {\n+    return UCS2;\n+  } else if (StringEqualNoCase(encoding, \"ucs-2\")) {\n+    return UCS2;\n+  } else if (StringEqualNoCase(encoding, \"utf16le\")) {\n+    return UCS2;\n+  } else if (StringEqualNoCase(encoding, \"utf-16le\")) {\n+    return UCS2;\n+  } else if (StringEqualNoCase(encoding, \"latin1\")) {\n+    return LATIN1;\n+  } else if (StringEqualNoCase(encoding, \"binary\")) {\n+    return LATIN1;  // BINARY is a deprecated alias of LATIN1.\n+  } else if (StringEqualNoCase(encoding, \"buffer\")) {\n+    return BUFFER;\n+  } else if (StringEqualNoCase(encoding, \"hex\")) {\n+    return HEX;\n+  } else {\n+    return default_encoding;\n+  }\n+}\n+\n+\n+enum encoding ParseEncoding(Isolate* isolate,\n+                            Local<Value> encoding_v,\n+                            enum encoding default_encoding) {\n+  CHECK(!encoding_v.IsEmpty());\n+\n+  if (!encoding_v->IsString())\n+    return default_encoding;\n+\n+  Utf8Value encoding(isolate, encoding_v);\n+\n+  return ParseEncoding(*encoding, default_encoding);\n+}\n+\n+Local<Value> Encode(Isolate* isolate,\n+                    const char* buf,\n+                    size_t len,\n+                    enum encoding encoding) {\n+  CHECK_NE(encoding, UCS2);\n+  Local<Value> error;\n+  return StringBytes::Encode(isolate, buf, len, encoding, &error)\n+      .ToLocalChecked();\n+}\n+\n+Local<Value> Encode(Isolate* isolate, const uint16_t* buf, size_t len) {\n+  Local<Value> error;\n+  return StringBytes::Encode(isolate, buf, len, &error)\n+      .ToLocalChecked();\n+}\n+\n+// Returns -1 if the handle was not valid for decoding\n+ssize_t DecodeBytes(Isolate* isolate,\n+                    Local<Value> val,\n+                    enum encoding encoding) {\n+  HandleScope scope(isolate);\n+\n+  return StringBytes::Size(isolate, val, encoding);\n+}\n+\n+// Returns number of bytes written.\n+ssize_t DecodeWrite(Isolate* isolate,\n+                    char* buf,\n+                    size_t buflen,\n+                    Local<Value> val,\n+                    enum encoding encoding) {\n+  return StringBytes::Write(isolate, buf, buflen, val, encoding, nullptr);\n+}\n+\n+}  // namespace node"
        }
    ],
    "stats": {
        "total": 262,
        "additions": 139,
        "deletions": 123
    }
}