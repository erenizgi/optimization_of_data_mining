{
    "author": "joyeecheung",
    "message": "src: use NativeModuleLoader to compile per_context.js\n\nThis patch introduces a NativeModuleLoader::CompileAndCall that\ncan run a JS script under `lib/` as a function called\nwith a null receiver and arguments specified from the C++ layer.\nSince all our bootstrappers are wrapped in functions in the\nsource to avoid leaking variables into the global scope anyway,\nthis allows us to remove that extra indentation in the JS source code.\n\nAs a start we move the compilation and execution of per_context.js\nto NativeModuleLoader::CompileAndCall(). This patch also changes the\nreturn value of NativeModuleLoader::LookupAndCompile() to a MaybeLocal\nsince the caller has to take care of the result being empty\nanyway.\n\nThis patch reverts the previous design of having the\nNativeModuleLoader::Compile() method magically know about the\nparameters of the function - until we have tooling\nin-place to guess the parameter names in the source with some\nannotation, it's more readable to allow the caller to specify\nthe parameters along with the arguments values.\n\nPR-URL: https://github.com/nodejs/node/pull/24660\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>",
    "sha": "804138093abb2c63cfaba5ee058e18df19b38f3e",
    "files": [
        {
            "sha": "87fc8d247eb9336ea3101b419ce6e3c90db4347c",
            "filename": "lib/internal/per_context.js",
            "status": "modified",
            "additions": 32,
            "deletions": 32,
            "changes": 64,
            "blob_url": "https://github.com/nodejs/node/blob/804138093abb2c63cfaba5ee058e18df19b38f3e/lib%2Finternal%2Fper_context.js",
            "raw_url": "https://github.com/nodejs/node/raw/804138093abb2c63cfaba5ee058e18df19b38f3e/lib%2Finternal%2Fper_context.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fper_context.js?ref=804138093abb2c63cfaba5ee058e18df19b38f3e",
            "patch": "@@ -1,44 +1,44 @@\n+// arguments: global\n+\n 'use strict';\n \n // node::NewContext calls this script\n \n-(function(global) {\n-  // https://github.com/nodejs/node/issues/14909\n-  if (global.Intl) delete global.Intl.v8BreakIterator;\n+// https://github.com/nodejs/node/issues/14909\n+if (global.Intl) delete global.Intl.v8BreakIterator;\n \n-  // https://github.com/nodejs/node/issues/21219\n-  // Adds Atomics.notify and warns on first usage of Atomics.wake\n-  // https://github.com/v8/v8/commit/c79206b363 adds Atomics.notify so\n-  // now we alias Atomics.wake to notify so that we can remove it\n-  // semver major without worrying about V8.\n+// https://github.com/nodejs/node/issues/21219\n+// Adds Atomics.notify and warns on first usage of Atomics.wake\n+// https://github.com/v8/v8/commit/c79206b363 adds Atomics.notify so\n+// now we alias Atomics.wake to notify so that we can remove it\n+// semver major without worrying about V8.\n \n-  const AtomicsNotify = global.Atomics.notify;\n-  const ReflectApply = global.Reflect.apply;\n+const AtomicsNotify = global.Atomics.notify;\n+const ReflectApply = global.Reflect.apply;\n \n-  const warning = 'Atomics.wake will be removed in a future version, ' +\n-    'use Atomics.notify instead.';\n+const warning = 'Atomics.wake will be removed in a future version, ' +\n+  'use Atomics.notify instead.';\n \n-  let wakeWarned = false;\n-  function wake(typedArray, index, count) {\n-    if (!wakeWarned) {\n-      wakeWarned = true;\n+let wakeWarned = false;\n+function wake(typedArray, index, count) {\n+  if (!wakeWarned) {\n+    wakeWarned = true;\n \n-      if (global.process !== undefined) {\n-        global.process.emitWarning(warning, 'Atomics');\n-      } else {\n-        global.console.error(`Atomics: ${warning}`);\n-      }\n+    if (global.process !== undefined) {\n+      global.process.emitWarning(warning, 'Atomics');\n+    } else {\n+      global.console.error(`Atomics: ${warning}`);\n     }\n-\n-    return ReflectApply(AtomicsNotify, this, arguments);\n   }\n \n-  global.Object.defineProperties(global.Atomics, {\n-    wake: {\n-      value: wake,\n-      writable: true,\n-      enumerable: false,\n-      configurable: true,\n-    },\n-  });\n-}(this));\n+  return ReflectApply(AtomicsNotify, this, arguments);\n+}\n+\n+global.Object.defineProperties(global.Atomics, {\n+  wake: {\n+    value: wake,\n+    writable: true,\n+    enumerable: false,\n+    configurable: true,\n+  },\n+});"
        },
        {
            "sha": "e01baf9726a45e2d4d834b013e032cf5f9c3cab8",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/804138093abb2c63cfaba5ee058e18df19b38f3e/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/804138093abb2c63cfaba5ee058e18df19b38f3e/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=804138093abb2c63cfaba5ee058e18df19b38f3e",
            "patch": "@@ -162,7 +162,6 @@ using v8::ObjectTemplate;\n using v8::PropertyAttribute;\n using v8::ReadOnly;\n using v8::Script;\n-using v8::ScriptCompiler;\n using v8::ScriptOrigin;\n using v8::SealHandleScope;\n using v8::SideEffectType;\n@@ -2500,14 +2499,16 @@ Local<Context> NewContext(Isolate* isolate,\n     // Run lib/internal/per_context.js\n     Context::Scope context_scope(context);\n \n-    // TODO(joyeecheung): use NativeModuleLoader::Compile\n-    Local<String> per_context =\n-        per_process_loader.GetSource(isolate, \"internal/per_context\");\n-    ScriptCompiler::Source per_context_src(per_context, nullptr);\n-    Local<Script> s = ScriptCompiler::Compile(\n-        context,\n-        &per_context_src).ToLocalChecked();\n-    s->Run(context).ToLocalChecked();\n+    std::vector<Local<String>> parameters = {\n+        FIXED_ONE_BYTE_STRING(isolate, \"global\")};\n+    std::vector<Local<Value>> arguments = {context->Global()};\n+    MaybeLocal<Value> result = per_process_loader.CompileAndCall(\n+        context, \"internal/per_context\", &parameters, &arguments, nullptr);\n+    if (result.IsEmpty()) {\n+      // Execution failed during context creation.\n+      // TODO(joyeecheung): deprecate this signature and return a MaybeLocal.\n+      return Local<Context>();\n+    }\n   }\n \n   return context;"
        },
        {
            "sha": "77763229ce44de2c55b492bde3f12b249c1b4563",
            "filename": "src/node_native_module.cc",
            "status": "modified",
            "additions": 60,
            "deletions": 47,
            "changes": 107,
            "blob_url": "https://github.com/nodejs/node/blob/804138093abb2c63cfaba5ee058e18df19b38f3e/src%2Fnode_native_module.cc",
            "raw_url": "https://github.com/nodejs/node/raw/804138093abb2c63cfaba5ee058e18df19b38f3e/src%2Fnode_native_module.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_native_module.cc?ref=804138093abb2c63cfaba5ee058e18df19b38f3e",
            "patch": "@@ -103,29 +103,54 @@ void NativeModuleLoader::CompileCodeCache(\n \n   // TODO(joyeecheung): allow compiling cache for bootstrapper by\n   // switching on id\n-  Local<Value> result = CompileAsModule(env, *id, true);\n+  MaybeLocal<Value> result =\n+      CompileAsModule(env, *id, CompilationResultType::kCodeCache);\n   if (!result.IsEmpty()) {\n-    args.GetReturnValue().Set(result);\n+    args.GetReturnValue().Set(result.ToLocalChecked());\n   }\n }\n \n void NativeModuleLoader::CompileFunction(\n     const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n-\n   CHECK(args[0]->IsString());\n   node::Utf8Value id(env->isolate(), args[0].As<String>());\n-  Local<Value> result = CompileAsModule(env, *id, false);\n+\n+  MaybeLocal<Value> result =\n+      CompileAsModule(env, *id, CompilationResultType::kFunction);\n   if (!result.IsEmpty()) {\n-    args.GetReturnValue().Set(result);\n+    args.GetReturnValue().Set(result.ToLocalChecked());\n   }\n }\n \n-Local<Value> NativeModuleLoader::CompileAsModule(Environment* env,\n-                                                 const char* id,\n-                                                 bool produce_code_cache) {\n+// TODO(joyeecheung): it should be possible to generate the argument names\n+// from some special comments for the bootstrapper case.\n+MaybeLocal<Value> NativeModuleLoader::CompileAndCall(\n+    Local<Context> context,\n+    const char* id,\n+    std::vector<Local<String>>* parameters,\n+    std::vector<Local<Value>>* arguments,\n+    Environment* optional_env) {\n+  Isolate* isolate = context->GetIsolate();\n+  MaybeLocal<Value> compiled = per_process_loader.LookupAndCompile(\n+      context, id, parameters, CompilationResultType::kFunction, nullptr);\n+  if (compiled.IsEmpty()) {\n+    return compiled;\n+  }\n+  Local<Function> fn = compiled.ToLocalChecked().As<Function>();\n+  return fn->Call(\n+      context, v8::Null(isolate), arguments->size(), arguments->data());\n+}\n+\n+MaybeLocal<Value> NativeModuleLoader::CompileAsModule(\n+    Environment* env, const char* id, CompilationResultType result) {\n+  std::vector<Local<String>> parameters = {env->exports_string(),\n+                                           env->require_string(),\n+                                           env->module_string(),\n+                                           env->process_string(),\n+                                           env->internal_binding_string()};\n   return per_process_loader.LookupAndCompile(\n-      env->context(), id, produce_code_cache, env);\n+      env->context(), id, &parameters, result, env);\n }\n \n // Currently V8 only checks that the length of the source code is the\n@@ -183,15 +208,18 @@ ScriptCompiler::CachedData* NativeModuleLoader::GetCachedData(\n   return new ScriptCompiler::CachedData(code_cache_value, code_cache_length);\n }\n \n-// Returns Local<Function> of the compiled module if produce_code_cache\n+// Returns Local<Function> of the compiled module if return_code_cache\n // is false (we are only compiling the function).\n // Otherwise return a Local<Object> containing the cache.\n-Local<Value> NativeModuleLoader::LookupAndCompile(Local<Context> context,\n-                                                  const char* id,\n-                                                  bool produce_code_cache,\n-                                                  Environment* optional_env) {\n+MaybeLocal<Value> NativeModuleLoader::LookupAndCompile(\n+    Local<Context> context,\n+    const char* id,\n+    std::vector<Local<String>>* parameters,\n+    CompilationResultType result_type,\n+    Environment* optional_env) {\n   Isolate* isolate = context->GetIsolate();\n   EscapableHandleScope scope(isolate);\n+  Local<Value> ret;  // Used to convert to MaybeLocal before return\n \n   Local<String> source = GetSource(isolate, id);\n \n@@ -209,7 +237,7 @@ Local<Value> NativeModuleLoader::LookupAndCompile(Local<Context> context,\n   //    built with them.\n   // 2. If we are generating code cache for tools/general_code_cache.js, we\n   //    are not going to use any cache ourselves.\n-  if (has_code_cache_ && !produce_code_cache) {\n+  if (has_code_cache_ && result_type == CompilationResultType::kFunction) {\n     cached_data = GetCachedData(id);\n     if (cached_data != nullptr) {\n       use_cache = true;\n@@ -219,50 +247,33 @@ Local<Value> NativeModuleLoader::LookupAndCompile(Local<Context> context,\n   ScriptCompiler::Source script_source(source, origin, cached_data);\n \n   ScriptCompiler::CompileOptions options;\n-  if (produce_code_cache) {\n+  if (result_type == CompilationResultType::kCodeCache) {\n     options = ScriptCompiler::kEagerCompile;\n   } else if (use_cache) {\n     options = ScriptCompiler::kConsumeCodeCache;\n   } else {\n     options = ScriptCompiler::kNoCompileOptions;\n   }\n \n-  MaybeLocal<Function> maybe_fun;\n-  // Currently we assume if Environment is ready, then we must be compiling\n-  // native modules instead of bootstrappers.\n-  if (optional_env != nullptr) {\n-    Local<String> parameters[] = {optional_env->exports_string(),\n-                                  optional_env->require_string(),\n-                                  optional_env->module_string(),\n-                                  optional_env->process_string(),\n-                                  optional_env->internal_binding_string()};\n-    maybe_fun = ScriptCompiler::CompileFunctionInContext(context,\n-                                                         &script_source,\n-                                                         arraysize(parameters),\n-                                                         parameters,\n-                                                         0,\n-                                                         nullptr,\n-                                                         options);\n-  } else {\n-    // Until we migrate bootstrappers compilations here this is unreachable\n-    // TODO(joyeecheung): it should be possible to generate the argument names\n-    // from some special comments for the bootstrapper case.\n-    // Note that for bootstrappers we may not be able to get the argument\n-    // names as env->some_string() because we might be compiling before\n-    // those strings are initialized.\n-    UNREACHABLE();\n-  }\n+  MaybeLocal<Function> maybe_fun =\n+      ScriptCompiler::CompileFunctionInContext(context,\n+                                               &script_source,\n+                                               parameters->size(),\n+                                               parameters->data(),\n+                                               0,\n+                                               nullptr,\n+                                               options);\n \n-  Local<Function> fun;\n   // This could fail when there are early errors in the native modules,\n   // e.g. the syntax errors\n-  if (maybe_fun.IsEmpty() || !maybe_fun.ToLocal(&fun)) {\n+  if (maybe_fun.IsEmpty()) {\n     // In the case of early errors, v8 is already capable of\n     // decorating the stack for us - note that we use CompileFunctionInContext\n     // so there is no need to worry about wrappers.\n-    return scope.Escape(Local<Value>());\n+    return MaybeLocal<Value>();\n   }\n \n+  Local<Function> fun = maybe_fun.ToLocalChecked();\n   if (use_cache) {\n     if (optional_env != nullptr) {\n       // This could happen when Node is run with any v8 flag, but\n@@ -279,7 +290,7 @@ Local<Value> NativeModuleLoader::LookupAndCompile(Local<Context> context,\n     }\n   }\n \n-  if (produce_code_cache) {\n+  if (result_type == CompilationResultType::kCodeCache) {\n     std::unique_ptr<ScriptCompiler::CachedData> cached_data(\n         ScriptCompiler::CreateCodeCacheForFunction(fun));\n     CHECK_NE(cached_data, nullptr);\n@@ -296,10 +307,12 @@ Local<Value> NativeModuleLoader::LookupAndCompile(Local<Context> context,\n                          copied.release(),\n                          cached_data_length,\n                          ArrayBufferCreationMode::kInternalized);\n-    return scope.Escape(Uint8Array::New(buf, 0, cached_data_length));\n+    ret = Uint8Array::New(buf, 0, cached_data_length);\n   } else {\n-    return scope.Escape(fun);\n+    ret = fun;\n   }\n+\n+  return scope.Escape(ret);\n }\n \n void NativeModuleLoader::Initialize(Local<Object> target,"
        },
        {
            "sha": "76725ec0f2825be402b37319239be32b1e6c2d45",
            "filename": "src/node_native_module.h",
            "status": "modified",
            "additions": 42,
            "deletions": 12,
            "changes": 54,
            "blob_url": "https://github.com/nodejs/node/blob/804138093abb2c63cfaba5ee058e18df19b38f3e/src%2Fnode_native_module.h",
            "raw_url": "https://github.com/nodejs/node/raw/804138093abb2c63cfaba5ee058e18df19b38f3e/src%2Fnode_native_module.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_native_module.h?ref=804138093abb2c63cfaba5ee058e18df19b38f3e",
            "patch": "@@ -16,17 +16,43 @@ namespace native_module {\n using NativeModuleRecordMap = std::map<std::string, UnionBytes>;\n using NativeModuleHashMap = std::map<std::string, std::string>;\n \n-// The native (C++) side of the native module compilation.\n-// This class should not depend on Environment\n+// The native (C++) side of the NativeModule in JS land, which\n+// handles compilation and caching of builtin modules (NativeModule)\n+// and bootstrappers, whose source are bundled into the binary\n+// as static data.\n+// This class should not depend on a particular isolate, context, or\n+// environment. Rather it should take them as arguments when necessary.\n+// The instances of this class are per-process.\n class NativeModuleLoader {\n  public:\n+  // kCodeCache indicates that the compilation result should be returned\n+  // as a Uint8Array, whereas kFunction indicates that the result should\n+  // be returned as a Function.\n+  // TODO(joyeecheung): it's possible to always produce code cache\n+  // on the main thread and consume them in worker threads, or just\n+  // share the cache among all the threads, although\n+  // we need to decide whether to do that even when workers are not used.\n+  enum class CompilationResultType { kCodeCache, kFunction };\n+\n   NativeModuleLoader();\n   static void Initialize(v8::Local<v8::Object> target,\n                          v8::Local<v8::Value> unused,\n                          v8::Local<v8::Context> context);\n   v8::Local<v8::Object> GetSourceObject(v8::Local<v8::Context> context) const;\n   v8::Local<v8::String> GetSource(v8::Isolate* isolate, const char* id) const;\n \n+  // Run a script with JS source bundled inside the binary as if it's wrapped\n+  // in a function called with a null receiver and arguments specified in C++.\n+  // The returned value is empty if an exception is encountered.\n+  // JS code run with this method can assume that their top-level\n+  // declarations won't affect the global scope.\n+  v8::MaybeLocal<v8::Value> CompileAndCall(\n+      v8::Local<v8::Context> context,\n+      const char* id,\n+      std::vector<v8::Local<v8::String>>* parameters,\n+      std::vector<v8::Local<v8::Value>>* arguments,\n+      Environment* optional_env);\n+\n  private:\n   static void GetCacheUsage(const v8::FunctionCallbackInfo<v8::Value>& args);\n   // For legacy process.binding('natives') which is mutable, and for\n@@ -48,17 +74,21 @@ class NativeModuleLoader {\n   void LoadCodeCacheHash();  // Loads data into code_cache_hash_\n \n   v8::ScriptCompiler::CachedData* GetCachedData(const char* id) const;\n-  static v8::Local<v8::Value> CompileAsModule(Environment* env,\n-                                              const char* id,\n-                                              bool produce_code_cache);\n-  // TODO(joyeecheung): make this public and reuse it to compile bootstrappers.\n+\n+  // Compile a script as a NativeModule that can be loaded via\n+  // NativeModule.p.require in JS land.\n+  static v8::MaybeLocal<v8::Value> CompileAsModule(\n+      Environment* env, const char* id, CompilationResultType result_type);\n+\n   // For bootstrappers optional_env may be a nullptr.\n-  // This method magically knows what parameter it should pass to\n-  // the function to be compiled.\n-  v8::Local<v8::Value> LookupAndCompile(v8::Local<v8::Context> context,\n-                                        const char* id,\n-                                        bool produce_code_cache,\n-                                        Environment* optional_env);\n+  // If an exception is encountered (e.g. source code contains\n+  // syntax error), the returned value is empty.\n+  v8::MaybeLocal<v8::Value> LookupAndCompile(\n+      v8::Local<v8::Context> context,\n+      const char* id,\n+      std::vector<v8::Local<v8::String>>* parameters,\n+      CompilationResultType result_type,\n+      Environment* optional_env);\n \n   bool has_code_cache_ = false;\n   NativeModuleRecordMap source_;"
        }
    ],
    "stats": {
        "total": 244,
        "additions": 144,
        "deletions": 100
    }
}