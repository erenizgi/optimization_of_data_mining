{
    "author": "jasnell",
    "message": "src: add trace events for env.cc\n\nPR-URL: https://github.com/nodejs/node/pull/23674\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Denys Otrishko <shishugi@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Ali Ijaz Sheikh <ofrobots@google.com>\nReviewed-By: Matheus Marchini <mat@mmarchini.me>",
    "sha": "72a48a2a0abb655e7387d09c3dc7550793ce4a6a",
    "files": [
        {
            "sha": "d58079360a0056085c4ba9974e1ae79a185cf72f",
            "filename": "doc/api/tracing.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/72a48a2a0abb655e7387d09c3dc7550793ce4a6a/doc%2Fapi%2Ftracing.md",
            "raw_url": "https://github.com/nodejs/node/raw/72a48a2a0abb655e7387d09c3dc7550793ce4a6a/doc%2Fapi%2Ftracing.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ftracing.md?ref=72a48a2a0abb655e7387d09c3dc7550793ce4a6a",
            "patch": "@@ -18,6 +18,7 @@ The available categories are:\n   The [`async_hooks`] events have a unique `asyncId` and a special `triggerId`\n   `triggerAsyncId` property.\n * `node.bootstrap` - Enables capture of Node.js bootstrap milestones.\n+* `node.environment` - Enables capture of Node.js Environment milestones.\n * `node.fs.sync` - Enables capture of trace data for file system sync methods.\n * `node.perf` - Enables capture of [Performance API] measurements.\n   * `node.perf.usertiming` - Enables capture of only Performance API User Timing"
        },
        {
            "sha": "f77bcbf1699912728ba86d2e7e019fd0f9f089a8",
            "filename": "src/env.cc",
            "status": "modified",
            "additions": 54,
            "deletions": 1,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/72a48a2a0abb655e7387d09c3dc7550793ce4a6a/src%2Fenv.cc",
            "raw_url": "https://github.com/nodejs/node/raw/72a48a2a0abb655e7387d09c3dc7550793ce4a6a/src%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.cc?ref=72a48a2a0abb655e7387d09c3dc7550793ce4a6a",
            "patch": "@@ -7,6 +7,7 @@\n #include \"node_context_data.h\"\n #include \"node_worker.h\"\n #include \"tracing/agent.h\"\n+#include \"tracing/traced_value.h\"\n \n #include <stdio.h>\n #include <algorithm>\n@@ -33,6 +34,25 @@ using worker::Worker;\n \n #define kTraceCategoryCount 1\n \n+// TODO(@jasnell): Likely useful to move this to util or node_internal to\n+// allow reuse. But since we're not reusing it yet...\n+class TraceEventScope {\n+ public:\n+  TraceEventScope(const char* category,\n+                  const char* name,\n+                  void* id) : category_(category), name_(name), id_(id) {\n+    TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(category_, name_, id_);\n+  }\n+  ~TraceEventScope() {\n+    TRACE_EVENT_NESTABLE_ASYNC_END0(category_, name_, id_);\n+  }\n+\n+ private:\n+  const char* category_;\n+  const char* name_;\n+  void* id_;\n+};\n+\n int const Environment::kNodeContextTag = 0x6e6f64;\n void* Environment::kNodeContextTagPtr = const_cast<void*>(\n     static_cast<const void*>(&Environment::kNodeContextTag));\n@@ -224,6 +244,9 @@ Environment::~Environment() {\n   delete[] heap_statistics_buffer_;\n   delete[] heap_space_statistics_buffer_;\n   delete[] http_parser_buffer_;\n+\n+  TRACE_EVENT_NESTABLE_ASYNC_END0(\n+    TRACING_CATEGORY_NODE1(environment), \"Environment\", this);\n }\n \n void Environment::Start(const std::vector<std::string>& args,\n@@ -232,6 +255,23 @@ void Environment::Start(const std::vector<std::string>& args,\n   HandleScope handle_scope(isolate());\n   Context::Scope context_scope(context());\n \n+  if (*TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(\n+      TRACING_CATEGORY_NODE1(environment)) != 0) {\n+    auto traced_value = tracing::TracedValue::Create();\n+    traced_value->BeginArray(\"args\");\n+    for (const std::string& arg : args)\n+      traced_value->AppendString(arg);\n+    traced_value->EndArray();\n+    traced_value->BeginArray(\"exec_args\");\n+    for (const std::string& arg : exec_args)\n+      traced_value->AppendString(arg);\n+    traced_value->EndArray();\n+    TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(\n+      TRACING_CATEGORY_NODE1(environment),\n+      \"Environment\", this,\n+      \"args\", std::move(traced_value));\n+  }\n+\n   CHECK_EQ(0, uv_timer_init(event_loop(), timer_handle()));\n   uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));\n \n@@ -401,6 +441,8 @@ void Environment::PrintSyncTrace() const {\n }\n \n void Environment::RunCleanup() {\n+  TraceEventScope trace_scope(TRACING_CATEGORY_NODE1(environment),\n+                              \"RunCleanup\", this);\n   CleanupHandles();\n \n   while (!cleanup_hooks_.empty()) {\n@@ -432,6 +474,8 @@ void Environment::RunCleanup() {\n }\n \n void Environment::RunBeforeExitCallbacks() {\n+  TraceEventScope trace_scope(TRACING_CATEGORY_NODE1(environment),\n+                              \"BeforeExit\", this);\n   for (ExitCallback before_exit : before_exit_functions_) {\n     before_exit.cb_(before_exit.arg_);\n   }\n@@ -443,6 +487,8 @@ void Environment::BeforeExit(void (*cb)(void* arg), void* arg) {\n }\n \n void Environment::RunAtExitCallbacks() {\n+  TraceEventScope trace_scope(TRACING_CATEGORY_NODE1(environment),\n+                              \"AtExit\", this);\n   for (ExitCallback at_exit : at_exit_functions_) {\n     at_exit.cb_(at_exit.arg_);\n   }\n@@ -496,13 +542,16 @@ void Environment::EnvPromiseHook(v8::PromiseHookType type,\n \n   Environment* env = Environment::GetCurrent(context);\n   if (env == nullptr) return;\n-\n+  TraceEventScope trace_scope(TRACING_CATEGORY_NODE1(environment),\n+                              \"EnvPromiseHook\", env);\n   for (const PromiseHookCallback& hook : env->promise_hooks_) {\n     hook.cb_(type, promise, parent, hook.arg_);\n   }\n }\n \n void Environment::RunAndClearNativeImmediates() {\n+  TraceEventScope trace_scope(TRACING_CATEGORY_NODE1(environment),\n+                              \"RunAndClearNativeImmediates\", this);\n   size_t count = native_immediate_callbacks_.size();\n   if (count > 0) {\n     size_t ref_count = 0;\n@@ -555,6 +604,8 @@ void Environment::ToggleTimerRef(bool ref) {\n \n void Environment::RunTimers(uv_timer_t* handle) {\n   Environment* env = Environment::from_timer_handle(handle);\n+  TraceEventScope trace_scope(TRACING_CATEGORY_NODE1(environment),\n+                              \"RunTimers\", env);\n \n   if (!env->can_call_into_js())\n     return;\n@@ -615,6 +666,8 @@ void Environment::RunTimers(uv_timer_t* handle) {\n \n void Environment::CheckImmediate(uv_check_t* handle) {\n   Environment* env = Environment::from_immediate_check_handle(handle);\n+  TraceEventScope trace_scope(TRACING_CATEGORY_NODE1(environment),\n+                              \"CheckImmediate\", env);\n \n   if (env->immediate_info()->count() == 0)\n     return;"
        },
        {
            "sha": "39218d0aac225ed3952a90fff2160eb3ceee7767",
            "filename": "test/parallel/test-trace-events-environment.js",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/nodejs/node/blob/72a48a2a0abb655e7387d09c3dc7550793ce4a6a/test%2Fparallel%2Ftest-trace-events-environment.js",
            "raw_url": "https://github.com/nodejs/node/raw/72a48a2a0abb655e7387d09c3dc7550793ce4a6a/test%2Fparallel%2Ftest-trace-events-environment.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-trace-events-environment.js?ref=72a48a2a0abb655e7387d09c3dc7550793ce4a6a",
            "patch": "@@ -0,0 +1,61 @@\n+// Flags: --no-warnings\n+\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const cp = require('child_process');\n+const path = require('path');\n+const fs = require('fs');\n+const tmpdir = require('../common/tmpdir');\n+\n+// This tests the emission of node.environment trace events\n+\n+if (!common.isMainThread)\n+  common.skip('process.chdir is not available in Workers');\n+\n+const names = new Set([\n+  'Environment',\n+  'RunAndClearNativeImmediates',\n+  'CheckImmediate',\n+  'RunTimers',\n+  'BeforeExit',\n+  'RunCleanup',\n+  'AtExit'\n+]);\n+\n+if (process.argv[2] === 'child') {\n+  // This is just so that the child has something to do.\n+  1 + 1;\n+  // These ensure that the RunTimers, CheckImmediate, and\n+  // RunAndClearNativeImmediates appear in the list.\n+  setImmediate(() => { 1 + 1; });\n+  setTimeout(() => { 1 + 1; }, 1);\n+} else {\n+  tmpdir.refresh();\n+  process.chdir(tmpdir.path);\n+\n+  const proc = cp.fork(__filename,\n+                       [ 'child' ], {\n+                         execArgv: [\n+                           '--trace-event-categories',\n+                           'node.environment'\n+                         ]\n+                       });\n+\n+  proc.once('exit', common.mustCall(async () => {\n+    const file = path.join(tmpdir.path, 'node_trace.1.log');\n+    const checkSet = new Set();\n+\n+    assert(fs.existsSync(file));\n+    const data = await fs.promises.readFile(file);\n+    JSON.parse(data.toString()).traceEvents\n+      .filter((trace) => trace.cat !== '__metadata')\n+      .forEach((trace) => {\n+        assert.strictEqual(trace.pid, proc.pid);\n+        assert(names.has(trace.name));\n+        checkSet.add(trace.name);\n+      });\n+\n+    assert.deepStrictEqual(names, checkSet);\n+  }));\n+}"
        }
    ],
    "stats": {
        "total": 117,
        "additions": 116,
        "deletions": 1
    }
}