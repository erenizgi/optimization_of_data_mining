{
    "author": "tniessen",
    "message": "crypto: always accept private keys as public keys\n\nSome APIs already accept private keys instead of public keys. This\nchanges all relevant crypto APIs to do so.\n\nPR-URL: https://github.com/nodejs/node/pull/25217\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Sam Roberts <vieuxtech@gmail.com>",
    "sha": "ae2d1f0e05449221ee770a393e5c967b359d9b1b",
    "files": [
        {
            "sha": "2605393878ef5d8aa4071cf3cbd9906f6ae59956",
            "filename": "doc/api/crypto.md",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/ae2d1f0e05449221ee770a393e5c967b359d9b1b/doc%2Fapi%2Fcrypto.md",
            "raw_url": "https://github.com/nodejs/node/raw/ae2d1f0e05449221ee770a393e5c967b359d9b1b/doc%2Fapi%2Fcrypto.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fcrypto.md?ref=ae2d1f0e05449221ee770a393e5c967b359d9b1b",
            "patch": "@@ -1379,6 +1379,9 @@ This can be called many times with new data as it is streamed.\n <!-- YAML\n added: v0.1.92\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/25217\n+    description: The key can now be a private key.\n   - version: v8.0.0\n     pr-url: https://github.com/nodejs/node/pull/11705\n     description: Support for RSASSA-PSS and additional options was added.\n@@ -1419,6 +1422,9 @@ The `verify` object can not be used again after `verify.verify()` has been\n called. Multiple calls to `verify.verify()` will result in an error being\n thrown.\n \n+Because public keys can be derived from private keys, a private key may\n+be passed instead of a public key.\n+\n ## `crypto` module methods and properties\n \n ### crypto.constants\n@@ -1829,6 +1835,10 @@ must be an object with the properties described above.\n ### crypto.createPublicKey(key)\n <!-- YAML\n added: v11.6.0\n+changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/25217\n+    description: The `key` argument can now be a private key.\n -->\n * `key` {Object | string | Buffer}\n   - `key`: {string | Buffer}\n@@ -1843,6 +1853,12 @@ must be an object with the properties described above.\n \n If the format is `'pem'`, the `'key'` may also be an X.509 certificate.\n \n+Because public keys can be derived from private keys, a private key may be\n+passed instead of a public key. In that case, this function behaves as if\n+[`crypto.createPrivateKey()`][] had been called, except that the type of the\n+returned `KeyObject` will be `public` and that the private key cannot be\n+extracted from the returned `KeyObject`.\n+\n ### crypto.createSecretKey(key)\n <!-- YAML\n added: v11.6.0"
        },
        {
            "sha": "db7be824ac3e16e3b47022c27c1e73c2372ee110",
            "filename": "lib/internal/crypto/keys.js",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/ae2d1f0e05449221ee770a393e5c967b359d9b1b/lib%2Finternal%2Fcrypto%2Fkeys.js",
            "raw_url": "https://github.com/nodejs/node/raw/ae2d1f0e05449221ee770a393e5c967b359d9b1b/lib%2Finternal%2Fcrypto%2Fkeys.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fkeys.js?ref=ae2d1f0e05449221ee770a393e5c967b359d9b1b",
            "patch": "@@ -261,10 +261,6 @@ function prepareAsymmetricKey(key, isPublic, allowKeyObject = true) {\n   }\n }\n \n-function preparePublicKey(key, allowKeyObject) {\n-  return prepareAsymmetricKey(key, true, allowKeyObject);\n-}\n-\n function preparePrivateKey(key, allowKeyObject) {\n   return prepareAsymmetricKey(key, false, allowKeyObject);\n }\n@@ -300,7 +296,7 @@ function createSecretKey(key) {\n }\n \n function createPublicKey(key) {\n-  const { format, type, data } = preparePublicKey(key, false);\n+  const { format, type, data } = preparePublicOrPrivateKey(key, false);\n   const handle = new KeyObjectHandle(kKeyTypePublic);\n   handle.init(data, format, type);\n   return new PublicKeyObject(handle);\n@@ -326,7 +322,6 @@ module.exports = {\n   // These are designed for internal use only and should not be exposed.\n   parsePublicKeyEncoding,\n   parsePrivateKeyEncoding,\n-  preparePublicKey,\n   preparePrivateKey,\n   preparePublicOrPrivateKey,\n   prepareSecretKey,"
        },
        {
            "sha": "4a0c66f9cf5a700f7de748731a3329baa0341acc",
            "filename": "lib/internal/crypto/sig.js",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/ae2d1f0e05449221ee770a393e5c967b359d9b1b/lib%2Finternal%2Fcrypto%2Fsig.js",
            "raw_url": "https://github.com/nodejs/node/raw/ae2d1f0e05449221ee770a393e5c967b359d9b1b/lib%2Finternal%2Fcrypto%2Fsig.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fsig.js?ref=ae2d1f0e05449221ee770a393e5c967b359d9b1b",
            "patch": "@@ -19,7 +19,7 @@ const {\n } = require('internal/crypto/util');\n const {\n   preparePrivateKey,\n-  preparePublicKey\n+  preparePublicOrPrivateKey\n } = require('internal/crypto/keys');\n const { Writable } = require('stream');\n \n@@ -112,8 +112,9 @@ Verify.prototype.verify = function verify(options, signature, sigEncoding) {\n   const {\n     data,\n     format,\n-    type\n-  } = preparePublicKey(options, true);\n+    type,\n+    passphrase\n+  } = preparePublicOrPrivateKey(options, true);\n \n   sigEncoding = sigEncoding || getDefaultEncoding();\n \n@@ -125,7 +126,7 @@ Verify.prototype.verify = function verify(options, signature, sigEncoding) {\n   signature = validateArrayBufferView(toBuf(signature, sigEncoding),\n                                       'signature');\n \n-  return this[kHandle].verify(data, format, type, signature,\n+  return this[kHandle].verify(data, format, type, passphrase, signature,\n                               rsaPadding, pssSaltLength);\n };\n "
        },
        {
            "sha": "ff3713eeecb13364b43edddc3b9b450861393c5a",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 26,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/ae2d1f0e05449221ee770a393e5c967b359d9b1b/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ae2d1f0e05449221ee770a393e5c967b359d9b1b/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=ae2d1f0e05449221ee770a393e5c967b359d9b1b",
            "patch": "@@ -3012,30 +3012,6 @@ static PublicKeyEncodingConfig GetPublicKeyEncodingFromJs(\n   return result;\n }\n \n-static ManagedEVPPKey GetPublicKeyFromJs(\n-    const FunctionCallbackInfo<Value>& args,\n-    unsigned int* offset,\n-    bool allow_key_object) {\n-  if (args[*offset]->IsString() || Buffer::HasInstance(args[*offset])) {\n-    Environment* env = Environment::GetCurrent(args);\n-    ByteSource key = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);\n-    PublicKeyEncodingConfig config =\n-        GetPublicKeyEncodingFromJs(args, offset, kKeyContextInput);\n-    EVPKeyPointer pkey;\n-    ParsePublicKey(&pkey, config, key.get(), key.size());\n-    if (!pkey)\n-      ThrowCryptoError(env, ERR_get_error(), \"Failed to read public key\");\n-    return ManagedEVPPKey(pkey.release());\n-  } else {\n-    CHECK(args[*offset]->IsObject() && allow_key_object);\n-    KeyObject* key;\n-    ASSIGN_OR_RETURN_UNWRAP(&key, args[*offset].As<Object>(), ManagedEVPPKey());\n-    CHECK_EQ(key->GetKeyType(), kKeyTypePublic);\n-    (*offset) += 3;\n-    return key->GetAsymmetricKey();\n-  }\n-}\n-\n static NonCopyableMaybe<PrivateKeyEncodingConfig> GetPrivateKeyEncodingFromJs(\n     const FunctionCallbackInfo<Value>& args,\n     unsigned int* offset,\n@@ -3397,7 +3373,7 @@ void KeyObject::Init(const FunctionCallbackInfo<Value>& args) {\n     CHECK_EQ(args.Length(), 3);\n \n     offset = 0;\n-    pkey = GetPublicKeyFromJs(args, &offset, false);\n+    pkey = GetPublicOrPrivateKeyFromJs(args, &offset, false);\n     if (!pkey)\n       return;\n     key->InitPublic(pkey);\n@@ -4679,7 +4655,7 @@ void Verify::VerifyFinal(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());\n \n   unsigned int offset = 0;\n-  ManagedEVPPKey pkey = GetPublicKeyFromJs(args, &offset, true);\n+  ManagedEVPPKey pkey = GetPublicOrPrivateKeyFromJs(args, &offset, true);\n \n   char* hbuf = Buffer::Data(args[offset]);\n   ssize_t hlen = Buffer::Length(args[offset]);"
        },
        {
            "sha": "61cd69b5d6acd779989112fd28a8a4ab98fb8228",
            "filename": "test/parallel/test-crypto-keygen.js",
            "status": "modified",
            "additions": 10,
            "deletions": 6,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/ae2d1f0e05449221ee770a393e5c967b359d9b1b/test%2Fparallel%2Ftest-crypto-keygen.js",
            "raw_url": "https://github.com/nodejs/node/raw/ae2d1f0e05449221ee770a393e5c967b359d9b1b/test%2Fparallel%2Ftest-crypto-keygen.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-keygen.js?ref=ae2d1f0e05449221ee770a393e5c967b359d9b1b",
            "patch": "@@ -31,19 +31,23 @@ function assertApproximateSize(key, expectedSize) {\n function testEncryptDecrypt(publicKey, privateKey) {\n   const message = 'Hello Node.js world!';\n   const plaintext = Buffer.from(message, 'utf8');\n-  const ciphertext = publicEncrypt(publicKey, plaintext);\n-  const received = privateDecrypt(privateKey, ciphertext);\n-  assert.strictEqual(received.toString('utf8'), message);\n+  for (const key of [publicKey, privateKey]) {\n+    const ciphertext = publicEncrypt(key, plaintext);\n+    const received = privateDecrypt(privateKey, ciphertext);\n+    assert.strictEqual(received.toString('utf8'), message);\n+  }\n }\n \n // Tests that a key pair can be used for signing / verification.\n function testSignVerify(publicKey, privateKey) {\n   const message = 'Hello Node.js world!';\n   const signature = createSign('SHA256').update(message)\n                                         .sign(privateKey, 'hex');\n-  const okay = createVerify('SHA256').update(message)\n-                                     .verify(publicKey, signature, 'hex');\n-  assert(okay);\n+  for (const key of [publicKey, privateKey]) {\n+    const okay = createVerify('SHA256').update(message)\n+                                       .verify(key, signature, 'hex');\n+    assert(okay);\n+  }\n }\n \n // Constructs a regular expression for a PEM-encoded key with the given label."
        }
    ],
    "stats": {
        "total": 76,
        "additions": 34,
        "deletions": 42
    }
}