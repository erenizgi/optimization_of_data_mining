{
    "author": "addaleax",
    "message": "test: fix flaky async-hooks/test-zlib.zlib-binding.deflate\n\nPreviously, the typed arrays used in this test would not\nautomatically be kept alive by the native handle when\nitâ€™s using them, so the V8 garbage collector could collect\nthem while they are still in use by the zlib module,\nleading to memory corruption.\n\nFixes: https://github.com/nodejs/node/issues/20907\n\nPR-URL: https://github.com/nodejs/node/pull/21077\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Jeremiah Senkpiel <fishrock123@rocketmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Rich Trott <rtrott@gmail.com>\nReviewed-By: Yang Guo <yangguo@chromium.org>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "2efe4c29fe115db6d6f88056c91739590034d0d2",
    "files": [
        {
            "sha": "ddcba9d89630f72b2459f5e559360a0251076150",
            "filename": "test/async-hooks/test-zlib.zlib-binding.deflate.js",
            "status": "modified",
            "additions": 16,
            "deletions": 7,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/2efe4c29fe115db6d6f88056c91739590034d0d2/test%2Fasync-hooks%2Ftest-zlib.zlib-binding.deflate.js",
            "raw_url": "https://github.com/nodejs/node/raw/2efe4c29fe115db6d6f88056c91739590034d0d2/test%2Fasync-hooks%2Ftest-zlib.zlib-binding.deflate.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fasync-hooks%2Ftest-zlib.zlib-binding.deflate.js?ref=2efe4c29fe115db6d6f88056c91739590034d0d2",
            "patch": "@@ -21,31 +21,37 @@ assert.strictEqual(typeof hdl.uid, 'number');\n assert.strictEqual(typeof hdl.triggerAsyncId, 'number');\n checkInvocations(hdl, { init: 1 }, 'when created handle');\n \n+// Store all buffers together so that they do not get\n+// garbage collected.\n+const buffers = {\n+  writeResult: new Uint32Array(2),\n+  dictionary: new Uint8Array(0),\n+  inBuf: new Uint8Array([0x78]),\n+  outBuf: new Uint8Array(1)\n+};\n+\n handle.init(\n   constants.Z_DEFAULT_WINDOWBITS,\n   constants.Z_MIN_LEVEL,\n   constants.Z_DEFAULT_MEMLEVEL,\n   constants.Z_DEFAULT_STRATEGY,\n-  new Uint32Array(2),\n+  buffers.writeResult,\n   function processCallback() { this.cb(); },\n-  Buffer.from('')\n+  buffers.dictionary\n );\n checkInvocations(hdl, { init: 1 }, 'when initialized handle');\n \n-const inBuf = Buffer.from('x');\n-const outBuf = Buffer.allocUnsafe(1);\n-\n let count = 2;\n handle.cb = common.mustCall(onwritten, 2);\n-handle.write(true, inBuf, 0, 1, outBuf, 0, 1);\n+handle.write(true, buffers.inBuf, 0, 1, buffers.outBuf, 0, 1);\n checkInvocations(hdl, { init: 1 }, 'when invoked write() on handle');\n \n function onwritten() {\n   if (--count) {\n     // first write\n     checkInvocations(hdl, { init: 1, before: 1 },\n                      'when wrote to handle the first time');\n-    handle.write(true, inBuf, 0, 1, outBuf, 0, 1);\n+    handle.write(true, buffers.inBuf, 0, 1, buffers.outBuf, 0, 1);\n   } else {\n     // second write\n     checkInvocations(hdl, { init: 1, before: 2, after: 1 },\n@@ -61,4 +67,7 @@ function onexit() {\n   // TODO: destroy never called here even with large amounts of ticks\n   // is that correct?\n   checkInvocations(hdl, { init: 1, before: 2, after: 2 }, 'when process exits');\n+\n+  // Do something with `buffers` to keep them alive until here.\n+  buffers.buffers = buffers;\n }"
        }
    ],
    "stats": {
        "total": 23,
        "additions": 16,
        "deletions": 7
    }
}