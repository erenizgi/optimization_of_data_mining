{
    "author": "tniessen",
    "message": "crypto: add support for AES-CCM\n\nThis commit adds support for another AEAD algorithm and introduces\nrequired API changes and extensions. Due to the design of CCM itself and\nthe way OpenSSL implements it, there are some restrictions when using\nthis mode as outlined in the updated documentation.\n\nPR-URL: https://github.com/nodejs/node/pull/18138\nFixes: https://github.com/nodejs/node/issues/2383\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Shigeki Ohtsu <ohtsu@ohtsu.org>\nReviewed-By: Rod Vagg <rod@vagg.org>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "1e07acd476309e7ddc4981160b89731b61a31179",
    "files": [
        {
            "sha": "5064d1a7b267b4db228c597d49e498f5377c673a",
            "filename": "doc/api/crypto.md",
            "status": "modified",
            "additions": 97,
            "deletions": 8,
            "changes": 105,
            "blob_url": "https://github.com/nodejs/node/blob/1e07acd476309e7ddc4981160b89731b61a31179/doc%2Fapi%2Fcrypto.md",
            "raw_url": "https://github.com/nodejs/node/raw/1e07acd476309e7ddc4981160b89731b61a31179/doc%2Fapi%2Fcrypto.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fcrypto.md?ref=1e07acd476309e7ddc4981160b89731b61a31179",
            "patch": "@@ -241,17 +241,22 @@ Once the `cipher.final()` method has been called, the `Cipher` object can no\n longer be used to encrypt data. Attempts to call `cipher.final()` more than\n once will result in an error being thrown.\n \n-### cipher.setAAD(buffer)\n+### cipher.setAAD(buffer[, options])\n <!-- YAML\n added: v1.0.0\n -->\n - `buffer` {Buffer}\n+- `options` {object}\n - Returns the {Cipher} for method chaining.\n \n-When using an authenticated encryption mode (only `GCM` is currently\n+When using an authenticated encryption mode (only `GCM` and `CCM` are currently\n supported), the `cipher.setAAD()` method sets the value used for the\n _additional authenticated data_ (AAD) input parameter.\n \n+The `options` argument is optional for `GCM`. When using `CCM`, the\n+`plaintextLength` option must be specified and its value must match the length\n+of the plaintext in bytes. See [CCM mode][].\n+\n The `cipher.setAAD()` method must be called before [`cipher.update()`][].\n \n ### cipher.getAuthTag()\n@@ -1312,7 +1317,12 @@ deprecated: REPLACEME\n - `options` {Object} [`stream.transform` options][]\n \n Creates and returns a `Cipher` object that uses the given `algorithm` and\n-`password`. Optional `options` argument controls stream behavior.\n+`password`.\n+\n+The `options` argument controls stream behavior and is optional except when a\n+cipher in CCM mode is used (e.g. `'aes-128-ccm'`). In that case, the\n+`authTagLength` option is required and specifies the length of the\n+authentication tag in bytes, see [CCM mode][].\n \n The `algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc. On\n recent OpenSSL releases, `openssl list-cipher-algorithms` will display the\n@@ -1353,8 +1363,10 @@ changes:\n - `options` {Object} [`stream.transform` options][]\n \n Creates and returns a `Cipher` object, with the given `algorithm`, `key` and\n-initialization vector (`iv`). Optional `options` argument controls stream\n-behavior.\n+The `options` argument controls stream behavior and is optional except when a\n+cipher in CCM mode is used (e.g. `'aes-128-ccm'`). In that case, the\n+`authTagLength` option is required and specifies the length of the\n+authentication tag in bytes, see [CCM mode][].\n \n The `algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc. On\n recent OpenSSL releases, `openssl list-cipher-algorithms` will display the\n@@ -1396,7 +1408,12 @@ deprecated: REPLACEME\n - `options` {Object} [`stream.transform` options][]\n \n Creates and returns a `Decipher` object that uses the given `algorithm` and\n-`password` (key). Optional `options` argument controls stream behavior.\n+`password` (key).\n+\n+The `options` argument controls stream behavior and is optional except when a\n+cipher in CCM mode is used (e.g. `'aes-128-ccm'`). In that case, the\n+`authTagLength` option is required and specifies the length of the\n+authentication tag in bytes, see [CCM mode][].\n \n The implementation of `crypto.createDecipher()` derives keys using the OpenSSL\n function [`EVP_BytesToKey`][] with the digest algorithm set to MD5, one\n@@ -1425,8 +1442,12 @@ changes:\n - `options` {Object} [`stream.transform` options][]\n \n Creates and returns a `Decipher` object that uses the given `algorithm`, `key`\n-and initialization vector (`iv`). Optional `options` argument controls stream\n-behavior.\n+and initialization vector (`iv`).\n+\n+The `options` argument controls stream behavior and is optional except when a\n+cipher in CCM mode is used (e.g. `'aes-128-ccm'`). In that case, the\n+`authTagLength` option is required and specifies the length of the\n+authentication tag in bytes, see [CCM mode][].\n \n The `algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc. On\n recent OpenSSL releases, `openssl list-cipher-algorithms` will display the\n@@ -2167,6 +2188,71 @@ Based on the recommendations of [NIST SP 800-131A][]:\n \n See the reference for other recommendations and details.\n \n+### CCM mode\n+\n+CCM is one of the two supported [AEAD algorithms][]. Applications which use this\n+mode must adhere to certain restrictions when using the cipher API:\n+\n+- The authentication tag length must be specified during cipher creation by\n+  setting the `authTagLength` option and must be one of 4, 6, 8, 10, 12, 14 or\n+  16 bytes.\n+- The length of the initialization vector (nonce) `N` must be between 7 and 13\n+  bytes (`7 ≤ N ≤ 13`).\n+- The length of the plaintext is limited to `2 ** (8 * (15 - N))` bytes.\n+- When decrypting, the authentication tag must be set via `setAuthTag()` before\n+  specifying additional authenticated data and / or calling `update()`.\n+  Otherwise, decryption will fail and `final()` will throw an error in\n+  compliance with section 2.6 of [RFC 3610][].\n+- Using stream methods such as `write(data)`, `end(data)` or `pipe()` in CCM\n+  mode might fail as CCM cannot handle more than one chunk of data per instance.\n+- When passing additional authenticated data (AAD), the length of the actual\n+  message in bytes must be passed to `setAAD()` via the `plaintextLength`\n+  option. This is not necessary if no AAD is used.\n+- As CCM processes the whole message at once, `update()` can only be called\n+  once.\n+- Even though calling `update()` is sufficient to encrypt / decrypt the message,\n+  applications *must* call `final()` to compute and / or verify the\n+  authentication tag.\n+\n+```js\n+const crypto = require('crypto');\n+\n+const key = 'keykeykeykeykeykeykeykey';\n+const nonce = crypto.randomBytes(12);\n+\n+const aad = Buffer.from('0123456789', 'hex');\n+\n+const cipher = crypto.createCipheriv('aes-192-ccm', key, nonce, {\n+  authTagLength: 16\n+});\n+const plaintext = 'Hello world';\n+cipher.setAAD(aad, {\n+  plaintextLength: Buffer.byteLength(plaintext)\n+});\n+const ciphertext = cipher.update(plaintext, 'utf8');\n+cipher.final();\n+const tag = cipher.getAuthTag();\n+\n+// Now transmit { ciphertext, tag }.\n+\n+const decipher = crypto.createDecipheriv('aes-192-ccm', key, nonce, {\n+  authTagLength: 16\n+});\n+decipher.setAuthTag(tag);\n+decipher.setAAD(aad, {\n+  plaintextLength: ciphertext.length\n+});\n+const receivedPlaintext = decipher.update(ciphertext, null, 'utf8');\n+\n+try {\n+  decipher.final();\n+} catch (err) {\n+  console.error('Authentication failed!');\n+}\n+\n+console.log(receivedPlaintext);\n+```\n+\n ## Crypto Constants\n \n The following constants exported by `crypto.constants` apply to various uses of\n@@ -2525,7 +2611,9 @@ the `crypto`, `tls`, and `https` modules and are generally specific to OpenSSL.\n [`tls.createSecureContext()`]: tls.html#tls_tls_createsecurecontext_options\n [`verify.update()`]: #crypto_verify_update_data_inputencoding\n [`verify.verify()`]: #crypto_verify_verify_object_signature_signatureformat\n+[AEAD algorithms]: https://en.wikipedia.org/wiki/Authenticated_encryption\n [Caveats]: #crypto_support_for_weak_or_compromised_algorithms\n+[CCM mode]: #crypto_ccm_mode\n [Crypto Constants]: #crypto_crypto_constants_1\n [HTML 5.2]: https://www.w3.org/TR/html52/changes.html#features-removed\n [HTML5's `keygen` element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/keygen\n@@ -2536,6 +2624,7 @@ the `crypto`, `tls`, and `https` modules and are generally specific to OpenSSL.\n [OpenSSL's SPKAC implementation]: https://www.openssl.org/docs/man1.0.2/apps/spkac.html\n [RFC 2412]: https://www.rfc-editor.org/rfc/rfc2412.txt\n [RFC 3526]: https://www.rfc-editor.org/rfc/rfc3526.txt\n+[RFC 3610]: https://www.rfc-editor.org/rfc/rfc3610.txt\n [RFC 4055]: https://www.rfc-editor.org/rfc/rfc4055.txt\n [initialization vector]: https://en.wikipedia.org/wiki/Initialization_vector\n [stream-writable-write]: stream.html#stream_writable_write_chunk_encoding_callback"
        },
        {
            "sha": "d33a970148f52afd9e9fac62b1354fbfeedd6671",
            "filename": "lib/internal/crypto/cipher.js",
            "status": "modified",
            "additions": 28,
            "deletions": 7,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/1e07acd476309e7ddc4981160b89731b61a31179/lib%2Finternal%2Fcrypto%2Fcipher.js",
            "raw_url": "https://github.com/nodejs/node/raw/1e07acd476309e7ddc4981160b89731b61a31179/lib%2Finternal%2Fcrypto%2Fcipher.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fcipher.js?ref=1e07acd476309e7ddc4981160b89731b61a31179",
            "patch": "@@ -7,7 +7,8 @@ const {\n \n const {\n   ERR_CRYPTO_INVALID_STATE,\n-  ERR_INVALID_ARG_TYPE\n+  ERR_INVALID_ARG_TYPE,\n+  ERR_INVALID_OPT_VALUE\n } = require('internal/errors').codes;\n \n const {\n@@ -62,6 +63,16 @@ function getDecoder(decoder, encoding) {\n   return decoder;\n }\n \n+function getUIntOption(options, key) {\n+  let value;\n+  if (options && (value = options[key]) != null) {\n+    if (value >>> 0 !== value)\n+      throw new ERR_INVALID_OPT_VALUE(key, value);\n+    return value;\n+  }\n+  return -1;\n+}\n+\n function Cipher(cipher, password, options) {\n   if (!(this instanceof Cipher))\n     return new Cipher(cipher, password, options);\n@@ -78,9 +89,11 @@ function Cipher(cipher, password, options) {\n     );\n   }\n \n+  const authTagLength = getUIntOption(options, 'authTagLength');\n+\n   this._handle = new CipherBase(true);\n \n-  this._handle.init(cipher, password);\n+  this._handle.init(cipher, password, authTagLength);\n   this._decoder = null;\n \n   LazyTransform.call(this, options);\n@@ -168,13 +181,15 @@ Cipher.prototype.setAuthTag = function setAuthTag(tagbuf) {\n   return this;\n };\n \n-Cipher.prototype.setAAD = function setAAD(aadbuf) {\n+Cipher.prototype.setAAD = function setAAD(aadbuf, options) {\n   if (!isArrayBufferView(aadbuf)) {\n     throw new ERR_INVALID_ARG_TYPE('buffer',\n                                    ['Buffer', 'TypedArray', 'DataView'],\n                                    aadbuf);\n   }\n-  if (this._handle.setAAD(aadbuf) === false)\n+\n+  const plaintextLength = getUIntOption(options, 'plaintextLength');\n+  if (this._handle.setAAD(aadbuf, plaintextLength) === false)\n     throw new ERR_CRYPTO_INVALID_STATE('setAAD');\n   return this;\n };\n@@ -204,8 +219,10 @@ function Cipheriv(cipher, key, iv, options) {\n     );\n   }\n \n+  const authTagLength = getUIntOption(options, 'authTagLength');\n+\n   this._handle = new CipherBase(true);\n-  this._handle.initiv(cipher, key, iv);\n+  this._handle.initiv(cipher, key, iv, authTagLength);\n   this._decoder = null;\n \n   LazyTransform.call(this, options);\n@@ -243,8 +260,10 @@ function Decipher(cipher, password, options) {\n     );\n   }\n \n+  const authTagLength = getUIntOption(options, 'authTagLength');\n+\n   this._handle = new CipherBase(false);\n-  this._handle.init(cipher, password);\n+  this._handle.init(cipher, password, authTagLength);\n   this._decoder = null;\n \n   LazyTransform.call(this, options);\n@@ -288,8 +307,10 @@ function Decipheriv(cipher, key, iv, options) {\n     );\n   }\n \n+  const authTagLength = getUIntOption(options, 'authTagLength');\n+\n   this._handle = new CipherBase(false);\n-  this._handle.initiv(cipher, key, iv);\n+  this._handle.initiv(cipher, key, iv, authTagLength);\n   this._decoder = null;\n \n   LazyTransform.call(this, options);"
        },
        {
            "sha": "52673b59da6f317998100a0655e3f71f09c983ad",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 201,
            "deletions": 55,
            "changes": 256,
            "blob_url": "https://github.com/nodejs/node/blob/1e07acd476309e7ddc4981160b89731b61a31179/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1e07acd476309e7ddc4981160b89731b61a31179/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=1e07acd476309e7ddc4981160b89731b61a31179",
            "patch": "@@ -2802,7 +2802,8 @@ void CipherBase::New(const FunctionCallbackInfo<Value>& args) {\n \n void CipherBase::Init(const char* cipher_type,\n                       const char* key_buf,\n-                      int key_buf_len) {\n+                      int key_buf_len,\n+                      int auth_tag_len) {\n   HandleScope scope(env()->isolate());\n \n #ifdef NODE_FIPS_MODE\n@@ -2847,6 +2848,12 @@ void CipherBase::Init(const char* cipher_type,\n   if (mode == EVP_CIPH_WRAP_MODE)\n     EVP_CIPHER_CTX_set_flags(ctx_, EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);\n \n+  if (IsAuthenticatedMode()) {\n+    if (!InitAuthenticated(cipher_type, EVP_CIPHER_iv_length(cipher),\n+                           auth_tag_len))\n+      return;\n+  }\n+\n   CHECK_EQ(1, EVP_CIPHER_CTX_set_key_length(ctx_, key_len));\n \n   EVP_CipherInit_ex(ctx_,\n@@ -2862,20 +2869,26 @@ void CipherBase::Init(const FunctionCallbackInfo<Value>& args) {\n   CipherBase* cipher;\n   ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());\n \n-  CHECK_GE(args.Length(), 2);\n+  CHECK_GE(args.Length(), 3);\n \n   const node::Utf8Value cipher_type(args.GetIsolate(), args[0]);\n   const char* key_buf = Buffer::Data(args[1]);\n   ssize_t key_buf_len = Buffer::Length(args[1]);\n-  cipher->Init(*cipher_type, key_buf, key_buf_len);\n+  CHECK(args[2]->IsInt32());\n+  // Don't assign to cipher->auth_tag_len_ directly; the value might not\n+  // represent a valid length at this point.\n+  int auth_tag_len = args[2].As<v8::Int32>()->Value();\n+\n+  cipher->Init(*cipher_type, key_buf, key_buf_len, auth_tag_len);\n }\n \n \n void CipherBase::InitIv(const char* cipher_type,\n                         const char* key,\n                         int key_len,\n                         const char* iv,\n-                        int iv_len) {\n+                        int iv_len,\n+                        int auth_tag_len) {\n   HandleScope scope(env()->isolate());\n \n   const EVP_CIPHER* const cipher = EVP_get_cipherbyname(cipher_type);\n@@ -2886,6 +2899,7 @@ void CipherBase::InitIv(const char* cipher_type,\n   const int expected_iv_len = EVP_CIPHER_iv_length(cipher);\n   const int mode = EVP_CIPHER_mode(cipher);\n   const bool is_gcm_mode = (EVP_CIPH_GCM_MODE == mode);\n+  const bool is_ccm_mode = (EVP_CIPH_CCM_MODE == mode);\n   const bool has_iv = iv_len >= 0;\n \n   // Throw if no IV was passed and the cipher requires an IV\n@@ -2896,7 +2910,7 @@ void CipherBase::InitIv(const char* cipher_type,\n   }\n \n   // Throw if an IV was passed which does not match the cipher's fixed IV length\n-  if (is_gcm_mode == false && has_iv && iv_len != expected_iv_len) {\n+  if (!is_gcm_mode && !is_ccm_mode && has_iv && iv_len != expected_iv_len) {\n     return env()->ThrowError(\"Invalid IV length\");\n   }\n \n@@ -2908,13 +2922,10 @@ void CipherBase::InitIv(const char* cipher_type,\n   const bool encrypt = (kind_ == kCipher);\n   EVP_CipherInit_ex(ctx_, cipher, nullptr, nullptr, nullptr, encrypt);\n \n-  if (is_gcm_mode) {\n+  if (IsAuthenticatedMode()) {\n     CHECK(has_iv);\n-    if (!EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_GCM_SET_IVLEN, iv_len, nullptr)) {\n-      EVP_CIPHER_CTX_free(ctx_);\n-      ctx_ = nullptr;\n-      return env()->ThrowError(\"Invalid IV length\");\n-    }\n+    if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))\n+      return;\n   }\n \n   if (!EVP_CIPHER_CTX_set_key_length(ctx_, key_len)) {\n@@ -2937,7 +2948,7 @@ void CipherBase::InitIv(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());\n   Environment* env = cipher->env();\n \n-  CHECK_GE(args.Length(), 3);\n+  CHECK_GE(args.Length(), 4);\n \n   const node::Utf8Value cipher_type(env->isolate(), args[0]);\n   ssize_t key_len = Buffer::Length(args[1]);\n@@ -2951,16 +2962,84 @@ void CipherBase::InitIv(const FunctionCallbackInfo<Value>& args) {\n     iv_buf = Buffer::Data(args[2]);\n     iv_len = Buffer::Length(args[2]);\n   }\n-  cipher->InitIv(*cipher_type, key_buf, key_len, iv_buf, iv_len);\n+  CHECK(args[3]->IsInt32());\n+  // Don't assign to cipher->auth_tag_len_ directly; the value might not\n+  // represent a valid length at this point.\n+  int auth_tag_len = args[3].As<v8::Int32>()->Value();\n+\n+  cipher->InitIv(*cipher_type, key_buf, key_len, iv_buf, iv_len, auth_tag_len);\n+}\n+\n+\n+bool CipherBase::InitAuthenticated(const char *cipher_type, int iv_len,\n+                                   int auth_tag_len) {\n+  CHECK(IsAuthenticatedMode());\n+\n+  // TODO(tniessen) Use EVP_CTRL_AEAD_SET_IVLEN when migrating to OpenSSL 1.1.0\n+  static_assert(EVP_CTRL_CCM_SET_IVLEN == EVP_CTRL_GCM_SET_IVLEN,\n+                \"OpenSSL constants differ between GCM and CCM\");\n+  if (!EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_GCM_SET_IVLEN, iv_len, nullptr)) {\n+    env()->ThrowError(\"Invalid IV length\");\n+    return false;\n+  }\n+\n+  if (EVP_CIPHER_CTX_mode(ctx_) == EVP_CIPH_CCM_MODE) {\n+    if (auth_tag_len < 0) {\n+      char msg[128];\n+      snprintf(msg, sizeof(msg), \"authTagLength required for %s\", cipher_type);\n+      env()->ThrowError(msg);\n+      return false;\n+    }\n+\n+#ifdef NODE_FIPS_MODE\n+    // TODO(tniessen) Support CCM decryption in FIPS mode\n+    if (kind_ == kDecipher && FIPS_mode()) {\n+      env()->ThrowError(\"CCM decryption not supported in FIPS mode\");\n+      return false;\n+    }\n+#endif\n+\n+    if (!EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_CCM_SET_TAG, auth_tag_len,\n+        nullptr)) {\n+      env()->ThrowError(\"Invalid authentication tag length\");\n+      return false;\n+    }\n+\n+    // When decrypting in CCM mode, this field will be set in setAuthTag().\n+    if (kind_ == kCipher)\n+      auth_tag_len_ = auth_tag_len;\n+\n+    // The message length is restricted to 2 ^ (8 * (15 - iv_len)) - 1 bytes.\n+    CHECK(iv_len >= 7 && iv_len <= 13);\n+    if (iv_len >= static_cast<int>(15.5 - log2(INT_MAX + 1.) / 8)) {\n+      max_message_size_ = (1 << (8 * (15 - iv_len))) - 1;\n+    } else {\n+      max_message_size_ = INT_MAX;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+\n+bool CipherBase::CheckCCMMessageLength(int message_len) {\n+  CHECK_NE(ctx_, nullptr);\n+  CHECK(EVP_CIPHER_CTX_mode(ctx_) == EVP_CIPH_CCM_MODE);\n+\n+  if (message_len > max_message_size_) {\n+    env()->ThrowError(\"Message exceeds maximum size\");\n+    return false;\n+  }\n+\n+  return true;\n }\n \n \n bool CipherBase::IsAuthenticatedMode() const {\n   // Check if this cipher operates in an AEAD mode that we support.\n   CHECK_NE(ctx_, nullptr);\n-  const EVP_CIPHER* const cipher = EVP_CIPHER_CTX_cipher(ctx_);\n-  int mode = EVP_CIPHER_mode(cipher);\n-  return mode == EVP_CIPH_GCM_MODE;\n+  const int mode = EVP_CIPHER_CTX_mode(ctx_);\n+  return mode == EVP_CIPH_GCM_MODE || mode == EVP_CIPH_CCM_MODE;\n }\n \n \n@@ -2995,12 +3074,15 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {\n \n   // Restrict GCM tag lengths according to NIST 800-38d, page 9.\n   unsigned int tag_len = Buffer::Length(args[0]);\n-  if (tag_len > 16 || (tag_len < 12 && tag_len != 8 && tag_len != 4)) {\n-    char msg[125];\n-    snprintf(msg, sizeof(msg),\n-             \"Permitting authentication tag lengths of %u bytes is deprecated. \"\n-             \"Valid GCM tag lengths are 4, 8, 12, 13, 14, 15, 16.\", tag_len);\n-    ProcessEmitDeprecationWarning(cipher->env(), msg, \"DEP0090\");\n+  const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_);\n+  if (mode == EVP_CIPH_GCM_MODE) {\n+    if (tag_len > 16 || (tag_len < 12 && tag_len != 8 && tag_len != 4)) {\n+      char msg[125];\n+      snprintf(msg, sizeof(msg),\n+          \"Permitting authentication tag lengths of %u bytes is deprecated. \"\n+          \"Valid GCM tag lengths are 4, 8, 12, 13, 14, 15, 16.\", tag_len);\n+      ProcessEmitDeprecationWarning(cipher->env(), msg, \"DEP0090\");\n+    }\n   }\n \n   // Note: we don't use std::max() here to work around a header conflict.\n@@ -3013,53 +3095,100 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n-bool CipherBase::SetAAD(const char* data, unsigned int len) {\n+bool CipherBase::SetAAD(const char* data, unsigned int len, int plaintext_len) {\n   if (ctx_ == nullptr || !IsAuthenticatedMode())\n     return false;\n+\n   int outlen;\n-  if (!EVP_CipherUpdate(ctx_,\n-                        nullptr,\n-                        &outlen,\n-                        reinterpret_cast<const unsigned char*>(data),\n-                        len)) {\n-    return false;\n+  const int mode = EVP_CIPHER_CTX_mode(ctx_);\n+\n+  // When in CCM mode, we need to set the authentication tag and the plaintext\n+  // length in advance.\n+  if (mode == EVP_CIPH_CCM_MODE) {\n+    if (plaintext_len < 0) {\n+      env()->ThrowError(\"plaintextLength required for CCM mode with AAD\");\n+      return false;\n+    }\n+\n+    if (!CheckCCMMessageLength(plaintext_len))\n+      return false;\n+\n+    if (kind_ == kDecipher && !auth_tag_set_ && auth_tag_len_ > 0) {\n+      if (!EVP_CIPHER_CTX_ctrl(ctx_,\n+                               EVP_CTRL_CCM_SET_TAG,\n+                               auth_tag_len_,\n+                               reinterpret_cast<unsigned char*>(auth_tag_))) {\n+        return false;\n+      }\n+      auth_tag_set_ = true;\n+    }\n+\n+    // Specify the plaintext length.\n+    if (!EVP_CipherUpdate(ctx_, nullptr, &outlen, nullptr, plaintext_len))\n+      return false;\n   }\n-  return true;\n+\n+  return 1 == EVP_CipherUpdate(ctx_,\n+                               nullptr,\n+                               &outlen,\n+                               reinterpret_cast<const unsigned char*>(data),\n+                               len);\n }\n \n \n void CipherBase::SetAAD(const FunctionCallbackInfo<Value>& args) {\n   CipherBase* cipher;\n   ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());\n \n-  if (!cipher->SetAAD(Buffer::Data(args[0]), Buffer::Length(args[0])))\n+  CHECK_EQ(args.Length(), 2);\n+  CHECK(args[1]->IsInt32());\n+  int plaintext_len = args[1].As<v8::Int32>()->Value();\n+\n+  if (!cipher->SetAAD(Buffer::Data(args[0]), Buffer::Length(args[0]),\n+                      plaintext_len))\n     args.GetReturnValue().Set(false);  // Report invalid state failure\n }\n \n \n-bool CipherBase::Update(const char* data,\n-                        int len,\n-                        unsigned char** out,\n-                        int* out_len) {\n+CipherBase::UpdateResult CipherBase::Update(const char* data,\n+                                            int len,\n+                                            unsigned char** out,\n+                                            int* out_len) {\n   if (ctx_ == nullptr)\n-    return false;\n+    return kErrorState;\n+\n+  const int mode = EVP_CIPHER_CTX_mode(ctx_);\n+\n+  if (mode == EVP_CIPH_CCM_MODE) {\n+    if (!CheckCCMMessageLength(len))\n+      return kErrorMessageSize;\n+  }\n \n   // on first update:\n-  if (kind_ == kDecipher && IsAuthenticatedMode() && auth_tag_len_ > 0) {\n+  if (kind_ == kDecipher && IsAuthenticatedMode() && auth_tag_len_ > 0 &&\n+      !auth_tag_set_) {\n     EVP_CIPHER_CTX_ctrl(ctx_,\n                         EVP_CTRL_GCM_SET_TAG,\n                         auth_tag_len_,\n                         reinterpret_cast<unsigned char*>(auth_tag_));\n-    auth_tag_len_ = 0;\n+    auth_tag_set_ = true;\n   }\n \n   *out_len = len + EVP_CIPHER_CTX_block_size(ctx_);\n   *out = Malloc<unsigned char>(static_cast<size_t>(*out_len));\n-  return EVP_CipherUpdate(ctx_,\n-                          *out,\n-                          out_len,\n-                          reinterpret_cast<const unsigned char*>(data),\n-                          len);\n+  int r = EVP_CipherUpdate(ctx_,\n+                           *out,\n+                           out_len,\n+                           reinterpret_cast<const unsigned char*>(data),\n+                           len);\n+\n+  // When in CCM mode, EVP_CipherUpdate will fail if the authentication tag is\n+  // invalid. In that case, remember the error and throw in final().\n+  if (!r && kind_ == kDecipher && mode == EVP_CIPH_CCM_MODE) {\n+    pending_auth_failed_ = true;\n+    return kSuccess;\n+  }\n+  return r == 1 ? kSuccess : kErrorState;\n }\n \n \n@@ -3070,7 +3199,7 @@ void CipherBase::Update(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());\n \n   unsigned char* out = nullptr;\n-  bool r;\n+  UpdateResult r;\n   int out_len = 0;\n \n   // Only copy the data if we have to, because it's a string\n@@ -3085,11 +3214,13 @@ void CipherBase::Update(const FunctionCallbackInfo<Value>& args) {\n     r = cipher->Update(buf, buflen, &out, &out_len);\n   }\n \n-  if (!r) {\n+  if (r != kSuccess) {\n     free(out);\n-    return ThrowCryptoError(env,\n-                            ERR_get_error(),\n-                            \"Trying to add data in unsupported state\");\n+    if (r == kErrorState) {\n+      ThrowCryptoError(env, ERR_get_error(),\n+                       \"Trying to add data in unsupported state\");\n+    }\n+    return;\n   }\n \n   CHECK(out != nullptr || out_len == 0);\n@@ -3120,21 +3251,36 @@ bool CipherBase::Final(unsigned char** out, int *out_len) {\n   if (ctx_ == nullptr)\n     return false;\n \n+  const int mode = EVP_CIPHER_CTX_mode(ctx_);\n+\n   *out = Malloc<unsigned char>(\n       static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_)));\n-  int r = EVP_CipherFinal_ex(ctx_, *out, out_len);\n \n-  if (r == 1 && kind_ == kCipher && IsAuthenticatedMode()) {\n-    auth_tag_len_ = sizeof(auth_tag_);\n-    r = EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_GCM_GET_TAG, auth_tag_len_,\n-                            reinterpret_cast<unsigned char*>(auth_tag_));\n-    CHECK_EQ(r, 1);\n+  // In CCM mode, final() only checks whether authentication failed in update().\n+  // EVP_CipherFinal_ex must not be called and will fail.\n+  bool ok;\n+  if (kind_ == kDecipher && mode == EVP_CIPH_CCM_MODE) {\n+    ok = !pending_auth_failed_;\n+  } else {\n+    ok = EVP_CipherFinal_ex(ctx_, *out, out_len) == 1;\n+\n+    if (ok && kind_ == kCipher && IsAuthenticatedMode()) {\n+      // For GCM, the tag length is static (16 bytes), while the CCM tag length\n+      // must be specified in advance.\n+      if (mode == EVP_CIPH_GCM_MODE)\n+        auth_tag_len_ = sizeof(auth_tag_);\n+      // TOOD(tniessen) Use EVP_CTRL_AEAP_GET_TAG in OpenSSL 1.1.0\n+      static_assert(EVP_CTRL_CCM_GET_TAG == EVP_CTRL_GCM_GET_TAG,\n+                    \"OpenSSL constants differ between GCM and CCM\");\n+      CHECK_EQ(1, EVP_CIPHER_CTX_ctrl(ctx_, EVP_CTRL_GCM_GET_TAG, auth_tag_len_,\n+                      reinterpret_cast<unsigned char*>(auth_tag_)));\n+    }\n   }\n \n   EVP_CIPHER_CTX_free(ctx_);\n   ctx_ = nullptr;\n \n-  return r == 1;\n+  return ok;\n }\n \n "
        },
        {
            "sha": "2f7c904ee9212d25d3f6c4d7bfeab53703645baa",
            "filename": "src/node_crypto.h",
            "status": "modified",
            "additions": 22,
            "deletions": 5,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/1e07acd476309e7ddc4981160b89731b61a31179/src%2Fnode_crypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/1e07acd476309e7ddc4981160b89731b61a31179/src%2Fnode_crypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.h?ref=1e07acd476309e7ddc4981160b89731b61a31179",
            "patch": "@@ -354,19 +354,31 @@ class CipherBase : public BaseObject {\n     kCipher,\n     kDecipher\n   };\n+  enum UpdateResult {\n+    kSuccess,\n+    kErrorMessageSize,\n+    kErrorState\n+  };\n \n-  void Init(const char* cipher_type, const char* key_buf, int key_buf_len);\n+  void Init(const char* cipher_type,\n+            const char* key_buf,\n+            int key_buf_len,\n+            int auth_tag_len);\n   void InitIv(const char* cipher_type,\n               const char* key,\n               int key_len,\n               const char* iv,\n-              int iv_len);\n-  bool Update(const char* data, int len, unsigned char** out, int* out_len);\n+              int iv_len,\n+              int auth_tag_len);\n+  bool InitAuthenticated(const char *cipher_type, int iv_len, int auth_tag_len);\n+  bool CheckCCMMessageLength(int message_len);\n+  UpdateResult Update(const char* data, int len, unsigned char** out,\n+                      int* out_len);\n   bool Final(unsigned char** out, int *out_len);\n   bool SetAutoPadding(bool auto_padding);\n \n   bool IsAuthenticatedMode() const;\n-  bool SetAAD(const char* data, unsigned int len);\n+  bool SetAAD(const char* data, unsigned int len, int plaintext_len);\n \n   static void New(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void Init(const v8::FunctionCallbackInfo<v8::Value>& args);\n@@ -385,15 +397,20 @@ class CipherBase : public BaseObject {\n       : BaseObject(env, wrap),\n         ctx_(nullptr),\n         kind_(kind),\n-        auth_tag_len_(0) {\n+        auth_tag_set_(false),\n+        auth_tag_len_(0),\n+        pending_auth_failed_(false) {\n     MakeWeak<CipherBase>(this);\n   }\n \n  private:\n   EVP_CIPHER_CTX* ctx_;\n   const CipherKind kind_;\n+  bool auth_tag_set_;\n   unsigned int auth_tag_len_;\n   char auth_tag_[EVP_GCM_TLS_TAG_LEN];\n+  bool pending_auth_failed_;\n+  int max_message_size_;\n };\n \n class Hmac : public BaseObject {"
        },
        {
            "sha": "73e3a23f72ac81f880b6fdbe346ad438a5ed4d1c",
            "filename": "test/parallel/test-crypto-authenticated.js",
            "status": "modified",
            "additions": 477,
            "deletions": 30,
            "changes": 507,
            "blob_url": "https://github.com/nodejs/node/blob/1e07acd476309e7ddc4981160b89731b61a31179/test%2Fparallel%2Ftest-crypto-authenticated.js",
            "raw_url": "https://github.com/nodejs/node/raw/1e07acd476309e7ddc4981160b89731b61a31179/test%2Fparallel%2Ftest-crypto-authenticated.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-authenticated.js?ref=1e07acd476309e7ddc4981160b89731b61a31179",
            "patch": "@@ -323,20 +323,216 @@ const TEST_CASES = [\n         '0fc0c3b780f244452da3ebf1c5d82cde' +\n         'a2418997200ef82e44ae7e3f',\n     tag: 'a44a8266ee1c8eb0c8b5d4cf5ae9f19a', tampered: false },\n+\n+  // The following test cases for AES-CCM are from RFC3610\n+\n+  // Packet Vector #1\n+  {\n+    algo: 'aes-128-ccm',\n+    key: 'c0c1c2c3c4c5c6c7c8c9cacbcccdcecf',\n+    iv: '00000003020100a0a1a2a3a4a5',\n+    plain: '08090a0b0c0d0e0f101112131415161718191a1b1c1d1e',\n+    aad: '0001020304050607',\n+    plainIsHex: true,\n+    ct: '588c979a61c663d2f066d0c2c0f989806d5f6b61dac384',\n+    tag: '17e8d12cfdf926e0'\n+  },\n+\n+  // Packet Vector #2\n+  {\n+    algo: 'aes-128-ccm',\n+    key: 'c0c1c2c3c4c5c6c7c8c9cacbcccdcecf',\n+    iv: '00000004030201a0a1a2a3a4a5',\n+    plain: '08090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f',\n+    aad: '0001020304050607',\n+    plainIsHex: true,\n+    ct: '72c91a36e135f8cf291ca894085c87e3cc15c439c9e43a3b',\n+    tag: 'a091d56e10400916'\n+  },\n+\n+  // Packet Vector #3\n+  {\n+    algo: 'aes-128-ccm',\n+    key: 'c0c1c2c3c4c5c6c7c8c9cacbcccdcecf',\n+    iv: '00000005040302a0a1a2a3a4a5',\n+    plain: '08090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20',\n+    aad: '0001020304050607',\n+    plainIsHex: true,\n+    ct: '51b1e5f44a197d1da46b0f8e2d282ae871e838bb64da859657',\n+    tag: '4adaa76fbd9fb0c5'\n+  },\n+\n+  // Packet Vector #4\n+  {\n+    algo: 'aes-128-ccm',\n+    key: 'c0c1c2c3c4c5c6c7c8c9cacbcccdcecf',\n+    iv: '00000006050403a0a1a2a3a4a5',\n+    plain: '0c0d0e0f101112131415161718191a1b1c1d1e',\n+    aad: '000102030405060708090a0b',\n+    plainIsHex: true,\n+    ct: 'a28c6865939a9a79faaa5c4c2a9d4a91cdac8c',\n+    tag: '96c861b9c9e61ef1'\n+  },\n+\n+  // Packet Vector #5\n+  {\n+    algo: 'aes-128-ccm',\n+    key: 'c0c1c2c3c4c5c6c7c8c9cacbcccdcecf',\n+    iv: '00000007060504a0a1a2a3a4a5',\n+    plain: '0c0d0e0f101112131415161718191a1b1c1d1e1f',\n+    aad: '000102030405060708090a0b',\n+    plainIsHex: true,\n+    ct: 'dcf1fb7b5d9e23fb9d4e131253658ad86ebdca3e',\n+    tag: '51e83f077d9c2d93'\n+  },\n+\n+  // Packet Vector #6\n+  {\n+    algo: 'aes-128-ccm',\n+    key: 'c0c1c2c3c4c5c6c7c8c9cacbcccdcecf',\n+    iv: '00000008070605a0a1a2a3a4a5',\n+    plain: '0c0d0e0f101112131415161718191a1b1c1d1e1f20',\n+    aad: '000102030405060708090a0b',\n+    plainIsHex: true,\n+    ct: '6fc1b011f006568b5171a42d953d469b2570a4bd87',\n+    tag: '405a0443ac91cb94'\n+  },\n+\n+  // Packet Vector #7\n+  {\n+    algo: 'aes-128-ccm',\n+    key: 'c0c1c2c3c4c5c6c7c8c9cacbcccdcecf',\n+    iv: '00000009080706a0a1a2a3a4a5',\n+    plain: '08090a0b0c0d0e0f101112131415161718191a1b1c1d1e',\n+    aad: '0001020304050607',\n+    plainIsHex: true,\n+    ct: '0135d1b2c95f41d5d1d4fec185d166b8094e999dfed96c',\n+    tag: '048c56602c97acbb7490'\n+  },\n+\n+  // Packet Vector #7 with invalid authentication tag\n+  {\n+    algo: 'aes-128-ccm',\n+    key: 'c0c1c2c3c4c5c6c7c8c9cacbcccdcecf',\n+    iv: '00000009080706a0a1a2a3a4a5',\n+    plain: '08090a0b0c0d0e0f101112131415161718191a1b1c1d1e',\n+    aad: '0001020304050607',\n+    plainIsHex: true,\n+    ct: '0135d1b2c95f41d5d1d4fec185d166b8094e999dfed96c',\n+    tag: '048c56602c97acbb7491',\n+    tampered: true\n+  },\n+\n+  // Packet Vector #7 with invalid ciphertext\n+  {\n+    algo: 'aes-128-ccm',\n+    key: 'c0c1c2c3c4c5c6c7c8c9cacbcccdcecf',\n+    iv: '00000009080706a0a1a2a3a4a5',\n+    plain: '08090a0b0c0d0e0f101112131415161718191a1b1c1d1e',\n+    aad: '0001020304050607',\n+    plainIsHex: true,\n+    ct: '0135d1b2c95f41d5d1d4fec185d166b8094e999dfed96d',\n+    tag: '048c56602c97acbb7490',\n+    tampered: true\n+  },\n+\n+  // Test case for CCM with a password using create(C|Dec)ipher\n+  {\n+    algo: 'aes-192-ccm',\n+    key: '1ed2233fa2223ef5d7df08546049406c7305220bca40d4c9',\n+    iv: '0e1791e9db3bd21a9122c416',\n+    plain: 'Hello node.js world!',\n+    password: 'very bad password',\n+    aad: '63616c76696e',\n+    ct: '49d2c2bd4892703af2f25db04cbe00e703d6d5ac',\n+    tag: '693c21ce212564fc3a6f',\n+    tampered: false\n+  },\n+\n+  // Test case for CCM with a password using create(C|Dec)ipher, invalid tag\n+  {\n+    algo: 'aes-192-ccm',\n+    key: '1ed2233fa2223ef5d7df08546049406c7305220bca40d4c9',\n+    iv: '0e1791e9db3bd21a9122c416',\n+    plain: 'Hello node.js world!',\n+    password: 'very bad password',\n+    aad: '63616c76696e',\n+    ct: '49d2c2bd4892703af2f25db04cbe00e703d6d5ac',\n+    tag: '693c21ce212564fc3a6e',\n+    tampered: true\n+  },\n+\n+  // Same test with a 128-bit key\n+  {\n+    algo: 'aes-128-ccm',\n+    key: '1ed2233fa2223ef5d7df08546049406c',\n+    iv: '7305220bca40d4c90e1791e9',\n+    plain: 'Hello node.js world!',\n+    password: 'very bad password',\n+    aad: '63616c76696e',\n+    ct: '8beba09d4d4d861f957d51c0794f4abf8030848e',\n+    tag: '0d9bcd142a94caf3d1dd',\n+    tampered: false\n+  },\n+\n+  // Test case for CCM without any AAD\n+  {\n+    algo: 'aes-128-ccm',\n+    key: '1ed2233fa2223ef5d7df08546049406c',\n+    iv: '7305220bca40d4c90e1791e9',\n+    plain: 'Hello node.js world!',\n+    password: 'very bad password',\n+    ct: '8beba09d4d4d861f957d51c0794f4abf8030848e',\n+    tag: '29d71a70bb58dae1425d',\n+    tampered: false\n+  },\n+\n+  // Test case for CCM with an empty message\n+  {\n+    algo: 'aes-128-ccm',\n+    key: '1ed2233fa2223ef5d7df08546049406c',\n+    iv: '7305220bca40d4c90e1791e9',\n+    plain: '',\n+    password: 'very bad password',\n+    aad: '63616c76696e',\n+    ct: '',\n+    tag: '65a6002b2cdfe9f00027f839332ca6fc',\n+    tampered: false\n+  },\n ];\n \n const errMessages = {\n   auth: / auth/,\n   state: / state/,\n   FIPS: /not supported in FIPS mode/,\n   length: /Invalid IV length/,\n+  authTagLength: /Invalid authentication tag length/\n };\n \n const ciphers = crypto.getCiphers();\n \n const expectedWarnings = common.hasFipsCrypto ?\n-  [] : [['Use Cipheriv for counter mode of aes-192-gcm',\n-         common.noWarnCode]];\n+  [] : [\n+    ['Use Cipheriv for counter mode of aes-192-gcm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-192-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-192-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-128-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-128-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-128-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode],\n+    ['Use Cipheriv for counter mode of aes-256-ccm', common.noWarnCode]\n+  ];\n \n const expectedDeprecationWarnings = [0, 1, 2, 6, 9, 10, 11, 17]\n   .map((i) => [`Permitting authentication tag lengths of ${i} bytes is ` +\n@@ -362,14 +558,30 @@ for (const test of TEST_CASES) {\n     continue;\n   }\n \n+  const isCCM = /^aes-(128|192|256)-ccm$/.test(test.algo);\n+\n+  let options;\n+  if (isCCM)\n+    options = { authTagLength: test.tag.length / 2 };\n+\n+  const inputEncoding = test.plainIsHex ? 'hex' : 'ascii';\n+\n+  let aadOptions;\n+  if (isCCM) {\n+    aadOptions = {\n+      plaintextLength: Buffer.from(test.plain, inputEncoding).length\n+    };\n+  }\n+\n   {\n     const encrypt = crypto.createCipheriv(test.algo,\n                                           Buffer.from(test.key, 'hex'),\n-                                          Buffer.from(test.iv, 'hex'));\n+                                          Buffer.from(test.iv, 'hex'),\n+                                          options);\n+\n     if (test.aad)\n-      encrypt.setAAD(Buffer.from(test.aad, 'hex'));\n+      encrypt.setAAD(Buffer.from(test.aad, 'hex'), aadOptions);\n \n-    const inputEncoding = test.plainIsHex ? 'hex' : 'ascii';\n     let hex = encrypt.update(test.plain, inputEncoding, 'hex');\n     hex += encrypt.final('hex');\n \n@@ -382,22 +594,32 @@ for (const test of TEST_CASES) {\n   }\n \n   {\n-    const decrypt = crypto.createDecipheriv(test.algo,\n-                                            Buffer.from(test.key, 'hex'),\n-                                            Buffer.from(test.iv, 'hex'));\n-    decrypt.setAuthTag(Buffer.from(test.tag, 'hex'));\n-    if (test.aad)\n-      decrypt.setAAD(Buffer.from(test.aad, 'hex'));\n+    if (isCCM && common.hasFipsCrypto) {\n+      assert.throws(() => {\n+        crypto.createDecipheriv(test.algo,\n+                                Buffer.from(test.key, 'hex'),\n+                                Buffer.from(test.iv, 'hex'),\n+                                options);\n+      }, errMessages.FIPS);\n+    } else {\n+      const decrypt = crypto.createDecipheriv(test.algo,\n+                                              Buffer.from(test.key, 'hex'),\n+                                              Buffer.from(test.iv, 'hex'),\n+                                              options);\n+      decrypt.setAuthTag(Buffer.from(test.tag, 'hex'));\n+      if (test.aad)\n+        decrypt.setAAD(Buffer.from(test.aad, 'hex'), aadOptions);\n \n-    const outputEncoding = test.plainIsHex ? 'hex' : 'ascii';\n+      const outputEncoding = test.plainIsHex ? 'hex' : 'ascii';\n \n-    let msg = decrypt.update(test.ct, 'hex', outputEncoding);\n-    if (!test.tampered) {\n-      msg += decrypt.final(outputEncoding);\n-      assert.strictEqual(msg, test.plain);\n-    } else {\n-      // assert that final throws if input data could not be verified!\n-      assert.throws(function() { decrypt.final('hex'); }, errMessages.auth);\n+      let msg = decrypt.update(test.ct, 'hex', outputEncoding);\n+      if (!test.tampered) {\n+        msg += decrypt.final(outputEncoding);\n+        assert.strictEqual(msg, test.plain);\n+      } else {\n+        // assert that final throws if input data could not be verified!\n+        assert.throws(function() { decrypt.final('hex'); }, errMessages.auth);\n+      }\n     }\n   }\n \n@@ -406,9 +628,9 @@ for (const test of TEST_CASES) {\n       assert.throws(() => { crypto.createCipher(test.algo, test.password); },\n                     errMessages.FIPS);\n     } else {\n-      const encrypt = crypto.createCipher(test.algo, test.password);\n+      const encrypt = crypto.createCipher(test.algo, test.password, options);\n       if (test.aad)\n-        encrypt.setAAD(Buffer.from(test.aad, 'hex'));\n+        encrypt.setAAD(Buffer.from(test.aad, 'hex'), aadOptions);\n       let hex = encrypt.update(test.plain, 'ascii', 'hex');\n       hex += encrypt.final('hex');\n       const auth_tag = encrypt.getAuthTag();\n@@ -425,10 +647,10 @@ for (const test of TEST_CASES) {\n       assert.throws(() => { crypto.createDecipher(test.algo, test.password); },\n                     errMessages.FIPS);\n     } else {\n-      const decrypt = crypto.createDecipher(test.algo, test.password);\n+      const decrypt = crypto.createDecipher(test.algo, test.password, options);\n       decrypt.setAuthTag(Buffer.from(test.tag, 'hex'));\n       if (test.aad)\n-        decrypt.setAAD(Buffer.from(test.aad, 'hex'));\n+        decrypt.setAAD(Buffer.from(test.aad, 'hex'), aadOptions);\n       let msg = decrypt.update(test.ct, 'hex', 'ascii');\n       if (!test.tampered) {\n         msg += decrypt.final('ascii');\n@@ -444,7 +666,8 @@ for (const test of TEST_CASES) {\n     // trying to get tag before inputting all data:\n     const encrypt = crypto.createCipheriv(test.algo,\n                                           Buffer.from(test.key, 'hex'),\n-                                          Buffer.from(test.iv, 'hex'));\n+                                          Buffer.from(test.iv, 'hex'),\n+                                          options);\n     encrypt.update('blah', 'ascii');\n     assert.throws(function() { encrypt.getAuthTag(); }, errMessages.state);\n   }\n@@ -453,17 +676,21 @@ for (const test of TEST_CASES) {\n     // trying to set tag on encryption object:\n     const encrypt = crypto.createCipheriv(test.algo,\n                                           Buffer.from(test.key, 'hex'),\n-                                          Buffer.from(test.iv, 'hex'));\n+                                          Buffer.from(test.iv, 'hex'),\n+                                          options);\n     assert.throws(() => { encrypt.setAuthTag(Buffer.from(test.tag, 'hex')); },\n                   errMessages.state);\n   }\n \n   {\n-    // trying to read tag from decryption object:\n-    const decrypt = crypto.createDecipheriv(test.algo,\n-                                            Buffer.from(test.key, 'hex'),\n-                                            Buffer.from(test.iv, 'hex'));\n-    assert.throws(function() { decrypt.getAuthTag(); }, errMessages.state);\n+    if (!isCCM || !common.hasFipsCrypto) {\n+      // trying to read tag from decryption object:\n+      const decrypt = crypto.createDecipheriv(test.algo,\n+                                              Buffer.from(test.key, 'hex'),\n+                                              Buffer.from(test.iv, 'hex'),\n+                                              options);\n+      assert.throws(function() { decrypt.getAuthTag(); }, errMessages.state);\n+    }\n   }\n \n   {\n@@ -501,3 +728,223 @@ for (const test of TEST_CASES) {\n     decrypt.setAuthTag(Buffer.from('1'.repeat(length)));\n   }\n }\n+\n+// Test that create(De|C)ipher(iv)? throws if the mode is CCM and an invalid\n+// authentication tag length has been specified.\n+{\n+  for (const authTagLength of [-1, true, false, NaN, 5.5]) {\n+    common.expectsError(() => {\n+      crypto.createCipheriv('aes-256-ccm',\n+                            'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n+                            'qkuZpJWCewa6S',\n+                            {\n+                              authTagLength\n+                            });\n+    }, {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${authTagLength}\" is invalid for option ` +\n+               '\"authTagLength\"'\n+    });\n+\n+    common.expectsError(() => {\n+      crypto.createDecipheriv('aes-256-ccm',\n+                              'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n+                              'qkuZpJWCewa6S',\n+                              {\n+                                authTagLength\n+                              });\n+    }, {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${authTagLength}\" is invalid for option ` +\n+               '\"authTagLength\"'\n+    });\n+\n+    if (!common.hasFipsCrypto) {\n+      common.expectsError(() => {\n+        crypto.createCipher('aes-256-ccm', 'bad password', { authTagLength });\n+      }, {\n+        type: TypeError,\n+        code: 'ERR_INVALID_OPT_VALUE',\n+        message: `The value \"${authTagLength}\" is invalid for option ` +\n+                 '\"authTagLength\"'\n+      });\n+\n+      common.expectsError(() => {\n+        crypto.createDecipher('aes-256-ccm', 'bad password', { authTagLength });\n+      }, {\n+        type: TypeError,\n+        code: 'ERR_INVALID_OPT_VALUE',\n+        message: `The value \"${authTagLength}\" is invalid for option ` +\n+                 '\"authTagLength\"'\n+      });\n+    }\n+  }\n+\n+  // The following values will not be caught by the JS layer and thus will not\n+  // use the default error codes.\n+  for (const authTagLength of [0, 1, 2, 3, 5, 7, 9, 11, 13, 15, 17, 18]) {\n+    assert.throws(() => {\n+      crypto.createCipheriv('aes-256-ccm',\n+                            'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n+                            'qkuZpJWCewa6S',\n+                            {\n+                              authTagLength\n+                            });\n+    }, errMessages.authTagLength);\n+\n+    if (!common.hasFipsCrypto) {\n+      assert.throws(() => {\n+        crypto.createDecipheriv('aes-256-ccm',\n+                                'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n+                                'qkuZpJWCewa6S',\n+                                {\n+                                  authTagLength\n+                                });\n+      }, errMessages.authTagLength);\n+\n+      assert.throws(() => {\n+        crypto.createCipher('aes-256-ccm', 'bad password', { authTagLength });\n+      }, errMessages.authTagLength);\n+\n+      assert.throws(() => {\n+        crypto.createDecipher('aes-256-ccm', 'bad password', { authTagLength });\n+      }, errMessages.authTagLength);\n+    }\n+  }\n+}\n+\n+// Test that create(De|C)ipher(iv)? throws if the mode is CCM and no\n+// authentication tag has been specified.\n+{\n+  assert.throws(() => {\n+    crypto.createCipheriv('aes-256-ccm',\n+                          'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n+                          'qkuZpJWCewa6S');\n+  }, /^Error: authTagLength required for aes-256-ccm$/);\n+\n+  // CCM decryption and create(De|C)ipher are unsupported in FIPS mode.\n+  if (!common.hasFipsCrypto) {\n+    assert.throws(() => {\n+      crypto.createDecipheriv('aes-256-ccm',\n+                              'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n+                              'qkuZpJWCewa6S');\n+    }, /^Error: authTagLength required for aes-256-ccm$/);\n+\n+    assert.throws(() => {\n+      crypto.createCipher('aes-256-ccm', 'very bad password');\n+    }, /^Error: authTagLength required for aes-256-ccm$/);\n+\n+    assert.throws(() => {\n+      crypto.createDecipher('aes-256-ccm', 'very bad password');\n+    }, /^Error: authTagLength required for aes-256-ccm$/);\n+  }\n+}\n+\n+// Test that setAAD throws if an invalid plaintext length has been specified.\n+{\n+  const cipher = crypto.createCipheriv('aes-256-ccm',\n+                                       'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n+                                       'qkuZpJWCewa6S',\n+                                       {\n+                                         authTagLength: 10\n+                                       });\n+\n+  for (const plaintextLength of [-1, true, false, NaN, 5.5]) {\n+    common.expectsError(() => {\n+      cipher.setAAD(Buffer.from('0123456789', 'hex'), { plaintextLength });\n+    }, {\n+      type: TypeError,\n+      code: 'ERR_INVALID_OPT_VALUE',\n+      message: `The value \"${plaintextLength}\" is invalid for option ` +\n+               '\"plaintextLength\"'\n+    });\n+  }\n+}\n+\n+// Test that setAAD and update throw if the plaintext is too long.\n+{\n+  for (const ivLength of [13, 12]) {\n+    const maxMessageSize = (1 << (8 * (15 - ivLength))) - 1;\n+    const key = 'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8';\n+    const cipher = () => crypto.createCipheriv('aes-256-ccm', key,\n+                                               '0'.repeat(ivLength),\n+                                               {\n+                                                 authTagLength: 10\n+                                               });\n+\n+    assert.throws(() => {\n+      cipher().setAAD(Buffer.alloc(0), {\n+        plaintextLength: maxMessageSize + 1\n+      });\n+    }, /^Error: Message exceeds maximum size$/);\n+\n+    const msg = Buffer.alloc(maxMessageSize + 1);\n+    assert.throws(() => {\n+      cipher().update(msg);\n+    }, /^Error: Message exceeds maximum size$/);\n+\n+    const c = cipher();\n+    c.setAAD(Buffer.alloc(0), {\n+      plaintextLength: maxMessageSize\n+    });\n+    c.update(msg.slice(1));\n+  }\n+}\n+\n+// Test that setAAD throws if the mode is CCM and the plaintext length has not\n+// been specified.\n+{\n+  assert.throws(() => {\n+    const cipher = crypto.createCipheriv('aes-256-ccm',\n+                                         'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n+                                         'qkuZpJWCewa6S',\n+                                         {\n+                                           authTagLength: 10\n+                                         });\n+    cipher.setAAD(Buffer.from('0123456789', 'hex'));\n+  }, /^Error: plaintextLength required for CCM mode with AAD$/);\n+\n+  if (!common.hasFipsCrypto) {\n+    assert.throws(() => {\n+      const cipher = crypto.createDecipheriv('aes-256-ccm',\n+                                             'FxLKsqdmv0E9xrQhp0b1ZgI0K7JFZJM8',\n+                                             'qkuZpJWCewa6S',\n+                                             {\n+                                               authTagLength: 10\n+                                             });\n+      cipher.setAAD(Buffer.from('0123456789', 'hex'));\n+    }, /^Error: plaintextLength required for CCM mode with AAD$/);\n+  }\n+}\n+\n+// Test that setAAD throws in CCM mode when no authentication tag is provided.\n+{\n+  if (!common.hasFipsCrypto) {\n+    const key = Buffer.from('1ed2233fa2223ef5d7df08546049406c', 'hex');\n+    const iv = Buffer.from('7305220bca40d4c90e1791e9', 'hex');\n+    const ct = Buffer.from('8beba09d4d4d861f957d51c0794f4abf8030848e', 'hex');\n+    const decrypt = crypto.createDecipheriv('aes-128-ccm', key, iv, {\n+      authTagLength: 10\n+    });\n+    // Normally, we would do this:\n+    // decrypt.setAuthTag(Buffer.from('0d9bcd142a94caf3d1dd', 'hex'));\n+    assert.throws(() => {\n+      decrypt.setAAD(Buffer.from('63616c76696e', 'hex'), {\n+        plaintextLength: ct.length\n+      });\n+    }, errMessages.state);\n+  }\n+}\n+\n+// Test that setAuthTag does not throw in GCM mode when called after setAAD.\n+{\n+  const key = Buffer.from('1ed2233fa2223ef5d7df08546049406c', 'hex');\n+  const iv = Buffer.from('579d9dfde9cd93d743da1ceaeebb86e4', 'hex');\n+  const decrypt = crypto.createDecipheriv('aes-128-gcm', key, iv);\n+  decrypt.setAAD(Buffer.from('0123456789', 'hex'));\n+  decrypt.setAuthTag(Buffer.from('1bb9253e250b8069cde97151d7ef32d9', 'hex'));\n+  assert.strictEqual(decrypt.update('807022', 'hex', 'hex'), 'abcdef');\n+  assert.strictEqual(decrypt.final('hex'), '');\n+}"
        }
    ],
    "stats": {
        "total": 930,
        "additions": 825,
        "deletions": 105
    }
}