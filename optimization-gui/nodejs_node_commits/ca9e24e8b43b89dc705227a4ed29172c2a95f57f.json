{
    "author": "joyeecheung",
    "message": "src: move public C++ APIs into src/api/*.cc\n\nThis patch moves most of the public C++ APIs into src/api/*.cc\nso that it's easier to tell that we need to be careful about\nthe compatibility of these code.\n\nSome APIs, like `node::LoadEnvironmet()`, `node::Start()` and\n`node::Init()` still stay in `node.cc` because they are still\nvery specific to our use cases and do not work quite well yet\nfor embedders anyway - we could not even manage to write cctest for\nthem at the moment.\n\nPR-URL: https://github.com/nodejs/node/pull/25541\nReviewed-By: Gus Caplan <me@gus.host>",
    "sha": "ca9e24e8b43b89dc705227a4ed29172c2a95f57f",
    "files": [
        {
            "sha": "c89f862c4269caff98eba1e18c344085060d5ac3",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=ca9e24e8b43b89dc705227a4ed29172c2a95f57f",
            "patch": "@@ -363,14 +363,19 @@\n       ],\n \n       'sources': [\n+        'src/api/callback.cc',\n+        'src/api/encoding.cc',\n+        'src/api/environment.cc',\n+        'src/api/exceptions.cc',\n+        'src/api/hooks.cc',\n+        'src/api/utils.cc',\n+\n         'src/async_wrap.cc',\n-        'src/callback_scope.cc',\n         'src/cares_wrap.cc',\n         'src/connect_wrap.cc',\n         'src/connection_wrap.cc',\n         'src/debug_utils.cc',\n         'src/env.cc',\n-        'src/exceptions.cc',\n         'src/fs_event_wrap.cc',\n         'src/handle_wrap.cc',\n         'src/heap_utils.cc',\n@@ -390,7 +395,6 @@\n         'src/node_contextify.cc',\n         'src/node_credentials.cc',\n         'src/node_domain.cc',\n-        'src/node_encoding.cc',\n         'src/node_env_var.cc',\n         'src/node_errors.cc',\n         'src/node_file.cc',"
        },
        {
            "sha": "885134799fe0198d63b3ed15e99c02bb316bc4bb",
            "filename": "src/api/callback.cc",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fapi%2Fcallback.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fapi%2Fcallback.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fapi%2Fcallback.cc?ref=ca9e24e8b43b89dc705227a4ed29172c2a95f57f",
            "previous_filename": "src/callback_scope.cc"
        },
        {
            "sha": "21d327509727a235610c147bd0f64fa923023533",
            "filename": "src/api/encoding.cc",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fapi%2Fencoding.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fapi%2Fencoding.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fapi%2Fencoding.cc?ref=ca9e24e8b43b89dc705227a4ed29172c2a95f57f",
            "previous_filename": "src/node_encoding.cc"
        },
        {
            "sha": "9480fb2b96144cf7ea3b390e1677023e39731a25",
            "filename": "src/api/environment.cc",
            "status": "added",
            "additions": 214,
            "deletions": 0,
            "changes": 214,
            "blob_url": "https://github.com/nodejs/node/blob/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fapi%2Fenvironment.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fapi%2Fenvironment.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fapi%2Fenvironment.cc?ref=ca9e24e8b43b89dc705227a4ed29172c2a95f57f",
            "patch": "@@ -0,0 +1,214 @@\n+#include \"env.h\"\n+#include \"node.h\"\n+#include \"node_context_data.h\"\n+#include \"node_errors.h\"\n+#include \"node_internals.h\"\n+#include \"node_native_module.h\"\n+#include \"node_platform.h\"\n+#include \"node_process.h\"\n+#include \"node_v8_platform-inl.h\"\n+#include \"uv.h\"\n+\n+namespace node {\n+using v8::Context;\n+using v8::Function;\n+using v8::HandleScope;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::MaybeLocal;\n+using v8::Message;\n+using v8::MicrotasksPolicy;\n+using v8::ObjectTemplate;\n+using v8::String;\n+using v8::Value;\n+\n+static bool AllowWasmCodeGenerationCallback(Local<Context> context,\n+                                            Local<String>) {\n+  Local<Value> wasm_code_gen =\n+      context->GetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration);\n+  return wasm_code_gen->IsUndefined() || wasm_code_gen->IsTrue();\n+}\n+\n+static bool ShouldAbortOnUncaughtException(Isolate* isolate) {\n+  HandleScope scope(isolate);\n+  Environment* env = Environment::GetCurrent(isolate);\n+  return env != nullptr && env->should_abort_on_uncaught_toggle()[0] &&\n+         !env->inside_should_not_abort_on_uncaught_scope();\n+}\n+\n+static void OnMessage(Local<Message> message, Local<Value> error) {\n+  Isolate* isolate = message->GetIsolate();\n+  switch (message->ErrorLevel()) {\n+    case Isolate::MessageErrorLevel::kMessageWarning: {\n+      Environment* env = Environment::GetCurrent(isolate);\n+      if (!env) {\n+        break;\n+      }\n+      Utf8Value filename(isolate, message->GetScriptOrigin().ResourceName());\n+      // (filename):(line) (message)\n+      std::stringstream warning;\n+      warning << *filename;\n+      warning << \":\";\n+      warning << message->GetLineNumber(env->context()).FromMaybe(-1);\n+      warning << \" \";\n+      v8::String::Utf8Value msg(isolate, message->Get());\n+      warning << *msg;\n+      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), \"V8\"));\n+      break;\n+    }\n+    case Isolate::MessageErrorLevel::kMessageError:\n+      FatalException(isolate, error, message);\n+      break;\n+  }\n+}\n+\n+void* ArrayBufferAllocator::Allocate(size_t size) {\n+  if (zero_fill_field_ || per_process::cli_options->zero_fill_all_buffers)\n+    return UncheckedCalloc(size);\n+  else\n+    return UncheckedMalloc(size);\n+}\n+\n+ArrayBufferAllocator* CreateArrayBufferAllocator() {\n+  return new ArrayBufferAllocator();\n+}\n+\n+void FreeArrayBufferAllocator(ArrayBufferAllocator* allocator) {\n+  delete allocator;\n+}\n+\n+Isolate* NewIsolate(ArrayBufferAllocator* allocator, uv_loop_t* event_loop) {\n+  Isolate::CreateParams params;\n+  params.array_buffer_allocator = allocator;\n+#ifdef NODE_ENABLE_VTUNE_PROFILING\n+  params.code_event_handler = vTune::GetVtuneCodeEventHandler();\n+#endif\n+\n+  Isolate* isolate = Isolate::Allocate();\n+  if (isolate == nullptr) return nullptr;\n+\n+  // Register the isolate on the platform before the isolate gets initialized,\n+  // so that the isolate can access the platform during initialization.\n+  per_process::v8_platform.Platform()->RegisterIsolate(isolate, event_loop);\n+  Isolate::Initialize(isolate, params);\n+\n+  isolate->AddMessageListenerWithErrorLevel(\n+      OnMessage,\n+      Isolate::MessageErrorLevel::kMessageError |\n+          Isolate::MessageErrorLevel::kMessageWarning);\n+  isolate->SetAbortOnUncaughtExceptionCallback(ShouldAbortOnUncaughtException);\n+  isolate->SetMicrotasksPolicy(MicrotasksPolicy::kExplicit);\n+  isolate->SetFatalErrorHandler(OnFatalError);\n+  isolate->SetAllowWasmCodeGenerationCallback(AllowWasmCodeGenerationCallback);\n+  v8::CpuProfiler::UseDetailedSourcePositionsForProfiling(isolate);\n+\n+  return isolate;\n+}\n+\n+IsolateData* CreateIsolateData(Isolate* isolate,\n+                               uv_loop_t* loop,\n+                               MultiIsolatePlatform* platform,\n+                               ArrayBufferAllocator* allocator) {\n+  return new IsolateData(\n+      isolate,\n+      loop,\n+      platform,\n+      allocator != nullptr ? allocator->zero_fill_field() : nullptr);\n+}\n+\n+void FreeIsolateData(IsolateData* isolate_data) {\n+  delete isolate_data;\n+}\n+\n+Environment* CreateEnvironment(IsolateData* isolate_data,\n+                               Local<Context> context,\n+                               int argc,\n+                               const char* const* argv,\n+                               int exec_argc,\n+                               const char* const* exec_argv) {\n+  Isolate* isolate = context->GetIsolate();\n+  HandleScope handle_scope(isolate);\n+  Context::Scope context_scope(context);\n+  // TODO(addaleax): This is a much better place for parsing per-Environment\n+  // options than the global parse call.\n+  std::vector<std::string> args(argv, argv + argc);\n+  std::vector<std::string> exec_args(exec_argv, exec_argv + exec_argc);\n+  Environment* env = new Environment(isolate_data, context);\n+  env->Start(per_process::v8_is_profiling);\n+  env->ProcessCliArgs(args, exec_args);\n+  return env;\n+}\n+\n+void FreeEnvironment(Environment* env) {\n+  env->RunCleanup();\n+  delete env;\n+}\n+\n+Environment* GetCurrentEnvironment(Local<Context> context) {\n+  return Environment::GetCurrent(context);\n+}\n+\n+MultiIsolatePlatform* GetMainThreadMultiIsolatePlatform() {\n+  return per_process::v8_platform.Platform();\n+}\n+\n+MultiIsolatePlatform* CreatePlatform(\n+    int thread_pool_size,\n+    node::tracing::TracingController* tracing_controller) {\n+  return new NodePlatform(thread_pool_size, tracing_controller);\n+}\n+\n+MultiIsolatePlatform* InitializeV8Platform(int thread_pool_size) {\n+  per_process::v8_platform.Initialize(thread_pool_size);\n+  return per_process::v8_platform.Platform();\n+}\n+\n+void FreePlatform(MultiIsolatePlatform* platform) {\n+  delete platform;\n+}\n+\n+Local<Context> NewContext(Isolate* isolate,\n+                          Local<ObjectTemplate> object_template) {\n+  auto context = Context::New(isolate, nullptr, object_template);\n+  if (context.IsEmpty()) return context;\n+  HandleScope handle_scope(isolate);\n+\n+  context->SetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration,\n+                           True(isolate));\n+\n+  {\n+    // Run lib/internal/per_context.js\n+    Context::Scope context_scope(context);\n+\n+    std::vector<Local<String>> parameters = {\n+        FIXED_ONE_BYTE_STRING(isolate, \"global\")};\n+    Local<Value> arguments[] = {context->Global()};\n+    MaybeLocal<Function> maybe_fn =\n+        per_process::native_module_loader.LookupAndCompile(\n+            context, \"internal/per_context\", &parameters, nullptr);\n+    if (maybe_fn.IsEmpty()) {\n+      return Local<Context>();\n+    }\n+    Local<Function> fn = maybe_fn.ToLocalChecked();\n+    MaybeLocal<Value> result =\n+        fn->Call(context, Undefined(isolate), arraysize(arguments), arguments);\n+    // Execution failed during context creation.\n+    // TODO(joyeecheung): deprecate this signature and return a MaybeLocal.\n+    if (result.IsEmpty()) {\n+      return Local<Context>();\n+    }\n+  }\n+\n+  return context;\n+}\n+\n+uv_loop_t* GetCurrentEventLoop(Isolate* isolate) {\n+  HandleScope handle_scope(isolate);\n+  Local<Context> context = isolate->GetCurrentContext();\n+  if (context.IsEmpty()) return nullptr;\n+  Environment* env = Environment::GetCurrent(context);\n+  if (env == nullptr) return nullptr;\n+  return env->event_loop();\n+}\n+\n+}  // namespace node"
        },
        {
            "sha": "4d1cca8b6512b4bae564bdf6ad09e8bdb29aafdd",
            "filename": "src/api/exceptions.cc",
            "status": "renamed",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fapi%2Fexceptions.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fapi%2Fexceptions.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fapi%2Fexceptions.cc?ref=ca9e24e8b43b89dc705227a4ed29172c2a95f57f",
            "patch": "@@ -12,6 +12,7 @@\n namespace node {\n \n using v8::Exception;\n+using v8::HandleScope;\n using v8::Integer;\n using v8::Isolate;\n using v8::Local;\n@@ -228,4 +229,17 @@ Local<Value> WinapiErrnoException(Isolate* isolate,\n }\n #endif\n \n+void FatalException(Isolate* isolate, const v8::TryCatch& try_catch) {\n+  // If we try to print out a termination exception, we'd just get 'null',\n+  // so just crashing here with that information seems like a better idea,\n+  // and in particular it seems like we should handle terminations at the call\n+  // site for this function rather than by printing them out somewhere.\n+  CHECK(!try_catch.HasTerminated());\n+\n+  HandleScope scope(isolate);\n+  if (!try_catch.IsVerbose()) {\n+    FatalException(isolate, try_catch.Exception(), try_catch.Message());\n+  }\n+}\n+\n }  // namespace node",
            "previous_filename": "src/exceptions.cc"
        },
        {
            "sha": "b54292638ddf9543964385cd6da4a40d59fe4a16",
            "filename": "src/api/hooks.cc",
            "status": "added",
            "additions": 149,
            "deletions": 0,
            "changes": 149,
            "blob_url": "https://github.com/nodejs/node/blob/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fapi%2Fhooks.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fapi%2Fhooks.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fapi%2Fhooks.cc?ref=ca9e24e8b43b89dc705227a4ed29172c2a95f57f",
            "patch": "@@ -0,0 +1,149 @@\n+#include \"env-inl.h\"\n+#include \"node.h\"\n+#include \"node_process.h\"\n+#include \"async_wrap.h\"\n+\n+namespace node {\n+\n+using v8::Context;\n+using v8::HandleScope;\n+using v8::Integer;\n+using v8::Isolate;\n+using v8::Local;\n+using v8::Object;\n+using v8::String;\n+using v8::Value;\n+using v8::NewStringType;\n+\n+void RunAtExit(Environment* env) {\n+  env->RunAtExitCallbacks();\n+}\n+\n+void AtExit(void (*cb)(void* arg), void* arg) {\n+  auto env = Environment::GetThreadLocalEnv();\n+  AtExit(env, cb, arg);\n+}\n+\n+void AtExit(Environment* env, void (*cb)(void* arg), void* arg) {\n+  CHECK_NOT_NULL(env);\n+  env->AtExit(cb, arg);\n+}\n+\n+void EmitBeforeExit(Environment* env) {\n+  HandleScope handle_scope(env->isolate());\n+  Context::Scope context_scope(env->context());\n+  Local<Value> exit_code = env->process_object()\n+                               ->Get(env->context(), env->exit_code_string())\n+                               .ToLocalChecked()\n+                               ->ToInteger(env->context())\n+                               .ToLocalChecked();\n+  ProcessEmit(env, \"beforeExit\", exit_code).ToLocalChecked();\n+}\n+\n+int EmitExit(Environment* env) {\n+  // process.emit('exit')\n+  HandleScope handle_scope(env->isolate());\n+  Context::Scope context_scope(env->context());\n+  Local<Object> process_object = env->process_object();\n+  process_object\n+      ->Set(env->context(),\n+            FIXED_ONE_BYTE_STRING(env->isolate(), \"_exiting\"),\n+            True(env->isolate()))\n+      .FromJust();\n+\n+  Local<String> exit_code = env->exit_code_string();\n+  int code = process_object->Get(env->context(), exit_code)\n+                 .ToLocalChecked()\n+                 ->Int32Value(env->context())\n+                 .ToChecked();\n+  ProcessEmit(env, \"exit\", Integer::New(env->isolate(), code));\n+\n+  // Reload exit code, it may be changed by `emit('exit')`\n+  return process_object->Get(env->context(), exit_code)\n+      .ToLocalChecked()\n+      ->Int32Value(env->context())\n+      .ToChecked();\n+}\n+\n+void AddPromiseHook(Isolate* isolate, promise_hook_func fn, void* arg) {\n+  Environment* env = Environment::GetCurrent(isolate);\n+  CHECK_NOT_NULL(env);\n+  env->AddPromiseHook(fn, arg);\n+}\n+\n+void AddEnvironmentCleanupHook(Isolate* isolate,\n+                               void (*fun)(void* arg),\n+                               void* arg) {\n+  Environment* env = Environment::GetCurrent(isolate);\n+  CHECK_NOT_NULL(env);\n+  env->AddCleanupHook(fun, arg);\n+}\n+\n+void RemoveEnvironmentCleanupHook(Isolate* isolate,\n+                                  void (*fun)(void* arg),\n+                                  void* arg) {\n+  Environment* env = Environment::GetCurrent(isolate);\n+  CHECK_NOT_NULL(env);\n+  env->RemoveCleanupHook(fun, arg);\n+}\n+\n+async_id AsyncHooksGetExecutionAsyncId(Isolate* isolate) {\n+  // Environment::GetCurrent() allocates a Local<> handle.\n+  HandleScope handle_scope(isolate);\n+  Environment* env = Environment::GetCurrent(isolate);\n+  if (env == nullptr) return -1;\n+  return env->execution_async_id();\n+}\n+\n+async_id AsyncHooksGetTriggerAsyncId(Isolate* isolate) {\n+  // Environment::GetCurrent() allocates a Local<> handle.\n+  HandleScope handle_scope(isolate);\n+  Environment* env = Environment::GetCurrent(isolate);\n+  if (env == nullptr) return -1;\n+  return env->trigger_async_id();\n+}\n+\n+\n+async_context EmitAsyncInit(Isolate* isolate,\n+                            Local<Object> resource,\n+                            const char* name,\n+                            async_id trigger_async_id) {\n+  HandleScope handle_scope(isolate);\n+  Local<String> type =\n+      String::NewFromUtf8(isolate, name, NewStringType::kInternalized)\n+          .ToLocalChecked();\n+  return EmitAsyncInit(isolate, resource, type, trigger_async_id);\n+}\n+\n+async_context EmitAsyncInit(Isolate* isolate,\n+                            Local<Object> resource,\n+                            Local<String> name,\n+                            async_id trigger_async_id) {\n+  HandleScope handle_scope(isolate);\n+  Environment* env = Environment::GetCurrent(isolate);\n+  CHECK_NOT_NULL(env);\n+\n+  // Initialize async context struct\n+  if (trigger_async_id == -1)\n+    trigger_async_id = env->get_default_trigger_async_id();\n+\n+  async_context context = {\n+    env->new_async_id(),  // async_id_\n+    trigger_async_id  // trigger_async_id_\n+  };\n+\n+  // Run init hooks\n+  AsyncWrap::EmitAsyncInit(env, resource, name, context.async_id,\n+                           context.trigger_async_id);\n+\n+  return context;\n+}\n+\n+void EmitAsyncDestroy(Isolate* isolate, async_context asyncContext) {\n+  // Environment::GetCurrent() allocates a Local<> handle.\n+  HandleScope handle_scope(isolate);\n+  AsyncWrap::EmitDestroy(\n+      Environment::GetCurrent(isolate), asyncContext.async_id);\n+}\n+\n+}  // namespace node"
        },
        {
            "sha": "e6993f33b00647ded75cc186fd47d22370cf3d98",
            "filename": "src/api/utils.cc",
            "status": "added",
            "additions": 170,
            "deletions": 0,
            "changes": 170,
            "blob_url": "https://github.com/nodejs/node/blob/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fapi%2Futils.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fapi%2Futils.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fapi%2Futils.cc?ref=ca9e24e8b43b89dc705227a4ed29172c2a95f57f",
            "patch": "@@ -0,0 +1,170 @@\n+#include \"node.h\"\n+#include \"node_internals.h\"\n+\n+#include <signal.h>\n+\n+namespace node {\n+\n+const char* signo_string(int signo) {\n+#define SIGNO_CASE(e)                                                          \\\n+  case e:                                                                      \\\n+    return #e;\n+  switch (signo) {\n+#ifdef SIGHUP\n+    SIGNO_CASE(SIGHUP);\n+#endif\n+\n+#ifdef SIGINT\n+    SIGNO_CASE(SIGINT);\n+#endif\n+\n+#ifdef SIGQUIT\n+    SIGNO_CASE(SIGQUIT);\n+#endif\n+\n+#ifdef SIGILL\n+    SIGNO_CASE(SIGILL);\n+#endif\n+\n+#ifdef SIGTRAP\n+    SIGNO_CASE(SIGTRAP);\n+#endif\n+\n+#ifdef SIGABRT\n+    SIGNO_CASE(SIGABRT);\n+#endif\n+\n+#ifdef SIGIOT\n+#if SIGABRT != SIGIOT\n+    SIGNO_CASE(SIGIOT);\n+#endif\n+#endif\n+\n+#ifdef SIGBUS\n+    SIGNO_CASE(SIGBUS);\n+#endif\n+\n+#ifdef SIGFPE\n+    SIGNO_CASE(SIGFPE);\n+#endif\n+\n+#ifdef SIGKILL\n+    SIGNO_CASE(SIGKILL);\n+#endif\n+\n+#ifdef SIGUSR1\n+    SIGNO_CASE(SIGUSR1);\n+#endif\n+\n+#ifdef SIGSEGV\n+    SIGNO_CASE(SIGSEGV);\n+#endif\n+\n+#ifdef SIGUSR2\n+    SIGNO_CASE(SIGUSR2);\n+#endif\n+\n+#ifdef SIGPIPE\n+    SIGNO_CASE(SIGPIPE);\n+#endif\n+\n+#ifdef SIGALRM\n+    SIGNO_CASE(SIGALRM);\n+#endif\n+\n+    SIGNO_CASE(SIGTERM);\n+\n+#ifdef SIGCHLD\n+    SIGNO_CASE(SIGCHLD);\n+#endif\n+\n+#ifdef SIGSTKFLT\n+    SIGNO_CASE(SIGSTKFLT);\n+#endif\n+\n+#ifdef SIGCONT\n+    SIGNO_CASE(SIGCONT);\n+#endif\n+\n+#ifdef SIGSTOP\n+    SIGNO_CASE(SIGSTOP);\n+#endif\n+\n+#ifdef SIGTSTP\n+    SIGNO_CASE(SIGTSTP);\n+#endif\n+\n+#ifdef SIGBREAK\n+    SIGNO_CASE(SIGBREAK);\n+#endif\n+\n+#ifdef SIGTTIN\n+    SIGNO_CASE(SIGTTIN);\n+#endif\n+\n+#ifdef SIGTTOU\n+    SIGNO_CASE(SIGTTOU);\n+#endif\n+\n+#ifdef SIGURG\n+    SIGNO_CASE(SIGURG);\n+#endif\n+\n+#ifdef SIGXCPU\n+    SIGNO_CASE(SIGXCPU);\n+#endif\n+\n+#ifdef SIGXFSZ\n+    SIGNO_CASE(SIGXFSZ);\n+#endif\n+\n+#ifdef SIGVTALRM\n+    SIGNO_CASE(SIGVTALRM);\n+#endif\n+\n+#ifdef SIGPROF\n+    SIGNO_CASE(SIGPROF);\n+#endif\n+\n+#ifdef SIGWINCH\n+    SIGNO_CASE(SIGWINCH);\n+#endif\n+\n+#ifdef SIGIO\n+    SIGNO_CASE(SIGIO);\n+#endif\n+\n+#ifdef SIGPOLL\n+#if SIGPOLL != SIGIO\n+    SIGNO_CASE(SIGPOLL);\n+#endif\n+#endif\n+\n+#ifdef SIGLOST\n+#if SIGLOST != SIGABRT\n+    SIGNO_CASE(SIGLOST);\n+#endif\n+#endif\n+\n+#ifdef SIGPWR\n+#if SIGPWR != SIGLOST\n+    SIGNO_CASE(SIGPWR);\n+#endif\n+#endif\n+\n+#ifdef SIGINFO\n+#if !defined(SIGPWR) || SIGINFO != SIGPWR\n+    SIGNO_CASE(SIGINFO);\n+#endif\n+#endif\n+\n+#ifdef SIGSYS\n+    SIGNO_CASE(SIGSYS);\n+#endif\n+\n+    default:\n+      return \"\";\n+  }\n+}\n+\n+}  // namespace node"
        },
        {
            "sha": "8f20d4f83705e3925447f3767c3647dd2b3ca791",
            "filename": "src/async_wrap.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 65,
            "changes": 65,
            "blob_url": "https://github.com/nodejs/node/blob/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fasync_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fasync_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.cc?ref=ca9e24e8b43b89dc705227a4ed29172c2a95f57f",
            "patch": "@@ -39,7 +39,6 @@ using v8::Integer;\n using v8::Isolate;\n using v8::Local;\n using v8::MaybeLocal;\n-using v8::NewStringType;\n using v8::Number;\n using v8::Object;\n using v8::ObjectTemplate;\n@@ -688,70 +687,6 @@ MaybeLocal<Value> AsyncWrap::MakeCallback(const Local<Function> cb,\n   return ret;\n }\n \n-\n-/* Public C++ embedder API */\n-\n-\n-async_id AsyncHooksGetExecutionAsyncId(Isolate* isolate) {\n-  // Environment::GetCurrent() allocates a Local<> handle.\n-  HandleScope handle_scope(isolate);\n-  Environment* env = Environment::GetCurrent(isolate);\n-  if (env == nullptr) return -1;\n-  return env->execution_async_id();\n-}\n-\n-\n-async_id AsyncHooksGetTriggerAsyncId(Isolate* isolate) {\n-  // Environment::GetCurrent() allocates a Local<> handle.\n-  HandleScope handle_scope(isolate);\n-  Environment* env = Environment::GetCurrent(isolate);\n-  if (env == nullptr) return -1;\n-  return env->trigger_async_id();\n-}\n-\n-\n-async_context EmitAsyncInit(Isolate* isolate,\n-                            Local<Object> resource,\n-                            const char* name,\n-                            async_id trigger_async_id) {\n-  HandleScope handle_scope(isolate);\n-  Local<String> type =\n-      String::NewFromUtf8(isolate, name, NewStringType::kInternalized)\n-          .ToLocalChecked();\n-  return EmitAsyncInit(isolate, resource, type, trigger_async_id);\n-}\n-\n-async_context EmitAsyncInit(Isolate* isolate,\n-                            Local<Object> resource,\n-                            Local<String> name,\n-                            async_id trigger_async_id) {\n-  HandleScope handle_scope(isolate);\n-  Environment* env = Environment::GetCurrent(isolate);\n-  CHECK_NOT_NULL(env);\n-\n-  // Initialize async context struct\n-  if (trigger_async_id == -1)\n-    trigger_async_id = env->get_default_trigger_async_id();\n-\n-  async_context context = {\n-    env->new_async_id(),  // async_id_\n-    trigger_async_id  // trigger_async_id_\n-  };\n-\n-  // Run init hooks\n-  AsyncWrap::EmitAsyncInit(env, resource, name, context.async_id,\n-                           context.trigger_async_id);\n-\n-  return context;\n-}\n-\n-void EmitAsyncDestroy(Isolate* isolate, async_context asyncContext) {\n-  // Environment::GetCurrent() allocates a Local<> handle.\n-  HandleScope handle_scope(isolate);\n-  AsyncWrap::EmitDestroy(\n-      Environment::GetCurrent(isolate), asyncContext.async_id);\n-}\n-\n std::string AsyncWrap::MemoryInfoName() const {\n   return provider_names[provider_type()];\n }"
        },
        {
            "sha": "745ed83917885e5494c17be1d463d9ab586177e9",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 454,
            "changes": 456,
            "blob_url": "https://github.com/nodejs/node/blob/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=ca9e24e8b43b89dc705227a4ed29172c2a95f57f",
            "patch": "@@ -119,32 +119,21 @@ using v8::Function;\n using v8::FunctionCallbackInfo;\n using v8::HandleScope;\n using v8::Int32;\n-using v8::Integer;\n using v8::Isolate;\n using v8::Just;\n using v8::Local;\n using v8::Locker;\n using v8::Maybe;\n using v8::MaybeLocal;\n-using v8::Message;\n-using v8::MicrotasksPolicy;\n using v8::Object;\n-using v8::ObjectTemplate;\n using v8::Script;\n-using v8::ScriptOrigin;\n using v8::SealHandleScope;\n using v8::String;\n-using v8::TracingController;\n using v8::Undefined;\n using v8::V8;\n using v8::Value;\n \n namespace per_process {\n-// Tells whether --prof is passed.\n-// TODO(joyeecheung): move env->options()->prof_process to\n-// per_process::cli_options.prof_process and use that instead.\n-static bool v8_is_profiling = false;\n-\n // TODO(joyeecheung): these are no longer necessary. Remove them.\n // See: https://github.com/nodejs/node/pull/25302#discussion_r244924196\n // Isolate on the main thread\n@@ -163,6 +152,8 @@ bool v8_initialized = false;\n // node_internals.h\n // process-relative uptime base, initialized at start-up\n double prog_start_time;\n+// Tells whether --prof is passed.\n+bool v8_is_profiling = false;\n \n // node_v8_platform-inl.h\n struct V8Platform v8_platform;\n@@ -172,209 +163,6 @@ struct V8Platform v8_platform;\n static const unsigned kMaxSignal = 32;\n #endif\n \n-const char* signo_string(int signo) {\n-#define SIGNO_CASE(e)  case e: return #e;\n-  switch (signo) {\n-#ifdef SIGHUP\n-  SIGNO_CASE(SIGHUP);\n-#endif\n-\n-#ifdef SIGINT\n-  SIGNO_CASE(SIGINT);\n-#endif\n-\n-#ifdef SIGQUIT\n-  SIGNO_CASE(SIGQUIT);\n-#endif\n-\n-#ifdef SIGILL\n-  SIGNO_CASE(SIGILL);\n-#endif\n-\n-#ifdef SIGTRAP\n-  SIGNO_CASE(SIGTRAP);\n-#endif\n-\n-#ifdef SIGABRT\n-  SIGNO_CASE(SIGABRT);\n-#endif\n-\n-#ifdef SIGIOT\n-# if SIGABRT != SIGIOT\n-  SIGNO_CASE(SIGIOT);\n-# endif\n-#endif\n-\n-#ifdef SIGBUS\n-  SIGNO_CASE(SIGBUS);\n-#endif\n-\n-#ifdef SIGFPE\n-  SIGNO_CASE(SIGFPE);\n-#endif\n-\n-#ifdef SIGKILL\n-  SIGNO_CASE(SIGKILL);\n-#endif\n-\n-#ifdef SIGUSR1\n-  SIGNO_CASE(SIGUSR1);\n-#endif\n-\n-#ifdef SIGSEGV\n-  SIGNO_CASE(SIGSEGV);\n-#endif\n-\n-#ifdef SIGUSR2\n-  SIGNO_CASE(SIGUSR2);\n-#endif\n-\n-#ifdef SIGPIPE\n-  SIGNO_CASE(SIGPIPE);\n-#endif\n-\n-#ifdef SIGALRM\n-  SIGNO_CASE(SIGALRM);\n-#endif\n-\n-  SIGNO_CASE(SIGTERM);\n-\n-#ifdef SIGCHLD\n-  SIGNO_CASE(SIGCHLD);\n-#endif\n-\n-#ifdef SIGSTKFLT\n-  SIGNO_CASE(SIGSTKFLT);\n-#endif\n-\n-\n-#ifdef SIGCONT\n-  SIGNO_CASE(SIGCONT);\n-#endif\n-\n-#ifdef SIGSTOP\n-  SIGNO_CASE(SIGSTOP);\n-#endif\n-\n-#ifdef SIGTSTP\n-  SIGNO_CASE(SIGTSTP);\n-#endif\n-\n-#ifdef SIGBREAK\n-  SIGNO_CASE(SIGBREAK);\n-#endif\n-\n-#ifdef SIGTTIN\n-  SIGNO_CASE(SIGTTIN);\n-#endif\n-\n-#ifdef SIGTTOU\n-  SIGNO_CASE(SIGTTOU);\n-#endif\n-\n-#ifdef SIGURG\n-  SIGNO_CASE(SIGURG);\n-#endif\n-\n-#ifdef SIGXCPU\n-  SIGNO_CASE(SIGXCPU);\n-#endif\n-\n-#ifdef SIGXFSZ\n-  SIGNO_CASE(SIGXFSZ);\n-#endif\n-\n-#ifdef SIGVTALRM\n-  SIGNO_CASE(SIGVTALRM);\n-#endif\n-\n-#ifdef SIGPROF\n-  SIGNO_CASE(SIGPROF);\n-#endif\n-\n-#ifdef SIGWINCH\n-  SIGNO_CASE(SIGWINCH);\n-#endif\n-\n-#ifdef SIGIO\n-  SIGNO_CASE(SIGIO);\n-#endif\n-\n-#ifdef SIGPOLL\n-# if SIGPOLL != SIGIO\n-  SIGNO_CASE(SIGPOLL);\n-# endif\n-#endif\n-\n-#ifdef SIGLOST\n-# if SIGLOST != SIGABRT\n-  SIGNO_CASE(SIGLOST);\n-# endif\n-#endif\n-\n-#ifdef SIGPWR\n-# if SIGPWR != SIGLOST\n-  SIGNO_CASE(SIGPWR);\n-# endif\n-#endif\n-\n-#ifdef SIGINFO\n-# if !defined(SIGPWR) || SIGINFO != SIGPWR\n-  SIGNO_CASE(SIGINFO);\n-# endif\n-#endif\n-\n-#ifdef SIGSYS\n-  SIGNO_CASE(SIGSYS);\n-#endif\n-\n-  default: return \"\";\n-  }\n-}\n-\n-void* ArrayBufferAllocator::Allocate(size_t size) {\n-  if (zero_fill_field_ || per_process::cli_options->zero_fill_all_buffers)\n-    return UncheckedCalloc(size);\n-  else\n-    return UncheckedMalloc(size);\n-}\n-\n-namespace {\n-\n-bool ShouldAbortOnUncaughtException(Isolate* isolate) {\n-  HandleScope scope(isolate);\n-  Environment* env = Environment::GetCurrent(isolate);\n-  return env != nullptr &&\n-         env->should_abort_on_uncaught_toggle()[0] &&\n-         !env->inside_should_not_abort_on_uncaught_scope();\n-}\n-\n-}  // anonymous namespace\n-\n-\n-void AddPromiseHook(Isolate* isolate, promise_hook_func fn, void* arg) {\n-  Environment* env = Environment::GetCurrent(isolate);\n-  CHECK_NOT_NULL(env);\n-  env->AddPromiseHook(fn, arg);\n-}\n-\n-void AddEnvironmentCleanupHook(Isolate* isolate,\n-                               void (*fun)(void* arg),\n-                               void* arg) {\n-  Environment* env = Environment::GetCurrent(isolate);\n-  CHECK_NOT_NULL(env);\n-  env->AddCleanupHook(fun, arg);\n-}\n-\n-\n-void RemoveEnvironmentCleanupHook(Isolate* isolate,\n-                                  void (*fun)(void* arg),\n-                                  void* arg) {\n-  Environment* env = Environment::GetCurrent(isolate);\n-  CHECK_NOT_NULL(env);\n-  env->RemoveCleanupHook(fun, arg);\n-}\n-\n static void WaitForInspectorDisconnect(Environment* env) {\n #if HAVE_INSPECTOR\n   if (env->inspector_agent()->IsActive()) {\n@@ -402,33 +190,6 @@ void Exit(const FunctionCallbackInfo<Value>& args) {\n   env->Exit(code);\n }\n \n-static void OnMessage(Local<Message> message, Local<Value> error) {\n-  Isolate* isolate = message->GetIsolate();\n-  switch (message->ErrorLevel()) {\n-    case Isolate::MessageErrorLevel::kMessageWarning: {\n-      Environment* env = Environment::GetCurrent(isolate);\n-      if (!env) {\n-        break;\n-      }\n-      Utf8Value filename(isolate,\n-          message->GetScriptOrigin().ResourceName());\n-      // (filename):(line) (message)\n-      std::stringstream warning;\n-      warning << *filename;\n-      warning << \":\";\n-      warning << message->GetLineNumber(env->context()).FromMaybe(-1);\n-      warning << \" \";\n-      v8::String::Utf8Value msg(isolate, message->Get());\n-      warning << *msg;\n-      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), \"V8\"));\n-      break;\n-    }\n-    case Isolate::MessageErrorLevel::kMessageError:\n-      FatalException(isolate, error, message);\n-      break;\n-  }\n-}\n-\n void SignalExit(int signo) {\n   uv_tty_reset_mode();\n #ifdef __FreeBSD__\n@@ -969,191 +730,13 @@ void Init(int* argc,\n     argv[i] = strdup(argv_[i].c_str());\n }\n \n-void RunAtExit(Environment* env) {\n-  env->RunAtExitCallbacks();\n-}\n-\n-\n-uv_loop_t* GetCurrentEventLoop(Isolate* isolate) {\n-  HandleScope handle_scope(isolate);\n-  Local<Context> context = isolate->GetCurrentContext();\n-  if (context.IsEmpty())\n-    return nullptr;\n-  Environment* env = Environment::GetCurrent(context);\n-  if (env == nullptr)\n-    return nullptr;\n-  return env->event_loop();\n-}\n-\n-\n-void AtExit(void (*cb)(void* arg), void* arg) {\n-  auto env = Environment::GetThreadLocalEnv();\n-  AtExit(env, cb, arg);\n-}\n-\n-\n-void AtExit(Environment* env, void (*cb)(void* arg), void* arg) {\n-  CHECK_NOT_NULL(env);\n-  env->AtExit(cb, arg);\n-}\n-\n-\n void RunBeforeExit(Environment* env) {\n   env->RunBeforeExitCallbacks();\n \n   if (!uv_loop_alive(env->event_loop()))\n     EmitBeforeExit(env);\n }\n \n-\n-void EmitBeforeExit(Environment* env) {\n-  HandleScope handle_scope(env->isolate());\n-  Context::Scope context_scope(env->context());\n-  Local<Value> exit_code = env->process_object()\n-                               ->Get(env->context(), env->exit_code_string())\n-                               .ToLocalChecked()\n-                               ->ToInteger(env->context())\n-                               .ToLocalChecked();\n-  ProcessEmit(env, \"beforeExit\", exit_code).ToLocalChecked();\n-}\n-\n-int EmitExit(Environment* env) {\n-  // process.emit('exit')\n-  HandleScope handle_scope(env->isolate());\n-  Context::Scope context_scope(env->context());\n-  Local<Object> process_object = env->process_object();\n-  process_object->Set(env->context(),\n-                      FIXED_ONE_BYTE_STRING(env->isolate(), \"_exiting\"),\n-                      True(env->isolate())).FromJust();\n-\n-  Local<String> exit_code = env->exit_code_string();\n-  int code = process_object->Get(env->context(), exit_code).ToLocalChecked()\n-      ->Int32Value(env->context()).ToChecked();\n-  ProcessEmit(env, \"exit\", Integer::New(env->isolate(), code));\n-\n-  // Reload exit code, it may be changed by `emit('exit')`\n-  return process_object->Get(env->context(), exit_code).ToLocalChecked()\n-      ->Int32Value(env->context()).ToChecked();\n-}\n-\n-\n-ArrayBufferAllocator* CreateArrayBufferAllocator() {\n-  return new ArrayBufferAllocator();\n-}\n-\n-\n-void FreeArrayBufferAllocator(ArrayBufferAllocator* allocator) {\n-  delete allocator;\n-}\n-\n-\n-IsolateData* CreateIsolateData(\n-    Isolate* isolate,\n-    uv_loop_t* loop,\n-    MultiIsolatePlatform* platform,\n-    ArrayBufferAllocator* allocator) {\n-  return new IsolateData(\n-        isolate,\n-        loop,\n-        platform,\n-        allocator != nullptr ? allocator->zero_fill_field() : nullptr);\n-}\n-\n-\n-void FreeIsolateData(IsolateData* isolate_data) {\n-  delete isolate_data;\n-}\n-\n-\n-Environment* CreateEnvironment(IsolateData* isolate_data,\n-                               Local<Context> context,\n-                               int argc,\n-                               const char* const* argv,\n-                               int exec_argc,\n-                               const char* const* exec_argv) {\n-  Isolate* isolate = context->GetIsolate();\n-  HandleScope handle_scope(isolate);\n-  Context::Scope context_scope(context);\n-  // TODO(addaleax): This is a much better place for parsing per-Environment\n-  // options than the global parse call.\n-  std::vector<std::string> args(argv, argv + argc);\n-  std::vector<std::string> exec_args(exec_argv, exec_argv + exec_argc);\n-  Environment* env = new Environment(isolate_data, context);\n-  env->Start(per_process::v8_is_profiling);\n-  env->ProcessCliArgs(args, exec_args);\n-  return env;\n-}\n-\n-\n-void FreeEnvironment(Environment* env) {\n-  env->RunCleanup();\n-  delete env;\n-}\n-\n-\n-Environment* GetCurrentEnvironment(Local<Context> context) {\n-  return Environment::GetCurrent(context);\n-}\n-\n-\n-MultiIsolatePlatform* GetMainThreadMultiIsolatePlatform() {\n-  return per_process::v8_platform.Platform();\n-}\n-\n-\n-MultiIsolatePlatform* CreatePlatform(\n-    int thread_pool_size,\n-    node::tracing::TracingController* tracing_controller) {\n-  return new NodePlatform(thread_pool_size, tracing_controller);\n-}\n-\n-\n-MultiIsolatePlatform* InitializeV8Platform(int thread_pool_size) {\n-  per_process::v8_platform.Initialize(thread_pool_size);\n-  return per_process::v8_platform.Platform();\n-}\n-\n-\n-void FreePlatform(MultiIsolatePlatform* platform) {\n-  delete platform;\n-}\n-\n-Local<Context> NewContext(Isolate* isolate,\n-                          Local<ObjectTemplate> object_template) {\n-  Local<Context> context = Context::New(isolate, nullptr, object_template);\n-  if (context.IsEmpty()) return context;\n-  HandleScope handle_scope(isolate);\n-\n-  context->SetEmbedderData(\n-      ContextEmbedderIndex::kAllowWasmCodeGeneration, True(isolate));\n-\n-  {\n-    // Run lib/internal/per_context.js\n-    Context::Scope context_scope(context);\n-\n-    std::vector<Local<String>> parameters = {\n-        FIXED_ONE_BYTE_STRING(isolate, \"global\")};\n-    Local<Value> arguments[] = {context->Global()};\n-    MaybeLocal<Function> maybe_fn =\n-        per_process::native_module_loader.LookupAndCompile(\n-            context, \"internal/per_context\", &parameters, nullptr);\n-    if (maybe_fn.IsEmpty()) {\n-      return Local<Context>();\n-    }\n-    Local<Function> fn = maybe_fn.ToLocalChecked();\n-    MaybeLocal<Value> result =\n-        fn->Call(context, Undefined(isolate), arraysize(arguments), arguments);\n-    // Execution failed during context creation.\n-    // TODO(joyeecheung): deprecate this signature and return a MaybeLocal.\n-    if (result.IsEmpty()) {\n-      return Local<Context>();\n-    }\n-  }\n-\n-  return context;\n-}\n-\n-\n inline int Start(Isolate* isolate, IsolateData* isolate_data,\n                  const std::vector<std::string>& args,\n                  const std::vector<std::string>& exec_args) {\n@@ -1235,41 +818,6 @@ inline int Start(Isolate* isolate, IsolateData* isolate_data,\n   return exit_code;\n }\n \n-bool AllowWasmCodeGenerationCallback(\n-    Local<Context> context, Local<String>) {\n-  Local<Value> wasm_code_gen =\n-    context->GetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration);\n-  return wasm_code_gen->IsUndefined() || wasm_code_gen->IsTrue();\n-}\n-\n-Isolate* NewIsolate(ArrayBufferAllocator* allocator, uv_loop_t* event_loop) {\n-  Isolate::CreateParams params;\n-  params.array_buffer_allocator = allocator;\n-#ifdef NODE_ENABLE_VTUNE_PROFILING\n-  params.code_event_handler = vTune::GetVtuneCodeEventHandler();\n-#endif\n-\n-  Isolate* isolate = Isolate::Allocate();\n-  if (isolate == nullptr)\n-    return nullptr;\n-\n-  // Register the isolate on the platform before the isolate gets initialized,\n-  // so that the isolate can access the platform during initialization.\n-  per_process::v8_platform.Platform()->RegisterIsolate(isolate, event_loop);\n-  Isolate::Initialize(isolate, params);\n-\n-  isolate->AddMessageListenerWithErrorLevel(OnMessage,\n-      Isolate::MessageErrorLevel::kMessageError |\n-      Isolate::MessageErrorLevel::kMessageWarning);\n-  isolate->SetAbortOnUncaughtExceptionCallback(ShouldAbortOnUncaughtException);\n-  isolate->SetMicrotasksPolicy(MicrotasksPolicy::kExplicit);\n-  isolate->SetFatalErrorHandler(OnFatalError);\n-  isolate->SetAllowWasmCodeGenerationCallback(AllowWasmCodeGenerationCallback);\n-  v8::CpuProfiler::UseDetailedSourcePositionsForProfiling(isolate);\n-\n-  return isolate;\n-}\n-\n inline int Start(uv_loop_t* event_loop,\n                  const std::vector<std::string>& args,\n                  const std::vector<std::string>& exec_args) {"
        },
        {
            "sha": "5a9f08839ceb52bb5590f6a52604d403126b1cae",
            "filename": "src/node_errors.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fnode_errors.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fnode_errors.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_errors.cc?ref=ca9e24e8b43b89dc705227a4ed29172c2a95f57f",
            "patch": "@@ -763,19 +763,6 @@ void FatalException(Isolate* isolate,\n   }\n }\n \n-void FatalException(Isolate* isolate, const v8::TryCatch& try_catch) {\n-  // If we try to print out a termination exception, we'd just get 'null',\n-  // so just crashing here with that information seems like a better idea,\n-  // and in particular it seems like we should handle terminations at the call\n-  // site for this function rather than by printing them out somewhere.\n-  CHECK(!try_catch.HasTerminated());\n-\n-  HandleScope scope(isolate);\n-  if (!try_catch.IsVerbose()) {\n-    FatalException(isolate, try_catch.Exception(), try_catch.Message());\n-  }\n-}\n-\n void FatalException(const FunctionCallbackInfo<Value>& args) {\n   Isolate* isolate = args.GetIsolate();\n   Environment* env = Environment::GetCurrent(isolate);"
        },
        {
            "sha": "b34e6f90e7d28cf65c858b91d7c999f733d707c6",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/ca9e24e8b43b89dc705227a4ed29172c2a95f57f/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=ca9e24e8b43b89dc705227a4ed29172c2a95f57f",
            "patch": "@@ -56,6 +56,7 @@ class NativeModuleLoader;\n namespace per_process {\n extern Mutex env_var_mutex;\n extern double prog_start_time;\n+extern bool v8_is_profiling;\n }  // namespace per_process\n \n // Forward declaration"
        }
    ],
    "stats": {
        "total": 1092,
        "additions": 557,
        "deletions": 535
    }
}