{
    "author": "oyyd",
    "message": "tls: close StreamWrap and its stream correctly\n\nWhen sockets of the \"net\" module destroyed, they will call\n`this._handle.close()` which will also emit EOF if not emitted\nbefore. This feature makes sockets on the other side emit \"end\" and\n\"close\" even though we haven't called `end()`. As `stream` of\n`StreamWrap` are likely to be instances of `net.Socket`, calling\n`destroy()` manually will avoid issues that don't properly close\nwrapped connections.\n\nFixes: https://github.com/nodejs/node/issues/14605\n\nPR-URL: https://github.com/nodejs/node/pull/23654\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "517955a474877893751d71b33f9c02a21bc25000",
    "files": [
        {
            "sha": "7ca7ff8bf49d25bbeec965efa5ef2a8a141fa13b",
            "filename": "lib/internal/wrap_js_stream.js",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/517955a474877893751d71b33f9c02a21bc25000/lib%2Finternal%2Fwrap_js_stream.js",
            "raw_url": "https://github.com/nodejs/node/raw/517955a474877893751d71b33f9c02a21bc25000/lib%2Finternal%2Fwrap_js_stream.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fwrap_js_stream.js?ref=517955a474877893751d71b33f9c02a21bc25000",
            "patch": "@@ -68,6 +68,12 @@ class JSStreamWrap extends Socket {\n       if (this._handle)\n         this._handle.emitEOF();\n     });\n+    // Some `Stream` don't pass `hasError` parameters when closed.\n+    stream.once('close', () => {\n+      // Errors emitted from `stream` have also been emitted to this instance\n+      // so that we don't pass errors to `destroy()` again.\n+      this.destroy();\n+    });\n \n     super({ handle, manualStart: true });\n     this.stream = stream;\n@@ -188,6 +194,14 @@ class JSStreamWrap extends Socket {\n   doClose(cb) {\n     const handle = this._handle;\n \n+    // When sockets of the \"net\" module destroyed, they will call\n+    // `this._handle.close()` which will also emit EOF if not emitted before.\n+    // This feature makes sockets on the other side emit \"end\" and \"close\"\n+    // even though we haven't called `end()`. As `stream` are likely to be\n+    // instances of `net.Socket`, calling `stream.destroy()` manually will\n+    // avoid issues that don't properly close wrapped connections.\n+    this.stream.destroy();\n+\n     setImmediate(() => {\n       // Should be already set by net.js\n       assert.strictEqual(this._handle, null);"
        },
        {
            "sha": "eb7a2ca338bd40f94c8ea3ede8af6600c0170fa6",
            "filename": "test/parallel/test-tls-destroy-stream.js",
            "status": "added",
            "additions": 69,
            "deletions": 0,
            "changes": 69,
            "blob_url": "https://github.com/nodejs/node/blob/517955a474877893751d71b33f9c02a21bc25000/test%2Fparallel%2Ftest-tls-destroy-stream.js",
            "raw_url": "https://github.com/nodejs/node/raw/517955a474877893751d71b33f9c02a21bc25000/test%2Fparallel%2Ftest-tls-destroy-stream.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-destroy-stream.js?ref=517955a474877893751d71b33f9c02a21bc25000",
            "patch": "@@ -0,0 +1,69 @@\n+'use strict';\n+\n+const common = require('../common');\n+if (!common.hasCrypto) common.skip('missing crypto');\n+\n+const fixtures = require('../common/fixtures');\n+const makeDuplexPair = require('../common/duplexpair');\n+const net = require('net');\n+const assert = require('assert');\n+const tls = require('tls');\n+\n+// This test ensures that an instance of StreamWrap should emit \"end\" and\n+// \"close\" when the socket on the other side call `destroy()` instead of\n+// `end()`.\n+// Refs: https://github.com/nodejs/node/issues/14605\n+const CONTENT = 'Hello World';\n+const tlsServer = tls.createServer(\n+  {\n+    key: fixtures.readSync('test_key.pem'),\n+    cert: fixtures.readSync('test_cert.pem'),\n+    ca: [fixtures.readSync('test_ca.pem')],\n+  },\n+  (socket) => {\n+    socket.on('error', common.mustNotCall());\n+    socket.on('close', common.mustCall());\n+    socket.write(CONTENT);\n+    socket.destroy();\n+  },\n+);\n+\n+const server = net.createServer((conn) => {\n+  conn.on('error', common.mustNotCall());\n+  // Assume that we want to use data to determine what to do with connections.\n+  conn.once('data', common.mustCall((chunk) => {\n+    const { clientSide, serverSide } = makeDuplexPair();\n+    serverSide.on('close', common.mustCall(() => {\n+      conn.destroy();\n+    }));\n+    clientSide.pipe(conn);\n+    conn.pipe(clientSide);\n+\n+    conn.on('close', common.mustCall(() => {\n+      clientSide.destroy();\n+    }));\n+    clientSide.on('close', common.mustCall(() => {\n+      conn.destroy();\n+    }));\n+\n+    process.nextTick(() => {\n+      conn.unshift(chunk);\n+    });\n+\n+    tlsServer.emit('connection', serverSide);\n+  }));\n+});\n+\n+server.listen(0, () => {\n+  const port = server.address().port;\n+  const conn = tls.connect({ port, rejectUnauthorized: false }, () => {\n+    conn.on('data', common.mustCall((data) => {\n+      assert.strictEqual(data.toString('utf8'), CONTENT);\n+    }));\n+    conn.on('error', common.mustNotCall());\n+    conn.on(\n+      'close',\n+      common.mustCall(() => server.close()),\n+    );\n+  });\n+});"
        },
        {
            "sha": "16d3e75e2ca7e327d3d8ed3ed39c433f592e1792",
            "filename": "test/parallel/test-wrap-js-stream-destroy.js",
            "status": "added",
            "additions": 118,
            "deletions": 0,
            "changes": 118,
            "blob_url": "https://github.com/nodejs/node/blob/517955a474877893751d71b33f9c02a21bc25000/test%2Fparallel%2Ftest-wrap-js-stream-destroy.js",
            "raw_url": "https://github.com/nodejs/node/raw/517955a474877893751d71b33f9c02a21bc25000/test%2Fparallel%2Ftest-wrap-js-stream-destroy.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-wrap-js-stream-destroy.js?ref=517955a474877893751d71b33f9c02a21bc25000",
            "patch": "@@ -0,0 +1,118 @@\n+'use strict';\n+\n+const common = require('../common');\n+const StreamWrap = require('_stream_wrap');\n+const net = require('net');\n+\n+// This test ensures that when we directly call `socket.destroy()` without\n+// having called `socket.end()` on an instance of streamWrap, it will\n+// still emit EOF which makes the socket on the other side emit \"end\" and\n+// \"close\" events, and vice versa.\n+{\n+  let port;\n+  const server = net.createServer((socket) => {\n+    socket.on('error', common.mustNotCall());\n+    socket.on('end', common.mustNotCall());\n+    socket.on('close', common.mustCall());\n+    socket.destroy();\n+  });\n+\n+  server.listen(() => {\n+    port = server.address().port;\n+    createSocket();\n+  });\n+\n+  function createSocket() {\n+    let streamWrap;\n+    const socket = new net.connect({\n+      port,\n+    }, () => {\n+      socket.on('error', common.mustNotCall());\n+      socket.on('end', common.mustCall());\n+      socket.on('close', common.mustCall());\n+\n+      streamWrap.on('error', common.mustNotCall());\n+      // The \"end\" events will be emitted which is as same as\n+      // the same situation for an instance of `net.Socket` without\n+      // `StreamWrap`.\n+      streamWrap.on('end', common.mustCall());\n+      // Destroying a socket in the server side should emit EOF and cause\n+      // the corresponding client-side socket closed.\n+      streamWrap.on('close', common.mustCall(() => {\n+        server.close();\n+      }));\n+    });\n+    streamWrap = new StreamWrap(socket);\n+  }\n+}\n+\n+// Destroy the streamWrap and test again.\n+{\n+  let port;\n+  const server = net.createServer((socket) => {\n+    socket.on('error', common.mustNotCall());\n+    socket.on('end', common.mustCall());\n+    socket.on('close', common.mustCall(() => {\n+      server.close();\n+    }));\n+    // Do not `socket.end()` and directly `socket.destroy()`.\n+  });\n+\n+  server.listen(() => {\n+    port = server.address().port;\n+    createSocket();\n+  });\n+\n+  function createSocket() {\n+    let streamWrap;\n+    const socket = new net.connect({\n+      port,\n+    }, () => {\n+      socket.on('error', common.mustNotCall());\n+      socket.on('end', common.mustNotCall());\n+      socket.on('close', common.mustCall());\n+\n+      streamWrap.on('error', common.mustNotCall());\n+      streamWrap.on('end', common.mustNotCall());\n+      // Destroying a socket in the server side should emit EOF and cause\n+      // the corresponding client-side socket closed.\n+      streamWrap.on('close', common.mustCall());\n+      streamWrap.destroy();\n+    });\n+    streamWrap = new StreamWrap(socket);\n+  }\n+}\n+\n+// Destroy the client socket and test again.\n+{\n+  let port;\n+  const server = net.createServer((socket) => {\n+    socket.on('error', common.mustNotCall());\n+    socket.on('end', common.mustCall());\n+    socket.on('close', common.mustCall(() => {\n+      server.close();\n+    }));\n+  });\n+\n+  server.listen(() => {\n+    port = server.address().port;\n+    createSocket();\n+  });\n+\n+  function createSocket() {\n+    let streamWrap;\n+    const socket = new net.connect({\n+      port,\n+    }, () => {\n+      socket.on('error', common.mustNotCall());\n+      socket.on('end', common.mustNotCall());\n+      socket.on('close', common.mustCall());\n+\n+      streamWrap.on('error', common.mustNotCall());\n+      streamWrap.on('end', common.mustNotCall());\n+      streamWrap.on('close', common.mustCall());\n+      socket.destroy();\n+    });\n+    streamWrap = new StreamWrap(socket);\n+  }\n+}"
        }
    ],
    "stats": {
        "total": 201,
        "additions": 201,
        "deletions": 0
    }
}