{
    "author": "tniessen",
    "message": "crypto: make PEM parsing RFC7468-compliant\n\nPR-URL: https://github.com/nodejs/node/pull/23164\nFixes: https://github.com/nodejs/node/issues/13612\nFixes: https://github.com/nodejs/node/issues/22815\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "ad07e44b37811e0a06aac0355bd8a13aece0f9b0",
    "files": [
        {
            "sha": "2932df5a4054244e8e15dafff6d9785f79fedaf8",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 51,
            "deletions": 32,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/ad07e44b37811e0a06aac0355bd8a13aece0f9b0/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/ad07e44b37811e0a06aac0355bd8a13aece0f9b0/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=ad07e44b37811e0a06aac0355bd8a13aece0f9b0",
            "patch": "@@ -45,13 +45,6 @@\n #include <memory>\n #include <vector>\n \n-static const char PUBLIC_KEY_PFX[] =  \"-----BEGIN PUBLIC KEY-----\";\n-static const int PUBLIC_KEY_PFX_LEN = sizeof(PUBLIC_KEY_PFX) - 1;\n-static const char PUBRSA_KEY_PFX[] =  \"-----BEGIN RSA PUBLIC KEY-----\";\n-static const int PUBRSA_KEY_PFX_LEN = sizeof(PUBRSA_KEY_PFX) - 1;\n-static const char CERTIFICATE_PFX[] =  \"-----BEGIN CERTIFICATE-----\";\n-static const int CERTIFICATE_PFX_LEN = sizeof(CERTIFICATE_PFX) - 1;\n-\n static const int X509_NAME_FLAGS = ASN1_STRFLGS_ESC_CTRL\n                                  | ASN1_STRFLGS_UTF8_CONVERT\n                                  | XN_FLAG_SEP_MULTILINE\n@@ -3650,38 +3643,64 @@ enum ParsePublicKeyResult {\n   kParsePublicFailed\n };\n \n+static ParsePublicKeyResult TryParsePublicKey(\n+    EVPKeyPointer* pkey,\n+    const BIOPointer& bp,\n+    const char* name,\n+    // NOLINTNEXTLINE(runtime/int)\n+    std::function<EVP_PKEY*(const unsigned char** p, long l)> parse) {\n+  unsigned char* der_data;\n+  long der_len;  // NOLINT(runtime/int)\n+\n+  // This skips surrounding data and decodes PEM to DER.\n+  {\n+    MarkPopErrorOnReturn mark_pop_error_on_return;\n+    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,\n+                           bp.get(), nullptr, nullptr) != 1)\n+      return kParsePublicNotRecognized;\n+  }\n+\n+  // OpenSSL might modify the pointer, so we need to make a copy before parsing.\n+  const unsigned char* p = der_data;\n+  pkey->reset(parse(&p, der_len));\n+  OPENSSL_clear_free(der_data, der_len);\n+\n+  return *pkey ? kParsePublicOk : kParsePublicFailed;\n+}\n+\n static ParsePublicKeyResult ParsePublicKey(EVPKeyPointer* pkey,\n                                            const char* key_pem,\n                                            int key_pem_len) {\n   BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));\n   if (!bp)\n     return kParsePublicFailed;\n \n-  // Check if this is a PKCS#8 or RSA public key before trying as X.509.\n-  if (strncmp(key_pem, PUBLIC_KEY_PFX, PUBLIC_KEY_PFX_LEN) == 0) {\n-    pkey->reset(\n-        PEM_read_bio_PUBKEY(bp.get(), nullptr, NoPasswordCallback, nullptr));\n-  } else if (strncmp(key_pem, PUBRSA_KEY_PFX, PUBRSA_KEY_PFX_LEN) == 0) {\n-    RSAPointer rsa(PEM_read_bio_RSAPublicKey(\n-        bp.get(), nullptr, PasswordCallback, nullptr));\n-    if (rsa) {\n-      pkey->reset(EVP_PKEY_new());\n-      if (*pkey)\n-        EVP_PKEY_set1_RSA(pkey->get(), rsa.get());\n-    }\n-  } else if (strncmp(key_pem, CERTIFICATE_PFX, CERTIFICATE_PFX_LEN) == 0) {\n-    // X.509 fallback\n-    X509Pointer x509(PEM_read_bio_X509(\n-        bp.get(), nullptr, NoPasswordCallback, nullptr));\n-    if (!x509)\n-      return kParsePublicFailed;\n-\n-    pkey->reset(X509_get_pubkey(x509.get()));\n-  } else {\n-    return kParsePublicNotRecognized;\n-  }\n-\n-  return *pkey ? kParsePublicOk : kParsePublicFailed;\n+  ParsePublicKeyResult ret;\n+\n+  // Try PKCS#8 first.\n+  ret = TryParsePublicKey(pkey, bp, \"PUBLIC KEY\",\n+      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)\n+        return d2i_PUBKEY(nullptr, p, l);\n+      });\n+  if (ret != kParsePublicNotRecognized)\n+    return ret;\n+\n+  // Maybe it is PKCS#1.\n+  CHECK(BIO_reset(bp.get()));\n+  ret = TryParsePublicKey(pkey, bp, \"RSA PUBLIC KEY\",\n+      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)\n+        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);\n+      });\n+  if (ret != kParsePublicNotRecognized)\n+    return ret;\n+\n+  // X.509 fallback.\n+  CHECK(BIO_reset(bp.get()));\n+  return TryParsePublicKey(pkey, bp, \"CERTIFICATE\",\n+      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)\n+        X509Pointer x509(d2i_X509(nullptr, p, l));\n+        return x509 ? X509_get_pubkey(x509.get()) : nullptr;\n+      });\n }\n \n void Verify::Initialize(Environment* env, v8::Local<Object> target) {"
        }
    ],
    "stats": {
        "total": 83,
        "additions": 51,
        "deletions": 32
    }
}