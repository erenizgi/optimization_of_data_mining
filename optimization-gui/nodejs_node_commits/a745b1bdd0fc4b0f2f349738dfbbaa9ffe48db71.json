{
    "author": "sam-github",
    "message": "test: cover tls multi-identity option mixtures\n\nProve that cert and key options do not have to be ordered, and that the\npfx option can be used at the same time as the cert/key option\n(which was claimed to be impossible by some pre-existing documentation).\n\nPR-URL: https://github.com/nodejs/node/pull/24374\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Franziska Hinkelmann <franziska.hinkelmann@gmail.com>",
    "sha": "a745b1bdd0fc4b0f2f349738dfbbaa9ffe48db71",
    "files": [
        {
            "sha": "8ccc0d32d93757651010fae3f4545a68677ec6f6",
            "filename": "test/parallel/test-tls-multi-key.js",
            "status": "modified",
            "additions": 146,
            "deletions": 30,
            "changes": 176,
            "blob_url": "https://github.com/nodejs/node/blob/a745b1bdd0fc4b0f2f349738dfbbaa9ffe48db71/test%2Fparallel%2Ftest-tls-multi-key.js",
            "raw_url": "https://github.com/nodejs/node/raw/a745b1bdd0fc4b0f2f349738dfbbaa9ffe48db71/test%2Fparallel%2Ftest-tls-multi-key.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-tls-multi-key.js?ref=a745b1bdd0fc4b0f2f349738dfbbaa9ffe48db71",
            "patch": "@@ -21,52 +21,168 @@\n \n 'use strict';\n const common = require('../common');\n+\n+// Test multi-identity ('key')/multi-algorithm scenarios.\n+\n if (!common.hasCrypto)\n   common.skip('missing crypto');\n \n const fixtures = require('../common/fixtures');\n const assert = require('assert');\n const tls = require('tls');\n \n-const options = {\n+// Key is ordered as ec, rsa, cert is ordered as rsa, ec.\n+test({\n   key: [\n-    fixtures.readKey('ec-key.pem'),\n+    fixtures.readKey('ec10-key.pem'),\n+    fixtures.readKey('agent1-key.pem'),\n+  ],\n+  cert: [\n+    fixtures.readKey('agent1-cert.pem'),\n+    fixtures.readKey('ec10-cert.pem'),\n+  ],\n+  eccCN: 'agent10.example.com',\n+  client: { ca: [\n+    fixtures.readKey('ca5-cert.pem'),\n+    fixtures.readKey('ca1-cert.pem'),\n+  ] },\n+});\n+\n+// Key and cert are ordered as ec, rsa.\n+test({\n+  key: [\n+    fixtures.readKey('ec10-key.pem'),\n     fixtures.readKey('agent1-key.pem'),\n   ],\n   cert: [\n     fixtures.readKey('agent1-cert.pem'),\n+    fixtures.readKey('ec10-cert.pem'),\n+  ],\n+  eccCN: 'agent10.example.com',\n+  client: { ca: [\n+    fixtures.readKey('ca5-cert.pem'),\n+    fixtures.readKey('ca1-cert.pem'),\n+  ] },\n+});\n+\n+// Key, cert, and pfx options can be used simultaneously.\n+test({\n+  key: [\n+    fixtures.readKey('ec-key.pem'),\n+  ],\n+  cert: [\n     fixtures.readKey('ec-cert.pem'),\n-  ]\n-};\n+  ],\n+  pfx: fixtures.readKey('agent1.pfx'),\n+  passphrase: 'sample',\n+  client: { ca: [\n+    fixtures.readKey('ec-cert.pem'),\n+    fixtures.readKey('ca1-cert.pem'),\n+  ] },\n+});\n \n-const ciphers = [];\n+// Key and cert with mixed algorithms, and cert chains with intermediate CAs\n+test({\n+  key: [\n+    fixtures.readKey('ec10-key.pem'),\n+    fixtures.readKey('agent10-key.pem'),\n+  ],\n+  cert: [\n+    fixtures.readKey('agent10-cert.pem'),\n+    fixtures.readKey('ec10-cert.pem'),\n+  ],\n+  rsaCN: 'agent10.example.com',\n+  eccCN: 'agent10.example.com',\n+  client: { ca: [\n+    fixtures.readKey('ca2-cert.pem'),\n+    fixtures.readKey('ca5-cert.pem'),\n+  ] },\n+});\n+\n+// Key and cert with mixed algorithms, and cert chains with intermediate CAs,\n+// using PFX for EC.\n+test({\n+  key: [\n+    fixtures.readKey('agent10-key.pem'),\n+  ],\n+  cert: [\n+    fixtures.readKey('agent10-cert.pem'),\n+  ],\n+  pfx: fixtures.readKey('ec10.pfx'),\n+  passphrase: 'sample',\n+  rsaCN: 'agent10.example.com',\n+  eccCN: 'agent10.example.com',\n+  client: { ca: [\n+    fixtures.readKey('ca2-cert.pem'),\n+    fixtures.readKey('ca5-cert.pem'),\n+  ] },\n+});\n+\n+// Key and cert with mixed algorithms, and cert chains with intermediate CAs,\n+// using PFX for RSA.\n+test({\n+  key: [\n+    fixtures.readKey('ec10-key.pem'),\n+  ],\n+  cert: [\n+    fixtures.readKey('ec10-cert.pem'),\n+  ],\n+  pfx: fixtures.readKey('agent10.pfx'),\n+  passphrase: 'sample',\n+  rsaCN: 'agent10.example.com',\n+  eccCN: 'agent10.example.com',\n+  client: { ca: [\n+    fixtures.readKey('ca2-cert.pem'),\n+    fixtures.readKey('ca5-cert.pem'),\n+  ] },\n+});\n+\n+function test(options) {\n+  const rsaCN = options.rsaCN || 'agent1';\n+  const eccCN = options.eccCN || 'agent2';\n+  const clientTrustRoots = options.client.ca;\n+  delete options.rsaCN;\n+  delete options.eccCN;\n+  delete options.client;\n+  const server = tls.createServer(options, function(conn) {\n+    conn.end('ok');\n+  }).listen(0, common.mustCall(connectWithEcdsa));\n \n-const server = tls.createServer(options, function(conn) {\n-  conn.end('ok');\n-}).listen(0, function() {\n-  const ecdsa = tls.connect(this.address().port, {\n-    ciphers: 'ECDHE-ECDSA-AES256-GCM-SHA384',\n-    rejectUnauthorized: false\n-  }, function() {\n-    ciphers.push(ecdsa.getCipher());\n+  function connectWithEcdsa() {\n+    const ecdsa = tls.connect(this.address().port, {\n+      ciphers: 'ECDHE-ECDSA-AES256-GCM-SHA384',\n+      rejectUnauthorized: true,\n+      ca: clientTrustRoots,\n+      checkServerIdentity: (_, c) => assert.strictEqual(c.subject.CN, eccCN),\n+    }, common.mustCall(function() {\n+      assert.deepStrictEqual(ecdsa.getCipher(), {\n+        name: 'ECDHE-ECDSA-AES256-GCM-SHA384',\n+        version: 'TLSv1/SSLv3'\n+      });\n+      assert.strictEqual(ecdsa.getPeerCertificate().subject.CN, eccCN);\n+      // XXX(sam) certs don't currently include EC key info, so depend on\n+      // absence of RSA key info to indicate key is EC.\n+      assert(!ecdsa.getPeerCertificate().exponent, 'not cert for an RSA key');\n+      ecdsa.end();\n+      connectWithRsa();\n+    }));\n+  }\n+\n+  function connectWithRsa() {\n     const rsa = tls.connect(server.address().port, {\n       ciphers: 'ECDHE-RSA-AES256-GCM-SHA384',\n-      rejectUnauthorized: false\n-    }, function() {\n-      ciphers.push(rsa.getCipher());\n-      ecdsa.end();\n+      rejectUnauthorized: true,\n+      ca: clientTrustRoots,\n+      checkServerIdentity: (_, c) => assert.strictEqual(c.subject.CN, rsaCN),\n+    }, common.mustCall(function() {\n+      assert.deepStrictEqual(rsa.getCipher(), {\n+        name: 'ECDHE-RSA-AES256-GCM-SHA384',\n+        version: 'TLSv1/SSLv3'\n+      });\n+      assert.strictEqual(rsa.getPeerCertificate().subject.CN, rsaCN);\n+      assert(rsa.getPeerCertificate().exponent, 'cert for an RSA key');\n       rsa.end();\n       server.close();\n-    });\n-  });\n-});\n-\n-process.on('exit', function() {\n-  assert.deepStrictEqual(ciphers, [{\n-    name: 'ECDHE-ECDSA-AES256-GCM-SHA384',\n-    version: 'TLSv1/SSLv3'\n-  }, {\n-    name: 'ECDHE-RSA-AES256-GCM-SHA384',\n-    version: 'TLSv1/SSLv3'\n-  }]);\n-});\n+    }));\n+  }\n+}"
        }
    ],
    "stats": {
        "total": 176,
        "additions": 146,
        "deletions": 30
    }
}