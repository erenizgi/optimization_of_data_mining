{
    "author": "addaleax",
    "message": "http2: fix issues with aborted `respondWithFile()`s\n\nPR-URL: https://github.com/nodejs/node/pull/21561\nFixes: https://github.com/nodejs/node/issues/20824\nFixes: https://github.com/nodejs/node/issues/21560\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "d94950e960e41a90c4dd5030795ecfb733ff1e8e",
    "files": [
        {
            "sha": "1274bc7f5b8d4d24fd10267424b700d800056a45",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/d94950e960e41a90c4dd5030795ecfb733ff1e8e/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d94950e960e41a90c4dd5030795ecfb733ff1e8e/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=d94950e960e41a90c4dd5030795ecfb733ff1e8e",
            "patch": "@@ -2060,10 +2060,9 @@ int Http2Stream::DoWrite(WriteWrap* req_wrap,\n                          uv_buf_t* bufs,\n                          size_t nbufs,\n                          uv_stream_t* send_handle) {\n-  CHECK(!this->IsDestroyed());\n   CHECK_NULL(send_handle);\n   Http2Scope h2scope(this);\n-  if (!IsWritable()) {\n+  if (!IsWritable() || IsDestroyed()) {\n     req_wrap->Done(UV_EOF);\n     return 0;\n   }"
        },
        {
            "sha": "e19f98e35d2821649a7f982dc4b1783bbb2162ee",
            "filename": "src/stream_pipe.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/d94950e960e41a90c4dd5030795ecfb733ff1e8e/src%2Fstream_pipe.cc",
            "raw_url": "https://github.com/nodejs/node/raw/d94950e960e41a90c4dd5030795ecfb733ff1e8e/src%2Fstream_pipe.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_pipe.cc?ref=d94950e960e41a90c4dd5030795ecfb733ff1e8e",
            "patch": "@@ -57,9 +57,11 @@ void StreamPipe::Unpipe() {\n   if (is_closed_)\n     return;\n \n-  // Note that we cannot use virtual methods on `source` and `sink` here,\n-  // because this function can be called from their destructors via\n+  // Note that we possibly cannot use virtual methods on `source` and `sink`\n+  // here, because this function can be called from their destructors via\n   // `OnStreamDestroy()`.\n+  if (!source_destroyed_)\n+    source()->ReadStop();\n \n   is_closed_ = true;\n   is_reading_ = false;\n@@ -144,7 +146,8 @@ void StreamPipe::ProcessData(size_t nread, const uv_buf_t& buf) {\n     is_writing_ = true;\n     is_reading_ = false;\n     res.wrap->SetAllocatedStorage(buf.base, buf.len);\n-    source()->ReadStop();\n+    if (source() != nullptr)\n+      source()->ReadStop();\n   }\n }\n \n@@ -183,13 +186,15 @@ void StreamPipe::WritableListener::OnStreamAfterShutdown(ShutdownWrap* w,\n \n void StreamPipe::ReadableListener::OnStreamDestroy() {\n   StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);\n+  pipe->source_destroyed_ = true;\n   if (!pipe->is_eof_) {\n     OnStreamRead(UV_EPIPE, uv_buf_init(nullptr, 0));\n   }\n }\n \n void StreamPipe::WritableListener::OnStreamDestroy() {\n   StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);\n+  pipe->sink_destroyed_ = true;\n   pipe->is_eof_ = true;\n   pipe->Unpipe();\n }"
        },
        {
            "sha": "36a0b1dc08106bc4a579f60cfd0d10b37da46681",
            "filename": "src/stream_pipe.h",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/d94950e960e41a90c4dd5030795ecfb733ff1e8e/src%2Fstream_pipe.h",
            "raw_url": "https://github.com/nodejs/node/raw/d94950e960e41a90c4dd5030795ecfb733ff1e8e/src%2Fstream_pipe.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_pipe.h?ref=d94950e960e41a90c4dd5030795ecfb733ff1e8e",
            "patch": "@@ -23,16 +23,18 @@ class StreamPipe : public AsyncWrap {\n   }\n \n  private:\n-  StreamBase* source();\n-  StreamBase* sink();\n+  inline StreamBase* source();\n+  inline StreamBase* sink();\n \n-  void ShutdownWritable();\n-  void FlushToWritable();\n+  inline void ShutdownWritable();\n+  inline void FlushToWritable();\n \n   bool is_reading_ = false;\n   bool is_writing_ = false;\n   bool is_eof_ = false;\n   bool is_closed_ = true;\n+  bool sink_destroyed_ = false;\n+  bool source_destroyed_ = false;\n \n   // Set a default value so that when we’re coming from Start(), we know\n   // that we don’t want to read just yet."
        },
        {
            "sha": "25926b2c9805a341a124d471958e2ec808e9842b",
            "filename": "test/parallel/test-http2-respond-with-file-connection-abort.js",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/d94950e960e41a90c4dd5030795ecfb733ff1e8e/test%2Fparallel%2Ftest-http2-respond-with-file-connection-abort.js",
            "raw_url": "https://github.com/nodejs/node/raw/d94950e960e41a90c4dd5030795ecfb733ff1e8e/test%2Fparallel%2Ftest-http2-respond-with-file-connection-abort.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http2-respond-with-file-connection-abort.js?ref=d94950e960e41a90c4dd5030795ecfb733ff1e8e",
            "patch": "@@ -0,0 +1,37 @@\n+'use strict';\n+\n+const common = require('../common');\n+if (!common.hasCrypto)\n+  common.skip('missing crypto');\n+const http2 = require('http2');\n+const net = require('net');\n+\n+const {\n+  HTTP2_HEADER_CONTENT_TYPE\n+} = http2.constants;\n+\n+const server = http2.createServer();\n+server.on('stream', common.mustCall((stream) => {\n+  stream.respondWithFile(process.execPath, {\n+    [HTTP2_HEADER_CONTENT_TYPE]: 'application/octet-stream'\n+  });\n+}));\n+\n+server.listen(0, common.mustCall(() => {\n+  const client = http2.connect(`http://localhost:${server.address().port}`);\n+  const req = client.request();\n+\n+  req.on('response', common.mustCall(() => {}));\n+  req.on('data', common.mustCall(() => {\n+    net.Socket.prototype.destroy.call(client.socket);\n+    server.close();\n+  }));\n+  req.end();\n+}));\n+\n+// TODO(addaleax): This is a *hack*. HTTP/2 needs to have a proper way of\n+// dealing with this kind of issue.\n+process.once('uncaughtException', (err) => {\n+  if (err.code === 'ECONNRESET') return;\n+  throw err;\n+});"
        }
    ],
    "stats": {
        "total": 61,
        "additions": 52,
        "deletions": 9
    }
}