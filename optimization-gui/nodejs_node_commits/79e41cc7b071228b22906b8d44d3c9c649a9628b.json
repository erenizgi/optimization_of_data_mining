{
    "author": "cjihrig",
    "message": "dgram: hide underscored Socket properties\n\ndgram sockets have a fair number of exposed private properties.\nThis commit hides them all behind a single symbol property.\n\nPR-URL: https://github.com/nodejs/node/pull/21923\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Wyatt Preul <wpreul@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "79e41cc7b071228b22906b8d44d3c9c649a9628b",
    "files": [
        {
            "sha": "93c94c71cfaa02732f40b4b569ba710ba9bc75e2",
            "filename": "lib/dgram.js",
            "status": "modified",
            "additions": 94,
            "deletions": 66,
            "changes": 160,
            "blob_url": "https://github.com/nodejs/node/blob/79e41cc7b071228b22906b8d44d3c9c649a9628b/lib%2Fdgram.js",
            "raw_url": "https://github.com/nodejs/node/raw/79e41cc7b071228b22906b8d44d3c9c649a9628b/lib%2Fdgram.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fdgram.js?ref=79e41cc7b071228b22906b8d44d3c9c649a9628b",
            "patch": "@@ -23,6 +23,7 @@\n \n const assert = require('assert');\n const errors = require('internal/errors');\n+const { kStateSymbol } = require('internal/dgram');\n const {\n   ERR_INVALID_ARG_TYPE,\n   ERR_MISSING_ARGS,\n@@ -115,36 +116,40 @@ function _createSocketHandle(address, port, addressType, fd, flags) {\n   return handle;\n }\n \n-const kOptionSymbol = Symbol('options symbol');\n \n function Socket(type, listener) {\n   EventEmitter.call(this);\n   var lookup;\n+  let recvBufferSize;\n+  let sendBufferSize;\n \n-  this[kOptionSymbol] = {};\n   if (type !== null && typeof type === 'object') {\n     var options = type;\n     type = options.type;\n     lookup = options.lookup;\n-    this[kOptionSymbol].recvBufferSize = options.recvBufferSize;\n-    this[kOptionSymbol].sendBufferSize = options.sendBufferSize;\n+    recvBufferSize = options.recvBufferSize;\n+    sendBufferSize = options.sendBufferSize;\n   }\n \n   var handle = newHandle(type, lookup);\n   handle.owner = this;\n \n-  this._handle = handle;\n-  this._receiving = false;\n-  this._bindState = BIND_STATE_UNBOUND;\n-  this[async_id_symbol] = this._handle.getAsyncId();\n+  this[async_id_symbol] = handle.getAsyncId();\n   this.type = type;\n   this.fd = null; // compatibility hack\n \n-  // If true - UV_UDP_REUSEADDR flag will be set\n-  this._reuseAddr = options && options.reuseAddr;\n-\n   if (typeof listener === 'function')\n     this.on('message', listener);\n+\n+  this[kStateSymbol] = {\n+    handle,\n+    receiving: false,\n+    bindState: BIND_STATE_UNBOUND,\n+    queue: undefined,\n+    reuseAddr: options && options.reuseAddr, // Use UV_UDP_REUSEADDR if true.\n+    recvBufferSize,\n+    sendBufferSize\n+  };\n }\n util.inherits(Socket, EventEmitter);\n \n@@ -155,41 +160,45 @@ function createSocket(type, listener) {\n \n \n function startListening(socket) {\n-  socket._handle.onmessage = onMessage;\n+  const state = socket[kStateSymbol];\n+\n+  state.handle.onmessage = onMessage;\n   // Todo: handle errors\n-  socket._handle.recvStart();\n-  socket._receiving = true;\n-  socket._bindState = BIND_STATE_BOUND;\n+  state.handle.recvStart();\n+  state.receiving = true;\n+  state.bindState = BIND_STATE_BOUND;\n   socket.fd = -42; // compatibility hack\n \n-  if (socket[kOptionSymbol].recvBufferSize)\n-    bufferSize(socket, socket[kOptionSymbol].recvBufferSize, RECV_BUFFER);\n+  if (state.recvBufferSize)\n+    bufferSize(socket, state.recvBufferSize, RECV_BUFFER);\n \n-  if (socket[kOptionSymbol].sendBufferSize)\n-    bufferSize(socket, socket[kOptionSymbol].sendBufferSize, SEND_BUFFER);\n+  if (state.sendBufferSize)\n+    bufferSize(socket, state.sendBufferSize, SEND_BUFFER);\n \n   socket.emit('listening');\n }\n \n function replaceHandle(self, newHandle) {\n+  const state = self[kStateSymbol];\n+  const oldHandle = state.handle;\n \n   // Set up the handle that we got from master.\n-  newHandle.lookup = self._handle.lookup;\n-  newHandle.bind = self._handle.bind;\n-  newHandle.send = self._handle.send;\n+  newHandle.lookup = oldHandle.lookup;\n+  newHandle.bind = oldHandle.bind;\n+  newHandle.send = oldHandle.send;\n   newHandle.owner = self;\n \n   // Replace the existing handle by the handle we got from master.\n-  self._handle.close();\n-  self._handle = newHandle;\n+  oldHandle.close();\n+  state.handle = newHandle;\n }\n \n function bufferSize(self, size, buffer) {\n   if (size >>> 0 !== size)\n     throw new ERR_SOCKET_BAD_BUFFER_SIZE();\n \n   const ctx = {};\n-  const ret = self._handle.bufferSize(size, buffer, ctx);\n+  const ret = self[kStateSymbol].handle.bufferSize(size, buffer, ctx);\n   if (ret === undefined) {\n     throw new ERR_SOCKET_BUFFER_SIZE(ctx);\n   }\n@@ -200,11 +209,12 @@ Socket.prototype.bind = function(port_, address_ /* , callback */) {\n   let port = port_;\n \n   healthCheck(this);\n+  const state = this[kStateSymbol];\n \n-  if (this._bindState !== BIND_STATE_UNBOUND)\n+  if (state.bindState !== BIND_STATE_UNBOUND)\n     throw new ERR_SOCKET_ALREADY_BOUND();\n \n-  this._bindState = BIND_STATE_BINDING;\n+  state.bindState = BIND_STATE_BINDING;\n \n   if (arguments.length && typeof arguments[arguments.length - 1] === 'function')\n     this.once('listening', arguments[arguments.length - 1]);\n@@ -236,9 +246,9 @@ Socket.prototype.bind = function(port_, address_ /* , callback */) {\n   }\n \n   // resolve address first\n-  this._handle.lookup(address, (err, ip) => {\n+  state.handle.lookup(address, (err, ip) => {\n     if (err) {\n-      this._bindState = BIND_STATE_UNBOUND;\n+      state.bindState = BIND_STATE_UNBOUND;\n       this.emit('error', err);\n       return;\n     }\n@@ -247,19 +257,19 @@ Socket.prototype.bind = function(port_, address_ /* , callback */) {\n       cluster = require('cluster');\n \n     var flags = 0;\n-    if (this._reuseAddr)\n+    if (state.reuseAddr)\n       flags |= UV_UDP_REUSEADDR;\n \n     if (cluster.isWorker && !exclusive) {\n       const onHandle = (err, handle) => {\n         if (err) {\n           var ex = exceptionWithHostPort(err, 'bind', ip, port);\n           this.emit('error', ex);\n-          this._bindState = BIND_STATE_UNBOUND;\n+          state.bindState = BIND_STATE_UNBOUND;\n           return;\n         }\n \n-        if (!this._handle)\n+        if (!state.handle)\n           // handle has been closed in the mean time.\n           return handle.close();\n \n@@ -274,14 +284,14 @@ Socket.prototype.bind = function(port_, address_ /* , callback */) {\n         flags: flags\n       }, onHandle);\n     } else {\n-      if (!this._handle)\n+      if (!state.handle)\n         return; // handle has been closed in the mean time\n \n-      const err = this._handle.bind(ip, port || 0, flags);\n+      const err = state.handle.bind(ip, port || 0, flags);\n       if (err) {\n         var ex = exceptionWithHostPort(err, 'bind', ip, port);\n         this.emit('error', ex);\n-        this._bindState = BIND_STATE_UNBOUND;\n+        state.bindState = BIND_STATE_UNBOUND;\n         // Todo: close?\n         return;\n       }\n@@ -354,14 +364,16 @@ function fixBufferList(list) {\n \n \n function enqueue(self, toEnqueue) {\n+  const state = self[kStateSymbol];\n+\n   // If the send queue hasn't been initialized yet, do it, and install an\n   // event handler that flushes the send queue after binding is done.\n-  if (!self._queue) {\n-    self._queue = [];\n+  if (state.queue === undefined) {\n+    state.queue = [];\n     self.once('error', onListenError);\n     self.once('listening', onListenSuccess);\n   }\n-  self._queue.push(toEnqueue);\n+  state.queue.push(toEnqueue);\n }\n \n \n@@ -373,14 +385,15 @@ function onListenSuccess() {\n \n function onListenError(err) {\n   this.removeListener('listening', onListenSuccess);\n-  this._queue = undefined;\n+  this[kStateSymbol].queue = undefined;\n   this.emit('error', new ERR_SOCKET_CANNOT_SEND());\n }\n \n \n function clearQueue() {\n-  const queue = this._queue;\n-  this._queue = undefined;\n+  const state = this[kStateSymbol];\n+  const queue = state.queue;\n+  state.queue = undefined;\n \n   // Flush the send queue.\n   for (var i = 0; i < queue.length; i++)\n@@ -446,15 +459,17 @@ Socket.prototype.send = function(buffer,\n \n   healthCheck(this);\n \n-  if (this._bindState === BIND_STATE_UNBOUND)\n+  const state = this[kStateSymbol];\n+\n+  if (state.bindState === BIND_STATE_UNBOUND)\n     this.bind({ port: 0, exclusive: true }, null);\n \n   if (list.length === 0)\n     list.push(Buffer.alloc(0));\n \n   // If the socket hasn't been bound yet, push the outbound packet onto the\n   // send queue and send after binding is complete.\n-  if (this._bindState !== BIND_STATE_BOUND) {\n+  if (state.bindState !== BIND_STATE_BOUND) {\n     enqueue(this, this.send.bind(this, list, port, address, callback));\n     return;\n   }\n@@ -467,10 +482,12 @@ Socket.prototype.send = function(buffer,\n     );\n   };\n \n-  this._handle.lookup(address, afterDns);\n+  state.handle.lookup(address, afterDns);\n };\n \n function doSend(ex, self, ip, list, address, port, callback) {\n+  const state = self[kStateSymbol];\n+\n   if (ex) {\n     if (typeof callback === 'function') {\n       process.nextTick(callback, ex);\n@@ -479,7 +496,7 @@ function doSend(ex, self, ip, list, address, port, callback) {\n \n     process.nextTick(() => self.emit('error', ex));\n     return;\n-  } else if (!self._handle) {\n+  } else if (!state.handle) {\n     return;\n   }\n \n@@ -492,7 +509,7 @@ function doSend(ex, self, ip, list, address, port, callback) {\n     req.oncomplete = afterSend;\n   }\n \n-  var err = self._handle.send(req,\n+  var err = state.handle.send(req,\n                               list,\n                               list.length,\n                               port,\n@@ -517,18 +534,21 @@ function afterSend(err, sent) {\n }\n \n Socket.prototype.close = function(callback) {\n+  const state = this[kStateSymbol];\n+  const queue = state.queue;\n+\n   if (typeof callback === 'function')\n     this.on('close', callback);\n \n-  if (this._queue) {\n-    this._queue.push(this.close.bind(this));\n+  if (queue !== undefined) {\n+    queue.push(this.close.bind(this));\n     return this;\n   }\n \n   healthCheck(this);\n   stopReceiving(this);\n-  this._handle.close();\n-  this._handle = null;\n+  state.handle.close();\n+  state.handle = null;\n   defaultTriggerAsyncIdScope(this[async_id_symbol],\n                              process.nextTick,\n                              socketCloseNT,\n@@ -547,7 +567,7 @@ Socket.prototype.address = function() {\n   healthCheck(this);\n \n   var out = {};\n-  var err = this._handle.getsockname(out);\n+  var err = this[kStateSymbol].handle.getsockname(out);\n   if (err) {\n     throw errnoException(err, 'getsockname');\n   }\n@@ -557,7 +577,7 @@ Socket.prototype.address = function() {\n \n \n Socket.prototype.setBroadcast = function(arg) {\n-  var err = this._handle.setBroadcast(arg ? 1 : 0);\n+  var err = this[kStateSymbol].handle.setBroadcast(arg ? 1 : 0);\n   if (err) {\n     throw errnoException(err, 'setBroadcast');\n   }\n@@ -569,7 +589,7 @@ Socket.prototype.setTTL = function(ttl) {\n     throw new ERR_INVALID_ARG_TYPE('ttl', 'number', ttl);\n   }\n \n-  var err = this._handle.setTTL(ttl);\n+  var err = this[kStateSymbol].handle.setTTL(ttl);\n   if (err) {\n     throw errnoException(err, 'setTTL');\n   }\n@@ -583,7 +603,7 @@ Socket.prototype.setMulticastTTL = function(ttl) {\n     throw new ERR_INVALID_ARG_TYPE('ttl', 'number', ttl);\n   }\n \n-  var err = this._handle.setMulticastTTL(ttl);\n+  var err = this[kStateSymbol].handle.setMulticastTTL(ttl);\n   if (err) {\n     throw errnoException(err, 'setMulticastTTL');\n   }\n@@ -593,7 +613,7 @@ Socket.prototype.setMulticastTTL = function(ttl) {\n \n \n Socket.prototype.setMulticastLoopback = function(arg) {\n-  var err = this._handle.setMulticastLoopback(arg ? 1 : 0);\n+  var err = this[kStateSymbol].handle.setMulticastLoopback(arg ? 1 : 0);\n   if (err) {\n     throw errnoException(err, 'setMulticastLoopback');\n   }\n@@ -610,7 +630,7 @@ Socket.prototype.setMulticastInterface = function(interfaceAddress) {\n       'interfaceAddress', 'string', interfaceAddress);\n   }\n \n-  const err = this._handle.setMulticastInterface(interfaceAddress);\n+  const err = this[kStateSymbol].handle.setMulticastInterface(interfaceAddress);\n   if (err) {\n     throw errnoException(err, 'setMulticastInterface');\n   }\n@@ -624,7 +644,8 @@ Socket.prototype.addMembership = function(multicastAddress,\n     throw new ERR_MISSING_ARGS('multicastAddress');\n   }\n \n-  var err = this._handle.addMembership(multicastAddress, interfaceAddress);\n+  const { handle } = this[kStateSymbol];\n+  var err = handle.addMembership(multicastAddress, interfaceAddress);\n   if (err) {\n     throw errnoException(err, 'addMembership');\n   }\n@@ -639,27 +660,30 @@ Socket.prototype.dropMembership = function(multicastAddress,\n     throw new ERR_MISSING_ARGS('multicastAddress');\n   }\n \n-  var err = this._handle.dropMembership(multicastAddress, interfaceAddress);\n+  const { handle } = this[kStateSymbol];\n+  var err = handle.dropMembership(multicastAddress, interfaceAddress);\n   if (err) {\n     throw errnoException(err, 'dropMembership');\n   }\n };\n \n \n function healthCheck(socket) {\n-  if (!socket._handle) {\n+  if (!socket[kStateSymbol].handle) {\n     // Error message from dgram_legacy.js.\n     throw new ERR_SOCKET_DGRAM_NOT_RUNNING();\n   }\n }\n \n \n function stopReceiving(socket) {\n-  if (!socket._receiving)\n+  const state = socket[kStateSymbol];\n+\n+  if (!state.receiving)\n     return;\n \n-  socket._handle.recvStop();\n-  socket._receiving = false;\n+  state.handle.recvStop();\n+  state.receiving = false;\n   socket.fd = null; // compatibility hack\n }\n \n@@ -675,16 +699,20 @@ function onMessage(nread, handle, buf, rinfo) {\n \n \n Socket.prototype.ref = function() {\n-  if (this._handle)\n-    this._handle.ref();\n+  const handle = this[kStateSymbol].handle;\n+\n+  if (handle)\n+    handle.ref();\n \n   return this;\n };\n \n \n Socket.prototype.unref = function() {\n-  if (this._handle)\n-    this._handle.unref();\n+  const handle = this[kStateSymbol].handle;\n+\n+  if (handle)\n+    handle.unref();\n \n   return this;\n };"
        },
        {
            "sha": "d22009505a457451a91c7751444a66d80a61d21d",
            "filename": "lib/internal/child_process.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/79e41cc7b071228b22906b8d44d3c9c649a9628b/lib%2Finternal%2Fchild_process.js",
            "raw_url": "https://github.com/nodejs/node/raw/79e41cc7b071228b22906b8d44d3c9c649a9628b/lib%2Finternal%2Fchild_process.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fchild_process.js?ref=79e41cc7b071228b22906b8d44d3c9c649a9628b",
            "patch": "@@ -32,6 +32,7 @@ const { isUint8Array } = require('internal/util/types');\n const spawn_sync = process.binding('spawn_sync');\n const { HTTPParser } = process.binding('http_parser');\n const { freeParser } = require('_http_common');\n+const { kStateSymbol } = require('internal/dgram');\n \n const {\n   UV_EACCES,\n@@ -181,7 +182,7 @@ const handleConversion = {\n     send: function(message, socket, options) {\n       message.dgramType = socket.type;\n \n-      return socket._handle;\n+      return socket[kStateSymbol].handle;\n     },\n \n     got: function(message, handle, emit) {"
        },
        {
            "sha": "0f333178e87378cfdaeb8d741179995fe145b728",
            "filename": "lib/internal/dgram.js",
            "status": "added",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/79e41cc7b071228b22906b8d44d3c9c649a9628b/lib%2Finternal%2Fdgram.js",
            "raw_url": "https://github.com/nodejs/node/raw/79e41cc7b071228b22906b8d44d3c9c649a9628b/lib%2Finternal%2Fdgram.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fdgram.js?ref=79e41cc7b071228b22906b8d44d3c9c649a9628b",
            "patch": "@@ -0,0 +1,4 @@\n+'use strict';\n+const kStateSymbol = Symbol('state symbol');\n+\n+module.exports = { kStateSymbol };"
        },
        {
            "sha": "0a8630cd1bff96548a57a45b4f141212b8876bfd",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/79e41cc7b071228b22906b8d44d3c9c649a9628b/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/79e41cc7b071228b22906b8d44d3c9c649a9628b/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=79e41cc7b071228b22906b8d44d3c9c649a9628b",
            "patch": "@@ -104,6 +104,7 @@\n       'lib/internal/crypto/sig.js',\n       'lib/internal/crypto/util.js',\n       'lib/internal/constants.js',\n+      'lib/internal/dgram.js',\n       'lib/internal/dns/promises.js',\n       'lib/internal/dns/utils.js',\n       'lib/internal/domexception.js',"
        },
        {
            "sha": "4b04610e4141dca7ca855f113a8221191bdf0823",
            "filename": "test/parallel/test-dgram-close-during-bind.js",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/79e41cc7b071228b22906b8d44d3c9c649a9628b/test%2Fparallel%2Ftest-dgram-close-during-bind.js",
            "raw_url": "https://github.com/nodejs/node/raw/79e41cc7b071228b22906b8d44d3c9c649a9628b/test%2Fparallel%2Ftest-dgram-close-during-bind.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-dgram-close-during-bind.js?ref=79e41cc7b071228b22906b8d44d3c9c649a9628b",
            "patch": "@@ -1,13 +1,16 @@\n+// Flags: --expose-internals\n 'use strict';\n const common = require('../common');\n const dgram = require('dgram');\n+const { kStateSymbol } = require('internal/dgram');\n const socket = dgram.createSocket('udp4');\n-const lookup = socket._handle.lookup;\n+const { handle } = socket[kStateSymbol];\n+const lookup = handle.lookup;\n \n // Test the scenario where the socket is closed during a bind operation.\n-socket._handle.bind = common.mustNotCall('bind() should not be called.');\n+handle.bind = common.mustNotCall('bind() should not be called.');\n \n-socket._handle.lookup = common.mustCall(function(address, callback) {\n+handle.lookup = common.mustCall(function(address, callback) {\n   socket.close(common.mustCall(() => {\n     lookup.call(this, address, callback);\n   }));"
        },
        {
            "sha": "7b49cee73bed6aa83314d5e86e27ae752119fb4f",
            "filename": "test/parallel/test-dgram-close.js",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/79e41cc7b071228b22906b8d44d3c9c649a9628b/test%2Fparallel%2Ftest-dgram-close.js",
            "raw_url": "https://github.com/nodejs/node/raw/79e41cc7b071228b22906b8d44d3c9c649a9628b/test%2Fparallel%2Ftest-dgram-close.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-dgram-close.js?ref=79e41cc7b071228b22906b8d44d3c9c649a9628b",
            "patch": "@@ -19,18 +19,20 @@\n // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n // USE OR OTHER DEALINGS IN THE SOFTWARE.\n \n+// Flags: --expose-internals\n 'use strict';\n // Ensure that if a dgram socket is closed before the DNS lookup completes, it\n // won't crash.\n \n const common = require('../common');\n const assert = require('assert');\n const dgram = require('dgram');\n+const { kStateSymbol } = require('internal/dgram');\n \n const buf = Buffer.alloc(1024, 42);\n \n let socket = dgram.createSocket('udp4');\n-const handle = socket._handle;\n+const { handle } = socket[kStateSymbol];\n \n // get a random port for send\n const portGetter = dgram.createSocket('udp4')"
        },
        {
            "sha": "9850d944ce10115ffcdfee34f0a83fa031b7f31d",
            "filename": "test/parallel/test-dgram-recv-error.js",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/79e41cc7b071228b22906b8d44d3c9c649a9628b/test%2Fparallel%2Ftest-dgram-recv-error.js",
            "raw_url": "https://github.com/nodejs/node/raw/79e41cc7b071228b22906b8d44d3c9c649a9628b/test%2Fparallel%2Ftest-dgram-recv-error.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-dgram-recv-error.js?ref=79e41cc7b071228b22906b8d44d3c9c649a9628b",
            "patch": "@@ -1,8 +1,11 @@\n+// Flags: --expose-internals\n 'use strict';\n const common = require('../common');\n const assert = require('assert');\n const dgram = require('dgram');\n+const { kStateSymbol } = require('internal/dgram');\n const s = dgram.createSocket('udp4');\n+const { handle } = s[kStateSymbol];\n \n s.on('error', common.mustCall((err) => {\n   s.close();\n@@ -13,4 +16,4 @@ s.on('error', common.mustCall((err) => {\n }));\n \n s.on('message', common.mustNotCall('no message should be received.'));\n-s.bind(common.mustCall(() => s._handle.onmessage(-1, s._handle, null, null)));\n+s.bind(common.mustCall(() => handle.onmessage(-1, handle, null, null)));"
        },
        {
            "sha": "7757db1e2d44740f121a28ccd1cac37335059e37",
            "filename": "test/parallel/test-dgram-send-error.js",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/79e41cc7b071228b22906b8d44d3c9c649a9628b/test%2Fparallel%2Ftest-dgram-send-error.js",
            "raw_url": "https://github.com/nodejs/node/raw/79e41cc7b071228b22906b8d44d3c9c649a9628b/test%2Fparallel%2Ftest-dgram-send-error.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-dgram-send-error.js?ref=79e41cc7b071228b22906b8d44d3c9c649a9628b",
            "patch": "@@ -1,15 +1,17 @@\n+// Flags: --expose-internals\n 'use strict';\n const common = require('../common');\n const assert = require('assert');\n const dgram = require('dgram');\n+const { kStateSymbol } = require('internal/dgram');\n const mockError = new Error('mock DNS error');\n \n function getSocket(callback) {\n   const socket = dgram.createSocket('udp4');\n \n   socket.on('message', common.mustNotCall('Should not receive any messages.'));\n   socket.bind(common.mustCall(() => {\n-    socket._handle.lookup = function(address, callback) {\n+    socket[kStateSymbol].handle.lookup = function(address, callback) {\n       process.nextTick(callback, mockError);\n     };\n \n@@ -57,7 +59,7 @@ getSocket((socket) => {\n       );\n     });\n \n-    socket._handle.send = function() {\n+    socket[kStateSymbol].handle.send = function() {\n       return errCode;\n     };\n "
        },
        {
            "sha": "cd0f5a26ca72adfe9f03e7c5022a76827caeb465",
            "filename": "test/parallel/test-handle-wrap-isrefed.js",
            "status": "modified",
            "additions": 18,
            "deletions": 12,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/79e41cc7b071228b22906b8d44d3c9c649a9628b/test%2Fparallel%2Ftest-handle-wrap-isrefed.js",
            "raw_url": "https://github.com/nodejs/node/raw/79e41cc7b071228b22906b8d44d3c9c649a9628b/test%2Fparallel%2Ftest-handle-wrap-isrefed.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-handle-wrap-isrefed.js?ref=79e41cc7b071228b22906b8d44d3c9c649a9628b",
            "patch": "@@ -1,3 +1,4 @@\n+// Flags: --expose-internals\n 'use strict';\n \n const common = require('../common');\n@@ -25,41 +26,46 @@ const strictEqual = require('assert').strictEqual;\n \n \n const dgram = require('dgram');\n+const { kStateSymbol } = require('internal/dgram');\n \n // dgram ipv4\n {\n   const sock4 = dgram.createSocket('udp4');\n-  strictEqual(Object.getPrototypeOf(sock4._handle).hasOwnProperty('hasRef'),\n+  const handle = sock4[kStateSymbol].handle;\n+\n+  strictEqual(Object.getPrototypeOf(handle).hasOwnProperty('hasRef'),\n               true, 'udp_wrap: ipv4: hasRef() missing');\n-  strictEqual(sock4._handle.hasRef(),\n+  strictEqual(handle.hasRef(),\n               true, 'udp_wrap: ipv4: not initially refed');\n   sock4.unref();\n-  strictEqual(sock4._handle.hasRef(),\n+  strictEqual(handle.hasRef(),\n               false, 'udp_wrap: ipv4: unref() ineffective');\n   sock4.ref();\n-  strictEqual(sock4._handle.hasRef(),\n+  strictEqual(handle.hasRef(),\n               true, 'udp_wrap: ipv4: ref() ineffective');\n-  sock4._handle.close(common.mustCall(() =>\n-    strictEqual(sock4._handle.hasRef(),\n+  handle.close(common.mustCall(() =>\n+    strictEqual(handle.hasRef(),\n                 false, 'udp_wrap: ipv4: not unrefed on close')));\n }\n \n \n // dgram ipv6\n {\n   const sock6 = dgram.createSocket('udp6');\n-  strictEqual(Object.getPrototypeOf(sock6._handle).hasOwnProperty('hasRef'),\n+  const handle = sock6[kStateSymbol].handle;\n+\n+  strictEqual(Object.getPrototypeOf(handle).hasOwnProperty('hasRef'),\n               true, 'udp_wrap: ipv6: hasRef() missing');\n-  strictEqual(sock6._handle.hasRef(),\n+  strictEqual(handle.hasRef(),\n               true, 'udp_wrap: ipv6: not initially refed');\n   sock6.unref();\n-  strictEqual(sock6._handle.hasRef(),\n+  strictEqual(handle.hasRef(),\n               false, 'udp_wrap: ipv6: unref() ineffective');\n   sock6.ref();\n-  strictEqual(sock6._handle.hasRef(),\n+  strictEqual(handle.hasRef(),\n               true, 'udp_wrap: ipv6: ref() ineffective');\n-  sock6._handle.close(common.mustCall(() =>\n-    strictEqual(sock6._handle.hasRef(),\n+  handle.close(common.mustCall(() =>\n+    strictEqual(handle.hasRef(),\n                 false, 'udp_wrap: ipv6: not unrefed on close')));\n }\n "
        },
        {
            "sha": "d77db12618f3bcca08203c97350e85a9e749bc20",
            "filename": "test/sequential/test-dgram-implicit-bind-failure.js",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/79e41cc7b071228b22906b8d44d3c9c649a9628b/test%2Fsequential%2Ftest-dgram-implicit-bind-failure.js",
            "raw_url": "https://github.com/nodejs/node/raw/79e41cc7b071228b22906b8d44d3c9c649a9628b/test%2Fsequential%2Ftest-dgram-implicit-bind-failure.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-dgram-implicit-bind-failure.js?ref=79e41cc7b071228b22906b8d44d3c9c649a9628b",
            "patch": "@@ -1,8 +1,10 @@\n+// Flags: --expose-internals\n 'use strict';\n const common = require('../common');\n const assert = require('assert');\n const dgram = require('dgram');\n const dns = require('dns');\n+const { kStateSymbol } = require('internal/dgram');\n \n // Monkey patch dns.lookup() so that it always fails.\n dns.lookup = function(address, family, callback) {\n@@ -25,8 +27,8 @@ socket.on('error', (err) => {\n     // should also be two listeners - this function and the dgram internal one\n     // time error handler.\n     dnsFailures++;\n-    assert(Array.isArray(socket._queue));\n-    assert.strictEqual(socket._queue.length, 1);\n+    assert(Array.isArray(socket[kStateSymbol].queue));\n+    assert.strictEqual(socket[kStateSymbol].queue.length, 1);\n     assert.strictEqual(socket.listenerCount('error'), 2);\n     return;\n   }\n@@ -35,7 +37,7 @@ socket.on('error', (err) => {\n     // On error, the queue should be destroyed and this function should be\n     // the only listener.\n     sendFailures++;\n-    assert.strictEqual(socket._queue, undefined);\n+    assert.strictEqual(socket[kStateSymbol].queue, undefined);\n     assert.strictEqual(socket.listenerCount('error'), 1);\n     return;\n   }"
        }
    ],
    "stats": {
        "total": 230,
        "additions": 141,
        "deletions": 89
    }
}