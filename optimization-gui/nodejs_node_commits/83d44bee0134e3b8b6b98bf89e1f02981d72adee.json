{
    "author": "vsemozhetbyt",
    "message": "tools: dry utility function in tools/doc/json.js\n\nAlso, move a declaration of unrelated variable\ncloser to its only context.\n\nPR-URL: https://github.com/nodejs/node/pull/19692\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>",
    "sha": "83d44bee0134e3b8b6b98bf89e1f02981d72adee",
    "files": [
        {
            "sha": "87122cea70fd5622bdd2ece48af1c964c1b92913",
            "filename": "tools/doc/json.js",
            "status": "modified",
            "additions": 19,
            "deletions": 36,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/83d44bee0134e3b8b6b98bf89e1f02981d72adee/tools%2Fdoc%2Fjson.js",
            "raw_url": "https://github.com/nodejs/node/raw/83d44bee0134e3b8b6b98bf89e1f02981d72adee/tools%2Fdoc%2Fjson.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fdoc%2Fjson.js?ref=83d44bee0134e3b8b6b98bf89e1f02981d72adee",
            "patch": "@@ -323,6 +323,8 @@ function processList(section) {\n   delete section.list;\n }\n \n+const paramExpr = /\\((.*)\\);?$/;\n+\n // textRaw = \"someobject.someMethod(a[, b=100][, c])\"\n function parseSignature(text, sig) {\n   var params = text.match(paramExpr);\n@@ -556,42 +558,23 @@ function deepCopy_(src) {\n \n \n // These parse out the contents of an H# tag.\n-const eventExpr = /^Event(?::|\\s)+['\"]?([^\"']+).*$/i;\n-const classExpr = /^Class:\\s*([^ ]+).*$/i;\n-const propExpr = /^[^.]+\\.([^ .()]+)\\s*$/;\n-const braceExpr = /^[^.[]+(\\[[^\\]]+\\])\\s*$/;\n-const classMethExpr = /^class\\s*method\\s*:?[^.]+\\.([^ .()]+)\\([^)]*\\)\\s*$/i;\n-const methExpr = /^(?:[^.]+\\.)?([^ .()]+)\\([^)]*\\)\\s*$/;\n-const newExpr = /^new ([A-Z][a-zA-Z]+)\\([^)]*\\)\\s*$/;\n-var paramExpr = /\\((.*)\\);?$/;\n-\n-function newSection(tok) {\n-  const section = {};\n+const headingExpressions = [\n+  { type: 'event', re: /^Event(?::|\\s)+['\"]?([^\"']+).*$/i },\n+  { type: 'class', re: /^Class:\\s*([^ ]+).*$/i },\n+  { type: 'property', re: /^[^.[]+(\\[[^\\]]+\\])\\s*$/ },\n+  { type: 'property', re: /^[^.]+\\.([^ .()]+)\\s*$/ },\n+  { type: 'classMethod', re: /^class\\s*method\\s*:?[^.]+\\.([^ .()]+)\\([^)]*\\)\\s*$/i },\n+  { type: 'method', re: /^(?:[^.]+\\.)?([^ .()]+)\\([^)]*\\)\\s*$/ },\n+  { type: 'ctor', re: /^new ([A-Z][a-zA-Z]+)\\([^)]*\\)\\s*$/ },\n+];\n+\n+function newSection({ text }) {\n   // Infer the type from the text.\n-  const text = section.textRaw = tok.text;\n-  if (text.match(eventExpr)) {\n-    section.type = 'event';\n-    section.name = text.replace(eventExpr, '$1');\n-  } else if (text.match(classExpr)) {\n-    section.type = 'class';\n-    section.name = text.replace(classExpr, '$1');\n-  } else if (text.match(braceExpr)) {\n-    section.type = 'property';\n-    section.name = text.replace(braceExpr, '$1');\n-  } else if (text.match(propExpr)) {\n-    section.type = 'property';\n-    section.name = text.replace(propExpr, '$1');\n-  } else if (text.match(classMethExpr)) {\n-    section.type = 'classMethod';\n-    section.name = text.replace(classMethExpr, '$1');\n-  } else if (text.match(methExpr)) {\n-    section.type = 'method';\n-    section.name = text.replace(methExpr, '$1');\n-  } else if (text.match(newExpr)) {\n-    section.type = 'ctor';\n-    section.name = text.replace(newExpr, '$1');\n-  } else {\n-    section.name = text;\n+  for (const { type, re } of headingExpressions) {\n+    const [, name] = text.match(re) || [];\n+    if (name) {\n+      return { textRaw: text, type, name };\n+    }\n   }\n-  return section;\n+  return { textRaw: text, name: text };\n }"
        }
    ],
    "stats": {
        "total": 55,
        "additions": 19,
        "deletions": 36
    }
}