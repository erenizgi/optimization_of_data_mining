{
    "author": "joyeecheung",
    "message": "process: split worker IO into internal/worker/io.js\n\n- Move `setupProcessStdio` which contains write access to\n  the process object into `bootstrap/node.js`\n- Move `MessagePort`, `MessageChannel`, `ReadableWorkerStdio`,\n  and `WritableWorkerStdio` into `internal/worker/io.js`\n- Move more worker-specific bootstrap code into\n  `internal/process/worker_thread_only` from `setupChild`\n  in `internal/worker.js`, and move the `process._fatalException`\n  overwrite into `bootstrap/node.js` for clarity.\n\nPR-URL: https://github.com/nodejs/node/pull/25199\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "af237152cdb0b7b5a4495e84cdf4b170f6ddd361",
    "files": [
        {
            "sha": "81ec1fc12b80f4f56aa12985a03c0600900c86fd",
            "filename": "lib/internal/bootstrap/node.js",
            "status": "modified",
            "additions": 39,
            "deletions": 4,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Finternal%2Fbootstrap%2Fnode.js",
            "raw_url": "https://github.com/nodejs/node/raw/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Finternal%2Fbootstrap%2Fnode.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbootstrap%2Fnode.js?ref=af237152cdb0b7b5a4495e84cdf4b170f6ddd361",
            "patch": "@@ -140,9 +140,13 @@ function startup() {\n   }\n \n   if (isMainThread) {\n-    mainThreadSetup.setupStdio();\n+    const { getStdout, getStdin, getStderr } =\n+      NativeModule.require('internal/process/stdio').getMainThreadStdio();\n+    setupProcessStdio(getStdout, getStdin, getStderr);\n   } else {\n-    workerThreadSetup.setupStdio();\n+    const { getStdout, getStdin, getStderr } =\n+      workerThreadSetup.initializeWorkerStdio();\n+    setupProcessStdio(getStdout, getStdin, getStderr);\n   }\n \n   if (global.__coverage__)\n@@ -312,8 +316,14 @@ function startup() {\n function startExecution() {\n   // This means we are in a Worker context, and any script execution\n   // will be directed by the worker module.\n-  if (internalBinding('worker').getEnvMessagePort() !== undefined) {\n-    NativeModule.require('internal/worker').setupChild();\n+  if (!isMainThread) {\n+    const workerThreadSetup = NativeModule.require(\n+      'internal/process/worker_thread_only'\n+    );\n+    // Set up the message port and start listening\n+    const { workerFatalExeception } = workerThreadSetup.setup();\n+    // Overwrite fatalException\n+    process._fatalException = workerFatalExeception;\n     return;\n   }\n \n@@ -505,6 +515,31 @@ function setupProcessObject() {\n   EventEmitter.call(process);\n }\n \n+function setupProcessStdio(getStdout, getStdin, getStderr) {\n+  Object.defineProperty(process, 'stdout', {\n+    configurable: true,\n+    enumerable: true,\n+    get: getStdout\n+  });\n+\n+  Object.defineProperty(process, 'stderr', {\n+    configurable: true,\n+    enumerable: true,\n+    get: getStderr\n+  });\n+\n+  Object.defineProperty(process, 'stdin', {\n+    configurable: true,\n+    enumerable: true,\n+    get: getStdin\n+  });\n+\n+  process.openStdin = function() {\n+    process.stdin.resume();\n+    return process.stdin;\n+  };\n+}\n+\n function setupGlobalVariables() {\n   Object.defineProperty(global, Symbol.toStringTag, {\n     value: 'global',"
        },
        {
            "sha": "42579e9da8acd1056ff78171f41b1594a632f6d7",
            "filename": "lib/internal/process/main_thread_only.js",
            "status": "modified",
            "additions": 0,
            "deletions": 10,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Finternal%2Fprocess%2Fmain_thread_only.js",
            "raw_url": "https://github.com/nodejs/node/raw/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Finternal%2Fprocess%2Fmain_thread_only.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fmain_thread_only.js?ref=af237152cdb0b7b5a4495e84cdf4b170f6ddd361",
            "patch": "@@ -16,15 +16,6 @@ const {\n   validateString\n } = require('internal/validators');\n \n-const {\n-  setupProcessStdio,\n-  getMainThreadStdio\n-} = require('internal/process/stdio');\n-\n-function setupStdio() {\n-  setupProcessStdio(getMainThreadStdio());\n-}\n-\n // The execution of this function itself should not cause any side effects.\n function wrapProcessMethods(binding) {\n   function chdir(directory) {\n@@ -174,7 +165,6 @@ function setupChildProcessIpcChannel() {\n }\n \n module.exports = {\n-  setupStdio,\n   wrapProcessMethods,\n   setupSignalHandlers,\n   setupChildProcessIpcChannel,"
        },
        {
            "sha": "bf5f6df15f123c1236f1d27393bd20ed5c5acd68",
            "filename": "lib/internal/process/stdio.js",
            "status": "modified",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Finternal%2Fprocess%2Fstdio.js",
            "raw_url": "https://github.com/nodejs/node/raw/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Finternal%2Fprocess%2Fstdio.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fstdio.js?ref=af237152cdb0b7b5a4495e84cdf4b170f6ddd361",
            "patch": "@@ -1,6 +1,5 @@\n 'use strict';\n \n-exports.setupProcessStdio = setupProcessStdio;\n exports.getMainThreadStdio = getMainThreadStdio;\n \n function dummyDestroy(err, cb) { cb(err); }\n@@ -134,31 +133,6 @@ function getMainThreadStdio() {\n   };\n }\n \n-function setupProcessStdio({ getStdout, getStdin, getStderr }) {\n-  Object.defineProperty(process, 'stdout', {\n-    configurable: true,\n-    enumerable: true,\n-    get: getStdout\n-  });\n-\n-  Object.defineProperty(process, 'stderr', {\n-    configurable: true,\n-    enumerable: true,\n-    get: getStderr\n-  });\n-\n-  Object.defineProperty(process, 'stdin', {\n-    configurable: true,\n-    enumerable: true,\n-    get: getStdin\n-  });\n-\n-  process.openStdin = function() {\n-    process.stdin.resume();\n-    return process.stdin;\n-  };\n-}\n-\n function createWritableStdioStream(fd) {\n   var stream;\n   const tty_wrap = internalBinding('tty_wrap');"
        },
        {
            "sha": "a9332fb4277363150a9c9dfe63361eaac15abd3d",
            "filename": "lib/internal/process/worker_thread_only.js",
            "status": "modified",
            "additions": 41,
            "deletions": 10,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Finternal%2Fprocess%2Fworker_thread_only.js",
            "raw_url": "https://github.com/nodejs/node/raw/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Finternal%2Fprocess%2Fworker_thread_only.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fworker_thread_only.js?ref=af237152cdb0b7b5a4495e84cdf4b170f6ddd361",
            "patch": "@@ -2,23 +2,54 @@\n \n // This file contains process bootstrappers that can only be\n // run in the worker thread.\n+const {\n+  getEnvMessagePort,\n+  threadId\n+} = internalBinding('worker');\n+\n+const debug = require('util').debuglog('worker');\n \n const {\n-  setupProcessStdio\n-} = require('internal/process/stdio');\n+  kWaitingStreams,\n+  ReadableWorkerStdio,\n+  WritableWorkerStdio\n+} = require('internal/worker/io');\n \n const {\n-  workerStdio\n+  createMessageHandler,\n+  createWorkerFatalExeception\n } = require('internal/worker');\n \n-function setupStdio() {\n-  setupProcessStdio({\n-    getStdout: () => workerStdio.stdout,\n-    getStderr: () => workerStdio.stderr,\n-    getStdin: () => workerStdio.stdin\n-  });\n+const workerStdio = {};\n+\n+function initializeWorkerStdio() {\n+  const port = getEnvMessagePort();\n+  port[kWaitingStreams] = 0;\n+  workerStdio.stdin = new ReadableWorkerStdio(port, 'stdin');\n+  workerStdio.stdout = new WritableWorkerStdio(port, 'stdout');\n+  workerStdio.stderr = new WritableWorkerStdio(port, 'stderr');\n+\n+  return {\n+    getStdout() { return workerStdio.stdout; },\n+    getStderr() { return workerStdio.stderr; },\n+    getStdin() { return workerStdio.stdin; }\n+  };\n+}\n+\n+function setup() {\n+  debug(`[${threadId}] is setting up worker child environment`);\n+\n+  const port = getEnvMessagePort();\n+  const publicWorker = require('worker_threads');\n+  port.on('message', createMessageHandler(publicWorker, port, workerStdio));\n+  port.start();\n+\n+  return {\n+    workerFatalExeception: createWorkerFatalExeception(port)\n+  };\n }\n \n module.exports = {\n-  setupStdio\n+  initializeWorkerStdio,\n+  setup\n };"
        },
        {
            "sha": "c4393d0459cf7e1678857695044bda7d341010eb",
            "filename": "lib/internal/worker.js",
            "status": "modified",
            "additions": 27,
            "deletions": 247,
            "changes": 274,
            "blob_url": "https://github.com/nodejs/node/blob/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Finternal%2Fworker.js",
            "raw_url": "https://github.com/nodejs/node/raw/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Finternal%2Fworker.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fworker.js?ref=af237152cdb0b7b5a4495e84cdf4b170f6ddd361",
            "patch": "@@ -4,249 +4,47 @@ const EventEmitter = require('events');\n const assert = require('assert');\n const path = require('path');\n const util = require('util');\n-const { Readable, Writable } = require('stream');\n const {\n   ERR_WORKER_PATH,\n   ERR_WORKER_UNSERIALIZABLE_ERROR,\n   ERR_WORKER_UNSUPPORTED_EXTENSION,\n } = require('internal/errors').codes;\n const { validateString } = require('internal/validators');\n+const { clearAsyncIdStack } = require('internal/async_hooks');\n \n-const { MessagePort, MessageChannel } = internalBinding('messaging');\n const {\n-  handle_onclose: handleOnCloseSymbol,\n-  oninit: onInitSymbol\n-} = internalBinding('symbols');\n-const { clearAsyncIdStack } = require('internal/async_hooks');\n+  drainMessagePort,\n+  MessageChannel,\n+  messageTypes,\n+  kPort,\n+  kIncrementsPortRef,\n+  kWaitingStreams,\n+  kStdioWantsMoreDataCallback,\n+  setupPortReferencing,\n+  ReadableWorkerStdio,\n+  WritableWorkerStdio,\n+} = require('internal/worker/io');\n const { serializeError, deserializeError } = require('internal/error-serdes');\n const { pathToFileURL } = require('url');\n \n const {\n   Worker: WorkerImpl,\n-  getEnvMessagePort,\n   threadId\n } = internalBinding('worker');\n \n const isMainThread = threadId === 0;\n \n-const kOnMessageListener = Symbol('kOnMessageListener');\n const kHandle = Symbol('kHandle');\n-const kName = Symbol('kName');\n-const kPort = Symbol('kPort');\n const kPublicPort = Symbol('kPublicPort');\n const kDispose = Symbol('kDispose');\n const kOnExit = Symbol('kOnExit');\n const kOnMessage = Symbol('kOnMessage');\n const kOnCouldNotSerializeErr = Symbol('kOnCouldNotSerializeErr');\n const kOnErrorMessage = Symbol('kOnErrorMessage');\n const kParentSideStdio = Symbol('kParentSideStdio');\n-const kWritableCallbacks = Symbol('kWritableCallbacks');\n-const kStdioWantsMoreDataCallback = Symbol('kStdioWantsMoreDataCallback');\n-const kStartedReading = Symbol('kStartedReading');\n-const kWaitingStreams = Symbol('kWaitingStreams');\n-const kIncrementsPortRef = Symbol('kIncrementsPortRef');\n \n const debug = util.debuglog('worker');\n \n-const messageTypes = {\n-  UP_AND_RUNNING: 'upAndRunning',\n-  COULD_NOT_SERIALIZE_ERROR: 'couldNotSerializeError',\n-  ERROR_MESSAGE: 'errorMessage',\n-  STDIO_PAYLOAD: 'stdioPayload',\n-  STDIO_WANTS_MORE_DATA: 'stdioWantsMoreData',\n-  LOAD_SCRIPT: 'loadScript'\n-};\n-\n-// We have to mess with the MessagePort prototype a bit, so that a) we can make\n-// it inherit from EventEmitter, even though it is a C++ class, and b) we do\n-// not provide methods that are not present in the Browser and not documented\n-// on our side (e.g. hasRef).\n-// Save a copy of the original set of methods as a shallow clone.\n-const MessagePortPrototype = Object.create(\n-  Object.getPrototypeOf(MessagePort.prototype),\n-  Object.getOwnPropertyDescriptors(MessagePort.prototype));\n-// Set up the new inheritance chain.\n-Object.setPrototypeOf(MessagePort, EventEmitter);\n-Object.setPrototypeOf(MessagePort.prototype, EventEmitter.prototype);\n-// Finally, purge methods we don't want to be public.\n-delete MessagePort.prototype.stop;\n-delete MessagePort.prototype.drain;\n-MessagePort.prototype.ref = MessagePortPrototype.ref;\n-MessagePort.prototype.unref = MessagePortPrototype.unref;\n-\n-// A communication channel consisting of a handle (that wraps around an\n-// uv_async_t) which can receive information from other threads and emits\n-// .onmessage events, and a function used for sending data to a MessagePort\n-// in some other thread.\n-MessagePort.prototype[kOnMessageListener] = function onmessage(payload) {\n-  debug(`[${threadId}] received message`, payload);\n-  // Emit the deserialized object to userland.\n-  this.emit('message', payload);\n-};\n-\n-// This is for compatibility with the Web's MessagePort API. It makes sense to\n-// provide it as an `EventEmitter` in Node.js, but if somebody overrides\n-// `onmessage`, we'll switch over to the Web API model.\n-Object.defineProperty(MessagePort.prototype, 'onmessage', {\n-  enumerable: true,\n-  configurable: true,\n-  get() {\n-    return this[kOnMessageListener];\n-  },\n-  set(value) {\n-    this[kOnMessageListener] = value;\n-    if (typeof value === 'function') {\n-      this.ref();\n-      MessagePortPrototype.start.call(this);\n-    } else {\n-      this.unref();\n-      MessagePortPrototype.stop.call(this);\n-    }\n-  }\n-});\n-\n-// This is called from inside the `MessagePort` constructor.\n-function oninit() {\n-  setupPortReferencing(this, this, 'message');\n-}\n-\n-Object.defineProperty(MessagePort.prototype, onInitSymbol, {\n-  enumerable: true,\n-  writable: false,\n-  value: oninit\n-});\n-\n-// This is called after the underlying `uv_async_t` has been closed.\n-function onclose() {\n-  if (typeof this.onclose === 'function') {\n-    // Not part of the Web standard yet, but there aren't many reasonable\n-    // alternatives in a non-EventEmitter usage setting.\n-    // Refs: https://github.com/whatwg/html/issues/1766\n-    this.onclose();\n-  }\n-  this.emit('close');\n-}\n-\n-Object.defineProperty(MessagePort.prototype, handleOnCloseSymbol, {\n-  enumerable: false,\n-  writable: false,\n-  value: onclose\n-});\n-\n-MessagePort.prototype.close = function(cb) {\n-  if (typeof cb === 'function')\n-    this.once('close', cb);\n-  MessagePortPrototype.close.call(this);\n-};\n-\n-Object.defineProperty(MessagePort.prototype, util.inspect.custom, {\n-  enumerable: false,\n-  writable: false,\n-  value: function inspect() {  // eslint-disable-line func-name-matching\n-    let ref;\n-    try {\n-      // This may throw when `this` does not refer to a native object,\n-      // e.g. when accessing the prototype directly.\n-      ref = MessagePortPrototype.hasRef.call(this);\n-    } catch { return this; }\n-    return Object.assign(Object.create(MessagePort.prototype),\n-                         ref === undefined ? {\n-                           active: false,\n-                         } : {\n-                           active: true,\n-                           refed: ref\n-                         },\n-                         this);\n-  }\n-});\n-\n-function setupPortReferencing(port, eventEmitter, eventName) {\n-  // Keep track of whether there are any workerMessage listeners:\n-  // If there are some, ref() the channel so it keeps the event loop alive.\n-  // If there are none or all are removed, unref() the channel so the worker\n-  // can shutdown gracefully.\n-  port.unref();\n-  eventEmitter.on('newListener', (name) => {\n-    if (name === eventName && eventEmitter.listenerCount(eventName) === 0) {\n-      port.ref();\n-      MessagePortPrototype.start.call(port);\n-    }\n-  });\n-  eventEmitter.on('removeListener', (name) => {\n-    if (name === eventName && eventEmitter.listenerCount(eventName) === 0) {\n-      MessagePortPrototype.stop.call(port);\n-      port.unref();\n-    }\n-  });\n-}\n-\n-\n-class ReadableWorkerStdio extends Readable {\n-  constructor(port, name) {\n-    super();\n-    this[kPort] = port;\n-    this[kName] = name;\n-    this[kIncrementsPortRef] = true;\n-    this[kStartedReading] = false;\n-    this.on('end', () => {\n-      if (this[kIncrementsPortRef] && --this[kPort][kWaitingStreams] === 0)\n-        this[kPort].unref();\n-    });\n-  }\n-\n-  _read() {\n-    if (!this[kStartedReading] && this[kIncrementsPortRef]) {\n-      this[kStartedReading] = true;\n-      if (this[kPort][kWaitingStreams]++ === 0)\n-        this[kPort].ref();\n-    }\n-\n-    this[kPort].postMessage({\n-      type: messageTypes.STDIO_WANTS_MORE_DATA,\n-      stream: this[kName]\n-    });\n-  }\n-}\n-\n-class WritableWorkerStdio extends Writable {\n-  constructor(port, name) {\n-    super({ decodeStrings: false });\n-    this[kPort] = port;\n-    this[kName] = name;\n-    this[kWritableCallbacks] = [];\n-  }\n-\n-  _write(chunk, encoding, cb) {\n-    this[kPort].postMessage({\n-      type: messageTypes.STDIO_PAYLOAD,\n-      stream: this[kName],\n-      chunk,\n-      encoding\n-    });\n-    this[kWritableCallbacks].push(cb);\n-    if (this[kPort][kWaitingStreams]++ === 0)\n-      this[kPort].ref();\n-  }\n-\n-  _final(cb) {\n-    this[kPort].postMessage({\n-      type: messageTypes.STDIO_PAYLOAD,\n-      stream: this[kName],\n-      chunk: null\n-    });\n-    cb();\n-  }\n-\n-  [kStdioWantsMoreDataCallback]() {\n-    const cbs = this[kWritableCallbacks];\n-    this[kWritableCallbacks] = [];\n-    for (const cb of cbs)\n-      cb();\n-    if ((this[kPort][kWaitingStreams] -= cbs.length) === 0)\n-      this[kPort].unref();\n-  }\n-}\n-\n class Worker extends EventEmitter {\n   constructor(filename, options = {}) {\n     super();\n@@ -314,8 +112,8 @@ class Worker extends EventEmitter {\n \n   [kOnExit](code) {\n     debug(`[${threadId}] hears end event for Worker ${this.threadId}`);\n-    MessagePortPrototype.drain.call(this[kPublicPort]);\n-    MessagePortPrototype.drain.call(this[kPort]);\n+    drainMessagePort(this[kPublicPort]);\n+    drainMessagePort(this[kPort]);\n     this[kDispose]();\n     this.emit('exit', code);\n     this.removeAllListeners();\n@@ -421,25 +219,8 @@ class Worker extends EventEmitter {\n   }\n }\n \n-const workerStdio = {};\n-if (!isMainThread) {\n-  const port = getEnvMessagePort();\n-  port[kWaitingStreams] = 0;\n-  workerStdio.stdin = new ReadableWorkerStdio(port, 'stdin');\n-  workerStdio.stdout = new WritableWorkerStdio(port, 'stdout');\n-  workerStdio.stderr = new WritableWorkerStdio(port, 'stderr');\n-}\n-\n-let originalFatalException;\n-\n-function setupChild() {\n-  // Called during bootstrap to set up worker script execution.\n-  debug(`[${threadId}] is setting up worker child environment`);\n-  const port = getEnvMessagePort();\n-\n-  const publicWorker = require('worker_threads');\n-\n-  port.on('message', (message) => {\n+function createMessageHandler(publicWorker, port, workerStdio) {\n+  return function(message) {\n     if (message.type === messageTypes.LOAD_SCRIPT) {\n       const { filename, doEval, workerData, publicPort, hasStdin } = message;\n       publicWorker.parentPort = publicPort;\n@@ -471,14 +252,15 @@ function setupChild() {\n     }\n \n     assert.fail(`Unknown worker message type ${message.type}`);\n-  });\n-\n-  port.start();\n+  };\n+}\n \n-  originalFatalException = process._fatalException;\n-  process._fatalException = fatalException;\n+function createWorkerFatalExeception(port) {\n+  const {\n+    fatalException: originalFatalException\n+  } = require('internal/process/execution');\n \n-  function fatalException(error) {\n+  return function(error) {\n     debug(`[${threadId}] gets fatal exception`);\n     let caught = false;\n     try {\n@@ -505,7 +287,7 @@ function setupChild() {\n \n       process.exit();\n     }\n-  }\n+  };\n }\n \n function pipeWithoutWarning(source, dest) {\n@@ -521,11 +303,9 @@ function pipeWithoutWarning(source, dest) {\n }\n \n module.exports = {\n-  MessagePort,\n-  MessageChannel,\n+  createMessageHandler,\n+  createWorkerFatalExeception,\n   threadId,\n   Worker,\n-  setupChild,\n-  isMainThread,\n-  workerStdio\n+  isMainThread\n };"
        },
        {
            "sha": "d249ba8508b7af357bf599205873e52bba50c283",
            "filename": "lib/internal/worker/io.js",
            "status": "added",
            "additions": 245,
            "deletions": 0,
            "changes": 245,
            "blob_url": "https://github.com/nodejs/node/blob/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Finternal%2Fworker%2Fio.js",
            "raw_url": "https://github.com/nodejs/node/raw/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Finternal%2Fworker%2Fio.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fworker%2Fio.js?ref=af237152cdb0b7b5a4495e84cdf4b170f6ddd361",
            "patch": "@@ -0,0 +1,245 @@\n+'use strict';\n+\n+const {\n+  handle_onclose: handleOnCloseSymbol,\n+  oninit: onInitSymbol\n+} = internalBinding('symbols');\n+const {\n+  MessagePort,\n+  MessageChannel\n+} = internalBinding('messaging');\n+const { threadId } = internalBinding('worker');\n+\n+const { Readable, Writable } = require('stream');\n+const EventEmitter = require('events');\n+const util = require('util');\n+const debug = util.debuglog('worker');\n+\n+const kIncrementsPortRef = Symbol('kIncrementsPortRef');\n+const kName = Symbol('kName');\n+const kOnMessageListener = Symbol('kOnMessageListener');\n+const kPort = Symbol('kPort');\n+const kWaitingStreams = Symbol('kWaitingStreams');\n+const kWritableCallbacks = Symbol('kWritableCallbacks');\n+const kStartedReading = Symbol('kStartedReading');\n+const kStdioWantsMoreDataCallback = Symbol('kStdioWantsMoreDataCallback');\n+\n+const messageTypes = {\n+  UP_AND_RUNNING: 'upAndRunning',\n+  COULD_NOT_SERIALIZE_ERROR: 'couldNotSerializeError',\n+  ERROR_MESSAGE: 'errorMessage',\n+  STDIO_PAYLOAD: 'stdioPayload',\n+  STDIO_WANTS_MORE_DATA: 'stdioWantsMoreData',\n+  LOAD_SCRIPT: 'loadScript'\n+};\n+\n+// Original drain from C++\n+const originalDrain = MessagePort.prototype.drain;\n+\n+function drainMessagePort(port) {\n+  return originalDrain.call(port);\n+}\n+\n+// We have to mess with the MessagePort prototype a bit, so that a) we can make\n+// it inherit from EventEmitter, even though it is a C++ class, and b) we do\n+// not provide methods that are not present in the Browser and not documented\n+// on our side (e.g. hasRef).\n+// Save a copy of the original set of methods as a shallow clone.\n+const MessagePortPrototype = Object.create(\n+  Object.getPrototypeOf(MessagePort.prototype),\n+  Object.getOwnPropertyDescriptors(MessagePort.prototype));\n+// Set up the new inheritance chain.\n+Object.setPrototypeOf(MessagePort, EventEmitter);\n+Object.setPrototypeOf(MessagePort.prototype, EventEmitter.prototype);\n+// Finally, purge methods we don't want to be public.\n+delete MessagePort.prototype.stop;\n+delete MessagePort.prototype.drain;\n+MessagePort.prototype.ref = MessagePortPrototype.ref;\n+MessagePort.prototype.unref = MessagePortPrototype.unref;\n+\n+// A communication channel consisting of a handle (that wraps around an\n+// uv_async_t) which can receive information from other threads and emits\n+// .onmessage events, and a function used for sending data to a MessagePort\n+// in some other thread.\n+MessagePort.prototype[kOnMessageListener] = function onmessage(payload) {\n+  debug(`[${threadId}] received message`, payload);\n+  // Emit the deserialized object to userland.\n+  this.emit('message', payload);\n+};\n+\n+// This is for compatibility with the Web's MessagePort API. It makes sense to\n+// provide it as an `EventEmitter` in Node.js, but if somebody overrides\n+// `onmessage`, we'll switch over to the Web API model.\n+Object.defineProperty(MessagePort.prototype, 'onmessage', {\n+  enumerable: true,\n+  configurable: true,\n+  get() {\n+    return this[kOnMessageListener];\n+  },\n+  set(value) {\n+    this[kOnMessageListener] = value;\n+    if (typeof value === 'function') {\n+      this.ref();\n+      MessagePortPrototype.start.call(this);\n+    } else {\n+      this.unref();\n+      MessagePortPrototype.stop.call(this);\n+    }\n+  }\n+});\n+\n+// This is called from inside the `MessagePort` constructor.\n+function oninit() {\n+  setupPortReferencing(this, this, 'message');\n+}\n+\n+Object.defineProperty(MessagePort.prototype, onInitSymbol, {\n+  enumerable: true,\n+  writable: false,\n+  value: oninit\n+});\n+\n+// This is called after the underlying `uv_async_t` has been closed.\n+function onclose() {\n+  if (typeof this.onclose === 'function') {\n+    // Not part of the Web standard yet, but there aren't many reasonable\n+    // alternatives in a non-EventEmitter usage setting.\n+    // Refs: https://github.com/whatwg/html/issues/1766\n+    this.onclose();\n+  }\n+  this.emit('close');\n+}\n+\n+Object.defineProperty(MessagePort.prototype, handleOnCloseSymbol, {\n+  enumerable: false,\n+  writable: false,\n+  value: onclose\n+});\n+\n+MessagePort.prototype.close = function(cb) {\n+  if (typeof cb === 'function')\n+    this.once('close', cb);\n+  MessagePortPrototype.close.call(this);\n+};\n+\n+Object.defineProperty(MessagePort.prototype, util.inspect.custom, {\n+  enumerable: false,\n+  writable: false,\n+  value: function inspect() {  // eslint-disable-line func-name-matching\n+    let ref;\n+    try {\n+      // This may throw when `this` does not refer to a native object,\n+      // e.g. when accessing the prototype directly.\n+      ref = MessagePortPrototype.hasRef.call(this);\n+    } catch { return this; }\n+    return Object.assign(Object.create(MessagePort.prototype),\n+                         ref === undefined ? {\n+                           active: false,\n+                         } : {\n+                           active: true,\n+                           refed: ref\n+                         },\n+                         this);\n+  }\n+});\n+\n+function setupPortReferencing(port, eventEmitter, eventName) {\n+  // Keep track of whether there are any workerMessage listeners:\n+  // If there are some, ref() the channel so it keeps the event loop alive.\n+  // If there are none or all are removed, unref() the channel so the worker\n+  // can shutdown gracefully.\n+  port.unref();\n+  eventEmitter.on('newListener', (name) => {\n+    if (name === eventName && eventEmitter.listenerCount(eventName) === 0) {\n+      port.ref();\n+      MessagePortPrototype.start.call(port);\n+    }\n+  });\n+  eventEmitter.on('removeListener', (name) => {\n+    if (name === eventName && eventEmitter.listenerCount(eventName) === 0) {\n+      MessagePortPrototype.stop.call(port);\n+      port.unref();\n+    }\n+  });\n+}\n+\n+\n+class ReadableWorkerStdio extends Readable {\n+  constructor(port, name) {\n+    super();\n+    this[kPort] = port;\n+    this[kName] = name;\n+    this[kIncrementsPortRef] = true;\n+    this[kStartedReading] = false;\n+    this.on('end', () => {\n+      if (this[kIncrementsPortRef] && --this[kPort][kWaitingStreams] === 0)\n+        this[kPort].unref();\n+    });\n+  }\n+\n+  _read() {\n+    if (!this[kStartedReading] && this[kIncrementsPortRef]) {\n+      this[kStartedReading] = true;\n+      if (this[kPort][kWaitingStreams]++ === 0)\n+        this[kPort].ref();\n+    }\n+\n+    this[kPort].postMessage({\n+      type: messageTypes.STDIO_WANTS_MORE_DATA,\n+      stream: this[kName]\n+    });\n+  }\n+}\n+\n+class WritableWorkerStdio extends Writable {\n+  constructor(port, name) {\n+    super({ decodeStrings: false });\n+    this[kPort] = port;\n+    this[kName] = name;\n+    this[kWritableCallbacks] = [];\n+  }\n+\n+  _write(chunk, encoding, cb) {\n+    this[kPort].postMessage({\n+      type: messageTypes.STDIO_PAYLOAD,\n+      stream: this[kName],\n+      chunk,\n+      encoding\n+    });\n+    this[kWritableCallbacks].push(cb);\n+    if (this[kPort][kWaitingStreams]++ === 0)\n+      this[kPort].ref();\n+  }\n+\n+  _final(cb) {\n+    this[kPort].postMessage({\n+      type: messageTypes.STDIO_PAYLOAD,\n+      stream: this[kName],\n+      chunk: null\n+    });\n+    cb();\n+  }\n+\n+  [kStdioWantsMoreDataCallback]() {\n+    const cbs = this[kWritableCallbacks];\n+    this[kWritableCallbacks] = [];\n+    for (const cb of cbs)\n+      cb();\n+    if ((this[kPort][kWaitingStreams] -= cbs.length) === 0)\n+      this[kPort].unref();\n+  }\n+}\n+\n+module.exports = {\n+  drainMessagePort,\n+  messageTypes,\n+  kPort,\n+  kIncrementsPortRef,\n+  kWaitingStreams,\n+  kStdioWantsMoreDataCallback,\n+  MessagePort,\n+  MessageChannel,\n+  setupPortReferencing,\n+  ReadableWorkerStdio,\n+  WritableWorkerStdio\n+};"
        },
        {
            "sha": "828edb6bffce7bc3bdfa23373a085e8a798923a7",
            "filename": "lib/worker_threads.js",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Fworker_threads.js",
            "raw_url": "https://github.com/nodejs/node/raw/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/lib%2Fworker_threads.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fworker_threads.js?ref=af237152cdb0b7b5a4495e84cdf4b170f6ddd361",
            "patch": "@@ -2,12 +2,15 @@\n \n const {\n   isMainThread,\n-  MessagePort,\n-  MessageChannel,\n   threadId,\n   Worker\n } = require('internal/worker');\n \n+const {\n+  MessagePort,\n+  MessageChannel\n+} = require('internal/worker/io');\n+\n module.exports = {\n   isMainThread,\n   MessagePort,"
        },
        {
            "sha": "d2c3560131b7e550d5fa9640b4b721f7812afbf8",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/af237152cdb0b7b5a4495e84cdf4b170f6ddd361/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=af237152cdb0b7b5a4495e84cdf4b170f6ddd361",
            "patch": "@@ -181,6 +181,7 @@\n       'lib/internal/stream_base_commons.js',\n       'lib/internal/vm/source_text_module.js',\n       'lib/internal/worker.js',\n+      'lib/internal/worker/io.js',\n       'lib/internal/streams/lazy_transform.js',\n       'lib/internal/streams/async_iterator.js',\n       'lib/internal/streams/buffer_list.js',"
        }
    ],
    "stats": {
        "total": 657,
        "additions": 358,
        "deletions": 299
    }
}