{
    "author": "addaleax",
    "message": "src: fix race condition in `~NodeTraceBuffer`\n\nLibuv does not guarantee that handles have their close\ncallbacks called in the order in which they were added\n(and in fact, currently calls them in reverse order).\n\nThis patch ensures that the `flush_signal_` handle\nis no longer in use (i.e. its close callback has already\nbeen run) when we signal to the main thread that\n`~NodeTraceBuffer` may be destroyed.\n\nThe same applies for `~NodeTraceWriter`.\n\nCredit for debugging goes to Gireesh Punathil.\n\nFixes: https://github.com/nodejs/node/issues/25512\nCo-authored-by: Gireesh Punathil <gpunathi@in.ibm.com>\n\nPR-URL: https://github.com/nodejs/node/pull/25896\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>\nReviewed-By: Eugene Ostroukhov <eostroukhov@google.com>",
    "sha": "5506dcdd73a69b353c12c7137d6cba49a4c07123",
    "files": [
        {
            "sha": "796c9f529288e543c96701b0c3177a121ae8a7ff",
            "filename": "src/tracing/node_trace_buffer.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 7,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/5506dcdd73a69b353c12c7137d6cba49a4c07123/src%2Ftracing%2Fnode_trace_buffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5506dcdd73a69b353c12c7137d6cba49a4c07123/src%2Ftracing%2Fnode_trace_buffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fnode_trace_buffer.cc?ref=5506dcdd73a69b353c12c7137d6cba49a4c07123",
            "patch": "@@ -1,4 +1,5 @@\n #include \"tracing/node_trace_buffer.h\"\n+#include \"util-inl.h\"\n \n namespace node {\n namespace tracing {\n@@ -170,15 +171,25 @@ void NodeTraceBuffer::NonBlockingFlushSignalCb(uv_async_t* signal) {\n \n // static\n void NodeTraceBuffer::ExitSignalCb(uv_async_t* signal) {\n-  NodeTraceBuffer* buffer = reinterpret_cast<NodeTraceBuffer*>(signal->data);\n-  uv_close(reinterpret_cast<uv_handle_t*>(&buffer->flush_signal_), nullptr);\n-  uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),\n+  NodeTraceBuffer* buffer =\n+      ContainerOf(&NodeTraceBuffer::exit_signal_, signal);\n+\n+  // Close both flush_signal_ and exit_signal_.\n+  uv_close(reinterpret_cast<uv_handle_t*>(&buffer->flush_signal_),\n            [](uv_handle_t* signal) {\n+    NodeTraceBuffer* buffer =\n+        ContainerOf(&NodeTraceBuffer::flush_signal_,\n+                    reinterpret_cast<uv_async_t*>(signal));\n+\n+    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),\n+             [](uv_handle_t* signal) {\n       NodeTraceBuffer* buffer =\n-          reinterpret_cast<NodeTraceBuffer*>(signal->data);\n-      Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);\n-      buffer->exited_ = true;\n-      buffer->exit_cond_.Signal(scoped_lock);\n+          ContainerOf(&NodeTraceBuffer::exit_signal_,\n+                      reinterpret_cast<uv_async_t*>(signal));\n+        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);\n+        buffer->exited_ = true;\n+        buffer->exit_cond_.Signal(scoped_lock);\n+    });\n   });\n }\n "
        },
        {
            "sha": "b93688cc958faab8c4f1651e0bd02ea34472b2a7",
            "filename": "src/tracing/node_trace_writer.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 10,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/5506dcdd73a69b353c12c7137d6cba49a4c07123/src%2Ftracing%2Fnode_trace_writer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5506dcdd73a69b353c12c7137d6cba49a4c07123/src%2Ftracing%2Fnode_trace_writer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fnode_trace_writer.cc?ref=5506dcdd73a69b353c12c7137d6cba49a4c07123",
            "patch": "@@ -218,18 +218,23 @@ void NodeTraceWriter::AfterWrite() {\n void NodeTraceWriter::ExitSignalCb(uv_async_t* signal) {\n   NodeTraceWriter* trace_writer =\n       ContainerOf(&NodeTraceWriter::exit_signal_, signal);\n+  // Close both flush_signal_ and exit_signal_.\n   uv_close(reinterpret_cast<uv_handle_t*>(&trace_writer->flush_signal_),\n-           nullptr);\n-  uv_close(reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),\n            [](uv_handle_t* signal) {\n-      NodeTraceWriter* trace_writer =\n-          ContainerOf(&NodeTraceWriter::exit_signal_,\n-                      reinterpret_cast<uv_async_t*>(signal));\n-      Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);\n-      trace_writer->exited_ = true;\n-      trace_writer->exit_cond_.Signal(scoped_lock);\n-  });\n+             NodeTraceWriter* trace_writer =\n+                 ContainerOf(&NodeTraceWriter::flush_signal_,\n+                             reinterpret_cast<uv_async_t*>(signal));\n+             uv_close(\n+                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),\n+                 [](uv_handle_t* signal) {\n+                   NodeTraceWriter* trace_writer =\n+                       ContainerOf(&NodeTraceWriter::exit_signal_,\n+                                   reinterpret_cast<uv_async_t*>(signal));\n+                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);\n+                   trace_writer->exited_ = true;\n+                   trace_writer->exit_cond_.Signal(scoped_lock);\n+                 });\n+           });\n }\n-\n }  // namespace tracing\n }  // namespace node"
        }
    ],
    "stats": {
        "total": 50,
        "additions": 33,
        "deletions": 17
    }
}