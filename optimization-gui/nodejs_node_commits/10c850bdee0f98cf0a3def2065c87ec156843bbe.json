{
    "author": "BridgeAR",
    "message": "util: harden util.inspect\n\nThis makes sure values without prototype will still be inspected\nproperly and do not cause errors. It restores the original\ninformation if possible.\n\nBesides that it fixes an issue with boxed symbols: extra keys were\nnot visualized so far.\n\nPR-URL: https://github.com/nodejs/node/pull/21869\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: John-David Dalton <john.david.dalton@gmail.com>",
    "sha": "10c850bdee0f98cf0a3def2065c87ec156843bbe",
    "files": [
        {
            "sha": "7f46e8db4e49c4b692cd89b9bae51bcc7e6a0b42",
            "filename": "lib/util.js",
            "status": "modified",
            "additions": 160,
            "deletions": 80,
            "changes": 240,
            "blob_url": "https://github.com/nodejs/node/blob/10c850bdee0f98cf0a3def2065c87ec156843bbe/lib%2Futil.js",
            "raw_url": "https://github.com/nodejs/node/raw/10c850bdee0f98cf0a3def2065c87ec156843bbe/lib%2Futil.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Futil.js?ref=10c850bdee0f98cf0a3def2065c87ec156843bbe",
            "patch": "@@ -43,6 +43,7 @@ const types = internalBinding('types');\n Object.assign(types, require('internal/util/types'));\n const {\n   isAnyArrayBuffer,\n+  isArrayBuffer,\n   isArgumentsObject,\n   isDataView,\n   isExternal,\n@@ -55,7 +56,23 @@ const {\n   isWeakSet,\n   isRegExp,\n   isDate,\n-  isTypedArray\n+  isTypedArray,\n+  isStringObject,\n+  isNumberObject,\n+  isBooleanObject,\n+  isSymbolObject,\n+  isBigIntObject,\n+  isUint8Array,\n+  isUint8ClampedArray,\n+  isUint16Array,\n+  isUint32Array,\n+  isInt8Array,\n+  isInt16Array,\n+  isInt32Array,\n+  isFloat32Array,\n+  isFloat64Array,\n+  isBigInt64Array,\n+  isBigUint64Array\n } = types;\n \n const {\n@@ -79,10 +96,31 @@ const inspectDefaultOptions = Object.seal({\n   compact: true\n });\n \n-const propertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n-const regExpToString = RegExp.prototype.toString;\n-const dateToISOString = Date.prototype.toISOString;\n-const errorToString = Error.prototype.toString;\n+const ReflectApply = Reflect.apply;\n+\n+// This function is borrowed from the function with the same name on V8 Extras'\n+// `utils` object. V8 implements Reflect.apply very efficiently in conjunction\n+// with the spread syntax, such that no additional special case is needed for\n+// function calls w/o arguments.\n+// Refs: https://github.com/v8/v8/blob/d6ead37d265d7215cf9c5f768f279e21bd170212/src/js/prologue.js#L152-L156\n+function uncurryThis(func) {\n+  return (thisArg, ...args) => ReflectApply(func, thisArg, args);\n+}\n+\n+const propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);\n+const regExpToString = uncurryThis(RegExp.prototype.toString);\n+const dateToISOString = uncurryThis(Date.prototype.toISOString);\n+const errorToString = uncurryThis(Error.prototype.toString);\n+\n+const bigIntValueOf = uncurryThis(BigInt.prototype.valueOf);\n+const booleanValueOf = uncurryThis(Boolean.prototype.valueOf);\n+const numberValueOf = uncurryThis(Number.prototype.valueOf);\n+const symbolValueOf = uncurryThis(Symbol.prototype.valueOf);\n+const stringValueOf = uncurryThis(String.prototype.valueOf);\n+\n+const setValues = uncurryThis(Set.prototype.values);\n+const mapEntries = uncurryThis(Map.prototype.entries);\n+const dateGetTime = uncurryThis(Date.prototype.getTime);\n \n let CIRCULAR_ERROR_MESSAGE;\n let internalDeepEqual;\n@@ -445,7 +483,7 @@ function getConstructorName(obj) {\n   return '';\n }\n \n-function getPrefix(constructor, tag) {\n+function getPrefix(constructor, tag, fallback) {\n   if (constructor !== '') {\n     if (tag !== '' && constructor !== tag) {\n       return `${constructor} [${tag}] `;\n@@ -456,9 +494,42 @@ function getPrefix(constructor, tag) {\n   if (tag !== '')\n     return `[${tag}] `;\n \n+  if (fallback !== undefined)\n+    return `${fallback} `;\n+\n   return '';\n }\n \n+function addExtraKeys(source, target, keys) {\n+  for (const key of keys) {\n+    target[key] = source[key];\n+  }\n+  return target;\n+}\n+\n+function findTypedConstructor(value) {\n+  for (const [check, clazz] of [\n+    [isUint8Array, Uint8Array],\n+    [isUint8ClampedArray, Uint8ClampedArray],\n+    [isUint16Array, Uint16Array],\n+    [isUint32Array, Uint32Array],\n+    [isInt8Array, Int8Array],\n+    [isInt16Array, Int16Array],\n+    [isInt32Array, Int32Array],\n+    [isFloat32Array, Float32Array],\n+    [isFloat64Array, Float64Array],\n+    [isBigInt64Array, BigInt64Array],\n+    [isBigUint64Array, BigUint64Array]\n+  ]) {\n+    if (check(value)) {\n+      return new clazz(value);\n+    }\n+  }\n+  return value;\n+}\n+\n+const getBoxedValue = formatPrimitive.bind(null, stylizeNoColor);\n+\n function formatValue(ctx, value, recurseTimes) {\n   // Primitive types cannot have properties\n   if (typeof value !== 'object' && typeof value !== 'function') {\n@@ -539,7 +610,7 @@ function formatValue(ctx, value, recurseTimes) {\n     }\n \n     if (symbols.length !== 0)\n-      symbols = symbols.filter((key) => propertyIsEnumerable.call(value, key));\n+      symbols = symbols.filter((key) => propertyIsEnumerable(value, key));\n   }\n \n   const keyLength = keys.length + symbols.length;\n@@ -552,8 +623,8 @@ function formatValue(ctx, value, recurseTimes) {\n   let formatter = formatObject;\n   let braces;\n   let noIterator = true;\n-  let raw;\n   let extra;\n+  let i = 0;\n \n   // Iterators and the rest are split to reduce checks\n   if (value[Symbol.iterator]) {\n@@ -587,34 +658,16 @@ function formatValue(ctx, value, recurseTimes) {\n       braces = [`[${tag}] {`, '}'];\n       formatter = formatSetIterator;\n     } else {\n-      // Check for boxed strings with valueOf()\n-      // The .valueOf() call can fail for a multitude of reasons\n-      try {\n-        raw = value.valueOf();\n-      } catch (e) { /* ignore */ }\n-\n-      if (typeof raw === 'string') {\n-        const formatted = formatPrimitive(stylizeNoColor, raw, ctx);\n-        if (keyLength === raw.length)\n-          return ctx.stylize(`[String: ${formatted}]`, 'string');\n-        base = `[String: ${formatted}]`;\n-        // For boxed Strings, we have to remove the 0-n indexed entries,\n-        // since they just noisy up the output and are redundant\n-        // Make boxed primitive Strings look like such\n-        keys = keys.slice(value.length);\n-        braces = ['{', '}'];\n-      } else {\n-        noIterator = true;\n-      }\n+      noIterator = true;\n     }\n   }\n   if (noIterator) {\n     braces = ['{', '}'];\n     if (constructor === 'Object') {\n       if (isArgumentsObject(value)) {\n-        braces[0] = '[Arguments] {';\n         if (keyLength === 0)\n           return '[Arguments] {}';\n+        braces[0] = '[Arguments] {';\n       } else if (tag !== '') {\n         braces[0] = `${getPrefix(constructor, tag)}{`;\n         if (keyLength === 0) {\n@@ -624,24 +677,24 @@ function formatValue(ctx, value, recurseTimes) {\n         return '{}';\n       }\n     } else if (typeof value === 'function') {\n-      const name =\n-        `${constructor || tag}${value.name ? `: ${value.name}` : ''}`;\n+      const type = constructor || tag || 'Function';\n+      const name = `${type}${value.name ? `: ${value.name}` : ''}`;\n       if (keyLength === 0)\n         return ctx.stylize(`[${name}]`, 'special');\n       base = `[${name}]`;\n     } else if (isRegExp(value)) {\n       // Make RegExps say that they are RegExps\n       if (keyLength === 0 || recurseTimes < 0)\n-        return ctx.stylize(regExpToString.call(value), 'regexp');\n-      base = `${regExpToString.call(value)}`;\n+        return ctx.stylize(regExpToString(value), 'regexp');\n+      base = `${regExpToString(value)}`;\n     } else if (isDate(value)) {\n+      // Make dates with properties first say the date\n       if (keyLength === 0) {\n-        if (Number.isNaN(value.getTime()))\n-          return ctx.stylize(value.toString(), 'date');\n-        return ctx.stylize(dateToISOString.call(value), 'date');\n+        if (Number.isNaN(dateGetTime(value)))\n+          return ctx.stylize(String(value), 'date');\n+        return ctx.stylize(dateToISOString(value), 'date');\n       }\n-      // Make dates with properties first say the date\n-      base = dateToISOString.call(value);\n+      base = dateToISOString(value);\n     } else if (isError(value)) {\n       // Make error with message first say the error\n       base = formatError(value);\n@@ -666,28 +719,31 @@ function formatValue(ctx, value, recurseTimes) {\n       // Fast path for ArrayBuffer and SharedArrayBuffer.\n       // Can't do the same for DataView because it has a non-primitive\n       // .buffer property that we need to recurse for.\n-      const prefix = getPrefix(constructor, tag);\n+      let prefix = getPrefix(constructor, tag);\n+      if (prefix === '') {\n+        prefix = isArrayBuffer(value) ? 'ArrayBuffer ' : 'SharedArrayBuffer ';\n+      }\n       if (keyLength === 0)\n         return prefix +\n               `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;\n       braces[0] = `${prefix}{`;\n       keys.unshift('byteLength');\n     } else if (isDataView(value)) {\n-      braces[0] = `${getPrefix(constructor, tag)}{`;\n+      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`;\n       // .buffer goes last, it's not a primitive like the others.\n       keys.unshift('byteLength', 'byteOffset', 'buffer');\n     } else if (isPromise(value)) {\n-      braces[0] = `${getPrefix(constructor, tag)}{`;\n+      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;\n       formatter = formatPromise;\n     } else if (isWeakSet(value)) {\n-      braces[0] = `${getPrefix(constructor, tag)}{`;\n+      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;\n       if (ctx.showHidden) {\n         formatter = formatWeakSet;\n       } else {\n         extra = '<items unknown>';\n       }\n     } else if (isWeakMap(value)) {\n-      braces[0] = `${getPrefix(constructor, tag)}{`;\n+      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;\n       if (ctx.showHidden) {\n         formatter = formatWeakMap;\n       } else {\n@@ -696,43 +752,67 @@ function formatValue(ctx, value, recurseTimes) {\n     } else if (types.isModuleNamespaceObject(value)) {\n       braces[0] = `[${tag}] {`;\n       formatter = formatNamespaceObject;\n+    } else if (isNumberObject(value)) {\n+      base = `[Number: ${getBoxedValue(numberValueOf(value))}]`;\n+      if (keyLength === 0)\n+        return ctx.stylize(base, 'number');\n+    } else if (isBooleanObject(value)) {\n+      base = `[Boolean: ${getBoxedValue(booleanValueOf(value))}]`;\n+      if (keyLength === 0)\n+        return ctx.stylize(base, 'boolean');\n+    } else if (isBigIntObject(value)) {\n+      base = `[BigInt: ${getBoxedValue(bigIntValueOf(value))}]`;\n+      if (keyLength === 0)\n+        return ctx.stylize(base, 'bigint');\n+    } else if (isSymbolObject(value)) {\n+      base = `[Symbol: ${getBoxedValue(symbolValueOf(value))}]`;\n+      if (keyLength === 0)\n+        return ctx.stylize(base, 'symbol');\n+    } else if (isStringObject(value)) {\n+      const raw = stringValueOf(value);\n+      base = `[String: ${getBoxedValue(raw, ctx)}]`;\n+      if (keyLength === raw.length)\n+        return ctx.stylize(base, 'string');\n+      // For boxed Strings, we have to remove the 0-n indexed entries,\n+      // since they just noisy up the output and are redundant\n+      // Make boxed primitive Strings look like such\n+      keys = keys.slice(value.length);\n+      braces = ['{', '}'];\n+    // The input prototype got manipulated. Special handle these.\n+    // We have to rebuild the information so we are able to display everything.\n+    } else if (isSet(value)) {\n+      const newVal = addExtraKeys(value, new Set(setValues(value)), keys);\n+      return formatValue(ctx, newVal, recurseTimes);\n+    } else if (isMap(value)) {\n+      const newVal = addExtraKeys(value, new Map(mapEntries(value)), keys);\n+      return formatValue(ctx, newVal, recurseTimes);\n+    } else if (Array.isArray(value)) {\n+      // The prefix is not always possible to fully reconstruct.\n+      const prefix = getPrefix(constructor, tag);\n+      braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];\n+      formatter = formatArray;\n+      const newValue = [];\n+      newValue.length = value.length;\n+      value = addExtraKeys(value, newValue, keys);\n+    } else if (isTypedArray(value)) {\n+      const newValue = findTypedConstructor(value);\n+      value = addExtraKeys(value, newValue, keys.slice(newValue.length));\n+      // The prefix is not always possible to fully reconstruct.\n+      braces = [`${getPrefix(getConstructorName(value), tag)}[`, ']'];\n+      formatter = formatTypedArray;\n+    } else if (isMapIterator(value)) {\n+      braces = [`[${tag || 'Map Iterator'}] {`, '}'];\n+      formatter = formatMapIterator;\n+    } else if (isSetIterator(value)) {\n+      braces = [`[${tag || 'Set Iterator'}] {`, '}'];\n+      formatter = formatSetIterator;\n+    // Handle other regular objects again.\n+    } else if (keyLength === 0) {\n+      if (isExternal(value))\n+        return ctx.stylize('[External]', 'special');\n+      return `${getPrefix(constructor, tag)}{}`;\n     } else {\n-      // Check boxed primitives other than string with valueOf()\n-      // NOTE: `Date` has to be checked first!\n-      // The .valueOf() call can fail for a multitude of reasons\n-      try {\n-        raw = value.valueOf();\n-      } catch (e) { /* ignore */ }\n-\n-      if (typeof raw === 'number') {\n-        // Make boxed primitive Numbers look like such\n-        const formatted = formatPrimitive(stylizeNoColor, raw);\n-        if (keyLength === 0)\n-          return ctx.stylize(`[Number: ${formatted}]`, 'number');\n-        base = `[Number: ${formatted}]`;\n-      } else if (typeof raw === 'boolean') {\n-        // Make boxed primitive Booleans look like such\n-        const formatted = formatPrimitive(stylizeNoColor, raw);\n-        if (keyLength === 0)\n-          return ctx.stylize(`[Boolean: ${formatted}]`, 'boolean');\n-        base = `[Boolean: ${formatted}]`;\n-        // eslint-disable-next-line valid-typeof\n-      } else if (typeof raw === 'bigint') {\n-        // Make boxed primitive BigInts look like such\n-        const formatted = formatPrimitive(stylizeNoColor, raw);\n-        if (keyLength === 0)\n-          return ctx.stylize(`[BigInt: ${formatted}]`, 'bigint');\n-        base = `[BigInt: ${formatted}]`;\n-      } else if (typeof raw === 'symbol') {\n-        const formatted = formatPrimitive(stylizeNoColor, raw);\n-        return ctx.stylize(`[Symbol: ${formatted}]`, 'symbol');\n-      } else if (keyLength === 0) {\n-        if (isExternal(value))\n-          return ctx.stylize('[External]', 'special');\n-        return `${getPrefix(constructor, tag)}{}`;\n-      } else {\n-        braces[0] = `${getPrefix(constructor, tag)}{`;\n-      }\n+      braces[0] = `${getPrefix(constructor, tag)}{`;\n     }\n   }\n \n@@ -765,7 +845,7 @@ function formatValue(ctx, value, recurseTimes) {\n   if (extra !== undefined)\n     output.unshift(extra);\n \n-  for (var i = 0; i < symbols.length; i++) {\n+  for (i = 0; i < symbols.length; i++) {\n     output.push(formatProperty(ctx, value, recurseTimes, symbols[i], 0));\n   }\n \n@@ -835,7 +915,7 @@ function formatPrimitive(fn, value, ctx) {\n }\n \n function formatError(value) {\n-  return value.stack || errorToString.call(value);\n+  return value.stack || errorToString(value);\n }\n \n function formatObject(ctx, value, recurseTimes, keys) {"
        },
        {
            "sha": "7b3da75a6ef084fd8acf18243e01425da800af1a",
            "filename": "test/parallel/test-util-inspect.js",
            "status": "modified",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/nodejs/node/blob/10c850bdee0f98cf0a3def2065c87ec156843bbe/test%2Fparallel%2Ftest-util-inspect.js",
            "raw_url": "https://github.com/nodejs/node/raw/10c850bdee0f98cf0a3def2065c87ec156843bbe/test%2Fparallel%2Ftest-util-inspect.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-util-inspect.js?ref=10c850bdee0f98cf0a3def2065c87ec156843bbe",
            "patch": "@@ -803,6 +803,14 @@ assert.strictEqual(util.inspect(new Number(13.37)), '[Number: 13.37]');\n   const num = new Number(13.37);\n   num.foo = 'bar';\n   assert.strictEqual(util.inspect(num), \"{ [Number: 13.37] foo: 'bar' }\");\n+\n+  const sym = Object(Symbol('foo'));\n+  sym.foo = 'bar';\n+  assert.strictEqual(util.inspect(sym), \"{ [Symbol: Symbol(foo)] foo: 'bar' }\");\n+\n+  const big = Object(BigInt(55));\n+  big.foo = 'bar';\n+  assert.strictEqual(util.inspect(big), \"{ [BigInt: 55n] foo: 'bar' }\");\n }\n \n // Test es6 Symbol.\n@@ -1433,3 +1441,78 @@ assert.strictEqual(util.inspect(\"'\"), '\"\\'\"');\n assert.strictEqual(util.inspect('\"\\''), '`\"\\'`');\n // eslint-disable-next-line no-template-curly-in-string\n assert.strictEqual(util.inspect('\"\\'${a}'), \"'\\\"\\\\'${a}'\");\n+\n+// Manipulating the Symbol.iterator should still produce nice results.\n+[\n+  [[1, 2], '[ 1, 2 ]'],\n+  [[, , 5, , , , ], '[ <2 empty items>, 5, <3 empty items> ]'],\n+  [new Set([1, 2]), 'Set { 1, 2 }'],\n+  [new Map([[1, 2]]), 'Map { 1 => 2 }'],\n+  [new Uint8Array(2), 'Uint8Array [ 0, 0 ]'],\n+  // It seems like the following can not be fully restored :(\n+  [new Set([1, 2]).entries(), 'Object [Set Iterator] {}'],\n+  [new Map([[1, 2]]).keys(), 'Object [Map Iterator] {}'],\n+].forEach(([value, expected]) => {\n+  // \"Remove the Symbol.iterator\"\n+  Object.defineProperty(value, Symbol.iterator, {\n+    value: false\n+  });\n+  assert.strictEqual(util.inspect(value), expected);\n+});\n+\n+// Verify the output in case the value has no prototype.\n+// Sadly, these cases can not be fully inspected :(\n+[\n+  [/a/, '/undefined/undefined'],\n+  [new DataView(new ArrayBuffer(2)),\n+   'DataView {\\n  byteLength: undefined,\\n  byteOffset: undefined,\\n  ' +\n+     'buffer: undefined }'],\n+  [new SharedArrayBuffer(2), 'SharedArrayBuffer { byteLength: undefined }']\n+].forEach(([value, expected]) => {\n+  assert.strictEqual(\n+    util.inspect(Object.setPrototypeOf(value, null)),\n+    expected\n+  );\n+});\n+\n+// Verify that throwing in valueOf and having no prototype still produces nice\n+// results.\n+[\n+  [new String(55), \"[String: '55']\"],\n+  [new Boolean(true), '[Boolean: true]'],\n+  [new Number(55), '[Number: 55]'],\n+  [Object(BigInt(55)), '[BigInt: 55n]'],\n+  [Object(Symbol('foo')), '[Symbol: Symbol(foo)]'],\n+  [function() {}, '[Function]'],\n+  [() => {}, '[Function]'],\n+  [[1, 2], '[ 1, 2 ]'],\n+  [[, , 5, , , , ], '[ <2 empty items>, 5, <3 empty items> ]'],\n+  [{ a: 5 }, '{ a: 5 }'],\n+  [new Set([1, 2]), 'Set { 1, 2 }'],\n+  [new Map([[1, 2]]), 'Map { 1 => 2 }'],\n+  [new Set([1, 2]).entries(), '[Set Iterator] { 1, 2 }'],\n+  [new Map([[1, 2]]).keys(), '[Map Iterator] { 1 }'],\n+  [new Date(2000), '1970-01-01T00:00:02.000Z'],\n+  [new Uint8Array(2), 'Uint8Array [ 0, 0 ]'],\n+  [new Promise((resolve) => setTimeout(resolve, 10)), 'Promise { <pending> }'],\n+  [new WeakSet(), 'WeakSet { <items unknown> }'],\n+  [new WeakMap(), 'WeakMap { <items unknown> }'],\n+].forEach(([value, expected]) => {\n+  Object.defineProperty(value, 'valueOf', {\n+    get() {\n+      throw new Error('valueOf');\n+    }\n+  });\n+  Object.defineProperty(value, 'toString', {\n+    get() {\n+      throw new Error('toString');\n+    }\n+  });\n+  assert.strictEqual(util.inspect(value), expected);\n+  assert.strictEqual(\n+    util.inspect(Object.setPrototypeOf(value, null)),\n+    expected\n+  );\n+  value.foo = 'bar';\n+  assert.notStrictEqual(util.inspect(value), expected);\n+});"
        }
    ],
    "stats": {
        "total": 323,
        "additions": 243,
        "deletions": 80
    }
}