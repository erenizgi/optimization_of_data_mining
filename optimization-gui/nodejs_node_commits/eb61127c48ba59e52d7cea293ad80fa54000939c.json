{
    "author": "BridgeAR",
    "message": "util: limit inspection output size to 128 MB\n\nThe maximum hard limit that `util.inspect()` could theoretically handle\nis the maximum string size. That is ~2 ** 28 on 32 bit systems and\n~2 ** 30 on 64 bit systems.\n\nDue to the recursive algorithm a complex object could easily exceed\nthat limit without throwing an error right away and therefore\ncrashing the application by exceeding the heap limit.\n\n`util.inspect()` is fast enough to compute 128 MB of data below one\nsecond on an Intel(R) Core(TM) i7-5600U CPU. This hard limit allows\nto inspect arbitrary big objects from now on without crashing the\napplication or blocking the event loop significantly.\n\nPR-URL: https://github.com/nodejs/node/pull/22756\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: John-David Dalton <john.david.dalton@gmail.com>",
    "sha": "eb61127c48ba59e52d7cea293ad80fa54000939c",
    "files": [
        {
            "sha": "d67f46c043e006e577cb5724f9ec07550499a967",
            "filename": "doc/api/util.md",
            "status": "modified",
            "additions": 10,
            "deletions": 5,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/eb61127c48ba59e52d7cea293ad80fa54000939c/doc%2Fapi%2Futil.md",
            "raw_url": "https://github.com/nodejs/node/raw/eb61127c48ba59e52d7cea293ad80fa54000939c/doc%2Fapi%2Futil.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Futil.md?ref=eb61127c48ba59e52d7cea293ad80fa54000939c",
            "patch": "@@ -360,6 +360,10 @@ stream.write('With ES6');\n <!-- YAML\n added: v0.3.0\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/22756\n+    description: The inspection output is now limited to about 128 MB. Data\n+                 above that size will not be fully inspected.\n   - version: v10.6.0\n     pr-url: https://github.com/nodejs/node/pull/20725\n     description: Inspecting linked lists and similar objects is now possible\n@@ -408,11 +412,11 @@ changes:\n     TODO(BridgeAR): Deprecate `maxArrayLength` and replace it with\n                     `maxEntries`.\n     -->\n-  * `maxArrayLength` {number} Specifies the maximum number of `Array`,\n+  * `maxArrayLength` {integer} Specifies the maximum number of `Array`,\n     [`TypedArray`][], [`WeakMap`][] and [`WeakSet`][] elements to include when\n     formatting. Set to `null` or `Infinity` to show all elements. Set to `0` or\n     negative to show no elements. **Default:** `100`.\n-  * `breakLength` {number} The length at which an object's keys are split\n+  * `breakLength` {integer} The length at which an object's keys are split\n     across multiple lines. Set to `Infinity` to format an object as a single\n     line. **Default:** `60` for legacy compatibility.\n   * `compact` {boolean} Setting this to `false` changes the default indentation\n@@ -532,9 +536,10 @@ console.log(inspect(weakSet, { showHidden: true }));\n ```\n \n Please note that `util.inspect()` is a synchronous method that is mainly\n-intended as a debugging tool. Some input values can have a significant\n-performance overhead that can block the event loop. Use this function\n-with care and never in a hot code path.\n+intended as a debugging tool. Its maximum output length is limited to\n+approximately 128 MB and input values that result in output bigger than that\n+will not be inspected fully. Such values can have a significant performance\n+overhead that can block the event loop for a significant amount of time.\n \n ### Customizing `util.inspect` colors\n "
        },
        {
            "sha": "985f455e5dc455b26ebf91bdb38adc317e8079ef",
            "filename": "lib/util.js",
            "status": "modified",
            "additions": 46,
            "deletions": 23,
            "changes": 69,
            "blob_url": "https://github.com/nodejs/node/blob/eb61127c48ba59e52d7cea293ad80fa54000939c/lib%2Futil.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb61127c48ba59e52d7cea293ad80fa54000939c/lib%2Futil.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Futil.js?ref=eb61127c48ba59e52d7cea293ad80fa54000939c",
            "patch": "@@ -406,24 +406,27 @@ function inspect(value, opts) {\n     maxArrayLength: inspectDefaultOptions.maxArrayLength,\n     breakLength: inspectDefaultOptions.breakLength,\n     indentationLvl: 0,\n-    compact: inspectDefaultOptions.compact\n+    compact: inspectDefaultOptions.compact,\n+    budget: {}\n   };\n-  // Legacy...\n-  if (arguments.length > 2) {\n-    if (arguments[2] !== undefined) {\n-      ctx.depth = arguments[2];\n-    }\n-    if (arguments.length > 3 && arguments[3] !== undefined) {\n-      ctx.colors = arguments[3];\n+  if (arguments.length > 1) {\n+    // Legacy...\n+    if (arguments.length > 2) {\n+      if (arguments[2] !== undefined) {\n+        ctx.depth = arguments[2];\n+      }\n+      if (arguments.length > 3 && arguments[3] !== undefined) {\n+        ctx.colors = arguments[3];\n+      }\n     }\n-  }\n-  // Set user-specified options\n-  if (typeof opts === 'boolean') {\n-    ctx.showHidden = opts;\n-  } else if (opts) {\n-    const optKeys = Object.keys(opts);\n-    for (var i = 0; i < optKeys.length; i++) {\n-      ctx[optKeys[i]] = opts[optKeys[i]];\n+    // Set user-specified options\n+    if (typeof opts === 'boolean') {\n+      ctx.showHidden = opts;\n+    } else if (opts) {\n+      const optKeys = Object.keys(opts);\n+      for (var i = 0; i < optKeys.length; i++) {\n+        ctx[optKeys[i]] = opts[optKeys[i]];\n+      }\n     }\n   }\n   if (ctx.colors) ctx.stylize = stylizeWithColor;\n@@ -623,14 +626,19 @@ function noPrototypeIterator(ctx, value, recurseTimes) {\n // corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n // value afterwards again.\n function formatValue(ctx, value, recurseTimes) {\n-  // Primitive types cannot have properties\n+  // Primitive types cannot have properties.\n   if (typeof value !== 'object' && typeof value !== 'function') {\n     return formatPrimitive(ctx.stylize, value, ctx);\n   }\n   if (value === null) {\n     return ctx.stylize('null', 'null');\n   }\n \n+  if (ctx.stop !== undefined) {\n+    const name = getConstructorName(value) || value[Symbol.toStringTag];\n+    return ctx.stylize(`[${name || 'Object'}]`, 'special');\n+  }\n+\n   if (ctx.showProxy) {\n     const proxy = getProxyDetails(value);\n     if (proxy !== undefined) {\n@@ -639,11 +647,11 @@ function formatValue(ctx, value, recurseTimes) {\n   }\n \n   // Provide a hook for user-specified inspect functions.\n-  // Check that value is an object with an inspect function on it\n+  // Check that value is an object with an inspect function on it.\n   if (ctx.customInspect) {\n     const maybeCustom = value[customInspectSymbol];\n     if (typeof maybeCustom === 'function' &&\n-        // Filter out the util module, its inspect function is special\n+        // Filter out the util module, its inspect function is special.\n         maybeCustom !== exports.inspect &&\n         // Also filter out any prototype objects using the circular check.\n         !(value.constructor && value.constructor.prototype === value)) {\n@@ -685,7 +693,7 @@ function formatRaw(ctx, value, recurseTimes) {\n \n   let extrasType = kObjectType;\n \n-  // Iterators and the rest are split to reduce checks\n+  // Iterators and the rest are split to reduce checks.\n   if (value[Symbol.iterator]) {\n     noIterator = false;\n     if (Array.isArray(value)) {\n@@ -766,7 +774,7 @@ function formatRaw(ctx, value, recurseTimes) {\n       }\n       base = dateToISOString(value);\n     } else if (isError(value)) {\n-      // Make error with message first say the error\n+      // Make error with message first say the error.\n       base = formatError(value);\n       // Wrap the error in brackets in case it has no stack trace.\n       const stackStart = base.indexOf('\\n    at');\n@@ -885,7 +893,21 @@ function formatRaw(ctx, value, recurseTimes) {\n   }\n   ctx.seen.pop();\n \n-  return reduceToSingleString(ctx, output, base, braces);\n+  const res = reduceToSingleString(ctx, output, base, braces);\n+  const budget = ctx.budget[ctx.indentationLvl] || 0;\n+  const newLength = budget + res.length;\n+  ctx.budget[ctx.indentationLvl] = newLength;\n+  // If any indentationLvl exceeds this limit, limit further inspecting to the\n+  // minimum. Otherwise the recursive algorithm might continue inspecting the\n+  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n+  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n+  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n+  // This limit also makes sure that huge objects don't block the event loop\n+  // significantly.\n+  if (newLength > 2 ** 27) {\n+    ctx.stop = true;\n+  }\n+  return res;\n }\n \n function handleMaxCallStackSize(ctx, err, constructor, tag) {\n@@ -1057,8 +1079,9 @@ function formatTypedArray(ctx, value, recurseTimes) {\n     formatBigInt;\n   for (var i = 0; i < maxLength; ++i)\n     output[i] = elementFormatter(ctx.stylize, value[i]);\n-  if (remaining > 0)\n+  if (remaining > 0) {\n     output[i] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n+  }\n   if (ctx.showHidden) {\n     // .buffer goes last, it's not a primitive like the others.\n     ctx.indentationLvl += 2;"
        },
        {
            "sha": "167f72ba64631a6e8549ce28e3d83864055f55b6",
            "filename": "test/parallel/test-util-inspect-long-running.js",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/eb61127c48ba59e52d7cea293ad80fa54000939c/test%2Fparallel%2Ftest-util-inspect-long-running.js",
            "raw_url": "https://github.com/nodejs/node/raw/eb61127c48ba59e52d7cea293ad80fa54000939c/test%2Fparallel%2Ftest-util-inspect-long-running.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-util-inspect-long-running.js?ref=eb61127c48ba59e52d7cea293ad80fa54000939c",
            "patch": "@@ -0,0 +1,20 @@\n+'use strict';\n+\n+require('../common');\n+\n+// Test that huge objects don't crash due to exceeding the maximum heap size.\n+\n+const util = require('util');\n+\n+// Create a difficult to stringify object. Without the artificial limitation\n+// this would crash or throw an maximum string size error.\n+let last = {};\n+const obj = last;\n+\n+for (let i = 0; i < 1000; i++) {\n+  last.next = { circular: obj, last, obj: { a: 1, b: 2, c: true } };\n+  last = last.next;\n+  obj[i] = last;\n+}\n+\n+util.inspect(obj, { depth: Infinity });"
        }
    ],
    "stats": {
        "total": 104,
        "additions": 76,
        "deletions": 28
    }
}