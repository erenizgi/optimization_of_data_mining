{
    "author": "addaleax",
    "message": "worker: enable stdio\n\nProvide `stdin`, `stdout` and `stderr` options for the `Worker`\nconstructor, and make these available to the worker thread\nunder their usual names.\n\nThe default for `stdin` is an empty stream, the default for\n`stdout` and `stderr` is redirecting to the parent threadâ€™s\ncorresponding stdio streams.\n\nPR-URL: https://github.com/nodejs/node/pull/20876\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Shingo Inoue <leko.noor@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: John-David Dalton <john.david.dalton@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>",
    "sha": "ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db",
    "files": [
        {
            "sha": "2fa55cfa2ddadff3e19b65c0d4707f331791c3c9",
            "filename": "doc/api/worker.md",
            "status": "modified",
            "additions": 43,
            "deletions": 1,
            "changes": 44,
            "blob_url": "https://github.com/nodejs/node/blob/ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db/doc%2Fapi%2Fworker.md",
            "raw_url": "https://github.com/nodejs/node/raw/ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db/doc%2Fapi%2Fworker.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fworker.md?ref=ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db",
            "patch": "@@ -240,7 +240,7 @@ Most Node.js APIs are available inside of it.\n Notable differences inside a Worker environment are:\n \n - The [`process.stdin`][], [`process.stdout`][] and [`process.stderr`][]\n-  properties are set to `null`.\n+  may be redirected by the parent thread.\n - The [`require('worker').isMainThread`][] property is set to `false`.\n - The [`require('worker').parentPort`][] message port is available,\n - [`process.exit()`][] does not stop the whole program, just the single thread,\n@@ -313,6 +313,13 @@ if (isMainThread) {\n     described in the [HTML structured clone algorithm][], and an error will be\n     thrown if the object cannot be cloned (e.g. because it contains\n     `function`s).\n+  * stdin {boolean} If this is set to `true`, then `worker.stdin` will\n+    provide a writable stream whose contents will appear as `process.stdin`\n+    inside the Worker. By default, no data is provided.\n+  * stdout {boolean} If this is set to `true`, then `worker.stdout` will\n+    not automatically be piped through to `process.stdout` in the parent.\n+  * stderr {boolean} If this is set to `true`, then `worker.stderr` will\n+    not automatically be piped through to `process.stderr` in the parent.\n \n ### Event: 'error'\n <!-- YAML\n@@ -377,6 +384,41 @@ Opposite of `unref()`, calling `ref()` on a previously `unref()`ed worker will\n behavior). If the worker is `ref()`ed, calling `ref()` again will have\n no effect.\n \n+### worker.stderr\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {stream.Readable}\n+\n+This is a readable stream which contains data written to [`process.stderr`][]\n+inside the worker thread. If `stderr: true` was not passed to the\n+[`Worker`][] constructor, then data will be piped to the parent thread's\n+[`process.stderr`][] stream.\n+\n+### worker.stdin\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {null|stream.Writable}\n+\n+If `stdin: true` was passed to the [`Worker`][] constructor, this is a\n+writable stream. The data written to this stream will be made available in\n+the worker thread as [`process.stdin`][].\n+\n+### worker.stdout\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* {stream.Readable}\n+\n+This is a readable stream which contains data written to [`process.stdout`][]\n+inside the worker thread. If `stdout: true` was not passed to the\n+[`Worker`][] constructor, then data will be piped to the parent thread's\n+[`process.stdout`][] stream.\n+\n ### worker.terminate([callback])\n <!-- YAML\n added: REPLACEME"
        },
        {
            "sha": "e5bb50e8ed81de73841a0fa663b907002717747f",
            "filename": "lib/internal/process/stdio.js",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db/lib%2Finternal%2Fprocess%2Fstdio.js",
            "raw_url": "https://github.com/nodejs/node/raw/ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db/lib%2Finternal%2Fprocess%2Fstdio.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fprocess%2Fstdio.js?ref=ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db",
            "patch": "@@ -6,7 +6,10 @@ const {\n   ERR_UNKNOWN_STDIN_TYPE,\n   ERR_UNKNOWN_STREAM_TYPE\n } = require('internal/errors').codes;\n-const { isMainThread } = require('internal/worker');\n+const {\n+  isMainThread,\n+  workerStdio\n+} = require('internal/worker');\n \n exports.setup = setupStdio;\n \n@@ -17,8 +20,7 @@ function setupStdio() {\n \n   function getStdout() {\n     if (stdout) return stdout;\n-    if (!isMainThread)\n-      return new (require('stream').Writable)({ write(b, e, cb) { cb(); } });\n+    if (!isMainThread) return workerStdio.stdout;\n     stdout = createWritableStdioStream(1);\n     stdout.destroySoon = stdout.destroy;\n     stdout._destroy = function(er, cb) {\n@@ -34,8 +36,7 @@ function setupStdio() {\n \n   function getStderr() {\n     if (stderr) return stderr;\n-    if (!isMainThread)\n-      return new (require('stream').Writable)({ write(b, e, cb) { cb(); } });\n+    if (!isMainThread) return workerStdio.stderr;\n     stderr = createWritableStdioStream(2);\n     stderr.destroySoon = stderr.destroy;\n     stderr._destroy = function(er, cb) {\n@@ -51,8 +52,7 @@ function setupStdio() {\n \n   function getStdin() {\n     if (stdin) return stdin;\n-    if (!isMainThread)\n-      return new (require('stream').Readable)({ read() { this.push(null); } });\n+    if (!isMainThread) return workerStdio.stdin;\n \n     const tty_wrap = process.binding('tty_wrap');\n     const fd = 0;"
        },
        {
            "sha": "5bd4c215e0403e2c6d1bf1cea7aab8c8f35aaeb3",
            "filename": "lib/internal/worker.js",
            "status": "modified",
            "additions": 163,
            "deletions": 3,
            "changes": 166,
            "blob_url": "https://github.com/nodejs/node/blob/ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db/lib%2Finternal%2Fworker.js",
            "raw_url": "https://github.com/nodejs/node/raw/ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db/lib%2Finternal%2Fworker.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fworker.js?ref=ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db",
            "patch": "@@ -5,6 +5,7 @@ const EventEmitter = require('events');\n const assert = require('assert');\n const path = require('path');\n const util = require('util');\n+const { Readable, Writable } = require('stream');\n const {\n   ERR_INVALID_ARG_TYPE,\n   ERR_WORKER_NEED_ABSOLUTE_PATH,\n@@ -29,13 +30,20 @@ const isMainThread = threadId === 0;\n \n const kOnMessageListener = Symbol('kOnMessageListener');\n const kHandle = Symbol('kHandle');\n+const kName = Symbol('kName');\n const kPort = Symbol('kPort');\n const kPublicPort = Symbol('kPublicPort');\n const kDispose = Symbol('kDispose');\n const kOnExit = Symbol('kOnExit');\n const kOnMessage = Symbol('kOnMessage');\n const kOnCouldNotSerializeErr = Symbol('kOnCouldNotSerializeErr');\n const kOnErrorMessage = Symbol('kOnErrorMessage');\n+const kParentSideStdio = Symbol('kParentSideStdio');\n+const kWritableCallbacks = Symbol('kWritableCallbacks');\n+const kStdioWantsMoreDataCallback = Symbol('kStdioWantsMoreDataCallback');\n+const kStartedReading = Symbol('kStartedReading');\n+const kWaitingStreams = Symbol('kWaitingStreams');\n+const kIncrementsPortRef = Symbol('kIncrementsPortRef');\n \n const debug = util.debuglog('worker');\n \n@@ -129,6 +137,72 @@ function setupPortReferencing(port, eventEmitter, eventName) {\n }\n \n \n+class ReadableWorkerStdio extends Readable {\n+  constructor(port, name) {\n+    super();\n+    this[kPort] = port;\n+    this[kName] = name;\n+    this[kIncrementsPortRef] = true;\n+    this[kStartedReading] = false;\n+    this.on('end', () => {\n+      if (this[kIncrementsPortRef] && --this[kPort][kWaitingStreams] === 0)\n+        this[kPort].unref();\n+    });\n+  }\n+\n+  _read() {\n+    if (!this[kStartedReading] && this[kIncrementsPortRef]) {\n+      this[kStartedReading] = true;\n+      if (this[kPort][kWaitingStreams]++ === 0)\n+        this[kPort].ref();\n+    }\n+\n+    this[kPort].postMessage({\n+      type: 'stdioWantsMoreData',\n+      stream: this[kName]\n+    });\n+  }\n+}\n+\n+class WritableWorkerStdio extends Writable {\n+  constructor(port, name) {\n+    super({ decodeStrings: false });\n+    this[kPort] = port;\n+    this[kName] = name;\n+    this[kWritableCallbacks] = [];\n+  }\n+\n+  _write(chunk, encoding, cb) {\n+    this[kPort].postMessage({\n+      type: 'stdioPayload',\n+      stream: this[kName],\n+      chunk,\n+      encoding\n+    });\n+    this[kWritableCallbacks].push(cb);\n+    if (this[kPort][kWaitingStreams]++ === 0)\n+      this[kPort].ref();\n+  }\n+\n+  _final(cb) {\n+    this[kPort].postMessage({\n+      type: 'stdioPayload',\n+      stream: this[kName],\n+      chunk: null\n+    });\n+    cb();\n+  }\n+\n+  [kStdioWantsMoreDataCallback]() {\n+    const cbs = this[kWritableCallbacks];\n+    this[kWritableCallbacks] = [];\n+    for (const cb of cbs)\n+      cb();\n+    if ((this[kPort][kWaitingStreams] -= cbs.length) === 0)\n+      this[kPort].unref();\n+  }\n+}\n+\n class Worker extends EventEmitter {\n   constructor(filename, options = {}) {\n     super();\n@@ -154,8 +228,25 @@ class Worker extends EventEmitter {\n     this[kPort].on('message', (data) => this[kOnMessage](data));\n     this[kPort].start();\n     this[kPort].unref();\n+    this[kPort][kWaitingStreams] = 0;\n     debug(`[${threadId}] created Worker with ID ${this.threadId}`);\n \n+    let stdin = null;\n+    if (options.stdin)\n+      stdin = new WritableWorkerStdio(this[kPort], 'stdin');\n+    const stdout = new ReadableWorkerStdio(this[kPort], 'stdout');\n+    if (!options.stdout) {\n+      stdout[kIncrementsPortRef] = false;\n+      pipeWithoutWarning(stdout, process.stdout);\n+    }\n+    const stderr = new ReadableWorkerStdio(this[kPort], 'stderr');\n+    if (!options.stderr) {\n+      stderr[kIncrementsPortRef] = false;\n+      pipeWithoutWarning(stderr, process.stderr);\n+    }\n+\n+    this[kParentSideStdio] = { stdin, stdout, stderr };\n+\n     const { port1, port2 } = new MessageChannel();\n     this[kPublicPort] = port1;\n     this[kPublicPort].on('message', (message) => this.emit('message', message));\n@@ -165,7 +256,8 @@ class Worker extends EventEmitter {\n       filename,\n       doEval: !!options.eval,\n       workerData: options.workerData,\n-      publicPort: port2\n+      publicPort: port2,\n+      hasStdin: !!options.stdin\n     }, [port2]);\n     // Actually start the new thread now that everything is in place.\n     this[kHandle].startThread();\n@@ -197,6 +289,16 @@ class Worker extends EventEmitter {\n         return this[kOnCouldNotSerializeErr]();\n       case 'errorMessage':\n         return this[kOnErrorMessage](message.error);\n+      case 'stdioPayload':\n+      {\n+        const { stream, chunk, encoding } = message;\n+        return this[kParentSideStdio][stream].push(chunk, encoding);\n+      }\n+      case 'stdioWantsMoreData':\n+      {\n+        const { stream } = message;\n+        return this[kParentSideStdio][stream][kStdioWantsMoreDataCallback]();\n+      }\n     }\n \n     assert.fail(`Unknown worker message type ${message.type}`);\n@@ -207,6 +309,18 @@ class Worker extends EventEmitter {\n     this[kHandle] = null;\n     this[kPort] = null;\n     this[kPublicPort] = null;\n+\n+    const { stdout, stderr } = this[kParentSideStdio];\n+    this[kParentSideStdio] = null;\n+\n+    if (!stdout._readableState.ended) {\n+      debug(`[${threadId}] explicitly closes stdout for ${this.threadId}`);\n+      stdout.push(null);\n+    }\n+    if (!stderr._readableState.ended) {\n+      debug(`[${threadId}] explicitly closes stderr for ${this.threadId}`);\n+      stderr.push(null);\n+    }\n   }\n \n   postMessage(...args) {\n@@ -243,6 +357,27 @@ class Worker extends EventEmitter {\n \n     return this[kHandle].threadId;\n   }\n+\n+  get stdin() {\n+    return this[kParentSideStdio].stdin;\n+  }\n+\n+  get stdout() {\n+    return this[kParentSideStdio].stdout;\n+  }\n+\n+  get stderr() {\n+    return this[kParentSideStdio].stderr;\n+  }\n+}\n+\n+const workerStdio = {};\n+if (!isMainThread) {\n+  const port = getEnvMessagePort();\n+  port[kWaitingStreams] = 0;\n+  workerStdio.stdin = new ReadableWorkerStdio(port, 'stdin');\n+  workerStdio.stdout = new WritableWorkerStdio(port, 'stdout');\n+  workerStdio.stderr = new WritableWorkerStdio(port, 'stderr');\n }\n \n let originalFatalException;\n@@ -256,10 +391,14 @@ function setupChild(evalScript) {\n \n   port.on('message', (message) => {\n     if (message.type === 'loadScript') {\n-      const { filename, doEval, workerData, publicPort } = message;\n+      const { filename, doEval, workerData, publicPort, hasStdin } = message;\n       publicWorker.parentPort = publicPort;\n       setupPortReferencing(publicPort, publicPort, 'message');\n       publicWorker.workerData = workerData;\n+\n+      if (!hasStdin)\n+        workerStdio.stdin.push(null);\n+\n       debug(`[${threadId}] starts worker script ${filename} ` +\n             `(eval = ${eval}) at cwd = ${process.cwd()}`);\n       port.unref();\n@@ -271,6 +410,14 @@ function setupChild(evalScript) {\n         require('module').runMain();\n       }\n       return;\n+    } else if (message.type === 'stdioPayload') {\n+      const { stream, chunk, encoding } = message;\n+      workerStdio[stream].push(chunk, encoding);\n+      return;\n+    } else if (message.type === 'stdioWantsMoreData') {\n+      const { stream } = message;\n+      workerStdio[stream][kStdioWantsMoreDataCallback]();\n+      return;\n     }\n \n     assert.fail(`Unknown worker message type ${message.type}`);\n@@ -317,11 +464,24 @@ function deserializeError(error) {\n                      error.byteLength).toString('utf8');\n }\n \n+function pipeWithoutWarning(source, dest) {\n+  const sourceMaxListeners = source._maxListeners;\n+  const destMaxListeners = dest._maxListeners;\n+  source.setMaxListeners(Infinity);\n+  dest.setMaxListeners(Infinity);\n+\n+  source.pipe(dest);\n+\n+  source._maxListeners = sourceMaxListeners;\n+  dest._maxListeners = destMaxListeners;\n+}\n+\n module.exports = {\n   MessagePort,\n   MessageChannel,\n   threadId,\n   Worker,\n   setupChild,\n-  isMainThread\n+  isMainThread,\n+  workerStdio\n };"
        },
        {
            "sha": "660a6d3a4ac28dc6a264d12bb019cccd4aa0b487",
            "filename": "test/parallel/test-worker-stdio.js",
            "status": "added",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db/test%2Fparallel%2Ftest-worker-stdio.js",
            "raw_url": "https://github.com/nodejs/node/raw/ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db/test%2Fparallel%2Ftest-worker-stdio.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-worker-stdio.js?ref=ddefa0f2c58450a1fa6cb7cd3b38ba02e733d4db",
            "patch": "@@ -0,0 +1,43 @@\n+// Flags: --experimental-worker\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const fs = require('fs');\n+const util = require('util');\n+const { Writable } = require('stream');\n+const { Worker, isMainThread } = require('worker');\n+\n+class BufferingWritable extends Writable {\n+  constructor() {\n+    super();\n+    this.chunks = [];\n+  }\n+\n+  _write(chunk, enc, cb) {\n+    this.chunks.push(chunk);\n+    cb();\n+  }\n+\n+  get buffer() {\n+    return Buffer.concat(this.chunks);\n+  }\n+}\n+\n+if (isMainThread) {\n+  const original = new BufferingWritable();\n+  const passed = new BufferingWritable();\n+\n+  const w = new Worker(__filename, { stdin: true, stdout: true });\n+  const source = fs.createReadStream(process.execPath);\n+  source.pipe(w.stdin);\n+  source.pipe(original);\n+  w.stdout.pipe(passed);\n+\n+  passed.on('finish', common.mustCall(() => {\n+    assert.strictEqual(original.buffer.compare(passed.buffer), 0,\n+                       `Original: ${util.inspect(original.buffer)}, ` +\n+                       `Actual: ${util.inspect(passed.buffer)}`);\n+  }));\n+} else {\n+  process.stdin.pipe(process.stdout);\n+}"
        }
    ],
    "stats": {
        "total": 267,
        "additions": 256,
        "deletions": 11
    }
}