{
    "author": "targos",
    "message": "module: move options checks from C++ to JS\n\nPR-URL: https://github.com/nodejs/node/pull/19822\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Guy Bedford <guybedford@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "77b52fd58f7398a81999c81afd21fe2e156c0766",
    "files": [
        {
            "sha": "e0c97263631432f487a5ca9fdca94df5dbeddd9e",
            "filename": "lib/internal/modules/esm/create_dynamic_module.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/77b52fd58f7398a81999c81afd21fe2e156c0766/lib%2Finternal%2Fmodules%2Fesm%2Fcreate_dynamic_module.js",
            "raw_url": "https://github.com/nodejs/node/raw/77b52fd58f7398a81999c81afd21fe2e156c0766/lib%2Finternal%2Fmodules%2Fesm%2Fcreate_dynamic_module.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fmodules%2Fesm%2Fcreate_dynamic_module.js?ref=77b52fd58f7398a81999c81afd21fe2e156c0766",
            "patch": "@@ -32,7 +32,7 @@ const createDynamicModule = (exports, url = '', evaluate) => {\n   }));`;\n   const reflectiveModule = new ModuleWrap(src, `cjs-facade:${url}`);\n   reflectiveModule.instantiate();\n-  const { setExecutor, reflect } = reflectiveModule.evaluate()();\n+  const { setExecutor, reflect } = reflectiveModule.evaluate(-1, false)();\n   // public exposed ESM\n   const reexports = `\n   import {"
        },
        {
            "sha": "8dbeef78e63a1dd5e7bb7b294dbea4099aeb4e04",
            "filename": "lib/internal/modules/esm/module_job.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/77b52fd58f7398a81999c81afd21fe2e156c0766/lib%2Finternal%2Fmodules%2Fesm%2Fmodule_job.js",
            "raw_url": "https://github.com/nodejs/node/raw/77b52fd58f7398a81999c81afd21fe2e156c0766/lib%2Finternal%2Fmodules%2Fesm%2Fmodule_job.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fmodules%2Fesm%2Fmodule_job.js?ref=77b52fd58f7398a81999c81afd21fe2e156c0766",
            "patch": "@@ -103,7 +103,7 @@ class ModuleJob {\n   async run() {\n     const module = await this.instantiate();\n     try {\n-      module.evaluate();\n+      module.evaluate(-1, false);\n     } catch (e) {\n       e.stack;\n       this.hadError = true;"
        },
        {
            "sha": "7284c8bd619901938e6814592bbb826c157399f7",
            "filename": "lib/internal/vm/module.js",
            "status": "modified",
            "additions": 54,
            "deletions": 26,
            "changes": 80,
            "blob_url": "https://github.com/nodejs/node/blob/77b52fd58f7398a81999c81afd21fe2e156c0766/lib%2Finternal%2Fvm%2Fmodule.js",
            "raw_url": "https://github.com/nodejs/node/raw/77b52fd58f7398a81999c81afd21fe2e156c0766/lib%2Finternal%2Fvm%2Fmodule.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fvm%2Fmodule.js?ref=77b52fd58f7398a81999c81afd21fe2e156c0766",
            "patch": "@@ -3,9 +3,10 @@\n const { internalBinding } = require('internal/bootstrap/loaders');\n const { emitExperimentalWarning } = require('internal/util');\n const { URL } = require('internal/url');\n-const { kParsingContext, isContext } = process.binding('contextify');\n+const { isContext } = process.binding('contextify');\n const {\n   ERR_INVALID_ARG_TYPE,\n+  ERR_OUT_OF_RANGE,\n   ERR_VM_MODULE_ALREADY_LINKED,\n   ERR_VM_MODULE_DIFFERENT_CONTEXT,\n   ERR_VM_MODULE_LINKING_ERRORED,\n@@ -55,23 +56,26 @@ class Module {\n     if (typeof src !== 'string')\n       throw new ERR_INVALID_ARG_TYPE('src', 'string', src);\n     if (typeof options !== 'object' || options === null)\n-      throw new ERR_INVALID_ARG_TYPE('options', 'object', options);\n+      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n \n-    let context;\n-    if (options.context !== undefined) {\n-      if (typeof options.context !== 'object' || options.context === null) {\n-        throw new ERR_INVALID_ARG_TYPE('options.context', 'object',\n-                                       options.context);\n+    const {\n+      context,\n+      lineOffset = 0,\n+      columnOffset = 0,\n+      initializeImportMeta\n+    } = options;\n+\n+    if (context !== undefined) {\n+      if (typeof context !== 'object' || context === null) {\n+        throw new ERR_INVALID_ARG_TYPE('options.context', 'Object', context);\n       }\n-      if (isContext(options.context)) {\n-        context = options.context;\n-      } else {\n-        throw new ERR_INVALID_ARG_TYPE('options.context',\n-                                       'vm.Context', options.context);\n+      if (!isContext(context)) {\n+        throw new ERR_INVALID_ARG_TYPE('options.context', 'vm.Context',\n+                                       context);\n       }\n     }\n \n-    let url = options.url;\n+    let { url } = options;\n     if (url !== undefined) {\n       if (typeof url !== 'string') {\n         throw new ERR_INVALID_ARG_TYPE('options.url', 'string', url);\n@@ -88,22 +92,19 @@ class Module {\n       perContextModuleId.set(context, 1);\n     }\n \n-    if (options.initializeImportMeta !== undefined) {\n-      if (typeof options.initializeImportMeta === 'function') {\n-        initImportMetaMap.set(this, options.initializeImportMeta);\n+    validateInteger(lineOffset, 'options.lineOffset');\n+    validateInteger(columnOffset, 'options.columnOffset');\n+\n+    if (initializeImportMeta !== undefined) {\n+      if (typeof initializeImportMeta === 'function') {\n+        initImportMetaMap.set(this, initializeImportMeta);\n       } else {\n         throw new ERR_INVALID_ARG_TYPE(\n-          'options.initializeImportMeta', 'function',\n-          options.initializeImportMeta);\n+          'options.initializeImportMeta', 'function', initializeImportMeta);\n       }\n     }\n \n-    const wrap = new ModuleWrap(src, url, {\n-      [kParsingContext]: context,\n-      lineOffset: options.lineOffset,\n-      columnOffset: options.columnOffset\n-    });\n-\n+    const wrap = new ModuleWrap(src, url, context, lineOffset, columnOffset);\n     wrapMap.set(this, wrap);\n     linkingStatusMap.set(this, 'unlinked');\n     wrapToModuleMap.set(wrap, this);\n@@ -194,7 +195,25 @@ class Module {\n     wrap.instantiate();\n   }\n \n-  async evaluate(options) {\n+  async evaluate(options = {}) {\n+    if (typeof options !== 'object' || options === null) {\n+      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n+    }\n+\n+    let timeout = options.timeout;\n+    if (timeout === undefined) {\n+      timeout = -1;\n+    } else if (!Number.isInteger(timeout) || timeout <= 0) {\n+      throw new ERR_INVALID_ARG_TYPE('options.timeout', 'a positive integer',\n+                                     timeout);\n+    }\n+\n+    const { breakOnSigint = false } = options;\n+    if (typeof breakOnSigint !== 'boolean') {\n+      throw new ERR_INVALID_ARG_TYPE('options.breakOnSigint', 'boolean',\n+                                     breakOnSigint);\n+    }\n+\n     const wrap = wrapMap.get(this);\n     const status = wrap.getStatus();\n     if (status !== kInstantiated &&\n@@ -204,7 +223,7 @@ class Module {\n         'must be one of instantiated, evaluated, and errored'\n       );\n     }\n-    const result = wrap.evaluate(options);\n+    const result = wrap.evaluate(timeout, breakOnSigint);\n     return { result, __proto__: null };\n   }\n \n@@ -224,6 +243,15 @@ class Module {\n   }\n }\n \n+function validateInteger(prop, propName) {\n+  if (!Number.isInteger(prop)) {\n+    throw new ERR_INVALID_ARG_TYPE(propName, 'integer', prop);\n+  }\n+  if ((prop >> 0) !== prop) {\n+    throw new ERR_OUT_OF_RANGE(propName, '32-bit integer', prop);\n+  }\n+}\n+\n module.exports = {\n   Module,\n   initImportMetaMap,"
        },
        {
            "sha": "7bf7b9dd08c0625a9d4a65831d41ecbd983d1a53",
            "filename": "src/module_wrap.cc",
            "status": "modified",
            "additions": 57,
            "deletions": 73,
            "changes": 130,
            "blob_url": "https://github.com/nodejs/node/blob/77b52fd58f7398a81999c81afd21fe2e156c0766/src%2Fmodule_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/77b52fd58f7398a81999c81afd21fe2e156c0766/src%2Fmodule_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fmodule_wrap.cc?ref=77b52fd58f7398a81999c81afd21fe2e156c0766",
            "patch": "@@ -13,6 +13,7 @@\n namespace node {\n namespace loader {\n \n+using node::contextify::ContextifyContext;\n using node::url::URL;\n using node::url::URL_FLAGS_FAILED;\n using v8::Array;\n@@ -77,54 +78,58 @@ ModuleWrap* ModuleWrap::GetFromModule(Environment* env,\n \n void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n+  Isolate* isolate = env->isolate();\n \n-  Isolate* isolate = args.GetIsolate();\n+  CHECK(args.IsConstructCall());\n+  Local<Object> that = args.This();\n \n-  if (!args.IsConstructCall()) {\n-    env->ThrowError(\"constructor must be called using new\");\n-    return;\n-  }\n-\n-  if (!args[0]->IsString()) {\n-    env->ThrowError(\"first argument is not a string\");\n-    return;\n-  }\n+  const int argc = args.Length();\n+  CHECK_GE(argc, 2);\n \n+  CHECK(args[0]->IsString());\n   Local<String> source_text = args[0].As<String>();\n \n-  if (!args[1]->IsString()) {\n-    env->ThrowError(\"second argument is not a string\");\n-    return;\n-  }\n-\n+  CHECK(args[1]->IsString());\n   Local<String> url = args[1].As<String>();\n \n-  Local<Object> that = args.This();\n+  Local<Context> context;\n+  Local<Integer> line_offset;\n+  Local<Integer> column_offset;\n \n-  Environment::ShouldNotAbortOnUncaughtScope no_abort_scope(env);\n-  TryCatch try_catch(isolate);\n-\n-  Local<Value> options = args[2];\n-  MaybeLocal<Integer> line_offset = contextify::GetLineOffsetArg(env, options);\n-  MaybeLocal<Integer> column_offset =\n-      contextify::GetColumnOffsetArg(env, options);\n-  MaybeLocal<Context> maybe_context = contextify::GetContextArg(env, options);\n+  if (argc == 5) {\n+    // new ModuleWrap(source, url, context?, lineOffset, columnOffset)\n+    if (args[2]->IsUndefined()) {\n+      context = that->CreationContext();\n+    } else {\n+      CHECK(args[2]->IsObject());\n+      ContextifyContext* sandbox =\n+          ContextifyContext::ContextFromContextifiedSandbox(\n+              env, args[2].As<Object>());\n+      CHECK_NE(sandbox, nullptr);\n+      context = sandbox->context();\n+    }\n \n+    CHECK(args[3]->IsNumber());\n+    line_offset = args[3].As<Integer>();\n \n-  if (try_catch.HasCaught()) {\n-    no_abort_scope.Close();\n-    try_catch.ReThrow();\n-    return;\n+    CHECK(args[4]->IsNumber());\n+    column_offset = args[4].As<Integer>();\n+  } else {\n+    // new ModuleWrap(source, url)\n+    context = that->CreationContext();\n+    line_offset = Integer::New(isolate, 0);\n+    column_offset = Integer::New(isolate, 0);\n   }\n \n-  Local<Context> context = maybe_context.FromMaybe(that->CreationContext());\n+  Environment::ShouldNotAbortOnUncaughtScope no_abort_scope(env);\n+  TryCatch try_catch(isolate);\n   Local<Module> module;\n \n   // compile\n   {\n     ScriptOrigin origin(url,\n-                        line_offset.ToLocalChecked(),         // line offset\n-                        column_offset.ToLocalChecked(),       // column offset\n+                        line_offset,                          // line offset\n+                        column_offset,                        // column offset\n                         False(isolate),                       // is cross origin\n                         Local<Integer>(),                     // script id\n                         Local<Value>(),                       // source map URL\n@@ -161,10 +166,9 @@ void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {\n void ModuleWrap::Link(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   Isolate* isolate = args.GetIsolate();\n-  if (!args[0]->IsFunction()) {\n-    env->ThrowError(\"first argument is not a function\");\n-    return;\n-  }\n+\n+  CHECK_EQ(args.Length(), 1);\n+  CHECK(args[0]->IsFunction());\n \n   Local<Object> that = args.This();\n \n@@ -239,27 +243,23 @@ void ModuleWrap::Instantiate(const FunctionCallbackInfo<Value>& args) {\n \n void ModuleWrap::Evaluate(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n-  Isolate* isolate = args.GetIsolate();\n+  Isolate* isolate = env->isolate();\n   ModuleWrap* obj;\n   ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());\n   Local<Context> context = obj->context_.Get(isolate);\n   Local<Module> module = obj->module_.Get(isolate);\n \n-  Environment::ShouldNotAbortOnUncaughtScope no_abort_scope(env);\n-  TryCatch try_catch(isolate);\n-  Maybe<int64_t> maybe_timeout =\n-    contextify::GetTimeoutArg(env, args[0]);\n-  Maybe<bool> maybe_break_on_sigint =\n-    contextify::GetBreakOnSigintArg(env, args[0]);\n+  // module.evaluate(timeout, breakOnSigint)\n+  CHECK_EQ(args.Length(), 2);\n \n-  if (try_catch.HasCaught()) {\n-    no_abort_scope.Close();\n-    try_catch.ReThrow();\n-    return;\n-  }\n+  CHECK(args[0]->IsNumber());\n+  int64_t timeout = args[0]->IntegerValue(env->context()).FromJust();\n \n-  int64_t timeout = maybe_timeout.ToChecked();\n-  bool break_on_sigint = maybe_break_on_sigint.ToChecked();\n+  CHECK(args[1]->IsBoolean());\n+  bool break_on_sigint = args[1]->IsTrue();\n+\n+  Environment::ShouldNotAbortOnUncaughtScope no_abort_scope(env);\n+  TryCatch try_catch(isolate);\n \n   bool timed_out = false;\n   bool received_signal = false;\n@@ -665,26 +665,14 @@ Maybe<URL> Resolve(Environment* env,\n void ModuleWrap::Resolve(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n-  if (args.IsConstructCall()) {\n-    env->ThrowError(\"resolve() must not be called as a constructor\");\n-    return;\n-  }\n-  if (args.Length() != 2) {\n-    env->ThrowError(\"resolve must have exactly 2 arguments (string, string)\");\n-    return;\n-  }\n+  // module.resolve(specifier, url)\n+  CHECK_EQ(args.Length(), 2);\n \n-  if (!args[0]->IsString()) {\n-    env->ThrowError(\"first argument is not a string\");\n-    return;\n-  }\n+  CHECK(args[0]->IsString());\n   Utf8Value specifier_utf8(env->isolate(), args[0]);\n   std::string specifier_std(*specifier_utf8, specifier_utf8.length());\n \n-  if (!args[1]->IsString()) {\n-    env->ThrowError(\"second argument is not a string\");\n-    return;\n-  }\n+  CHECK(args[1]->IsString());\n   Utf8Value url_utf8(env->isolate(), args[1]);\n   URL url(*url_utf8, url_utf8.length());\n \n@@ -748,11 +736,9 @@ void ModuleWrap::SetImportModuleDynamicallyCallback(\n   Isolate* iso = args.GetIsolate();\n   Environment* env = Environment::GetCurrent(args);\n   HandleScope handle_scope(iso);\n-  if (!args[0]->IsFunction()) {\n-    env->ThrowError(\"first argument is not a function\");\n-    return;\n-  }\n \n+  CHECK_EQ(args.Length(), 1);\n+  CHECK(args[0]->IsFunction());\n   Local<Function> import_callback = args[0].As<Function>();\n   env->set_host_import_module_dynamically_callback(import_callback);\n \n@@ -781,11 +767,9 @@ void ModuleWrap::SetInitializeImportMetaObjectCallback(\n     const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   Isolate* isolate = env->isolate();\n-  if (!args[0]->IsFunction()) {\n-    env->ThrowError(\"first argument is not a function\");\n-    return;\n-  }\n \n+  CHECK_EQ(args.Length(), 1);\n+  CHECK(args[0]->IsFunction());\n   Local<Function> import_meta_callback = args[0].As<Function>();\n   env->set_host_initialize_import_meta_object_callback(import_meta_callback);\n "
        },
        {
            "sha": "ce2357650187759fdd96a82c48976b9ef49f0feb",
            "filename": "src/node_contextify.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 127,
            "changes": 127,
            "blob_url": "https://github.com/nodejs/node/blob/77b52fd58f7398a81999c81afd21fe2e156c0766/src%2Fnode_contextify.cc",
            "raw_url": "https://github.com/nodejs/node/raw/77b52fd58f7398a81999c81afd21fe2e156c0766/src%2Fnode_contextify.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.cc?ref=77b52fd58f7398a81999c81afd21fe2e156c0766",
            "patch": "@@ -47,7 +47,6 @@ using v8::Maybe;\n using v8::MaybeLocal;\n using v8::Name;\n using v8::NamedPropertyHandlerConfiguration;\n-using v8::Nothing;\n using v8::Object;\n using v8::ObjectTemplate;\n using v8::PropertyAttribute;\n@@ -586,132 +585,6 @@ void ContextifyContext::IndexedPropertyDeleterCallback(\n   args.GetReturnValue().Set(false);\n }\n \n-Maybe<bool> GetBreakOnSigintArg(Environment* env,\n-                                Local<Value> options) {\n-  if (options->IsUndefined() || options->IsString()) {\n-    return Just(false);\n-  }\n-  if (!options->IsObject()) {\n-    env->ThrowTypeError(\"options must be an object\");\n-    return Nothing<bool>();\n-  }\n-\n-  Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"breakOnSigint\");\n-  MaybeLocal<Value> maybe_value =\n-      options.As<Object>()->Get(env->context(), key);\n-  if (maybe_value.IsEmpty())\n-    return Nothing<bool>();\n-\n-  Local<Value> value = maybe_value.ToLocalChecked();\n-  return Just(value->IsTrue());\n-}\n-\n-Maybe<int64_t> GetTimeoutArg(Environment* env, Local<Value> options) {\n-  if (options->IsUndefined() || options->IsString()) {\n-    return Just<int64_t>(-1);\n-  }\n-  if (!options->IsObject()) {\n-    env->ThrowTypeError(\"options must be an object\");\n-    return Nothing<int64_t>();\n-  }\n-\n-  MaybeLocal<Value> maybe_value =\n-      options.As<Object>()->Get(env->context(), env->timeout_string());\n-  if (maybe_value.IsEmpty())\n-    return Nothing<int64_t>();\n-\n-  Local<Value> value = maybe_value.ToLocalChecked();\n-  if (value->IsUndefined()) {\n-    return Just<int64_t>(-1);\n-  }\n-\n-  Maybe<int64_t> timeout = value->IntegerValue(env->context());\n-\n-  if (timeout.IsJust() && timeout.ToChecked() <= 0) {\n-    env->ThrowRangeError(\"timeout must be a positive number\");\n-    return Nothing<int64_t>();\n-  }\n-\n-  return timeout;\n-}\n-\n-MaybeLocal<Integer> GetLineOffsetArg(Environment* env,\n-                                     Local<Value> options) {\n-  Local<Integer> defaultLineOffset = Integer::New(env->isolate(), 0);\n-\n-  if (!options->IsObject()) {\n-    return defaultLineOffset;\n-  }\n-\n-  Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"lineOffset\");\n-  MaybeLocal<Value> maybe_value =\n-      options.As<Object>()->Get(env->context(), key);\n-  if (maybe_value.IsEmpty())\n-    return MaybeLocal<Integer>();\n-\n-  Local<Value> value = maybe_value.ToLocalChecked();\n-  if (value->IsUndefined())\n-    return defaultLineOffset;\n-\n-  return value->ToInteger(env->context());\n-}\n-\n-MaybeLocal<Integer> GetColumnOffsetArg(Environment* env,\n-                                       Local<Value> options) {\n-  Local<Integer> defaultColumnOffset = Integer::New(env->isolate(), 0);\n-\n-  if (!options->IsObject()) {\n-    return defaultColumnOffset;\n-  }\n-\n-  Local<String> key = FIXED_ONE_BYTE_STRING(env->isolate(), \"columnOffset\");\n-  MaybeLocal<Value> maybe_value =\n-    options.As<Object>()->Get(env->context(), key);\n-  if (maybe_value.IsEmpty())\n-    return MaybeLocal<Integer>();\n-\n-  Local<Value> value = maybe_value.ToLocalChecked();\n-  if (value->IsUndefined())\n-    return defaultColumnOffset;\n-\n-  return value->ToInteger(env->context());\n-}\n-\n-MaybeLocal<Context> GetContextArg(Environment* env,\n-                                  Local<Value> options) {\n-  if (!options->IsObject())\n-    return MaybeLocal<Context>();\n-\n-  MaybeLocal<Value> maybe_value =\n-      options.As<Object>()->Get(env->context(),\n-                                env->vm_parsing_context_symbol());\n-  Local<Value> value;\n-  if (!maybe_value.ToLocal(&value))\n-    return MaybeLocal<Context>();\n-\n-  if (!value->IsObject()) {\n-    if (!value->IsNullOrUndefined()) {\n-      env->ThrowTypeError(\n-          \"contextifiedSandbox argument must be an object.\");\n-    }\n-    return MaybeLocal<Context>();\n-  }\n-\n-  ContextifyContext* sandbox =\n-      ContextifyContext::ContextFromContextifiedSandbox(\n-          env, value.As<Object>());\n-  if (!sandbox) {\n-    env->ThrowTypeError(\n-        \"sandbox argument must have been converted to a context.\");\n-    return MaybeLocal<Context>();\n-  }\n-\n-  Local<Context> context = sandbox->context();\n-  if (context.IsEmpty())\n-    return MaybeLocal<Context>();\n-  return context;\n-}\n-\n class ContextifyScript : public BaseObject {\n  private:\n   Persistent<UnboundScript> script_;"
        },
        {
            "sha": "565b8ef856ea49aa8dcea43c194859bb758dc32a",
            "filename": "src/node_contextify.h",
            "status": "modified",
            "additions": 0,
            "deletions": 11,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/77b52fd58f7398a81999c81afd21fe2e156c0766/src%2Fnode_contextify.h",
            "raw_url": "https://github.com/nodejs/node/raw/77b52fd58f7398a81999c81afd21fe2e156c0766/src%2Fnode_contextify.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.h?ref=77b52fd58f7398a81999c81afd21fe2e156c0766",
            "patch": "@@ -98,17 +98,6 @@ class ContextifyContext {\n       const v8::PropertyCallbackInfo<v8::Boolean>& args);\n };\n \n-v8::Maybe<bool> GetBreakOnSigintArg(\n-    Environment* env, v8::Local<v8::Value> options);\n-v8::Maybe<int64_t> GetTimeoutArg(\n-    Environment* env, v8::Local<v8::Value> options);\n-v8::MaybeLocal<v8::Integer> GetLineOffsetArg(\n-    Environment* env, v8::Local<v8::Value> options);\n-v8::MaybeLocal<v8::Integer> GetColumnOffsetArg(\n-    Environment* env, v8::Local<v8::Value> options);\n-v8::MaybeLocal<v8::Context> GetContextArg(\n-    Environment* env, v8::Local<v8::Value> options);\n-\n }  // namespace contextify\n }  // namespace node\n "
        },
        {
            "sha": "bb4a648ef7f68457360a56d45fbd756710ca1743",
            "filename": "test/parallel/test-internal-module-wrap.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/77b52fd58f7398a81999c81afd21fe2e156c0766/test%2Fparallel%2Ftest-internal-module-wrap.js",
            "raw_url": "https://github.com/nodejs/node/raw/77b52fd58f7398a81999c81afd21fe2e156c0766/test%2Fparallel%2Ftest-internal-module-wrap.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-internal-module-wrap.js?ref=77b52fd58f7398a81999c81afd21fe2e156c0766",
            "patch": "@@ -24,6 +24,6 @@ const bar = new ModuleWrap('export const five = 5', 'bar');\n \n   foo.instantiate();\n \n-  assert.strictEqual(await foo.evaluate(), 6);\n+  assert.strictEqual(await foo.evaluate(-1, false), 6);\n   assert.strictEqual(foo.namespace().five, 5);\n })();"
        }
    ],
    "stats": {
        "total": 354,
        "additions": 114,
        "deletions": 240
    }
}