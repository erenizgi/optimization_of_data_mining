{
    "author": "bnoordhuis",
    "message": "crypto: refactor pbkdf2() and pbkdf2Sync() methods\n\nUse the scrypt() infrastructure to reimplement pbkdf2() in a simpler\nmanner.\n\nPR-URL: https://github.com/nodejs/node/pull/20816\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Tobias Nie√üen <tniessen@tnie.de>",
    "sha": "c188cc5338cf56d6d30590800bf1db6362a9abc6",
    "files": [
        {
            "sha": "c0773caf7c9bbc782b4756c9c666c6c1ca31db25",
            "filename": "doc/api/errors.md",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/c188cc5338cf56d6d30590800bf1db6362a9abc6/doc%2Fapi%2Ferrors.md",
            "raw_url": "https://github.com/nodejs/node/raw/c188cc5338cf56d6d30590800bf1db6362a9abc6/doc%2Fapi%2Ferrors.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ferrors.md?ref=c188cc5338cf56d6d30590800bf1db6362a9abc6",
            "patch": "@@ -739,6 +739,12 @@ An invalid [crypto digest algorithm][] was specified.\n A crypto method was used on an object that was in an invalid state. For\n instance, calling [`cipher.getAuthTag()`][] before calling `cipher.final()`.\n \n+<a id=\"ERR_CRYPTO_PBKDF2_ERROR\"></a>\n+### ERR_CRYPTO_PBKDF2_ERROR\n+\n+The PBKDF2 algorithm failed for unspecified reasons. OpenSSL does not provide\n+more details and therefore neither does Node.js.\n+\n <a id=\"ERR_CRYPTO_SCRYPT_INVALID_PARAMETER\"></a>\n ### ERR_CRYPTO_SCRYPT_INVALID_PARAMETER\n "
        },
        {
            "sha": "f842ab82b9a26af86a3548b3fb5c1e61c10283e1",
            "filename": "lib/internal/crypto/pbkdf2.js",
            "status": "modified",
            "additions": 41,
            "deletions": 32,
            "changes": 73,
            "blob_url": "https://github.com/nodejs/node/blob/c188cc5338cf56d6d30590800bf1db6362a9abc6/lib%2Finternal%2Fcrypto%2Fpbkdf2.js",
            "raw_url": "https://github.com/nodejs/node/raw/c188cc5338cf56d6d30590800bf1db6362a9abc6/lib%2Finternal%2Fcrypto%2Fpbkdf2.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fcrypto%2Fpbkdf2.js?ref=c188cc5338cf56d6d30590800bf1db6362a9abc6",
            "patch": "@@ -1,39 +1,61 @@\n 'use strict';\n \n+const { AsyncWrap, Providers } = process.binding('async_wrap');\n+const { Buffer } = require('buffer');\n+const { pbkdf2: _pbkdf2 } = process.binding('crypto');\n const {\n+  ERR_CRYPTO_INVALID_DIGEST,\n+  ERR_CRYPTO_PBKDF2_ERROR,\n   ERR_INVALID_ARG_TYPE,\n   ERR_INVALID_CALLBACK,\n-  ERR_CRYPTO_INVALID_DIGEST,\n } = require('internal/errors').codes;\n const {\n   checkIsArrayBufferView,\n   checkIsUint,\n   getDefaultEncoding,\n } = require('internal/crypto/util');\n-const {\n-  PBKDF2\n-} = process.binding('crypto');\n \n function pbkdf2(password, salt, iterations, keylen, digest, callback) {\n   if (typeof digest === 'function') {\n     callback = digest;\n     digest = undefined;\n   }\n \n+  ({ password, salt, iterations, keylen, digest } =\n+      check(password, salt, iterations, keylen, digest, callback));\n+\n   if (typeof callback !== 'function')\n     throw new ERR_INVALID_CALLBACK();\n \n-  return _pbkdf2(password, salt, iterations, keylen, digest, callback);\n+  const encoding = getDefaultEncoding();\n+  const keybuf = Buffer.alloc(keylen);\n+\n+  const wrap = new AsyncWrap(Providers.PBKDF2REQUEST);\n+  wrap.ondone = (ok) => {  // Retains keybuf while request is in flight.\n+    if (!ok) return callback.call(wrap, new ERR_CRYPTO_PBKDF2_ERROR());\n+    if (encoding === 'buffer') return callback.call(wrap, null, keybuf);\n+    callback.call(wrap, null, keybuf.toString(encoding));\n+  };\n+\n+  handleError(keybuf, password, salt, iterations, digest, wrap);\n }\n \n function pbkdf2Sync(password, salt, iterations, keylen, digest) {\n-  return _pbkdf2(password, salt, iterations, keylen, digest);\n+  ({ password, salt, iterations, keylen, digest } =\n+      check(password, salt, iterations, keylen, digest, pbkdf2Sync));\n+  const keybuf = Buffer.alloc(keylen);\n+  handleError(keybuf, password, salt, iterations, digest);\n+  const encoding = getDefaultEncoding();\n+  if (encoding === 'buffer') return keybuf;\n+  return keybuf.toString(encoding);\n }\n \n-function _pbkdf2(password, salt, iterations, keylen, digest, callback) {\n-\n-  if (digest !== null && typeof digest !== 'string')\n-    throw new ERR_INVALID_ARG_TYPE('digest', ['string', 'null'], digest);\n+function check(password, salt, iterations, keylen, digest, callback) {\n+  if (typeof digest !== 'string') {\n+    if (digest !== null)\n+      throw new ERR_INVALID_ARG_TYPE('digest', ['string', 'null'], digest);\n+    digest = 'sha1';\n+  }\n \n   password = checkIsArrayBufferView('password', password);\n   salt = checkIsArrayBufferView('salt', salt);\n@@ -42,30 +64,17 @@ function _pbkdf2(password, salt, iterations, keylen, digest, callback) {\n   iterations = checkIsUint('iterations', iterations, 'a non-negative number');\n   keylen = checkIsUint('keylen', keylen);\n \n-  const encoding = getDefaultEncoding();\n+  return { password, salt, iterations, keylen, digest };\n+}\n \n-  if (encoding === 'buffer') {\n-    const ret = PBKDF2(password, salt, iterations, keylen, digest, callback);\n-    if (ret === -1)\n-      throw new ERR_CRYPTO_INVALID_DIGEST(digest);\n-    return ret;\n-  }\n+function handleError(keybuf, password, salt, iterations, digest, wrap) {\n+  const rc = _pbkdf2(keybuf, password, salt, iterations, digest, wrap);\n \n-  // at this point, we need to handle encodings.\n-  if (callback) {\n-    function next(er, ret) {\n-      if (ret)\n-        ret = ret.toString(encoding);\n-      callback(er, ret);\n-    }\n-    if (PBKDF2(password, salt, iterations, keylen, digest, next) === -1)\n-      throw new ERR_CRYPTO_INVALID_DIGEST(digest);\n-  } else {\n-    const ret = PBKDF2(password, salt, iterations, keylen, digest);\n-    if (ret === -1)\n-      throw new ERR_CRYPTO_INVALID_DIGEST(digest);\n-    return ret.toString(encoding);\n-  }\n+  if (rc === -1)\n+    throw new ERR_CRYPTO_INVALID_DIGEST(digest);\n+\n+  if (rc === false)\n+    throw new ERR_CRYPTO_PBKDF2_ERROR();\n }\n \n module.exports = {"
        },
        {
            "sha": "51bf07adf3d91b153419cd96e93400b255bb2e9b",
            "filename": "lib/internal/errors.js",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c188cc5338cf56d6d30590800bf1db6362a9abc6/lib%2Finternal%2Ferrors.js",
            "raw_url": "https://github.com/nodejs/node/raw/c188cc5338cf56d6d30590800bf1db6362a9abc6/lib%2Finternal%2Ferrors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ferrors.js?ref=c188cc5338cf56d6d30590800bf1db6362a9abc6",
            "patch": "@@ -500,6 +500,8 @@ E('ERR_CRYPTO_HASH_FINALIZED', 'Digest already called', Error);\n E('ERR_CRYPTO_HASH_UPDATE_FAILED', 'Hash update failed', Error);\n E('ERR_CRYPTO_INVALID_DIGEST', 'Invalid digest: %s', TypeError);\n E('ERR_CRYPTO_INVALID_STATE', 'Invalid state for operation %s', Error);\n+// TODO(bnoordhuis) Decapitalize: s/PBKDF2 Error/PBKDF2 error/\n+E('ERR_CRYPTO_PBKDF2_ERROR', 'PBKDF2 Error', Error);\n E('ERR_CRYPTO_SCRYPT_INVALID_PARAMETER', 'Invalid scrypt parameter', Error);\n E('ERR_CRYPTO_SCRYPT_NOT_SUPPORTED', 'Scrypt algorithm not supported', Error);\n // Switch to TypeError. The current implementation does not seem right."
        },
        {
            "sha": "acc83f2bed9c51726383fa01a11c7fab92dabde7",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c188cc5338cf56d6d30590800bf1db6362a9abc6/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/c188cc5338cf56d6d30590800bf1db6362a9abc6/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=c188cc5338cf56d6d30590800bf1db6362a9abc6",
            "patch": "@@ -244,7 +244,6 @@ struct PackageConfig {\n   V(password_string, \"password\")                                              \\\n   V(path_string, \"path\")                                                      \\\n   V(pending_handle_string, \"pendingHandle\")                                   \\\n-  V(pbkdf2_error_string, \"PBKDF2 Error\")                                      \\\n   V(pid_string, \"pid\")                                                        \\\n   V(pipe_string, \"pipe\")                                                      \\\n   V(pipe_target_string, \"pipeTarget\")                                         \\\n@@ -337,7 +336,6 @@ struct PackageConfig {\n   V(inspector_console_api_object, v8::Object)                                 \\\n   V(message_port, v8::Object)                                                 \\\n   V(message_port_constructor_template, v8::FunctionTemplate)                  \\\n-  V(pbkdf2_constructor_template, v8::ObjectTemplate)                          \\\n   V(pipe_constructor_template, v8::FunctionTemplate)                          \\\n   V(performance_entry_callback, v8::Function)                                 \\\n   V(performance_entry_template, v8::Function)                                 \\"
        },
        {
            "sha": "528786579012a98585aaa2f499d027760a43c12c",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 71,
            "deletions": 145,
            "changes": 216,
            "blob_url": "https://github.com/nodejs/node/blob/c188cc5338cf56d6d30590800bf1db6362a9abc6/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/c188cc5338cf56d6d30590800bf1db6362a9abc6/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=c188cc5338cf56d6d30590800bf1db6362a9abc6",
            "patch": "@@ -64,7 +64,6 @@ namespace crypto {\n using v8::Array;\n using v8::Boolean;\n using v8::Context;\n-using v8::DEFAULT;\n using v8::DontDelete;\n using v8::EscapableHandleScope;\n using v8::Exception;\n@@ -75,10 +74,12 @@ using v8::HandleScope;\n using v8::Int32;\n using v8::Integer;\n using v8::Isolate;\n+using v8::Just;\n using v8::Local;\n using v8::Maybe;\n using v8::MaybeLocal;\n using v8::NewStringType;\n+using v8::Nothing;\n using v8::Null;\n using v8::Object;\n using v8::ObjectTemplate;\n@@ -4585,142 +4586,6 @@ inline void CopyBuffer(Local<Value> buf, std::vector<char>* vec) {\n }\n \n \n-class PBKDF2Request : public AsyncWrap, public ThreadPoolWork {\n- public:\n-  PBKDF2Request(Environment* env,\n-                Local<Object> object,\n-                const EVP_MD* digest,\n-                MallocedBuffer<char>&& pass,\n-                MallocedBuffer<char>&& salt,\n-                int keylen,\n-                int iteration_count)\n-      : AsyncWrap(env, object, AsyncWrap::PROVIDER_PBKDF2REQUEST),\n-        ThreadPoolWork(env),\n-        digest_(digest),\n-        success_(false),\n-        pass_(std::move(pass)),\n-        salt_(std::move(salt)),\n-        key_(keylen),\n-        iteration_count_(iteration_count) {\n-  }\n-\n-  size_t self_size() const override { return sizeof(*this); }\n-\n-  void DoThreadPoolWork() override;\n-  void AfterThreadPoolWork(int status) override;\n-\n-  void After(Local<Value> (*argv)[2]);\n-\n- private:\n-  const EVP_MD* digest_;\n-  bool success_;\n-  MallocedBuffer<char> pass_;\n-  MallocedBuffer<char> salt_;\n-  MallocedBuffer<char> key_;\n-  int iteration_count_;\n-};\n-\n-\n-void PBKDF2Request::DoThreadPoolWork() {\n-  success_ =\n-      PKCS5_PBKDF2_HMAC(\n-          pass_.data, pass_.size,\n-          reinterpret_cast<unsigned char*>(salt_.data), salt_.size,\n-          iteration_count_, digest_,\n-          key_.size,\n-          reinterpret_cast<unsigned char*>(key_.data));\n-  OPENSSL_cleanse(pass_.data, pass_.size);\n-  OPENSSL_cleanse(salt_.data, salt_.size);\n-}\n-\n-\n-void PBKDF2Request::After(Local<Value> (*argv)[2]) {\n-  if (success_) {\n-    (*argv)[0] = Null(env()->isolate());\n-    (*argv)[1] = Buffer::New(env(), key_.release(), key_.size)\n-        .ToLocalChecked();\n-  } else {\n-    (*argv)[0] = Exception::Error(env()->pbkdf2_error_string());\n-    (*argv)[1] = Undefined(env()->isolate());\n-  }\n-}\n-\n-\n-void PBKDF2Request::AfterThreadPoolWork(int status) {\n-  std::unique_ptr<PBKDF2Request> req(this);\n-  if (status == UV_ECANCELED)\n-    return;\n-  CHECK_EQ(status, 0);\n-\n-  HandleScope handle_scope(env()->isolate());\n-  Context::Scope context_scope(env()->context());\n-  Local<Value> argv[2];\n-  After(&argv);\n-  MakeCallback(env()->ondone_string(), arraysize(argv), argv);\n-}\n-\n-\n-void PBKDF2(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n-  const EVP_MD* digest = nullptr;\n-  int keylen = -1;\n-  int iteration_count = -1;\n-  Local<Object> obj;\n-\n-  int passlen = Buffer::Length(args[0]);\n-\n-  MallocedBuffer<char> pass(passlen);\n-  memcpy(pass.data, Buffer::Data(args[0]), passlen);\n-\n-  int saltlen = Buffer::Length(args[1]);\n-\n-  MallocedBuffer<char> salt(saltlen);\n-  memcpy(salt.data, Buffer::Data(args[1]), saltlen);\n-\n-  iteration_count = args[2]->Int32Value(env->context()).FromJust();\n-  keylen = args[3]->IntegerValue(env->context()).FromJust();\n-\n-  if (args[4]->IsString()) {\n-    node::Utf8Value digest_name(env->isolate(), args[4]);\n-    digest = EVP_get_digestbyname(*digest_name);\n-    if (digest == nullptr) {\n-      args.GetReturnValue().Set(-1);\n-      return;\n-    }\n-  }\n-\n-  if (digest == nullptr) {\n-    digest = EVP_sha1();\n-  }\n-\n-  obj = env->pbkdf2_constructor_template()->\n-      NewInstance(env->context()).ToLocalChecked();\n-  std::unique_ptr<PBKDF2Request> req(\n-      new PBKDF2Request(env, obj, digest,\n-                        std::move(pass),\n-                        std::move(salt),\n-                        keylen,\n-                        iteration_count));\n-\n-  if (args[5]->IsFunction()) {\n-    obj->Set(env->context(), env->ondone_string(), args[5]).FromJust();\n-\n-    req.release()->ScheduleWork();\n-  } else {\n-    env->PrintSyncTrace();\n-    req->DoThreadPoolWork();\n-    Local<Value> argv[2];\n-    req->After(&argv);\n-\n-    if (argv[0]->IsObject())\n-      env->isolate()->ThrowException(argv[0]);\n-    else\n-      args.GetReturnValue().Set(argv[1]);\n-  }\n-}\n-\n-\n // Only instantiate within a valid HandleScope.\n class RandomBytesRequest : public AsyncWrap, public ThreadPoolWork {\n  public:\n@@ -4926,6 +4791,74 @@ void RandomBytesBuffer(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n+struct PBKDF2Job : public CryptoJob {\n+  unsigned char* keybuf_data;\n+  size_t keybuf_size;\n+  std::vector<char> pass;\n+  std::vector<char> salt;\n+  uint32_t iteration_count;\n+  const EVP_MD* digest;\n+  Maybe<bool> success;\n+\n+  inline explicit PBKDF2Job(Environment* env)\n+      : CryptoJob(env), success(Nothing<bool>()) {}\n+\n+  inline ~PBKDF2Job() override {\n+    Cleanse();\n+  }\n+\n+  inline void DoThreadPoolWork() override {\n+    auto salt_data = reinterpret_cast<const unsigned char*>(salt.data());\n+    const bool ok =\n+        PKCS5_PBKDF2_HMAC(pass.data(), pass.size(), salt_data, salt.size(),\n+                          iteration_count, digest, keybuf_size, keybuf_data);\n+    success = Just(ok);\n+    Cleanse();\n+  }\n+\n+  inline void AfterThreadPoolWork() override {\n+    Local<Value> arg = ToResult();\n+    async_wrap->MakeCallback(env->ondone_string(), 1, &arg);\n+  }\n+\n+  inline Local<Value> ToResult() const {\n+    return Boolean::New(env->isolate(), success.FromJust());\n+  }\n+\n+  inline void Cleanse() {\n+    OPENSSL_cleanse(pass.data(), pass.size());\n+    OPENSSL_cleanse(salt.data(), salt.size());\n+    pass.clear();\n+    salt.clear();\n+  }\n+};\n+\n+\n+inline void PBKDF2(const FunctionCallbackInfo<Value>& args) {\n+  auto rv = args.GetReturnValue();\n+  Environment* env = Environment::GetCurrent(args);\n+  CHECK(args[0]->IsArrayBufferView());  // keybuf; wrap object retains ref.\n+  CHECK(args[1]->IsArrayBufferView());  // pass\n+  CHECK(args[2]->IsArrayBufferView());  // salt\n+  CHECK(args[3]->IsUint32());  // iteration_count\n+  CHECK(args[4]->IsString());  // digest_name\n+  CHECK(args[5]->IsObject() || args[5]->IsUndefined());  // wrap object\n+  std::unique_ptr<PBKDF2Job> job(new PBKDF2Job(env));\n+  job->keybuf_data = reinterpret_cast<unsigned char*>(Buffer::Data(args[0]));\n+  job->keybuf_size = Buffer::Length(args[0]);\n+  CopyBuffer(args[1], &job->pass);\n+  CopyBuffer(args[2], &job->salt);\n+  job->iteration_count = args[3].As<Uint32>()->Value();\n+  Utf8Value digest_name(args.GetIsolate(), args[4]);\n+  job->digest = EVP_get_digestbyname(*digest_name);\n+  if (job->digest == nullptr) return rv.Set(-1);\n+  if (args[5]->IsObject()) return PBKDF2Job::Run(std::move(job), args[5]);\n+  env->PrintSyncTrace();\n+  job->DoThreadPoolWork();\n+  rv.Set(job->ToResult());\n+}\n+\n+\n #ifndef OPENSSL_NO_SCRYPT\n struct ScryptJob : public CryptoJob {\n   unsigned char* keybuf_data;\n@@ -5417,7 +5350,7 @@ void Initialize(Local<Object> target,\n   env->SetMethod(target, \"setFipsCrypto\", SetFipsCrypto);\n #endif\n \n-  env->SetMethod(target, \"PBKDF2\", PBKDF2);\n+  env->SetMethod(target, \"pbkdf2\", PBKDF2);\n   env->SetMethod(target, \"randomBytes\", RandomBytes);\n   env->SetMethod(target, \"randomFill\", RandomBytesBuffer);\n   env->SetMethod(target, \"timingSafeEqual\", TimingSafeEqual);\n@@ -5445,13 +5378,6 @@ void Initialize(Local<Object> target,\n   env->SetMethod(target, \"scrypt\", Scrypt);\n #endif  // OPENSSL_NO_SCRYPT\n \n-  Local<FunctionTemplate> pb = FunctionTemplate::New(env->isolate());\n-  pb->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), \"PBKDF2\"));\n-  AsyncWrap::AddWrapMethods(env, pb);\n-  Local<ObjectTemplate> pbt = pb->InstanceTemplate();\n-  pbt->SetInternalFieldCount(1);\n-  env->set_pbkdf2_constructor_template(pbt);\n-\n   Local<FunctionTemplate> rb = FunctionTemplate::New(env->isolate());\n   rb->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), \"RandomBytes\"));\n   AsyncWrap::AddWrapMethods(env, rb);"
        },
        {
            "sha": "fb887ed5acd2c6c01924f06d2e1a3a2ef3ea708e",
            "filename": "test/sequential/test-async-wrap-getasyncid.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c188cc5338cf56d6d30590800bf1db6362a9abc6/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "raw_url": "https://github.com/nodejs/node/raw/c188cc5338cf56d6d30590800bf1db6362a9abc6/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-async-wrap-getasyncid.js?ref=c188cc5338cf56d6d30590800bf1db6362a9abc6",
            "patch": "@@ -115,7 +115,7 @@ if (common.hasCrypto) { // eslint-disable-line node-core/crypto-check\n   // so need to check it from the callback.\n \n   const mc = common.mustCall(function pb() {\n-    testInitialized(this, 'PBKDF2');\n+    testInitialized(this, 'AsyncWrap');\n   });\n   crypto.pbkdf2('password', 'salt', 1, 20, 'sha256', mc);\n "
        }
    ],
    "stats": {
        "total": 301,
        "additions": 121,
        "deletions": 180
    }
}