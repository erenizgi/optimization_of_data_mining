{
    "author": "devsnek",
    "message": "streams: refactor ReadableStream asyncIterator creation and a few fixes\n\nCloses: https://github.com/nodejs/node/issues/23041\n\n- Rewrite `ReadableAsyncIterator` class into\n`ReadableStreamAsyncIteratorPrototype` which contains no constructor and\ninherits from `%AsyncIteratorPrototype%`.\n\n- Rewrite `AsyncIteratorRecord` into dumb function.\n\nPR-URL: https://github.com/nodejs/node/pull/23042\nFixes: https://github.com/nodejs/node/issues/23041\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "8bce9e8f190ad2e10eb31bdceeaab4158d5ee8b4",
    "files": [
        {
            "sha": "488d10a10b5bbda7be9b967fa0b414f734dee4e2",
            "filename": "lib/_stream_readable.js",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/8bce9e8f190ad2e10eb31bdceeaab4158d5ee8b4/lib%2F_stream_readable.js",
            "raw_url": "https://github.com/nodejs/node/raw/8bce9e8f190ad2e10eb31bdceeaab4158d5ee8b4/lib%2F_stream_readable.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_stream_readable.js?ref=8bce9e8f190ad2e10eb31bdceeaab4158d5ee8b4",
            "patch": "@@ -42,7 +42,7 @@ const { emitExperimentalWarning } = require('internal/util');\n \n // Lazy loaded to improve the startup performance.\n let StringDecoder;\n-let ReadableAsyncIterator;\n+let createReadableStreamAsyncIterator;\n \n util.inherits(Readable, Stream);\n \n@@ -990,9 +990,11 @@ Readable.prototype.wrap = function(stream) {\n \n Readable.prototype[Symbol.asyncIterator] = function() {\n   emitExperimentalWarning('Readable[Symbol.asyncIterator]');\n-  if (ReadableAsyncIterator === undefined)\n-    ReadableAsyncIterator = require('internal/streams/async_iterator');\n-  return new ReadableAsyncIterator(this);\n+  if (createReadableStreamAsyncIterator === undefined) {\n+    createReadableStreamAsyncIterator =\n+      require('internal/streams/async_iterator');\n+  }\n+  return createReadableStreamAsyncIterator(this);\n };\n \n Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {"
        },
        {
            "sha": "91c473ee9d29c55d374f14c0f4210c41d20c7656",
            "filename": "lib/internal/streams/async_iterator.js",
            "status": "modified",
            "additions": 50,
            "deletions": 44,
            "changes": 94,
            "blob_url": "https://github.com/nodejs/node/blob/8bce9e8f190ad2e10eb31bdceeaab4158d5ee8b4/lib%2Finternal%2Fstreams%2Fasync_iterator.js",
            "raw_url": "https://github.com/nodejs/node/raw/8bce9e8f190ad2e10eb31bdceeaab4158d5ee8b4/lib%2Finternal%2Fstreams%2Fasync_iterator.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fstreams%2Fasync_iterator.js?ref=8bce9e8f190ad2e10eb31bdceeaab4158d5ee8b4",
            "patch": "@@ -8,12 +8,9 @@ const kLastPromise = Symbol('lastPromise');\n const kHandlePromise = Symbol('handlePromise');\n const kStream = Symbol('stream');\n \n-const AsyncIteratorRecord = class AsyncIteratorRecord {\n-  constructor(value, done) {\n-    this.done = done;\n-    this.value = value;\n-  }\n-};\n+function createIterResult(value, done) {\n+  return { value, done };\n+}\n \n function readAndResolve(iter) {\n   const resolve = iter[kLastResolve];\n@@ -26,7 +23,7 @@ function readAndResolve(iter) {\n       iter[kLastPromise] = null;\n       iter[kLastResolve] = null;\n       iter[kLastReject] = null;\n-      resolve(new AsyncIteratorRecord(data, false));\n+      resolve(createIterResult(data, false));\n     }\n   }\n }\n@@ -43,7 +40,7 @@ function onEnd(iter) {\n     iter[kLastPromise] = null;\n     iter[kLastResolve] = null;\n     iter[kLastReject] = null;\n-    resolve(new AsyncIteratorRecord(null, true));\n+    resolve(createIterResult(null, true));\n   }\n   iter[kEnded] = true;\n }\n@@ -69,39 +66,13 @@ function wrapForNext(lastPromise, iter) {\n   };\n }\n \n-const ReadableAsyncIterator = class ReadableAsyncIterator {\n-  constructor(stream) {\n-    this[kStream] = stream;\n-    this[kLastResolve] = null;\n-    this[kLastReject] = null;\n-    this[kError] = null;\n-    this[kEnded] = false;\n-    this[kLastPromise] = null;\n-\n-    stream.on('readable', onReadable.bind(null, this));\n-    stream.on('end', onEnd.bind(null, this));\n-    stream.on('error', onError.bind(null, this));\n-\n-    // the function passed to new Promise\n-    // is cached so we avoid allocating a new\n-    // closure at every run\n-    this[kHandlePromise] = (resolve, reject) => {\n-      const data = this[kStream].read();\n-      if (data) {\n-        this[kLastPromise] = null;\n-        this[kLastResolve] = null;\n-        this[kLastReject] = null;\n-        resolve(new AsyncIteratorRecord(data, false));\n-      } else {\n-        this[kLastResolve] = resolve;\n-        this[kLastReject] = reject;\n-      }\n-    };\n-  }\n+const AsyncIteratorPrototype = Object.getPrototypeOf(\n+  Object.getPrototypeOf(async function* () {}).prototype);\n \n+const ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf({\n   get stream() {\n     return this[kStream];\n-  }\n+  },\n \n   next() {\n     // if we have detected an error in the meanwhile\n@@ -112,7 +83,7 @@ const ReadableAsyncIterator = class ReadableAsyncIterator {\n     }\n \n     if (this[kEnded]) {\n-      return Promise.resolve(new AsyncIteratorRecord(null, true));\n+      return Promise.resolve(createIterResult(null, true));\n     }\n \n     // if we have multiple next() calls\n@@ -129,7 +100,7 @@ const ReadableAsyncIterator = class ReadableAsyncIterator {\n       // without triggering the next() queue\n       const data = this[kStream].read();\n       if (data !== null) {\n-        return Promise.resolve(new AsyncIteratorRecord(data, false));\n+        return Promise.resolve(createIterResult(data, false));\n       }\n \n       promise = new Promise(this[kHandlePromise]);\n@@ -138,7 +109,7 @@ const ReadableAsyncIterator = class ReadableAsyncIterator {\n     this[kLastPromise] = promise;\n \n     return promise;\n-  }\n+  },\n \n   return() {\n     // destroy(err, cb) is a private API\n@@ -150,10 +121,45 @@ const ReadableAsyncIterator = class ReadableAsyncIterator {\n           reject(err);\n           return;\n         }\n-        resolve(new AsyncIteratorRecord(null, true));\n+        resolve(createIterResult(null, true));\n       });\n     });\n-  }\n+  },\n+}, AsyncIteratorPrototype);\n+\n+const createReadableStreamAsyncIterator = (stream) => {\n+  const iterator = Object.create(ReadableStreamAsyncIteratorPrototype, {\n+    [kStream]: { value: stream, writable: true },\n+    [kLastResolve]: { value: null, writable: true },\n+    [kLastReject]: { value: null, writable: true },\n+    [kError]: { value: null, writable: true },\n+    [kEnded]: { value: false, writable: true },\n+    [kLastPromise]: { value: null, writable: true },\n+    // the function passed to new Promise\n+    // is cached so we avoid allocating a new\n+    // closure at every run\n+    [kHandlePromise]: {\n+      value: (resolve, reject) => {\n+        const data = iterator[kStream].read();\n+        if (data) {\n+          iterator[kLastPromise] = null;\n+          iterator[kLastResolve] = null;\n+          iterator[kLastReject] = null;\n+          resolve(createIterResult(data, false));\n+        } else {\n+          iterator[kLastResolve] = resolve;\n+          iterator[kLastReject] = reject;\n+        }\n+      },\n+      writable: true,\n+    },\n+  });\n+\n+  stream.on('readable', onReadable.bind(null, iterator));\n+  stream.on('end', onEnd.bind(null, iterator));\n+  stream.on('error', onError.bind(null, iterator));\n+\n+  return iterator;\n };\n \n-module.exports = ReadableAsyncIterator;\n+module.exports = createReadableStreamAsyncIterator;"
        },
        {
            "sha": "fb3c55846c44507669d3870e8843d07e0741ce62",
            "filename": "test/parallel/test-stream-readable-async-iterators.js",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/8bce9e8f190ad2e10eb31bdceeaab4158d5ee8b4/test%2Fparallel%2Ftest-stream-readable-async-iterators.js",
            "raw_url": "https://github.com/nodejs/node/raw/8bce9e8f190ad2e10eb31bdceeaab4158d5ee8b4/test%2Fparallel%2Ftest-stream-readable-async-iterators.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-stream-readable-async-iterators.js?ref=8bce9e8f190ad2e10eb31bdceeaab4158d5ee8b4",
            "patch": "@@ -5,6 +5,28 @@ const { Readable } = require('stream');\n const assert = require('assert');\n \n async function tests() {\n+  {\n+    const AsyncIteratorPrototype = Object.getPrototypeOf(\n+      Object.getPrototypeOf(async function* () {}).prototype);\n+    const rs = new Readable({});\n+    assert.strictEqual(\n+      Object.getPrototypeOf(Object.getPrototypeOf(rs[Symbol.asyncIterator]())),\n+      AsyncIteratorPrototype);\n+  }\n+\n+  await (async function() {\n+    const readable = new Readable({ objectMode: true, read() {} });\n+    readable.push(0);\n+    readable.push(1);\n+    readable.push(null);\n+\n+    const iter = readable[Symbol.asyncIterator]();\n+    assert.strictEqual((await iter.next()).value, 0);\n+    for await (const d of iter) {\n+      assert.strictEqual(d, 1);\n+    }\n+  })();\n+\n   await (async function() {\n     console.log('read without for..await');\n     const max = 5;"
        }
    ],
    "stats": {
        "total": 126,
        "additions": 78,
        "deletions": 48
    }
}