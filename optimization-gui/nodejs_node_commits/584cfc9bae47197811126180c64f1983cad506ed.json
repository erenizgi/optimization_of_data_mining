{
    "author": "addaleax",
    "message": "http2: no stream destroy while its data is on the wire\n\nThis fixes a crash that occurred when a `Http2Stream` write\nis completed after it is already destroyed.\n\nInstead, donâ€™t destroy the stream in that case and wait for\nGC to take over.\n\nPR-URL: https://github.com/nodejs/node/pull/19002\nFixes: https://github.com/nodejs/node/issues/18973\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>",
    "sha": "584cfc9bae47197811126180c64f1983cad506ed",
    "files": [
        {
            "sha": "7650969f8639ceae420d70a2b437607e439c71fb",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 5,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/584cfc9bae47197811126180c64f1983cad506ed/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/584cfc9bae47197811126180c64f1983cad506ed/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=584cfc9bae47197811126180c64f1983cad506ed",
            "patch": "@@ -1700,6 +1700,14 @@ void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n   stream_buf_ = uv_buf_init(nullptr, 0);\n }\n \n+bool Http2Session::HasWritesOnSocketForStream(Http2Stream* stream) {\n+  for (const nghttp2_stream_write& wr : outgoing_buffers_) {\n+    if (wr.req_wrap != nullptr && wr.req_wrap->stream() == stream)\n+      return true;\n+  }\n+  return false;\n+}\n+\n // Every Http2Session session is tightly bound to a single i/o StreamBase\n // (typically a net.Socket or tls.TLSSocket). The lifecycle of the two is\n // tightly coupled with all data transfer between the two happening at the\n@@ -1753,13 +1761,11 @@ Http2Stream::Http2Stream(\n \n \n Http2Stream::~Http2Stream() {\n+  DEBUG_HTTP2STREAM(this, \"tearing down stream\");\n   if (session_ != nullptr) {\n     session_->RemoveStream(this);\n     session_ = nullptr;\n   }\n-\n-  if (!object().IsEmpty())\n-    ClearWrap(object());\n }\n \n // Notify the Http2Stream that a new block of HEADERS is being processed.\n@@ -1837,15 +1843,19 @@ inline void Http2Stream::Destroy() {\n     Http2Stream* stream = static_cast<Http2Stream*>(data);\n     // Free any remaining outgoing data chunks here. This should be done\n     // here because it's possible for destroy to have been called while\n-    // we still have qeueued outbound writes.\n+    // we still have queued outbound writes.\n     while (!stream->queue_.empty()) {\n       nghttp2_stream_write& head = stream->queue_.front();\n       if (head.req_wrap != nullptr)\n         head.req_wrap->Done(UV_ECANCELED);\n       stream->queue_.pop();\n     }\n \n-    delete stream;\n+    // We can destroy the stream now if there are no writes for it\n+    // already on the socket. Otherwise, we'll wait for the garbage collector\n+    // to take care of cleaning up.\n+    if (!stream->session()->HasWritesOnSocketForStream(stream))\n+      delete stream;\n   }, this, this->object());\n \n   statistics_.end_time = uv_hrtime();"
        },
        {
            "sha": "8f6662a0160becafcb8ab674f6f1dd3a1b41ebcf",
            "filename": "src/node_http2.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/584cfc9bae47197811126180c64f1983cad506ed/src%2Fnode_http2.h",
            "raw_url": "https://github.com/nodejs/node/raw/584cfc9bae47197811126180c64f1983cad506ed/src%2Fnode_http2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.h?ref=584cfc9bae47197811126180c64f1983cad506ed",
            "patch": "@@ -878,6 +878,9 @@ class Http2Session : public AsyncWrap, public StreamListener {\n   // Removes a stream instance from this session\n   inline void RemoveStream(Http2Stream* stream);\n \n+  // Indicates whether there currently exist outgoing buffers for this stream.\n+  bool HasWritesOnSocketForStream(Http2Stream* stream);\n+\n   // Write data to the session\n   inline ssize_t Write(const uv_buf_t* bufs, size_t nbufs);\n "
        },
        {
            "sha": "3b2dd4bcd4e5485c0bdf29cd7089a29a6f2ff53e",
            "filename": "test/parallel/test-http2-write-finishes-after-stream-destroy.js",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/nodejs/node/blob/584cfc9bae47197811126180c64f1983cad506ed/test%2Fparallel%2Ftest-http2-write-finishes-after-stream-destroy.js",
            "raw_url": "https://github.com/nodejs/node/raw/584cfc9bae47197811126180c64f1983cad506ed/test%2Fparallel%2Ftest-http2-write-finishes-after-stream-destroy.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-http2-write-finishes-after-stream-destroy.js?ref=584cfc9bae47197811126180c64f1983cad506ed",
            "patch": "@@ -0,0 +1,62 @@\n+// Flags: --expose-gc\n+'use strict';\n+const common = require('../common');\n+if (!common.hasCrypto)\n+  common.skip('missing crypto');\n+const assert = require('assert');\n+const http2 = require('http2');\n+const makeDuplexPair = require('../common/duplexpair');\n+\n+// Make sure the Http2Stream destructor works, since we don't clean the\n+// stream up like we would otherwise do.\n+process.on('exit', global.gc);\n+\n+{\n+  const { clientSide, serverSide } = makeDuplexPair();\n+\n+  let serverSideHttp2Stream;\n+  let serverSideHttp2StreamDestroyed = false;\n+  const server = http2.createServer();\n+  server.on('stream', common.mustCall((stream, headers) => {\n+    serverSideHttp2Stream = stream;\n+    stream.respond({\n+      'content-type': 'text/html',\n+      ':status': 200\n+    });\n+\n+    const originalWrite = serverSide._write;\n+    serverSide._write = (buf, enc, cb) => {\n+      if (serverSideHttp2StreamDestroyed) {\n+        serverSide.destroy();\n+        serverSide.write = () => {};\n+      } else {\n+        setImmediate(() => {\n+          originalWrite.call(serverSide, buf, enc, () => setImmediate(cb));\n+        });\n+      }\n+    };\n+\n+    // Enough data to fit into a single *session* window,\n+    // not enough data to fit into a single *stream* window.\n+    stream.write(Buffer.alloc(40000));\n+  }));\n+\n+  server.emit('connection', serverSide);\n+\n+  const client = http2.connect('http://localhost:80', {\n+    createConnection: common.mustCall(() => clientSide)\n+  });\n+\n+  const req = client.request({ ':path': '/' });\n+\n+  req.on('response', common.mustCall((headers) => {\n+    assert.strictEqual(headers[':status'], 200);\n+  }));\n+\n+  req.on('data', common.mustCallAtLeast(() => {\n+    if (!serverSideHttp2StreamDestroyed) {\n+      serverSideHttp2Stream.destroy();\n+      serverSideHttp2StreamDestroyed = true;\n+    }\n+  }));\n+}"
        }
    ],
    "stats": {
        "total": 85,
        "additions": 80,
        "deletions": 5
    }
}