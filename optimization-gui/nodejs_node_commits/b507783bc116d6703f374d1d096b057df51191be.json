{
    "author": "unknown",
    "message": "tools: use print() function on both Python 2 and 3\n\nPR-URL: https://github.com/nodejs/node/pull/24486\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Sakthipriyan Vairamani <thechargingvolcano@gmail.com>",
    "sha": "b507783bc116d6703f374d1d096b057df51191be",
    "files": [
        {
            "sha": "0f56857700c4032b2ad726aa4f9fd6ec1ee6bc74",
            "filename": "tools/genv8constants.py",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/b507783bc116d6703f374d1d096b057df51191be/tools%2Fgenv8constants.py",
            "raw_url": "https://github.com/nodejs/node/raw/b507783bc116d6703f374d1d096b057df51191be/tools%2Fgenv8constants.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fgenv8constants.py?ref=b507783bc116d6703f374d1d096b057df51191be",
            "patch": "@@ -7,13 +7,14 @@\n # ustack helper.\n #\n \n+from __future__ import print_function\n import re\n import subprocess\n import sys\n import errno\n \n if len(sys.argv) != 3:\n-  print \"usage: objsym.py outfile libv8_base.a\"\n+  print(\"usage: objsym.py outfile libv8_base.a\")\n   sys.exit(2);\n \n outfile = file(sys.argv[1], 'w');\n@@ -22,13 +23,13 @@\n       bufsize=-1, stdout=subprocess.PIPE).stdout;\n except OSError, e:\n   if e.errno == errno.ENOENT:\n-    print '''\n+    print('''\n       Node.js compile error: could not find objdump\n \n       Check that GNU binutils are installed and included in PATH\n-      '''\n+      ''')\n   else:\n-    print 'problem running objdump: ', e.strerror\n+    print('problem running objdump: ', e.strerror)\n \n   sys.exit()\n "
        },
        {
            "sha": "831d2ef1550cdbe5f000696fe08109221ca6e381",
            "filename": "tools/gyp_node.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/b507783bc116d6703f374d1d096b057df51191be/tools%2Fgyp_node.py",
            "raw_url": "https://github.com/nodejs/node/raw/b507783bc116d6703f374d1d096b057df51191be/tools%2Fgyp_node.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fgyp_node.py?ref=b507783bc116d6703f374d1d096b057df51191be",
            "patch": "@@ -1,4 +1,5 @@\n #!/usr/bin/env python\n+from __future__ import print_function\n import os\n import sys\n \n@@ -52,7 +53,7 @@ def run_gyp(args):\n \n   rc = gyp.main(args)\n   if rc != 0:\n-    print 'Error running GYP'\n+    print('Error running GYP')\n     sys.exit(rc)\n \n "
        },
        {
            "sha": "2b771cb641ec37c5270c021649a0e3164dd5aa18",
            "filename": "tools/icu/icutrim.py",
            "status": "modified",
            "additions": 36,
            "deletions": 35,
            "changes": 71,
            "blob_url": "https://github.com/nodejs/node/blob/b507783bc116d6703f374d1d096b057df51191be/tools%2Ficu%2Ficutrim.py",
            "raw_url": "https://github.com/nodejs/node/raw/b507783bc116d6703f374d1d096b057df51191be/tools%2Ficu%2Ficutrim.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Ficu%2Ficutrim.py?ref=b507783bc116d6703f374d1d096b057df51191be",
            "patch": "@@ -11,6 +11,7 @@\n # Usage:\n #  Use \"-h\" to get help options.\n \n+from __future__ import print_function\n import sys\n import shutil\n # for utf-8\n@@ -79,54 +80,54 @@\n \n for opt in [ \"datfile\", \"filterfile\", \"tmpdir\", \"outfile\" ]:\n     if optVars[opt] is None:\n-        print \"Missing required option: %s\" % opt\n+        print(\"Missing required option: %s\" % opt)\n         sys.exit(1)\n \n if options.verbose>0:\n-    print \"Options: \"+str(options)\n+    print(\"Options: \"+str(options))\n \n if (os.path.isdir(options.tmpdir) and options.deltmpdir):\n   if options.verbose>1:\n-    print \"Deleting tmp dir %s..\" % (options.tmpdir)\n+    print(\"Deleting tmp dir %s..\" % (options.tmpdir))\n   shutil.rmtree(options.tmpdir)\n \n if not (os.path.isdir(options.tmpdir)):\n     os.mkdir(options.tmpdir)\n else:\n-    print \"Please delete tmpdir %s before beginning.\" % options.tmpdir\n+    print(\"Please delete tmpdir %s before beginning.\" % options.tmpdir)\n     sys.exit(1)\n \n if options.endian not in (\"big\",\"little\",\"host\"):\n-    print \"Unknown endianness: %s\" % options.endian\n+    print(\"Unknown endianness: %s\" % options.endian)\n     sys.exit(1)\n \n if options.endian is \"host\":\n     options.endian = endian\n \n if not os.path.isdir(options.tmpdir):\n-    print \"Error, tmpdir not a directory: %s\" % (options.tmpdir)\n+    print(\"Error, tmpdir not a directory: %s\" % (options.tmpdir))\n     sys.exit(1)\n \n if not os.path.isfile(options.filterfile):\n-    print \"Filterfile doesn't exist: %s\" % (options.filterfile)\n+    print(\"Filterfile doesn't exist: %s\" % (options.filterfile))\n     sys.exit(1)\n \n if not os.path.isfile(options.datfile):\n-    print \"Datfile doesn't exist: %s\" % (options.datfile)\n+    print(\"Datfile doesn't exist: %s\" % (options.datfile))\n     sys.exit(1)\n \n if not options.datfile.endswith(\".dat\"):\n-    print \"Datfile doesn't end with .dat: %s\" % (options.datfile)\n+    print(\"Datfile doesn't end with .dat: %s\" % (options.datfile))\n     sys.exit(1)\n \n outfile = os.path.join(options.tmpdir, options.outfile)\n \n if os.path.isfile(outfile):\n-    print \"Error, output file does exist: %s\" % (outfile)\n+    print(\"Error, output file does exist: %s\" % (outfile))\n     sys.exit(1)\n \n if not options.outfile.endswith(\".dat\"):\n-    print \"Outfile doesn't end with .dat: %s\" % (options.outfile)\n+    print(\"Outfile doesn't end with .dat: %s\" % (options.outfile))\n     sys.exit(1)\n \n dataname=options.outfile[0:-4]\n@@ -140,11 +141,11 @@ def runcmd(tool, cmd, doContinue=False):\n         cmd = tool + \" \" + cmd\n \n     if(options.verbose>4):\n-        print \"# \" + cmd\n+        print(\"# \" + cmd)\n \n     rc = os.system(cmd)\n     if rc is not 0 and not doContinue:\n-        print \"FAILED: %s\" % cmd\n+        print(\"FAILED: %s\" % cmd)\n         sys.exit(1)\n     return rc\n \n@@ -161,10 +162,10 @@ def runcmd(tool, cmd, doContinue=False):\n   config[\"variables\"][\"locales\"][\"only\"] = options.locales.split(',')\n \n if (options.verbose > 6):\n-    print config\n+    print(config)\n \n if(config.has_key(\"comment\")):\n-    print \"%s: %s\" % (options.filterfile, config[\"comment\"])\n+    print(\"%s: %s\" % (options.filterfile, config[\"comment\"]))\n \n ## STEP 1 - copy the data file, swapping endianness\n ## The first letter of endian_letter will be 'b' or 'l' for big or little\n@@ -184,7 +185,7 @@ def runcmd(tool, cmd, doContinue=False):\n itemset = set(items)\n \n if (options.verbose>1):\n-    print \"input file: %d items\" % (len(items))\n+    print(\"input file: %d items\" % (len(items)))\n \n # list of all trees\n trees = {}\n@@ -211,23 +212,23 @@ def queueForRemoval(tree):\n         return\n     mytree = trees[tree]\n     if(options.verbose>0):\n-        print \"* %s: %d items\" % (tree, len(mytree[\"locs\"]))\n+        print(\"* %s: %d items\" % (tree, len(mytree[\"locs\"])))\n     # do varible substitution for this tree here\n     if type(config[\"trees\"][tree]) == str or type(config[\"trees\"][tree]) == unicode:\n         treeStr = config[\"trees\"][tree]\n         if(options.verbose>5):\n-            print \" Substituting $%s for tree %s\" % (treeStr, tree)\n+            print(\" Substituting $%s for tree %s\" % (treeStr, tree))\n         if(not config.has_key(\"variables\") or not config[\"variables\"].has_key(treeStr)):\n-            print \" ERROR: no variable:  variables.%s for tree %s\" % (treeStr, tree)\n+            print(\" ERROR: no variable:  variables.%s for tree %s\" % (treeStr, tree))\n             sys.exit(1)\n         config[\"trees\"][tree] = config[\"variables\"][treeStr]\n     myconfig = config[\"trees\"][tree]\n     if(options.verbose>4):\n-        print \" Config: %s\" % (myconfig)\n+        print(\" Config: %s\" % (myconfig))\n     # Process this tree\n     if(len(myconfig)==0 or len(mytree[\"locs\"])==0):\n         if(options.verbose>2):\n-            print \" No processing for %s - skipping\" % (tree)\n+            print(\" No processing for %s - skipping\" % (tree))\n     else:\n         only = None\n         if myconfig.has_key(\"only\"):\n@@ -236,22 +237,22 @@ def queueForRemoval(tree):\n                 thePool = \"%spool.res\" % (mytree[\"treeprefix\"])\n                 if (thePool in itemset):\n                     if(options.verbose>0):\n-                        print \"Removing %s because tree %s is empty.\" % (thePool, tree)\n+                        print(\"Removing %s because tree %s is empty.\" % (thePool, tree))\n                     remove.add(thePool)\n         else:\n-            print \"tree %s - no ONLY\"\n+            print(\"tree %s - no ONLY\")\n         for l in range(len(mytree[\"locs\"])):\n             loc = mytree[\"locs\"][l]\n             if (only is not None) and not loc in only:\n                 # REMOVE loc\n                 toRemove = \"%s%s%s\" % (mytree[\"treeprefix\"], loc, mytree[\"extension\"])\n                 if(options.verbose>6):\n-                    print \"Queueing for removal: %s\" % toRemove\n+                    print(\"Queueing for removal: %s\" % toRemove)\n                 remove.add(toRemove)\n \n def addTreeByType(tree, mytree):\n     if(options.verbose>1):\n-        print \"(considering %s): %s\" % (tree, mytree)\n+        print(\"(considering %s): %s\" % (tree, mytree))\n     trees[tree] = mytree\n     mytree[\"locs\"]=[]\n     for i in range(len(items)):\n@@ -278,7 +279,7 @@ def addTreeByType(tree, mytree):\n         else:\n             tree = treeprefix[0:-1]\n         if(options.verbose>6):\n-            print \"procesing %s\" % (tree)\n+            print(\"procesing %s\" % (tree))\n         trees[tree] = { \"extension\": \".res\", \"treeprefix\": treeprefix, \"hasIndex\": True }\n         # read in the resource list for the tree\n         treelistfile = os.path.join(options.tmpdir,\"%s.lst\" % tree)\n@@ -288,7 +289,7 @@ def addTreeByType(tree, mytree):\n         trees[tree][\"locs\"] = [treeitems[i].strip() for i in range(len(treeitems))]\n         fi.close()\n         if(not config.has_key(\"trees\") or not config[\"trees\"].has_key(tree)):\n-            print \" Warning: filter file %s does not mention trees.%s - will be kept as-is\" % (options.filterfile, tree)\n+            print(\" Warning: filter file %s does not mention trees.%s - will be kept as-is\" % (options.filterfile, tree))\n         else:\n             queueForRemoval(tree)\n \n@@ -297,22 +298,22 @@ def removeList(count=0):\n     global remove\n     remove = remove - keep\n     if(count > 10):\n-        print \"Giving up - %dth attempt at removal.\" % count\n+        print(\"Giving up - %dth attempt at removal.\" % count)\n         sys.exit(1)\n     if(options.verbose>1):\n-        print \"%d items to remove - try #%d\" % (len(remove),count)\n+        print(\"%d items to remove - try #%d\" % (len(remove),count))\n     if(len(remove)>0):\n         oldcount = len(remove)\n         hackerrfile=os.path.join(options.tmpdir, \"REMOVE.err\")\n         removefile = os.path.join(options.tmpdir, \"REMOVE.lst\")\n         fi = open(removefile, 'wb')\n         for i in remove:\n-            print >>fi, i\n+            print(i, file=fi)\n         fi.close()\n         rc = runcmd(\"icupkg\",\"-r %s %s 2> %s\" %  (removefile,outfile,hackerrfile),True)\n         if rc is not 0:\n             if(options.verbose>5):\n-                print \"## Damage control, trying to parse stderr from icupkg..\"\n+                print(\"## Damage control, trying to parse stderr from icupkg..\")\n             fi = open(hackerrfile, 'rb')\n             erritems = fi.readlines()\n             fi.close()\n@@ -324,15 +325,15 @@ def removeList(count=0):\n                 if m:\n                     toDelete = m.group(1)\n                     if(options.verbose > 5):\n-                        print \"<< %s added to delete\" % toDelete\n+                        print(\"<< %s added to delete\" % toDelete)\n                     remove.add(toDelete)\n                 else:\n-                    print \"ERROR: could not match errline: %s\" % line\n+                    print(\"ERROR: could not match errline: %s\" % line)\n                     sys.exit(1)\n             if(options.verbose > 5):\n-                print \" now %d items to remove\" % len(remove)\n+                print(\" now %d items to remove\" % len(remove))\n             if(oldcount == len(remove)):\n-                print \" ERROR: could not add any mor eitems to remove. Fail.\"\n+                print(\" ERROR: could not add any mor eitems to remove. Fail.\")\n                 sys.exit(1)\n             removeList(count+1)\n "
        },
        {
            "sha": "b6e456279b32c244a4d8db313fabb9e7e8dac055",
            "filename": "tools/icu/shrink-icu-src.py",
            "status": "modified",
            "additions": 19,
            "deletions": 18,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/b507783bc116d6703f374d1d096b057df51191be/tools%2Ficu%2Fshrink-icu-src.py",
            "raw_url": "https://github.com/nodejs/node/raw/b507783bc116d6703f374d1d096b057df51191be/tools%2Ficu%2Fshrink-icu-src.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Ficu%2Fshrink-icu-src.py?ref=b507783bc116d6703f374d1d096b057df51191be",
            "patch": "@@ -1,4 +1,5 @@\n #!/usr/bin/env python\n+from __future__ import print_function\n import optparse\n import os\n import re\n@@ -29,11 +30,11 @@\n (options, args) = parser.parse_args()\n \n if os.path.isdir(options.icusmall):\n-    print 'Deleting existing icusmall %s' % (options.icusmall)\n+    print('Deleting existing icusmall %s' % (options.icusmall))\n     shutil.rmtree(options.icusmall)\n \n if not os.path.isdir(options.icusrc):\n-    print 'Missing source ICU dir --icusrc=%s' % (options.icusrc)\n+    print('Missing source ICU dir --icusrc=%s' % (options.icusrc))\n     sys.exit(1)\n \n \n@@ -73,7 +74,7 @@ def icu_ignore(dir, files):\n def icu_info(icu_full_path):\n     uvernum_h = os.path.join(icu_full_path, 'source/common/unicode/uvernum.h')\n     if not os.path.isfile(uvernum_h):\n-        print ' Error: could not load %s - is ICU installed?' % uvernum_h\n+        print(' Error: could not load %s - is ICU installed?' % uvernum_h)\n         sys.exit(1)\n     icu_ver_major = None\n     matchVerExp = r'^\\s*#define\\s+U_ICU_VERSION_SHORT\\s+\"([^\"]*)\".*'\n@@ -83,25 +84,25 @@ def icu_info(icu_full_path):\n         if m:\n             icu_ver_major = m.group(1)\n     if not icu_ver_major:\n-        print ' Could not read U_ICU_VERSION_SHORT version from %s' % uvernum_h\n+        print(' Could not read U_ICU_VERSION_SHORT version from %s' % uvernum_h)\n         sys.exit(1)\n     icu_endianness = sys.byteorder[0];  # TODO(srl295): EBCDIC should be 'e'\n     return (icu_ver_major, icu_endianness)\n \n (icu_ver_major, icu_endianness) = icu_info(options.icusrc)\n-print \"icudt%s%s\" % (icu_ver_major, icu_endianness)\n+print(\"icudt%s%s\" % (icu_ver_major, icu_endianness))\n \n src_datafile = os.path.join(options.icutmp, \"icusmdt%s.dat\" % (icu_ver_major))\n dst_datafile = os.path.join(options.icusmall, \"source\",\"data\",\"in\", \"icudt%s%s.dat\" % (icu_ver_major, icu_endianness))\n \n if not os.path.isfile(src_datafile):\n-    print \"Could not find source datafile %s - did you build small-icu node?\" % src_datafile\n+    print(\"Could not find source datafile %s - did you build small-icu node?\" % src_datafile)\n     sys.exit(1)\n else:\n-    print \"will use small datafile %s\" % (src_datafile)\n-print '%s --> %s' % (options.icusrc, options.icusmall)\n+    print(\"will use small datafile %s\" % (src_datafile))\n+print('%s --> %s' % (options.icusrc, options.icusmall))\n shutil.copytree(options.icusrc, options.icusmall, ignore=icu_ignore)\n-print '%s --> %s' % (src_datafile, dst_datafile)\n+print('%s --> %s' % (src_datafile, dst_datafile))\n \n # now, make the data dir (since we ignored it)\n os.mkdir(os.path.join(os.path.join(options.icusmall, \"source\", \"data\")))\n@@ -114,13 +115,13 @@ def icu_info(icu_full_path):\n readme_name = os.path.join(options.icusmall, \"README-SMALL-ICU.txt\" )\n \n fi = open(readme_name, 'wb')\n-print >>fi, \"Small ICU sources - auto generated by shrink-icu-src.py\"\n-print >>fi, \"\"\n-print >>fi, \"This directory contains the ICU subset used by --with-intl=small-icu (the default)\"\n-print >>fi, \"It is a strict subset of ICU %s source files with the following exception(s):\" % (icu_ver_major)\n-print >>fi, \"* %s : Reduced-size data file\" % (dst_datafile)\n-print >>fi, \"\"\n-print >>fi, \"\"\n-print >>fi, \"To rebuild this directory, see ../../tools/icu/README.md\"\n-print >>fi, \"\"\n+print(\"Small ICU sources - auto generated by shrink-icu-src.py\", file=fi)\n+print(\"\", file=fi)\n+print(\"This directory contains the ICU subset used by --with-intl=small-icu (the default)\", file=fi)\n+print(\"It is a strict subset of ICU %s source files with the following exception(s):\" % (icu_ver_major), file=fi)\n+print(\"* %s : Reduced-size data file\" % (dst_datafile), file=fi)\n+print(\"\", file=fi)\n+print(\"\", file=fi)\n+print(\"To rebuild this directory, see ../../tools/icu/README.md\", file=fi)\n+print(\"\", file=fi)\n fi.close()"
        },
        {
            "sha": "67fa424584e63a50b31d7df668a08393a52c2768",
            "filename": "tools/run-valgrind.py",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/b507783bc116d6703f374d1d096b057df51191be/tools%2Frun-valgrind.py",
            "raw_url": "https://github.com/nodejs/node/raw/b507783bc116d6703f374d1d096b057df51191be/tools%2Frun-valgrind.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Frun-valgrind.py?ref=b507783bc116d6703f374d1d096b057df51191be",
            "patch": "@@ -27,6 +27,7 @@\n # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \n+from __future__ import print_function\n from os import path\n import subprocess\n import sys\n@@ -40,12 +41,12 @@\n ]\n \n if len(sys.argv) < 2:\n-  print 'Please provide an executable to analyze.'\n+  print('Please provide an executable to analyze.')\n   sys.exit(1)\n \n executable = path.join(NODE_ROOT, sys.argv[1])\n if not path.exists(executable):\n-  print 'Cannot find the file specified: %s' % executable\n+  print('Cannot find the file specified: %s' % executable)\n   sys.exit(1)\n \n # Compute the command line."
        },
        {
            "sha": "d9e8c1fd13ea514fbb0b3aa5ac8ceee6f8e65a3d",
            "filename": "tools/specialize_node_d.py",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/b507783bc116d6703f374d1d096b057df51191be/tools%2Fspecialize_node_d.py",
            "raw_url": "https://github.com/nodejs/node/raw/b507783bc116d6703f374d1d096b057df51191be/tools%2Fspecialize_node_d.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fspecialize_node_d.py?ref=b507783bc116d6703f374d1d096b057df51191be",
            "patch": "@@ -6,11 +6,12 @@\n # Specialize node.d for given flavor (`freebsd`) and arch (`x64` or `ia32`)\n #\n \n+from __future__ import print_function\n import re\n import sys\n \n if len(sys.argv) != 5:\n-  print \"usage: specialize_node_d.py outfile src/node.d flavor arch\"\n+  print(\"usage: specialize_node_d.py outfile src/node.d flavor arch\")\n   sys.exit(2);\n \n outfile = file(sys.argv[1], 'w');"
        },
        {
            "sha": "640206f95cb4203aa8baa9b5dfecd855b274c375",
            "filename": "tools/test.py",
            "status": "modified",
            "additions": 53,
            "deletions": 52,
            "changes": 105,
            "blob_url": "https://github.com/nodejs/node/blob/b507783bc116d6703f374d1d096b057df51191be/tools%2Ftest.py",
            "raw_url": "https://github.com/nodejs/node/raw/b507783bc116d6703f374d1d096b057df51191be/tools%2Ftest.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Ftest.py?ref=b507783bc116d6703f374d1d096b057df51191be",
            "patch": "@@ -28,6 +28,7 @@\n # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \n \n+from __future__ import print_function\n import imp\n import logging\n import optparse\n@@ -87,11 +88,11 @@ def PrintFailureHeader(self, test):\n       negative_marker = '[negative] '\n     else:\n       negative_marker = ''\n-    print \"=== %(label)s %(negative)s===\" % {\n+    print(\"=== %(label)s %(negative)s===\" % {\n       'label': test.GetLabel(),\n       'negative': negative_marker\n-    }\n-    print \"Path: %s\" % \"/\".join(test.path)\n+    })\n+    print(\"Path: %s\" % \"/\".join(test.path))\n \n   def Run(self, tasks):\n     self.Starting()\n@@ -182,40 +183,40 @@ def EscapeCommand(command):\n class SimpleProgressIndicator(ProgressIndicator):\n \n   def Starting(self):\n-    print 'Running %i tests' % len(self.cases)\n+    print('Running %i tests' % len(self.cases))\n \n   def Done(self):\n-    print\n+    print()\n     for failed in self.failed:\n       self.PrintFailureHeader(failed.test)\n       if failed.output.stderr:\n-        print \"--- stderr ---\"\n-        print failed.output.stderr.strip()\n+        print(\"--- stderr ---\")\n+        print(failed.output.stderr.strip())\n       if failed.output.stdout:\n-        print \"--- stdout ---\"\n-        print failed.output.stdout.strip()\n-      print \"Command: %s\" % EscapeCommand(failed.command)\n+        print(\"--- stdout ---\")\n+        print(failed.output.stdout.strip())\n+      print(\"Command: %s\" % EscapeCommand(failed.command))\n       if failed.HasCrashed():\n-        print \"--- %s ---\" % PrintCrashed(failed.output.exit_code)\n+        print(\"--- %s ---\" % PrintCrashed(failed.output.exit_code))\n       if failed.HasTimedOut():\n-        print \"--- TIMEOUT ---\"\n+        print(\"--- TIMEOUT ---\")\n     if len(self.failed) == 0:\n-      print \"===\"\n-      print \"=== All tests succeeded\"\n-      print \"===\"\n+      print(\"===\")\n+      print(\"=== All tests succeeded\")\n+      print(\"===\")\n     else:\n-      print\n-      print \"===\"\n-      print \"=== %i tests failed\" % len(self.failed)\n+      print()\n+      print(\"===\")\n+      print(\"=== %i tests failed\" % len(self.failed))\n       if self.crashed > 0:\n-        print \"=== %i tests CRASHED\" % self.crashed\n-      print \"===\"\n+        print(\"=== %i tests CRASHED\" % self.crashed)\n+      print(\"===\")\n \n \n class VerboseProgressIndicator(SimpleProgressIndicator):\n \n   def AboutToRun(self, case):\n-    print 'Starting %s...' % case.GetLabel()\n+    print('Starting %s...' % case.GetLabel())\n     sys.stdout.flush()\n \n   def HasRun(self, output):\n@@ -226,7 +227,7 @@ def HasRun(self, output):\n         outcome = 'FAIL'\n     else:\n       outcome = 'pass'\n-    print 'Done running %s: %s' % (output.test.GetLabel(), outcome)\n+    print('Done running %s: %s' % (output.test.GetLabel(), outcome))\n \n \n class DotsProgressIndicator(SimpleProgressIndicator):\n@@ -362,9 +363,9 @@ def HasRun(self, output):\n          (\"because:\" in line or \"reason:\" in line):\n         if not printed_file:\n           printed_file = True\n-          print '==== %s ====' % command\n+          print('==== %s ====' % command)\n           self.failed.append(output)\n-        print '  %s' % line\n+        print('  %s' % line)\n \n   def Done(self):\n     pass\n@@ -393,15 +394,15 @@ def HasRun(self, output):\n       self.PrintFailureHeader(output.test)\n       stdout = output.output.stdout.strip()\n       if len(stdout):\n-        print self.templates['stdout'] % stdout\n+        print(self.templates['stdout'] % stdout)\n       stderr = output.output.stderr.strip()\n       if len(stderr):\n-        print self.templates['stderr'] % stderr\n-      print \"Command: %s\" % EscapeCommand(output.command)\n+        print(self.templates['stderr'] % stderr)\n+      print(\"Command: %s\" % EscapeCommand(output.command))\n       if output.HasCrashed():\n-        print \"--- %s ---\" % PrintCrashed(output.output.exit_code)\n+        print(\"--- %s ---\" % PrintCrashed(output.output.exit_code))\n       if output.HasTimedOut():\n-        print \"--- TIMEOUT ---\"\n+        print(\"--- TIMEOUT ---\")\n \n   def Truncate(self, str, length):\n     if length and (len(str) > (length - 3)):\n@@ -422,7 +423,7 @@ def PrintProgress(self, name):\n     }\n     status = self.Truncate(status, 78)\n     self.last_status_length = len(status)\n-    print status,\n+    print(status, end=' ')\n     sys.stdout.flush()\n \n \n@@ -437,7 +438,7 @@ def __init__(self, cases, flaky_tests_mode):\n     super(ColorProgressIndicator, self).__init__(cases, flaky_tests_mode, templates)\n \n   def ClearLine(self, last_line_length):\n-    print \"\\033[1K\\r\",\n+    print(\"\\033[1K\\r\", end=' ')\n \n \n class MonochromeProgressIndicator(CompactProgressIndicator):\n@@ -453,7 +454,7 @@ def __init__(self, cases, flaky_tests_mode):\n     super(MonochromeProgressIndicator, self).__init__(cases, flaky_tests_mode, templates)\n \n   def ClearLine(self, last_line_length):\n-    print (\"\\r\" + (\" \" * last_line_length) + \"\\r\"),\n+    print((\"\\r\" + (\" \" * last_line_length) + \"\\r\"), end=' ')\n \n \n PROGRESS_INDICATORS = {\n@@ -616,7 +617,7 @@ def KillTimedOutProcess(context, pid):\n \n \n def RunProcess(context, timeout, args, **rest):\n-  if context.verbose: print \"#\", \" \".join(args)\n+  if context.verbose: print(\"#\", \" \".join(args))\n   popen_args = args\n   prev_error_mode = SEM_INVALID_VALUE;\n   if utils.IsWindows():\n@@ -1181,15 +1182,15 @@ def ParseCondition(expr):\n   \"\"\"Parses a logical expression into an Expression object\"\"\"\n   tokens = Tokenizer(expr).Tokenize()\n   if not tokens:\n-    print \"Malformed expression: '%s'\" % expr\n+    print(\"Malformed expression: '%s'\" % expr)\n     return None\n   scan = Scanner(tokens)\n   ast = ParseLogicalExpression(scan)\n   if not ast:\n-    print \"Malformed expression: '%s'\" % expr\n+    print(\"Malformed expression: '%s'\" % expr)\n     return None\n   if scan.HasMore():\n-    print \"Malformed expression: '%s'\" % expr\n+    print(\"Malformed expression: '%s'\" % expr)\n     return None\n   return ast\n \n@@ -1387,27 +1388,27 @@ def ProcessOptions(options):\n   if options.run == [\"\"]:\n     options.run = None\n   elif len(options.run) != 2:\n-    print \"The run argument must be two comma-separated integers.\"\n+    print(\"The run argument must be two comma-separated integers.\")\n     return False\n   else:\n     try:\n       options.run = map(int, options.run)\n     except ValueError:\n-      print \"Could not parse the integers from the run argument.\"\n+      print(\"Could not parse the integers from the run argument.\")\n       return False\n     if options.run[0] < 0 or options.run[1] < 0:\n-      print \"The run argument cannot have negative integers.\"\n+      print(\"The run argument cannot have negative integers.\")\n       return False\n     if options.run[0] >= options.run[1]:\n-      print \"The test group to run (n) must be smaller than number of groups (m).\"\n+      print(\"The test group to run (n) must be smaller than number of groups (m).\")\n       return False\n   if options.J:\n     # inherit JOBS from environment if provided. some virtualised systems\n     # tends to exaggerate the number of available cpus/cores.\n     cores = os.environ.get('JOBS')\n     options.j = int(cores) if cores is not None else multiprocessing.cpu_count()\n   if options.flaky_tests not in [RUN, SKIP, DONTCARE]:\n-    print \"Unknown flaky-tests mode %s\" % options.flaky_tests\n+    print(\"Unknown flaky-tests mode %s\" % options.flaky_tests)\n     return False\n   return True\n \n@@ -1606,13 +1607,13 @@ def Main():\n       for mode in options.mode:\n         vm = context.GetVm(arch, mode)\n         if not exists(vm):\n-          print \"Can't find shell executable: '%s'\" % vm\n+          print(\"Can't find shell executable: '%s'\" % vm)\n           continue\n         archEngineContext = Execute([vm, \"-p\", \"process.arch\"], context)\n         vmArch = archEngineContext.stdout.rstrip()\n         if archEngineContext.exit_code is not 0 or vmArch == \"undefined\":\n-          print \"Can't determine the arch of: '%s'\" % vm\n-          print archEngineContext.stderr.rstrip()\n+          print(\"Can't determine the arch of: '%s'\" % vm)\n+          print(archEngineContext.stderr.rstrip())\n           continue\n         env = {\n           'mode': mode,\n@@ -1649,15 +1650,15 @@ def Main():\n       if key in visited:\n         continue\n       visited.add(key)\n-      print \"--- begin source: %s ---\" % test.GetLabel()\n+      print(\"--- begin source: %s ---\" % test.GetLabel())\n       source = test.GetSource().strip()\n-      print source\n-      print \"--- end source: %s ---\" % test.GetLabel()\n+      print(source)\n+      print(\"--- end source: %s ---\" % test.GetLabel())\n     return 0\n \n   if options.warn_unused:\n     for rule in globally_unused_rules:\n-      print \"Rule for '%s' was not used.\" % '/'.join([str(s) for s in rule.path])\n+      print(\"Rule for '%s' was not used.\" % '/'.join([str(s) for s in rule.path]))\n \n   tempdir = os.environ.get('NODE_TEST_DIR') or options.temp_dir\n   if tempdir:\n@@ -1666,7 +1667,7 @@ def Main():\n       os.makedirs(tempdir)\n     except OSError as exception:\n       if exception.errno != errno.EEXIST:\n-        print \"Could not create the temporary directory\", options.temp_dir\n+        print(\"Could not create the temporary directory\", options.temp_dir)\n         sys.exit(1)\n \n   def should_keep(case):\n@@ -1700,7 +1701,7 @@ def should_keep(case):\n                                len(cases_to_run),\n                                options.run[1]) ]\n   if len(cases_to_run) == 0:\n-    print \"No tests to run.\"\n+    print(\"No tests to run.\")\n     return 1\n   else:\n     try:\n@@ -1711,13 +1712,13 @@ def should_keep(case):\n         result = 1\n       duration = time.time() - start\n     except KeyboardInterrupt:\n-      print \"Interrupted\"\n+      print(\"Interrupted\")\n       return 1\n \n   if options.time:\n     # Write the times to stderr to make it easy to separate from the\n     # test output.\n-    print\n+    print()\n     sys.stderr.write(\"--- Total time: %s ---\\n\" % FormatTime(duration))\n     timed_tests = [ t for t in cases_to_run if not t.duration is None ]\n     timed_tests.sort(lambda a, b: a.CompareTime(b))"
        }
    ],
    "stats": {
        "total": 233,
        "additions": 120,
        "deletions": 113
    }
}