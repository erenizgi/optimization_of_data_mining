{
    "author": "joyeecheung",
    "message": "src: move error handling code into node_errors.cc\n\nMove the following code into a new node_errors.cc file and\ndeclare them in node_errors.h for clarity and make it possible\nto include them with node_errors.h.\n\n- AppendExceptionLine()\n- DecorateErrorStack()\n- FatalError()\n- OnFatalError()\n- PrintErrorString()\n- FatalException()\n- ReportException()\n- FatalTryCatch\n\nAnd move the following definitions (declared elsewhere than\nnode_errors.h) to node_errors.cc:\n\n- Abort() (in util.h)\n- Assert() (in util.h)\n\nPR-URL: https://github.com/nodejs/node/pull/24058\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "5850220229cdd8b62f6d5022779af7c232231d64",
    "files": [
        {
            "sha": "5a42d2b7149b78cb70918f4fe4b093bdcb7c250e",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/5850220229cdd8b62f6d5022779af7c232231d64/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/5850220229cdd8b62f6d5022779af7c232231d64/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=5850220229cdd8b62f6d5022779af7c232231d64",
            "patch": "@@ -345,6 +345,7 @@\n         'src/node_domain.cc',\n         'src/node_encoding.cc',\n         'src/node_errors.h',\n+        'src/node_errors.cc',\n         'src/node_file.cc',\n         'src/node_http2.cc',\n         'src/node_http_parser.cc',"
        },
        {
            "sha": "471fa231c2e86151fa07ec965fab326bd42dc457",
            "filename": "src/async_wrap.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fasync_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fasync_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.cc?ref=5850220229cdd8b62f6d5022779af7c232231d64",
            "patch": "@@ -21,9 +21,10 @@\n \n #include \"async_wrap-inl.h\"\n #include \"env-inl.h\"\n+#include \"node_errors.h\"\n #include \"node_internals.h\"\n-#include \"util-inl.h\"\n #include \"tracing/traced_value.h\"\n+#include \"util-inl.h\"\n \n #include \"v8.h\"\n #include \"v8-profiler.h\""
        },
        {
            "sha": "e22e8ee9592921ee6e342f5d629e0b882a848157",
            "filename": "src/inspector_agent.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/5850220229cdd8b62f6d5022779af7c232231d64/src%2Finspector_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5850220229cdd8b62f6d5022779af7c232231d64/src%2Finspector_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.cc?ref=5850220229cdd8b62f6d5022779af7c232231d64",
            "patch": "@@ -1,12 +1,13 @@\n #include \"inspector_agent.h\"\n \n-#include \"inspector_io.h\"\n #include \"inspector/main_thread_interface.h\"\n #include \"inspector/node_string.h\"\n #include \"inspector/tracing_agent.h\"\n #include \"inspector/worker_agent.h\"\n #include \"inspector/worker_inspector.h\"\n+#include \"inspector_io.h\"\n #include \"node/inspector/protocol/Protocol.h\"\n+#include \"node_errors.h\"\n #include \"node_internals.h\"\n #include \"node_url.h\"\n #include \"v8-inspector.h\""
        },
        {
            "sha": "b612ef3c348302ffe171a0f94d26f90a97561d39",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 384,
            "changes": 388,
            "blob_url": "https://github.com/nodejs/node/blob/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=5850220229cdd8b62f6d5022779af7c232231d64",
            "patch": "@@ -21,14 +21,16 @@\n \n #include \"node_buffer.h\"\n #include \"node_constants.h\"\n+#include \"node_context_data.h\"\n+#include \"node_errors.h\"\n+#include \"node_internals.h\"\n #include \"node_javascript.h\"\n #include \"node_code_cache.h\"\n #include \"node_platform.h\"\n #include \"node_version.h\"\n #include \"node_internals.h\"\n #include \"node_revert.h\"\n-#include \"node_perf.h\"\n-#include \"node_context_data.h\"\n+#include \"node_version.h\"\n #include \"tracing/traced_value.h\"\n \n #if HAVE_OPENSSL\n@@ -387,41 +389,6 @@ tracing::AgentWriterHandle* GetTracingAgentWriter() {\n static const unsigned kMaxSignal = 32;\n #endif\n \n-void PrintErrorString(const char* format, ...) {\n-  va_list ap;\n-  va_start(ap, format);\n-#ifdef _WIN32\n-  HANDLE stderr_handle = GetStdHandle(STD_ERROR_HANDLE);\n-\n-  // Check if stderr is something other than a tty/console\n-  if (stderr_handle == INVALID_HANDLE_VALUE ||\n-      stderr_handle == nullptr ||\n-      uv_guess_handle(_fileno(stderr)) != UV_TTY) {\n-    vfprintf(stderr, format, ap);\n-    va_end(ap);\n-    return;\n-  }\n-\n-  // Fill in any placeholders\n-  int n = _vscprintf(format, ap);\n-  std::vector<char> out(n + 1);\n-  vsprintf(out.data(), format, ap);\n-\n-  // Get required wide buffer size\n-  n = MultiByteToWideChar(CP_UTF8, 0, out.data(), -1, nullptr, 0);\n-\n-  std::vector<wchar_t> wbuf(n);\n-  MultiByteToWideChar(CP_UTF8, 0, out.data(), -1, wbuf.data(), n);\n-\n-  // Don't include the null character in the output\n-  CHECK_GT(n, 0);\n-  WriteConsoleW(stderr_handle, wbuf.data(), n - 1, nullptr, nullptr);\n-#else\n-  vfprintf(stderr, format, ap);\n-#endif\n-  va_end(ap);\n-}\n-\n const char* signo_string(int signo) {\n #define SIGNO_CASE(e)  case e: return #e;\n   switch (signo) {\n@@ -777,223 +744,6 @@ Local<Value> MakeCallback(Isolate* isolate,\n           .FromMaybe(Local<Value>()));\n }\n \n-bool IsExceptionDecorated(Environment* env, Local<Value> er) {\n-  if (!er.IsEmpty() && er->IsObject()) {\n-    Local<Object> err_obj = er.As<Object>();\n-    auto maybe_value =\n-        err_obj->GetPrivate(env->context(), env->decorated_private_symbol());\n-    Local<Value> decorated;\n-    return maybe_value.ToLocal(&decorated) && decorated->IsTrue();\n-  }\n-  return false;\n-}\n-\n-void AppendExceptionLine(Environment* env,\n-                         Local<Value> er,\n-                         Local<Message> message,\n-                         enum ErrorHandlingMode mode) {\n-  if (message.IsEmpty())\n-    return;\n-\n-  HandleScope scope(env->isolate());\n-  Local<Object> err_obj;\n-  if (!er.IsEmpty() && er->IsObject()) {\n-    err_obj = er.As<Object>();\n-  }\n-\n-  // Print (filename):(line number): (message).\n-  ScriptOrigin origin = message->GetScriptOrigin();\n-  node::Utf8Value filename(env->isolate(), message->GetScriptResourceName());\n-  const char* filename_string = *filename;\n-  int linenum = message->GetLineNumber(env->context()).FromJust();\n-  // Print line of source code.\n-  MaybeLocal<String> source_line_maybe = message->GetSourceLine(env->context());\n-  node::Utf8Value sourceline(env->isolate(),\n-                             source_line_maybe.ToLocalChecked());\n-  const char* sourceline_string = *sourceline;\n-  if (strstr(sourceline_string, \"node-do-not-add-exception-line\") != nullptr)\n-    return;\n-\n-  // Because of how node modules work, all scripts are wrapped with a\n-  // \"function (module, exports, __filename, ...) {\"\n-  // to provide script local variables.\n-  //\n-  // When reporting errors on the first line of a script, this wrapper\n-  // function is leaked to the user. There used to be a hack here to\n-  // truncate off the first 62 characters, but it caused numerous other\n-  // problems when vm.runIn*Context() methods were used for non-module\n-  // code.\n-  //\n-  // If we ever decide to re-instate such a hack, the following steps\n-  // must be taken:\n-  //\n-  // 1. Pass a flag around to say \"this code was wrapped\"\n-  // 2. Update the stack frame output so that it is also correct.\n-  //\n-  // It would probably be simpler to add a line rather than add some\n-  // number of characters to the first line, since V8 truncates the\n-  // sourceline to 78 characters, and we end up not providing very much\n-  // useful debugging info to the user if we remove 62 characters.\n-\n-  int script_start =\n-      (linenum - origin.ResourceLineOffset()->Value()) == 1 ?\n-          origin.ResourceColumnOffset()->Value() : 0;\n-  int start = message->GetStartColumn(env->context()).FromMaybe(0);\n-  int end = message->GetEndColumn(env->context()).FromMaybe(0);\n-  if (start >= script_start) {\n-    CHECK_GE(end, start);\n-    start -= script_start;\n-    end -= script_start;\n-  }\n-\n-  char arrow[1024];\n-  int max_off = sizeof(arrow) - 2;\n-\n-  int off = snprintf(arrow,\n-                     sizeof(arrow),\n-                     \"%s:%i\\n%s\\n\",\n-                     filename_string,\n-                     linenum,\n-                     sourceline_string);\n-  CHECK_GE(off, 0);\n-  if (off > max_off) {\n-    off = max_off;\n-  }\n-\n-  // Print wavy underline (GetUnderline is deprecated).\n-  for (int i = 0; i < start; i++) {\n-    if (sourceline_string[i] == '\\0' || off >= max_off) {\n-      break;\n-    }\n-    CHECK_LT(off, max_off);\n-    arrow[off++] = (sourceline_string[i] == '\\t') ? '\\t' : ' ';\n-  }\n-  for (int i = start; i < end; i++) {\n-    if (sourceline_string[i] == '\\0' || off >= max_off) {\n-      break;\n-    }\n-    CHECK_LT(off, max_off);\n-    arrow[off++] = '^';\n-  }\n-  CHECK_LE(off, max_off);\n-  arrow[off] = '\\n';\n-  arrow[off + 1] = '\\0';\n-\n-  Local<String> arrow_str = String::NewFromUtf8(env->isolate(), arrow,\n-      NewStringType::kNormal).ToLocalChecked();\n-\n-  const bool can_set_arrow = !arrow_str.IsEmpty() && !err_obj.IsEmpty();\n-  // If allocating arrow_str failed, print it out. There's not much else to do.\n-  // If it's not an error, but something needs to be printed out because\n-  // it's a fatal exception, also print it out from here.\n-  // Otherwise, the arrow property will be attached to the object and handled\n-  // by the caller.\n-  if (!can_set_arrow || (mode == FATAL_ERROR && !err_obj->IsNativeError())) {\n-    if (env->printed_error())\n-      return;\n-    Mutex::ScopedLock lock(process_mutex);\n-    env->set_printed_error(true);\n-\n-    uv_tty_reset_mode();\n-    PrintErrorString(\"\\n%s\", arrow);\n-    return;\n-  }\n-\n-  CHECK(err_obj->SetPrivate(\n-            env->context(),\n-            env->arrow_message_private_symbol(),\n-            arrow_str).FromMaybe(false));\n-}\n-\n-\n-void ReportException(Environment* env,\n-                     Local<Value> er,\n-                     Local<Message> message) {\n-  CHECK(!er.IsEmpty());\n-  HandleScope scope(env->isolate());\n-\n-  if (message.IsEmpty())\n-    message = Exception::CreateMessage(env->isolate(), er);\n-\n-  AppendExceptionLine(env, er, message, FATAL_ERROR);\n-\n-  Local<Value> trace_value;\n-  Local<Value> arrow;\n-  const bool decorated = IsExceptionDecorated(env, er);\n-\n-  if (er->IsUndefined() || er->IsNull()) {\n-    trace_value = Undefined(env->isolate());\n-  } else {\n-    Local<Object> err_obj = er->ToObject(env->context()).ToLocalChecked();\n-\n-    trace_value = err_obj->Get(env->stack_string());\n-    arrow =\n-        err_obj->GetPrivate(\n-            env->context(),\n-            env->arrow_message_private_symbol()).ToLocalChecked();\n-  }\n-\n-  node::Utf8Value trace(env->isolate(), trace_value);\n-\n-  // range errors have a trace member set to undefined\n-  if (trace.length() > 0 && !trace_value->IsUndefined()) {\n-    if (arrow.IsEmpty() || !arrow->IsString() || decorated) {\n-      PrintErrorString(\"%s\\n\", *trace);\n-    } else {\n-      node::Utf8Value arrow_string(env->isolate(), arrow);\n-      PrintErrorString(\"%s\\n%s\\n\", *arrow_string, *trace);\n-    }\n-  } else {\n-    // this really only happens for RangeErrors, since they're the only\n-    // kind that won't have all this info in the trace, or when non-Error\n-    // objects are thrown manually.\n-    Local<Value> message;\n-    Local<Value> name;\n-\n-    if (er->IsObject()) {\n-      Local<Object> err_obj = er.As<Object>();\n-      message = err_obj->Get(env->message_string());\n-      name = err_obj->Get(FIXED_ONE_BYTE_STRING(env->isolate(), \"name\"));\n-    }\n-\n-    if (message.IsEmpty() ||\n-        message->IsUndefined() ||\n-        name.IsEmpty() ||\n-        name->IsUndefined()) {\n-      // Not an error object. Just print as-is.\n-      String::Utf8Value message(env->isolate(), er);\n-\n-      PrintErrorString(\"%s\\n\", *message ? *message :\n-                                          \"<toString() threw exception>\");\n-    } else {\n-      node::Utf8Value name_string(env->isolate(), name);\n-      node::Utf8Value message_string(env->isolate(), message);\n-\n-      if (arrow.IsEmpty() || !arrow->IsString() || decorated) {\n-        PrintErrorString(\"%s: %s\\n\", *name_string, *message_string);\n-      } else {\n-        node::Utf8Value arrow_string(env->isolate(), arrow);\n-        PrintErrorString(\"%s\\n%s: %s\\n\",\n-                         *arrow_string,\n-                         *name_string,\n-                         *message_string);\n-      }\n-    }\n-  }\n-\n-  fflush(stderr);\n-\n-#if HAVE_INSPECTOR\n-  env->inspector_agent()->FatalException(er, message);\n-#endif\n-}\n-\n-\n-static void ReportException(Environment* env, const TryCatch& try_catch) {\n-  ReportException(env, try_catch.Exception(), try_catch.Message());\n-}\n-\n-\n // Executes a str within the current v8 context.\n static MaybeLocal<Value> ExecuteString(Environment* env,\n                                        Local<String> source,\n@@ -1028,31 +778,6 @@ static MaybeLocal<Value> ExecuteString(Environment* env,\n   return scope.Escape(result.ToLocalChecked());\n }\n \n-\n-[[noreturn]] void Abort() {\n-  DumpBacktrace(stderr);\n-  fflush(stderr);\n-  ABORT_NO_BACKTRACE();\n-}\n-\n-\n-[[noreturn]] void Assert(const char* const (*args)[4]) {\n-  auto filename = (*args)[0];\n-  auto linenum = (*args)[1];\n-  auto message = (*args)[2];\n-  auto function = (*args)[3];\n-\n-  char name[1024];\n-  GetHumanReadableProcessName(&name);\n-\n-  fprintf(stderr, \"%s: %s:%s:%s%s Assertion `%s' failed.\\n\",\n-          name, filename, linenum, function, *function ? \":\" : \"\", message);\n-  fflush(stderr);\n-\n-  Abort();\n-}\n-\n-\n static void WaitForInspectorDisconnect(Environment* env) {\n #if HAVE_INSPECTOR\n   if (env->inspector_agent()->IsActive()) {\n@@ -1333,111 +1058,6 @@ static void DLOpen(const FunctionCallbackInfo<Value>& args) {\n   // coverity[leaked_storage]\n }\n \n-\n-static void OnFatalError(const char* location, const char* message) {\n-  if (location) {\n-    PrintErrorString(\"FATAL ERROR: %s %s\\n\", location, message);\n-  } else {\n-    PrintErrorString(\"FATAL ERROR: %s\\n\", message);\n-  }\n-  fflush(stderr);\n-  ABORT();\n-}\n-\n-\n-[[noreturn]] void FatalError(const char* location, const char* message) {\n-  OnFatalError(location, message);\n-  // to suppress compiler warning\n-  ABORT();\n-}\n-\n-\n-FatalTryCatch::~FatalTryCatch() {\n-  if (HasCaught()) {\n-    HandleScope scope(env_->isolate());\n-    ReportException(env_, *this);\n-    exit(7);\n-  }\n-}\n-\n-\n-void FatalException(Isolate* isolate,\n-                    Local<Value> error,\n-                    Local<Message> message) {\n-  HandleScope scope(isolate);\n-\n-  Environment* env = Environment::GetCurrent(isolate);\n-  CHECK_NOT_NULL(env);  // TODO(addaleax): Handle nullptr here.\n-  Local<Object> process_object = env->process_object();\n-  Local<String> fatal_exception_string = env->fatal_exception_string();\n-  Local<Value> fatal_exception_function =\n-      process_object->Get(fatal_exception_string);\n-\n-  if (!fatal_exception_function->IsFunction()) {\n-    // Failed before the process._fatalException function was added!\n-    // this is probably pretty bad.  Nothing to do but report and exit.\n-    ReportException(env, error, message);\n-    exit(6);\n-  } else {\n-    TryCatch fatal_try_catch(isolate);\n-\n-    // Do not call FatalException when _fatalException handler throws\n-    fatal_try_catch.SetVerbose(false);\n-\n-    // This will return true if the JS layer handled it, false otherwise\n-    MaybeLocal<Value> caught = fatal_exception_function.As<Function>()->Call(\n-        env->context(), process_object, 1, &error);\n-\n-    if (fatal_try_catch.HasTerminated())\n-      return;\n-\n-    if (fatal_try_catch.HasCaught()) {\n-      // The fatal exception function threw, so we must exit\n-      ReportException(env, fatal_try_catch);\n-      exit(7);\n-    } else if (caught.ToLocalChecked()->IsFalse()) {\n-      ReportException(env, error, message);\n-\n-      // fatal_exception_function call before may have set a new exit code ->\n-      // read it again, otherwise use default for uncaughtException 1\n-      Local<String> exit_code = env->exit_code_string();\n-      Local<Value> code;\n-      if (!process_object->Get(env->context(), exit_code).ToLocal(&code) ||\n-          !code->IsInt32()) {\n-        exit(1);\n-      }\n-      exit(code.As<Int32>()->Value());\n-    }\n-  }\n-}\n-\n-\n-void FatalException(Isolate* isolate, const TryCatch& try_catch) {\n-  // If we try to print out a termination exception, we'd just get 'null',\n-  // so just crashing here with that information seems like a better idea,\n-  // and in particular it seems like we should handle terminations at the call\n-  // site for this function rather than by printing them out somewhere.\n-  CHECK(!try_catch.HasTerminated());\n-\n-  HandleScope scope(isolate);\n-  if (!try_catch.IsVerbose()) {\n-    FatalException(isolate, try_catch.Exception(), try_catch.Message());\n-  }\n-}\n-\n-\n-static void FatalException(const FunctionCallbackInfo<Value>& args) {\n-  Isolate* isolate = args.GetIsolate();\n-  Environment* env = Environment::GetCurrent(isolate);\n-  if (env != nullptr && env->abort_on_uncaught_exception()) {\n-    Abort();\n-  }\n-  Local<Value> exception = args[0];\n-  Local<Message> message = Exception::CreateMessage(isolate, exception);\n-  FatalException(isolate, exception, message);\n-}\n-\n-\n static void OnMessage(Local<Message> message, Local<Value> error) {\n   // The current version of V8 sends messages for errors only\n   // (thus `error` is always set)."
        },
        {
            "sha": "c023920da41f74fc20c4984c4eec3b5e535b1b21",
            "filename": "src/node_api.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api.cc?ref=5850220229cdd8b62f6d5022779af7c232231d64",
            "patch": "@@ -6,9 +6,10 @@\n #include <cmath>\n #include <vector>\n #define NAPI_EXPERIMENTAL\n+#include \"env.h\"\n #include \"node_api.h\"\n+#include \"node_errors.h\"\n #include \"node_internals.h\"\n-#include \"env.h\"\n \n static\n napi_status napi_set_last_error(napi_env env, napi_status error_code,"
        },
        {
            "sha": "e878507731ef1cebe207540c094391ad9e5da620",
            "filename": "src/node_contextify.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 42,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_contextify.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_contextify.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.cc?ref=5850220229cdd8b62f6d5022779af7c232231d64",
            "patch": "@@ -847,47 +847,6 @@ void ContextifyScript::RunInContext(const FunctionCallbackInfo<Value>& args) {\n       TRACING_CATEGORY_NODE2(vm, script), \"RunInContext\", wrapped_script);\n }\n \n-void ContextifyScript::DecorateErrorStack(\n-    Environment* env, const TryCatch& try_catch) {\n-  Local<Value> exception = try_catch.Exception();\n-\n-  if (!exception->IsObject())\n-    return;\n-\n-  Local<Object> err_obj = exception.As<Object>();\n-\n-  if (IsExceptionDecorated(env, err_obj))\n-    return;\n-\n-  AppendExceptionLine(env, exception, try_catch.Message(), CONTEXTIFY_ERROR);\n-  Local<Value> stack = err_obj->Get(env->stack_string());\n-  MaybeLocal<Value> maybe_value =\n-      err_obj->GetPrivate(\n-          env->context(),\n-          env->arrow_message_private_symbol());\n-\n-  Local<Value> arrow;\n-  if (!(maybe_value.ToLocal(&arrow) && arrow->IsString())) {\n-    return;\n-  }\n-\n-  if (stack.IsEmpty() || !stack->IsString()) {\n-    return;\n-  }\n-\n-  Local<String> decorated_stack = String::Concat(\n-      env->isolate(),\n-      String::Concat(env->isolate(),\n-                     arrow.As<String>(),\n-                     FIXED_ONE_BYTE_STRING(env->isolate(), \"\\n\")),\n-      stack.As<String>());\n-  err_obj->Set(env->stack_string(), decorated_stack);\n-  err_obj->SetPrivate(\n-      env->context(),\n-      env->decorated_private_symbol(),\n-      True(env->isolate()));\n-}\n-\n bool ContextifyScript::EvalMachine(Environment* env,\n                                    const int64_t timeout,\n                                    const bool display_errors,\n@@ -1080,7 +1039,7 @@ void ContextifyContext::CompileFunction(\n \n   Local<Function> fun;\n   if (maybe_fun.IsEmpty() || !maybe_fun.ToLocal(&fun)) {\n-    ContextifyScript::DecorateErrorStack(env, try_catch);\n+    DecorateErrorStack(env, try_catch);\n     try_catch.ReThrow();\n     return;\n   }"
        },
        {
            "sha": "1221233bb8bfe51e20a0f841e58423a60fc16d01",
            "filename": "src/node_contextify.h",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_contextify.h",
            "raw_url": "https://github.com/nodejs/node/raw/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_contextify.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_contextify.h?ref=5850220229cdd8b62f6d5022779af7c232231d64",
            "patch": "@@ -119,8 +119,6 @@ class ContextifyScript : public BaseObject {\n       const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void RunInThisContext(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void RunInContext(const v8::FunctionCallbackInfo<v8::Value>& args);\n-  static void DecorateErrorStack(Environment* env,\n-                                 const v8::TryCatch& try_catch);\n   static bool EvalMachine(Environment* env,\n                           const int64_t timeout,\n                           const bool display_errors,"
        },
        {
            "sha": "cc8cff0f0ed2b819f36af1ed8ae53c39c70c1ec0",
            "filename": "src/node_errors.cc",
            "status": "added",
            "additions": 427,
            "deletions": 0,
            "changes": 427,
            "blob_url": "https://github.com/nodejs/node/blob/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_errors.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_errors.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_errors.cc?ref=5850220229cdd8b62f6d5022779af7c232231d64",
            "patch": "@@ -0,0 +1,427 @@\n+#include <stdarg.h>\n+#include \"node_errors.h\"\n+#include \"node_internals.h\"\n+\n+namespace node {\n+using v8::Context;\n+using v8::Exception;\n+using v8::Function;\n+using v8::FunctionCallbackInfo;\n+using v8::HandleScope;\n+using v8::Int32;\n+using v8::Isolate;\n+using v8::Just;\n+using v8::Local;\n+using v8::Maybe;\n+using v8::MaybeLocal;\n+using v8::Message;\n+using v8::NewStringType;\n+using v8::Number;\n+using v8::Object;\n+using v8::ScriptOrigin;\n+using v8::String;\n+using v8::TryCatch;\n+using v8::Undefined;\n+using v8::Value;\n+\n+bool IsExceptionDecorated(Environment* env, Local<Value> er) {\n+  if (!er.IsEmpty() && er->IsObject()) {\n+    Local<Object> err_obj = er.As<Object>();\n+    auto maybe_value =\n+        err_obj->GetPrivate(env->context(), env->decorated_private_symbol());\n+    Local<Value> decorated;\n+    return maybe_value.ToLocal(&decorated) && decorated->IsTrue();\n+  }\n+  return false;\n+}\n+\n+void AppendExceptionLine(Environment* env,\n+                         Local<Value> er,\n+                         Local<Message> message,\n+                         enum ErrorHandlingMode mode) {\n+  if (message.IsEmpty()) return;\n+\n+  HandleScope scope(env->isolate());\n+  Local<Object> err_obj;\n+  if (!er.IsEmpty() && er->IsObject()) {\n+    err_obj = er.As<Object>();\n+  }\n+\n+  // Print (filename):(line number): (message).\n+  ScriptOrigin origin = message->GetScriptOrigin();\n+  node::Utf8Value filename(env->isolate(), message->GetScriptResourceName());\n+  const char* filename_string = *filename;\n+  int linenum = message->GetLineNumber(env->context()).FromJust();\n+  // Print line of source code.\n+  MaybeLocal<String> source_line_maybe = message->GetSourceLine(env->context());\n+  node::Utf8Value sourceline(env->isolate(),\n+                             source_line_maybe.ToLocalChecked());\n+  const char* sourceline_string = *sourceline;\n+  if (strstr(sourceline_string, \"node-do-not-add-exception-line\") != nullptr)\n+    return;\n+\n+  // Because of how node modules work, all scripts are wrapped with a\n+  // \"function (module, exports, __filename, ...) {\"\n+  // to provide script local variables.\n+  //\n+  // When reporting errors on the first line of a script, this wrapper\n+  // function is leaked to the user. There used to be a hack here to\n+  // truncate off the first 62 characters, but it caused numerous other\n+  // problems when vm.runIn*Context() methods were used for non-module\n+  // code.\n+  //\n+  // If we ever decide to re-instate such a hack, the following steps\n+  // must be taken:\n+  //\n+  // 1. Pass a flag around to say \"this code was wrapped\"\n+  // 2. Update the stack frame output so that it is also correct.\n+  //\n+  // It would probably be simpler to add a line rather than add some\n+  // number of characters to the first line, since V8 truncates the\n+  // sourceline to 78 characters, and we end up not providing very much\n+  // useful debugging info to the user if we remove 62 characters.\n+\n+  int script_start = (linenum - origin.ResourceLineOffset()->Value()) == 1\n+                         ? origin.ResourceColumnOffset()->Value()\n+                         : 0;\n+  int start = message->GetStartColumn(env->context()).FromMaybe(0);\n+  int end = message->GetEndColumn(env->context()).FromMaybe(0);\n+  if (start >= script_start) {\n+    CHECK_GE(end, start);\n+    start -= script_start;\n+    end -= script_start;\n+  }\n+\n+  char arrow[1024];\n+  int max_off = sizeof(arrow) - 2;\n+\n+  int off = snprintf(arrow,\n+                     sizeof(arrow),\n+                     \"%s:%i\\n%s\\n\",\n+                     filename_string,\n+                     linenum,\n+                     sourceline_string);\n+  CHECK_GE(off, 0);\n+  if (off > max_off) {\n+    off = max_off;\n+  }\n+\n+  // Print wavy underline (GetUnderline is deprecated).\n+  for (int i = 0; i < start; i++) {\n+    if (sourceline_string[i] == '\\0' || off >= max_off) {\n+      break;\n+    }\n+    CHECK_LT(off, max_off);\n+    arrow[off++] = (sourceline_string[i] == '\\t') ? '\\t' : ' ';\n+  }\n+  for (int i = start; i < end; i++) {\n+    if (sourceline_string[i] == '\\0' || off >= max_off) {\n+      break;\n+    }\n+    CHECK_LT(off, max_off);\n+    arrow[off++] = '^';\n+  }\n+  CHECK_LE(off, max_off);\n+  arrow[off] = '\\n';\n+  arrow[off + 1] = '\\0';\n+\n+  Local<String> arrow_str =\n+      String::NewFromUtf8(env->isolate(), arrow, NewStringType::kNormal)\n+          .ToLocalChecked();\n+\n+  const bool can_set_arrow = !arrow_str.IsEmpty() && !err_obj.IsEmpty();\n+  // If allocating arrow_str failed, print it out. There's not much else to do.\n+  // If it's not an error, but something needs to be printed out because\n+  // it's a fatal exception, also print it out from here.\n+  // Otherwise, the arrow property will be attached to the object and handled\n+  // by the caller.\n+  if (!can_set_arrow || (mode == FATAL_ERROR && !err_obj->IsNativeError())) {\n+    if (env->printed_error()) return;\n+    Mutex::ScopedLock lock(process_mutex);\n+    env->set_printed_error(true);\n+\n+    uv_tty_reset_mode();\n+    PrintErrorString(\"\\n%s\", arrow);\n+    return;\n+  }\n+\n+  CHECK(err_obj\n+            ->SetPrivate(\n+                env->context(), env->arrow_message_private_symbol(), arrow_str)\n+            .FromMaybe(false));\n+}\n+\n+[[noreturn]] void Abort() {\n+  DumpBacktrace(stderr);\n+  fflush(stderr);\n+  ABORT_NO_BACKTRACE();\n+}\n+\n+[[noreturn]] void Assert(const char* const (*args)[4]) {\n+  auto filename = (*args)[0];\n+  auto linenum = (*args)[1];\n+  auto message = (*args)[2];\n+  auto function = (*args)[3];\n+\n+  char name[1024];\n+  GetHumanReadableProcessName(&name);\n+\n+  fprintf(stderr,\n+          \"%s: %s:%s:%s%s Assertion `%s' failed.\\n\",\n+          name,\n+          filename,\n+          linenum,\n+          function,\n+          *function ? \":\" : \"\",\n+          message);\n+  fflush(stderr);\n+\n+  Abort();\n+}\n+\n+void ReportException(Environment* env,\n+                     Local<Value> er,\n+                     Local<Message> message) {\n+  CHECK(!er.IsEmpty());\n+  HandleScope scope(env->isolate());\n+\n+  if (message.IsEmpty()) message = Exception::CreateMessage(env->isolate(), er);\n+\n+  AppendExceptionLine(env, er, message, FATAL_ERROR);\n+\n+  Local<Value> trace_value;\n+  Local<Value> arrow;\n+  const bool decorated = IsExceptionDecorated(env, er);\n+\n+  if (er->IsUndefined() || er->IsNull()) {\n+    trace_value = Undefined(env->isolate());\n+  } else {\n+    Local<Object> err_obj = er->ToObject(env->context()).ToLocalChecked();\n+\n+    trace_value = err_obj->Get(env->stack_string());\n+    arrow =\n+        err_obj->GetPrivate(env->context(), env->arrow_message_private_symbol())\n+            .ToLocalChecked();\n+  }\n+\n+  node::Utf8Value trace(env->isolate(), trace_value);\n+\n+  // range errors have a trace member set to undefined\n+  if (trace.length() > 0 && !trace_value->IsUndefined()) {\n+    if (arrow.IsEmpty() || !arrow->IsString() || decorated) {\n+      PrintErrorString(\"%s\\n\", *trace);\n+    } else {\n+      node::Utf8Value arrow_string(env->isolate(), arrow);\n+      PrintErrorString(\"%s\\n%s\\n\", *arrow_string, *trace);\n+    }\n+  } else {\n+    // this really only happens for RangeErrors, since they're the only\n+    // kind that won't have all this info in the trace, or when non-Error\n+    // objects are thrown manually.\n+    Local<Value> message;\n+    Local<Value> name;\n+\n+    if (er->IsObject()) {\n+      Local<Object> err_obj = er.As<Object>();\n+      message = err_obj->Get(env->message_string());\n+      name = err_obj->Get(FIXED_ONE_BYTE_STRING(env->isolate(), \"name\"));\n+    }\n+\n+    if (message.IsEmpty() || message->IsUndefined() || name.IsEmpty() ||\n+        name->IsUndefined()) {\n+      // Not an error object. Just print as-is.\n+      String::Utf8Value message(env->isolate(), er);\n+\n+      PrintErrorString(\"%s\\n\",\n+                       *message ? *message : \"<toString() threw exception>\");\n+    } else {\n+      node::Utf8Value name_string(env->isolate(), name);\n+      node::Utf8Value message_string(env->isolate(), message);\n+\n+      if (arrow.IsEmpty() || !arrow->IsString() || decorated) {\n+        PrintErrorString(\"%s: %s\\n\", *name_string, *message_string);\n+      } else {\n+        node::Utf8Value arrow_string(env->isolate(), arrow);\n+        PrintErrorString(\n+            \"%s\\n%s: %s\\n\", *arrow_string, *name_string, *message_string);\n+      }\n+    }\n+  }\n+\n+  fflush(stderr);\n+\n+#if HAVE_INSPECTOR\n+  env->inspector_agent()->FatalException(er, message);\n+#endif\n+}\n+\n+void ReportException(Environment* env, const TryCatch& try_catch) {\n+  ReportException(env, try_catch.Exception(), try_catch.Message());\n+}\n+\n+void DecorateErrorStack(Environment* env, const TryCatch& try_catch) {\n+  Local<Value> exception = try_catch.Exception();\n+\n+  if (!exception->IsObject()) return;\n+\n+  Local<Object> err_obj = exception.As<Object>();\n+\n+  if (IsExceptionDecorated(env, err_obj)) return;\n+\n+  AppendExceptionLine(env, exception, try_catch.Message(), CONTEXTIFY_ERROR);\n+  Local<Value> stack = err_obj->Get(env->stack_string());\n+  MaybeLocal<Value> maybe_value =\n+      err_obj->GetPrivate(env->context(), env->arrow_message_private_symbol());\n+\n+  Local<Value> arrow;\n+  if (!(maybe_value.ToLocal(&arrow) && arrow->IsString())) {\n+    return;\n+  }\n+\n+  if (stack.IsEmpty() || !stack->IsString()) {\n+    return;\n+  }\n+\n+  Local<String> decorated_stack = String::Concat(\n+      env->isolate(),\n+      String::Concat(env->isolate(),\n+                     arrow.As<String>(),\n+                     FIXED_ONE_BYTE_STRING(env->isolate(), \"\\n\")),\n+      stack.As<String>());\n+  err_obj->Set(env->stack_string(), decorated_stack);\n+  err_obj->SetPrivate(\n+      env->context(), env->decorated_private_symbol(), True(env->isolate()));\n+}\n+\n+void PrintErrorString(const char* format, ...) {\n+  va_list ap;\n+  va_start(ap, format);\n+#ifdef _WIN32\n+  HANDLE stderr_handle = GetStdHandle(STD_ERROR_HANDLE);\n+\n+  // Check if stderr is something other than a tty/console\n+  if (stderr_handle == INVALID_HANDLE_VALUE || stderr_handle == nullptr ||\n+      uv_guess_handle(_fileno(stderr)) != UV_TTY) {\n+    vfprintf(stderr, format, ap);\n+    va_end(ap);\n+    return;\n+  }\n+\n+  // Fill in any placeholders\n+  int n = _vscprintf(format, ap);\n+  std::vector<char> out(n + 1);\n+  vsprintf(out.data(), format, ap);\n+\n+  // Get required wide buffer size\n+  n = MultiByteToWideChar(CP_UTF8, 0, out.data(), -1, nullptr, 0);\n+\n+  std::vector<wchar_t> wbuf(n);\n+  MultiByteToWideChar(CP_UTF8, 0, out.data(), -1, wbuf.data(), n);\n+\n+  // Don't include the null character in the output\n+  CHECK_GT(n, 0);\n+  WriteConsoleW(stderr_handle, wbuf.data(), n - 1, nullptr, nullptr);\n+#else\n+  vfprintf(stderr, format, ap);\n+#endif\n+  va_end(ap);\n+}\n+\n+[[noreturn]] void FatalError(const char* location, const char* message) {\n+  OnFatalError(location, message);\n+  // to suppress compiler warning\n+  ABORT();\n+}\n+\n+void OnFatalError(const char* location, const char* message) {\n+  if (location) {\n+    PrintErrorString(\"FATAL ERROR: %s %s\\n\", location, message);\n+  } else {\n+    PrintErrorString(\"FATAL ERROR: %s\\n\", message);\n+  }\n+  fflush(stderr);\n+  ABORT();\n+}\n+\n+FatalTryCatch::~FatalTryCatch() {\n+  if (HasCaught()) {\n+    HandleScope scope(env_->isolate());\n+    ReportException(env_, *this);\n+    exit(7);\n+  }\n+}\n+\n+void FatalException(Isolate* isolate,\n+                    Local<Value> error,\n+                    Local<Message> message) {\n+  HandleScope scope(isolate);\n+\n+  Environment* env = Environment::GetCurrent(isolate);\n+  CHECK_NOT_NULL(env);  // TODO(addaleax): Handle nullptr here.\n+  Local<Object> process_object = env->process_object();\n+  Local<String> fatal_exception_string = env->fatal_exception_string();\n+  Local<Value> fatal_exception_function =\n+      process_object->Get(fatal_exception_string);\n+\n+  if (!fatal_exception_function->IsFunction()) {\n+    // Failed before the process._fatalException function was added!\n+    // this is probably pretty bad.  Nothing to do but report and exit.\n+    ReportException(env, error, message);\n+    exit(6);\n+  } else {\n+    TryCatch fatal_try_catch(isolate);\n+\n+    // Do not call FatalException when _fatalException handler throws\n+    fatal_try_catch.SetVerbose(false);\n+\n+    // This will return true if the JS layer handled it, false otherwise\n+    MaybeLocal<Value> caught = fatal_exception_function.As<Function>()->Call(\n+        env->context(), process_object, 1, &error);\n+\n+    if (fatal_try_catch.HasTerminated()) return;\n+\n+    if (fatal_try_catch.HasCaught()) {\n+      // The fatal exception function threw, so we must exit\n+      ReportException(env, fatal_try_catch);\n+      exit(7);\n+    } else if (caught.ToLocalChecked()->IsFalse()) {\n+      ReportException(env, error, message);\n+\n+      // fatal_exception_function call before may have set a new exit code ->\n+      // read it again, otherwise use default for uncaughtException 1\n+      Local<String> exit_code = env->exit_code_string();\n+      Local<Value> code;\n+      if (!process_object->Get(env->context(), exit_code).ToLocal(&code) ||\n+          !code->IsInt32()) {\n+        exit(1);\n+      }\n+      exit(code.As<Int32>()->Value());\n+    }\n+  }\n+}\n+\n+void FatalException(Isolate* isolate, const TryCatch& try_catch) {\n+  // If we try to print out a termination exception, we'd just get 'null',\n+  // so just crashing here with that information seems like a better idea,\n+  // and in particular it seems like we should handle terminations at the call\n+  // site for this function rather than by printing them out somewhere.\n+  CHECK(!try_catch.HasTerminated());\n+\n+  HandleScope scope(isolate);\n+  if (!try_catch.IsVerbose()) {\n+    FatalException(isolate, try_catch.Exception(), try_catch.Message());\n+  }\n+}\n+\n+void FatalException(const FunctionCallbackInfo<Value>& args) {\n+  Isolate* isolate = args.GetIsolate();\n+  Environment* env = Environment::GetCurrent(isolate);\n+  if (env != nullptr && env->abort_on_uncaught_exception()) {\n+    Abort();\n+  }\n+  Local<Value> exception = args[0];\n+  Local<Message> message = Exception::CreateMessage(isolate, exception);\n+  FatalException(isolate, exception, message);\n+}\n+\n+}  // namespace node"
        },
        {
            "sha": "2c52007c5110c6aacfc4537ba60380a1ccb6ae93",
            "filename": "src/node_errors.h",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_errors.h",
            "raw_url": "https://github.com/nodejs/node/raw/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_errors.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_errors.h?ref=5850220229cdd8b62f6d5022779af7c232231d64",
            "patch": "@@ -14,6 +14,38 @@\n \n namespace node {\n \n+void DecorateErrorStack(Environment* env, const v8::TryCatch& try_catch);\n+\n+enum ErrorHandlingMode { CONTEXTIFY_ERROR, FATAL_ERROR, MODULE_ERROR };\n+void AppendExceptionLine(Environment* env,\n+                         v8::Local<v8::Value> er,\n+                         v8::Local<v8::Message> message,\n+                         enum ErrorHandlingMode mode);\n+\n+[[noreturn]] void FatalError(const char* location, const char* message);\n+void OnFatalError(const char* location, const char* message);\n+\n+// Like a `TryCatch` but exits the process if an exception was caught.\n+class FatalTryCatch : public v8::TryCatch {\n+ public:\n+  explicit FatalTryCatch(Environment* env)\n+      : TryCatch(env->isolate()), env_(env) {}\n+  ~FatalTryCatch();\n+\n+ private:\n+  Environment* env_;\n+};\n+\n+void PrintErrorString(const char* format, ...);\n+\n+void ReportException(Environment* env, const v8::TryCatch& try_catch);\n+\n+void FatalException(v8::Isolate* isolate,\n+                    v8::Local<v8::Value> error,\n+                    v8::Local<v8::Message> message);\n+\n+void FatalException(const v8::FunctionCallbackInfo<v8::Value>& args);\n+\n // Helpers to construct errors similar to the ones provided by\n // lib/internal/errors.js.\n // Example: with `V(ERR_INVALID_ARG_TYPE, TypeError)`, there will be"
        },
        {
            "sha": "b83c23681b3b949be43ceb3270076115d2ca330c",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 40,
            "deletions": 71,
            "changes": 111,
            "blob_url": "https://github.com/nodejs/node/blob/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=5850220229cdd8b62f6d5022779af7c232231d64",
            "patch": "@@ -102,46 +102,46 @@ struct sockaddr;\n // function. This helps the built-in modules are loaded properly when\n // node is built as static library. No need to depend on the\n // __attribute__((constructor)) like mechanism in GCC.\n-#define NODE_BUILTIN_STANDARD_MODULES(V)                                      \\\n-    V(async_wrap)                                                             \\\n-    V(buffer)                                                                 \\\n-    V(cares_wrap)                                                             \\\n-    V(config)                                                                 \\\n-    V(contextify)                                                             \\\n-    V(domain)                                                                 \\\n-    V(fs)                                                                     \\\n-    V(fs_event_wrap)                                                          \\\n-    V(heap_utils)                                                             \\\n-    V(http2)                                                                  \\\n-    V(http_parser)                                                            \\\n-    V(inspector)                                                              \\\n-    V(js_stream)                                                              \\\n-    V(messaging)                                                              \\\n-    V(module_wrap)                                                            \\\n-    V(options)                                                                \\\n-    V(os)                                                                     \\\n-    V(performance)                                                            \\\n-    V(pipe_wrap)                                                              \\\n-    V(process_wrap)                                                           \\\n-    V(serdes)                                                                 \\\n-    V(signal_wrap)                                                            \\\n-    V(spawn_sync)                                                             \\\n-    V(stream_pipe)                                                            \\\n-    V(stream_wrap)                                                            \\\n-    V(string_decoder)                                                         \\\n-    V(symbols)                                                                \\\n-    V(tcp_wrap)                                                               \\\n-    V(timers)                                                                 \\\n-    V(trace_events)                                                           \\\n-    V(tty_wrap)                                                               \\\n-    V(types)                                                                  \\\n-    V(udp_wrap)                                                               \\\n-    V(url)                                                                    \\\n-    V(util)                                                                   \\\n-    V(uv)                                                                     \\\n-    V(v8)                                                                     \\\n-    V(worker)                                                                 \\\n-    V(zlib)\n+#define NODE_BUILTIN_STANDARD_MODULES(V)                                       \\\n+  V(async_wrap)                                                                \\\n+  V(buffer)                                                                    \\\n+  V(cares_wrap)                                                                \\\n+  V(config)                                                                    \\\n+  V(contextify)                                                                \\\n+  V(domain)                                                                    \\\n+  V(fs)                                                                        \\\n+  V(fs_event_wrap)                                                             \\\n+  V(heap_utils)                                                                \\\n+  V(http2)                                                                     \\\n+  V(http_parser)                                                               \\\n+  V(inspector)                                                                 \\\n+  V(js_stream)                                                                 \\\n+  V(messaging)                                                                 \\\n+  V(module_wrap)                                                               \\\n+  V(options)                                                                   \\\n+  V(os)                                                                        \\\n+  V(performance)                                                               \\\n+  V(pipe_wrap)                                                                 \\\n+  V(process_wrap)                                                              \\\n+  V(serdes)                                                                    \\\n+  V(signal_wrap)                                                               \\\n+  V(spawn_sync)                                                                \\\n+  V(stream_pipe)                                                               \\\n+  V(stream_wrap)                                                               \\\n+  V(string_decoder)                                                            \\\n+  V(symbols)                                                                   \\\n+  V(tcp_wrap)                                                                  \\\n+  V(timers)                                                                    \\\n+  V(trace_events)                                                              \\\n+  V(tty_wrap)                                                                  \\\n+  V(types)                                                                     \\\n+  V(udp_wrap)                                                                  \\\n+  V(url)                                                                       \\\n+  V(util)                                                                      \\\n+  V(uv)                                                                        \\\n+  V(v8)                                                                        \\\n+  V(worker)                                                                    \\\n+  V(zlib)\n \n #define NODE_BUILTIN_MODULES(V)                                               \\\n   NODE_BUILTIN_STANDARD_MODULES(V)                                            \\\n@@ -214,11 +214,6 @@ void GetSockOrPeerName(const v8::FunctionCallbackInfo<v8::Value>& args) {\n   args.GetReturnValue().Set(err);\n }\n \n-void FatalException(v8::Isolate* isolate,\n-                    v8::Local<v8::Value> error,\n-                    v8::Local<v8::Message> message);\n-\n-\n void SignalExit(int signo);\n #ifdef __POSIX__\n void RegisterSignalHandler(int signal,\n@@ -244,27 +239,6 @@ constexpr size_t arraysize(const T(&)[N]) { return N; }\n # define MUST_USE_RESULT\n #endif\n \n-bool IsExceptionDecorated(Environment* env, v8::Local<v8::Value> er);\n-\n-enum ErrorHandlingMode { CONTEXTIFY_ERROR, FATAL_ERROR, MODULE_ERROR };\n-void AppendExceptionLine(Environment* env,\n-                         v8::Local<v8::Value> er,\n-                         v8::Local<v8::Message> message,\n-                         enum ErrorHandlingMode mode);\n-\n-[[noreturn]] void FatalError(const char* location, const char* message);\n-\n-// Like a `TryCatch` but exits the process if an exception was caught.\n-class FatalTryCatch : public v8::TryCatch {\n- public:\n-  explicit FatalTryCatch(Environment* env)\n-      : TryCatch(env->isolate()), env_(env) {}\n-  ~FatalTryCatch();\n-\n- private:\n-  Environment* env_;\n-};\n-\n class SlicedArguments {\n  public:\n   inline explicit SlicedArguments(\n@@ -298,10 +272,6 @@ SlicedArguments::SlicedArguments(\n   size_ = size;\n }\n \n-void ReportException(Environment* env,\n-                     v8::Local<v8::Value> er,\n-                     v8::Local<v8::Message> message);\n-\n v8::Maybe<bool> ProcessEmitWarning(Environment* env, const char* fmt, ...);\n v8::Maybe<bool> ProcessEmitDeprecationWarning(Environment* env,\n                                               const char* warning,\n@@ -829,7 +799,6 @@ static inline const char* errno_string(int errorno) {\n // Functions defined in node.cc that are exposed via the bootstrapper object\n \n extern double prog_start_time;\n-void PrintErrorString(const char* format, ...);\n \n void Abort(const v8::FunctionCallbackInfo<v8::Value>& args);\n void Chdir(const v8::FunctionCallbackInfo<v8::Value>& args);"
        },
        {
            "sha": "a3f22f7c983e7d4728f0746a948132b0ca3d6a3a",
            "filename": "src/node_url.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_url.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_url.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_url.cc?ref=5850220229cdd8b62f6d5022779af7c232231d64",
            "patch": "@@ -1,7 +1,8 @@\n #include \"node_url.h\"\n-#include \"node_internals.h\"\n #include \"base_object-inl.h\"\n+#include \"node_errors.h\"\n #include \"node_i18n.h\"\n+#include \"node_internals.h\"\n \n #include <string>\n #include <vector>"
        },
        {
            "sha": "b8665dc1be225d070b0529a7d0c3000c27d61086",
            "filename": "src/node_watchdog.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_watchdog.cc",
            "raw_url": "https://github.com/nodejs/node/raw/5850220229cdd8b62f6d5022779af7c232231d64/src%2Fnode_watchdog.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_watchdog.cc?ref=5850220229cdd8b62f6d5022779af7c232231d64",
            "patch": "@@ -20,9 +20,10 @@\n // USE OR OTHER DEALINGS IN THE SOFTWARE.\n \n #include \"node_watchdog.h\"\n-#include \"node_internals.h\"\n-#include \"debug_utils.h\"\n #include <algorithm>\n+#include \"debug_utils.h\"\n+#include \"node_errors.h\"\n+#include \"node_internals.h\"\n \n namespace node {\n "
        }
    ],
    "stats": {
        "total": 1021,
        "additions": 516,
        "deletions": 505
    }
}