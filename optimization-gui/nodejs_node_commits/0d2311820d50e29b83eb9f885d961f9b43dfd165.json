{
    "author": "mikesamuel",
    "message": "url: use SafeSet to filter known special protocols\n\nAvoids a maintenance hazard when reviewers assume that\n`hostlessProtocol` and `slashedProtocol` are disjoint.\n\nThe following may be counter-intuitive:\n\n```js\n// These objects seem to have no keys in common\nconst hostlessProtocol = { 'javascript': true };\nconst slashedProtocol = { 'http': true };\n// A reasonable reviewer may assumes bothTrue is never truthy\nfunction bothTrue(lowerProto) {\n  return hostlessProtocol[lowerProto] && slashedProtocol[lowerProto];\n}\n// But\nconsole.log(Boolean(bothTrue('constructor')));  // true\n```\n\nThis change uses SafeSet instead of plain-old objects.\n\n----\n\nRejected alternative:\n\nWe could have used object with a `null` prototype as lookup tables\nso that `lowerProto` is never treated as a key into `Object.prototype`.\n\n```js\nconst hostlessProtocol = { __proto__: null, 'javascript': true };\nconst slashedProtocol = { __proto__: null, 'http': true };\n\nfunction bothTrue(lowerProto) {\n  return hostlessProtocol[lowerProto] && slashedProtocol[lowerProto];\n}\n\nconsole.log(Boolean(bothTrue('constructor')));  // false\n```\n\nPR-URL: https://github.com/nodejs/node/pull/24703\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "0d2311820d50e29b83eb9f885d961f9b43dfd165",
    "files": [
        {
            "sha": "a5f8f45d01484134d665729f2af2428c7c545a9a",
            "filename": "lib/url.js",
            "status": "modified",
            "additions": 33,
            "deletions": 30,
            "changes": 63,
            "blob_url": "https://github.com/nodejs/node/blob/0d2311820d50e29b83eb9f885d961f9b43dfd165/lib%2Furl.js",
            "raw_url": "https://github.com/nodejs/node/raw/0d2311820d50e29b83eb9f885d961f9b43dfd165/lib%2Furl.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Furl.js?ref=0d2311820d50e29b83eb9f885d961f9b43dfd165",
            "patch": "@@ -26,6 +26,8 @@ const { toASCII } = process.binding('config').hasIntl ?\n \n const { hexTable } = require('internal/querystring');\n \n+const { SafeSet } = require('internal/safe_globals');\n+\n const {\n   ERR_INVALID_ARG_TYPE\n } = require('internal/errors').codes;\n@@ -76,28 +78,28 @@ const simplePathPattern = /^(\\/\\/?(?!\\/)[^?\\s]*)(\\?[^\\s]*)?$/;\n \n const hostnameMaxLen = 255;\n // protocols that can allow \"unsafe\" and \"unwise\" chars.\n-const unsafeProtocol = {\n-  'javascript': true,\n-  'javascript:': true\n-};\n+const unsafeProtocol = new SafeSet([\n+  'javascript',\n+  'javascript:'\n+]);\n // protocols that never have a hostname.\n-const hostlessProtocol = {\n-  'javascript': true,\n-  'javascript:': true\n-};\n+const hostlessProtocol = new SafeSet([\n+  'javascript',\n+  'javascript:'\n+]);\n // protocols that always contain a // bit.\n-const slashedProtocol = {\n-  'http': true,\n-  'http:': true,\n-  'https': true,\n-  'https:': true,\n-  'ftp': true,\n-  'ftp:': true,\n-  'gopher': true,\n-  'gopher:': true,\n-  'file': true,\n-  'file:': true\n-};\n+const slashedProtocol = new SafeSet([\n+  'http',\n+  'http:',\n+  'https',\n+  'https:',\n+  'ftp',\n+  'ftp:',\n+  'gopher',\n+  'gopher:',\n+  'file',\n+  'file:'\n+]);\n const {\n   CHAR_SPACE,\n   CHAR_TAB,\n@@ -267,14 +269,14 @@ Url.prototype.parse = function parse(url, parseQueryString, slashesDenoteHost) {\n   if (slashesDenoteHost || proto || hostPattern.test(rest)) {\n     var slashes = rest.charCodeAt(0) === CHAR_FORWARD_SLASH &&\n                   rest.charCodeAt(1) === CHAR_FORWARD_SLASH;\n-    if (slashes && !(proto && hostlessProtocol[lowerProto])) {\n+    if (slashes && !(proto && hostlessProtocol.has(lowerProto))) {\n       rest = rest.slice(2);\n       this.slashes = true;\n     }\n   }\n \n-  if (!hostlessProtocol[lowerProto] &&\n-      (slashes || (proto && !slashedProtocol[proto]))) {\n+  if (!hostlessProtocol.has(lowerProto) &&\n+      (slashes || (proto && !slashedProtocol.has(proto)))) {\n \n     // there's a hostname.\n     // the first instance of /, ?, ;, or # ends the host.\n@@ -400,7 +402,7 @@ Url.prototype.parse = function parse(url, parseQueryString, slashesDenoteHost) {\n \n   // now rest is set to the post-host stuff.\n   // chop off any delim chars.\n-  if (!unsafeProtocol[lowerProto]) {\n+  if (!unsafeProtocol.has(lowerProto)) {\n     // First, make 100% sure that any \"autoEscape\" chars get\n     // escaped, even if encodeURIComponent doesn't think they\n     // need to be.\n@@ -447,7 +449,7 @@ Url.prototype.parse = function parse(url, parseQueryString, slashesDenoteHost) {\n   } else if (firstIdx > 0) {\n     this.pathname = rest.slice(0, firstIdx);\n   }\n-  if (slashedProtocol[lowerProto] &&\n+  if (slashedProtocol.has(lowerProto) &&\n       this.hostname && !this.pathname) {\n     this.pathname = '/';\n   }\n@@ -629,7 +631,7 @@ Url.prototype.format = function format() {\n \n   // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n   // unless they had them to begin with.\n-  if (this.slashes || slashedProtocol[protocol]) {\n+  if (this.slashes || slashedProtocol.has(protocol)) {\n     if (this.slashes || host) {\n       if (pathname && pathname.charCodeAt(0) !== CHAR_FORWARD_SLASH)\n         pathname = '/' + pathname;\n@@ -701,7 +703,7 @@ Url.prototype.resolveObject = function resolveObject(relative) {\n     }\n \n     // urlParse appends trailing / to urls like http://www.example.com\n-    if (slashedProtocol[result.protocol] &&\n+    if (slashedProtocol.has(result.protocol) &&\n         result.hostname && !result.pathname) {\n       result.path = result.pathname = '/';\n     }\n@@ -719,7 +721,7 @@ Url.prototype.resolveObject = function resolveObject(relative) {\n     // if it is file:, then the host is dropped,\n     // because that's known to be hostless.\n     // anything else is assumed to be absolute.\n-    if (!slashedProtocol[relative.protocol]) {\n+    if (!slashedProtocol.has(relative.protocol)) {\n       var keys = Object.keys(relative);\n       for (var v = 0; v < keys.length; v++) {\n         var k = keys[v];\n@@ -732,7 +734,7 @@ Url.prototype.resolveObject = function resolveObject(relative) {\n     result.protocol = relative.protocol;\n     if (!relative.host &&\n         !/^file:?$/.test(relative.protocol) &&\n-        !hostlessProtocol[relative.protocol]) {\n+        !hostlessProtocol.has(relative.protocol)) {\n       const relPath = (relative.pathname || '').split('/');\n       while (relPath.length && !(relative.host = relPath.shift()));\n       if (!relative.host) relative.host = '';\n@@ -769,7 +771,8 @@ Url.prototype.resolveObject = function resolveObject(relative) {\n   var removeAllDots = mustEndAbs;\n   var srcPath = result.pathname && result.pathname.split('/') || [];\n   var relPath = relative.pathname && relative.pathname.split('/') || [];\n-  var noLeadingSlashes = result.protocol && !slashedProtocol[result.protocol];\n+  var noLeadingSlashes = result.protocol &&\n+      !slashedProtocol.has(result.protocol);\n \n   // if the url is a non-slashed url, then relative\n   // links like ../.. should be able"
        }
    ],
    "stats": {
        "total": 63,
        "additions": 33,
        "deletions": 30
    }
}