{
    "author": "joyeecheung",
    "message": "src: use STL containers instead of v8 values for static module data\n\nInstead of putting the source code and the cache in v8::Objects,\nput them in per-process std::maps. This has the following benefits:\n\n- It's slightly lighter in weight compared to storing things on the\n  v8 heap. Also it may be slightly faster since the preivous v8::Object\n  is already in dictionary mode - though the difference is very small\n  given the number of native modules is limited.\n- The source and code cache generation templates are now much simpler\n  since they just initialize static arrays and manipulate STL\n  constructs.\n- The static native module data can be accessed independently of any\n  Environment or Isolate, and it's easy to look them up from the\n  C++'s side.\n- It's now impossible to mutate the source code used to compile\n  native modules from the JS land since it's completely separate\n  from the v8 heap. We can still get the constant strings from\n  process.binding('natives') but that's all.\n\nA few drive-by fixes:\n\n- Remove DecorateErrorStack in LookupAndCompile - We don't need to\n  capture the exception to decorate when we encounter\n  errors during native module compilation, as those errors should be\n  syntax errors and v8 is able to decorate them well. We use\n  CompileFunctionInContext so there is no need to worry about\n  wrappers either.\n- The code cache could be rejected when node is started with v8 flags.\n  Instead of aborting in that case, simply keep a record in the\n  native_module_without_cache set.\n- Refactor js2c.py a bit, reduce code duplication and inline Render()\n  to make the one-byte/two-byte special treatment easier to read.\n\nPR-URL: https://github.com/nodejs/node/pull/24384\nFixes: https://github.com/Remove\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Franziska Hinkelmann <franziska.hinkelmann@gmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "7778c035a0a3f9bbb988eb0298a026d80f423e03",
    "files": [
        {
            "sha": "eb68b92ed866a6bb9c4d08808d6f1404328bc47d",
            "filename": "lib/internal/bootstrap/cache.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/lib%2Finternal%2Fbootstrap%2Fcache.js",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/lib%2Finternal%2Fbootstrap%2Fcache.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fbootstrap%2Fcache.js?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -9,11 +9,12 @@ const {\n   NativeModule\n } = require('internal/bootstrap/loaders');\n const {\n-  source,\n+  getSource,\n   compileCodeCache\n } = internalBinding('native_module');\n const { hasTracing } = process.binding('config');\n \n+const source = getSource();\n const depsModule = Object.keys(source).filter(\n   (key) => NativeModule.isDepsModule(key) || key.startsWith('internal/deps')\n );"
        },
        {
            "sha": "d900ee63ed47f08ce69e6b35cb6208df2f0e7be0",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -410,15 +410,13 @@\n         'src/node_api.h',\n         'src/node_api_types.h',\n         'src/node_buffer.h',\n-        'src/node_code_cache.h',\n         'src/node_constants.h',\n         'src/node_contextify.h',\n         'src/node_errors.h',\n         'src/node_file.h',\n         'src/node_http2.h',\n         'src/node_http2_state.h',\n         'src/node_internals.h',\n-        'src/node_javascript.h',\n         'src/node_messaging.h',\n         'src/node_mutex.h',\n         'src/node_native_module.h',\n@@ -430,6 +428,7 @@\n         'src/node_persistent.h',\n         'src/node_platform.h',\n         'src/node_root_certs.h',\n+        'src/node_union_bytes.h',\n         'src/node_version.h',\n         'src/node_watchdog.h',\n         'src/node_revert.h',"
        },
        {
            "sha": "5731bad9932603753a0d5ed897718d4d7c847761",
            "filename": "src/env.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fenv.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.cc?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -1,13 +1,14 @@\n-#include \"node_internals.h\"\n #include \"async_wrap.h\"\n-#include \"v8-profiler.h\"\n #include \"node_buffer.h\"\n-#include \"node_platform.h\"\n-#include \"node_file.h\"\n #include \"node_context_data.h\"\n+#include \"node_file.h\"\n+#include \"node_internals.h\"\n+#include \"node_native_module.h\"\n+#include \"node_platform.h\"\n #include \"node_worker.h\"\n #include \"tracing/agent.h\"\n #include \"tracing/traced_value.h\"\n+#include \"v8-profiler.h\"\n \n #include <stdio.h>\n #include <algorithm>"
        },
        {
            "sha": "6bed104dbb4f31515228d3cea563d6bd23bbcfcb",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 6,
            "deletions": 9,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -29,13 +29,13 @@\n #include \"inspector_agent.h\"\n #endif\n #include \"handle_wrap.h\"\n+#include \"node.h\"\n+#include \"node_http2_state.h\"\n+#include \"node_options.h\"\n #include \"req_wrap.h\"\n #include \"util.h\"\n #include \"uv.h\"\n #include \"v8.h\"\n-#include \"node.h\"\n-#include \"node_options.h\"\n-#include \"node_http2_state.h\"\n \n #include <list>\n #include <stdint.h>\n@@ -347,12 +347,6 @@ constexpr size_t kFsStatsBufferLength = kFsStatsFieldsNumber * 2;\n   V(libuv_stream_wrap_ctor_template, v8::FunctionTemplate)                     \\\n   V(message_port, v8::Object)                                                  \\\n   V(message_port_constructor_template, v8::FunctionTemplate)                   \\\n-  V(native_modules_code_cache, v8::Object)                                     \\\n-  V(native_modules_code_cache_hash, v8::Object)                                \\\n-  V(native_modules_source, v8::Object)                                         \\\n-  V(native_modules_source_hash, v8::Object)                                    \\\n-  V(native_modules_with_cache, v8::Set)                                        \\\n-  V(native_modules_without_cache, v8::Set)                                     \\\n   V(performance_entry_callback, v8::Function)                                  \\\n   V(performance_entry_template, v8::Function)                                  \\\n   V(pipe_constructor_template, v8::FunctionTemplate)                           \\\n@@ -684,6 +678,9 @@ class Environment {\n   // List of id's that have been destroyed and need the destroy() cb called.\n   inline std::vector<double>* destroy_async_id_list();\n \n+  std::set<std::string> native_modules_with_cache;\n+  std::set<std::string> native_modules_without_cache;\n+\n   std::unordered_multimap<int, loader::ModuleWrap*> hash_to_module_map;\n   std::unordered_map<uint32_t, loader::ModuleWrap*> id_to_module_map;\n   std::unordered_map<uint32_t, contextify::ContextifyScript*>"
        },
        {
            "sha": "20aafe6a050e20c4243ff0d77ca833979b408c42",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 17,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -24,7 +24,6 @@\n #include \"node_context_data.h\"\n #include \"node_errors.h\"\n #include \"node_internals.h\"\n-#include \"node_javascript.h\"\n #include \"node_native_module.h\"\n #include \"node_perf.h\"\n #include \"node_platform.h\"\n@@ -130,7 +129,7 @@ typedef int mode_t;\n \n namespace node {\n \n-using native_module::NativeModule;\n+using native_module::NativeModuleLoader;\n using options_parser::kAllowedInEnvironment;\n using options_parser::kDisallowedInEnvironment;\n using v8::Array;\n@@ -212,7 +211,7 @@ double prog_start_time;\n Mutex per_process_opts_mutex;\n std::shared_ptr<PerProcessOptions> per_process_opts {\n     new PerProcessOptions() };\n-\n+NativeModuleLoader per_process_loader;\n static Mutex node_isolate_mutex;\n static Isolate* node_isolate;\n \n@@ -1243,8 +1242,7 @@ static void GetInternalBinding(const FunctionCallbackInfo<Value>& args) {\n                                 Null(env->isolate())).FromJust());\n     DefineConstants(env->isolate(), exports);\n   } else if (!strcmp(*module_v, \"natives\")) {\n-    exports = Object::New(env->isolate());\n-    NativeModule::GetNatives(env, exports);\n+    exports = per_process_loader.GetSourceObject(env->context());\n   } else {\n     return ThrowIfNoSuchModule(env, *module_v);\n   }\n@@ -1780,18 +1778,24 @@ void LoadEnvironment(Environment* env) {\n \n   // The bootstrapper scripts are lib/internal/bootstrap/loaders.js and\n   // lib/internal/bootstrap/node.js, each included as a static C string\n-  // defined in node_javascript.h, generated in node_javascript.cc by\n-  // node_js2c.\n+  // generated in node_javascript.cc by node_js2c.\n \n-  // TODO(joyeecheung): use NativeModule::Compile\n+  // TODO(joyeecheung): use NativeModuleLoader::Compile\n+  // We duplicate the string literals here since once we refactor the bootstrap\n+  // compilation out to NativeModuleLoader none of this is going to matter\n+  Isolate* isolate = env->isolate();\n   Local<String> loaders_name =\n-      FIXED_ONE_BYTE_STRING(env->isolate(), \"internal/bootstrap/loaders.js\");\n+      FIXED_ONE_BYTE_STRING(isolate, \"internal/bootstrap/loaders.js\");\n+  Local<String> loaders_source =\n+      per_process_loader.GetSource(isolate, \"internal/bootstrap/loaders\");\n   MaybeLocal<Function> loaders_bootstrapper =\n-      GetBootstrapper(env, LoadersBootstrapperSource(env), loaders_name);\n+      GetBootstrapper(env, loaders_source, loaders_name);\n   Local<String> node_name =\n-      FIXED_ONE_BYTE_STRING(env->isolate(), \"internal/bootstrap/node.js\");\n+      FIXED_ONE_BYTE_STRING(isolate, \"internal/bootstrap/node.js\");\n+  Local<String> node_source =\n+      per_process_loader.GetSource(isolate, \"internal/bootstrap/node\");\n   MaybeLocal<Function> node_bootstrapper =\n-      GetBootstrapper(env, NodeBootstrapperSource(env), node_name);\n+      GetBootstrapper(env, node_source, node_name);\n \n   if (loaders_bootstrapper.IsEmpty() || node_bootstrapper.IsEmpty()) {\n     // Execution was interrupted.\n@@ -1843,8 +1847,6 @@ void LoadEnvironment(Environment* env) {\n                  env->options()->debug_options->break_node_first_line)\n   };\n \n-  NativeModule::LoadBindings(env);\n-\n   // Bootstrap internal loaders\n   Local<Value> bootstrapped_loaders;\n   if (!ExecuteBootstrapper(env, loaders_bootstrapper.ToLocalChecked(),\n@@ -2485,7 +2487,6 @@ void FreePlatform(MultiIsolatePlatform* platform) {\n   delete platform;\n }\n \n-\n Local<Context> NewContext(Isolate* isolate,\n                           Local<ObjectTemplate> object_template) {\n   auto context = Context::New(isolate, nullptr, object_template);\n@@ -2499,8 +2500,9 @@ Local<Context> NewContext(Isolate* isolate,\n     // Run lib/internal/per_context.js\n     Context::Scope context_scope(context);\n \n-    // TODO(joyeecheung): use NativeModule::Compile\n-    Local<String> per_context = NodePerContextSource(isolate);\n+    // TODO(joyeecheung): use NativeModuleLoader::Compile\n+    Local<String> per_context =\n+        per_process_loader.GetSource(isolate, \"internal/per_context\");\n     ScriptCompiler::Source per_context_src(per_context, nullptr);\n     Local<Script> s = ScriptCompiler::Compile(\n         context,"
        },
        {
            "sha": "8054279d55ba96cf42ccb396079805f8f9d023b5",
            "filename": "src/node_code_cache.h",
            "status": "removed",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/092ab7a1d39d97a3e93f8ed46d80d8ad783b2f9c/src%2Fnode_code_cache.h",
            "raw_url": "https://github.com/nodejs/node/raw/092ab7a1d39d97a3e93f8ed46d80d8ad783b2f9c/src%2Fnode_code_cache.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_code_cache.h?ref=092ab7a1d39d97a3e93f8ed46d80d8ad783b2f9c",
            "patch": "@@ -1,19 +0,0 @@\n-#ifndef SRC_NODE_CODE_CACHE_H_\n-#define SRC_NODE_CODE_CACHE_H_\n-\n-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n-\n-#include \"node_internals.h\"\n-\n-namespace node {\n-\n-extern const bool native_module_has_code_cache;\n-\n-void DefineCodeCache(Environment* env, v8::Local<v8::Object> target);\n-void DefineCodeCacheHash(Environment* env, v8::Local<v8::Object> target);\n-\n-}  // namespace node\n-\n-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n-\n-#endif  // SRC_NODE_CODE_CACHE_H_"
        },
        {
            "sha": "95997bb120bbf27f25916dd9c117e8d5b152fdf4",
            "filename": "src/node_code_cache_stub.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 13,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fnode_code_cache_stub.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fnode_code_cache_stub.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_code_cache_stub.cc?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -1,23 +1,19 @@\n \n-#include \"node_code_cache.h\"\n+#include \"node_native_module.h\"\n \n // This is supposed to be generated by tools/generate_code_cache.js\n // The stub here is used when configure is run without `--code-cache-path`\n \n namespace node {\n+namespace native_module {\n \n-const bool native_module_has_code_cache = false;\n+// The generated source code would insert <std::string, UnionString> pairs\n+// into native_module_loader.code_cache_.\n+void NativeModuleLoader::LoadCodeCache() {}\n \n-void DefineCodeCache(Environment* env, v8::Local<v8::Object> target) {\n-  // When we do not produce code cache for builtin modules,\n-  // `internalBinding('code_cache')` returns an empty object\n-  // (here as `target`) so this is a noop.\n-}\n-\n-void DefineCodeCacheHash(Environment* env, v8::Local<v8::Object> target) {\n-  // When we do not produce code cache for builtin modules,\n-  // `internalBinding('code_cache_hash')` returns an empty object\n-  // (here as `target`) so this is a noop.\n-}\n+// The generated source code would instert <std::string, std::string> pairs\n+// into native_module_loader.code_cache_hash_.\n+void NativeModuleLoader::LoadCodeCacheHash() {}\n \n+}  // namespace native_module\n }  // namespace node"
        },
        {
            "sha": "68c0b1f753588cbdc9cdc57e632946c0d2084058",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -171,6 +171,10 @@ struct sockaddr;\n \n namespace node {\n \n+namespace native_module {\n+class NativeModuleLoader;\n+}\n+\n extern Mutex process_mutex;\n extern Mutex environ_mutex;\n \n@@ -179,6 +183,7 @@ extern bool v8_initialized;\n \n extern Mutex per_process_opts_mutex;\n extern std::shared_ptr<PerProcessOptions> per_process_opts;\n+extern native_module::NativeModuleLoader per_process_loader;\n \n // Forward declaration\n class Environment;"
        },
        {
            "sha": "80ef40b4ec414f59726a633128913ac97537d564",
            "filename": "src/node_javascript.h",
            "status": "removed",
            "additions": 0,
            "deletions": 41,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/092ab7a1d39d97a3e93f8ed46d80d8ad783b2f9c/src%2Fnode_javascript.h",
            "raw_url": "https://github.com/nodejs/node/raw/092ab7a1d39d97a3e93f8ed46d80d8ad783b2f9c/src%2Fnode_javascript.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_javascript.h?ref=092ab7a1d39d97a3e93f8ed46d80d8ad783b2f9c",
            "patch": "@@ -1,41 +0,0 @@\n-// Copyright Joyent, Inc. and other Node contributors.\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a\n-// copy of this software and associated documentation files (the\n-// \"Software\"), to deal in the Software without restriction, including\n-// without limitation the rights to use, copy, modify, merge, publish,\n-// distribute, sublicense, and/or sell copies of the Software, and to permit\n-// persons to whom the Software is furnished to do so, subject to the\n-// following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included\n-// in all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n-// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n-// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n-// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n-// USE OR OTHER DEALINGS IN THE SOFTWARE.\n-\n-#ifndef SRC_NODE_JAVASCRIPT_H_\n-#define SRC_NODE_JAVASCRIPT_H_\n-\n-#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n-\n-#include \"node_internals.h\"\n-\n-namespace node {\n-\n-void DefineJavaScript(Environment* env, v8::Local<v8::Object> target);\n-void DefineJavaScriptHash(Environment* env, v8::Local<v8::Object> target);\n-v8::Local<v8::String> NodePerContextSource(v8::Isolate* isolate);\n-v8::Local<v8::String> LoadersBootstrapperSource(Environment* env);\n-v8::Local<v8::String> NodeBootstrapperSource(Environment* env);\n-\n-}  // namespace node\n-\n-#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n-\n-#endif  // SRC_NODE_JAVASCRIPT_H_"
        },
        {
            "sha": "11136a244c685fc682a9aed35787c6c9d650a139",
            "filename": "src/node_native_module.cc",
            "status": "modified",
            "additions": 162,
            "deletions": 162,
            "changes": 324,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fnode_native_module.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fnode_native_module.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_native_module.cc?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -1,13 +1,13 @@\n #include \"node_native_module.h\"\n-#include \"node_code_cache.h\"\n #include \"node_errors.h\"\n-#include \"node_javascript.h\"\n+#include \"node_internals.h\"\n \n namespace node {\n namespace native_module {\n \n using v8::Array;\n using v8::ArrayBuffer;\n+using v8::ArrayBufferCreationMode;\n using v8::Context;\n using v8::EscapableHandleScope;\n using v8::Function;\n@@ -25,94 +25,107 @@ using v8::ScriptCompiler;\n using v8::ScriptOrigin;\n using v8::Set;\n using v8::String;\n-using v8::TryCatch;\n using v8::Uint8Array;\n using v8::Value;\n \n-void NativeModule::GetNatives(Environment* env, Local<Object> exports) {\n-  DefineJavaScript(env, exports);\n+// TODO(joyeecheung): make these more general and put them into util.h\n+Local<Object> MapToObject(Local<Context> context,\n+                          const NativeModuleRecordMap& in) {\n+  Isolate* isolate = context->GetIsolate();\n+  Local<Object> out = Object::New(isolate);\n+  for (auto const& x : in) {\n+    Local<String> key = OneByteString(isolate, x.first.c_str(), x.first.size());\n+    out->Set(context, key, x.second.ToStringChecked(isolate)).FromJust();\n+  }\n+  return out;\n+}\n+\n+Local<Set> ToJsSet(Local<Context> context,\n+                   const std::set<std::string>& in) {\n+  Isolate* isolate = context->GetIsolate();\n+  Local<Set> out = Set::New(isolate);\n+  for (auto const& x : in) {\n+    out->Add(context, OneByteString(isolate, x.c_str(), x.size()))\n+        .ToLocalChecked();\n+  }\n+  return out;\n }\n \n-void NativeModule::LoadBindings(Environment* env) {\n-  // TODO(joyeecheung): put the static values into a\n-  // std::map<std::string, const uint8_t*> instead of a v8::Object,\n-  // because here they are only looked up from the C++ side\n-  // (except in process.binding('natives') which we don't use)\n-  // so there is little value to put them in a v8::Object upfront.\n-  // Moreover, a std::map lookup should be faster than a lookup on\n-  // an V8 Object in dictionary mode.\n+void NativeModuleLoader::GetCacheUsage(\n+    const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n   Isolate* isolate = env->isolate();\n   Local<Context> context = env->context();\n-  Local<Value> null = Null(isolate);\n-\n-  Local<Object> native_modules_source = Object::New(isolate);\n-  CHECK(native_modules_source->SetPrototype(context, null).FromJust());\n-  DefineJavaScript(env, native_modules_source);\n-  native_modules_source->SetIntegrityLevel(context, IntegrityLevel::kFrozen)\n+  Local<Object> result = Object::New(isolate);\n+  result\n+      ->Set(env->context(),\n+            OneByteString(isolate, \"compiledWithCache\"),\n+            ToJsSet(context, env->native_modules_with_cache))\n       .FromJust();\n-  env->set_native_modules_source(native_modules_source);\n-\n-  Local<Object> native_modules_source_hash = Object::New(isolate);\n-  CHECK(native_modules_source_hash->SetPrototype(context, null).FromJust());\n-  DefineJavaScriptHash(env, native_modules_source_hash);\n-  native_modules_source_hash\n-      ->SetIntegrityLevel(context, IntegrityLevel::kFrozen)\n+  result\n+      ->Set(env->context(),\n+            OneByteString(isolate, \"compiledWithoutCache\"),\n+            ToJsSet(context, env->native_modules_without_cache))\n       .FromJust();\n-  env->set_native_modules_source_hash(native_modules_source_hash);\n+  args.GetReturnValue().Set(result);\n+}\n \n-  Local<Object> native_modules_code_cache = Object::New(isolate);\n-  CHECK(native_modules_code_cache->SetPrototype(context, null).FromJust());\n-  DefineCodeCache(env, native_modules_code_cache);\n-  native_modules_code_cache->SetIntegrityLevel(context, IntegrityLevel::kFrozen)\n-      .FromJust();\n-  env->set_native_modules_code_cache(native_modules_code_cache);\n+void NativeModuleLoader::GetSourceObject(\n+    const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  args.GetReturnValue().Set(per_process_loader.GetSourceObject(env->context()));\n+}\n \n-  Local<Object> native_modules_code_cache_hash = Object::New(isolate);\n-  CHECK(native_modules_code_cache_hash->SetPrototype(context, null).FromJust());\n-  DefineCodeCacheHash(env, native_modules_code_cache_hash);\n-  native_modules_code_cache_hash\n-      ->SetIntegrityLevel(context, IntegrityLevel::kFrozen)\n-      .FromJust();\n-  env->set_native_modules_code_cache_hash(native_modules_code_cache_hash);\n+Local<Object> NativeModuleLoader::GetSourceObject(\n+    Local<Context> context) const {\n+  return MapToObject(context, source_);\n+}\n+\n+Local<String> NativeModuleLoader::GetSource(Isolate* isolate,\n+                                            const char* id) const {\n+  const auto it = source_.find(id);\n+  CHECK_NE(it, source_.end());\n+  return it->second.ToStringChecked(isolate);\n+}\n \n-  env->set_native_modules_with_cache(Set::New(isolate));\n-  env->set_native_modules_without_cache(Set::New(isolate));\n+NativeModuleLoader::NativeModuleLoader() {\n+  LoadJavaScriptSource();\n+  LoadJavaScriptHash();\n+  LoadCodeCache();\n+  LoadCodeCacheHash();\n }\n \n-void NativeModule::CompileCodeCache(const FunctionCallbackInfo<Value>& args) {\n+void NativeModuleLoader::CompileCodeCache(\n+    const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   CHECK(args[0]->IsString());\n-  Local<String> id = args[0].As<String>();\n+  node::Utf8Value id(env->isolate(), args[0].As<String>());\n \n-  Local<Value> result = CompileAsModule(env, id, true);\n+  // TODO(joyeecheung): allow compiling cache for bootstrapper by\n+  // switching on id\n+  Local<Value> result = CompileAsModule(env, *id, true);\n   if (!result.IsEmpty()) {\n     args.GetReturnValue().Set(result);\n   }\n }\n \n-void NativeModule::CompileFunction(const FunctionCallbackInfo<Value>& args) {\n+void NativeModuleLoader::CompileFunction(\n+    const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n \n   CHECK(args[0]->IsString());\n-  Local<String> id = args[0].As<String>();\n-\n-  Local<Value> result = CompileAsModule(env, id, false);\n+  node::Utf8Value id(env->isolate(), args[0].As<String>());\n+  Local<Value> result = CompileAsModule(env, *id, false);\n   if (!result.IsEmpty()) {\n     args.GetReturnValue().Set(result);\n   }\n }\n \n-Local<Value> NativeModule::CompileAsModule(Environment* env,\n-                                           Local<String> id,\n-                                           bool produce_code_cache) {\n-  Local<String> parameters[] = {env->exports_string(),\n-                                env->require_string(),\n-                                env->module_string(),\n-                                env->process_string(),\n-                                env->internal_binding_string()};\n-\n-  return Compile(\n-      env, id, parameters, arraysize(parameters), produce_code_cache);\n+Local<Value> NativeModuleLoader::CompileAsModule(Environment* env,\n+                                                 const char* id,\n+                                                 bool produce_code_cache) {\n+  return per_process_loader.LookupAndCompile(\n+      env->context(), id, produce_code_cache, env);\n }\n \n // Currently V8 only checks that the length of the source code is the\n@@ -139,64 +152,52 @@ Local<Value> NativeModule::CompileAsModule(Environment* env,\n // early in the bootstrap process so it should be easy to detect and fix.\n \n // Returns nullptr if there is no code cache corresponding to the id\n-ScriptCompiler::CachedData* GetCachedData(Environment* env, Local<String> id) {\n-  HandleScope scope(env->isolate());\n-  Local<Context> context = env->context();\n-\n-  Local<Value> result =\n-      env->native_modules_code_cache()->Get(context, id).ToLocalChecked();\n+ScriptCompiler::CachedData* NativeModuleLoader::GetCachedData(\n+    const char* id) const {\n+  const auto it = per_process_loader.code_cache_.find(id);\n   // This could be false if the module cannot be cached somehow.\n   // See lib/internal/bootstrap/cache.js on the modules that cannot be cached\n-  if (result->IsUndefined()) {\n+  if (it == per_process_loader.code_cache_.end()) {\n     return nullptr;\n   }\n \n-  CHECK(result->IsUint8Array());\n-  Local<Uint8Array> code_cache = result.As<Uint8Array>();\n+  const uint8_t* code_cache_value = it->second.one_bytes_data();\n+  size_t code_cache_length = it->second.length();\n \n-  result =\n-      env->native_modules_code_cache_hash()->Get(context, id).ToLocalChecked();\n-  CHECK(result->IsString());\n-  Local<String> code_cache_hash = result.As<String>();\n+  const auto it2 = code_cache_hash_.find(id);\n+  CHECK_NE(it2, code_cache_hash_.end());\n+  const std::string& code_cache_hash_value = it2->second;\n \n-  result =\n-      env->native_modules_source_hash()->Get(context, id).ToLocalChecked();\n-  CHECK(result->IsString());\n-  Local<String> source_hash = result.As<String>();\n+  const auto it3 = source_hash_.find(id);\n+  CHECK_NE(it3, source_hash_.end());\n+  const std::string& source_hash_value = it3->second;\n \n   // It may fail when any of the inputs of the `node_js2c` target in\n   // node.gyp is modified but the tools/generate_code_cache.js\n   // is not re run.\n   // FIXME(joyeecheung): Figure out how to resolve the dependency issue.\n   // When the code cache was introduced we were at a point where refactoring\n   // node.gyp may not be worth the effort.\n-  CHECK(code_cache_hash->StrictEquals(source_hash));\n+  CHECK_EQ(code_cache_hash_value, source_hash_value);\n \n-  ArrayBuffer::Contents contents = code_cache->Buffer()->GetContents();\n-  uint8_t* data = static_cast<uint8_t*>(contents.Data());\n-  return new ScriptCompiler::CachedData(data + code_cache->ByteOffset(),\n-                                        code_cache->ByteLength());\n+  return new ScriptCompiler::CachedData(code_cache_value, code_cache_length);\n }\n \n // Returns Local<Function> of the compiled module if produce_code_cache\n // is false (we are only compiling the function).\n // Otherwise return a Local<Object> containing the cache.\n-Local<Value> NativeModule::Compile(Environment* env,\n-                                   Local<String> id,\n-                                   Local<String> parameters[],\n-                                   size_t parameters_count,\n-                                   bool produce_code_cache) {\n-  EscapableHandleScope scope(env->isolate());\n-  Local<Context> context = env->context();\n-  Isolate* isolate = env->isolate();\n+Local<Value> NativeModuleLoader::LookupAndCompile(Local<Context> context,\n+                                                  const char* id,\n+                                                  bool produce_code_cache,\n+                                                  Environment* optional_env) {\n+  Isolate* isolate = context->GetIsolate();\n+  EscapableHandleScope scope(isolate);\n \n-  Local<Value> result =\n-      env->native_modules_source()->Get(context, id).ToLocalChecked();\n-  CHECK(result->IsString());\n-  Local<String> source = result.As<String>();\n+  Local<String> source = GetSource(isolate, id);\n \n+  std::string filename_s = id + std::string(\".js\");\n   Local<String> filename =\n-      String::Concat(isolate, id, FIXED_ONE_BYTE_STRING(isolate, \".js\"));\n+      OneByteString(isolate, filename_s.c_str(), filename_s.size());\n   Local<Integer> line_offset = Integer::New(isolate, 0);\n   Local<Integer> column_offset = Integer::New(isolate, 0);\n   ScriptOrigin origin(filename, line_offset, column_offset);\n@@ -208,8 +209,8 @@ Local<Value> NativeModule::Compile(Environment* env,\n   //    built with them.\n   // 2. If we are generating code cache for tools/general_code_cache.js, we\n   //    are not going to use any cache ourselves.\n-  if (native_module_has_code_cache && !produce_code_cache) {\n-    cached_data = GetCachedData(env, id);\n+  if (has_code_cache_ && !produce_code_cache) {\n+    cached_data = GetCachedData(id);\n     if (cached_data != nullptr) {\n       use_cache = true;\n     }\n@@ -226,101 +227,100 @@ Local<Value> NativeModule::Compile(Environment* env,\n     options = ScriptCompiler::kNoCompileOptions;\n   }\n \n-  MaybeLocal<Function> maybe_fun =\n-      ScriptCompiler::CompileFunctionInContext(context,\n-                                               &script_source,\n-                                               parameters_count,\n-                                               parameters,\n-                                               0,\n-                                               nullptr,\n-                                               options);\n+  MaybeLocal<Function> maybe_fun;\n+  // Currently we assume if Environment is ready, then we must be compiling\n+  // native modules instead of bootstrappers.\n+  if (optional_env != nullptr) {\n+    Local<String> parameters[] = {optional_env->exports_string(),\n+                                  optional_env->require_string(),\n+                                  optional_env->module_string(),\n+                                  optional_env->process_string(),\n+                                  optional_env->internal_binding_string()};\n+    maybe_fun = ScriptCompiler::CompileFunctionInContext(context,\n+                                                         &script_source,\n+                                                         arraysize(parameters),\n+                                                         parameters,\n+                                                         0,\n+                                                         nullptr,\n+                                                         options);\n+  } else {\n+    // Until we migrate bootstrappers compilations here this is unreachable\n+    // TODO(joyeecheung): it should be possible to generate the argument names\n+    // from some special comments for the bootstrapper case.\n+    // Note that for bootstrappers we may not be able to get the argument\n+    // names as env->some_string() because we might be compiling before\n+    // those strings are initialized.\n+    UNREACHABLE();\n+  }\n \n-  TryCatch try_catch(isolate);\n   Local<Function> fun;\n   // This could fail when there are early errors in the native modules,\n   // e.g. the syntax errors\n   if (maybe_fun.IsEmpty() || !maybe_fun.ToLocal(&fun)) {\n-    DecorateErrorStack(env, try_catch);\n-    try_catch.ReThrow();\n+    // In the case of early errors, v8 is already capable of\n+    // decorating the stack for us - note that we use CompileFunctionInContext\n+    // so there is no need to worry about wrappers.\n     return scope.Escape(Local<Value>());\n   }\n \n   if (use_cache) {\n-    // If the cache is rejected, something must be wrong with the build\n-    // and we should just crash.\n-    CHECK(!script_source.GetCachedData()->rejected);\n-    if (env->native_modules_with_cache()->Add(context, id).IsEmpty()) {\n-      return scope.Escape(Local<Value>());\n+    if (optional_env != nullptr) {\n+      // This could happen when Node is run with any v8 flag, but\n+      // the cache is not generated with one\n+      if (script_source.GetCachedData()->rejected) {\n+        optional_env->native_modules_without_cache.insert(id);\n+      } else {\n+        optional_env->native_modules_with_cache.insert(id);\n+      }\n     }\n   } else {\n-    if (env->native_modules_without_cache()->Add(context, id).IsEmpty()) {\n-      return scope.Escape(Local<Value>());\n+    if (optional_env != nullptr) {\n+      optional_env->native_modules_without_cache.insert(id);\n     }\n   }\n \n   if (produce_code_cache) {\n     std::unique_ptr<ScriptCompiler::CachedData> cached_data(\n         ScriptCompiler::CreateCodeCacheForFunction(fun));\n     CHECK_NE(cached_data, nullptr);\n-    char* data =\n-        reinterpret_cast<char*>(const_cast<uint8_t*>(cached_data->data));\n-\n-    // Since we have no API to create a buffer from a new'ed pointer,\n-    // we will need to copy it - but this code path is only run by the\n-    // tooling that generates the code cache to be bundled in the binary\n+    size_t cached_data_length = cached_data->length;\n+    // Since we have no special allocator to create an ArrayBuffer\n+    // from a new'ed pointer, we will need to copy it - but this\n+    // code path is only run by the tooling that generates the code\n+    // cache to be bundled in the binary\n     // so it should be fine.\n-    Local<Object> buf =\n-        Buffer::Copy(env, data, cached_data->length).ToLocalChecked();\n-    return scope.Escape(buf);\n+    MallocedBuffer<uint8_t> copied(cached_data->length);\n+    memcpy(copied.data, cached_data->data, cached_data_length);\n+    Local<ArrayBuffer> buf =\n+        ArrayBuffer::New(isolate,\n+                         copied.release(),\n+                         cached_data_length,\n+                         ArrayBufferCreationMode::kInternalized);\n+    return scope.Escape(Uint8Array::New(buf, 0, cached_data_length));\n   } else {\n     return scope.Escape(fun);\n   }\n }\n \n-void Initialize(Local<Object> target,\n-                Local<Value> unused,\n-                Local<Context> context) {\n+void NativeModuleLoader::Initialize(Local<Object> target,\n+                                    Local<Value> unused,\n+                                    Local<Context> context) {\n   Environment* env = Environment::GetCurrent(context);\n \n-  target\n-      ->Set(context,\n-            FIXED_ONE_BYTE_STRING(env->isolate(), \"source\"),\n-            env->native_modules_source())\n-      .FromJust();\n-  target\n-      ->Set(context,\n-            FIXED_ONE_BYTE_STRING(env->isolate(), \"sourceHash\"),\n-            env->native_modules_source_hash())\n-      .FromJust();\n-  target\n-      ->Set(context,\n-            FIXED_ONE_BYTE_STRING(env->isolate(), \"codeCache\"),\n-            env->native_modules_code_cache())\n-      .FromJust();\n-  target\n-      ->Set(context,\n-            FIXED_ONE_BYTE_STRING(env->isolate(), \"codeCacheHash\"),\n-            env->native_modules_code_cache_hash())\n-      .FromJust();\n-  target\n-      ->Set(context,\n-            FIXED_ONE_BYTE_STRING(env->isolate(), \"compiledWithCache\"),\n-            env->native_modules_with_cache())\n-      .FromJust();\n-  target\n-      ->Set(context,\n-            FIXED_ONE_BYTE_STRING(env->isolate(), \"compiledWithoutCache\"),\n-            env->native_modules_without_cache())\n-      .FromJust();\n-\n-  env->SetMethod(target, \"compileFunction\", NativeModule::CompileFunction);\n-  env->SetMethod(target, \"compileCodeCache\", NativeModule::CompileCodeCache);\n+  env->SetMethod(\n+      target, \"getSource\", NativeModuleLoader::GetSourceObject);\n+  env->SetMethod(\n+      target, \"getCacheUsage\", NativeModuleLoader::GetCacheUsage);\n+  env->SetMethod(\n+      target, \"compileFunction\", NativeModuleLoader::CompileFunction);\n+  env->SetMethod(\n+      target, \"compileCodeCache\", NativeModuleLoader::CompileCodeCache);\n   // internalBinding('native_module') should be frozen\n   target->SetIntegrityLevel(context, IntegrityLevel::kFrozen).FromJust();\n }\n \n }  // namespace native_module\n }  // namespace node\n \n-NODE_MODULE_CONTEXT_AWARE_INTERNAL(native_module,\n-                                   node::native_module::Initialize)\n+NODE_MODULE_CONTEXT_AWARE_INTERNAL(\n+    native_module, node::native_module::NativeModuleLoader::Initialize)"
        },
        {
            "sha": "ad9343f1994630735fbce34ca117954f8483d7d5",
            "filename": "src/node_native_module.h",
            "status": "modified",
            "additions": 49,
            "deletions": 15,
            "changes": 64,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fnode_native_module.h",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fnode_native_module.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_native_module.h?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -3,34 +3,68 @@\n \n #if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n \n-#include \"node_internals.h\"\n+#include <map>\n+#include <set>\n+#include <string>\n+#include \"env.h\"\n+#include \"node_union_bytes.h\"\n+#include \"v8.h\"\n \n namespace node {\n namespace native_module {\n \n-// The native (C++) side of the native module compilation.\n+using NativeModuleRecordMap = std::map<std::string, UnionBytes>;\n+using NativeModuleHashMap = std::map<std::string, std::string>;\n \n-class NativeModule {\n+// The native (C++) side of the native module compilation.\n+// This class should not depend on Environment\n+class NativeModuleLoader {\n  public:\n-  // For legacy process.binding('natives') which is mutable\n-  static void GetNatives(Environment* env, v8::Local<v8::Object> exports);\n-  // Loads the static JavaScript source code and the cache into Environment\n-  static void LoadBindings(Environment* env);\n+  NativeModuleLoader();\n+  static void Initialize(v8::Local<v8::Object> target,\n+                         v8::Local<v8::Value> unused,\n+                         v8::Local<v8::Context> context);\n+  v8::Local<v8::Object> GetSourceObject(v8::Local<v8::Context> context) const;\n+  v8::Local<v8::String> GetSource(v8::Isolate* isolate, const char* id) const;\n+\n+ private:\n+  static void GetCacheUsage(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  // For legacy process.binding('natives') which is mutable, and for\n+  // internalBinding('native_module').source for internal use\n+  static void GetSourceObject(const v8::FunctionCallbackInfo<v8::Value>& args);\n   // Compile code cache for a specific native module\n   static void CompileCodeCache(const v8::FunctionCallbackInfo<v8::Value>& args);\n   // Compile a specific native module as a function\n   static void CompileFunction(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n- private:\n+  // Generated by tools/js2c.py as node_javascript.cc\n+  void LoadJavaScriptSource();  // Loads data into source_\n+  void LoadJavaScriptHash();    // Loads data into source_hash_\n+\n+  // Generated by tools/generate_code_cache.js as node_code_cache.cc when\n+  // the build is configured with --code-cache-path=.... They are noops\n+  // in node_code_cache_stub.cc\n+  void LoadCodeCache();      // Loads data into code_cache_\n+  void LoadCodeCacheHash();  // Loads data into code_cache_hash_\n+\n+  v8::ScriptCompiler::CachedData* GetCachedData(const char* id) const;\n   static v8::Local<v8::Value> CompileAsModule(Environment* env,\n-                                              v8::Local<v8::String> id,\n+                                              const char* id,\n                                               bool produce_code_cache);\n-  // TODO(joyeecheung): make this public and reuse it to compile bootstrappers\n-  static v8::Local<v8::Value> Compile(Environment* env,\n-                                      v8::Local<v8::String> id,\n-                                      v8::Local<v8::String> parameters[],\n-                                      size_t parameters_count,\n-                                      bool produce_code_cache);\n+  // TODO(joyeecheung): make this public and reuse it to compile bootstrappers.\n+  // For bootstrappers optional_env may be a nullptr.\n+  // This method magically knows what parameter it should pass to\n+  // the function to be compiled.\n+  v8::Local<v8::Value> LookupAndCompile(v8::Local<v8::Context> context,\n+                                        const char* id,\n+                                        bool produce_code_cache,\n+                                        Environment* optional_env);\n+\n+  bool has_code_cache_ = false;\n+  NativeModuleRecordMap source_;\n+  NativeModuleRecordMap code_cache_;\n+  NativeModuleHashMap source_hash_;\n+  NativeModuleHashMap code_cache_hash_;\n };\n \n }  // namespace native_module"
        },
        {
            "sha": "128bb11ed0d0abb45e0565c1103a8c9485222c41",
            "filename": "src/node_union_bytes.h",
            "status": "added",
            "additions": 93,
            "deletions": 0,
            "changes": 93,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fnode_union_bytes.h",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/src%2Fnode_union_bytes.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_union_bytes.h?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -0,0 +1,93 @@\n+\n+#ifndef SRC_NODE_UNION_BYTES_H_\n+#define SRC_NODE_UNION_BYTES_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+// A union of const uint8_t* or const uint16_t* data that can be\n+// turned into external v8::String when given an isolate.\n+\n+#include \"env.h\"\n+#include \"v8.h\"\n+\n+namespace node {\n+\n+class NonOwningExternalOneByteResource\n+    : public v8::String::ExternalOneByteStringResource {\n+ public:\n+  explicit NonOwningExternalOneByteResource(const uint8_t* data, size_t length)\n+      : data_(data), length_(length) {}\n+  ~NonOwningExternalOneByteResource() override = default;\n+\n+  const char* data() const override {\n+    return reinterpret_cast<const char*>(data_);\n+  }\n+  size_t length() const override { return length_; }\n+\n+ private:\n+  const uint8_t* data_;\n+  size_t length_;\n+  DISALLOW_COPY_AND_ASSIGN(NonOwningExternalOneByteResource);\n+};\n+\n+class NonOwningExternalTwoByteResource\n+    : public v8::String::ExternalStringResource {\n+ public:\n+  explicit NonOwningExternalTwoByteResource(const uint16_t* data, size_t length)\n+      : data_(data), length_(length) {}\n+  ~NonOwningExternalTwoByteResource() override = default;\n+\n+  const uint16_t* data() const override { return data_; }\n+  size_t length() const override { return length_; }\n+\n+ private:\n+  const uint16_t* data_;\n+  size_t length_;\n+  DISALLOW_COPY_AND_ASSIGN(NonOwningExternalTwoByteResource);\n+};\n+\n+// Similar to a v8::String, but it's independent from Isolates\n+// and can be materialized in Isolates as external Strings\n+// via ToStringChecked. The data pointers are owned by the caller.\n+class UnionBytes {\n+ public:\n+  UnionBytes(const uint16_t* data, size_t length)\n+      : is_one_byte_(false), two_bytes_(data), length_(length) {}\n+  UnionBytes(const uint8_t* data, size_t length)\n+      : is_one_byte_(true), one_bytes_(data), length_(length) {}\n+  bool is_one_byte() const { return is_one_byte_; }\n+  const uint16_t* two_bytes_data() const {\n+    CHECK(!is_one_byte_);\n+    return two_bytes_;\n+  }\n+  const uint8_t* one_bytes_data() const {\n+    CHECK(is_one_byte_);\n+    return one_bytes_;\n+  }\n+  v8::Local<v8::String> ToStringChecked(v8::Isolate* isolate) const {\n+    if (is_one_byte_) {\n+      NonOwningExternalOneByteResource* source =\n+          new NonOwningExternalOneByteResource(one_bytes_, length_);\n+      return v8::String::NewExternalOneByte(isolate, source).ToLocalChecked();\n+    } else {\n+      NonOwningExternalTwoByteResource* source =\n+          new NonOwningExternalTwoByteResource(two_bytes_, length_);\n+      return v8::String::NewExternalTwoByte(isolate, source).ToLocalChecked();\n+    }\n+  }\n+  size_t length() { return length_; }\n+\n+ private:\n+  bool is_one_byte_;\n+  union {\n+    const uint8_t* one_bytes_;\n+    const uint16_t* two_bytes_;\n+  };\n+  size_t length_;\n+};\n+\n+}  // namespace node\n+\n+#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#endif  // SRC_NODE_UNION_BYTES_H_"
        },
        {
            "sha": "b440d4e58c7c8895f68087a71113414fdfc9bd5d",
            "filename": "test/code-cache/test-code-cache-generator.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/test%2Fcode-cache%2Ftest-code-cache-generator.js",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/test%2Fcode-cache%2Ftest-code-cache-generator.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fcode-cache%2Ftest-code-cache-generator.js?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -30,10 +30,10 @@ if (child.status !== 0) {\n }\n \n // Verifies that:\n-// - node::DefineCodeCache()\n-// - node::DefineCodeCacheHash()\n+// - node::LoadCodeCache()\n+// - node::LoadCodeCacheHash()\n // are defined in the generated code.\n-// See src/node_code_cache_stub.cc for explanations.\n+// See src/node_native_module.h for explanations.\n \n const rl = readline.createInterface({\n   input: fs.createReadStream(dest),\n@@ -44,10 +44,10 @@ let hasCacheDef = false;\n let hasHashDef = false;\n \n rl.on('line', common.mustCallAtLeast((line) => {\n-  if (line.includes('DefineCodeCache(')) {\n+  if (line.includes('LoadCodeCache(')) {\n     hasCacheDef = true;\n   }\n-  if (line.includes('DefineCodeCacheHash(')) {\n+  if (line.includes('LoadCodeCacheHash(')) {\n     hasHashDef = true;\n   }\n }, 2));"
        },
        {
            "sha": "669e1367d60d538f03f08a1493e0d14de218368d",
            "filename": "test/code-cache/test-code-cache.js",
            "status": "modified",
            "additions": 12,
            "deletions": 3,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/test%2Fcode-cache%2Ftest-code-cache.js",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/test%2Fcode-cache%2Ftest-code-cache.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fcode-cache%2Ftest-code-cache.js?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -19,8 +19,7 @@ const {\n   internalBinding\n } = require('internal/test/binding');\n const {\n-  compiledWithoutCache,\n-  compiledWithCache\n+  getCacheUsage\n } = internalBinding('native_module');\n \n for (const key of cachableBuiltins) {\n@@ -30,6 +29,12 @@ for (const key of cachableBuiltins) {\n   require(key);\n }\n \n+// The computation has to be delayed until we have done loading modules\n+const {\n+  compiledWithoutCache,\n+  compiledWithCache\n+} = getCacheUsage();\n+\n const loadedModules = process.moduleLoadList\n   .filter((m) => m.startsWith('NativeModule'))\n   .map((m) => m.replace('NativeModule ', ''));\n@@ -39,7 +44,11 @@ const loadedModules = process.moduleLoadList\n if (process.config.variables.node_code_cache_path === undefined) {\n   console.log('The binary is not configured with code cache');\n   assert.deepStrictEqual(compiledWithCache, new Set());\n-  assert.deepStrictEqual(compiledWithoutCache, new Set(loadedModules));\n+\n+  for (const key of loadedModules) {\n+    assert(compiledWithoutCache.has(key),\n+           `\"${key}\" should've been compiled without code cache`);\n+  }\n } else {\n   console.log('The binary is configured with code cache');\n   assert.strictEqual("
        },
        {
            "sha": "b185f6246d0ef652c7ee930f1d469ea40e38e561",
            "filename": "tools/generate_code_cache.js",
            "status": "modified",
            "additions": 42,
            "deletions": 40,
            "changes": 82,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/tools%2Fgenerate_code_cache.js",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/tools%2Fgenerate_code_cache.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fgenerate_code_cache.js?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -13,6 +13,12 @@ const {\n   cachableBuiltins\n } = require('internal/bootstrap/cache');\n \n+const {\n+  types: {\n+    isUint8Array\n+  }\n+} = require('util');\n+\n function hash(str) {\n   if (process.versions.openssl) {\n     return require('crypto').createHash('sha256').update(str).digest('hex');\n@@ -52,29 +58,25 @@ function formatSize(num) {\n  * initializers of the code cache.\n  *\n  * @param {string} key ID of the builtin module\n- * @param {Buffer} cache Code cache of the builtin module\n+ * @param {Uint8Array} cache Code cache of the builtin module\n  * @return { definition: string, initializer: string }\n  */\n function getInitalizer(key, cache) {\n-  const defName = key.replace(/\\//g, '_').replace(/-/g, '_');\n-  const definition = `static uint8_t ${defName}_raw[] = {\\n` +\n+  const defName = `${key.replace(/\\//g, '_').replace(/-/g, '_')}_raw`;\n+  const definition = `static const uint8_t ${defName}[] = {\\n` +\n                      `${cache.join(',')}\\n};`;\n   const source = getSource(key);\n   const sourceHash = hash(source);\n-  const initializer = `\n-  v8::Local<v8::ArrayBuffer> ${defName}_ab =\n-    v8::ArrayBuffer::New(isolate, ${defName}_raw, ${cache.length});\n-  v8::Local<v8::Uint8Array> ${defName}_array =\n-    v8::Uint8Array::New(${defName}_ab, 0, ${cache.length});\n-  target->Set(context,\n-              FIXED_ONE_BYTE_STRING(isolate, \"${key}\"),\n-              ${defName}_array).FromJust();\n-  `;\n-  const hashIntializer = `\n-  target->Set(context,\n-              FIXED_ONE_BYTE_STRING(isolate, \"${key}\"),\n-              OneByteString(isolate, \"${sourceHash}\")).FromJust();\n-  `;\n+  const initializer =\n+    'code_cache_.emplace(\\n' +\n+    `  \"${key}\",\\n` +\n+    `  UnionBytes(${defName}, arraysize(${defName}))\\n` +\n+    ');';\n+  const hashIntializer =\n+    'code_cache_hash_.emplace(\\n' +\n+    `  \"${key}\",\\n` +\n+    `  \"${sourceHash}\"\\n` +\n+    ');';\n   return {\n     definition, initializer, hashIntializer, sourceHash\n   };\n@@ -85,55 +87,55 @@ const cacheInitializers = [];\n const cacheHashInitializers = [];\n let totalCacheSize = 0;\n \n+function lexical(a, b) {\n+  if (a < b) {\n+    return -1;\n+  }\n+  if (a > b) {\n+    return 1;\n+  }\n+  return 0;\n+}\n \n-for (const key of cachableBuiltins) {\n+for (const key of cachableBuiltins.sort(lexical)) {\n   const cachedData = getCodeCache(key);\n-  if (!cachedData.length) {\n+  if (!isUint8Array(cachedData)) {\n     console.error(`Failed to generate code cache for '${key}'`);\n     process.exit(1);\n   }\n \n-  const length = cachedData.length;\n-  totalCacheSize += length;\n+  const size = cachedData.byteLength;\n+  totalCacheSize += size;\n   const {\n     definition, initializer, hashIntializer, sourceHash\n   } = getInitalizer(key, cachedData);\n   cacheDefinitions.push(definition);\n   cacheInitializers.push(initializer);\n   cacheHashInitializers.push(hashIntializer);\n-  console.log(`Generated cache for '${key}', size = ${formatSize(length)}` +\n+  console.log(`Generated cache for '${key}', size = ${formatSize(size)}` +\n               `, hash = ${sourceHash}, total = ${formatSize(totalCacheSize)}`);\n }\n \n-const result = `#include \"node.h\"\n-#include \"node_code_cache.h\"\n-#include \"v8.h\"\n-#include \"env.h\"\n-#include \"env-inl.h\"\n+const result = `#include \"node_native_module.h\"\n+#include \"node_internals.h\"\n \n // This file is generated by tools/generate_code_cache.js\n // and is used when configure is run with \\`--code-cache-path\\`\n \n namespace node {\n-\n+namespace native_module {\n ${cacheDefinitions.join('\\n\\n')}\n \n-const bool native_module_has_code_cache = true;\n-\n-// The target here will be returned as \\`internalBinding('code_cache')\\`\n-void DefineCodeCache(Environment* env, v8::Local<v8::Object> target) {\n-  v8::Isolate* isolate = env->isolate();\n-  v8::Local<v8::Context> context = env->context();\n-  ${cacheInitializers.join('\\n')}\n+void NativeModuleLoader::LoadCodeCache() {\n+  has_code_cache_ = true;\n+  ${cacheInitializers.join('\\n  ')}\n }\n \n-// The target here will be returned as \\`internalBinding('code_cache_hash')\\`\n-void DefineCodeCacheHash(Environment* env, v8::Local<v8::Object> target) {\n-  v8::Isolate* isolate = env->isolate();\n-  v8::Local<v8::Context> context = env->context();\n-  ${cacheHashInitializers.join('\\n')}\n+void NativeModuleLoader::LoadCodeCacheHash() {\n+  ${cacheHashInitializers.join('\\n  ')}\n }\n \n+}  // namespace native_module\n }  // namespace node\n `;\n "
        },
        {
            "sha": "e01e385afcf75cd768f1de337020f67c939d7cb7",
            "filename": "tools/js2c.py",
            "status": "modified",
            "additions": 47,
            "deletions": 88,
            "changes": 135,
            "blob_url": "https://github.com/nodejs/node/blob/7778c035a0a3f9bbb988eb0298a026d80f423e03/tools%2Fjs2c.py",
            "raw_url": "https://github.com/nodejs/node/raw/7778c035a0a3f9bbb988eb0298a026d80f423e03/tools%2Fjs2c.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Fjs2c.py?ref=7778c035a0a3f9bbb988eb0298a026d80f423e03",
            "patch": "@@ -43,11 +43,6 @@ def ToCArray(elements, step=10):\n   slices = map(lambda s: ','.join(str(x) for x in s), slices)\n   return ',\\n'.join(slices)\n \n-\n-def ToCString(contents):\n-  return ToCArray(map(ord, contents), step=20)\n-\n-\n def ReadFile(filename):\n   file = open(filename, \"rt\")\n   try:\n@@ -176,79 +171,49 @@ def ReadMacros(lines):\n \n \n TEMPLATE = \"\"\"\n-#include \"node.h\"\n-#include \"node_javascript.h\"\n-#include \"v8.h\"\n-#include \"env.h\"\n-#include \"env-inl.h\"\n+#include \"node_native_module.h\"\n+#include \"node_internals.h\"\n \n namespace node {{\n \n-namespace {{\n+namespace native_module {{\n \n {definitions}\n \n-}}  // anonymous namespace\n-\n-v8::Local<v8::String> NodePerContextSource(v8::Isolate* isolate) {{\n-  return internal_per_context_value.ToStringChecked(isolate);\n-}}\n-\n-v8::Local<v8::String> LoadersBootstrapperSource(Environment* env) {{\n-  return internal_bootstrap_loaders_value.ToStringChecked(env->isolate());\n-}}\n-\n-v8::Local<v8::String> NodeBootstrapperSource(Environment* env) {{\n-  return internal_bootstrap_node_value.ToStringChecked(env->isolate());\n-}}\n-\n-void DefineJavaScript(Environment* env, v8::Local<v8::Object> target) {{\n+void NativeModuleLoader::LoadJavaScriptSource() {{\n   {initializers}\n }}\n \n-void DefineJavaScriptHash(Environment* env, v8::Local<v8::Object> target) {{\n+void NativeModuleLoader::LoadJavaScriptHash() {{\n   {hash_initializers}\n }}\n \n+}}  // namespace native_module\n+\n }}  // namespace node\n \"\"\"\n \n ONE_BYTE_STRING = \"\"\"\n-static const uint8_t raw_{var}[] = {{ {data} }};\n-static struct : public v8::String::ExternalOneByteStringResource {{\n-  const char* data() const override {{\n-    return reinterpret_cast<const char*>(raw_{var});\n-  }}\n-  size_t length() const override {{ return arraysize(raw_{var}); }}\n-  void Dispose() override {{ /* Default calls `delete this`. */ }}\n-  v8::Local<v8::String> ToStringChecked(v8::Isolate* isolate) {{\n-    return v8::String::NewExternalOneByte(isolate, this).ToLocalChecked();\n-  }}\n-}} {var};\n+static const uint8_t {var}[] = {{ {data} }};\n \"\"\"\n \n TWO_BYTE_STRING = \"\"\"\n-static const uint16_t raw_{var}[] = {{ {data} }};\n-static struct : public v8::String::ExternalStringResource {{\n-  const uint16_t* data() const override {{ return raw_{var}; }}\n-  size_t length() const override {{ return arraysize(raw_{var}); }}\n-  void Dispose() override {{ /* Default calls `delete this`. */ }}\n-  v8::Local<v8::String> ToStringChecked(v8::Isolate* isolate) {{\n-    return v8::String::NewExternalTwoByte(isolate, this).ToLocalChecked();\n-  }}\n-}} {var};\n+static const uint16_t {var}[] = {{ {data} }};\n \"\"\"\n \n-INITIALIZER = \"\"\"\\\n-CHECK(target->Set(env->context(),\n-                  {key}.ToStringChecked(env->isolate()),\n-                  {value}.ToStringChecked(env->isolate())).FromJust());\n+\n+INITIALIZER = \"\"\"\n+source_.emplace(\n+    \"{module}\",\n+    UnionBytes({var}, arraysize({var}))\n+);\n \"\"\"\n \n HASH_INITIALIZER = \"\"\"\\\n-CHECK(target->Set(env->context(),\n-                  FIXED_ONE_BYTE_STRING(env->isolate(), \"{key}\"),\n-                  FIXED_ONE_BYTE_STRING(env->isolate(), \"{value}\")).FromJust());\n+source_hash_.emplace(\n+    \"{module}\",\n+    \"{hash_value}\"\n+);\n \"\"\"\n \n DEPRECATED_DEPS = \"\"\"\\\n@@ -259,20 +224,6 @@ def ReadMacros(lines):\n module.exports = require('internal/deps/{module}');\n \"\"\"\n \n-\n-def Render(var, data):\n-  # Treat non-ASCII as UTF-8 and convert it to UTF-16.\n-  if any(ord(c) > 127 for c in data):\n-    template = TWO_BYTE_STRING\n-    data = map(ord, data.decode('utf-8').encode('utf-16be'))\n-    data = [data[i] * 256 + data[i+1] for i in xrange(0, len(data), 2)]\n-    data = ToCArray(data)\n-  else:\n-    template = ONE_BYTE_STRING\n-    data = ToCString(data)\n-  return template.format(var=var, data=data)\n-\n-\n def JS2C(source, target):\n   modules = []\n   consts = {}\n@@ -291,7 +242,29 @@ def JS2C(source, target):\n   # Build source code lines\n   definitions = []\n   initializers = []\n-  hash_initializers = [];\n+  hash_initializers = []\n+\n+  def AddModule(module, source):\n+    var = '%s_raw' % (module.replace('-', '_').replace('/', '_'))\n+    source_hash = hashlib.sha256(source).hexdigest()\n+\n+    # Treat non-ASCII as UTF-8 and convert it to UTF-16.\n+    if any(ord(c) > 127 for c in source):\n+      source = map(ord, source.decode('utf-8').encode('utf-16be'))\n+      source = [source[i] * 256 + source[i+1] for i in xrange(0, len(source), 2)]\n+      source = ToCArray(source)\n+      definition = TWO_BYTE_STRING.format(var=var, data=source)\n+    else:\n+      source = ToCArray(map(ord, source), step=20)\n+      definition = ONE_BYTE_STRING.format(var=var, data=source)\n+\n+    initializer = INITIALIZER.format(module=module,\n+                                     var=var)\n+    hash_initializer = HASH_INITIALIZER.format(module=module,\n+                                               hash_value=source_hash)\n+    definitions.append(definition)\n+    initializers.append(initializer)\n+    hash_initializers.append(hash_initializer)\n \n   for name in modules:\n     lines = ReadFile(str(name))\n@@ -317,28 +290,14 @@ def JS2C(source, target):\n     if name.endswith(\".gypi\"):\n       lines = re.sub(r'#.*?\\n', '', lines)\n       lines = re.sub(r'\\'', '\"', lines)\n-    name = name.split('.', 1)[0]\n-    var = name.replace('-', '_').replace('/', '_')\n-    key = '%s_key' % var\n-    value = '%s_value' % var\n-    hash_value = hashlib.sha256(lines).hexdigest()\n \n-    definitions.append(Render(key, name))\n-    definitions.append(Render(value, lines))\n-    initializers.append(INITIALIZER.format(key=key, value=value))\n-    hash_initializers.append(HASH_INITIALIZER.format(key=name, value=hash_value))\n+    AddModule(name.split('.', 1)[0], lines)\n \n+    # Add deprecated aliases for deps without 'deps/'\n     if deprecated_deps is not None:\n-      name = '/'.join(deprecated_deps)\n-      name = name.split('.', 1)[0]\n-      var = name.replace('-', '_').replace('/', '_')\n-      key = '%s_key' % var\n-      value = '%s_value' % var\n-\n-      definitions.append(Render(key, name))\n-      definitions.append(Render(value, DEPRECATED_DEPS.format(module=name)))\n-      initializers.append(INITIALIZER.format(key=key, value=value))\n-      hash_initializers.append(HASH_INITIALIZER.format(key=name, value=hash_value))\n+      module = '/'.join(deprecated_deps).split('.', 1)[0]\n+      source = DEPRECATED_DEPS.format(module=module)\n+      AddModule(module, source)\n \n   # Emit result\n   output = open(str(target[0]), \"w\")"
        }
    ],
    "stats": {
        "total": 876,
        "additions": 457,
        "deletions": 419
    }
}