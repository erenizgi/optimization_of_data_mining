{
    "author": "addaleax",
    "message": "zlib: reduce number of static internal methods\n\nThere really isnâ€™t any good reason for these to be static methods,\nit just adds one layer of indirection (when reading the code,\nnot in a way that affects behaviour).\n\nAddresses a `TODO` comment introduced in c072057049.\n\nPR-URL: https://github.com/nodejs/node/pull/20674\nRefs: https://github.com/nodejs/node/commit/c0720570498895d06dcec4e8f01e8922a81ac78b\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "2b8cd93246a87378167d7d25a7d90fabbd235590",
    "files": [
        {
            "sha": "632dad1f8110be741b224287abd8f20cd7c3c6df",
            "filename": "src/node_zlib.cc",
            "status": "modified",
            "additions": 74,
            "deletions": 88,
            "changes": 162,
            "blob_url": "https://github.com/nodejs/node/blob/2b8cd93246a87378167d7d25a7d90fabbd235590/src%2Fnode_zlib.cc",
            "raw_url": "https://github.com/nodejs/node/raw/2b8cd93246a87378167d7d25a7d90fabbd235590/src%2Fnode_zlib.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_zlib.cc?ref=2b8cd93246a87378167d7d25a7d90fabbd235590",
            "patch": "@@ -202,7 +202,7 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n       // sync version\n       env->PrintSyncTrace();\n       ctx->DoThreadPoolWork();\n-      if (CheckError(ctx)) {\n+      if (ctx->CheckError()) {\n         ctx->write_result_[0] = ctx->strm_.avail_out;\n         ctx->write_result_[1] = ctx->strm_.avail_in;\n         ctx->write_in_progress_ = false;\n@@ -215,53 +215,43 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n     ctx->ScheduleWork();\n   }\n \n-  // TODO(addaleax): Make these methods non-static. It's a significant bunch\n-  // of churn that's better left for a separate PR.\n-  void DoThreadPoolWork() override {\n-    Process(this);\n-  }\n-\n-  void AfterThreadPoolWork(int status) override {\n-    After(this, status);\n-  }\n-\n   // thread pool!\n   // This function may be called multiple times on the uv_work pool\n   // for a single write() call, until all of the input bytes have\n   // been consumed.\n-  static void Process(ZCtx* ctx) {\n+  void DoThreadPoolWork() {\n     const Bytef* next_expected_header_byte = nullptr;\n \n     // If the avail_out is left at 0, then it means that it ran out\n     // of room.  If there was avail_out left over, then it means\n     // that all of the input was consumed.\n-    switch (ctx->mode_) {\n+    switch (mode_) {\n       case DEFLATE:\n       case GZIP:\n       case DEFLATERAW:\n-        ctx->err_ = deflate(&ctx->strm_, ctx->flush_);\n+        err_ = deflate(&strm_, flush_);\n         break;\n       case UNZIP:\n-        if (ctx->strm_.avail_in > 0) {\n-          next_expected_header_byte = ctx->strm_.next_in;\n+        if (strm_.avail_in > 0) {\n+          next_expected_header_byte = strm_.next_in;\n         }\n \n-        switch (ctx->gzip_id_bytes_read_) {\n+        switch (gzip_id_bytes_read_) {\n           case 0:\n             if (next_expected_header_byte == nullptr) {\n               break;\n             }\n \n             if (*next_expected_header_byte == GZIP_HEADER_ID1) {\n-              ctx->gzip_id_bytes_read_ = 1;\n+              gzip_id_bytes_read_ = 1;\n               next_expected_header_byte++;\n \n-              if (ctx->strm_.avail_in == 1) {\n+              if (strm_.avail_in == 1) {\n                 // The only available byte was already read.\n                 break;\n               }\n             } else {\n-              ctx->mode_ = INFLATE;\n+              mode_ = INFLATE;\n               break;\n             }\n \n@@ -272,12 +262,12 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n             }\n \n             if (*next_expected_header_byte == GZIP_HEADER_ID2) {\n-              ctx->gzip_id_bytes_read_ = 2;\n-              ctx->mode_ = GUNZIP;\n+              gzip_id_bytes_read_ = 2;\n+              mode_ = GUNZIP;\n             } else {\n               // There is no actual difference between INFLATE and INFLATERAW\n               // (after initialization).\n-              ctx->mode_ = INFLATE;\n+              mode_ = INFLATE;\n             }\n \n             break;\n@@ -289,39 +279,37 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n       case INFLATE:\n       case GUNZIP:\n       case INFLATERAW:\n-        ctx->err_ = inflate(&ctx->strm_, ctx->flush_);\n+        err_ = inflate(&strm_, flush_);\n \n         // If data was encoded with dictionary (INFLATERAW will have it set in\n         // SetDictionary, don't repeat that here)\n-        if (ctx->mode_ != INFLATERAW &&\n-            ctx->err_ == Z_NEED_DICT &&\n-            ctx->dictionary_ != nullptr) {\n+        if (mode_ != INFLATERAW &&\n+            err_ == Z_NEED_DICT &&\n+            dictionary_ != nullptr) {\n           // Load it\n-          ctx->err_ = inflateSetDictionary(&ctx->strm_,\n-                                           ctx->dictionary_,\n-                                           ctx->dictionary_len_);\n-          if (ctx->err_ == Z_OK) {\n+          err_ = inflateSetDictionary(&strm_, dictionary_, dictionary_len_);\n+          if (err_ == Z_OK) {\n             // And try to decode again\n-            ctx->err_ = inflate(&ctx->strm_, ctx->flush_);\n-          } else if (ctx->err_ == Z_DATA_ERROR) {\n+            err_ = inflate(&strm_, flush_);\n+          } else if (err_ == Z_DATA_ERROR) {\n             // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.\n             // Make it possible for After() to tell a bad dictionary from bad\n             // input.\n-            ctx->err_ = Z_NEED_DICT;\n+            err_ = Z_NEED_DICT;\n           }\n         }\n \n-        while (ctx->strm_.avail_in > 0 &&\n-               ctx->mode_ == GUNZIP &&\n-               ctx->err_ == Z_STREAM_END &&\n-               ctx->strm_.next_in[0] != 0x00) {\n+        while (strm_.avail_in > 0 &&\n+               mode_ == GUNZIP &&\n+               err_ == Z_STREAM_END &&\n+               strm_.next_in[0] != 0x00) {\n           // Bytes remain in input buffer. Perhaps this is another compressed\n           // member in the same archive, or just trailing garbage.\n           // Trailing zero bytes are okay, though, since they are frequently\n           // used for padding.\n \n-          Reset(ctx);\n-          ctx->err_ = inflate(&ctx->strm_, ctx->flush_);\n+          Reset();\n+          err_ = inflate(&strm_, flush_);\n         }\n         break;\n       default:\n@@ -336,27 +324,27 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n   }\n \n \n-  static bool CheckError(ZCtx* ctx) {\n+  bool CheckError() {\n     // Acceptable error states depend on the type of zlib stream.\n-    switch (ctx->err_) {\n+    switch (err_) {\n     case Z_OK:\n     case Z_BUF_ERROR:\n-      if (ctx->strm_.avail_out != 0 && ctx->flush_ == Z_FINISH) {\n-        ZCtx::Error(ctx, \"unexpected end of file\");\n+      if (strm_.avail_out != 0 && flush_ == Z_FINISH) {\n+        Error(\"unexpected end of file\");\n         return false;\n       }\n     case Z_STREAM_END:\n       // normal statuses, not fatal\n       break;\n     case Z_NEED_DICT:\n-      if (ctx->dictionary_ == nullptr)\n-        ZCtx::Error(ctx, \"Missing dictionary\");\n+      if (dictionary_ == nullptr)\n+        Error(\"Missing dictionary\");\n       else\n-        ZCtx::Error(ctx, \"Bad dictionary\");\n+        Error(\"Bad dictionary\");\n       return false;\n     default:\n       // something else.\n-      ZCtx::Error(ctx, \"Zlib error\");\n+      Error(\"Zlib error\");\n       return false;\n     }\n \n@@ -365,59 +353,57 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n \n \n   // v8 land!\n-  static void After(ZCtx* ctx, int status) {\n-    Environment* env = ctx->env();\n-    ctx->write_in_progress_ = false;\n+  void AfterThreadPoolWork(int status) {\n+    write_in_progress_ = false;\n \n     if (status == UV_ECANCELED) {\n-      ctx->Close();\n+      Close();\n       return;\n     }\n \n     CHECK_EQ(status, 0);\n \n-    HandleScope handle_scope(env->isolate());\n-    Context::Scope context_scope(env->context());\n+    HandleScope handle_scope(env()->isolate());\n+    Context::Scope context_scope(env()->context());\n \n-    if (!CheckError(ctx))\n+    if (!CheckError())\n       return;\n \n-    ctx->write_result_[0] = ctx->strm_.avail_out;\n-    ctx->write_result_[1] = ctx->strm_.avail_in;\n+    write_result_[0] = strm_.avail_out;\n+    write_result_[1] = strm_.avail_in;\n \n     // call the write() cb\n-    Local<Function> cb = PersistentToLocal(env->isolate(),\n-                                           ctx->write_js_callback_);\n-    ctx->MakeCallback(cb, 0, nullptr);\n+    Local<Function> cb = PersistentToLocal(env()->isolate(),\n+                                           write_js_callback_);\n+    MakeCallback(cb, 0, nullptr);\n \n-    ctx->Unref();\n-    if (ctx->pending_close_)\n-      ctx->Close();\n+    Unref();\n+    if (pending_close_)\n+      Close();\n   }\n \n-  static void Error(ZCtx* ctx, const char* message) {\n-    Environment* env = ctx->env();\n-\n+  // TODO(addaleax): Switch to modern error system (node_errors.h).\n+  void Error(const char* message) {\n     // If you hit this assertion, you forgot to enter the v8::Context first.\n-    CHECK_EQ(env->context(), env->isolate()->GetCurrentContext());\n+    CHECK_EQ(env()->context(), env()->isolate()->GetCurrentContext());\n \n-    if (ctx->strm_.msg != nullptr) {\n-      message = ctx->strm_.msg;\n+    if (strm_.msg != nullptr) {\n+      message = strm_.msg;\n     }\n \n-    HandleScope scope(env->isolate());\n+    HandleScope scope(env()->isolate());\n     Local<Value> args[2] = {\n-      OneByteString(env->isolate(), message),\n-      Number::New(env->isolate(), ctx->err_)\n+      OneByteString(env()->isolate(), message),\n+      Number::New(env()->isolate(), err_)\n     };\n-    ctx->MakeCallback(env->onerror_string(), arraysize(args), args);\n+    MakeCallback(env()->onerror_string(), arraysize(args), args);\n \n     // no hope of rescue.\n-    if (ctx->write_in_progress_)\n-      ctx->Unref();\n-    ctx->write_in_progress_ = false;\n-    if (ctx->pending_close_)\n-      ctx->Close();\n+    if (write_in_progress_)\n+      Unref();\n+    write_in_progress_ = false;\n+    if (pending_close_)\n+      Close();\n   }\n \n   static void New(const FunctionCallbackInfo<Value>& args) {\n@@ -510,7 +496,7 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n   static void Reset(const FunctionCallbackInfo<Value> &args) {\n     ZCtx* ctx;\n     ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());\n-    Reset(ctx);\n+    ctx->Reset();\n     SetDictionary(ctx);\n   }\n \n@@ -613,7 +599,7 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n     }\n \n     if (ctx->err_ != Z_OK) {\n-      ZCtx::Error(ctx, \"Failed to set dictionary\");\n+      ctx->Error(\"Failed to set dictionary\");\n     }\n   }\n \n@@ -630,30 +616,30 @@ class ZCtx : public AsyncWrap, public ThreadPoolWork {\n     }\n \n     if (ctx->err_ != Z_OK && ctx->err_ != Z_BUF_ERROR) {\n-      ZCtx::Error(ctx, \"Failed to set parameters\");\n+      ctx->Error(\"Failed to set parameters\");\n     }\n   }\n \n-  static void Reset(ZCtx* ctx) {\n-    ctx->err_ = Z_OK;\n+  void Reset() {\n+    err_ = Z_OK;\n \n-    switch (ctx->mode_) {\n+    switch (mode_) {\n       case DEFLATE:\n       case DEFLATERAW:\n       case GZIP:\n-        ctx->err_ = deflateReset(&ctx->strm_);\n+        err_ = deflateReset(&strm_);\n         break;\n       case INFLATE:\n       case INFLATERAW:\n       case GUNZIP:\n-        ctx->err_ = inflateReset(&ctx->strm_);\n+        err_ = inflateReset(&strm_);\n         break;\n       default:\n         break;\n     }\n \n-    if (ctx->err_ != Z_OK) {\n-      ZCtx::Error(ctx, \"Failed to reset stream\");\n+    if (err_ != Z_OK) {\n+      Error(\"Failed to reset stream\");\n     }\n   }\n "
        }
    ],
    "stats": {
        "total": 162,
        "additions": 74,
        "deletions": 88
    }
}