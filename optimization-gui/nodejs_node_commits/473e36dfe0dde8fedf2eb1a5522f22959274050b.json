{
    "author": "targos",
    "message": "deps: patch V8 to 6.7.288.45\n\nRefs: https://github.com/v8/v8/compare/6.7.288.44...6.7.288.45\n\nPR-URL: https://github.com/nodejs/node/pull/21192\nReviewed-By: Ali Ijaz Sheikh <ofrobots@google.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "473e36dfe0dde8fedf2eb1a5522f22959274050b",
    "files": [
        {
            "sha": "649deb515aa395d1d632f0a4a674297c3651b17c",
            "filename": "deps/v8/include/v8-version.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/473e36dfe0dde8fedf2eb1a5522f22959274050b/deps%2Fv8%2Finclude%2Fv8-version.h",
            "raw_url": "https://github.com/nodejs/node/raw/473e36dfe0dde8fedf2eb1a5522f22959274050b/deps%2Fv8%2Finclude%2Fv8-version.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finclude%2Fv8-version.h?ref=473e36dfe0dde8fedf2eb1a5522f22959274050b",
            "patch": "@@ -11,7 +11,7 @@\n #define V8_MAJOR_VERSION 6\n #define V8_MINOR_VERSION 7\n #define V8_BUILD_NUMBER 288\n-#define V8_PATCH_LEVEL 44\n+#define V8_PATCH_LEVEL 45\n \n // Use 1 for candidates and 0 otherwise.\n // (Boolean macro values are not supported by all preprocessors.)"
        },
        {
            "sha": "ab77238a77f97fc3098b44e36dcc0014c69914db",
            "filename": "deps/v8/include/v8.h",
            "status": "modified",
            "additions": 11,
            "deletions": 2,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/473e36dfe0dde8fedf2eb1a5522f22959274050b/deps%2Fv8%2Finclude%2Fv8.h",
            "raw_url": "https://github.com/nodejs/node/raw/473e36dfe0dde8fedf2eb1a5522f22959274050b/deps%2Fv8%2Finclude%2Fv8.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finclude%2Fv8.h?ref=473e36dfe0dde8fedf2eb1a5522f22959274050b",
            "patch": "@@ -9071,6 +9071,7 @@ class Internals {\n   static const int kNodeStateIsWeakValue = 2;\n   static const int kNodeStateIsPendingValue = 3;\n   static const int kNodeStateIsNearDeathValue = 4;\n+  static const int kNodeIsIndependentShift = 3;\n   static const int kNodeIsActiveShift = 4;\n \n   static const int kFirstNonstringType = 0x80;\n@@ -9294,7 +9295,10 @@ void Persistent<T, M>::Copy(const Persistent<S, M2>& that) {\n \n template <class T>\n bool PersistentBase<T>::IsIndependent() const {\n-  return true;\n+  typedef internal::Internals I;\n+  if (this->IsEmpty()) return false;\n+  return I::GetNodeFlag(reinterpret_cast<internal::Object**>(this->val_),\n+                        I::kNodeIsIndependentShift);\n }\n \n template <class T>\n@@ -9383,7 +9387,12 @@ void PersistentBase<T>::RegisterExternalReference(Isolate* isolate) const {\n }\n \n template <class T>\n-void PersistentBase<T>::MarkIndependent() {}\n+void PersistentBase<T>::MarkIndependent() {\n+  typedef internal::Internals I;\n+  if (this->IsEmpty()) return;\n+  I::UpdateNodeFlag(reinterpret_cast<internal::Object**>(this->val_), true,\n+                    I::kNodeIsIndependentShift);\n+}\n \n template <class T>\n void PersistentBase<T>::MarkActive() {"
        },
        {
            "sha": "0e9b678ceb7eb8a0b6c7ff1b553e13b0bd35d1a1",
            "filename": "deps/v8/src/global-handles.cc",
            "status": "modified",
            "additions": 42,
            "deletions": 13,
            "changes": 55,
            "blob_url": "https://github.com/nodejs/node/blob/473e36dfe0dde8fedf2eb1a5522f22959274050b/deps%2Fv8%2Fsrc%2Fglobal-handles.cc",
            "raw_url": "https://github.com/nodejs/node/raw/473e36dfe0dde8fedf2eb1a5522f22959274050b/deps%2Fv8%2Fsrc%2Fglobal-handles.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fglobal-handles.cc?ref=473e36dfe0dde8fedf2eb1a5522f22959274050b",
            "patch": "@@ -41,6 +41,8 @@ class GlobalHandles::Node {\n     STATIC_ASSERT(WEAK == Internals::kNodeStateIsWeakValue);\n     STATIC_ASSERT(PENDING == Internals::kNodeStateIsPendingValue);\n     STATIC_ASSERT(NEAR_DEATH == Internals::kNodeStateIsNearDeathValue);\n+    STATIC_ASSERT(static_cast<int>(IsIndependent::kShift) ==\n+                  Internals::kNodeIsIndependentShift);\n     STATIC_ASSERT(static_cast<int>(IsActive::kShift) ==\n                   Internals::kNodeIsActiveShift);\n   }\n@@ -52,6 +54,7 @@ class GlobalHandles::Node {\n     object_ = reinterpret_cast<Object*>(kGlobalHandleZapValue);\n     class_id_ = v8::HeapProfiler::kPersistentHandleNoClassId;\n     index_ = 0;\n+    set_independent(false);\n     set_active(false);\n     set_in_new_space_list(false);\n     data_.next_free = nullptr;\n@@ -73,6 +76,7 @@ class GlobalHandles::Node {\n     DCHECK(state() == FREE);\n     object_ = object;\n     class_id_ = v8::HeapProfiler::kPersistentHandleNoClassId;\n+    set_independent(false);\n     set_active(false);\n     set_state(NORMAL);\n     data_.parameter = nullptr;\n@@ -92,6 +96,7 @@ class GlobalHandles::Node {\n     // Zap the values for eager trapping.\n     object_ = reinterpret_cast<Object*>(kGlobalHandleZapValue);\n     class_id_ = v8::HeapProfiler::kPersistentHandleNoClassId;\n+    set_independent(false);\n     set_active(false);\n     weak_callback_ = nullptr;\n     DecreaseBlockUses();\n@@ -119,6 +124,9 @@ class GlobalHandles::Node {\n     flags_ = NodeState::update(flags_, state);\n   }\n \n+  bool is_independent() { return IsIndependent::decode(flags_); }\n+  void set_independent(bool v) { flags_ = IsIndependent::update(flags_, v); }\n+\n   bool is_active() {\n     return IsActive::decode(flags_);\n   }\n@@ -183,6 +191,12 @@ class GlobalHandles::Node {\n     set_state(PENDING);\n   }\n \n+  // Independent flag accessors.\n+  void MarkIndependent() {\n+    DCHECK(IsInUse());\n+    set_independent(true);\n+  }\n+\n   // Callback parameter accessors.\n   void set_parameter(void* parameter) {\n     DCHECK(IsInUse());\n@@ -330,7 +344,7 @@ class GlobalHandles::Node {\n   // Placed first to avoid offset computation.\n   Object* object_;\n \n-  // Next word stores class_id, index, and state.\n+  // Next word stores class_id, index, state, and independent.\n   // Note: the most aligned fields should go first.\n \n   // Wrapper class ID.\n@@ -339,7 +353,10 @@ class GlobalHandles::Node {\n   // Index in the containing handle block.\n   uint8_t index_;\n \n+  // This stores three flags (independent, partially_dependent and\n+  // in_new_space_list) and a State.\n   class NodeState : public BitField<State, 0, 3> {};\n+  class IsIndependent : public BitField<bool, 3, 1> {};\n   // The following two fields are mutually exclusive\n   class IsActive : public BitField<bool, 4, 1> {};\n   class IsInNewSpaceList : public BitField<bool, 5, 1> {};\n@@ -591,6 +608,14 @@ void GlobalHandles::AnnotateStrongRetainer(Object** location,\n   Node::FromLocation(location)->AnnotateStrongRetainer(label);\n }\n \n+void GlobalHandles::MarkIndependent(Object** location) {\n+  Node::FromLocation(location)->MarkIndependent();\n+}\n+\n+bool GlobalHandles::IsIndependent(Object** location) {\n+  return Node::FromLocation(location)->is_independent();\n+}\n+\n bool GlobalHandles::IsNearDeath(Object** location) {\n   return Node::FromLocation(location)->IsNearDeath();\n }\n@@ -647,7 +672,8 @@ void GlobalHandles::IdentifyWeakHandles(WeakSlotCallback should_reset_handle) {\n void GlobalHandles::IterateNewSpaceStrongAndDependentRoots(RootVisitor* v) {\n   for (Node* node : new_space_nodes_) {\n     if (node->IsStrongRetainer() ||\n-        (node->IsWeakRetainer() && node->is_active())) {\n+        (node->IsWeakRetainer() && !node->is_independent() &&\n+         node->is_active())) {\n       v->VisitRootPointer(Root::kGlobalHandles, node->label(),\n                           node->location());\n     }\n@@ -662,7 +688,8 @@ void GlobalHandles::IterateNewSpaceStrongAndDependentRootsAndIdentifyUnmodified(\n       node->set_active(true);\n     }\n     if (node->IsStrongRetainer() ||\n-        (node->IsWeakRetainer() && node->is_active())) {\n+        (node->IsWeakRetainer() && !node->is_independent() &&\n+         node->is_active())) {\n       v->VisitRootPointer(Root::kGlobalHandles, node->label(),\n                           node->location());\n     }\n@@ -682,8 +709,8 @@ void GlobalHandles::MarkNewSpaceWeakUnmodifiedObjectsPending(\n     WeakSlotCallbackWithHeap is_dead) {\n   for (Node* node : new_space_nodes_) {\n     DCHECK(node->is_in_new_space_list());\n-    if (node->IsWeak() && is_dead(isolate_->heap(), node->location())) {\n-      DCHECK(!node->is_active());\n+    if ((node->is_independent() || !node->is_active()) && node->IsWeak() &&\n+        is_dead(isolate_->heap(), node->location())) {\n       if (!node->IsPhantomCallback() && !node->IsPhantomResetHandle()) {\n         node->MarkPending();\n       }\n@@ -695,8 +722,8 @@ void GlobalHandles::IterateNewSpaceWeakUnmodifiedRootsForFinalizers(\n     RootVisitor* v) {\n   for (Node* node : new_space_nodes_) {\n     DCHECK(node->is_in_new_space_list());\n-    if (!node->is_active() && node->IsWeakRetainer() &&\n-        (node->state() == Node::PENDING)) {\n+    if ((node->is_independent() || !node->is_active()) &&\n+        node->IsWeakRetainer() && (node->state() == Node::PENDING)) {\n       DCHECK(!node->IsPhantomCallback());\n       DCHECK(!node->IsPhantomResetHandle());\n       // Finalizers need to survive.\n@@ -710,8 +737,8 @@ void GlobalHandles::IterateNewSpaceWeakUnmodifiedRootsForPhantomHandles(\n     RootVisitor* v, WeakSlotCallbackWithHeap should_reset_handle) {\n   for (Node* node : new_space_nodes_) {\n     DCHECK(node->is_in_new_space_list());\n-    if (!node->is_active() && node->IsWeakRetainer() &&\n-        (node->state() != Node::PENDING)) {\n+    if ((node->is_independent() || !node->is_active()) &&\n+        node->IsWeakRetainer() && (node->state() != Node::PENDING)) {\n       DCHECK(node->IsPhantomResetHandle() || node->IsPhantomCallback());\n       if (should_reset_handle(isolate_->heap(), node->location())) {\n         if (node->IsPhantomResetHandle()) {\n@@ -757,12 +784,15 @@ int GlobalHandles::PostScavengeProcessing(\n       // the freed_nodes.\n       continue;\n     }\n-\n-    // Active nodes are kept alive, so no further processing is requires.\n-    if (node->is_active()) {\n+    // Skip dependent or unmodified handles. Their weak callbacks might expect\n+    // to be\n+    // called between two global garbage collection callbacks which\n+    // are not called for minor collections.\n+    if (!node->is_independent() && (node->is_active())) {\n       node->set_active(false);\n       continue;\n     }\n+    node->set_active(false);\n \n     if (node->PostGarbageCollectionProcessing(isolate_)) {\n       if (initial_post_gc_processing_count != post_gc_processing_count_) {\n@@ -773,7 +803,6 @@ int GlobalHandles::PostScavengeProcessing(\n         return freed_nodes;\n       }\n     }\n-\n     if (!node->IsRetainer()) {\n       freed_nodes++;\n     }"
        },
        {
            "sha": "2c2fbbd3f95e9757f3d13a9ce6a5b30839feff94",
            "filename": "deps/v8/src/global-handles.h",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/473e36dfe0dde8fedf2eb1a5522f22959274050b/deps%2Fv8%2Fsrc%2Fglobal-handles.h",
            "raw_url": "https://github.com/nodejs/node/raw/473e36dfe0dde8fedf2eb1a5522f22959274050b/deps%2Fv8%2Fsrc%2Fglobal-handles.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fglobal-handles.h?ref=473e36dfe0dde8fedf2eb1a5522f22959274050b",
            "patch": "@@ -99,6 +99,11 @@ class GlobalHandles {\n   // Clear the weakness of a global handle.\n   static void* ClearWeakness(Object** location);\n \n+  // Mark the reference to this object independent.\n+  static void MarkIndependent(Object** location);\n+\n+  static bool IsIndependent(Object** location);\n+\n   // Tells whether global handle is near death.\n   static bool IsNearDeath(Object** location);\n \n@@ -155,7 +160,8 @@ class GlobalHandles {\n   void MarkNewSpaceWeakUnmodifiedObjectsPending(\n       WeakSlotCallbackWithHeap is_dead);\n \n-  // Iterates over weak unmodified handles. See the note above.\n+  // Iterates over weak independent or unmodified handles.\n+  // See the note above.\n   void IterateNewSpaceWeakUnmodifiedRootsForFinalizers(RootVisitor* v);\n   void IterateNewSpaceWeakUnmodifiedRootsForPhantomHandles(\n       RootVisitor* v, WeakSlotCallbackWithHeap should_reset_handle);"
        },
        {
            "sha": "734c2ea36d727372265a679067b291f45c90386c",
            "filename": "deps/v8/src/profiler/sampling-heap-profiler.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/473e36dfe0dde8fedf2eb1a5522f22959274050b/deps%2Fv8%2Fsrc%2Fprofiler%2Fsampling-heap-profiler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/473e36dfe0dde8fedf2eb1a5522f22959274050b/deps%2Fv8%2Fsrc%2Fprofiler%2Fsampling-heap-profiler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fprofiler%2Fsampling-heap-profiler.cc?ref=473e36dfe0dde8fedf2eb1a5522f22959274050b",
            "patch": "@@ -99,6 +99,7 @@ void SamplingHeapProfiler::SampleObject(Address soon_object, size_t size) {\n   Sample* sample = new Sample(size, node, loc, this);\n   samples_.emplace(sample);\n   sample->global.SetWeak(sample, OnWeakCallback, WeakCallbackType::kParameter);\n+  sample->global.MarkIndependent();\n }\n \n void SamplingHeapProfiler::OnWeakCallback("
        },
        {
            "sha": "d698c1a9e008a49e5224c1d6e9ba3c18cb3d20db",
            "filename": "deps/v8/test/cctest/test-api.cc",
            "status": "modified",
            "additions": 193,
            "deletions": 0,
            "changes": 193,
            "blob_url": "https://github.com/nodejs/node/blob/473e36dfe0dde8fedf2eb1a5522f22959274050b/deps%2Fv8%2Ftest%2Fcctest%2Ftest-api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/473e36dfe0dde8fedf2eb1a5522f22959274050b/deps%2Fv8%2Ftest%2Fcctest%2Ftest-api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftest%2Fcctest%2Ftest-api.cc?ref=473e36dfe0dde8fedf2eb1a5522f22959274050b",
            "patch": "@@ -7807,6 +7807,80 @@ struct FlagAndPersistent {\n   v8::Global<v8::Object> handle;\n };\n \n+static void SetFlag(const v8::WeakCallbackInfo<FlagAndPersistent>& data) {\n+  data.GetParameter()->flag = true;\n+  data.GetParameter()->handle.Reset();\n+}\n+\n+static void IndependentWeakHandle(bool global_gc, bool interlinked) {\n+  i::FLAG_stress_incremental_marking = false;\n+  // Parallel scavenge introduces too much fragmentation.\n+  i::FLAG_parallel_scavenge = false;\n+  v8::Isolate* iso = CcTest::isolate();\n+  v8::HandleScope scope(iso);\n+  v8::Local<Context> context = Context::New(iso);\n+  Context::Scope context_scope(context);\n+\n+  FlagAndPersistent object_a, object_b;\n+\n+  size_t big_heap_size = 0;\n+  size_t big_array_size = 0;\n+\n+  {\n+    v8::HandleScope handle_scope(iso);\n+    Local<Object> a(v8::Object::New(iso));\n+    Local<Object> b(v8::Object::New(iso));\n+    object_a.handle.Reset(iso, a);\n+    object_b.handle.Reset(iso, b);\n+    if (interlinked) {\n+      a->Set(context, v8_str(\"x\"), b).FromJust();\n+      b->Set(context, v8_str(\"x\"), a).FromJust();\n+    }\n+    if (global_gc) {\n+      CcTest::CollectAllGarbage();\n+    } else {\n+      CcTest::CollectGarbage(i::NEW_SPACE);\n+    }\n+    v8::Local<Value> big_array = v8::Array::New(CcTest::isolate(), 5000);\n+    // Verify that we created an array where the space was reserved up front.\n+    big_array_size =\n+        v8::internal::JSArray::cast(*v8::Utils::OpenHandle(*big_array))\n+            ->elements()\n+            ->Size();\n+    CHECK_LE(20000, big_array_size);\n+    a->Set(context, v8_str(\"y\"), big_array).FromJust();\n+    big_heap_size = CcTest::heap()->SizeOfObjects();\n+  }\n+\n+  object_a.flag = false;\n+  object_b.flag = false;\n+  object_a.handle.SetWeak(&object_a, &SetFlag,\n+                          v8::WeakCallbackType::kParameter);\n+  object_b.handle.SetWeak(&object_b, &SetFlag,\n+                          v8::WeakCallbackType::kParameter);\n+  CHECK(!object_b.handle.IsIndependent());\n+  object_a.handle.MarkIndependent();\n+  object_b.handle.MarkIndependent();\n+  CHECK(object_b.handle.IsIndependent());\n+  if (global_gc) {\n+    CcTest::CollectAllGarbage();\n+  } else {\n+    CcTest::CollectGarbage(i::NEW_SPACE);\n+  }\n+  // A single GC should be enough to reclaim the memory, since we are using\n+  // phantom handles.\n+  CHECK_GT(big_heap_size - big_array_size, CcTest::heap()->SizeOfObjects());\n+  CHECK(object_a.flag);\n+  CHECK(object_b.flag);\n+}\n+\n+TEST(IndependentWeakHandle) {\n+  IndependentWeakHandle(false, false);\n+  IndependentWeakHandle(false, true);\n+  IndependentWeakHandle(true, false);\n+  IndependentWeakHandle(true, true);\n+}\n+\n class Trivial {\n  public:\n   explicit Trivial(int x) : x_(x) {}\n@@ -7899,6 +7973,125 @@ THREADED_TEST(InternalFieldCallback) {\n   InternalFieldCallback(true);\n }\n \n+static void ResetUseValueAndSetFlag(\n+    const v8::WeakCallbackInfo<FlagAndPersistent>& data) {\n+  // Blink will reset the handle, and then use the other handle, so they\n+  // can't use the same backing slot.\n+  data.GetParameter()->handle.Reset();\n+  data.GetParameter()->flag = true;\n+}\n+\n+void v8::internal::heap::HeapTester::ResetWeakHandle(bool global_gc) {\n+  using v8::Context;\n+  using v8::Local;\n+  using v8::Object;\n+\n+  v8::Isolate* iso = CcTest::isolate();\n+  v8::HandleScope scope(iso);\n+  v8::Local<Context> context = Context::New(iso);\n+  Context::Scope context_scope(context);\n+\n+  FlagAndPersistent object_a, object_b;\n+\n+  {\n+    v8::HandleScope handle_scope(iso);\n+    Local<Object> a(v8::Object::New(iso));\n+    Local<Object> b(v8::Object::New(iso));\n+    object_a.handle.Reset(iso, a);\n+    object_b.handle.Reset(iso, b);\n+    if (global_gc) {\n+      CcTest::CollectAllGarbage(Heap::kAbortIncrementalMarkingMask);\n+    } else {\n+      CcTest::CollectGarbage(i::NEW_SPACE);\n+    }\n+  }\n+\n+  object_a.flag = false;\n+  object_b.flag = false;\n+  object_a.handle.SetWeak(&object_a, &ResetUseValueAndSetFlag,\n+                          v8::WeakCallbackType::kParameter);\n+  object_b.handle.SetWeak(&object_b, &ResetUseValueAndSetFlag,\n+                          v8::WeakCallbackType::kParameter);\n+  if (!global_gc) {\n+    object_a.handle.MarkIndependent();\n+    object_b.handle.MarkIndependent();\n+    CHECK(object_b.handle.IsIndependent());\n+  }\n+  if (global_gc) {\n+    CcTest::CollectAllGarbage(Heap::kAbortIncrementalMarkingMask);\n+  } else {\n+    CcTest::CollectGarbage(i::NEW_SPACE);\n+  }\n+  CHECK(object_a.flag);\n+  CHECK(object_b.flag);\n+}\n+\n+THREADED_HEAP_TEST(ResetWeakHandle) {\n+  v8::internal::heap::HeapTester::ResetWeakHandle(false);\n+  v8::internal::heap::HeapTester::ResetWeakHandle(true);\n+}\n+\n+static void InvokeScavenge() { CcTest::CollectGarbage(i::NEW_SPACE); }\n+\n+static void InvokeMarkSweep() { CcTest::CollectAllGarbage(); }\n+\n+static void ForceScavenge2(\n+    const v8::WeakCallbackInfo<FlagAndPersistent>& data) {\n+  data.GetParameter()->flag = true;\n+  InvokeScavenge();\n+}\n+\n+static void ForceScavenge1(\n+    const v8::WeakCallbackInfo<FlagAndPersistent>& data) {\n+  data.GetParameter()->handle.Reset();\n+  data.SetSecondPassCallback(ForceScavenge2);\n+}\n+\n+static void ForceMarkSweep2(\n+    const v8::WeakCallbackInfo<FlagAndPersistent>& data) {\n+  data.GetParameter()->flag = true;\n+  InvokeMarkSweep();\n+}\n+\n+static void ForceMarkSweep1(\n+    const v8::WeakCallbackInfo<FlagAndPersistent>& data) {\n+  data.GetParameter()->handle.Reset();\n+  data.SetSecondPassCallback(ForceMarkSweep2);\n+}\n+\n+THREADED_TEST(GCFromWeakCallbacks) {\n+  v8::Isolate* isolate = CcTest::isolate();\n+  v8::Locker locker(CcTest::isolate());\n+  v8::HandleScope scope(isolate);\n+  v8::Local<Context> context = Context::New(isolate);\n+  Context::Scope context_scope(context);\n+\n+  static const int kNumberOfGCTypes = 2;\n+  typedef v8::WeakCallbackInfo<FlagAndPersistent>::Callback Callback;\n+  Callback gc_forcing_callback[kNumberOfGCTypes] = {&ForceScavenge1,\n+                                                    &ForceMarkSweep1};\n+\n+  typedef void (*GCInvoker)();\n+  GCInvoker invoke_gc[kNumberOfGCTypes] = {&InvokeScavenge, &InvokeMarkSweep};\n+\n+  for (int outer_gc = 0; outer_gc < kNumberOfGCTypes; outer_gc++) {\n+    for (int inner_gc = 0; inner_gc < kNumberOfGCTypes; inner_gc++) {\n+      FlagAndPersistent object;\n+      {\n+        v8::HandleScope handle_scope(isolate);\n+        object.handle.Reset(isolate, v8::Object::New(isolate));\n+      }\n+      object.flag = false;\n+      object.handle.SetWeak(&object, gc_forcing_callback[inner_gc],\n+                            v8::WeakCallbackType::kParameter);\n+      object.handle.MarkIndependent();\n+      invoke_gc[outer_gc]();\n+      EmptyMessageQueues(isolate);\n+      CHECK(object.flag);\n+    }\n+  }\n+}\n+\n v8::Local<Function> args_fun;\n \n "
        }
    ],
    "stats": {
        "total": 272,
        "additions": 255,
        "deletions": 17
    }
}