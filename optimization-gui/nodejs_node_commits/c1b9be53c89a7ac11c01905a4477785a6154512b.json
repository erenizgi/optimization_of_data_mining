{
    "author": "silverwind",
    "message": "util: treat format arguments equally\n\nTwo changes here which bring us closer to the console standard:\n\n- Arguments to `util.format` are no longer formatted differently\n  depending on their order, with format strings being an exception.\n- Format specifier formatting is now only triggered if the string\n  actually contains a format string.\n\nUnder the hood, we now use a single shared function to format the given\narguments which will make the code easier to read and modify.\n\nPR-URL: https://github.com/nodejs/node/pull/23162\nFixes: https://github.com/nodejs/node/issues/23137\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Refael Ackermann <refack@gmail.com>",
    "sha": "c1b9be53c89a7ac11c01905a4477785a6154512b",
    "files": [
        {
            "sha": "3def79546b6aa09c131f88c52c460544506ad943",
            "filename": "doc/api/util.md",
            "status": "modified",
            "additions": 31,
            "deletions": 19,
            "changes": 50,
            "blob_url": "https://github.com/nodejs/node/blob/c1b9be53c89a7ac11c01905a4477785a6154512b/doc%2Fapi%2Futil.md",
            "raw_url": "https://github.com/nodejs/node/raw/c1b9be53c89a7ac11c01905a4477785a6154512b/doc%2Fapi%2Futil.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Futil.md?ref=c1b9be53c89a7ac11c01905a4477785a6154512b",
            "patch": "@@ -183,6 +183,17 @@ property take precedence over `--trace-deprecation` and\n <!-- YAML\n added: v0.5.3\n changes:\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/23162\n+    description: The `format` argument is now only taken as such if it actually\n+                 contains format specifiers.\n+  - version: REPLACEME\n+    pr-url: https://github.com/nodejs/node/pull/23162\n+    description: If the `format` argument is not a format string, the output\n+                 string's formatting is no longer dependent on the type of the\n+                 first argument. This change removes previously present quotes\n+                 from strings that were being output when the first argument\n+                 was not a string.\n   - version: REPLACEME\n     pr-url: https://github.com/nodejs/node/pull/17907\n     description: The `%o` specifier's `depth` option will now fall back to the\n@@ -195,11 +206,9 @@ changes:\n * `format` {string} A `printf`-like format string.\n \n The `util.format()` method returns a formatted string using the first argument\n-as a `printf`-like format.\n-\n-The first argument is a string containing zero or more *placeholder* tokens.\n-Each placeholder token is replaced with the converted value from the\n-corresponding argument. Supported placeholders are:\n+as a `printf`-like format string which can contain zero or more format\n+specifiers. Each specifier is replaced with the converted value from the\n+corresponding argument. Supported specifiers are:\n \n * `%s` - `String`.\n * `%d` - `Number` (integer or floating point value) or `BigInt`.\n@@ -218,37 +227,40 @@ contains circular references.\n * `%%` - single percent sign (`'%'`). This does not consume an argument.\n * Returns: {string} The formatted string\n \n-If the placeholder does not have a corresponding argument, the placeholder is\n-not replaced.\n+If a specifier does not have a corresponding argument, it is not replaced:\n \n ```js\n util.format('%s:%s', 'foo');\n // Returns: 'foo:%s'\n ```\n \n-If there are more arguments passed to the `util.format()` method than the number\n-of placeholders, the extra arguments are coerced into strings then concatenated\n-to the returned string, each delimited by a space. Excessive arguments whose\n-`typeof` is `'object'` or `'symbol'` (except `null`) will be transformed by\n-`util.inspect()`.\n+Values that are not part of the format string are formatted using\n+`util.inspect()` if their type is either `'object'`, `'symbol'`, `'function'`\n+or `'number'` and using `String()` in all other cases.\n+\n+If there are more arguments passed to the `util.format()` method than the\n+number of specifiers, the extra arguments are concatenated to the returned\n+string, separated by spaces:\n \n ```js\n-util.format('%s:%s', 'foo', 'bar', 'baz'); // 'foo:bar baz'\n+util.format('%s:%s', 'foo', 'bar', 'baz');\n+// Returns: 'foo:bar baz'\n ```\n \n-If the first argument is not a string then `util.format()` returns\n-a string that is the concatenation of all arguments separated by spaces.\n-Each argument is converted to a string using `util.inspect()`.\n+If the first argument does not contain a valid format specifier, `util.format()`\n+returns a string that is the concatenation of all arguments separated by spaces:\n \n ```js\n-util.format(1, 2, 3); // '1 2 3'\n+util.format(1, 2, 3);\n+// Returns: '1 2 3'\n ```\n \n If only one argument is passed to `util.format()`, it is returned as it is\n-without any formatting.\n+without any formatting:\n \n ```js\n-util.format('%% %s'); // '%% %s'\n+util.format('%% %s');\n+// Returns: '%% %s'\n ```\n \n Please note that `util.format()` is a synchronous method that is mainly"
        },
        {
            "sha": "22c2b260daf319cde78c401bee241de306c0f57b",
            "filename": "lib/util.js",
            "status": "modified",
            "additions": 98,
            "deletions": 83,
            "changes": 181,
            "blob_url": "https://github.com/nodejs/node/blob/c1b9be53c89a7ac11c01905a4477785a6154512b/lib%2Futil.js",
            "raw_url": "https://github.com/nodejs/node/raw/c1b9be53c89a7ac11c01905a4477785a6154512b/lib%2Futil.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Futil.js?ref=c1b9be53c89a7ac11c01905a4477785a6154512b",
            "patch": "@@ -72,98 +72,113 @@ function format(...args) {\n   return formatWithOptions(emptyOptions, ...args);\n }\n \n-function formatWithOptions(inspectOptions, f) {\n-  let i, tempStr;\n-  if (typeof f !== 'string') {\n-    if (arguments.length === 1) return '';\n-    let res = '';\n-    for (i = 1; i < arguments.length - 1; i++) {\n-      res += inspect(arguments[i], inspectOptions);\n-      res += ' ';\n-    }\n-    res += inspect(arguments[i], inspectOptions);\n-    return res;\n+function formatValue(val, inspectOptions) {\n+  const inspectTypes = ['object', 'symbol', 'function', 'number'];\n+\n+  if (inspectTypes.includes(typeof val)) {\n+    return inspect(val, inspectOptions);\n+  } else {\n+    return String(val);\n+  }\n+}\n+\n+function formatWithOptions(inspectOptions, ...args) {\n+  const first = args[0];\n+  const parts = [];\n+\n+  const firstIsString = typeof first === 'string';\n+\n+  if (firstIsString && args.length === 1) {\n+    return first;\n   }\n \n-  if (arguments.length === 2) return f;\n-\n-  let str = '';\n-  let a = 2;\n-  let lastPos = 0;\n-  for (i = 0; i < f.length - 1; i++) {\n-    if (f.charCodeAt(i) === 37) { // '%'\n-      const nextChar = f.charCodeAt(++i);\n-      if (a !== arguments.length) {\n-        switch (nextChar) {\n-          case 115: // 's'\n-            tempStr = String(arguments[a++]);\n-            break;\n-          case 106: // 'j'\n-            tempStr = tryStringify(arguments[a++]);\n-            break;\n-          case 100: // 'd'\n-            const tempNum = arguments[a++];\n-            // eslint-disable-next-line valid-typeof\n-            if (typeof tempNum === 'bigint') {\n-              tempStr = `${tempNum}n`;\n-            } else {\n-              tempStr = `${Number(tempNum)}`;\n+  if (firstIsString && /%[sjdOoif%]/.test(first)) {\n+    let i, tempStr;\n+    let str = '';\n+    let a = 1;\n+    let lastPos = 0;\n+\n+    for (i = 0; i < first.length - 1; i++) {\n+      if (first.charCodeAt(i) === 37) { // '%'\n+        const nextChar = first.charCodeAt(++i);\n+        if (a !== args.length) {\n+          switch (nextChar) {\n+            case 115: // 's'\n+              tempStr = String(args[a++]);\n+              break;\n+            case 106: // 'j'\n+              tempStr = tryStringify(args[a++]);\n+              break;\n+            case 100: // 'd'\n+              const tempNum = args[a++];\n+              // eslint-disable-next-line valid-typeof\n+              if (typeof tempNum === 'bigint') {\n+                tempStr = `${tempNum}n`;\n+              } else {\n+                tempStr = `${Number(tempNum)}`;\n+              }\n+              break;\n+            case 79: // 'O'\n+              tempStr = inspect(args[a++], inspectOptions);\n+              break;\n+            case 111: // 'o'\n+            {\n+              const opts = Object.assign({}, inspectOptions, {\n+                showHidden: true,\n+                showProxy: true,\n+                depth: 4\n+              });\n+              tempStr = inspect(args[a++], opts);\n+              break;\n             }\n-            break;\n-          case 79: // 'O'\n-            tempStr = inspect(arguments[a++], inspectOptions);\n-            break;\n-          case 111: // 'o'\n-          {\n-            const opts = Object.assign({}, inspectOptions, {\n-              showHidden: true,\n-              showProxy: true\n-            });\n-            tempStr = inspect(arguments[a++], opts);\n-            break;\n+            case 105: // 'i'\n+              const tempInteger = args[a++];\n+              // eslint-disable-next-line valid-typeof\n+              if (typeof tempInteger === 'bigint') {\n+                tempStr = `${tempInteger}n`;\n+              } else {\n+                tempStr = `${parseInt(tempInteger)}`;\n+              }\n+              break;\n+            case 102: // 'f'\n+              tempStr = `${parseFloat(args[a++])}`;\n+              break;\n+            case 37: // '%'\n+              str += first.slice(lastPos, i);\n+              lastPos = i + 1;\n+              continue;\n+            default: // any other character is not a correct placeholder\n+              continue;\n           }\n-          case 105: // 'i'\n-            const tempInteger = arguments[a++];\n-            // eslint-disable-next-line valid-typeof\n-            if (typeof tempInteger === 'bigint') {\n-              tempStr = `${tempInteger}n`;\n-            } else {\n-              tempStr = `${parseInt(tempInteger)}`;\n-            }\n-            break;\n-          case 102: // 'f'\n-            tempStr = `${parseFloat(arguments[a++])}`;\n-            break;\n-          case 37: // '%'\n-            str += f.slice(lastPos, i);\n-            lastPos = i + 1;\n-            continue;\n-          default: // any other character is not a correct placeholder\n-            continue;\n+          if (lastPos !== i - 1) {\n+            str += first.slice(lastPos, i - 1);\n+          }\n+          str += tempStr;\n+          lastPos = i + 1;\n+        } else if (nextChar === 37) {\n+          str += first.slice(lastPos, i);\n+          lastPos = i + 1;\n         }\n-        if (lastPos !== i - 1)\n-          str += f.slice(lastPos, i - 1);\n-        str += tempStr;\n-        lastPos = i + 1;\n-      } else if (nextChar === 37) {\n-        str += f.slice(lastPos, i);\n-        lastPos = i + 1;\n       }\n     }\n-  }\n-  if (lastPos === 0)\n-    str = f;\n-  else if (lastPos < f.length)\n-    str += f.slice(lastPos);\n-  while (a < arguments.length) {\n-    const x = arguments[a++];\n-    if ((typeof x !== 'object' && typeof x !== 'symbol') || x === null) {\n-      str += ` ${x}`;\n-    } else {\n-      str += ` ${inspect(x, inspectOptions)}`;\n+    if (lastPos === 0) {\n+      str = first;\n+    } else if (lastPos < first.length) {\n+      str += first.slice(lastPos);\n+    }\n+\n+    parts.push(str);\n+    while (a < args.length) {\n+      parts.push(formatValue(args[a], inspectOptions));\n+      a++;\n+    }\n+  } else {\n+    for (const arg of args) {\n+      parts.push(formatValue(arg, inspectOptions));\n     }\n   }\n-  return str;\n+\n+  return parts.join(' ');\n }\n \n const debugs = {};"
        },
        {
            "sha": "2ca8e0857f3aad49d4ba845345f3ebe729995234",
            "filename": "test/parallel/test-util-format.js",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/c1b9be53c89a7ac11c01905a4477785a6154512b/test%2Fparallel%2Ftest-util-format.js",
            "raw_url": "https://github.com/nodejs/node/raw/c1b9be53c89a7ac11c01905a4477785a6154512b/test%2Fparallel%2Ftest-util-format.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-util-format.js?ref=c1b9be53c89a7ac11c01905a4477785a6154512b",
            "patch": "@@ -273,6 +273,10 @@ assert.strictEqual(util.format('percent: %d%, fraction: %d', 10, 0.1),\n                    'percent: 10%, fraction: 0.1');\n assert.strictEqual(util.format('abc%', 1), 'abc% 1');\n \n+// Additional arguments after format specifiers\n+assert.strictEqual(util.format('%i', 1, 'number'), '1 number');\n+assert.strictEqual(util.format('%i', 1, () => {}), '1 [Function]');\n+\n {\n   const o = {};\n   o.o = o;\n@@ -315,3 +319,15 @@ function BadCustomError(msg) {\n util.inherits(BadCustomError, Error);\n assert.strictEqual(util.format(new BadCustomError('foo')),\n                    '[BadCustomError: foo]');\n+\n+// The format of arguments should not depend on type of the first argument\n+assert.strictEqual(util.format('1', '1'), '1 1');\n+assert.strictEqual(util.format(1, '1'), '1 1');\n+assert.strictEqual(util.format('1', 1), '1 1');\n+assert.strictEqual(util.format(1, 1), '1 1');\n+assert.strictEqual(util.format('1', () => {}), '1 [Function]');\n+assert.strictEqual(util.format(1, () => {}), '1 [Function]');\n+assert.strictEqual(util.format('1', \"'\"), \"1 '\");\n+assert.strictEqual(util.format(1, \"'\"), \"1 '\");\n+assert.strictEqual(util.format('1', 'number'), '1 number');\n+assert.strictEqual(util.format(1, 'number'), '1 number');"
        }
    ],
    "stats": {
        "total": 247,
        "additions": 145,
        "deletions": 102
    }
}