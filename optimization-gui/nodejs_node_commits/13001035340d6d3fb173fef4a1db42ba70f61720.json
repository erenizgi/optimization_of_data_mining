{
    "author": "unknown",
    "message": "inspector: allow concurrent inspector sessions\n\nThis change enables concurrent inspector sessions, through WebSocket\ninterface as well as JS interface, in any combination.\n\nPR-URL: https://github.com/nodejs/node/pull/20137\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: Rich Trott <rtrott@gmail.com>",
    "sha": "13001035340d6d3fb173fef4a1db42ba70f61720",
    "files": [
        {
            "sha": "1530b206456bb5f2292b140641e104cec31c9b66",
            "filename": "src/inspector_agent.cc",
            "status": "modified",
            "additions": 70,
            "deletions": 66,
            "changes": 136,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Finspector_agent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Finspector_agent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.cc?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -189,9 +189,9 @@ const int CONTEXT_GROUP_ID = 1;\n \n class ChannelImpl final : public v8_inspector::V8Inspector::Channel {\n  public:\n-  explicit ChannelImpl(V8Inspector* inspector,\n-                       InspectorSessionDelegate* delegate)\n-                       : delegate_(delegate) {\n+  explicit ChannelImpl(const std::unique_ptr<V8Inspector>& inspector,\n+                       std::unique_ptr<InspectorSessionDelegate> delegate)\n+                       : delegate_(std::move(delegate)) {\n     session_ = inspector->connect(1, this, StringView());\n   }\n \n@@ -201,19 +201,11 @@ class ChannelImpl final : public v8_inspector::V8Inspector::Channel {\n     session_->dispatchProtocolMessage(message);\n   }\n \n-  bool waitForFrontendMessage() {\n-    return delegate_->WaitForFrontendMessageWhilePaused();\n-  }\n-\n   void schedulePauseOnNextStatement(const std::string& reason) {\n     std::unique_ptr<StringBuffer> buffer = Utf8ToStringView(reason);\n     session_->schedulePauseOnNextStatement(buffer->string(), buffer->string());\n   }\n \n-  InspectorSessionDelegate* delegate() {\n-    return delegate_;\n-  }\n-\n  private:\n   void sendResponse(\n       int callId,\n@@ -232,7 +224,7 @@ class ChannelImpl final : public v8_inspector::V8Inspector::Channel {\n     delegate_->SendMessageToFrontend(message);\n   }\n \n-  InspectorSessionDelegate* const delegate_;\n+  std::unique_ptr<InspectorSessionDelegate> delegate_;\n   std::unique_ptr<v8_inspector::V8InspectorSession> session_;\n };\n \n@@ -300,8 +292,7 @@ class InspectorTimerHandle {\n class NodeInspectorClient : public V8InspectorClient {\n  public:\n   NodeInspectorClient(node::Environment* env, node::NodePlatform* platform)\n-      : env_(env), platform_(platform), terminated_(false),\n-        running_nested_loop_(false) {\n+      : env_(env), platform_(platform) {\n     client_ = V8Inspector::create(env->isolate(), this);\n     // TODO(bnoordhuis) Make name configurable from src/node.cc.\n     ContextInfo info(GetHumanReadableProcessName());\n@@ -310,18 +301,28 @@ class NodeInspectorClient : public V8InspectorClient {\n   }\n \n   void runMessageLoopOnPause(int context_group_id) override {\n-    CHECK_NE(channel_, nullptr);\n+    runMessageLoop(false);\n+  }\n+\n+  void runMessageLoop(bool ignore_terminated) {\n     if (running_nested_loop_)\n       return;\n     terminated_ = false;\n     running_nested_loop_ = true;\n-    while (!terminated_ && channel_->waitForFrontendMessage()) {\n+    while ((ignore_terminated || !terminated_) && waitForFrontendEvent()) {\n       while (platform_->FlushForegroundTasks(env_->isolate())) {}\n     }\n     terminated_ = false;\n     running_nested_loop_ = false;\n   }\n \n+  bool waitForFrontendEvent() {\n+    InspectorIo* io = env_->inspector_agent()->io();\n+    if (io == nullptr)\n+      return false;\n+    return io->WaitForFrontendEvent();\n+  }\n+\n   double currentTimeMS() override {\n     return uv_hrtime() * 1.0 / NANOS_PER_MSEC;\n   }\n@@ -363,20 +364,22 @@ class NodeInspectorClient : public V8InspectorClient {\n     terminated_ = true;\n   }\n \n-  void connectFrontend(InspectorSessionDelegate* delegate) {\n-    CHECK_EQ(channel_, nullptr);\n-    channel_ = std::unique_ptr<ChannelImpl>(\n-        new ChannelImpl(client_.get(), delegate));\n+  int connectFrontend(std::unique_ptr<InspectorSessionDelegate> delegate) {\n+    events_dispatched_ = true;\n+    int session_id = next_session_id_++;\n+    channels_[session_id] =\n+        std::make_unique<ChannelImpl>(client_, std::move(delegate));\n+    return session_id;\n   }\n \n-  void disconnectFrontend() {\n-    quitMessageLoopOnPause();\n-    channel_.reset();\n+  void disconnectFrontend(int session_id) {\n+    events_dispatched_ = true;\n+    channels_.erase(session_id);\n   }\n \n-  void dispatchMessageFromFrontend(const StringView& message) {\n-    CHECK_NE(channel_, nullptr);\n-    channel_->dispatchProtocolMessage(message);\n+  void dispatchMessageFromFrontend(int session_id, const StringView& message) {\n+    events_dispatched_ = true;\n+    channels_[session_id]->dispatchProtocolMessage(message);\n   }\n \n   Local<Context> ensureDefaultContextInGroup(int contextGroupId) override {\n@@ -426,10 +429,6 @@ class NodeInspectorClient : public V8InspectorClient {\n         script_id);\n   }\n \n-  ChannelImpl* channel() {\n-    return channel_.get();\n-  }\n-\n   void startRepeatingTimer(double interval_s,\n                            TimerCallback callback,\n                            void* data) override {\n@@ -464,20 +463,31 @@ class NodeInspectorClient : public V8InspectorClient {\n     client_->allAsyncTasksCanceled();\n   }\n \n+  void schedulePauseOnNextStatement(const std::string& reason) {\n+    for (const auto& id_channel : channels_) {\n+      id_channel.second->schedulePauseOnNextStatement(reason);\n+    }\n+  }\n+\n+  bool hasConnectedSessions() {\n+    return !channels_.empty();\n+  }\n+\n  private:\n   node::Environment* env_;\n   node::NodePlatform* platform_;\n-  bool terminated_;\n-  bool running_nested_loop_;\n+  bool terminated_ = false;\n+  bool running_nested_loop_ = false;\n   std::unique_ptr<V8Inspector> client_;\n-  std::unique_ptr<ChannelImpl> channel_;\n+  std::unordered_map<int, std::unique_ptr<ChannelImpl>> channels_;\n   std::unordered_map<void*, InspectorTimerHandle> timers_;\n+  int next_session_id_ = 1;\n+  bool events_dispatched_ = false;\n };\n \n Agent::Agent(Environment* env) : parent_env_(env),\n                                  client_(nullptr),\n                                  platform_(nullptr),\n-                                 enabled_(false),\n                                  pending_enable_async_hook_(false),\n                                  pending_disable_async_hook_(false) {}\n \n@@ -491,7 +501,7 @@ bool Agent::Start(node::NodePlatform* platform, const char* path,\n   path_ = path == nullptr ? \"\" : path;\n   debug_options_ = options;\n   client_ =\n-      std::unique_ptr<NodeInspectorClient>(\n+      std::shared_ptr<NodeInspectorClient>(\n           new NodeInspectorClient(parent_env_, platform));\n   platform_ = platform;\n   CHECK_EQ(0, uv_async_init(uv_default_loop(),\n@@ -515,7 +525,6 @@ bool Agent::StartIoThread(bool wait_for_connect) {\n \n   CHECK_NE(client_, nullptr);\n \n-  enabled_ = true;\n   io_ = std::unique_ptr<InspectorIo>(\n       new InspectorIo(parent_env_, platform_, path_, debug_options_,\n                       wait_for_connect));\n@@ -554,20 +563,25 @@ void Agent::Stop() {\n   if (io_ != nullptr) {\n     io_->Stop();\n     io_.reset();\n-    enabled_ = false;\n   }\n }\n \n-void Agent::Connect(InspectorSessionDelegate* delegate) {\n-  enabled_ = true;\n-  client_->connectFrontend(delegate);\n+std::unique_ptr<InspectorSession> Agent::Connect(\n+    std::unique_ptr<InspectorSessionDelegate> delegate) {\n+  int session_id = client_->connectFrontend(std::move(delegate));\n+  return std::make_unique<InspectorSession>(session_id, client_);\n }\n \n void Agent::WaitForDisconnect() {\n   CHECK_NE(client_, nullptr);\n   client_->contextDestroyed(parent_env_->context());\n   if (io_ != nullptr) {\n     io_->WaitForDisconnect();\n+    // There is a bug in V8 Inspector (https://crbug.com/834056) that\n+    // calls V8InspectorClient::quitMessageLoopOnPause when a session\n+    // disconnects. We are using this flag to ignore those calls so the message\n+    // loop is spinning as long as there's a reason to expect inspector messages\n+    client_->runMessageLoop(true);\n   }\n }\n \n@@ -578,33 +592,8 @@ void Agent::FatalException(Local<Value> error, Local<v8::Message> message) {\n   WaitForDisconnect();\n }\n \n-void Agent::Dispatch(const StringView& message) {\n-  CHECK_NE(client_, nullptr);\n-  client_->dispatchMessageFromFrontend(message);\n-}\n-\n-void Agent::Disconnect() {\n-  CHECK_NE(client_, nullptr);\n-  client_->disconnectFrontend();\n-}\n-\n-void Agent::RunMessageLoop() {\n-  CHECK_NE(client_, nullptr);\n-  client_->runMessageLoopOnPause(CONTEXT_GROUP_ID);\n-}\n-\n-InspectorSessionDelegate* Agent::delegate() {\n-  CHECK_NE(client_, nullptr);\n-  ChannelImpl* channel = client_->channel();\n-  if (channel == nullptr)\n-    return nullptr;\n-  return channel->delegate();\n-}\n-\n void Agent::PauseOnNextJavascriptStatement(const std::string& reason) {\n-  ChannelImpl* channel = client_->channel();\n-  if (channel != nullptr)\n-    channel->schedulePauseOnNextStatement(reason);\n+  client_->schedulePauseOnNextStatement(reason);\n }\n \n void Agent::RegisterAsyncHook(Isolate* isolate,\n@@ -699,5 +688,20 @@ bool Agent::IsWaitingForConnect() {\n   return debug_options_.wait_for_connect();\n }\n \n+bool Agent::HasConnectedSessions() {\n+  return client_->hasConnectedSessions();\n+}\n+\n+InspectorSession::InspectorSession(int session_id,\n+                                   std::shared_ptr<NodeInspectorClient> client)\n+                                   : session_id_(session_id), client_(client) {}\n+\n+InspectorSession::~InspectorSession() {\n+  client_->disconnectFrontend(session_id_);\n+}\n+\n+void InspectorSession::Dispatch(const StringView& message) {\n+  client_->dispatchMessageFromFrontend(session_id_, message);\n+}\n }  // namespace inspector\n }  // namespace node"
        },
        {
            "sha": "64e4202ee88e1369d96e285be9b28de763889a9e",
            "filename": "src/inspector_agent.h",
            "status": "modified",
            "additions": 22,
            "deletions": 18,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Finspector_agent.h",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Finspector_agent.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_agent.h?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -23,18 +23,26 @@ class Environment;\n struct ContextInfo;\n \n namespace inspector {\n+class InspectorIo;\n+class NodeInspectorClient;\n+\n+class InspectorSession {\n+ public:\n+  InspectorSession(int session_id, std::shared_ptr<NodeInspectorClient> client);\n+  ~InspectorSession();\n+  void Dispatch(const v8_inspector::StringView& message);\n+ private:\n+  int session_id_;\n+  std::shared_ptr<NodeInspectorClient> client_;\n+};\n \n class InspectorSessionDelegate {\n  public:\n   virtual ~InspectorSessionDelegate() = default;\n-  virtual bool WaitForFrontendMessageWhilePaused() = 0;\n   virtual void SendMessageToFrontend(const v8_inspector::StringView& message)\n                                      = 0;\n };\n \n-class InspectorIo;\n-class NodeInspectorClient;\n-\n class Agent {\n  public:\n   explicit Agent(node::Environment* env);\n@@ -66,19 +74,19 @@ class Agent {\n   void RegisterAsyncHook(v8::Isolate* isolate,\n     v8::Local<v8::Function> enable_function,\n     v8::Local<v8::Function> disable_function);\n+  void EnableAsyncHook();\n+  void DisableAsyncHook();\n \n-  // These methods are called by the WS protocol and JS binding to create\n-  // inspector sessions.  The inspector responds by using the delegate to send\n-  // messages back.\n-  void Connect(InspectorSessionDelegate* delegate);\n-  void Disconnect();\n-  void Dispatch(const v8_inspector::StringView& message);\n-  InspectorSessionDelegate* delegate();\n+  // Called by the WS protocol and JS binding to create inspector sessions.\n+  // The inspector responds by using the delegate to send messages back.\n+  std::unique_ptr<InspectorSession> Connect(\n+      std::unique_ptr<InspectorSessionDelegate> delegate);\n \n-  void RunMessageLoop();\n-  bool enabled() { return enabled_; }\n   void PauseOnNextJavascriptStatement(const std::string& reason);\n \n+  // Returns true as long as there is at least one connected session.\n+  bool HasConnectedSessions();\n+\n   InspectorIo* io() {\n     return io_.get();\n   }\n@@ -92,18 +100,14 @@ class Agent {\n   DebugOptions& options() { return debug_options_; }\n   void ContextCreated(v8::Local<v8::Context> context, const ContextInfo& info);\n \n-  void EnableAsyncHook();\n-  void DisableAsyncHook();\n-\n  private:\n   void ToggleAsyncHook(v8::Isolate* isolate,\n                        const Persistent<v8::Function>& fn);\n \n   node::Environment* parent_env_;\n-  std::unique_ptr<NodeInspectorClient> client_;\n+  std::shared_ptr<NodeInspectorClient> client_;\n   std::unique_ptr<InspectorIo> io_;\n   v8::Platform* platform_;\n-  bool enabled_;\n   std::string path_;\n   DebugOptions debug_options_;\n "
        },
        {
            "sha": "5e0d29d3caf2cdfa8341c1add5e8e95e26824bcd",
            "filename": "src/inspector_io.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 43,
            "changes": 74,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Finspector_io.cc",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Finspector_io.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_io.cc?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -122,11 +122,11 @@ std::unique_ptr<StringBuffer> Utf8ToStringView(const std::string& message) {\n \n class IoSessionDelegate : public InspectorSessionDelegate {\n  public:\n-  explicit IoSessionDelegate(InspectorIo* io) : io_(io) { }\n-  bool WaitForFrontendMessageWhilePaused() override;\n+  explicit IoSessionDelegate(InspectorIo* io, int id) : io_(io), id_(id) { }\n   void SendMessageToFrontend(const v8_inspector::StringView& message) override;\n  private:\n   InspectorIo* io_;\n+  int id_;\n };\n \n // Passed to InspectorSocketServer to handle WS inspector protocol events,\n@@ -190,8 +190,7 @@ InspectorIo::InspectorIo(Environment* env, v8::Platform* platform,\n                          : options_(options), thread_(), delegate_(nullptr),\n                            state_(State::kNew), parent_env_(env),\n                            thread_req_(), platform_(platform),\n-                           dispatching_messages_(false), session_id_(0),\n-                           script_name_(path),\n+                           dispatching_messages_(false), script_name_(path),\n                            wait_for_connect_(wait_for_connect), port_(-1) {\n   main_thread_req_ = new AsyncAndAgent({uv_async_t(), env->inspector_agent()});\n   CHECK_EQ(0, uv_async_init(env->event_loop(), &main_thread_req_->first,\n@@ -222,7 +221,7 @@ bool InspectorIo::Start() {\n }\n \n void InspectorIo::Stop() {\n-  CHECK(state_ == State::kAccepting || state_ == State::kConnected);\n+  CHECK(state_ == State::kAccepting || !sessions_.empty());\n   Write(TransportAction::kKill, 0, StringView());\n   int err = uv_thread_join(&thread_);\n   CHECK_EQ(err, 0);\n@@ -237,12 +236,11 @@ bool InspectorIo::IsStarted() {\n void InspectorIo::WaitForDisconnect() {\n   if (state_ == State::kAccepting)\n     state_ = State::kDone;\n-  if (state_ == State::kConnected) {\n+  if (!sessions_.empty()) {\n     state_ = State::kShutDown;\n     Write(TransportAction::kStop, 0, StringView());\n     fprintf(stderr, \"Waiting for the debugger to disconnect...\\n\");\n     fflush(stderr);\n-    parent_env_->inspector_agent()->RunMessageLoop();\n   }\n }\n \n@@ -348,45 +346,23 @@ void InspectorIo::PostIncomingMessage(InspectorAction action, int session_id,\n     isolate->RequestInterrupt(InterruptCallback, agent);\n     CHECK_EQ(0, uv_async_send(&main_thread_req_->first));\n   }\n-  NotifyMessageReceived();\n+  Mutex::ScopedLock scoped_lock(state_lock_);\n+  incoming_message_cond_.Broadcast(scoped_lock);\n }\n \n std::vector<std::string> InspectorIo::GetTargetIds() const {\n   return delegate_ ? delegate_->GetTargetIds() : std::vector<std::string>();\n }\n \n-void InspectorIo::WaitForFrontendMessageWhilePaused() {\n-  dispatching_messages_ = false;\n-  Mutex::ScopedLock scoped_lock(state_lock_);\n-  if (incoming_message_queue_.empty())\n-    incoming_message_cond_.Wait(scoped_lock);\n-}\n-\n-void InspectorIo::NotifyMessageReceived() {\n-  Mutex::ScopedLock scoped_lock(state_lock_);\n-  incoming_message_cond_.Broadcast(scoped_lock);\n-}\n-\n TransportAction InspectorIo::Attach(int session_id) {\n   Agent* agent = parent_env_->inspector_agent();\n-  if (agent->delegate() != nullptr)\n-    return TransportAction::kDeclineSession;\n-\n-  CHECK_EQ(session_delegate_, nullptr);\n-  session_id_ = session_id;\n-  state_ = State::kConnected;\n   fprintf(stderr, \"Debugger attached.\\n\");\n-  session_delegate_ = std::unique_ptr<InspectorSessionDelegate>(\n-      new IoSessionDelegate(this));\n-  agent->Connect(session_delegate_.get());\n+  sessions_[session_id] =\n+      agent->Connect(std::make_unique<IoSessionDelegate>(this, session_id));\n   return TransportAction::kAcceptSession;\n }\n \n void InspectorIo::DispatchMessages() {\n-  // This function can be reentered if there was an incoming message while\n-  // V8 was processing another inspector request (e.g. if the user is\n-  // evaluating a long-running JS code snippet). This can happen only at\n-  // specific points (e.g. the lines that call inspector_ methods)\n   if (dispatching_messages_)\n     return;\n   dispatching_messages_ = true;\n@@ -409,17 +385,20 @@ void InspectorIo::DispatchMessages() {\n         Attach(id);\n         break;\n       case InspectorAction::kEndSession:\n-        CHECK_NE(session_delegate_, nullptr);\n+        sessions_.erase(id);\n+        if (!sessions_.empty())\n+          continue;\n         if (state_ == State::kShutDown) {\n           state_ = State::kDone;\n         } else {\n           state_ = State::kAccepting;\n         }\n-        parent_env_->inspector_agent()->Disconnect();\n-        session_delegate_.reset();\n         break;\n       case InspectorAction::kSendMessage:\n-        parent_env_->inspector_agent()->Dispatch(message);\n+        auto session = sessions_.find(id);\n+        if (session != sessions_.end() && session->second) {\n+          session->second->Dispatch(message);\n+        }\n         break;\n       }\n     }\n@@ -445,6 +424,20 @@ void InspectorIo::Write(TransportAction action, int session_id,\n   CHECK_EQ(0, err);\n }\n \n+bool InspectorIo::WaitForFrontendEvent() {\n+  // We allow DispatchMessages reentry as we enter the pause. This is important\n+  // to support debugging the code invoked by an inspector call, such\n+  // as Runtime.evaluate\n+  dispatching_messages_ = false;\n+  Mutex::ScopedLock scoped_lock(state_lock_);\n+  if (sessions_.empty())\n+    return false;\n+  if (dispatching_message_queue_.empty() && incoming_message_queue_.empty()) {\n+    incoming_message_cond_.Wait(scoped_lock);\n+  }\n+  return true;\n+}\n+\n InspectorIoDelegate::InspectorIoDelegate(InspectorIo* io,\n                                          const std::string& script_path,\n                                          const std::string& script_name,\n@@ -502,14 +495,9 @@ std::string InspectorIoDelegate::GetTargetUrl(const std::string& id) {\n   return \"file://\" + script_path_;\n }\n \n-bool IoSessionDelegate::WaitForFrontendMessageWhilePaused() {\n-  io_->WaitForFrontendMessageWhilePaused();\n-  return true;\n-}\n-\n void IoSessionDelegate::SendMessageToFrontend(\n     const v8_inspector::StringView& message) {\n-  io_->Write(TransportAction::kSendMessage, io_->session_id_, message);\n+  io_->Write(TransportAction::kSendMessage, id_, message);\n }\n \n }  // namespace inspector"
        },
        {
            "sha": "276c78056cb0a1c5bd984f3bbcfb433f3d5d665f",
            "filename": "src/inspector_io.h",
            "status": "modified",
            "additions": 5,
            "deletions": 8,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Finspector_io.h",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Finspector_io.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_io.h?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -7,6 +7,7 @@\n #include \"uv.h\"\n \n #include <deque>\n+#include <map>\n #include <memory>\n #include <stddef.h>\n \n@@ -76,6 +77,7 @@ class InspectorIo {\n   void ServerDone() {\n     uv_close(reinterpret_cast<uv_handle_t*>(&thread_req_), nullptr);\n   }\n+  bool WaitForFrontendEvent();\n \n   int port() const { return port_; }\n   std::string host() const { return options_.host_name(); }\n@@ -89,7 +91,6 @@ class InspectorIo {\n   enum class State {\n     kNew,\n     kAccepting,\n-    kConnected,\n     kDone,\n     kError,\n     kShutDown\n@@ -107,7 +108,6 @@ class InspectorIo {\n   // messages from outgoing_message_queue to the InspectorSockerServer\n   template <typename Transport> static void IoThreadAsyncCb(uv_async_t* async);\n \n-  void SetConnected(bool connected);\n   void DispatchMessages();\n   // Write action to outgoing_message_queue, and wake the thread\n   void Write(TransportAction action, int session_id,\n@@ -122,10 +122,6 @@ class InspectorIo {\n   template <typename ActionType>\n   void SwapBehindLock(MessageQueue<ActionType>* vector1,\n                       MessageQueue<ActionType>* vector2);\n-  // Wait on incoming_message_cond_\n-  void WaitForFrontendMessageWhilePaused();\n-  // Broadcast incoming_message_cond_\n-  void NotifyMessageReceived();\n   // Attach session to an inspector. Either kAcceptSession or kDeclineSession\n   TransportAction Attach(int session_id);\n \n@@ -147,23 +143,24 @@ class InspectorIo {\n   // Note that this will live while the async is being closed - likely, past\n   // the parent object lifespan\n   std::pair<uv_async_t, Agent*>* main_thread_req_;\n-  std::unique_ptr<InspectorSessionDelegate> session_delegate_;\n   v8::Platform* platform_;\n \n   // Message queues\n   ConditionVariable incoming_message_cond_;\n   Mutex state_lock_;  // Locked before mutating either queue.\n   MessageQueue<InspectorAction> incoming_message_queue_;\n   MessageQueue<TransportAction> outgoing_message_queue_;\n+  // This queue is to maintain the order of the messages for the cases\n+  // when we reenter the DispatchMessages function.\n   MessageQueue<InspectorAction> dispatching_message_queue_;\n \n   bool dispatching_messages_;\n-  int session_id_;\n \n   std::string script_name_;\n   std::string script_path_;\n   const bool wait_for_connect_;\n   int port_;\n+  std::unordered_map<int, std::unique_ptr<InspectorSession>> sessions_;\n \n   friend class DispatchMessagesTask;\n   friend class IoSessionDelegate;"
        },
        {
            "sha": "3d05b2f6feafffd7f4ec08cbad3f629c01c2eaf2",
            "filename": "src/inspector_js_api.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 33,
            "changes": 47,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Finspector_js_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Finspector_js_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_js_api.cc?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -42,10 +42,6 @@ class JSBindingsConnection : public AsyncWrap {\n                                 connection_(connection) {\n     }\n \n-    bool WaitForFrontendMessageWhilePaused() override {\n-      return false;\n-    }\n-\n     void SendMessageToFrontend(const v8_inspector::StringView& message)\n         override {\n       Isolate* isolate = env_->isolate();\n@@ -58,12 +54,6 @@ class JSBindingsConnection : public AsyncWrap {\n       connection_->OnMessage(argument);\n     }\n \n-    void Disconnect() {\n-      Agent* agent = env_->inspector_agent();\n-      if (agent->delegate() == this)\n-        agent->Disconnect();\n-    }\n-\n    private:\n     Environment* env_;\n     JSBindingsConnection* connection_;\n@@ -73,31 +63,17 @@ class JSBindingsConnection : public AsyncWrap {\n                        Local<Object> wrap,\n                        Local<Function> callback)\n                        : AsyncWrap(env, wrap, PROVIDER_INSPECTORJSBINDING),\n-                         delegate_(env, this),\n                          callback_(env->isolate(), callback) {\n     Wrap(wrap, this);\n-\n     Agent* inspector = env->inspector_agent();\n-    if (inspector->delegate() != nullptr) {\n-      // This signals JS code that it has to throw an error.\n-      Local<String> session_attached =\n-          FIXED_ONE_BYTE_STRING(env->isolate(), \"sessionAttached\");\n-      wrap->Set(env->context(), session_attached,\n-                Boolean::New(env->isolate(), true)).ToChecked();\n-      return;\n-    }\n-    inspector->Connect(&delegate_);\n+    session_ = inspector->Connect(\n+        std::make_unique<JSBindingsSessionDelegate>(env, this));\n   }\n \n   void OnMessage(Local<Value> value) {\n     MakeCallback(callback_.Get(env()->isolate()), 1, &value);\n   }\n \n-  void CheckIsCurrent() {\n-    Agent* inspector = env()->inspector_agent();\n-    CHECK_EQ(&delegate_, inspector->delegate());\n-  }\n-\n   static void New(const FunctionCallbackInfo<Value>& info) {\n     Environment* env = Environment::GetCurrent(info);\n     CHECK(info[0]->IsFunction());\n@@ -106,7 +82,7 @@ class JSBindingsConnection : public AsyncWrap {\n   }\n \n   void Disconnect() {\n-    delegate_.Disconnect();\n+    session_.reset();\n     if (!persistent().IsEmpty()) {\n       ClearWrap(object());\n     }\n@@ -125,18 +101,23 @@ class JSBindingsConnection : public AsyncWrap {\n     ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());\n     CHECK(info[0]->IsString());\n \n-    session->CheckIsCurrent();\n-    Agent* inspector = env->inspector_agent();\n-    inspector->Dispatch(ToProtocolString(env->isolate(), info[0])->string());\n+    if (session->session_) {\n+      session->session_->Dispatch(\n+          ToProtocolString(env->isolate(), info[0])->string());\n+    }\n   }\n \n   size_t self_size() const override { return sizeof(*this); }\n \n  private:\n-  JSBindingsSessionDelegate delegate_;\n+  std::unique_ptr<InspectorSession> session_;\n   Persistent<Function> callback_;\n };\n \n+static bool InspectorEnabled(Environment* env) {\n+  Agent* agent = env->inspector_agent();\n+  return agent->io() != nullptr || agent->HasConnectedSessions();\n+}\n \n void AddCommandLineAPI(const FunctionCallbackInfo<Value>& info) {\n   auto env = Environment::GetCurrent(info);\n@@ -178,7 +159,7 @@ void InspectorConsoleCall(const FunctionCallbackInfo<Value>& info) {\n     call_args.push_back(info[i]);\n   }\n   Environment* env = Environment::GetCurrent(isolate);\n-  if (env->inspector_agent()->enabled()) {\n+  if (InspectorEnabled(env)) {\n     Local<Value> inspector_method = info[0];\n     CHECK(inspector_method->IsFunction());\n     Local<Value> config_value = info[2];\n@@ -256,7 +237,7 @@ static void RegisterAsyncHookWrapper(const FunctionCallbackInfo<Value>& args) {\n \n void IsEnabled(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n-  args.GetReturnValue().Set(env->inspector_agent()->enabled());\n+  args.GetReturnValue().Set(InspectorEnabled(env));\n }\n \n void Open(const FunctionCallbackInfo<Value>& args) {"
        },
        {
            "sha": "e890f66a38b53f8efe7a1ea7e36fc3154fc6acb5",
            "filename": "src/inspector_socket_server.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 20,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Finspector_socket_server.cc",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Finspector_socket_server.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Finspector_socket_server.cc?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -373,27 +373,17 @@ void InspectorSocketServer::SendListResponse(InspectorSocket* socket,\n     target_map[\"url\"] = delegate_->GetTargetUrl(id);\n     Escape(&target_map[\"url\"]);\n \n-    bool connected = false;\n-    for (const auto& session : connected_sessions_) {\n-      if (session.second.first == id) {\n-        connected = true;\n-        break;\n-      }\n-    }\n-    if (!connected) {\n-      std::string detected_host = host;\n-      if (detected_host.empty()) {\n-        detected_host = FormatHostPort(socket->GetHost(),\n-                                       session->server_port());\n-      }\n-      std::ostringstream frontend_url;\n-      frontend_url << \"chrome-devtools://devtools/bundled\";\n-      frontend_url << \"/inspector.html?experiments=true&v8only=true&ws=\";\n-      frontend_url << FormatAddress(detected_host, id, false);\n-      target_map[\"devtoolsFrontendUrl\"] += frontend_url.str();\n-      target_map[\"webSocketDebuggerUrl\"] =\n-          FormatAddress(detected_host, id, true);\n+    std::string detected_host = host;\n+    if (detected_host.empty()) {\n+      detected_host = FormatHostPort(socket->GetHost(),\n+                                     session->server_port());\n     }\n+    std::ostringstream frontend_url;\n+    frontend_url << \"chrome-devtools://devtools/bundled\";\n+    frontend_url << \"/inspector.html?experiments=true&v8only=true&ws=\";\n+    frontend_url << FormatAddress(detected_host, id, false);\n+    target_map[\"devtoolsFrontendUrl\"] += frontend_url.str();\n+    target_map[\"webSocketDebuggerUrl\"] = FormatAddress(detected_host, id, true);\n   }\n   SendHttpResponse(socket, MapsToString(response));\n }"
        },
        {
            "sha": "d8c0bded38da16fca062b0ae77add4e65d5ca1ef",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -1959,7 +1959,7 @@ static void InitGroups(const FunctionCallbackInfo<Value>& args) {\n \n static void WaitForInspectorDisconnect(Environment* env) {\n #if HAVE_INSPECTOR\n-  if (env->inspector_agent()->delegate() != nullptr) {\n+  if (env->inspector_agent()->HasConnectedSessions()) {\n     // Restore signal dispositions, the app is done and is no longer\n     // capable of handling signals.\n #if defined(__POSIX__) && !defined(NODE_SHARED_MODE)"
        },
        {
            "sha": "e590349f9c2b715aa5c694087d6cb11160f98a59",
            "filename": "test/common/inspector-helper.js",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fcommon%2Finspector-helper.js",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fcommon%2Finspector-helper.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fcommon%2Finspector-helper.js?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -154,8 +154,9 @@ class InspectorSession {\n     return this._terminationPromise;\n   }\n \n-  disconnect() {\n+  async disconnect() {\n     this._socket.destroy();\n+    return this.waitForServerDisconnect();\n   }\n \n   _onMessage(message) {\n@@ -444,6 +445,7 @@ class NodeInstance {\n \n   kill() {\n     this._process.kill();\n+    return this.expectShutdown();\n   }\n \n   scriptPath() {"
        },
        {
            "sha": "62f0feefade88dc282febacb101312068bd25b9f",
            "filename": "test/parallel/test-inspector-esm.js",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fparallel%2Ftest-inspector-esm.js",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fparallel%2Ftest-inspector-esm.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-inspector-esm.js?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -9,12 +9,6 @@ const { resolve: UrlResolve } = require('url');\n const fixtures = require('../common/fixtures');\n const { NodeInstance } = require('../common/inspector-helper.js');\n \n-function assertNoUrlsWhileConnected(response) {\n-  assert.strictEqual(response.length, 1);\n-  assert.ok(!response[0].hasOwnProperty('devtoolsFrontendUrl'));\n-  assert.ok(!response[0].hasOwnProperty('webSocketDebuggerUrl'));\n-}\n-\n function assertScopeValues({ result }, expected) {\n   const unmatched = new Set(Object.keys(expected));\n   for (const actual of result) {\n@@ -110,7 +104,6 @@ async function runTest() {\n                                  '', fixtures.path('es-modules/loop.mjs'));\n \n   const session = await child.connectInspectorSession();\n-  assertNoUrlsWhileConnected(await child.httpGet(null, '/json/list'));\n   await testBreakpointOnStart(session);\n   await testBreakpoint(session);\n   await session.runToCompletion();"
        },
        {
            "sha": "58533f4cd6241ee999a37f5e00851f6bf1ac84b7",
            "filename": "test/parallel/test-inspector-multisession-js.js",
            "status": "added",
            "additions": 59,
            "deletions": 0,
            "changes": 59,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fparallel%2Ftest-inspector-multisession-js.js",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fparallel%2Ftest-inspector-multisession-js.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-inspector-multisession-js.js?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -0,0 +1,59 @@\n+'use strict';\n+const common = require('../common');\n+\n+common.skipIfInspectorDisabled();\n+\n+const assert = require('assert');\n+const { Session } = require('inspector');\n+const path = require('path');\n+\n+function debugged() {\n+  return 42;\n+}\n+\n+async function test() {\n+  const session1 = new Session();\n+  const session2 = new Session();\n+\n+  session1.connect();\n+  session2.connect();\n+\n+  let session1Paused = false;\n+  let session2Paused = false;\n+\n+  session1.on('Debugger.paused', () => session1Paused = true);\n+  session2.on('Debugger.paused', () => session2Paused = true);\n+\n+  console.log('Connected');\n+\n+  session1.post('Debugger.enable');\n+  session2.post('Debugger.enable');\n+  console.log('Debugger was enabled');\n+\n+  await new Promise((resolve, reject) => {\n+    session1.post('Debugger.setBreakpointByUrl', {\n+      'lineNumber': 9,\n+      'url': path.resolve(__dirname, __filename),\n+      'columnNumber': 0,\n+      'condition': ''\n+    }, (error, result) => {\n+      return error ? reject(error) : resolve(result);\n+    });\n+  });\n+  console.log('Breakpoint was set');\n+\n+  debugged();\n+\n+  // Both sessions will receive the paused event\n+  assert(session1Paused);\n+  assert(session2Paused);\n+  console.log('Breakpoint was hit');\n+\n+  session1.disconnect();\n+  session2.disconnect();\n+  console.log('Sessions were disconnected');\n+}\n+\n+common.crashOnUnhandledRejection();\n+\n+test();"
        },
        {
            "sha": "d17adab2f486ccccd17c0b8c814597251feff358",
            "filename": "test/parallel/test-inspector-multisession-ws.js",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fparallel%2Ftest-inspector-multisession-ws.js",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fparallel%2Ftest-inspector-multisession-ws.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-inspector-multisession-ws.js?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -0,0 +1,75 @@\n+// Flags: --expose-internals\n+'use strict';\n+const common = require('../common');\n+\n+common.skipIfInspectorDisabled();\n+\n+const { NodeInstance } = require('../common/inspector-helper.js');\n+\n+// Sets up JS bindings session and runs till the \"paused\" event\n+const script = `\n+const { Session } = require('inspector');\n+const session = new Session();\n+let done = false;\n+const interval = setInterval(() => {\n+  if (done)\n+    clearInterval(interval);\n+}, 150);\n+session.on('Debugger.paused', () => {\n+  done = true;\n+});\n+session.connect();\n+session.post('Debugger.enable');\n+console.log('Ready');\n+`;\n+\n+async function setupSession(node) {\n+  const session = await node.connectInspectorSession();\n+  await session.send([\n+    { 'method': 'Runtime.enable' },\n+    { 'method': 'Debugger.enable' },\n+    { 'method': 'Debugger.setPauseOnExceptions',\n+      'params': { 'state': 'none' } },\n+    { 'method': 'Debugger.setAsyncCallStackDepth',\n+      'params': { 'maxDepth': 0 } },\n+    { 'method': 'Profiler.enable' },\n+    { 'method': 'Profiler.setSamplingInterval',\n+      'params': { 'interval': 100 } },\n+    { 'method': 'Debugger.setBlackboxPatterns',\n+      'params': { 'patterns': [] } },\n+    { 'method': 'Runtime.runIfWaitingForDebugger' }\n+  ]);\n+  return session;\n+}\n+\n+async function testSuspend(sessionA, sessionB) {\n+  console.log('[test]', 'Breaking in code and verifying events are fired');\n+  await sessionA.waitForNotification('Debugger.paused', 'Initial pause');\n+  sessionA.send({ 'method': 'Debugger.resume' });\n+\n+  await sessionA.waitForNotification('Runtime.consoleAPICalled',\n+                                     'Console output');\n+  sessionA.send({ 'method': 'Debugger.pause' });\n+  return Promise.all([\n+    sessionA.waitForNotification('Debugger.paused', 'SessionA paused'),\n+    sessionB.waitForNotification('Debugger.paused', 'SessionB paused')\n+  ]);\n+}\n+\n+async function runTest() {\n+  const child = new NodeInstance(undefined, script);\n+\n+  const [session1, session2] =\n+      await Promise.all([setupSession(child), setupSession(child)]);\n+  await testSuspend(session2, session1);\n+  console.log('[test]', 'Should shut down after both sessions disconnect');\n+\n+  await session1.runToCompletion();\n+  await session2.send({ 'method': 'Debugger.disable' });\n+  await session2.disconnect();\n+  return child.expectShutdown();\n+}\n+\n+common.crashOnUnhandledRejection();\n+\n+runTest();"
        },
        {
            "sha": "15fa96952ed125d246b883cb99487d533be0cbfc",
            "filename": "test/parallel/test-inspector-no-crash-ws-after-bindings.js",
            "status": "removed",
            "additions": 0,
            "deletions": 31,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/5c57cea8049bad5939807e6b849ee303ec8e1526/test%2Fparallel%2Ftest-inspector-no-crash-ws-after-bindings.js",
            "raw_url": "https://github.com/nodejs/node/raw/5c57cea8049bad5939807e6b849ee303ec8e1526/test%2Fparallel%2Ftest-inspector-no-crash-ws-after-bindings.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-inspector-no-crash-ws-after-bindings.js?ref=5c57cea8049bad5939807e6b849ee303ec8e1526",
            "patch": "@@ -1,31 +0,0 @@\n-// Flags: --expose-internals\n-'use strict';\n-const common = require('../common');\n-common.skipIfInspectorDisabled();\n-common.crashOnUnhandledRejection();\n-const { NodeInstance } = require('../common/inspector-helper.js');\n-const assert = require('assert');\n-\n-const expected = 'Can connect now!';\n-\n-const script = `\n-  'use strict';\n-  const { Session } = require('inspector');\n-\n-  const s = new Session();\n-  s.connect();\n-  console.error('${expected}');\n-  process.stdin.on('data', () => process.exit(0));\n-`;\n-\n-async function runTests() {\n-  const instance = new NodeInstance(['--inspect=0', '--expose-internals'],\n-                                    script);\n-  while (await instance.nextStderrString() !== expected);\n-  assert.strictEqual(400, await instance.expectConnectionDeclined());\n-  instance.write('Stop!\\n');\n-  assert.deepStrictEqual({ exitCode: 0, signal: null },\n-                         await instance.expectShutdown());\n-}\n-\n-runTests();"
        },
        {
            "sha": "c23c8520e0601d6bb5e310a74c6aec1bf4b1d45f",
            "filename": "test/sequential/test-inspector-bindings.js",
            "status": "modified",
            "additions": 0,
            "deletions": 9,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fsequential%2Ftest-inspector-bindings.js",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fsequential%2Ftest-inspector-bindings.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-inspector-bindings.js?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -76,15 +76,6 @@ function testSampleDebugSession() {\n   };\n   const session = new inspector.Session();\n   session.connect();\n-  let secondSessionOpened = false;\n-  const secondSession = new inspector.Session();\n-  try {\n-    secondSession.connect();\n-    secondSessionOpened = true;\n-  } catch (error) {\n-    // expected as the session already exists\n-  }\n-  assert.strictEqual(secondSessionOpened, false);\n   session.on('Debugger.paused',\n              (notification) => debuggerPausedCallback(session, notification));\n   let cbAsSecondArgCalled = false;"
        },
        {
            "sha": "eaecd49c982311c3728b6f00648f51933122ad11",
            "filename": "test/sequential/test-inspector-module.js",
            "status": "modified",
            "additions": 0,
            "deletions": 10,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fsequential%2Ftest-inspector-module.js",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fsequential%2Ftest-inspector-module.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-inspector-module.js?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -55,16 +55,6 @@ common.expectsError(\n   }\n );\n \n-const session2 = new Session();\n-common.expectsError(\n-  () => session2.connect(),\n-  {\n-    code: 'ERR_INSPECTOR_ALREADY_CONNECTED',\n-    type: Error,\n-    message: 'Another inspector session is already connected'\n-  }\n-);\n-\n session.disconnect();\n // Calling disconnect twice should not throw.\n session.disconnect();"
        },
        {
            "sha": "0a9b2ccd1abd3d7002e4a13bc8f13876911fbe6d",
            "filename": "test/sequential/test-inspector.js",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fsequential%2Ftest-inspector.js",
            "raw_url": "https://github.com/nodejs/node/raw/13001035340d6d3fb173fef4a1db42ba70f61720/test%2Fsequential%2Ftest-inspector.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-inspector.js?ref=13001035340d6d3fb173fef4a1db42ba70f61720",
            "patch": "@@ -37,12 +37,6 @@ function checkException(message) {\n                      'An exception occurred during execution');\n }\n \n-function assertNoUrlsWhileConnected(response) {\n-  assert.strictEqual(1, response.length);\n-  assert.ok(!response[0].hasOwnProperty('devtoolsFrontendUrl'));\n-  assert.ok(!response[0].hasOwnProperty('webSocketDebuggerUrl'));\n-}\n-\n function assertScopeValues({ result }, expected) {\n   const unmatched = new Set(Object.keys(expected));\n   for (const actual of result) {\n@@ -290,7 +284,6 @@ async function runTest() {\n   await child.httpGet(null, '/json/badpath').catch(checkBadPath);\n \n   const session = await child.connectInspectorSession();\n-  assertNoUrlsWhileConnected(await child.httpGet(null, '/json/list'));\n   await testBreakpointOnStart(session);\n   await testBreakpoint(session);\n   await testI18NCharacters(session);"
        }
    ],
    "stats": {
        "total": 544,
        "additions": 290,
        "deletions": 254
    }
}