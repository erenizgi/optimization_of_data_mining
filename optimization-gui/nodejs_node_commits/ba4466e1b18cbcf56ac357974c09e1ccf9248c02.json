{
    "author": "addaleax",
    "message": "test: use blocks instead of async IIFE\n\nUsing an IIFE with async functions + await is equivalent\nto using a block scope (aside from scoping effects\nwe don’t rely on), as far as I can tell.\n\nPR-URL: https://github.com/nodejs/node/pull/24989\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: Michaël Zasso <targos@protonmail.com>\nReviewed-By: Anto Aravinth <anto.aravinth.cse@gmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>",
    "sha": "ba4466e1b18cbcf56ac357974c09e1ccf9248c02",
    "files": [
        {
            "sha": "13da0d9c4514af2d34fdb1ab15eb5fe65df4081e",
            "filename": "test/parallel/test-stream-readable-async-iterators.js",
            "status": "modified",
            "additions": 38,
            "deletions": 38,
            "changes": 76,
            "blob_url": "https://github.com/nodejs/node/blob/ba4466e1b18cbcf56ac357974c09e1ccf9248c02/test%2Fparallel%2Ftest-stream-readable-async-iterators.js",
            "raw_url": "https://github.com/nodejs/node/raw/ba4466e1b18cbcf56ac357974c09e1ccf9248c02/test%2Fparallel%2Ftest-stream-readable-async-iterators.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-stream-readable-async-iterators.js?ref=ba4466e1b18cbcf56ac357974c09e1ccf9248c02",
            "patch": "@@ -14,7 +14,7 @@ async function tests() {\n       AsyncIteratorPrototype);\n   }\n \n-  await (async function() {\n+  {\n     const readable = new Readable({ objectMode: true, read() {} });\n     readable.push(0);\n     readable.push(1);\n@@ -25,9 +25,9 @@ async function tests() {\n     for await (const d of iter) {\n       assert.strictEqual(d, 1);\n     }\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('read without for..await');\n     const max = 5;\n     const readable = new Readable({\n@@ -55,9 +55,9 @@ async function tests() {\n \n     const last = await iter.next();\n     assert.strictEqual(last.done, true);\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('read without for..await deferred');\n     const readable = new Readable({\n       objectMode: true,\n@@ -95,9 +95,9 @@ async function tests() {\n \n     const last = await iter.next();\n     assert.strictEqual(last.done, true);\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('read without for..await with errors');\n     const max = 3;\n     const readable = new Readable({\n@@ -133,9 +133,9 @@ async function tests() {\n     });\n \n     readable.destroy(new Error('kaboom'));\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('call next() after error');\n     const readable = new Readable({\n       read() {}\n@@ -145,9 +145,9 @@ async function tests() {\n     const err = new Error('kaboom');\n     readable.destroy(new Error('kaboom'));\n     await assert.rejects(iterator.next.bind(iterator), err);\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('read object mode');\n     const max = 42;\n     let readed = 0;\n@@ -168,9 +168,9 @@ async function tests() {\n     }\n \n     assert.strictEqual(readed, received);\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('destroy sync');\n     const readable = new Readable({\n       objectMode: true,\n@@ -187,9 +187,9 @@ async function tests() {\n       err = e;\n     }\n     assert.strictEqual(err.message, 'kaboom from read');\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('destroy async');\n     const readable = new Readable({\n       objectMode: true,\n@@ -219,9 +219,9 @@ async function tests() {\n \n     assert.strictEqual(err.message, 'kaboom');\n     assert.strictEqual(received, 1);\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('destroyed by throw');\n     const readable = new Readable({\n       objectMode: true,\n@@ -242,9 +242,9 @@ async function tests() {\n \n     assert.strictEqual(err.message, 'kaboom');\n     assert.strictEqual(readable.destroyed, true);\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('destroyed sync after push');\n     const readable = new Readable({\n       objectMode: true,\n@@ -268,9 +268,9 @@ async function tests() {\n \n     assert.strictEqual(err.message, 'kaboom');\n     assert.strictEqual(received, 1);\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('push async');\n     const max = 42;\n     let readed = 0;\n@@ -293,9 +293,9 @@ async function tests() {\n     }\n \n     assert.strictEqual(readed, received);\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('push binary async');\n     const max = 42;\n     let readed = 0;\n@@ -323,9 +323,9 @@ async function tests() {\n     }\n \n     assert.strictEqual(data, expected);\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('.next() on destroyed stream');\n     const readable = new Readable({\n       read() {\n@@ -337,9 +337,9 @@ async function tests() {\n \n     const { done } = await readable[Symbol.asyncIterator]().next();\n     assert.strictEqual(done, true);\n-  })();\n+  }\n \n-  await (async function() {\n+  {\n     console.log('.next() on pipelined stream');\n     const readable = new Readable({\n       read() {\n@@ -358,9 +358,9 @@ async function tests() {\n     } catch (e) {\n       assert.strictEqual(e, err);\n     }\n-  })();\n+  }\n \n-  await (async () => {\n+  {\n     console.log('iterating on an ended stream completes');\n     const r = new Readable({\n       objectMode: true,\n@@ -376,9 +376,9 @@ async function tests() {\n     // eslint-disable-next-line no-unused-vars\n     for await (const b of r) {\n     }\n-  })();\n+  }\n \n-  await (async () => {\n+  {\n     console.log('destroy mid-stream does not error');\n     const r = new Readable({\n       objectMode: true,\n@@ -392,9 +392,9 @@ async function tests() {\n     for await (const a of r) {\n       r.destroy(null);\n     }\n-  })();\n+  }\n \n-  await (async () => {\n+  {\n     console.log('all next promises must be resolved on end');\n     const r = new Readable({\n       objectMode: true,\n@@ -408,9 +408,9 @@ async function tests() {\n     r.push(null);\n     assert.deepStrictEqual(await c, { done: true, value: undefined });\n     assert.deepStrictEqual(await d, { done: true, value: undefined });\n-  })();\n+  }\n \n-  await (async () => {\n+  {\n     console.log('all next promises must be resolved on destroy');\n     const r = new Readable({\n       objectMode: true,\n@@ -424,9 +424,9 @@ async function tests() {\n     r.destroy();\n     assert.deepStrictEqual(await c, { done: true, value: undefined });\n     assert.deepStrictEqual(await d, { done: true, value: undefined });\n-  })();\n+  }\n \n-  await (async () => {\n+  {\n     console.log('all next promises must be resolved on destroy with error');\n     const r = new Readable({\n       objectMode: true,\n@@ -457,7 +457,7 @@ async function tests() {\n       }\n       assert.strictEqual(e, err);\n     })()]);\n-  })();\n+  }\n }\n \n // to avoid missing some tests if a promise does not resolve"
        }
    ],
    "stats": {
        "total": 76,
        "additions": 38,
        "deletions": 38
    }
}