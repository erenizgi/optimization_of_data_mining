{
    "author": "addaleax",
    "message": "src: unify ReqWrap libuv calling\n\nThis allows easier tracking of whether there are active `ReqWrap`s.\n\nMany thanks for Stephen Belanger for reviewing the original version of\nthis commit in the Ayo.js project.\n\nRefs: https://github.com/ayojs/ayo/pull/85\nPR-URL: https://github.com/nodejs/node/pull/19377\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "cac8496c2ff592198a7afd114610deccb0e178ab",
    "files": [
        {
            "sha": "f829eb2b01d5c9268e0d984c3dccad74a6ce7d69",
            "filename": "src/cares_wrap.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 14,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Fcares_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Fcares_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fcares_wrap.cc?ref=cac8496c2ff592198a7afd114610deccb0e178ab",
            "patch": "@@ -515,7 +515,7 @@ ChannelWrap::~ChannelWrap() {\n void ChannelWrap::CleanupTimer() {\n   if (timer_handle_ == nullptr) return;\n \n-  env()->CloseHandle(timer_handle_, [](uv_timer_t* handle){ delete handle; });\n+  env()->CloseHandle(timer_handle_, [](uv_timer_t* handle) { delete handle; });\n   timer_handle_ = nullptr;\n }\n \n@@ -1927,13 +1927,11 @@ void GetAddrInfo(const FunctionCallbackInfo<Value>& args) {\n   hints.ai_socktype = SOCK_STREAM;\n   hints.ai_flags = flags;\n \n-  int err = uv_getaddrinfo(env->event_loop(),\n-                           req_wrap->req(),\n-                           AfterGetAddrInfo,\n-                           *hostname,\n-                           nullptr,\n-                           &hints);\n-  req_wrap->Dispatched();\n+  int err = req_wrap->Dispatch(uv_getaddrinfo,\n+                               AfterGetAddrInfo,\n+                               *hostname,\n+                               nullptr,\n+                               &hints);\n   if (err)\n     delete req_wrap;\n \n@@ -1957,12 +1955,10 @@ void GetNameInfo(const FunctionCallbackInfo<Value>& args) {\n \n   GetNameInfoReqWrap* req_wrap = new GetNameInfoReqWrap(env, req_wrap_obj);\n \n-  int err = uv_getnameinfo(env->event_loop(),\n-                           req_wrap->req(),\n-                           AfterGetNameInfo,\n-                           (struct sockaddr*)&addr,\n-                           NI_NAMEREQD);\n-  req_wrap->Dispatched();\n+  int err = req_wrap->Dispatch(uv_getnameinfo,\n+                               AfterGetNameInfo,\n+                               reinterpret_cast<struct sockaddr*>(&addr),\n+                               NI_NAMEREQD);\n   if (err)\n     delete req_wrap;\n "
        },
        {
            "sha": "713dcbf633189800cdb3a51e17de8f8514fb14dd",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 19,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=cac8496c2ff592198a7afd114610deccb0e178ab",
            "patch": "@@ -89,6 +89,11 @@ using v8::Value;\n   TRACE_EVENT_END(TRACING_CATEGORY_NODE2(fs, sync), TRACE_NAME(syscall),   \\\n   ##__VA_ARGS__);\n \n+// We sometimes need to convert a C++ lambda function to a raw C-style function.\n+// This is helpful, because ReqWrap::Dispatch() does not recognize lambda\n+// functions, and thus does not wrap them properly.\n+typedef void(*uv_fs_callback_t)(uv_fs_t*);\n+\n // The FileHandle object wraps a file descriptor and will close it on garbage\n // collection if necessary. If that happens, a process warning will be\n // emitted (or a fatal exception will occur if the fd cannot be closed.)\n@@ -216,7 +221,7 @@ inline MaybeLocal<Promise> FileHandle::ClosePromise() {\n   if (!closed_ && !closing_) {\n     closing_ = true;\n     CloseReq* req = new CloseReq(env(), promise, object());\n-    auto AfterClose = [](uv_fs_t* req) {\n+    auto AfterClose = uv_fs_callback_t{[](uv_fs_t* req) {\n       CloseReq* close = static_cast<CloseReq*>(req->data);\n       CHECK_NE(close, nullptr);\n       close->file_handle()->AfterClose();\n@@ -227,9 +232,8 @@ inline MaybeLocal<Promise> FileHandle::ClosePromise() {\n         close->Resolve();\n       }\n       delete close;\n-    };\n-    req->Dispatched();\n-    int ret = uv_fs_close(env()->event_loop(), req->req(), fd_, AfterClose);\n+    }};\n+    int ret = req->Dispatch(uv_fs_close, fd_, AfterClose);\n     if (ret < 0) {\n       req->Reject(UVException(isolate, ret, \"close\"));\n       delete req;\n@@ -309,17 +313,15 @@ int FileHandle::ReadStart() {\n     recommended_read = read_length_;\n \n   read_wrap->buffer_ = EmitAlloc(recommended_read);\n-  read_wrap->Dispatched();\n \n   current_read_ = std::move(read_wrap);\n \n-  uv_fs_read(env()->event_loop(),\n-             current_read_->req(),\n-             fd_,\n-             &current_read_->buffer_,\n-             1,\n-             read_offset_,\n-             [](uv_fs_t* req) {\n+  current_read_->Dispatch(uv_fs_read,\n+                          fd_,\n+                          &current_read_->buffer_,\n+                          1,\n+                          read_offset_,\n+                          uv_fs_callback_t{[](uv_fs_t* req) {\n     FileHandle* handle;\n     {\n       FileHandleReadWrap* req_wrap = FileHandleReadWrap::from_req(req);\n@@ -342,8 +344,10 @@ int FileHandle::ReadStart() {\n     // once we’re exiting the current scope.\n     constexpr size_t wanted_freelist_fill = 100;\n     auto& freelist = handle->env()->file_handle_read_wrap_freelist();\n-    if (freelist.size() < wanted_freelist_fill)\n+    if (freelist.size() < wanted_freelist_fill) {\n+      read_wrap->Reset();\n       freelist.emplace_back(std::move(read_wrap));\n+    }\n \n     if (result >= 0) {\n       // Read at most as many bytes as we originally planned to.\n@@ -370,7 +374,7 @@ int FileHandle::ReadStart() {\n     // Start over, if EmitRead() didn’t tell us to stop.\n     if (handle->reading_)\n       handle->ReadStart();\n-  });\n+  }});\n \n   return 0;\n }\n@@ -389,8 +393,7 @@ ShutdownWrap* FileHandle::CreateShutdownWrap(Local<Object> object) {\n int FileHandle::DoShutdown(ShutdownWrap* req_wrap) {\n   FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(req_wrap);\n   closing_ = true;\n-  wrap->Dispatched();\n-  uv_fs_close(env()->event_loop(), wrap->req(), fd_, [](uv_fs_t* req) {\n+  wrap->Dispatch(uv_fs_close, fd_, uv_fs_callback_t{[](uv_fs_t* req) {\n     FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(\n         FileHandleCloseWrap::from_req(req));\n     FileHandle* handle = static_cast<FileHandle*>(wrap->stream());\n@@ -399,7 +402,7 @@ int FileHandle::DoShutdown(ShutdownWrap* req_wrap) {\n     int result = req->result;\n     uv_fs_req_cleanup(req);\n     wrap->Done(result);\n-  });\n+  }});\n \n   return 0;\n }\n@@ -616,8 +619,7 @@ inline FSReqBase* AsyncDestCall(Environment* env,\n     enum encoding enc, uv_fs_cb after, Func fn, Args... fn_args) {\n   CHECK_NE(req_wrap, nullptr);\n   req_wrap->Init(syscall, dest, len, enc);\n-  int err = fn(env->event_loop(), req_wrap->req(), fn_args..., after);\n-  req_wrap->Dispatched();\n+  int err = req_wrap->Dispatch(fn, fn_args..., after);\n   if (err < 0) {\n     uv_fs_t* uv_req = req_wrap->req();\n     uv_req->result = err;"
        },
        {
            "sha": "7ec5bdf15be9ccd74f3956a4a7e7b0c026ee7afc",
            "filename": "src/pipe_wrap.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Fpipe_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Fpipe_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fpipe_wrap.cc?ref=cac8496c2ff592198a7afd114610deccb0e178ab",
            "patch": "@@ -224,11 +224,10 @@ void PipeWrap::Connect(const FunctionCallbackInfo<Value>& args) {\n \n   ConnectWrap* req_wrap =\n       new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_PIPECONNECTWRAP);\n-  uv_pipe_connect(req_wrap->req(),\n-                  &wrap->handle_,\n-                  *name,\n-                  AfterConnect);\n-  req_wrap->Dispatched();\n+  req_wrap->Dispatch(uv_pipe_connect,\n+                     &wrap->handle_,\n+                     *name,\n+                     AfterConnect);\n \n   args.GetReturnValue().Set(0);  // uv_pipe_connect() doesn't return errors.\n }"
        },
        {
            "sha": "54abf74430f6afd782e0828f2a0aff502237ceb9",
            "filename": "src/req_wrap-inl.h",
            "status": "modified",
            "additions": 104,
            "deletions": 0,
            "changes": 104,
            "blob_url": "https://github.com/nodejs/node/blob/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Freq_wrap-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Freq_wrap-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Freq_wrap-inl.h?ref=cac8496c2ff592198a7afd114610deccb0e178ab",
            "patch": "@@ -43,6 +43,110 @@ void ReqWrap<T>::Cancel() {\n   uv_cancel(reinterpret_cast<uv_req_t*>(&req_));\n }\n \n+// Below is dark template magic designed to invoke libuv functions that\n+// initialize uv_req_t instances in a unified fashion, to allow easier\n+// tracking of active/inactive requests.\n+\n+// Invoke a generic libuv function that initializes uv_req_t instances.\n+// This is, unfortunately, necessary since they come in three different\n+// variants that can not all be invoked in the same way:\n+// - int uv_foo(uv_loop_t* loop, uv_req_t* request, ...);\n+// - int uv_foo(uv_req_t* request, ...);\n+// - void uv_foo(uv_req_t* request, ...);\n+template <typename ReqT, typename T>\n+struct CallLibuvFunction;\n+\n+// Detect `int uv_foo(uv_loop_t* loop, uv_req_t* request, ...);`.\n+template <typename ReqT, typename... Args>\n+struct CallLibuvFunction<ReqT, int(*)(uv_loop_t*, ReqT*, Args...)> {\n+  using T = int(*)(uv_loop_t*, ReqT*, Args...);\n+  template <typename... PassedArgs>\n+  static int Call(T fn, uv_loop_t* loop, ReqT* req, PassedArgs... args) {\n+    return fn(loop, req, args...);\n+  }\n+};\n+\n+// Detect `int uv_foo(uv_req_t* request, ...);`.\n+template <typename ReqT, typename... Args>\n+struct CallLibuvFunction<ReqT, int(*)(ReqT*, Args...)> {\n+  using T = int(*)(ReqT*, Args...);\n+  template <typename... PassedArgs>\n+  static int Call(T fn, uv_loop_t* loop, ReqT* req, PassedArgs... args) {\n+    return fn(req, args...);\n+  }\n+};\n+\n+// Detect `void uv_foo(uv_req_t* request, ...);`.\n+template <typename ReqT, typename... Args>\n+struct CallLibuvFunction<ReqT, void(*)(ReqT*, Args...)> {\n+  using T = void(*)(ReqT*, Args...);\n+  template <typename... PassedArgs>\n+  static int Call(T fn, uv_loop_t* loop, ReqT* req, PassedArgs... args) {\n+    fn(req, args...);\n+    return 0;\n+  }\n+};\n+\n+// This is slightly darker magic: This template is 'applied' to each parameter\n+// passed to the libuv function. If the parameter type (aka `T`) is a\n+// function type, it is assumed that this it is the request callback, and a\n+// wrapper that calls the original callback is created.\n+// If not, the parameter is passed through verbatim.\n+template <typename ReqT, typename T>\n+struct MakeLibuvRequestCallback {\n+  static T For(ReqWrap<ReqT>* req_wrap, T v) {\n+    static_assert(!std::is_function<T>::value,\n+                  \"MakeLibuvRequestCallback missed a callback\");\n+    return v;\n+  }\n+};\n+\n+// Match the `void callback(uv_req_t*, ...);` signature that all libuv\n+// callbacks use.\n+template <typename ReqT, typename... Args>\n+struct MakeLibuvRequestCallback<ReqT, void(*)(ReqT*, Args...)> {\n+  using F = void(*)(ReqT* req, Args... args);\n+\n+  static void Wrapper(ReqT* req, Args... args) {\n+    ReqWrap<ReqT>* req_wrap = ContainerOf(&ReqWrap<ReqT>::req_, req);\n+    F original_callback = reinterpret_cast<F>(req_wrap->original_callback_);\n+    original_callback(req, args...);\n+  }\n+\n+  static F For(ReqWrap<ReqT>* req_wrap, F v) {\n+    CHECK_EQ(req_wrap->original_callback_, nullptr);\n+    req_wrap->original_callback_ =\n+        reinterpret_cast<typename ReqWrap<ReqT>::callback_t>(v);\n+    return Wrapper;\n+  }\n+};\n+\n+template <typename T>\n+template <typename LibuvFunction, typename... Args>\n+int ReqWrap<T>::Dispatch(LibuvFunction fn, Args... args) {\n+  Dispatched();\n+\n+  // This expands as:\n+  //\n+  // return fn(env()->event_loop(), req(), arg1, arg2, Wrapper, arg3, ...)\n+  //           ^                                       ^        ^\n+  //           |                                       |        |\n+  //           \\-- Omitted if `fn` has no              |        |\n+  //               first `uv_loop_t*` argument         |        |\n+  //                                                   |        |\n+  //     A function callback whose first argument      |        |\n+  //     matches the libuv request type is replaced ---/        |\n+  //     by the `Wrapper` method defined above                  |\n+  //                                                            |\n+  //            Other (non-function) arguments are passed  -----/\n+  //            through verbatim\n+  return CallLibuvFunction<T, LibuvFunction>::Call(\n+      fn,\n+      env()->event_loop(),\n+      req(),\n+      MakeLibuvRequestCallback<T, Args>::For(this, args)...);\n+}\n+\n }  // namespace node\n \n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS"
        },
        {
            "sha": "d181817218227b7636abdae47edf4906602304ae",
            "filename": "src/req_wrap.h",
            "status": "modified",
            "additions": 12,
            "deletions": 1,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Freq_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Freq_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Freq_wrap.h?ref=cac8496c2ff592198a7afd114610deccb0e178ab",
            "patch": "@@ -17,17 +17,28 @@ class ReqWrap : public AsyncWrap {\n                  v8::Local<v8::Object> object,\n                  AsyncWrap::ProviderType provider);\n   inline ~ReqWrap() override;\n-  inline void Dispatched();  // Call this after the req has been dispatched.\n+  // Call this after the req has been dispatched, if that did not already\n+  // happen by using Dispatch().\n+  inline void Dispatched();\n   T* req() { return &req_; }\n   inline void Cancel();\n \n   static ReqWrap* from_req(T* req);\n \n+  template <typename LibuvFunction, typename... Args>\n+  inline int Dispatch(LibuvFunction fn, Args... args);\n+\n  private:\n   friend class Environment;\n   friend int GenDebugSymbols();\n+  template <typename ReqT, typename U>\n+  friend struct MakeLibuvRequestCallback;\n+\n   ListNode<ReqWrap> req_wrap_queue_;\n \n+  typedef void (*callback_t)();\n+  callback_t original_callback_ = nullptr;\n+\n  protected:\n   // req_wrap_queue_ needs to be at a fixed offset from the start of the class\n   // because it is used by ContainerOf to calculate the address of the embedding"
        },
        {
            "sha": "70c60fa47cc68f3eef69bc678921388baa8e08ae",
            "filename": "src/tcp_wrap.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 10,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Ftcp_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Ftcp_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftcp_wrap.cc?ref=cac8496c2ff592198a7afd114610deccb0e178ab",
            "patch": "@@ -287,11 +287,10 @@ void TCPWrap::Connect(const FunctionCallbackInfo<Value>& args) {\n     AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap);\n     ConnectWrap* req_wrap =\n         new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_TCPCONNECTWRAP);\n-    err = uv_tcp_connect(req_wrap->req(),\n-                         &wrap->handle_,\n-                         reinterpret_cast<const sockaddr*>(&addr),\n-                         AfterConnect);\n-    req_wrap->Dispatched();\n+    err = req_wrap->Dispatch(uv_tcp_connect,\n+                             &wrap->handle_,\n+                             reinterpret_cast<const sockaddr*>(&addr),\n+                             AfterConnect);\n     if (err)\n       delete req_wrap;\n   }\n@@ -323,11 +322,10 @@ void TCPWrap::Connect6(const FunctionCallbackInfo<Value>& args) {\n     AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap);\n     ConnectWrap* req_wrap =\n         new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_TCPCONNECTWRAP);\n-    err = uv_tcp_connect(req_wrap->req(),\n-                         &wrap->handle_,\n-                         reinterpret_cast<const sockaddr*>(&addr),\n-                         AfterConnect);\n-    req_wrap->Dispatched();\n+    err = req_wrap->Dispatch(uv_tcp_connect,\n+                             &wrap->handle_,\n+                             reinterpret_cast<const sockaddr*>(&addr),\n+                             AfterConnect);\n     if (err)\n       delete req_wrap;\n   }"
        },
        {
            "sha": "1d1ded449bd22177671185fcb47b78f31801679e",
            "filename": "src/udp_wrap.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Fudp_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/cac8496c2ff592198a7afd114610deccb0e178ab/src%2Fudp_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fudp_wrap.cc?ref=cac8496c2ff592198a7afd114610deccb0e178ab",
            "patch": "@@ -380,15 +380,14 @@ void UDPWrap::DoSend(const FunctionCallbackInfo<Value>& args, int family) {\n   }\n \n   if (err == 0) {\n-    err = uv_udp_send(req_wrap->req(),\n-                      &wrap->handle_,\n-                      *bufs,\n-                      count,\n-                      reinterpret_cast<const sockaddr*>(&addr),\n-                      OnSend);\n+    err = req_wrap->Dispatch(uv_udp_send,\n+                             &wrap->handle_,\n+                             *bufs,\n+                             count,\n+                             reinterpret_cast<const sockaddr*>(&addr),\n+                             OnSend);\n   }\n \n-  req_wrap->Dispatched();\n   if (err)\n     delete req_wrap;\n "
        }
    ],
    "stats": {
        "total": 221,
        "additions": 165,
        "deletions": 56
    }
}