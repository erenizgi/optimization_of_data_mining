{
    "author": "joyeecheung",
    "message": "fs: throw errors on invalid paths synchronously\n\n- Throw getPathFromURL() and nullCheck() errors synchronously instead\n  of deferring them to the next tick, since we already throw\n  validatePath() errors synchronously.\n- Merge nullCheck() into validatePath()\n- Never throws in `fs.exists()`, instead, invoke the callback with\n  false, or emit a warning when the callback is not a function.\n  This is to bring it inline with fs.existsSync(), which never throws.\n- Updates the comment of rethrow()\n- Throw ERR_INVALID_ARG_VALUE for null checks\n\nPR-URL: https://github.com/nodejs/node/pull/18308\nReviewed-By: Gireesh Punathil <gpunathi@in.ibm.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "d8f73385e220d54de9f9c53da8d8693813e6d774",
    "files": [
        {
            "sha": "56acc657912bbeb4a4e56b1da1fd68f53c1f194a",
            "filename": "lib/fs.js",
            "status": "modified",
            "additions": 153,
            "deletions": 251,
            "changes": 404,
            "blob_url": "https://github.com/nodejs/node/blob/d8f73385e220d54de9f9c53da8d8693813e6d774/lib%2Ffs.js",
            "raw_url": "https://github.com/nodejs/node/raw/d8f73385e220d54de9f9c53da8d8693813e6d774/lib%2Ffs.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ffs.js?ref=d8f73385e220d54de9f9c53da8d8693813e6d774",
            "patch": "@@ -108,8 +108,9 @@ function copyObject(source) {\n   return target;\n }\n \n+// TODO(joyeecheung): explore how the deprecation could be solved via linting\n+// rules. See https://github.com/nodejs/node/pull/12976\n function rethrow() {\n-  // TODO(thefourtheye) Throw error instead of warning in major version > 7\n   process.emitWarning(\n     'Calling an asynchronous function without callback is deprecated.',\n     'DeprecationWarning', 'DEP0013', rethrow\n@@ -207,6 +208,34 @@ function validateOffsetLengthWrite(offset, length, byteLength) {\n   }\n }\n \n+// Check if the path contains null types if it is a string nor Uint8Array,\n+// otherwise return silently.\n+function nullCheck(path, propName, throwError = true) {\n+  const pathIsString = typeof path === 'string';\n+  const pathIsUint8Array = isUint8Array(path);\n+\n+  // We can only perform meaningful checks on strings and Uint8Arrays.\n+  if (!pathIsString && !pathIsUint8Array) {\n+    return;\n+  }\n+\n+  if (pathIsString && path.indexOf('\\u0000') === -1) {\n+    return;\n+  } else if (pathIsUint8Array && path.indexOf(0) === -1) {\n+    return;\n+  }\n+\n+  const err = new errors.Error(\n+    'ERR_INVALID_ARG_VALUE', propName, path,\n+    'must be a string or Uint8Array without null bytes');\n+\n+  if (throwError) {\n+    Error.captureStackTrace(err, nullCheck);\n+    throw err;\n+  }\n+  return err;\n+}\n+\n function validatePath(path, propName) {\n   let err;\n \n@@ -217,6 +246,8 @@ function validatePath(path, propName) {\n   if (typeof path !== 'string' && !isUint8Array(path)) {\n     err = new errors.TypeError('ERR_INVALID_ARG_TYPE', propName,\n                                ['string', 'Buffer', 'URL']);\n+  } else {\n+    err = nullCheck(path, propName, false);\n   }\n \n   if (err !== undefined) {\n@@ -255,21 +286,6 @@ function makeStatsCallback(cb) {\n   };\n }\n \n-function nullCheck(path, callback) {\n-  if (('' + path).indexOf('\\u0000') !== -1) {\n-    const er = new errors.Error('ERR_INVALID_ARG_TYPE',\n-                                'path',\n-                                'string without null bytes',\n-                                path);\n-\n-    if (typeof callback !== 'function')\n-      throw er;\n-    process.nextTick(callback, er);\n-    return false;\n-  }\n-  return true;\n-}\n-\n function isFd(path) {\n   return (path >>> 0) === path;\n }\n@@ -361,16 +377,6 @@ Object.defineProperties(fs, {\n   X_OK: { enumerable: true, value: constants.X_OK || 0 },\n });\n \n-function handleError(val, callback) {\n-  if (val instanceof Error) {\n-    if (typeof callback === 'function') {\n-      process.nextTick(callback, val);\n-      return true;\n-    } else throw val;\n-  }\n-  return false;\n-}\n-\n fs.access = function(path, mode, callback) {\n   if (typeof mode === 'function') {\n     callback = mode;\n@@ -379,24 +385,18 @@ fs.access = function(path, mode, callback) {\n     throw new errors.TypeError('ERR_INVALID_CALLBACK');\n   }\n \n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-\n+  path = getPathFromURL(path);\n   validatePath(path);\n \n-  if (!nullCheck(path, callback))\n-    return;\n-\n   mode = mode | 0;\n   var req = new FSReqWrap();\n   req.oncomplete = makeCallback(callback);\n   binding.access(pathModule.toNamespacedPath(path), mode, req);\n };\n \n fs.accessSync = function(path, mode) {\n-  handleError((path = getPathFromURL(path)));\n+  path = getPathFromURL(path);\n   validatePath(path);\n-  nullCheck(path);\n \n   if (mode === undefined)\n     mode = fs.F_OK;\n@@ -411,17 +411,30 @@ fs.accessSync = function(path, mode) {\n   }\n };\n \n+// fs.exists never throws even when the arguments are invalid - if there is\n+// a callback it would invoke it with false, otherwise it emits a warning\n+// (see the comments of rethrow()).\n+// This is to bring it inline with fs.existsSync, which never throws.\n+// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\n fs.exists = function(path, callback) {\n-  if (handleError((path = getPathFromURL(path)), cb))\n+  if (typeof callback !== 'function') {\n+    rethrow();\n     return;\n-  validatePath(path);\n-  if (!nullCheck(path, cb)) return;\n+  }\n+\n+  function suppressedCallback(err) {\n+    callback(err ? false : true);\n+  }\n+\n+  try {\n+    path = getPathFromURL(path);\n+    validatePath(path);\n+  } catch (err) {\n+    return callback(false);\n+  }\n   var req = new FSReqWrap();\n-  req.oncomplete = cb;\n+  req.oncomplete = suppressedCallback;\n   binding.stat(pathModule.toNamespacedPath(path), req);\n-  function cb(err) {\n-    if (callback) callback(err ? false : true);\n-  }\n };\n \n Object.defineProperty(fs.exists, internalUtil.promisify.custom, {\n@@ -432,16 +445,16 @@ Object.defineProperty(fs.exists, internalUtil.promisify.custom, {\n   }\n });\n \n-\n+// fs.existsSync never throws, it only returns true or false.\n+// Since fs.existsSync never throws, users have established\n+// the expectation that passing invalid arguments to it, even like\n+// fs.existsSync(), would only get a false in return, so we cannot signal\n+// validation errors to users properly out of compatibility concerns.\n+// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\n fs.existsSync = function(path) {\n   try {\n-    handleError((path = getPathFromURL(path)));\n-    try {\n-      validatePath(path);\n-    } catch (e) {\n-      return false;\n-    }\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n+    validatePath(path);\n     const ctx = { path };\n     binding.stat(pathModule.toNamespacedPath(path), undefined, ctx);\n     if (ctx.errno !== undefined) {\n@@ -456,12 +469,6 @@ fs.existsSync = function(path) {\n fs.readFile = function(path, options, callback) {\n   callback = maybeCallback(callback || options);\n   options = getOptions(options, { flag: 'r' });\n-\n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-  if (!nullCheck(path, callback))\n-    return;\n-\n   var context = new ReadFileContext(callback, options.encoding);\n   context.isUserFd = isFd(path); // file descriptor ownership\n   var req = new FSReqWrap();\n@@ -475,8 +482,8 @@ fs.readFile = function(path, options, callback) {\n     return;\n   }\n \n+  path = getPathFromURL(path);\n   validatePath(path);\n-\n   binding.open(pathModule.toNamespacedPath(path),\n                stringToFlags(options.flag || 'r'),\n                0o666,\n@@ -754,9 +761,7 @@ fs.open = function(path, flags, mode, callback_) {\n   var callback = makeCallback(arguments[arguments.length - 1]);\n   mode = modeNum(mode, 0o666);\n \n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-  if (!nullCheck(path, callback)) return;\n+  path = getPathFromURL(path);\n   validatePath(path);\n   validateUint32(mode, 'mode');\n \n@@ -771,8 +776,7 @@ fs.open = function(path, flags, mode, callback_) {\n \n fs.openSync = function(path, flags, mode) {\n   mode = modeNum(mode, 0o666);\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(path);\n+  path = getPathFromURL(path);\n   validatePath(path);\n   validateUint32(mode, 'mode');\n \n@@ -901,15 +905,9 @@ fs.writeSync = function(fd, buffer, offset, length, position) {\n \n fs.rename = function(oldPath, newPath, callback) {\n   callback = makeCallback(callback);\n-  if (handleError((oldPath = getPathFromURL(oldPath)), callback))\n-    return;\n-\n-  if (handleError((newPath = getPathFromURL(newPath)), callback))\n-    return;\n-\n-  if (!nullCheck(oldPath, callback)) return;\n-  if (!nullCheck(newPath, callback)) return;\n+  oldPath = getPathFromURL(oldPath);\n   validatePath(oldPath, 'oldPath');\n+  newPath = getPathFromURL(newPath);\n   validatePath(newPath, 'newPath');\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n@@ -919,11 +917,9 @@ fs.rename = function(oldPath, newPath, callback) {\n };\n \n fs.renameSync = function(oldPath, newPath) {\n-  handleError((oldPath = getPathFromURL(oldPath)));\n-  handleError((newPath = getPathFromURL(newPath)));\n-  nullCheck(oldPath);\n-  nullCheck(newPath);\n+  oldPath = getPathFromURL(oldPath);\n   validatePath(oldPath, 'oldPath');\n+  newPath = getPathFromURL(newPath);\n   validatePath(newPath, 'newPath');\n   const ctx = { path: oldPath, dest: newPath };\n   binding.rename(pathModule.toNamespacedPath(oldPath),\n@@ -1005,18 +1001,15 @@ fs.ftruncateSync = function(fd, len = 0) {\n \n fs.rmdir = function(path, callback) {\n   callback = maybeCallback(callback);\n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-  if (!nullCheck(path, callback)) return;\n+  path = getPathFromURL(path);\n   validatePath(path);\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.rmdir(pathModule.toNamespacedPath(path), req);\n };\n \n fs.rmdirSync = function(path) {\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(path);\n+  path = getPathFromURL(path);\n   validatePath(path);\n   return binding.rmdir(pathModule.toNamespacedPath(path));\n };\n@@ -1056,10 +1049,7 @@ fs.fsyncSync = function(fd) {\n fs.mkdir = function(path, mode, callback) {\n   if (typeof mode === 'function') callback = mode;\n   callback = makeCallback(callback);\n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-  if (!nullCheck(path, callback)) return;\n-\n+  path = getPathFromURL(path);\n   validatePath(path);\n   mode = modeNum(mode, 0o777);\n   validateUint32(mode, 'mode');\n@@ -1070,8 +1060,7 @@ fs.mkdir = function(path, mode, callback) {\n };\n \n fs.mkdirSync = function(path, mode) {\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(path);\n+  path = getPathFromURL(path);\n   validatePath(path);\n   mode = modeNum(mode, 0o777);\n   validateUint32(mode, 'mode');\n@@ -1081,10 +1070,7 @@ fs.mkdirSync = function(path, mode) {\n fs.readdir = function(path, options, callback) {\n   callback = makeCallback(typeof options === 'function' ? options : callback);\n   options = getOptions(options, {});\n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-  if (!nullCheck(path, callback)) return;\n-\n+  path = getPathFromURL(path);\n   validatePath(path);\n \n   const req = new FSReqWrap();\n@@ -1094,8 +1080,7 @@ fs.readdir = function(path, options, callback) {\n \n fs.readdirSync = function(path, options) {\n   options = getOptions(options, {});\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(path);\n+  path = getPathFromURL(path);\n   validatePath(path);\n   return binding.readdir(pathModule.toNamespacedPath(path), options.encoding);\n };\n@@ -1109,9 +1094,7 @@ fs.fstat = function(fd, callback) {\n \n fs.lstat = function(path, callback) {\n   callback = makeStatsCallback(callback);\n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-  if (!nullCheck(path, callback)) return;\n+  path = getPathFromURL(path);\n   validatePath(path);\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n@@ -1120,9 +1103,7 @@ fs.lstat = function(path, callback) {\n \n fs.stat = function(path, callback) {\n   callback = makeStatsCallback(callback);\n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-  if (!nullCheck(path, callback)) return;\n+  path = getPathFromURL(path);\n   validatePath(path);\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n@@ -1140,8 +1121,7 @@ fs.fstatSync = function(fd) {\n };\n \n fs.lstatSync = function(path) {\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(path);\n+  path = getPathFromURL(path);\n   validatePath(path);\n   const ctx = { path };\n   binding.lstat(pathModule.toNamespacedPath(path), undefined, ctx);\n@@ -1152,8 +1132,7 @@ fs.lstatSync = function(path) {\n };\n \n fs.statSync = function(path) {\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(path);\n+  path = getPathFromURL(path);\n   validatePath(path);\n   const ctx = { path };\n   binding.stat(pathModule.toNamespacedPath(path), undefined, ctx);\n@@ -1166,9 +1145,7 @@ fs.statSync = function(path) {\n fs.readlink = function(path, options, callback) {\n   callback = makeCallback(typeof options === 'function' ? options : callback);\n   options = getOptions(options, {});\n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-  if (!nullCheck(path, callback)) return;\n+  path = getPathFromURL(path);\n   validatePath(path, 'oldPath');\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n@@ -1177,8 +1154,7 @@ fs.readlink = function(path, options, callback) {\n \n fs.readlinkSync = function(path, options) {\n   options = getOptions(options, {});\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(path);\n+  path = getPathFromURL(path);\n   validatePath(path, 'oldPath');\n   const ctx = { path };\n   const result = binding.readlink(pathModule.toNamespacedPath(path),\n@@ -1229,14 +1205,8 @@ fs.symlink = function(target, path, type_, callback_) {\n   var type = (typeof type_ === 'string' ? type_ : null);\n   var callback = makeCallback(arguments[arguments.length - 1]);\n \n-  if (handleError((target = getPathFromURL(target)), callback))\n-    return;\n-\n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-\n-  if (!nullCheck(target, callback)) return;\n-  if (!nullCheck(path, callback)) return;\n+  target = getPathFromURL(target);\n+  path = getPathFromURL(path);\n   validatePath(target, 'target');\n   validatePath(path);\n \n@@ -1250,11 +1220,8 @@ fs.symlink = function(target, path, type_, callback_) {\n \n fs.symlinkSync = function(target, path, type) {\n   type = (typeof type === 'string' ? type : null);\n-  handleError((target = getPathFromURL(target)));\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(target);\n-  nullCheck(path);\n-\n+  target = getPathFromURL(target);\n+  path = getPathFromURL(path);\n   validatePath(target, 'target');\n   validatePath(path);\n   const flags = stringToSymlinkType(type);\n@@ -1276,15 +1243,8 @@ fs.symlinkSync = function(target, path, type) {\n fs.link = function(existingPath, newPath, callback) {\n   callback = makeCallback(callback);\n \n-  if (handleError((existingPath = getPathFromURL(existingPath)), callback))\n-    return;\n-\n-  if (handleError((newPath = getPathFromURL(newPath)), callback))\n-    return;\n-\n-  if (!nullCheck(existingPath, callback)) return;\n-  if (!nullCheck(newPath, callback)) return;\n-\n+  existingPath = getPathFromURL(existingPath);\n+  newPath = getPathFromURL(newPath);\n   validatePath(existingPath, 'existingPath');\n   validatePath(newPath, 'newPath');\n \n@@ -1297,10 +1257,8 @@ fs.link = function(existingPath, newPath, callback) {\n };\n \n fs.linkSync = function(existingPath, newPath) {\n-  handleError((existingPath = getPathFromURL(existingPath)));\n-  handleError((newPath = getPathFromURL(newPath)));\n-  nullCheck(existingPath);\n-  nullCheck(newPath);\n+  existingPath = getPathFromURL(existingPath);\n+  newPath = getPathFromURL(newPath);\n   validatePath(existingPath, 'existingPath');\n   validatePath(newPath, 'newPath');\n \n@@ -1316,18 +1274,15 @@ fs.linkSync = function(existingPath, newPath) {\n \n fs.unlink = function(path, callback) {\n   callback = makeCallback(callback);\n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-  if (!nullCheck(path, callback)) return;\n+  path = getPathFromURL(path);\n   validatePath(path);\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   binding.unlink(pathModule.toNamespacedPath(path), req);\n };\n \n fs.unlinkSync = function(path) {\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(path);\n+  path = getPathFromURL(path);\n   validatePath(path);\n   const ctx = { path };\n   binding.unlink(pathModule.toNamespacedPath(path), undefined, ctx);\n@@ -1394,10 +1349,7 @@ if (constants.O_SYMLINK !== undefined) {\n \n fs.chmod = function(path, mode, callback) {\n   callback = makeCallback(callback);\n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-  if (!nullCheck(path, callback)) return;\n-\n+  path = getPathFromURL(path);\n   validatePath(path);\n   mode = modeNum(mode);\n   validateUint32(mode, 'mode');\n@@ -1408,8 +1360,7 @@ fs.chmod = function(path, mode, callback) {\n };\n \n fs.chmodSync = function(path, mode) {\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(path);\n+  path = getPathFromURL(path);\n   validatePath(path);\n   mode = modeNum(mode);\n   validateUint32(mode, 'mode');\n@@ -1466,10 +1417,7 @@ fs.fchownSync = function(fd, uid, gid) {\n \n fs.chown = function(path, uid, gid, callback) {\n   callback = makeCallback(callback);\n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-  if (!nullCheck(path, callback)) return;\n-\n+  path = getPathFromURL(path);\n   validatePath(path);\n   validateUint32(uid, 'uid');\n   validateUint32(gid, 'gid');\n@@ -1480,8 +1428,7 @@ fs.chown = function(path, uid, gid, callback) {\n };\n \n fs.chownSync = function(path, uid, gid) {\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(path);\n+  path = getPathFromURL(path);\n   validatePath(path);\n   validateUint32(uid, 'uid');\n   validateUint32(gid, 'gid');\n@@ -1515,10 +1462,7 @@ fs._toUnixTimestamp = toUnixTimestamp;\n \n fs.utimes = function(path, atime, mtime, callback) {\n   callback = makeCallback(callback);\n-  if (handleError((path = getPathFromURL(path)), callback))\n-    return;\n-  if (!nullCheck(path, callback)) return;\n-\n+  path = getPathFromURL(path);\n   validatePath(path);\n \n   const req = new FSReqWrap();\n@@ -1530,8 +1474,7 @@ fs.utimes = function(path, atime, mtime, callback) {\n };\n \n fs.utimesSync = function(path, atime, mtime) {\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(path);\n+  path = getPathFromURL(path);\n   validatePath(path);\n   binding.utimes(pathModule.toNamespacedPath(path),\n                  toUnixTimestamp(atime),\n@@ -1685,12 +1628,17 @@ function FSWatcher() {\n }\n util.inherits(FSWatcher, EventEmitter);\n \n+// FIXME(joyeecheung): this method is not documented.\n+// At the moment if filename is undefined, we\n+// 1. Throw an Error from C++ land if it's the first time .start() is called\n+// 2. Return silently from C++ land if .start() has already been called\n+//    on a valid filename and the wrap has been initialized\n FSWatcher.prototype.start = function(filename,\n                                      persistent,\n                                      recursive,\n                                      encoding) {\n-  handleError((filename = getPathFromURL(filename)));\n-  nullCheck(filename);\n+  filename = getPathFromURL(filename);\n+  nullCheck(filename, 'filename');\n   var err = this._handle.start(pathModule.toNamespacedPath(filename),\n                                persistent,\n                                recursive,\n@@ -1708,9 +1656,6 @@ FSWatcher.prototype.close = function() {\n };\n \n fs.watch = function(filename, options, listener) {\n-  handleError((filename = getPathFromURL(filename)));\n-  nullCheck(filename);\n-\n   if (typeof options === 'function') {\n     listener = options;\n   }\n@@ -1777,9 +1722,14 @@ function StatWatcher() {\n util.inherits(StatWatcher, EventEmitter);\n \n \n+// FIXME(joyeecheung): this method is not documented.\n+// At the moment if filename is undefined, we\n+// 1. Throw an Error from C++ land if it's the first time .start() is called\n+// 2. Return silently from C++ land if .start() has already been called\n+//    on a valid filename and the wrap has been initialized\n StatWatcher.prototype.start = function(filename, persistent, interval) {\n-  handleError((filename = getPathFromURL(filename)));\n-  nullCheck(filename);\n+  filename = getPathFromURL(filename);\n+  nullCheck(filename, 'filename');\n   this._handle.start(pathModule.toNamespacedPath(filename),\n                      persistent, interval);\n };\n@@ -1793,8 +1743,8 @@ StatWatcher.prototype.stop = function() {\n const statWatchers = new Map();\n \n fs.watchFile = function(filename, options, listener) {\n-  handleError((filename = getPathFromURL(filename)));\n-  nullCheck(filename);\n+  filename = getPathFromURL(filename);\n+  validatePath(filename);\n   filename = pathModule.resolve(filename);\n   var stat;\n \n@@ -1833,8 +1783,8 @@ fs.watchFile = function(filename, options, listener) {\n };\n \n fs.unwatchFile = function(filename, listener) {\n-  handleError((filename = getPathFromURL(filename)));\n-  nullCheck(filename);\n+  filename = getPathFromURL(filename);\n+  validatePath(filename);\n   filename = pathModule.resolve(filename);\n   var stat = statWatchers.get(filename);\n \n@@ -1903,12 +1853,11 @@ fs.realpathSync = function realpathSync(p, options) {\n     options = emptyObj;\n   else\n     options = getOptions(options, emptyObj);\n+  p = getPathFromURL(p);\n   if (typeof p !== 'string') {\n-    handleError((p = getPathFromURL(p)));\n-    if (typeof p !== 'string')\n-      p += '';\n+    p += '';\n   }\n-  nullCheck(p);\n+  validatePath(p);\n   p = pathModule.resolve(p);\n \n   const cache = options[internalFS.realpathCacheKey];\n@@ -2046,8 +1995,8 @@ fs.realpathSync = function realpathSync(p, options) {\n \n fs.realpathSync.native = function(path, options) {\n   options = getOptions(options, {});\n-  handleError((path = getPathFromURL(path)));\n-  nullCheck(path);\n+  path = getPathFromURL(path);\n+  validatePath(path);\n   return binding.realpath(path, options.encoding);\n };\n \n@@ -2058,14 +2007,11 @@ fs.realpath = function realpath(p, options, callback) {\n     options = emptyObj;\n   else\n     options = getOptions(options, emptyObj);\n+  p = getPathFromURL(p);\n   if (typeof p !== 'string') {\n-    if (handleError((p = getPathFromURL(p)), callback))\n-      return;\n-    if (typeof p !== 'string')\n-      p += '';\n+    p += '';\n   }\n-  if (!nullCheck(p, callback))\n-    return;\n+  validatePath(p);\n   p = pathModule.resolve(p);\n \n   const seenLinks = Object.create(null);\n@@ -2192,14 +2138,13 @@ fs.realpath = function realpath(p, options, callback) {\n fs.realpath.native = function(path, options, callback) {\n   callback = maybeCallback(callback || options);\n   options = getOptions(options, {});\n-  if (handleError((path = getPathFromURL(path)), callback)) return;\n-  if (!nullCheck(path, callback)) return;\n+  path = getPathFromURL(path);\n+  validatePath(path);\n   const req = new FSReqWrap();\n   req.oncomplete = callback;\n   return binding.realpath(path, options.encoding, req);\n };\n \n-\n fs.mkdtemp = function(prefix, options, callback) {\n   callback = makeCallback(typeof options === 'function' ? options : callback);\n   options = getOptions(options, {});\n@@ -2209,26 +2154,22 @@ fs.mkdtemp = function(prefix, options, callback) {\n                                'string',\n                                prefix);\n   }\n-  if (!nullCheck(prefix, callback)) {\n-    return;\n-  }\n-\n+  nullCheck(prefix, 'prefix');\n   var req = new FSReqWrap();\n   req.oncomplete = callback;\n-\n   binding.mkdtemp(`${prefix}XXXXXX`, options.encoding, req);\n };\n \n \n fs.mkdtempSync = function(prefix, options) {\n+  options = getOptions(options, {});\n   if (!prefix || typeof prefix !== 'string') {\n     throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n                                'prefix',\n                                'string',\n                                prefix);\n   }\n-  options = getOptions(options, {});\n-  nullCheck(prefix);\n+  nullCheck(prefix, 'prefix');\n   return binding.mkdtemp(`${prefix}XXXXXX`, options.encoding);\n };\n \n@@ -2248,21 +2189,7 @@ fs.copyFile = function(src, dest, flags, callback) {\n   }\n \n   src = getPathFromURL(src);\n-\n-  if (handleError(src, callback))\n-    return;\n-\n-  if (!nullCheck(src, callback))\n-    return;\n-\n   dest = getPathFromURL(dest);\n-\n-  if (handleError(dest, callback))\n-    return;\n-\n-  if (!nullCheck(dest, callback))\n-    return;\n-\n   validatePath(src, 'src');\n   validatePath(dest, 'dest');\n \n@@ -2277,13 +2204,7 @@ fs.copyFile = function(src, dest, flags, callback) {\n \n fs.copyFileSync = function(src, dest, flags) {\n   src = getPathFromURL(src);\n-  handleError(src);\n-  nullCheck(src);\n-\n   dest = getPathFromURL(dest);\n-  handleError(dest);\n-  nullCheck(dest);\n-\n   validatePath(src, 'src');\n   validatePath(dest, 'dest');\n \n@@ -2320,7 +2241,8 @@ function ReadStream(path, options) {\n \n   Readable.call(this, options);\n \n-  handleError((this.path = getPathFromURL(path)));\n+  // path will be ignored when fd is specified, so it can be falsy\n+  this.path = getPathFromURL(path);\n   this.fd = options.fd === undefined ? null : options.fd;\n   this.flags = options.flags === undefined ? 'r' : options.flags;\n   this.mode = options.mode === undefined ? 0o666 : options.mode;\n@@ -2483,7 +2405,8 @@ function WriteStream(path, options) {\n \n   Writable.call(this, options);\n \n-  handleError((this.path = getPathFromURL(path)));\n+  // path will be ignored when fd is specified, so it can be falsy\n+  this.path = getPathFromURL(path);\n   this.fd = options.fd === undefined ? null : options.fd;\n   this.flags = options.flags === undefined ? 'w' : options.flags;\n   this.mode = options.mode === undefined ? 0o666 : options.mode;\n@@ -2783,8 +2706,7 @@ async function readFileHandle(filehandle, options) {\n // thrown synchronously\n const promises = {\n   async access(path, mode = fs.F_OK) {\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path);\n \n     mode = mode | 0;\n@@ -2793,10 +2715,8 @@ const promises = {\n   },\n \n   async copyFile(src, dest, flags) {\n-    handleError((src = getPathFromURL(src)));\n-    handleError((dest = getPathFromURL(dest)));\n-    nullCheck(src);\n-    nullCheck(dest);\n+    src = getPathFromURL(src);\n+    dest = getPathFromURL(dest);\n     validatePath(src, 'src');\n     validatePath(dest, 'dest');\n     flags = flags | 0;\n@@ -2809,8 +2729,7 @@ const promises = {\n   // promises.open() uses the fs.FileHandle class.\n   async open(path, flags, mode) {\n     mode = modeNum(mode, 0o666);\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path);\n     validateUint32(mode, 'mode');\n     return new FileHandle(\n@@ -2877,10 +2796,8 @@ const promises = {\n   },\n \n   async rename(oldPath, newPath) {\n-    handleError((oldPath = getPathFromURL(oldPath)));\n-    handleError((newPath = getPathFromURL(newPath)));\n-    nullCheck(oldPath);\n-    nullCheck(newPath);\n+    oldPath = getPathFromURL(oldPath);\n+    newPath = getPathFromURL(newPath);\n     validatePath(oldPath, 'oldPath');\n     validatePath(newPath, 'newPath');\n     return binding.rename(pathModule.toNamespacedPath(oldPath),\n@@ -2900,8 +2817,7 @@ const promises = {\n   },\n \n   async rmdir(path) {\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path);\n     return binding.rmdir(pathModule.toNamespacedPath(path), kUsePromises);\n   },\n@@ -2918,37 +2834,32 @@ const promises = {\n \n   async mkdir(path, mode) {\n     mode = modeNum(mode, 0o777);\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path);\n     validateUint32(mode, 'mode');\n     return binding.mkdir(pathModule.toNamespacedPath(path), mode, kUsePromises);\n   },\n \n   async readdir(path, options) {\n     options = getOptions(options, {});\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path);\n     return binding.readdir(pathModule.toNamespacedPath(path),\n                            options.encoding, kUsePromises);\n   },\n \n   async readlink(path, options) {\n     options = getOptions(options, {});\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path, 'oldPath');\n     return binding.readlink(pathModule.toNamespacedPath(path),\n                             options.encoding, kUsePromises);\n   },\n \n   async symlink(target, path, type_) {\n     const type = (typeof type_ === 'string' ? type_ : null);\n-    handleError((target = getPathFromURL(target)));\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(target);\n-    nullCheck(path);\n+    target = getPathFromURL(target);\n+    path = getPathFromURL(path);\n     validatePath(target, 'target');\n     validatePath(path);\n     return binding.symlink(preprocessSymlinkDestination(target, type, path),\n@@ -2963,26 +2874,22 @@ const promises = {\n   },\n \n   async lstat(path) {\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path);\n     return statsFromValues(\n       await binding.lstat(pathModule.toNamespacedPath(path), kUsePromises));\n   },\n \n   async stat(path) {\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path);\n     return statsFromValues(\n       await binding.stat(pathModule.toNamespacedPath(path), kUsePromises));\n   },\n \n   async link(existingPath, newPath) {\n-    handleError((existingPath = getPathFromURL(existingPath)));\n-    handleError((newPath = getPathFromURL(newPath)));\n-    nullCheck(existingPath);\n-    nullCheck(newPath);\n+    existingPath = getPathFromURL(existingPath);\n+    newPath = getPathFromURL(newPath);\n     validatePath(existingPath, 'existingPath');\n     validatePath(newPath, 'newPath');\n     return binding.link(pathModule.toNamespacedPath(existingPath),\n@@ -2991,8 +2898,7 @@ const promises = {\n   },\n \n   async unlink(path) {\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path);\n     return binding.unlink(pathModule.toNamespacedPath(path), kUsePromises);\n   },\n@@ -3007,8 +2913,7 @@ const promises = {\n   },\n \n   async chmod(path, mode) {\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path);\n     mode = modeNum(mode);\n     validateUint32(mode, 'mode');\n@@ -3041,8 +2946,7 @@ const promises = {\n   },\n \n   async chown(path, uid, gid) {\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path);\n     validateUint32(uid, 'uid');\n     validateUint32(gid, 'gid');\n@@ -3051,8 +2955,7 @@ const promises = {\n   },\n \n   async utimes(path, atime, mtime) {\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path);\n     return binding.utimes(pathModule.toNamespacedPath(path),\n                           toUnixTimestamp(atime),\n@@ -3069,8 +2972,7 @@ const promises = {\n \n   async realpath(path, options) {\n     options = getOptions(options, {});\n-    handleError((path = getPathFromURL(path)));\n-    nullCheck(path);\n+    path = getPathFromURL(path);\n     validatePath(path);\n     return binding.realpath(path, options.encoding, kUsePromises);\n   },"
        },
        {
            "sha": "7055667718beeddda13971a54a0c5b2314499268",
            "filename": "lib/internal/url.js",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/d8f73385e220d54de9f9c53da8d8693813e6d774/lib%2Finternal%2Furl.js",
            "raw_url": "https://github.com/nodejs/node/raw/d8f73385e220d54de9f9c53da8d8693813e6d774/lib%2Finternal%2Furl.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Furl.js?ref=d8f73385e220d54de9f9c53da8d8693813e6d774",
            "patch": "@@ -1321,7 +1321,7 @@ function getPathFromURLWin32(url) {\n       var third = pathname.codePointAt(n + 2) | 0x20;\n       if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n           (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n-        return new errors.TypeError(\n+        throw new errors.TypeError(\n           'ERR_INVALID_FILE_URL_PATH',\n           'must not include encoded \\\\ or / characters');\n       }\n@@ -1342,24 +1342,24 @@ function getPathFromURLWin32(url) {\n     var sep = pathname[2];\n     if (letter < 97 || letter > 122 ||   // a..z A..Z\n         (sep !== ':')) {\n-      return new errors.TypeError('ERR_INVALID_FILE_URL_PATH',\n-                                  'must be absolute');\n+      throw new errors.TypeError('ERR_INVALID_FILE_URL_PATH',\n+                                 'must be absolute');\n     }\n     return pathname.slice(1);\n   }\n }\n \n function getPathFromURLPosix(url) {\n   if (url.hostname !== '') {\n-    return new errors.TypeError('ERR_INVALID_FILE_URL_HOST', platform);\n+    throw new errors.TypeError('ERR_INVALID_FILE_URL_HOST', platform);\n   }\n   var pathname = url.pathname;\n   for (var n = 0; n < pathname.length; n++) {\n     if (pathname[n] === '%') {\n       var third = pathname.codePointAt(n + 2) | 0x20;\n       if (pathname[n + 1] === '2' && third === 102) {\n-        return new errors.TypeError('ERR_INVALID_FILE_URL_PATH',\n-                                    'must not include encoded / characters');\n+        throw new errors.TypeError('ERR_INVALID_FILE_URL_PATH',\n+                                   'must not include encoded / characters');\n       }\n     }\n   }\n@@ -1372,7 +1372,7 @@ function getPathFromURL(path) {\n     return path;\n   }\n   if (path.protocol !== 'file:')\n-    return new errors.TypeError('ERR_INVALID_URL_SCHEME', 'file');\n+    throw new errors.TypeError('ERR_INVALID_URL_SCHEME', 'file');\n   return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n }\n "
        },
        {
            "sha": "8b910ba046ec48c463797cf633a099317e1fc30e",
            "filename": "test/parallel/test-fs-copyfile.js",
            "status": "modified",
            "additions": 0,
            "deletions": 20,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/d8f73385e220d54de9f9c53da8d8693813e6d774/test%2Fparallel%2Ftest-fs-copyfile.js",
            "raw_url": "https://github.com/nodejs/node/raw/d8f73385e220d54de9f9c53da8d8693813e6d774/test%2Fparallel%2Ftest-fs-copyfile.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-copyfile.js?ref=d8f73385e220d54de9f9c53da8d8693813e6d774",
            "patch": "@@ -102,26 +102,6 @@ common.expectsError(() => {\n   );\n });\n \n-// Throws if the source path is an invalid path.\n-common.expectsError(() => {\n-  fs.copyFileSync('\\u0000', dest);\n-}, {\n-  code: 'ERR_INVALID_ARG_TYPE',\n-  type: Error,\n-  message: 'The \"path\" argument must be of type string without null bytes.' +\n-           ' Received type string'\n-});\n-\n-// Throws if the destination path is an invalid path.\n-common.expectsError(() => {\n-  fs.copyFileSync(src, '\\u0000');\n-}, {\n-  code: 'ERR_INVALID_ARG_TYPE',\n-  type: Error,\n-  message: 'The \"path\" argument must be of type string without null bytes.' +\n-           ' Received type string'\n-});\n-\n // Errors if invalid flags are provided.\n assert.throws(() => {\n   fs.copyFileSync(src, dest, -1);"
        },
        {
            "sha": "c52679764b45588d7f323bfa9c947bce31c088e6",
            "filename": "test/parallel/test-fs-exists.js",
            "status": "modified",
            "additions": 14,
            "deletions": 11,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/d8f73385e220d54de9f9c53da8d8693813e6d774/test%2Fparallel%2Ftest-fs-exists.js",
            "raw_url": "https://github.com/nodejs/node/raw/d8f73385e220d54de9f9c53da8d8693813e6d774/test%2Fparallel%2Ftest-fs-exists.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-exists.js?ref=d8f73385e220d54de9f9c53da8d8693813e6d774",
            "patch": "@@ -26,30 +26,33 @@ const fs = require('fs');\n const { URL } = require('url');\n const f = __filename;\n \n+// Only warnings are emitted when the callback is invalid\n+assert.doesNotThrow(() => fs.exists(f));\n+assert.doesNotThrow(() => fs.exists());\n+assert.doesNotThrow(() => fs.exists(f, {}));\n+\n fs.exists(f, common.mustCall(function(y) {\n   assert.strictEqual(y, true);\n }));\n \n-assert.doesNotThrow(() => fs.exists(f));\n-\n fs.exists(`${f}-NO`, common.mustCall(function(y) {\n   assert.strictEqual(y, false);\n }));\n \n+// If the path is invalid, fs.exists will still invoke the callback with false\n+// instead of throwing errors\n fs.exists(new URL('https://foo'), common.mustCall(function(y) {\n   assert.strictEqual(y, false);\n }));\n \n+fs.exists({}, common.mustCall(function(y) {\n+  assert.strictEqual(y, false);\n+}));\n+\n assert(fs.existsSync(f));\n assert(!fs.existsSync(`${f}-NO`));\n \n-common.expectsError(\n-  () => { fs.exists(() => {}); },\n-  {\n-    code: 'ERR_INVALID_ARG_TYPE',\n-    message: 'The \"path\" argument must be one of type string, Buffer, or URL',\n-    type: TypeError\n-  }\n-);\n-\n+// fs.existsSync() never throws\n assert(!fs.existsSync());\n+assert(!fs.existsSync({}));\n+assert(!fs.existsSync(new URL('https://foo')));"
        },
        {
            "sha": "6ffaef571ac8d65aedb2874f824e872fcfc9c54d",
            "filename": "test/parallel/test-fs-null-bytes.js",
            "status": "modified",
            "additions": 16,
            "deletions": 12,
            "changes": 28,
            "blob_url": "https://github.com/nodejs/node/blob/d8f73385e220d54de9f9c53da8d8693813e6d774/test%2Fparallel%2Ftest-fs-null-bytes.js",
            "raw_url": "https://github.com/nodejs/node/raw/d8f73385e220d54de9f9c53da8d8693813e6d774/test%2Fparallel%2Ftest-fs-null-bytes.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-null-bytes.js?ref=d8f73385e220d54de9f9c53da8d8693813e6d774",
            "patch": "@@ -27,30 +27,28 @@ const URL = require('url').URL;\n \n function check(async, sync) {\n   const argsSync = Array.prototype.slice.call(arguments, 2);\n-  const argsAsync = argsSync.concat((er) => {\n-    common.expectsError(\n-      () => {\n-        throw er;\n-      },\n-      {\n-        code: 'ERR_INVALID_ARG_TYPE',\n-        type: Error\n-      });\n-  });\n+  const argsAsync = argsSync.concat(common.mustNotCall());\n \n   if (sync) {\n     common.expectsError(\n       () => {\n         sync.apply(null, argsSync);\n       },\n       {\n-        code: 'ERR_INVALID_ARG_TYPE',\n+        code: 'ERR_INVALID_ARG_VALUE',\n         type: Error,\n       });\n   }\n \n   if (async) {\n-    async.apply(null, argsAsync);\n+    common.expectsError(\n+      () => {\n+        async.apply(null, argsAsync);\n+      },\n+      {\n+        code: 'ERR_INVALID_ARG_VALUE',\n+        type: Error\n+      });\n   }\n }\n \n@@ -59,6 +57,8 @@ check(fs.access, fs.accessSync, 'foo\\u0000bar', fs.F_OK);\n check(fs.appendFile, fs.appendFileSync, 'foo\\u0000bar', 'abc');\n check(fs.chmod, fs.chmodSync, 'foo\\u0000bar', '0644');\n check(fs.chown, fs.chownSync, 'foo\\u0000bar', 12, 34);\n+check(fs.copyFile, fs.copyFileSync, 'foo\\u0000bar', 'abc');\n+check(fs.copyFile, fs.copyFileSync, 'abc', 'foo\\u0000bar');\n check(fs.link, fs.linkSync, 'foo\\u0000bar', 'foobar');\n check(fs.link, fs.linkSync, 'foobar', 'foo\\u0000bar');\n check(fs.lstat, fs.lstatSync, 'foo\\u0000bar');\n@@ -90,6 +90,8 @@ check(fs.access, fs.accessSync, fileUrl, fs.F_OK);\n check(fs.appendFile, fs.appendFileSync, fileUrl, 'abc');\n check(fs.chmod, fs.chmodSync, fileUrl, '0644');\n check(fs.chown, fs.chownSync, fileUrl, 12, 34);\n+check(fs.copyFile, fs.copyFileSync, fileUrl, 'abc');\n+check(fs.copyFile, fs.copyFileSync, 'abc', fileUrl);\n check(fs.link, fs.linkSync, fileUrl, 'foobar');\n check(fs.link, fs.linkSync, 'foobar', fileUrl);\n check(fs.lstat, fs.lstatSync, fileUrl);\n@@ -118,6 +120,8 @@ check(fs.access, fs.accessSync, fileUrl2, fs.F_OK);\n check(fs.appendFile, fs.appendFileSync, fileUrl2, 'abc');\n check(fs.chmod, fs.chmodSync, fileUrl2, '0644');\n check(fs.chown, fs.chownSync, fileUrl2, 12, 34);\n+check(fs.copyFile, fs.copyFileSync, fileUrl2, 'abc');\n+check(fs.copyFile, fs.copyFileSync, 'abc', fileUrl2);\n check(fs.link, fs.linkSync, fileUrl2, 'foobar');\n check(fs.link, fs.linkSync, 'foobar', fileUrl2);\n check(fs.lstat, fs.lstatSync, fileUrl2);"
        },
        {
            "sha": "cfdfbe0dde01b81f8128fed8280d68a2a442fd12",
            "filename": "test/parallel/test-fs-whatwg-url.js",
            "status": "modified",
            "additions": 61,
            "deletions": 32,
            "changes": 93,
            "blob_url": "https://github.com/nodejs/node/blob/d8f73385e220d54de9f9c53da8d8693813e6d774/test%2Fparallel%2Ftest-fs-whatwg-url.js",
            "raw_url": "https://github.com/nodejs/node/raw/d8f73385e220d54de9f9c53da8d8693813e6d774/test%2Fparallel%2Ftest-fs-whatwg-url.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-fs-whatwg-url.js?ref=d8f73385e220d54de9f9c53da8d8693813e6d774",
            "patch": "@@ -29,46 +29,75 @@ fs.readFile(url, common.mustCall((err, data) => {\n \n // Check that using a non file:// URL reports an error\n const httpUrl = new URL('http://example.org');\n-fs.readFile(httpUrl, common.expectsError({\n-  code: 'ERR_INVALID_URL_SCHEME',\n-  type: TypeError,\n-  message: 'The URL must be of scheme file'\n-}));\n \n-// pct-encoded characters in the path will be decoded and checked\n-fs.readFile(new URL('file:///c:/tmp/%00test'), common.mustCall((err) => {\n-  common.expectsError(\n-    () => {\n-      throw err;\n-    },\n-    {\n-      code: 'ERR_INVALID_ARG_TYPE',\n-      type: Error\n-    });\n-}));\n+common.expectsError(\n+  () => {\n+    fs.readFile(httpUrl, common.mustNotCall());\n+  },\n+  {\n+    code: 'ERR_INVALID_URL_SCHEME',\n+    type: TypeError,\n+    message: 'The URL must be of scheme file'\n+  });\n \n+// pct-encoded characters in the path will be decoded and checked\n if (common.isWindows) {\n   // encoded back and forward slashes are not permitted on windows\n   ['%2f', '%2F', '%5c', '%5C'].forEach((i) => {\n-    fs.readFile(new URL(`file:///c:/tmp/${i}`), common.expectsError({\n-      code: 'ERR_INVALID_FILE_URL_PATH',\n-      type: TypeError,\n-      message: 'File URL path must not include encoded \\\\ or / characters'\n-    }));\n+    common.expectsError(\n+      () => {\n+        fs.readFile(new URL(`file:///c:/tmp/${i}`), common.mustNotCall());\n+      },\n+      {\n+        code: 'ERR_INVALID_FILE_URL_PATH',\n+        type: TypeError,\n+        message: 'File URL path must not include encoded \\\\ or / characters'\n+      }\n+    );\n   });\n+  common.expectsError(\n+    () => {\n+      fs.readFile(new URL('file:///c:/tmp/%00test'), common.mustNotCall());\n+    },\n+    {\n+      code: 'ERR_INVALID_ARG_VALUE',\n+      type: Error,\n+      message: 'The argument \\'path\\' must be a string or Uint8Array without ' +\n+               'null bytes. Received \\'c:/tmp/\\\\u0000test\\''\n+    }\n+  );\n } else {\n   // encoded forward slashes are not permitted on other platforms\n   ['%2f', '%2F'].forEach((i) => {\n-    fs.readFile(new URL(`file:///c:/tmp/${i}`), common.expectsError({\n-      code: 'ERR_INVALID_FILE_URL_PATH',\n-      type: TypeError,\n-      message: 'File URL path must not include encoded / characters'\n-    }));\n+    common.expectsError(\n+      () => {\n+        fs.readFile(new URL(`file:///c:/tmp/${i}`), common.mustNotCall());\n+      },\n+      {\n+        code: 'ERR_INVALID_FILE_URL_PATH',\n+        type: TypeError,\n+        message: 'File URL path must not include encoded / characters'\n+      });\n   });\n-\n-  fs.readFile(new URL('file://hostname/a/b/c'), common.expectsError({\n-    code: 'ERR_INVALID_FILE_URL_HOST',\n-    type: TypeError,\n-    message: `File URL host must be \"localhost\" or empty on ${os.platform()}`\n-  }));\n+  common.expectsError(\n+    () => {\n+      fs.readFile(new URL('file://hostname/a/b/c'), common.mustNotCall());\n+    },\n+    {\n+      code: 'ERR_INVALID_FILE_URL_HOST',\n+      type: TypeError,\n+      message: `File URL host must be \"localhost\" or empty on ${os.platform()}`\n+    }\n+  );\n+  common.expectsError(\n+    () => {\n+      fs.readFile(new URL('file:///tmp/%00test'), common.mustNotCall());\n+    },\n+    {\n+      code: 'ERR_INVALID_ARG_VALUE',\n+      type: Error,\n+      message: 'The argument \\'path\\' must be a string or Uint8Array without ' +\n+               'null bytes. Received \\'/tmp/\\\\u0000test\\''\n+    }\n+  );\n }"
        },
        {
            "sha": "43c868f8326f3fec6133c76997b6e8dac8b405bb",
            "filename": "test/parallel/test-repl-persistent-history.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/d8f73385e220d54de9f9c53da8d8693813e6d774/test%2Fparallel%2Ftest-repl-persistent-history.js",
            "raw_url": "https://github.com/nodejs/node/raw/d8f73385e220d54de9f9c53da8d8693813e6d774/test%2Fparallel%2Ftest-repl-persistent-history.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-repl-persistent-history.js?ref=d8f73385e220d54de9f9c53da8d8693813e6d774",
            "patch": "@@ -57,7 +57,7 @@ const CLEAR = { ctrl: true, name: 'u' };\n // File paths\n const historyFixturePath = fixtures.path('.node_repl_history');\n const historyPath = path.join(tmpdir.path, '.fixture_copy_repl_history');\n-const historyPathFail = path.join(tmpdir.path, '.node_repl\\u0000_history');\n+const historyPathFail = fixtures.path('nonexistent_folder', 'filename');\n const oldHistoryPathObj = fixtures.path('old-repl-history-file-obj.json');\n const oldHistoryPathFaulty = fixtures.path('old-repl-history-file-faulty.json');\n const oldHistoryPath = fixtures.path('old-repl-history-file.json');"
        }
    ],
    "stats": {
        "total": 586,
        "additions": 252,
        "deletions": 334
    }
}