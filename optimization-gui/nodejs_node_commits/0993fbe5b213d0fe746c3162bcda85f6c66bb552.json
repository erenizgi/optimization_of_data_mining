{
    "author": "devsnek",
    "message": "vm: add modules\n\nAdds vm.Module, which wraps around ModuleWrap to provide an interface\nfor developers to work with modules in a more reflective manner.\n\nCo-authored-by: Timothy Gu <timothygu99@gmail.com>\nPR-URL: https://github.com/nodejs/node/pull/17560\nReviewed-By: MichaÃ«l Zasso <targos@protonmail.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>",
    "sha": "0993fbe5b213d0fe746c3162bcda85f6c66bb552",
    "files": [
        {
            "sha": "d68640d82ca7079ea00dada285ec94aa8ea13bea",
            "filename": "doc/api/errors.md",
            "status": "modified",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/doc%2Fapi%2Ferrors.md",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/doc%2Fapi%2Ferrors.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Ferrors.md?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -1639,6 +1639,43 @@ entry types were found.\n \n Superseded by `ERR_OUT_OF_RANGE`\n \n+<a id=\"ERR_VM_MODULE_ALREADY_LINKED\"></a>\n+### ERR_VM_MODULE_ALREADY_LINKED\n+\n+The module attempted to be linked is not eligible for linking, because of one of\n+the following reasons:\n+\n+- It has already been linked (`linkingStatus` is `'linked'`)\n+- It is being linked (`linkingStatus` is `'linking'`)\n+- Linking has failed for this module (`linkingStatus` is `'errored'`)\n+\n+<a id=\"ERR_VM_MODULE_DIFFERENT_CONTEXT\"></a>\n+### ERR_VM_MODULE_DIFFERENT_CONTEXT\n+\n+The module being returned from the linker function is from a different context\n+than the parent module. Linked modules must share the same context.\n+\n+<a id=\"ERR_VM_MODULE_LINKING_ERRORED\"></a>\n+### ERR_VM_MODULE_LINKING_ERRORED\n+\n+The linker function returned a module for which linking has failed.\n+\n+<a id=\"ERR_VM_MODULE_NOT_LINKED\"></a>\n+### ERR_VM_MODULE_NOT_LINKED\n+\n+The module must be successfully linked before instantiation.\n+\n+<a id=\"ERR_VM_MODULE_NOT_MODULE\"></a>\n+### ERR_VM_MODULE_NOT_MODULE\n+\n+The fulfilled value of a linking promise is not a `vm.Module` object.\n+\n+<a id=\"ERR_VM_MODULE_STATUS\"></a>\n+### ERR_VM_MODULE_STATUS\n+\n+The current module's status does not allow for this operation. The specific\n+meaning of the error depends on the specific function.\n+\n <a id=\"ERR_ZLIB_BINDING_CLOSED\"></a>\n ### ERR_ZLIB_BINDING_CLOSED\n "
        },
        {
            "sha": "516e18b6a0fc6c0af13efcb29a80af09067f9cdd",
            "filename": "doc/api/vm.md",
            "status": "modified",
            "additions": 322,
            "deletions": 0,
            "changes": 322,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/doc%2Fapi%2Fvm.md",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/doc%2Fapi%2Fvm.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fvm.md?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -43,6 +43,322 @@ console.log(x); // 1; y is not defined.\n *Note*: The vm module is not a security mechanism.\n **Do not use it to run untrusted code**.\n \n+## Class: vm.Module\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+> Stability: 1 - Experimental\n+\n+*This feature is only available with the `--experimental-vm-modules` command\n+flag enabled.*\n+\n+The `vm.Module` class provides a low-level interface for using ECMAScript\n+modules in VM contexts. It is the counterpart of the `vm.Script` class that\n+closely mirrors [Source Text Module Record][]s as defined in the ECMAScript\n+specification.\n+\n+Unlike `vm.Script` however, every `vm.Module` object is bound to a context from\n+its creation. Operations on `vm.Module` objects are intrinsically asynchronous,\n+in contrast with the synchronous nature of `vm.Script` objects. With the help\n+of async functions, however, manipulating `vm.Module` objects is fairly\n+straightforward.\n+\n+Using a `vm.Module` object requires four distinct steps: creation/parsing,\n+linking, instantiation, and evaluation. These four steps are illustrated in the\n+following example.\n+\n+*Note*: This implementation lies at a lower level than the [ECMAScript Module\n+loader][]. There is also currently no way to interact with the Loader, though\n+support is planned.\n+\n+```js\n+const vm = require('vm');\n+\n+const contextifiedSandbox = vm.createContext({ secret: 42 });\n+\n+(async () => {\n+  // Step 1\n+  //\n+  // Create a Module by constructing a new `vm.Module` object. This parses the\n+  // provided source text, throwing a `SyntaxError` if anything goes wrong. By\n+  // default, a Module is created in the top context. But here, we specify\n+  // `contextifiedSandbox` as the context this Module belongs to.\n+  //\n+  // Here, we attempt to obtain the default export from the module \"foo\", and\n+  // put it into local binding \"secret\".\n+\n+  const bar = new vm.Module(`\n+    import s from 'foo';\n+    s;\n+  `, { context: contextifiedSandbox });\n+\n+\n+  // Step 2\n+  //\n+  // \"Link\" the imported dependencies of this Module to it.\n+  //\n+  // The provided linking callback (the \"linker\") accepts two arguments: the\n+  // parent module (`bar` in this case) and the string that is the specifier of\n+  // the imported module. The callback is expected to return a Module that\n+  // corresponds to the provided specifier, with certain requirements documented\n+  // in `module.link()`.\n+  //\n+  // If linking has not started for the returned Module, the same linker\n+  // callback will be called on the returned Module.\n+  //\n+  // Even top-level Modules without dependencies must be explicitly linked. The\n+  // callback provided would never be called, however.\n+  //\n+  // The link() method returns a Promise that will be resolved when all the\n+  // Promises returned by the linker resolve.\n+  //\n+  // Note: This is a contrived example in that the linker function creates a new\n+  // \"foo\" module every time it is called. In a full-fledged module system, a\n+  // cache would probably be used to avoid duplicated modules.\n+\n+  async function linker(referencingModule, specifier) {\n+    if (specifier === 'foo') {\n+      return new vm.Module(`\n+        // The \"secret\" variable refers to the global variable we added to\n+        // \"contextifiedSandbox\" when creating the context.\n+        export default secret;\n+      `, { context: referencingModule.context });\n+\n+      // Using `contextifiedSandbox` instead of `referencingModule.context`\n+      // here would work as well.\n+    }\n+    throw new Error(`Unable to resolve dependency: ${specifier}`);\n+  }\n+  await bar.link(linker);\n+\n+\n+  // Step 3\n+  //\n+  // Instantiate the top-level Module.\n+  //\n+  // Only the top-level Module needs to be explicitly instantiated; its\n+  // dependencies will be recursively instantiated by instantiate().\n+\n+  bar.instantiate();\n+\n+\n+  // Step 4\n+  //\n+  // Evaluate the Module. The evaluate() method returns a Promise with a single\n+  // property \"result\" that contains the result of the very last statement\n+  // executed in the Module. In the case of `bar`, it is `s;`, which refers to\n+  // the default export of the `foo` module, the `secret` we set in the\n+  // beginning to 42.\n+\n+  const { result } = await bar.evaluate();\n+\n+  console.log(result);\n+  // Prints 42.\n+})();\n+```\n+\n+### Constructor: new vm.Module(code[, options])\n+\n+* `code` {string} JavaScript Module code to parse\n+* `options`\n+  * `url` {string} URL used in module resolution and stack traces. **Default**:\n+    `'vm:module(i)'` where `i` is a context-specific ascending index.\n+  * `context` {Object} The [contextified][] object as returned by the\n+    `vm.createContext()` method, to compile and evaluate this Module in.\n+  * `lineOffset` {integer} Specifies the line number offset that is displayed\n+    in stack traces produced by this Module.\n+  * `columnOffset` {integer} Spcifies the column number offset that is displayed\n+    in stack traces produced by this Module.\n+\n+Creates a new ES `Module` object.\n+\n+### module.dependencySpecifiers\n+\n+* {string[]}\n+\n+The specifiers of all dependencies of this module. The returned array is frozen\n+to disallow any changes to it.\n+\n+Corresponds to the [[RequestedModules]] field of [Source Text Module Record][]s\n+in the ECMAScript specification.\n+\n+### module.error\n+\n+* {any}\n+\n+If the `module.status` is `'errored'`, this property contains the exception thrown\n+by the module during evaluation. If the status is anything else, accessing this\n+property will result in a thrown exception.\n+\n+*Note*: `undefined` cannot be used for cases where there is not a thrown\n+exception due to possible ambiguity with `throw undefined;`.\n+\n+Corresponds to the [[EvaluationError]] field of [Source Text Module Record][]s\n+in the ECMAScript specification.\n+\n+### module.linkingStatus\n+\n+* {string}\n+\n+The current linking status of `module`. It will be one of the following values:\n+\n+- `'unlinked'`: `module.link()` has not yet been called.\n+- `'linking'`: `module.link()` has been called, but not all Promises returned by\n+  the linker function have been resolved yet.\n+- `'linked'`: `module.link()` has been called, and all its dependencies have\n+  been successfully linked.\n+- `'errored'`: `module.link()` has been called, but at least one of its\n+  dependencies failed to link, either because the callback returned a Promise\n+  that is rejected, or because the Module the callback returned is invalid.\n+\n+### module.namespace\n+\n+* {Object}\n+\n+The namespace object of the module. This is only available after instantiation\n+(`module.instantiate()`) has completed.\n+\n+Corresponds to the [GetModuleNamespace][] abstract operation in the ECMAScript\n+specification.\n+\n+### module.status\n+\n+* {string}\n+\n+The current status of the module. Will be one of:\n+\n+- `'uninstantiated'`: The module is not instantiated. It may because of any of\n+  the following reasons:\n+\n+  - The module was just created.\n+  - `module.instantiate()` has been called on this module, but it failed for\n+    some reason.\n+\n+  This status does not convey any information regarding if `module.link()` has\n+  been called. See `module.linkingStatus` for that.\n+\n+- `'instantiating'`: The module is currently being instantiated through a\n+  `module.instantiate()` call on itself or a parent module.\n+\n+- `'instantiated'`: The module has been instantiated successfully, but\n+  `module.evaluate()` has not yet been called.\n+\n+- `'evaluating'`: The module is being evaluated through a `module.evaluate()` on\n+  itself or a parent module.\n+\n+- `'evaluated'`: The module has been successfully evaluated.\n+\n+- `'errored'`: The module has been evaluated, but an exception was thrown.\n+\n+Other than `'errored'`, this status string corresponds to the specification's\n+[Source Text Module Record][]'s [[Status]] field. `'errored'` corresponds to\n+`'evaluated'` in the specification, but with [[EvaluationError]] set to a value\n+that is not `undefined`.\n+\n+### module.url\n+\n+* {string}\n+\n+The URL of the current module, as set in the constructor.\n+\n+### module.evaluate([options])\n+\n+* `options` {Object}\n+  * `timeout` {number} Specifies the number of milliseconds to evaluate\n+    before terminating execution. If execution is interrupted, an [`Error`][]\n+    will be thrown.\n+  * `breakOnSigint` {boolean} If `true`, the execution will be terminated when\n+    `SIGINT` (Ctrl+C) is received. Existing handlers for the event that have\n+    been attached via `process.on(\"SIGINT\")` will be disabled during script\n+    execution, but will continue to work after that. If execution is\n+    interrupted, an [`Error`][] will be thrown.\n+* Returns: {Promise}\n+\n+Evaluate the module.\n+\n+This must be called after the module has been instantiated; otherwise it will\n+throw an error. It could be called also when the module has already been\n+evaluated, in which case it will do one of the following two things:\n+\n+- return `undefined` if the initial evaluation ended in success (`module.status`\n+  is `'evaluated'`)\n+- rethrow the same exception the initial evaluation threw if the initial\n+  evaluation ended in an error (`module.status` is `'errored'`)\n+\n+This method cannot be called while the module is being evaluated\n+(`module.status` is `'evaluating'`) to prevent infinite recursion.\n+\n+Corresponds to the [Evaluate() concrete method][] field of [Source Text Module\n+Record][]s in the ECMAScript specification.\n+\n+### module.instantiate()\n+\n+Instantiate the module. This must be called after linking has completed\n+(`linkingStatus` is `'linked'`); otherwise it will throw an error. It may also\n+throw an exception if one of the dependencies does not provide an export the\n+parent module requires.\n+\n+However, if this function succeeded, further calls to this function after the\n+initial instantiation will be no-ops, to be consistent with the ECMAScript\n+specification.\n+\n+Unlike other methods operating on `Module`, this function completes\n+synchronously and returns nothing.\n+\n+Corresponds to the [Instantiate() concrete method][] field of [Source Text\n+Module Record][]s in the ECMAScript specification.\n+\n+### module.link(linker)\n+\n+* `linker` {Function}\n+* Returns: {Promise}\n+\n+Link module dependencies. This method must be called before instantiation, and\n+can only be called once per module.\n+\n+Two parameters will be passed to the `linker` function:\n+\n+- `referencingModule` The `Module` object `link()` is called on.\n+- `specifier` The specifier of the requested module:\n+\n+  <!-- eslint-skip -->\n+  ```js\n+  import foo from 'foo';\n+  //              ^^^^^ the module specifier\n+  ```\n+\n+The function is expected to return a `Module` object or a `Promise` that\n+eventually resolves to a `Module` object. The returned `Module` must satisfy the\n+following two invariants:\n+\n+- It must belong to the same context as the parent `Module`.\n+- Its `linkingStatus` must not be `'errored'`.\n+\n+If the returned `Module`'s `linkingStatus` is `'unlinked'`, this method will be\n+recursively called on the returned `Module` with the same provided `linker`\n+function.\n+\n+`link()` returns a `Promise` that will either get resolved when all linking\n+instances resolve to a valid `Module`, or rejected if the linker function either\n+throws an exception or returns an invalid `Module`.\n+\n+The linker function roughly corresponds to the implementation-defined\n+[HostResolveImportedModule][] abstract operation in the ECMAScript\n+specification, with a few key differences:\n+\n+- The linker function is allowed to be asynchronous while\n+  [HostResolveImportedModule][] is synchronous.\n+- The linker function is executed during linking, a Node.js-specific stage\n+  before instantiation, while [HostResolveImportedModule][] is called during\n+  instantiation.\n+\n+The actual [HostResolveImportedModule][] implementation used during module\n+instantiation is one that returns the modules linked during linking. Since at\n+that point all modules would have been fully linked already, the\n+[HostResolveImportedModule][] implementation is fully synchronous per\n+specification.\n+\n ## Class: vm.Script\n <!-- YAML\n added: v0.3.1\n@@ -518,8 +834,14 @@ associating it with the `sandbox` object is what this document refers to as\n [`vm.createContext()`]: #vm_vm_createcontext_sandbox_options\n [`vm.runInContext()`]: #vm_vm_runincontext_code_contextifiedsandbox_options\n [`vm.runInThisContext()`]: #vm_vm_runinthiscontext_code_options\n+[GetModuleNamespace]: https://tc39.github.io/ecma262/#sec-getmodulenamespace\n+[ECMAScript Module Loader]: esm.html#esm_ecmascript_modules\n+[Evaluate() concrete method]: https://tc39.github.io/ecma262/#sec-moduleevaluation\n+[HostResolveImportedModule]: https://tc39.github.io/ecma262/#sec-hostresolveimportedmodule\n+[Instantiate() concrete method]: https://tc39.github.io/ecma262/#sec-moduledeclarationinstantiation\n [V8 Embedder's Guide]: https://github.com/v8/v8/wiki/Embedder's%20Guide#contexts\n [contextified]: #vm_what_does_it_mean_to_contextify_an_object\n [global object]: https://es5.github.io/#x15.1\n [indirect `eval()` call]: https://es5.github.io/#x10.4.2\n [origin]: https://developer.mozilla.org/en-US/docs/Glossary/Origin\n+[Source Text Module Record]: https://tc39.github.io/ecma262/#sec-source-text-module-records"
        },
        {
            "sha": "3530d63710cf77d07f659f2d2ee9c3da0ae18668",
            "filename": "lib/internal/errors.js",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/lib%2Finternal%2Ferrors.js",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/lib%2Finternal%2Ferrors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ferrors.js?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -676,6 +676,15 @@ E('ERR_V8BREAKITERATOR', 'Full ICU data not installed. ' +\n   'See https://github.com/nodejs/node/wiki/Intl');\n E('ERR_VALID_PERFORMANCE_ENTRY_TYPE',\n   'At least one valid performance entry type is required');\n+E('ERR_VM_MODULE_ALREADY_LINKED', 'Module has already been linked');\n+E('ERR_VM_MODULE_DIFFERENT_CONTEXT',\n+  'Linked modules must use the same context');\n+E('ERR_VM_MODULE_LINKING_ERRORED',\n+  'Linking has already failed for the provided module');\n+E('ERR_VM_MODULE_NOT_LINKED',\n+  'Module must be linked before it can be instantiated');\n+E('ERR_VM_MODULE_NOT_MODULE', 'Provided module is not an instance of Module');\n+E('ERR_VM_MODULE_STATUS', 'Module status %s');\n E('ERR_ZLIB_BINDING_CLOSED', 'zlib binding closed');\n E('ERR_ZLIB_INITIALIZATION_FAILED', 'Initialization failed');\n "
        },
        {
            "sha": "a8625ef76be613ac0267d71b63b716341bb7495a",
            "filename": "lib/internal/vm/Module.js",
            "status": "added",
            "additions": 205,
            "deletions": 0,
            "changes": 205,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/lib%2Finternal%2Fvm%2FModule.js",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/lib%2Finternal%2Fvm%2FModule.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fvm%2FModule.js?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -0,0 +1,205 @@\n+'use strict';\n+\n+const { emitExperimentalWarning } = require('internal/util');\n+const { URL } = require('internal/url');\n+const { kParsingContext, isContext } = process.binding('contextify');\n+const errors = require('internal/errors');\n+const {\n+  getConstructorOf,\n+  customInspectSymbol,\n+} = require('internal/util');\n+\n+const {\n+  ModuleWrap,\n+  kUninstantiated,\n+  kInstantiating,\n+  kInstantiated,\n+  kEvaluating,\n+  kEvaluated,\n+  kErrored,\n+} = internalBinding('module_wrap');\n+\n+const STATUS_MAP = {\n+  [kUninstantiated]: 'uninstantiated',\n+  [kInstantiating]: 'instantiating',\n+  [kInstantiated]: 'instantiated',\n+  [kEvaluating]: 'evaluating',\n+  [kEvaluated]: 'evaluated',\n+  [kErrored]: 'errored',\n+};\n+\n+let globalModuleId = 0;\n+const perContextModuleId = new WeakMap();\n+const wrapMap = new WeakMap();\n+const dependencyCacheMap = new WeakMap();\n+const linkingStatusMap = new WeakMap();\n+\n+class Module {\n+  constructor(src, options = {}) {\n+    emitExperimentalWarning('vm.Module');\n+\n+    if (typeof src !== 'string')\n+      throw new errors.TypeError(\n+        'ERR_INVALID_ARG_TYPE', 'src', 'string', src);\n+    if (typeof options !== 'object' || options === null)\n+      throw new errors.TypeError(\n+        'ERR_INVALID_ARG_TYPE', 'options', 'object', options);\n+\n+    let context;\n+    if (options.context !== undefined) {\n+      if (isContext(options.context)) {\n+        context = options.context;\n+      } else {\n+        throw new errors.TypeError(\n+          'ERR_INVALID_ARG_TYPE', 'options.context', 'vm.Context');\n+      }\n+    }\n+\n+    let url = options.url;\n+    if (url !== undefined) {\n+      if (typeof url !== 'string') {\n+        throw new errors.TypeError(\n+          'ERR_INVALID_ARG_TYPE', 'options.url', 'string', url);\n+      }\n+      url = new URL(url).href;\n+    } else if (context === undefined) {\n+      url = `vm:module(${globalModuleId++})`;\n+    } else if (perContextModuleId.has(context)) {\n+      const curId = perContextModuleId.get(context);\n+      url = `vm:module(${curId})`;\n+      perContextModuleId.set(context, curId + 1);\n+    } else {\n+      url = 'vm:module(0)';\n+      perContextModuleId.set(context, 1);\n+    }\n+\n+    const wrap = new ModuleWrap(src, url, {\n+      [kParsingContext]: context,\n+      lineOffset: options.lineOffset,\n+      columnOffset: options.columnOffset\n+    });\n+\n+    wrapMap.set(this, wrap);\n+    linkingStatusMap.set(this, 'unlinked');\n+\n+    Object.defineProperties(this, {\n+      url: { value: url, enumerable: true },\n+      context: { value: context, enumerable: true },\n+    });\n+  }\n+\n+  get linkingStatus() {\n+    return linkingStatusMap.get(this);\n+  }\n+\n+  get status() {\n+    return STATUS_MAP[wrapMap.get(this).getStatus()];\n+  }\n+\n+  get namespace() {\n+    const wrap = wrapMap.get(this);\n+    if (wrap.getStatus() < kInstantiated)\n+      throw new errors.Error('ERR_VM_MODULE_STATUS',\n+                             'must not be uninstantiated or instantiating');\n+    return wrap.namespace();\n+  }\n+\n+  get dependencySpecifiers() {\n+    let deps = dependencyCacheMap.get(this);\n+    if (deps !== undefined)\n+      return deps;\n+\n+    deps = wrapMap.get(this).getStaticDependencySpecifiers();\n+    Object.freeze(deps);\n+    dependencyCacheMap.set(this, deps);\n+    return deps;\n+  }\n+\n+  get error() {\n+    const wrap = wrapMap.get(this);\n+    if (wrap.getStatus() !== kErrored)\n+      throw new errors.Error('ERR_VM_MODULE_STATUS', 'must be errored');\n+    return wrap.getError();\n+  }\n+\n+  async link(linker) {\n+    if (typeof linker !== 'function')\n+      throw new errors.TypeError(\n+        'ERR_INVALID_ARG_TYPE', 'linker', 'function', linker);\n+    if (linkingStatusMap.get(this) !== 'unlinked')\n+      throw new errors.Error('ERR_VM_MODULE_ALREADY_LINKED');\n+    const wrap = wrapMap.get(this);\n+    if (wrap.getStatus() !== kUninstantiated)\n+      throw new errors.Error('ERR_VM_MODULE_STATUS', 'must be uninstantiated');\n+    linkingStatusMap.set(this, 'linking');\n+    const promises = [];\n+    wrap.link((specifier) => {\n+      const p = (async () => {\n+        const m = await linker(this, specifier);\n+        if (!m || !wrapMap.has(m))\n+          throw new errors.Error('ERR_VM_MODULE_NOT_MODULE');\n+        if (m.context !== this.context)\n+          throw new errors.Error('ERR_VM_MODULE_DIFFERENT_CONTEXT');\n+        const childLinkingStatus = linkingStatusMap.get(m);\n+        if (childLinkingStatus === 'errored')\n+          throw new errors.Error('ERR_VM_MODULE_LINKING_ERRORED');\n+        if (childLinkingStatus === 'unlinked')\n+          await m.link(linker);\n+        return wrapMap.get(m);\n+      })();\n+      promises.push(p);\n+      return p;\n+    });\n+    try {\n+      await Promise.all(promises);\n+      linkingStatusMap.set(this, 'linked');\n+    } catch (err) {\n+      linkingStatusMap.set(this, 'errored');\n+      throw err;\n+    }\n+  }\n+\n+  instantiate() {\n+    const wrap = wrapMap.get(this);\n+    const status = wrap.getStatus();\n+    if (status === kInstantiating || status === kEvaluating)\n+      throw new errors.Error(\n+        'ERR_VM_MODULE_STATUS', 'must not be instantiating or evaluating');\n+    if (linkingStatusMap.get(this) !== 'linked')\n+      throw new errors.Error('ERR_VM_MODULE_NOT_LINKED');\n+    wrap.instantiate();\n+  }\n+\n+  async evaluate(options) {\n+    const wrap = wrapMap.get(this);\n+    const status = wrap.getStatus();\n+    if (status !== kInstantiated &&\n+        status !== kEvaluated &&\n+        status !== kErrored) {\n+      throw new errors.Error(\n+        'ERR_VM_MODULE_STATUS',\n+        'must be one of instantiated, evaluated, and errored');\n+    }\n+    const result = wrap.evaluate(options);\n+    return { result, __proto__: null };\n+  }\n+\n+  [customInspectSymbol](depth, options) {\n+    let ctor = getConstructorOf(this);\n+    ctor = ctor === null ? Module : ctor;\n+\n+    if (typeof depth === 'number' && depth < 0)\n+      return options.stylize(`[${ctor.name}]`, 'special');\n+\n+    const o = Object.create({ constructor: ctor });\n+    o.status = this.status;\n+    o.linkingStatus = this.linkingStatus;\n+    o.url = this.url;\n+    o.context = this.context;\n+    return require('util').inspect(o, options);\n+  }\n+}\n+\n+module.exports = {\n+  Module\n+};"
        },
        {
            "sha": "c9bb44f05732c91d0122da579f90023f61759b39",
            "filename": "lib/vm.js",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/lib%2Fvm.js",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/lib%2Fvm.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fvm.js?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -192,5 +192,8 @@ module.exports = {\n   runInContext,\n   runInNewContext,\n   runInThisContext,\n-  isContext\n+  isContext,\n };\n+\n+if (process.binding('config').experimentalVMModules)\n+  module.exports.Module = require('internal/vm/Module').Module;"
        },
        {
            "sha": "d8546a13738607881a0f60fcf5e3b7839f5a54e6",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -138,6 +138,7 @@\n       'lib/internal/v8.js',\n       'lib/internal/v8_prof_polyfill.js',\n       'lib/internal/v8_prof_processor.js',\n+      'lib/internal/vm/Module.js',\n       'lib/internal/streams/lazy_transform.js',\n       'lib/internal/streams/async_iterator.js',\n       'lib/internal/streams/BufferList.js',"
        },
        {
            "sha": "ba07fcdc79d61aed5a0cceed86fb724c38db92d1",
            "filename": "src/module_wrap.cc",
            "status": "modified",
            "additions": 150,
            "deletions": 32,
            "changes": 182,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/src%2Fmodule_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/src%2Fmodule_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fmodule_wrap.cc?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -7,12 +7,15 @@\n #include \"node_url.h\"\n #include \"util-inl.h\"\n #include \"node_internals.h\"\n+#include \"node_contextify.h\"\n+#include \"node_watchdog.h\"\n \n namespace node {\n namespace loader {\n \n using node::url::URL;\n using node::url::URL_FLAGS_FAILED;\n+using v8::Array;\n using v8::Context;\n using v8::Function;\n using v8::FunctionCallbackInfo;\n@@ -58,6 +61,7 @@ ModuleWrap::~ModuleWrap() {\n   }\n \n   module_.Reset();\n+  context_.Reset();\n }\n \n void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {\n@@ -70,12 +74,6 @@ void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {\n     return;\n   }\n \n-  if (args.Length() != 2) {\n-    env->ThrowError(\"constructor must have exactly 2 arguments \"\n-                    \"(string, string)\");\n-    return;\n-  }\n-\n   if (!args[0]->IsString()) {\n     env->ThrowError(\"first argument is not a string\");\n     return;\n@@ -90,20 +88,39 @@ void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {\n \n   Local<String> url = args[1].As<String>();\n \n+  Local<Object> that = args.This();\n+\n+  Environment::ShouldNotAbortOnUncaughtScope no_abort_scope(env);\n+  TryCatch try_catch(isolate);\n+\n+  Local<Value> options = args[2];\n+  MaybeLocal<Integer> line_offset = contextify::GetLineOffsetArg(env, options);\n+  MaybeLocal<Integer> column_offset =\n+      contextify::GetColumnOffsetArg(env, options);\n+  MaybeLocal<Context> maybe_context = contextify::GetContextArg(env, options);\n+\n+\n+  if (try_catch.HasCaught()) {\n+    no_abort_scope.Close();\n+    try_catch.ReThrow();\n+    return;\n+  }\n+\n+  Local<Context> context = maybe_context.FromMaybe(that->CreationContext());\n   Local<Module> module;\n \n   // compile\n   {\n     ScriptOrigin origin(url,\n-                        Integer::New(isolate, 0),             // line offset\n-                        Integer::New(isolate, 0),             // column offset\n+                        line_offset.ToLocalChecked(),         // line offset\n+                        column_offset.ToLocalChecked(),       // column offset\n                         False(isolate),                       // is cross origin\n                         Local<Integer>(),                     // script id\n                         Local<Value>(),                       // source map URL\n                         False(isolate),                       // is opaque (?)\n                         False(isolate),                       // is WASM\n                         True(isolate));                       // is ES6 module\n-    TryCatch try_catch(isolate);\n+    Context::Scope context_scope(context);\n     ScriptCompiler::Source source(source_text, origin);\n     if (!ScriptCompiler::CompileModule(isolate, &source).ToLocal(&module)) {\n       CHECK(try_catch.HasCaught());\n@@ -116,15 +133,14 @@ void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {\n     }\n   }\n \n-  Local<Object> that = args.This();\n-  Local<Context> context = that->CreationContext();\n   Local<String> url_str = FIXED_ONE_BYTE_STRING(isolate, \"url\");\n \n   if (!that->Set(context, url_str, url).FromMaybe(false)) {\n     return;\n   }\n \n   ModuleWrap* obj = new ModuleWrap(env, that, module, url);\n+  obj->context_.Reset(isolate, context);\n \n   env->module_map.emplace(module->GetIdentityHash(), obj);\n   Wrap(that, obj);\n@@ -141,15 +157,19 @@ void ModuleWrap::Link(const FunctionCallbackInfo<Value>& args) {\n     return;\n   }\n \n-  Local<Function> resolver_arg = args[0].As<Function>();\n-\n   Local<Object> that = args.This();\n-  ModuleWrap* obj = Unwrap<ModuleWrap>(that);\n-  CHECK_NE(obj, nullptr);\n-  Local<Context> mod_context = that->CreationContext();\n-  if (obj->linked_) return;\n+\n+  ModuleWrap* obj;\n+  ASSIGN_OR_RETURN_UNWRAP(&obj, that);\n+\n+  if (obj->linked_)\n+    return;\n   obj->linked_ = true;\n-  Local<Module> module(obj->module_.Get(isolate));\n+\n+  Local<Function> resolver_arg = args[0].As<Function>();\n+\n+  Local<Context> mod_context = obj->context_.Get(isolate);\n+  Local<Module> module = obj->module_.Get(isolate);\n \n   // call the dependency resolve callbacks\n   for (int i = 0; i < module->GetModuleRequestsLength(); i++) {\n@@ -181,11 +201,9 @@ void ModuleWrap::Link(const FunctionCallbackInfo<Value>& args) {\n void ModuleWrap::Instantiate(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   Isolate* isolate = args.GetIsolate();\n-  Local<Object> that = args.This();\n-  Local<Context> context = that->CreationContext();\n-\n-  ModuleWrap* obj = Unwrap<ModuleWrap>(that);\n-  CHECK_NE(obj, nullptr);\n+  ModuleWrap* obj;\n+  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());\n+  Local<Context> context = obj->context_.Get(isolate);\n   Local<Module> module = obj->module_.Get(isolate);\n   TryCatch try_catch(isolate);\n   Maybe<bool> ok =\n@@ -208,14 +226,60 @@ void ModuleWrap::Instantiate(const FunctionCallbackInfo<Value>& args) {\n }\n \n void ModuleWrap::Evaluate(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n   Isolate* isolate = args.GetIsolate();\n-  Local<Object> that = args.This();\n-  Local<Context> context = that->CreationContext();\n-  ModuleWrap* obj = Unwrap<ModuleWrap>(that);\n-  CHECK_NE(obj, nullptr);\n-  MaybeLocal<Value> result = obj->module_.Get(isolate)->Evaluate(context);\n+  ModuleWrap* obj;\n+  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());\n+  Local<Context> context = obj->context_.Get(isolate);\n+  Local<Module> module = obj->module_.Get(isolate);\n \n-  if (result.IsEmpty()) {\n+  Environment::ShouldNotAbortOnUncaughtScope no_abort_scope(env);\n+  TryCatch try_catch(isolate);\n+  Maybe<int64_t> maybe_timeout =\n+    contextify::GetTimeoutArg(env, args[0]);\n+  Maybe<bool> maybe_break_on_sigint =\n+    contextify::GetBreakOnSigintArg(env, args[0]);\n+\n+  if (try_catch.HasCaught()) {\n+    no_abort_scope.Close();\n+    try_catch.ReThrow();\n+    return;\n+  }\n+\n+  int64_t timeout = maybe_timeout.ToChecked();\n+  bool break_on_sigint = maybe_break_on_sigint.ToChecked();\n+\n+  bool timed_out = false;\n+  bool received_signal = false;\n+  MaybeLocal<Value> result;\n+  if (break_on_sigint && timeout != -1) {\n+    Watchdog wd(isolate, timeout, &timed_out);\n+    SigintWatchdog swd(isolate, &received_signal);\n+    result = module->Evaluate(context);\n+  } else if (break_on_sigint) {\n+    SigintWatchdog swd(isolate, &received_signal);\n+    result = module->Evaluate(context);\n+  } else if (timeout != -1) {\n+    Watchdog wd(isolate, timeout, &timed_out);\n+    result = module->Evaluate(context);\n+  } else {\n+    result = module->Evaluate(context);\n+  }\n+\n+  if (timed_out || received_signal) {\n+    // It is possible that execution was terminated by another timeout in\n+    // which this timeout is nested, so check whether one of the watchdogs\n+    // from this invocation is responsible for termination.\n+    if (timed_out) {\n+      env->ThrowError(\"Script execution timed out.\");\n+    } else if (received_signal) {\n+      env->ThrowError(\"Script execution interrupted.\");\n+    }\n+    env->isolate()->CancelTerminateExecution();\n+  }\n+\n+  if (try_catch.HasCaught()) {\n+    try_catch.ReThrow();\n     return;\n   }\n \n@@ -225,9 +289,8 @@ void ModuleWrap::Evaluate(const FunctionCallbackInfo<Value>& args) {\n void ModuleWrap::Namespace(const FunctionCallbackInfo<Value>& args) {\n   Environment* env = Environment::GetCurrent(args);\n   Isolate* isolate = args.GetIsolate();\n-  Local<Object> that = args.This();\n-  ModuleWrap* obj = Unwrap<ModuleWrap>(that);\n-  CHECK_NE(obj, nullptr);\n+  ModuleWrap* obj;\n+  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());\n \n   Local<Module> module = obj->module_.Get(isolate);\n \n@@ -245,6 +308,44 @@ void ModuleWrap::Namespace(const FunctionCallbackInfo<Value>& args) {\n   args.GetReturnValue().Set(result);\n }\n \n+void ModuleWrap::GetStatus(const FunctionCallbackInfo<Value>& args) {\n+  Isolate* isolate = args.GetIsolate();\n+  ModuleWrap* obj;\n+  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());\n+\n+  Local<Module> module = obj->module_.Get(isolate);\n+\n+  args.GetReturnValue().Set(module->GetStatus());\n+}\n+\n+void ModuleWrap::GetStaticDependencySpecifiers(\n+    const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  ModuleWrap* obj;\n+  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());\n+\n+  Local<Module> module = obj->module_.Get(env->isolate());\n+\n+  int count = module->GetModuleRequestsLength();\n+\n+  Local<Array> specifiers = Array::New(env->isolate(), count);\n+\n+  for (int i = 0; i < count; i++)\n+    specifiers->Set(env->context(), i, module->GetModuleRequest(i)).FromJust();\n+\n+  args.GetReturnValue().Set(specifiers);\n+}\n+\n+void ModuleWrap::GetError(const FunctionCallbackInfo<Value>& args) {\n+  Isolate* isolate = args.GetIsolate();\n+  ModuleWrap* obj;\n+  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());\n+\n+  Local<Module> module = obj->module_.Get(isolate);\n+\n+  args.GetReturnValue().Set(module->GetException());\n+}\n+\n MaybeLocal<Module> ModuleWrap::ResolveCallback(Local<Context> context,\n                                                Local<String> specifier,\n                                                Local<Module> referrer) {\n@@ -636,12 +737,29 @@ void ModuleWrap::Initialize(Local<Object> target,\n   env->SetProtoMethod(tpl, \"instantiate\", Instantiate);\n   env->SetProtoMethod(tpl, \"evaluate\", Evaluate);\n   env->SetProtoMethod(tpl, \"namespace\", Namespace);\n+  env->SetProtoMethod(tpl, \"getStatus\", GetStatus);\n+  env->SetProtoMethod(tpl, \"getError\", GetError);\n+  env->SetProtoMethod(tpl, \"getStaticDependencySpecifiers\",\n+                      GetStaticDependencySpecifiers);\n \n   target->Set(FIXED_ONE_BYTE_STRING(isolate, \"ModuleWrap\"), tpl->GetFunction());\n   env->SetMethod(target, \"resolve\", node::loader::ModuleWrap::Resolve);\n   env->SetMethod(target,\n                  \"setImportModuleDynamicallyCallback\",\n                  node::loader::ModuleWrap::SetImportModuleDynamicallyCallback);\n+\n+#define V(name)                                                                \\\n+    target->Set(context,                                                       \\\n+      FIXED_ONE_BYTE_STRING(env->isolate(), #name),                            \\\n+      Integer::New(env->isolate(), Module::Status::name))                      \\\n+        .FromJust()\n+    V(kUninstantiated);\n+    V(kInstantiating);\n+    V(kInstantiated);\n+    V(kEvaluating);\n+    V(kEvaluated);\n+    V(kErrored);\n+#undef V\n }\n \n }  // namespace loader"
        },
        {
            "sha": "bedf665165c8f63e6eaa2cc9575d7a147290e915",
            "filename": "src/module_wrap.h",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/src%2Fmodule_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/src%2Fmodule_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fmodule_wrap.h?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -36,8 +36,11 @@ class ModuleWrap : public BaseObject {\n   static void Instantiate(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void Evaluate(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void Namespace(const v8::FunctionCallbackInfo<v8::Value>& args);\n-  static void GetUrl(v8::Local<v8::String> property,\n-                     const v8::PropertyCallbackInfo<v8::Value>& info);\n+  static void GetStatus(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void GetError(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void GetStaticDependencySpecifiers(\n+      const v8::FunctionCallbackInfo<v8::Value>& args);\n+\n   static void Resolve(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void SetImportModuleDynamicallyCallback(\n       const v8::FunctionCallbackInfo<v8::Value>& args);\n@@ -50,6 +53,7 @@ class ModuleWrap : public BaseObject {\n   v8::Persistent<v8::String> url_;\n   bool linked_ = false;\n   std::unordered_map<std::string, v8::Persistent<v8::Promise>> resolve_cache_;\n+  v8::Persistent<v8::Context> context_;\n };\n \n }  // namespace loader"
        },
        {
            "sha": "c82bd73348fe10c468c65a30c7c4c37066b32779",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -240,6 +240,11 @@ bool config_preserve_symlinks = false;\n // that is used by lib/module.js\n bool config_experimental_modules = false;\n \n+// Set in node.cc by ParseArgs when --experimental-vm-modules is used.\n+// Used in node_config.cc to set a constant on process.binding('config')\n+// that is used by lib/vm.js\n+bool config_experimental_vm_modules = false;\n+\n // Set in node.cc by ParseArgs when --loader is used.\n // Used in node_config.cc to set a constant on process.binding('config')\n // that is used by lib/internal/bootstrap_node.js\n@@ -3424,6 +3429,8 @@ static void PrintHelp() {\n          \"  --preserve-symlinks        preserve symbolic links when resolving\\n\"\n          \"  --experimental-modules     experimental ES Module support\\n\"\n          \"                             and caching modules\\n\"\n+         \"  --experimental-vm-modules  experimental ES Module support\\n\"\n+         \"                             in vm module\\n\"\n #endif\n          \"\\n\"\n          \"Environment variables:\\n\"\n@@ -3503,6 +3510,7 @@ static void CheckIfAllowedInEnv(const char* exe, bool is_env,\n     \"--napi-modules\",\n     \"--expose-http2\",   // keep as a non-op through v9.x\n     \"--experimental-modules\",\n+    \"--experimental-vm-modules\",\n     \"--loader\",\n     \"--trace-warnings\",\n     \"--redirect-warnings\",\n@@ -3670,6 +3678,8 @@ static void ParseArgs(int* argc,\n       config_preserve_symlinks = true;\n     } else if (strcmp(arg, \"--experimental-modules\") == 0) {\n       config_experimental_modules = true;\n+    } else if (strcmp(arg, \"--experimental-vm-modules\") == 0) {\n+      config_experimental_vm_modules = true;\n     }  else if (strcmp(arg, \"--loader\") == 0) {\n       const char* module = argv[index + 1];\n       if (!config_experimental_modules) {"
        },
        {
            "sha": "cac551ad2c410a0ab88addfa61ce398ad2d9a515",
            "filename": "src/node_config.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/src%2Fnode_config.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/src%2Fnode_config.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_config.cc?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -82,6 +82,9 @@ static void InitConfig(Local<Object> target,\n     }\n   }\n \n+  if (config_experimental_vm_modules)\n+    READONLY_BOOLEAN_PROPERTY(\"experimentalVMModules\");\n+\n   if (config_pending_deprecation)\n     READONLY_BOOLEAN_PROPERTY(\"pendingDeprecation\");\n "
        },
        {
            "sha": "b3e1f5cd9f270c24f72e7c33f6845c48aa58aaaa",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -172,6 +172,11 @@ extern bool config_preserve_symlinks;\n // that is used by lib/module.js\n extern bool config_experimental_modules;\n \n+// Set in node.cc by ParseArgs when --experimental-vm-modules is used.\n+// Used in node_config.cc to set a constant on process.binding('config')\n+// that is used by lib/vm.js\n+extern bool config_experimental_vm_modules;\n+\n // Set in node.cc by ParseArgs when --loader is used.\n // Used in node_config.cc to set a constant on process.binding('config')\n // that is used by lib/internal/bootstrap_node.js"
        },
        {
            "sha": "4bbe0a95ee6724e85fee6bf9ee555c0491de2900",
            "filename": "test/parallel/test-vm-module-basic.js",
            "status": "added",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/test%2Fparallel%2Ftest-vm-module-basic.js",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/test%2Fparallel%2Ftest-vm-module-basic.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-module-basic.js?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -0,0 +1,54 @@\n+'use strict';\n+\n+// Flags: --experimental-vm-modules\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const { Module, createContext } = require('vm');\n+\n+common.crashOnUnhandledRejection();\n+\n+(async function test1() {\n+  const context = createContext({\n+    foo: 'bar',\n+    baz: undefined,\n+    typeofProcess: undefined,\n+  });\n+  const m = new Module(\n+    'baz = foo; typeofProcess = typeof process; typeof Object;',\n+    { context }\n+  );\n+  assert.strictEqual(m.status, 'uninstantiated');\n+  await m.link(common.mustNotCall());\n+  m.instantiate();\n+  assert.strictEqual(m.status, 'instantiated');\n+  const result = await m.evaluate();\n+  assert.strictEqual(m.status, 'evaluated');\n+  assert.strictEqual(Object.getPrototypeOf(result), null);\n+  assert.deepStrictEqual(context, {\n+    foo: 'bar',\n+    baz: 'bar',\n+    typeofProcess: 'undefined'\n+  });\n+  assert.strictEqual(result.result, 'function');\n+}());\n+\n+(async () => {\n+  const m = new Module(\n+    'global.vmResult = \"foo\"; Object.prototype.toString.call(process);'\n+  );\n+  await m.link(common.mustNotCall());\n+  m.instantiate();\n+  const { result } = await m.evaluate();\n+  assert.strictEqual(global.vmResult, 'foo');\n+  assert.strictEqual(result, '[object process]');\n+  delete global.vmResult;\n+})();\n+\n+(async () => {\n+  const m = new Module('while (true) {}');\n+  await m.link(common.mustNotCall());\n+  m.instantiate();\n+  await m.evaluate({ timeout: 500 })\n+    .then(() => assert(false), () => {});\n+})();"
        },
        {
            "sha": "ca4dceb5def7318ec5be421071b8d95c565899cd",
            "filename": "test/parallel/test-vm-module-dynamic-import.js",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/test%2Fparallel%2Ftest-vm-module-dynamic-import.js",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/test%2Fparallel%2Ftest-vm-module-dynamic-import.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-module-dynamic-import.js?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -0,0 +1,27 @@\n+'use strict';\n+\n+// Flags: --experimental-vm-modules --experimental-modules --harmony-dynamic-import\n+\n+const common = require('../common');\n+common.crashOnUnhandledRejection();\n+\n+const assert = require('assert');\n+const { Module, createContext } = require('vm');\n+\n+const finished = common.mustCall();\n+\n+(async function() {\n+  const m = new Module('import(\"foo\")', { context: createContext() });\n+  await m.link(common.mustNotCall());\n+  m.instantiate();\n+  const { result } = await m.evaluate();\n+  let threw = false;\n+  try {\n+    await result;\n+  } catch (err) {\n+    threw = true;\n+    assert.strictEqual(err.message, 'import() called outside of main context');\n+  }\n+  assert(threw);\n+  finished();\n+}());"
        },
        {
            "sha": "8bcb101ccc8e6d080bfd7dea8b1c409a7bbe6299",
            "filename": "test/parallel/test-vm-module-errors.js",
            "status": "added",
            "additions": 264,
            "deletions": 0,
            "changes": 264,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/test%2Fparallel%2Ftest-vm-module-errors.js",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/test%2Fparallel%2Ftest-vm-module-errors.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-module-errors.js?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -0,0 +1,264 @@\n+'use strict';\n+\n+// Flags: --experimental-vm-modules\n+\n+const common = require('../common');\n+common.crashOnUnhandledRejection();\n+\n+const assert = require('assert');\n+\n+const { Module, createContext } = require('vm');\n+\n+async function expectsRejection(fn, settings) {\n+  const validateError = common.expectsError(settings);\n+  // Retain async context.\n+  const storedError = new Error('Thrown from:');\n+  try {\n+    await fn();\n+  } catch (err) {\n+    try {\n+      validateError(err);\n+    } catch (validationError) {\n+      console.error(validationError);\n+      console.error('Original error:');\n+      console.error(err);\n+      throw storedError;\n+    }\n+    return;\n+  }\n+  assert.fail('Missing expected exception');\n+}\n+\n+async function createEmptyLinkedModule() {\n+  const m = new Module('');\n+  await m.link(common.mustNotCall());\n+  return m;\n+}\n+\n+async function checkArgType() {\n+  common.expectsError(() => {\n+    new Module();\n+  }, {\n+    code: 'ERR_INVALID_ARG_TYPE',\n+    type: TypeError\n+  });\n+\n+  for (const invalidOptions of [\n+    0, 1, null, true, 'str', () => {}, Symbol.iterator\n+  ]) {\n+    common.expectsError(() => {\n+      new Module('', invalidOptions);\n+    }, {\n+      code: 'ERR_INVALID_ARG_TYPE',\n+      type: TypeError\n+    });\n+  }\n+\n+  for (const invalidLinker of [\n+    0, 1, undefined, null, true, 'str', {}, Symbol.iterator\n+  ]) {\n+    await expectsRejection(async () => {\n+      const m = new Module('');\n+      await m.link(invalidLinker);\n+    }, {\n+      code: 'ERR_INVALID_ARG_TYPE',\n+      type: TypeError\n+    });\n+  }\n+}\n+\n+// Check methods/properties can only be used under a specific state.\n+async function checkModuleState() {\n+  await expectsRejection(async () => {\n+    const m = new Module('');\n+    await m.link(common.mustNotCall());\n+    assert.strictEqual(m.linkingStatus, 'linked');\n+    await m.link(common.mustNotCall());\n+  }, {\n+    code: 'ERR_VM_MODULE_ALREADY_LINKED'\n+  });\n+\n+  await expectsRejection(async () => {\n+    const m = new Module('');\n+    m.link(common.mustNotCall());\n+    assert.strictEqual(m.linkingStatus, 'linking');\n+    await m.link(common.mustNotCall());\n+  }, {\n+    code: 'ERR_VM_MODULE_ALREADY_LINKED'\n+  });\n+\n+  common.expectsError(() => {\n+    const m = new Module('');\n+    m.instantiate();\n+  }, {\n+    code: 'ERR_VM_MODULE_NOT_LINKED'\n+  });\n+\n+  await expectsRejection(async () => {\n+    const m = new Module('import \"foo\";');\n+    try {\n+      await m.link(common.mustCall(() => ({})));\n+    } catch (err) {\n+      assert.strictEqual(m.linkingStatus, 'errored');\n+      m.instantiate();\n+    }\n+    assert.fail('Unreachable');\n+  }, {\n+    code: 'ERR_VM_MODULE_NOT_LINKED'\n+  });\n+\n+  {\n+    const m = new Module('import \"foo\";');\n+    await m.link(common.mustCall(async (module, specifier) => {\n+      assert.strictEqual(module, m);\n+      assert.strictEqual(specifier, 'foo');\n+      assert.strictEqual(m.linkingStatus, 'linking');\n+      common.expectsError(() => {\n+        m.instantiate();\n+      }, {\n+        code: 'ERR_VM_MODULE_NOT_LINKED'\n+      });\n+      return new Module('');\n+    }));\n+    m.instantiate();\n+    await m.evaluate();\n+  }\n+\n+  await expectsRejection(async () => {\n+    const m = new Module('');\n+    await m.evaluate();\n+  }, {\n+    code: 'ERR_VM_MODULE_STATUS',\n+    message: 'Module status must be one of instantiated, evaluated, and errored'\n+  });\n+\n+  await expectsRejection(async () => {\n+    const m = await createEmptyLinkedModule();\n+    await m.evaluate();\n+  }, {\n+    code: 'ERR_VM_MODULE_STATUS',\n+    message: 'Module status must be one of instantiated, evaluated, and errored'\n+  });\n+\n+  common.expectsError(() => {\n+    const m = new Module('');\n+    m.error;\n+  }, {\n+    code: 'ERR_VM_MODULE_STATUS',\n+    message: 'Module status must be errored'\n+  });\n+\n+  await expectsRejection(async () => {\n+    const m = await createEmptyLinkedModule();\n+    m.instantiate();\n+    await m.evaluate();\n+    m.error;\n+  }, {\n+    code: 'ERR_VM_MODULE_STATUS',\n+    message: 'Module status must be errored'\n+  });\n+\n+  common.expectsError(() => {\n+    const m = new Module('');\n+    m.namespace;\n+  }, {\n+    code: 'ERR_VM_MODULE_STATUS',\n+    message: 'Module status must not be uninstantiated or instantiating'\n+  });\n+\n+  await expectsRejection(async () => {\n+    const m = await createEmptyLinkedModule();\n+    m.namespace;\n+  }, {\n+    code: 'ERR_VM_MODULE_STATUS',\n+    message: 'Module status must not be uninstantiated or instantiating'\n+  });\n+}\n+\n+// Check link() fails when the returned module is not valid.\n+async function checkLinking() {\n+  await expectsRejection(async () => {\n+    const m = new Module('import \"foo\";');\n+    try {\n+      await m.link(common.mustCall(() => ({})));\n+    } catch (err) {\n+      assert.strictEqual(m.linkingStatus, 'errored');\n+      throw err;\n+    }\n+    assert.fail('Unreachable');\n+  }, {\n+    code: 'ERR_VM_MODULE_NOT_MODULE'\n+  });\n+\n+  await expectsRejection(async () => {\n+    const c = createContext({ a: 1 });\n+    const foo = new Module('', { context: c });\n+    await foo.link(common.mustNotCall());\n+    const bar = new Module('import \"foo\";');\n+    try {\n+      await bar.link(common.mustCall(() => foo));\n+    } catch (err) {\n+      assert.strictEqual(bar.linkingStatus, 'errored');\n+      throw err;\n+    }\n+    assert.fail('Unreachable');\n+  }, {\n+    code: 'ERR_VM_MODULE_DIFFERENT_CONTEXT'\n+  });\n+\n+  await expectsRejection(async () => {\n+    const erroredModule = new Module('import \"foo\";');\n+    try {\n+      await erroredModule.link(common.mustCall(() => ({})));\n+    } catch (err) {\n+      // ignored\n+    } finally {\n+      assert.strictEqual(erroredModule.linkingStatus, 'errored');\n+    }\n+\n+    const rootModule = new Module('import \"errored\";');\n+    await rootModule.link(common.mustCall(() => erroredModule));\n+  }, {\n+    code: 'ERR_VM_MODULE_LINKING_ERRORED'\n+  });\n+}\n+\n+// Check the JavaScript engine deals with exceptions correctly\n+async function checkExecution() {\n+  await (async () => {\n+    const m = new Module('import { nonexistent } from \"module\";');\n+    await m.link(common.mustCall(() => new Module('')));\n+\n+    // There is no code for this exception since it is thrown by the JavaScript\n+    // engine.\n+    assert.throws(() => {\n+      m.instantiate();\n+    }, SyntaxError);\n+  })();\n+\n+  await (async () => {\n+    const m = new Module('throw new Error();');\n+    await m.link(common.mustNotCall());\n+    m.instantiate();\n+    const evaluatePromise = m.evaluate();\n+    await evaluatePromise.catch(() => {});\n+    assert.strictEqual(m.status, 'errored');\n+    try {\n+      await evaluatePromise;\n+    } catch (err) {\n+      assert.strictEqual(m.error, err);\n+      return;\n+    }\n+    assert.fail('Missing expected exception');\n+  })();\n+}\n+\n+const finished = common.mustCall();\n+\n+(async function main() {\n+  await checkArgType();\n+  await checkModuleState();\n+  await checkLinking();\n+  await checkExecution();\n+  finished();\n+})();"
        },
        {
            "sha": "870427e91be4bffe3d36373941a68e4c25f12b15",
            "filename": "test/parallel/test-vm-module-link.js",
            "status": "added",
            "additions": 135,
            "deletions": 0,
            "changes": 135,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/test%2Fparallel%2Ftest-vm-module-link.js",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/test%2Fparallel%2Ftest-vm-module-link.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-module-link.js?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -0,0 +1,135 @@\n+'use strict';\n+\n+// Flags: --experimental-vm-modules\n+\n+const common = require('../common');\n+common.crashOnUnhandledRejection();\n+\n+const assert = require('assert');\n+const { URL } = require('url');\n+\n+const { Module } = require('vm');\n+\n+async function simple() {\n+  const foo = new Module('export default 5;');\n+  await foo.link(common.mustNotCall());\n+\n+  const bar = new Module('import five from \"foo\"; five');\n+\n+  assert.deepStrictEqual(bar.dependencySpecifiers, ['foo']);\n+\n+  await bar.link(common.mustCall((module, specifier) => {\n+    assert.strictEqual(module, bar);\n+    assert.strictEqual(specifier, 'foo');\n+    return foo;\n+  }));\n+\n+  bar.instantiate();\n+\n+  assert.strictEqual((await bar.evaluate()).result, 5);\n+}\n+\n+async function depth() {\n+  const foo = new Module('export default 5');\n+  await foo.link(common.mustNotCall());\n+\n+  async function getProxy(parentName, parentModule) {\n+    const mod = new Module(`\n+      import ${parentName} from '${parentName}';\n+      export default ${parentName};\n+    `);\n+    await mod.link(common.mustCall((module, specifier) => {\n+      assert.strictEqual(module, mod);\n+      assert.strictEqual(specifier, parentName);\n+      return parentModule;\n+    }));\n+    return mod;\n+  }\n+\n+  const bar = await getProxy('foo', foo);\n+  const baz = await getProxy('bar', bar);\n+  const barz = await getProxy('baz', baz);\n+\n+  barz.instantiate();\n+  await barz.evaluate();\n+\n+  assert.strictEqual(barz.namespace.default, 5);\n+}\n+\n+async function circular() {\n+  const foo = new Module(`\n+    import getFoo from 'bar';\n+    export let foo = 42;\n+    export default getFoo();\n+  `);\n+  const bar = new Module(`\n+    import { foo } from 'foo';\n+    export default function getFoo() {\n+      return foo;\n+    }\n+  `);\n+  await foo.link(common.mustCall(async (fooModule, fooSpecifier) => {\n+    assert.strictEqual(fooModule, foo);\n+    assert.strictEqual(fooSpecifier, 'bar');\n+    await bar.link(common.mustCall((barModule, barSpecifier) => {\n+      assert.strictEqual(barModule, bar);\n+      assert.strictEqual(barSpecifier, 'foo');\n+      assert.strictEqual(foo.linkingStatus, 'linking');\n+      return foo;\n+    }));\n+    assert.strictEqual(bar.linkingStatus, 'linked');\n+    return bar;\n+  }));\n+\n+  foo.instantiate();\n+  await foo.evaluate();\n+  assert.strictEqual(foo.namespace.default, 42);\n+}\n+\n+async function circular2() {\n+  const sourceMap = {\n+    root: `\n+      import * as a from './a.mjs';\n+      import * as b from './b.mjs';\n+      if (!('fromA' in a))\n+        throw new Error();\n+      if (!('fromB' in a))\n+        throw new Error();\n+      if (!('fromA' in b))\n+        throw new Error();\n+      if (!('fromB' in b))\n+        throw new Error();\n+    `,\n+    './a.mjs': `\n+      export * from './b.mjs';\n+      export var fromA;\n+    `,\n+    './b.mjs': `\n+      export * from './a.mjs';\n+      export var fromB;\n+    `\n+  };\n+  const moduleMap = new Map();\n+  const rootModule = new Module(sourceMap.root, { url: 'vm:root' });\n+  async function link(referencingModule, specifier) {\n+    if (moduleMap.has(specifier)) {\n+      return moduleMap.get(specifier);\n+    }\n+    const mod = new Module(sourceMap[specifier], { url: new URL(specifier, 'file:///').href });\n+    moduleMap.set(specifier, mod);\n+    return mod;\n+  }\n+  await rootModule.link(link);\n+  rootModule.instantiate();\n+  await rootModule.evaluate();\n+}\n+\n+const finished = common.mustCall();\n+\n+(async function main() {\n+  await simple();\n+  await depth();\n+  await circular();\n+  await circular2();\n+  finished();\n+})();"
        },
        {
            "sha": "e4f5858800e297b475908f0858ae2993f64dad65",
            "filename": "test/parallel/test-vm-module-reevaluate.js",
            "status": "added",
            "additions": 49,
            "deletions": 0,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/0993fbe5b213d0fe746c3162bcda85f6c66bb552/test%2Fparallel%2Ftest-vm-module-reevaluate.js",
            "raw_url": "https://github.com/nodejs/node/raw/0993fbe5b213d0fe746c3162bcda85f6c66bb552/test%2Fparallel%2Ftest-vm-module-reevaluate.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-vm-module-reevaluate.js?ref=0993fbe5b213d0fe746c3162bcda85f6c66bb552",
            "patch": "@@ -0,0 +1,49 @@\n+'use strict';\n+\n+// Flags: --experimental-vm-modules\n+\n+const common = require('../common');\n+common.crashOnUnhandledRejection();\n+\n+const assert = require('assert');\n+\n+const { Module } = require('vm');\n+\n+const finished = common.mustCall();\n+\n+(async function main() {\n+  {\n+    const m = new Module('1');\n+    await m.link(common.mustNotCall());\n+    m.instantiate();\n+    assert.strictEqual((await m.evaluate()).result, 1);\n+    assert.strictEqual((await m.evaluate()).result, undefined);\n+    assert.strictEqual((await m.evaluate()).result, undefined);\n+  }\n+\n+  {\n+    const m = new Module('throw new Error()');\n+    await m.link(common.mustNotCall());\n+    m.instantiate();\n+\n+    let threw = false;\n+    try {\n+      await m.evaluate();\n+    } catch (err) {\n+      assert(err instanceof Error);\n+      threw = true;\n+    }\n+    assert(threw);\n+\n+    threw = false;\n+    try {\n+      await m.evaluate();\n+    } catch (err) {\n+      assert(err instanceof Error);\n+      threw = true;\n+    }\n+    assert(threw);\n+  }\n+\n+  finished();\n+})();"
        }
    ],
    "stats": {
        "total": 1316,
        "additions": 1281,
        "deletions": 35
    }
}