{
    "author": "cjihrig",
    "message": "deps: upgrade to libuv 1.21.0\n\nNotable changes:\n\n- Building via cmake is now supported.\n  PR-URL: https://github.com/libuv/libuv/pull/1850\n- Stricter checks have been added to prevent watching the same\n  file descriptor multiple times.\n  PR-URL: https://github.com/libuv/libuv/pull/1851\n  Refs: https://github.com/nodejs/node/issues/3604\n- An IPC deadlock on Windows has been fixed.\n  PR-URL: https://github.com/libuv/libuv/pull/1843\n  Fixes: https://github.com/nodejs/node/issues/9706\n  Fixes: https://github.com/nodejs/node/issues/7657\n- uv_fs_lchown() has been added.\n  PR-URL: https://github.com/libuv/libuv/pull/1826\n  Refs: https://github.com/nodejs/node/issues/19868\n- uv_fs_copyfile() sets errno on error.\n  PR-URL: https://github.com/libuv/libuv/pull/1881\n  Fixes: https://github.com/nodejs/node/issues/21329\n- uv_fs_fchmod() supports -A files on Windows.\n  PR-URL: https://github.com/libuv/libuv/pull/1819\n  Refs: https://github.com/nodejs/node/issues/12803\n\nPR-URL: https://github.com/nodejs/node/pull/21466\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Santiago Gimeno <santiago.gimeno@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "537a4baa443daea9850a8e324b5b4d7c21dd2717",
    "files": [
        {
            "sha": "eb8501aab12d458024339cd9e6f6aa64a7582332",
            "filename": "deps/uv/AUTHORS",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FAUTHORS",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FAUTHORS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FAUTHORS?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -338,3 +338,8 @@ zzzjim <zzzjim@users.noreply.github.com>\n Alex Arslan <ararslan@comcast.net>\n Kyle Farnung <kfarnung@microsoft.com>\n ssrlive <30760636+ssrlive@users.noreply.github.com>\n+Tobias Nießen <tniessen@tnie.de>\n+Björn Linse <bjorn.linse@gmail.com>\n+zyxwvu Shi <i@shiyc.cn>\n+Peter Johnson <johnson.peter@gmail.com>\n+Paolo Greppi <paolo.greppi@libpf.com>"
        },
        {
            "sha": "f13e5295636b49b8939a636c54fa0d3095015e41",
            "filename": "deps/uv/CMakeLists.txt",
            "status": "added",
            "additions": 381,
            "deletions": 0,
            "changes": 381,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FCMakeLists.txt",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FCMakeLists.txt",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FCMakeLists.txt?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -0,0 +1,381 @@\n+# TODO: determine CMAKE_SYSTEM_NAME on OS/390.  Currently assumes \"OS/390\".\n+cmake_minimum_required(VERSION 3.0)\n+project(libuv)\n+enable_testing()\n+\n+if(MSVC)\n+  list(APPEND uv_cflags /W4)\n+elseif(CMAKE_C_COMPILER_ID MATCHES \"AppleClang|Clang|GNU\")\n+  list(APPEND uv_cflags -fvisibility=hidden --std=gnu89)\n+  list(APPEND uv_cflags -Wall -Wextra -Wstrict-prototypes)\n+  list(APPEND uv_cflags -Wno-unused-parameter)\n+endif()\n+\n+set(uv_sources\n+    src/fs-poll.c\n+    src/inet.c\n+    src/threadpool.c\n+    src/uv-common.c\n+    src/uv-data-getter-setters.c\n+    src/version.c)\n+\n+set(uv_test_sources\n+    test/blackhole-server.c\n+    test/echo-server.c\n+    test/run-tests.c\n+    test/runner.c\n+    test/test-active.c\n+    test/test-async-null-cb.c\n+    test/test-async.c\n+    test/test-barrier.c\n+    test/test-callback-order.c\n+    test/test-callback-stack.c\n+    test/test-close-fd.c\n+    test/test-close-order.c\n+    test/test-condvar.c\n+    test/test-connect-unspecified.c\n+    test/test-connection-fail.c\n+    test/test-cwd-and-chdir.c\n+    test/test-default-loop-close.c\n+    test/test-delayed-accept.c\n+    test/test-dlerror.c\n+    test/test-eintr-handling.c\n+    test/test-embed.c\n+    test/test-emfile.c\n+    test/test-env-vars.c\n+    test/test-error.c\n+    test/test-fail-always.c\n+    test/test-fork.c\n+    test/test-fs-copyfile.c\n+    test/test-fs-event.c\n+    test/test-fs-poll.c\n+    test/test-fs.c\n+    test/test-get-currentexe.c\n+    test/test-get-loadavg.c\n+    test/test-get-memory.c\n+    test/test-get-passwd.c\n+    test/test-getaddrinfo.c\n+    test/test-gethostname.c\n+    test/test-getnameinfo.c\n+    test/test-getsockname.c\n+    test/test-getters-setters.c\n+    test/test-handle-fileno.c\n+    test/test-homedir.c\n+    test/test-hrtime.c\n+    test/test-idle.c\n+    test/test-ip4-addr.c\n+    test/test-ip6-addr.c\n+    test/test-ip6-addr.c\n+    test/test-ipc-heavy-traffic-deadlock-bug.c\n+    test/test-ipc-send-recv.c\n+    test/test-ipc.c\n+    test/test-loop-alive.c\n+    test/test-loop-close.c\n+    test/test-loop-configure.c\n+    test/test-loop-handles.c\n+    test/test-loop-stop.c\n+    test/test-loop-time.c\n+    test/test-multiple-listen.c\n+    test/test-mutexes.c\n+    test/test-osx-select.c\n+    test/test-pass-always.c\n+    test/test-ping-pong.c\n+    test/test-pipe-bind-error.c\n+    test/test-pipe-close-stdout-read-stdin.c\n+    test/test-pipe-connect-error.c\n+    test/test-pipe-connect-multiple.c\n+    test/test-pipe-connect-prepare.c\n+    test/test-pipe-getsockname.c\n+    test/test-pipe-pending-instances.c\n+    test/test-pipe-sendmsg.c\n+    test/test-pipe-server-close.c\n+    test/test-pipe-set-fchmod.c\n+    test/test-pipe-set-non-blocking.c\n+    test/test-platform-output.c\n+    test/test-poll-close-doesnt-corrupt-stack.c\n+    test/test-poll-close.c\n+    test/test-poll-closesocket.c\n+    test/test-poll-oob.c\n+    test/test-poll.c\n+    test/test-process-title-threadsafe.c\n+    test/test-process-title.c\n+    test/test-queue-foreach-delete.c\n+    test/test-ref.c\n+    test/test-run-nowait.c\n+    test/test-run-once.c\n+    test/test-semaphore.c\n+    test/test-shutdown-close.c\n+    test/test-shutdown-eof.c\n+    test/test-shutdown-twice.c\n+    test/test-signal-multiple-loops.c\n+    test/test-signal.c\n+    test/test-socket-buffer-size.c\n+    test/test-spawn.c\n+    test/test-stdio-over-pipes.c\n+    test/test-tcp-alloc-cb-fail.c\n+    test/test-tcp-bind-error.c\n+    test/test-tcp-bind6-error.c\n+    test/test-tcp-close-accept.c\n+    test/test-tcp-close-while-connecting.c\n+    test/test-tcp-close.c\n+    test/test-tcp-connect-error-after-write.c\n+    test/test-tcp-connect-error.c\n+    test/test-tcp-connect-timeout.c\n+    test/test-tcp-connect6-error.c\n+    test/test-tcp-create-socket-early.c\n+    test/test-tcp-flags.c\n+    test/test-tcp-oob.c\n+    test/test-tcp-open.c\n+    test/test-tcp-read-stop.c\n+    test/test-tcp-shutdown-after-write.c\n+    test/test-tcp-try-write.c\n+    test/test-tcp-unexpected-read.c\n+    test/test-tcp-write-after-connect.c\n+    test/test-tcp-write-fail.c\n+    test/test-tcp-write-queue-order.c\n+    test/test-tcp-write-to-half-open-connection.c\n+    test/test-tcp-writealot.c\n+    test/test-thread-equal.c\n+    test/test-thread.c\n+    test/test-threadpool-cancel.c\n+    test/test-threadpool.c\n+    test/test-timer-again.c\n+    test/test-timer-from-check.c\n+    test/test-timer.c\n+    test/test-tmpdir.c\n+    test/test-tty.c\n+    test/test-udp-alloc-cb-fail.c\n+    test/test-udp-bind.c\n+    test/test-udp-create-socket-early.c\n+    test/test-udp-dgram-too-big.c\n+    test/test-udp-ipv6.c\n+    test/test-udp-multicast-interface.c\n+    test/test-udp-multicast-interface6.c\n+    test/test-udp-multicast-join.c\n+    test/test-udp-multicast-join6.c\n+    test/test-udp-multicast-ttl.c\n+    test/test-udp-open.c\n+    test/test-udp-options.c\n+    test/test-udp-send-and-recv.c\n+    test/test-udp-send-hang-loop.c\n+    test/test-udp-send-immediate.c\n+    test/test-udp-send-unreachable.c\n+    test/test-udp-try-send.c\n+    test/test-walk-handles.c\n+    test/test-watcher-cross-stop.c)\n+\n+if(WIN32)\n+  list(APPEND uv_defines WIN32_LEAN_AND_MEAN _WIN32_WINNT=0x0600)\n+  list(APPEND uv_libraries\n+       advapi32\n+       iphlpapi\n+       psapi\n+       shell32\n+       user32\n+       userenv\n+       ws2_32)\n+  list(APPEND uv_sources\n+       src/win/async.c\n+       src/win/core.c\n+       src/win/detect-wakeup.c\n+       src/win/dl.c\n+       src/win/error.c\n+       src/win/fs.c\n+       src/win/fs-event.c\n+       src/win/getaddrinfo.c\n+       src/win/getnameinfo.c\n+       src/win/handle.c\n+       src/win/loop-watcher.c\n+       src/win/pipe.c\n+       src/win/thread.c\n+       src/win/poll.c\n+       src/win/process.c\n+       src/win/process-stdio.c\n+       src/win/req.c\n+       src/win/signal.c\n+       src/win/snprintf.c\n+       src/win/stream.c\n+       src/win/tcp.c\n+       src/win/tty.c\n+       src/win/timer.c\n+       src/win/udp.c\n+       src/win/util.c\n+       src/win/winapi.c\n+       src/win/winsock.c)\n+  list(APPEND uv_test_libraries ws2_32)\n+  list(APPEND uv_test_sources src/win/snprintf.c test/runner-win.c)\n+else()\n+  list(APPEND uv_defines _FILE_OFFSET_BITS=64 _LARGEFILE_SOURCE)\n+  list(APPEND uv_libraries pthread)\n+  list(APPEND uv_sources\n+       src/unix/async.c\n+       src/unix/core.c\n+       src/unix/dl.c\n+       src/unix/fs.c\n+       src/unix/getaddrinfo.c\n+       src/unix/getnameinfo.c\n+       src/unix/loop-watcher.c\n+       src/unix/loop.c\n+       src/unix/pipe.c\n+       src/unix/poll.c\n+       src/unix/process.c\n+       src/unix/signal.c\n+       src/unix/stream.c\n+       src/unix/tcp.c\n+       src/unix/thread.c\n+       src/unix/timer.c\n+       src/unix/tty.c\n+       src/unix/udp.c)\n+  list(APPEND uv_test_sources test/runner-unix.c)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME STREQUAL \"AIX\")\n+  list(APPEND uv_defines\n+       _ALL_SOURCE\n+       _LINUX_SOURCE_COMPAT\n+       _THREAD_SAFE\n+       _XOPEN_SOURCE=500)\n+  list(APPEND uv_libraries perfstat)\n+  list(APPEND uv_sources src/unix/aix.c)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME STREQUAL \"Android\")\n+  list(APPEND uv_libs dl)\n+  list(APPEND uv_sources\n+       src/unix/android-ifaddrs.c\n+       src/unix/linux-core.c\n+       src/unix/linux-inotify.c\n+       src/unix/linux-syscalls.c\n+       src/unix/procfs-exepath.c\n+       src/unix/pthread-fixes.c\n+       src/unix/sysinfo-loadavg.c\n+       src/unix/sysinfo-memory.c)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME MATCHES \"Android|Darwin|Linux|OS/390\")\n+  list(APPEND uv_sources src/unix/proctitle.c)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME MATCHES \"DragonFly|FreeBSD\")\n+  list(APPEND uv_sources src/unix/freebsd.c)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME MATCHES \"DragonFly|FreeBSD|NetBSD|OpenBSD\")\n+  list(APPEND uv_sources src/unix/posix-hrtime.c)\n+  list(APPEND uv_libraries kvm)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME MATCHES \"Darwin|DragonFly|FreeBSD|NetBSD|OpenBSD\")\n+  list(APPEND uv_sources src/unix/bsd-ifaddrs.c src/unix/kqueue.c)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n+  list(APPEND uv_defines _DARWIN_UNLIMITED_SELECT=1 _DARWIN_USE_64_BIT_INODE=1)\n+  list(APPEND uv_sources\n+       src/unix/darwin-proctitle.c\n+       src/unix/darwin.c\n+       src/unix/fsevents.c)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME STREQUAL \"Linux\")\n+  list(APPEND uv_defines _GNU_SOURCE _POSIX_C_SOURCE=200112)\n+  list(APPEND uv_libraries dl rt)\n+  list(APPEND uv_sources\n+       src/unix/linux-core.c\n+       src/unix/linux-inotify.c\n+       src/unix/linux-syscalls.c\n+       src/unix/procfs-exepath.c\n+       src/unix/sysinfo-loadavg.c\n+       src/unix/sysinfo-memory.c)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME STREQUAL \"NetBSD\")\n+  list(APPEND uv_sources src/unix/netbsd.c)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME STREQUAL \"OpenBSD\")\n+  list(APPEND uv_sources src/unix/openbsd.c)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME STREQUAL \"OS/390\")\n+  list(APPEND uv_defines PATH_MAX=255)\n+  list(APPEND uv_defines _AE_BIMODAL)\n+  list(APPEND uv_defines _ALL_SOURCE)\n+  list(APPEND uv_defines _LARGE_TIME_API)\n+  list(APPEND uv_defines _OPEN_MSGQ_EXT)\n+  list(APPEND uv_defines _OPEN_SYS_FILE_EXT)\n+  list(APPEND uv_defines _OPEN_SYS_IF_EXT)\n+  list(APPEND uv_defines _OPEN_SYS_SOCK_IPV6)\n+  list(APPEND uv_defines _UNIX03_SOURCE)\n+  list(APPEND uv_defines _UNIX03_THREADS)\n+  list(APPEND uv_defines _UNIX03_WITHDRAWN)\n+  list(APPEND uv_defines _XOPEN_SOURCE_EXTENDED)\n+  list(APPEND uv_sources\n+       src/unix/pthread-fixes.c\n+       src/unix/pthread-barrier.c\n+       src/unix/os390.c\n+       src/unix/os390-syscalls.c)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME STREQUAL \"SunOS\")\n+  list(APPEND uv_defines __EXTENSIONS__ _XOPEN_SOURCE=500)\n+  list(APPEND uv_libraries kstat nsl sendfile socket)\n+  list(APPEND uv_sources src/unix/no-proctitle.c src/unix/sunos.c)\n+endif()\n+\n+if(CMAKE_SYSTEM_NAME MATCHES \"Darwin|DragonFly|FreeBSD|Linux|NetBSD|OpenBSD\")\n+  list(APPEND uv_test_libraries util)\n+endif()\n+\n+add_library(uv SHARED ${uv_sources})\n+target_compile_definitions(uv PRIVATE ${uv_defines} BUILDING_UV_SHARED=1)\n+target_compile_options(uv PRIVATE ${uv_cflags})\n+target_include_directories(uv PRIVATE include src)\n+target_link_libraries(uv ${uv_libraries})\n+\n+add_library(uv_a STATIC ${uv_sources})\n+target_compile_definitions(uv_a PRIVATE ${uv_defines})\n+target_compile_options(uv_a PRIVATE ${uv_cflags})\n+target_include_directories(uv_a PRIVATE include src)\n+target_link_libraries(uv_a ${uv_libraries})\n+\n+if(BUILD_TESTING)\n+  include(CTest)\n+  add_executable(uv_run_tests ${uv_test_sources})\n+  target_compile_definitions(uv_run_tests PRIVATE ${uv_defines})\n+  target_compile_options(uv_run_tests PRIVATE ${uv_cflags})\n+  target_include_directories(uv_run_tests PRIVATE include)\n+  target_link_libraries(uv_run_tests uv ${uv_test_libraries})\n+  add_test(NAME uv_test\n+           COMMAND uv_run_tests\n+           WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n+  add_executable(uv_run_tests_a ${uv_test_sources})\n+  target_compile_definitions(uv_run_tests_a PRIVATE ${uv_defines})\n+  target_compile_options(uv_run_tests_a PRIVATE ${uv_cflags})\n+  target_include_directories(uv_run_tests_a PRIVATE include)\n+  target_link_libraries(uv_run_tests_a uv_a ${uv_test_libraries})\n+  add_test(NAME uv_test_a\n+           COMMAND uv_run_tests_a\n+           WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n+endif()\n+\n+if(UNIX)\n+  # Now for some gibbering horrors from beyond the stars...\n+  include(GNUInstallDirs)\n+  foreach(x ${uv_libraries})\n+    set(LIBS \"${LIBS} -l${x}\")\n+  endforeach(x)\n+  file(STRINGS configure.ac configure_ac REGEX ^AC_INIT)\n+  string(REGEX MATCH [0-9]+[.][0-9]+[.][0-9]+ PACKAGE_VERSION \"${configure_ac}\")\n+  set(includedir ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR})\n+  set(libdir ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR})\n+  set(prefix ${CMAKE_INSTALL_PREFIX})\n+  configure_file(libuv.pc.in ${CMAKE_CURRENT_BINARY_DIR}/libuv.pc @ONLY)\n+\n+  install(DIRECTORY include/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\n+  install(FILES LICENSE DESTINATION ${CMAKE_INSTALL_DOCDIR})\n+  install(FILES LICENSE ${CMAKE_CURRENT_BINARY_DIR}/libuv.pc\n+          DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\n+  install(TARGETS uv LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR})\n+  install(TARGETS uv_a ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})\n+endif()"
        },
        {
            "sha": "f22e124e3b23b97b7eb220dd68549ba42a1764a1",
            "filename": "deps/uv/CONTRIBUTING.md",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FCONTRIBUTING.md",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FCONTRIBUTING.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FCONTRIBUTING.md?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -137,7 +137,10 @@ $ git rebase upstream/v1.x  # or upstream/master\n ### TEST\n \n Bug fixes and features should come with tests.  Add your tests in the\n-`test/` directory. Each new test needs to be registered in `test/test-list.h`. If you add a new test file, it needs to be registered in two places:\n+`test/` directory. Each new test needs to be registered in `test/test-list.h`.\n+\n+If you add a new test file, it needs to be registered in three places:\n+- `CMakeLists.txt`: add the file's name to the `uv_test_sources` list.\n - `Makefile.am`: add the file's name to the `test_run_tests_SOURCES` list.\n - `uv.gyp`: add the file's name to the `sources` list in the `run-tests` target.\n "
        },
        {
            "sha": "3569d5d57515641c7b6110160ca0f2365d4f411c",
            "filename": "deps/uv/ChangeLog",
            "status": "modified",
            "additions": 97,
            "deletions": 0,
            "changes": 97,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FChangeLog",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FChangeLog",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FChangeLog?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -1,3 +1,100 @@\n+2018.06.23, Version 1.21.0 (Stable), e4983a9b0c152932f7553ff4a9ff189d2314cdcb\n+\n+Changes since version 1.20.3:\n+\n+* unix,windows: map EFTYPE errno (cjihrig)\n+\n+* win: perform case insensitive PATH= comparison (cjihrig)\n+\n+* win, fs: uv_fs_fchmod support for -A files (Bartosz Sosnowski)\n+\n+* src,lib: fix comments (Tobias Nießen)\n+\n+* win,process: allow child pipe handles to be opened in overlapped mode (Björn\n+  Linse)\n+\n+* src,test: fix idiosyncratic comment style (Bert Belder)\n+\n+* test: fs_fchmod_archive_readonly must return a value (Bert Belder)\n+\n+* win,pipe: fix incorrect error code returned from uv_pipe_write_impl() (Bert\n+  Belder)\n+\n+* win,pipe: properly set uv_write_t.send_handle in uv_write2() (Bert Belder)\n+\n+* test: add vectored uv_write() ping-pong tests (Bert Belder)\n+\n+* win,pipe: support vectored uv_write() calls (Bert Belder)\n+\n+* win,pipe: refactor pipe read cancellation logic (Bert Belder)\n+\n+* test: improve output from IPC test helpers (Bert Belder)\n+\n+* test: add test for IPC deadlock on Windows (\n+\n+* win,pipe: fix IPC pipe deadlock (Bert Belder)\n+\n+* unix: catch some cases of watching fd twice (Ben Noordhuis)\n+\n+* test: use custom timeout for getaddrinfo_fail_sync (Ben Noordhuis)\n+\n+* Revert \"win: add Windows XP support to uv_if_indextoname()\" (Bert Belder)\n+\n+* win,thread: remove fallback uv_cond implementation (Bert Belder)\n+\n+* src,test: s/olny/only (cjihrig)\n+\n+* unix: close signal pipe fds on unload (Ben Noordhuis)\n+\n+* win: allow setting udp socket options before bind (cjihrig)\n+\n+* unix: return UV_ENOTSUP on FICLONE_FORCE failure (cjihrig)\n+\n+* win,pipe: remove unreferenced local variable (Bert Belder)\n+\n+* win,code: remove GetQueuedCompletionStatus-based poller (Bert Belder)\n+\n+* win: remove the remaining dynamic kernel32 imports (Bert Belder)\n+\n+* test: speedup process-title-threadsafe on macOS (cjihrig)\n+\n+* core: move all include files except uv.h to uv/ (Saúl Ibarra Corretgé)\n+\n+* win: move stdint-msvc2008.h to include/uv/ (Ben Noordhuis)\n+\n+* build: fix cygwin install (Ben Noordhuis)\n+\n+* build,win: remove MinGW Makefile (Saúl Ibarra Corretgé)\n+\n+* build: add a cmake build file (Ben Noordhuis)\n+\n+* build: add test suite option to cmake build (Ben Noordhuis)\n+\n+* unix: set errno in uv_fs_copyfile() (cjihrig)\n+\n+* samples: fix inconsistency in parse_opts vs usage (zyxwvu Shi)\n+\n+* linux: handle exclusive POLLHUP with UV_DISCONNECT (Brad King)\n+\n+* include: declare uv_cpu_times_s in higher scope (Peter Johnson)\n+\n+* doc: add uv_fs_fsync() AIX limitations (jBarz)\n+\n+* unix,win: add uv_fs_lchown() (Paolo Greppi)\n+\n+* unix: disable clang variable length array warning (Peter Johnson)\n+\n+* doc: document uv_pipe_t::ipc (Ed Schouten)\n+\n+* doc: undocument uv_req_type's UV_REQ_TYPE_PRIVATE (Ed Schouten)\n+\n+* doc: document UV_*_MAP() macros (Ed Schouten)\n+\n+* win: remove use of min() macro in pipe.c (Peter Johnson)\n+\n+* doc: add jbarz as maintainer (\n+\n+\n 2018.05.08, Version 1.20.3 (Stable), 8cfd67e59195251dff793ee47c185c9d6a8f3818\n \n Changes since version 1.20.2:"
        },
        {
            "sha": "a895780fc118097009ce800dcb0246dff93f4794",
            "filename": "deps/uv/MAINTAINERS.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FMAINTAINERS.md",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FMAINTAINERS.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FMAINTAINERS.md?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -14,6 +14,7 @@ libuv is currently managed by the following individuals:\n   - GPG key: AF2E EA41 EC34 47BF DD86  FED9 D706 3CCE 19B7 E890 (pubkey-indutny)\n * **Imran Iqbal** ([@iWuzHere](https://github.com/iWuzHere))\n   - GPG key: 9DFE AA5F 481B BF77 2D90  03CE D592 4925 2F8E C41A (pubkey-iwuzhere)\n+* **John Barboza** ([@jbarz](https://github.com/jbarz))\n * **Santiago Gimeno** ([@santigimeno](https://github.com/santigimeno))\n   - GPG key: 612F 0EAD 9401 6223 79DF  4402 F28C 3C8D A33C 03BE (pubkey-santigimeno)\n * **Saúl Ibarra Corretgé** ([@saghul](https://github.com/saghul))"
        },
        {
            "sha": "5f07dba23a3b7d716f86210b76985496b76241db",
            "filename": "deps/uv/Makefile.am",
            "status": "modified",
            "additions": 20,
            "deletions": 17,
            "changes": 37,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FMakefile.am",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FMakefile.am",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FMakefile.am?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -17,7 +17,10 @@ ACLOCAL_AMFLAGS = -I m4\n AM_CPPFLAGS = -I$(top_srcdir)/include \\\n               -I$(top_srcdir)/src\n \n-include_HEADERS=include/uv.h include/uv-errno.h include/uv-threadpool.h include/uv-version.h\n+include_HEADERS=include/uv.h\n+\n+uvincludedir = $(includedir)/uv\n+uvinclude_HEADERS=include/uv/errno.h include/uv/threadpool.h include/uv/version.h\n \n CLEANFILES =\n \n@@ -42,7 +45,7 @@ endif\n \n if WINNT\n \n-include_HEADERS += include/uv-win.h include/tree.h\n+uvinclude_HEADERS += include/uv/win.h include/uv/tree.h\n AM_CPPFLAGS += -I$(top_srcdir)/src/win \\\n                -DWIN32_LEAN_AND_MEAN \\\n                -D_WIN32_WINNT=0x0600\n@@ -82,7 +85,7 @@ libuv_la_SOURCES += src/win/async.c \\\n \n else  # WINNT\n \n-include_HEADERS += include/uv-unix.h\n+uvinclude_HEADERS += include/uv/unix.h\n AM_CPPFLAGS += -I$(top_srcdir)/src/unix\n libuv_la_SOURCES += src/unix/async.c \\\n                    src/unix/atomic-ops.h \\\n@@ -121,7 +124,6 @@ EXTRA_DIST = test/fixtures/empty_file \\\n              README.md \\\n              checksparse.sh \\\n              vcbuild.bat \\\n-             Makefile.mingw \\\n              common.gypi \\\n              gyp_uv.py \\\n              uv.gyp\n@@ -191,6 +193,7 @@ test_run_tests_SOURCES = test/blackhole-server.c \\\n                          test/test-idle.c \\\n                          test/test-ip4-addr.c \\\n                          test/test-ip6-addr.c \\\n+                         test/test-ipc-heavy-traffic-deadlock-bug.c \\\n                          test/test-ipc-send-recv.c \\\n                          test/test-ipc.c \\\n                          test/test-list.h \\\n@@ -332,19 +335,19 @@ libuv_la_CFLAGS += -D_ALL_SOURCE \\\n                    -D_LINUX_SOURCE_COMPAT \\\n                    -D_THREAD_SAFE \\\n                    -DHAVE_SYS_AHAFS_EVPRODS_H\n-include_HEADERS += include/uv-aix.h\n+uvinclude_HEADERS += include/uv/aix.h\n libuv_la_SOURCES += src/unix/aix.c src/unix/aix-common.c\n endif\n \n if ANDROID\n-include_HEADERS += include/android-ifaddrs.h \\\n-                   include/pthread-barrier.h\n+uvinclude_HEADERS += include/uv/android-ifaddrs.h \\\n+                   include/uv/pthread-barrier.h\n libuv_la_SOURCES += src/unix/android-ifaddrs.c \\\n                     src/unix/pthread-fixes.c\n endif\n \n if CYGWIN\n-include_HEADERS += include/uv-posix.h\n+uvinclude_HEADERS += include/uv/posix.h\n libuv_la_CFLAGS += -D_GNU_SOURCE\n libuv_la_SOURCES += src/unix/cygwin.c \\\n                     src/unix/bsd-ifaddrs.c \\\n@@ -358,8 +361,8 @@ libuv_la_SOURCES += src/unix/cygwin.c \\\n endif\n \n if DARWIN\n-include_HEADERS += include/uv-darwin.h \\\n-                   include/pthread-barrier.h\n+uvinclude_HEADERS += include/uv/darwin.h \\\n+                   include/uv/pthread-barrier.h\n libuv_la_CFLAGS += -D_DARWIN_USE_64_BIT_INODE=1\n libuv_la_CFLAGS += -D_DARWIN_UNLIMITED_SELECT=1\n libuv_la_SOURCES += src/unix/bsd-ifaddrs.c \\\n@@ -372,7 +375,7 @@ test_run_tests_LDFLAGS += -lutil\n endif\n \n if DRAGONFLY\n-include_HEADERS += include/uv-bsd.h\n+uvinclude_HEADERS += include/uv/bsd.h\n libuv_la_SOURCES += src/unix/bsd-ifaddrs.c \\\n                     src/unix/freebsd.c \\\n                     src/unix/kqueue.c \\\n@@ -381,7 +384,7 @@ test_run_tests_LDFLAGS += -lutil\n endif\n \n if FREEBSD\n-include_HEADERS += include/uv-bsd.h\n+uvinclude_HEADERS += include/uv/bsd.h\n libuv_la_SOURCES += src/unix/bsd-ifaddrs.c \\\n                     src/unix/freebsd.c \\\n                     src/unix/kqueue.c \\\n@@ -390,7 +393,7 @@ test_run_tests_LDFLAGS += -lutil\n endif\n \n if LINUX\n-include_HEADERS += include/uv-linux.h\n+uvinclude_HEADERS += include/uv/linux.h\n libuv_la_CFLAGS += -D_GNU_SOURCE\n libuv_la_SOURCES += src/unix/linux-core.c \\\n                     src/unix/linux-inotify.c \\\n@@ -417,7 +420,7 @@ libuv_la_SOURCES += src/unix/cygwin.c \\\n endif\n \n if NETBSD\n-include_HEADERS += include/uv-bsd.h\n+uvinclude_HEADERS += include/uv/bsd.h\n libuv_la_SOURCES += src/unix/bsd-ifaddrs.c \\\n                     src/unix/kqueue.c \\\n                     src/unix/netbsd.c \\\n@@ -426,7 +429,7 @@ test_run_tests_LDFLAGS += -lutil\n endif\n \n if OPENBSD\n-include_HEADERS += include/uv-bsd.h\n+uvinclude_HEADERS += include/uv/bsd.h\n libuv_la_SOURCES += src/unix/bsd-ifaddrs.c \\\n                     src/unix/kqueue.c \\\n                     src/unix/openbsd.c \\\n@@ -435,14 +438,14 @@ test_run_tests_LDFLAGS += -lutil\n endif\n \n if SUNOS\n-include_HEADERS += include/uv-sunos.h\n+uvinclude_HEADERS += include/uv/sunos.h\n libuv_la_CFLAGS += -D__EXTENSIONS__ -D_XOPEN_SOURCE=500\n libuv_la_SOURCES += src/unix/no-proctitle.c \\\n                     src/unix/sunos.c\n endif\n \n if OS390\n-include_HEADERS += include/pthread-barrier.h\n+uvinclude_HEADERS += include/uv/pthread-barrier.h\n libuv_la_CFLAGS += -D_UNIX03_THREADS \\\n                    -D_UNIX03_SOURCE \\\n                    -D_OPEN_SYS_IF_EXT=1 \\"
        },
        {
            "sha": "3acf9e14a9eab47a7faf3308c8d1ab43f5af98e5",
            "filename": "deps/uv/Makefile.mingw",
            "status": "removed",
            "additions": 0,
            "deletions": 86,
            "changes": 86,
            "blob_url": "https://github.com/nodejs/node/blob/49e5f0a10fc3784b318842b06854b38475fc884b/deps%2Fuv%2FMakefile.mingw",
            "raw_url": "https://github.com/nodejs/node/raw/49e5f0a10fc3784b318842b06854b38475fc884b/deps%2Fuv%2FMakefile.mingw",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FMakefile.mingw?ref=49e5f0a10fc3784b318842b06854b38475fc884b",
            "patch": "@@ -1,86 +0,0 @@\n-# Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>\n-#\n-# Permission to use, copy, modify, and/or distribute this software for any\n-# purpose with or without fee is hereby granted, provided that the above\n-# copyright notice and this permission notice appear in all copies.\n-#\n-# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n-# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n-# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n-# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n-# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n-# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n-# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n-\n-CC ?= gcc\n-\n-CFLAGS += -Wall \\\n-          -Wextra \\\n-          -Wno-unused-parameter \\\n-          -Wstrict-prototypes \\\n-          -Iinclude \\\n-          -Isrc \\\n-          -Isrc/win \\\n-          -DWIN32_LEAN_AND_MEAN \\\n-          -D_WIN32_WINNT=0x0600\n-\n-INCLUDES = include/stdint-msvc2008.h \\\n-           include/tree.h \\\n-           include/uv-errno.h \\\n-           include/uv-threadpool.h \\\n-           include/uv-version.h \\\n-           include/uv-win.h \\\n-           include/uv.h \\\n-           src/heap-inl.h \\\n-           src/queue.h \\\n-           src/uv-common.h \\\n-           src/win/atomicops-inl.h \\\n-           src/win/handle-inl.h \\\n-           src/win/internal.h \\\n-           src/win/req-inl.h \\\n-           src/win/stream-inl.h \\\n-           src/win/winapi.h \\\n-           src/win/winsock.h\n-\n-OBJS = src/fs-poll.o \\\n-       src/inet.o \\\n-       src/threadpool.o \\\n-       src/uv-common.o \\\n-       src/version.o \\\n-       src/win/async.o \\\n-       src/win/core.o \\\n-       src/win/detect-wakeup.o \\\n-       src/win/dl.o \\\n-       src/win/error.o \\\n-       src/win/fs-event.o \\\n-       src/win/fs.o \\\n-       src/win/getaddrinfo.o \\\n-       src/win/getnameinfo.o \\\n-       src/win/handle.o \\\n-       src/win/loop-watcher.o \\\n-       src/win/pipe.o \\\n-       src/win/poll.o \\\n-       src/win/process-stdio.o \\\n-       src/win/process.o \\\n-       src/win/req.o \\\n-       src/win/signal.o \\\n-       src/win/stream.o \\\n-       src/win/tcp.o \\\n-       src/win/thread.o \\\n-       src/win/timer.o \\\n-       src/win/tty.o \\\n-       src/win/udp.o \\\n-       src/win/util.o \\\n-       src/win/winapi.o \\\n-       src/win/winsock.o\n-\n-all: libuv.a\n-\n-clean:\n-\t-$(RM) $(OBJS) libuv.a\n-\n-libuv.a: $(OBJS)\n-\t$(AR) crs $@ $^\n-\n-$(OBJS): %.o : %.c $(INCLUDES)\n-\t$(CC) $(CFLAGS) -c -o $@ $<"
        },
        {
            "sha": "f6e7288dedd80d8e56a5953efec86e557106a877",
            "filename": "deps/uv/README.md",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FREADME.md",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2FREADME.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2FREADME.md?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -169,6 +169,16 @@ $ make check\n $ make install\n ```\n \n+To build with [CMake](https://cmake.org/):\n+\n+```bash\n+$ mkdir -p out/cmake ; cd out/cmake ; cmake -DBUILD_TESTING=ON ../..\n+$ make all test\n+# Or manually:\n+$ ./uv_run_tests    # shared library build\n+$ ./uv_run_tests_a  # static library build\n+```\n+\n To build with GYP, first run:\n \n ```bash"
        },
        {
            "sha": "91f130d4f5893cf058769256f623d550c0f263a1",
            "filename": "deps/uv/checksparse.sh",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fchecksparse.sh",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fchecksparse.sh",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fchecksparse.sh?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -26,8 +26,8 @@ SPARSE_FLAGS=${SPARSE_FLAGS:-\"\n \"}\n \n SOURCES=\"\n-include/tree.h\n-include/uv-unix.h\n+include/uv/tree.h\n+include/uv/unix.h\n include/uv.h\n src/fs-poll.c\n src/inet.c\n@@ -113,6 +113,7 @@ test/test-homedir.c\n test/test-hrtime.c\n test/test-idle.c\n test/test-ip6-addr.c\n+test/test-ipc-heavy-traffic-deadlock-bug.c\n test/test-ipc-send-recv.c\n test/test-ipc.c\n test/test-loop-handles.c\n@@ -195,29 +196,29 @@ OS400)\n Darwin)\n   SPARSE_FLAGS=\"$SPARSE_FLAGS -D__APPLE__=1\"\n   SOURCES=\"$SOURCES\n-           include/uv-bsd.h\n+           include/uv/bsd.h\n            src/unix/darwin.c\n            src/unix/kqueue.c\n            src/unix/fsevents.c\"\n   ;;\n DragonFly)\n   SPARSE_FLAGS=\"$SPARSE_FLAGS -D__DragonFly__=1\"\n   SOURCES=\"$SOURCES\n-           include/uv-bsd.h\n+           include/uv/bsd.h\n            src/unix/kqueue.c\n            src/unix/freebsd.c\"\n   ;;\n FreeBSD)\n   SPARSE_FLAGS=\"$SPARSE_FLAGS -D__FreeBSD__=1\"\n   SOURCES=\"$SOURCES\n-           include/uv-bsd.h\n+           include/uv/bsd.h\n            src/unix/kqueue.c\n            src/unix/freebsd.c\"\n   ;;\n Linux)\n   SPARSE_FLAGS=\"$SPARSE_FLAGS -D__linux__=1\"\n   SOURCES=\"$SOURCES\n-           include/uv-linux.h\n+           include/uv/linux.h\n            src/unix/linux-inotify.c\n            src/unix/linux-core.c\n            src/unix/linux-syscalls.c\n@@ -226,21 +227,21 @@ Linux)\n NetBSD)\n   SPARSE_FLAGS=\"$SPARSE_FLAGS -D__NetBSD__=1\"\n   SOURCES=\"$SOURCES\n-           include/uv-bsd.h\n+           include/uv/bsd.h\n            src/unix/kqueue.c\n            src/unix/netbsd.c\"\n   ;;\n OpenBSD)\n   SPARSE_FLAGS=\"$SPARSE_FLAGS -D__OpenBSD__=1\"\n   SOURCES=\"$SOURCES\n-           include/uv-bsd.h\n+           include/uv/bsd.h\n            src/unix/kqueue.c\n            src/unix/openbsd.c\"\n   ;;\n SunOS)\n   SPARSE_FLAGS=\"$SPARSE_FLAGS -D__sun=1\"\n   SOURCES=\"$SOURCES\n-           include/uv-sunos.h\n+           include/uv/sunos.h\n            src/unix/sunos.c\"\n   ;;\n esac"
        },
        {
            "sha": "c3a6a7796904c8735e2830d7fe29b5b53e5b15c2",
            "filename": "deps/uv/configure.ac",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fconfigure.ac",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fconfigure.ac",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fconfigure.ac?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -13,7 +13,7 @@\n # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n \n AC_PREREQ(2.57)\n-AC_INIT([libuv], [1.20.3], [https://github.com/libuv/libuv/issues])\n+AC_INIT([libuv], [1.21.0], [https://github.com/libuv/libuv/issues])\n AC_CONFIG_MACRO_DIR([m4])\n m4_include([m4/libuv-extra-automake-flags.m4])\n m4_include([m4/as_case.m4])"
        },
        {
            "sha": "f6f43253d364c5ea7787dae23c5ff381c8c2c923",
            "filename": "deps/uv/docs/src/conf.py",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Fconf.py",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Fconf.py",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Fconf.py?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -18,7 +18,7 @@\n \n \n def get_libuv_version():\n-    with open('../../include/uv-version.h') as f:\n+    with open('../../include/uv/version.h') as f:\n         data = f.read()\n     try:\n         m = re.search(r\"\"\"^#define UV_VERSION_MAJOR (\\d+)$\"\"\", data, re.MULTILINE)"
        },
        {
            "sha": "7c3f95d760416fd72d48100e9474a4a67a76a524",
            "filename": "deps/uv/docs/src/errors.rst",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Ferrors.rst",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Ferrors.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Ferrors.rst?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -323,6 +323,13 @@ Error constants\n API\n ---\n \n+.. c:function:: UV_ERRNO_MAP(iter_macro)\n+\n+    Macro that expands to a series of invocations of `iter_macro` for\n+    each of the error constants above. `iter_macro` is invoked with two\n+    arguments: the name of the error constant without the `UV_` prefix,\n+    and the error message string literal.\n+\n .. c:function:: const char* uv_strerror(int err)\n \n     Returns the error message for the given error code.  Leaks a few bytes"
        },
        {
            "sha": "a390f1409d2f26c3daee63fda8857d629dd429b6",
            "filename": "deps/uv/docs/src/fs.rst",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Ffs.rst",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Ffs.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Ffs.rst?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -92,6 +92,7 @@ Data types\n             UV_FS_READLINK,\n             UV_FS_CHOWN,\n             UV_FS_FCHOWN,\n+            UV_FS_LCHOWN,\n             UV_FS_REALPATH,\n             UV_FS_COPYFILE\n         } uv_fs_type;\n@@ -234,6 +235,10 @@ API\n \n     Equivalent to :man:`fsync(2)`.\n \n+    .. note::\n+        For AIX, `uv_fs_fsync` returns `UV_EBADF` on file descriptors referencing\n+        non regular files.\n+\n .. c:function:: int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb)\n \n     Equivalent to :man:`fdatasync(2)`.\n@@ -345,12 +350,15 @@ API\n \n .. c:function:: int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)\n .. c:function:: int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)\n+.. c:function:: int uv_fs_lchown(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb)\n \n-    Equivalent to :man:`chown(2)` and :man:`fchown(2)` respectively.\n+    Equivalent to :man:`chown(2)`, :man:`fchown(2)` and :man:`lchown(2)` respectively.\n \n     .. note::\n         These functions are not implemented on Windows.\n \n+    .. versionchanged:: 1.21.0 implemented uv_fs_lchown\n+\n .. c:function:: uv_fs_type uv_fs_get_type(const uv_fs_t* req)\n \n     Returns `req->fs_type`."
        },
        {
            "sha": "86fa811d3f7eed3d2ceeb8466bd3dcaf623309a9",
            "filename": "deps/uv/docs/src/handle.rst",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Fhandle.rst",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Fhandle.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Fhandle.rst?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -101,6 +101,14 @@ Public members\n API\n ---\n \n+.. c:function:: UV_HANDLE_TYPE_MAP(iter_macro)\n+\n+    Macro that expands to a series of invocations of `iter_macro` for\n+    each of the handle types. `iter_macro` is invoked with two\n+    arguments: the name of the `uv_handle_type` element without the\n+    `UV_` prefix, and the name of the corresponding structure type\n+    without the `uv_` prefix and `_t` suffix.\n+\n .. c:function:: int uv_is_active(const uv_handle_t* handle)\n \n     Returns non-zero if the handle is active, zero if it's inactive. What"
        },
        {
            "sha": "376d6117bbea755243a230fa32ccb82c41dafc23",
            "filename": "deps/uv/docs/src/pipe.rst",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Fpipe.rst",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Fpipe.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Fpipe.rst?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -21,7 +21,9 @@ Data types\n Public members\n ^^^^^^^^^^^^^^\n \n-N/A\n+.. c:member:: int uv_pipe_t.ipc\n+\n+    Whether this pipe is suitable for handle passing between processes.\n \n .. seealso:: The :c:type:`uv_stream_t` members also apply.\n "
        },
        {
            "sha": "bc968554e149f2d49bc81a699775ec0f3ceb5d27",
            "filename": "deps/uv/docs/src/process.rst",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Fprocess.rst",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Fprocess.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Fprocess.rst?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -109,6 +109,11 @@ Data types\n             */\n             UV_READABLE_PIPE = 0x10,\n             UV_WRITABLE_PIPE = 0x20\n+            /*\n+             * Open the child pipe handle in overlapped mode on Windows.\n+             * On Unix it is silently ignored.\n+             */\n+            UV_OVERLAPPED_PIPE = 0x40\n         } uv_stdio_flags;\n \n "
        },
        {
            "sha": "56038287b2ae1184467f631634d1f8325d68ff2e",
            "filename": "deps/uv/docs/src/request.rst",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Frequest.rst",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fdocs%2Fsrc%2Frequest.rst",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fdocs%2Fsrc%2Frequest.rst?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -46,14 +46,21 @@ Public members\n             UV_WORK,\n             UV_GETADDRINFO,\n             UV_GETNAMEINFO,\n-            UV_REQ_TYPE_PRIVATE,\n             UV_REQ_TYPE_MAX,\n         } uv_req_type;\n \n \n API\n ---\n \n+.. c:function:: UV_REQ_TYPE_MAP(iter_macro)\n+\n+    Macro that expands to a series of invocations of `iter_macro` for\n+    each of the request types. `iter_macro` is invoked with two\n+    arguments: the name of the `uv_req_type` element without the `UV_`\n+    prefix, and the name of the corresponding structure type without the\n+    `uv_` prefix and `_t` suffix.\n+\n .. c:function:: int uv_cancel(uv_req_t* req)\n \n     Cancel a pending request. Fails if the request is executing or has finished"
        },
        {
            "sha": "91451ada7885c2d5cca4ec1d099ffcdf703bfda6",
            "filename": "deps/uv/include/uv.h",
            "status": "modified",
            "additions": 30,
            "deletions": 14,
            "changes": 44,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -45,21 +45,21 @@ extern \"C\" {\n # define UV_EXTERN /* nothing */\n #endif\n \n-#include \"uv-errno.h\"\n-#include \"uv-version.h\"\n+#include \"uv/errno.h\"\n+#include \"uv/version.h\"\n #include <stddef.h>\n #include <stdio.h>\n \n #if defined(_MSC_VER) && _MSC_VER < 1600\n-# include \"stdint-msvc2008.h\"\n+# include \"uv/stdint-msvc2008.h\"\n #else\n # include <stdint.h>\n #endif\n \n #if defined(_WIN32)\n-# include \"uv-win.h\"\n+# include \"uv/win.h\"\n #else\n-# include \"uv-unix.h\"\n+# include \"uv/unix.h\"\n #endif\n \n /* Expand this list if necessary. */\n@@ -142,6 +142,7 @@ extern \"C\" {\n   XX(EHOSTDOWN, \"host is down\")                                               \\\n   XX(EREMOTEIO, \"remote I/O error\")                                           \\\n   XX(ENOTTY, \"inappropriate ioctl for device\")                                \\\n+  XX(EFTYPE, \"inappropriate file type or format\")                             \\\n \n #define UV_HANDLE_TYPE_MAP(XX)                                                \\\n   XX(ASYNC, async)                                                            \\\n@@ -503,7 +504,7 @@ UV_EXTERN int uv_try_write(uv_stream_t* handle,\n struct uv_write_s {\n   UV_REQ_FIELDS\n   uv_write_cb cb;\n-  uv_stream_t* send_handle;\n+  uv_stream_t* send_handle; /* TODO: make private and unix-only in v2.x. */\n   uv_stream_t* handle;\n   UV_WRITE_PRIVATE_FIELDS\n };\n@@ -865,7 +866,13 @@ typedef enum {\n    * flags may be specified to create a duplex data stream.\n    */\n   UV_READABLE_PIPE  = 0x10,\n-  UV_WRITABLE_PIPE  = 0x20\n+  UV_WRITABLE_PIPE  = 0x20,\n+\n+  /*\n+   * Open the child pipe handle in overlapped mode on Windows.\n+   * On Unix it is silently ignored.\n+   */\n+  UV_OVERLAPPED_PIPE = 0x40\n } uv_stdio_flags;\n \n typedef struct uv_stdio_container_s {\n@@ -997,16 +1004,18 @@ UV_EXTERN int uv_queue_work(uv_loop_t* loop,\n UV_EXTERN int uv_cancel(uv_req_t* req);\n \n \n+struct uv_cpu_times_s {\n+  uint64_t user;\n+  uint64_t nice;\n+  uint64_t sys;\n+  uint64_t idle;\n+  uint64_t irq;\n+};\n+\n struct uv_cpu_info_s {\n   char* model;\n   int speed;\n-  struct uv_cpu_times_s {\n-    uint64_t user;\n-    uint64_t nice;\n-    uint64_t sys;\n-    uint64_t idle;\n-    uint64_t irq;\n-  } cpu_times;\n+  struct uv_cpu_times_s cpu_times;\n };\n \n struct uv_interface_address_s {\n@@ -1132,6 +1141,7 @@ typedef enum {\n   UV_FS_READLINK,\n   UV_FS_CHOWN,\n   UV_FS_FCHOWN,\n+  UV_FS_LCHOWN,\n   UV_FS_REALPATH,\n   UV_FS_COPYFILE\n } uv_fs_type;\n@@ -1336,6 +1346,12 @@ UV_EXTERN int uv_fs_fchown(uv_loop_t* loop,\n                            uv_uid_t uid,\n                            uv_gid_t gid,\n                            uv_fs_cb cb);\n+UV_EXTERN int uv_fs_lchown(uv_loop_t* loop,\n+                           uv_fs_t* req,\n+                           const char* path,\n+                           uv_uid_t uid,\n+                           uv_gid_t gid,\n+                           uv_fs_cb cb);\n \n \n enum uv_fs_event {"
        },
        {
            "sha": "7dc992fa6d74b5db275847ace8ef9acfd8108c2f",
            "filename": "deps/uv/include/uv/aix.h",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Faix.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Faix.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Faix.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "previous_filename": "deps/uv/include/uv-aix.h"
        },
        {
            "sha": "9cd19fec1294fbc76f1040fa05f0fadbed4c688d",
            "filename": "deps/uv/include/uv/android-ifaddrs.h",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fandroid-ifaddrs.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fandroid-ifaddrs.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fandroid-ifaddrs.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "previous_filename": "deps/uv/include/android-ifaddrs.h"
        },
        {
            "sha": "2d72b3d7711311144aae0fdfe73479b89f2aba2d",
            "filename": "deps/uv/include/uv/bsd.h",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fbsd.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fbsd.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fbsd.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "previous_filename": "deps/uv/include/uv-bsd.h"
        },
        {
            "sha": "d226415820bb6a504f79b74dd7c7e460d4c403f5",
            "filename": "deps/uv/include/uv/darwin.h",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fdarwin.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fdarwin.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fdarwin.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "previous_filename": "deps/uv/include/uv-darwin.h"
        },
        {
            "sha": "8eeb95de31b065788d994ad8bbbaec7f290c6e1d",
            "filename": "deps/uv/include/uv/errno.h",
            "status": "renamed",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Ferrno.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Ferrno.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Ferrno.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -433,5 +433,11 @@\n # define UV__ENOTTY (-4029)\n #endif\n \n+#if defined(EFTYPE) && !defined(_WIN32)\n+# define UV__EFTYPE UV__ERR(EFTYPE)\n+#else\n+# define UV__EFTYPE (-4028)\n+#endif\n+\n \n #endif /* UV_ERRNO_H_ */",
            "previous_filename": "deps/uv/include/uv-errno.h"
        },
        {
            "sha": "9b38405a190d323c92882d92db23ef762a570a96",
            "filename": "deps/uv/include/uv/linux.h",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Flinux.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Flinux.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Flinux.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "previous_filename": "deps/uv/include/uv-linux.h"
        },
        {
            "sha": "0267d74cbd02c93d34c02bbc2750932a7e842898",
            "filename": "deps/uv/include/uv/os390.h",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fos390.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fos390.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fos390.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "previous_filename": "deps/uv/include/uv-os390.h"
        },
        {
            "sha": "9a96634db0e3a585c75905bbbfc49ebe5c63e2df",
            "filename": "deps/uv/include/uv/posix.h",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fposix.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fposix.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fposix.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "previous_filename": "deps/uv/include/uv-posix.h"
        },
        {
            "sha": "07db9b8a6a27e0a6fb88522fdb9eb5eec7522e62",
            "filename": "deps/uv/include/uv/pthread-barrier.h",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fpthread-barrier.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fpthread-barrier.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fpthread-barrier.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "previous_filename": "deps/uv/include/pthread-barrier.h"
        },
        {
            "sha": "d02608a5972642c7b7a13b987f21e2502a5af3ea",
            "filename": "deps/uv/include/uv/stdint-msvc2008.h",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fstdint-msvc2008.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fstdint-msvc2008.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fstdint-msvc2008.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "previous_filename": "deps/uv/include/stdint-msvc2008.h"
        },
        {
            "sha": "042166424e50b7de043fe869bec40cc27ce7d136",
            "filename": "deps/uv/include/uv/sunos.h",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fsunos.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fsunos.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fsunos.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "previous_filename": "deps/uv/include/uv-sunos.h"
        },
        {
            "sha": "9708ebdd5301a9cf1f9da856b4b12b89ef6fd683",
            "filename": "deps/uv/include/uv/threadpool.h",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fthreadpool.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fthreadpool.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fthreadpool.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "previous_filename": "deps/uv/include/uv-threadpool.h"
        },
        {
            "sha": "f936416e3d83131ed638b28aa6b8d04eaa639801",
            "filename": "deps/uv/include/uv/tree.h",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Ftree.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Ftree.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Ftree.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "previous_filename": "deps/uv/include/tree.h"
        },
        {
            "sha": "74a0d643ceec28157150ca82949ae6aedb71045f",
            "filename": "deps/uv/include/uv/unix.h",
            "status": "renamed",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Funix.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Funix.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Funix.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -42,32 +42,32 @@\n #include <pthread.h>\n #include <signal.h>\n \n-#include \"uv-threadpool.h\"\n+#include \"uv/threadpool.h\"\n \n #if defined(__linux__)\n-# include \"uv-linux.h\"\n+# include \"uv/linux.h\"\n #elif defined (__MVS__)\n-# include \"uv-os390.h\"\n+# include \"uv/os390.h\"\n #elif defined(__PASE__)\n-# include \"uv-posix.h\"\n+# include \"uv/posix.h\"\n #elif defined(_AIX)\n-# include \"uv-aix.h\"\n+# include \"uv/aix.h\"\n #elif defined(__sun)\n-# include \"uv-sunos.h\"\n+# include \"uv/sunos.h\"\n #elif defined(__APPLE__)\n-# include \"uv-darwin.h\"\n+# include \"uv/darwin.h\"\n #elif defined(__DragonFly__)       || \\\n       defined(__FreeBSD__)         || \\\n       defined(__FreeBSD_kernel__)  || \\\n       defined(__OpenBSD__)         || \\\n       defined(__NetBSD__)\n-# include \"uv-bsd.h\"\n+# include \"uv/bsd.h\"\n #elif defined(__CYGWIN__) || defined(__MSYS__)\n-# include \"uv-posix.h\"\n+# include \"uv/posix.h\"\n #endif\n \n #ifndef PTHREAD_BARRIER_SERIAL_THREAD\n-# include \"pthread-barrier.h\"\n+# include \"uv/pthread-barrier.h\"\n #endif\n \n #ifndef NI_MAXHOST",
            "previous_filename": "deps/uv/include/uv-unix.h"
        },
        {
            "sha": "0b829717b81ab021cf5c4432384ac6f5f20bf369",
            "filename": "deps/uv/include/uv/version.h",
            "status": "renamed",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fversion.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fversion.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fversion.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -31,8 +31,8 @@\n  */\n \n #define UV_VERSION_MAJOR 1\n-#define UV_VERSION_MINOR 20\n-#define UV_VERSION_PATCH 3\n+#define UV_VERSION_MINOR 21\n+#define UV_VERSION_PATCH 0\n #define UV_VERSION_IS_RELEASE 1\n #define UV_VERSION_SUFFIX \"\"\n ",
            "previous_filename": "deps/uv/include/uv-version.h"
        },
        {
            "sha": "f01335296a05e901a37e212055c5aa78ffa4e2ee",
            "filename": "deps/uv/include/uv/win.h",
            "status": "renamed",
            "additions": 22,
            "deletions": 21,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fwin.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Finclude%2Fuv%2Fwin.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Finclude%2Fuv%2Fwin.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -53,13 +53,13 @@ typedef struct pollfd {\n #include <sys/stat.h>\n \n #if defined(_MSC_VER) && _MSC_VER < 1600\n-# include \"stdint-msvc2008.h\"\n+# include \"uv/stdint-msvc2008.h\"\n #else\n # include <stdint.h>\n #endif\n \n-#include \"tree.h\"\n-#include \"uv-threadpool.h\"\n+#include \"uv/tree.h\"\n+#include \"uv/threadpool.h\"\n \n #define MAX_PIPENAME_LEN 256\n \n@@ -86,8 +86,8 @@ typedef struct pollfd {\n #define SIGKILL               9\n #define SIGWINCH             28\n \n-/* The CRT defines SIGABRT_COMPAT as 6, which equals SIGABRT on many */\n-/* unix-like platforms. However MinGW doesn't define it, so we do. */\n+/* The CRT defines SIGABRT_COMPAT as 6, which equals SIGABRT on many unix-like\n+ * platforms. However MinGW doesn't define it, so we do. */\n #ifndef SIGABRT_COMPAT\n # define SIGABRT_COMPAT       6\n #endif\n@@ -244,7 +244,7 @@ typedef union {\n     CRITICAL_SECTION waiters_count_lock;\n     HANDLE signal_event;\n     HANDLE broadcast_event;\n-  } fallback;\n+  } unused_; /* TODO: retained for ABI compatibility; remove me in v2.x. */\n } uv_cond_t;\n \n typedef union {\n@@ -368,10 +368,10 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n   } u;                                                                        \\\n   struct uv_req_s* next_req;\n \n-#define UV_WRITE_PRIVATE_FIELDS                                               \\\n-  int ipc_header;                                                             \\\n-  uv_buf_t write_buffer;                                                      \\\n-  HANDLE event_handle;                                                        \\\n+#define UV_WRITE_PRIVATE_FIELDS \\\n+  int coalesced;                \\\n+  uv_buf_t write_buffer;        \\\n+  HANDLE event_handle;          \\\n   HANDLE wait_handle;\n \n #define UV_CONNECT_PRIVATE_FIELDS                                             \\\n@@ -459,16 +459,17 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n \n #define uv_pipe_connection_fields                                             \\\n   uv_timer_t* eof_timer;                                                      \\\n-  uv_write_t ipc_header_write_req;                                            \\\n-  int ipc_pid;                                                                \\\n-  uint64_t remaining_ipc_rawdata_bytes;                                       \\\n-  struct {                                                                    \\\n-    void* queue[2];                                                           \\\n-    int queue_len;                                                            \\\n-  } pending_ipc_info;                                                         \\\n+  uv_write_t dummy; /* TODO: retained for ABI compat; remove this in v2.x. */ \\\n+  DWORD ipc_remote_pid;                                                       \\\n+  union {                                                                     \\\n+    uint32_t payload_remaining;                                               \\\n+    uint64_t dummy; /* TODO: retained for ABI compat; remove this in v2.x. */ \\\n+  } ipc_data_frame;                                                           \\\n+  void* ipc_xfer_queue[2];                                                    \\\n+  int ipc_xfer_queue_length;                                                  \\\n   uv_write_t* non_overlapped_writes_tail;                                     \\\n-  uv_mutex_t readfile_mutex;                                                  \\\n-  volatile HANDLE readfile_thread;\n+  CRITICAL_SECTION readfile_thread_lock;                                      \\\n+  volatile HANDLE readfile_thread_handle;\n \n #define UV_PIPE_PRIVATE_FIELDS                                                \\\n   HANDLE handle;                                                              \\\n@@ -478,8 +479,8 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n     struct { uv_pipe_connection_fields } conn;                                \\\n   } pipe;\n \n-/* TODO: put the parser states in an union - TTY handles are always */\n-/* half-duplex so read-state can safely overlap write-state. */\n+/* TODO: put the parser states in an union - TTY handles are always half-duplex\n+ * so read-state can safely overlap write-state. */\n #define UV_TTY_PRIVATE_FIELDS                                                 \\\n   HANDLE handle;                                                              \\\n   union {                                                                     \\",
            "previous_filename": "deps/uv/include/uv-win.h"
        },
        {
            "sha": "1d7b86f751764c56daee46ac1f727fa5c9da79c9",
            "filename": "deps/uv/libuv.pc.in",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Flibuv.pc.in",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Flibuv.pc.in",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Flibuv.pc.in?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -3,7 +3,7 @@ exec_prefix=${prefix}\n libdir=@libdir@\n includedir=@includedir@\n \n-Name: @PACKAGE_NAME@\n+Name: libuv\n Version: @PACKAGE_VERSION@\n Description: multi-platform support library with a focus on asynchronous I/O.\n URL: http://libuv.org/"
        },
        {
            "sha": "e77c7c69078dd6cdfd08468a12c868420fee1a23",
            "filename": "deps/uv/samples/socks5-proxy/main.c",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsamples%2Fsocks5-proxy%2Fmain.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsamples%2Fsocks5-proxy%2Fmain.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsamples%2Fsocks5-proxy%2Fmain.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -63,9 +63,9 @@ const char *_getprogname(void) {\n static void parse_opts(server_config *cf, int argc, char **argv) {\n   int opt;\n \n-  while (-1 != (opt = getopt(argc, argv, \"H:hp:\"))) {\n+  while (-1 != (opt = getopt(argc, argv, \"b:hp:\"))) {\n     switch (opt) {\n-      case 'H':\n+      case 'b':\n         cf->bind_host = optarg;\n         break;\n \n@@ -85,7 +85,7 @@ static void parse_opts(server_config *cf, int argc, char **argv) {\n static void usage(void) {\n   printf(\"Usage:\\n\"\n          \"\\n\"\n-         \"  %s [-b <address> [-h] [-p <port>]\\n\"\n+         \"  %s [-b <address>] [-h] [-p <port>]\\n\"\n          \"\\n\"\n          \"Options:\\n\"\n          \"\\n\""
        },
        {
            "sha": "4598ca1e9f967053350a66a018c19ced8b835bc8",
            "filename": "deps/uv/src/inet.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Finet.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Finet.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Finet.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -19,7 +19,7 @@\n #include <string.h>\n \n #if defined(_MSC_VER) && _MSC_VER < 1600\n-# include \"stdint-msvc2008.h\"\n+# include \"uv/stdint-msvc2008.h\"\n #else\n # include <stdint.h>\n #endif"
        },
        {
            "sha": "99fb25a43b427971b96a57725268238de76a6ab3",
            "filename": "deps/uv/src/unix/android-ifaddrs.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fandroid-ifaddrs.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fandroid-ifaddrs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fandroid-ifaddrs.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -23,7 +23,7 @@ ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n \n-#include \"android-ifaddrs.h\"\n+#include \"uv/android-ifaddrs.h\"\n #include \"uv-common.h\"\n \n #include <string.h>"
        },
        {
            "sha": "c2e7bd730d5d45e62a75610a843f771568046b15",
            "filename": "deps/uv/src/unix/core.c",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fcore.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fcore.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fcore.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -174,8 +174,8 @@ void uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n \n   case UV_SIGNAL:\n     uv__signal_close((uv_signal_t*) handle);\n-    /* Signal handles may not be closed immediately. The signal code will */\n-    /* itself close uv__make_close_pending whenever appropriate. */\n+    /* Signal handles may not be closed immediately. The signal code will\n+     * itself close uv__make_close_pending whenever appropriate. */\n     return;\n \n   default:\n@@ -927,6 +927,11 @@ int uv__io_active(const uv__io_t* w, unsigned int events) {\n }\n \n \n+int uv__fd_exists(uv_loop_t* loop, int fd) {\n+  return (unsigned) fd < loop->nwatchers && loop->watchers[fd] != NULL;\n+}\n+\n+\n int uv_getrusage(uv_rusage_t* rusage) {\n   struct rusage usage;\n "
        },
        {
            "sha": "652cdfd734ac5bafdd7d75553df496349df3aac0",
            "filename": "deps/uv/src/unix/fs.c",
            "status": "modified",
            "additions": 25,
            "deletions": 4,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Ffs.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Ffs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ffs.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -865,9 +865,11 @@ static ssize_t uv__fs_copyfile(uv_fs_t* req) {\n       /* If an error occurred that the sendfile fallback also won't handle, or\n          this is a force clone then exit. Otherwise, fall through to try using\n          sendfile(). */\n-      if ((errno != ENOTTY && errno != EOPNOTSUPP && errno != EXDEV) ||\n-          req->flags & UV_FS_COPYFILE_FICLONE_FORCE) {\n-        err = -errno;\n+      if (errno != ENOTTY && errno != EOPNOTSUPP && errno != EXDEV) {\n+        err = UV__ERR(errno);\n+        goto out;\n+      } else if (req->flags & UV_FS_COPYFILE_FICLONE_FORCE) {\n+        err = UV_ENOTSUP;\n         goto out;\n       }\n     } else {\n@@ -927,7 +929,11 @@ static ssize_t uv__fs_copyfile(uv_fs_t* req) {\n     }\n   }\n \n-  return result;\n+  if (result == 0)\n+    return 0;\n+\n+  errno = UV__ERR(result);\n+  return -1;\n #endif\n }\n \n@@ -1114,6 +1120,7 @@ static void uv__fs_work(struct uv__work* w) {\n     X(COPYFILE, uv__fs_copyfile(req));\n     X(FCHMOD, fchmod(req->file, req->mode));\n     X(FCHOWN, fchown(req->file, req->uid, req->gid));\n+    X(LCHOWN, lchown(req->path, req->uid, req->gid));\n     X(FDATASYNC, uv__fs_fdatasync(req));\n     X(FSTAT, uv__fs_fstat(req->file, &req->statbuf));\n     X(FSYNC, uv__fs_fsync(req));\n@@ -1240,6 +1247,20 @@ int uv_fs_fchown(uv_loop_t* loop,\n }\n \n \n+int uv_fs_lchown(uv_loop_t* loop,\n+                 uv_fs_t* req,\n+                 const char* path,\n+                 uv_uid_t uid,\n+                 uv_gid_t gid,\n+                 uv_fs_cb cb) {\n+  INIT(LCHOWN);\n+  PATH;\n+  req->uid = uid;\n+  req->gid = gid;\n+  POST;\n+}\n+\n+\n int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n   INIT(FDATASYNC);\n   req->file = file;"
        },
        {
            "sha": "b0c5dcadf155f68c7e51916a09e0e1e41643b6ad",
            "filename": "deps/uv/src/unix/internal.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Finternal.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Finternal.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Finternal.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -219,6 +219,7 @@ int uv__io_active(const uv__io_t* w, unsigned int events);\n int uv__io_check_fd(uv_loop_t* loop, int fd);\n void uv__io_poll(uv_loop_t* loop, int timeout); /* in milliseconds or -1 */\n int uv__io_fork(uv_loop_t* loop);\n+int uv__fd_exists(uv_loop_t* loop, int fd);\n \n /* async */\n void uv__async_stop(uv_loop_t* loop);"
        },
        {
            "sha": "930f2da7126a5d80da4e192b7405306307307465",
            "filename": "deps/uv/src/unix/kqueue.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fkqueue.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fkqueue.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fkqueue.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -261,8 +261,8 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {\n       w = loop->watchers[fd];\n \n       if (w == NULL) {\n-        /* File descriptor that we've stopped watching, disarm it. */\n-        /* TODO batch up */\n+        /* File descriptor that we've stopped watching, disarm it.\n+         * TODO: batch up. */\n         struct kevent events[1];\n \n         EV_SET(events + 0, fd, ev->filter, EV_DELETE, 0, 0, 0);"
        },
        {
            "sha": "d09bbcdd6f292bfd037bb2f4b4dc97dfbc9cb457",
            "filename": "deps/uv/src/unix/linux-core.c",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Flinux-core.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Flinux-core.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Flinux-core.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -51,7 +51,7 @@\n \n #ifdef HAVE_IFADDRS_H\n # if defined(__ANDROID__)\n-#  include \"android-ifaddrs.h\"\n+#  include \"uv/android-ifaddrs.h\"\n # else\n #  include <ifaddrs.h>\n # endif\n@@ -388,7 +388,8 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {\n        * free when we switch over to edge-triggered I/O.\n        */\n       if (pe->events == POLLERR || pe->events == POLLHUP)\n-        pe->events |= w->pevents & (POLLIN | POLLOUT | UV__POLLPRI);\n+        pe->events |=\n+          w->pevents & (POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI);\n \n       if (pe->events != 0) {\n         /* Run signal watchers last.  This also affects child process watchers"
        },
        {
            "sha": "7797f842524ed3e5b0000b43e6ae16f6a1fcc0c3",
            "filename": "deps/uv/src/unix/linux-inotify.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Flinux-inotify.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Flinux-inotify.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Flinux-inotify.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -19,7 +19,7 @@\n  */\n \n #include \"uv.h\"\n-#include \"tree.h\"\n+#include \"uv/tree.h\"\n #include \"internal.h\"\n \n #include <stdint.h>"
        },
        {
            "sha": "f990403d40c059ef84c611219a9b45380ad0596a",
            "filename": "deps/uv/src/unix/loop.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Floop.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Floop.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Floop.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -20,7 +20,7 @@\n  */\n \n #include \"uv.h\"\n-#include \"tree.h\"\n+#include \"uv/tree.h\"\n #include \"internal.h\"\n #include \"heap-inl.h\"\n #include <stdlib.h>"
        },
        {
            "sha": "91114db6162f8cb1875d189b6c1eb43e72ca079f",
            "filename": "deps/uv/src/unix/pipe.c",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fpipe.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fpipe.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fpipe.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -134,6 +134,9 @@ void uv__pipe_close(uv_pipe_t* handle) {\n int uv_pipe_open(uv_pipe_t* handle, uv_file fd) {\n   int err;\n \n+  if (uv__fd_exists(handle->loop, fd))\n+    return UV_EEXIST;\n+\n   err = uv__nonblock(fd, 1);\n   if (err)\n     return err;"
        },
        {
            "sha": "3d5022b22e85b6690f3c0a7d01637bc5826e71ae",
            "filename": "deps/uv/src/unix/poll.c",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fpoll.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fpoll.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fpoll.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -68,6 +68,9 @@ static void uv__poll_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd) {\n   int err;\n \n+  if (uv__fd_exists(loop, fd))\n+    return UV_EEXIST;\n+\n   err = uv__io_check_fd(loop, fd);\n   if (err)\n     return err;"
        },
        {
            "sha": "8da08b868024254a4166803172ee32e4c7845048",
            "filename": "deps/uv/src/unix/signal.c",
            "status": "modified",
            "additions": 24,
            "deletions": 15,
            "changes": 39,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fsignal.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fsignal.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fsignal.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -54,8 +54,7 @@ static void uv__signal_unregister_handler(int signum);\n static uv_once_t uv__signal_global_init_guard = UV_ONCE_INIT;\n static struct uv__signal_tree_s uv__signal_tree =\n     RB_INITIALIZER(uv__signal_tree);\n-static int uv__signal_lock_pipefd[2];\n-\n+static int uv__signal_lock_pipefd[2] = { -1, -1 };\n \n RB_GENERATE_STATIC(uv__signal_tree_s,\n                    uv_signal_s, tree_entry,\n@@ -64,7 +63,7 @@ RB_GENERATE_STATIC(uv__signal_tree_s,\n static void uv__signal_global_reinit(void);\n \n static void uv__signal_global_init(void) {\n-  if (!uv__signal_lock_pipefd[0])\n+  if (uv__signal_lock_pipefd[0] == -1)\n     /* pthread_atfork can register before and after handlers, one\n      * for each child. This only registers one for the child. That\n      * state is both persistent and cumulative, so if we keep doing\n@@ -74,27 +73,38 @@ static void uv__signal_global_init(void) {\n     if (pthread_atfork(NULL, NULL, &uv__signal_global_reinit))\n       abort();\n \n-  if (uv__make_pipe(uv__signal_lock_pipefd, 0))\n-    abort();\n-\n-  if (uv__signal_unlock())\n-    abort();\n+  uv__signal_global_reinit();\n }\n \n \n-static void uv__signal_global_reinit(void) {\n+UV_DESTRUCTOR(static void uv__signal_global_fini(void)) {\n   /* We can only use signal-safe functions here.\n    * That includes read/write and close, fortunately.\n    * We do all of this directly here instead of resetting\n    * uv__signal_global_init_guard because\n    * uv__signal_global_once_init is only called from uv_loop_init\n    * and this needs to function in existing loops.\n    */\n-  uv__close(uv__signal_lock_pipefd[0]);\n-  uv__signal_lock_pipefd[0] = -1;\n-  uv__close(uv__signal_lock_pipefd[1]);\n-  uv__signal_lock_pipefd[1] = -1;\n-  uv__signal_global_init();\n+  if (uv__signal_lock_pipefd[0] != -1) {\n+    uv__close(uv__signal_lock_pipefd[0]);\n+    uv__signal_lock_pipefd[0] = -1;\n+  }\n+\n+  if (uv__signal_lock_pipefd[1] != -1) {\n+    uv__close(uv__signal_lock_pipefd[1]);\n+    uv__signal_lock_pipefd[1] = -1;\n+  }\n+}\n+\n+\n+static void uv__signal_global_reinit(void) {\n+  uv__signal_global_fini();\n+\n+  if (uv__make_pipe(uv__signal_lock_pipefd, 0))\n+    abort();\n+\n+  if (uv__signal_unlock())\n+    abort();\n }\n \n \n@@ -103,7 +113,6 @@ void uv__signal_global_once_init(void) {\n }\n \n \n-\n static int uv__signal_lock(void) {\n   int r;\n   char data;"
        },
        {
            "sha": "fb56a06b43e3bee1c183405e9ebe3ece92798c80",
            "filename": "deps/uv/src/unix/stream.c",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fstream.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fstream.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fstream.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -1121,6 +1121,7 @@ static int uv__stream_recv_cmsg(uv_stream_t* stream, struct msghdr* msg) {\n #ifdef __clang__\n # pragma clang diagnostic push\n # pragma clang diagnostic ignored \"-Wgnu-folding-constant\"\n+# pragma clang diagnostic ignored \"-Wvla-extension\"\n #endif\n \n static void uv__read(uv_stream_t* stream) {\n@@ -1311,7 +1312,7 @@ static void uv__stream_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n \n   assert(uv__stream_fd(stream) >= 0);\n \n-  /* Ignore POLLHUP here. Even it it's set, there may still be data to read. */\n+  /* Ignore POLLHUP here. Even if it's set, there may still be data to read. */\n   if (events & (POLLIN | POLLERR | POLLHUP))\n     uv__read(stream);\n "
        },
        {
            "sha": "27a2a6130cba1d733906ad3015141f5b3cb6880f",
            "filename": "deps/uv/src/unix/tcp.c",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Ftcp.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Ftcp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Ftcp.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -263,6 +263,9 @@ int uv__tcp_connect(uv_connect_t* req,\n int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock) {\n   int err;\n \n+  if (uv__fd_exists(handle->loop, sock))\n+    return UV_EEXIST;\n+\n   err = uv__nonblock(sock, 1);\n   if (err)\n     return err;"
        },
        {
            "sha": "15da047a5c5fbc9739eb30704f1c9c0205e5756e",
            "filename": "deps/uv/src/unix/udp.c",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fudp.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Funix%2Fudp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Funix%2Fudp.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -624,6 +624,9 @@ int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {\n   if (handle->io_watcher.fd != -1)\n     return UV_EBUSY;\n \n+  if (uv__fd_exists(handle->loop, sock))\n+    return UV_EEXIST;\n+\n   err = uv__nonblock(sock, 1);\n   if (err)\n     return err;"
        },
        {
            "sha": "85bcbe6c8adeceeabbaaa9931021afa2eacfa854",
            "filename": "deps/uv/src/uv-common.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fuv-common.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fuv-common.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fuv-common.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -32,13 +32,13 @@\n #include <stddef.h>\n \n #if defined(_MSC_VER) && _MSC_VER < 1600\n-# include \"stdint-msvc2008.h\"\n+# include \"uv/stdint-msvc2008.h\"\n #else\n # include <stdint.h>\n #endif\n \n #include \"uv.h\"\n-#include \"tree.h\"\n+#include \"uv/tree.h\"\n #include \"queue.h\"\n \n #if EDOM > 0"
        },
        {
            "sha": "13d3c7b33e48af87e9eaa7fb9fde408767c2c31c",
            "filename": "deps/uv/src/win/async.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fasync.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fasync.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fasync.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -71,8 +71,8 @@ int uv_async_send(uv_async_t* handle) {\n     return -1;\n   }\n \n-  /* The user should make sure never to call uv_async_send to a closing */\n-  /* or closed handle. */\n+  /* The user should make sure never to call uv_async_send to a closing or\n+   * closed handle. */\n   assert(!(handle->flags & UV__HANDLE_CLOSING));\n \n   if (!uv__atomic_exchange_set(&handle->async_sent)) {"
        },
        {
            "sha": "52713cf305feb5bdf2fa6b8acfbf838fdccf4288",
            "filename": "deps/uv/src/win/atomicops-inl.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fatomicops-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fatomicops-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fatomicops-inl.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -29,10 +29,10 @@\n /* Atomic set operation on char */\n #ifdef _MSC_VER /* MSVC */\n \n-/* _InterlockedOr8 is supported by MSVC on x32 and x64. It is  slightly less */\n-/* efficient than InterlockedExchange, but InterlockedExchange8 does not */\n-/* exist, and interlocked operations on larger targets might require the */\n-/* target to be aligned. */\n+/* _InterlockedOr8 is supported by MSVC on x32 and x64. It is slightly less\n+ * efficient than InterlockedExchange, but InterlockedExchange8 does not exist,\n+ * and interlocked operations on larger targets might require the target to be\n+ * aligned. */\n #pragma intrinsic(_InterlockedOr8)\n \n static char INLINE uv__atomic_exchange_set(char volatile* target) {"
        },
        {
            "sha": "d6af282a2999ee22e2308412e741b280474f322f",
            "filename": "deps/uv/src/win/core.c",
            "status": "modified",
            "additions": 8,
            "deletions": 65,
            "changes": 73,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fcore.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fcore.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fcore.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -359,58 +359,7 @@ int uv_backend_timeout(const uv_loop_t* loop) {\n }\n \n \n-static void uv_poll(uv_loop_t* loop, DWORD timeout) {\n-  DWORD bytes;\n-  ULONG_PTR key;\n-  OVERLAPPED* overlapped;\n-  uv_req_t* req;\n-  int repeat;\n-  uint64_t timeout_time;\n-\n-  timeout_time = loop->time + timeout;\n-\n-  for (repeat = 0; ; repeat++) {\n-    GetQueuedCompletionStatus(loop->iocp,\n-                              &bytes,\n-                              &key,\n-                              &overlapped,\n-                              timeout);\n-\n-    if (overlapped) {\n-      /* Package was dequeued */\n-      req = uv_overlapped_to_req(overlapped);\n-      uv_insert_pending_req(loop, req);\n-\n-      /* Some time might have passed waiting for I/O,\n-       * so update the loop time here.\n-       */\n-      uv_update_time(loop);\n-    } else if (GetLastError() != WAIT_TIMEOUT) {\n-      /* Serious error */\n-      uv_fatal_error(GetLastError(), \"GetQueuedCompletionStatus\");\n-    } else if (timeout > 0) {\n-      /* GetQueuedCompletionStatus can occasionally return a little early.\n-       * Make sure that the desired timeout target time is reached.\n-       */\n-      uv_update_time(loop);\n-      if (timeout_time > loop->time) {\n-        timeout = (DWORD)(timeout_time - loop->time);\n-        /* The first call to GetQueuedCompletionStatus should return very\n-         * close to the target time and the second should reach it, but\n-         * this is not stated in the documentation. To make sure a busy\n-         * loop cannot happen, the timeout is increased exponentially\n-         * starting on the third round.\n-         */\n-        timeout += repeat ? (1 << (repeat - 1)) : 0;\n-        continue;\n-      }\n-    }\n-    break;\n-  }\n-}\n-\n-\n-static void uv_poll_ex(uv_loop_t* loop, DWORD timeout) {\n+static void uv__poll(uv_loop_t* loop, DWORD timeout) {\n   BOOL success;\n   uv_req_t* req;\n   OVERLAPPED_ENTRY overlappeds[128];\n@@ -422,12 +371,12 @@ static void uv_poll_ex(uv_loop_t* loop, DWORD timeout) {\n   timeout_time = loop->time + timeout;\n \n   for (repeat = 0; ; repeat++) {\n-    success = pGetQueuedCompletionStatusEx(loop->iocp,\n-                                           overlappeds,\n-                                           ARRAY_SIZE(overlappeds),\n-                                           &count,\n-                                           timeout,\n-                                           FALSE);\n+    success = GetQueuedCompletionStatusEx(loop->iocp,\n+                                          overlappeds,\n+                                          ARRAY_SIZE(overlappeds),\n+                                          &count,\n+                                          timeout,\n+                                          FALSE);\n \n     if (success) {\n       for (i = 0; i < count; i++) {\n@@ -485,12 +434,6 @@ int uv_run(uv_loop_t *loop, uv_run_mode mode) {\n   DWORD timeout;\n   int r;\n   int ran_pending;\n-  void (*poll)(uv_loop_t* loop, DWORD timeout);\n-\n-  if (pGetQueuedCompletionStatusEx)\n-    poll = &uv_poll_ex;\n-  else\n-    poll = &uv_poll;\n \n   r = uv__loop_alive(loop);\n   if (!r)\n@@ -508,7 +451,7 @@ int uv_run(uv_loop_t *loop, uv_run_mode mode) {\n     if ((mode == UV_RUN_ONCE && !ran_pending) || mode == UV_RUN_DEFAULT)\n       timeout = uv_backend_timeout(loop);\n \n-    (*poll)(loop, timeout);\n+    uv__poll(loop, timeout);\n \n     uv_check_invoke(loop);\n     uv_process_endgames(loop);"
        },
        {
            "sha": "24924ba81ef3b251c1cf27a3dbe89003cbb47923",
            "filename": "deps/uv/src/win/error.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Ferror.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Ferror.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ferror.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -46,8 +46,8 @@ void uv_fatal_error(const int errorno, const char* syscall) {\n     errmsg = \"Unknown error\";\n   }\n \n-  /* FormatMessage messages include a newline character already, */\n-  /* so don't add another. */\n+  /* FormatMessage messages include a newline character already, so don't add\n+   * another. */\n   if (syscall) {\n     fprintf(stderr, \"%s: (%d) %s\", syscall, errorno, errmsg);\n   } else {"
        },
        {
            "sha": "71b6a81a0d5a8a5b4b3dc1127fa23f75de2caad3",
            "filename": "deps/uv/src/win/fs.c",
            "status": "modified",
            "additions": 89,
            "deletions": 40,
            "changes": 129,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Ffs.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Ffs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ffs.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -326,12 +326,11 @@ INLINE static int fs__readlink_handle(HANDLE handle, char** target_ptr,\n         reparse_data->SymbolicLinkReparseBuffer.SubstituteNameLength /\n         sizeof(WCHAR);\n \n-    /* Real symlinks can contain pretty much everything, but the only thing */\n-    /* we really care about is undoing the implicit conversion to an NT */\n-    /* namespaced path that CreateSymbolicLink will perform on absolute */\n-    /* paths. If the path is win32-namespaced then the user must have */\n-    /* explicitly made it so, and we better just return the unmodified */\n-    /* reparse data. */\n+    /* Real symlinks can contain pretty much everything, but the only thing we\n+     * really care about is undoing the implicit conversion to an NT namespaced\n+     * path that CreateSymbolicLink will perform on absolute paths. If the path\n+     * is win32-namespaced then the user must have explicitly made it so, and\n+     * we better just return the unmodified reparse data. */\n     if (w_target_len >= 4 &&\n         w_target[0] == L'\\\\' &&\n         w_target[1] == L'?' &&\n@@ -352,8 +351,8 @@ INLINE static int fs__readlink_handle(HANDLE handle, char** target_ptr,\n                  (w_target[5] == L'N' || w_target[5] == L'n') &&\n                  (w_target[6] == L'C' || w_target[6] == L'c') &&\n                  w_target[7] == L'\\\\') {\n-        /* \\??\\UNC\\<server>\\<share>\\ - make sure the final path looks like */\n-        /* \\\\<server>\\<share>\\ */\n+        /* \\??\\UNC\\<server>\\<share>\\ - make sure the final path looks like\n+         * \\\\<server>\\<share>\\ */\n         w_target += 6;\n         w_target[0] = L'\\\\';\n         w_target_len -= 6;\n@@ -368,11 +367,11 @@ INLINE static int fs__readlink_handle(HANDLE handle, char** target_ptr,\n     w_target_len = reparse_data->MountPointReparseBuffer.SubstituteNameLength /\n         sizeof(WCHAR);\n \n-    /* Only treat junctions that look like \\??\\<drive>:\\ as symlink. */\n-    /* Junctions can also be used as mount points, like \\??\\Volume{<guid>}, */\n-    /* but that's confusing for programs since they wouldn't be able to */\n-    /* actually understand such a path when returned by uv_readlink(). */\n-    /* UNC paths are never valid for junctions so we don't care about them. */\n+    /* Only treat junctions that look like \\??\\<drive>:\\ as symlink. Junctions\n+     * can also be used as mount points, like \\??\\Volume{<guid>}, but that's\n+     * confusing for programs since they wouldn't be able to actually\n+     * understand such a path when returned by uv_readlink(). UNC paths are\n+     * never valid for junctions so we don't care about them. */\n     if (!(w_target_len >= 6 &&\n           w_target[0] == L'\\\\' &&\n           w_target[1] == L'?' &&\n@@ -409,8 +408,8 @@ void fs__open(uv_fs_t* req) {\n   int fd, current_umask;\n   int flags = req->fs.info.file_flags;\n \n-  /* Obtain the active umask. umask() never fails and returns the previous */\n-  /* umask. */\n+  /* Obtain the active umask. umask() never fails and returns the previous\n+   * umask. */\n   current_umask = umask(0);\n   umask(current_umask);\n \n@@ -530,8 +529,8 @@ void fs__open(uv_fs_t* req) {\n     DWORD error = GetLastError();\n     if (error == ERROR_FILE_EXISTS && (flags & UV_FS_O_CREAT) &&\n         !(flags & UV_FS_O_EXCL)) {\n-      /* Special case: when ERROR_FILE_EXISTS happens and UV_FS_O_CREAT was */\n-      /* specified, it means the path referred to a directory. */\n+      /* Special case: when ERROR_FILE_EXISTS happens and UV_FS_O_CREAT was\n+       * specified, it means the path referred to a directory. */\n       SET_REQ_UV_ERROR(req, UV_EISDIR, error);\n     } else {\n       SET_REQ_WIN32_ERROR(req, GetLastError());\n@@ -756,9 +755,9 @@ void fs__unlink(uv_fs_t* req) {\n   }\n \n   if (info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n-    /* Do not allow deletion of directories, unless it is a symlink. When */\n-    /* the path refers to a non-symlink directory, report EPERM as mandated */\n-    /* by POSIX.1. */\n+    /* Do not allow deletion of directories, unless it is a symlink. When the\n+     * path refers to a non-symlink directory, report EPERM as mandated by\n+     * POSIX.1. */\n \n     /* Check if it is a reparse point. If it's not, it's a normal directory. */\n     if (!(info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {\n@@ -767,8 +766,8 @@ void fs__unlink(uv_fs_t* req) {\n       return;\n     }\n \n-    /* Read the reparse point and check if it is a valid symlink. */\n-    /* If not, don't unlink. */\n+    /* Read the reparse point and check if it is a valid symlink. If not, don't\n+     * unlink. */\n     if (fs__readlink_handle(handle, NULL, NULL) < 0) {\n       DWORD error = GetLastError();\n       if (error == ERROR_SYMLINK_NOT_SUPPORTED)\n@@ -1490,14 +1489,19 @@ static void fs__chmod(uv_fs_t* req) {\n \n static void fs__fchmod(uv_fs_t* req) {\n   int fd = req->file.fd;\n+  int clear_archive_flag;\n   HANDLE handle;\n   NTSTATUS nt_status;\n   IO_STATUS_BLOCK io_status;\n   FILE_BASIC_INFORMATION file_info;\n \n   VERIFY_FD(fd, req);\n \n-  handle = uv__get_osfhandle(fd);\n+  handle = ReOpenFile(uv__get_osfhandle(fd), FILE_WRITE_ATTRIBUTES, 0, 0);\n+  if (handle == INVALID_HANDLE_VALUE) {\n+    SET_REQ_WIN32_ERROR(req, GetLastError());\n+    return;\n+  }\n \n   nt_status = pNtQueryInformationFile(handle,\n                                       &io_status,\n@@ -1507,7 +1511,27 @@ static void fs__fchmod(uv_fs_t* req) {\n \n   if (!NT_SUCCESS(nt_status)) {\n     SET_REQ_WIN32_ERROR(req, pRtlNtStatusToDosError(nt_status));\n-    return;\n+    goto fchmod_cleanup;\n+  }\n+ \n+  /* Test if the Archive attribute is cleared */\n+  if ((file_info.FileAttributes & FILE_ATTRIBUTE_ARCHIVE) == 0) {\n+      /* Set Archive flag, otherwise setting or clearing the read-only \n+         flag will not work */\n+      file_info.FileAttributes |= FILE_ATTRIBUTE_ARCHIVE;\n+      nt_status = pNtSetInformationFile(handle,\n+                                        &io_status,\n+                                        &file_info,\n+                                        sizeof file_info,\n+                                        FileBasicInformation);\n+      if (!NT_SUCCESS(nt_status)) {\n+        SET_REQ_WIN32_ERROR(req, pRtlNtStatusToDosError(nt_status));\n+        goto fchmod_cleanup;\n+      }\n+      /* Remeber to clear the flag later on */\n+      clear_archive_flag = 1;\n+  } else {\n+      clear_archive_flag = 0;\n   }\n \n   if (req->fs.info.mode & _S_IWRITE) {\n@@ -1524,10 +1548,28 @@ static void fs__fchmod(uv_fs_t* req) {\n \n   if (!NT_SUCCESS(nt_status)) {\n     SET_REQ_WIN32_ERROR(req, pRtlNtStatusToDosError(nt_status));\n-    return;\n+    goto fchmod_cleanup;\n+  }\n+\n+  if (clear_archive_flag) {\n+      file_info.FileAttributes &= ~FILE_ATTRIBUTE_ARCHIVE;\n+      if (file_info.FileAttributes == 0) {\n+          file_info.FileAttributes = FILE_ATTRIBUTE_NORMAL;\n+      }\n+      nt_status = pNtSetInformationFile(handle,\n+                                        &io_status,\n+                                        &file_info,\n+                                        sizeof file_info,\n+                                        FileBasicInformation);\n+      if (!NT_SUCCESS(nt_status)) {\n+        SET_REQ_WIN32_ERROR(req, pRtlNtStatusToDosError(nt_status));\n+        goto fchmod_cleanup;\n+      }\n   }\n \n   SET_REQ_SUCCESS(req);\n+fchmod_cleanup:\n+  CloseHandle(handle);\n }\n \n \n@@ -1787,17 +1829,13 @@ static void fs__symlink(uv_fs_t* req) {\n     fs__create_junction(req, pathw, new_pathw);\n     return;\n   }\n-  if (!pCreateSymbolicLinkW) {\n-    SET_REQ_UV_ERROR(req, UV_ENOSYS, ERROR_NOT_SUPPORTED);\n-    return;\n-  }\n \n   if (req->fs.info.file_flags & UV_FS_SYMLINK_DIR)\n     flags = SYMBOLIC_LINK_FLAG_DIRECTORY | uv__file_symlink_usermode_flag;\n   else\n     flags = uv__file_symlink_usermode_flag;\n \n-  if (pCreateSymbolicLinkW(new_pathw, pathw, flags)) {\n+  if (CreateSymbolicLinkW(new_pathw, pathw, flags)) {\n     SET_REQ_RESULT(req, 0);\n     return;\n   }\n@@ -1854,7 +1892,7 @@ static size_t fs__realpath_handle(HANDLE handle, char** realpath_ptr) {\n   WCHAR* w_realpath_ptr = NULL;\n   WCHAR* w_realpath_buf;\n \n-  w_realpath_len = pGetFinalPathNameByHandleW(handle, NULL, 0, VOLUME_NAME_DOS);\n+  w_realpath_len = GetFinalPathNameByHandleW(handle, NULL, 0, VOLUME_NAME_DOS);\n   if (w_realpath_len == 0) {\n     return -1;\n   }\n@@ -1866,10 +1904,8 @@ static size_t fs__realpath_handle(HANDLE handle, char** realpath_ptr) {\n   }\n   w_realpath_ptr = w_realpath_buf;\n \n-  if (pGetFinalPathNameByHandleW(handle,\n-                                w_realpath_ptr,\n-                                w_realpath_len,\n-                                VOLUME_NAME_DOS) == 0) {\n+  if (GetFinalPathNameByHandleW(\n+          handle, w_realpath_ptr, w_realpath_len, VOLUME_NAME_DOS) == 0) {\n     uv__free(w_realpath_buf);\n     SetLastError(ERROR_INVALID_HANDLE);\n     return -1;\n@@ -1901,11 +1937,6 @@ static size_t fs__realpath_handle(HANDLE handle, char** realpath_ptr) {\n static void fs__realpath(uv_fs_t* req) {\n   HANDLE handle;\n \n-  if (!pGetFinalPathNameByHandleW) {\n-    SET_REQ_UV_ERROR(req, UV_ENOSYS, ERROR_NOT_SUPPORTED);\n-    return;\n-  }\n-\n   handle = CreateFileW(req->file.pathw,\n                        0,\n                        0,\n@@ -1940,6 +1971,10 @@ static void fs__fchown(uv_fs_t* req) {\n }\n \n \n+static void fs__lchown(uv_fs_t* req) {\n+  req->result = 0;\n+}\n+\n static void uv__fs_work(struct uv__work* w) {\n   uv_fs_t* req;\n \n@@ -1977,6 +2012,7 @@ static void uv__fs_work(struct uv__work* w) {\n     XX(REALPATH, realpath)\n     XX(CHOWN, chown)\n     XX(FCHOWN, fchown);\n+    XX(LCHOWN, lchown);\n     default:\n       assert(!\"bad uv_fs_type\");\n   }\n@@ -2262,6 +2298,19 @@ int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_uid_t uid,\n }\n \n \n+int uv_fs_lchown(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_uid_t uid,\n+    uv_gid_t gid, uv_fs_cb cb) {\n+  int err;\n+\n+  INIT(UV_FS_LCHOWN);\n+  err = fs__capture_path(req, path, NULL, cb != NULL);\n+  if (err) {\n+    return uv_translate_sys_error(err);\n+  }\n+  POST;\n+}\n+\n+\n int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n   int err;\n "
        },
        {
            "sha": "063b4937cdad24f07f7ab34690e63a78d6fb1427",
            "filename": "deps/uv/src/win/getaddrinfo.c",
            "status": "modified",
            "additions": 9,
            "deletions": 16,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fgetaddrinfo.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fgetaddrinfo.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fgetaddrinfo.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -71,8 +71,8 @@ int uv__getaddrinfo_translate_error(int sys_err) {\n #endif\n \n \n-/* adjust size value to be multiple of 4. Use to keep pointer aligned */\n-/* Do we need different versions of this for different architectures? */\n+/* Adjust size value to be multiple of 4. Use to keep pointer aligned.\n+ * Do we need different versions of this for different architectures? */\n #define ALIGNED_SIZE(X)     ((((X) + 3) >> 2) << 2)\n \n #ifndef NDIS_IF_MAX_STRING_SIZE\n@@ -124,8 +124,7 @@ static void uv__getaddrinfo_done(struct uv__work* w, int status) {\n   }\n \n   if (req->retcode == 0) {\n-    /* convert addrinfoW to addrinfo */\n-    /* first calculate required length */\n+    /* Convert addrinfoW to addrinfo. First calculate required length. */\n     addrinfow_ptr = req->addrinfow;\n     while (addrinfow_ptr != NULL) {\n       addrinfo_len += addrinfo_struct_len +\n@@ -313,8 +312,8 @@ int uv_getaddrinfo(uv_loop_t* loop,\n   /* save alloc_ptr now so we can free if error */\n   req->alloc = (void*)alloc_ptr;\n \n-  /* convert node string to UTF16 into allocated memory and save pointer in */\n-  /* the request. */\n+  /* Convert node string to UTF16 into allocated memory and save pointer in the\n+   * request. */\n   if (node != NULL) {\n     req->node = (WCHAR*)alloc_ptr;\n     if (MultiByteToWideChar(CP_UTF8,\n@@ -331,8 +330,8 @@ int uv_getaddrinfo(uv_loop_t* loop,\n     req->node = NULL;\n   }\n \n-  /* convert service string to UTF16 into allocated memory and save pointer */\n-  /* in the req. */\n+  /* Convert service string to UTF16 into allocated memory and save pointer in\n+   * the req. */\n   if (service != NULL) {\n     req->service = (WCHAR*)alloc_ptr;\n     if (MultiByteToWideChar(CP_UTF8,\n@@ -392,21 +391,15 @@ int uv_if_indextoname(unsigned int ifindex, char* buffer, size_t* size) {\n   DWORD bufsize;\n   int r;\n \n-  uv__once_init();\n-\n   if (buffer == NULL || size == NULL || *size == 0)\n     return UV_EINVAL;\n \n-  if (pConvertInterfaceIndexToLuid == NULL)\n-    return UV_ENOSYS;\n-  r = pConvertInterfaceIndexToLuid(ifindex, &luid);\n+  r = ConvertInterfaceIndexToLuid(ifindex, &luid);\n \n   if (r != 0)\n     return uv_translate_sys_error(r);\n \n-  if (pConvertInterfaceLuidToNameW == NULL)\n-    return UV_ENOSYS;\n-  r = pConvertInterfaceLuidToNameW(&luid, wname, ARRAY_SIZE(wname));\n+  r = ConvertInterfaceLuidToNameW(&luid, wname, ARRAY_SIZE(wname));\n \n   if (r != 0)\n     return uv_translate_sys_error(r);"
        },
        {
            "sha": "ed843072dfc0269a1bafa8403f7a17c4d05b72ad",
            "filename": "deps/uv/src/win/handle-inl.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fhandle-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fhandle-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fhandle-inl.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -164,10 +164,10 @@ INLINE static void uv_process_endgames(uv_loop_t* loop) {\n \n INLINE static HANDLE uv__get_osfhandle(int fd)\n {\n-  /* _get_osfhandle() raises an assert in debug builds if the FD is invalid. */\n-  /* But  it also correctly checks the FD and returns INVALID_HANDLE_VALUE */\n-  /* for invalid FDs in release builds (or if you let the assert continue).  */\n-  /* So this wrapper function disables asserts when calling _get_osfhandle. */\n+  /* _get_osfhandle() raises an assert in debug builds if the FD is invalid.\n+   * But it also correctly checks the FD and returns INVALID_HANDLE_VALUE for\n+   * invalid FDs in release builds (or if you let the assert continue). So this\n+   * wrapper function disables asserts when calling _get_osfhandle. */\n \n   HANDLE handle;\n   UV_BEGIN_DISABLE_CRT_ASSERT();"
        },
        {
            "sha": "fa926d9a44986e0e417f518ae12c604cacb21b4e",
            "filename": "deps/uv/src/win/internal.h",
            "status": "modified",
            "additions": 16,
            "deletions": 18,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Finternal.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Finternal.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Finternal.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -25,7 +25,7 @@\n #include \"uv.h\"\n #include \"../uv-common.h\"\n \n-#include \"tree.h\"\n+#include \"uv/tree.h\"\n #include \"winapi.h\"\n #include \"winsock.h\"\n \n@@ -99,7 +99,6 @@ extern UV_THREAD_LOCAL int uv__crt_assert_enabled;\n /* Only used by uv_pipe_t handles. */\n #define UV_HANDLE_NON_OVERLAPPED_PIPE           0x01000000\n #define UV_HANDLE_PIPESERVER                    0x02000000\n-#define UV_HANDLE_PIPE_READ_CANCELABLE          0x04000000\n \n /* Only used by uv_tty_t handles. */\n #define UV_HANDLE_TTY_READABLE                  0x01000000\n@@ -127,8 +126,9 @@ extern UV_THREAD_LOCAL int uv__crt_assert_enabled;\n \n typedef struct {\n   WSAPROTOCOL_INFOW socket_info;\n-  int delayed_error;\n-} uv__ipc_socket_info_ex;\n+  uint32_t delayed_error;\n+  uint32_t flags; /* Either zero or UV_HANDLE_CONNECTION. */\n+} uv__ipc_socket_xfer_info_t;\n \n int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb);\n int uv_tcp_accept(uv_tcp_t* server, uv_tcp_t* client);\n@@ -150,11 +150,10 @@ void uv_process_tcp_connect_req(uv_loop_t* loop, uv_tcp_t* handle,\n void uv_tcp_close(uv_loop_t* loop, uv_tcp_t* tcp);\n void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle);\n \n-int uv_tcp_import(uv_tcp_t* tcp, uv__ipc_socket_info_ex* socket_info_ex,\n-    int tcp_connection);\n-\n-int uv_tcp_duplicate_socket(uv_tcp_t* handle, int pid,\n-    LPWSAPROTOCOL_INFOW protocol_info);\n+int uv__tcp_xfer_export(uv_tcp_t* handle,\n+                        int pid,\n+                        uv__ipc_socket_xfer_info_t* xfer_info);\n+int uv__tcp_xfer_import(uv_tcp_t* tcp, uv__ipc_socket_xfer_info_t* xfer_info);\n \n \n /*\n@@ -178,14 +177,14 @@ int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb);\n int uv_pipe_accept(uv_pipe_t* server, uv_stream_t* client);\n int uv_pipe_read_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,\n     uv_read_cb read_cb);\n-int uv_pipe_write(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,\n-    const uv_buf_t bufs[], unsigned int nbufs, uv_write_cb cb);\n-int uv_pipe_write2(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,\n-    const uv_buf_t bufs[], unsigned int nbufs, uv_stream_t* send_handle,\n-    uv_write_cb cb);\n-void uv__pipe_pause_read(uv_pipe_t* handle);\n-void uv__pipe_unpause_read(uv_pipe_t* handle);\n-void uv__pipe_stop_read(uv_pipe_t* handle);\n+void uv__pipe_read_stop(uv_pipe_t* handle);\n+int uv__pipe_write(uv_loop_t* loop,\n+                   uv_write_t* req,\n+                   uv_pipe_t* handle,\n+                   const uv_buf_t bufs[],\n+                   size_t nbufs,\n+                   uv_stream_t* send_handle,\n+                   uv_write_cb cb);\n \n void uv_process_pipe_read_req(uv_loop_t* loop, uv_pipe_t* handle,\n     uv_req_t* req);\n@@ -332,7 +331,6 @@ void uv__fs_poll_endgame(uv_loop_t* loop, uv_fs_poll_t* handle);\n void uv__util_init(void);\n \n uint64_t uv__hrtime(double scale);\n-int uv_current_pid(void);\n __declspec(noreturn) void uv_fatal_error(const int errorno, const char* syscall);\n int uv__getpwuid_r(uv_passwd_t* pwd);\n int uv__convert_utf16_to_utf8(const WCHAR* utf16, int utf16len, char** utf8);"
        },
        {
            "sha": "ae569326dd00041acadaa7d0789b6d1cf2472273",
            "filename": "deps/uv/src/win/pipe.c",
            "status": "modified",
            "additions": 586,
            "deletions": 472,
            "changes": 1058,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fpipe.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -21,9 +21,10 @@\n \n #include <assert.h>\n #include <io.h>\n-#include <string.h>\n+#include <stdbool.h>\n #include <stdio.h>\n #include <stdlib.h>\n+#include <string.h>\n \n #include \"uv.h\"\n #include \"internal.h\"\n@@ -34,26 +35,14 @@\n #include <aclapi.h>\n #include <accctrl.h>\n \n-typedef struct uv__ipc_queue_item_s uv__ipc_queue_item_t;\n-\n-struct uv__ipc_queue_item_s {\n-  /*\n-   * NOTE: It is important for socket_info_ex to be the first field,\n-   * because we will we assigning it to the pending_ipc_info.socket_info\n-   */\n-  uv__ipc_socket_info_ex socket_info_ex;\n-  QUEUE member;\n-  int tcp_connection;\n-};\n-\n /* A zero-size buffer for use by uv_pipe_read */\n static char uv_zero_[] = \"\";\n \n /* Null uv_buf_t */\n static const uv_buf_t uv_null_buf_ = { 0, NULL };\n \n-/* The timeout that the pipe will wait for the remote end to write data */\n-/* when the local ends wants to shut it down. */\n+/* The timeout that the pipe will wait for the remote end to write data when\n+ * the local ends wants to shut it down. */\n static const int64_t eof_timeout = 50; /* ms */\n \n static const int default_pending_pipe_instances = 4;\n@@ -62,22 +51,27 @@ static const int default_pending_pipe_instances = 4;\n static char pipe_prefix[] = \"\\\\\\\\?\\\\pipe\";\n static const int pipe_prefix_len = sizeof(pipe_prefix) - 1;\n \n-/* IPC protocol flags. */\n-#define UV_IPC_RAW_DATA       0x0001\n-#define UV_IPC_TCP_SERVER     0x0002\n-#define UV_IPC_TCP_CONNECTION 0x0004\n+/* IPC incoming xfer queue item. */\n+typedef struct {\n+  uv__ipc_socket_xfer_info_t xfer_info;\n+  QUEUE member;\n+} uv__ipc_xfer_queue_item_t;\n+\n+/* IPC frame types. */\n+enum { UV__IPC_DATA_FRAME = 0, UV__IPC_XFER_FRAME = 1 };\n \n /* IPC frame header. */\n typedef struct {\n-  int flags;\n-  uint64_t raw_data_length;\n-} uv_ipc_frame_header_t;\n+  uint32_t type;\n+  uint32_t payload_length;\n+} uv__ipc_frame_header_t;\n \n-/* IPC frame, which contains an imported TCP socket stream. */\n+/* Coalesced write request. */\n typedef struct {\n-  uv_ipc_frame_header_t header;\n-  uv__ipc_socket_info_ex socket_info_ex;\n-} uv_ipc_frame_uv_stream;\n+  uv_write_t req;       /* Internal heap-allocated write request. */\n+  uv_write_t* user_req; /* Pointer to user-specified uv_write_t. */\n+} uv__coalesced_write_t;\n+\n \n static void eof_timer_init(uv_pipe_t* pipe);\n static void eof_timer_start(uv_pipe_t* pipe);\n@@ -98,15 +92,12 @@ int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int ipc) {\n   handle->reqs_pending = 0;\n   handle->handle = INVALID_HANDLE_VALUE;\n   handle->name = NULL;\n-  handle->pipe.conn.ipc_pid = 0;\n-  handle->pipe.conn.remaining_ipc_rawdata_bytes = 0;\n-  QUEUE_INIT(&handle->pipe.conn.pending_ipc_info.queue);\n-  handle->pipe.conn.pending_ipc_info.queue_len = 0;\n+  handle->pipe.conn.ipc_remote_pid = 0;\n+  handle->pipe.conn.ipc_data_frame.payload_remaining = 0;\n+  QUEUE_INIT(&handle->pipe.conn.ipc_xfer_queue);\n+  handle->pipe.conn.ipc_xfer_queue_length = 0;\n   handle->ipc = ipc;\n   handle->pipe.conn.non_overlapped_writes_tail = NULL;\n-  handle->pipe.conn.readfile_thread = NULL;\n-\n-  UV_REQ_INIT(&handle->pipe.conn.ipc_header_write_req, UV_UNKNOWN_REQ);\n \n   return 0;\n }\n@@ -117,10 +108,9 @@ static void uv_pipe_connection_init(uv_pipe_t* handle) {\n   handle->read_req.data = handle;\n   handle->pipe.conn.eof_timer = NULL;\n   assert(!(handle->flags & UV_HANDLE_PIPESERVER));\n-  if (pCancelSynchronousIo &&\n-      handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {\n-      uv_mutex_init(&handle->pipe.conn.readfile_mutex);\n-      handle->flags |= UV_HANDLE_PIPE_READ_CANCELABLE;\n+  if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {\n+    handle->pipe.conn.readfile_thread_handle = NULL;\n+    InitializeCriticalSection(&handle->pipe.conn.readfile_thread_lock);\n   }\n }\n \n@@ -347,12 +337,7 @@ void uv_pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle) {\n   NTSTATUS nt_status;\n   IO_STATUS_BLOCK io_status;\n   FILE_PIPE_LOCAL_INFORMATION pipe_info;\n-  uv__ipc_queue_item_t* item;\n-\n-  if (handle->flags & UV_HANDLE_PIPE_READ_CANCELABLE) {\n-    handle->flags &= ~UV_HANDLE_PIPE_READ_CANCELABLE;\n-    uv_mutex_destroy(&handle->pipe.conn.readfile_mutex);\n-  }\n+  uv__ipc_xfer_queue_item_t* xfer_queue_item;\n \n   if ((handle->flags & UV_HANDLE_CONNECTION) &&\n       handle->stream.conn.shutdown_req != NULL &&\n@@ -429,27 +414,27 @@ void uv_pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle) {\n \n     if (handle->flags & UV_HANDLE_CONNECTION) {\n       /* Free pending sockets */\n-      while (!QUEUE_EMPTY(&handle->pipe.conn.pending_ipc_info.queue)) {\n+      while (!QUEUE_EMPTY(&handle->pipe.conn.ipc_xfer_queue)) {\n         QUEUE* q;\n         SOCKET socket;\n \n-        q = QUEUE_HEAD(&handle->pipe.conn.pending_ipc_info.queue);\n+        q = QUEUE_HEAD(&handle->pipe.conn.ipc_xfer_queue);\n         QUEUE_REMOVE(q);\n-        item = QUEUE_DATA(q, uv__ipc_queue_item_t, member);\n+        xfer_queue_item = QUEUE_DATA(q, uv__ipc_xfer_queue_item_t, member);\n \n         /* Materialize socket and close it */\n         socket = WSASocketW(FROM_PROTOCOL_INFO,\n                             FROM_PROTOCOL_INFO,\n                             FROM_PROTOCOL_INFO,\n-                            &item->socket_info_ex.socket_info,\n+                            &xfer_queue_item->xfer_info.socket_info,\n                             0,\n                             WSA_FLAG_OVERLAPPED);\n-        uv__free(item);\n+        uv__free(xfer_queue_item);\n \n         if (socket != INVALID_SOCKET)\n           closesocket(socket);\n       }\n-      handle->pipe.conn.pending_ipc_info.queue_len = 0;\n+      handle->pipe.conn.ipc_xfer_queue_length = 0;\n \n       if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n         if (handle->read_req.wait_handle != INVALID_HANDLE_VALUE) {\n@@ -461,6 +446,9 @@ void uv_pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle) {\n           handle->read_req.event_handle = NULL;\n         }\n       }\n+\n+      if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE)\n+        DeleteCriticalSection(&handle->pipe.conn.readfile_thread_lock);\n     }\n \n     if (handle->flags & UV_HANDLE_PIPESERVER) {\n@@ -595,8 +583,8 @@ static DWORD WINAPI pipe_connect_thread_proc(void* parameter) {\n   loop = handle->loop;\n   assert(loop);\n \n-  /* We're here because CreateFile on a pipe returned ERROR_PIPE_BUSY. */\n-  /* We wait for the pipe to become available with WaitNamedPipe. */\n+  /* We're here because CreateFile on a pipe returned ERROR_PIPE_BUSY. We wait\n+   * for the pipe to become available with WaitNamedPipe. */\n   while (WaitNamedPipeW(handle->name, 30000)) {\n     /* The pipe is now available, try to connect. */\n     pipeHandle = open_named_pipe(handle->name, &duplex_flags);\n@@ -706,55 +694,68 @@ void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,\n }\n \n \n-void uv__pipe_pause_read(uv_pipe_t* handle) {\n-  if (handle->flags & UV_HANDLE_PIPE_READ_CANCELABLE) {\n-      /* Pause the ReadFile task briefly, to work\n-         around the Windows kernel bug that causes\n-         any access to a NamedPipe to deadlock if\n-         any process has called ReadFile */\n-      HANDLE h;\n-      uv_mutex_lock(&handle->pipe.conn.readfile_mutex);\n-      h = handle->pipe.conn.readfile_thread;\n-      while (h) {\n-        /* spinlock: we expect this to finish quickly,\n-           or we are probably about to deadlock anyways\n-           (in the kernel), so it doesn't matter */\n-        pCancelSynchronousIo(h);\n-        SwitchToThread(); /* yield thread control briefly */\n-        h = handle->pipe.conn.readfile_thread;\n-      }\n-  }\n-}\n+void uv__pipe_interrupt_read(uv_pipe_t* handle) {\n+  BOOL r;\n+\n+  if (!(handle->flags & UV_HANDLE_READ_PENDING))\n+    return; /* No pending reads. */\n+  if (handle->flags & UV_HANDLE_CANCELLATION_PENDING)\n+    return; /* Already cancelled. */\n+  if (handle->handle == INVALID_HANDLE_VALUE)\n+    return; /* Pipe handle closed. */\n+\n+  if (!(handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE)) {\n+    /* Cancel asynchronous read. */\n+    r = CancelIoEx(handle->handle, &handle->read_req.u.io.overlapped);\n+    assert(r || GetLastError() == ERROR_NOT_FOUND);\n \n+  } else {\n+    /* Cancel synchronous read (which is happening in the thread pool). */\n+    HANDLE thread;\n+    volatile HANDLE* thread_ptr = &handle->pipe.conn.readfile_thread_handle;\n+\n+    EnterCriticalSection(&handle->pipe.conn.readfile_thread_lock);\n+\n+    thread = *thread_ptr;\n+    if (thread == NULL) {\n+      /* The thread pool thread has not yet reached the point of blocking, we\n+       * can pre-empt it by setting thread_handle to INVALID_HANDLE_VALUE. */\n+      *thread_ptr = INVALID_HANDLE_VALUE;\n+\n+    } else {\n+      /* Spin until the thread has acknowledged (by setting the thread to\n+       * INVALID_HANDLE_VALUE) that it is past the point of blocking. */\n+      while (thread != INVALID_HANDLE_VALUE) {\n+        r = CancelSynchronousIo(thread);\n+        assert(r || GetLastError() == ERROR_NOT_FOUND);\n+        SwitchToThread(); /* Yield thread. */\n+        thread = *thread_ptr;\n+      }\n+    }\n \n-void uv__pipe_unpause_read(uv_pipe_t* handle) {\n-  if (handle->flags & UV_HANDLE_PIPE_READ_CANCELABLE) {\n-    uv_mutex_unlock(&handle->pipe.conn.readfile_mutex);\n+    LeaveCriticalSection(&handle->pipe.conn.readfile_thread_lock);\n   }\n+\n+  /* Set flag to indicate that read has been cancelled. */\n+  handle->flags |= UV_HANDLE_CANCELLATION_PENDING;\n }\n \n \n-void uv__pipe_stop_read(uv_pipe_t* handle) {\n-  if (pCancelIoEx &&\n-      !(handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) &&\n-      !(handle->flags & UV_HANDLE_EMULATE_IOCP) &&\n-      handle->flags & UV_HANDLE_READING &&\n-      handle->read_req.type == UV_READ) {\n-    pCancelIoEx(handle->handle, &handle->read_req.u.io.overlapped);\n-  }\n+void uv__pipe_read_stop(uv_pipe_t* handle) {\n   handle->flags &= ~UV_HANDLE_READING;\n-  uv__pipe_pause_read((uv_pipe_t*)handle);\n-  uv__pipe_unpause_read((uv_pipe_t*)handle);\n+  DECREASE_ACTIVE_COUNT(handle->loop, handle);\n+\n+  uv__pipe_interrupt_read(handle);\n }\n \n \n-/* Cleans up uv_pipe_t (server or connection) and all resources associated */\n-/* with it. */\n+/* Cleans up uv_pipe_t (server or connection) and all resources associated with\n+ * it. */\n void uv_pipe_cleanup(uv_loop_t* loop, uv_pipe_t* handle) {\n   int i;\n   HANDLE pipeHandle;\n \n-  uv__pipe_stop_read(handle);\n+  uv__pipe_interrupt_read(handle);\n \n   if (handle->name) {\n     uv__free(handle->name);\n@@ -864,23 +865,21 @@ int uv_pipe_accept(uv_pipe_t* server, uv_stream_t* client) {\n   uv_pipe_t* pipe_client;\n   uv_pipe_accept_t* req;\n   QUEUE* q;\n-  uv__ipc_queue_item_t* item;\n+  uv__ipc_xfer_queue_item_t* item;\n   int err;\n \n   if (server->ipc) {\n-    if (QUEUE_EMPTY(&server->pipe.conn.pending_ipc_info.queue)) {\n+    if (QUEUE_EMPTY(&server->pipe.conn.ipc_xfer_queue)) {\n       /* No valid pending sockets. */\n       return WSAEWOULDBLOCK;\n     }\n \n-    q = QUEUE_HEAD(&server->pipe.conn.pending_ipc_info.queue);\n+    q = QUEUE_HEAD(&server->pipe.conn.ipc_xfer_queue);\n     QUEUE_REMOVE(q);\n-    server->pipe.conn.pending_ipc_info.queue_len--;\n-    item = QUEUE_DATA(q, uv__ipc_queue_item_t, member);\n+    server->pipe.conn.ipc_xfer_queue_length--;\n+    item = QUEUE_DATA(q, uv__ipc_xfer_queue_item_t, member);\n \n-    err = uv_tcp_import((uv_tcp_t*)client,\n-                        &item->socket_info_ex,\n-                        item->tcp_connection);\n+    err = uv__tcp_xfer_import((uv_tcp_t*) client, &item->xfer_info);\n     if (err != 0)\n       return err;\n \n@@ -889,8 +888,8 @@ int uv_pipe_accept(uv_pipe_t* server, uv_stream_t* client) {\n   } else {\n     pipe_client = (uv_pipe_t*)client;\n \n-    /* Find a connection instance that has been connected, but not yet */\n-    /* accepted. */\n+    /* Find a connection instance that has been connected, but not yet\n+     * accepted. */\n     req = server->pipe.serv.pending_accepts;\n \n     if (!req) {\n@@ -953,74 +952,75 @@ int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb) {\n }\n \n \n-static DWORD WINAPI uv_pipe_zero_readfile_thread_proc(void* parameter) {\n-  int result;\n-  DWORD bytes;\n-  uv_read_t* req = (uv_read_t*) parameter;\n+static DWORD WINAPI uv_pipe_zero_readfile_thread_proc(void* arg) {\n+  uv_read_t* req = (uv_read_t*) arg;\n   uv_pipe_t* handle = (uv_pipe_t*) req->data;\n   uv_loop_t* loop = handle->loop;\n-  HANDLE hThread = NULL;\n+  volatile HANDLE* thread_ptr = &handle->pipe.conn.readfile_thread_handle;\n+  CRITICAL_SECTION* lock = &handle->pipe.conn.readfile_thread_lock;\n+  HANDLE thread;\n+  DWORD bytes;\n   DWORD err;\n-  uv_mutex_t *m = &handle->pipe.conn.readfile_mutex;\n \n-  assert(req != NULL);\n   assert(req->type == UV_READ);\n   assert(handle->type == UV_NAMED_PIPE);\n \n-  if (handle->flags & UV_HANDLE_PIPE_READ_CANCELABLE) {\n-    uv_mutex_lock(m); /* mutex controls *setting* of readfile_thread */\n-    if (DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),\n-                        GetCurrentProcess(), &hThread,\n-                        0, FALSE, DUPLICATE_SAME_ACCESS)) {\n-      handle->pipe.conn.readfile_thread = hThread;\n-    } else {\n-      hThread = NULL;\n-    }\n-    uv_mutex_unlock(m);\n+  err = 0;\n+\n+  /* Create a handle to the current thread. */\n+  if (!DuplicateHandle(GetCurrentProcess(),\n+                       GetCurrentThread(),\n+                       GetCurrentProcess(),\n+                       &thread,\n+                       0,\n+                       FALSE,\n+                       DUPLICATE_SAME_ACCESS)) {\n+    err = GetLastError();\n+    goto out1;\n   }\n-restart_readfile:\n-  if (handle->flags & UV_HANDLE_READING) {\n-    result = ReadFile(handle->handle,\n-                      &uv_zero_,\n-                      0,\n-                      &bytes,\n-                      NULL);\n-    if (!result) {\n-      err = GetLastError();\n-      if (err == ERROR_OPERATION_ABORTED &&\n-          handle->flags & UV_HANDLE_PIPE_READ_CANCELABLE) {\n-        if (handle->flags & UV_HANDLE_READING) {\n-          /* just a brief break to do something else */\n-          handle->pipe.conn.readfile_thread = NULL;\n-          /* resume after it is finished */\n-          uv_mutex_lock(m);\n-          handle->pipe.conn.readfile_thread = hThread;\n-          uv_mutex_unlock(m);\n-          goto restart_readfile;\n-        } else {\n-          result = 1; /* successfully stopped reading */\n-        }\n-      }\n-    }\n+\n+  /* The lock needs to be held when thread handle is modified. */\n+  EnterCriticalSection(lock);\n+  if (*thread_ptr == INVALID_HANDLE_VALUE) {\n+    /* uv__pipe_interrupt_read() cancelled reading before we got here. */\n+    err = ERROR_OPERATION_ABORTED;\n   } else {\n-    result = 1; /* successfully aborted read before it even started */\n-  }\n-  if (hThread) {\n-    assert(hThread == handle->pipe.conn.readfile_thread);\n-    /* mutex does not control clearing readfile_thread */\n-    handle->pipe.conn.readfile_thread = NULL;\n-    uv_mutex_lock(m);\n-    /* only when we hold the mutex lock is it safe to\n-       open or close the handle */\n-    CloseHandle(hThread);\n-    uv_mutex_unlock(m);\n+    /* Let main thread know which worker thread is doing the blocking read. */\n+    assert(*thread_ptr == NULL);\n+    *thread_ptr = thread;\n   }\n+  LeaveCriticalSection(lock);\n \n-  if (!result) {\n-    SET_REQ_ERROR(req, err);\n-  }\n+  if (err)\n+    goto out2;\n+\n+  /* Block the thread until data is available on the pipe, or the read is\n+   * cancelled. */\n+  if (!ReadFile(handle->handle, &uv_zero_, 0, &bytes, NULL))\n+    err = GetLastError();\n+\n+  /* Let the main thread know the worker is past the point of blocking. */\n+  assert(thread == *thread_ptr);\n+  *thread_ptr = INVALID_HANDLE_VALUE;\n \n+  /* Briefly acquire the mutex. Since the main thread holds the lock while it\n+   * is spinning trying to cancel this thread's I/O, we will block here until\n+   * it stops doing that. */\n+  EnterCriticalSection(lock);\n+  LeaveCriticalSection(lock);\n+\n+out2:\n+  /* Close the handle to the current thread. */\n+  CloseHandle(thread);\n+\n+out1:\n+  /* Set request status and post a completion record to the IOCP. */\n+  if (err)\n+    SET_REQ_ERROR(req, err);\n+  else\n+    SET_REQ_SUCCESS(req);\n   POST_COMPLETION_FOR_REQ(loop, req);\n+\n   return 0;\n }\n \n@@ -1102,6 +1102,7 @@ static void uv_pipe_queue_read(uv_loop_t* loop, uv_pipe_t* handle) {\n   req = &handle->read_req;\n \n   if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {\n+    handle->pipe.conn.readfile_thread_handle = NULL; /* Reset cancellation. */\n     if (!QueueUserWorkItem(&uv_pipe_zero_readfile_thread_proc,\n                            req,\n                            WT_EXECUTELONGFUNCTION)) {\n@@ -1169,8 +1170,8 @@ int uv_pipe_read_start(uv_pipe_t* handle,\n   handle->read_cb = read_cb;\n   handle->alloc_cb = alloc_cb;\n \n-  /* If reading was stopped and then started again, there could still be a */\n-  /* read request pending. */\n+  /* If reading was stopped and then started again, there could still be a read\n+   * request pending. */\n   if (!(handle->flags & UV_HANDLE_READ_PENDING))\n     uv_pipe_queue_read(loop, handle);\n \n@@ -1226,154 +1227,111 @@ static void uv_queue_non_overlapped_write(uv_pipe_t* handle) {\n }\n \n \n-static int uv_pipe_write_impl(uv_loop_t* loop,\n-                              uv_write_t* req,\n-                              uv_pipe_t* handle,\n-                              const uv_buf_t bufs[],\n-                              unsigned int nbufs,\n-                              uv_stream_t* send_handle,\n-                              uv_write_cb cb) {\n-  int err;\n-  int result;\n-  uv_tcp_t* tcp_send_handle;\n-  uv_write_t* ipc_header_req = NULL;\n-  uv_ipc_frame_uv_stream ipc_frame;\n+static int uv__build_coalesced_write_req(uv_write_t* user_req,\n+                                         const uv_buf_t bufs[],\n+                                         size_t nbufs,\n+                                         uv_write_t** req_out,\n+                                         uv_buf_t* write_buf_out) {\n+  /* Pack into a single heap-allocated buffer:\n+   *   (a) a uv_write_t structure where libuv stores the actual state.\n+   *   (b) a pointer to the original uv_write_t.\n+   *   (c) data from all `bufs` entries.\n+   */\n+  char* heap_buffer;\n+  size_t heap_buffer_length, heap_buffer_offset;\n+  uv__coalesced_write_t* coalesced_write_req; /* (a) + (b) */\n+  char* data_start;                           /* (c) */\n+  size_t data_length;\n+  unsigned int i;\n+\n+  /* Compute combined size of all combined buffers from `bufs`. */\n+  data_length = 0;\n+  for (i = 0; i < nbufs; i++)\n+    data_length += bufs[i].len;\n+\n+  /* The total combined size of data buffers should not exceed UINT32_MAX,\n+   * because WriteFile() won't accept buffers larger than that. */\n+  if (data_length > UINT32_MAX)\n+    return WSAENOBUFS; /* Maps to UV_ENOBUFS. */\n+\n+  /* Compute heap buffer size. */\n+  heap_buffer_length = sizeof *coalesced_write_req + /* (a) + (b) */\n+                       data_length;                  /* (c) */\n+\n+  /* Allocate buffer. */\n+  heap_buffer = uv__malloc(heap_buffer_length);\n+  if (heap_buffer == NULL)\n+    return ERROR_NOT_ENOUGH_MEMORY; /* Maps to UV_ENOMEM. */\n+\n+  /* Copy uv_write_t information to the buffer. */\n+  coalesced_write_req = (uv__coalesced_write_t*) heap_buffer;\n+  coalesced_write_req->req = *user_req; /* copy (a) */\n+  coalesced_write_req->req.coalesced = 1;\n+  coalesced_write_req->user_req = user_req;         /* copy (b) */\n+  heap_buffer_offset = sizeof *coalesced_write_req; /* offset (a) + (b) */\n+\n+  /* Copy data buffers to the heap buffer. */\n+  data_start = &heap_buffer[heap_buffer_offset];\n+  for (i = 0; i < nbufs; i++) {\n+    memcpy(&heap_buffer[heap_buffer_offset],\n+           bufs[i].base,\n+           bufs[i].len);               /* copy (c) */\n+    heap_buffer_offset += bufs[i].len; /* offset (c) */\n+  }\n+  assert(heap_buffer_offset == heap_buffer_length);\n+\n+  /* Set out arguments and return. */\n+  *req_out = &coalesced_write_req->req;\n+  *write_buf_out = uv_buf_init(data_start, (unsigned int) data_length);\n+  return 0;\n+}\n \n-  if (nbufs != 1 && (nbufs != 0 || !send_handle)) {\n-    return ERROR_NOT_SUPPORTED;\n-  }\n \n-  /* Only TCP handles are supported for sharing. */\n-  if (send_handle && ((send_handle->type != UV_TCP) ||\n-      (!(send_handle->flags & UV_HANDLE_BOUND) &&\n-       !(send_handle->flags & UV_HANDLE_CONNECTION)))) {\n-    return ERROR_NOT_SUPPORTED;\n-  }\n+static int uv__pipe_write_data(uv_loop_t* loop,\n+                               uv_write_t* req,\n+                               uv_pipe_t* handle,\n+                               const uv_buf_t bufs[],\n+                               size_t nbufs,\n+                               uv_stream_t* send_handle,\n+                               uv_write_cb cb,\n+                               bool copy_always) {\n+  int err;\n+  int result;\n+  uv_buf_t write_buf;\n \n   assert(handle->handle != INVALID_HANDLE_VALUE);\n \n   UV_REQ_INIT(req, UV_WRITE);\n   req->handle = (uv_stream_t*) handle;\n+  req->send_handle = send_handle;\n   req->cb = cb;\n-  req->ipc_header = 0;\n+  /* Private fields. */\n+  req->coalesced = 0;\n   req->event_handle = NULL;\n   req->wait_handle = INVALID_HANDLE_VALUE;\n   memset(&req->u.io.overlapped, 0, sizeof(req->u.io.overlapped));\n-\n-  if (handle->ipc) {\n-    assert(!(handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE));\n-    ipc_frame.header.flags = 0;\n-\n-    /* Use the IPC framing protocol. */\n-    if (send_handle) {\n-      tcp_send_handle = (uv_tcp_t*)send_handle;\n-\n-      if (handle->pipe.conn.ipc_pid == 0) {\n-          handle->pipe.conn.ipc_pid = uv_current_pid();\n-      }\n-\n-      err = uv_tcp_duplicate_socket(tcp_send_handle, handle->pipe.conn.ipc_pid,\n-          &ipc_frame.socket_info_ex.socket_info);\n-      if (err) {\n-        return err;\n-      }\n-\n-      ipc_frame.socket_info_ex.delayed_error = tcp_send_handle->delayed_error;\n-\n-      ipc_frame.header.flags |= UV_IPC_TCP_SERVER;\n-\n-      if (tcp_send_handle->flags & UV_HANDLE_CONNECTION) {\n-        ipc_frame.header.flags |= UV_IPC_TCP_CONNECTION;\n-      }\n-    }\n-\n-    if (nbufs == 1) {\n-      ipc_frame.header.flags |= UV_IPC_RAW_DATA;\n-      ipc_frame.header.raw_data_length = bufs[0].len;\n-    }\n-\n-    /*\n-     * Use the provided req if we're only doing a single write.\n-     * If we're doing multiple writes, use ipc_header_write_req to do\n-     * the first write, and then use the provided req for the second write.\n-     */\n-    if (!(ipc_frame.header.flags & UV_IPC_RAW_DATA)) {\n-      ipc_header_req = req;\n-    } else {\n-      /*\n-       * Try to use the preallocated write req if it's available.\n-       * Otherwise allocate a new one.\n-       */\n-      if (handle->pipe.conn.ipc_header_write_req.type != UV_WRITE) {\n-        ipc_header_req = (uv_write_t*)&handle->pipe.conn.ipc_header_write_req;\n-      } else {\n-        ipc_header_req = (uv_write_t*)uv__malloc(sizeof(uv_write_t));\n-        if (!ipc_header_req) {\n-          uv_fatal_error(ERROR_OUTOFMEMORY, \"uv__malloc\");\n-        }\n-      }\n-\n-      UV_REQ_INIT(ipc_header_req, UV_WRITE);\n-      ipc_header_req->handle = (uv_stream_t*) handle;\n-      ipc_header_req->cb = NULL;\n-      ipc_header_req->ipc_header = 1;\n-    }\n-\n-    /* Write the header or the whole frame. */\n-    memset(&ipc_header_req->u.io.overlapped, 0,\n-           sizeof(ipc_header_req->u.io.overlapped));\n-\n-    /* Using overlapped IO, but wait for completion before returning.\n-       This write is blocking because ipc_frame is on stack. */\n-    ipc_header_req->u.io.overlapped.hEvent = CreateEvent(NULL, 1, 0, NULL);\n-    if (!ipc_header_req->u.io.overlapped.hEvent) {\n-      uv_fatal_error(GetLastError(), \"CreateEvent\");\n-    }\n-\n-    result = WriteFile(handle->handle,\n-                        &ipc_frame,\n-                        ipc_frame.header.flags & UV_IPC_TCP_SERVER ?\n-                          sizeof(ipc_frame) : sizeof(ipc_frame.header),\n-                        NULL,\n-                        &ipc_header_req->u.io.overlapped);\n-    if (!result && GetLastError() != ERROR_IO_PENDING) {\n-      err = GetLastError();\n-      CloseHandle(ipc_header_req->u.io.overlapped.hEvent);\n+  req->write_buffer = uv_null_buf_;\n+\n+  if (nbufs == 0) {\n+    /* Write empty buffer. */\n+    write_buf = uv_null_buf_;\n+  } else if (nbufs == 1 && !copy_always) {\n+    /* Write directly from bufs[0]. */\n+    write_buf = bufs[0];\n+  } else {\n+    /* Coalesce all `bufs` into one big buffer. This also creates a new\n+     * write-request structure that replaces the old one. */\n+    err = uv__build_coalesced_write_req(req, bufs, nbufs, &req, &write_buf);\n+    if (err != 0)\n       return err;\n-    }\n-\n-    if (!result) {\n-      /* Request not completed immediately. Wait for it.*/\n-      if (WaitForSingleObject(ipc_header_req->u.io.overlapped.hEvent, INFINITE) !=\n-          WAIT_OBJECT_0) {\n-        err = GetLastError();\n-        CloseHandle(ipc_header_req->u.io.overlapped.hEvent);\n-        return err;\n-      }\n-    }\n-    ipc_header_req->u.io.queued_bytes = 0;\n-    CloseHandle(ipc_header_req->u.io.overlapped.hEvent);\n-    ipc_header_req->u.io.overlapped.hEvent = NULL;\n-\n-    REGISTER_HANDLE_REQ(loop, handle, ipc_header_req);\n-    handle->reqs_pending++;\n-    handle->stream.conn.write_reqs_pending++;\n-\n-    /* If we don't have any raw data to write - we're done. */\n-    if (!(ipc_frame.header.flags & UV_IPC_RAW_DATA)) {\n-      return 0;\n-    }\n   }\n \n   if ((handle->flags &\n       (UV_HANDLE_BLOCKING_WRITES | UV_HANDLE_NON_OVERLAPPED_PIPE)) ==\n       (UV_HANDLE_BLOCKING_WRITES | UV_HANDLE_NON_OVERLAPPED_PIPE)) {\n     DWORD bytes;\n-    result = WriteFile(handle->handle,\n-                       bufs[0].base,\n-                       bufs[0].len,\n-                       &bytes,\n-                       NULL);\n+    result =\n+        WriteFile(handle->handle, write_buf.base, write_buf.len, &bytes, NULL);\n \n     if (!result) {\n       err = GetLastError();\n@@ -1389,14 +1347,14 @@ static int uv_pipe_write_impl(uv_loop_t* loop,\n     POST_COMPLETION_FOR_REQ(loop, req);\n     return 0;\n   } else if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {\n-    req->write_buffer = bufs[0];\n+    req->write_buffer = write_buf;\n     uv_insert_non_overlapped_write_req(handle, req);\n     if (handle->stream.conn.write_reqs_pending == 0) {\n       uv_queue_non_overlapped_write(handle);\n     }\n \n     /* Request queued by the kernel. */\n-    req->u.io.queued_bytes = bufs[0].len;\n+    req->u.io.queued_bytes = write_buf.len;\n     handle->write_queue_size += req->u.io.queued_bytes;\n   } else if (handle->flags & UV_HANDLE_BLOCKING_WRITES) {\n     /* Using overlapped IO, but wait for completion before returning */\n@@ -1406,8 +1364,8 @@ static int uv_pipe_write_impl(uv_loop_t* loop,\n     }\n \n     result = WriteFile(handle->handle,\n-                       bufs[0].base,\n-                       bufs[0].len,\n+                       write_buf.base,\n+                       write_buf.len,\n                        NULL,\n                        &req->u.io.overlapped);\n \n@@ -1422,13 +1380,13 @@ static int uv_pipe_write_impl(uv_loop_t* loop,\n       req->u.io.queued_bytes = 0;\n     } else {\n       /* Request queued by the kernel. */\n-      req->u.io.queued_bytes = bufs[0].len;\n+      req->u.io.queued_bytes = write_buf.len;\n       handle->write_queue_size += req->u.io.queued_bytes;\n       if (WaitForSingleObject(req->u.io.overlapped.hEvent, INFINITE) !=\n           WAIT_OBJECT_0) {\n         err = GetLastError();\n         CloseHandle(req->u.io.overlapped.hEvent);\n-        return uv_translate_sys_error(err);\n+        return err;\n       }\n     }\n     CloseHandle(req->u.io.overlapped.hEvent);\n@@ -1439,8 +1397,8 @@ static int uv_pipe_write_impl(uv_loop_t* loop,\n     return 0;\n   } else {\n     result = WriteFile(handle->handle,\n-                       bufs[0].base,\n-                       bufs[0].len,\n+                       write_buf.base,\n+                       write_buf.len,\n                        NULL,\n                        &req->u.io.overlapped);\n \n@@ -1453,7 +1411,7 @@ static int uv_pipe_write_impl(uv_loop_t* loop,\n       req->u.io.queued_bytes = 0;\n     } else {\n       /* Request queued by the kernel. */\n-      req->u.io.queued_bytes = bufs[0].len;\n+      req->u.io.queued_bytes = write_buf.len;\n       handle->write_queue_size += req->u.io.queued_bytes;\n     }\n \n@@ -1478,35 +1436,140 @@ static int uv_pipe_write_impl(uv_loop_t* loop,\n }\n \n \n-int uv_pipe_write(uv_loop_t* loop,\n-                  uv_write_t* req,\n-                  uv_pipe_t* handle,\n-                  const uv_buf_t bufs[],\n-                  unsigned int nbufs,\n-                  uv_write_cb cb) {\n-  return uv_pipe_write_impl(loop, req, handle, bufs, nbufs, NULL, cb);\n+static DWORD uv__pipe_get_ipc_remote_pid(uv_pipe_t* handle) {\n+  DWORD* pid = &handle->pipe.conn.ipc_remote_pid;\n+\n+  /* If the both ends of the IPC pipe are owned by the same process,\n+   * the remote end pid may not yet be set. If so, do it here.\n+   * TODO: this is weird; it'd probably better to use a handshake. */\n+  if (*pid == 0)\n+    *pid = GetCurrentProcessId();\n+\n+  return *pid;\n+}\n+\n+\n+int uv__pipe_write_ipc(uv_loop_t* loop,\n+                       uv_write_t* req,\n+                       uv_pipe_t* handle,\n+                       const uv_buf_t data_bufs[],\n+                       size_t data_buf_count,\n+                       uv_stream_t* send_handle,\n+                       uv_write_cb cb) {\n+  uv_buf_t stack_bufs[6];\n+  uv_buf_t* bufs;\n+  size_t buf_count, buf_index;\n+  uv__ipc_frame_header_t xfer_frame_header;\n+  uv__ipc_socket_xfer_info_t xfer_info;\n+  uv__ipc_frame_header_t data_frame_header;\n+  size_t data_length;\n+  size_t i;\n+  int err;\n+\n+  /* Compute the combined size of data buffers. */\n+  data_length = 0;\n+  for (i = 0; i < data_buf_count; i++)\n+    data_length += data_bufs[i].len;\n+  if (data_length > UINT32_MAX)\n+    return WSAENOBUFS; /* Maps to UV_ENOBUFS. */\n+\n+  /* Prepare xfer frame payload. */\n+  if (send_handle) {\n+    uv_tcp_t* send_tcp_handle = (uv_tcp_t*) send_handle;\n+\n+    /* Verify that `send_handle` it is indeed a tcp handle. */\n+    if (send_tcp_handle->type != UV_TCP)\n+      return ERROR_NOT_SUPPORTED;\n+\n+    /* Export the tcp handle. */\n+    err = uv__tcp_xfer_export(\n+        send_tcp_handle, uv__pipe_get_ipc_remote_pid(handle), &xfer_info);\n+    if (err != 0)\n+      return err;\n+  }\n+\n+  /* Compute the number of uv_buf_t's required. */\n+  buf_count = 0;\n+  if (send_handle != NULL) {\n+    buf_count += 2; /* One for the frame header, one for the payload. */\n+  }\n+  if (data_buf_count > 0) {\n+    buf_count += 1 + data_buf_count; /* One extra for the frame header. */\n+  }\n+\n+  /* Use the on-stack buffer array if it is big enough; otherwise allocate\n+   * space for it on the heap. */\n+  if (buf_count < ARRAY_SIZE(stack_bufs)) {\n+    /* Use on-stack buffer array. */\n+    bufs = stack_bufs;\n+  } else {\n+    /* Use heap-allocated buffer array. */\n+    bufs = uv__calloc(buf_count, sizeof(uv_buf_t));\n+    if (bufs == NULL)\n+      return ERROR_NOT_ENOUGH_MEMORY; /* Maps to UV_ENOMEM. */\n+  }\n+  buf_index = 0;\n+\n+  if (send_handle != NULL) {\n+    /* Add xfer frame header. */\n+    xfer_frame_header.type = UV__IPC_XFER_FRAME;\n+    xfer_frame_header.payload_length = sizeof xfer_info;\n+    bufs[buf_index++] =\n+        uv_buf_init((char*) &xfer_frame_header, sizeof xfer_frame_header);\n+\n+    /* Add xfer frame payload. */\n+    bufs[buf_index++] = uv_buf_init((char*) &xfer_info, sizeof xfer_info);\n+  }\n+\n+  if (data_length > 0) {\n+    /* Add data frame header. */\n+    data_frame_header.type = UV__IPC_DATA_FRAME;\n+    data_frame_header.payload_length = (uint32_t) data_length;\n+    bufs[buf_index++] =\n+        uv_buf_init((char*) &data_frame_header, sizeof data_frame_header);\n+\n+    /* Add data buffers. */\n+    for (i = 0; i < data_buf_count; i++)\n+      bufs[buf_index++] = data_bufs[i];\n+  }\n+\n+  /* Write buffers. We set the `always_copy` flag, so it is not a problem that\n+   * some of the written data lives on the stack. */\n+  err = uv__pipe_write_data(\n+      loop, req, handle, bufs, buf_count, send_handle, cb, true);\n+\n+  /* If we had to heap-allocate the bufs array, free it now. */\n+  if (bufs != stack_bufs) {\n+    uv__free(bufs);\n+  }\n+\n+  return err;\n }\n \n \n-int uv_pipe_write2(uv_loop_t* loop,\n+int uv__pipe_write(uv_loop_t* loop,\n                    uv_write_t* req,\n                    uv_pipe_t* handle,\n                    const uv_buf_t bufs[],\n-                   unsigned int nbufs,\n+                   size_t nbufs,\n                    uv_stream_t* send_handle,\n                    uv_write_cb cb) {\n-  if (!handle->ipc) {\n-    return WSAEINVAL;\n+  if (handle->ipc) {\n+    /* IPC pipe write: use framing protocol. */\n+    return uv__pipe_write_ipc(loop, req, handle, bufs, nbufs, send_handle, cb);\n+  } else {\n+    /* Non-IPC pipe write: put data on the wire directly. */\n+    assert(send_handle == NULL);\n+    return uv__pipe_write_data(\n+        loop, req, handle, bufs, nbufs, NULL, cb, false);\n   }\n-\n-  return uv_pipe_write_impl(loop, req, handle, bufs, nbufs, send_handle, cb);\n }\n \n \n static void uv_pipe_read_eof(uv_loop_t* loop, uv_pipe_t* handle,\n     uv_buf_t buf) {\n-  /* If there is an eof timer running, we don't need it any more, */\n-  /* so discard it. */\n+  /* If there is an eof timer running, we don't need it any more, so discard\n+   * it. */\n   eof_timer_destroy(handle);\n \n   handle->flags &= ~UV_HANDLE_READABLE;\n@@ -1518,8 +1581,8 @@ static void uv_pipe_read_eof(uv_loop_t* loop, uv_pipe_t* handle,\n \n static void uv_pipe_read_error(uv_loop_t* loop, uv_pipe_t* handle, int error,\n     uv_buf_t buf) {\n-  /* If there is an eof timer running, we don't need it any more, */\n-  /* so discard it. */\n+  /* If there is an eof timer running, we don't need it any more, so discard\n+   * it. */\n   eof_timer_destroy(handle);\n \n   uv_read_stop((uv_stream_t*) handle);\n@@ -1530,163 +1593,206 @@ static void uv_pipe_read_error(uv_loop_t* loop, uv_pipe_t* handle, int error,\n \n static void uv_pipe_read_error_or_eof(uv_loop_t* loop, uv_pipe_t* handle,\n     int error, uv_buf_t buf) {\n-  if (error == ERROR_OPERATION_ABORTED) {\n-    /* do nothing (equivalent to EINTR) */\n-  }\n-  else if (error == ERROR_BROKEN_PIPE) {\n+  if (error == ERROR_BROKEN_PIPE) {\n     uv_pipe_read_eof(loop, handle, buf);\n   } else {\n     uv_pipe_read_error(loop, handle, error, buf);\n   }\n }\n \n \n-void uv__pipe_insert_pending_socket(uv_pipe_t* handle,\n-                                    uv__ipc_socket_info_ex* info,\n-                                    int tcp_connection) {\n-  uv__ipc_queue_item_t* item;\n+static void uv__pipe_queue_ipc_xfer_info(\n+    uv_pipe_t* handle, uv__ipc_socket_xfer_info_t* xfer_info) {\n+  uv__ipc_xfer_queue_item_t* item;\n \n-  item = (uv__ipc_queue_item_t*) uv__malloc(sizeof(*item));\n+  item = (uv__ipc_xfer_queue_item_t*) uv__malloc(sizeof(*item));\n   if (item == NULL)\n     uv_fatal_error(ERROR_OUTOFMEMORY, \"uv__malloc\");\n \n-  memcpy(&item->socket_info_ex, info, sizeof(item->socket_info_ex));\n-  item->tcp_connection = tcp_connection;\n-  QUEUE_INSERT_TAIL(&handle->pipe.conn.pending_ipc_info.queue, &item->member);\n-  handle->pipe.conn.pending_ipc_info.queue_len++;\n+  memcpy(&item->xfer_info, xfer_info, sizeof(item->xfer_info));\n+  QUEUE_INSERT_TAIL(&handle->pipe.conn.ipc_xfer_queue, &item->member);\n+  handle->pipe.conn.ipc_xfer_queue_length++;\n }\n \n \n-void uv_process_pipe_read_req(uv_loop_t* loop, uv_pipe_t* handle,\n-    uv_req_t* req) {\n-  DWORD bytes, avail;\n+/* Read an exact number of bytes from a pipe. If an error or end-of-file is\n+ * encountered before the requested number of bytes are read, an error is\n+ * returned. */\n+static int uv__pipe_read_exactly(HANDLE h, void* buffer, DWORD count) {\n+  DWORD bytes_read, bytes_read_now;\n+\n+  bytes_read = 0;\n+  while (bytes_read < count) {\n+    if (!ReadFile(h,\n+                  (char*) buffer + bytes_read,\n+                  count - bytes_read,\n+                  &bytes_read_now,\n+                  NULL)) {\n+      return GetLastError();\n+    }\n+\n+    bytes_read += bytes_read_now;\n+  }\n+\n+  assert(bytes_read == count);\n+  return 0;\n+}\n+\n+\n+static DWORD uv__pipe_read_data(uv_loop_t* loop,\n+                                uv_pipe_t* handle,\n+                                DWORD suggested_bytes,\n+                                DWORD max_bytes) {\n+  DWORD bytes_read;\n   uv_buf_t buf;\n-  uv_ipc_frame_uv_stream ipc_frame;\n \n+  /* Ask the user for a buffer to read data into. */\n+  buf = uv_buf_init(NULL, 0);\n+  handle->alloc_cb((uv_handle_t*) handle, suggested_bytes, &buf);\n+  if (buf.base == NULL || buf.len == 0) {\n+    handle->read_cb((uv_stream_t*) handle, UV_ENOBUFS, &buf);\n+    return 0; /* Break out of read loop. */\n+  }\n+\n+  /* Ensure we read at most the smaller of:\n+   *   (a) the length of the user-allocated buffer.\n+   *   (b) the maximum data length as specified by the `max_bytes` argument.\n+   */\n+  if (max_bytes > buf.len)\n+    max_bytes = buf.len;\n+\n+  /* Read into the user buffer. */\n+  if (!ReadFile(handle->handle, buf.base, max_bytes, &bytes_read, NULL)) {\n+    uv_pipe_read_error_or_eof(loop, handle, GetLastError(), buf);\n+    return 0; /* Break out of read loop. */\n+  }\n+\n+  /* Call the read callback. */\n+  handle->read_cb((uv_stream_t*) handle, bytes_read, &buf);\n+\n+  return bytes_read;\n+}\n+\n+\n+static DWORD uv__pipe_read_ipc(uv_loop_t* loop, uv_pipe_t* handle) {\n+  DWORD* data_remaining = &handle->pipe.conn.ipc_data_frame.payload_remaining;\n+  int err;\n+\n+  if (*data_remaining > 0) {\n+    /* Read data frame payload. */\n+    DWORD bytes_read =\n+        uv__pipe_read_data(loop, handle, *data_remaining, *data_remaining);\n+    *data_remaining -= bytes_read;\n+    return bytes_read;\n+\n+  } else {\n+    /* Start of a new IPC frame. */\n+    uv__ipc_frame_header_t frame_header;\n+    uv__ipc_socket_xfer_info_t xfer_info;\n+\n+    /* Read the IPC frame header. */\n+    err = uv__pipe_read_exactly(\n+        handle->handle, &frame_header, sizeof frame_header);\n+    if (err)\n+      goto error;\n+\n+    if (frame_header.type == UV__IPC_DATA_FRAME) {\n+      /* Data frame: capture payload length. Actual data will be read in\n+       * subsequent call to uv__pipe_read_ipc(). */\n+      *data_remaining = frame_header.payload_length;\n+\n+      /* Return number of bytes read. */\n+      return sizeof frame_header;\n+\n+    } else if (frame_header.type == UV__IPC_XFER_FRAME) {\n+      /* Xfer frame: read the payload. */\n+      assert(frame_header.payload_length == sizeof xfer_info);\n+      err =\n+          uv__pipe_read_exactly(handle->handle, &xfer_info, sizeof xfer_info);\n+      if (err)\n+        goto error;\n+\n+      /* Store the pending socket info. */\n+      uv__pipe_queue_ipc_xfer_info(handle, &xfer_info);\n+\n+      /* Return number of bytes read. */\n+      return sizeof frame_header + sizeof xfer_info;\n+    }\n+\n+    /* Invalid frame. */\n+    err = WSAECONNABORTED; /* Maps to UV_ECONNABORTED. */\n+  }\n+\n+error:\n+  uv_pipe_read_error_or_eof(loop, handle, err, uv_null_buf_);\n+  return 0; /* Break out of read loop. */\n+}\n+\n+\n+void uv_process_pipe_read_req(uv_loop_t* loop,\n+                              uv_pipe_t* handle,\n+                              uv_req_t* req) {\n   assert(handle->type == UV_NAMED_PIPE);\n \n-  handle->flags &= ~UV_HANDLE_READ_PENDING;\n+  handle->flags &= ~(UV_HANDLE_READ_PENDING | UV_HANDLE_CANCELLATION_PENDING);\n+  DECREASE_PENDING_REQ_COUNT(handle);\n   eof_timer_stop(handle);\n \n-  if (!REQ_SUCCESS(req)) {\n-    /* An error occurred doing the 0-read. */\n-    if (handle->flags & UV_HANDLE_READING) {\n-      uv_pipe_read_error_or_eof(loop,\n-                                handle,\n-                                GET_REQ_ERROR(req),\n-                                uv_null_buf_);\n-    }\n-  } else {\n-    /* Do non-blocking reads until the buffer is empty */\n-    while (handle->flags & UV_HANDLE_READING) {\n-      if (!PeekNamedPipe(handle->handle,\n-                          NULL,\n-                          0,\n-                          NULL,\n-                          &avail,\n-                          NULL)) {\n-        uv_pipe_read_error_or_eof(loop, handle, GetLastError(), uv_null_buf_);\n-        break;\n-      }\n+  /* At this point, we're done with bookkeeping. If the user has stopped\n+   * reading the pipe in the meantime, there is nothing left to do, since there\n+   * is no callback that we can call. */\n+  if (!(handle->flags & UV_HANDLE_READING))\n+    return;\n \n-      if (avail == 0) {\n-        /* There is nothing to read after all. */\n-        break;\n-      }\n+  if (!REQ_SUCCESS(req)) {\n+    /* An error occurred doing the zero-read. */\n+    DWORD err = GET_REQ_ERROR(req);\n \n-      if (handle->ipc) {\n-        /* Use the IPC framing protocol to read the incoming data. */\n-        if (handle->pipe.conn.remaining_ipc_rawdata_bytes == 0) {\n-          /* We're reading a new frame.  First, read the header. */\n-          assert(avail >= sizeof(ipc_frame.header));\n-\n-          if (!ReadFile(handle->handle,\n-                        &ipc_frame.header,\n-                        sizeof(ipc_frame.header),\n-                        &bytes,\n-                        NULL)) {\n-            uv_pipe_read_error_or_eof(loop, handle, GetLastError(),\n-              uv_null_buf_);\n-            break;\n-          }\n-\n-          assert(bytes == sizeof(ipc_frame.header));\n-          assert(ipc_frame.header.flags <= (UV_IPC_TCP_SERVER | UV_IPC_RAW_DATA |\n-            UV_IPC_TCP_CONNECTION));\n-\n-          if (ipc_frame.header.flags & UV_IPC_TCP_SERVER) {\n-            assert(avail - sizeof(ipc_frame.header) >=\n-              sizeof(ipc_frame.socket_info_ex));\n-\n-            /* Read the TCP socket info. */\n-            if (!ReadFile(handle->handle,\n-                          &ipc_frame.socket_info_ex,\n-                          sizeof(ipc_frame) - sizeof(ipc_frame.header),\n-                          &bytes,\n-                          NULL)) {\n-              uv_pipe_read_error_or_eof(loop, handle, GetLastError(),\n-                uv_null_buf_);\n-              break;\n-            }\n-\n-            assert(bytes == sizeof(ipc_frame) - sizeof(ipc_frame.header));\n-\n-            /* Store the pending socket info. */\n-            uv__pipe_insert_pending_socket(\n-                handle,\n-                &ipc_frame.socket_info_ex,\n-                ipc_frame.header.flags & UV_IPC_TCP_CONNECTION);\n-          }\n-\n-          if (ipc_frame.header.flags & UV_IPC_RAW_DATA) {\n-            handle->pipe.conn.remaining_ipc_rawdata_bytes =\n-              ipc_frame.header.raw_data_length;\n-            continue;\n-          }\n-        } else {\n-          avail = min(avail, (DWORD)handle->pipe.conn.remaining_ipc_rawdata_bytes);\n-        }\n-      }\n+    /* If the read was cancelled by uv__pipe_interrupt_read(), the request may\n+     * indicate an ERROR_OPERATION_ABORTED error. This error isn't relevant to\n+     * the user; we'll start a new zero-read at the end of this function. */\n+    if (err != ERROR_OPERATION_ABORTED)\n+      uv_pipe_read_error_or_eof(loop, handle, err, uv_null_buf_);\n \n-      buf = uv_buf_init(NULL, 0);\n-      handle->alloc_cb((uv_handle_t*) handle, avail, &buf);\n-      if (buf.base == NULL || buf.len == 0) {\n-        handle->read_cb((uv_stream_t*) handle, UV_ENOBUFS, &buf);\n+  } else {\n+    /* The zero-read completed without error, indicating there is data\n+     * available in the kernel buffer. */\n+    DWORD avail;\n+\n+    /* Get the number of bytes available. */\n+    avail = 0;\n+    if (!PeekNamedPipe(handle->handle, NULL, 0, NULL, &avail, NULL))\n+      uv_pipe_read_error_or_eof(loop, handle, GetLastError(), uv_null_buf_);\n+\n+    /* Read until we've either read all the bytes available, or the 'reading'\n+     * flag is cleared. */\n+    while (avail > 0 && handle->flags & UV_HANDLE_READING) {\n+      /* Depending on the type of pipe, read either IPC frames or raw data. */\n+      DWORD bytes_read =\n+          handle->ipc ? uv__pipe_read_ipc(loop, handle)\n+                      : uv__pipe_read_data(loop, handle, avail, (DWORD) -1);\n+\n+      /* If no bytes were read, treat this as an indication that an error\n+       * occurred, and break out of the read loop. */\n+      if (bytes_read == 0)\n         break;\n-      }\n-      assert(buf.base != NULL);\n-\n-      if (ReadFile(handle->handle,\n-                   buf.base,\n-                   min(buf.len, avail),\n-                   &bytes,\n-                   NULL)) {\n-        /* Successful read */\n-        if (handle->ipc) {\n-          assert(handle->pipe.conn.remaining_ipc_rawdata_bytes >= bytes);\n-          handle->pipe.conn.remaining_ipc_rawdata_bytes =\n-            handle->pipe.conn.remaining_ipc_rawdata_bytes - bytes;\n-        }\n-        handle->read_cb((uv_stream_t*)handle, bytes, &buf);\n \n-        /* Read again only if bytes == buf.len */\n-        if (bytes <= buf.len) {\n-          break;\n-        }\n-      } else {\n-        uv_pipe_read_error_or_eof(loop, handle, GetLastError(), buf);\n+      /* It is possible that more bytes were read than we thought were\n+       * available. To prevent `avail` from underflowing, break out of the loop\n+       * if this is the case. */\n+      if (bytes_read > avail)\n         break;\n-      }\n-    }\n \n-    /* Post another 0-read if still reading and not closing. */\n-    if ((handle->flags & UV_HANDLE_READING) &&\n-        !(handle->flags & UV_HANDLE_READ_PENDING)) {\n-      uv_pipe_queue_read(loop, handle);\n+      /* Recompute the number of bytes available. */\n+      avail -= bytes_read;\n     }\n   }\n \n-  DECREASE_PENDING_REQ_COUNT(handle);\n+  /* Start another zero-read request if necessary. */\n+  if ((handle->flags & UV_HANDLE_READING) &&\n+      !(handle->flags & UV_HANDLE_READ_PENDING)) {\n+    uv_pipe_queue_read(loop, handle);\n+  }\n }\n \n \n@@ -1712,17 +1818,19 @@ void uv_process_pipe_write_req(uv_loop_t* loop, uv_pipe_t* handle,\n     }\n   }\n \n-  if (req->ipc_header) {\n-    if (req == &handle->pipe.conn.ipc_header_write_req) {\n-      req->type = UV_UNKNOWN_REQ;\n-    } else {\n-      uv__free(req);\n-    }\n-  } else {\n-    if (req->cb) {\n-      err = GET_REQ_ERROR(req);\n-      req->cb(req, uv_translate_sys_error(err));\n-    }\n+  err = GET_REQ_ERROR(req);\n+\n+  /* If this was a coalesced write, extract pointer to the user_provided\n+   * uv_write_t structure so we can pass the expected pointer to the callback,\n+   * then free the heap-allocated write req. */\n+  if (req->coalesced) {\n+    uv__coalesced_write_t* coalesced_write =\n+        container_of(req, uv__coalesced_write_t, req);\n+    req = coalesced_write->user_req;\n+    uv__free(coalesced_write);\n+  }\n+  if (req->cb) {\n+    req->cb(req, uv_translate_sys_error(err));\n   }\n \n   handle->stream.conn.write_reqs_pending--;\n@@ -1806,19 +1914,19 @@ void uv_process_pipe_shutdown_req(uv_loop_t* loop, uv_pipe_t* handle,\n   UNREGISTER_HANDLE_REQ(loop, handle, req);\n \n   if (handle->flags & UV_HANDLE_READABLE) {\n-    /* Initialize and optionally start the eof timer. Only do this if the */\n-    /* pipe is readable and we haven't seen EOF come in ourselves. */\n+    /* Initialize and optionally start the eof timer. Only do this if the pipe\n+     * is readable and we haven't seen EOF come in ourselves. */\n     eof_timer_init(handle);\n \n-    /* If reading start the timer right now. */\n-    /* Otherwise uv_pipe_queue_read will start it. */\n+    /* If reading start the timer right now. Otherwise uv_pipe_queue_read will\n+     * start it. */\n     if (handle->flags & UV_HANDLE_READ_PENDING) {\n       eof_timer_start(handle);\n     }\n \n   } else {\n-    /* This pipe is not readable. We can just close it to let the other end */\n-    /* know that we're done writing. */\n+    /* This pipe is not readable. We can just close it to let the other end\n+     * know that we're done writing. */\n     close_pipe(handle);\n   }\n \n@@ -1869,17 +1977,16 @@ static void eof_timer_cb(uv_timer_t* timer) {\n \n   assert(pipe->type == UV_NAMED_PIPE);\n \n-  /* This should always be true, since we start the timer only */\n-  /* in uv_pipe_queue_read after successfully calling ReadFile, */\n-  /* or in uv_process_pipe_shutdown_req if a read is pending, */\n-  /* and we always immediately stop the timer in */\n-  /* uv_process_pipe_read_req. */\n+  /* This should always be true, since we start the timer only in\n+   * uv_pipe_queue_read after successfully calling ReadFile, or in\n+   * uv_process_pipe_shutdown_req if a read is pending, and we always\n+   * immediately stop the timer in uv_process_pipe_read_req. */\n   assert(pipe->flags & UV_HANDLE_READ_PENDING);\n \n-  /* If there are many packets coming off the iocp then the timer callback */\n-  /* may be called before the read request is coming off the queue. */\n-  /* Therefore we check here if the read request has completed but will */\n-  /* be processed later. */\n+  /* If there are many packets coming off the iocp then the timer callback may\n+   * be called before the read request is coming off the queue. Therefore we\n+   * check here if the read request has completed but will be processed later.\n+   */\n   if ((pipe->flags & UV_HANDLE_READ_PENDING) &&\n       HasOverlappedIoCompleted(&pipe->read_req.u.io.overlapped)) {\n     return;\n@@ -1888,12 +1995,12 @@ static void eof_timer_cb(uv_timer_t* timer) {\n   /* Force both ends off the pipe. */\n   close_pipe(pipe);\n \n-  /* Stop reading, so the pending read that is going to fail will */\n-  /* not be reported to the user. */\n+  /* Stop reading, so the pending read that is going to fail will not be\n+   * reported to the user. */\n   uv_read_stop((uv_stream_t*) pipe);\n \n-  /* Report the eof and update flags. This will get reported even if the */\n-  /* user stopped reading in the meantime. TODO: is that okay? */\n+  /* Report the eof and update flags. This will get reported even if the user\n+   * stopped reading in the meantime. TODO: is that okay? */\n   uv_pipe_read_eof(loop, pipe, uv_null_buf_);\n }\n \n@@ -1980,8 +2087,8 @@ int uv_pipe_open(uv_pipe_t* pipe, uv_file file) {\n \n   if (pipe->ipc) {\n     assert(!(pipe->flags & UV_HANDLE_NON_OVERLAPPED_PIPE));\n-    pipe->pipe.conn.ipc_pid = uv_os_getppid();\n-    assert(pipe->pipe.conn.ipc_pid != -1);\n+    pipe->pipe.conn.ipc_remote_pid = uv_os_getppid();\n+    assert(pipe->pipe.conn.ipc_remote_pid != -1);\n   }\n   return 0;\n }\n@@ -2006,7 +2113,15 @@ static int uv__pipe_getname(const uv_pipe_t* handle, char* buffer, size_t* size)\n     return UV_EINVAL;\n   }\n \n-  uv__pipe_pause_read((uv_pipe_t*)handle); /* cast away const warning */\n+  /* NtQueryInformationFile will block if another thread is performing a\n+   * blocking operation on the queried handle. If the pipe handle is\n+   * synchronous, there may be a worker thread currently calling ReadFile() on\n+   * the pipe handle, which could cause a deadlock. To avoid this, interrupt\n+   * the read. */\n+  if (handle->flags & UV_HANDLE_CONNECTION &&\n+      handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {\n+    uv__pipe_interrupt_read((uv_pipe_t*) handle); /* cast away const warning */\n+  }\n \n   nt_status = pNtQueryInformationFile(handle->handle,\n                                       &io_status,\n@@ -2097,15 +2212,14 @@ static int uv__pipe_getname(const uv_pipe_t* handle, char* buffer, size_t* size)\n   uv__free(name_info);\n \n cleanup:\n-  uv__pipe_unpause_read((uv_pipe_t*)handle); /* cast away const warning */\n   return err;\n }\n \n \n int uv_pipe_pending_count(uv_pipe_t* handle) {\n   if (!handle->ipc)\n     return 0;\n-  return handle->pipe.conn.pending_ipc_info.queue_len;\n+  return handle->pipe.conn.ipc_xfer_queue_length;\n }\n \n \n@@ -2138,7 +2252,7 @@ int uv_pipe_getpeername(const uv_pipe_t* handle, char* buffer, size_t* size) {\n uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle) {\n   if (!handle->ipc)\n     return UV_UNKNOWN_HANDLE;\n-  if (handle->pipe.conn.pending_ipc_info.queue_len == 0)\n+  if (handle->pipe.conn.ipc_xfer_queue_length == 0)\n     return UV_UNKNOWN_HANDLE;\n   else\n     return UV_TCP;"
        },
        {
            "sha": "b1369df3c442d3a4d33c9a3f4ed0131c617e8684",
            "filename": "deps/uv/src/win/poll.c",
            "status": "modified",
            "additions": 20,
            "deletions": 21,
            "changes": 41,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fpoll.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fpoll.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fpoll.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -91,16 +91,16 @@ static void uv__fast_poll_submit_poll_req(uv_loop_t* loop, uv_poll_t* handle) {\n     handle->mask_events_1 = handle->events;\n     handle->mask_events_2 = 0;\n   } else {\n-    /* Just wait until there's an unsubmitted req. */\n-    /* This will happen almost immediately as one of the 2 outstanding */\n-    /* requests is about to return. When this happens, */\n-    /* uv__fast_poll_process_poll_req will be called, and the pending */\n-    /* events, if needed, will be processed in a subsequent request. */\n+    /* Just wait until there's an unsubmitted req. This will happen almost\n+     * immediately as one of the 2 outstanding requests is about to return.\n+     * When this happens, uv__fast_poll_process_poll_req will be called, and\n+     * the pending events, if needed, will be processed in a subsequent\n+     * request. */\n     return;\n   }\n \n-  /* Setting Exclusive to TRUE makes the other poll request return if there */\n-  /* is any. */\n+  /* Setting Exclusive to TRUE makes the other poll request return if there is\n+   * any. */\n   afd_poll_info->Exclusive = TRUE;\n   afd_poll_info->NumberOfHandles = 1;\n   afd_poll_info->Timeout.QuadPart = INT64_MAX;\n@@ -257,8 +257,8 @@ static int uv__fast_poll_close(uv_loop_t* loop, uv_poll_t* handle) {\n     uv_want_endgame(loop, (uv_handle_t*) handle);\n     return 0;\n   } else {\n-    /* Cancel outstanding poll requests by executing another, unique poll */\n-    /* request that forces the outstanding ones to return. */\n+    /* Cancel outstanding poll requests by executing another, unique poll\n+     * request that forces the outstanding ones to return. */\n     return uv__fast_poll_cancel_poll_req(loop, handle);\n   }\n }\n@@ -316,9 +316,8 @@ static SOCKET uv__fast_poll_get_peer_socket(uv_loop_t* loop,\n     return INVALID_SOCKET;\n   }\n \n-  /* If we didn't (try) to create a peer socket yet, try to make one. Don't */\n-  /* try again if the peer socket creation failed earlier for the same */\n-  /* protocol. */\n+  /* If we didn't (try) to create a peer socket yet, try to make one. Don't try\n+   * again if the peer socket creation failed earlier for the same protocol. */\n   peer_socket = loop->poll_peer_sockets[index];\n   if (peer_socket == 0) {\n     peer_socket = uv__fast_poll_create_peer_socket(loop->iocp, protocol_info);\n@@ -357,8 +356,8 @@ static DWORD WINAPI uv__slow_poll_thread_proc(void* arg) {\n     efds.fd_count = 0;\n   }\n \n-  /* Make the select() time out after 3 minutes. If select() hangs because */\n-  /* the user closed the socket, we will at least not hang indefinitely. */\n+  /* Make the select() time out after 3 minutes. If select() hangs because the\n+   * user closed the socket, we will at least not hang indefinitely. */\n   timeout.tv_sec = 3 * 60;\n   timeout.tv_usec = 0;\n \n@@ -522,10 +521,10 @@ int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle,\n   if (ioctlsocket(socket, FIONBIO, &yes) == SOCKET_ERROR)\n     return uv_translate_sys_error(WSAGetLastError());\n \n-  /* Try to obtain a base handle for the socket. This increases this chances */\n-  /* that we find an AFD handle and are able to use the fast poll mechanism. */\n-  /* This will always fail on windows XP/2k3, since they don't support the */\n-  /* SIO_BASE_HANDLE ioctl. */\n+/* Try to obtain a base handle for the socket. This increases this chances that\n+ * we find an AFD handle and are able to use the fast poll mechanism. This will\n+ * always fail on windows XP/2k3, since they don't support the. SIO_BASE_HANDLE\n+ * ioctl. */\n #ifndef NDEBUG\n   base_socket = INVALID_SOCKET;\n #endif\n@@ -557,9 +556,9 @@ int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle,\n     return uv_translate_sys_error(WSAGetLastError());\n   }\n \n-  /* Get the peer socket that is needed to enable fast poll. If the returned */\n-  /* value is NULL, the protocol is not implemented by MSAFD and we'll have */\n-  /* to use slow mode. */\n+  /* Get the peer socket that is needed to enable fast poll. If the returned\n+   * value is NULL, the protocol is not implemented by MSAFD and we'll have to\n+   * use slow mode. */\n   peer_socket = uv__fast_poll_get_peer_socket(loop, &protocol_info);\n \n   if (peer_socket != INVALID_SOCKET) {"
        },
        {
            "sha": "0ae9f0624af88a27341695711ff6ddb1a314ff4d",
            "filename": "deps/uv/src/win/process-stdio.c",
            "status": "modified",
            "additions": 29,
            "deletions": 29,
            "changes": 58,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fprocess-stdio.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fprocess-stdio.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fprocess-stdio.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -105,10 +105,9 @@ static int uv__create_stdio_pipe_pair(uv_loop_t* loop,\n   int err;\n \n   if (flags & UV_READABLE_PIPE) {\n-    /* The server needs inbound access too, otherwise CreateNamedPipe() */\n-    /* won't give us the FILE_READ_ATTRIBUTES permission. We need that to */\n-    /* probe the state of the write buffer when we're trying to shutdown */\n-    /* the pipe. */\n+    /* The server needs inbound access too, otherwise CreateNamedPipe() won't\n+     * give us the FILE_READ_ATTRIBUTES permission. We need that to probe the\n+     * state of the write buffer when we're trying to shutdown the pipe. */\n     server_access |= PIPE_ACCESS_OUTBOUND | PIPE_ACCESS_INBOUND;\n     client_access |= GENERIC_READ | FILE_WRITE_ATTRIBUTES;\n   }\n@@ -131,12 +130,13 @@ static int uv__create_stdio_pipe_pair(uv_loop_t* loop,\n   sa.lpSecurityDescriptor = NULL;\n   sa.bInheritHandle = TRUE;\n \n+  BOOL overlap = server_pipe->ipc || (flags & UV_OVERLAPPED_PIPE);\n   child_pipe = CreateFileA(pipe_name,\n                            client_access,\n                            0,\n                            &sa,\n                            OPEN_EXISTING,\n-                           server_pipe->ipc ? FILE_FLAG_OVERLAPPED : 0,\n+                           overlap ? FILE_FLAG_OVERLAPPED : 0,\n                            NULL);\n   if (child_pipe == INVALID_HANDLE_VALUE) {\n     err = GetLastError();\n@@ -159,8 +159,8 @@ static int uv__create_stdio_pipe_pair(uv_loop_t* loop,\n   }\n #endif\n \n-  /* Do a blocking ConnectNamedPipe.  This should not block because we have */\n-  /* both ends of the pipe created. */\n+  /* Do a blocking ConnectNamedPipe. This should not block because we have both\n+   * ends of the pipe created. */\n   if (!ConnectNamedPipe(server_pipe->handle, NULL)) {\n     if (GetLastError() != ERROR_PIPE_CONNECTED) {\n       err = GetLastError();\n@@ -194,11 +194,11 @@ static int uv__duplicate_handle(uv_loop_t* loop, HANDLE handle, HANDLE* dup) {\n   HANDLE current_process;\n \n \n-  /* _get_osfhandle will sometimes return -2 in case of an error. This seems */\n-  /* to happen when fd <= 2 and the process' corresponding stdio handle is */\n-  /* set to NULL. Unfortunately DuplicateHandle will happily duplicate */\n-  /* (HANDLE) -2, so this situation goes unnoticed until someone tries to */\n-  /* use the duplicate. Therefore we filter out known-invalid handles here. */\n+  /* _get_osfhandle will sometimes return -2 in case of an error. This seems to\n+   * happen when fd <= 2 and the process' corresponding stdio handle is set to\n+   * NULL. Unfortunately DuplicateHandle will happily duplicate (HANDLE) -2, so\n+   * this situation goes unnoticed until someone tries to use the duplicate.\n+   * Therefore we filter out known-invalid handles here. */\n   if (handle == INVALID_HANDLE_VALUE ||\n       handle == NULL ||\n       handle == (HANDLE) -2) {\n@@ -284,8 +284,8 @@ int uv__stdio_create(uv_loop_t* loop,\n     return ERROR_OUTOFMEMORY;\n   }\n \n-  /* Prepopulate the buffer with INVALID_HANDLE_VALUE handles so we can */\n-  /* clean up on failure. */\n+  /* Prepopulate the buffer with INVALID_HANDLE_VALUE handles so we can clean\n+   * up on failure. */\n   CHILD_STDIO_COUNT(buffer) = count;\n   for (i = 0; i < count; i++) {\n     CHILD_STDIO_CRT_FLAGS(buffer, i) = 0;\n@@ -303,12 +303,12 @@ int uv__stdio_create(uv_loop_t* loop,\n     switch (fdopt.flags & (UV_IGNORE | UV_CREATE_PIPE | UV_INHERIT_FD |\n             UV_INHERIT_STREAM)) {\n       case UV_IGNORE:\n-        /* Starting a process with no stdin/stout/stderr can confuse it. */\n-        /* So no matter what the user specified, we make sure the first */\n-        /* three FDs are always open in their typical modes, e.g. stdin */\n-        /* be readable and stdout/err should be writable. For FDs > 2, don't */\n-        /* do anything - all handles in the stdio buffer are initialized with */\n-        /* INVALID_HANDLE_VALUE, which should be okay. */\n+        /* Starting a process with no stdin/stout/stderr can confuse it. So no\n+         * matter what the user specified, we make sure the first three FDs are\n+         * always open in their typical modes, e. g. stdin be readable and\n+         * stdout/err should be writable. For FDs > 2, don't do anything - all\n+         * handles in the stdio buffer are initialized with.\n+         * INVALID_HANDLE_VALUE, which should be okay. */\n         if (i <= 2) {\n           DWORD access = (i == 0) ? FILE_GENERIC_READ :\n                                     FILE_GENERIC_WRITE | FILE_READ_ATTRIBUTES;\n@@ -323,14 +323,14 @@ int uv__stdio_create(uv_loop_t* loop,\n         break;\n \n       case UV_CREATE_PIPE: {\n-        /* Create a pair of two connected pipe ends; one end is turned into */\n-        /* an uv_pipe_t for use by the parent. The other one is given to */\n-        /* the child. */\n+        /* Create a pair of two connected pipe ends; one end is turned into an\n+         * uv_pipe_t for use by the parent. The other one is given to the\n+         * child. */\n         uv_pipe_t* parent_pipe = (uv_pipe_t*) fdopt.data.stream;\n         HANDLE child_pipe = INVALID_HANDLE_VALUE;\n \n-        /* Create a new, connected pipe pair. stdio[i].stream should point */\n-        /* to an uninitialized, but not connected pipe handle. */\n+        /* Create a new, connected pipe pair. stdio[i]. stream should point to\n+         * an uninitialized, but not connected pipe handle. */\n         assert(fdopt.data.stream->type == UV_NAMED_PIPE);\n         assert(!(fdopt.data.stream->flags & UV_HANDLE_CONNECTION));\n         assert(!(fdopt.data.stream->flags & UV_HANDLE_PIPESERVER));\n@@ -354,8 +354,8 @@ int uv__stdio_create(uv_loop_t* loop,\n         /* Make an inheritable duplicate of the handle. */\n         err = uv__duplicate_fd(loop, fdopt.data.fd, &child_handle);\n         if (err) {\n-          /* If fdopt.data.fd is not valid and fd fd <= 2, then ignore the */\n-          /* error. */\n+          /* If fdopt. data. fd is not valid and fd <= 2, then ignore the\n+           * error. */\n           if (fdopt.data.fd <= 2 && err == ERROR_INVALID_HANDLE) {\n             CHILD_STDIO_CRT_FLAGS(buffer, i) = 0;\n             CHILD_STDIO_HANDLE(buffer, i) = INVALID_HANDLE_VALUE;\n@@ -418,8 +418,8 @@ int uv__stdio_create(uv_loop_t* loop,\n \n         if (stream_handle == NULL ||\n             stream_handle == INVALID_HANDLE_VALUE) {\n-          /* The handle is already closed, or not yet created, or the */\n-          /* stream type is not supported. */\n+          /* The handle is already closed, or not yet created, or the stream\n+           * type is not supported. */\n           err = ERROR_NOT_SUPPORTED;\n           goto error;\n         }"
        },
        {
            "sha": "08910088e47ee1fcbea2a32076f7245ca2ad26fd",
            "filename": "deps/uv/src/win/process.c",
            "status": "modified",
            "additions": 28,
            "deletions": 23,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fprocess.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fprocess.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fprocess.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -360,8 +360,8 @@ static WCHAR* search_path(const WCHAR *file,\n     return NULL;\n   }\n \n-  /* Find the start of the filename so we can split the directory from the */\n-  /* name. */\n+  /* Find the start of the filename so we can split the directory from the\n+   * name. */\n   for (file_name_start = (WCHAR*)file + file_len;\n        file_name_start > file\n            && file_name_start[-1] != L'\\\\'\n@@ -556,8 +556,8 @@ int make_program_args(char** args, int verbatim_arguments, WCHAR** dst_ptr) {\n     arg_count++;\n   }\n \n-  /* Adjust for potential quotes. Also assume the worst-case scenario */\n-  /* that every character needs escaping, so we need twice as much space. */\n+  /* Adjust for potential quotes. Also assume the worst-case scenario that\n+   * every character needs escaping, so we need twice as much space. */\n   dst_len = dst_len * 2 + arg_count * 2;\n \n   /* Allocate buffer for the final command line. */\n@@ -831,8 +831,13 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {\n  */\n static WCHAR* find_path(WCHAR *env) {\n   for (; env != NULL && *env != 0; env += wcslen(env) + 1) {\n-    if (wcsncmp(env, L\"PATH=\", 5) == 0)\n+    if ((env[0] == L'P' || env[0] == L'p') &&\n+        (env[1] == L'A' || env[1] == L'a') &&\n+        (env[2] == L'T' || env[2] == L't') &&\n+        (env[3] == L'H' || env[3] == L'h') &&\n+        (env[4] == L'=')) {\n       return &env[5];\n+    }\n   }\n \n   return NULL;\n@@ -865,8 +870,8 @@ void uv_process_proc_exit(uv_loop_t* loop, uv_process_t* handle) {\n   assert(handle->exit_cb_pending);\n   handle->exit_cb_pending = 0;\n \n-  /* If we're closing, don't call the exit callback. Just schedule a close */\n-  /* callback now. */\n+  /* If we're closing, don't call the exit callback. Just schedule a close\n+   * callback now. */\n   if (handle->flags & UV__HANDLE_CLOSING) {\n     uv_want_endgame(loop, (uv_handle_t*) handle);\n     return;\n@@ -878,14 +883,14 @@ void uv_process_proc_exit(uv_loop_t* loop, uv_process_t* handle) {\n     handle->wait_handle = INVALID_HANDLE_VALUE;\n   }\n \n-  /* Set the handle to inactive: no callbacks will be made after the exit */\n-  /* callback.*/\n+  /* Set the handle to inactive: no callbacks will be made after the exit\n+   * callback. */\n   uv__handle_stop(handle);\n \n   if (GetExitCodeProcess(handle->process_handle, &status)) {\n     exit_code = status;\n   } else {\n-    /* Unable to to obtain the exit code. This should never happen. */\n+    /* Unable to obtain the exit code. This should never happen. */\n     exit_code = uv_translate_sys_error(GetLastError());\n   }\n \n@@ -900,8 +905,8 @@ void uv_process_close(uv_loop_t* loop, uv_process_t* handle) {\n   uv__handle_closing(handle);\n \n   if (handle->wait_handle != INVALID_HANDLE_VALUE) {\n-    /* This blocks until either the wait was cancelled, or the callback has */\n-    /* completed. */\n+    /* This blocks until either the wait was cancelled, or the callback has\n+     * completed. */\n     BOOL r = UnregisterWaitEx(handle->wait_handle, INVALID_HANDLE_VALUE);\n     if (!r) {\n       /* This should never happen, and if it happens, we can't recover... */\n@@ -1104,14 +1109,13 @@ int uv_spawn(uv_loop_t* loop,\n     goto done;\n   }\n \n-  /* Spawn succeeded */\n-  /* Beyond this point, failure is reported asynchronously. */\n+  /* Spawn succeeded. Beyond this point, failure is reported asynchronously. */\n \n   process->process_handle = info.hProcess;\n   process->pid = info.dwProcessId;\n \n-  /* If the process isn't spawned as detached, assign to the global job */\n-  /* object so windows will kill it when the parent process dies. */\n+  /* If the process isn't spawned as detached, assign to the global job object\n+   * so windows will kill it when the parent process dies. */\n   if (!(options->flags & UV_PROCESS_DETACHED)) {\n     uv_once(&uv_global_job_handle_init_guard_, uv__init_global_job_handle);\n \n@@ -1138,7 +1142,8 @@ int uv_spawn(uv_loop_t* loop,\n     if (fdopt->flags & UV_CREATE_PIPE &&\n         fdopt->data.stream->type == UV_NAMED_PIPE &&\n         ((uv_pipe_t*) fdopt->data.stream)->ipc) {\n-      ((uv_pipe_t*) fdopt->data.stream)->pipe.conn.ipc_pid = info.dwProcessId;\n+      ((uv_pipe_t*) fdopt->data.stream)->pipe.conn.ipc_remote_pid =\n+          info.dwProcessId;\n     }\n   }\n \n@@ -1154,8 +1159,8 @@ int uv_spawn(uv_loop_t* loop,\n \n   assert(!err);\n \n-  /* Make the handle active. It will remain active until the exit callback */\n-  /* is made or the handle is closed, whichever happens first. */\n+  /* Make the handle active. It will remain active until the exit callback is\n+   * made or the handle is closed, whichever happens first. */\n   uv__handle_start(process);\n \n   /* Cleanup, whether we succeeded or failed. */\n@@ -1186,16 +1191,16 @@ static int uv__kill(HANDLE process_handle, int signum) {\n     case SIGTERM:\n     case SIGKILL:\n     case SIGINT: {\n-      /* Unconditionally terminate the process. On Windows, killed processes */\n-      /* normally return 1. */\n+      /* Unconditionally terminate the process. On Windows, killed processes\n+       * normally return 1. */\n       DWORD status;\n       int err;\n \n       if (TerminateProcess(process_handle, 1))\n         return 0;\n \n-      /* If the process already exited before TerminateProcess was called, */\n-      /* TerminateProcess will fail with ERROR_ACCESS_DENIED. */\n+      /* If the process already exited before TerminateProcess was called,.\n+       * TerminateProcess will fail with ERROR_ACCESS_DENIED. */\n       err = GetLastError();\n       if (err == ERROR_ACCESS_DENIED &&\n           GetExitCodeProcess(process_handle, &status) &&"
        },
        {
            "sha": "750c1b36ef88bc901e298ace1c415aa4a62b1331",
            "filename": "deps/uv/src/win/signal.c",
            "status": "modified",
            "additions": 17,
            "deletions": 17,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fsignal.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fsignal.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fsignal.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -47,13 +47,13 @@ void uv_signals_init(void) {\n \n \n static int uv__signal_compare(uv_signal_t* w1, uv_signal_t* w2) {\n-  /* Compare signums first so all watchers with the same signnum end up */\n-  /* adjacent. */\n+  /* Compare signums first so all watchers with the same signnum end up\n+   * adjacent. */\n   if (w1->signum < w2->signum) return -1;\n   if (w1->signum > w2->signum) return 1;\n \n-  /* Sort by loop pointer, so we can easily look up the first item after */\n-  /* { .signum = x, .loop = NULL } */\n+  /* Sort by loop pointer, so we can easily look up the first item after\n+   * { .signum = x, .loop = NULL }. */\n   if ((uintptr_t) w1->loop < (uintptr_t) w2->loop) return -1;\n   if ((uintptr_t) w1->loop > (uintptr_t) w2->loop) return 1;\n \n@@ -118,19 +118,19 @@ static BOOL WINAPI uv__signal_control_handler(DWORD type) {\n \n     case CTRL_CLOSE_EVENT:\n       if (uv__signal_dispatch(SIGHUP)) {\n-        /* Windows will terminate the process after the control handler */\n-        /* returns. After that it will just terminate our process. Therefore */\n-        /* block the signal handler so the main loop has some time to pick */\n-        /* up the signal and do something for a few seconds. */\n+        /* Windows will terminate the process after the control handler\n+         * returns. After that it will just terminate our process. Therefore\n+         * block the signal handler so the main loop has some time to pick up\n+         * the signal and do something for a few seconds. */\n         Sleep(INFINITE);\n         return TRUE;\n       }\n       return FALSE;\n \n     case CTRL_LOGOFF_EVENT:\n     case CTRL_SHUTDOWN_EVENT:\n-      /* These signals are only sent to services. Services have their own */\n-      /* notification mechanism, so there's no point in handling these. */\n+      /* These signals are only sent to services. Services have their own\n+       * notification mechanism, so there's no point in handling these. */\n \n     default:\n       /* We don't handle these. */\n@@ -193,10 +193,10 @@ int uv__signal_start(uv_signal_t* handle,\n   if (signum != SIGWINCH && (signum <= 0 || signum >= NSIG))\n     return UV_EINVAL;\n \n-  /* Short circuit: if the signal watcher is already watching {signum} don't */\n-  /* go through the process of deregistering and registering the handler. */\n-  /* Additionally, this avoids pending signals getting lost in the (small) */\n-  /* time frame that handle->signum == 0. */\n+  /* Short circuit: if the signal watcher is already watching {signum} don't go\n+   * through the process of deregistering and registering the handler.\n+   * Additionally, this avoids pending signals getting lost in the (small) time\n+   * frame that handle->signum == 0. */\n   if (signum == handle->signum) {\n     handle->signal_cb = signal_cb;\n     return 0;\n@@ -237,9 +237,9 @@ void uv_process_signal_req(uv_loop_t* loop, uv_signal_t* handle,\n           (volatile LONG*) &handle->pending_signum, 0);\n   assert(dispatched_signum != 0);\n \n-  /* Check if the pending signal equals the signum that we are watching for. */\n-  /* These can get out of sync when the handler is stopped and restarted */\n-  /* while the signal_req is pending. */\n+  /* Check if the pending signal equals the signum that we are watching for.\n+   * These can get out of sync when the handler is stopped and restarted while\n+   * the signal_req is pending. */\n   if (dispatched_signum == handle->signum)\n     handle->signal_cb(handle, dispatched_signum);\n "
        },
        {
            "sha": "3273a03c1cee4fad98ff5dce6ba457f62a765a7d",
            "filename": "deps/uv/src/win/stream.c",
            "status": "modified",
            "additions": 13,
            "deletions": 21,
            "changes": 34,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fstream.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fstream.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fstream.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -105,12 +105,10 @@ int uv_read_stop(uv_stream_t* handle) {\n   err = 0;\n   if (handle->type == UV_TTY) {\n     err = uv_tty_read_stop((uv_tty_t*) handle);\n+  } else if (handle->type == UV_NAMED_PIPE) {\n+    uv__pipe_read_stop((uv_pipe_t*) handle);\n   } else {\n-    if (handle->type == UV_NAMED_PIPE) {\n-      uv__pipe_stop_read((uv_pipe_t*) handle);\n-    } else {\n-      handle->flags &= ~UV_HANDLE_READING;\n-    }\n+    handle->flags &= ~UV_HANDLE_READING;\n     DECREASE_ACTIVE_COUNT(handle->loop, handle);\n   }\n \n@@ -136,7 +134,8 @@ int uv_write(uv_write_t* req,\n       err = uv_tcp_write(loop, req, (uv_tcp_t*) handle, bufs, nbufs, cb);\n       break;\n     case UV_NAMED_PIPE:\n-      err = uv_pipe_write(loop, req, (uv_pipe_t*) handle, bufs, nbufs, cb);\n+      err = uv__pipe_write(\n+          loop, req, (uv_pipe_t*) handle, bufs, nbufs, NULL, cb);\n       break;\n     case UV_TTY:\n       err = uv_tty_write(loop, req, (uv_tty_t*) handle, bufs, nbufs, cb);\n@@ -158,25 +157,18 @@ int uv_write2(uv_write_t* req,\n   uv_loop_t* loop = handle->loop;\n   int err;\n \n-  if (!(handle->flags & UV_HANDLE_WRITABLE)) {\n-    return UV_EPIPE;\n+  if (send_handle == NULL) {\n+    return uv_write(req, handle, bufs, nbufs, cb);\n   }\n \n-  err = ERROR_INVALID_PARAMETER;\n-  switch (handle->type) {\n-    case UV_NAMED_PIPE:\n-      err = uv_pipe_write2(loop,\n-                           req,\n-                           (uv_pipe_t*) handle,\n-                           bufs,\n-                           nbufs,\n-                           send_handle,\n-                           cb);\n-      break;\n-    default:\n-      assert(0);\n+  if (handle->type != UV_NAMED_PIPE || !((uv_pipe_t*) handle)->ipc) {\n+    return UV_EINVAL;\n+  } else if (!(handle->flags & UV_HANDLE_WRITABLE)) {\n+    return UV_EPIPE;\n   }\n \n+  err = uv__pipe_write(\n+      loop, req, (uv_pipe_t*) handle, bufs, nbufs, send_handle, cb);\n   return uv_translate_sys_error(err);\n }\n "
        },
        {
            "sha": "38cd73e0d12dc352e422419b994b1895ca9d2f8a",
            "filename": "deps/uv/src/win/tcp.c",
            "status": "modified",
            "additions": 86,
            "deletions": 97,
            "changes": 183,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Ftcp.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Ftcp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ftcp.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -99,8 +99,8 @@ static int uv_tcp_set_socket(uv_loop_t* loop,\n   if (!SetHandleInformation((HANDLE) socket, HANDLE_FLAG_INHERIT, 0))\n     return GetLastError();\n \n-  /* Associate it with the I/O completion port. */\n-  /* Use uv_handle_t pointer as completion key. */\n+  /* Associate it with the I/O completion port. Use uv_handle_t pointer as\n+   * completion key. */\n   if (CreateIoCompletionPort((HANDLE)socket,\n                              loop->iocp,\n                              (ULONG_PTR)socket,\n@@ -118,15 +118,12 @@ static int uv_tcp_set_socket(uv_loop_t* loop,\n     non_ifs_lsp = uv_tcp_non_ifs_lsp_ipv4;\n   }\n \n-  if (pSetFileCompletionNotificationModes &&\n-      !(handle->flags & UV_HANDLE_EMULATE_IOCP) && !non_ifs_lsp) {\n-    if (pSetFileCompletionNotificationModes((HANDLE) socket,\n-        FILE_SKIP_SET_EVENT_ON_HANDLE |\n-        FILE_SKIP_COMPLETION_PORT_ON_SUCCESS)) {\n-      handle->flags |= UV_HANDLE_SYNC_BYPASS_IOCP;\n-    } else if (GetLastError() != ERROR_INVALID_FUNCTION) {\n+  if (!(handle->flags & UV_HANDLE_EMULATE_IOCP) && !non_ifs_lsp) {\n+    UCHAR sfcnm_flags =\n+        FILE_SKIP_SET_EVENT_ON_HANDLE | FILE_SKIP_COMPLETION_PORT_ON_SUCCESS;\n+    if (!SetFileCompletionNotificationModes((HANDLE) socket, sfcnm_flags))\n       return GetLastError();\n-    }\n+    handle->flags |= UV_HANDLE_SYNC_BYPASS_IOCP;\n   }\n \n   if (handle->flags & UV_HANDLE_TCP_NODELAY) {\n@@ -326,9 +323,9 @@ static int uv_tcp_try_bind(uv_tcp_t* handle,\n \n     on = (flags & UV_TCP_IPV6ONLY) != 0;\n \n-    /* TODO: how to handle errors? This may fail if there is no ipv4 stack */\n-    /* available, or when run on XP/2003 which have no support for dualstack */\n-    /* sockets. For now we're silently ignoring the error. */\n+    /* TODO: how to handle errors? This may fail if there is no ipv4 stack\n+     * available, or when run on XP/2003 which have no support for dualstack\n+     * sockets. For now we're silently ignoring the error. */\n     setsockopt(handle->socket,\n                IPPROTO_IPV6,\n                IPV6_V6ONLY,\n@@ -626,9 +623,9 @@ int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb) {\n       uv_tcp_queue_accept(handle, req);\n     }\n \n-    /* Initialize other unused requests too, because uv_tcp_endgame */\n-    /* doesn't know how how many requests were initialized, so it will */\n-    /* try to clean up {uv_simultaneous_server_accepts} requests. */\n+    /* Initialize other unused requests too, because uv_tcp_endgame doesn't\n+     * know how many requests were initialized, so it will try to clean up\n+     * {uv_simultaneous_server_accepts} requests. */\n     for (i = simultaneous_accepts; i < uv_simultaneous_server_accepts; i++) {\n       req = &handle->tcp.serv.accept_reqs[i];\n       UV_REQ_INIT(req, UV_ACCEPT);\n@@ -721,8 +718,8 @@ int uv_tcp_read_start(uv_tcp_t* handle, uv_alloc_cb alloc_cb,\n   handle->alloc_cb = alloc_cb;\n   INCREASE_ACTIVE_COUNT(loop, handle);\n \n-  /* If reading was stopped and then started again, there could still be a */\n-  /* read request pending. */\n+  /* If reading was stopped and then started again, there could still be a read\n+   * request pending. */\n   if (!(handle->flags & UV_HANDLE_READ_PENDING)) {\n     if (handle->flags & UV_HANDLE_EMULATE_IOCP &&\n         !handle->read_req.event_handle) {\n@@ -965,8 +962,7 @@ void uv_process_tcp_read_req(uv_loop_t* loop, uv_tcp_t* handle,\n       err = GET_REQ_SOCK_ERROR(req);\n \n       if (err == WSAECONNABORTED) {\n-        /*\n-         * Turn WSAECONNABORTED into UV_ECONNRESET to be consistent with Unix.\n+        /* Turn WSAECONNABORTED into UV_ECONNRESET to be consistent with Unix.\n          */\n         err = WSAECONNRESET;\n       }\n@@ -1046,8 +1042,8 @@ void uv_process_tcp_read_req(uv_loop_t* loop, uv_tcp_t* handle,\n           DECREASE_ACTIVE_COUNT(loop, handle);\n \n           if (err == WSAECONNABORTED) {\n-            /* Turn WSAECONNABORTED into UV_ECONNRESET to be consistent with */\n-            /* Unix. */\n+            /* Turn WSAECONNABORTED into UV_ECONNRESET to be consistent with\n+             * Unix. */\n             err = WSAECONNRESET;\n           }\n \n@@ -1119,10 +1115,9 @@ void uv_process_tcp_accept_req(uv_loop_t* loop, uv_tcp_t* handle,\n \n   assert(handle->type == UV_TCP);\n \n-  /* If handle->accepted_socket is not a valid socket, then */\n-  /* uv_queue_accept must have failed. This is a serious error. We stop */\n-  /* accepting connections and report this error to the connection */\n-  /* callback. */\n+  /* If handle->accepted_socket is not a valid socket, then uv_queue_accept\n+   * must have failed. This is a serious error. We stop accepting connections\n+   * and report this error to the connection callback. */\n   if (req->accept_socket == INVALID_SOCKET) {\n     if (handle->flags & UV_HANDLE_LISTENING) {\n       handle->flags &= ~UV_HANDLE_LISTENING;\n@@ -1147,9 +1142,9 @@ void uv_process_tcp_accept_req(uv_loop_t* loop, uv_tcp_t* handle,\n       handle->stream.serv.connection_cb((uv_stream_t*)handle, 0);\n     }\n   } else {\n-    /* Error related to accepted socket is ignored because the server */\n-    /* socket may still be healthy. If the server socket is broken */\n-    /* uv_queue_accept will detect it. */\n+    /* Error related to accepted socket is ignored because the server socket\n+     * may still be healthy. If the server socket is broken uv_queue_accept\n+     * will detect it. */\n     closesocket(req->accept_socket);\n     req->accept_socket = INVALID_SOCKET;\n     if (handle->flags & UV_HANDLE_LISTENING) {\n@@ -1194,40 +1189,68 @@ void uv_process_tcp_connect_req(uv_loop_t* loop, uv_tcp_t* handle,\n }\n \n \n-int uv_tcp_import(uv_tcp_t* tcp, uv__ipc_socket_info_ex* socket_info_ex,\n-    int tcp_connection) {\n+int uv__tcp_xfer_export(uv_tcp_t* handle,\n+                        int target_pid,\n+                        uv__ipc_socket_xfer_info_t* xfer_info) {\n+  if (!(handle->flags & UV_HANDLE_CONNECTION)) {\n+    /* We're about to share the socket with another process. Because this is a\n+     * listening socket, we assume that the other process will be accepting\n+     * connections on it. Thus, before sharing the socket with another process,\n+     * we call listen here in the parent process. */\n+    if (!(handle->flags & UV_HANDLE_LISTENING)) {\n+      if (!(handle->flags & UV_HANDLE_BOUND)) {\n+        return ERROR_NOT_SUPPORTED;\n+      }\n+      if (handle->delayed_error == 0 &&\n+          listen(handle->socket, SOMAXCONN) == SOCKET_ERROR) {\n+        handle->delayed_error = WSAGetLastError();\n+      }\n+    }\n+  }\n+\n+  if (WSADuplicateSocketW(\n+          handle->socket, target_pid, &xfer_info->socket_info)) {\n+    return WSAGetLastError();\n+  }\n+  xfer_info->delayed_error = handle->delayed_error;\n+  xfer_info->flags = handle->flags & UV_HANDLE_CONNECTION;\n+\n+  /* Mark the local copy of the handle as 'shared' so we behave in a way that's\n+   * friendly to the process(es) that we share the socket with. */\n+  handle->flags |= UV_HANDLE_SHARED_TCP_SOCKET;\n+\n+  return 0;\n+}\n+\n+\n+int uv__tcp_xfer_import(uv_tcp_t* tcp, uv__ipc_socket_xfer_info_t* xfer_info) {\n   int err;\n   SOCKET socket = WSASocketW(FROM_PROTOCOL_INFO,\n                              FROM_PROTOCOL_INFO,\n                              FROM_PROTOCOL_INFO,\n-                             &socket_info_ex->socket_info,\n+                             &xfer_info->socket_info,\n                              0,\n                              WSA_FLAG_OVERLAPPED);\n \n   if (socket == INVALID_SOCKET) {\n     return WSAGetLastError();\n   }\n \n-  err = uv_tcp_set_socket(tcp->loop,\n-                          tcp,\n-                          socket,\n-                          socket_info_ex->socket_info.iAddressFamily,\n-                          1);\n+  err = uv_tcp_set_socket(\n+      tcp->loop, tcp, socket, xfer_info->socket_info.iAddressFamily, 1);\n   if (err) {\n     closesocket(socket);\n     return err;\n   }\n \n-  if (tcp_connection) {\n+  tcp->delayed_error = xfer_info->delayed_error;\n+  tcp->flags |= UV_HANDLE_BOUND | UV_HANDLE_SHARED_TCP_SOCKET;\n+\n+  if (xfer_info->flags & UV_HANDLE_CONNECTION) {\n     uv_connection_init((uv_stream_t*)tcp);\n     tcp->flags |= UV_HANDLE_READABLE | UV_HANDLE_WRITABLE;\n   }\n \n-  tcp->flags |= UV_HANDLE_BOUND;\n-  tcp->flags |= UV_HANDLE_SHARED_TCP_SOCKET;\n-\n-  tcp->delayed_error = socket_info_ex->delayed_error;\n-\n   tcp->loop->active_tcp_streams++;\n   return 0;\n }\n@@ -1273,39 +1296,6 @@ int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) {\n }\n \n \n-int uv_tcp_duplicate_socket(uv_tcp_t* handle, int pid,\n-    LPWSAPROTOCOL_INFOW protocol_info) {\n-  if (!(handle->flags & UV_HANDLE_CONNECTION)) {\n-    /*\n-     * We're about to share the socket with another process.  Because\n-     * this is a listening socket, we assume that the other process will\n-     * be accepting connections on it.  So, before sharing the socket\n-     * with another process, we call listen here in the parent process.\n-     */\n-\n-    if (!(handle->flags & UV_HANDLE_LISTENING)) {\n-      if (!(handle->flags & UV_HANDLE_BOUND)) {\n-        return ERROR_INVALID_PARAMETER;\n-      }\n-\n-      if (!(handle->delayed_error)) {\n-        if (listen(handle->socket, SOMAXCONN) == SOCKET_ERROR) {\n-          handle->delayed_error = WSAGetLastError();\n-        }\n-      }\n-    }\n-  }\n-\n-  if (WSADuplicateSocketW(handle->socket, pid, protocol_info)) {\n-    return WSAGetLastError();\n-  }\n-\n-  handle->flags |= UV_HANDLE_SHARED_TCP_SOCKET;\n-\n-  return 0;\n-}\n-\n-\n int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable) {\n   if (handle->flags & UV_HANDLE_CONNECTION) {\n     return UV_EINVAL;\n@@ -1346,8 +1336,8 @@ static int uv_tcp_try_cancel_io(uv_tcp_t* tcp) {\n   non_ifs_lsp = (tcp->flags & UV_HANDLE_IPV6) ? uv_tcp_non_ifs_lsp_ipv6 :\n                                                 uv_tcp_non_ifs_lsp_ipv4;\n \n-  /* If there are non-ifs LSPs then try to obtain a base handle for the */\n-  /* socket. This will always fail on Windows XP/3k. */\n+  /* If there are non-ifs LSPs then try to obtain a base handle for the socket.\n+   * This will always fail on Windows XP/3k. */\n   if (non_ifs_lsp) {\n     DWORD bytes;\n     if (WSAIoctl(socket,\n@@ -1379,38 +1369,37 @@ void uv_tcp_close(uv_loop_t* loop, uv_tcp_t* tcp) {\n   int close_socket = 1;\n \n   if (tcp->flags & UV_HANDLE_READ_PENDING) {\n-    /* In order for winsock to do a graceful close there must not be any */\n-    /* any pending reads, or the socket must be shut down for writing */\n+    /* In order for winsock to do a graceful close there must not be any any\n+     * pending reads, or the socket must be shut down for writing */\n     if (!(tcp->flags & UV_HANDLE_SHARED_TCP_SOCKET)) {\n       /* Just do shutdown on non-shared sockets, which ensures graceful close. */\n       shutdown(tcp->socket, SD_SEND);\n \n     } else if (uv_tcp_try_cancel_io(tcp) == 0) {\n-      /* In case of a shared socket, we try to cancel all outstanding I/O, */\n-      /* If that works, don't close the socket yet - wait for the read req to */\n-      /* return and close the socket in uv_tcp_endgame. */\n+      /* In case of a shared socket, we try to cancel all outstanding I/O,. If\n+       * that works, don't close the socket yet - wait for the read req to\n+       * return and close the socket in uv_tcp_endgame. */\n       close_socket = 0;\n \n     } else {\n-      /* When cancelling isn't possible - which could happen when an LSP is */\n-      /* present on an old Windows version, we will have to close the socket */\n-      /* with a read pending. That is not nice because trailing sent bytes */\n-      /* may not make it to the other side. */\n+      /* When cancelling isn't possible - which could happen when an LSP is\n+       * present on an old Windows version, we will have to close the socket\n+       * with a read pending. That is not nice because trailing sent bytes may\n+       * not make it to the other side. */\n     }\n \n   } else if ((tcp->flags & UV_HANDLE_SHARED_TCP_SOCKET) &&\n              tcp->tcp.serv.accept_reqs != NULL) {\n-    /* Under normal circumstances closesocket() will ensure that all pending */\n-    /* accept reqs are canceled. However, when the socket is shared the */\n-    /* presence of another reference to the socket in another process will */\n-    /* keep the accept reqs going, so we have to ensure that these are */\n-    /* canceled. */\n+    /* Under normal circumstances closesocket() will ensure that all pending\n+     * accept reqs are canceled. However, when the socket is shared the\n+     * presence of another reference to the socket in another process will keep\n+     * the accept reqs going, so we have to ensure that these are canceled. */\n     if (uv_tcp_try_cancel_io(tcp) != 0) {\n-      /* When cancellation is not possible, there is another option: we can */\n-      /* close the incoming sockets, which will also cancel the accept */\n-      /* operations. However this is not cool because we might inadvertently */\n-      /* close a socket that just accepted a new connection, which will */\n-      /* cause the connection to be aborted. */\n+      /* When cancellation is not possible, there is another option: we can\n+       * close the incoming sockets, which will also cancel the accept\n+       * operations. However this is not cool because we might inadvertently\n+       * close a socket that just accepted a new connection, which will cause\n+       * the connection to be aborted. */\n       unsigned int i;\n       for (i = 0; i < uv_simultaneous_server_accepts; i++) {\n         uv_tcp_accept_t* req = &tcp->tcp.serv.accept_reqs[i];"
        },
        {
            "sha": "3342fd759435ef60d4f83a315b4d80c1049d5fdb",
            "filename": "deps/uv/src/win/thread.c",
            "status": "modified",
            "additions": 12,
            "deletions": 217,
            "changes": 229,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fthread.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fthread.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fthread.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -26,17 +26,6 @@\n #include \"uv.h\"\n #include \"internal.h\"\n \n-\n-#define HAVE_CONDVAR_API() (pInitializeConditionVariable != NULL)\n-\n-static int uv_cond_fallback_init(uv_cond_t* cond);\n-static void uv_cond_fallback_destroy(uv_cond_t* cond);\n-static void uv_cond_fallback_signal(uv_cond_t* cond);\n-static void uv_cond_fallback_broadcast(uv_cond_t* cond);\n-static void uv_cond_fallback_wait(uv_cond_t* cond, uv_mutex_t* mutex);\n-static int uv_cond_fallback_timedwait(uv_cond_t* cond,\n-    uv_mutex_t* mutex, uint64_t timeout);\n-\n static int uv_cond_condvar_init(uv_cond_t* cond);\n static void uv_cond_condvar_destroy(uv_cond_t* cond);\n static void uv_cond_condvar_signal(uv_cond_t* cond);\n@@ -69,8 +58,8 @@ static void uv__once_inner(uv_once_t* guard, void (*callback)(void)) {\n     guard->ran = 1;\n \n   } else {\n-    /* We lost the race. Destroy the event we created and wait for the */\n-    /* existing one to become signaled. */\n+    /* We lost the race. Destroy the event we created and wait for the existing\n+     * one to become signaled. */\n     CloseHandle(created_event);\n     result = WaitForSingleObject(existing_event, INFINITE);\n     assert(result == WAIT_OBJECT_0);\n@@ -377,236 +366,42 @@ int uv_sem_trywait(uv_sem_t* sem) {\n }\n \n \n-/* This condition variable implementation is based on the SetEvent solution\n- * (section 3.2) at http://www.cs.wustl.edu/~schmidt/win32-cv-1.html\n- * We could not use the SignalObjectAndWait solution (section 3.4) because\n- * it want the 2nd argument (type uv_mutex_t) of uv_cond_wait() and\n- * uv_cond_timedwait() to be HANDLEs, but we use CRITICAL_SECTIONs.\n- */\n-\n-static int uv_cond_fallback_init(uv_cond_t* cond) {\n-  int err;\n-\n-  /* Initialize the count to 0. */\n-  cond->fallback.waiters_count = 0;\n-\n-  InitializeCriticalSection(&cond->fallback.waiters_count_lock);\n-\n-  /* Create an auto-reset event. */\n-  cond->fallback.signal_event = CreateEvent(NULL,  /* no security */\n-                                            FALSE, /* auto-reset event */\n-                                            FALSE, /* non-signaled initially */\n-                                            NULL); /* unnamed */\n-  if (!cond->fallback.signal_event) {\n-    err = GetLastError();\n-    goto error2;\n-  }\n-\n-  /* Create a manual-reset event. */\n-  cond->fallback.broadcast_event = CreateEvent(NULL,  /* no security */\n-                                               TRUE,  /* manual-reset */\n-                                               FALSE, /* non-signaled */\n-                                               NULL); /* unnamed */\n-  if (!cond->fallback.broadcast_event) {\n-    err = GetLastError();\n-    goto error;\n-  }\n-\n-  return 0;\n-\n-error:\n-  CloseHandle(cond->fallback.signal_event);\n-error2:\n-  DeleteCriticalSection(&cond->fallback.waiters_count_lock);\n-  return uv_translate_sys_error(err);\n-}\n-\n-\n-static int uv_cond_condvar_init(uv_cond_t* cond) {\n-  pInitializeConditionVariable(&cond->cond_var);\n-  return 0;\n-}\n-\n-\n int uv_cond_init(uv_cond_t* cond) {\n-  uv__once_init();\n-\n-  if (HAVE_CONDVAR_API())\n-    return uv_cond_condvar_init(cond);\n-  else\n-    return uv_cond_fallback_init(cond);\n-}\n-\n-\n-static void uv_cond_fallback_destroy(uv_cond_t* cond) {\n-  if (!CloseHandle(cond->fallback.broadcast_event))\n-    abort();\n-  if (!CloseHandle(cond->fallback.signal_event))\n-    abort();\n-  DeleteCriticalSection(&cond->fallback.waiters_count_lock);\n-}\n-\n-\n-static void uv_cond_condvar_destroy(uv_cond_t* cond) {\n-  /* nothing to do */\n+  InitializeConditionVariable(&cond->cond_var);\n+  return 0;\n }\n \n \n void uv_cond_destroy(uv_cond_t* cond) {\n-  if (HAVE_CONDVAR_API())\n-    uv_cond_condvar_destroy(cond);\n-  else\n-    uv_cond_fallback_destroy(cond);\n-}\n-\n-\n-static void uv_cond_fallback_signal(uv_cond_t* cond) {\n-  int have_waiters;\n-\n-  /* Avoid race conditions. */\n-  EnterCriticalSection(&cond->fallback.waiters_count_lock);\n-  have_waiters = cond->fallback.waiters_count > 0;\n-  LeaveCriticalSection(&cond->fallback.waiters_count_lock);\n-\n-  if (have_waiters)\n-    SetEvent(cond->fallback.signal_event);\n-}\n-\n-\n-static void uv_cond_condvar_signal(uv_cond_t* cond) {\n-  pWakeConditionVariable(&cond->cond_var);\n+  /* nothing to do */\n+  UV__UNUSED(cond);\n }\n \n \n void uv_cond_signal(uv_cond_t* cond) {\n-  if (HAVE_CONDVAR_API())\n-    uv_cond_condvar_signal(cond);\n-  else\n-    uv_cond_fallback_signal(cond);\n-}\n-\n-\n-static void uv_cond_fallback_broadcast(uv_cond_t* cond) {\n-  int have_waiters;\n-\n-  /* Avoid race conditions. */\n-  EnterCriticalSection(&cond->fallback.waiters_count_lock);\n-  have_waiters = cond->fallback.waiters_count > 0;\n-  LeaveCriticalSection(&cond->fallback.waiters_count_lock);\n-\n-  if (have_waiters)\n-    SetEvent(cond->fallback.broadcast_event);\n-}\n-\n-\n-static void uv_cond_condvar_broadcast(uv_cond_t* cond) {\n-  pWakeAllConditionVariable(&cond->cond_var);\n+  WakeConditionVariable(&cond->cond_var);\n }\n \n \n void uv_cond_broadcast(uv_cond_t* cond) {\n-  if (HAVE_CONDVAR_API())\n-    uv_cond_condvar_broadcast(cond);\n-  else\n-    uv_cond_fallback_broadcast(cond);\n-}\n-\n-\n-static int uv_cond_wait_helper(uv_cond_t* cond, uv_mutex_t* mutex,\n-    DWORD dwMilliseconds) {\n-  DWORD result;\n-  int last_waiter;\n-  HANDLE handles[2] = {\n-    cond->fallback.signal_event,\n-    cond->fallback.broadcast_event\n-  };\n-\n-  /* Avoid race conditions. */\n-  EnterCriticalSection(&cond->fallback.waiters_count_lock);\n-  cond->fallback.waiters_count++;\n-  LeaveCriticalSection(&cond->fallback.waiters_count_lock);\n-\n-  /* It's ok to release the <mutex> here since Win32 manual-reset events */\n-  /* maintain state when used with <SetEvent>. This avoids the \"lost wakeup\" */\n-  /* bug. */\n-  uv_mutex_unlock(mutex);\n-\n-  /* Wait for either event to become signaled due to <uv_cond_signal> being */\n-  /* called or <uv_cond_broadcast> being called. */\n-  result = WaitForMultipleObjects(2, handles, FALSE, dwMilliseconds);\n-\n-  EnterCriticalSection(&cond->fallback.waiters_count_lock);\n-  cond->fallback.waiters_count--;\n-  last_waiter = result == WAIT_OBJECT_0 + 1\n-      && cond->fallback.waiters_count == 0;\n-  LeaveCriticalSection(&cond->fallback.waiters_count_lock);\n-\n-  /* Some thread called <pthread_cond_broadcast>. */\n-  if (last_waiter) {\n-    /* We're the last waiter to be notified or to stop waiting, so reset the */\n-    /* the manual-reset event. */\n-    ResetEvent(cond->fallback.broadcast_event);\n-  }\n-\n-  /* Reacquire the <mutex>. */\n-  uv_mutex_lock(mutex);\n-\n-  if (result == WAIT_OBJECT_0 || result == WAIT_OBJECT_0 + 1)\n-    return 0;\n-\n-  if (result == WAIT_TIMEOUT)\n-    return UV_ETIMEDOUT;\n-\n-  abort();\n-  return -1; /* Satisfy the compiler. */\n-}\n-\n-\n-static void uv_cond_fallback_wait(uv_cond_t* cond, uv_mutex_t* mutex) {\n-  if (uv_cond_wait_helper(cond, mutex, INFINITE))\n-    abort();\n-}\n-\n-\n-static void uv_cond_condvar_wait(uv_cond_t* cond, uv_mutex_t* mutex) {\n-  if (!pSleepConditionVariableCS(&cond->cond_var, mutex, INFINITE))\n-    abort();\n+  WakeAllConditionVariable(&cond->cond_var);\n }\n \n \n void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex) {\n-  if (HAVE_CONDVAR_API())\n-    uv_cond_condvar_wait(cond, mutex);\n-  else\n-    uv_cond_fallback_wait(cond, mutex);\n-}\n-\n-\n-static int uv_cond_fallback_timedwait(uv_cond_t* cond,\n-    uv_mutex_t* mutex, uint64_t timeout) {\n-  return uv_cond_wait_helper(cond, mutex, (DWORD)(timeout / 1e6));\n+  if (!SleepConditionVariableCS(&cond->cond_var, mutex, INFINITE))\n+    abort();\n }\n \n-\n-static int uv_cond_condvar_timedwait(uv_cond_t* cond,\n-    uv_mutex_t* mutex, uint64_t timeout) {\n-  if (pSleepConditionVariableCS(&cond->cond_var, mutex, (DWORD)(timeout / 1e6)))\n+int uv_cond_timedwait(uv_cond_t* cond, uv_mutex_t* mutex, uint64_t timeout) {\n+  if (SleepConditionVariableCS(&cond->cond_var, mutex, (DWORD)(timeout / 1e6)))\n     return 0;\n   if (GetLastError() != ERROR_TIMEOUT)\n     abort();\n   return UV_ETIMEDOUT;\n }\n \n \n-int uv_cond_timedwait(uv_cond_t* cond, uv_mutex_t* mutex,\n-    uint64_t timeout) {\n-  if (HAVE_CONDVAR_API())\n-    return uv_cond_condvar_timedwait(cond, mutex, timeout);\n-  else\n-    return uv_cond_fallback_timedwait(cond, mutex, timeout);\n-}\n-\n-\n int uv_barrier_init(uv_barrier_t* barrier, unsigned int count) {\n   int err;\n "
        },
        {
            "sha": "eda5c24f6e83921582d8f5ad065dab68e122a3b7",
            "filename": "deps/uv/src/win/timer.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Ftimer.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Ftimer.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ftimer.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -24,7 +24,7 @@\n \n #include \"uv.h\"\n #include \"internal.h\"\n-#include \"tree.h\"\n+#include \"uv/tree.h\"\n #include \"handle-inl.h\"\n \n "
        },
        {
            "sha": "ab4a648b2ec82671aec60e41aea9caf758359dad",
            "filename": "deps/uv/src/win/tty.c",
            "status": "modified",
            "additions": 64,
            "deletions": 65,
            "changes": 129,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Ftty.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Ftty.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Ftty.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -25,7 +25,7 @@\n #include <stdlib.h>\n \n #if defined(_MSC_VER) && _MSC_VER < 1600\n-# include \"stdint-msvc2008.h\"\n+# include \"uv/stdint-msvc2008.h\"\n #else\n # include <stdint.h>\n #endif\n@@ -205,8 +205,8 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, uv_file fd, int readable) {\n       return uv_translate_sys_error(GetLastError());\n     }\n \n-    /* Obtain the the tty_output_lock because the virtual window state is */\n-    /* shared between all uv_tty_t handles. */\n+    /* Obtain the tty_output_lock because the virtual window state is shared\n+     * between all uv_tty_t handles. */\n     uv_sem_wait(&uv_tty_output_lock);\n \n     if (uv__vterm_state == UV_UNCHECKED)\n@@ -484,8 +484,8 @@ static DWORD CALLBACK uv_tty_line_read_thread(void* data) {\n     bytes = MAX_INPUT_BUFFER_LENGTH;\n   }\n \n-  /* At last, unicode! */\n-  /* One utf-16 codeunit never takes more than 3 utf-8 codeunits to encode */\n+  /* At last, unicode! One utf-16 codeunit never takes more than 3 utf-8\n+   * codeunits to encode. */\n   chars = bytes / 3;\n \n   status = InterlockedExchange(&uv__read_console_status, IN_PROGRESS);\n@@ -620,10 +620,10 @@ static const char* get_vt100_fn_key(DWORD code, char shift, char ctrl,\n       }\n \n   switch (code) {\n-    /* These mappings are the same as Cygwin's. Unmodified and alt-modified */\n-    /* keypad keys comply with linux console, modifiers comply with xterm */\n-    /* modifier usage. F1..f12 and shift-f1..f10 comply with linux console, */\n-    /* f6..f12 with and without modifiers comply with rxvt. */\n+    /* These mappings are the same as Cygwin's. Unmodified and alt-modified\n+     * keypad keys comply with linux console, modifiers comply with xterm\n+     * modifier usage. F1. f12 and shift-f1. f10 comply with linux console, f6.\n+     * f12 with and without modifiers comply with rxvt. */\n     VK_CASE(VK_INSERT,  \"[2~\",  \"[2;2~\", \"[2;5~\", \"[2;6~\")\n     VK_CASE(VK_END,     \"[4~\",  \"[4;2~\", \"[4;5~\", \"[4;6~\")\n     VK_CASE(VK_DOWN,    \"[B\",   \"[1;2B\", \"[1;5B\", \"[1;6B\")\n@@ -706,8 +706,8 @@ void uv_process_tty_read_raw_req(uv_loop_t* loop, uv_tty_t* handle,\n     goto out;\n   }\n \n-  /* Windows sends a lot of events that we're not interested in, so buf */\n-  /* will be allocated on demand, when there's actually something to emit. */\n+  /* Windows sends a lot of events that we're not interested in, so buf will be\n+   * allocated on demand, when there's actually something to emit. */\n   buf = uv_null_buf_;\n   buf_used = 0;\n \n@@ -733,16 +733,16 @@ void uv_process_tty_read_raw_req(uv_loop_t* loop, uv_tty_t* handle,\n         continue;\n       }\n \n-      /* Ignore keyup events, unless the left alt key was held and a valid */\n-      /* unicode character was emitted. */\n+      /* Ignore keyup events, unless the left alt key was held and a valid\n+       * unicode character was emitted. */\n       if (!KEV.bKeyDown && !(((KEV.dwControlKeyState & LEFT_ALT_PRESSED) ||\n           KEV.wVirtualKeyCode==VK_MENU) && KEV.uChar.UnicodeChar != 0)) {\n         continue;\n       }\n \n-      /* Ignore keypresses to numpad number keys if the left alt is held */\n-      /* because the user is composing a character, or windows simulating */\n-      /* this. */\n+      /* Ignore keypresses to numpad number keys if the left alt is held\n+       * because the user is composing a character, or windows simulating this.\n+       */\n       if ((KEV.dwControlKeyState & LEFT_ALT_PRESSED) &&\n           !(KEV.dwControlKeyState & ENHANCED_KEY) &&\n           (KEV.wVirtualKeyCode == VK_INSERT ||\n@@ -779,8 +779,8 @@ void uv_process_tty_read_raw_req(uv_loop_t* loop, uv_tty_t* handle,\n           continue;\n         }\n \n-        /* Prefix with \\u033 if alt was held, but alt was not used as part */\n-        /* a compose sequence. */\n+        /* Prefix with \\u033 if alt was held, but alt was not used as part a\n+         * compose sequence. */\n         if ((KEV.dwControlKeyState & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))\n             && !(KEV.dwControlKeyState & (LEFT_CTRL_PRESSED |\n             RIGHT_CTRL_PRESSED)) && KEV.bKeyDown) {\n@@ -818,8 +818,8 @@ void uv_process_tty_read_raw_req(uv_loop_t* loop, uv_tty_t* handle,\n         /* Whatever happened, the last character wasn't a high surrogate. */\n         handle->tty.rd.last_utf16_high_surrogate = 0;\n \n-        /* If the utf16 character(s) couldn't be converted something must */\n-        /* be wrong. */\n+        /* If the utf16 character(s) couldn't be converted something must be\n+         * wrong. */\n         if (!char_len) {\n           handle->flags &= ~UV_HANDLE_READING;\n           DECREASE_ACTIVE_COUNT(loop, handle);\n@@ -950,8 +950,7 @@ void uv_process_tty_read_line_req(uv_loop_t* loop, uv_tty_t* handle,\n \n   } else {\n     if (!(handle->flags & UV_HANDLE_CANCELLATION_PENDING)) {\n-      /* Read successful */\n-      /* TODO: read unicode, convert to utf-8 */\n+      /* Read successful. TODO: read unicode, convert to utf-8 */\n       DWORD bytes = req->u.io.overlapped.InternalHigh;\n       handle->read_cb((uv_stream_t*) handle, bytes, &buf);\n     } else {\n@@ -975,9 +974,9 @@ void uv_process_tty_read_req(uv_loop_t* loop, uv_tty_t* handle,\n   assert(handle->type == UV_TTY);\n   assert(handle->flags & UV_HANDLE_TTY_READABLE);\n \n-  /* If the read_line_buffer member is zero, it must have been an raw read. */\n-  /* Otherwise it was a line-buffered read. */\n-  /* FIXME: This is quite obscure. Use a flag or something. */\n+  /* If the read_line_buffer member is zero, it must have been an raw read.\n+   * Otherwise it was a line-buffered read. FIXME: This is quite obscure. Use a\n+   * flag or something. */\n   if (handle->tty.rd.read_line_buffer.len == 0) {\n     uv_process_tty_read_raw_req(loop, handle, req);\n   } else {\n@@ -999,14 +998,14 @@ int uv_tty_read_start(uv_tty_t* handle, uv_alloc_cb alloc_cb,\n   handle->read_cb = read_cb;\n   handle->alloc_cb = alloc_cb;\n \n-  /* If reading was stopped and then started again, there could still be a */\n-  /* read request pending. */\n+  /* If reading was stopped and then started again, there could still be a read\n+   * request pending. */\n   if (handle->flags & UV_HANDLE_READ_PENDING) {\n     return 0;\n   }\n \n-  /* Maybe the user stopped reading half-way while processing key events. */\n-  /* Short-circuit if this could be the case. */\n+  /* Maybe the user stopped reading half-way while processing key events.\n+   * Short-circuit if this could be the case. */\n   if (handle->tty.rd.last_key_len > 0) {\n     SET_REQ_SUCCESS(&handle->read_req);\n     uv_insert_pending_req(handle->loop, (uv_req_t*) &handle->read_req);\n@@ -1033,8 +1032,8 @@ int uv_tty_read_stop(uv_tty_t* handle) {\n     return 0;\n \n   if (handle->flags & UV_HANDLE_TTY_RAW) {\n-    /* Cancel raw read */\n-    /* Write some bullshit event to force the console wait to return. */\n+    /* Cancel raw read. Write some bullshit event to force the console wait to\n+     * return. */\n     memset(&record, 0, sizeof record);\n     if (!WriteConsoleInputW(handle->handle, &record, 1, &written)) {\n       return GetLastError();\n@@ -1116,8 +1115,8 @@ static void uv_tty_update_virtual_window(CONSOLE_SCREEN_BUFFER_INFO* info) {\n     uv_tty_virtual_offset = info->dwCursorPosition.Y;\n   } else if (uv_tty_virtual_offset < info->dwCursorPosition.Y -\n              uv_tty_virtual_height + 1) {\n-    /* If suddenly find the cursor outside of the virtual window, it must */\n-    /* have somehow scrolled. Update the virtual window offset. */\n+    /* If suddenly find the cursor outside of the virtual window, it must have\n+     * somehow scrolled. Update the virtual window offset. */\n     uv_tty_virtual_offset = info->dwCursorPosition.Y -\n                             uv_tty_virtual_height + 1;\n   }\n@@ -1304,8 +1303,8 @@ static int uv_tty_clear(uv_tty_t* handle, int dir, char entire_screen,\n     x2 = 0;\n     x2r = 1;\n   } else {\n-    /* Clear to end of row. We pretend the console is 65536 characters wide, */\n-    /* uv_tty_make_real_coord will clip it to the actual console width. */\n+    /* Clear to end of row. We pretend the console is 65536 characters wide,\n+     * uv_tty_make_real_coord will clip it to the actual console width. */\n     x2 = 0xffff;\n     x2r = 0;\n   }\n@@ -1613,8 +1612,8 @@ static int uv_tty_write_bufs(uv_tty_t* handle,\n                              const uv_buf_t bufs[],\n                              unsigned int nbufs,\n                              DWORD* error) {\n-  /* We can only write 8k characters at a time. Windows can't handle */\n-  /* much more characters in a single console write anyway. */\n+  /* We can only write 8k characters at a time. Windows can't handle much more\n+   * characters in a single console write anyway. */\n   WCHAR utf16_buf[MAX_CONSOLE_CHAR];\n   WCHAR* utf16_buffer;\n   DWORD utf16_buf_used = 0;\n@@ -1650,9 +1649,8 @@ static int uv_tty_write_bufs(uv_tty_t* handle,\n   unsigned char previous_eol = handle->tty.wr.previous_eol;\n   unsigned char ansi_parser_state = handle->tty.wr.ansi_parser_state;\n \n-  /* Store the error here. If we encounter an error, stop trying to do i/o */\n-  /* but keep parsing the buffer so we leave the parser in a consistent */\n-  /* state. */\n+  /* Store the error here. If we encounter an error, stop trying to do i/o but\n+   * keep parsing the buffer so we leave the parser in a consistent state. */\n   *error = ERROR_SUCCESS;\n \n   utf16_buffer = utf16_buf;\n@@ -1700,9 +1698,9 @@ static int uv_tty_write_bufs(uv_tty_t* handle,\n     for (j = 0; j < buf.len; j++) {\n       unsigned char c = buf.base[j];\n \n-      /* Run the character through the utf8 decoder We happily accept non */\n-      /* shortest form encodings and invalid code points - there's no real */\n-      /* harm that can be done. */\n+      /* Run the character through the utf8 decoder We happily accept non\n+       * shortest form encodings and invalid code points - there's no real harm\n+       * that can be done. */\n       if (utf8_bytes_left == 0) {\n         /* Read utf-8 start byte */\n         DWORD first_zero_bit;\n@@ -1742,8 +1740,8 @@ static int uv_tty_write_bufs(uv_tty_t* handle,\n         /* Start byte where continuation was expected. */\n         utf8_bytes_left = 0;\n         utf8_codepoint = UNICODE_REPLACEMENT_CHARACTER;\n-        /* Patch buf offset so this character will be parsed again as a */\n-        /* start byte. */\n+        /* Patch buf offset so this character will be parsed again as a start\n+         * byte. */\n         j--;\n       }\n \n@@ -1776,8 +1774,8 @@ static int uv_tty_write_bufs(uv_tty_t* handle,\n           case '_':\n           case 'P':\n           case ']':\n-            /* Not supported, but we'll have to parse until we see a stop */\n-            /* code, e.g. ESC \\ or BEL. */\n+            /* Not supported, but we'll have to parse until we see a stop code,\n+             * e. g. ESC \\ or BEL. */\n             ansi_parser_state = ANSI_ST_CONTROL;\n             continue;\n \n@@ -1859,8 +1857,9 @@ static int uv_tty_write_bufs(uv_tty_t* handle,\n               continue;\n \n             } else {\n-              /* If ANSI_IN_ARG is not set, add another argument and */\n-              /* default it to 0. */\n+              /* If ANSI_IN_ARG is not set, add another argument and default it\n+               * to 0. */\n+\n               /* Check for too many arguments */\n               if (handle->tty.wr.ansi_csi_argc >= ARRAY_SIZE(handle->tty.wr.ansi_csi_argv)) {\n                 ansi_parser_state |= ANSI_IGNORE;\n@@ -1874,9 +1873,9 @@ static int uv_tty_write_bufs(uv_tty_t* handle,\n \n           } else if (utf8_codepoint == '?' && !(ansi_parser_state & ANSI_IN_ARG) &&\n                      handle->tty.wr.ansi_csi_argc == 0) {\n-            /* Ignores '?' if it is the first character after CSI[ */\n-            /* This is an extension character from the VT100 codeset */\n-            /* that is supported and used by most ANSI terminals today. */\n+            /* Ignores '?' if it is the first character after CSI[. This is an\n+             * extension character from the VT100 codeset that is supported and\n+             * used by most ANSI terminals today. */\n             continue;\n \n           } else if (utf8_codepoint >= '@' && utf8_codepoint <= '~' &&\n@@ -2006,8 +2005,8 @@ static int uv_tty_write_bufs(uv_tty_t* handle,\n             continue;\n \n           } else {\n-            /* We don't support commands that use private mode characters or */\n-            /* intermediaries. Ignore the rest of the sequence. */\n+            /* We don't support commands that use private mode characters or\n+             * intermediaries. Ignore the rest of the sequence. */\n             ansi_parser_state |= ANSI_IGNORE;\n             continue;\n           }\n@@ -2020,8 +2019,8 @@ static int uv_tty_write_bufs(uv_tty_t* handle,\n         }\n \n       } else if (ansi_parser_state & ANSI_ST_CONTROL) {\n-        /* Unsupported control code */\n-        /* Ignore everything until we see BEL or ESC \\ */\n+        /* Unsupported control code.\n+         * Ignore everything until we see `BEL` or `ESC \\`. */\n         if (ansi_parser_state & ANSI_IN_STRING) {\n           if (!(ansi_parser_state & ANSI_BACKSLASH_SEEN)) {\n             if (utf8_codepoint == '\"') {\n@@ -2055,9 +2054,9 @@ static int uv_tty_write_bufs(uv_tty_t* handle,\n         abort();\n       }\n \n-      /* We wouldn't mind emitting utf-16 surrogate pairs. Too bad, the */\n-      /* windows console doesn't really support UTF-16, so just emit the */\n-      /* replacement character. */\n+      /* We wouldn't mind emitting utf-16 surrogate pairs. Too bad, the windows\n+       * console doesn't really support UTF-16, so just emit the replacement\n+       * character. */\n       if (utf8_codepoint > 0xffff) {\n         utf8_codepoint = UNICODE_REPLACEMENT_CHARACTER;\n       }\n@@ -2071,10 +2070,10 @@ static int uv_tty_write_bufs(uv_tty_t* handle,\n           utf16_buf[utf16_buf_used++] = L'\\r';\n           utf16_buf[utf16_buf_used++] = L'\\n';\n         } else if (utf8_codepoint == 0x0d && previous_eol == 0x0a) {\n-          /* \\n was followed by \\r; do not print the \\r, since */\n-          /* the source was either \\r\\n\\r (so the second \\r is */\n-          /* redundant) or was \\n\\r (so the \\n was processed */\n-          /* by the last case and an \\r automatically inserted). */\n+          /* \\n was followed by \\r; do not print the \\r, since the source was\n+           * either \\r\\n\\r (so the second \\r is redundant) or was \\n\\r (so the\n+           * \\n was processed by the last case and an \\r automatically\n+           * inserted). */\n         } else {\n           /* \\r without \\n; print \\r as-is. */\n           ENSURE_BUFFER_SPACE(1);\n@@ -2224,8 +2223,8 @@ void uv_tty_endgame(uv_loop_t* loop, uv_tty_t* handle) {\n \n   if (handle->flags & UV__HANDLE_CLOSING &&\n       handle->reqs_pending == 0) {\n-    /* The wait handle used for raw reading should be unregistered when the */\n-    /* wait callback runs. */\n+    /* The wait handle used for raw reading should be unregistered when the\n+     * wait callback runs. */\n     assert(!(handle->flags & UV_HANDLE_TTY_READABLE) ||\n            handle->tty.rd.read_raw_wait == NULL);\n "
        },
        {
            "sha": "e56282ae44c74ecc19d9bf27abecf6925169f0f9",
            "filename": "deps/uv/src/win/udp.c",
            "status": "modified",
            "additions": 43,
            "deletions": 46,
            "changes": 89,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fudp.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fudp.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fudp.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -74,40 +74,37 @@ static int uv_udp_set_socket(uv_loop_t* loop, uv_udp_t* handle, SOCKET socket,\n     return GetLastError();\n   }\n \n-  /* Associate it with the I/O completion port. */\n-  /* Use uv_handle_t pointer as completion key. */\n+  /* Associate it with the I/O completion port. Use uv_handle_t pointer as\n+   * completion key. */\n   if (CreateIoCompletionPort((HANDLE)socket,\n                              loop->iocp,\n                              (ULONG_PTR)socket,\n                              0) == NULL) {\n     return GetLastError();\n   }\n \n-  if (pSetFileCompletionNotificationModes) {\n-    /* All known Windows that support SetFileCompletionNotificationModes */\n-    /* have a bug that makes it impossible to use this function in */\n-    /* conjunction with datagram sockets. We can work around that but only */\n-    /* if the user is using the default UDP driver (AFD) and has no other */\n-    /* LSPs stacked on top. Here we check whether that is the case. */\n-    opt_len = (int) sizeof info;\n-    if (getsockopt(socket,\n-                   SOL_SOCKET,\n-                   SO_PROTOCOL_INFOW,\n-                   (char*) &info,\n-                   &opt_len) == SOCKET_ERROR) {\n-      return GetLastError();\n-    }\n+  /* All known Windows that support SetFileCompletionNotificationModes have a\n+   * bug that makes it impossible to use this function in conjunction with\n+   * datagram sockets. We can work around that but only if the user is using\n+   * the default UDP driver (AFD) and has no other. LSPs stacked on top. Here\n+   * we check whether that is the case. */\n+  opt_len = (int) sizeof info;\n+  if (getsockopt(\n+          socket, SOL_SOCKET, SO_PROTOCOL_INFOW, (char*) &info, &opt_len) ==\n+      SOCKET_ERROR) {\n+    return GetLastError();\n+  }\n \n-    if (info.ProtocolChain.ChainLen == 1) {\n-      if (pSetFileCompletionNotificationModes((HANDLE)socket,\n-          FILE_SKIP_SET_EVENT_ON_HANDLE |\n-          FILE_SKIP_COMPLETION_PORT_ON_SUCCESS)) {\n-        handle->flags |= UV_HANDLE_SYNC_BYPASS_IOCP;\n-        handle->func_wsarecv = uv_wsarecv_workaround;\n-        handle->func_wsarecvfrom = uv_wsarecvfrom_workaround;\n-      } else if (GetLastError() != ERROR_INVALID_FUNCTION) {\n-        return GetLastError();\n-      }\n+  if (info.ProtocolChain.ChainLen == 1) {\n+    if (SetFileCompletionNotificationModes(\n+            (HANDLE) socket,\n+            FILE_SKIP_SET_EVENT_ON_HANDLE |\n+                FILE_SKIP_COMPLETION_PORT_ON_SUCCESS)) {\n+      handle->flags |= UV_HANDLE_SYNC_BYPASS_IOCP;\n+      handle->func_wsarecv = uv_wsarecv_workaround;\n+      handle->func_wsarecvfrom = uv_wsarecvfrom_workaround;\n+    } else if (GetLastError() != ERROR_INVALID_FUNCTION) {\n+      return GetLastError();\n     }\n   }\n \n@@ -245,12 +242,12 @@ static int uv_udp_maybe_bind(uv_udp_t* handle,\n     handle->flags |= UV_HANDLE_IPV6;\n \n   if (addr->sa_family == AF_INET6 && !(flags & UV_UDP_IPV6ONLY)) {\n-    /* On windows IPV6ONLY is on by default. */\n-    /* If the user doesn't specify it libuv turns it off. */\n+    /* On windows IPV6ONLY is on by default. If the user doesn't specify it\n+     * libuv turns it off. */\n \n-    /* TODO: how to handle errors? This may fail if there is no ipv4 stack */\n-    /* available, or when run on XP/2003 which have no support for dualstack */\n-    /* sockets. For now we're silently ignoring the error. */\n+    /* TODO: how to handle errors? This may fail if there is no ipv4 stack\n+     * available, or when run on XP/2003 which have no support for dualstack\n+     * sockets. For now we're silently ignoring the error. */\n     setsockopt(handle->socket,\n                IPPROTO_IPV6,\n                IPV6_V6ONLY,\n@@ -386,8 +383,8 @@ int uv__udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,\n   handle->recv_cb = recv_cb;\n   handle->alloc_cb = alloc_cb;\n \n-  /* If reading was stopped and then started again, there could still be a */\n-  /* recv request pending. */\n+  /* If reading was stopped and then started again, there could still be a recv\n+   * request pending. */\n   if (!(handle->flags & UV_HANDLE_READ_PENDING))\n     uv_udp_queue_recv(loop, handle);\n \n@@ -467,19 +464,19 @@ void uv_process_udp_recv_req(uv_loop_t* loop, uv_udp_t* handle,\n   if (!REQ_SUCCESS(req)) {\n     DWORD err = GET_REQ_SOCK_ERROR(req);\n     if (err == WSAEMSGSIZE) {\n-      /* Not a real error, it just indicates that the received packet */\n-      /* was bigger than the receive buffer. */\n+      /* Not a real error, it just indicates that the received packet was\n+       * bigger than the receive buffer. */\n     } else if (err == WSAECONNRESET || err == WSAENETRESET) {\n-      /* A previous sendto operation failed; ignore this error. If */\n-      /* zero-reading we need to call WSARecv/WSARecvFrom _without_ the */\n-      /* MSG_PEEK flag to clear out the error queue. For nonzero reads, */\n-      /* immediately queue a new receive. */\n+      /* A previous sendto operation failed; ignore this error. If zero-reading\n+       * we need to call WSARecv/WSARecvFrom _without_ the. MSG_PEEK flag to\n+       * clear out the error queue. For nonzero reads, immediately queue a new\n+       * receive. */\n       if (!(handle->flags & UV_HANDLE_ZERO_READ)) {\n         goto done;\n       }\n     } else {\n-      /* A real error occurred. Report the error to the user only if we're */\n-      /* currently reading. */\n+      /* A real error occurred. Report the error to the user only if we're\n+       * currently reading. */\n       if (handle->flags & UV_HANDLE_READING) {\n         uv_udp_recv_stop(handle);\n         buf = (handle->flags & UV_HANDLE_ZERO_READ) ?\n@@ -503,8 +500,8 @@ void uv_process_udp_recv_req(uv_loop_t* loop, uv_udp_t* handle,\n     struct sockaddr_storage from;\n     int from_len;\n \n-    /* Do a nonblocking receive */\n-    /* TODO: try to read multiple datagrams at once. FIONREAD maybe? */\n+    /* Do a nonblocking receive.\n+     * TODO: try to read multiple datagrams at once. FIONREAD maybe? */\n     buf = uv_buf_init(NULL, 0);\n     handle->alloc_cb((uv_handle_t*) handle, 65536, &buf);\n     if (buf.base == NULL || buf.len == 0) {\n@@ -741,7 +738,7 @@ int uv_udp_set_multicast_interface(uv_udp_t* handle, const char* interface_addr)\n     return UV_EINVAL;\n   }\n \n-  if (!(handle->flags & UV_HANDLE_BOUND))\n+  if (handle->socket == INVALID_SOCKET)\n     return UV_EBADF;\n \n   if (addr_st.ss_family == AF_INET) {\n@@ -772,7 +769,7 @@ int uv_udp_set_multicast_interface(uv_udp_t* handle, const char* interface_addr)\n int uv_udp_set_broadcast(uv_udp_t* handle, int value) {\n   BOOL optval = (BOOL) value;\n \n-  if (!(handle->flags & UV_HANDLE_BOUND))\n+  if (handle->socket == INVALID_SOCKET)\n     return UV_EBADF;\n \n   if (setsockopt(handle->socket,\n@@ -818,7 +815,7 @@ int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {\n       return UV_EINVAL;                                                       \\\n     }                                                                         \\\n                                                                               \\\n-    if (!(handle->flags & UV_HANDLE_BOUND))                                   \\\n+    if (handle->socket == INVALID_SOCKET)                                     \\\n       return UV_EBADF;                                                        \\\n                                                                               \\\n     if (!(handle->flags & UV_HANDLE_IPV6)) {                                  \\"
        },
        {
            "sha": "3e86ff15048063f26c01a96bef9a6dabf7083398",
            "filename": "deps/uv/src/win/util.c",
            "status": "modified",
            "additions": 36,
            "deletions": 48,
            "changes": 84,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Futil.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Futil.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Futil.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -74,10 +74,6 @@\n static char *process_title;\n static CRITICAL_SECTION process_title_lock;\n \n-/* Cached copy of the process id, written once. */\n-static DWORD current_pid = 0;\n-\n-\n /* Interval (in seconds) of the high-resolution clock. */\n static double hrtime_interval_ = 0;\n \n@@ -149,8 +145,8 @@ int uv_exepath(char* buffer, size_t* size_ptr) {\n \n   uv__free(utf16_buffer);\n \n-  /* utf8_len *does* include the terminating null at this point, but the */\n-  /* returned size shouldn't. */\n+  /* utf8_len *does* include the terminating null at this point, but the\n+   * returned size shouldn't. */\n   *size_ptr = utf8_len - 1;\n   return 0;\n \n@@ -173,16 +169,16 @@ int uv_cwd(char* buffer, size_t* size) {\n   if (utf16_len == 0) {\n     return uv_translate_sys_error(GetLastError());\n   } else if (utf16_len > MAX_PATH) {\n-    /* This should be impossible;  however the CRT has a code path to deal */\n-    /* with this scenario, so I added a check anyway. */\n+    /* This should be impossible; however the CRT has a code path to deal with\n+     * this scenario, so I added a check anyway. */\n     return UV_EIO;\n   }\n \n   /* utf16_len contains the length, *not* including the terminating null. */\n   utf16_buffer[utf16_len] = L'\\0';\n \n-  /* The returned directory should not have a trailing slash, unless it */\n-  /* points at a drive root, like c:\\. Remove it if needed.*/\n+  /* The returned directory should not have a trailing slash, unless it points\n+   * at a drive root, like c:\\. Remove it if needed. */\n   if (utf16_buffer[utf16_len - 1] == L'\\\\' &&\n       !(utf16_len == 3 && utf16_buffer[1] == L':')) {\n     utf16_len--;\n@@ -239,9 +235,9 @@ int uv_chdir(const char* dir) {\n                           utf16_buffer,\n                           MAX_PATH) == 0) {\n     DWORD error = GetLastError();\n-    /* The maximum length of the current working directory is 260 chars, */\n-    /* including terminating null. If it doesn't fit, the path name must be */\n-    /* too long. */\n+    /* The maximum length of the current working directory is 260 chars,\n+     * including terminating null. If it doesn't fit, the path name must be too\n+     * long. */\n     if (error == ERROR_INSUFFICIENT_BUFFER) {\n       return UV_ENAMETOOLONG;\n     } else {\n@@ -253,27 +249,27 @@ int uv_chdir(const char* dir) {\n     return uv_translate_sys_error(GetLastError());\n   }\n \n-  /* Windows stores the drive-local path in an \"hidden\" environment variable, */\n-  /* which has the form \"=C:=C:\\Windows\". SetCurrentDirectory does not */\n-  /* update this, so we'll have to do it. */\n+  /* Windows stores the drive-local path in an \"hidden\" environment variable,\n+   * which has the form \"=C:=C:\\Windows\". SetCurrentDirectory does not update\n+   * this, so we'll have to do it. */\n   utf16_len = GetCurrentDirectoryW(MAX_PATH, utf16_buffer);\n   if (utf16_len == 0) {\n     return uv_translate_sys_error(GetLastError());\n   } else if (utf16_len > MAX_PATH) {\n     return UV_EIO;\n   }\n \n-  /* The returned directory should not have a trailing slash, unless it */\n-  /* points at a drive root, like c:\\. Remove it if needed. */\n+  /* The returned directory should not have a trailing slash, unless it points\n+   * at a drive root, like c:\\. Remove it if needed. */\n   if (utf16_buffer[utf16_len - 1] == L'\\\\' &&\n       !(utf16_len == 3 && utf16_buffer[1] == L':')) {\n     utf16_len--;\n     utf16_buffer[utf16_len] = L'\\0';\n   }\n \n   if (utf16_len < 2 || utf16_buffer[1] != L':') {\n-    /* Doesn't look like a drive letter could be there - probably an UNC */\n-    /* path. TODO: Need to handle win32 namespaces like \\\\?\\C:\\ ? */\n+    /* Doesn't look like a drive letter could be there - probably an UNC path.\n+     * TODO: Need to handle win32 namespaces like \\\\?\\C:\\ ? */\n     drive_letter = 0;\n   } else if (utf16_buffer[0] >= L'A' && utf16_buffer[0] <= L'Z') {\n     drive_letter = utf16_buffer[0];\n@@ -359,14 +355,6 @@ uv_pid_t uv_os_getppid(void) {\n }\n \n \n-int uv_current_pid(void) {\n-  if (current_pid == 0) {\n-    current_pid = GetCurrentProcessId();\n-  }\n-  return current_pid;\n-}\n-\n-\n char** uv_setup_args(int argc, char** argv) {\n   return argv;\n }\n@@ -842,17 +830,17 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,\n   }\n \n \n-  /* Fetch the size of the adapters reported by windows, and then get the */\n-  /* list itself. */\n+  /* Fetch the size of the adapters reported by windows, and then get the list\n+   * itself. */\n   win_address_buf_size = 0;\n   win_address_buf = NULL;\n \n   for (;;) {\n     ULONG r;\n \n-    /* If win_address_buf is 0, then GetAdaptersAddresses will fail with */\n-    /* ERROR_BUFFER_OVERFLOW, and the required buffer size will be stored in */\n-    /* win_address_buf_size. */\n+    /* If win_address_buf is 0, then GetAdaptersAddresses will fail with.\n+     * ERROR_BUFFER_OVERFLOW, and the required buffer size will be stored in\n+     * win_address_buf_size. */\n     r = GetAdaptersAddresses(AF_UNSPEC,\n                              flags,\n                              NULL,\n@@ -866,8 +854,8 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,\n \n     switch (r) {\n       case ERROR_BUFFER_OVERFLOW:\n-        /* This happens when win_address_buf is NULL or too small to hold */\n-        /* all adapters. */\n+        /* This happens when win_address_buf is NULL or too small to hold all\n+         * adapters. */\n         win_address_buf = uv__malloc(win_address_buf_size);\n         if (win_address_buf == NULL)\n           return UV_ENOMEM;\n@@ -901,15 +889,15 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,\n         return UV_ENOBUFS;\n \n       default:\n-        /* Other (unspecified) errors can happen, but we don't have any */\n-        /* special meaning for them. */\n+        /* Other (unspecified) errors can happen, but we don't have any special\n+         * meaning for them. */\n         assert(r != ERROR_SUCCESS);\n         return uv_translate_sys_error(r);\n     }\n   }\n \n-  /* Count the number of enabled interfaces and compute how much space is */\n-  /* needed to store their info. */\n+  /* Count the number of enabled interfaces and compute how much space is\n+   * needed to store their info. */\n   count = 0;\n   uv_address_buf_size = 0;\n \n@@ -919,9 +907,9 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,\n     IP_ADAPTER_UNICAST_ADDRESS* unicast_address;\n     int name_size;\n \n-    /* Interfaces that are not 'up' should not be reported. Also skip */\n-    /* interfaces that have no associated unicast address, as to avoid */\n-    /* allocating space for the name for this interface. */\n+    /* Interfaces that are not 'up' should not be reported. Also skip\n+     * interfaces that have no associated unicast address, as to avoid\n+     * allocating space for the name for this interface. */\n     if (adapter->OperStatus != IfOperStatusUp ||\n         adapter->FirstUnicastAddress == NULL)\n       continue;\n@@ -941,8 +929,8 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,\n     }\n     uv_address_buf_size += name_size;\n \n-    /* Count the number of addresses associated with this interface, and */\n-    /* compute the size. */\n+    /* Count the number of addresses associated with this interface, and\n+     * compute the size. */\n     for (unicast_address = (IP_ADAPTER_UNICAST_ADDRESS*)\n                            adapter->FirstUnicastAddress;\n          unicast_address != NULL;\n@@ -959,8 +947,8 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,\n     return UV_ENOMEM;\n   }\n \n-  /* Compute the start of the uv_interface_address_t array, and the place in */\n-  /* the buffer where the interface names will be stored. */\n+  /* Compute the start of the uv_interface_address_t array, and the place in\n+   * the buffer where the interface names will be stored. */\n   uv_address = uv_address_buf;\n   name_buf = (char*) (uv_address_buf + count);\n \n@@ -1199,8 +1187,8 @@ int uv_os_tmpdir(char* buffer, size_t* size) {\n     return UV_EIO;\n   }\n \n-  /* The returned directory should not have a trailing slash, unless it */\n-  /* points at a drive root, like c:\\. Remove it if needed.*/\n+  /* The returned directory should not have a trailing slash, unless it points\n+   * at a drive root, like c:\\. Remove it if needed. */\n   if (path[len - 1] == L'\\\\' &&\n       !(len == 3 && path[1] == L':')) {\n     len--;"
        },
        {
            "sha": "0fd598eacb4503f9c431a7bea59c3d0110804242",
            "filename": "deps/uv/src/win/winapi.c",
            "status": "modified",
            "additions": 0,
            "deletions": 67,
            "changes": 67,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fwinapi.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fwinapi.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fwinapi.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -34,37 +34,17 @@ sNtQueryVolumeInformationFile pNtQueryVolumeInformationFile;\n sNtQueryDirectoryFile pNtQueryDirectoryFile;\n sNtQuerySystemInformation pNtQuerySystemInformation;\n \n-\n-/* Kernel32 function pointers */\n-sGetQueuedCompletionStatusEx pGetQueuedCompletionStatusEx;\n-sSetFileCompletionNotificationModes pSetFileCompletionNotificationModes;\n-sCreateSymbolicLinkW pCreateSymbolicLinkW;\n-sCancelIoEx pCancelIoEx;\n-sInitializeConditionVariable pInitializeConditionVariable;\n-sSleepConditionVariableCS pSleepConditionVariableCS;\n-sSleepConditionVariableSRW pSleepConditionVariableSRW;\n-sWakeAllConditionVariable pWakeAllConditionVariable;\n-sWakeConditionVariable pWakeConditionVariable;\n-sCancelSynchronousIo pCancelSynchronousIo;\n-sGetFinalPathNameByHandleW pGetFinalPathNameByHandleW;\n-\n-\n /* Powrprof.dll function pointer */\n sPowerRegisterSuspendResumeNotification pPowerRegisterSuspendResumeNotification;\n \n /* User32.dll function pointer */\n sSetWinEventHook pSetWinEventHook;\n \n-/* iphlpapi.dll function pointer */\n-sConvertInterfaceIndexToLuid pConvertInterfaceIndexToLuid = NULL;\n-sConvertInterfaceLuidToNameW pConvertInterfaceLuidToNameW = NULL;\n \n void uv_winapi_init(void) {\n   HMODULE ntdll_module;\n-  HMODULE kernel32_module;\n   HMODULE powrprof_module;\n   HMODULE user32_module;\n-  HMODULE iphlpapi_module;\n \n   ntdll_module = GetModuleHandleA(\"ntdll.dll\");\n   if (ntdll_module == NULL) {\n@@ -118,46 +98,6 @@ void uv_winapi_init(void) {\n     uv_fatal_error(GetLastError(), \"GetProcAddress\");\n   }\n \n-  kernel32_module = GetModuleHandleA(\"kernel32.dll\");\n-  if (kernel32_module == NULL) {\n-    uv_fatal_error(GetLastError(), \"GetModuleHandleA\");\n-  }\n-\n-  pGetQueuedCompletionStatusEx = (sGetQueuedCompletionStatusEx) GetProcAddress(\n-      kernel32_module,\n-      \"GetQueuedCompletionStatusEx\");\n-\n-  pSetFileCompletionNotificationModes = (sSetFileCompletionNotificationModes)\n-    GetProcAddress(kernel32_module, \"SetFileCompletionNotificationModes\");\n-\n-  pCreateSymbolicLinkW = (sCreateSymbolicLinkW)\n-    GetProcAddress(kernel32_module, \"CreateSymbolicLinkW\");\n-\n-  pCancelIoEx = (sCancelIoEx)\n-    GetProcAddress(kernel32_module, \"CancelIoEx\");\n-\n-  pInitializeConditionVariable = (sInitializeConditionVariable)\n-    GetProcAddress(kernel32_module, \"InitializeConditionVariable\");\n-\n-  pSleepConditionVariableCS = (sSleepConditionVariableCS)\n-    GetProcAddress(kernel32_module, \"SleepConditionVariableCS\");\n-\n-  pSleepConditionVariableSRW = (sSleepConditionVariableSRW)\n-    GetProcAddress(kernel32_module, \"SleepConditionVariableSRW\");\n-\n-  pWakeAllConditionVariable = (sWakeAllConditionVariable)\n-    GetProcAddress(kernel32_module, \"WakeAllConditionVariable\");\n-\n-  pWakeConditionVariable = (sWakeConditionVariable)\n-    GetProcAddress(kernel32_module, \"WakeConditionVariable\");\n-\n-  pCancelSynchronousIo = (sCancelSynchronousIo)\n-    GetProcAddress(kernel32_module, \"CancelSynchronousIo\");\n-\n-  pGetFinalPathNameByHandleW = (sGetFinalPathNameByHandleW)\n-    GetProcAddress(kernel32_module, \"GetFinalPathNameByHandleW\");\n-\n-\n   powrprof_module = LoadLibraryA(\"powrprof.dll\");\n   if (powrprof_module != NULL) {\n     pPowerRegisterSuspendResumeNotification = (sPowerRegisterSuspendResumeNotification)\n@@ -170,11 +110,4 @@ void uv_winapi_init(void) {\n       GetProcAddress(user32_module, \"SetWinEventHook\");\n   }\n \n-  iphlpapi_module = LoadLibraryA(\"iphlpapi.dll\");\n-  if (iphlpapi_module != NULL) {\n-    pConvertInterfaceIndexToLuid = (sConvertInterfaceIndexToLuid)\n-      GetProcAddress(iphlpapi_module, \"ConvertInterfaceIndexToLuid\");\n-    pConvertInterfaceLuidToNameW = (sConvertInterfaceLuidToNameW)\n-      GetProcAddress(iphlpapi_module, \"ConvertInterfaceLuidToNameW\");\n-  }\n }"
        },
        {
            "sha": "d0fcfd8e7ae021f2935f256d5df105b9627bc762",
            "filename": "deps/uv/src/win/winapi.h",
            "status": "modified",
            "additions": 2,
            "deletions": 82,
            "changes": 84,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fwinapi.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fwinapi.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fwinapi.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -4076,8 +4076,8 @@\n # define STATUS_HASH_NOT_PRESENT ((NTSTATUS) 0xC000A101L)\n #endif\n \n-/* This is not the NTSTATUS_FROM_WIN32 that the DDK provides, because the */\n-/* DDK got it wrong! */\n+/* This is not the NTSTATUS_FROM_WIN32 that the DDK provides, because the DDK\n+ * got it wrong! */\n #ifdef NTSTATUS_FROM_WIN32\n # undef NTSTATUS_FROM_WIN32\n #endif\n@@ -4642,56 +4642,6 @@ typedef NTSTATUS (NTAPI *sNtQueryDirectoryFile)\n # define ERROR_MUI_FILE_NOT_LOADED 15105\n #endif\n \n-typedef BOOL (WINAPI *sGetQueuedCompletionStatusEx)\n-             (HANDLE CompletionPort,\n-              LPOVERLAPPED_ENTRY lpCompletionPortEntries,\n-              ULONG ulCount,\n-              PULONG ulNumEntriesRemoved,\n-              DWORD dwMilliseconds,\n-              BOOL fAlertable);\n-\n-typedef BOOL (WINAPI* sSetFileCompletionNotificationModes)\n-             (HANDLE FileHandle,\n-              UCHAR Flags);\n-\n-typedef BOOLEAN (WINAPI* sCreateSymbolicLinkW)\n-                (LPCWSTR lpSymlinkFileName,\n-                 LPCWSTR lpTargetFileName,\n-                 DWORD dwFlags);\n-\n-typedef BOOL (WINAPI* sCancelIoEx)\n-             (HANDLE hFile,\n-              LPOVERLAPPED lpOverlapped);\n-\n-typedef VOID (WINAPI* sInitializeConditionVariable)\n-             (PCONDITION_VARIABLE ConditionVariable);\n-\n-typedef BOOL (WINAPI* sSleepConditionVariableCS)\n-             (PCONDITION_VARIABLE ConditionVariable,\n-              PCRITICAL_SECTION CriticalSection,\n-              DWORD dwMilliseconds);\n-\n-typedef BOOL (WINAPI* sSleepConditionVariableSRW)\n-             (PCONDITION_VARIABLE ConditionVariable,\n-              PSRWLOCK SRWLock,\n-              DWORD dwMilliseconds,\n-              ULONG Flags);\n-\n-typedef VOID (WINAPI* sWakeAllConditionVariable)\n-             (PCONDITION_VARIABLE ConditionVariable);\n-\n-typedef VOID (WINAPI* sWakeConditionVariable)\n-             (PCONDITION_VARIABLE ConditionVariable);\n-\n-typedef BOOL (WINAPI* sCancelSynchronousIo)\n-             (HANDLE hThread);\n-\n-typedef DWORD (WINAPI* sGetFinalPathNameByHandleW)\n-             (HANDLE hFile,\n-              LPWSTR lpszFilePath,\n-              DWORD cchFilePath,\n-              DWORD dwFlags);\n-\n /* from powerbase.h */\n #ifndef DEVICE_NOTIFY_CALLBACK\n # define DEVICE_NOTIFY_CALLBACK 2\n@@ -4754,40 +4704,10 @@ extern sNtQueryVolumeInformationFile pNtQueryVolumeInformationFile;\n extern sNtQueryDirectoryFile pNtQueryDirectoryFile;\n extern sNtQuerySystemInformation pNtQuerySystemInformation;\n \n-\n-/* Kernel32 function pointers */\n-extern sGetQueuedCompletionStatusEx pGetQueuedCompletionStatusEx;\n-extern sSetFileCompletionNotificationModes pSetFileCompletionNotificationModes;\n-extern sCreateSymbolicLinkW pCreateSymbolicLinkW;\n-extern sCancelIoEx pCancelIoEx;\n-extern sInitializeConditionVariable pInitializeConditionVariable;\n-extern sSleepConditionVariableCS pSleepConditionVariableCS;\n-extern sSleepConditionVariableSRW pSleepConditionVariableSRW;\n-extern sWakeAllConditionVariable pWakeAllConditionVariable;\n-extern sWakeConditionVariable pWakeConditionVariable;\n-extern sCancelSynchronousIo pCancelSynchronousIo;\n-extern sGetFinalPathNameByHandleW pGetFinalPathNameByHandleW;\n-\n-\n /* Powrprof.dll function pointer */\n extern sPowerRegisterSuspendResumeNotification pPowerRegisterSuspendResumeNotification;\n \n /* User32.dll function pointer */\n extern sSetWinEventHook pSetWinEventHook;\n \n-/* iphlpapi.dll function pointer */\n-union _NET_LUID_LH;\n-typedef DWORD (WINAPI *sConvertInterfaceIndexToLuid)(\n-    ULONG InterfaceIndex,\n-    union _NET_LUID_LH *InterfaceLuid);\n-\n-typedef DWORD (WINAPI *sConvertInterfaceLuidToNameW)(\n-    const union _NET_LUID_LH *InterfaceLuid,\n-    PWSTR InterfaceName,\n-    size_t Length);\n-\n-extern sConvertInterfaceIndexToLuid pConvertInterfaceIndexToLuid;\n-extern sConvertInterfaceLuidToNameW pConvertInterfaceLuidToNameW;\n-\n-\n #endif /* UV_WIN_WINAPI_H_ */"
        },
        {
            "sha": "5e7da2a8f252935616100a94eff31e7b47e138dd",
            "filename": "deps/uv/src/win/winsock.c",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fwinsock.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fsrc%2Fwin%2Fwinsock.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fsrc%2Fwin%2Fwinsock.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -256,8 +256,8 @@ int uv_ntstatus_to_winsock_error(NTSTATUS status) {\n     default:\n       if ((status & (FACILITY_NTWIN32 << 16)) == (FACILITY_NTWIN32 << 16) &&\n           (status & (ERROR_SEVERITY_ERROR | ERROR_SEVERITY_WARNING))) {\n-        /* It's a windows error that has been previously mapped to an */\n-        /* ntstatus code. */\n+        /* It's a windows error that has been previously mapped to an ntstatus\n+         * code. */\n         return (DWORD) (status & 0xffff);\n       } else {\n         /* The default fallback for unmappable ntstatus codes. */\n@@ -519,8 +519,8 @@ int WSAAPI uv_msafd_poll(SOCKET socket, AFD_POLL_INFO* info_in,\n                                   sizeof *info_out);\n \n   if (overlapped == NULL) {\n-    /* If this is a blocking operation, wait for the event to become */\n-    /* signaled, and then grab the real status from the io status block. */\n+    /* If this is a blocking operation, wait for the event to become signaled,\n+     * and then grab the real status from the io status block. */\n     if (status == STATUS_PENDING) {\n       DWORD r = WaitForSingleObject(event, INFINITE);\n "
        },
        {
            "sha": "119ae5eee5a28c77f6e0de74898f57d1b6a82770",
            "filename": "deps/uv/test/benchmark-async-pummel.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Fbenchmark-async-pummel.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Fbenchmark-async-pummel.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Fbenchmark-async-pummel.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -41,7 +41,7 @@ static void async_cb(uv_async_t* handle) {\n     /* Tell the pummel thread to stop. */\n     ACCESS_ONCE(const char*, handle->data) = stop;\n \n-    /* Wait for for the pummel thread to acknowledge that it has stoppped. */\n+    /* Wait for the pummel thread to acknowledge that it has stoppped. */\n     while (ACCESS_ONCE(const char*, handle->data) != stopped)\n       uv_sleep(0);\n "
        },
        {
            "sha": "9b8af0460877bdc0a6ffc8a0d9829f78b05288f4",
            "filename": "deps/uv/test/run-tests.c",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Frun-tests.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Frun-tests.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Frun-tests.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -37,6 +37,7 @@\n #include \"test-list.h\"\n \n int ipc_helper(int listen_after_write);\n+int ipc_helper_heavy_traffic_deadlock_bug(void);\n int ipc_helper_tcp_connection(void);\n int ipc_helper_closed_handle(void);\n int ipc_send_recv_helper(void);\n@@ -83,6 +84,10 @@ static int maybe_run_test(int argc, char **argv) {\n     return ipc_helper(1);\n   }\n \n+  if (strcmp(argv[1], \"ipc_helper_heavy_traffic_deadlock_bug\") == 0) {\n+    return ipc_helper_heavy_traffic_deadlock_bug();\n+  }\n+\n   if (strcmp(argv[1], \"ipc_send_recv_helper\") == 0) {\n     return ipc_send_recv_helper();\n   }"
        },
        {
            "sha": "de0db0cc486d6a33896d967112f9b910f85f09f2",
            "filename": "deps/uv/test/runner-unix.c",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Frunner-unix.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Frunner-unix.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Frunner-unix.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -57,8 +57,8 @@ int platform_init(int argc, char **argv) {\n }\n \n \n-/* Invoke \"argv[0] test-name [test-part]\". Store process info in *p. */\n-/* Make sure that all stdio output of the processes is buffered up. */\n+/* Invoke \"argv[0] test-name [test-part]\". Store process info in *p. Make sure\n+ * that all stdio output of the processes is buffered up. */\n int process_start(char* name, char* part, process_info_t* p, int is_helper) {\n   FILE* stdout_file;\n   int stdout_fd;\n@@ -161,9 +161,9 @@ static void* dowait(void* data) {\n }\n \n \n-/* Wait for all `n` processes in `vec` to terminate. */\n-/* Time out after `timeout` msec, or never if timeout == -1 */\n-/* Return 0 if all processes are terminated, -1 on error, -2 on timeout. */\n+/* Wait for all `n` processes in `vec` to terminate. Time out after `timeout`\n+ * msec, or never if timeout == -1. Return 0 if all processes are terminated,\n+ * -1 on error, -2 on timeout. */\n int process_wait(process_info_t* vec, int n, int timeout) {\n   int i;\n   int r;\n@@ -358,8 +358,7 @@ int process_terminate(process_info_t *p) {\n }\n \n \n-/* Return the exit code of process p. */\n-/* On error, return -1. */\n+/* Return the exit code of process p. On error, return -1. */\n int process_reap(process_info_t *p) {\n   if (WIFEXITED(p->status)) {\n     return WEXITSTATUS(p->status);"
        },
        {
            "sha": "ce9727054700192d78d6ca3ea5fd035e1bf50926",
            "filename": "deps/uv/test/runner-win.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Frunner-win.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Frunner-win.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Frunner-win.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -165,8 +165,8 @@ int process_start(char *name, char *part, process_info_t *p, int is_helper) {\n }\n \n \n-/* Timeout is is msecs. Set timeout < 0 to never time out. */\n-/* Returns 0 when all processes are terminated, -2 on timeout. */\n+/* Timeout is in msecs. Set timeout < 0 to never time out. Returns 0 when all\n+ * processes are terminated, -2 on timeout. */\n int process_wait(process_info_t *vec, int n, int timeout) {\n   int i;\n   HANDLE handles[MAXIMUM_WAIT_OBJECTS];"
        },
        {
            "sha": "1a33950852de15206a62a5acb3d63c71fc3a5c91",
            "filename": "deps/uv/test/runner.h",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Frunner.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Frunner.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Frunner.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -138,13 +138,13 @@ void print_lines(const char* buffer, size_t size, FILE* stream);\n /* Do platform-specific initialization. */\n int platform_init(int argc, char** argv);\n \n-/* Invoke \"argv[0] test-name [test-part]\". Store process info in *p. */\n-/* Make sure that all stdio output of the processes is buffered up. */\n+/* Invoke \"argv[0] test-name [test-part]\". Store process info in *p. Make sure\n+ * that all stdio output of the processes is buffered up. */\n int process_start(char *name, char* part, process_info_t *p, int is_helper);\n \n-/* Wait for all `n` processes in `vec` to terminate. */\n-/* Time out after `timeout` msec, or never if timeout == -1 */\n-/* Return 0 if all processes are terminated, -1 on error, -2 on timeout. */\n+/* Wait for all `n` processes in `vec` to terminate. Time out after `timeout`\n+ * msec, or never if timeout == -1. Return 0 if all processes are terminated,\n+ * -1 on error, -2 on timeout. */\n int process_wait(process_info_t *vec, int n, int timeout);\n \n /* Returns the number of bytes in the stdio output buffer for process `p`. */\n@@ -164,8 +164,7 @@ char* process_get_name(process_info_t *p);\n /* Terminate process `p`. */\n int process_terminate(process_info_t *p);\n \n-/* Return the exit code of process p. */\n-/* On error, return -1. */\n+/* Return the exit code of process p. On error, return -1. */\n int process_reap(process_info_t *p);\n \n /* Clean up after terminating process `p` (e.g. free the output buffer etc.). */"
        },
        {
            "sha": "92a90a540be34f132320f25fa6f313b81c896bab",
            "filename": "deps/uv/test/task.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftask.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftask.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftask.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -29,7 +29,7 @@\n #include <stdlib.h>\n \n #if defined(_MSC_VER) && _MSC_VER < 1600\n-# include \"stdint-msvc2008.h\"\n+# include \"uv/stdint-msvc2008.h\"\n #else\n # include <stdint.h>\n #endif"
        },
        {
            "sha": "1871e7e98196d12ef8c3c2c7fe6bec3ed40b573d",
            "filename": "deps/uv/test/test-callback-stack.c",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-callback-stack.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-callback-stack.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-callback-stack.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -88,10 +88,9 @@ static void read_cb(uv_stream_t* tcp, ssize_t nread, const uv_buf_t* buf) {\n \n   bytes_received += nread;\n \n-  /* We call shutdown here because when bytes_received == sizeof MESSAGE */\n-  /* there will be no more data sent nor received, so here it would be */\n-  /* possible for a backend to to call shutdown_cb immediately and *not* */\n-  /* from a fresh stack. */\n+  /* We call shutdown here because when bytes_received == sizeof MESSAGE there\n+   * will be no more data sent nor received, so here it would be possible for a\n+   * backend to call shutdown_cb immediately and *not* from a fresh stack. */\n   if (bytes_received == sizeof MESSAGE) {\n     nested++;\n \n@@ -131,10 +130,10 @@ static void write_cb(uv_write_t* req, int status) {\n \n   puts(\"Data written. 500ms timeout...\");\n \n-  /* After the data has been sent, we're going to wait for a while, then */\n-  /* start reading. This makes us certain that the message has been echoed */\n-  /* back to our receive buffer when we start reading. This maximizes the */\n-  /* temptation for the backend to use dirty stack for calling read_cb. */\n+  /* After the data has been sent, we're going to wait for a while, then start\n+   * reading. This makes us certain that the message has been echoed back to\n+   * our receive buffer when we start reading. This maximizes the temptation\n+   * for the backend to use dirty stack for calling read_cb. */\n   nested++;\n   r = uv_timer_init(uv_default_loop(), &timer);\n   ASSERT(r == 0);"
        },
        {
            "sha": "8338cacdec3c5f3cb0d144d62015d8885ecbbad9",
            "filename": "deps/uv/test/test-connection-fail.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-connection-fail.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-connection-fail.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-connection-fail.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -98,8 +98,8 @@ static void connection_fail(uv_connect_cb connect_cb) {\n   r = uv_tcp_init(uv_default_loop(), &tcp);\n   ASSERT(!r);\n \n-  /* We are never doing multiple reads/connects at a time anyway. */\n-  /* so these handles can be pre-initialized. */\n+  /* We are never doing multiple reads/connects at a time anyway. so these\n+   * handles can be pre-initialized. */\n   ASSERT(0 == uv_tcp_bind(&tcp, (const struct sockaddr*) &client_addr, 0));\n \n   r = uv_tcp_connect(&req,"
        },
        {
            "sha": "513e69bd5b7d23a017b1999db6a6a6e54a49945f",
            "filename": "deps/uv/test/test-delayed-accept.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-delayed-accept.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-delayed-accept.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-delayed-accept.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -138,8 +138,8 @@ static void connect_cb(uv_connect_t* req, int status) {\n   ASSERT(req != NULL);\n   ASSERT(status == 0);\n \n-  /* Not that the server will send anything, but otherwise we'll never know */\n-  /* when the server closes the connection. */\n+  /* Not that the server will send anything, but otherwise we'll never know\n+   * when the server closes the connection. */\n   r = uv_read_start((uv_stream_t*)(req->handle), alloc_cb, read_cb);\n   ASSERT(r == 0);\n "
        },
        {
            "sha": "2a1ddc497a133f6f9947b85da32c0f2fdf7d8b71",
            "filename": "deps/uv/test/test-fork.c",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-fork.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-fork.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-fork.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -317,8 +317,7 @@ TEST_IMPL(fork_signal_to_child_closed) {\n     printf(\"Waiting for child in parent\\n\");\n     assert_wait_child(child_pid);\n   } else {\n-    /* child */\n-    /* Our signal handler should still be installed. */\n+    /* Child. Our signal handler should still be installed. */\n     ASSERT(0 == uv_loop_fork(uv_default_loop()));\n     printf(\"Checking loop in child\\n\");\n     ASSERT(0 != uv_loop_alive(uv_default_loop()));\n@@ -652,13 +651,11 @@ TEST_IMPL(fork_threadpool_queue_work_simple) {\n   ASSERT(child_pid != -1);\n \n   if (child_pid != 0) {\n-    /* parent */\n-    /* We can still run work. */\n+    /* Parent. We can still run work. */\n     assert_run_work(uv_default_loop());\n     assert_wait_child(child_pid);\n   } else {\n-    /* child */\n-    /* We can work in a new loop. */\n+    /* Child. We can work in a new loop. */\n     printf(\"Running child in %d\\n\", getpid());\n     uv_loop_init(&loop);\n     printf(\"Child first watch\\n\");"
        },
        {
            "sha": "eadff542bcb43cfb8a4667208c25975065aa69ac",
            "filename": "deps/uv/test/test-fs-copyfile.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-fs-copyfile.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-fs-copyfile.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-fs-copyfile.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -179,7 +179,7 @@ TEST_IMPL(fs_copyfile) {\n   unlink(dst);\n   r = uv_fs_copyfile(NULL, &req, fixture, dst, UV_FS_COPYFILE_FICLONE_FORCE,\n                      NULL);\n-  ASSERT(r == 0 || r == UV_ENOSYS || r == UV_ENOTSUP || r == UV_ENOTTY);\n+  ASSERT(r == 0 || r == UV_ENOSYS || r == UV_ENOTSUP);\n \n   if (r == 0)\n     handle_result(&req);"
        },
        {
            "sha": "57da39891a5c5b19e28bf2b17cc1efece7dbbf37",
            "filename": "deps/uv/test/test-fs.c",
            "status": "modified",
            "additions": 168,
            "deletions": 1,
            "changes": 169,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-fs.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-fs.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-fs.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -84,6 +84,7 @@ static int chmod_cb_count;\n static int fchmod_cb_count;\n static int chown_cb_count;\n static int fchown_cb_count;\n+static int lchown_cb_count;\n static int link_cb_count;\n static int symlink_cb_count;\n static int readlink_cb_count;\n@@ -253,6 +254,13 @@ static void chown_cb(uv_fs_t* req) {\n   uv_fs_req_cleanup(req);\n }\n \n+static void lchown_cb(uv_fs_t* req) {\n+  ASSERT(req->fs_type == UV_FS_LCHOWN);\n+  ASSERT(req->result == 0);\n+  lchown_cb_count++;\n+  uv_fs_req_cleanup(req);\n+}\n+\n static void chown_root_cb(uv_fs_t* req) {\n   ASSERT(req->fs_type == UV_FS_CHOWN);\n #if defined(_WIN32) || defined(__MSYS__)\n@@ -1540,6 +1548,7 @@ TEST_IMPL(fs_chown) {\n \n   /* Setup. */\n   unlink(\"test_file\");\n+  unlink(\"test_file_link\");\n \n   loop = uv_default_loop();\n \n@@ -1583,7 +1592,29 @@ TEST_IMPL(fs_chown) {\n   uv_run(loop, UV_RUN_DEFAULT);\n   ASSERT(fchown_cb_count == 1);\n \n-  close(file);\n+  /* sync link */\n+  r = uv_fs_link(NULL, &req, \"test_file\", \"test_file_link\", NULL);\n+  ASSERT(r == 0);\n+  ASSERT(req.result == 0);\n+  uv_fs_req_cleanup(&req);\n+\n+  /* sync lchown */\n+  r = uv_fs_lchown(NULL, &req, \"test_file_link\", -1, -1, NULL);\n+  ASSERT(r == 0);\n+  ASSERT(req.result == 0);\n+  uv_fs_req_cleanup(&req);\n+\n+  /* async lchown */\n+  r = uv_fs_lchown(loop, &req, \"test_file_link\", -1, -1, lchown_cb);\n+  ASSERT(r == 0);\n+  uv_run(loop, UV_RUN_DEFAULT);\n+  ASSERT(lchown_cb_count == 1);\n+\n+  /* Close file */\n+  r = uv_fs_close(NULL, &req, file, NULL);\n+  ASSERT(r == 0);\n+  ASSERT(req.result == 0);\n+  uv_fs_req_cleanup(&req);\n \n   /*\n    * Run the loop just to check we don't have make any extraneous uv_ref()\n@@ -1593,6 +1624,7 @@ TEST_IMPL(fs_chown) {\n \n   /* Cleanup. */\n   unlink(\"test_file\");\n+  unlink(\"test_file_link\");\n \n   MAKE_VALGRIND_HAPPY();\n   return 0;\n@@ -3230,3 +3262,138 @@ TEST_IMPL(fs_exclusive_sharing_mode) {\n   return 0;\n }\n #endif\n+\n+#ifdef _WIN32\n+int call_icacls(const char* command, ...) {\n+    char icacls_command[1024];\n+    va_list args;\n+    \n+    va_start(args, command);\n+    vsnprintf(icacls_command, ARRAYSIZE(icacls_command), command, args);\n+    va_end(args);\n+    return system(icacls_command);\n+}\n+\n+TEST_IMPL(fs_open_readonly_acl) {\n+    uv_passwd_t pwd;\n+    uv_fs_t req;\n+    int r;\n+\n+    /*\n+        Based on Node.js test from\n+        https://github.com/nodejs/node/commit/3ba81e34e86a5c32658e218cb6e65b13e8326bc5\n+\n+        If anything goes wrong, you can delte the test_fle_icacls with:\n+\n+            icacls test_file_icacls /remove \"%USERNAME%\" /inheritance:e\n+            attrib -r test_file_icacls\n+            del test_file_icacls\n+    */\n+    \n+    /* Setup - clear the ACL and remove the file */\n+    loop = uv_default_loop();\n+    r = uv_os_get_passwd(&pwd);\n+    ASSERT(r == 0);\n+    call_icacls(\"icacls test_file_icacls /remove \\\"%s\\\" /inheritance:e\",\n+                pwd.username);\n+    uv_fs_chmod(loop, &req, \"test_file_icacls\", S_IWUSR, NULL);\n+    unlink(\"test_file_icacls\");\n+\n+    /* Create the file */    \n+    r = uv_fs_open(loop,\n+                   &open_req1,\n+                   \"test_file_icacls\",\n+                   O_RDONLY | O_CREAT,\n+                   S_IRUSR,\n+                   NULL);\n+    ASSERT(r >= 0);\n+    ASSERT(open_req1.result >= 0);\n+    uv_fs_req_cleanup(&open_req1);\n+    r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);\n+    ASSERT(r == 0);\n+    ASSERT(close_req.result == 0);\n+    uv_fs_req_cleanup(&close_req);\n+\n+    /* Set up ACL */\n+    r = call_icacls(\"icacls test_file_icacls /inheritance:r /remove \\\"%s\\\"\",\n+                    pwd.username);\n+    if (r != 0) {\n+        goto acl_cleanup;\n+    }\n+    r = call_icacls(\"icacls test_file_icacls /grant \\\"%s\\\":RX\", pwd.username);\n+    if (r != 0) {\n+        goto acl_cleanup;\n+    }\n+    \n+    /* Try opening the file */\n+    r = uv_fs_open(NULL, &open_req1, \"test_file_icacls\", O_RDONLY, 0, NULL);\n+    if (r < 0) {\n+        goto acl_cleanup;\n+    }\n+    uv_fs_req_cleanup(&open_req1);\n+    r = uv_fs_close(NULL, &close_req, open_req1.result, NULL);\n+    if (r != 0) {\n+        goto acl_cleanup;\n+    }\n+    uv_fs_req_cleanup(&close_req);\n+\n+ acl_cleanup:\n+    /* Cleanup */\n+    call_icacls(\"icacls test_file_icacls /remove \\\"%s\\\" /inheritance:e\",\n+                pwd.username);\n+    unlink(\"test_file_icacls\");\n+    uv_os_free_passwd(&pwd);\n+    ASSERT(r == 0);\n+    MAKE_VALGRIND_HAPPY();\n+    return 0;\n+}\n+#endif\n+\n+#ifdef _WIN32\n+TEST_IMPL(fs_fchmod_archive_readonly) {\n+    uv_fs_t req;\n+    uv_file file;\n+    int r;\n+    /* Test clearing read-only flag from files with Archive flag cleared */\n+\n+    /* Setup*/\n+    unlink(\"test_file\");\n+    r = uv_fs_open(NULL,\n+                   &req,\n+                   \"test_file\",\n+                   O_WRONLY | O_CREAT,\n+                   S_IWUSR | S_IRUSR,\n+                   NULL);\n+    ASSERT(r >= 0);\n+    ASSERT(req.result >= 0);\n+    file = req.result;\n+    uv_fs_req_cleanup(&req);\n+    r = uv_fs_close(NULL, &req, file, NULL);\n+    ASSERT(r == 0);\n+    uv_fs_req_cleanup(&req);\n+    /* Make the file read-only and clear archive flag */\n+    r = SetFileAttributes(\"test_file\", FILE_ATTRIBUTE_READONLY);\n+    ASSERT(r != 0);\n+    check_permission(\"test_file\", 0400);\n+    /* Try fchmod */\n+    r = uv_fs_open(NULL, &req, \"test_file\", O_RDONLY, 0, NULL);\n+    ASSERT(r >= 0);\n+    ASSERT(req.result >= 0);\n+    file = req.result;\n+    uv_fs_req_cleanup(&req);\n+    r = uv_fs_fchmod(NULL, &req, file, S_IWUSR, NULL);\n+    ASSERT(r == 0);\n+    ASSERT(req.result == 0);\n+    uv_fs_req_cleanup(&req);\n+    r = uv_fs_close(NULL, &req, file, NULL);\n+    ASSERT(r == 0);\n+    uv_fs_req_cleanup(&req);\n+    check_permission(\"test_file\", S_IWUSR);\n+\n+    /* Restore Archive flag for rest of the tests */\n+    r = SetFileAttributes(\"test_file\", FILE_ATTRIBUTE_ARCHIVE);\n+    ASSERT(r != 0);\n+\n+    return 0;\n+}\n+#endif"
        },
        {
            "sha": "fbe9a68bfc70d2656cb4d5dfaa29cb71491047fa",
            "filename": "deps/uv/test/test-hrtime.c",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-hrtime.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-hrtime.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-hrtime.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -43,9 +43,9 @@ TEST_IMPL(hrtime) {\n \n     /*  printf(\"i= %d diff = %llu\\n\", i, (unsigned long long int) diff); */\n \n-    /* The windows Sleep() function has only a resolution of 10-20 ms. */\n-    /* Check that the difference between the two hrtime values is somewhat in */\n-    /* the range we expect it to be. */\n+    /* The windows Sleep() function has only a resolution of 10-20 ms. Check\n+     * that the difference between the two hrtime values is somewhat in the\n+     * range we expect it to be. */\n     ASSERT(diff > (uint64_t) 25 * NANOSEC / MILLISEC);\n     ASSERT(diff < (uint64_t) 80 * NANOSEC / MILLISEC);\n     --i;"
        },
        {
            "sha": "240fc64588b413405e2d03cf63779708cc95a58e",
            "filename": "deps/uv/test/test-ipc-heavy-traffic-deadlock-bug.c",
            "status": "added",
            "additions": 158,
            "deletions": 0,
            "changes": 158,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-ipc-heavy-traffic-deadlock-bug.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-ipc-heavy-traffic-deadlock-bug.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-ipc-heavy-traffic-deadlock-bug.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -0,0 +1,158 @@\n+/* Copyright libuv project contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"task.h\"\n+#include \"uv.h\"\n+\n+#include <string.h>\n+\n+/* See test-ipc.c */\n+void spawn_helper(uv_pipe_t* channel,\n+                  uv_process_t* process,\n+                  const char* helper);\n+\n+#define NUM_WRITES 256\n+#define BUFFERS_PER_WRITE 3\n+#define BUFFER_SIZE 0x2000 /* 8 kb. */\n+#define BUFFER_CONTENT 42\n+\n+#define XFER_SIZE (NUM_WRITES * BUFFERS_PER_WRITE * BUFFER_SIZE)\n+\n+struct write_info {\n+  uv_write_t write_req;\n+  char buffers[BUFFER_SIZE][BUFFERS_PER_WRITE];\n+};\n+\n+static uv_shutdown_t shutdown_req;\n+\n+static size_t bytes_written;\n+static size_t bytes_read;\n+\n+static void write_cb(uv_write_t* req, int status) {\n+  struct write_info* write_info =\n+      container_of(req, struct write_info, write_req);\n+  ASSERT(status == 0);\n+  bytes_written += BUFFERS_PER_WRITE * BUFFER_SIZE;\n+  free(write_info);\n+}\n+\n+static void shutdown_cb(uv_shutdown_t* req, int status) {\n+  ASSERT(status == 0);\n+  uv_close((uv_handle_t*) req->handle, NULL);\n+}\n+\n+static void do_write(uv_stream_t* handle) {\n+  struct write_info* write_info;\n+  uv_buf_t bufs[BUFFERS_PER_WRITE];\n+  size_t i;\n+  int r;\n+\n+  write_info = malloc(sizeof *write_info);\n+  ASSERT(write_info != NULL);\n+\n+  for (i = 0; i < BUFFERS_PER_WRITE; i++) {\n+    memset(&write_info->buffers[i], BUFFER_CONTENT, BUFFER_SIZE);\n+    bufs[i] = uv_buf_init(write_info->buffers[i], BUFFER_SIZE);\n+  }\n+\n+  r = uv_write(\n+      &write_info->write_req, handle, bufs, BUFFERS_PER_WRITE, write_cb);\n+  ASSERT(r == 0);\n+}\n+\n+static void alloc_cb(uv_handle_t* handle,\n+                     size_t suggested_size,\n+                     uv_buf_t* buf) {\n+  buf->base = malloc(suggested_size);\n+  buf->len = (int) suggested_size;\n+}\n+\n+#ifndef _WIN32\n+#include <sys/types.h>\n+#include <unistd.h>\n+#endif\n+\n+static void read_cb(uv_stream_t* handle, ssize_t nread, const uv_buf_t* buf) {\n+  ssize_t i;\n+  int r;\n+\n+  ASSERT(nread >= 0);\n+  bytes_read += nread;\n+\n+  for (i = 0; i < nread; i++)\n+    ASSERT(buf->base[i] == BUFFER_CONTENT);\n+  free(buf->base);\n+\n+  if (bytes_read >= XFER_SIZE) {\n+    r = uv_read_stop(handle);\n+    ASSERT(r == 0);\n+    r = uv_shutdown(&shutdown_req, handle, shutdown_cb);\n+    ASSERT(r == 0);\n+  }\n+}\n+\n+static void do_writes_and_reads(uv_stream_t* handle) {\n+  size_t i;\n+  int r;\n+\n+  bytes_written = 0;\n+  bytes_read = 0;\n+\n+  for (i = 0; i < NUM_WRITES; i++) {\n+    do_write(handle);\n+  }\n+\n+  r = uv_read_start(handle, alloc_cb, read_cb);\n+  ASSERT(r == 0);\n+\n+  r = uv_run(handle->loop, UV_RUN_DEFAULT);\n+  ASSERT(r == 0);\n+\n+  ASSERT(bytes_written == XFER_SIZE);\n+  ASSERT(bytes_read == XFER_SIZE);\n+}\n+\n+TEST_IMPL(ipc_heavy_traffic_deadlock_bug) {\n+  uv_pipe_t pipe;\n+  uv_process_t process;\n+\n+  spawn_helper(&pipe, &process, \"ipc_helper_heavy_traffic_deadlock_bug\");\n+  do_writes_and_reads((uv_stream_t*) &pipe);\n+\n+  MAKE_VALGRIND_HAPPY();\n+  return 0;\n+}\n+\n+int ipc_helper_heavy_traffic_deadlock_bug(void) {\n+  uv_pipe_t pipe;\n+  int r;\n+\n+  r = uv_pipe_init(uv_default_loop(), &pipe, 1);\n+  ASSERT(r == 0);\n+  r = uv_pipe_open(&pipe, 0);\n+  ASSERT(r == 0);\n+\n+  do_writes_and_reads((uv_stream_t*) &pipe);\n+  uv_sleep(100);\n+\n+  MAKE_VALGRIND_HAPPY();\n+  return 0;\n+}"
        },
        {
            "sha": "3dedc86b8b01708119f6957f84b0f11a8a02cad5",
            "filename": "deps/uv/test/test-ipc-send-recv.c",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-ipc-send-recv.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-ipc-send-recv.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-ipc-send-recv.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -25,7 +25,7 @@\n #include <stdio.h>\n #include <string.h>\n \n-/* See test-ipc.ctx */\n+/* See test-ipc.c */\n void spawn_helper(uv_pipe_t* channel,\n                   uv_process_t* process,\n                   const char* helper);\n@@ -149,6 +149,7 @@ static void connect_cb(uv_connect_t* req, int status) {\n                 &ctx.send.stream,\n                 NULL);\n   ASSERT(r == 0);\n+  ASSERT(ctx.write_req.send_handle == &ctx.send.stream);\n \n   /* Perform two writes to the same pipe to make sure that on Windows we are\n    * not running into issue 505:\n@@ -160,6 +161,7 @@ static void connect_cb(uv_connect_t* req, int status) {\n                 &ctx.send2.stream,\n                 NULL);\n   ASSERT(r == 0);\n+  ASSERT(ctx.write_req2.send_handle == &ctx.send2.stream);\n \n   r = uv_read_start((uv_stream_t*)&ctx.channel, alloc_cb, recv_cb);\n   ASSERT(r == 0);\n@@ -344,6 +346,7 @@ static void read_cb(uv_stream_t* handle,\n                   &recv->stream,\n                   write2_cb);\n     ASSERT(r == 0);\n+    ASSERT(write_req->send_handle == &recv->stream);\n   } while (uv_pipe_pending_count(pipe) > 0);\n }\n "
        },
        {
            "sha": "200f68d6000a77e843d548b4ec3e84f976c04240",
            "filename": "deps/uv/test/test-ipc.c",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-ipc.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-ipc.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-ipc.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -281,7 +281,7 @@ void spawn_helper(uv_pipe_t* channel,\n   char exepath[1024];\n   char* args[3];\n   int r;\n-  uv_stdio_container_t stdio[1];\n+  uv_stdio_container_t stdio[3];\n \n   r = uv_pipe_init(uv_default_loop(), channel, 1);\n   ASSERT(r == 0);\n@@ -300,12 +300,15 @@ void spawn_helper(uv_pipe_t* channel,\n   options.file = exepath;\n   options.args = args;\n   options.exit_cb = exit_cb;\n-\n   options.stdio = stdio;\n-  options.stdio[0].flags = UV_CREATE_PIPE |\n-    UV_READABLE_PIPE | UV_WRITABLE_PIPE;\n-  options.stdio[0].data.stream = (uv_stream_t*)channel;\n-  options.stdio_count = 1;\n+  options.stdio_count = ARRAY_SIZE(stdio);\n+\n+  stdio[0].flags = UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE;\n+  stdio[0].data.stream = (uv_stream_t*) channel;\n+  stdio[1].flags = UV_INHERIT_FD;\n+  stdio[1].data.fd = 1;\n+  stdio[2].flags = UV_INHERIT_FD;\n+  stdio[2].data.fd = 2;\n \n   r = uv_spawn(uv_default_loop(), process, &options);\n   ASSERT(r == 0);"
        },
        {
            "sha": "e59c6b65513787bc9a43cd711dcf0cd39a607523",
            "filename": "deps/uv/test/test-list.h",
            "status": "modified",
            "additions": 22,
            "deletions": 4,
            "changes": 26,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-list.h",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-list.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-list.h?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -57,6 +57,7 @@ TEST_DECLARE   (tty_pty)\n TEST_DECLARE   (stdio_over_pipes)\n TEST_DECLARE   (ip6_pton)\n TEST_DECLARE   (connect_unspecified)\n+TEST_DECLARE   (ipc_heavy_traffic_deadlock_bug)\n TEST_DECLARE   (ipc_listen_before_write)\n TEST_DECLARE   (ipc_listen_after_write)\n #ifndef _WIN32\n@@ -71,8 +72,11 @@ TEST_DECLARE   (ipc_closed_handle)\n #endif\n TEST_DECLARE   (tcp_alloc_cb_fail)\n TEST_DECLARE   (tcp_ping_pong)\n-TEST_DECLARE   (tcp_ping_pong_v6)\n+TEST_DECLARE   (tcp_ping_pong_vec)\n+TEST_DECLARE   (tcp6_ping_pong)\n+TEST_DECLARE   (tcp6_ping_pong_vec)\n TEST_DECLARE   (pipe_ping_pong)\n+TEST_DECLARE   (pipe_ping_pong_vec)\n TEST_DECLARE   (delayed_accept)\n TEST_DECLARE   (multiple_listen)\n #ifndef _WIN32\n@@ -337,6 +341,8 @@ TEST_DECLARE   (fs_file_pos_after_op_with_offset)\n TEST_DECLARE   (fs_null_req)\n #ifdef _WIN32\n TEST_DECLARE   (fs_exclusive_sharing_mode)\n+TEST_DECLARE   (fs_open_readonly_acl)\n+TEST_DECLARE   (fs_fchmod_archive_readonly)\n #endif\n TEST_DECLARE   (threadpool_queue_work_simple)\n TEST_DECLARE   (threadpool_queue_work_einval)\n@@ -479,6 +485,7 @@ TASK_LIST_START\n   TEST_ENTRY  (stdio_over_pipes)\n   TEST_ENTRY  (ip6_pton)\n   TEST_ENTRY  (connect_unspecified)\n+  TEST_ENTRY  (ipc_heavy_traffic_deadlock_bug)\n   TEST_ENTRY  (ipc_listen_before_write)\n   TEST_ENTRY  (ipc_listen_after_write)\n #ifndef _WIN32\n@@ -497,12 +504,21 @@ TASK_LIST_START\n   TEST_ENTRY  (tcp_ping_pong)\n   TEST_HELPER (tcp_ping_pong, tcp4_echo_server)\n \n-  TEST_ENTRY  (tcp_ping_pong_v6)\n-  TEST_HELPER (tcp_ping_pong_v6, tcp6_echo_server)\n+  TEST_ENTRY  (tcp_ping_pong_vec)\n+  TEST_HELPER (tcp_ping_pong_vec, tcp4_echo_server)\n+\n+  TEST_ENTRY  (tcp6_ping_pong)\n+  TEST_HELPER (tcp6_ping_pong, tcp6_echo_server)\n+\n+  TEST_ENTRY  (tcp6_ping_pong_vec)\n+  TEST_HELPER (tcp6_ping_pong_vec, tcp6_echo_server)\n \n   TEST_ENTRY  (pipe_ping_pong)\n   TEST_HELPER (pipe_ping_pong, pipe_echo_server)\n \n+  TEST_ENTRY  (pipe_ping_pong_vec)\n+  TEST_HELPER (pipe_ping_pong_vec, pipe_echo_server)\n+\n   TEST_ENTRY  (delayed_accept)\n   TEST_ENTRY  (multiple_listen)\n \n@@ -708,7 +724,7 @@ TASK_LIST_START\n   TEST_ENTRY  (hrtime)\n \n   TEST_ENTRY_CUSTOM (getaddrinfo_fail, 0, 0, 10000)\n-  TEST_ENTRY  (getaddrinfo_fail_sync)\n+  TEST_ENTRY_CUSTOM (getaddrinfo_fail_sync, 0, 0, 10000)\n \n   TEST_ENTRY  (getaddrinfo_basic)\n   TEST_ENTRY  (getaddrinfo_basic_sync)\n@@ -869,6 +885,8 @@ TASK_LIST_START\n   TEST_ENTRY  (fs_null_req)\n #ifdef _WIN32\n   TEST_ENTRY  (fs_exclusive_sharing_mode)\n+  TEST_ENTRY  (fs_open_readonly_acl)\n+  TEST_ENTRY  (fs_fchmod_archive_readonly)\n #endif\n   TEST_ENTRY  (get_osfhandle_valid_handle)\n   TEST_ENTRY  (threadpool_queue_work_simple)"
        },
        {
            "sha": "6471cd08b32fc4b10d1de74603df839ac10f82b4",
            "filename": "deps/uv/test/test-loop-handles.c",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-loop-handles.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-loop-handles.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-loop-handles.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -228,8 +228,8 @@ static void check_cb(uv_check_t* handle) {\n       uv_close((uv_handle_t*)&idle_1_handles[i], idle_1_close_cb);\n     }\n \n-    /* This handle is closed/recreated every time, close it only if it is */\n-    /* active.*/\n+    /* This handle is closed/recreated every time, close it only if it is\n+     * active. */\n     if (idle_2_is_active) {\n       uv_close((uv_handle_t*)&idle_2_handle, idle_2_close_cb);\n     }\n@@ -246,10 +246,10 @@ static void prepare_2_cb(uv_prepare_t* handle) {\n   fflush(stderr);\n   ASSERT(handle == &prepare_2_handle);\n \n-  /* prepare_2 gets started by prepare_1 when (loop_iteration % 2 == 0), */\n-  /* and it stops itself immediately. A started watcher is not queued */\n-  /* until the next round, so when this callback is made */\n-  /* (loop_iteration % 2 == 0) cannot be true. */\n+  /* Prepare_2 gets started by prepare_1 when (loop_iteration % 2 == 0), and it\n+   * stops itself immediately. A started watcher is not queued until the next\n+   * round, so when this callback is made (loop_iteration % 2 == 0) cannot be\n+   * true. */\n   ASSERT(loop_iteration % 2 != 0);\n \n   r = uv_prepare_stop((uv_prepare_t*)handle);\n@@ -304,8 +304,8 @@ TEST_IMPL(loop_handles) {\n \n   /* don't init or start idle_2, both is done by idle_1_cb */\n \n-  /* the timer callback is there to keep the event loop polling */\n-  /* unref it as it is not supposed to keep the loop alive */\n+  /* The timer callback is there to keep the event loop polling unref it as it\n+   * is not supposed to keep the loop alive */\n   r = uv_timer_init(uv_default_loop(), &timer_handle);\n   ASSERT(r == 0);\n   r = uv_timer_start(&timer_handle, timer_cb, TIMEOUT, TIMEOUT);"
        },
        {
            "sha": "c86a3f4a66592f6d96fd492c751d62277dabdf0c",
            "filename": "deps/uv/test/test-ping-pong.c",
            "status": "modified",
            "additions": 58,
            "deletions": 31,
            "changes": 89,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-ping-pong.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-ping-pong.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-ping-pong.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -22,8 +22,8 @@\n #include \"uv.h\"\n #include \"task.h\"\n \n-#include <stdlib.h>\n #include <stdio.h>\n+#include <stdlib.h>\n \n static int completed_pingers = 0;\n \n@@ -41,6 +41,7 @@ static int pinger_on_connect_count;\n \n \n typedef struct {\n+  int vectored_writes;\n   int pongs;\n   int state;\n   union {\n@@ -77,15 +78,26 @@ static void pinger_after_write(uv_write_t *req, int status) {\n \n static void pinger_write_ping(pinger_t* pinger) {\n   uv_write_t *req;\n-  uv_buf_t buf;\n-\n-  buf = uv_buf_init(PING, sizeof(PING) - 1);\n+  uv_buf_t bufs[sizeof PING - 1];\n+  int i, nbufs;\n+\n+  if (!pinger->vectored_writes) {\n+    /* Write a single buffer. */\n+    nbufs = 1;\n+    bufs[0] = uv_buf_init(PING, sizeof PING - 1);\n+  } else {\n+    /* Write multiple buffers, each with one byte in them. */\n+    nbufs = sizeof PING - 1;\n+    for (i = 0; i < nbufs; i++) {\n+      bufs[i] = uv_buf_init(&PING[i], 1);\n+    }\n+  }\n \n   req = malloc(sizeof(*req));\n   if (uv_write(req,\n                (uv_stream_t*) &pinger->stream.tcp,\n-               &buf,\n-               1,\n+               bufs,\n+               nbufs,\n                pinger_after_write)) {\n     FATAL(\"uv_write failed\");\n   }\n@@ -154,7 +166,7 @@ static void pinger_on_connect(uv_connect_t *req, int status) {\n \n \n /* same ping-pong test, but using IPv6 connection */\n-static void tcp_pinger_v6_new(void) {\n+static void tcp_pinger_v6_new(int vectored_writes) {\n   int r;\n   struct sockaddr_in6 server_addr;\n   pinger_t *pinger;\n@@ -163,6 +175,7 @@ static void tcp_pinger_v6_new(void) {\n   ASSERT(0 ==uv_ip6_addr(\"::1\", TEST_PORT, &server_addr));\n   pinger = malloc(sizeof(*pinger));\n   ASSERT(pinger != NULL);\n+  pinger->vectored_writes = vectored_writes;\n   pinger->state = 0;\n   pinger->pongs = 0;\n \n@@ -171,8 +184,8 @@ static void tcp_pinger_v6_new(void) {\n   pinger->stream.tcp.data = pinger;\n   ASSERT(!r);\n \n-  /* We are never doing multiple reads/connects at a time anyway. */\n-  /* so these handles can be pre-initialized. */\n+  /* We are never doing multiple reads/connects at a time anyway, so these\n+   * handles can be pre-initialized. */\n   r = uv_tcp_connect(&pinger->connect_req,\n                      &pinger->stream.tcp,\n                      (const struct sockaddr*) &server_addr,\n@@ -184,14 +197,15 @@ static void tcp_pinger_v6_new(void) {\n }\n \n \n-static void tcp_pinger_new(void) {\n+static void tcp_pinger_new(int vectored_writes) {\n   int r;\n   struct sockaddr_in server_addr;\n   pinger_t *pinger;\n \n   ASSERT(0 == uv_ip4_addr(\"127.0.0.1\", TEST_PORT, &server_addr));\n   pinger = malloc(sizeof(*pinger));\n   ASSERT(pinger != NULL);\n+  pinger->vectored_writes = vectored_writes;\n   pinger->state = 0;\n   pinger->pongs = 0;\n \n@@ -200,8 +214,8 @@ static void tcp_pinger_new(void) {\n   pinger->stream.tcp.data = pinger;\n   ASSERT(!r);\n \n-  /* We are never doing multiple reads/connects at a time anyway. */\n-  /* so these handles can be pre-initialized. */\n+  /* We are never doing multiple reads/connects at a time anyway, so these\n+   * handles can be pre-initialized. */\n   r = uv_tcp_connect(&pinger->connect_req,\n                      &pinger->stream.tcp,\n                      (const struct sockaddr*) &server_addr,\n@@ -213,12 +227,13 @@ static void tcp_pinger_new(void) {\n }\n \n \n-static void pipe_pinger_new(void) {\n+static void pipe_pinger_new(int vectored_writes) {\n   int r;\n   pinger_t *pinger;\n \n   pinger = (pinger_t*)malloc(sizeof(*pinger));\n   ASSERT(pinger != NULL);\n+  pinger->vectored_writes = vectored_writes;\n   pinger->state = 0;\n   pinger->pongs = 0;\n \n@@ -227,9 +242,8 @@ static void pipe_pinger_new(void) {\n   pinger->stream.pipe.data = pinger;\n   ASSERT(!r);\n \n-  /* We are never doing multiple reads/connects at a time anyway. */\n-  /* so these handles can be pre-initialized. */\n-\n+  /* We are never doing multiple reads/connects at a time anyway, so these\n+   * handles can be pre-initialized. */\n   uv_pipe_connect(&pinger->connect_req, &pinger->stream.pipe, TEST_PIPENAME,\n       pinger_on_connect);\n \n@@ -238,37 +252,50 @@ static void pipe_pinger_new(void) {\n }\n \n \n-TEST_IMPL(tcp_ping_pong) {\n-  tcp_pinger_new();\n+static int run_ping_pong_test(void) {\n   uv_run(uv_default_loop(), UV_RUN_DEFAULT);\n-\n   ASSERT(completed_pingers == 1);\n \n   MAKE_VALGRIND_HAPPY();\n   return 0;\n }\n \n \n-TEST_IMPL(tcp_ping_pong_v6) {\n+TEST_IMPL(tcp_ping_pong) {\n+  tcp_pinger_new(0);\n+  return run_ping_pong_test();\n+}\n+\n+\n+TEST_IMPL(tcp_ping_pong_vec) {\n+  tcp_pinger_new(1);\n+  return run_ping_pong_test();\n+}\n+\n+\n+TEST_IMPL(tcp6_ping_pong) {\n   if (!can_ipv6())\n     RETURN_SKIP(\"IPv6 not supported\");\n+  tcp_pinger_v6_new(0);\n+  return run_ping_pong_test();\n+}\n \n-  tcp_pinger_v6_new();\n-  uv_run(uv_default_loop(), UV_RUN_DEFAULT);\n \n-  ASSERT(completed_pingers == 1);\n-\n-  MAKE_VALGRIND_HAPPY();\n-  return 0;\n+TEST_IMPL(tcp6_ping_pong_vec) {\n+  if (!can_ipv6())\n+    RETURN_SKIP(\"IPv6 not supported\");\n+  tcp_pinger_v6_new(1);\n+  return run_ping_pong_test();\n }\n \n \n TEST_IMPL(pipe_ping_pong) {\n-  pipe_pinger_new();\n-  uv_run(uv_default_loop(), UV_RUN_DEFAULT);\n+  pipe_pinger_new(0);\n+  return run_ping_pong_test();\n+}\n \n-  ASSERT(completed_pingers == 1);\n \n-  MAKE_VALGRIND_HAPPY();\n-  return 0;\n+TEST_IMPL(pipe_ping_pong_vec) {\n+  pipe_pinger_new(1);\n+  return run_ping_pong_test();\n }"
        },
        {
            "sha": "91e476652e027f3311880e8746cffbf2c6beeebf",
            "filename": "deps/uv/test/test-pipe-set-fchmod.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-pipe-set-fchmod.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-pipe-set-fchmod.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-pipe-set-fchmod.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -39,8 +39,8 @@ TEST_IMPL(pipe_set_chmod) {\n   r = uv_pipe_bind(&pipe_handle, TEST_PIPENAME);\n   ASSERT(r == 0);\n \n-  /* No easy way to test if this works, we will only make sure that */\n-  /* the call is successful. */\n+  /* No easy way to test if this works, we will only make sure that the call is\n+   * successful. */\n   r = uv_pipe_chmod(&pipe_handle, UV_READABLE);\n   if (r == UV_EPERM) {\n     MAKE_VALGRIND_HAPPY();"
        },
        {
            "sha": "cc3fd41a13683373ee6873d361a0e2c576b5ea4d",
            "filename": "deps/uv/test/test-process-title-threadsafe.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-process-title-threadsafe.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-process-title-threadsafe.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-process-title-threadsafe.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -26,7 +26,7 @@\n #include <string.h>\n \n #ifdef __APPLE__\n-# define NUM_ITERATIONS 20\n+# define NUM_ITERATIONS 10\n #else\n # define NUM_ITERATIONS 50\n #endif"
        },
        {
            "sha": "79242fc9fa99e7029d94541777c39bd15c28a882",
            "filename": "deps/uv/test/test-signal-multiple-loops.c",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-signal-multiple-loops.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-signal-multiple-loops.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-signal-multiple-loops.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -249,7 +249,7 @@ TEST_IMPL(signal_multiple_loops) {\n     uv_sem_wait(&sem);\n \n   /* Block all signals to this thread, so we are sure that from here the signal\n-   * handler runs in another thread. This is is more likely to catch thread and\n+   * handler runs in another thread. This is more likely to catch thread and\n    * signal safety issues if there are any.\n    */\n   sigfillset(&sigset);"
        },
        {
            "sha": "1ab6e78807ff5f2a63ff58af68b97c2cf79c3754",
            "filename": "deps/uv/test/test-spawn.c",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-spawn.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-spawn.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-spawn.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -1637,8 +1637,8 @@ TEST_IMPL(spawn_reads_child_path) {\n   static const char dyld_path_var[] = \"LD_LIBRARY_PATH\";\n #endif\n \n-  /* Set up the process, but make sure that the file to run is relative and */\n-  /* requires a lookup into PATH */\n+  /* Set up the process, but make sure that the file to run is relative and\n+   * requires a lookup into PATH. */\n   init_process_options(\"spawn_helper1\", exit_cb);\n \n   /* Set up the PATH env variable */\n@@ -1805,8 +1805,8 @@ TEST_IMPL(spawn_quoted_path) {\n   options.args = args;\n   options.exit_cb = exit_cb;\n   options.flags = 0;\n-  /* We test if search_path works correctly with semicolons in quoted path. */\n-  /* We will use invalid drive, so we are sure no executable is spawned */\n+  /* We test if search_path works correctly with semicolons in quoted path. We\n+   * will use an invalid drive, so we are sure no executable is spawned. */\n   quoted_path_env[0] = \"PATH=\\\"xyz:\\\\test;\\\";xyz:\\\\other\";\n   quoted_path_env[1] = NULL;\n   options.env = quoted_path_env;"
        },
        {
            "sha": "f5d8f136b1f6004dc5c5a2c693118624187f0ad2",
            "filename": "deps/uv/test/test-tcp-open.c",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-tcp-open.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-tcp-open.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-tcp-open.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -181,6 +181,20 @@ TEST_IMPL(tcp_open) {\n                      connect_cb);\n   ASSERT(r == 0);\n \n+#ifndef _WIN32\n+  {\n+    uv_tcp_t client2;\n+\n+    r = uv_tcp_init(uv_default_loop(), &client2);\n+    ASSERT(r == 0);\n+\n+    r = uv_tcp_open(&client2, sock);\n+    ASSERT(r == UV_EEXIST);\n+\n+    uv_close((uv_handle_t*) &client2, NULL);\n+  }\n+#endif  /* !_WIN32 */\n+\n   uv_run(uv_default_loop(), UV_RUN_DEFAULT);\n \n   ASSERT(shutdown_cb_called == 1);"
        },
        {
            "sha": "e87d2edf18f121ddba20e99112c2fbe128c5f370",
            "filename": "deps/uv/test/test-timer-again.c",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-timer-again.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-timer-again.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-timer-again.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -58,8 +58,8 @@ static void repeat_1_cb(uv_timer_t* handle) {\n \n   if (repeat_1_cb_called == 10) {\n     uv_close((uv_handle_t*)handle, close_cb);\n-    /* We're not calling uv_timer_again on repeat_2 any more, so after this */\n-    /* timer_2_cb is expected. */\n+    /* We're not calling uv_timer_again on repeat_2 any more, so after this\n+     * timer_2_cb is expected. */\n     repeat_2_cb_allowed = 1;\n     return;\n   }"
        },
        {
            "sha": "0cee09c942ef2cdaf08bb3d91e3e3e13c548d0f8",
            "filename": "deps/uv/test/test-udp-alloc-cb-fail.c",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-alloc-cb-fail.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-alloc-cb-fail.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-udp-alloc-cb-fail.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -120,8 +120,7 @@ static void sv_recv_cb(uv_udp_t* handle,\n   }\n \n   if (nread == 0) {\n-    /* Returning unused buffer */\n-    /* Don't count towards sv_recv_cb_called */\n+    /* Returning unused buffer. Don't count towards sv_recv_cb_called */\n     ASSERT(addr == NULL);\n     return;\n   }"
        },
        {
            "sha": "053d2f791498f7cd16180489fe9f5f9eb50c1db6",
            "filename": "deps/uv/test/test-udp-multicast-join.c",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-multicast-join.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-multicast-join.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-udp-multicast-join.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -81,8 +81,7 @@ static void cl_recv_cb(uv_udp_t* handle,\n   }\n \n   if (nread == 0) {\n-    /* Returning unused buffer */\n-    /* Don't count towards cl_recv_cb_called */\n+    /* Returning unused buffer. Don't count towards cl_recv_cb_called */\n     ASSERT(addr == NULL);\n     return;\n   }"
        },
        {
            "sha": "bda5e20ea704034c0a80fd2b4920b3effa027354",
            "filename": "deps/uv/test/test-udp-multicast-join6.c",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-multicast-join6.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-multicast-join6.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-udp-multicast-join6.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -82,8 +82,7 @@ static void cl_recv_cb(uv_udp_t* handle,\n   }\n \n   if (nread == 0) {\n-    /* Returning unused buffer */\n-    /* Don't count towards cl_recv_cb_called */\n+    /* Returning unused buffer. Don't count towards cl_recv_cb_called */\n     ASSERT(addr == NULL);\n     return;\n   }"
        },
        {
            "sha": "ee04c99f61bae26823754a1157c8eb9e560efce9",
            "filename": "deps/uv/test/test-udp-open.c",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-open.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-open.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-udp-open.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -106,8 +106,7 @@ static void recv_cb(uv_udp_t* handle,\n   }\n \n   if (nread == 0) {\n-    /* Returning unused buffer */\n-    /* Don't count towards sv_recv_cb_called */\n+    /* Returning unused buffer. Don't count towards sv_recv_cb_called */\n     ASSERT(addr == NULL);\n     return;\n   }\n@@ -165,6 +164,20 @@ TEST_IMPL(udp_open) {\n                   send_cb);\n   ASSERT(r == 0);\n \n+#ifndef _WIN32\n+  {\n+    uv_udp_t client2;\n+\n+    r = uv_udp_init(uv_default_loop(), &client2);\n+    ASSERT(r == 0);\n+\n+    r = uv_udp_open(&client2, sock);\n+    ASSERT(r == UV_EEXIST);\n+\n+    uv_close((uv_handle_t*) &client2, NULL);\n+  }\n+#endif  /* !_WIN32 */\n+\n   uv_run(uv_default_loop(), UV_RUN_DEFAULT);\n \n   ASSERT(send_cb_called == 1);"
        },
        {
            "sha": "d8c9d68d81b42853992559e7954b161593d80279",
            "filename": "deps/uv/test/test-udp-options.c",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-options.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-options.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-udp-options.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -114,9 +114,11 @@ TEST_IMPL(udp_options6) {\n TEST_IMPL(udp_no_autobind) {\n   uv_loop_t* loop;\n   uv_udp_t h;\n+  uv_udp_t h2;\n \n   loop = uv_default_loop();\n \n+  /* Test a lazy initialized socket. */\n   ASSERT(0 == uv_udp_init(loop, &h));\n   ASSERT(UV_EBADF == uv_udp_set_multicast_ttl(&h, 32));\n   ASSERT(UV_EBADF == uv_udp_set_broadcast(&h, 1));\n@@ -130,6 +132,23 @@ TEST_IMPL(udp_no_autobind) {\n \n   uv_close((uv_handle_t*) &h, NULL);\n \n+  /* Test a non-lazily initialized socket. */\n+  ASSERT(0 == uv_udp_init_ex(loop, &h2, AF_INET));\n+  ASSERT(0 == uv_udp_set_multicast_ttl(&h2, 32));\n+  ASSERT(0 == uv_udp_set_broadcast(&h2, 1));\n+\n+#if defined(__MVS__)\n+  /* zOS only supports setting ttl for IPv6 sockets. */\n+  ASSERT(UV_ENOTSUP == uv_udp_set_ttl(&h2, 1));\n+#else\n+  ASSERT(0 == uv_udp_set_ttl(&h2, 1));\n+#endif\n+\n+  ASSERT(0 == uv_udp_set_multicast_loop(&h2, 1));\n+  ASSERT(0 == uv_udp_set_multicast_interface(&h2, \"0.0.0.0\"));\n+\n+  uv_close((uv_handle_t*) &h2, NULL);\n+\n   ASSERT(0 == uv_run(loop, UV_RUN_DEFAULT));\n \n   MAKE_VALGRIND_HAPPY();"
        },
        {
            "sha": "1f01188b274a4994e603df20fa0d59e027da4e88",
            "filename": "deps/uv/test/test-udp-send-and-recv.c",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-send-and-recv.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-send-and-recv.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-udp-send-and-recv.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -72,8 +72,7 @@ static void cl_recv_cb(uv_udp_t* handle,\n   }\n \n   if (nread == 0) {\n-    /* Returning unused buffer */\n-    /* Don't count towards cl_recv_cb_called */\n+    /* Returning unused buffer. Don't count towards cl_recv_cb_called */\n     ASSERT(addr == NULL);\n     return;\n   }\n@@ -128,8 +127,7 @@ static void sv_recv_cb(uv_udp_t* handle,\n   }\n \n   if (nread == 0) {\n-    /* Returning unused buffer */\n-    /* Don't count towards sv_recv_cb_called */\n+    /* Returning unused buffer. Don't count towards sv_recv_cb_called */\n     ASSERT(addr == NULL);\n     return;\n   }"
        },
        {
            "sha": "1011aa467e054130bfbc67655633084c055c3cf8",
            "filename": "deps/uv/test/test-udp-send-immediate.c",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-send-immediate.c",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest-udp-send-immediate.c",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest-udp-send-immediate.c?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -74,8 +74,7 @@ static void sv_recv_cb(uv_udp_t* handle,\n   }\n \n   if (nread == 0) {\n-    /* Returning unused buffer */\n-    /* Don't count towards sv_recv_cb_called */\n+    /* Returning unused buffer. Don't count towards sv_recv_cb_called */\n     ASSERT(addr == NULL);\n     return;\n   }"
        },
        {
            "sha": "917533618bf12c7ec27f7d3144d3f763ebc3e594",
            "filename": "deps/uv/test/test.gyp",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Ftest%2Ftest.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Ftest%2Ftest.gyp?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -47,8 +47,9 @@\n         'test-hrtime.c',\n         'test-idle.c',\n         'test-ip6-addr.c',\n-        'test-ipc.c',\n+        'test-ipc-heavy-traffic-deadlock-bug.c',\n         'test-ipc-send-recv.c',\n+        'test-ipc.c',\n         'test-list.h',\n         'test-loop-handles.c',\n         'test-loop-alive.c',"
        },
        {
            "sha": "8aaf541b996f511d4de4cb177019e2e4ae006aa0",
            "filename": "deps/uv/uv.gyp",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fuv.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/537a4baa443daea9850a8e324b5b4d7c21dd2717/deps%2Fuv%2Fuv.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fuv%2Fuv.gyp?ref=537a4baa443daea9850a8e324b5b4d7c21dd2717",
            "patch": "@@ -64,10 +64,10 @@\n       'sources': [\n         'common.gypi',\n         'include/uv.h',\n-        'include/tree.h',\n-        'include/uv-errno.h',\n-        'include/uv-threadpool.h',\n-        'include/uv-version.h',\n+        'include/uv/tree.h',\n+        'include/uv/errno.h',\n+        'include/uv/threadpool.h',\n+        'include/uv/version.h',\n         'src/fs-poll.c',\n         'src/heap-inl.h',\n         'src/inet.c',\n@@ -95,7 +95,7 @@\n             '_GNU_SOURCE',\n           ],\n           'sources': [\n-            'include/uv-win.h',\n+            'include/uv/win.h',\n             'src/win/async.c',\n             'src/win/atomicops-inl.h',\n             'src/win/core.c',\n@@ -144,12 +144,12 @@\n           },\n         }, { # Not Windows i.e. POSIX\n           'sources': [\n-            'include/uv-unix.h',\n-            'include/uv-linux.h',\n-            'include/uv-sunos.h',\n-            'include/uv-darwin.h',\n-            'include/uv-bsd.h',\n-            'include/uv-aix.h',\n+            'include/uv/unix.h',\n+            'include/uv/linux.h',\n+            'include/uv/sunos.h',\n+            'include/uv/darwin.h',\n+            'include/uv/bsd.h',\n+            'include/uv/aix.h',\n             'src/unix/async.c',\n             'src/unix/atomic-ops.h',\n             'src/unix/core.c',\n@@ -199,7 +199,7 @@\n             ['uv_library==\"shared_library\" and OS!=\"mac\" and OS!=\"zos\"', {\n               # This will cause gyp to set soname\n               # Must correspond with UV_VERSION_MAJOR\n-              # in include/uv-version.h\n+              # in include/uv/version.h\n               'product_extension': 'so.1',\n             }],\n           ],"
        }
    ],
    "stats": {
        "total": 4035,
        "additions": 2345,
        "deletions": 1690
    }
}