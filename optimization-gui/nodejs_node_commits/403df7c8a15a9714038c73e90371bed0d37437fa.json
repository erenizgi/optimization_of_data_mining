{
    "author": "unknown",
    "message": "n-api: clean up thread-safe function\n\n* Move class `TsFn` to name space `v8impl` and rename it to\n  `ThreadSafeFunction`\n* Remove `NAPI_EXTERN` from API declarations, because it's only needed\n  in the header file.\n\nPR-URL: https://github.com/nodejs/node/pull/22259\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Kyle Farnung <kfarnung@microsoft.com>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>",
    "sha": "403df7c8a15a9714038c73e90371bed0d37437fa",
    "files": [
        {
            "sha": "22be3647ea86dd8822cda79a3b33ccbde77598ef",
            "filename": "src/node_api.cc",
            "status": "modified",
            "additions": 439,
            "deletions": 434,
            "changes": 873,
            "blob_url": "https://github.com/nodejs/node/blob/403df7c8a15a9714038c73e90371bed0d37437fa/src%2Fnode_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/403df7c8a15a9714038c73e90371bed0d37437fa/src%2Fnode_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api.cc?ref=403df7c8a15a9714038c73e90371bed0d37437fa",
            "patch": "@@ -827,6 +827,336 @@ napi_status ConcludeDeferred(napi_env env,\n   return GET_RETURN_STATUS(env);\n }\n \n+class ThreadSafeFunction : public node::AsyncResource {\n+ public:\n+  ThreadSafeFunction(v8::Local<v8::Function> func,\n+                     v8::Local<v8::Object> resource,\n+                     v8::Local<v8::String> name,\n+                     size_t thread_count_,\n+                     void* context_,\n+                     size_t max_queue_size_,\n+                     napi_env env_,\n+                     void* finalize_data_,\n+                     napi_finalize finalize_cb_,\n+                     napi_threadsafe_function_call_js call_js_cb_):\n+                     AsyncResource(env_->isolate,\n+                                   resource,\n+                                   *v8::String::Utf8Value(env_->isolate, name)),\n+      thread_count(thread_count_),\n+      is_closing(false),\n+      context(context_),\n+      max_queue_size(max_queue_size_),\n+      env(env_),\n+      finalize_data(finalize_data_),\n+      finalize_cb(finalize_cb_),\n+      call_js_cb(call_js_cb_ == nullptr ? CallJs : call_js_cb_),\n+      handles_closing(false) {\n+    ref.Reset(env->isolate, func);\n+    node::AddEnvironmentCleanupHook(env->isolate, Cleanup, this);\n+  }\n+\n+  ~ThreadSafeFunction() {\n+    node::RemoveEnvironmentCleanupHook(env->isolate, Cleanup, this);\n+  }\n+\n+  // These methods can be called from any thread.\n+\n+  napi_status Push(void* data, napi_threadsafe_function_call_mode mode) {\n+    node::Mutex::ScopedLock lock(this->mutex);\n+\n+    while (queue.size() >= max_queue_size &&\n+        max_queue_size > 0 &&\n+        !is_closing) {\n+      if (mode == napi_tsfn_nonblocking) {\n+        return napi_queue_full;\n+      }\n+      cond->Wait(lock);\n+    }\n+\n+    if (is_closing) {\n+      if (thread_count == 0) {\n+        return napi_invalid_arg;\n+      } else {\n+        thread_count--;\n+        return napi_closing;\n+      }\n+    } else {\n+      if (uv_async_send(&async) != 0) {\n+        return napi_generic_failure;\n+      }\n+      queue.push(data);\n+      return napi_ok;\n+    }\n+  }\n+\n+  napi_status Acquire() {\n+    node::Mutex::ScopedLock lock(this->mutex);\n+\n+    if (is_closing) {\n+      return napi_closing;\n+    }\n+\n+    thread_count++;\n+\n+    return napi_ok;\n+  }\n+\n+  napi_status Release(napi_threadsafe_function_release_mode mode) {\n+    node::Mutex::ScopedLock lock(this->mutex);\n+\n+    if (thread_count == 0) {\n+      return napi_invalid_arg;\n+    }\n+\n+    thread_count--;\n+\n+    if (thread_count == 0 || mode == napi_tsfn_abort) {\n+      if (!is_closing) {\n+        is_closing = (mode == napi_tsfn_abort);\n+        if (is_closing && max_queue_size > 0) {\n+          cond->Signal(lock);\n+        }\n+        if (uv_async_send(&async) != 0) {\n+          return napi_generic_failure;\n+        }\n+      }\n+    }\n+\n+    return napi_ok;\n+  }\n+\n+  void EmptyQueueAndDelete() {\n+    for (; !queue.empty() ; queue.pop()) {\n+      call_js_cb(nullptr, nullptr, context, queue.front());\n+    }\n+    delete this;\n+  }\n+\n+  // These methods must only be called from the loop thread.\n+\n+  napi_status Init() {\n+    ThreadSafeFunction* ts_fn = this;\n+\n+    if (uv_async_init(env->loop, &async, AsyncCb) == 0) {\n+      if (max_queue_size > 0) {\n+        cond.reset(new node::ConditionVariable);\n+      }\n+      if ((max_queue_size == 0 || cond.get() != nullptr) &&\n+          uv_idle_init(env->loop, &idle) == 0) {\n+        return napi_ok;\n+      }\n+\n+      node::Environment::GetCurrent(env->isolate)->CloseHandle(\n+          reinterpret_cast<uv_handle_t*>(&async),\n+          [](uv_handle_t* handle) -> void {\n+            ThreadSafeFunction* ts_fn =\n+                node::ContainerOf(&ThreadSafeFunction::async,\n+                                  reinterpret_cast<uv_async_t*>(handle));\n+            delete ts_fn;\n+          });\n+\n+      // Prevent the thread-safe function from being deleted here, because\n+      // the callback above will delete it.\n+      ts_fn = nullptr;\n+    }\n+\n+    delete ts_fn;\n+\n+    return napi_generic_failure;\n+  }\n+\n+  napi_status Unref() {\n+    uv_unref(reinterpret_cast<uv_handle_t*>(&async));\n+    uv_unref(reinterpret_cast<uv_handle_t*>(&idle));\n+\n+    return napi_ok;\n+  }\n+\n+  napi_status Ref() {\n+    uv_ref(reinterpret_cast<uv_handle_t*>(&async));\n+    uv_ref(reinterpret_cast<uv_handle_t*>(&idle));\n+\n+    return napi_ok;\n+  }\n+\n+  void DispatchOne() {\n+    void* data = nullptr;\n+    bool popped_value = false;\n+    bool idle_stop_failed = false;\n+\n+    {\n+      node::Mutex::ScopedLock lock(this->mutex);\n+      if (is_closing) {\n+        CloseHandlesAndMaybeDelete();\n+      } else {\n+        size_t size = queue.size();\n+        if (size > 0) {\n+          data = queue.front();\n+          queue.pop();\n+          popped_value = true;\n+          if (size == max_queue_size && max_queue_size > 0) {\n+            cond->Signal(lock);\n+          }\n+          size--;\n+        }\n+\n+        if (size == 0) {\n+          if (thread_count == 0) {\n+            is_closing = true;\n+            if (max_queue_size > 0) {\n+              cond->Signal(lock);\n+            }\n+            CloseHandlesAndMaybeDelete();\n+          } else {\n+            if (uv_idle_stop(&idle) != 0) {\n+              idle_stop_failed = true;\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    if (popped_value || idle_stop_failed) {\n+      v8::HandleScope scope(env->isolate);\n+      CallbackScope cb_scope(this);\n+\n+      if (idle_stop_failed) {\n+        CHECK(napi_throw_error(env,\n+                               \"ERR_NAPI_TSFN_STOP_IDLE_LOOP\",\n+                               \"Failed to stop the idle loop\") == napi_ok);\n+      } else {\n+        v8::Local<v8::Function> js_cb =\n+            v8::Local<v8::Function>::New(env->isolate, ref);\n+        call_js_cb(env,\n+                   v8impl::JsValueFromV8LocalValue(js_cb),\n+                   context,\n+                   data);\n+      }\n+    }\n+  }\n+\n+  node::Environment* NodeEnv() {\n+    // For some reason grabbing the Node.js environment requires a handle scope.\n+    v8::HandleScope scope(env->isolate);\n+    return node::Environment::GetCurrent(env->isolate);\n+  }\n+\n+  void MaybeStartIdle() {\n+    if (uv_idle_start(&idle, IdleCb) != 0) {\n+      v8::HandleScope scope(env->isolate);\n+      CallbackScope cb_scope(this);\n+      CHECK(napi_throw_error(env,\n+                             \"ERR_NAPI_TSFN_START_IDLE_LOOP\",\n+                             \"Failed to start the idle loop\") == napi_ok);\n+    }\n+  }\n+\n+  void Finalize() {\n+    v8::HandleScope scope(env->isolate);\n+    if (finalize_cb) {\n+      CallbackScope cb_scope(this);\n+      finalize_cb(env, finalize_data, context);\n+    }\n+    EmptyQueueAndDelete();\n+  }\n+\n+  inline void* Context() {\n+    return context;\n+  }\n+\n+  void CloseHandlesAndMaybeDelete(bool set_closing = false) {\n+    if (set_closing) {\n+      node::Mutex::ScopedLock lock(this->mutex);\n+      is_closing = true;\n+      if (max_queue_size > 0) {\n+        cond->Signal(lock);\n+      }\n+    }\n+    if (handles_closing) {\n+      return;\n+    }\n+    handles_closing = true;\n+    NodeEnv()->CloseHandle(\n+        reinterpret_cast<uv_handle_t*>(&async),\n+        [](uv_handle_t* handle) -> void {\n+          ThreadSafeFunction* ts_fn =\n+              node::ContainerOf(&ThreadSafeFunction::async,\n+                                reinterpret_cast<uv_async_t*>(handle));\n+          ts_fn->NodeEnv()->CloseHandle(\n+              reinterpret_cast<uv_handle_t*>(&ts_fn->idle),\n+              [](uv_handle_t* handle) -> void {\n+                ThreadSafeFunction* ts_fn =\n+                    node::ContainerOf(&ThreadSafeFunction::idle,\n+                                      reinterpret_cast<uv_idle_t*>(handle));\n+                ts_fn->Finalize();\n+              });\n+        });\n+  }\n+\n+  // Default way of calling into JavaScript. Used when ThreadSafeFunction is\n+  //  without a call_js_cb_.\n+  static void CallJs(napi_env env, napi_value cb, void* context, void* data) {\n+    if (!(env == nullptr || cb == nullptr)) {\n+      napi_value recv;\n+      napi_status status;\n+\n+      status = napi_get_undefined(env, &recv);\n+      if (status != napi_ok) {\n+        napi_throw_error(env, \"ERR_NAPI_TSFN_GET_UNDEFINED\",\n+            \"Failed to retrieve undefined value\");\n+        return;\n+      }\n+\n+      status = napi_call_function(env, recv, cb, 0, nullptr, nullptr);\n+      if (status != napi_ok && status != napi_pending_exception) {\n+        napi_throw_error(env, \"ERR_NAPI_TSFN_CALL_JS\",\n+            \"Failed to call JS callback\");\n+        return;\n+      }\n+    }\n+  }\n+\n+  static void IdleCb(uv_idle_t* idle) {\n+    ThreadSafeFunction* ts_fn =\n+        node::ContainerOf(&ThreadSafeFunction::idle, idle);\n+    ts_fn->DispatchOne();\n+  }\n+\n+  static void AsyncCb(uv_async_t* async) {\n+    ThreadSafeFunction* ts_fn =\n+        node::ContainerOf(&ThreadSafeFunction::async, async);\n+    ts_fn->MaybeStartIdle();\n+  }\n+\n+  static void Cleanup(void* data) {\n+    reinterpret_cast<ThreadSafeFunction*>(data)\n+        ->CloseHandlesAndMaybeDelete(true);\n+  }\n+\n+ private:\n+  // These are variables protected by the mutex.\n+  node::Mutex mutex;\n+  std::unique_ptr<node::ConditionVariable> cond;\n+  std::queue<void*> queue;\n+  uv_async_t async;\n+  uv_idle_t idle;\n+  size_t thread_count;\n+  bool is_closing;\n+\n+  // These are variables set once, upon creation, and then never again, which\n+  // means we don't need the mutex to read them.\n+  void* context;\n+  size_t max_queue_size;\n+\n+  // These are variables accessed only from the loop thread.\n+  node::Persistent<v8::Function> ref;\n+  napi_env env;\n+  void* finalize_data;\n+  napi_finalize finalize_cb;\n+  napi_threadsafe_function_call_js call_js_cb;\n+  bool handles_closing;\n+};\n+\n }  // end of namespace v8impl\n \n // Intercepts the Node-V8 module registration callback. Converts parameters\n@@ -3591,448 +3921,121 @@ napi_status napi_create_async_work(napi_env env,\n   return napi_clear_last_error(env);\n }\n \n-napi_status napi_delete_async_work(napi_env env, napi_async_work work) {\n-  CHECK_ENV(env);\n-  CHECK_ARG(env, work);\n-\n-  uvimpl::Work::Delete(reinterpret_cast<uvimpl::Work*>(work));\n-\n-  return napi_clear_last_error(env);\n-}\n-\n-napi_status napi_get_uv_event_loop(napi_env env, uv_loop_t** loop) {\n-  CHECK_ENV(env);\n-  CHECK_ARG(env, loop);\n-  *loop = env->loop;\n-  return napi_clear_last_error(env);\n-}\n-\n-napi_status napi_queue_async_work(napi_env env, napi_async_work work) {\n-  CHECK_ENV(env);\n-  CHECK_ARG(env, work);\n-\n-  napi_status status;\n-  uv_loop_t* event_loop = nullptr;\n-  status = napi_get_uv_event_loop(env, &event_loop);\n-  if (status != napi_ok)\n-    return napi_set_last_error(env, status);\n-\n-  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);\n-\n-  w->ScheduleWork();\n-\n-  return napi_clear_last_error(env);\n-}\n-\n-napi_status napi_cancel_async_work(napi_env env, napi_async_work work) {\n-  CHECK_ENV(env);\n-  CHECK_ARG(env, work);\n-\n-  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);\n-\n-  CALL_UV(env, w->CancelWork());\n-\n-  return napi_clear_last_error(env);\n-}\n-\n-napi_status napi_create_promise(napi_env env,\n-                                napi_deferred* deferred,\n-                                napi_value* promise) {\n-  NAPI_PREAMBLE(env);\n-  CHECK_ARG(env, deferred);\n-  CHECK_ARG(env, promise);\n-\n-  auto maybe = v8::Promise::Resolver::New(env->isolate->GetCurrentContext());\n-  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);\n-\n-  auto v8_resolver = maybe.ToLocalChecked();\n-  auto v8_deferred = new node::Persistent<v8::Value>();\n-  v8_deferred->Reset(env->isolate, v8_resolver);\n-\n-  *deferred = v8impl::JsDeferredFromNodePersistent(v8_deferred);\n-  *promise = v8impl::JsValueFromV8LocalValue(v8_resolver->GetPromise());\n-  return GET_RETURN_STATUS(env);\n-}\n-\n-napi_status napi_resolve_deferred(napi_env env,\n-                                  napi_deferred deferred,\n-                                  napi_value resolution) {\n-  return v8impl::ConcludeDeferred(env, deferred, resolution, true);\n-}\n-\n-napi_status napi_reject_deferred(napi_env env,\n-                                 napi_deferred deferred,\n-                                 napi_value resolution) {\n-  return v8impl::ConcludeDeferred(env, deferred, resolution, false);\n-}\n-\n-napi_status napi_is_promise(napi_env env,\n-                            napi_value promise,\n-                            bool* is_promise) {\n-  CHECK_ENV(env);\n-  CHECK_ARG(env, promise);\n-  CHECK_ARG(env, is_promise);\n-\n-  *is_promise = v8impl::V8LocalValueFromJsValue(promise)->IsPromise();\n-\n-  return napi_clear_last_error(env);\n-}\n-\n-napi_status napi_run_script(napi_env env,\n-                            napi_value script,\n-                            napi_value* result) {\n-  NAPI_PREAMBLE(env);\n-  CHECK_ARG(env, script);\n-  CHECK_ARG(env, result);\n-\n-  v8::Local<v8::Value> v8_script = v8impl::V8LocalValueFromJsValue(script);\n-\n-  if (!v8_script->IsString()) {\n-    return napi_set_last_error(env, napi_string_expected);\n-  }\n-\n-  v8::Local<v8::Context> context = env->isolate->GetCurrentContext();\n-\n-  auto maybe_script = v8::Script::Compile(context,\n-      v8::Local<v8::String>::Cast(v8_script));\n-  CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure);\n-\n-  auto script_result =\n-      maybe_script.ToLocalChecked()->Run(context);\n-  CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure);\n-\n-  *result = v8impl::JsValueFromV8LocalValue(script_result.ToLocalChecked());\n-  return GET_RETURN_STATUS(env);\n-}\n-\n-class TsFn: public node::AsyncResource {\n- public:\n-  TsFn(v8::Local<v8::Function> func,\n-       v8::Local<v8::Object> resource,\n-       v8::Local<v8::String> name,\n-       size_t thread_count_,\n-       void* context_,\n-       size_t max_queue_size_,\n-       napi_env env_,\n-       void* finalize_data_,\n-       napi_finalize finalize_cb_,\n-       napi_threadsafe_function_call_js call_js_cb_):\n-      AsyncResource(env_->isolate,\n-                    resource,\n-                    *v8::String::Utf8Value(env_->isolate, name)),\n-      thread_count(thread_count_),\n-      is_closing(false),\n-      context(context_),\n-      max_queue_size(max_queue_size_),\n-      env(env_),\n-      finalize_data(finalize_data_),\n-      finalize_cb(finalize_cb_),\n-      call_js_cb(call_js_cb_ == nullptr ? CallJs : call_js_cb_),\n-      handles_closing(false) {\n-    ref.Reset(env->isolate, func);\n-    node::AddEnvironmentCleanupHook(env->isolate, Cleanup, this);\n-  }\n-\n-  ~TsFn() {\n-    node::RemoveEnvironmentCleanupHook(env->isolate, Cleanup, this);\n-  }\n-\n-  // These methods can be called from any thread.\n-\n-  napi_status Push(void* data, napi_threadsafe_function_call_mode mode) {\n-    node::Mutex::ScopedLock lock(this->mutex);\n-\n-    while (queue.size() >= max_queue_size &&\n-        max_queue_size > 0 &&\n-        !is_closing) {\n-      if (mode == napi_tsfn_nonblocking) {\n-        return napi_queue_full;\n-      }\n-      cond->Wait(lock);\n-    }\n-\n-    if (is_closing) {\n-      if (thread_count == 0) {\n-        return napi_invalid_arg;\n-      } else {\n-        thread_count--;\n-        return napi_closing;\n-      }\n-    } else {\n-      if (uv_async_send(&async) != 0) {\n-        return napi_generic_failure;\n-      }\n-      queue.push(data);\n-      return napi_ok;\n-    }\n-  }\n-\n-  napi_status Acquire() {\n-    node::Mutex::ScopedLock lock(this->mutex);\n-\n-    if (is_closing) {\n-      return napi_closing;\n-    }\n-\n-    thread_count++;\n-\n-    return napi_ok;\n-  }\n-\n-  napi_status Release(napi_threadsafe_function_release_mode mode) {\n-    node::Mutex::ScopedLock lock(this->mutex);\n-\n-    if (thread_count == 0) {\n-      return napi_invalid_arg;\n-    }\n-\n-    thread_count--;\n-\n-    if (thread_count == 0 || mode == napi_tsfn_abort) {\n-      if (!is_closing) {\n-        is_closing = (mode == napi_tsfn_abort);\n-        if (is_closing && max_queue_size > 0) {\n-          cond->Signal(lock);\n-        }\n-        if (uv_async_send(&async) != 0) {\n-          return napi_generic_failure;\n-        }\n-      }\n-    }\n-\n-    return napi_ok;\n-  }\n-\n-  void EmptyQueueAndDelete() {\n-    for (; !queue.empty() ; queue.pop()) {\n-      call_js_cb(nullptr, nullptr, context, queue.front());\n-    }\n-    delete this;\n-  }\n-\n-  // These methods must only be called from the loop thread.\n-\n-  napi_status Init() {\n-    TsFn* ts_fn = this;\n+napi_status napi_delete_async_work(napi_env env, napi_async_work work) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, work);\n \n-    if (uv_async_init(env->loop, &async, AsyncCb) == 0) {\n-      if (max_queue_size > 0) {\n-        cond.reset(new node::ConditionVariable);\n-      }\n-      if ((max_queue_size == 0 || cond.get() != nullptr) &&\n-          uv_idle_init(env->loop, &idle) == 0) {\n-        return napi_ok;\n-      }\n+  uvimpl::Work::Delete(reinterpret_cast<uvimpl::Work*>(work));\n \n-      node::Environment::GetCurrent(env->isolate)->CloseHandle(\n-          reinterpret_cast<uv_handle_t*>(&async),\n-          [] (uv_handle_t* handle) -> void {\n-            TsFn* ts_fn =\n-                node::ContainerOf(&TsFn::async,\n-                                  reinterpret_cast<uv_async_t*>(handle));\n-            delete ts_fn;\n-          });\n+  return napi_clear_last_error(env);\n+}\n \n-      // Prevent the thread-safe function from being deleted here, because\n-      // the callback above will delete it.\n-      ts_fn = nullptr;\n-    }\n+napi_status napi_get_uv_event_loop(napi_env env, uv_loop_t** loop) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, loop);\n+  *loop = env->loop;\n+  return napi_clear_last_error(env);\n+}\n \n-    delete ts_fn;\n+napi_status napi_queue_async_work(napi_env env, napi_async_work work) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, work);\n \n-    return napi_generic_failure;\n-  }\n+  napi_status status;\n+  uv_loop_t* event_loop = nullptr;\n+  status = napi_get_uv_event_loop(env, &event_loop);\n+  if (status != napi_ok)\n+    return napi_set_last_error(env, status);\n \n-  napi_status Unref() {\n-    uv_unref(reinterpret_cast<uv_handle_t*>(&async));\n-    uv_unref(reinterpret_cast<uv_handle_t*>(&idle));\n+  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);\n \n-    return napi_ok;\n-  }\n+  w->ScheduleWork();\n \n-  napi_status Ref() {\n-    uv_ref(reinterpret_cast<uv_handle_t*>(&async));\n-    uv_ref(reinterpret_cast<uv_handle_t*>(&idle));\n+  return napi_clear_last_error(env);\n+}\n \n-    return napi_ok;\n-  }\n+napi_status napi_cancel_async_work(napi_env env, napi_async_work work) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, work);\n \n-  void DispatchOne() {\n-    void* data = nullptr;\n-    bool popped_value = false;\n-    bool idle_stop_failed = false;\n+  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);\n \n-    {\n-      node::Mutex::ScopedLock lock(this->mutex);\n-      if (is_closing) {\n-        CloseHandlesAndMaybeDelete();\n-      } else {\n-        size_t size = queue.size();\n-        if (size > 0) {\n-          data = queue.front();\n-          queue.pop();\n-          popped_value = true;\n-          if (size == max_queue_size && max_queue_size > 0) {\n-            cond->Signal(lock);\n-          }\n-          size--;\n-        }\n+  CALL_UV(env, w->CancelWork());\n \n-        if (size == 0) {\n-          if (thread_count == 0) {\n-            is_closing = true;\n-            if (max_queue_size > 0) {\n-              cond->Signal(lock);\n-            }\n-            CloseHandlesAndMaybeDelete();\n-          } else {\n-            if (uv_idle_stop(&idle) != 0) {\n-              idle_stop_failed = true;\n-            }\n-          }\n-        }\n-      }\n-    }\n+  return napi_clear_last_error(env);\n+}\n \n-    if (popped_value || idle_stop_failed) {\n-      v8::HandleScope scope(env->isolate);\n-      CallbackScope cb_scope(this);\n+napi_status napi_create_promise(napi_env env,\n+                                napi_deferred* deferred,\n+                                napi_value* promise) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, deferred);\n+  CHECK_ARG(env, promise);\n \n-      if (idle_stop_failed) {\n-        CHECK(napi_throw_error(env,\n-                               \"ERR_NAPI_TSFN_STOP_IDLE_LOOP\",\n-                               \"Failed to stop the idle loop\") == napi_ok);\n-      } else {\n-        v8::Local<v8::Function> js_cb =\n-            v8::Local<v8::Function>::New(env->isolate, ref);\n-        call_js_cb(env,\n-                   v8impl::JsValueFromV8LocalValue(js_cb),\n-                   context,\n-                   data);\n-      }\n-    }\n-  }\n+  auto maybe = v8::Promise::Resolver::New(env->isolate->GetCurrentContext());\n+  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);\n \n-  node::Environment* NodeEnv() {\n-    // For some reason grabbing the Node.js environment requires a handle scope.\n-    v8::HandleScope scope(env->isolate);\n-    return node::Environment::GetCurrent(env->isolate);\n-  }\n+  auto v8_resolver = maybe.ToLocalChecked();\n+  auto v8_deferred = new node::Persistent<v8::Value>();\n+  v8_deferred->Reset(env->isolate, v8_resolver);\n \n-  void MaybeStartIdle() {\n-    if (uv_idle_start(&idle, IdleCb) != 0) {\n-      v8::HandleScope scope(env->isolate);\n-      CallbackScope cb_scope(this);\n-      CHECK(napi_throw_error(env,\n-                             \"ERR_NAPI_TSFN_START_IDLE_LOOP\",\n-                             \"Failed to start the idle loop\") == napi_ok);\n-    }\n-  }\n+  *deferred = v8impl::JsDeferredFromNodePersistent(v8_deferred);\n+  *promise = v8impl::JsValueFromV8LocalValue(v8_resolver->GetPromise());\n+  return GET_RETURN_STATUS(env);\n+}\n \n-  void Finalize() {\n-    v8::HandleScope scope(env->isolate);\n-    if (finalize_cb) {\n-      CallbackScope cb_scope(this);\n-      finalize_cb(env, finalize_data, context);\n-    }\n-    EmptyQueueAndDelete();\n-  }\n+napi_status napi_resolve_deferred(napi_env env,\n+                                  napi_deferred deferred,\n+                                  napi_value resolution) {\n+  return v8impl::ConcludeDeferred(env, deferred, resolution, true);\n+}\n \n-  inline void* Context() {\n-    return context;\n-  }\n+napi_status napi_reject_deferred(napi_env env,\n+                                 napi_deferred deferred,\n+                                 napi_value resolution) {\n+  return v8impl::ConcludeDeferred(env, deferred, resolution, false);\n+}\n \n-  void CloseHandlesAndMaybeDelete(bool set_closing = false) {\n-    if (set_closing) {\n-      node::Mutex::ScopedLock lock(this->mutex);\n-      is_closing = true;\n-      if (max_queue_size > 0) {\n-        cond->Signal(lock);\n-      }\n-    }\n-    if (handles_closing) {\n-      return;\n-    }\n-    handles_closing = true;\n-    NodeEnv()->CloseHandle(\n-        reinterpret_cast<uv_handle_t*>(&async),\n-        [] (uv_handle_t* handle) -> void {\n-          TsFn* ts_fn = node::ContainerOf(&TsFn::async,\n-              reinterpret_cast<uv_async_t*>(handle));\n-          ts_fn->NodeEnv()->CloseHandle(\n-              reinterpret_cast<uv_handle_t*>(&ts_fn->idle),\n-              [] (uv_handle_t* handle) -> void {\n-                TsFn* ts_fn = node::ContainerOf(&TsFn::idle,\n-                    reinterpret_cast<uv_idle_t*>(handle));\n-                ts_fn->Finalize();\n-              });\n-        });\n-  }\n+napi_status napi_is_promise(napi_env env,\n+                            napi_value promise,\n+                            bool* is_promise) {\n+  CHECK_ENV(env);\n+  CHECK_ARG(env, promise);\n+  CHECK_ARG(env, is_promise);\n \n-  // Default way of calling into JavaScript. Used when TsFn is constructed\n-  // without a call_js_cb_.\n-  static void CallJs(napi_env env, napi_value cb, void* context, void* data) {\n-    if (!(env == nullptr || cb == nullptr)) {\n-      napi_value recv;\n-      napi_status status;\n+  *is_promise = v8impl::V8LocalValueFromJsValue(promise)->IsPromise();\n \n-      status = napi_get_undefined(env, &recv);\n-      if (status != napi_ok) {\n-        napi_throw_error(env, \"ERR_NAPI_TSFN_GET_UNDEFINED\",\n-            \"Failed to retrieve undefined value\");\n-        return;\n-      }\n+  return napi_clear_last_error(env);\n+}\n \n-      status = napi_call_function(env, recv, cb, 0, nullptr, nullptr);\n-      if (status != napi_ok && status != napi_pending_exception) {\n-        napi_throw_error(env, \"ERR_NAPI_TSFN_CALL_JS\",\n-            \"Failed to call JS callback\");\n-        return;\n-      }\n-    }\n-  }\n+napi_status napi_run_script(napi_env env,\n+                            napi_value script,\n+                            napi_value* result) {\n+  NAPI_PREAMBLE(env);\n+  CHECK_ARG(env, script);\n+  CHECK_ARG(env, result);\n \n-  static void IdleCb(uv_idle_t* idle) {\n-    TsFn* ts_fn =\n-        node::ContainerOf(&TsFn::idle, idle);\n-    ts_fn->DispatchOne();\n-  }\n+  v8::Local<v8::Value> v8_script = v8impl::V8LocalValueFromJsValue(script);\n \n-  static void AsyncCb(uv_async_t* async) {\n-    TsFn* ts_fn =\n-        node::ContainerOf(&TsFn::async, async);\n-    ts_fn->MaybeStartIdle();\n+  if (!v8_script->IsString()) {\n+    return napi_set_last_error(env, napi_string_expected);\n   }\n \n-  static void Cleanup(void* data) {\n-    reinterpret_cast<TsFn*>(data)->CloseHandlesAndMaybeDelete(true);\n-  }\n+  v8::Local<v8::Context> context = env->isolate->GetCurrentContext();\n \n- private:\n-  // These are variables protected by the mutex.\n-  node::Mutex mutex;\n-  std::unique_ptr<node::ConditionVariable> cond;\n-  std::queue<void*> queue;\n-  uv_async_t async;\n-  uv_idle_t idle;\n-  size_t thread_count;\n-  bool is_closing;\n+  auto maybe_script = v8::Script::Compile(context,\n+      v8::Local<v8::String>::Cast(v8_script));\n+  CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure);\n \n-  // These are variables set once, upon creation, and then never again, which\n-  // means we don't need the mutex to read them.\n-  void* context;\n-  size_t max_queue_size;\n+  auto script_result =\n+      maybe_script.ToLocalChecked()->Run(context);\n+  CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure);\n \n-  // These are variables accessed only from the loop thread.\n-  node::Persistent<v8::Function> ref;\n-  napi_env env;\n-  void* finalize_data;\n-  napi_finalize finalize_cb;\n-  napi_threadsafe_function_call_js call_js_cb;\n-  bool handles_closing;\n-};\n+  *result = v8impl::JsValueFromV8LocalValue(script_result.ToLocalChecked());\n+  return GET_RETURN_STATUS(env);\n+}\n \n-NAPI_EXTERN napi_status\n+napi_status\n napi_create_threadsafe_function(napi_env env,\n                                 napi_value func,\n                                 napi_value async_resource,\n@@ -4067,16 +4070,17 @@ napi_create_threadsafe_function(napi_env env,\n   v8::Local<v8::String> v8_name;\n   CHECK_TO_STRING(env, v8_context, v8_name, async_resource_name);\n \n-  TsFn* ts_fn = new TsFn(v8_func,\n-                         v8_resource,\n-                         v8_name,\n-                         initial_thread_count,\n-                         context,\n-                         max_queue_size,\n-                         env,\n-                         thread_finalize_data,\n-                         thread_finalize_cb,\n-                         call_js_cb);\n+  v8impl::ThreadSafeFunction* ts_fn =\n+      new v8impl::ThreadSafeFunction(v8_func,\n+                                     v8_resource,\n+                                     v8_name,\n+                                     initial_thread_count,\n+                                     context,\n+                                     max_queue_size,\n+                                     env,\n+                                     thread_finalize_data,\n+                                     thread_finalize_cb,\n+                                     call_js_cb);\n \n   if (ts_fn == nullptr) {\n     status = napi_generic_failure;\n@@ -4091,45 +4095,46 @@ napi_create_threadsafe_function(napi_env env,\n   return napi_set_last_error(env, status);\n }\n \n-NAPI_EXTERN napi_status\n+napi_status\n napi_get_threadsafe_function_context(napi_threadsafe_function func,\n                                      void** result) {\n   CHECK(func != nullptr);\n   CHECK(result != nullptr);\n \n-  *result = reinterpret_cast<TsFn*>(func)->Context();\n+  *result = reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Context();\n   return napi_ok;\n }\n \n-NAPI_EXTERN napi_status\n+napi_status\n napi_call_threadsafe_function(napi_threadsafe_function func,\n                               void* data,\n                               napi_threadsafe_function_call_mode is_blocking) {\n   CHECK(func != nullptr);\n-  return reinterpret_cast<TsFn*>(func)->Push(data, is_blocking);\n+  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Push(data,\n+                                                                   is_blocking);\n }\n \n-NAPI_EXTERN napi_status\n+napi_status\n napi_acquire_threadsafe_function(napi_threadsafe_function func) {\n   CHECK(func != nullptr);\n-  return reinterpret_cast<TsFn*>(func)->Acquire();\n+  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Acquire();\n }\n \n-NAPI_EXTERN napi_status\n+napi_status\n napi_release_threadsafe_function(napi_threadsafe_function func,\n                                  napi_threadsafe_function_release_mode mode) {\n   CHECK(func != nullptr);\n-  return reinterpret_cast<TsFn*>(func)->Release(mode);\n+  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Release(mode);\n }\n \n-NAPI_EXTERN napi_status\n+napi_status\n napi_unref_threadsafe_function(napi_env env, napi_threadsafe_function func) {\n   CHECK(func != nullptr);\n-  return reinterpret_cast<TsFn*>(func)->Unref();\n+  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Unref();\n }\n \n-NAPI_EXTERN napi_status\n+napi_status\n napi_ref_threadsafe_function(napi_env env, napi_threadsafe_function func) {\n   CHECK(func != nullptr);\n-  return reinterpret_cast<TsFn*>(func)->Ref();\n+  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Ref();\n }"
        }
    ],
    "stats": {
        "total": 873,
        "additions": 439,
        "deletions": 434
    }
}