{
    "author": "gireeshpunathil",
    "message": "child_process: close pipe ends that are re-piped\n\nwhen t0 and t1 are spawned with t0's outputstream [1, 2] is piped into\nt1's input, a new pipe is created which uses a copy of the t0's fd.\nThis leaves the original copy in Node parent, unattended. Net result is\nthat when t0 produces data, it gets bifurcated into both the copies\n\nDetect the passed handle to be of 'wrap' type and close after the\nnative spawn invocation by which time piping would have been over.\n\nFixes: https://github.com/nodejs/node/issues/9413\nFixes: https://github.com/nodejs/node/issues/18016\n\nPR-URL: https://github.com/nodejs/node/pull/21209\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>",
    "sha": "b1f82e4342f8a630b1ef83cd33781a725428f569",
    "files": [
        {
            "sha": "cb0d8ec6b65bbe81199858d40d2ecfe0e6208a24",
            "filename": "lib/internal/child_process.js",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/b1f82e4342f8a630b1ef83cd33781a725428f569/lib%2Finternal%2Fchild_process.js",
            "raw_url": "https://github.com/nodejs/node/raw/b1f82e4342f8a630b1ef83cd33781a725428f569/lib%2Finternal%2Fchild_process.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Fchild_process.js?ref=b1f82e4342f8a630b1ef83cd33781a725428f569",
            "patch": "@@ -384,6 +384,12 @@ ChildProcess.prototype.spawn = function(options) {\n       continue;\n     }\n \n+    // stream is already cloned and piped, so close\n+    if (stream.type === 'wrap') {\n+      stream.handle.close();\n+      continue;\n+    }\n+\n     if (stream.handle) {\n       // when i === 0 - we're dealing with stdin\n       // (which is the only one writable pipe)"
        },
        {
            "sha": "501fb29032b3c8cf298da6c9926ddf7b20a5c8f2",
            "filename": "test/parallel/test-child-process-pipe-dataflow.js",
            "status": "added",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/b1f82e4342f8a630b1ef83cd33781a725428f569/test%2Fparallel%2Ftest-child-process-pipe-dataflow.js",
            "raw_url": "https://github.com/nodejs/node/raw/b1f82e4342f8a630b1ef83cd33781a725428f569/test%2Fparallel%2Ftest-child-process-pipe-dataflow.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-child-process-pipe-dataflow.js?ref=b1f82e4342f8a630b1ef83cd33781a725428f569",
            "patch": "@@ -0,0 +1,51 @@\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const path = require('path');\n+const fs = require('fs');\n+const spawn = require('child_process').spawn;\n+const tmpdir = require('../common/tmpdir');\n+\n+let cat, grep, wc;\n+\n+const KB = 1024;\n+const MB = KB * KB;\n+\n+\n+// Make sure process chaining allows desired data flow:\n+// check cat <file> | grep 'x' | wc -c === 1MB\n+// This helps to make sure no data is lost between pipes.\n+\n+{\n+  tmpdir.refresh();\n+  const file = path.resolve(tmpdir.path, 'data.txt');\n+  const buf = Buffer.alloc(MB).fill('x');\n+\n+  // Most OS commands that deal with data, attach special\n+  // meanings to new line - for example, line buffering.\n+  // So cut the buffer into lines at some points, forcing\n+  // data flow to be split in the stream.\n+  for (let i = 0; i < KB; i++)\n+    buf[i * KB] = 10;\n+  fs.writeFileSync(file, buf.toString());\n+\n+  cat = spawn('cat', [file]);\n+  grep = spawn('grep', ['x'], { stdio: [cat.stdout, 'pipe', 'pipe'] });\n+  wc = spawn('wc', ['-c'], { stdio: [grep.stdout, 'pipe', 'pipe'] });\n+\n+  wc.stdout.on('data', common.mustCall(function(data) {\n+    assert.strictEqual(data.toString().trim(), MB.toString());\n+  }));\n+\n+  cat.on('exit', common.mustCall(function(code) {\n+    assert.strictEqual(code, 0);\n+  }));\n+\n+  grep.on('exit', common.mustCall(function(code) {\n+    assert.strictEqual(code, 0);\n+  }));\n+\n+  wc.on('exit', common.mustCall(function(code) {\n+    assert.strictEqual(code, 0);\n+  }));\n+}"
        }
    ],
    "stats": {
        "total": 57,
        "additions": 57,
        "deletions": 0
    }
}