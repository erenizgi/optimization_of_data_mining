{
    "author": "addaleax",
    "message": "src: initialize file trace writer on tracing thread\n\nRun the initialization for the file trace writerâ€™s `uv_async_t`s\non the same thread as `uv_run()` for their loop to avoid race\nconditions.\n\nPR-URL: https://github.com/nodejs/node/pull/21867\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Eugene Ostroukhov <eostroukhov@google.com>\nReviewed-By: Ali Ijaz Sheikh <ofrobots@google.com>",
    "sha": "1f5aa5a23c5868eb42b673f3efe65912d445ac18",
    "files": [
        {
            "sha": "5deeaa6a945df09d20f6b2379d6dcfe057d8f9b0",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/1f5aa5a23c5868eb42b673f3efe65912d445ac18/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1f5aa5a23c5868eb42b673f3efe65912d445ac18/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=1f5aa5a23c5868eb42b673f3efe65912d445ac18",
            "patch": "@@ -434,8 +434,7 @@ static struct {\n       tracing_file_writer_ = tracing_agent_->AddClient(\n           ParseCommaSeparatedSet(trace_enabled_categories),\n           std::unique_ptr<tracing::AsyncTraceWriter>(\n-              new tracing::NodeTraceWriter(trace_file_pattern,\n-                                           tracing_agent_->loop())),\n+              new tracing::NodeTraceWriter(trace_file_pattern)),\n           tracing::Agent::kUseDefaultCategories);\n     }\n   }"
        },
        {
            "sha": "9b435b56d2c8ade6d3e666297ffe9fc383602239",
            "filename": "src/tracing/agent.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/nodejs/node/blob/1f5aa5a23c5868eb42b673f3efe65912d445ac18/src%2Ftracing%2Fagent.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1f5aa5a23c5868eb42b673f3efe65912d445ac18/src%2Ftracing%2Fagent.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fagent.cc?ref=1f5aa5a23c5868eb42b673f3efe65912d445ac18",
            "patch": "@@ -53,9 +53,27 @@ Agent::Agent() {\n   tracing_controller_->Initialize(nullptr);\n \n   CHECK_EQ(uv_loop_init(&tracing_loop_), 0);\n+  CHECK_EQ(uv_async_init(&tracing_loop_,\n+                         &initialize_writer_async_,\n+                         [](uv_async_t* async) {\n+    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);\n+    agent->InitializeWritersOnThread();\n+  }), 0);\n+}\n+\n+void Agent::InitializeWritersOnThread() {\n+  Mutex::ScopedLock lock(initialize_writer_mutex_);\n+  while (!to_be_initialized_.empty()) {\n+    AsyncTraceWriter* head = *to_be_initialized_.begin();\n+    head->InitializeOnThread(&tracing_loop_);\n+    to_be_initialized_.erase(head);\n+  }\n+  initialize_writer_condvar_.Broadcast(lock);\n }\n \n Agent::~Agent() {\n+  uv_close(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_), nullptr);\n+  uv_run(&tracing_loop_, UV_RUN_ONCE);\n   CheckedUvLoopClose(&tracing_loop_);\n }\n \n@@ -95,9 +113,18 @@ AgentWriterHandle Agent::AddClient(\n \n   ScopedSuspendTracing suspend(tracing_controller_, this);\n   int id = next_writer_id_++;\n+  AsyncTraceWriter* raw = writer.get();\n   writers_[id] = std::move(writer);\n   categories_[id] = { use_categories->begin(), use_categories->end() };\n \n+  {\n+    Mutex::ScopedLock lock(initialize_writer_mutex_);\n+    to_be_initialized_.insert(raw);\n+    uv_async_send(&initialize_writer_async_);\n+    while (to_be_initialized_.count(raw) > 0)\n+      initialize_writer_condvar_.Wait(lock);\n+  }\n+\n   return AgentWriterHandle(this, id);\n }\n \n@@ -120,6 +147,10 @@ void Agent::StopTracing() {\n \n void Agent::Disconnect(int client) {\n   if (client == kDefaultHandleId) return;\n+  {\n+    Mutex::ScopedLock lock(initialize_writer_mutex_);\n+    to_be_initialized_.erase(writers_[client].get());\n+  }\n   ScopedSuspendTracing suspend(tracing_controller_, this);\n   writers_.erase(client);\n   categories_.erase(client);"
        },
        {
            "sha": "045aaef85e8ea63dab29e1c9497871f9bb096452",
            "filename": "src/tracing/agent.h",
            "status": "modified",
            "additions": 10,
            "deletions": 3,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/1f5aa5a23c5868eb42b673f3efe65912d445ac18/src%2Ftracing%2Fagent.h",
            "raw_url": "https://github.com/nodejs/node/raw/1f5aa5a23c5868eb42b673f3efe65912d445ac18/src%2Ftracing%2Fagent.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fagent.h?ref=1f5aa5a23c5868eb42b673f3efe65912d445ac18",
            "patch": "@@ -5,6 +5,7 @@\n #include \"uv.h\"\n #include \"v8.h\"\n #include \"util.h\"\n+#include \"node_mutex.h\"\n \n #include <set>\n #include <string>\n@@ -23,6 +24,7 @@ class AsyncTraceWriter {\n   virtual ~AsyncTraceWriter() {}\n   virtual void AppendTraceEvent(TraceObject* trace_event) = 0;\n   virtual void Flush(bool blocking) = 0;\n+  virtual void InitializeOnThread(uv_loop_t* loop) {}\n };\n \n class TracingController : public v8::platform::tracing::TracingController {\n@@ -92,13 +94,11 @@ class Agent {\n \n   TraceConfig* CreateTraceConfig() const;\n \n-  // TODO(addaleax): This design is broken and inherently thread-unsafe.\n-  inline uv_loop_t* loop() { return &tracing_loop_; }\n-\n  private:\n   friend class AgentWriterHandle;\n \n   static void ThreadCb(void* arg);\n+  void InitializeWritersOnThread();\n \n   void Start();\n   void StopTracing();\n@@ -120,6 +120,13 @@ class Agent {\n   std::unordered_map<int, std::multiset<std::string>> categories_;\n   std::unordered_map<int, std::unique_ptr<AsyncTraceWriter>> writers_;\n   TracingController* tracing_controller_ = nullptr;\n+\n+  // Variables related to initializing per-event-loop properties of individual\n+  // writers, such as libuv handles.\n+  Mutex initialize_writer_mutex_;\n+  ConditionVariable initialize_writer_condvar_;\n+  uv_async_t initialize_writer_async_;\n+  std::set<AsyncTraceWriter*> to_be_initialized_;\n };\n \n void AgentWriterHandle::reset() {"
        },
        {
            "sha": "2fdb92972330b59f4912112ef9aff6c7ef741467",
            "filename": "src/tracing/node_trace_writer.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 13,
            "changes": 32,
            "blob_url": "https://github.com/nodejs/node/blob/1f5aa5a23c5868eb42b673f3efe65912d445ac18/src%2Ftracing%2Fnode_trace_writer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/1f5aa5a23c5868eb42b673f3efe65912d445ac18/src%2Ftracing%2Fnode_trace_writer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fnode_trace_writer.cc?ref=1f5aa5a23c5868eb42b673f3efe65912d445ac18",
            "patch": "@@ -3,16 +3,25 @@\n #include <string.h>\n #include <fcntl.h>\n \n-#include \"util.h\"\n+#include \"util-inl.h\"\n \n namespace node {\n namespace tracing {\n \n-NodeTraceWriter::NodeTraceWriter(const std::string& log_file_pattern,\n-                                 uv_loop_t* tracing_loop)\n-    : tracing_loop_(tracing_loop), log_file_pattern_(log_file_pattern) {\n+NodeTraceWriter::NodeTraceWriter(const std::string& log_file_pattern)\n+    : log_file_pattern_(log_file_pattern) {}\n+\n+void NodeTraceWriter::InitializeOnThread(uv_loop_t* loop) {\n+  CHECK_NULL(tracing_loop_);\n+  tracing_loop_ = loop;\n+\n   flush_signal_.data = this;\n-  int err = uv_async_init(tracing_loop_, &flush_signal_, FlushSignalCb);\n+  int err = uv_async_init(tracing_loop_, &flush_signal_,\n+                          [](uv_async_t* signal) {\n+    NodeTraceWriter* trace_writer =\n+        ContainerOf(&NodeTraceWriter::flush_signal_, signal);\n+    trace_writer->FlushPrivate();\n+  });\n   CHECK_EQ(err, 0);\n \n   exit_signal_.data = this;\n@@ -126,11 +135,6 @@ void NodeTraceWriter::FlushPrivate() {\n   WriteToFile(std::move(str), highest_request_id);\n }\n \n-void NodeTraceWriter::FlushSignalCb(uv_async_t* signal) {\n-  NodeTraceWriter* trace_writer = static_cast<NodeTraceWriter*>(signal->data);\n-  trace_writer->FlushPrivate();\n-}\n-\n void NodeTraceWriter::Flush(bool blocking) {\n   Mutex::ScopedLock scoped_lock(request_mutex_);\n   if (!json_trace_writer_) {\n@@ -170,7 +174,7 @@ void NodeTraceWriter::WriteToFile(std::string&& str, int highest_request_id) {\n }\n \n void NodeTraceWriter::WriteCb(uv_fs_t* req) {\n-  WriteRequest* write_req = reinterpret_cast<WriteRequest*>(req);\n+  WriteRequest* write_req = ContainerOf(&WriteRequest::req, req);\n   CHECK_GE(write_req->req.result, 0);\n \n   NodeTraceWriter* writer = write_req->writer;\n@@ -187,13 +191,15 @@ void NodeTraceWriter::WriteCb(uv_fs_t* req) {\n \n // static\n void NodeTraceWriter::ExitSignalCb(uv_async_t* signal) {\n-  NodeTraceWriter* trace_writer = static_cast<NodeTraceWriter*>(signal->data);\n+  NodeTraceWriter* trace_writer =\n+      ContainerOf(&NodeTraceWriter::exit_signal_, signal);\n   uv_close(reinterpret_cast<uv_handle_t*>(&trace_writer->flush_signal_),\n            nullptr);\n   uv_close(reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),\n            [](uv_handle_t* signal) {\n       NodeTraceWriter* trace_writer =\n-          static_cast<NodeTraceWriter*>(signal->data);\n+          ContainerOf(&NodeTraceWriter::exit_signal_,\n+                      reinterpret_cast<uv_async_t*>(signal));\n       Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);\n       trace_writer->exited_ = true;\n       trace_writer->exit_cond_.Signal(scoped_lock);"
        },
        {
            "sha": "9c4decc8eec3d44ed81f8eee03f710beb7c07333",
            "filename": "src/tracing/node_trace_writer.h",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/1f5aa5a23c5868eb42b673f3efe65912d445ac18/src%2Ftracing%2Fnode_trace_writer.h",
            "raw_url": "https://github.com/nodejs/node/raw/1f5aa5a23c5868eb42b673f3efe65912d445ac18/src%2Ftracing%2Fnode_trace_writer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Fnode_trace_writer.h?ref=1f5aa5a23c5868eb42b673f3efe65912d445ac18",
            "patch": "@@ -4,7 +4,6 @@\n #include <sstream>\n #include <queue>\n \n-#include \"node_mutex.h\"\n #include \"libplatform/v8-tracing.h\"\n #include \"tracing/agent.h\"\n #include \"uv.h\"\n@@ -17,10 +16,10 @@ using v8::platform::tracing::TraceWriter;\n \n class NodeTraceWriter : public AsyncTraceWriter {\n  public:\n-  explicit NodeTraceWriter(const std::string& log_file_pattern,\n-                           uv_loop_t* tracing_loop);\n+  explicit NodeTraceWriter(const std::string& log_file_pattern);\n   ~NodeTraceWriter();\n \n+  void InitializeOnThread(uv_loop_t* loop) override;\n   void AppendTraceEvent(TraceObject* trace_event) override;\n   void Flush(bool blocking) override;\n \n@@ -38,11 +37,10 @@ class NodeTraceWriter : public AsyncTraceWriter {\n   void OpenNewFileForStreaming();\n   void WriteToFile(std::string&& str, int highest_request_id);\n   void WriteSuffix();\n-  static void FlushSignalCb(uv_async_t* signal);\n   void FlushPrivate();\n   static void ExitSignalCb(uv_async_t* signal);\n \n-  uv_loop_t* tracing_loop_;\n+  uv_loop_t* tracing_loop_ = nullptr;\n   // Triggers callback to initiate writing the contents of stream_ to disk.\n   uv_async_t flush_signal_;\n   // Triggers callback to close async objects, ending the tracing thread."
        }
    ],
    "stats": {
        "total": 87,
        "additions": 64,
        "deletions": 23
    }
}