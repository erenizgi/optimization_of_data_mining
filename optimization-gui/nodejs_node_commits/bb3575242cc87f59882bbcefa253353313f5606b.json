{
    "author": "unknown",
    "message": "deps: backport a8f6869 from upstream V8\n\nOriginal commit message:\n\n  [debug] Fully implement Debug::ArchiveDebug and Debug::RestoreDebug.\n\n  I have a project that embeds V8 and uses a single `Isolate` from multiple\n  threads. The program runs just fine, but sometimes the inspector doesn't\n  stop on the correct line after stepping over a statement that switches\n  threads behind the scenes, even though the original thread is restored by\n  the time the next statement is executed.\n\n  After some digging, I discovered that the `Debug::ArchiveDebug` and\n  `Debug::RestoreDebug` methods, which should be responsible for\n  saving/restoring this `ThreadLocal` information when switching threads,\n  currently don't do anything.\n\n  This commit implements those methods using MemCopy, in the style of other\n  Archive/Restore methods in the V8 codebase.\n\n  Related: https://groups.google.com/forum/#!topic/v8-users/_Qf2rwljRk8\n\n  R=yangguo@chromium.org,jgruber@chromium.org\n  CC=info@bnoordhuis.nl\n\n  Bug: v8:7230\n  Change-Id: Id517c873eb81cd53f7216c7efd441b956cf7f943\n  Reviewed-on: https://chromium-review.googlesource.com/833260\n  Commit-Queue: Yang Guo <yangguo@chromium.org>\n  Reviewed-by: Yang Guo <yangguo@chromium.org>\n  Cr-Commit-Position: refs/heads/master@{#54902}\n\nRefs: https://github.com/v8/v8/commit/a8f6869177685cfb9c199c454a86f4698c260515\n\nFix build errors by matching older V8 APIs used by Node.\n\nIt looks like\n\n  SetDebugDelegate(debug::DebugDelegate* delegate, bool pass_ownership)\n\nwas simplified to just\n\n  SetDebugDelegate(debug::DebugDelegate* delegate)\n\nin https://github.com/v8/v8/commit/37dcd837dbafa7f1175be5f01f0def013437c7e7,\nbut the extra `pass_ownership` parameter is still there in the current\nversion of `node/deps/v8`. I should be able to fix those tests by passing\n`false` for `pass_ownership`.\n\nAlso, the `DebugDelegate::BreakProgramRequested` method lost a parameter\nin https://github.com/v8/v8/commit/e404670696b4c49d7f8adcdb075b98acab9967dd,\nbut it's not a parameter I was using in my test, so there shouldn't be any\nharm in adding the `exec_state` parameter back to `BreakProgramRequested`\n(and continuing to ignore it).\n\nSkip restoring debug state unless thread previously in DebugScope.\n\nA simpler version of the changes I proposed upstream in this V8 change\nrequest: https://chromium-review.googlesource.com/c/v8/v8/+/1168449\n\nIn this version, Debug::RestoreDebug never attempts to enter a new\nDebugScope, but merely reuses the previous one, if we're returning to a\nthread that was previously in a DebugScope. If the thread was not\npreviously in a DebugScope, I believe it does not need to have any\ndebugging state restored with ClearOneShot and PrepareStep.\n\nThe tests from https://chromium-review.googlesource.com/c/v8/v8/+/833260\nstill pass, and the failing V8-CI tests are now passing locally for me.\n\nPR-URL: https://github.com/nodejs/node/pull/22122\nReviewed-By: Franziska Hinkelmann <franziska.hinkelmann@gmail.com>\nReviewed-By: MichaÃ«l Zasso <targos@protonmail.com>",
    "sha": "bb3575242cc87f59882bbcefa253353313f5606b",
    "files": [
        {
            "sha": "8e1948a85cbeaca3112ec0455184e932c9d86630",
            "filename": "common.gypi",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/bb3575242cc87f59882bbcefa253353313f5606b/common.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/bb3575242cc87f59882bbcefa253353313f5606b/common.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/common.gypi?ref=bb3575242cc87f59882bbcefa253353313f5606b",
            "patch": "@@ -29,7 +29,7 @@\n \n     # Reset this number to 0 on major V8 upgrades.\n     # Increment by one for each non-official patch applied to deps/v8.\n-    'v8_embedder_string': '-node.24',\n+    'v8_embedder_string': '-node.25',\n \n     # Enable disassembler for `--print-code` v8 options\n     'v8_enable_disassembler': 1,"
        },
        {
            "sha": "afad3a50414858a2c6e6367b91a917bd327fe341",
            "filename": "deps/v8/AUTHORS",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/bb3575242cc87f59882bbcefa253353313f5606b/deps%2Fv8%2FAUTHORS",
            "raw_url": "https://github.com/nodejs/node/raw/bb3575242cc87f59882bbcefa253353313f5606b/deps%2Fv8%2FAUTHORS",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2FAUTHORS?ref=bb3575242cc87f59882bbcefa253353313f5606b",
            "patch": "@@ -32,6 +32,7 @@ Facebook, Inc. <*@fb.com>\n Facebook, Inc. <*@oculus.com>\n Vewd Software AS <*@vewd.com>\n Groupon <*@groupon.com>\n+Meteor Development Group <*@meteor.com>\n Cloudflare, Inc. <*@cloudflare.com>\n \n Aaron Bieber <deftly@gmail.com>\n@@ -49,6 +50,7 @@ Andrei Kashcha <anvaka@gmail.com>\n Anna Henningsen <anna@addaleax.net>\n Bangfu Tao <bangfu.tao@samsung.com>\n Ben Coe <ben@npmjs.com>\n+Ben Newman <ben@meteor.com>\n Ben Noordhuis <info@bnoordhuis.nl>\n Benjamin Tan <demoneaux@gmail.com>\n Bert Belder <bertbelder@gmail.com>"
        },
        {
            "sha": "d25c2598467e6cf29b4d00df6df0952699435ab7",
            "filename": "deps/v8/src/debug/debug.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 6,
            "changes": 29,
            "blob_url": "https://github.com/nodejs/node/blob/bb3575242cc87f59882bbcefa253353313f5606b/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.cc",
            "raw_url": "https://github.com/nodejs/node/raw/bb3575242cc87f59882bbcefa253353313f5606b/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.cc?ref=bb3575242cc87f59882bbcefa253353313f5606b",
            "patch": "@@ -355,19 +355,36 @@ void Debug::ThreadInit() {\n \n \n char* Debug::ArchiveDebug(char* storage) {\n-  // Simply reset state. Don't archive anything.\n-  ThreadInit();\n+  MemCopy(storage, reinterpret_cast<char*>(&thread_local_),\n+          ArchiveSpacePerThread());\n   return storage + ArchiveSpacePerThread();\n }\n \n-\n char* Debug::RestoreDebug(char* storage) {\n-  // Simply reset state. Don't restore anything.\n-  ThreadInit();\n+  MemCopy(reinterpret_cast<char*>(&thread_local_), storage,\n+          ArchiveSpacePerThread());\n+\n+  if (in_debug_scope()) {\n+    // If this thread was in a DebugScope when we archived it, restore the\n+    // previous debugging state now. Note that in_debug_scope() returns\n+    // true when thread_local_.current_debug_scope_ (restored by MemCopy\n+    // above) is non-null.\n+\n+    // Clear any one-shot breakpoints that may have been set by the other\n+    // thread, and reapply breakpoints for this thread.\n+    HandleScope scope(isolate_);\n+    ClearOneShot();\n+\n+    if (thread_local_.last_step_action_ != StepNone) {\n+      // Reset the previous step action for this thread.\n+      PrepareStep(thread_local_.last_step_action_);\n+    }\n+  }\n+\n   return storage + ArchiveSpacePerThread();\n }\n \n-int Debug::ArchiveSpacePerThread() { return 0; }\n+int Debug::ArchiveSpacePerThread() { return sizeof(ThreadLocal); }\n \n void Debug::Iterate(RootVisitor* v) {\n   v->VisitRootPointer(Root::kDebug, nullptr, &thread_local_.return_value_);"
        },
        {
            "sha": "17bdfc03680a07c7bf59aa6990a3b764df5d193a",
            "filename": "deps/v8/src/debug/debug.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/bb3575242cc87f59882bbcefa253353313f5606b/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.h",
            "raw_url": "https://github.com/nodejs/node/raw/bb3575242cc87f59882bbcefa253353313f5606b/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fdebug%2Fdebug.h?ref=bb3575242cc87f59882bbcefa253353313f5606b",
            "patch": "@@ -327,6 +327,7 @@ class Debug {\n   static int ArchiveSpacePerThread();\n   void FreeThreadResources() { }\n   void Iterate(RootVisitor* v);\n+  void InitThread(const ExecutionAccess& lock) { ThreadInit(); }\n \n   bool CheckExecutionState(int id) {\n     return CheckExecutionState() && break_id() == id;"
        },
        {
            "sha": "0fb333c1f37572e688560aa7de7f6e478364b6b6",
            "filename": "deps/v8/src/v8threads.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/bb3575242cc87f59882bbcefa253353313f5606b/deps%2Fv8%2Fsrc%2Fv8threads.cc",
            "raw_url": "https://github.com/nodejs/node/raw/bb3575242cc87f59882bbcefa253353313f5606b/deps%2Fv8%2Fsrc%2Fv8threads.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fv8threads.cc?ref=bb3575242cc87f59882bbcefa253353313f5606b",
            "patch": "@@ -45,7 +45,7 @@ void Locker::Initialize(v8::Isolate* isolate) {\n     } else {\n       internal::ExecutionAccess access(isolate_);\n       isolate_->stack_guard()->ClearThread(access);\n-      isolate_->stack_guard()->InitThread(access);\n+      isolate_->thread_manager()->InitThread(access);\n     }\n   }\n   DCHECK(isolate_->thread_manager()->IsLockedByCurrentThread());\n@@ -95,6 +95,10 @@ Unlocker::~Unlocker() {\n \n namespace internal {\n \n+void ThreadManager::InitThread(const ExecutionAccess& lock) {\n+  isolate_->stack_guard()->InitThread(lock);\n+  isolate_->debug()->InitThread(lock);\n+}\n \n bool ThreadManager::RestoreThread() {\n   DCHECK(IsLockedByCurrentThread());\n@@ -127,7 +131,7 @@ bool ThreadManager::RestoreThread() {\n       isolate_->FindPerThreadDataForThisThread();\n   if (per_thread == nullptr || per_thread->thread_state() == nullptr) {\n     // This is a new thread.\n-    isolate_->stack_guard()->InitThread(access);\n+    InitThread(access);\n     return false;\n   }\n   ThreadState* state = per_thread->thread_state();"
        },
        {
            "sha": "7fde0c9ec494e77dbbcf8bdbeb3817ab1a9d4c00",
            "filename": "deps/v8/src/v8threads.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/bb3575242cc87f59882bbcefa253353313f5606b/deps%2Fv8%2Fsrc%2Fv8threads.h",
            "raw_url": "https://github.com/nodejs/node/raw/bb3575242cc87f59882bbcefa253353313f5606b/deps%2Fv8%2Fsrc%2Fv8threads.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fv8threads.h?ref=bb3575242cc87f59882bbcefa253353313f5606b",
            "patch": "@@ -67,6 +67,7 @@ class ThreadManager {\n   void Lock();\n   void Unlock();\n \n+  void InitThread(const ExecutionAccess&);\n   void ArchiveThread();\n   bool RestoreThread();\n   void FreeThreadResources();"
        },
        {
            "sha": "92abcae16e817b270e8600945840d7403db8f690",
            "filename": "deps/v8/test/cctest/test-debug.cc",
            "status": "modified",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/nodejs/node/blob/bb3575242cc87f59882bbcefa253353313f5606b/deps%2Fv8%2Ftest%2Fcctest%2Ftest-debug.cc",
            "raw_url": "https://github.com/nodejs/node/raw/bb3575242cc87f59882bbcefa253353313f5606b/deps%2Fv8%2Ftest%2Fcctest%2Ftest-debug.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftest%2Fcctest%2Ftest-debug.cc?ref=bb3575242cc87f59882bbcefa253353313f5606b",
            "patch": "@@ -6221,6 +6221,135 @@ TEST(DebugBreakOffThreadTerminate) {\n }\n \n \n+class ArchiveRestoreThread : public v8::base::Thread,\n+                             public v8::debug::DebugDelegate {\n+ public:\n+  ArchiveRestoreThread(v8::Isolate* isolate, int spawn_count)\n+      : Thread(Options(\"ArchiveRestoreThread\")),\n+        isolate_(isolate),\n+        debug_(reinterpret_cast<i::Isolate*>(isolate_)->debug()),\n+        spawn_count_(spawn_count),\n+        break_count_(0) {}\n+\n+  virtual void Run() {\n+    v8::Locker locker(isolate_);\n+    isolate_->Enter();\n+\n+    v8::HandleScope scope(isolate_);\n+    v8::Local<v8::Context> context = v8::Context::New(isolate_);\n+    v8::Context::Scope context_scope(context);\n+\n+    v8::Local<v8::Function> test = CompileFunction(isolate_,\n+                                                   \"function test(n) {\\n\"\n+                                                   \"  debugger;\\n\"\n+                                                   \"  return n + 1;\\n\"\n+                                                   \"}\\n\",\n+                                                   \"test\");\n+\n+    debug_->SetDebugDelegate(this, false);\n+    v8::internal::DisableBreak enable_break(debug_, false);\n+\n+    v8::Local<v8::Value> args[1] = {v8::Integer::New(isolate_, spawn_count_)};\n+\n+    int result = test->Call(context, context->Global(), 1, args)\n+                     .ToLocalChecked()\n+                     ->Int32Value(context)\n+                     .FromJust();\n+\n+    // Verify that test(spawn_count_) returned spawn_count_ + 1.\n+    CHECK_EQ(spawn_count_ + 1, result);\n+\n+    isolate_->Exit();\n+  }\n+\n+  void BreakProgramRequested(v8::Local<v8::Context> context,\n+                             v8::Local<v8::Object> exec_state,\n+                             const std::vector<v8::debug::BreakpointId>&) {\n+    auto stack_traces = v8::debug::StackTraceIterator::Create(isolate_);\n+    if (!stack_traces->Done()) {\n+      v8::debug::Location location = stack_traces->GetSourceLocation();\n+\n+      i::PrintF(\"ArchiveRestoreThread #%d hit breakpoint at line %d\\n\",\n+                spawn_count_, location.GetLineNumber());\n+\n+      switch (location.GetLineNumber()) {\n+        case 1:  // debugger;\n+          CHECK_EQ(break_count_, 0);\n+\n+          // Attempt to stop on the next line after the first debugger\n+          // statement. If debug->{Archive,Restore}Debug() improperly reset\n+          // thread-local debug information, the debugger will fail to stop\n+          // before the test function returns.\n+          debug_->PrepareStep(StepNext);\n+\n+          // Spawning threads while handling the current breakpoint verifies\n+          // that the parent thread correctly archived and restored the\n+          // state necessary to stop on the next line. If not, then control\n+          // will simply continue past the `return n + 1` statement.\n+          MaybeSpawnChildThread();\n+\n+          break;\n+\n+        case 2:  // return n + 1;\n+          CHECK_EQ(break_count_, 1);\n+          break;\n+\n+        default:\n+          CHECK(false);\n+      }\n+    }\n+\n+    ++break_count_;\n+  }\n+\n+  void MaybeSpawnChildThread() {\n+    if (spawn_count_ > 1) {\n+      v8::Unlocker unlocker(isolate_);\n+\n+      // Spawn a thread that spawns a thread that spawns a thread (and so\n+      // on) so that the ThreadManager is forced to archive and restore\n+      // the current thread.\n+      ArchiveRestoreThread child(isolate_, spawn_count_ - 1);\n+      child.Start();\n+      child.Join();\n+\n+      // The child thread sets itself as the debug delegate, so we need to\n+      // usurp it after the child finishes, or else future breakpoints\n+      // will be delegated to a destroyed ArchiveRestoreThread object.\n+      debug_->SetDebugDelegate(this, false);\n+\n+      // This is the most important check in this test, since\n+      // child.GetBreakCount() will return 1 if the debugger fails to stop\n+      // on the `return n + 1` line after the grandchild thread returns.\n+      CHECK_EQ(child.GetBreakCount(), 2);\n+    }\n+  }\n+\n+  int GetBreakCount() { return break_count_; }\n+\n+ private:\n+  v8::Isolate* isolate_;\n+  v8::internal::Debug* debug_;\n+  const int spawn_count_;\n+  int break_count_;\n+};\n+\n+TEST(DebugArchiveRestore) {\n+  v8::Isolate::CreateParams create_params;\n+  create_params.array_buffer_allocator = CcTest::array_buffer_allocator();\n+  v8::Isolate* isolate = v8::Isolate::New(create_params);\n+\n+  ArchiveRestoreThread thread(isolate, 5);\n+  // Instead of calling thread.Start() and thread.Join() here, we call\n+  // thread.Run() directly, to make sure we exercise archive/restore\n+  // logic on the *current* thread as well as other threads.\n+  thread.Run();\n+  CHECK_EQ(thread.GetBreakCount(), 2);\n+\n+  isolate->Dispose();\n+}\n+\n+\n static void DebugEventExpectNoException(\n     const v8::Debug::EventDetails& event_details) {\n   v8::DebugEvent event = event_details.GetEvent();"
        }
    ],
    "stats": {
        "total": 172,
        "additions": 163,
        "deletions": 9
    }
}