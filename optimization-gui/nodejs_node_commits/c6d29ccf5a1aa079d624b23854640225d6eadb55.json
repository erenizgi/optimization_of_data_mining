{
    "author": "addaleax",
    "message": "buffer: do proper error propagation in addon methods\n\n- Always fulfill the `MaybeLocal<>` contract by scheduling an\n  exception when returning an empty value. This was previously\n  inconsistent, with no way to know whether an exception was\n  be scheduled or not in case of failure.\n- Make sure that memory is released exactly once in case of\n  failure. Previously, some exit conditions would have leaked\n  memory or attempted to free it multiple times.\n\nThis should not really affect how `Buffer`s are created by\naddons in practice, due to the low frequency with which\nthese errors would typically occur.\n\nPR-URL: https://github.com/nodejs/node/pull/23939\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "c6d29ccf5a1aa079d624b23854640225d6eadb55",
    "files": [
        {
            "sha": "59605ff50a8968eca8c1695d6731e346a494539b",
            "filename": "src/node_buffer.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 23,
            "changes": 48,
            "blob_url": "https://github.com/nodejs/node/blob/c6d29ccf5a1aa079d624b23854640225d6eadb55/src%2Fnode_buffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/c6d29ccf5a1aa079d624b23854640225d6eadb55/src%2Fnode_buffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_buffer.cc?ref=c6d29ccf5a1aa079d624b23854640225d6eadb55",
            "patch": "@@ -243,8 +243,10 @@ MaybeLocal<Object> New(Isolate* isolate,\n   if (length > 0) {\n     data = static_cast<char*>(BufferMalloc(length));\n \n-    if (data == nullptr)\n+    if (data == nullptr) {\n+      THROW_ERR_MEMORY_ALLOCATION_FAILED(isolate);\n       return Local<Object>();\n+    }\n \n     actual = StringBytes::Write(isolate, data, length, string, enc);\n     CHECK(actual <= length);\n@@ -286,14 +288,17 @@ MaybeLocal<Object> New(Environment* env, size_t length) {\n \n   // V8 currently only allows a maximum Typed Array index of max Smi.\n   if (length > kMaxLength) {\n+    env->isolate()->ThrowException(ERR_BUFFER_TOO_LARGE(env->isolate()));\n     return Local<Object>();\n   }\n \n   void* data;\n   if (length > 0) {\n     data = BufferMalloc(length);\n-    if (data == nullptr)\n+    if (data == nullptr) {\n+      THROW_ERR_MEMORY_ALLOCATION_FAILED(env);\n       return Local<Object>();\n+    }\n   } else {\n     data = nullptr;\n   }\n@@ -303,14 +308,10 @@ MaybeLocal<Object> New(Environment* env, size_t length) {\n         data,\n         length,\n         ArrayBufferCreationMode::kInternalized);\n-  MaybeLocal<Uint8Array> ui = Buffer::New(env, ab, 0, length);\n-\n-  if (ui.IsEmpty()) {\n-    // Object failed to be created. Clean up resources.\n-    free(data);\n-  }\n-\n-  return scope.Escape(ui.FromMaybe(Local<Uint8Array>()));\n+  Local<Object> obj;\n+  if (Buffer::New(env, ab, 0, length).ToLocal(&obj))\n+    return scope.Escape(obj);\n+  return Local<Object>();\n }\n \n \n@@ -333,15 +334,18 @@ MaybeLocal<Object> Copy(Environment* env, const char* data, size_t length) {\n \n   // V8 currently only allows a maximum Typed Array index of max Smi.\n   if (length > kMaxLength) {\n+    env->isolate()->ThrowException(ERR_BUFFER_TOO_LARGE(env->isolate()));\n     return Local<Object>();\n   }\n \n   void* new_data;\n   if (length > 0) {\n     CHECK_NOT_NULL(data);\n     new_data = node::UncheckedMalloc(length);\n-    if (new_data == nullptr)\n+    if (new_data == nullptr) {\n+      THROW_ERR_MEMORY_ALLOCATION_FAILED(env);\n       return Local<Object>();\n+    }\n     memcpy(new_data, data, length);\n   } else {\n     new_data = nullptr;\n@@ -352,14 +356,10 @@ MaybeLocal<Object> Copy(Environment* env, const char* data, size_t length) {\n         new_data,\n         length,\n         ArrayBufferCreationMode::kInternalized);\n-  MaybeLocal<Uint8Array> ui = Buffer::New(env, ab, 0, length);\n-\n-  if (ui.IsEmpty()) {\n-    // Object failed to be created. Clean up resources.\n-    free(new_data);\n-  }\n-\n-  return scope.Escape(ui.FromMaybe(Local<Uint8Array>()));\n+  Local<Object> obj;\n+  if (Buffer::New(env, ab, 0, length).ToLocal(&obj))\n+    return scope.Escape(obj);\n+  return Local<Object>();\n }\n \n \n@@ -390,6 +390,8 @@ MaybeLocal<Object> New(Environment* env,\n   EscapableHandleScope scope(env->isolate());\n \n   if (length > kMaxLength) {\n+    env->isolate()->ThrowException(ERR_BUFFER_TOO_LARGE(env->isolate()));\n+    callback(data, hint);\n     return Local<Object>();\n   }\n \n@@ -401,11 +403,11 @@ MaybeLocal<Object> New(Environment* env,\n     ab->Neuter();\n   MaybeLocal<Uint8Array> ui = Buffer::New(env, ab, 0, length);\n \n-  if (ui.IsEmpty()) {\n-    return Local<Object>();\n-  }\n-\n   CallbackInfo::New(env->isolate(), ab, callback, data, hint);\n+\n+  if (ui.IsEmpty())\n+    return MaybeLocal<Object>();\n+\n   return scope.Escape(ui.ToLocalChecked());\n }\n "
        }
    ],
    "stats": {
        "total": 48,
        "additions": 25,
        "deletions": 23
    }
}