{
    "author": "ofrobots",
    "message": "async_hooks: deprecate unsafe emit{Before,After}\n\nThe emit{Before,After} APIs in AsyncResource are problematic.\n\n* emit{Before,After} are named to suggest that the only thing they do\n  is emit the before and after hooks. However, they in fact, mutate\n  the current execution context.\n* They must be properly nested. Failure to do so by user code leads\n  to catastrophic (unrecoverable) exceptions. It is very easy for the\n  users to forget that they must be using a try/finally block around\n  the code that must be surrounded by these operations. Even the\n  example provided in the official docs makes this mistake. Failing\n  to use a finally can lead to a catastrophic crash if the callback\n  ends up throwing.\n\nThis change provides a safer `runInAsyncScope` API as an alternative\nand deprecates emit{Before,After}.\n\nPR-URL: https://github.com/nodejs/node/pull/18513\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Andreas Madsen <amwebdk@gmail.com>",
    "sha": "523a1550a3d07ecc3d13e071cb0f1c732bae3bad",
    "files": [
        {
            "sha": "4813169bfd81791862dffbf81e8917028a1ca7f7",
            "filename": "doc/api/async_hooks.md",
            "status": "modified",
            "additions": 52,
            "deletions": 12,
            "changes": 64,
            "blob_url": "https://github.com/nodejs/node/blob/523a1550a3d07ecc3d13e071cb0f1c732bae3bad/doc%2Fapi%2Fasync_hooks.md",
            "raw_url": "https://github.com/nodejs/node/raw/523a1550a3d07ecc3d13e071cb0f1c732bae3bad/doc%2Fapi%2Fasync_hooks.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fasync_hooks.md?ref=523a1550a3d07ecc3d13e071cb0f1c732bae3bad",
            "patch": "@@ -599,10 +599,6 @@ own resources.\n \n The `init` hook will trigger when an `AsyncResource` is instantiated.\n \n-The `before` and `after` calls must be unwound in the same order that they\n-are called. Otherwise, an unrecoverable exception will occur and the process\n-will abort.\n-\n The following is an overview of the `AsyncResource` API.\n \n ```js\n@@ -615,11 +611,13 @@ const asyncResource = new AsyncResource(\n   type, { triggerAsyncId: executionAsyncId(), requireManualDestroy: false }\n );\n \n-// Call AsyncHooks before callbacks.\n-asyncResource.emitBefore();\n-\n-// Call AsyncHooks after callbacks.\n-asyncResource.emitAfter();\n+// Run a function in the execution context of the resource. This will\n+// * establish the context of the resource\n+// * trigger the AsyncHooks before callbacks\n+// * call the provided function `fn` with the supplied arguments\n+// * trigger the AsyncHooks after callbacks\n+// * restore the original execution context\n+asyncResource.runInAsyncScope(fn, thisArg, ...args);\n \n // Call AsyncHooks destroy callbacks.\n asyncResource.emitDestroy();\n@@ -629,6 +627,14 @@ asyncResource.asyncId();\n \n // Return the trigger ID for the AsyncResource instance.\n asyncResource.triggerAsyncId();\n+\n+// Call AsyncHooks before callbacks.\n+// Deprecated: Use asyncResource.runInAsyncScope instead.\n+asyncResource.emitBefore();\n+\n+// Call AsyncHooks after callbacks.\n+// Deprecated: Use asyncResource.runInAsyncScope instead.\n+asyncResource.emitAfter();\n ```\n \n #### `AsyncResource(type[, options])`\n@@ -654,9 +660,7 @@ class DBQuery extends AsyncResource {\n \n   getInfo(query, callback) {\n     this.db.get(query, (err, data) => {\n-      this.emitBefore();\n-      callback(err, data);\n-      this.emitAfter();\n+      this.runInAsyncScope(callback, null, err, data);\n     });\n   }\n \n@@ -667,15 +671,44 @@ class DBQuery extends AsyncResource {\n }\n ```\n \n+#### `asyncResource.runInAsyncScope(fn[, thisArg, ...args])`\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `fn` {Function} The function to call in the execution context of this async\n+  resource.\n+* `thisArg` {any} The receiver to be used for the function call.\n+* `...args` {any} Optional arguments to pass to the function.\n+\n+Call the provided function with the provided arguments in the execution context\n+of the async resource. This will establish the context, trigger the AsyncHooks\n+before callbacks, call the function, trigger the AsyncHooks after callbacks, and\n+then restore the original execution context.\n+\n #### `asyncResource.emitBefore()`\n+<!-- YAML\n+deprecated: REPLACEME\n+-->\n+> Stability: 0 - Deprecated: Use [`asyncResource.runInAsyncScope()`][] instead.\n \n * Returns: {undefined}\n \n Call all `before` callbacks to notify that a new asynchronous execution context\n is being entered. If nested calls to `emitBefore()` are made, the stack of\n `asyncId`s will be tracked and properly unwound.\n \n+`before` and `after` calls must be unwound in the same order that they\n+are called. Otherwise, an unrecoverable exception will occur and the process\n+will abort. For this reason, the `emitBefore` and `emitAfter` APIs are\n+considered deprecated. Please use `runInAsyncScope`, as it provides a much safer\n+alternative.\n+\n #### `asyncResource.emitAfter()`\n+<!-- YAML\n+deprecated: REPLACEME\n+-->\n+> Stability: 0 - Deprecated: Use [`asyncResource.runInAsyncScope()`][] instead.\n \n * Returns: {undefined}\n \n@@ -686,6 +719,12 @@ If the user's callback throws an exception, `emitAfter()` will automatically be\n called for all `asyncId`s on the stack if the error is handled by a domain or\n `'uncaughtException'` handler.\n \n+`before` and `after` calls must be unwound in the same order that they\n+are called. Otherwise, an unrecoverable exception will occur and the process\n+will abort. For this reason, the `emitBefore` and `emitAfter` APIs are\n+considered deprecated. Please use `runInAsyncScope`, as it provides a much safer\n+alternative.\n+\n #### `asyncResource.emitDestroy()`\n \n * Returns: {undefined}\n@@ -705,6 +744,7 @@ never be called.\n constructor.\n \n [`after` callback]: #async_hooks_after_asyncid\n+[`asyncResource.runInAsyncScope()`]: #async_hooks_asyncresource_runinasyncscope_fn_thisarg_args\n [`before` callback]: #async_hooks_before_asyncid\n [`destroy` callback]: #async_hooks_destroy_asyncid\n [`init` callback]: #async_hooks_init_asyncid_type_triggerasyncid_resource"
        },
        {
            "sha": "c18c9d58e0b521e9115c92aff30beadfceba3a12",
            "filename": "doc/api/deprecations.md",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/nodejs/node/blob/523a1550a3d07ecc3d13e071cb0f1c732bae3bad/doc%2Fapi%2Fdeprecations.md",
            "raw_url": "https://github.com/nodejs/node/raw/523a1550a3d07ecc3d13e071cb0f1c732bae3bad/doc%2Fapi%2Fdeprecations.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fdeprecations.md?ref=523a1550a3d07ecc3d13e071cb0f1c732bae3bad",
            "patch": "@@ -880,6 +880,18 @@ Users of `MakeCallback` that add the `domain` property to carry context,\n should start using the `async_context` variant of `MakeCallback` or\n `CallbackScope`, or the the high-level `AsyncResource` class.\n \n+<a id=\"DEP0098\"></a>\n+### DEP0098: AsyncHooks Embedder AsyncResource.emit{Before,After} APIs\n+\n+Type: Runtime\n+\n+The embedded API provided by AsyncHooks exposes emit{Before,After} methods\n+which are very easy to use incorrectly which can lead to unrecoverable errors.\n+\n+Use [`asyncResource.runInAsyncScope()`][] API instead which provides a much\n+safer, and more convenient, alternative. See\n+https://github.com/nodejs/node/pull/18513 for more details.\n+\n [`--pending-deprecation`]: cli.html#cli_pending_deprecation\n [`Buffer.allocUnsafeSlow(size)`]: buffer.html#buffer_class_method_buffer_allocunsafeslow_size\n [`Buffer.from(array)`]: buffer.html#buffer_class_method_buffer_from_array\n@@ -892,6 +904,7 @@ should start using the `async_context` variant of `MakeCallback` or\n [`Server.getConnections()`]: net.html#net_server_getconnections_callback\n [`Server.listen({fd: <number>})`]: net.html#net_server_listen_handle_backlog_callback\n [`SlowBuffer`]: buffer.html#buffer_class_slowbuffer\n+[`asyncResource.runInAsyncScope()`]: async_hooks.html#async_hooks_asyncresource_runinasyncscope_fn_thisarg_args\n [`child_process`]: child_process.html\n [`console.error()`]: console.html#console_console_error_data_args\n [`console.log()`]: console.html#console_console_log_data_args"
        },
        {
            "sha": "e7450f29acc05fb99b7918f23876137720d94e62",
            "filename": "lib/async_hooks.js",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/nodejs/node/blob/523a1550a3d07ecc3d13e071cb0f1c732bae3bad/lib%2Fasync_hooks.js",
            "raw_url": "https://github.com/nodejs/node/raw/523a1550a3d07ecc3d13e071cb0f1c732bae3bad/lib%2Fasync_hooks.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Fasync_hooks.js?ref=523a1550a3d07ecc3d13e071cb0f1c732bae3bad",
            "patch": "@@ -139,6 +139,17 @@ function triggerAsyncId() {\n \n const destroyedSymbol = Symbol('destroyed');\n \n+let emitBeforeAfterWarning = true;\n+function showEmitBeforeAfterWarning() {\n+  if (emitBeforeAfterWarning) {\n+    process.emitWarning(\n+      'asyncResource.emitBefore and emitAfter are deprecated. Please use ' +\n+      'asyncResource.runInAsyncScope instead',\n+      'DeprecationWarning', 'DEP00XX');\n+    emitBeforeAfterWarning = false;\n+  }\n+}\n+\n class AsyncResource {\n   constructor(type, opts = {}) {\n     if (typeof type !== 'string')\n@@ -174,15 +185,28 @@ class AsyncResource {\n   }\n \n   emitBefore() {\n+    showEmitBeforeAfterWarning();\n     emitBefore(this[async_id_symbol], this[trigger_async_id_symbol]);\n     return this;\n   }\n \n   emitAfter() {\n+    showEmitBeforeAfterWarning();\n     emitAfter(this[async_id_symbol]);\n     return this;\n   }\n \n+  runInAsyncScope(fn, thisArg, ...args) {\n+    emitBefore(this[async_id_symbol], this[trigger_async_id_symbol]);\n+    let ret;\n+    try {\n+      ret = Reflect.apply(fn, thisArg, args);\n+    } finally {\n+      emitAfter(this[async_id_symbol]);\n+    }\n+    return ret;\n+  }\n+\n   emitDestroy() {\n     this[destroyedSymbol].destroyed = true;\n     emitDestroy(this[async_id_symbol]);"
        },
        {
            "sha": "627880b4d98b07cffda61737924e2f9ee16cf58f",
            "filename": "test/async-hooks/test-embedder.api.async-resource.runInAsyncScope.js",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/523a1550a3d07ecc3d13e071cb0f1c732bae3bad/test%2Fasync-hooks%2Ftest-embedder.api.async-resource.runInAsyncScope.js",
            "raw_url": "https://github.com/nodejs/node/raw/523a1550a3d07ecc3d13e071cb0f1c732bae3bad/test%2Fasync-hooks%2Ftest-embedder.api.async-resource.runInAsyncScope.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fasync-hooks%2Ftest-embedder.api.async-resource.runInAsyncScope.js?ref=523a1550a3d07ecc3d13e071cb0f1c732bae3bad",
            "patch": "@@ -0,0 +1,11 @@\n+'use strict';\n+require('../common');\n+const assert = require('assert');\n+const async_hooks = require('async_hooks');\n+\n+// Ensure that asyncResource.makeCallback returns the callback return value.\n+const a = new async_hooks.AsyncResource('foobar');\n+const ret = a.runInAsyncScope(() => {\n+  return 1729;\n+});\n+assert.strictEqual(ret, 1729);"
        },
        {
            "sha": "bc4ac86e7f1ca197de4cd8d49c3a90703a860208",
            "filename": "test/parallel/test-async-hooks-recursive-stack-runInAsyncScope.js",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/nodejs/node/blob/523a1550a3d07ecc3d13e071cb0f1c732bae3bad/test%2Fparallel%2Ftest-async-hooks-recursive-stack-runInAsyncScope.js",
            "raw_url": "https://github.com/nodejs/node/raw/523a1550a3d07ecc3d13e071cb0f1c732bae3bad/test%2Fparallel%2Ftest-async-hooks-recursive-stack-runInAsyncScope.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-async-hooks-recursive-stack-runInAsyncScope.js?ref=523a1550a3d07ecc3d13e071cb0f1c732bae3bad",
            "patch": "@@ -0,0 +1,20 @@\n+'use strict';\n+require('../common');\n+const assert = require('assert');\n+const async_hooks = require('async_hooks');\n+\n+// This test verifies that the async ID stack can grow indefinitely.\n+\n+function recurse(n) {\n+  const a = new async_hooks.AsyncResource('foobar');\n+  a.runInAsyncScope(() => {\n+    assert.strictEqual(a.asyncId(), async_hooks.executionAsyncId());\n+    assert.strictEqual(a.triggerAsyncId(), async_hooks.triggerAsyncId());\n+    if (n >= 0)\n+      recurse(n - 1);\n+    assert.strictEqual(a.asyncId(), async_hooks.executionAsyncId());\n+    assert.strictEqual(a.triggerAsyncId(), async_hooks.triggerAsyncId());\n+  });\n+}\n+\n+recurse(1000);"
        },
        {
            "sha": "5003972e9984aa0ec2df10418b52bc8d43af13e2",
            "filename": "test/parallel/test-emit-after-uncaught-exception-runInAsyncScope.js",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/523a1550a3d07ecc3d13e071cb0f1c732bae3bad/test%2Fparallel%2Ftest-emit-after-uncaught-exception-runInAsyncScope.js",
            "raw_url": "https://github.com/nodejs/node/raw/523a1550a3d07ecc3d13e071cb0f1c732bae3bad/test%2Fparallel%2Ftest-emit-after-uncaught-exception-runInAsyncScope.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-emit-after-uncaught-exception-runInAsyncScope.js?ref=523a1550a3d07ecc3d13e071cb0f1c732bae3bad",
            "patch": "@@ -0,0 +1,40 @@\n+'use strict';\n+\n+const common = require('../common');\n+const assert = require('assert');\n+const async_hooks = require('async_hooks');\n+\n+const id_obj = {};\n+let collect = true;\n+\n+const hook = async_hooks.createHook({\n+  before(id) { if (collect) id_obj[id] = true; },\n+  after(id) { delete id_obj[id]; },\n+}).enable();\n+\n+process.once('uncaughtException', common.mustCall((er) => {\n+  assert.strictEqual(er.message, 'bye');\n+  collect = false;\n+}));\n+\n+setImmediate(common.mustCall(() => {\n+  process.nextTick(common.mustCall(() => {\n+    assert.strictEqual(Object.keys(id_obj).length, 0);\n+    hook.disable();\n+  }));\n+\n+  // Create a stack of async ids that will need to be emitted in the case of\n+  // an uncaught exception.\n+  const ar1 = new async_hooks.AsyncResource('Mine');\n+  ar1.runInAsyncScope(() => {\n+    const ar2 = new async_hooks.AsyncResource('Mine');\n+    ar2.runInAsyncScope(() => {\n+      throw new Error('bye');\n+    });\n+  });\n+\n+  // TODO(trevnorris): This test shows that the after() hooks are always called\n+  // correctly, but it doesn't solve where the emitDestroy() is missed because\n+  // of the uncaught exception. Simple solution is to always call emitDestroy()\n+  // before the emitAfter(), but how to codify this?\n+}));"
        }
    ],
    "stats": {
        "total": 172,
        "additions": 160,
        "deletions": 12
    }
}