{
    "author": "addaleax",
    "message": "report: make more items programmatically accessible\n\nPrefer structured output over stringified information\nfor libuv handles and the native stack trace.\n\nPR-URL: https://github.com/nodejs/node/pull/26019\nReviewed-By: Richard Lau <riclau@uk.ibm.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "2c84f6e75cc513fe6e958f0489d104ee883db232",
    "files": [
        {
            "sha": "8d6d054c0a10b9aa827fb63619b9d4dc7db90b8a",
            "filename": "doc/api/report.md",
            "status": "modified",
            "additions": 61,
            "deletions": 18,
            "changes": 79,
            "blob_url": "https://github.com/nodejs/node/blob/2c84f6e75cc513fe6e958f0489d104ee883db232/doc%2Fapi%2Freport.md",
            "raw_url": "https://github.com/nodejs/node/raw/2c84f6e75cc513fe6e958f0489d104ee883db232/doc%2Fapi%2Freport.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Freport.md?ref=2c84f6e75cc513fe6e958f0489d104ee883db232",
            "patch": "@@ -78,12 +78,26 @@ is provided below for reference.\n     ]\n   },\n   \"nativeStack\": [\n-    \" [pc=0xa7ef87]  [/home/nodeuser/project/node/out/Release/node]\",\n-    \" [pc=0xa81adb] report::TriggerNodeReport(v8::Isolate*, node::Environment*, char const*, char const*, std::string, v8::Local<v8::String>) [/home/nodeuser/project/node/out/Release/node]\",\n-    \" [pc=0xa834f2] report::OnUncaughtException(v8::FunctionCallbackInfo<v8::Value> const&) [/home/nodeuser/project/node/out/Release/node]\",\n-    \" [pc=0xbe6b78]  [/home/nodeuser/project/node/out/Release/node]\",\n-    \" [pc=0xbe7596] v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) [/home/nodeuser/project/node/out/Release/node]\",\n-    \" [pc=0x1930cae]  [/home/nodeuser/project/node/out/Release/node]\"\n+    {\n+      \"pc\": \"0x000055b57f07a9ef\",\n+      \"symbol\": \"report::GetNodeReport(v8::Isolate*, node::Environment*, char const*, char const*, v8::Local<v8::String>, std::ostream&) [./node]\"\n+    },\n+    {\n+      \"pc\": \"0x000055b57f07cf03\",\n+      \"symbol\": \"report::GetReport(v8::FunctionCallbackInfo<v8::Value> const&) [./node]\"\n+    },\n+    {\n+      \"pc\": \"0x000055b57f1bccfd\",\n+      \"symbol\": \" [./node]\"\n+    },\n+    {\n+      \"pc\": \"0x000055b57f1be048\",\n+      \"symbol\": \"v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) [./node]\"\n+    },\n+    {\n+      \"pc\": \"0x000055b57feeda0e\",\n+      \"symbol\": \" [./node]\"\n+    }\n   ],\n   \"javascriptHeap\": {\n     \"totalMemory\": 6127616,\n@@ -175,46 +189,75 @@ is provided below for reference.\n       \"details\": \"\"\n     },\n     {\n+      \"repeat\": 0,\n+      \"firesInMsFromNow\": 94403548320796,\n+      \"expired\": true,\n       \"type\": \"timer\",\n       \"is_active\": false,\n       \"is_referenced\": false,\n-      \"address\": \"0x00007fff5fbfeab0\",\n-      \"details\": \"repeat: 0, timeout expired: 18075165916 ms ago\"\n+      \"address\": \"0x00007fff5fbfeab0\"\n     },\n     {\n       \"type\": \"check\",\n       \"is_active\": true,\n       \"is_referenced\": false,\n-      \"address\": \"0x00007fff5fbfeb48\",\n-      \"details\": \"\"\n+      \"address\": \"0x00007fff5fbfeb48\"\n     },\n     {\n       \"type\": \"idle\",\n       \"is_active\": false,\n       \"is_referenced\": true,\n-      \"address\": \"0x00007fff5fbfebc0\",\n-      \"details\": \"\"\n+      \"address\": \"0x00007fff5fbfebc0\"\n     },\n     {\n       \"type\": \"prepare\",\n       \"is_active\": false,\n       \"is_referenced\": false,\n-      \"address\": \"0x00007fff5fbfec38\",\n-      \"details\": \"\"\n+      \"address\": \"0x00007fff5fbfec38\"\n     },\n     {\n       \"type\": \"check\",\n       \"is_active\": false,\n       \"is_referenced\": false,\n-      \"address\": \"0x00007fff5fbfecb0\",\n-      \"details\": \"\"\n+      \"address\": \"0x00007fff5fbfecb0\"\n     },\n     {\n       \"type\": \"async\",\n       \"is_active\": true,\n       \"is_referenced\": false,\n-      \"address\": \"0x000000010188f2e0\",\n-      \"details\": \"\"\n+      \"address\": \"0x000000010188f2e0\"\n+    },\n+    {\n+      \"width\": 204,\n+      \"height\": 55,\n+      \"fd\": 17,\n+      \"writeQueueSize\": 0,\n+      \"readable\": true,\n+      \"writable\": true,\n+      \"type\": \"tty\",\n+      \"is_active\": false,\n+      \"is_referenced\": true,\n+      \"address\": \"0x000055b581db0e18\"\n+    },\n+    {\n+      \"signum\": 28,\n+      \"signal\": \"SIGWINCH\",\n+      \"type\": \"signal\",\n+      \"is_active\": true,\n+      \"is_referenced\": false,\n+      \"address\": \"0x000055b581d80010\"\n+    },\n+    {\n+      \"width\": 204,\n+      \"height\": 55,\n+      \"fd\": 19,\n+      \"writeQueueSize\": 0,\n+      \"readable\": true,\n+      \"writable\": true,\n+      \"type\": \"tty\",\n+      \"is_active\": true,\n+      \"is_referenced\": true,\n+      \"address\": \"0x000055b581df59f8\"\n     },\n     {\n       \"type\": \"loop\","
        },
        {
            "sha": "1a459a2d1c97a34346cd40780e83ea2b2f18489f",
            "filename": "src/node_report.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/2c84f6e75cc513fe6e958f0489d104ee883db232/src%2Fnode_report.cc",
            "raw_url": "https://github.com/nodejs/node/raw/2c84f6e75cc513fe6e958f0489d104ee883db232/src%2Fnode_report.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_report.cc?ref=2c84f6e75cc513fe6e958f0489d104ee883db232",
            "patch": "@@ -216,9 +216,8 @@ void GetNodeReport(Isolate* isolate,\n   // Obtain the current time and the pid (platform dependent)\n   TIME_TYPE tm_struct;\n   LocalTime(&tm_struct);\n-  std::string str = \"NA\";\n   WriteNodeReport(\n-      isolate, env, message, location, str, out, stackstr, &tm_struct);\n+      isolate, env, message, location, \"\", out, stackstr, &tm_struct);\n }\n \n // Internal function to coordinate and write the various\n@@ -249,7 +248,7 @@ static void WriteNodeReport(Isolate* isolate,\n   if (!filename.empty())\n     writer.json_keyvalue(\"filename\", filename);\n   else\n-    writer.json_keyvalue(\"filename\", \"''\");\n+    writer.json_keyvalue(\"filename\", JSONWriter::Null{});\n \n   // Report dump event and module load date/time stamps\n   char timebuf[64];\n@@ -431,13 +430,13 @@ static void PrintNativeStack(JSONWriter* writer) {\n   const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));\n   writer->json_arraystart(\"nativeStack\");\n   int i;\n-  std::ostringstream buf;\n   for (i = 1; i < size; i++) {\n     void* frame = frames[i];\n-    buf.str(\"\");\n-    buf << \" [pc=\" << frame << \"] \";\n-    buf << sym_ctx->LookupSymbol(frame).Display().c_str();\n-    writer->json_element(buf.str());\n+    writer->json_start();\n+    writer->json_keyvalue(\"pc\",\n+                          ValueToHexString(reinterpret_cast<uintptr_t>(frame)));\n+    writer->json_keyvalue(\"symbol\", sym_ctx->LookupSymbol(frame).Display());\n+    writer->json_end();\n   }\n   writer->json_arrayend();\n }"
        },
        {
            "sha": "c83c52eb395a58e4c87fdb304ff9c5c588bd54fb",
            "filename": "src/node_report.h",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/2c84f6e75cc513fe6e958f0489d104ee883db232/src%2Fnode_report.h",
            "raw_url": "https://github.com/nodejs/node/raw/2c84f6e75cc513fe6e958f0489d104ee883db232/src%2Fnode_report.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_report.h?ref=2c84f6e75cc513fe6e958f0489d104ee883db232",
            "patch": "@@ -54,7 +54,6 @@ void GetNodeReport(v8::Isolate* isolate,\n                    std::ostream& out);\n \n // Function declarations - utility functions in src/node_report_utils.cc\n-void ReportEndpoints(uv_handle_t* h, std::ostringstream& out);\n void WalkHandle(uv_handle_t* h, void* arg);\n std::string EscapeJsonChars(const std::string& str);\n \n@@ -157,6 +156,8 @@ class JSONWriter {\n     state_ = kAfterValue;\n   }\n \n+  struct Null {};  // Usable as a JSON value.\n+\n  private:\n   template <typename T,\n             typename test_for_number = typename std::\n@@ -168,6 +169,7 @@ class JSONWriter {\n       out_ << number;\n   }\n \n+  inline void write_value(Null null) { out_ << \"null\"; }\n   inline void write_value(const char* str) { write_string(str); }\n   inline void write_value(const std::string& str) { write_string(str); }\n "
        },
        {
            "sha": "db7290118723e0d47ca7cc04104337eb43f0aee0",
            "filename": "src/node_report_utils.cc",
            "status": "modified",
            "additions": 61,
            "deletions": 48,
            "changes": 109,
            "blob_url": "https://github.com/nodejs/node/blob/2c84f6e75cc513fe6e958f0489d104ee883db232/src%2Fnode_report_utils.cc",
            "raw_url": "https://github.com/nodejs/node/raw/2c84f6e75cc513fe6e958f0489d104ee883db232/src%2Fnode_report_utils.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_report_utils.cc?ref=2c84f6e75cc513fe6e958f0489d104ee883db232",
            "patch": "@@ -5,20 +5,24 @@ namespace report {\n \n using node::MallocedBuffer;\n \n+static constexpr auto null = JSONWriter::Null{};\n+\n // Utility function to format libuv socket information.\n-void ReportEndpoints(uv_handle_t* h, std::ostringstream& out) {\n+static void ReportEndpoints(uv_handle_t* h, JSONWriter* writer) {\n   struct sockaddr_storage addr_storage;\n   struct sockaddr* addr = reinterpret_cast<sockaddr*>(&addr_storage);\n   uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);\n   int addr_size = sizeof(addr_storage);\n   int rc = -1;\n+  bool wrote_local_endpoint = false;\n+  bool wrote_remote_endpoint = false;\n \n   switch (h->type) {\n     case UV_UDP:\n-      rc = uv_udp_getsockname(&(handle->udp), addr, &addr_size);\n+      rc = uv_udp_getsockname(&handle->udp, addr, &addr_size);\n       break;\n     case UV_TCP:\n-      rc = uv_tcp_getsockname(&(handle->tcp), addr, &addr_size);\n+      rc = uv_tcp_getsockname(&handle->tcp, addr, &addr_size);\n       break;\n     default:\n       break;\n@@ -28,31 +32,42 @@ void ReportEndpoints(uv_handle_t* h, std::ostringstream& out) {\n     uv_getnameinfo_t local;\n     rc = uv_getnameinfo(h->loop, &local, nullptr, addr, NI_NUMERICSERV);\n \n-    if (rc == 0)\n-      out << local.host << \":\" << local.service;\n+    if (rc == 0) {\n+      writer->json_objectstart(\"localEndpoint\");\n+      writer->json_keyvalue(\"host\", local.host);\n+      writer->json_keyvalue(\"port\", local.service);\n+      writer->json_objectend();\n+      wrote_local_endpoint = true;\n+    }\n+  }\n+  if (!wrote_local_endpoint) writer->json_keyvalue(\"localEndpoint\", null);\n \n-    if (h->type == UV_TCP) {\n-      // Get the remote end of the connection.\n-      rc = uv_tcp_getpeername(&(handle->tcp), addr, &addr_size);\n-      if (rc == 0) {\n-        uv_getnameinfo_t remote;\n-        rc = uv_getnameinfo(h->loop, &remote, nullptr, addr, NI_NUMERICSERV);\n+  if (h->type == UV_TCP) {\n+    // Get the remote end of the connection.\n+    rc = uv_tcp_getpeername(&handle->tcp, addr, &addr_size);\n+    if (rc == 0) {\n+      uv_getnameinfo_t remote;\n+      rc = uv_getnameinfo(h->loop, &remote, nullptr, addr, NI_NUMERICSERV);\n \n-        if (rc == 0)\n-          out << \" connected to \" << remote.host << \":\" << remote.service;\n-      } else if (rc == UV_ENOTCONN) {\n-        out << \" (not connected)\";\n+      if (rc == 0) {\n+        writer->json_objectstart(\"remoteEndpoint\");\n+        writer->json_keyvalue(\"host\", remote.host);\n+        writer->json_keyvalue(\"port\", remote.service);\n+        writer->json_objectend();\n+        wrote_local_endpoint = true;\n       }\n     }\n   }\n+  if (!wrote_remote_endpoint) writer->json_keyvalue(\"remoteEndpoint\", null);\n }\n \n // Utility function to format libuv path information.\n-void ReportPath(uv_handle_t* h, std::ostringstream& out) {\n+static void ReportPath(uv_handle_t* h, JSONWriter* writer) {\n   MallocedBuffer<char> buffer(0);\n   int rc = -1;\n   size_t size = 0;\n   uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);\n+  bool wrote_filename = false;\n   // First call to get required buffer size.\n   switch (h->type) {\n     case UV_FS_EVENT:\n@@ -65,7 +80,7 @@ void ReportPath(uv_handle_t* h, std::ostringstream& out) {\n       break;\n   }\n   if (rc == UV_ENOBUFS) {\n-    buffer = MallocedBuffer<char>(size);\n+    buffer = MallocedBuffer<char>(size + 1);\n     switch (h->type) {\n       case UV_FS_EVENT:\n         rc = uv_fs_event_getpath(&(handle->fs_event), buffer.data, &size);\n@@ -78,55 +93,58 @@ void ReportPath(uv_handle_t* h, std::ostringstream& out) {\n     }\n     if (rc == 0) {\n       // buffer is not null terminated.\n-      std::string name(buffer.data, size);\n-      out << \"filename: \" << name;\n+      buffer.data[size] = '\\0';\n+      writer->json_keyvalue(\"filename\", buffer.data);\n+      wrote_filename = true;\n     }\n   }\n+  if (!wrote_filename) writer->json_keyvalue(\"filename\", null);\n }\n \n // Utility function to walk libuv handles.\n void WalkHandle(uv_handle_t* h, void* arg) {\n   const char* type = uv_handle_type_name(h->type);\n-  std::ostringstream data;\n   JSONWriter* writer = static_cast<JSONWriter*>(arg);\n   uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);\n \n+  writer->json_start();\n+\n   switch (h->type) {\n     case UV_FS_EVENT:\n     case UV_FS_POLL:\n-      ReportPath(h, data);\n+      ReportPath(h, writer);\n       break;\n     case UV_PROCESS:\n-      data << \"pid: \" << handle->process.pid;\n+      writer->json_keyvalue(\"pid\", handle->process.pid);\n       break;\n     case UV_TCP:\n     case UV_UDP:\n-      ReportEndpoints(h, data);\n+      ReportEndpoints(h, writer);\n       break;\n     case UV_TIMER: {\n       uint64_t due = handle->timer.timeout;\n       uint64_t now = uv_now(handle->timer.loop);\n-      data << \"repeat: \" << uv_timer_get_repeat(&(handle->timer));\n-      if (due > now) {\n-        data << \", timeout in: \" << (due - now) << \" ms\";\n-      } else {\n-        data << \", timeout expired: \" << (now - due) << \" ms ago\";\n-      }\n+      writer->json_keyvalue(\"repeat\", uv_timer_get_repeat(&handle->timer));\n+      writer->json_keyvalue(\"firesInMsFromNow\",\n+                            static_cast<int64_t>(due - now));\n+      writer->json_keyvalue(\"expired\", now >= due);\n       break;\n     }\n     case UV_TTY: {\n       int height, width, rc;\n       rc = uv_tty_get_winsize(&(handle->tty), &width, &height);\n       if (rc == 0) {\n-        data << \"width: \" << width << \", height: \" << height;\n+        writer->json_keyvalue(\"width\", width);\n+        writer->json_keyvalue(\"height\", height);\n       }\n       break;\n     }\n     case UV_SIGNAL:\n       // SIGWINCH is used by libuv so always appears.\n       // See http://docs.libuv.org/en/v1.x/signal.html\n-      data << \"signum: \" << handle->signal.signum << \" (\" <<\n-              node::signo_string(handle->signal.signum) << \")\";\n+      writer->json_keyvalue(\"signum\", handle->signal.signum);\n+      writer->json_keyvalue(\"signal\",\n+                            node::signo_string(handle->signal.signum));\n       break;\n     default:\n       break;\n@@ -141,13 +159,10 @@ void WalkHandle(uv_handle_t* h, void* arg) {\n     // values they contain.\n     int send_size = 0;\n     int recv_size = 0;\n-    if (h->type == UV_TCP || h->type == UV_UDP) {\n-      data << \", \";\n-    }\n     uv_send_buffer_size(h, &send_size);\n     uv_recv_buffer_size(h, &recv_size);\n-    data << \"send buffer size: \" << send_size\n-         << \", recv buffer size: \" << recv_size;\n+    writer->json_keyvalue(\"sendBufferSize\", send_size);\n+    writer->json_keyvalue(\"recvBufferSize\", recv_size);\n   }\n \n #ifndef _WIN32\n@@ -157,37 +172,35 @@ void WalkHandle(uv_handle_t* h, void* arg) {\n     int rc = uv_fileno(h, &fd_v);\n \n     if (rc == 0) {\n+      writer->json_keyvalue(\"fd\", static_cast<int>(fd_v));\n       switch (fd_v) {\n         case 0:\n-          data << \", stdin\";\n+          writer->json_keyvalue(\"stdio\", \"stdin\");\n           break;\n         case 1:\n-          data << \", stdout\";\n+          writer->json_keyvalue(\"stdio\", \"stdout\");\n           break;\n         case 2:\n-          data << \", stderr\";\n-          break;\n-        default:\n-          data << \", file descriptor: \" << static_cast<int>(fd_v);\n+          writer->json_keyvalue(\"stdio\", \"stderr\");\n           break;\n       }\n     }\n   }\n #endif\n \n   if (h->type == UV_TCP || h->type == UV_NAMED_PIPE || h->type == UV_TTY) {\n-    data << \", write queue size: \" << handle->stream.write_queue_size;\n-    data << (uv_is_readable(&handle->stream) ? \", readable\" : \"\")\n-         << (uv_is_writable(&handle->stream) ? \", writable\" : \"\");\n+    writer->json_keyvalue(\"writeQueueSize\", handle->stream.write_queue_size);\n+    writer->json_keyvalue(\"readable\",\n+                          static_cast<bool>(uv_is_readable(&handle->stream)));\n+    writer->json_keyvalue(\"writable\",\n+                          static_cast<bool>(uv_is_writable(&handle->stream)));\n   }\n \n-  writer->json_start();\n   writer->json_keyvalue(\"type\", type);\n   writer->json_keyvalue(\"is_active\", static_cast<bool>(uv_is_active(h)));\n   writer->json_keyvalue(\"is_referenced\", static_cast<bool>(uv_has_ref(h)));\n   writer->json_keyvalue(\"address\",\n                         ValueToHexString(reinterpret_cast<uint64_t>(h)));\n-  writer->json_keyvalue(\"details\", data.str());\n   writer->json_end();\n }\n "
        }
    ],
    "stats": {
        "total": 207,
        "additions": 132,
        "deletions": 75
    }
}