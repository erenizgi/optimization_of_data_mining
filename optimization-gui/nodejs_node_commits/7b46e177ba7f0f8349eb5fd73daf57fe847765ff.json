{
    "author": "addaleax",
    "message": "lib,src: make `StatWatcher` a `HandleWrap`\n\nWrapping libuv handles is what `HandleWrap` is there for.\nThis allows a decent reduction of state tracking machinery\nby moving active-ness tracking to JS, and removing all\ninteraction with garbage collection.\n\nRefs: https://github.com/nodejs/node/pull/21093\n\nPR-URL: https://github.com/nodejs/node/pull/21244\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "7b46e177ba7f0f8349eb5fd73daf57fe847765ff",
    "files": [
        {
            "sha": "e7edc1c5acd91f4d83e13a0828a3c0cce8ae0b38",
            "filename": "lib/internal/fs/watchers.js",
            "status": "modified",
            "additions": 40,
            "deletions": 28,
            "changes": 68,
            "blob_url": "https://github.com/nodejs/node/blob/7b46e177ba7f0f8349eb5fd73daf57fe847765ff/lib%2Finternal%2Ffs%2Fwatchers.js",
            "raw_url": "https://github.com/nodejs/node/raw/7b46e177ba7f0f8349eb5fd73daf57fe847765ff/lib%2Finternal%2Ffs%2Fwatchers.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Ffs%2Fwatchers.js?ref=7b46e177ba7f0f8349eb5fd73daf57fe847765ff",
            "patch": "@@ -11,41 +11,42 @@ const {\n   getStatsFromBinding,\n   validatePath\n } = require('internal/fs/utils');\n+const { defaultTriggerAsyncIdScope } = require('internal/async_hooks');\n const { toNamespacedPath } = require('path');\n const { validateUint32 } = require('internal/validators');\n const { getPathFromURL } = require('internal/url');\n const util = require('util');\n const assert = require('assert');\n \n+const kOldStatus = Symbol('kOldStatus');\n+const kUseBigint = Symbol('kUseBigint');\n+const kOwner = Symbol('kOwner');\n+\n function emitStop(self) {\n   self.emit('stop');\n }\n \n function StatWatcher(bigint) {\n   EventEmitter.call(this);\n \n-  this._handle = new _StatWatcher(bigint);\n-\n-  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\n-  // the sake of backwards compatibility\n-  let oldStatus = -1;\n-\n-  this._handle.onchange = (newStatus, stats) => {\n-    if (oldStatus === -1 &&\n-        newStatus === -1 &&\n-        stats[2/* new nlink */] === stats[16/* old nlink */]) return;\n-\n-    oldStatus = newStatus;\n-    this.emit('change', getStatsFromBinding(stats),\n-              getStatsFromBinding(stats, kFsStatsFieldsLength));\n-  };\n-\n-  this._handle.onstop = () => {\n-    process.nextTick(emitStop, this);\n-  };\n+  this._handle = null;\n+  this[kOldStatus] = -1;\n+  this[kUseBigint] = bigint;\n }\n util.inherits(StatWatcher, EventEmitter);\n \n+function onchange(newStatus, stats) {\n+  const self = this[kOwner];\n+  if (self[kOldStatus] === -1 &&\n+      newStatus === -1 &&\n+      stats[2/* new nlink */] === stats[16/* old nlink */]) {\n+    return;\n+  }\n+\n+  self[kOldStatus] = newStatus;\n+  self.emit('change', getStatsFromBinding(stats),\n+            getStatsFromBinding(stats, kFsStatsFieldsLength));\n+}\n \n // FIXME(joyeecheung): this method is not documented.\n // At the moment if filename is undefined, we\n@@ -54,16 +55,23 @@ util.inherits(StatWatcher, EventEmitter);\n //    on a valid filename and the wrap has been initialized\n // This method is a noop if the watcher has already been started.\n StatWatcher.prototype.start = function(filename, persistent, interval) {\n-  assert(this._handle instanceof _StatWatcher, 'handle must be a StatWatcher');\n-  if (this._handle.isActive) {\n+  if (this._handle !== null)\n     return;\n-  }\n+\n+  this._handle = new _StatWatcher(this[kUseBigint]);\n+  this._handle[kOwner] = this;\n+  this._handle.onchange = onchange;\n+  if (!persistent)\n+    this._handle.unref();\n+\n+  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\n+  // the sake of backwards compatibility\n+  this[kOldStatus] = -1;\n \n   filename = getPathFromURL(filename);\n   validatePath(filename, 'filename');\n   validateUint32(interval, 'interval');\n-  const err = this._handle.start(toNamespacedPath(filename),\n-                                 persistent, interval);\n+  const err = this._handle.start(toNamespacedPath(filename), interval);\n   if (err) {\n     const error = errors.uvException({\n       errno: err,\n@@ -80,11 +88,15 @@ StatWatcher.prototype.start = function(filename, persistent, interval) {\n // FSWatcher is .close()\n // This method is a noop if the watcher has not been started.\n StatWatcher.prototype.stop = function() {\n-  assert(this._handle instanceof _StatWatcher, 'handle must be a StatWatcher');\n-  if (!this._handle.isActive) {\n+  if (this._handle === null)\n     return;\n-  }\n-  this._handle.stop();\n+\n+  defaultTriggerAsyncIdScope(this._handle.getAsyncId(),\n+                             process.nextTick,\n+                             emitStop,\n+                             this);\n+  this._handle.close();\n+  this._handle = null;\n };\n \n "
        },
        {
            "sha": "d497a0012b03d5f334f26a9c5014deb1aa67baa9",
            "filename": "src/node_stat_watcher.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 87,
            "changes": 108,
            "blob_url": "https://github.com/nodejs/node/blob/7b46e177ba7f0f8349eb5fd73daf57fe847765ff/src%2Fnode_stat_watcher.cc",
            "raw_url": "https://github.com/nodejs/node/raw/7b46e177ba7f0f8349eb5fd73daf57fe847765ff/src%2Fnode_stat_watcher.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_stat_watcher.cc?ref=7b46e177ba7f0f8349eb5fd73daf57fe847765ff",
            "patch": "@@ -31,17 +31,12 @@\n namespace node {\n \n using v8::Context;\n-using v8::DontDelete;\n-using v8::DontEnum;\n using v8::FunctionCallbackInfo;\n using v8::FunctionTemplate;\n using v8::HandleScope;\n using v8::Integer;\n using v8::Local;\n using v8::Object;\n-using v8::PropertyAttribute;\n-using v8::ReadOnly;\n-using v8::Signature;\n using v8::String;\n using v8::Uint32;\n using v8::Value;\n@@ -58,43 +53,32 @@ void StatWatcher::Initialize(Environment* env, Local<Object> target) {\n \n   AsyncWrap::AddWrapMethods(env, t);\n   env->SetProtoMethod(t, \"start\", StatWatcher::Start);\n-  env->SetProtoMethod(t, \"stop\", StatWatcher::Stop);\n-\n-  Local<FunctionTemplate> is_active_templ =\n-      FunctionTemplate::New(env->isolate(),\n-                            IsActive,\n-                            env->as_external(),\n-                            Signature::New(env->isolate(), t));\n-  t->PrototypeTemplate()->SetAccessorProperty(\n-      FIXED_ONE_BYTE_STRING(env->isolate(), \"isActive\"),\n-      is_active_templ,\n-      Local<FunctionTemplate>(),\n-      static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum));\n+  env->SetProtoMethod(t, \"close\", HandleWrap::Close);\n+  env->SetProtoMethod(t, \"ref\", HandleWrap::Ref);\n+  env->SetProtoMethod(t, \"unref\", HandleWrap::Unref);\n+  env->SetProtoMethod(t, \"hasRef\", HandleWrap::HasRef);\n \n   target->Set(statWatcherString, t->GetFunction());\n }\n \n \n-StatWatcher::StatWatcher(Environment* env, Local<Object> wrap, bool use_bigint)\n-    : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_STATWATCHER),\n-      watcher_(nullptr),\n+StatWatcher::StatWatcher(Environment* env,\n+                         Local<Object> wrap,\n+                         bool use_bigint)\n+    : HandleWrap(env,\n+                 wrap,\n+                 reinterpret_cast<uv_handle_t*>(&watcher_),\n+                 AsyncWrap::PROVIDER_STATWATCHER),\n       use_bigint_(use_bigint) {\n-  MakeWeak();\n-}\n-\n-\n-StatWatcher::~StatWatcher() {\n-  if (IsActive())\n-    Stop();\n+  CHECK_EQ(0, uv_fs_poll_init(env->event_loop(), &watcher_));\n }\n \n \n void StatWatcher::Callback(uv_fs_poll_t* handle,\n                            int status,\n                            const uv_stat_t* prev,\n                            const uv_stat_t* curr) {\n-  StatWatcher* wrap = static_cast<StatWatcher*>(handle->data);\n-  CHECK_EQ(wrap->watcher_, handle);\n+  StatWatcher* wrap = ContainerOf(&StatWatcher::watcher_, handle);\n   Environment* env = wrap->env();\n   HandleScope handle_scope(env->isolate());\n   Context::Scope context_scope(env->context());\n@@ -118,78 +102,28 @@ void StatWatcher::New(const FunctionCallbackInfo<Value>& args) {\n   new StatWatcher(env, args.This(), args[0]->IsTrue());\n }\n \n-bool StatWatcher::IsActive() {\n-  return watcher_ != nullptr;\n-}\n-\n-void StatWatcher::IsActive(const v8::FunctionCallbackInfo<v8::Value>& args) {\n-  StatWatcher* wrap = Unwrap<StatWatcher>(args.This());\n-  CHECK_NOT_NULL(wrap);\n-  args.GetReturnValue().Set(wrap->IsActive());\n-}\n-\n-// wrap.start(filename, persistent, interval)\n+// wrap.start(filename, interval)\n void StatWatcher::Start(const FunctionCallbackInfo<Value>& args) {\n-  CHECK_EQ(args.Length(), 3);\n+  CHECK_EQ(args.Length(), 2);\n \n-  StatWatcher* wrap = Unwrap<StatWatcher>(args.Holder());\n-  CHECK_NOT_NULL(wrap);\n-  if (wrap->IsActive()) {\n-    return;\n-  }\n+  StatWatcher* wrap;\n+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());\n+  CHECK(!uv_is_active(wrap->GetHandle()));\n \n   const int argc = args.Length();\n-  CHECK_GE(argc, 3);\n \n   node::Utf8Value path(args.GetIsolate(), args[0]);\n   CHECK_NOT_NULL(*path);\n \n-  bool persistent = true;\n-  if (args[1]->IsFalse()) {\n-    persistent = false;\n-  }\n-\n-  CHECK(args[2]->IsUint32());\n-  const uint32_t interval = args[2].As<Uint32>()->Value();\n-\n-  wrap->watcher_ = new uv_fs_poll_t();\n-  CHECK_EQ(0, uv_fs_poll_init(wrap->env()->event_loop(), wrap->watcher_));\n-  wrap->watcher_->data = static_cast<void*>(wrap);\n-  // Safe, uv_ref/uv_unref are idempotent.\n-  if (persistent)\n-    uv_ref(reinterpret_cast<uv_handle_t*>(wrap->watcher_));\n-  else\n-    uv_unref(reinterpret_cast<uv_handle_t*>(wrap->watcher_));\n+  CHECK(args[1]->IsUint32());\n+  const uint32_t interval = args[1].As<Uint32>()->Value();\n \n   // Note that uv_fs_poll_start does not return ENOENT, we are handling\n   // mostly memory errors here.\n-  const int err = uv_fs_poll_start(wrap->watcher_, Callback, *path, interval);\n+  const int err = uv_fs_poll_start(&wrap->watcher_, Callback, *path, interval);\n   if (err != 0) {\n     args.GetReturnValue().Set(err);\n   }\n-  wrap->ClearWeak();\n }\n \n-\n-void StatWatcher::Stop(const FunctionCallbackInfo<Value>& args) {\n-  StatWatcher* wrap = Unwrap<StatWatcher>(args.Holder());\n-  CHECK_NOT_NULL(wrap);\n-  if (!wrap->IsActive()) {\n-    return;\n-  }\n-\n-  Environment* env = wrap->env();\n-  Context::Scope context_scope(env->context());\n-  wrap->MakeCallback(env->onstop_string(), 0, nullptr);\n-  wrap->Stop();\n-}\n-\n-\n-void StatWatcher::Stop() {\n-  env()->CloseHandle(watcher_, [](uv_fs_poll_t* handle) { delete handle; });\n-  watcher_ = nullptr;\n-  MakeWeak();\n-}\n-\n-\n }  // namespace node"
        },
        {
            "sha": "45150de785f9d1c7d37bce0fdf4a4e4140927228",
            "filename": "src/node_stat_watcher.h",
            "status": "modified",
            "additions": 6,
            "deletions": 10,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/7b46e177ba7f0f8349eb5fd73daf57fe847765ff/src%2Fnode_stat_watcher.h",
            "raw_url": "https://github.com/nodejs/node/raw/7b46e177ba7f0f8349eb5fd73daf57fe847765ff/src%2Fnode_stat_watcher.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_stat_watcher.h?ref=7b46e177ba7f0f8349eb5fd73daf57fe847765ff",
            "patch": "@@ -25,26 +25,24 @@\n #if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n \n #include \"node.h\"\n-#include \"async_wrap.h\"\n+#include \"handle_wrap.h\"\n #include \"env.h\"\n #include \"uv.h\"\n #include \"v8.h\"\n \n namespace node {\n \n-class StatWatcher : public AsyncWrap {\n+class StatWatcher : public HandleWrap {\n  public:\n-  ~StatWatcher() override;\n-\n   static void Initialize(Environment* env, v8::Local<v8::Object> target);\n \n  protected:\n-  StatWatcher(Environment* env, v8::Local<v8::Object> wrap, bool use_bigint);\n+  StatWatcher(Environment* env,\n+              v8::Local<v8::Object> wrap,\n+              bool use_bigint);\n \n   static void New(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void Start(const v8::FunctionCallbackInfo<v8::Value>& args);\n-  static void Stop(const v8::FunctionCallbackInfo<v8::Value>& args);\n-  static void IsActive(const v8::FunctionCallbackInfo<v8::Value>& args);\n \n   size_t self_size() const override { return sizeof(*this); }\n \n@@ -53,10 +51,8 @@ class StatWatcher : public AsyncWrap {\n                        int status,\n                        const uv_stat_t* prev,\n                        const uv_stat_t* curr);\n-  void Stop();\n-  bool IsActive();\n \n-  uv_fs_poll_t* watcher_;\n+  uv_fs_poll_t watcher_;\n   const bool use_bigint_;\n };\n "
        },
        {
            "sha": "9755cc8bb11311f53d345413e80576c10abeaff5",
            "filename": "test/sequential/test-fs-watch.js",
            "status": "modified",
            "additions": 0,
            "deletions": 16,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/7b46e177ba7f0f8349eb5fd73daf57fe847765ff/test%2Fsequential%2Ftest-fs-watch.js",
            "raw_url": "https://github.com/nodejs/node/raw/7b46e177ba7f0f8349eb5fd73daf57fe847765ff/test%2Fsequential%2Ftest-fs-watch.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-fs-watch.js?ref=7b46e177ba7f0f8349eb5fd73daf57fe847765ff",
            "patch": "@@ -126,19 +126,3 @@ tmpdir.refresh();\n   });\n   oldhandle.close(); // clean up\n }\n-\n-{\n-  let oldhandle;\n-  assert.throws(() => {\n-    const w = fs.watchFile(__filename,\n-                           { persistent: false },\n-                           common.mustNotCall());\n-    oldhandle = w._handle;\n-    w._handle = { stop: w._handle.stop };\n-    w.stop();\n-  }, {\n-    message: 'handle must be a StatWatcher',\n-    code: 'ERR_ASSERTION'\n-  });\n-  oldhandle.stop(); // clean up\n-}"
        }
    ],
    "stats": {
        "total": 208,
        "additions": 67,
        "deletions": 141
    }
}