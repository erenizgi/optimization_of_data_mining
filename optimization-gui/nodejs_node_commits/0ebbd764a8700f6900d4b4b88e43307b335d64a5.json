{
    "author": "ofrobots",
    "message": "deps: V8: cherry-pick b49206d from upstream\n\nOriginal commit message:\n  ThreadDataTable: Change global linked list to per-Isolate hash map.\n\n  For use cases with a large number of threads or a large number of\n  isolates (or both), ThreadDataTable can be a major performance\n  bottleneck due to O(n) lookup time of the linked list. Switching to a\n  hash map reduces this to O(1).\n\n  Example 1: Sandstorm.io, a Node.js app that utilizes \"fibers\", was\n  observed spending the majority of CPU time iterating over the\n  ThreadDataTable.\n  See: https://sandstorm.io/news/2016-09-30-fiber-bomb-debugging-story\n\n  Example 2: Cloudflare's Workers engine, a high-multi-tenancy web\n  server framework built on V8 (but not Node), creates large numbers of\n  threads and isolates per-process. It saw a 34x improvement in\n  throughput when we applied this patch.\n\n  Cloudflare has been using a patch in production since the Worker\n  launch which replaces the linked list with a hash map -- but still\n  global.\n\n  This commit builds on that but goes further and creates a separate\n  hash map and mutex for each isolate, with the table being a member of\n  the Isolate class. This avoids any globals and should reduce lock\n  contention.\n\n  Bug: v8:5338\n  Change-Id: If0d11509afb2e043b888c376e36d3463db931b47\n  Reviewed-on: https://chromium-review.googlesource.com/1014407\n  Reviewed-by: Yang Guo <yangguo@chromium.org>\n  Commit-Queue: Yang Guo <yangguo@chromium.org>\n  Cr-Commit-Position: refs/heads/master@{#52753}\n\nPR-URL: https://github.com/nodejs/node/pull/20727\nRef: https://github.com/nodejs/node/issues/20083\n\nRefs: https://github.com/nodejs/node/issues/20083\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "0ebbd764a8700f6900d4b4b88e43307b335d64a5",
    "files": [
        {
            "sha": "d7a730906b537bbeef2593c5f7e407619b06f94e",
            "filename": "common.gypi",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/0ebbd764a8700f6900d4b4b88e43307b335d64a5/common.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/0ebbd764a8700f6900d4b4b88e43307b335d64a5/common.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/common.gypi?ref=0ebbd764a8700f6900d4b4b88e43307b335d64a5",
            "patch": "@@ -27,7 +27,7 @@\n \n     # Reset this number to 0 on major V8 upgrades.\n     # Increment by one for each non-official patch applied to deps/v8.\n-    'v8_embedder_string': '-node.7',\n+    'v8_embedder_string': '-node.8',\n \n     # Enable disassembler for `--print-code` v8 options\n     'v8_enable_disassembler': 1,"
        },
        {
            "sha": "37a5578763d8d15196f38e1d89db55e1c345c898",
            "filename": "deps/v8/src/isolate.cc",
            "status": "modified",
            "additions": 26,
            "deletions": 56,
            "changes": 82,
            "blob_url": "https://github.com/nodejs/node/blob/0ebbd764a8700f6900d4b4b88e43307b335d64a5/deps%2Fv8%2Fsrc%2Fisolate.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0ebbd764a8700f6900d4b4b88e43307b335d64a5/deps%2Fv8%2Fsrc%2Fisolate.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fisolate.cc?ref=0ebbd764a8700f6900d4b4b88e43307b335d64a5",
            "patch": "@@ -8,6 +8,7 @@\n \n #include <fstream>  // NOLINT(readability/streams)\n #include <sstream>\n+#include <unordered_map>\n \n #include \"src/api.h\"\n #include \"src/assembler-inl.h\"\n@@ -136,8 +137,6 @@ void ThreadLocalTop::Free() {\n base::Thread::LocalStorageKey Isolate::isolate_key_;\n base::Thread::LocalStorageKey Isolate::thread_id_key_;\n base::Thread::LocalStorageKey Isolate::per_isolate_thread_data_key_;\n-base::LazyMutex Isolate::thread_data_table_mutex_ = LAZY_MUTEX_INITIALIZER;\n-Isolate::ThreadDataTable* Isolate::thread_data_table_ = nullptr;\n base::Atomic32 Isolate::isolate_counter_ = 0;\n #if DEBUG\n base::Atomic32 Isolate::isolate_key_created_ = 0;\n@@ -148,13 +147,13 @@ Isolate::PerIsolateThreadData*\n   ThreadId thread_id = ThreadId::Current();\n   PerIsolateThreadData* per_thread = nullptr;\n   {\n-    base::LockGuard<base::Mutex> lock_guard(thread_data_table_mutex_.Pointer());\n-    per_thread = thread_data_table_->Lookup(this, thread_id);\n+    base::LockGuard<base::Mutex> lock_guard(&thread_data_table_mutex_);\n+    per_thread = thread_data_table_.Lookup(thread_id);\n     if (per_thread == nullptr) {\n       per_thread = new PerIsolateThreadData(this, thread_id);\n-      thread_data_table_->Insert(per_thread);\n+      thread_data_table_.Insert(per_thread);\n     }\n-    DCHECK(thread_data_table_->Lookup(this, thread_id) == per_thread);\n+    DCHECK(thread_data_table_.Lookup(thread_id) == per_thread);\n   }\n   return per_thread;\n }\n@@ -165,12 +164,11 @@ void Isolate::DiscardPerThreadDataForThisThread() {\n   if (thread_id_int) {\n     ThreadId thread_id = ThreadId(thread_id_int);\n     DCHECK(!thread_manager_->mutex_owner_.Equals(thread_id));\n-    base::LockGuard<base::Mutex> lock_guard(thread_data_table_mutex_.Pointer());\n-    PerIsolateThreadData* per_thread =\n-        thread_data_table_->Lookup(this, thread_id);\n+    base::LockGuard<base::Mutex> lock_guard(&thread_data_table_mutex_);\n+    PerIsolateThreadData* per_thread = thread_data_table_.Lookup(thread_id);\n     if (per_thread) {\n       DCHECK(!per_thread->thread_state_);\n-      thread_data_table_->Remove(per_thread);\n+      thread_data_table_.Remove(per_thread);\n     }\n   }\n }\n@@ -186,23 +184,20 @@ Isolate::PerIsolateThreadData* Isolate::FindPerThreadDataForThread(\n     ThreadId thread_id) {\n   PerIsolateThreadData* per_thread = nullptr;\n   {\n-    base::LockGuard<base::Mutex> lock_guard(thread_data_table_mutex_.Pointer());\n-    per_thread = thread_data_table_->Lookup(this, thread_id);\n+    base::LockGuard<base::Mutex> lock_guard(&thread_data_table_mutex_);\n+    per_thread = thread_data_table_.Lookup(thread_id);\n   }\n   return per_thread;\n }\n \n \n void Isolate::InitializeOncePerProcess() {\n-  base::LockGuard<base::Mutex> lock_guard(thread_data_table_mutex_.Pointer());\n-  CHECK_NULL(thread_data_table_);\n   isolate_key_ = base::Thread::CreateThreadLocalKey();\n #if DEBUG\n   base::Relaxed_Store(&isolate_key_created_, 1);\n #endif\n   thread_id_key_ = base::Thread::CreateThreadLocalKey();\n   per_isolate_thread_data_key_ = base::Thread::CreateThreadLocalKey();\n-  thread_data_table_ = new Isolate::ThreadDataTable();\n }\n \n Address Isolate::get_address_from_id(IsolateAddressId id) {\n@@ -2240,14 +2235,9 @@ char* Isolate::RestoreThread(char* from) {\n   return from + sizeof(ThreadLocalTop);\n }\n \n-Isolate::ThreadDataTable::ThreadDataTable() : list_(nullptr) {}\n+Isolate::ThreadDataTable::ThreadDataTable() : table_() {}\n \n-Isolate::ThreadDataTable::~ThreadDataTable() {\n-  // TODO(svenpanne) The assertion below would fire if an embedder does not\n-  // cleanly dispose all Isolates before disposing v8, so we are conservative\n-  // and leave it out for now.\n-  // DCHECK_NULL(list_);\n-}\n+Isolate::ThreadDataTable::~ThreadDataTable() {}\n \n void Isolate::ReleaseManagedObjects() {\n   Isolate::ManagedObjectFinalizer* current =\n@@ -2294,40 +2284,30 @@ Isolate::PerIsolateThreadData::~PerIsolateThreadData() {\n #endif\n }\n \n-\n-Isolate::PerIsolateThreadData*\n-    Isolate::ThreadDataTable::Lookup(Isolate* isolate,\n-                                     ThreadId thread_id) {\n-  for (PerIsolateThreadData* data = list_; data != nullptr;\n-       data = data->next_) {\n-    if (data->Matches(isolate, thread_id)) return data;\n-  }\n-  return nullptr;\n+Isolate::PerIsolateThreadData* Isolate::ThreadDataTable::Lookup(\n+    ThreadId thread_id) {\n+  auto t = table_.find(thread_id);\n+  if (t == table_.end()) return nullptr;\n+  return t->second;\n }\n \n \n void Isolate::ThreadDataTable::Insert(Isolate::PerIsolateThreadData* data) {\n-  if (list_ != nullptr) list_->prev_ = data;\n-  data->next_ = list_;\n-  list_ = data;\n+  bool inserted = table_.insert(std::make_pair(data->thread_id_, data)).second;\n+  CHECK(inserted);\n }\n \n \n void Isolate::ThreadDataTable::Remove(PerIsolateThreadData* data) {\n-  if (list_ == data) list_ = data->next_;\n-  if (data->next_ != nullptr) data->next_->prev_ = data->prev_;\n-  if (data->prev_ != nullptr) data->prev_->next_ = data->next_;\n+  table_.erase(data->thread_id_);\n   delete data;\n }\n \n-\n-void Isolate::ThreadDataTable::RemoveAllThreads(Isolate* isolate) {\n-  PerIsolateThreadData* data = list_;\n-  while (data != nullptr) {\n-    PerIsolateThreadData* next = data->next_;\n-    if (data->isolate() == isolate) Remove(data);\n-    data = next;\n+void Isolate::ThreadDataTable::RemoveAllThreads() {\n+  for (auto& x : table_) {\n+    delete x.second;\n   }\n+  table_.clear();\n }\n \n \n@@ -2502,10 +2482,6 @@ Isolate::Isolate(bool enable_serializer)\n       cancelable_task_manager_(new CancelableTaskManager()),\n       abort_on_uncaught_exception_callback_(nullptr),\n       total_regexp_code_generated_(0) {\n-  {\n-    base::LockGuard<base::Mutex> lock_guard(thread_data_table_mutex_.Pointer());\n-    CHECK(thread_data_table_);\n-  }\n   id_ = base::Relaxed_AtomicIncrement(&isolate_counter_, 1);\n   TRACE_ISOLATE(constructor);\n \n@@ -2563,8 +2539,8 @@ void Isolate::TearDown() {\n   Deinit();\n \n   {\n-    base::LockGuard<base::Mutex> lock_guard(thread_data_table_mutex_.Pointer());\n-    thread_data_table_->RemoveAllThreads(this);\n+    base::LockGuard<base::Mutex> lock_guard(&thread_data_table_mutex_);\n+    thread_data_table_.RemoveAllThreads();\n   }\n \n #ifdef DEBUG\n@@ -2578,12 +2554,6 @@ void Isolate::TearDown() {\n }\n \n \n-void Isolate::GlobalTearDown() {\n-  delete thread_data_table_;\n-  thread_data_table_ = nullptr;\n-}\n-\n-\n void Isolate::ClearSerializerData() {\n   delete external_reference_table_;\n   external_reference_table_ = nullptr;"
        },
        {
            "sha": "40135ef3248906251692623341189c496c64f587",
            "filename": "deps/v8/src/isolate.h",
            "status": "modified",
            "additions": 17,
            "deletions": 10,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/0ebbd764a8700f6900d4b4b88e43307b335d64a5/deps%2Fv8%2Fsrc%2Fisolate.h",
            "raw_url": "https://github.com/nodejs/node/raw/0ebbd764a8700f6900d4b4b88e43307b335d64a5/deps%2Fv8%2Fsrc%2Fisolate.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fisolate.h?ref=0ebbd764a8700f6900d4b4b88e43307b335d64a5",
            "patch": "@@ -8,6 +8,7 @@\n #include <cstddef>\n #include <memory>\n #include <queue>\n+#include <unordered_map>\n #include <vector>\n \n #include \"include/v8.h\"\n@@ -247,6 +248,8 @@ class ThreadId {\n     return *this;\n   }\n \n+  bool operator==(const ThreadId& other) const { return Equals(other); }\n+\n   // Returns ThreadId for current thread.\n   static ThreadId Current() { return ThreadId(GetCurrentThreadId()); }\n \n@@ -287,7 +290,6 @@ class ThreadId {\n   friend class Isolate;\n };\n \n-\n #define FIELD_ACCESSOR(type, name)                 \\\n   inline void set_##name(type v) { name##_ = v; }  \\\n   inline type name() const { return name##_; }\n@@ -550,8 +552,6 @@ class Isolate {\n \n   void ReleaseManagedObjects();\n \n-  static void GlobalTearDown();\n-\n   void ClearSerializerData();\n \n   // Find the PerThread for this particular (isolate, thread) combination\n@@ -1371,20 +1371,24 @@ class Isolate {\n   void* embedder_data_[Internals::kNumIsolateDataSlots];\n   Heap heap_;\n \n-  // The per-process lock should be acquired before the ThreadDataTable is\n-  // modified.\n   class ThreadDataTable {\n    public:\n     ThreadDataTable();\n     ~ThreadDataTable();\n \n-    PerIsolateThreadData* Lookup(Isolate* isolate, ThreadId thread_id);\n+    PerIsolateThreadData* Lookup(ThreadId thread_id);\n     void Insert(PerIsolateThreadData* data);\n     void Remove(PerIsolateThreadData* data);\n-    void RemoveAllThreads(Isolate* isolate);\n+    void RemoveAllThreads();\n \n    private:\n-    PerIsolateThreadData* list_;\n+    struct Hasher {\n+      std::size_t operator()(const ThreadId& t) const {\n+        return std::hash<int>()(t.ToInteger());\n+      }\n+    };\n+\n+    std::unordered_map<ThreadId, PerIsolateThreadData*, Hasher> table_;\n   };\n \n   // These items form a stack synchronously with threads Enter'ing and Exit'ing\n@@ -1412,12 +1416,15 @@ class Isolate {\n     DISALLOW_COPY_AND_ASSIGN(EntryStackItem);\n   };\n \n-  static base::LazyMutex thread_data_table_mutex_;\n+  // TODO(kenton@cloudflare.com): This mutex can be removed if\n+  // thread_data_table_ is always accessed under the isolate lock. I do not\n+  // know if this is the case, so I'm preserving it for now.\n+  base::Mutex thread_data_table_mutex_;\n \n   static base::Thread::LocalStorageKey per_isolate_thread_data_key_;\n   static base::Thread::LocalStorageKey isolate_key_;\n   static base::Thread::LocalStorageKey thread_id_key_;\n-  static ThreadDataTable* thread_data_table_;\n+  ThreadDataTable thread_data_table_;\n \n   // A global counter for all generated Isolates, might overflow.\n   static base::Atomic32 isolate_counter_;"
        },
        {
            "sha": "d3b4c471a4f8a4b8e617726cc6eb3788347da0f7",
            "filename": "deps/v8/src/v8.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/0ebbd764a8700f6900d4b4b88e43307b335d64a5/deps%2Fv8%2Fsrc%2Fv8.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0ebbd764a8700f6900d4b4b88e43307b335d64a5/deps%2Fv8%2Fsrc%2Fv8.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fv8.cc?ref=0ebbd764a8700f6900d4b4b88e43307b335d64a5",
            "patch": "@@ -49,7 +49,6 @@ void V8::TearDown() {\n   Bootstrapper::TearDownExtensions();\n   ElementsAccessor::TearDown();\n   RegisteredExtension::UnregisterAll();\n-  Isolate::GlobalTearDown();\n   sampler::Sampler::TearDown();\n   FlagList::ResetAllFlags();  // Frees memory held by string arguments.\n }"
        }
    ],
    "stats": {
        "total": 112,
        "additions": 44,
        "deletions": 68
    }
}