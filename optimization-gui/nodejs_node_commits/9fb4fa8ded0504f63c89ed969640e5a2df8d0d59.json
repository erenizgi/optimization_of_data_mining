{
    "author": "BridgeAR",
    "message": "assert,util: harden comparison\n\nThe former algorithm used checks which were unsafe. Most of these\nhave been replaced with alternatives that can not be manipulated or\nfooled that easily.\n\nPR-URL: https://github.com/nodejs/node/pull/24831\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>",
    "sha": "9fb4fa8ded0504f63c89ed969640e5a2df8d0d59",
    "files": [
        {
            "sha": "1d959f843bcbd398c5446762b0d36696824144ae",
            "filename": "lib/internal/util/comparisons.js",
            "status": "modified",
            "additions": 38,
            "deletions": 13,
            "changes": 51,
            "blob_url": "https://github.com/nodejs/node/blob/9fb4fa8ded0504f63c89ed969640e5a2df8d0d59/lib%2Finternal%2Futil%2Fcomparisons.js",
            "raw_url": "https://github.com/nodejs/node/raw/9fb4fa8ded0504f63c89ed969640e5a2df8d0d59/lib%2Finternal%2Futil%2Fcomparisons.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Futil%2Fcomparisons.js?ref=9fb4fa8ded0504f63c89ed969640e5a2df8d0d59",
            "patch": "@@ -7,7 +7,14 @@ const {\n   isDate,\n   isMap,\n   isRegExp,\n-  isSet\n+  isSet,\n+  isNativeError,\n+  isBoxedPrimitive,\n+  isNumberObject,\n+  isStringObject,\n+  isBooleanObject,\n+  isBigIntObject,\n+  isSymbolObject\n } = internalBinding('types');\n const {\n   getOwnNonIndexProperties,\n@@ -33,6 +40,13 @@ const kIsMap = 3;\n const objectToString = uncurryThis(Object.prototype.toString);\n const hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n const propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);\n+const dateGetTime = uncurryThis(Date.prototype.getTime);\n+\n+const bigIntValueOf = uncurryThis(BigInt.prototype.valueOf);\n+const booleanValueOf = uncurryThis(Boolean.prototype.valueOf);\n+const numberValueOf = uncurryThis(Number.prototype.valueOf);\n+const symbolValueOf = uncurryThis(Symbol.prototype.valueOf);\n+const stringValueOf = uncurryThis(String.prototype.valueOf);\n \n const objectKeys = Object.keys;\n const getPrototypeOf = Object.getPrototypeOf;\n@@ -82,6 +96,24 @@ function isObjectOrArrayTag(tag) {\n   return tag === '[object Array]' || tag === '[object Object]';\n }\n \n+function isEqualBoxedPrimitive(val1, val2) {\n+  if (isNumberObject(val1)) {\n+    return isNumberObject(val2) &&\n+           objectIs(numberValueOf(val1), numberValueOf(val2));\n+  }\n+  if (isStringObject(val1)) {\n+    return isStringObject(val2) && stringValueOf(val1) === stringValueOf(val2);\n+  }\n+  if (isBooleanObject(val1)) {\n+    return isBooleanObject(val2) &&\n+           booleanValueOf(val1) === booleanValueOf(val2);\n+  }\n+  if (isBigIntObject(val1)) {\n+    return isBigIntObject(val2) && bigIntValueOf(val1) === bigIntValueOf(val2);\n+  }\n+  return isSymbolObject(val2) && symbolValueOf(val1) === symbolValueOf(val2);\n+}\n+\n // Notes: Type tags are historical [[Class]] properties that can be set by\n // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS\n // and retrieved using Object.prototype.toString.call(obj) in JS\n@@ -117,7 +149,7 @@ function strictDeepEqual(val1, val2, memos) {\n   if (getPrototypeOf(val1) !== getPrototypeOf(val2)) {\n     return false;\n   }\n-  if (val1Tag === '[object Array]') {\n+  if (Array.isArray(val1)) {\n     // Check for sparse arrays and general fast path\n     if (val1.length !== val2.length) {\n       return false;\n@@ -133,15 +165,14 @@ function strictDeepEqual(val1, val2, memos) {\n     return keyCheck(val1, val2, kStrict, memos, kNoIterator);\n   }\n   if (isDate(val1)) {\n-    // TODO: Make these safe.\n-    if (val1.getTime() !== val2.getTime()) {\n+    if (dateGetTime(val1) !== dateGetTime(val2)) {\n       return false;\n     }\n   } else if (isRegExp(val1)) {\n     if (!areSimilarRegExps(val1, val2)) {\n       return false;\n     }\n-  } else if (val1Tag === '[object Error]') {\n+  } else if (isNativeError(val1) || val1 instanceof Error) {\n     // Do not compare the stack as it might differ even though the error itself\n     // is otherwise identical. The non-enumerable name should be identical as\n     // the prototype is also identical. Otherwise this is caught later on.\n@@ -175,14 +206,8 @@ function strictDeepEqual(val1, val2, memos) {\n     if (!areEqualArrayBuffers(val1, val2)) {\n       return false;\n     }\n-  // TODO: Make the valueOf checks safe.\n-  } else if (typeof val1.valueOf === 'function') {\n-    const val1Value = val1.valueOf();\n-    if (val1Value !== val1 &&\n-        (typeof val2.valueOf !== 'function' ||\n-          !innerDeepEqual(val1Value, val2.valueOf(), kStrict))) {\n-      return false;\n-    }\n+  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {\n+    return false;\n   }\n   return keyCheck(val1, val2, kStrict, memos, kNoIterator);\n }"
        },
        {
            "sha": "c1e8c2f246663b3f7184635f3b27bab09f5d99ae",
            "filename": "test/parallel/test-assert-deep.js",
            "status": "modified",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/nodejs/node/blob/9fb4fa8ded0504f63c89ed969640e5a2df8d0d59/test%2Fparallel%2Ftest-assert-deep.js",
            "raw_url": "https://github.com/nodejs/node/raw/9fb4fa8ded0504f63c89ed969640e5a2df8d0d59/test%2Fparallel%2Ftest-assert-deep.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-assert-deep.js?ref=9fb4fa8ded0504f63c89ed969640e5a2df8d0d59",
            "patch": "@@ -985,3 +985,67 @@ assert.throws(\n             '  ]'\n   }\n );\n+\n+// Verify that manipulating the `getTime()` function has no impact on the time\n+// verification.\n+{\n+  const a = new Date('2000');\n+  const b = new Date('2000');\n+  Object.defineProperty(a, 'getTime', {\n+    value: () => 5\n+  });\n+  assert.deepStrictEqual(a, b);\n+}\n+\n+// Verify that extra keys will be tested for when using fake arrays.\n+{\n+  const a = {\n+    0: 1,\n+    1: 1,\n+    2: 'broken'\n+  };\n+  Object.setPrototypeOf(a, Object.getPrototypeOf([]));\n+  Object.defineProperty(a, Symbol.toStringTag, {\n+    value: 'Array',\n+  });\n+  Object.defineProperty(a, 'length', {\n+    value: 2\n+  });\n+  assert.notDeepStrictEqual(a, [1, 1]);\n+}\n+\n+// Verify that changed tags will still check for the error message.\n+{\n+  const err = new Error('foo');\n+  err[Symbol.toStringTag] = 'Foobar';\n+  const err2 = new Error('bar');\n+  err2[Symbol.toStringTag] = 'Foobar';\n+  assertNotDeepOrStrict(err, err2, AssertionError);\n+}\n+\n+// Check for non-native errors.\n+{\n+  const source = new Error('abc');\n+  const err = Object.create(\n+    Object.getPrototypeOf(source), Object.getOwnPropertyDescriptors(source));\n+  Object.defineProperty(err, 'message', { value: 'foo' });\n+  const err2 = Object.create(\n+    Object.getPrototypeOf(source), Object.getOwnPropertyDescriptors(source));\n+  Object.defineProperty(err2, 'message', { value: 'bar' });\n+  err[Symbol.toStringTag] = 'Foo';\n+  err2[Symbol.toStringTag] = 'Foo';\n+  assert.notDeepStrictEqual(err, err2);\n+}\n+\n+// Verify that `valueOf` is not called for boxed primitives.\n+{\n+  const a = new Number(5);\n+  const b = new Number(5);\n+  Object.defineProperty(a, 'valueOf', {\n+    value: () => { throw new Error('failed'); }\n+  });\n+  Object.defineProperty(b, 'valueOf', {\n+    value: () => { throw new Error('failed'); }\n+  });\n+  assertDeepAndStrictEqual(a, b);\n+}"
        }
    ],
    "stats": {
        "total": 115,
        "additions": 102,
        "deletions": 13
    }
}