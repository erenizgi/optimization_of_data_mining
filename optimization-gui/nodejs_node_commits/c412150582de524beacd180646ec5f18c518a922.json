{
    "author": "addaleax",
    "message": "src: make `FileHandle` a (readonly) `StreamBase`\n\nThis enables accessing files using a more standard pattern.\n\nOnce some more refactoring has been performed on the other existing\n`StreamBase` streams, this could also be used to implement `fs`\nstreams in a more standard manner.\n\nPR-URL: https://github.com/nodejs/node/pull/18936\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "c412150582de524beacd180646ec5f18c518a922",
    "files": [
        {
            "sha": "05c7a90c52fee7141d6ac9cd5b420dac06e53cf4",
            "filename": "src/env-inl.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/c412150582de524beacd180646ec5f18c518a922/src%2Fenv-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/c412150582de524beacd180646ec5f18c518a922/src%2Fenv-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv-inl.h?ref=c412150582de524beacd180646ec5f18c518a922",
            "patch": "@@ -484,6 +484,11 @@ Environment::fs_stats_field_array() {\n   return &fs_stats_field_array_;\n }\n \n+inline std::vector<std::unique_ptr<fs::FileHandleReadWrap>>&\n+Environment::file_handle_read_wrap_freelist() {\n+  return file_handle_read_wrap_freelist_;\n+}\n+\n void Environment::CreateImmediate(native_immediate_callback cb,\n                                void* data,\n                                v8::Local<v8::Object> obj,"
        },
        {
            "sha": "d361262e22ba0951a0c336f89f788ab91e15177f",
            "filename": "src/env.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/c412150582de524beacd180646ec5f18c518a922/src%2Fenv.cc",
            "raw_url": "https://github.com/nodejs/node/raw/c412150582de524beacd180646ec5f18c518a922/src%2Fenv.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.cc?ref=c412150582de524beacd180646ec5f18c518a922",
            "patch": "@@ -2,6 +2,7 @@\n #include \"async_wrap.h\"\n #include \"node_buffer.h\"\n #include \"node_platform.h\"\n+#include \"node_file.h\"\n \n #include <stdio.h>\n #include <algorithm>"
        },
        {
            "sha": "e0f6856f8d0b1d974ed2883d7ccc67ae69c868e2",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/c412150582de524beacd180646ec5f18c518a922/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/c412150582de524beacd180646ec5f18c518a922/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=c412150582de524beacd180646ec5f18c518a922",
            "patch": "@@ -48,6 +48,10 @@ struct nghttp2_rcbuf;\n \n namespace node {\n \n+namespace fs {\n+class FileHandleReadWrap;\n+}\n+\n namespace performance {\n class performance_state;\n }\n@@ -297,6 +301,7 @@ struct PackageConfig {\n   V(context, v8::Context)                                                     \\\n   V(domain_callback, v8::Function)                                            \\\n   V(fd_constructor_template, v8::ObjectTemplate)                              \\\n+  V(filehandlereadwrap_template, v8::ObjectTemplate)                          \\\n   V(fsreqpromise_constructor_template, v8::ObjectTemplate)                    \\\n   V(fdclose_constructor_template, v8::ObjectTemplate)                         \\\n   V(host_import_module_dynamically_callback, v8::Function)                    \\\n@@ -642,6 +647,9 @@ class Environment {\n \n   inline AliasedBuffer<double, v8::Float64Array>* fs_stats_field_array();\n \n+  inline std::vector<std::unique_ptr<fs::FileHandleReadWrap>>&\n+      file_handle_read_wrap_freelist();\n+\n   inline performance::performance_state* performance_state();\n   inline std::map<std::string, uint64_t>* performance_marks();\n \n@@ -822,6 +830,9 @@ class Environment {\n   static const int kFsStatsFieldsLength = 2 * 14;\n   AliasedBuffer<double, v8::Float64Array> fs_stats_field_array_;\n \n+  std::vector<std::unique_ptr<fs::FileHandleReadWrap>>\n+      file_handle_read_wrap_freelist_;\n+\n   struct ExitCallback {\n     void (*cb_)(void* arg);\n     void* arg_;"
        },
        {
            "sha": "36bb326aa51517036328be1677c0db0beec8772e",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 193,
            "deletions": 9,
            "changes": 202,
            "blob_url": "https://github.com/nodejs/node/blob/c412150582de524beacd180646ec5f18c518a922/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/c412150582de524beacd180646ec5f18c518a922/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=c412150582de524beacd180646ec5f18c518a922",
            "patch": "@@ -26,6 +26,7 @@\n #include \"node_file.h\"\n \n #include \"req_wrap-inl.h\"\n+#include \"stream_base-inl.h\"\n #include \"string_bytes.h\"\n #include \"string_search.h\"\n \n@@ -41,7 +42,6 @@\n #endif\n \n #include <memory>\n-#include <vector>\n \n namespace node {\n \n@@ -115,11 +115,13 @@ using v8::Value;\n // The FileHandle object wraps a file descriptor and will close it on garbage\n // collection if necessary. If that happens, a process warning will be\n // emitted (or a fatal exception will occur if the fd cannot be closed.)\n-FileHandle::FileHandle(Environment* env, int fd)\n+FileHandle::FileHandle(Environment* env, int fd, Local<Object> obj)\n     : AsyncWrap(env,\n-                env->fd_constructor_template()\n-                    ->NewInstance(env->context()).ToLocalChecked(),\n-                AsyncWrap::PROVIDER_FILEHANDLE), fd_(fd) {\n+                obj.IsEmpty() ? env->fd_constructor_template()\n+                    ->NewInstance(env->context()).ToLocalChecked() : obj,\n+                AsyncWrap::PROVIDER_FILEHANDLE),\n+      StreamBase(env),\n+      fd_(fd) {\n   MakeWeak<FileHandle>(this);\n   v8::PropertyAttribute attr =\n       static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete);\n@@ -129,6 +131,19 @@ FileHandle::FileHandle(Environment* env, int fd)\n                               attr).FromJust();\n }\n \n+void FileHandle::New(const v8::FunctionCallbackInfo<v8::Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+  CHECK(args.IsConstructCall());\n+  CHECK(args[0]->IsInt32());\n+\n+  FileHandle* handle =\n+      new FileHandle(env, args[0].As<v8::Int32>()->Value(), args.This());\n+  if (args[1]->IsNumber())\n+    handle->read_offset_ = args[1]->IntegerValue(env->context()).FromJust();\n+  if (args[2]->IsNumber())\n+    handle->read_length_ = args[2]->IntegerValue(env->context()).FromJust();\n+}\n+\n FileHandle::~FileHandle() {\n   CHECK(!closing_);  // We should not be deleting while explicitly closing!\n   Close();           // Close synchronously and emit warning\n@@ -142,10 +157,10 @@ FileHandle::~FileHandle() {\n // will crash the process immediately.\n inline void FileHandle::Close() {\n   if (closed_) return;\n-  closed_ = true;\n   uv_fs_t req;\n   int ret = uv_fs_close(env()->event_loop(), &req, fd_, nullptr);\n   uv_fs_req_cleanup(&req);\n+  AfterClose();\n \n   struct err_detail { int ret; int fd; };\n \n@@ -219,18 +234,18 @@ inline MaybeLocal<Promise> FileHandle::ClosePromise() {\n   CHECK(!maybe_resolver.IsEmpty());\n   Local<Promise::Resolver> resolver = maybe_resolver.ToLocalChecked();\n   Local<Promise> promise = resolver.As<Promise>();\n+  CHECK(!reading_);\n   if (!closed_ && !closing_) {\n     closing_ = true;\n     CloseReq* req = new CloseReq(env(), promise, object());\n     auto AfterClose = [](uv_fs_t* req) {\n       CloseReq* close = static_cast<CloseReq*>(req->data);\n       CHECK_NE(close, nullptr);\n-      close->file_handle()->closing_ = false;\n+      close->file_handle()->AfterClose();\n       Isolate* isolate = close->env()->isolate();\n       if (req->result < 0) {\n         close->Reject(UVException(isolate, req->result, \"close\"));\n       } else {\n-        close->file_handle()->closed_ = true;\n         close->Resolve();\n       }\n       delete close;\n@@ -256,6 +271,162 @@ void FileHandle::Close(const FunctionCallbackInfo<Value>& args) {\n }\n \n \n+void FileHandle::ReleaseFD(const FunctionCallbackInfo<Value>& args) {\n+  FileHandle* fd;\n+  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());\n+  // Just act as if this FileHandle has been closed.\n+  fd->AfterClose();\n+}\n+\n+\n+void FileHandle::AfterClose() {\n+  closing_ = false;\n+  closed_ = true;\n+  if (reading_ && !persistent().IsEmpty())\n+    EmitRead(UV_EOF);\n+}\n+\n+\n+FileHandleReadWrap::FileHandleReadWrap(FileHandle* handle, Local<Object> obj)\n+  : ReqWrap(handle->env(), obj, AsyncWrap::PROVIDER_FSREQWRAP),\n+    file_handle_(handle) {}\n+\n+int FileHandle::ReadStart() {\n+  if (!IsAlive() || IsClosing())\n+    return UV_EOF;\n+\n+  reading_ = true;\n+\n+  if (current_read_)\n+    return 0;\n+\n+  std::unique_ptr<FileHandleReadWrap> read_wrap;\n+\n+  if (read_length_ == 0) {\n+    EmitRead(UV_EOF);\n+    return 0;\n+  }\n+\n+  {\n+    // Create a new FileHandleReadWrap or re-use one.\n+    // Either way, we need these two scopes for AsyncReset() or otherwise\n+    // for creating the new instance.\n+    HandleScope handle_scope(env()->isolate());\n+    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);\n+\n+    auto& freelist = env()->file_handle_read_wrap_freelist();\n+    if (freelist.size() > 0) {\n+      read_wrap = std::move(freelist.back());\n+      freelist.pop_back();\n+      read_wrap->AsyncReset();\n+      read_wrap->file_handle_ = this;\n+    } else {\n+      Local<Object> wrap_obj = env()->filehandlereadwrap_template()\n+          ->NewInstance(env()->context()).ToLocalChecked();\n+      read_wrap.reset(new FileHandleReadWrap(this, wrap_obj));\n+    }\n+  }\n+  int64_t recommended_read = 65536;\n+  if (read_length_ >= 0 && read_length_ <= recommended_read)\n+    recommended_read = read_length_;\n+\n+  read_wrap->buffer_ = EmitAlloc(recommended_read);\n+  read_wrap->Dispatched();\n+\n+  current_read_ = std::move(read_wrap);\n+\n+  uv_fs_read(env()->event_loop(),\n+             current_read_->req(),\n+             fd_,\n+             &current_read_->buffer_,\n+             1,\n+             read_offset_,\n+             [](uv_fs_t* req) {\n+    FileHandle* handle;\n+    {\n+      FileHandleReadWrap* req_wrap = FileHandleReadWrap::from_req(req);\n+      handle = req_wrap->file_handle_;\n+      CHECK_EQ(handle->current_read_.get(), req_wrap);\n+    }\n+\n+    // ReadStart() checks whether current_read_ is set to determine whether\n+    // a read is in progress. Moving it into a local variable makes sure that\n+    // the ReadStart() call below doesn’t think we’re still actively reading.\n+    std::unique_ptr<FileHandleReadWrap> read_wrap =\n+        std::move(handle->current_read_);\n+\n+    int result = req->result;\n+    uv_buf_t buffer = read_wrap->buffer_;\n+\n+    uv_fs_req_cleanup(req);\n+\n+    // Push the read wrap back to the freelist, or let it be destroyed\n+    // once we’re exiting the current scope.\n+    constexpr size_t wanted_freelist_fill = 100;\n+    auto& freelist = handle->env()->file_handle_read_wrap_freelist();\n+    if (freelist.size() < wanted_freelist_fill)\n+      freelist.emplace_back(std::move(read_wrap));\n+\n+    if (result >= 0) {\n+      // Read at most as many bytes as we originally planned to.\n+      if (handle->read_length_ >= 0 && handle->read_length_ < result)\n+        result = handle->read_length_;\n+\n+      // If we read data and we have an expected length, decrease it by\n+      // how much we have read.\n+      if (handle->read_length_ >= 0)\n+        handle->read_length_ -= result;\n+\n+      // If we have an offset, increase it by how much we have read.\n+      if (handle->read_offset_ >= 0)\n+        handle->read_offset_ += result;\n+    }\n+\n+    // Reading 0 bytes from a file always means EOF, or that we reached\n+    // the end of the requested range.\n+    if (result == 0)\n+      result = UV_EOF;\n+\n+    handle->EmitRead(result, buffer);\n+\n+    // Start over, if EmitRead() didn’t tell us to stop.\n+    if (handle->reading_)\n+      handle->ReadStart();\n+  });\n+\n+  return 0;\n+}\n+\n+int FileHandle::ReadStop() {\n+  reading_ = false;\n+  return 0;\n+}\n+\n+typedef SimpleShutdownWrap<ReqWrap<uv_fs_t>> FileHandleCloseWrap;\n+\n+ShutdownWrap* FileHandle::CreateShutdownWrap(Local<Object> object) {\n+  return new FileHandleCloseWrap(this, object);\n+}\n+\n+int FileHandle::DoShutdown(ShutdownWrap* req_wrap) {\n+  FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(req_wrap);\n+  closing_ = true;\n+  wrap->Dispatched();\n+  uv_fs_close(env()->event_loop(), wrap->req(), fd_, [](uv_fs_t* req) {\n+    FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(\n+        FileHandleCloseWrap::from_req(req));\n+    FileHandle* handle = static_cast<FileHandle*>(wrap->stream());\n+    handle->AfterClose();\n+\n+    int result = req->result;\n+    uv_fs_req_cleanup(req);\n+    wrap->Done(result);\n+  });\n+\n+  return 0;\n+}\n+\n+\n void FSReqWrap::Reject(Local<Value> reject) {\n   MakeCallback(env()->oncomplete_string(), 1, &reject);\n }\n@@ -1730,6 +1901,17 @@ void InitFs(Local<Object> target,\n   fst->SetClassName(wrapString);\n   target->Set(context, wrapString, fst->GetFunction()).FromJust();\n \n+  // Create FunctionTemplate for FileHandleReadWrap. There’s no need\n+  // to do anything in the constructor, so we only store the instance template.\n+  Local<FunctionTemplate> fh_rw = FunctionTemplate::New(env->isolate());\n+  fh_rw->InstanceTemplate()->SetInternalFieldCount(1);\n+  AsyncWrap::AddWrapMethods(env, fh_rw);\n+  Local<String> fhWrapString =\n+      FIXED_ONE_BYTE_STRING(env->isolate(), \"FileHandleReqWrap\");\n+  fh_rw->SetClassName(fhWrapString);\n+  env->set_filehandlereadwrap_template(\n+      fst->InstanceTemplate());\n+\n   // Create Function Template for FSReqPromise\n   Local<FunctionTemplate> fpt = FunctionTemplate::New(env->isolate());\n   AsyncWrap::AddWrapMethods(env, fpt);\n@@ -1741,14 +1923,16 @@ void InitFs(Local<Object> target,\n   env->set_fsreqpromise_constructor_template(fpo);\n \n   // Create FunctionTemplate for FileHandle\n-  Local<FunctionTemplate> fd = FunctionTemplate::New(env->isolate());\n+  Local<FunctionTemplate> fd = env->NewFunctionTemplate(FileHandle::New);\n   AsyncWrap::AddWrapMethods(env, fd);\n   env->SetProtoMethod(fd, \"close\", FileHandle::Close);\n+  env->SetProtoMethod(fd, \"releaseFD\", FileHandle::ReleaseFD);\n   Local<ObjectTemplate> fdt = fd->InstanceTemplate();\n   fdt->SetInternalFieldCount(1);\n   Local<String> handleString =\n        FIXED_ONE_BYTE_STRING(env->isolate(), \"FileHandle\");\n   fd->SetClassName(handleString);\n+  StreamBase::AddMethods<FileHandle>(env, fd, StreamBase::kFlagNone);\n   target->Set(context, handleString, fd->GetFunction()).FromJust();\n   env->set_fd_constructor_template(fdt);\n "
        },
        {
            "sha": "fa373d46ad00030767c1a675a3222486d5e0908e",
            "filename": "src/node_file.h",
            "status": "modified",
            "additions": 59,
            "deletions": 3,
            "changes": 62,
            "blob_url": "https://github.com/nodejs/node/blob/c412150582de524beacd180646ec5f18c518a922/src%2Fnode_file.h",
            "raw_url": "https://github.com/nodejs/node/raw/c412150582de524beacd180646ec5f18c518a922/src%2Fnode_file.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.h?ref=c412150582de524beacd180646ec5f18c518a922",
            "patch": "@@ -4,6 +4,7 @@\n #if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n \n #include \"node.h\"\n+#include \"stream_base.h\"\n #include \"req_wrap-inl.h\"\n \n namespace node {\n@@ -20,6 +21,7 @@ using v8::Value;\n \n namespace fs {\n \n+\n class FSReqBase : public ReqWrap<uv_fs_t> {\n  public:\n   FSReqBase(Environment* env, Local<Object> req, AsyncWrap::ProviderType type)\n@@ -120,23 +122,71 @@ class FSReqAfterScope {\n   Context::Scope context_scope_;\n };\n \n+class FileHandle;\n+\n+// A request wrap specifically for uv_fs_read()s scheduled for reading\n+// from a FileHandle.\n+class FileHandleReadWrap : public ReqWrap<uv_fs_t> {\n+ public:\n+  FileHandleReadWrap(FileHandle* handle, v8::Local<v8::Object> obj);\n+\n+  static inline FileHandleReadWrap* from_req(uv_fs_t* req) {\n+    return static_cast<FileHandleReadWrap*>(ReqWrap::from_req(req));\n+  }\n+\n+  size_t self_size() const override { return sizeof(*this); }\n+\n+ private:\n+  FileHandle* file_handle_;\n+  uv_buf_t buffer_;\n+\n+  friend class FileHandle;\n+};\n+\n // A wrapper for a file descriptor that will automatically close the fd when\n // the object is garbage collected\n-class FileHandle : public AsyncWrap {\n+class FileHandle : public AsyncWrap, public StreamBase {\n  public:\n-  FileHandle(Environment* env, int fd);\n+  FileHandle(Environment* env,\n+             int fd,\n+             v8::Local<v8::Object> obj = v8::Local<v8::Object>());\n   virtual ~FileHandle();\n \n+  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);\n+\n   int fd() const { return fd_; }\n   size_t self_size() const override { return sizeof(*this); }\n \n   // Will asynchronously close the FD and return a Promise that will\n   // be resolved once closing is complete.\n   static void Close(const FunctionCallbackInfo<Value>& args);\n \n+  // Releases ownership of the FD.\n+  static void ReleaseFD(const FunctionCallbackInfo<Value>& args);\n+\n+  // StreamBase interface:\n+  int ReadStart() override;\n+  int ReadStop() override;\n+\n+  bool IsAlive() override { return !closed_; }\n+  bool IsClosing() override { return closing_; }\n+  AsyncWrap* GetAsyncWrap() override { return this; }\n+\n+  // In the case of file streams, shutting down corresponds to closing.\n+  ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object) override;\n+  int DoShutdown(ShutdownWrap* req_wrap) override;\n+\n+  int DoWrite(WriteWrap* w,\n+              uv_buf_t* bufs,\n+              size_t count,\n+              uv_stream_t* send_handle) override {\n+    return UV_ENOSYS;  // Not implemented (yet).\n+  }\n+\n  private:\n   // Synchronous close that emits a warning\n-  inline void Close();\n+  void Close();\n+  void AfterClose();\n \n   class CloseReq : public ReqWrap<uv_fs_t> {\n    public:\n@@ -176,6 +226,12 @@ class FileHandle : public AsyncWrap {\n   int fd_;\n   bool closing_ = false;\n   bool closed_ = false;\n+  int64_t read_offset_ = -1;\n+  int64_t read_length_ = -1;\n+\n+  bool reading_ = false;\n+  std::unique_ptr<FileHandleReadWrap> current_read_ = nullptr;\n+\n \n   DISALLOW_COPY_AND_ASSIGN(FileHandle);\n };"
        },
        {
            "sha": "b7495a80ac63e0af6ba42881718335bc772a557b",
            "filename": "src/stream_base-inl.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/c412150582de524beacd180646ec5f18c518a922/src%2Fstream_base-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/c412150582de524beacd180646ec5f18c518a922/src%2Fstream_base-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base-inl.h?ref=c412150582de524beacd180646ec5f18c518a922",
            "patch": "@@ -146,6 +146,9 @@ inline Environment* StreamBase::stream_env() const {\n \n inline int StreamBase::Shutdown(v8::Local<v8::Object> req_wrap_obj) {\n   Environment* env = stream_env();\n+\n+  HandleScope handle_scope(env->isolate());\n+\n   if (req_wrap_obj.IsEmpty()) {\n     req_wrap_obj =\n         env->shutdown_wrap_constructor_function()\n@@ -183,6 +186,8 @@ inline StreamWriteResult StreamBase::Write(\n     }\n   }\n \n+  HandleScope handle_scope(env->isolate());\n+\n   if (req_wrap_obj.IsEmpty()) {\n     req_wrap_obj =\n         env->write_wrap_constructor_function()"
        },
        {
            "sha": "f3e010d5bc94c9ec2e5c6aa600e93375e67a6782",
            "filename": "src/stream_base.h",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/c412150582de524beacd180646ec5f18c518a922/src%2Fstream_base.h",
            "raw_url": "https://github.com/nodejs/node/raw/c412150582de524beacd180646ec5f18c518a922/src%2Fstream_base.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.h?ref=c412150582de524beacd180646ec5f18c518a922",
            "patch": "@@ -95,7 +95,7 @@ class StreamListener {\n  public:\n   virtual ~StreamListener();\n \n-  // This is called when a stream wants to allocate memory immediately before\n+  // This is called when a stream wants to allocate memory before\n   // reading data into the freshly allocated buffer (i.e. it is always followed\n   // by a `OnStreamRead()` call).\n   // This memory may be statically or dynamically allocated; for example,\n@@ -105,6 +105,9 @@ class StreamListener {\n   // The returned buffer does not need to contain `suggested_size` bytes.\n   // The default implementation of this method returns a buffer that has exactly\n   // the suggested size and is allocated using malloc().\n+  // It is not valid to return a zero-length buffer from this method.\n+  // It is not guaranteed that the corresponding `OnStreamRead()` call\n+  // happens in the same event loop turn as this call.\n   virtual uv_buf_t OnStreamAlloc(size_t suggested_size);\n \n   // `OnStreamRead()` is called when data is available on the socket and has"
        },
        {
            "sha": "c822390ec56f8bd3a6eacfad61ea04d86c4dc5fa",
            "filename": "src/util.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c412150582de524beacd180646ec5f18c518a922/src%2Futil.h",
            "raw_url": "https://github.com/nodejs/node/raw/c412150582de524beacd180646ec5f18c518a922/src%2Futil.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Futil.h?ref=c412150582de524beacd180646ec5f18c518a922",
            "patch": "@@ -34,6 +34,7 @@\n #include <stdlib.h>\n #include <string.h>\n \n+#include <functional>  // std::function\n #include <type_traits>  // std::remove_reference\n \n namespace node {\n@@ -433,7 +434,6 @@ class BufferValue : public MaybeStackBuffer<char> {\n // Use this when a variable or parameter is unused in order to explicitly\n // silence a compiler warning about that.\n template <typename T> inline void USE(T&&) {}\n-\n }  // namespace node\n \n #endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS"
        }
    ],
    "stats": {
        "total": 293,
        "additions": 279,
        "deletions": 14
    }
}