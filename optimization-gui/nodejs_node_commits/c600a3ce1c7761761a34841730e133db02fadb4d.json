{
    "author": "BridgeAR",
    "message": "util: move inspect in separate file\n\nThe inspect function became very big and it's better to handle this\nin a separate file.\n\nPR-URL: https://github.com/nodejs/node/pull/22845\nReviewed-By: John-David Dalton <john.david.dalton@gmail.com>\nReviewed-By: Refael Ackermann <refack@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Trivikram Kamat <trivikr.dev@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "c600a3ce1c7761761a34841730e133db02fadb4d",
    "files": [
        {
            "sha": "dc66c5f9dfedd3d56d54793debdc29278775b9ce",
            "filename": "lib/internal/util/inspect.js",
            "status": "added",
            "additions": 1155,
            "deletions": 0,
            "changes": 1155,
            "blob_url": "https://github.com/nodejs/node/blob/c600a3ce1c7761761a34841730e133db02fadb4d/lib%2Finternal%2Futil%2Finspect.js",
            "raw_url": "https://github.com/nodejs/node/raw/c600a3ce1c7761761a34841730e133db02fadb4d/lib%2Finternal%2Futil%2Finspect.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Futil%2Finspect.js?ref=c600a3ce1c7761761a34841730e133db02fadb4d",
            "patch": "@@ -0,0 +1,1155 @@\n+'use strict';\n+\n+const { internalBinding } = require('internal/bootstrap/loaders');\n+\n+const {\n+  getOwnNonIndexProperties,\n+  getPromiseDetails,\n+  getProxyDetails,\n+  kPending,\n+  kRejected,\n+  previewEntries,\n+  propertyFilter: {\n+    ALL_PROPERTIES,\n+    ONLY_ENUMERABLE\n+  }\n+} = internalBinding('util');\n+\n+const {\n+  customInspectSymbol,\n+  isError,\n+  join,\n+  removeColors\n+} = require('internal/util');\n+\n+const {\n+  codes: {\n+    ERR_INVALID_ARG_TYPE\n+  },\n+  isStackOverflowError\n+} = require('internal/errors');\n+\n+const types = internalBinding('types');\n+Object.assign(types, require('internal/util/types'));\n+const {\n+  isAnyArrayBuffer,\n+  isArrayBuffer,\n+  isArgumentsObject,\n+  isBoxedPrimitive,\n+  isDataView,\n+  isExternal,\n+  isMap,\n+  isMapIterator,\n+  isPromise,\n+  isSet,\n+  isSetIterator,\n+  isWeakMap,\n+  isWeakSet,\n+  isRegExp,\n+  isDate,\n+  isTypedArray,\n+  isStringObject,\n+  isNumberObject,\n+  isBooleanObject,\n+  isBigIntObject,\n+  isUint8Array,\n+  isUint8ClampedArray,\n+  isUint16Array,\n+  isUint32Array,\n+  isInt8Array,\n+  isInt16Array,\n+  isInt32Array,\n+  isFloat32Array,\n+  isFloat64Array,\n+  isBigInt64Array,\n+  isBigUint64Array\n+} = types;\n+\n+const ReflectApply = Reflect.apply;\n+\n+// This function is borrowed from the function with the same name on V8 Extras'\n+// `utils` object. V8 implements Reflect.apply very efficiently in conjunction\n+// with the spread syntax, such that no additional special case is needed for\n+// function calls w/o arguments.\n+// Refs: https://github.com/v8/v8/blob/d6ead37d265d7215cf9c5f768f279e21bd170212/src/js/prologue.js#L152-L156\n+function uncurryThis(func) {\n+  return (thisArg, ...args) => ReflectApply(func, thisArg, args);\n+}\n+\n+const propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);\n+const regExpToString = uncurryThis(RegExp.prototype.toString);\n+const dateToISOString = uncurryThis(Date.prototype.toISOString);\n+const errorToString = uncurryThis(Error.prototype.toString);\n+\n+const bigIntValueOf = uncurryThis(BigInt.prototype.valueOf);\n+const booleanValueOf = uncurryThis(Boolean.prototype.valueOf);\n+const numberValueOf = uncurryThis(Number.prototype.valueOf);\n+const symbolValueOf = uncurryThis(Symbol.prototype.valueOf);\n+const stringValueOf = uncurryThis(String.prototype.valueOf);\n+\n+const setValues = uncurryThis(Set.prototype.values);\n+const mapEntries = uncurryThis(Map.prototype.entries);\n+const dateGetTime = uncurryThis(Date.prototype.getTime);\n+const hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n+\n+const inspectDefaultOptions = Object.seal({\n+  showHidden: false,\n+  depth: 2,\n+  colors: false,\n+  customInspect: true,\n+  showProxy: false,\n+  maxArrayLength: 100,\n+  breakLength: 60,\n+  compact: true,\n+  sorted: false\n+});\n+\n+const kObjectType = 0;\n+const kArrayType = 1;\n+const kArrayExtrasType = 2;\n+\n+/* eslint-disable no-control-regex */\n+const strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c]/;\n+const strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c]/g;\n+const strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c]/;\n+const strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c]/g;\n+/* eslint-enable no-control-regex */\n+\n+const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\n+const numberRegExp = /^(0|[1-9][0-9]*)$/;\n+\n+const readableRegExps = {};\n+\n+const kMinLineLength = 16;\n+\n+// Constants to map the iterator state.\n+const kWeak = 0;\n+const kIterator = 1;\n+const kMapEntries = 2;\n+\n+// Escaped special characters. Use empty strings to fill up unused entries.\n+const meta = [\n+  '\\\\u0000', '\\\\u0001', '\\\\u0002', '\\\\u0003', '\\\\u0004',\n+  '\\\\u0005', '\\\\u0006', '\\\\u0007', '\\\\b', '\\\\t',\n+  '\\\\n', '\\\\u000b', '\\\\f', '\\\\r', '\\\\u000e',\n+  '\\\\u000f', '\\\\u0010', '\\\\u0011', '\\\\u0012', '\\\\u0013',\n+  '\\\\u0014', '\\\\u0015', '\\\\u0016', '\\\\u0017', '\\\\u0018',\n+  '\\\\u0019', '\\\\u001a', '\\\\u001b', '\\\\u001c', '\\\\u001d',\n+  '\\\\u001e', '\\\\u001f', '', '', '',\n+  '', '', '', '', \"\\\\'\", '', '', '', '', '',\n+  '', '', '', '', '', '', '', '', '', '',\n+  '', '', '', '', '', '', '', '', '', '',\n+  '', '', '', '', '', '', '', '', '', '',\n+  '', '', '', '', '', '', '', '', '', '',\n+  '', '', '', '', '', '', '', '\\\\\\\\'\n+];\n+\n+/**\n+ * Echos the value of any input. Tries to print the value out\n+ * in the best way possible given the different types.\n+ *\n+ * @param {any} value The value to print out.\n+ * @param {Object} opts Optional options object that alters the output.\n+ */\n+/* Legacy: value, showHidden, depth, colors */\n+function inspect(value, opts) {\n+  // Default options\n+  const ctx = {\n+    budget: {},\n+    indentationLvl: 0,\n+    seen: [],\n+    stylize: stylizeNoColor,\n+    showHidden: inspectDefaultOptions.showHidden,\n+    depth: inspectDefaultOptions.depth,\n+    colors: inspectDefaultOptions.colors,\n+    customInspect: inspectDefaultOptions.customInspect,\n+    showProxy: inspectDefaultOptions.showProxy,\n+    // TODO(BridgeAR): Deprecate `maxArrayLength` and replace it with\n+    // `maxEntries`.\n+    maxArrayLength: inspectDefaultOptions.maxArrayLength,\n+    breakLength: inspectDefaultOptions.breakLength,\n+    compact: inspectDefaultOptions.compact,\n+    sorted: inspectDefaultOptions.sorted\n+  };\n+  if (arguments.length > 1) {\n+    // Legacy...\n+    if (arguments.length > 2) {\n+      if (arguments[2] !== undefined) {\n+        ctx.depth = arguments[2];\n+      }\n+      if (arguments.length > 3 && arguments[3] !== undefined) {\n+        ctx.colors = arguments[3];\n+      }\n+    }\n+    // Set user-specified options\n+    if (typeof opts === 'boolean') {\n+      ctx.showHidden = opts;\n+    } else if (opts) {\n+      const optKeys = Object.keys(opts);\n+      for (var i = 0; i < optKeys.length; i++) {\n+        ctx[optKeys[i]] = opts[optKeys[i]];\n+      }\n+    }\n+  }\n+  if (ctx.colors) ctx.stylize = stylizeWithColor;\n+  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n+  return formatValue(ctx, value, ctx.depth);\n+}\n+inspect.custom = customInspectSymbol;\n+\n+Object.defineProperty(inspect, 'defaultOptions', {\n+  get() {\n+    return inspectDefaultOptions;\n+  },\n+  set(options) {\n+    if (options === null || typeof options !== 'object') {\n+      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n+    }\n+    return Object.assign(inspectDefaultOptions, options);\n+  }\n+});\n+\n+// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n+inspect.colors = Object.assign(Object.create(null), {\n+  'bold': [1, 22],\n+  'italic': [3, 23],\n+  'underline': [4, 24],\n+  'inverse': [7, 27],\n+  'white': [37, 39],\n+  'grey': [90, 39],\n+  'black': [30, 39],\n+  'blue': [34, 39],\n+  'cyan': [36, 39],\n+  'green': [32, 39],\n+  'magenta': [35, 39],\n+  'red': [31, 39],\n+  'yellow': [33, 39]\n+});\n+\n+// Don't use 'blue' not visible on cmd.exe\n+inspect.styles = Object.assign(Object.create(null), {\n+  'special': 'cyan',\n+  'number': 'yellow',\n+  'bigint': 'yellow',\n+  'boolean': 'yellow',\n+  'undefined': 'grey',\n+  'null': 'bold',\n+  'string': 'green',\n+  'symbol': 'green',\n+  'date': 'magenta',\n+  // \"name\": intentionally not styling\n+  'regexp': 'red'\n+});\n+\n+function addQuotes(str, quotes) {\n+  if (quotes === -1) {\n+    return `\"${str}\"`;\n+  }\n+  if (quotes === -2) {\n+    return `\\`${str}\\``;\n+  }\n+  return `'${str}'`;\n+}\n+\n+const escapeFn = (str) => meta[str.charCodeAt(0)];\n+\n+// Escape control characters, single quotes and the backslash.\n+// This is similar to JSON stringify escaping.\n+function strEscape(str) {\n+  let escapeTest = strEscapeSequencesRegExp;\n+  let escapeReplace = strEscapeSequencesReplacer;\n+  let singleQuote = 39;\n+\n+  // Check for double quotes. If not present, do not escape single quotes and\n+  // instead wrap the text in double quotes. If double quotes exist, check for\n+  // backticks. If they do not exist, use those as fallback instead of the\n+  // double quotes.\n+  if (str.indexOf(\"'\") !== -1) {\n+    // This invalidates the charCode and therefore can not be matched for\n+    // anymore.\n+    if (str.indexOf('\"') === -1) {\n+      singleQuote = -1;\n+    } else if (str.indexOf('`') === -1 && str.indexOf('${') === -1) {\n+      singleQuote = -2;\n+    }\n+    if (singleQuote !== 39) {\n+      escapeTest = strEscapeSequencesRegExpSingle;\n+      escapeReplace = strEscapeSequencesReplacerSingle;\n+    }\n+  }\n+\n+  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n+  if (str.length < 5000 && !escapeTest.test(str))\n+    return addQuotes(str, singleQuote);\n+  if (str.length > 100) {\n+    str = str.replace(escapeReplace, escapeFn);\n+    return addQuotes(str, singleQuote);\n+  }\n+\n+  let result = '';\n+  let last = 0;\n+  for (var i = 0; i < str.length; i++) {\n+    const point = str.charCodeAt(i);\n+    if (point === singleQuote || point === 92 || point < 32) {\n+      if (last === i) {\n+        result += meta[point];\n+      } else {\n+        result += `${str.slice(last, i)}${meta[point]}`;\n+      }\n+      last = i + 1;\n+    }\n+  }\n+  if (last === 0) {\n+    result = str;\n+  } else if (last !== i) {\n+    result += str.slice(last);\n+  }\n+  return addQuotes(result, singleQuote);\n+}\n+\n+function stylizeWithColor(str, styleType) {\n+  const style = inspect.styles[styleType];\n+  if (style !== undefined) {\n+    const color = inspect.colors[style];\n+    return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\n+  }\n+  return str;\n+}\n+\n+function stylizeNoColor(str) {\n+  return str;\n+}\n+\n+// Return a new empty array to push in the results of the default formatter.\n+function getEmptyFormatArray() {\n+  return [];\n+}\n+\n+function getConstructorName(obj) {\n+  while (obj) {\n+    const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');\n+    if (descriptor !== undefined &&\n+        typeof descriptor.value === 'function' &&\n+        descriptor.value.name !== '') {\n+      return descriptor.value.name;\n+    }\n+\n+    obj = Object.getPrototypeOf(obj);\n+  }\n+\n+  return '';\n+}\n+\n+function getPrefix(constructor, tag, fallback) {\n+  if (constructor !== '') {\n+    if (tag !== '' && constructor !== tag) {\n+      return `${constructor} [${tag}] `;\n+    }\n+    return `${constructor} `;\n+  }\n+\n+  if (tag !== '')\n+    return `[${tag}] `;\n+\n+  if (fallback !== undefined)\n+    return `${fallback} `;\n+\n+  return '';\n+}\n+\n+const getBoxedValue = formatPrimitive.bind(null, stylizeNoColor);\n+\n+// Look up the keys of the object.\n+function getKeys(value, showHidden) {\n+  let keys;\n+  const symbols = Object.getOwnPropertySymbols(value);\n+  if (showHidden) {\n+    keys = Object.getOwnPropertyNames(value);\n+    if (symbols.length !== 0)\n+      keys.push(...symbols);\n+  } else {\n+    // This might throw if `value` is a Module Namespace Object from an\n+    // unevaluated module, but we don't want to perform the actual type\n+    // check because it's expensive.\n+    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n+    // and modify this logic as needed.\n+    try {\n+      keys = Object.keys(value);\n+    } catch (err) {\n+      if (types.isNativeError(err) &&\n+          err.name === 'ReferenceError' &&\n+          types.isModuleNamespaceObject(value)) {\n+        keys = Object.getOwnPropertyNames(value);\n+      } else {\n+        throw err;\n+      }\n+    }\n+    if (symbols.length !== 0) {\n+      keys.push(...symbols.filter((key) => propertyIsEnumerable(value, key)));\n+    }\n+  }\n+  return keys;\n+}\n+\n+function formatProxy(ctx, proxy, recurseTimes) {\n+  if (recurseTimes != null) {\n+    if (recurseTimes < 0)\n+      return ctx.stylize('Proxy [Array]', 'special');\n+    recurseTimes -= 1;\n+  }\n+  ctx.indentationLvl += 2;\n+  const res = [\n+    formatValue(ctx, proxy[0], recurseTimes),\n+    formatValue(ctx, proxy[1], recurseTimes)\n+  ];\n+  ctx.indentationLvl -= 2;\n+  const str = reduceToSingleString(ctx, res, '', ['[', ']']);\n+  return `Proxy ${str}`;\n+}\n+\n+function findTypedConstructor(value) {\n+  for (const [check, clazz] of [\n+    [isUint8Array, Uint8Array],\n+    [isUint8ClampedArray, Uint8ClampedArray],\n+    [isUint16Array, Uint16Array],\n+    [isUint32Array, Uint32Array],\n+    [isInt8Array, Int8Array],\n+    [isInt16Array, Int16Array],\n+    [isInt32Array, Int32Array],\n+    [isFloat32Array, Float32Array],\n+    [isFloat64Array, Float64Array],\n+    [isBigInt64Array, BigInt64Array],\n+    [isBigUint64Array, BigUint64Array]\n+  ]) {\n+    if (check(value)) {\n+      return clazz;\n+    }\n+  }\n+}\n+\n+function noPrototypeIterator(ctx, value, recurseTimes) {\n+  let newVal;\n+  // TODO: Create a Subclass in case there's no prototype and show\n+  // `null-prototype`.\n+  if (isSet(value)) {\n+    const clazz = Object.getPrototypeOf(value) || Set;\n+    newVal = new clazz(setValues(value));\n+  } else if (isMap(value)) {\n+    const clazz = Object.getPrototypeOf(value) || Map;\n+    newVal = new clazz(mapEntries(value));\n+  } else if (Array.isArray(value)) {\n+    const clazz = Object.getPrototypeOf(value) || Array;\n+    newVal = new clazz(value.length || 0);\n+  } else if (isTypedArray(value)) {\n+    const clazz = findTypedConstructor(value) || Uint8Array;\n+    newVal = new clazz(value);\n+  }\n+  if (newVal) {\n+    Object.defineProperties(newVal, Object.getOwnPropertyDescriptors(value));\n+    return formatValue(ctx, newVal, recurseTimes);\n+  }\n+}\n+\n+// Note: using `formatValue` directly requires the indentation level to be\n+// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n+// value afterwards again.\n+function formatValue(ctx, value, recurseTimes) {\n+  // Primitive types cannot have properties.\n+  if (typeof value !== 'object' && typeof value !== 'function') {\n+    return formatPrimitive(ctx.stylize, value, ctx);\n+  }\n+  if (value === null) {\n+    return ctx.stylize('null', 'null');\n+  }\n+\n+  if (ctx.stop !== undefined) {\n+    const name = getConstructorName(value) || value[Symbol.toStringTag];\n+    return ctx.stylize(`[${name || 'Object'}]`, 'special');\n+  }\n+\n+  if (ctx.showProxy) {\n+    const proxy = getProxyDetails(value);\n+    if (proxy !== undefined) {\n+      return formatProxy(ctx, proxy, recurseTimes);\n+    }\n+  }\n+\n+  // Provide a hook for user-specified inspect functions.\n+  // Check that value is an object with an inspect function on it.\n+  if (ctx.customInspect) {\n+    const maybeCustom = value[customInspectSymbol];\n+    if (typeof maybeCustom === 'function' &&\n+        // Filter out the util module, its inspect function is special.\n+        maybeCustom !== inspect &&\n+        // Also filter out any prototype objects using the circular check.\n+        !(value.constructor && value.constructor.prototype === value)) {\n+      const ret = maybeCustom.call(value, recurseTimes, ctx);\n+\n+      // If the custom inspection method returned `this`, don't go into\n+      // infinite recursion.\n+      if (ret !== value) {\n+        if (typeof ret !== 'string') {\n+          return formatValue(ctx, ret, recurseTimes);\n+        }\n+        return ret;\n+      }\n+    }\n+  }\n+\n+  // Using an array here is actually better for the average case than using\n+  // a Set. `seen` will only check for the depth and will never grow too large.\n+  if (ctx.seen.indexOf(value) !== -1)\n+    return ctx.stylize('[Circular]', 'special');\n+\n+  return formatRaw(ctx, value, recurseTimes);\n+}\n+\n+function formatRaw(ctx, value, recurseTimes) {\n+  let keys;\n+\n+  const constructor = getConstructorName(value);\n+  let tag = value[Symbol.toStringTag];\n+  if (typeof tag !== 'string')\n+    tag = '';\n+  let base = '';\n+  let formatter = getEmptyFormatArray;\n+  let braces;\n+  let noIterator = true;\n+  let i = 0;\n+  let skip = false;\n+  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n+\n+  let extrasType = kObjectType;\n+\n+  // Iterators and the rest are split to reduce checks.\n+  if (value[Symbol.iterator]) {\n+    noIterator = false;\n+    if (Array.isArray(value)) {\n+      keys = getOwnNonIndexProperties(value, filter);\n+      // Only set the constructor for non ordinary (\"Array [...]\") arrays.\n+      const prefix = getPrefix(constructor, tag);\n+      braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];\n+      if (value.length === 0 && keys.length === 0)\n+        return `${braces[0]}]`;\n+      extrasType = kArrayExtrasType;\n+      formatter = formatArray;\n+    } else if (isSet(value)) {\n+      keys = getKeys(value, ctx.showHidden);\n+      const prefix = getPrefix(constructor, tag);\n+      if (value.size === 0 && keys.length === 0)\n+        return `${prefix}{}`;\n+      braces = [`${prefix}{`, '}'];\n+      formatter = formatSet;\n+    } else if (isMap(value)) {\n+      keys = getKeys(value, ctx.showHidden);\n+      const prefix = getPrefix(constructor, tag);\n+      if (value.size === 0 && keys.length === 0)\n+        return `${prefix}{}`;\n+      braces = [`${prefix}{`, '}'];\n+      formatter = formatMap;\n+    } else if (isTypedArray(value)) {\n+      keys = getOwnNonIndexProperties(value, filter);\n+      braces = [`${getPrefix(constructor, tag)}[`, ']'];\n+      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n+        return `${braces[0]}]`;\n+      formatter = formatTypedArray;\n+      extrasType = kArrayExtrasType;\n+    } else if (isMapIterator(value)) {\n+      keys = getKeys(value, ctx.showHidden);\n+      braces = [`[${tag}] {`, '}'];\n+      formatter = formatMapIterator;\n+    } else if (isSetIterator(value)) {\n+      keys = getKeys(value, ctx.showHidden);\n+      braces = [`[${tag}] {`, '}'];\n+      formatter = formatSetIterator;\n+    } else {\n+      noIterator = true;\n+    }\n+  }\n+  if (noIterator) {\n+    keys = getKeys(value, ctx.showHidden);\n+    braces = ['{', '}'];\n+    if (constructor === 'Object') {\n+      if (isArgumentsObject(value)) {\n+        if (keys.length === 0)\n+          return '[Arguments] {}';\n+        braces[0] = '[Arguments] {';\n+      } else if (tag !== '') {\n+        braces[0] = `${getPrefix(constructor, tag)}{`;\n+        if (keys.length === 0) {\n+          return `${braces[0]}}`;\n+        }\n+      } else if (keys.length === 0) {\n+        return '{}';\n+      }\n+    } else if (typeof value === 'function') {\n+      const type = constructor || tag || 'Function';\n+      const name = `${type}${value.name ? `: ${value.name}` : ''}`;\n+      if (keys.length === 0)\n+        return ctx.stylize(`[${name}]`, 'special');\n+      base = `[${name}]`;\n+    } else if (isRegExp(value)) {\n+      // Make RegExps say that they are RegExps\n+      if (keys.length === 0 || recurseTimes < 0)\n+        return ctx.stylize(regExpToString(value), 'regexp');\n+      base = `${regExpToString(value)}`;\n+    } else if (isDate(value)) {\n+      // Make dates with properties first say the date\n+      if (keys.length === 0) {\n+        if (Number.isNaN(dateGetTime(value)))\n+          return ctx.stylize(String(value), 'date');\n+        return ctx.stylize(dateToISOString(value), 'date');\n+      }\n+      base = dateToISOString(value);\n+    } else if (isError(value)) {\n+      // Make error with message first say the error.\n+      base = formatError(value);\n+      // Wrap the error in brackets in case it has no stack trace.\n+      const stackStart = base.indexOf('\\n    at');\n+      if (stackStart === -1) {\n+        base = `[${base}]`;\n+      }\n+      // The message and the stack have to be indented as well!\n+      if (ctx.indentationLvl !== 0) {\n+        const indentation = ' '.repeat(ctx.indentationLvl);\n+        base = formatError(value).replace(/\\n/g, `\\n${indentation}`);\n+      }\n+      if (keys.length === 0)\n+        return base;\n+\n+      if (ctx.compact === false && stackStart !== -1) {\n+        braces[0] += `${base.slice(stackStart)}`;\n+        base = `[${base.slice(0, stackStart)}]`;\n+      }\n+    } else if (isAnyArrayBuffer(value)) {\n+      let prefix = getPrefix(constructor, tag);\n+      if (prefix === '') {\n+        prefix = isArrayBuffer(value) ? 'ArrayBuffer ' : 'SharedArrayBuffer ';\n+      }\n+      // Fast path for ArrayBuffer and SharedArrayBuffer.\n+      // Can't do the same for DataView because it has a non-primitive\n+      // .buffer property that we need to recurse for.\n+      if (keys.length === 0)\n+        return prefix +\n+              `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;\n+      braces[0] = `${prefix}{`;\n+      keys.unshift('byteLength');\n+    } else if (isDataView(value)) {\n+      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`;\n+      // .buffer goes last, it's not a primitive like the others.\n+      keys.unshift('byteLength', 'byteOffset', 'buffer');\n+    } else if (isPromise(value)) {\n+      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;\n+      formatter = formatPromise;\n+    } else if (isWeakSet(value)) {\n+      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;\n+      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n+    } else if (isWeakMap(value)) {\n+      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;\n+      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n+    } else if (types.isModuleNamespaceObject(value)) {\n+      braces[0] = `[${tag}] {`;\n+      formatter = formatNamespaceObject;\n+      skip = true;\n+    } else if (isBoxedPrimitive(value)) {\n+      let type;\n+      if (isNumberObject(value)) {\n+        base = `[Number: ${getBoxedValue(numberValueOf(value))}]`;\n+        type = 'number';\n+      } else if (isStringObject(value)) {\n+        base = `[String: ${getBoxedValue(stringValueOf(value), ctx)}]`;\n+        type = 'string';\n+        // For boxed Strings, we have to remove the 0-n indexed entries,\n+        // since they just noisy up the output and are redundant\n+        // Make boxed primitive Strings look like such\n+        keys = keys.slice(value.length);\n+      } else if (isBooleanObject(value)) {\n+        base = `[Boolean: ${getBoxedValue(booleanValueOf(value))}]`;\n+        type = 'boolean';\n+      } else if (isBigIntObject(value)) {\n+        base = `[BigInt: ${getBoxedValue(bigIntValueOf(value))}]`;\n+        type = 'bigint';\n+      } else {\n+        base = `[Symbol: ${getBoxedValue(symbolValueOf(value))}]`;\n+        type = 'symbol';\n+      }\n+      if (keys.length === 0) {\n+        return ctx.stylize(base, type);\n+      }\n+    } else {\n+      // The input prototype got manipulated. Special handle these. We have to\n+      // rebuild the information so we are able to display everything.\n+      const specialIterator = noPrototypeIterator(ctx, value, recurseTimes);\n+      if (specialIterator) {\n+        return specialIterator;\n+      }\n+      if (isMapIterator(value)) {\n+        braces = [`[${tag || 'Map Iterator'}] {`, '}'];\n+        formatter = formatMapIterator;\n+      } else if (isSetIterator(value)) {\n+        braces = [`[${tag || 'Set Iterator'}] {`, '}'];\n+        formatter = formatSetIterator;\n+      // Handle other regular objects again.\n+      } else if (keys.length === 0) {\n+        if (isExternal(value))\n+          return ctx.stylize('[External]', 'special');\n+        return `${getPrefix(constructor, tag)}{}`;\n+      } else {\n+        braces[0] = `${getPrefix(constructor, tag)}{`;\n+      }\n+    }\n+  }\n+\n+  if (recurseTimes != null) {\n+    if (recurseTimes < 0)\n+      return ctx.stylize(`[${constructor || tag || 'Object'}]`, 'special');\n+    recurseTimes -= 1;\n+  }\n+\n+  ctx.seen.push(value);\n+  let output;\n+  const indentationLvl = ctx.indentationLvl;\n+  try {\n+    output = formatter(ctx, value, recurseTimes, keys);\n+    if (skip === false) {\n+      for (i = 0; i < keys.length; i++) {\n+        output.push(\n+          formatProperty(ctx, value, recurseTimes, keys[i], extrasType));\n+      }\n+    }\n+  } catch (err) {\n+    return handleMaxCallStackSize(ctx, err, constructor, tag, indentationLvl);\n+  }\n+  ctx.seen.pop();\n+\n+  if (ctx.sorted) {\n+    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\n+    if (extrasType === kObjectType) {\n+      output = output.sort(comparator);\n+    } else if (keys.length > 1) {\n+      const sorted = output.slice(output.length - keys.length).sort(comparator);\n+      output.splice(output.length - keys.length, keys.length, ...sorted);\n+    }\n+  }\n+\n+  const res = reduceToSingleString(ctx, output, base, braces);\n+  const budget = ctx.budget[ctx.indentationLvl] || 0;\n+  const newLength = budget + res.length;\n+  ctx.budget[ctx.indentationLvl] = newLength;\n+  // If any indentationLvl exceeds this limit, limit further inspecting to the\n+  // minimum. Otherwise the recursive algorithm might continue inspecting the\n+  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n+  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n+  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n+  // This limit also makes sure that huge objects don't block the event loop\n+  // significantly.\n+  if (newLength > 2 ** 27) {\n+    ctx.stop = true;\n+  }\n+  return res;\n+}\n+\n+function handleMaxCallStackSize(ctx, err, constructor, tag, indentationLvl) {\n+  if (isStackOverflowError(err)) {\n+    ctx.seen.pop();\n+    ctx.indentationLvl = indentationLvl;\n+    return ctx.stylize(\n+      `[${constructor || tag || 'Object'}: Inspection interrupted ` +\n+        'prematurely. Maximum call stack size exceeded.]',\n+      'special'\n+    );\n+  }\n+  throw err;\n+}\n+\n+function formatNumber(fn, value) {\n+  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.\n+  if (Object.is(value, -0))\n+    return fn('-0', 'number');\n+  return fn(`${value}`, 'number');\n+}\n+\n+function formatBigInt(fn, value) {\n+  return fn(`${value}n`, 'bigint');\n+}\n+\n+function formatPrimitive(fn, value, ctx) {\n+  if (typeof value === 'string') {\n+    if (ctx.compact === false &&\n+      ctx.indentationLvl + value.length > ctx.breakLength &&\n+      value.length > kMinLineLength) {\n+      // eslint-disable-next-line max-len\n+      const minLineLength = Math.max(ctx.breakLength - ctx.indentationLvl, kMinLineLength);\n+      // eslint-disable-next-line max-len\n+      const averageLineLength = Math.ceil(value.length / Math.ceil(value.length / minLineLength));\n+      const divisor = Math.max(averageLineLength, kMinLineLength);\n+      let res = '';\n+      if (readableRegExps[divisor] === undefined) {\n+        // Build a new RegExp that naturally breaks text into multiple lines.\n+        //\n+        // Rules\n+        // 1. Greedy match all text up the max line length that ends with a\n+        //    whitespace or the end of the string.\n+        // 2. If none matches, non-greedy match any text up to a whitespace or\n+        //    the end of the string.\n+        //\n+        // eslint-disable-next-line max-len, node-core/no-unescaped-regexp-dot\n+        readableRegExps[divisor] = new RegExp(`(.|\\\\n){1,${divisor}}(\\\\s|$)|(\\\\n|.)+?(\\\\s|$)`, 'gm');\n+      }\n+      const matches = value.match(readableRegExps[divisor]);\n+      if (matches.length > 1) {\n+        const indent = ' '.repeat(ctx.indentationLvl);\n+        res += `${fn(strEscape(matches[0]), 'string')} +\\n`;\n+        for (var i = 1; i < matches.length - 1; i++) {\n+          res += `${indent}  ${fn(strEscape(matches[i]), 'string')} +\\n`;\n+        }\n+        res += `${indent}  ${fn(strEscape(matches[i]), 'string')}`;\n+        return res;\n+      }\n+    }\n+    return fn(strEscape(value), 'string');\n+  }\n+  if (typeof value === 'number')\n+    return formatNumber(fn, value);\n+  // eslint-disable-next-line valid-typeof\n+  if (typeof value === 'bigint')\n+    return formatBigInt(fn, value);\n+  if (typeof value === 'boolean')\n+    return fn(`${value}`, 'boolean');\n+  if (typeof value === 'undefined')\n+    return fn('undefined', 'undefined');\n+  // es6 symbol primitive\n+  return fn(value.toString(), 'symbol');\n+}\n+\n+function formatError(value) {\n+  return value.stack || errorToString(value);\n+}\n+\n+function formatNamespaceObject(ctx, value, recurseTimes, keys) {\n+  const len = keys.length;\n+  const output = new Array(len);\n+  for (var i = 0; i < len; i++) {\n+    try {\n+      output[i] = formatProperty(ctx, value, recurseTimes, keys[i],\n+                                 kObjectType);\n+    } catch (err) {\n+      if (!(types.isNativeError(err) && err.name === 'ReferenceError')) {\n+        throw err;\n+      }\n+      // Use the existing functionality. This makes sure the indentation and\n+      // line breaks are always correct. Otherwise it is very difficult to keep\n+      // this aligned, even though this is a hacky way of dealing with this.\n+      const tmp = { [keys[i]]: '' };\n+      output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);\n+      const pos = output[i].lastIndexOf(' ');\n+      // We have to find the last whitespace and have to replace that value as\n+      // it will be visualized as a regular string.\n+      output[i] = output[i].slice(0, pos + 1) +\n+                  ctx.stylize('<uninitialized>', 'special');\n+    }\n+  }\n+  return output;\n+}\n+\n+// The array is sparse and/or has extra keys\n+function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {\n+  const keys = Object.keys(value);\n+  let index = i;\n+  for (; i < keys.length && output.length < maxLength; i++) {\n+    const key = keys[i];\n+    const tmp = +key;\n+    // Arrays can only have up to 2^32 - 1 entries\n+    if (tmp > 2 ** 32 - 2) {\n+      break;\n+    }\n+    if (`${index}` !== key) {\n+      if (!numberRegExp.test(key)) {\n+        break;\n+      }\n+      const emptyItems = tmp - index;\n+      const ending = emptyItems > 1 ? 's' : '';\n+      const message = `<${emptyItems} empty item${ending}>`;\n+      output.push(ctx.stylize(message, 'undefined'));\n+      index = tmp;\n+      if (output.length === maxLength) {\n+        break;\n+      }\n+    }\n+    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));\n+    index++;\n+  }\n+  const remaining = value.length - index;\n+  if (output.length !== maxLength) {\n+    if (remaining > 0) {\n+      const ending = remaining > 1 ? 's' : '';\n+      const message = `<${remaining} empty item${ending}>`;\n+      output.push(ctx.stylize(message, 'undefined'));\n+    }\n+  } else if (remaining > 0) {\n+    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n+  }\n+  return output;\n+}\n+\n+function formatArray(ctx, value, recurseTimes) {\n+  const valLen = value.length;\n+  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);\n+\n+  const remaining = valLen - len;\n+  const output = [];\n+  for (var i = 0; i < len; i++) {\n+    // Special handle sparse arrays.\n+    if (!hasOwnProperty(value, i)) {\n+      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);\n+    }\n+    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));\n+  }\n+  if (remaining > 0)\n+    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n+  return output;\n+}\n+\n+function formatTypedArray(ctx, value, recurseTimes) {\n+  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);\n+  const remaining = value.length - maxLength;\n+  const output = new Array(maxLength);\n+  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\n+    formatNumber :\n+    formatBigInt;\n+  for (var i = 0; i < maxLength; ++i)\n+    output[i] = elementFormatter(ctx.stylize, value[i]);\n+  if (remaining > 0) {\n+    output[i] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n+  }\n+  if (ctx.showHidden) {\n+    // .buffer goes last, it's not a primitive like the others.\n+    ctx.indentationLvl += 2;\n+    for (const key of [\n+      'BYTES_PER_ELEMENT',\n+      'length',\n+      'byteLength',\n+      'byteOffset',\n+      'buffer'\n+    ]) {\n+      const str = formatValue(ctx, value[key], recurseTimes);\n+      output.push(`[${key}]: ${str}`);\n+    }\n+    ctx.indentationLvl -= 2;\n+  }\n+  return output;\n+}\n+\n+function formatSet(ctx, value, recurseTimes) {\n+  const output = [];\n+  ctx.indentationLvl += 2;\n+  for (const v of value) {\n+    output.push(formatValue(ctx, v, recurseTimes));\n+  }\n+  ctx.indentationLvl -= 2;\n+  // With `showHidden`, `length` will display as a hidden property for\n+  // arrays. For consistency's sake, do the same for `size`, even though this\n+  // property isn't selected by Object.getOwnPropertyNames().\n+  if (ctx.showHidden)\n+    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);\n+  return output;\n+}\n+\n+function formatMap(ctx, value, recurseTimes) {\n+  const output = [];\n+  ctx.indentationLvl += 2;\n+  for (const [k, v] of value) {\n+    output.push(`${formatValue(ctx, k, recurseTimes)} => ` +\n+                formatValue(ctx, v, recurseTimes));\n+  }\n+  ctx.indentationLvl -= 2;\n+  // See comment in formatSet\n+  if (ctx.showHidden)\n+    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);\n+  return output;\n+}\n+\n+function formatSetIterInner(ctx, recurseTimes, entries, state) {\n+  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);\n+  const maxLength = Math.min(maxArrayLength, entries.length);\n+  let output = new Array(maxLength);\n+  ctx.indentationLvl += 2;\n+  for (var i = 0; i < maxLength; i++) {\n+    output[i] = formatValue(ctx, entries[i], recurseTimes);\n+  }\n+  ctx.indentationLvl -= 2;\n+  if (state === kWeak) {\n+    // Sort all entries to have a halfway reliable output (if more entries than\n+    // retrieved ones exist, we can not reliably return the same output).\n+    output = output.sort();\n+  }\n+  const remaining = entries.length - maxLength;\n+  if (remaining > 0) {\n+    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n+  }\n+  return output;\n+}\n+\n+function formatMapIterInner(ctx, recurseTimes, entries, state) {\n+  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);\n+  // Entries exist as [key1, val1, key2, val2, ...]\n+  const len = entries.length / 2;\n+  const remaining = len - maxArrayLength;\n+  const maxLength = Math.min(maxArrayLength, len);\n+  let output = new Array(maxLength);\n+  let start = '';\n+  let end = '';\n+  let middle = ' => ';\n+  let i = 0;\n+  if (state === kMapEntries) {\n+    start = '[ ';\n+    end = ' ]';\n+    middle = ', ';\n+  }\n+  ctx.indentationLvl += 2;\n+  for (; i < maxLength; i++) {\n+    const pos = i * 2;\n+    output[i] = `${start}${formatValue(ctx, entries[pos], recurseTimes)}` +\n+      `${middle}${formatValue(ctx, entries[pos + 1], recurseTimes)}${end}`;\n+  }\n+  ctx.indentationLvl -= 2;\n+  if (state === kWeak) {\n+    // Sort all entries to have a halfway reliable output (if more entries\n+    // than retrieved ones exist, we can not reliably return the same output).\n+    output = output.sort();\n+  }\n+  if (remaining > 0) {\n+    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n+  }\n+  return output;\n+}\n+\n+function formatWeakCollection(ctx) {\n+  return [ctx.stylize('<items unknown>', 'special')];\n+}\n+\n+function formatWeakSet(ctx, value, recurseTimes) {\n+  const entries = previewEntries(value);\n+  return formatSetIterInner(ctx, recurseTimes, entries, kWeak);\n+}\n+\n+function formatWeakMap(ctx, value, recurseTimes) {\n+  const entries = previewEntries(value);\n+  return formatMapIterInner(ctx, recurseTimes, entries, kWeak);\n+}\n+\n+function formatSetIterator(ctx, value, recurseTimes) {\n+  const entries = previewEntries(value);\n+  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);\n+}\n+\n+function formatMapIterator(ctx, value, recurseTimes) {\n+  const [entries, isKeyValue] = previewEntries(value, true);\n+  if (isKeyValue) {\n+    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);\n+  }\n+\n+  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);\n+}\n+\n+function formatPromise(ctx, value, recurseTimes) {\n+  let output;\n+  const [state, result] = getPromiseDetails(value);\n+  if (state === kPending) {\n+    output = [ctx.stylize('<pending>', 'special')];\n+  } else {\n+    // Using `formatValue` is correct here without the need to fix the\n+    // indentation level.\n+    ctx.indentationLvl += 2;\n+    const str = formatValue(ctx, result, recurseTimes);\n+    ctx.indentationLvl -= 2;\n+    output = [\n+      state === kRejected ?\n+        `${ctx.stylize('<rejected>', 'special')} ${str}` :\n+        str\n+    ];\n+  }\n+  return output;\n+}\n+\n+function formatProperty(ctx, value, recurseTimes, key, type) {\n+  let name, str;\n+  let extra = ' ';\n+  const desc = Object.getOwnPropertyDescriptor(value, key) ||\n+    { value: value[key], enumerable: true };\n+  if (desc.value !== undefined) {\n+    const diff = (type !== kObjectType || ctx.compact === false) ? 2 : 3;\n+    ctx.indentationLvl += diff;\n+    str = formatValue(ctx, desc.value, recurseTimes);\n+    if (diff === 3) {\n+      const len = ctx.colors ? removeColors(str).length : str.length;\n+      if (ctx.breakLength < len) {\n+        extra = `\\n${' '.repeat(ctx.indentationLvl)}`;\n+      }\n+    }\n+    ctx.indentationLvl -= diff;\n+  } else if (desc.get !== undefined) {\n+    if (desc.set !== undefined) {\n+      str = ctx.stylize('[Getter/Setter]', 'special');\n+    } else {\n+      str = ctx.stylize('[Getter]', 'special');\n+    }\n+  } else if (desc.set !== undefined) {\n+    str = ctx.stylize('[Setter]', 'special');\n+  } else {\n+    str = ctx.stylize('undefined', 'undefined');\n+  }\n+  if (type === kArrayType) {\n+    return str;\n+  }\n+  if (typeof key === 'symbol') {\n+    const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);\n+    name = `[${ctx.stylize(tmp, 'symbol')}]`;\n+  } else if (desc.enumerable === false) {\n+    name = `[${key.replace(strEscapeSequencesReplacer, escapeFn)}]`;\n+  } else if (keyStrRegExp.test(key)) {\n+    name = ctx.stylize(key, 'name');\n+  } else {\n+    name = ctx.stylize(strEscape(key), 'string');\n+  }\n+  return `${name}:${extra}${str}`;\n+}\n+\n+function reduceToSingleString(ctx, output, base, braces) {\n+  const breakLength = ctx.breakLength;\n+  let i = 0;\n+  if (ctx.compact === false) {\n+    const indentation = ' '.repeat(ctx.indentationLvl);\n+    let res = `${base ? `${base} ` : ''}${braces[0]}\\n${indentation}  `;\n+    for (; i < output.length - 1; i++) {\n+      res += `${output[i]},\\n${indentation}  `;\n+    }\n+    res += `${output[i]}\\n${indentation}${braces[1]}`;\n+    return res;\n+  }\n+  if (output.length * 2 <= breakLength) {\n+    let length = 0;\n+    for (; i < output.length && length <= breakLength; i++) {\n+      if (ctx.colors) {\n+        length += removeColors(output[i]).length + 1;\n+      } else {\n+        length += output[i].length + 1;\n+      }\n+    }\n+    if (length <= breakLength)\n+      return `${braces[0]}${base ? ` ${base}` : ''} ${join(output, ', ')} ` +\n+        braces[1];\n+  }\n+  // If the opening \"brace\" is too large, like in the case of \"Set {\",\n+  // we need to force the first item to be on the next line or the\n+  // items will not line up correctly.\n+  const indentation = ' '.repeat(ctx.indentationLvl);\n+  const ln = base === '' && braces[0].length === 1 ?\n+    ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\n+  const str = join(output, `,\\n${indentation}  `);\n+  return `${braces[0]}${ln}${str} ${braces[1]}`;\n+}\n+\n+module.exports = {\n+  inspect\n+};"
        },
        {
            "sha": "ae2295533df3ef1980303c2763feee81bec1ba1e",
            "filename": "lib/util.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1129,
            "changes": 1130,
            "blob_url": "https://github.com/nodejs/node/blob/c600a3ce1c7761761a34841730e133db02fadb4d/lib%2Futil.js",
            "raw_url": "https://github.com/nodejs/node/raw/c600a3ce1c7761761a34841730e133db02fadb4d/lib%2Futil.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Futil.js?ref=c600a3ce1c7761761a34841730e133db02fadb4d",
            "patch": "@@ -22,6 +22,7 @@\n 'use strict';\n \n const errors = require('internal/errors');\n+const { inspect } = require('internal/util/inspect');\n const {\n   ERR_FALSY_VALUE_REJECTION,\n   ERR_INVALID_ARG_TYPE,\n@@ -32,213 +33,24 @@ const { TextDecoder, TextEncoder } = require('internal/encoding');\n const { isBuffer } = require('buffer').Buffer;\n \n const { internalBinding } = require('internal/bootstrap/loaders');\n-const {\n-  getOwnNonIndexProperties,\n-  getPromiseDetails,\n-  getProxyDetails,\n-  kPending,\n-  kRejected,\n-  previewEntries,\n-  propertyFilter: {\n-    ALL_PROPERTIES,\n-    ONLY_ENUMERABLE\n-  }\n-} = internalBinding('util');\n \n const types = internalBinding('types');\n Object.assign(types, require('internal/util/types'));\n const {\n-  isAnyArrayBuffer,\n-  isArrayBuffer,\n-  isArgumentsObject,\n-  isBoxedPrimitive,\n-  isDataView,\n-  isExternal,\n-  isMap,\n-  isMapIterator,\n-  isPromise,\n-  isSet,\n-  isSetIterator,\n-  isWeakMap,\n-  isWeakSet,\n   isRegExp,\n   isDate,\n-  isTypedArray,\n-  isStringObject,\n-  isNumberObject,\n-  isBooleanObject,\n-  isBigIntObject,\n-  isUint8Array,\n-  isUint8ClampedArray,\n-  isUint16Array,\n-  isUint32Array,\n-  isInt8Array,\n-  isInt16Array,\n-  isInt32Array,\n-  isFloat32Array,\n-  isFloat64Array,\n-  isBigInt64Array,\n-  isBigUint64Array\n } = types;\n \n const {\n-  customInspectSymbol,\n   deprecate,\n   getSystemErrorName: internalErrorName,\n   isError,\n   promisify,\n-  join,\n-  removeColors\n } = require('internal/util');\n \n-const inspectDefaultOptions = Object.seal({\n-  showHidden: false,\n-  depth: 2,\n-  colors: false,\n-  customInspect: true,\n-  showProxy: false,\n-  maxArrayLength: 100,\n-  breakLength: 60,\n-  compact: true,\n-  sorted: false\n-});\n-\n-const kObjectType = 0;\n-const kArrayType = 1;\n-const kArrayExtrasType = 2;\n-\n-const ReflectApply = Reflect.apply;\n-\n-// This function is borrowed from the function with the same name on V8 Extras'\n-// `utils` object. V8 implements Reflect.apply very efficiently in conjunction\n-// with the spread syntax, such that no additional special case is needed for\n-// function calls w/o arguments.\n-// Refs: https://github.com/v8/v8/blob/d6ead37d265d7215cf9c5f768f279e21bd170212/src/js/prologue.js#L152-L156\n-function uncurryThis(func) {\n-  return (thisArg, ...args) => ReflectApply(func, thisArg, args);\n-}\n-\n-const propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);\n-const regExpToString = uncurryThis(RegExp.prototype.toString);\n-const dateToISOString = uncurryThis(Date.prototype.toISOString);\n-const errorToString = uncurryThis(Error.prototype.toString);\n-\n-const bigIntValueOf = uncurryThis(BigInt.prototype.valueOf);\n-const booleanValueOf = uncurryThis(Boolean.prototype.valueOf);\n-const numberValueOf = uncurryThis(Number.prototype.valueOf);\n-const symbolValueOf = uncurryThis(Symbol.prototype.valueOf);\n-const stringValueOf = uncurryThis(String.prototype.valueOf);\n-\n-const setValues = uncurryThis(Set.prototype.values);\n-const mapEntries = uncurryThis(Map.prototype.entries);\n-const dateGetTime = uncurryThis(Date.prototype.getTime);\n-const hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n-\n let CIRCULAR_ERROR_MESSAGE;\n let internalDeepEqual;\n \n-/* eslint-disable no-control-regex */\n-const strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c]/;\n-const strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c]/g;\n-const strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c]/;\n-const strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c]/g;\n-\n-/* eslint-enable no-control-regex */\n-\n-const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\n-const numberRegExp = /^(0|[1-9][0-9]*)$/;\n-\n-const readableRegExps = {};\n-\n-const MIN_LINE_LENGTH = 16;\n-\n-// Escaped special characters. Use empty strings to fill up unused entries.\n-const meta = [\n-  '\\\\u0000', '\\\\u0001', '\\\\u0002', '\\\\u0003', '\\\\u0004',\n-  '\\\\u0005', '\\\\u0006', '\\\\u0007', '\\\\b', '\\\\t',\n-  '\\\\n', '\\\\u000b', '\\\\f', '\\\\r', '\\\\u000e',\n-  '\\\\u000f', '\\\\u0010', '\\\\u0011', '\\\\u0012', '\\\\u0013',\n-  '\\\\u0014', '\\\\u0015', '\\\\u0016', '\\\\u0017', '\\\\u0018',\n-  '\\\\u0019', '\\\\u001a', '\\\\u001b', '\\\\u001c', '\\\\u001d',\n-  '\\\\u001e', '\\\\u001f', '', '', '',\n-  '', '', '', '', \"\\\\'\", '', '', '', '', '',\n-  '', '', '', '', '', '', '', '', '', '',\n-  '', '', '', '', '', '', '', '', '', '',\n-  '', '', '', '', '', '', '', '', '', '',\n-  '', '', '', '', '', '', '', '', '', '',\n-  '', '', '', '', '', '', '', '\\\\\\\\'\n-];\n-// Constants to map the iterator state.\n-const kWeak = 0;\n-const kIterator = 1;\n-const kMapEntries = 2;\n-\n-function addQuotes(str, quotes) {\n-  if (quotes === -1) {\n-    return `\"${str}\"`;\n-  }\n-  if (quotes === -2) {\n-    return `\\`${str}\\``;\n-  }\n-  return `'${str}'`;\n-}\n-\n-const escapeFn = (str) => meta[str.charCodeAt(0)];\n-\n-// Escape control characters, single quotes and the backslash.\n-// This is similar to JSON stringify escaping.\n-function strEscape(str) {\n-  let escapeTest = strEscapeSequencesRegExp;\n-  let escapeReplace = strEscapeSequencesReplacer;\n-  let singleQuote = 39;\n-\n-  // Check for double quotes. If not present, do not escape single quotes and\n-  // instead wrap the text in double quotes. If double quotes exist, check for\n-  // backticks. If they do not exist, use those as fallback instead of the\n-  // double quotes.\n-  if (str.indexOf(\"'\") !== -1) {\n-    // This invalidates the charCode and therefore can not be matched for\n-    // anymore.\n-    if (str.indexOf('\"') === -1) {\n-      singleQuote = -1;\n-    } else if (str.indexOf('`') === -1 && str.indexOf('${') === -1) {\n-      singleQuote = -2;\n-    }\n-    if (singleQuote !== 39) {\n-      escapeTest = strEscapeSequencesRegExpSingle;\n-      escapeReplace = strEscapeSequencesReplacerSingle;\n-    }\n-  }\n-\n-  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n-  if (str.length < 5000 && !escapeTest.test(str))\n-    return addQuotes(str, singleQuote);\n-  if (str.length > 100) {\n-    str = str.replace(escapeReplace, escapeFn);\n-    return addQuotes(str, singleQuote);\n-  }\n-\n-  let result = '';\n-  let last = 0;\n-  for (var i = 0; i < str.length; i++) {\n-    const point = str.charCodeAt(i);\n-    if (point === singleQuote || point === 92 || point < 32) {\n-      if (last === i) {\n-        result += meta[point];\n-      } else {\n-        result += `${str.slice(last, i)}${meta[point]}`;\n-      }\n-      last = i + 1;\n-    }\n-  }\n-  if (last === 0) {\n-    result = str;\n-  } else if (last !== i) {\n-    result += str.slice(last);\n-  }\n-  return addQuotes(result, singleQuote);\n-}\n-\n function tryStringify(arg) {\n   try {\n     return JSON.stringify(arg);\n@@ -384,946 +196,6 @@ function debuglog(set) {\n   return debugs[set];\n }\n \n-/**\n- * Echos the value of any input. Tries to print the value out\n- * in the best way possible given the different types.\n- *\n- * @param {any} value The value to print out.\n- * @param {Object} opts Optional options object that alters the output.\n- */\n-/* Legacy: value, showHidden, depth, colors */\n-function inspect(value, opts) {\n-  // Default options\n-  const ctx = {\n-    budget: {},\n-    indentationLvl: 0,\n-    seen: [],\n-    stylize: stylizeNoColor,\n-    showHidden: inspectDefaultOptions.showHidden,\n-    depth: inspectDefaultOptions.depth,\n-    colors: inspectDefaultOptions.colors,\n-    customInspect: inspectDefaultOptions.customInspect,\n-    showProxy: inspectDefaultOptions.showProxy,\n-    // TODO(BridgeAR): Deprecate `maxArrayLength` and replace it with\n-    // `maxEntries`.\n-    maxArrayLength: inspectDefaultOptions.maxArrayLength,\n-    breakLength: inspectDefaultOptions.breakLength,\n-    compact: inspectDefaultOptions.compact,\n-    sorted: inspectDefaultOptions.sorted\n-  };\n-  if (arguments.length > 1) {\n-    // Legacy...\n-    if (arguments.length > 2) {\n-      if (arguments[2] !== undefined) {\n-        ctx.depth = arguments[2];\n-      }\n-      if (arguments.length > 3 && arguments[3] !== undefined) {\n-        ctx.colors = arguments[3];\n-      }\n-    }\n-    // Set user-specified options\n-    if (typeof opts === 'boolean') {\n-      ctx.showHidden = opts;\n-    } else if (opts) {\n-      const optKeys = Object.keys(opts);\n-      for (var i = 0; i < optKeys.length; i++) {\n-        ctx[optKeys[i]] = opts[optKeys[i]];\n-      }\n-    }\n-  }\n-  if (ctx.colors) ctx.stylize = stylizeWithColor;\n-  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n-  return formatValue(ctx, value, ctx.depth);\n-}\n-inspect.custom = customInspectSymbol;\n-\n-Object.defineProperty(inspect, 'defaultOptions', {\n-  get() {\n-    return inspectDefaultOptions;\n-  },\n-  set(options) {\n-    if (options === null || typeof options !== 'object') {\n-      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);\n-    }\n-    return _extend(inspectDefaultOptions, options);\n-  }\n-});\n-\n-// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n-inspect.colors = Object.assign(Object.create(null), {\n-  'bold': [1, 22],\n-  'italic': [3, 23],\n-  'underline': [4, 24],\n-  'inverse': [7, 27],\n-  'white': [37, 39],\n-  'grey': [90, 39],\n-  'black': [30, 39],\n-  'blue': [34, 39],\n-  'cyan': [36, 39],\n-  'green': [32, 39],\n-  'magenta': [35, 39],\n-  'red': [31, 39],\n-  'yellow': [33, 39]\n-});\n-\n-// Don't use 'blue' not visible on cmd.exe\n-inspect.styles = Object.assign(Object.create(null), {\n-  'special': 'cyan',\n-  'number': 'yellow',\n-  'bigint': 'yellow',\n-  'boolean': 'yellow',\n-  'undefined': 'grey',\n-  'null': 'bold',\n-  'string': 'green',\n-  'symbol': 'green',\n-  'date': 'magenta',\n-  // \"name\": intentionally not styling\n-  'regexp': 'red'\n-});\n-\n-function stylizeWithColor(str, styleType) {\n-  const style = inspect.styles[styleType];\n-  if (style !== undefined) {\n-    const color = inspect.colors[style];\n-    return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\n-  }\n-  return str;\n-}\n-\n-function stylizeNoColor(str) {\n-  return str;\n-}\n-\n-// Return a new empty array to push in the results of the default formatter.\n-function getEmptyFormatArray() {\n-  return [];\n-}\n-\n-function getConstructorName(obj) {\n-  while (obj) {\n-    const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');\n-    if (descriptor !== undefined &&\n-        typeof descriptor.value === 'function' &&\n-        descriptor.value.name !== '') {\n-      return descriptor.value.name;\n-    }\n-\n-    obj = Object.getPrototypeOf(obj);\n-  }\n-\n-  return '';\n-}\n-\n-function getPrefix(constructor, tag, fallback) {\n-  if (constructor !== '') {\n-    if (tag !== '' && constructor !== tag) {\n-      return `${constructor} [${tag}] `;\n-    }\n-    return `${constructor} `;\n-  }\n-\n-  if (tag !== '')\n-    return `[${tag}] `;\n-\n-  if (fallback !== undefined)\n-    return `${fallback} `;\n-\n-  return '';\n-}\n-\n-const getBoxedValue = formatPrimitive.bind(null, stylizeNoColor);\n-\n-// Look up the keys of the object.\n-function getKeys(value, showHidden) {\n-  let keys;\n-  const symbols = Object.getOwnPropertySymbols(value);\n-  if (showHidden) {\n-    keys = Object.getOwnPropertyNames(value);\n-    if (symbols.length !== 0)\n-      keys.push(...symbols);\n-  } else {\n-    // This might throw if `value` is a Module Namespace Object from an\n-    // unevaluated module, but we don't want to perform the actual type\n-    // check because it's expensive.\n-    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n-    // and modify this logic as needed.\n-    try {\n-      keys = Object.keys(value);\n-    } catch (err) {\n-      if (types.isNativeError(err) &&\n-          err.name === 'ReferenceError' &&\n-          types.isModuleNamespaceObject(value)) {\n-        keys = Object.getOwnPropertyNames(value);\n-      } else {\n-        throw err;\n-      }\n-    }\n-    if (symbols.length !== 0) {\n-      keys.push(...symbols.filter((key) => propertyIsEnumerable(value, key)));\n-    }\n-  }\n-  return keys;\n-}\n-\n-function formatProxy(ctx, proxy, recurseTimes) {\n-  if (recurseTimes != null) {\n-    if (recurseTimes < 0)\n-      return ctx.stylize('Proxy [Array]', 'special');\n-    recurseTimes -= 1;\n-  }\n-  ctx.indentationLvl += 2;\n-  const res = [\n-    formatValue(ctx, proxy[0], recurseTimes),\n-    formatValue(ctx, proxy[1], recurseTimes)\n-  ];\n-  ctx.indentationLvl -= 2;\n-  const str = reduceToSingleString(ctx, res, '', ['[', ']']);\n-  return `Proxy ${str}`;\n-}\n-\n-function findTypedConstructor(value) {\n-  for (const [check, clazz] of [\n-    [isUint8Array, Uint8Array],\n-    [isUint8ClampedArray, Uint8ClampedArray],\n-    [isUint16Array, Uint16Array],\n-    [isUint32Array, Uint32Array],\n-    [isInt8Array, Int8Array],\n-    [isInt16Array, Int16Array],\n-    [isInt32Array, Int32Array],\n-    [isFloat32Array, Float32Array],\n-    [isFloat64Array, Float64Array],\n-    [isBigInt64Array, BigInt64Array],\n-    [isBigUint64Array, BigUint64Array]\n-  ]) {\n-    if (check(value)) {\n-      return clazz;\n-    }\n-  }\n-}\n-\n-function noPrototypeIterator(ctx, value, recurseTimes) {\n-  let newVal;\n-  // TODO: Create a Subclass in case there's no prototype and show\n-  // `null-prototype`.\n-  if (isSet(value)) {\n-    const clazz = Object.getPrototypeOf(value) || Set;\n-    newVal = new clazz(setValues(value));\n-  } else if (isMap(value)) {\n-    const clazz = Object.getPrototypeOf(value) || Map;\n-    newVal = new clazz(mapEntries(value));\n-  } else if (Array.isArray(value)) {\n-    const clazz = Object.getPrototypeOf(value) || Array;\n-    newVal = new clazz(value.length || 0);\n-  } else if (isTypedArray(value)) {\n-    const clazz = findTypedConstructor(value) || Uint8Array;\n-    newVal = new clazz(value);\n-  }\n-  if (newVal) {\n-    Object.defineProperties(newVal, Object.getOwnPropertyDescriptors(value));\n-    return formatValue(ctx, newVal, recurseTimes);\n-  }\n-}\n-\n-// Note: using `formatValue` directly requires the indentation level to be\n-// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n-// value afterwards again.\n-function formatValue(ctx, value, recurseTimes) {\n-  // Primitive types cannot have properties.\n-  if (typeof value !== 'object' && typeof value !== 'function') {\n-    return formatPrimitive(ctx.stylize, value, ctx);\n-  }\n-  if (value === null) {\n-    return ctx.stylize('null', 'null');\n-  }\n-\n-  if (ctx.stop !== undefined) {\n-    const name = getConstructorName(value) || value[Symbol.toStringTag];\n-    return ctx.stylize(`[${name || 'Object'}]`, 'special');\n-  }\n-\n-  if (ctx.showProxy) {\n-    const proxy = getProxyDetails(value);\n-    if (proxy !== undefined) {\n-      return formatProxy(ctx, proxy, recurseTimes);\n-    }\n-  }\n-\n-  // Provide a hook for user-specified inspect functions.\n-  // Check that value is an object with an inspect function on it.\n-  if (ctx.customInspect) {\n-    const maybeCustom = value[customInspectSymbol];\n-    if (typeof maybeCustom === 'function' &&\n-        // Filter out the util module, its inspect function is special.\n-        maybeCustom !== exports.inspect &&\n-        // Also filter out any prototype objects using the circular check.\n-        !(value.constructor && value.constructor.prototype === value)) {\n-      const ret = maybeCustom.call(value, recurseTimes, ctx);\n-\n-      // If the custom inspection method returned `this`, don't go into\n-      // infinite recursion.\n-      if (ret !== value) {\n-        if (typeof ret !== 'string') {\n-          return formatValue(ctx, ret, recurseTimes);\n-        }\n-        return ret;\n-      }\n-    }\n-  }\n-\n-  // Using an array here is actually better for the average case than using\n-  // a Set. `seen` will only check for the depth and will never grow too large.\n-  if (ctx.seen.indexOf(value) !== -1)\n-    return ctx.stylize('[Circular]', 'special');\n-\n-  return formatRaw(ctx, value, recurseTimes);\n-}\n-\n-function formatRaw(ctx, value, recurseTimes) {\n-  let keys;\n-\n-  const constructor = getConstructorName(value);\n-  let tag = value[Symbol.toStringTag];\n-  if (typeof tag !== 'string')\n-    tag = '';\n-  let base = '';\n-  let formatter = getEmptyFormatArray;\n-  let braces;\n-  let noIterator = true;\n-  let i = 0;\n-  let skip = false;\n-  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n-\n-  let extrasType = kObjectType;\n-\n-  // Iterators and the rest are split to reduce checks.\n-  if (value[Symbol.iterator]) {\n-    noIterator = false;\n-    if (Array.isArray(value)) {\n-      keys = getOwnNonIndexProperties(value, filter);\n-      // Only set the constructor for non ordinary (\"Array [...]\") arrays.\n-      const prefix = getPrefix(constructor, tag);\n-      braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];\n-      if (value.length === 0 && keys.length === 0)\n-        return `${braces[0]}]`;\n-      extrasType = kArrayExtrasType;\n-      formatter = formatArray;\n-    } else if (isSet(value)) {\n-      keys = getKeys(value, ctx.showHidden);\n-      const prefix = getPrefix(constructor, tag);\n-      if (value.size === 0 && keys.length === 0)\n-        return `${prefix}{}`;\n-      braces = [`${prefix}{`, '}'];\n-      formatter = formatSet;\n-    } else if (isMap(value)) {\n-      keys = getKeys(value, ctx.showHidden);\n-      const prefix = getPrefix(constructor, tag);\n-      if (value.size === 0 && keys.length === 0)\n-        return `${prefix}{}`;\n-      braces = [`${prefix}{`, '}'];\n-      formatter = formatMap;\n-    } else if (isTypedArray(value)) {\n-      keys = getOwnNonIndexProperties(value, filter);\n-      braces = [`${getPrefix(constructor, tag)}[`, ']'];\n-      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n-        return `${braces[0]}]`;\n-      formatter = formatTypedArray;\n-      extrasType = kArrayExtrasType;\n-    } else if (isMapIterator(value)) {\n-      keys = getKeys(value, ctx.showHidden);\n-      braces = [`[${tag}] {`, '}'];\n-      formatter = formatMapIterator;\n-    } else if (isSetIterator(value)) {\n-      keys = getKeys(value, ctx.showHidden);\n-      braces = [`[${tag}] {`, '}'];\n-      formatter = formatSetIterator;\n-    } else {\n-      noIterator = true;\n-    }\n-  }\n-  if (noIterator) {\n-    keys = getKeys(value, ctx.showHidden);\n-    braces = ['{', '}'];\n-    if (constructor === 'Object') {\n-      if (isArgumentsObject(value)) {\n-        if (keys.length === 0)\n-          return '[Arguments] {}';\n-        braces[0] = '[Arguments] {';\n-      } else if (tag !== '') {\n-        braces[0] = `${getPrefix(constructor, tag)}{`;\n-        if (keys.length === 0) {\n-          return `${braces[0]}}`;\n-        }\n-      } else if (keys.length === 0) {\n-        return '{}';\n-      }\n-    } else if (typeof value === 'function') {\n-      const type = constructor || tag || 'Function';\n-      const name = `${type}${value.name ? `: ${value.name}` : ''}`;\n-      if (keys.length === 0)\n-        return ctx.stylize(`[${name}]`, 'special');\n-      base = `[${name}]`;\n-    } else if (isRegExp(value)) {\n-      // Make RegExps say that they are RegExps\n-      if (keys.length === 0 || recurseTimes < 0)\n-        return ctx.stylize(regExpToString(value), 'regexp');\n-      base = `${regExpToString(value)}`;\n-    } else if (isDate(value)) {\n-      // Make dates with properties first say the date\n-      if (keys.length === 0) {\n-        if (Number.isNaN(dateGetTime(value)))\n-          return ctx.stylize(String(value), 'date');\n-        return ctx.stylize(dateToISOString(value), 'date');\n-      }\n-      base = dateToISOString(value);\n-    } else if (isError(value)) {\n-      // Make error with message first say the error.\n-      base = formatError(value);\n-      // Wrap the error in brackets in case it has no stack trace.\n-      const stackStart = base.indexOf('\\n    at');\n-      if (stackStart === -1) {\n-        base = `[${base}]`;\n-      }\n-      // The message and the stack have to be indented as well!\n-      if (ctx.indentationLvl !== 0) {\n-        const indentation = ' '.repeat(ctx.indentationLvl);\n-        base = formatError(value).replace(/\\n/g, `\\n${indentation}`);\n-      }\n-      if (keys.length === 0)\n-        return base;\n-\n-      if (ctx.compact === false && stackStart !== -1) {\n-        braces[0] += `${base.slice(stackStart)}`;\n-        base = `[${base.slice(0, stackStart)}]`;\n-      }\n-    } else if (isAnyArrayBuffer(value)) {\n-      let prefix = getPrefix(constructor, tag);\n-      if (prefix === '') {\n-        prefix = isArrayBuffer(value) ? 'ArrayBuffer ' : 'SharedArrayBuffer ';\n-      }\n-      // Fast path for ArrayBuffer and SharedArrayBuffer.\n-      // Can't do the same for DataView because it has a non-primitive\n-      // .buffer property that we need to recurse for.\n-      if (keys.length === 0)\n-        return prefix +\n-              `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;\n-      braces[0] = `${prefix}{`;\n-      keys.unshift('byteLength');\n-    } else if (isDataView(value)) {\n-      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`;\n-      // .buffer goes last, it's not a primitive like the others.\n-      keys.unshift('byteLength', 'byteOffset', 'buffer');\n-    } else if (isPromise(value)) {\n-      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;\n-      formatter = formatPromise;\n-    } else if (isWeakSet(value)) {\n-      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;\n-      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n-    } else if (isWeakMap(value)) {\n-      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;\n-      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n-    } else if (types.isModuleNamespaceObject(value)) {\n-      braces[0] = `[${tag}] {`;\n-      formatter = formatNamespaceObject;\n-      skip = true;\n-    } else if (isBoxedPrimitive(value)) {\n-      let type;\n-      if (isNumberObject(value)) {\n-        base = `[Number: ${getBoxedValue(numberValueOf(value))}]`;\n-        type = 'number';\n-      } else if (isStringObject(value)) {\n-        base = `[String: ${getBoxedValue(stringValueOf(value), ctx)}]`;\n-        type = 'string';\n-        // For boxed Strings, we have to remove the 0-n indexed entries,\n-        // since they just noisy up the output and are redundant\n-        // Make boxed primitive Strings look like such\n-        keys = keys.slice(value.length);\n-      } else if (isBooleanObject(value)) {\n-        base = `[Boolean: ${getBoxedValue(booleanValueOf(value))}]`;\n-        type = 'boolean';\n-      } else if (isBigIntObject(value)) {\n-        base = `[BigInt: ${getBoxedValue(bigIntValueOf(value))}]`;\n-        type = 'bigint';\n-      } else {\n-        base = `[Symbol: ${getBoxedValue(symbolValueOf(value))}]`;\n-        type = 'symbol';\n-      }\n-      if (keys.length === 0) {\n-        return ctx.stylize(base, type);\n-      }\n-    } else {\n-      // The input prototype got manipulated. Special handle these. We have to\n-      // rebuild the information so we are able to display everything.\n-      const specialIterator = noPrototypeIterator(ctx, value, recurseTimes);\n-      if (specialIterator) {\n-        return specialIterator;\n-      }\n-      if (isMapIterator(value)) {\n-        braces = [`[${tag || 'Map Iterator'}] {`, '}'];\n-        formatter = formatMapIterator;\n-      } else if (isSetIterator(value)) {\n-        braces = [`[${tag || 'Set Iterator'}] {`, '}'];\n-        formatter = formatSetIterator;\n-      // Handle other regular objects again.\n-      } else if (keys.length === 0) {\n-        if (isExternal(value))\n-          return ctx.stylize('[External]', 'special');\n-        return `${getPrefix(constructor, tag)}{}`;\n-      } else {\n-        braces[0] = `${getPrefix(constructor, tag)}{`;\n-      }\n-    }\n-  }\n-\n-  if (recurseTimes != null) {\n-    if (recurseTimes < 0)\n-      return ctx.stylize(`[${constructor || tag || 'Object'}]`, 'special');\n-    recurseTimes -= 1;\n-  }\n-\n-  ctx.seen.push(value);\n-  let output;\n-  const indentationLvl = ctx.indentationLvl;\n-  try {\n-    output = formatter(ctx, value, recurseTimes, keys);\n-    if (skip === false) {\n-      for (i = 0; i < keys.length; i++) {\n-        output.push(\n-          formatProperty(ctx, value, recurseTimes, keys[i], extrasType));\n-      }\n-    }\n-  } catch (err) {\n-    return handleMaxCallStackSize(ctx, err, constructor, tag, indentationLvl);\n-  }\n-  ctx.seen.pop();\n-\n-  if (ctx.sorted) {\n-    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\n-    if (extrasType === kObjectType) {\n-      output = output.sort(comparator);\n-    } else if (keys.length > 1) {\n-      const sorted = output.slice(output.length - keys.length).sort(comparator);\n-      output.splice(output.length - keys.length, keys.length, ...sorted);\n-    }\n-  }\n-\n-  const res = reduceToSingleString(ctx, output, base, braces);\n-  const budget = ctx.budget[ctx.indentationLvl] || 0;\n-  const newLength = budget + res.length;\n-  ctx.budget[ctx.indentationLvl] = newLength;\n-  // If any indentationLvl exceeds this limit, limit further inspecting to the\n-  // minimum. Otherwise the recursive algorithm might continue inspecting the\n-  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n-  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n-  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n-  // This limit also makes sure that huge objects don't block the event loop\n-  // significantly.\n-  if (newLength > 2 ** 27) {\n-    ctx.stop = true;\n-  }\n-  return res;\n-}\n-\n-function handleMaxCallStackSize(ctx, err, constructor, tag, indentationLvl) {\n-  if (errors.isStackOverflowError(err)) {\n-    ctx.seen.pop();\n-    ctx.indentationLvl = indentationLvl;\n-    return ctx.stylize(\n-      `[${constructor || tag || 'Object'}: Inspection interrupted ` +\n-        'prematurely. Maximum call stack size exceeded.]',\n-      'special'\n-    );\n-  }\n-  throw err;\n-}\n-\n-function formatNumber(fn, value) {\n-  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.\n-  if (Object.is(value, -0))\n-    return fn('-0', 'number');\n-  return fn(`${value}`, 'number');\n-}\n-\n-function formatBigInt(fn, value) {\n-  return fn(`${value}n`, 'bigint');\n-}\n-\n-function formatPrimitive(fn, value, ctx) {\n-  if (typeof value === 'string') {\n-    if (ctx.compact === false &&\n-      ctx.indentationLvl + value.length > ctx.breakLength &&\n-      value.length > MIN_LINE_LENGTH) {\n-      // eslint-disable-next-line max-len\n-      const minLineLength = Math.max(ctx.breakLength - ctx.indentationLvl, MIN_LINE_LENGTH);\n-      // eslint-disable-next-line max-len\n-      const averageLineLength = Math.ceil(value.length / Math.ceil(value.length / minLineLength));\n-      const divisor = Math.max(averageLineLength, MIN_LINE_LENGTH);\n-      let res = '';\n-      if (readableRegExps[divisor] === undefined) {\n-        // Build a new RegExp that naturally breaks text into multiple lines.\n-        //\n-        // Rules\n-        // 1. Greedy match all text up the max line length that ends with a\n-        //    whitespace or the end of the string.\n-        // 2. If none matches, non-greedy match any text up to a whitespace or\n-        //    the end of the string.\n-        //\n-        // eslint-disable-next-line max-len, node-core/no-unescaped-regexp-dot\n-        readableRegExps[divisor] = new RegExp(`(.|\\\\n){1,${divisor}}(\\\\s|$)|(\\\\n|.)+?(\\\\s|$)`, 'gm');\n-      }\n-      const matches = value.match(readableRegExps[divisor]);\n-      if (matches.length > 1) {\n-        const indent = ' '.repeat(ctx.indentationLvl);\n-        res += `${fn(strEscape(matches[0]), 'string')} +\\n`;\n-        for (var i = 1; i < matches.length - 1; i++) {\n-          res += `${indent}  ${fn(strEscape(matches[i]), 'string')} +\\n`;\n-        }\n-        res += `${indent}  ${fn(strEscape(matches[i]), 'string')}`;\n-        return res;\n-      }\n-    }\n-    return fn(strEscape(value), 'string');\n-  }\n-  if (typeof value === 'number')\n-    return formatNumber(fn, value);\n-  // eslint-disable-next-line valid-typeof\n-  if (typeof value === 'bigint')\n-    return formatBigInt(fn, value);\n-  if (typeof value === 'boolean')\n-    return fn(`${value}`, 'boolean');\n-  if (typeof value === 'undefined')\n-    return fn('undefined', 'undefined');\n-  // es6 symbol primitive\n-  return fn(value.toString(), 'symbol');\n-}\n-\n-function formatError(value) {\n-  return value.stack || errorToString(value);\n-}\n-\n-function formatNamespaceObject(ctx, value, recurseTimes, keys) {\n-  const len = keys.length;\n-  const output = new Array(len);\n-  for (var i = 0; i < len; i++) {\n-    try {\n-      output[i] = formatProperty(ctx, value, recurseTimes, keys[i],\n-                                 kObjectType);\n-    } catch (err) {\n-      if (!(types.isNativeError(err) && err.name === 'ReferenceError')) {\n-        throw err;\n-      }\n-      // Use the existing functionality. This makes sure the indentation and\n-      // line breaks are always correct. Otherwise it is very difficult to keep\n-      // this aligned, even though this is a hacky way of dealing with this.\n-      const tmp = { [keys[i]]: '' };\n-      output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);\n-      const pos = output[i].lastIndexOf(' ');\n-      // We have to find the last whitespace and have to replace that value as\n-      // it will be visualized as a regular string.\n-      output[i] = output[i].slice(0, pos + 1) +\n-                  ctx.stylize('<uninitialized>', 'special');\n-    }\n-  }\n-  return output;\n-}\n-\n-// The array is sparse and/or has extra keys\n-function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {\n-  const keys = Object.keys(value);\n-  let index = i;\n-  for (; i < keys.length && output.length < maxLength; i++) {\n-    const key = keys[i];\n-    const tmp = +key;\n-    // Arrays can only have up to 2^32 - 1 entries\n-    if (tmp > 2 ** 32 - 2) {\n-      break;\n-    }\n-    if (`${index}` !== key) {\n-      if (!numberRegExp.test(key)) {\n-        break;\n-      }\n-      const emptyItems = tmp - index;\n-      const ending = emptyItems > 1 ? 's' : '';\n-      const message = `<${emptyItems} empty item${ending}>`;\n-      output.push(ctx.stylize(message, 'undefined'));\n-      index = tmp;\n-      if (output.length === maxLength) {\n-        break;\n-      }\n-    }\n-    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));\n-    index++;\n-  }\n-  const remaining = value.length - index;\n-  if (output.length !== maxLength) {\n-    if (remaining > 0) {\n-      const ending = remaining > 1 ? 's' : '';\n-      const message = `<${remaining} empty item${ending}>`;\n-      output.push(ctx.stylize(message, 'undefined'));\n-    }\n-  } else if (remaining > 0) {\n-    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n-  }\n-  return output;\n-}\n-\n-function formatArray(ctx, value, recurseTimes) {\n-  const valLen = value.length;\n-  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);\n-\n-  const remaining = valLen - len;\n-  const output = [];\n-  for (var i = 0; i < len; i++) {\n-    // Special handle sparse arrays.\n-    if (!hasOwnProperty(value, i)) {\n-      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);\n-    }\n-    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));\n-  }\n-  if (remaining > 0)\n-    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n-  return output;\n-}\n-\n-function formatTypedArray(ctx, value, recurseTimes) {\n-  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);\n-  const remaining = value.length - maxLength;\n-  const output = new Array(maxLength);\n-  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\n-    formatNumber :\n-    formatBigInt;\n-  for (var i = 0; i < maxLength; ++i)\n-    output[i] = elementFormatter(ctx.stylize, value[i]);\n-  if (remaining > 0) {\n-    output[i] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n-  }\n-  if (ctx.showHidden) {\n-    // .buffer goes last, it's not a primitive like the others.\n-    ctx.indentationLvl += 2;\n-    for (const key of [\n-      'BYTES_PER_ELEMENT',\n-      'length',\n-      'byteLength',\n-      'byteOffset',\n-      'buffer'\n-    ]) {\n-      const str = formatValue(ctx, value[key], recurseTimes);\n-      output.push(`[${key}]: ${str}`);\n-    }\n-    ctx.indentationLvl -= 2;\n-  }\n-  return output;\n-}\n-\n-function formatSet(ctx, value, recurseTimes) {\n-  const output = [];\n-  ctx.indentationLvl += 2;\n-  for (const v of value) {\n-    output.push(formatValue(ctx, v, recurseTimes));\n-  }\n-  ctx.indentationLvl -= 2;\n-  // With `showHidden`, `length` will display as a hidden property for\n-  // arrays. For consistency's sake, do the same for `size`, even though this\n-  // property isn't selected by Object.getOwnPropertyNames().\n-  if (ctx.showHidden)\n-    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);\n-  return output;\n-}\n-\n-function formatMap(ctx, value, recurseTimes) {\n-  const output = [];\n-  ctx.indentationLvl += 2;\n-  for (const [k, v] of value) {\n-    output.push(`${formatValue(ctx, k, recurseTimes)} => ` +\n-                formatValue(ctx, v, recurseTimes));\n-  }\n-  ctx.indentationLvl -= 2;\n-  // See comment in formatSet\n-  if (ctx.showHidden)\n-    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);\n-  return output;\n-}\n-\n-function formatSetIterInner(ctx, recurseTimes, entries, state) {\n-  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);\n-  const maxLength = Math.min(maxArrayLength, entries.length);\n-  let output = new Array(maxLength);\n-  ctx.indentationLvl += 2;\n-  for (var i = 0; i < maxLength; i++) {\n-    output[i] = formatValue(ctx, entries[i], recurseTimes);\n-  }\n-  ctx.indentationLvl -= 2;\n-  if (state === kWeak) {\n-    // Sort all entries to have a halfway reliable output (if more entries than\n-    // retrieved ones exist, we can not reliably return the same output).\n-    output = output.sort();\n-  }\n-  const remaining = entries.length - maxLength;\n-  if (remaining > 0) {\n-    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n-  }\n-  return output;\n-}\n-\n-function formatMapIterInner(ctx, recurseTimes, entries, state) {\n-  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);\n-  // Entries exist as [key1, val1, key2, val2, ...]\n-  const len = entries.length / 2;\n-  const remaining = len - maxArrayLength;\n-  const maxLength = Math.min(maxArrayLength, len);\n-  let output = new Array(maxLength);\n-  let start = '';\n-  let end = '';\n-  let middle = ' => ';\n-  let i = 0;\n-  if (state === kMapEntries) {\n-    start = '[ ';\n-    end = ' ]';\n-    middle = ', ';\n-  }\n-  ctx.indentationLvl += 2;\n-  for (; i < maxLength; i++) {\n-    const pos = i * 2;\n-    output[i] = `${start}${formatValue(ctx, entries[pos], recurseTimes)}` +\n-      `${middle}${formatValue(ctx, entries[pos + 1], recurseTimes)}${end}`;\n-  }\n-  ctx.indentationLvl -= 2;\n-  if (state === kWeak) {\n-    // Sort all entries to have a halfway reliable output (if more entries\n-    // than retrieved ones exist, we can not reliably return the same output).\n-    output = output.sort();\n-  }\n-  if (remaining > 0) {\n-    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n-  }\n-  return output;\n-}\n-\n-function formatWeakCollection(ctx) {\n-  return [ctx.stylize('<items unknown>', 'special')];\n-}\n-\n-function formatWeakSet(ctx, value, recurseTimes) {\n-  const entries = previewEntries(value);\n-  return formatSetIterInner(ctx, recurseTimes, entries, kWeak);\n-}\n-\n-function formatWeakMap(ctx, value, recurseTimes) {\n-  const entries = previewEntries(value);\n-  return formatMapIterInner(ctx, recurseTimes, entries, kWeak);\n-}\n-\n-function formatSetIterator(ctx, value, recurseTimes) {\n-  const entries = previewEntries(value);\n-  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);\n-}\n-\n-function formatMapIterator(ctx, value, recurseTimes) {\n-  const [entries, isKeyValue] = previewEntries(value, true);\n-  if (isKeyValue) {\n-    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);\n-  }\n-\n-  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);\n-}\n-\n-function formatPromise(ctx, value, recurseTimes) {\n-  let output;\n-  const [state, result] = getPromiseDetails(value);\n-  if (state === kPending) {\n-    output = [ctx.stylize('<pending>', 'special')];\n-  } else {\n-    // Using `formatValue` is correct here without the need to fix the\n-    // indentation level.\n-    ctx.indentationLvl += 2;\n-    const str = formatValue(ctx, result, recurseTimes);\n-    ctx.indentationLvl -= 2;\n-    output = [\n-      state === kRejected ?\n-        `${ctx.stylize('<rejected>', 'special')} ${str}` :\n-        str\n-    ];\n-  }\n-  return output;\n-}\n-\n-function formatProperty(ctx, value, recurseTimes, key, type) {\n-  let name, str;\n-  let extra = ' ';\n-  const desc = Object.getOwnPropertyDescriptor(value, key) ||\n-    { value: value[key], enumerable: true };\n-  if (desc.value !== undefined) {\n-    const diff = (type !== kObjectType || ctx.compact === false) ? 2 : 3;\n-    ctx.indentationLvl += diff;\n-    str = formatValue(ctx, desc.value, recurseTimes);\n-    if (diff === 3) {\n-      const len = ctx.colors ? removeColors(str).length : str.length;\n-      if (ctx.breakLength < len) {\n-        extra = `\\n${' '.repeat(ctx.indentationLvl)}`;\n-      }\n-    }\n-    ctx.indentationLvl -= diff;\n-  } else if (desc.get !== undefined) {\n-    if (desc.set !== undefined) {\n-      str = ctx.stylize('[Getter/Setter]', 'special');\n-    } else {\n-      str = ctx.stylize('[Getter]', 'special');\n-    }\n-  } else if (desc.set !== undefined) {\n-    str = ctx.stylize('[Setter]', 'special');\n-  } else {\n-    str = ctx.stylize('undefined', 'undefined');\n-  }\n-  if (type === kArrayType) {\n-    return str;\n-  }\n-  if (typeof key === 'symbol') {\n-    const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);\n-    name = `[${ctx.stylize(tmp, 'symbol')}]`;\n-  } else if (desc.enumerable === false) {\n-    name = `[${key.replace(strEscapeSequencesReplacer, escapeFn)}]`;\n-  } else if (keyStrRegExp.test(key)) {\n-    name = ctx.stylize(key, 'name');\n-  } else {\n-    name = ctx.stylize(strEscape(key), 'string');\n-  }\n-  return `${name}:${extra}${str}`;\n-}\n-\n-function reduceToSingleString(ctx, output, base, braces) {\n-  const breakLength = ctx.breakLength;\n-  let i = 0;\n-  if (ctx.compact === false) {\n-    const indentation = ' '.repeat(ctx.indentationLvl);\n-    let res = `${base ? `${base} ` : ''}${braces[0]}\\n${indentation}  `;\n-    for (; i < output.length - 1; i++) {\n-      res += `${output[i]},\\n${indentation}  `;\n-    }\n-    res += `${output[i]}\\n${indentation}${braces[1]}`;\n-    return res;\n-  }\n-  if (output.length * 2 <= breakLength) {\n-    let length = 0;\n-    for (; i < output.length && length <= breakLength; i++) {\n-      if (ctx.colors) {\n-        length += removeColors(output[i]).length + 1;\n-      } else {\n-        length += output[i].length + 1;\n-      }\n-    }\n-    if (length <= breakLength)\n-      return `${braces[0]}${base ? ` ${base}` : ''} ${join(output, ', ')} ` +\n-        braces[1];\n-  }\n-  // If the opening \"brace\" is too large, like in the case of \"Set {\",\n-  // we need to force the first item to be on the next line or the\n-  // items will not line up correctly.\n-  const indentation = ' '.repeat(ctx.indentationLvl);\n-  const ln = base === '' && braces[0].length === 1 ?\n-    ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\n-  const str = join(output, `,\\n${indentation}  `);\n-  return `${braces[0]}${ln}${str} ${braces[1]}`;\n-}\n-\n function isBoolean(arg) {\n   return typeof arg === 'boolean';\n }"
        },
        {
            "sha": "e1adf8cd12e30b1f70a33b61a6ceb5a9f1f46566",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/c600a3ce1c7761761a34841730e133db02fadb4d/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/c600a3ce1c7761761a34841730e133db02fadb4d/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=c600a3ce1c7761761a34841730e133db02fadb4d",
            "patch": "@@ -162,6 +162,7 @@\n       'lib/internal/url.js',\n       'lib/internal/util.js',\n       'lib/internal/util/comparisons.js',\n+      'lib/internal/util/inspect.js',\n       'lib/internal/util/inspector.js',\n       'lib/internal/util/types.js',\n       'lib/internal/http2/core.js',"
        },
        {
            "sha": "e2e5075f6b2b481d52847c21dc6c6bc33f44c4fb",
            "filename": "test/parallel/test-bootstrap-modules.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/c600a3ce1c7761761a34841730e133db02fadb4d/test%2Fparallel%2Ftest-bootstrap-modules.js",
            "raw_url": "https://github.com/nodejs/node/raw/c600a3ce1c7761761a34841730e133db02fadb4d/test%2Fparallel%2Ftest-bootstrap-modules.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-bootstrap-modules.js?ref=c600a3ce1c7761761a34841730e133db02fadb4d",
            "patch": "@@ -11,4 +11,4 @@ const list = process.moduleLoadList.slice();\n \n const assert = require('assert');\n \n-assert(list.length <= 75, list);\n+assert(list.length <= 76, list);"
        }
    ],
    "stats": {
        "total": 2288,
        "additions": 1158,
        "deletions": 1130
    }
}