{
    "author": "sam-github",
    "message": "src: in-source comments and minor TLS cleanups\n\nRenamed some internal C++ methods and properties for consistency, and\ncommented SSL I/O.\n\n- Rename waiting_new_session_ after is_waiting_new_session(), instead of\n  using reverse naming (new_session_wait_), and change \"waiting\" to\n  \"awaiting\".\n- Make TLSWrap::ClearIn() return void, the value is never used.\n- Fix a getTicketKeys() cut-n-paste error. Since it doesn't use the\n  arguments, remove them from the js wrapper.\n- Remove call of setTicketKeys(getTicketKeys()), its a no-op.\n\nPR-URL: https://github.com/nodejs/node/pull/25713\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>",
    "sha": "46c5c3388d24615d8bcd887bb366d4171e99fdee",
    "files": [
        {
            "sha": "816fcb689607c7345eee5db8886177fd5bdc28e8",
            "filename": "lib/_tls_wrap.js",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/46c5c3388d24615d8bcd887bb366d4171e99fdee/lib%2F_tls_wrap.js",
            "raw_url": "https://github.com/nodejs/node/raw/46c5c3388d24615d8bcd887bb366d4171e99fdee/lib%2F_tls_wrap.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_tls_wrap.js?ref=46c5c3388d24615d8bcd887bb366d4171e99fdee",
            "patch": "@@ -1003,8 +1003,6 @@ Server.prototype.setSecureContext = function(options) {\n   if (options.ticketKeys) {\n     this.ticketKeys = options.ticketKeys;\n     this.setTicketKeys(this.ticketKeys);\n-  } else {\n-    this.setTicketKeys(this.getTicketKeys());\n   }\n };\n \n@@ -1021,8 +1019,8 @@ Server.prototype._setServerData = function(data) {\n };\n \n \n-Server.prototype.getTicketKeys = function getTicketKeys(keys) {\n-  return this._sharedCreds.context.getTicketKeys(keys);\n+Server.prototype.getTicketKeys = function getTicketKeys() {\n+  return this._sharedCreds.context.getTicketKeys();\n };\n \n "
        },
        {
            "sha": "0b6c6c8582887ad5f6438de92b41087d68f59ec1",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=46c5c3388d24615d8bcd887bb366d4171e99fdee",
            "patch": "@@ -1532,7 +1532,7 @@ int SSLWrap<Base>::NewSessionCallback(SSL* s, SSL_SESSION* sess) {\n       reinterpret_cast<const char*>(session_id_data),\n       session_id_length).ToLocalChecked();\n   Local<Value> argv[] = { session_id, session };\n-  w->new_session_wait_ = true;\n+  w->awaiting_new_session_ = true;\n   w->MakeCallback(env->onnewsession_string(), arraysize(argv), argv);\n \n   return 0;\n@@ -2128,6 +2128,7 @@ void SSLWrap<Base>::Renegotiate(const FunctionCallbackInfo<Value>& args) {\n \n   ClearErrorOnReturn clear_error_on_return;\n \n+  // XXX(sam) Return/throw an error, don't discard the SSL error reason.\n   bool yes = SSL_renegotiate(w->ssl_.get()) == 1;\n   args.GetReturnValue().Set(yes);\n }\n@@ -2161,7 +2162,7 @@ template <class Base>\n void SSLWrap<Base>::NewSessionDone(const FunctionCallbackInfo<Value>& args) {\n   Base* w;\n   ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());\n-  w->new_session_wait_ = false;\n+  w->awaiting_new_session_ = false;\n   w->NewSessionDoneCb();\n }\n "
        },
        {
            "sha": "32b61882593900f3246b2e67cb3b46d25a53ac35",
            "filename": "src/node_crypto.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Fnode_crypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Fnode_crypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.h?ref=46c5c3388d24615d8bcd887bb366d4171e99fdee",
            "patch": "@@ -218,7 +218,7 @@ class SSLWrap {\n         kind_(kind),\n         next_sess_(nullptr),\n         session_callbacks_(false),\n-        new_session_wait_(false),\n+        awaiting_new_session_(false),\n         cert_cb_(nullptr),\n         cert_cb_arg_(nullptr),\n         cert_cb_running_(false) {\n@@ -234,7 +234,7 @@ class SSLWrap {\n   inline void enable_session_callbacks() { session_callbacks_ = true; }\n   inline bool is_server() const { return kind_ == kServer; }\n   inline bool is_client() const { return kind_ == kClient; }\n-  inline bool is_waiting_new_session() const { return new_session_wait_; }\n+  inline bool is_awaiting_new_session() const { return awaiting_new_session_; }\n   inline bool is_waiting_cert_cb() const { return cert_cb_ != nullptr; }\n \n  protected:\n@@ -325,7 +325,7 @@ class SSLWrap {\n   SSLSessionPointer next_sess_;\n   SSLPointer ssl_;\n   bool session_callbacks_;\n-  bool new_session_wait_;\n+  bool awaiting_new_session_;\n \n   // SSL_set_cert_cb\n   CertCb cert_cb_;"
        },
        {
            "sha": "b7f1d4f169edfe354f4e836d5a395df4ba22be0b",
            "filename": "src/node_crypto_bio.h",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Fnode_crypto_bio.h",
            "raw_url": "https://github.com/nodejs/node/raw/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Fnode_crypto_bio.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto_bio.h?ref=46c5c3388d24615d8bcd887bb366d4171e99fdee",
            "patch": "@@ -34,8 +34,8 @@ namespace node {\n namespace crypto {\n \n // This class represents buffers for OpenSSL I/O, implemented as a singly-linked\n-// list of chunks. It can be used both for writing data from Node to OpenSSL\n-// and back, but only one direction per instance.\n+// list of chunks. It can be used either for writing data from Node to OpenSSL,\n+// or for reading data back, but not both.\n // The structure is only accessed, and owned by, the OpenSSL BIOPointer\n // (a.k.a. std::unique_ptr<BIO>).\n class NodeBIO : public MemoryRetainer {\n@@ -80,11 +80,12 @@ class NodeBIO : public MemoryRetainer {\n   // Put `len` bytes from `data` into buffer\n   void Write(const char* data, size_t size);\n \n-  // Return pointer to internal data and amount of\n-  // contiguous data available for future writes\n+  // Return pointer to contiguous block of reserved data and the size available\n+  // for future writes. Call Commit() once the write is complete.\n   char* PeekWritable(size_t* size);\n \n-  // Commit reserved data\n+  // Specify how much data was written into the block returned by\n+  // PeekWritable().\n   void Commit(size_t size);\n \n "
        },
        {
            "sha": "48f49771fdf401128fdd1c0efbc6adea4ac5f9e8",
            "filename": "src/node_crypto_clienthello.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Fnode_crypto_clienthello.h",
            "raw_url": "https://github.com/nodejs/node/raw/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Fnode_crypto_clienthello.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto_clienthello.h?ref=46c5c3388d24615d8bcd887bb366d4171e99fdee",
            "patch": "@@ -30,6 +30,9 @@\n namespace node {\n namespace crypto {\n \n+// Parse the client hello so we can do async session resumption. OpenSSL's\n+// session resumption uses synchronous callbacks, see SSL_CTX_sess_set_get_cb\n+// and get_session_cb.\n class ClientHelloParser {\n  public:\n   inline ClientHelloParser();"
        },
        {
            "sha": "627bcf5949c545ed7a94c5c8eb322313830d0bc2",
            "filename": "src/stream_wrap.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Fstream_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Fstream_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_wrap.cc?ref=46c5c3388d24615d8bcd887bb366d4171e99fdee",
            "patch": "@@ -232,7 +232,7 @@ void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) {\n     type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream()));\n   }\n \n-  // We should not be getting this callback if someone as already called\n+  // We should not be getting this callback if someone has already called\n   // uv_close() on the handle.\n   CHECK_EQ(persistent().IsEmpty(), false);\n "
        },
        {
            "sha": "e467e2d167f6287078b0e98184c4460d482147b9",
            "filename": "src/tls_wrap.cc",
            "status": "modified",
            "additions": 43,
            "deletions": 17,
            "changes": 60,
            "blob_url": "https://github.com/nodejs/node/blob/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Ftls_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Ftls_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.cc?ref=46c5c3388d24615d8bcd887bb366d4171e99fdee",
            "patch": "@@ -115,6 +115,11 @@ void TLSWrap::InitSSL() {\n #endif  // SSL_MODE_RELEASE_BUFFERS\n \n   SSL_set_app_data(ssl_.get(), this);\n+  // Using InfoCallback isn't how we are supposed to check handshake progress:\n+  //   https://github.com/openssl/openssl/issues/7199#issuecomment-420915993\n+  //\n+  // Note on when this gets called on various openssl versions:\n+  //   https://github.com/openssl/openssl/issues/7199#issuecomment-420670544\n   SSL_set_info_callback(ssl_.get(), SSLInfoCallback);\n \n   if (is_server()) {\n@@ -193,6 +198,9 @@ void TLSWrap::Start(const FunctionCallbackInfo<Value>& args) {\n \n   // Send ClientHello handshake\n   CHECK(wrap->is_client());\n+  // Seems odd to read when when we want to send, but SSL_read() triggers a\n+  // handshake if a session isn't established, and handshake will cause\n+  // encrypted data to become available for output.\n   wrap->ClearOut();\n   wrap->EncOut();\n }\n@@ -247,7 +255,7 @@ void TLSWrap::EncOut() {\n     return;\n \n   // Wait for `newSession` callback to be invoked\n-  if (is_waiting_new_session())\n+  if (is_awaiting_new_session())\n     return;\n \n   // Split-off queue\n@@ -257,7 +265,7 @@ void TLSWrap::EncOut() {\n   if (ssl_ == nullptr)\n     return;\n \n-  // No data to write\n+  // No encrypted output ready to write to the underlying stream.\n   if (BIO_pending(enc_out_) == 0) {\n     if (pending_cleartext_input_.empty())\n       InvokeQueued(0);\n@@ -479,13 +487,13 @@ void TLSWrap::ClearOut() {\n }\n \n \n-bool TLSWrap::ClearIn() {\n+void TLSWrap::ClearIn() {\n   // Ignore cycling data if ClientHello wasn't yet parsed\n   if (!hello_parser_.IsEnded())\n-    return false;\n+    return;\n \n   if (ssl_ == nullptr)\n-    return false;\n+    return;\n \n   std::vector<uv_buf_t> buffers;\n   buffers.swap(pending_cleartext_input_);\n@@ -505,8 +513,9 @@ bool TLSWrap::ClearIn() {\n \n   // All written\n   if (i == buffers.size()) {\n+    // We wrote all the buffers, so no writes failed (written < 0 on failure).\n     CHECK_GE(written, 0);\n-    return true;\n+    return;\n   }\n \n   // Error or partial write\n@@ -518,6 +527,8 @@ bool TLSWrap::ClearIn() {\n   Local<Value> arg = GetSSLError(written, &err, &error_str);\n   if (!arg.IsEmpty()) {\n     write_callback_scheduled_ = true;\n+    // XXX(sam) Should forward an error object with .code/.function/.etc, if\n+    // possible.\n     InvokeQueued(UV_EPROTO, error_str.c_str());\n   } else {\n     // Push back the not-yet-written pending buffers into their queue.\n@@ -528,7 +539,7 @@ bool TLSWrap::ClearIn() {\n                                     buffers.end());\n   }\n \n-  return false;\n+  return;\n }\n \n \n@@ -584,6 +595,7 @@ void TLSWrap::ClearError() {\n }\n \n \n+// Called by StreamBase::Write() to request async write of clear text into SSL.\n int TLSWrap::DoWrite(WriteWrap* w,\n                      uv_buf_t* bufs,\n                      size_t count,\n@@ -597,18 +609,26 @@ int TLSWrap::DoWrite(WriteWrap* w,\n   }\n \n   bool empty = true;\n-\n-  // Empty writes should not go through encryption process\n   size_t i;\n-  for (i = 0; i < count; i++)\n+  for (i = 0; i < count; i++) {\n     if (bufs[i].len > 0) {\n       empty = false;\n       break;\n     }\n+  }\n+\n+  // We want to trigger a Write() on the underlying stream to drive the stream\n+  // system, but don't want to encrypt empty buffers into a TLS frame, so see\n+  // if we can find something to Write().\n+  // First, call ClearOut(). It does an SSL_read(), which might cause handshake\n+  // or other internal messages to be encrypted. If it does, write them later\n+  // with EncOut().\n+  // If there is still no encrypted output, call Write(bufs) on the underlying\n+  // stream. Since the bufs are empty, it won't actually write non-TLS data\n+  // onto the socket, we just want the side-effects. After, make sure the\n+  // WriteWrap was accepted by the stream, or that we call Done() on it.\n   if (empty) {\n     ClearOut();\n-    // However, if there is any data that should be written to the socket,\n-    // the callback should not be invoked immediately\n     if (BIO_pending(enc_out_) == 0) {\n       CHECK_NULL(current_empty_write_);\n       current_empty_write_ = w;\n@@ -628,7 +648,7 @@ int TLSWrap::DoWrite(WriteWrap* w,\n   CHECK_NULL(current_write_);\n   current_write_ = w;\n \n-  // Write queued data\n+  // Write encrypted data to underlying stream and call Done().\n   if (empty) {\n     EncOut();\n     return 0;\n@@ -647,17 +667,20 @@ int TLSWrap::DoWrite(WriteWrap* w,\n   if (i != count) {\n     int err;\n     Local<Value> arg = GetSSLError(written, &err, &error_);\n+\n+    // If we stopped writing because of an error, it's fatal, discard the data.\n     if (!arg.IsEmpty()) {\n       current_write_ = nullptr;\n       return UV_EPROTO;\n     }\n \n+    // Otherwise, save unwritten data so it can be written later by ClearIn().\n     pending_cleartext_input_.insert(pending_cleartext_input_.end(),\n                                     &bufs[i],\n                                     &bufs[count]);\n   }\n \n-  // Try writing data immediately\n+  // Write any encrypted/handshake output that may be ready.\n   EncOut();\n \n   return 0;\n@@ -689,17 +712,20 @@ void TLSWrap::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n     return;\n   }\n \n-  // Only client connections can receive data\n   if (ssl_ == nullptr) {\n     EmitRead(UV_EPROTO);\n     return;\n   }\n \n-  // Commit read data\n+  // Commit the amount of data actually read into the peeked/allocated buffer\n+  // from the underlying stream.\n   crypto::NodeBIO* enc_in = crypto::NodeBIO::FromBIO(enc_in_);\n   enc_in->Commit(nread);\n \n-  // Parse ClientHello first\n+  // Parse ClientHello first, if we need to. It's only parsed if session event\n+  // listeners are used on the server side.  \"ended\" is the initial state, so\n+  // can mean parsing was never started, or that parsing is finished. Either\n+  // way, ended means we can give the buffered data to SSL.\n   if (!hello_parser_.IsEnded()) {\n     size_t avail = 0;\n     uint8_t* data = reinterpret_cast<uint8_t*>(enc_in->Peek(&avail));"
        },
        {
            "sha": "cd2701cd6d9fb750a9fd49d0614ff256ae4e6def",
            "filename": "src/tls_wrap.h",
            "status": "modified",
            "additions": 23,
            "deletions": 7,
            "changes": 30,
            "blob_url": "https://github.com/nodejs/node/blob/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Ftls_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/46c5c3388d24615d8bcd887bb366d4171e99fdee/src%2Ftls_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftls_wrap.h?ref=46c5c3388d24615d8bcd887bb366d4171e99fdee",
            "patch": "@@ -72,7 +72,9 @@ class TLSWrap : public AsyncWrap,\n               uv_buf_t* bufs,\n               size_t count,\n               uv_stream_t* send_handle) override;\n+  // Return error_ string or nullptr if it's empty.\n   const char* Error() const override;\n+  // Reset error_ string to empty. Not related to \"clear text\".\n   void ClearError() override;\n \n   void NewSessionDoneCb();\n@@ -105,11 +107,22 @@ class TLSWrap : public AsyncWrap,\n \n   static void SSLInfoCallback(const SSL* ssl_, int where, int ret);\n   void InitSSL();\n-  void EncOut();\n-  bool ClearIn();\n-  void ClearOut();\n+  // SSL has a \"clear\" text (unencrypted) side (to/from the node API) and\n+  // encrypted (\"enc\") text side (to/from the underlying socket/stream).\n+  // On each side data flows \"in\" or \"out\" of SSL context.\n+  //\n+  // EncIn() doesn't exist. Encrypted data is pushed from underlying stream into\n+  // enc_in_ via the stream listener's OnStreamAlloc()/OnStreamRead() interface.\n+  void EncOut();  // Write encrypted data from enc_out_ to underlying stream.\n+  void ClearIn();  // SSL_write() clear data \"in\" to SSL.\n+  void ClearOut();  // SSL_read() clear text \"out\" from SSL.\n+\n+  // Call Done() on outstanding WriteWrap request.\n   bool InvokeQueued(int status, const char* error_str = nullptr);\n \n+  // Drive the SSL state machine by attempting to SSL_read() and SSL_write() to\n+  // it. Transparent handshakes mean SSL_read() might trigger I/O on the\n+  // underlying stream even if there is no clear text to read or write.\n   inline void Cycle() {\n     // Prevent recursion\n     if (++cycle_depth_ > 1)\n@@ -118,6 +131,7 @@ class TLSWrap : public AsyncWrap,\n     for (; cycle_depth_ > 0; cycle_depth_--) {\n       ClearIn();\n       ClearOut();\n+      // EncIn() doesn't exist, it happens via stream listener callbacks.\n       EncOut();\n     }\n   }\n@@ -139,16 +153,18 @@ class TLSWrap : public AsyncWrap,\n   static void SetVerifyMode(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void EnableSessionCallbacks(\n       const v8::FunctionCallbackInfo<v8::Value>& args);\n-  static void EnableCertCb(\n-      const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void EnableTrace(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void EnableCertCb(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void DestroySSL(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void GetServername(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static void SetServername(const v8::FunctionCallbackInfo<v8::Value>& args);\n   static int SelectSNIContextCallback(SSL* s, int* ad, void* arg);\n \n   crypto::SecureContext* sc_;\n-  BIO* enc_in_ = nullptr;\n-  BIO* enc_out_ = nullptr;\n+  // BIO buffers hold encrypted data.\n+  BIO* enc_in_ = nullptr;   // StreamListener fills this for SSL_read().\n+  BIO* enc_out_ = nullptr;  // SSL_write()/handshake fills this for EncOut().\n+  // Waiting for ClearIn() to pass to SSL_write().\n   std::vector<uv_buf_t> pending_cleartext_input_;\n   size_t write_size_ = 0;\n   WriteWrap* current_write_ = nullptr;"
        }
    ],
    "stats": {
        "total": 123,
        "additions": 84,
        "deletions": 39
    }
}