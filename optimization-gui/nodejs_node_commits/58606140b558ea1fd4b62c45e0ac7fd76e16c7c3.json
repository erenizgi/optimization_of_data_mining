{
    "author": "addaleax",
    "message": "report: use `uv_handle_type_name()` to get handle type\n\nPR-URL: https://github.com/nodejs/node/pull/25610\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Richard Lau <riclau@uk.ibm.com>",
    "sha": "58606140b558ea1fd4b62c45e0ac7fd76e16c7c3",
    "files": [
        {
            "sha": "2cd92599b0a91ebf1b20d785a90dea85ce704c24",
            "filename": "src/node_report_utils.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 58,
            "changes": 65,
            "blob_url": "https://github.com/nodejs/node/blob/58606140b558ea1fd4b62c45e0ac7fd76e16c7c3/src%2Fnode_report_utils.cc",
            "raw_url": "https://github.com/nodejs/node/raw/58606140b558ea1fd4b62c45e0ac7fd76e16c7c3/src%2Fnode_report_utils.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_report_utils.cc?ref=58606140b558ea1fd4b62c45e0ac7fd76e16c7c3",
            "patch": "@@ -105,65 +105,26 @@ void ReportPath(uv_handle_t* h, std::ostringstream& out) {\n \n // Utility function to walk libuv handles.\n void WalkHandle(uv_handle_t* h, void* arg) {\n-  std::string type;\n+  const char* type = uv_handle_type_name(h->type);\n   std::ostringstream data;\n   JSONWriter* writer = static_cast<JSONWriter*>(arg);\n   uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);\n \n-  // List all the types so we get a compile warning if we've missed one,\n-  // (using default: supresses the compiler warning).\n   switch (h->type) {\n-    case UV_UNKNOWN_HANDLE:\n-      type = \"unknown\";\n-      break;\n-    case UV_ASYNC:\n-      type = \"async\";\n-      break;\n-    case UV_CHECK:\n-      type = \"check\";\n-      break;\n-    case UV_FS_EVENT: {\n-      type = \"fs_event\";\n-      ReportPath(h, data);\n-      break;\n-    }\n-    case UV_FS_POLL: {\n-      type = \"fs_poll\";\n+    case UV_FS_EVENT:\n+    case UV_FS_POLL:\n       ReportPath(h, data);\n       break;\n-    }\n-    case UV_HANDLE:\n-      type = \"handle\";\n-      break;\n-    case UV_IDLE:\n-      type = \"idle\";\n-      break;\n-    case UV_NAMED_PIPE:\n-      type = \"pipe\";\n-      break;\n-    case UV_POLL:\n-      type = \"poll\";\n-      break;\n-    case UV_PREPARE:\n-      type = \"prepare\";\n-      break;\n-    case UV_PROCESS: {\n-      type = \"process\";\n+    case UV_PROCESS:\n       data << \"pid: \" << handle->process.pid;\n       break;\n-    }\n-    case UV_STREAM:\n-      type = \"stream\";\n-      break;\n-    case UV_TCP: {\n-      type = \"tcp\";\n+    case UV_TCP:\n+    case UV_UDP:\n       ReportEndpoints(h, data);\n       break;\n-    }\n     case UV_TIMER: {\n       uint64_t due = handle->timer.timeout;\n       uint64_t now = uv_now(handle->timer.loop);\n-      type = \"timer\";\n       data << \"repeat: \" << uv_timer_get_repeat(&(handle->timer));\n       if (due > now) {\n         data << \", timeout in: \" << (due - now) << \" ms\";\n@@ -174,35 +135,23 @@ void WalkHandle(uv_handle_t* h, void* arg) {\n     }\n     case UV_TTY: {\n       int height, width, rc;\n-      type = \"tty\";\n       rc = uv_tty_get_winsize(&(handle->tty), &width, &height);\n       if (rc == 0) {\n         data << \"width: \" << width << \", height: \" << height;\n       }\n       break;\n     }\n-    case UV_UDP: {\n-      type = \"udp\";\n-      ReportEndpoints(h, data);\n-      break;\n-    }\n     case UV_SIGNAL: {\n       // SIGWINCH is used by libuv so always appears.\n       // See http://docs.libuv.org/en/v1.x/signal.html\n-      type = \"signal\";\n       data << \"signum: \" << handle->signal.signum\n #ifndef _WIN32\n            << \" (\" << node::signo_string(handle->signal.signum) << \")\"\n #endif\n            << \"\";\n       break;\n     }\n-    case UV_FILE:\n-      type = \"file\";\n-      break;\n-    // We shouldn't see \"max\" type\n-    case UV_HANDLE_TYPE_MAX:\n-      type = \"max\";\n+    default:\n       break;\n   }\n "
        }
    ],
    "stats": {
        "total": 65,
        "additions": 7,
        "deletions": 58
    }
}