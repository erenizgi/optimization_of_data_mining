{
    "author": "addaleax",
    "message": "stream: always reset awaitDrain when emitting data\n\nThe complicated `awaitDrain` machinery can be made a bit\nslimmer, and more correct, by just resetting the value\neach time `stream.emit('data')` is called.\n\nBy resetting the value before emitting the data chunk, and\nseeing whether any pipe destinations return `.write() === false`,\nwe always end up in a consistent state and donâ€™t need to worry\nabout odd situations (like `dest.write(chunk)` emitting more data).\n\nPR-URL: https://github.com/nodejs/node/pull/18516\nFixes: https://github.com/nodejs/node/issues/18484\nFixes: https://github.com/nodejs/node/issues/18512\nRefs: https://github.com/nodejs/node/pull/18515\nReviewed-By: Anatoli Papirovski <apapirovski@mac.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Minwoo Jung <minwoo@nodesource.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>",
    "sha": "e7cb694a609de41817ba7492fe6848ab6dcb4768",
    "files": [
        {
            "sha": "c7b356ed4421b0c6bc16a94e7665211bd385cdab",
            "filename": "lib/_stream_readable.js",
            "status": "modified",
            "additions": 3,
            "deletions": 9,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/e7cb694a609de41817ba7492fe6848ab6dcb4768/lib%2F_stream_readable.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7cb694a609de41817ba7492fe6848ab6dcb4768/lib%2F_stream_readable.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2F_stream_readable.js?ref=e7cb694a609de41817ba7492fe6848ab6dcb4768",
            "patch": "@@ -258,6 +258,7 @@ function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n \n function addChunk(stream, state, chunk, addToFront) {\n   if (state.flowing && state.length === 0 && !state.sync) {\n+    state.awaitDrain = 0;\n     stream.emit('data', chunk);\n   } else {\n     // update the buffer info.\n@@ -456,6 +457,7 @@ Readable.prototype.read = function(n) {\n     n = 0;\n   } else {\n     state.length -= n;\n+    state.awaitDrain = 0;\n   }\n \n   if (state.length === 0) {\n@@ -637,18 +639,12 @@ Readable.prototype.pipe = function(dest, pipeOpts) {\n       ondrain();\n   }\n \n-  // If the user pushes more data while we're writing to dest then we'll end up\n-  // in ondata again. However, we only want to increase awaitDrain once because\n-  // dest will only emit one 'drain' event for the multiple writes.\n-  // => Introduce a guard on increasing awaitDrain.\n-  var increasedAwaitDrain = false;\n   src.on('data', ondata);\n   function ondata(chunk) {\n     debug('ondata');\n-    increasedAwaitDrain = false;\n     var ret = dest.write(chunk);\n     debug('dest.write', ret);\n-    if (false === ret && !increasedAwaitDrain) {\n+    if (ret === false) {\n       // If the user unpiped during `dest.write()`, it is possible\n       // to get stuck in a permanently paused state if that write\n       // also returned false.\n@@ -658,7 +654,6 @@ Readable.prototype.pipe = function(dest, pipeOpts) {\n           !cleanedUp) {\n         debug('false write response, pause', state.awaitDrain);\n         state.awaitDrain++;\n-        increasedAwaitDrain = true;\n       }\n       src.pause();\n     }\n@@ -834,7 +829,6 @@ function resume_(stream, state) {\n   }\n \n   state.resumeScheduled = false;\n-  state.awaitDrain = 0;\n   stream.emit('resume');\n   flow(stream);\n   if (state.flowing && !state.reading)"
        },
        {
            "sha": "08269acfd3b015c1715cd57317c6f6b67ef82882",
            "filename": "test/parallel/test-stream-pipe-manual-resume.js",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/nodejs/node/blob/e7cb694a609de41817ba7492fe6848ab6dcb4768/test%2Fparallel%2Ftest-stream-pipe-manual-resume.js",
            "raw_url": "https://github.com/nodejs/node/raw/e7cb694a609de41817ba7492fe6848ab6dcb4768/test%2Fparallel%2Ftest-stream-pipe-manual-resume.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-stream-pipe-manual-resume.js?ref=e7cb694a609de41817ba7492fe6848ab6dcb4768",
            "patch": "@@ -0,0 +1,35 @@\n+'use strict';\n+const common = require('../common');\n+const stream = require('stream');\n+\n+function test(throwCodeInbetween) {\n+  // Check that a pipe does not stall if .read() is called unexpectedly\n+  // (i.e. the stream is not resumed by the pipe).\n+\n+  const n = 1000;\n+  let counter = n;\n+  const rs = stream.Readable({\n+    objectMode: true,\n+    read: common.mustCallAtLeast(() => {\n+      if (--counter >= 0)\n+        rs.push({ counter });\n+      else\n+        rs.push(null);\n+    }, n)\n+  });\n+\n+  const ws = stream.Writable({\n+    objectMode: true,\n+    write: common.mustCall((data, enc, cb) => {\n+      setImmediate(cb);\n+    }, n)\n+  });\n+\n+  setImmediate(() => throwCodeInbetween(rs, ws));\n+\n+  rs.pipe(ws);\n+}\n+\n+test((rs) => rs.read());\n+test((rs) => rs.resume());\n+test(() => 0);"
        }
    ],
    "stats": {
        "total": 47,
        "additions": 38,
        "deletions": 9
    }
}