{
    "author": "kfarnung",
    "message": "n-api: add more `int64_t` tests\n\n* Updated tests for `Number` and `int32_t`\n* Added new tests for `int64_t`\n* Updated N-API `int64_t` behavior to return zero for all non-finite\n  numbers\n* Clarified the documentation for these calls.\n\nPR-URL: https://github.com/nodejs/node/pull/19402\nRefs: https://github.com/nodejs/node-chakracore/pull/500\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "c5291682491f1b7ee328b7fe5bbd037a91b8a79c",
    "files": [
        {
            "sha": "cece9d1fd154aa7485a52076a19df5de8a3b7527",
            "filename": "doc/api/n-api.md",
            "status": "modified",
            "additions": 20,
            "deletions": 7,
            "changes": 27,
            "blob_url": "https://github.com/nodejs/node/blob/c5291682491f1b7ee328b7fe5bbd037a91b8a79c/doc%2Fapi%2Fn-api.md",
            "raw_url": "https://github.com/nodejs/node/raw/c5291682491f1b7ee328b7fe5bbd037a91b8a79c/doc%2Fapi%2Fn-api.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Fn-api.md?ref=c5291682491f1b7ee328b7fe5bbd037a91b8a79c",
            "patch": "@@ -1797,13 +1797,17 @@ napi_status napi_get_value_int32(napi_env env,\n - `[out] result`: C int32 primitive equivalent of the given JavaScript Number.\n \n Returns `napi_ok` if the API succeeded. If a non-number `napi_value`\n-is passed in `napi_number_expected .\n+is passed in `napi_number_expected`.\n \n This API returns the C int32 primitive equivalent\n-of the given JavaScript Number. If the number exceeds the range of the\n-32 bit integer, then the result is truncated to the equivalent of the\n-bottom 32 bits. This can result in a large positive number becoming\n-a negative number if the value is > 2^31 -1.\n+of the given JavaScript Number.\n+\n+If the number exceeds the range of the 32 bit integer, then the result is\n+truncated to the equivalent of the bottom 32 bits. This can result in a large\n+positive number becoming a negative number if the value is > 2^31 -1.\n+\n+Non-finite number values (NaN, positive infinity, or negative infinity) set the\n+result to zero.\n \n #### napi_get_value_int64\n <!-- YAML\n@@ -1822,8 +1826,17 @@ napi_status napi_get_value_int64(napi_env env,\n Returns `napi_ok` if the API succeeded. If a non-number `napi_value`\n is passed in it returns `napi_number_expected`.\n \n-This API returns the C int64 primitive equivalent of the given\n-JavaScript Number.\n+This API returns the C int64 primitive equivalent of the given JavaScript\n+Number.\n+\n+Number values outside the range of\n+[`Number.MIN_SAFE_INTEGER`](https://tc39.github.io/ecma262/#sec-number.min_safe_integer)\n+-(2^53 - 1) -\n+[`Number.MAX_SAFE_INTEGER`](https://tc39.github.io/ecma262/#sec-number.max_safe_integer)\n+(2^53 - 1) will lose precision.\n+\n+Non-finite number values (NaN, positive infinity, or negative infinity) set the\n+result to zero.\n \n #### napi_get_value_string_latin1\n <!-- YAML"
        },
        {
            "sha": "3a02e5effa7a4f742a879d97481286efc1714406",
            "filename": "src/node_api.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/nodejs/node/blob/c5291682491f1b7ee328b7fe5bbd037a91b8a79c/src%2Fnode_api.cc",
            "raw_url": "https://github.com/nodejs/node/raw/c5291682491f1b7ee328b7fe5bbd037a91b8a79c/src%2Fnode_api.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_api.cc?ref=c5291682491f1b7ee328b7fe5bbd037a91b8a79c",
            "patch": "@@ -2170,15 +2170,16 @@ napi_status napi_get_value_int64(napi_env env,\n \n   RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);\n \n-  // v8::Value::IntegerValue() converts NaN to INT64_MIN, inconsistent with\n-  // v8::Value::Int32Value() that converts NaN to 0. So special-case NaN here.\n+  // v8::Value::IntegerValue() converts NaN, +Inf, and -Inf to INT64_MIN,\n+  // inconsistent with v8::Value::Int32Value() which converts those values to 0.\n+  // Special-case all non-finite values to match that behavior.\n   double doubleValue = val.As<v8::Number>()->Value();\n-  if (std::isnan(doubleValue)) {\n-    *result = 0;\n-  } else {\n+  if (std::isfinite(doubleValue)) {\n     // Empty context: https://github.com/nodejs/node/issues/14379\n     v8::Local<v8::Context> context;\n     *result = val->IntegerValue(context).FromJust();\n+  } else {\n+    *result = 0;\n   }\n \n   return napi_clear_last_error(env);"
        },
        {
            "sha": "6c04a222cb4eb61b153847a2943f2cb1fb4807a8",
            "filename": "test/addons-napi/test_number/test.js",
            "status": "modified",
            "additions": 99,
            "deletions": 36,
            "changes": 135,
            "blob_url": "https://github.com/nodejs/node/blob/c5291682491f1b7ee328b7fe5bbd037a91b8a79c/test%2Faddons-napi%2Ftest_number%2Ftest.js",
            "raw_url": "https://github.com/nodejs/node/raw/c5291682491f1b7ee328b7fe5bbd037a91b8a79c/test%2Faddons-napi%2Ftest_number%2Ftest.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Faddons-napi%2Ftest_number%2Ftest.js?ref=c5291682491f1b7ee328b7fe5bbd037a91b8a79c",
            "patch": "@@ -5,50 +5,113 @@ const test_number = require(`./build/${common.buildType}/test_number`);\n \n \n // testing api calls for number\n-assert.strictEqual(0, test_number.Test(0));\n-assert.strictEqual(1, test_number.Test(1));\n-assert.strictEqual(-1, test_number.Test(-1));\n-assert.strictEqual(100, test_number.Test(100));\n-assert.strictEqual(2121, test_number.Test(2121));\n-assert.strictEqual(-1233, test_number.Test(-1233));\n-assert.strictEqual(986583, test_number.Test(986583));\n-assert.strictEqual(-976675, test_number.Test(-976675));\n+function testNumber(num) {\n+  assert.strictEqual(num, test_number.Test(num));\n+}\n \n-const num1 = 98765432213456789876546896323445679887645323232436587988766545658;\n-assert.strictEqual(num1, test_number.Test(num1));\n+testNumber(0);\n+testNumber(-0);\n+testNumber(1);\n+testNumber(-1);\n+testNumber(100);\n+testNumber(2121);\n+testNumber(-1233);\n+testNumber(986583);\n+testNumber(-976675);\n \n-const num2 = -4350987086545760976737453646576078997096876957864353245245769809;\n-assert.strictEqual(num2, test_number.Test(num2));\n+testNumber(\n+  98765432213456789876546896323445679887645323232436587988766545658);\n+testNumber(\n+  -4350987086545760976737453646576078997096876957864353245245769809);\n+testNumber(Number.MIN_SAFE_INTEGER);\n+testNumber(Number.MAX_SAFE_INTEGER);\n+testNumber(Number.MAX_SAFE_INTEGER + 10);\n \n-const num3 = Number.MAX_SAFE_INTEGER;\n-assert.strictEqual(num3, test_number.Test(num3));\n+testNumber(Number.MIN_VALUE);\n+testNumber(Number.MAX_VALUE);\n+testNumber(Number.MAX_VALUE + 10);\n \n-const num4 = Number.MAX_SAFE_INTEGER + 10;\n-assert.strictEqual(num4, test_number.Test(num4));\n+testNumber(Number.POSITIVE_INFINITY);\n+testNumber(Number.NEGATIVE_INFINITY);\n+testNumber(Number.NaN);\n \n-const num5 = Number.MAX_VALUE;\n-assert.strictEqual(num5, test_number.Test(num5));\n+// validate documented behavior when value is retrieved as 32-bit integer with\n+// `napi_get_value_int32`\n+function testInt32(input, expected = input) {\n+  assert.strictEqual(expected, test_number.TestInt32Truncation(input));\n+}\n \n-const num6 = Number.MAX_VALUE + 10;\n-assert.strictEqual(num6, test_number.Test(num6));\n+// Test zero\n+testInt32(0.0, 0);\n+testInt32(-0.0, 0);\n \n-const num7 = Number.POSITIVE_INFINITY;\n-assert.strictEqual(num7, test_number.Test(num7));\n+// Test min/max int32 range\n+testInt32(-Math.pow(2, 31));\n+testInt32(Math.pow(2, 31) - 1);\n \n-const num8 = Number.NEGATIVE_INFINITY;\n-assert.strictEqual(num8, test_number.Test(num8));\n+// Test overflow scenarios\n+testInt32(4294967297, 1);\n+testInt32(4294967296, 0);\n+testInt32(4294967295, -1);\n+testInt32(4294967296 * 5 + 3, 3);\n \n+// Test min/max safe integer range\n+testInt32(Number.MIN_SAFE_INTEGER, 1);\n+testInt32(Number.MAX_SAFE_INTEGER, -1);\n \n-// validate documented behavior when value is retrieved\n-// as 32 bit integer with napi_get_value_int32\n-assert.strictEqual(1, test_number.TestInt32Truncation(4294967297));\n-assert.strictEqual(0, test_number.TestInt32Truncation(4294967296));\n-assert.strictEqual(-1, test_number.TestInt32Truncation(4294967295));\n-assert.strictEqual(3, test_number.TestInt32Truncation(4294967296 * 5 + 3));\n+// Test within int64_t range (with precision loss)\n+testInt32(-Math.pow(2, 63) + (Math.pow(2, 9) + 1), 1024);\n+testInt32(Math.pow(2, 63) - (Math.pow(2, 9) + 1), -1024);\n \n-// validate that the boundaries of safe integer can be passed through\n-// successfully\n-assert.strictEqual(Number.MAX_SAFE_INTEGER,\n-                   test_number.TestInt64Truncation(Number.MAX_SAFE_INTEGER));\n-assert.strictEqual(Number.MIN_SAFE_INTEGER,\n-                   test_number.TestInt64Truncation(Number.MIN_SAFE_INTEGER));\n+// Test min/max double value\n+testInt32(-Number.MIN_VALUE, 0);\n+testInt32(Number.MIN_VALUE, 0);\n+testInt32(-Number.MAX_VALUE, 0);\n+testInt32(Number.MAX_VALUE, 0);\n+\n+// Test outside int64_t range\n+testInt32(-Math.pow(2, 63) + (Math.pow(2, 9)), 0);\n+testInt32(Math.pow(2, 63) - (Math.pow(2, 9)), 0);\n+\n+// Test non-finite numbers\n+testInt32(Number.POSITIVE_INFINITY, 0);\n+testInt32(Number.NEGATIVE_INFINITY, 0);\n+testInt32(Number.NaN, 0);\n+\n+// validate documented behavior when value is retrieved as 64-bit integer with\n+// `napi_get_value_int64`\n+function testInt64(input, expected = input) {\n+  assert.strictEqual(expected, test_number.TestInt64Truncation(input));\n+}\n+\n+// Both V8 and ChakraCore return a sentinel value of `0x8000000000000000` when\n+// the conversion goes out of range, but V8 treats it as unsigned in some cases.\n+const RANGEERROR_POSITIVE = Math.pow(2, 63);\n+const RANGEERROR_NEGATIVE = -Math.pow(2, 63);\n+\n+// Test zero\n+testInt64(0.0, 0);\n+testInt64(-0.0, 0);\n+\n+// Test min/max safe integer range\n+testInt64(Number.MIN_SAFE_INTEGER);\n+testInt64(Number.MAX_SAFE_INTEGER);\n+\n+// Test within int64_t range (with precision loss)\n+testInt64(-Math.pow(2, 63) + (Math.pow(2, 9) + 1));\n+testInt64(Math.pow(2, 63) - (Math.pow(2, 9) + 1));\n+\n+// Test min/max double value\n+testInt64(-Number.MIN_VALUE, 0);\n+testInt64(Number.MIN_VALUE, 0);\n+testInt64(-Number.MAX_VALUE, RANGEERROR_NEGATIVE);\n+testInt64(Number.MAX_VALUE, RANGEERROR_POSITIVE);\n+\n+// Test outside int64_t range\n+testInt64(-Math.pow(2, 63) + (Math.pow(2, 9)), RANGEERROR_NEGATIVE);\n+testInt64(Math.pow(2, 63) - (Math.pow(2, 9)), RANGEERROR_POSITIVE);\n+\n+// Test non-finite numbers\n+testInt64(Number.POSITIVE_INFINITY, 0);\n+testInt64(Number.NEGATIVE_INFINITY, 0);\n+testInt64(Number.NaN, 0);"
        }
    ],
    "stats": {
        "total": 173,
        "additions": 125,
        "deletions": 48
    }
}