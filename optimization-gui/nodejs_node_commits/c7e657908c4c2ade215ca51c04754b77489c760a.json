{
    "author": "joyeecheung",
    "message": "fs: replace pushValueToArray with pure C++ API\n\nInstead of calling into JS from C++ to push values into an array,\nuse the new Array::New API that takes a pointer and a length\ndirectly.\n\nPR-URL: https://github.com/nodejs/node/pull/24125\nRefs: https://github.com/v8/v8/commit/0483e9a9abe77a73632fd85b9c0cd608efa9aa0d\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Yang Guo <yangguo@chromium.org>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Refael Ackermann <refack@gmail.com>",
    "sha": "c7e657908c4c2ade215ca51c04754b77489c760a",
    "files": [
        {
            "sha": "6333f8d8626f5238611757971cc5baf80ee605ba",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 64,
            "changes": 74,
            "blob_url": "https://github.com/nodejs/node/blob/c7e657908c4c2ade215ca51c04754b77489c760a/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/c7e657908c4c2ade215ca51c04754b77489c760a/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=c7e657908c4c2ade215ca51c04754b77489c760a",
            "patch": "@@ -571,10 +571,7 @@ void AfterScanDir(uv_fs_t* req) {\n   Environment* env = req_wrap->env();\n   Local<Value> error;\n   int r;\n-  Local<Array> names = Array::New(env->isolate(), 0);\n-  Local<Function> fn = env->push_values_to_array_function();\n-  Local<Value> name_argv[NODE_PUSH_VAL_TO_ARRAY_MAX];\n-  size_t name_idx = 0;\n+  std::vector<Local<Value>> name_argv;\n \n   for (int i = 0; ; i++) {\n     uv_dirent_t ent;\n@@ -596,23 +593,11 @@ void AfterScanDir(uv_fs_t* req) {\n     if (filename.IsEmpty())\n       return req_wrap->Reject(error);\n \n-    name_argv[name_idx++] = filename.ToLocalChecked();\n-\n-    if (name_idx >= arraysize(name_argv)) {\n-      MaybeLocal<Value> ret = fn->Call(env->context(), names, name_idx,\n-                                       name_argv);\n-      if (ret.IsEmpty()) {\n-        return;\n-      }\n-      name_idx = 0;\n-    }\n-  }\n-\n-  if (name_idx > 0) {\n-    fn->Call(env->context(), names, name_idx, name_argv)\n-      .ToLocalChecked();\n+    name_argv.push_back(filename.ToLocalChecked());\n   }\n \n+  Local<Array> names =\n+      Array::New(env->isolate(), name_argv.data(), name_argv.size());\n   req_wrap->Resolve(names);\n }\n \n@@ -1497,18 +1482,8 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n \n     CHECK_GE(req_wrap_sync.req.result, 0);\n     int r;\n-    Local<Array> names = Array::New(isolate, 0);\n-    Local<Function> fn = env->push_values_to_array_function();\n-    Local<Value> name_v[NODE_PUSH_VAL_TO_ARRAY_MAX];\n-    size_t name_idx = 0;\n-\n-    Local<Value> types;\n-    Local<Value> type_v[NODE_PUSH_VAL_TO_ARRAY_MAX];\n-    size_t type_idx;\n-    if (with_types) {\n-      types = Array::New(isolate, 0);\n-      type_idx = 0;\n-    }\n+    std::vector<Local<Value>> name_v;\n+    std::vector<Local<Value>> type_v;\n \n     for (int i = 0; ; i++) {\n       uv_dirent_t ent;\n@@ -1537,47 +1512,18 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n         return;\n       }\n \n-      name_v[name_idx++] = filename.ToLocalChecked();\n-\n-      if (name_idx >= arraysize(name_v)) {\n-        MaybeLocal<Value> ret = fn->Call(env->context(), names, name_idx,\n-                                         name_v);\n-        if (ret.IsEmpty()) {\n-          return;\n-        }\n-        name_idx = 0;\n-      }\n+      name_v.push_back(filename.ToLocalChecked());\n \n       if (with_types) {\n-        type_v[type_idx++] = Integer::New(isolate, ent.type);\n-\n-        if (type_idx >= arraysize(type_v)) {\n-          MaybeLocal<Value> ret = fn->Call(env->context(), types, type_idx,\n-              type_v);\n-          if (ret.IsEmpty()) {\n-            return;\n-          }\n-          type_idx = 0;\n-        }\n+        type_v.push_back(Integer::New(isolate, ent.type));\n       }\n     }\n \n-    if (name_idx > 0) {\n-      MaybeLocal<Value> ret = fn->Call(env->context(), names, name_idx, name_v);\n-      if (ret.IsEmpty()) {\n-        return;\n-      }\n-    }\n-\n-    if (with_types && type_idx > 0) {\n-      MaybeLocal<Value> ret = fn->Call(env->context(), types, type_idx, type_v);\n-      if (ret.IsEmpty()) {\n-        return;\n-      }\n-    }\n \n+    Local<Array> names = Array::New(isolate, name_v.data(), name_v.size());\n     if (with_types) {\n       Local<Array> result = Array::New(isolate, 2);\n+      Local<Value> types = Array::New(isolate, type_v.data(), type_v.size());\n       result->Set(0, names);\n       result->Set(1, types);\n       args.GetReturnValue().Set(result);"
        }
    ],
    "stats": {
        "total": 74,
        "additions": 10,
        "deletions": 64
    }
}