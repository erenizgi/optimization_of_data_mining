{
    "author": "apapirovski",
    "message": "timers: refactor timer list processing\n\nInstead of using kOnTimeout index to track a special list\nprocessing function, just pass in a function to C++ at\nstartup that executes all handles and determines which\nfunction to call.\n\nThis change improves the performance of unpooled timeouts\nby roughly 20%, as well as makes the unref/ref processing\neasier to follow.\n\nPR-URL: https://github.com/nodejs/node/pull/18582\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>\nReviewed-By: Vladimir de Turckheim <vlad2t@hotmail.com>\nReviewed-By: Evan Lucas <evanlucas@me.com>",
    "sha": "0f9efef05deb11dbbdf5adf96460839f5b332207",
    "files": [
        {
            "sha": "19f0f6a4af4d0d6f5afe5773983c8135e84a9d8d",
            "filename": "benchmark/timers/timers-timeout-unpooled.js",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/nodejs/node/blob/0f9efef05deb11dbbdf5adf96460839f5b332207/benchmark%2Ftimers%2Ftimers-timeout-unpooled.js",
            "raw_url": "https://github.com/nodejs/node/raw/0f9efef05deb11dbbdf5adf96460839f5b332207/benchmark%2Ftimers%2Ftimers-timeout-unpooled.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/benchmark%2Ftimers%2Ftimers-timeout-unpooled.js?ref=0f9efef05deb11dbbdf5adf96460839f5b332207",
            "patch": "@@ -0,0 +1,36 @@\n+'use strict';\n+const common = require('../common.js');\n+\n+// The following benchmark sets up n * 1e6 unpooled timeouts,\n+// then measures their execution on the next uv tick\n+\n+const bench = common.createBenchmark(main, {\n+  n: [1e6],\n+});\n+\n+function main({ n }) {\n+  let count = 0;\n+\n+  // Function tracking on the hidden class in V8 can cause misleading\n+  // results in this benchmark if only a single function is used â€”\n+  // alternate between two functions for a fairer benchmark\n+\n+  function cb() {\n+    count++;\n+    if (count === n)\n+      bench.end(n);\n+  }\n+  function cb2() {\n+    count++;\n+    if (count === n)\n+      bench.end(n);\n+  }\n+\n+  for (var i = 0; i < n; i++) {\n+    // unref().ref() will cause each of these timers to\n+    // allocate their own handle\n+    setTimeout(i % 2 ? cb : cb2, 1).unref().ref();\n+  }\n+\n+  bench.start();\n+}"
        },
        {
            "sha": "8e914d751a93d89d4aac9918268722818636fcbf",
            "filename": "lib/timers.js",
            "status": "modified",
            "additions": 19,
            "deletions": 19,
            "changes": 38,
            "blob_url": "https://github.com/nodejs/node/blob/0f9efef05deb11dbbdf5adf96460839f5b332207/lib%2Ftimers.js",
            "raw_url": "https://github.com/nodejs/node/raw/0f9efef05deb11dbbdf5adf96460839f5b332207/lib%2Ftimers.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Ftimers.js?ref=0f9efef05deb11dbbdf5adf96460839f5b332207",
            "patch": "@@ -24,7 +24,7 @@\n const async_wrap = process.binding('async_wrap');\n const {\n   Timer: TimerWrap,\n-  setImmediateCallback,\n+  setupTimers,\n } = process.binding('timer_wrap');\n const L = require('internal/linkedlist');\n const timerInternals = require('internal/timers');\n@@ -34,7 +34,6 @@ const assert = require('assert');\n const util = require('util');\n const errors = require('internal/errors');\n const debug = util.debuglog('timer');\n-const kOnTimeout = TimerWrap.kOnTimeout | 0;\n // Two arrays that share state between C++ and JS.\n const { async_hook_fields, async_id_fields } = async_wrap;\n const {\n@@ -57,7 +56,7 @@ const kRefCount = 1;\n const kHasOutstanding = 2;\n \n const [immediateInfo, toggleImmediateRef] =\n-  setImmediateCallback(processImmediate);\n+  setupTimers(processImmediate, processTimers);\n \n const kRefed = Symbol('refed');\n \n@@ -221,10 +220,14 @@ function TimersList(msecs, unrefed) {\n   timer.start(msecs);\n }\n \n-// adds listOnTimeout to the C++ object prototype, as\n-// V8 would not inline it otherwise.\n-TimerWrap.prototype[kOnTimeout] = function listOnTimeout(now) {\n-  const list = this._list;\n+function processTimers(now) {\n+  if (this.owner)\n+    return unrefdHandle(this.owner, now);\n+  return listOnTimeout(this, now);\n+}\n+\n+function listOnTimeout(handle, now) {\n+  const list = handle._list;\n   const msecs = list.msecs;\n \n   debug('timeout callback %d', msecs);\n@@ -241,7 +244,7 @@ TimerWrap.prototype[kOnTimeout] = function listOnTimeout(now) {\n       if (timeRemaining <= 0) {\n         timeRemaining = 1;\n       }\n-      this.start(timeRemaining);\n+      handle.start(timeRemaining);\n       debug('%d list wait because diff is %d', msecs, diff);\n       return true;\n     }\n@@ -280,11 +283,11 @@ TimerWrap.prototype[kOnTimeout] = function listOnTimeout(now) {\n \n   // Do not close the underlying handle if its ownership has changed\n   // (e.g it was unrefed in its callback).\n-  if (!this.owner)\n-    this.close();\n+  if (!handle.owner)\n+    handle.close();\n \n   return true;\n-};\n+}\n \n \n // An optimization so that the try/finally only de-optimizes (since at least v8\n@@ -516,18 +519,17 @@ exports.clearInterval = function(timer) {\n };\n \n \n-function unrefdHandle(now) {\n+function unrefdHandle(timer, now) {\n   try {\n     // Don't attempt to call the callback if it is not a function.\n-    if (typeof this.owner._onTimeout === 'function') {\n-      tryOnTimeout(this.owner, now);\n+    if (typeof timer._onTimeout === 'function') {\n+      tryOnTimeout(timer, now);\n     }\n   } finally {\n     // Make sure we clean up if the callback is no longer a function\n     // even if the timer is an interval.\n-    if (!this.owner._repeat ||\n-        typeof this.owner._onTimeout !== 'function') {\n-      this.owner.close();\n+    if (!timer._repeat || typeof timer._onTimeout !== 'function') {\n+      timer.close();\n     }\n   }\n \n@@ -557,7 +559,6 @@ Timeout.prototype.unref = function() {\n \n     this._handle = handle || new TimerWrap();\n     this._handle.owner = this;\n-    this._handle[kOnTimeout] = unrefdHandle;\n     this._handle.start(delay);\n     this._handle.unref();\n   }\n@@ -581,7 +582,6 @@ Timeout.prototype.close = function() {\n     }\n \n     this._idleTimeout = -1;\n-    this._handle[kOnTimeout] = null;\n     this._handle.close();\n   } else {\n     unenroll(this);"
        },
        {
            "sha": "95548c0900ea138a8d77fae5ef8e651eddeab97f",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/0f9efef05deb11dbbdf5adf96460839f5b332207/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/0f9efef05deb11dbbdf5adf96460839f5b332207/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=0f9efef05deb11dbbdf5adf96460839f5b332207",
            "patch": "@@ -308,6 +308,7 @@ class ModuleWrap;\n   V(secure_context_constructor_template, v8::FunctionTemplate)                \\\n   V(tcp_constructor_template, v8::FunctionTemplate)                           \\\n   V(tick_callback_function, v8::Function)                                     \\\n+  V(timers_callback_function, v8::Function)                                   \\\n   V(tls_wrap_constructor_function, v8::Function)                              \\\n   V(tty_constructor_template, v8::FunctionTemplate)                           \\\n   V(udp_constructor_function, v8::Function)                                   \\"
        },
        {
            "sha": "02c0b8166981abf627a7ebfce1bbbe711c200fa9",
            "filename": "src/timer_wrap.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/0f9efef05deb11dbbdf5adf96460839f5b332207/src%2Ftimer_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/0f9efef05deb11dbbdf5adf96460839f5b332207/src%2Ftimer_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftimer_wrap.cc?ref=0f9efef05deb11dbbdf5adf96460839f5b332207",
            "patch": "@@ -41,8 +41,6 @@ using v8::Object;\n using v8::String;\n using v8::Value;\n \n-const uint32_t kOnTimeout = 0;\n-\n class TimerWrap : public HandleWrap {\n  public:\n   static void Initialize(Local<Object> target,\n@@ -53,8 +51,6 @@ class TimerWrap : public HandleWrap {\n     Local<String> timerString = FIXED_ONE_BYTE_STRING(env->isolate(), \"Timer\");\n     constructor->InstanceTemplate()->SetInternalFieldCount(1);\n     constructor->SetClassName(timerString);\n-    constructor->Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"kOnTimeout\"),\n-                     Integer::New(env->isolate(), kOnTimeout));\n \n     env->SetTemplateMethod(constructor, \"now\", Now);\n \n@@ -71,18 +67,22 @@ class TimerWrap : public HandleWrap {\n     target->Set(timerString, constructor->GetFunction());\n \n     target->Set(env->context(),\n-                FIXED_ONE_BYTE_STRING(env->isolate(), \"setImmediateCallback\"),\n-                env->NewFunctionTemplate(SetImmediateCallback)\n+                FIXED_ONE_BYTE_STRING(env->isolate(), \"setupTimers\"),\n+                env->NewFunctionTemplate(SetupTimers)\n                    ->GetFunction(env->context()).ToLocalChecked()).FromJust();\n   }\n \n   size_t self_size() const override { return sizeof(*this); }\n \n  private:\n-  static void SetImmediateCallback(const FunctionCallbackInfo<Value>& args) {\n+  static void SetupTimers(const FunctionCallbackInfo<Value>& args) {\n     CHECK(args[0]->IsFunction());\n+    CHECK(args[1]->IsFunction());\n     auto env = Environment::GetCurrent(args);\n+\n     env->set_immediate_callback_function(args[0].As<Function>());\n+    env->set_timers_callback_function(args[1].As<Function>());\n+\n     auto toggle_ref_cb = [] (const FunctionCallbackInfo<Value>& args) {\n       Environment::GetCurrent(args)->ToggleImmediateRef(args[0]->IsTrue());\n     };\n@@ -142,7 +142,8 @@ class TimerWrap : public HandleWrap {\n     Local<Value> args[1];\n     do {\n       args[0] = env->GetNow();\n-      ret = wrap->MakeCallback(kOnTimeout, 1, args).ToLocalChecked();\n+      ret = wrap->MakeCallback(env->timers_callback_function(), 1, args)\n+                .ToLocalChecked();\n     } while (ret->IsUndefined() &&\n              !env->tick_info()->has_thrown() &&\n              wrap->object()->Get(env->context(),"
        },
        {
            "sha": "382cf5a054942ce13bc8afd685725ab4d383d844",
            "filename": "test/message/timeout_throw.out",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/0f9efef05deb11dbbdf5adf96460839f5b332207/test%2Fmessage%2Ftimeout_throw.out",
            "raw_url": "https://github.com/nodejs/node/raw/0f9efef05deb11dbbdf5adf96460839f5b332207/test%2Fmessage%2Ftimeout_throw.out",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fmessage%2Ftimeout_throw.out?ref=0f9efef05deb11dbbdf5adf96460839f5b332207",
            "patch": "@@ -5,4 +5,5 @@ ReferenceError: undefined_reference_error_maker is not defined\n     at Timeout._onTimeout (*test*message*timeout_throw.js:*:*)\n     at ontimeout (timers.js:*:*)\n     at tryOnTimeout (timers.js:*:*)\n-    at Timer.listOnTimeout (timers.js:*:*)\n+    at listOnTimeout (timers.js:*:*)\n+    at Timer.processTimers (timers.js:*:*)"
        }
    ],
    "stats": {
        "total": 95,
        "additions": 67,
        "deletions": 28
    }
}