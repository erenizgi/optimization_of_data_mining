{
    "author": "joyeecheung",
    "message": "src: move InternalMakeCallback and MakeCallback\n\nThis commit moves InternalMakeCallback and MakeCallback into\ncallback_scope.cc. Since these are just wrappers on top of\n`InternalCallbackScope`, this makes the implementations easier to find.\n\nhttps://github.com/nodejs/node/pull/25299\nPR-URL: https://github.com/nodejs/node/pull/25299\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "e54d11e2f64aadc74ea52185b4430afbe034f09b",
    "files": [
        {
            "sha": "885134799fe0198d63b3ed15e99c02bb316bc4bb",
            "filename": "src/callback_scope.cc",
            "status": "modified",
            "additions": 131,
            "deletions": 0,
            "changes": 131,
            "blob_url": "https://github.com/nodejs/node/blob/e54d11e2f64aadc74ea52185b4430afbe034f09b/src%2Fcallback_scope.cc",
            "raw_url": "https://github.com/nodejs/node/raw/e54d11e2f64aadc74ea52185b4430afbe034f09b/src%2Fcallback_scope.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fcallback_scope.cc?ref=e54d11e2f64aadc74ea52185b4430afbe034f09b",
            "patch": "@@ -5,11 +5,17 @@\n \n namespace node {\n \n+using v8::Context;\n+using v8::EscapableHandleScope;\n using v8::Function;\n using v8::HandleScope;\n using v8::Isolate;\n using v8::Local;\n+using v8::MaybeLocal;\n+using v8::NewStringType;\n using v8::Object;\n+using v8::String;\n+using v8::Value;\n \n using AsyncHooks = Environment::AsyncHooks;\n \n@@ -126,4 +132,129 @@ void InternalCallbackScope::Close() {\n   }\n }\n \n+MaybeLocal<Value> InternalMakeCallback(Environment* env,\n+                                       Local<Object> recv,\n+                                       const Local<Function> callback,\n+                                       int argc,\n+                                       Local<Value> argv[],\n+                                       async_context asyncContext) {\n+  CHECK(!recv.IsEmpty());\n+  InternalCallbackScope scope(env, recv, asyncContext);\n+  if (scope.Failed()) {\n+    return MaybeLocal<Value>();\n+  }\n+\n+  Local<Function> domain_cb = env->domain_callback();\n+  MaybeLocal<Value> ret;\n+  if (asyncContext.async_id != 0 || domain_cb.IsEmpty() || recv.IsEmpty()) {\n+    ret = callback->Call(env->context(), recv, argc, argv);\n+  } else {\n+    std::vector<Local<Value>> args(1 + argc);\n+    args[0] = callback;\n+    std::copy(&argv[0], &argv[argc], args.begin() + 1);\n+    ret = domain_cb->Call(env->context(), recv, args.size(), &args[0]);\n+  }\n+\n+  if (ret.IsEmpty()) {\n+    scope.MarkAsFailed();\n+    return MaybeLocal<Value>();\n+  }\n+\n+  scope.Close();\n+  if (scope.Failed()) {\n+    return MaybeLocal<Value>();\n+  }\n+\n+  return ret;\n+}\n+\n+// Public MakeCallback()s\n+\n+MaybeLocal<Value> MakeCallback(Isolate* isolate,\n+                               Local<Object> recv,\n+                               const char* method,\n+                               int argc,\n+                               Local<Value> argv[],\n+                               async_context asyncContext) {\n+  Local<String> method_string =\n+      String::NewFromUtf8(isolate, method, NewStringType::kNormal)\n+          .ToLocalChecked();\n+  return MakeCallback(isolate, recv, method_string, argc, argv, asyncContext);\n+}\n+\n+MaybeLocal<Value> MakeCallback(Isolate* isolate,\n+                               Local<Object> recv,\n+                               Local<String> symbol,\n+                               int argc,\n+                               Local<Value> argv[],\n+                               async_context asyncContext) {\n+  Local<Value> callback_v =\n+      recv->Get(isolate->GetCurrentContext(), symbol).ToLocalChecked();\n+  if (callback_v.IsEmpty()) return Local<Value>();\n+  if (!callback_v->IsFunction()) return Local<Value>();\n+  Local<Function> callback = callback_v.As<Function>();\n+  return MakeCallback(isolate, recv, callback, argc, argv, asyncContext);\n+}\n+\n+MaybeLocal<Value> MakeCallback(Isolate* isolate,\n+                               Local<Object> recv,\n+                               Local<Function> callback,\n+                               int argc,\n+                               Local<Value> argv[],\n+                               async_context asyncContext) {\n+  // Observe the following two subtleties:\n+  //\n+  // 1. The environment is retrieved from the callback function's context.\n+  // 2. The context to enter is retrieved from the environment.\n+  //\n+  // Because of the AssignToContext() call in src/node_contextify.cc,\n+  // the two contexts need not be the same.\n+  Environment* env = Environment::GetCurrent(callback->CreationContext());\n+  CHECK_NOT_NULL(env);\n+  Context::Scope context_scope(env->context());\n+  MaybeLocal<Value> ret =\n+      InternalMakeCallback(env, recv, callback, argc, argv, asyncContext);\n+  if (ret.IsEmpty() && env->makecallback_depth() == 0) {\n+    // This is only for legacy compatiblity and we may want to look into\n+    // removing/adjusting it.\n+    return Undefined(env->isolate());\n+  }\n+  return ret;\n+}\n+\n+// Legacy MakeCallback()s\n+\n+Local<Value> MakeCallback(Isolate* isolate,\n+                          Local<Object> recv,\n+                          const char* method,\n+                          int argc,\n+                          Local<Value>* argv) {\n+  EscapableHandleScope handle_scope(isolate);\n+  return handle_scope.Escape(\n+      MakeCallback(isolate, recv, method, argc, argv, {0, 0})\n+          .FromMaybe(Local<Value>()));\n+}\n+\n+Local<Value> MakeCallback(Isolate* isolate,\n+                          Local<Object> recv,\n+                          Local<String> symbol,\n+                          int argc,\n+                          Local<Value>* argv) {\n+  EscapableHandleScope handle_scope(isolate);\n+  return handle_scope.Escape(\n+      MakeCallback(isolate, recv, symbol, argc, argv, {0, 0})\n+          .FromMaybe(Local<Value>()));\n+}\n+\n+Local<Value> MakeCallback(Isolate* isolate,\n+                          Local<Object> recv,\n+                          Local<Function> callback,\n+                          int argc,\n+                          Local<Value>* argv) {\n+  EscapableHandleScope handle_scope(isolate);\n+  return handle_scope.Escape(\n+      MakeCallback(isolate, recv, callback, argc, argv, {0, 0})\n+          .FromMaybe(Local<Value>()));\n+}\n+\n }  // namespace node"
        },
        {
            "sha": "3a1a6a9d6c2712f5fb712fec7a0fefd571f7a4c1",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 133,
            "changes": 133,
            "blob_url": "https://github.com/nodejs/node/blob/e54d11e2f64aadc74ea52185b4430afbe034f09b/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/e54d11e2f64aadc74ea52185b4430afbe034f09b/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=e54d11e2f64aadc74ea52185b4430afbe034f09b",
            "patch": "@@ -109,7 +109,6 @@ using v8::Array;\n using v8::Boolean;\n using v8::Context;\n using v8::DEFAULT;\n-using v8::EscapableHandleScope;\n using v8::Exception;\n using v8::Function;\n using v8::FunctionCallbackInfo;\n@@ -556,138 +555,6 @@ void RemoveEnvironmentCleanupHook(Isolate* isolate,\n   env->RemoveCleanupHook(fun, arg);\n }\n \n-MaybeLocal<Value> InternalMakeCallback(Environment* env,\n-                                       Local<Object> recv,\n-                                       const Local<Function> callback,\n-                                       int argc,\n-                                       Local<Value> argv[],\n-                                       async_context asyncContext) {\n-  CHECK(!recv.IsEmpty());\n-  InternalCallbackScope scope(env, recv, asyncContext);\n-  if (scope.Failed()) {\n-    return MaybeLocal<Value>();\n-  }\n-\n-  Local<Function> domain_cb = env->domain_callback();\n-  MaybeLocal<Value> ret;\n-  if (asyncContext.async_id != 0 || domain_cb.IsEmpty() || recv.IsEmpty()) {\n-    ret = callback->Call(env->context(), recv, argc, argv);\n-  } else {\n-    std::vector<Local<Value>> args(1 + argc);\n-    args[0] = callback;\n-    std::copy(&argv[0], &argv[argc], args.begin() + 1);\n-    ret = domain_cb->Call(env->context(), recv, args.size(), &args[0]);\n-  }\n-\n-  if (ret.IsEmpty()) {\n-    scope.MarkAsFailed();\n-    return MaybeLocal<Value>();\n-  }\n-\n-  scope.Close();\n-  if (scope.Failed()) {\n-    return MaybeLocal<Value>();\n-  }\n-\n-  return ret;\n-}\n-\n-\n-// Public MakeCallback()s\n-\n-\n-MaybeLocal<Value> MakeCallback(Isolate* isolate,\n-                               Local<Object> recv,\n-                               const char* method,\n-                               int argc,\n-                               Local<Value> argv[],\n-                               async_context asyncContext) {\n-  Local<String> method_string =\n-      String::NewFromUtf8(isolate, method, NewStringType::kNormal)\n-          .ToLocalChecked();\n-  return MakeCallback(isolate, recv, method_string, argc, argv, asyncContext);\n-}\n-\n-\n-MaybeLocal<Value> MakeCallback(Isolate* isolate,\n-                               Local<Object> recv,\n-                               Local<String> symbol,\n-                               int argc,\n-                               Local<Value> argv[],\n-                               async_context asyncContext) {\n-  Local<Value> callback_v = recv->Get(isolate->GetCurrentContext(),\n-                                      symbol).ToLocalChecked();\n-  if (callback_v.IsEmpty()) return Local<Value>();\n-  if (!callback_v->IsFunction()) return Local<Value>();\n-  Local<Function> callback = callback_v.As<Function>();\n-  return MakeCallback(isolate, recv, callback, argc, argv, asyncContext);\n-}\n-\n-\n-MaybeLocal<Value> MakeCallback(Isolate* isolate,\n-                               Local<Object> recv,\n-                               Local<Function> callback,\n-                               int argc,\n-                               Local<Value> argv[],\n-                               async_context asyncContext) {\n-  // Observe the following two subtleties:\n-  //\n-  // 1. The environment is retrieved from the callback function's context.\n-  // 2. The context to enter is retrieved from the environment.\n-  //\n-  // Because of the AssignToContext() call in src/node_contextify.cc,\n-  // the two contexts need not be the same.\n-  Environment* env = Environment::GetCurrent(callback->CreationContext());\n-  CHECK_NOT_NULL(env);\n-  Context::Scope context_scope(env->context());\n-  MaybeLocal<Value> ret = InternalMakeCallback(env, recv, callback,\n-                                               argc, argv, asyncContext);\n-  if (ret.IsEmpty() && env->makecallback_depth() == 0) {\n-    // This is only for legacy compatiblity and we may want to look into\n-    // removing/adjusting it.\n-    return Undefined(env->isolate());\n-  }\n-  return ret;\n-}\n-\n-\n-// Legacy MakeCallback()s\n-\n-Local<Value> MakeCallback(Isolate* isolate,\n-                          Local<Object> recv,\n-                          const char* method,\n-                          int argc,\n-                          Local<Value>* argv) {\n-  EscapableHandleScope handle_scope(isolate);\n-  return handle_scope.Escape(\n-      MakeCallback(isolate, recv, method, argc, argv, {0, 0})\n-          .FromMaybe(Local<Value>()));\n-}\n-\n-\n-Local<Value> MakeCallback(Isolate* isolate,\n-    Local<Object> recv,\n-    Local<String> symbol,\n-    int argc,\n-    Local<Value>* argv) {\n-  EscapableHandleScope handle_scope(isolate);\n-  return handle_scope.Escape(\n-      MakeCallback(isolate, recv, symbol, argc, argv, {0, 0})\n-          .FromMaybe(Local<Value>()));\n-}\n-\n-\n-Local<Value> MakeCallback(Isolate* isolate,\n-    Local<Object> recv,\n-    Local<Function> callback,\n-    int argc,\n-    Local<Value>* argv) {\n-  EscapableHandleScope handle_scope(isolate);\n-  return handle_scope.Escape(\n-      MakeCallback(isolate, recv, callback, argc, argv, {0, 0})\n-          .FromMaybe(Local<Value>()));\n-}\n-\n static void WaitForInspectorDisconnect(Environment* env) {\n #if HAVE_INSPECTOR\n   if (env->inspector_agent()->IsActive()) {"
        }
    ],
    "stats": {
        "total": 264,
        "additions": 131,
        "deletions": 133
    }
}