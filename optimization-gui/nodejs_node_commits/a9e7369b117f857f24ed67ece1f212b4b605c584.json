{
    "author": "tniessen",
    "message": "crypto: fix edge case in authenticated encryption\n\nRestricting the authentication tag length and calling update or\nsetAAD before setAuthTag caused an incorrect authentication tag to\nbe passed to OpenSSL: The auth_tag_len_ field was already set, so\nthe implementation assumed that the tag itself was known as well.\n\nPR-URL: https://github.com/nodejs/node/pull/22828\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "a9e7369b117f857f24ed67ece1f212b4b605c584",
    "files": [
        {
            "sha": "35b06e4ff07eceb8c513d4cf870e11ec542278e0",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/a9e7369b117f857f24ed67ece1f212b4b605c584/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/a9e7369b117f857f24ed67ece1f212b4b605c584/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=a9e7369b117f857f24ed67ece1f212b4b605c584",
            "patch": "@@ -2897,6 +2897,10 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {\n     return args.GetReturnValue().Set(false);\n   }\n \n+  // TODO(tniessen): Throw if the authentication tag has already been set.\n+  if (cipher->auth_tag_state_ == kAuthTagPassedToOpenSSL)\n+    return args.GetReturnValue().Set(true);\n+\n   unsigned int tag_len = Buffer::Length(args[0]);\n   const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_.get());\n   bool is_valid;\n@@ -2921,6 +2925,7 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {\n   }\n \n   cipher->auth_tag_len_ = tag_len;\n+  cipher->auth_tag_state_ = kAuthTagKnown;\n   CHECK_LE(cipher->auth_tag_len_, sizeof(cipher->auth_tag_));\n \n   memset(cipher->auth_tag_, 0, sizeof(cipher->auth_tag_));\n@@ -2931,14 +2936,14 @@ void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {\n \n \n bool CipherBase::MaybePassAuthTagToOpenSSL() {\n-  if (!auth_tag_set_ && auth_tag_len_ != kNoAuthTagLength) {\n+  if (auth_tag_state_ == kAuthTagKnown) {\n     if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),\n                              EVP_CTRL_AEAD_SET_TAG,\n                              auth_tag_len_,\n                              reinterpret_cast<unsigned char*>(auth_tag_))) {\n       return false;\n     }\n-    auth_tag_set_ = true;\n+    auth_tag_state_ = kAuthTagPassedToOpenSSL;\n   }\n   return true;\n }"
        },
        {
            "sha": "1a93ae7a47e2cffde442efa3b3ff62443bd8c30e",
            "filename": "src/node_crypto.h",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/a9e7369b117f857f24ed67ece1f212b4b605c584/src%2Fnode_crypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/a9e7369b117f857f24ed67ece1f212b4b605c584/src%2Fnode_crypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.h?ref=a9e7369b117f857f24ed67ece1f212b4b605c584",
            "patch": "@@ -363,6 +363,11 @@ class CipherBase : public BaseObject {\n     kErrorMessageSize,\n     kErrorState\n   };\n+  enum AuthTagState {\n+    kAuthTagUnknown,\n+    kAuthTagKnown,\n+    kAuthTagPassedToOpenSSL\n+  };\n   static const unsigned kNoAuthTagLength = static_cast<unsigned>(-1);\n \n   void Init(const char* cipher_type,\n@@ -404,7 +409,7 @@ class CipherBase : public BaseObject {\n       : BaseObject(env, wrap),\n         ctx_(nullptr),\n         kind_(kind),\n-        auth_tag_set_(false),\n+        auth_tag_state_(kAuthTagUnknown),\n         auth_tag_len_(kNoAuthTagLength),\n         pending_auth_failed_(false) {\n     MakeWeak();\n@@ -413,7 +418,7 @@ class CipherBase : public BaseObject {\n  private:\n   DeleteFnPtr<EVP_CIPHER_CTX, EVP_CIPHER_CTX_free> ctx_;\n   const CipherKind kind_;\n-  bool auth_tag_set_;\n+  AuthTagState auth_tag_state_;\n   unsigned int auth_tag_len_;\n   char auth_tag_[EVP_GCM_TLS_TAG_LEN];\n   bool pending_auth_failed_;"
        },
        {
            "sha": "77587fadf79a1be59fded263f3fb79862decb987",
            "filename": "test/parallel/test-crypto-authenticated.js",
            "status": "modified",
            "additions": 24,
            "deletions": 16,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/a9e7369b117f857f24ed67ece1f212b4b605c584/test%2Fparallel%2Ftest-crypto-authenticated.js",
            "raw_url": "https://github.com/nodejs/node/raw/a9e7369b117f857f24ed67ece1f212b4b605c584/test%2Fparallel%2Ftest-crypto-authenticated.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-authenticated.js?ref=a9e7369b117f857f24ed67ece1f212b4b605c584",
            "patch": "@@ -557,27 +557,35 @@ for (const test of TEST_CASES) {\n }\n \n // Test that the authentication tag can be set at any point before calling\n-// final() in GCM mode.\n+// final() in GCM or OCB mode.\n {\n   const plain = Buffer.from('Hello world', 'utf8');\n   const key = Buffer.from('0123456789abcdef', 'utf8');\n   const iv = Buffer.from('0123456789ab', 'utf8');\n \n-  const cipher = crypto.createCipheriv('aes-128-gcm', key, iv);\n-  const ciphertext = Buffer.concat([cipher.update(plain), cipher.final()]);\n-  const authTag = cipher.getAuthTag();\n-\n-  for (const authTagBeforeUpdate of [true, false]) {\n-    const decipher = crypto.createDecipheriv('aes-128-gcm', key, iv);\n-    if (authTagBeforeUpdate) {\n-      decipher.setAuthTag(authTag);\n-    }\n-    const resultUpdate = decipher.update(ciphertext);\n-    if (!authTagBeforeUpdate) {\n-      decipher.setAuthTag(authTag);\n+  for (const mode of ['gcm', 'ocb']) {\n+    for (const authTagLength of mode === 'gcm' ? [undefined, 8] : [8]) {\n+      const cipher = crypto.createCipheriv(`aes-128-${mode}`, key, iv, {\n+        authTagLength\n+      });\n+      const ciphertext = Buffer.concat([cipher.update(plain), cipher.final()]);\n+      const authTag = cipher.getAuthTag();\n+\n+      for (const authTagBeforeUpdate of [true, false]) {\n+        const decipher = crypto.createDecipheriv(`aes-128-${mode}`, key, iv, {\n+          authTagLength\n+        });\n+        if (authTagBeforeUpdate) {\n+          decipher.setAuthTag(authTag);\n+        }\n+        const resultUpdate = decipher.update(ciphertext);\n+        if (!authTagBeforeUpdate) {\n+          decipher.setAuthTag(authTag);\n+        }\n+        const resultFinal = decipher.final();\n+        const result = Buffer.concat([resultUpdate, resultFinal]);\n+        assert(result.equals(plain));\n+      }\n     }\n-    const resultFinal = decipher.final();\n-    const result = Buffer.concat([resultUpdate, resultFinal]);\n-    assert(result.equals(plain));\n   }\n }"
        }
    ],
    "stats": {
        "total": 58,
        "additions": 38,
        "deletions": 20
    }
}