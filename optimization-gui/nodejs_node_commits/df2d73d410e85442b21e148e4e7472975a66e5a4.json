{
    "author": "BridgeAR",
    "message": "test: fix buffer writes on mips\n\nMips has a different way of handling NaN. This makes sure the tests\npass on MIPS as well.\n\nPR-URL: https://github.com/nodejs/node/pull/20377\nReviewed-By: Richard Lau <riclau@uk.ibm.com>",
    "sha": "df2d73d410e85442b21e148e4e7472975a66e5a4",
    "files": [
        {
            "sha": "8a17d536909dcef0c2ee01a41b24ba0c2e047282",
            "filename": "test/parallel/test-buffer-writedouble.js",
            "status": "modified",
            "additions": 13,
            "deletions": 4,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/df2d73d410e85442b21e148e4e7472975a66e5a4/test%2Fparallel%2Ftest-buffer-writedouble.js",
            "raw_url": "https://github.com/nodejs/node/raw/df2d73d410e85442b21e148e4e7472975a66e5a4/test%2Fparallel%2Ftest-buffer-writedouble.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-writedouble.js?ref=df2d73d410e85442b21e148e4e7472975a66e5a4",
            "patch": "@@ -67,10 +67,19 @@ assert.strictEqual(buffer.readDoubleLE(8), -Infinity);\n buffer.writeDoubleBE(NaN, 0);\n buffer.writeDoubleLE(NaN, 8);\n \n-assert.ok(buffer.equals(new Uint8Array([\n-  0x7F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n-  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x7F\n-])));\n+// JS only knows a single NaN but there exist two platform specific\n+// implementations. Therefore, allow both quiet and signalling NaNs.\n+if (buffer[1] === 0xF7) {\n+  assert.ok(buffer.equals(new Uint8Array([\n+    0x7F, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n+    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0x7F\n+  ])));\n+} else {\n+  assert.ok(buffer.equals(new Uint8Array([\n+    0x7F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x7F\n+  ])));\n+}\n \n assert.ok(Number.isNaN(buffer.readDoubleBE(0)));\n assert.ok(Number.isNaN(buffer.readDoubleLE(8)));"
        },
        {
            "sha": "4c2c7539eaafcbe3d090a3d50b0906e78fad1830",
            "filename": "test/parallel/test-buffer-writefloat.js",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/df2d73d410e85442b21e148e4e7472975a66e5a4/test%2Fparallel%2Ftest-buffer-writefloat.js",
            "raw_url": "https://github.com/nodejs/node/raw/df2d73d410e85442b21e148e4e7472975a66e5a4/test%2Fparallel%2Ftest-buffer-writefloat.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-buffer-writefloat.js?ref=df2d73d410e85442b21e148e4e7472975a66e5a4",
            "patch": "@@ -50,8 +50,18 @@ assert.strictEqual(buffer.readFloatLE(4), -Infinity);\n \n buffer.writeFloatBE(NaN, 0);\n buffer.writeFloatLE(NaN, 4);\n-assert.ok(buffer.equals(\n-  new Uint8Array([ 0x7F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F ])));\n+\n+// JS only knows a single NaN but there exist two platform specific\n+// implementations. Therefore, allow both quiet and signalling NaNs.\n+if (buffer[1] === 0xBF) {\n+  assert.ok(\n+    buffer.equals(new Uint8Array(\n+      [ 0x7F, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x7F ])));\n+} else {\n+  assert.ok(\n+    buffer.equals(new Uint8Array(\n+      [ 0x7F, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x7F ])));\n+}\n \n assert.ok(Number.isNaN(buffer.readFloatBE(0)));\n assert.ok(Number.isNaN(buffer.readFloatLE(4)));"
        }
    ],
    "stats": {
        "total": 31,
        "additions": 25,
        "deletions": 6
    }
}