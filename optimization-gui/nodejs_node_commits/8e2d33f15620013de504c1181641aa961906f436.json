{
    "author": "addaleax",
    "message": "src: unify native symbol inspection code\n\nUse a single file, and a single interface, for inspecting\nsymbols in the current process for debugging.\n\nPR-URL: https://github.com/nodejs/node/pull/21238\nReviewed-By: Tiancheng \"Timothy\" Gu <timothygu99@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Gus Caplan <me@gus.host>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Benjamin Gruenbaum <benjamingr@gmail.com>\nReviewed-By: Colin Ihrig <cjihrig@gmail.com>",
    "sha": "8e2d33f15620013de504c1181641aa961906f436",
    "files": [
        {
            "sha": "978855f00653bf6e224c89be87e3c5c0174a6c87",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 5,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/8e2d33f15620013de504c1181641aa961906f436/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/8e2d33f15620013de504c1181641aa961906f436/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=8e2d33f15620013de504c1181641aa961906f436",
            "patch": "@@ -317,6 +317,7 @@\n         'src/cares_wrap.cc',\n         'src/connection_wrap.cc',\n         'src/connect_wrap.cc',\n+        'src/debug_utils.cc',\n         'src/env.cc',\n         'src/exceptions.cc',\n         'src/fs_event_wrap.cc',\n@@ -496,9 +497,6 @@\n           'defines': [ 'HAVE_INSPECTOR=0' ]\n         }],\n         [ 'OS==\"win\"', {\n-          'sources': [\n-            'src/backtrace_win32.cc',\n-          ],\n           'conditions': [\n             [ 'node_intermediate_lib_type!=\"static_library\"', {\n               'sources': [\n@@ -507,8 +505,6 @@\n             }],\n           ],\n           'libraries': [ '-lpsapi.lib' ]\n-        }, { # POSIX\n-          'sources': [ 'src/backtrace_posix.cc' ],\n         }],\n         [ 'node_use_etw==\"true\"', {\n           'defines': [ 'HAVE_ETW=1' ],"
        },
        {
            "sha": "c7a6bea1938a7cb25285327928f32453b14e96fc",
            "filename": "src/backtrace_posix.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 49,
            "changes": 49,
            "blob_url": "https://github.com/nodejs/node/blob/483bbf097bc80924d3220bc345ea2f142cc06a7c/src%2Fbacktrace_posix.cc",
            "raw_url": "https://github.com/nodejs/node/raw/483bbf097bc80924d3220bc345ea2f142cc06a7c/src%2Fbacktrace_posix.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fbacktrace_posix.cc?ref=483bbf097bc80924d3220bc345ea2f142cc06a7c",
            "patch": "@@ -1,49 +0,0 @@\n-#include \"node_internals.h\"\n-\n-#if defined(__linux__)\n-#include <features.h>\n-#endif\n-\n-#if defined(__linux__) && !defined(__GLIBC__) || \\\n-    defined(__UCLIBC__) || \\\n-    defined(_AIX)\n-#define HAVE_EXECINFO_H 0\n-#else\n-#define HAVE_EXECINFO_H 1\n-#endif\n-\n-#if HAVE_EXECINFO_H\n-#include <cxxabi.h>\n-#include <dlfcn.h>\n-#include <execinfo.h>\n-#include <stdio.h>\n-#endif\n-\n-namespace node {\n-\n-void DumpBacktrace(FILE* fp) {\n-#if HAVE_EXECINFO_H\n-  void* frames[256];\n-  const int size = backtrace(frames, arraysize(frames));\n-  for (int i = 1; i < size; i += 1) {\n-    void* frame = frames[i];\n-    fprintf(fp, \"%2d: \", i);\n-    Dl_info info;\n-    const bool have_info = dladdr(frame, &info);\n-    if (!have_info || info.dli_sname == nullptr) {\n-      fprintf(fp, \"%p\", frame);\n-    } else if (char* demangled = abi::__cxa_demangle(info.dli_sname, 0, 0, 0)) {\n-      fprintf(fp, \"%s\", demangled);\n-      free(demangled);\n-    } else {\n-      fprintf(fp, \"%s\", info.dli_sname);\n-    }\n-    if (have_info && info.dli_fname != nullptr) {\n-      fprintf(fp, \" [%s]\", info.dli_fname);\n-    }\n-    fprintf(fp, \"\\n\");\n-  }\n-#endif  // HAVE_EXECINFO_H\n-}\n-\n-}  // namespace node"
        },
        {
            "sha": "ccc3af9455b18d5b565ea88ee04f316c801a7e34",
            "filename": "src/backtrace_win32.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 40,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/483bbf097bc80924d3220bc345ea2f142cc06a7c/src%2Fbacktrace_win32.cc",
            "raw_url": "https://github.com/nodejs/node/raw/483bbf097bc80924d3220bc345ea2f142cc06a7c/src%2Fbacktrace_win32.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fbacktrace_win32.cc?ref=483bbf097bc80924d3220bc345ea2f142cc06a7c",
            "patch": "@@ -1,40 +0,0 @@\n-#include \"node_internals.h\"\n-#include <windows.h>\n-#include <dbghelp.h>\n-\n-namespace node {\n-\n-void DumpBacktrace(FILE* fp) {\n-  void* frames[256];\n-  int size = CaptureStackBackTrace(0, arraysize(frames), frames, nullptr);\n-  HANDLE process = GetCurrentProcess();\n-  (void)SymInitialize(process, nullptr, true);\n-\n-  // Ref: https://msdn.microsoft.com/en-en/library/windows/desktop/ms680578(v=vs.85).aspx\n-  char info_buf[sizeof(SYMBOL_INFO) + MAX_SYM_NAME];\n-  SYMBOL_INFO* info = reinterpret_cast<SYMBOL_INFO*>(info_buf);\n-  char demangled[MAX_SYM_NAME];\n-\n-  for (int i = 1; i < size; i += 1) {\n-    void* frame = frames[i];\n-    fprintf(fp, \"%2d: \", i);\n-    info->MaxNameLen = MAX_SYM_NAME;\n-    info->SizeOfStruct = sizeof(SYMBOL_INFO);\n-    const bool have_info =\n-        SymFromAddr(process, reinterpret_cast<DWORD64>(frame), nullptr, info);\n-    if (!have_info || strlen(info->Name) == 0) {\n-      fprintf(fp, \"%p\", frame);\n-    } else if (UnDecorateSymbolName(info->Name,\n-                                    demangled,\n-                                    sizeof(demangled),\n-                                    UNDNAME_COMPLETE)) {\n-      fprintf(fp, \"%s\", demangled);\n-    } else {\n-      fprintf(fp, \"%s\", info->Name);\n-    }\n-    fprintf(fp, \"\\n\");\n-  }\n-  (void)SymCleanup(process);\n-}\n-\n-}  // namespace node"
        },
        {
            "sha": "53212fcd05e3f1e275a28ec3b3d54ab4f5da5e08",
            "filename": "src/debug_utils.cc",
            "status": "added",
            "additions": 180,
            "deletions": 0,
            "changes": 180,
            "blob_url": "https://github.com/nodejs/node/blob/8e2d33f15620013de504c1181641aa961906f436/src%2Fdebug_utils.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8e2d33f15620013de504c1181641aa961906f436/src%2Fdebug_utils.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fdebug_utils.cc?ref=8e2d33f15620013de504c1181641aa961906f436",
            "patch": "@@ -0,0 +1,180 @@\n+#include \"debug_utils.h\"\n+#include \"node_internals.h\"\n+\n+#ifdef __POSIX__\n+#if defined(__linux__)\n+#include <features.h>\n+#endif\n+\n+#if defined(__linux__) && !defined(__GLIBC__) || \\\n+    defined(__UCLIBC__) || \\\n+    defined(_AIX)\n+#define HAVE_EXECINFO_H 0\n+#else\n+#define HAVE_EXECINFO_H 1\n+#endif\n+\n+#if HAVE_EXECINFO_H\n+#include <cxxabi.h>\n+#include <dlfcn.h>\n+#include <execinfo.h>\n+#include <unistd.h>\n+#include <sys/mman.h>\n+#include <stdio.h>\n+#endif\n+\n+#else  // __POSIX__\n+\n+#include <windows.h>\n+#include <dbghelp.h>\n+\n+#endif  // __POSIX__\n+\n+namespace node {\n+\n+#ifdef __POSIX__\n+#if HAVE_EXECINFO_H\n+class PosixSymbolDebuggingContext final : public NativeSymbolDebuggingContext {\n+ public:\n+  PosixSymbolDebuggingContext() : pagesize_(getpagesize()) { }\n+\n+  SymbolInfo LookupSymbol(void* address) override {\n+    Dl_info info;\n+    const bool have_info = dladdr(address, &info);\n+    SymbolInfo ret;\n+    if (!have_info)\n+      return ret;\n+\n+    if (info.dli_sname != nullptr) {\n+      if (char* demangled = abi::__cxa_demangle(info.dli_sname, 0, 0, 0)) {\n+        ret.name = demangled;\n+        free(demangled);\n+      } else {\n+        ret.name = info.dli_sname;\n+      }\n+    }\n+\n+    if (info.dli_fname != nullptr) {\n+      ret.filename = info.dli_fname;\n+    }\n+\n+    return ret;\n+  }\n+\n+  bool IsMapped(void* address) override {\n+    void* page_aligned = reinterpret_cast<void*>(\n+        reinterpret_cast<uintptr_t>(address) & ~(pagesize_ - 1));\n+    return msync(page_aligned, pagesize_, MS_ASYNC) == 0;\n+  }\n+\n+  int GetStackTrace(void** frames, int count) override {\n+    return backtrace(frames, count);\n+  }\n+\n+ private:\n+  uintptr_t pagesize_;\n+};\n+\n+std::unique_ptr<NativeSymbolDebuggingContext>\n+NativeSymbolDebuggingContext::New() {\n+  return std::unique_ptr<NativeSymbolDebuggingContext>(\n+      new PosixSymbolDebuggingContext());\n+}\n+\n+#else  // HAVE_EXECINFO_H\n+\n+std::unique_ptr<NativeSymbolDebuggingContext>\n+NativeSymbolDebuggingContext::New() {\n+  return std::unique_ptr<NativeSymbolDebuggingContext>(\n+      new NativeSymbolDebuggingContext());\n+}\n+\n+#endif  // HAVE_EXECINFO_H\n+\n+#else  // __POSIX__\n+\n+class Win32SymbolDebuggingContext final : public NativeSymbolDebuggingContext {\n+ public:\n+  Win32SymbolDebuggingContext() {\n+    current_process_ = GetCurrentProcess();\n+    USE(SymInitialize(process, nullptr, true));\n+  }\n+\n+  ~Win32SymbolDebuggingContext() {\n+    USE(SymCleanup(process));\n+  }\n+\n+  SymbolInfo LookupSymbol(void* address) override {\n+    // Ref: https://msdn.microsoft.com/en-en/library/windows/desktop/ms680578(v=vs.85).aspx\n+    char info_buf[sizeof(SYMBOL_INFO) + MAX_SYM_NAME];\n+    SYMBOL_INFO* info = reinterpret_cast<SYMBOL_INFO*>(info_buf);\n+    char demangled[MAX_SYM_NAME];\n+\n+    info->MaxNameLen = MAX_SYM_NAME;\n+    info->SizeOfStruct = sizeof(SYMBOL_INFO);\n+\n+    SymbolInfo ret;\n+    const bool have_info = SymFromAddr(process,\n+                                       reinterpret_cast<DWORD64>(address),\n+                                       nullptr,\n+                                       info);\n+    if (have_info && strlen(info->Name) == 0) {\n+      if (UnDecorateSymbolName(info->Name,\n+                               demangled_,\n+                               sizeof(demangled_),\n+                               UNDNAME_COMPLETE)) {\n+        ret.name = demangled_;\n+      } else {\n+        ret.name = info->Name;\n+      }\n+    }\n+\n+    return ret;\n+  }\n+\n+  bool IsMapped(void* address) override {\n+    MEMORY_BASIC_INFORMATION info;\n+\n+    if (VirtualQuery(address, &info, sizeof(info)) != info)\n+      return false;\n+\n+    return info.State == MEM_COMMIT && info.Protect != 0;\n+  }\n+\n+  int GetStackTrace(void** frames, int count) override {\n+    return CaptureStackBackTrace(0, count, frames, nullptr);\n+  }\n+\n+ private:\n+  HANDLE current_process_;\n+};\n+\n+NativeSymbolDebuggingContext::New() {\n+  return std::unique_ptr<NativeSymbolDebuggingContext>(\n+      new Win32SymbolDebuggingContext());\n+}\n+\n+#endif  // __POSIX__\n+\n+std::string NativeSymbolDebuggingContext::SymbolInfo::Display() const {\n+  std::string ret = name;\n+  if (!filename.empty()) {\n+    ret += \" [\";\n+    ret += filename;\n+    ret += ']';\n+  }\n+  return ret;\n+}\n+\n+void DumpBacktrace(FILE* fp) {\n+  auto sym_ctx = NativeSymbolDebuggingContext::New();\n+  void* frames[256];\n+  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));\n+  for (int i = 1; i < size; i += 1) {\n+    void* frame = frames[i];\n+    fprintf(fp, \"%2d: %p %s\\n\",\n+            i, frame, sym_ctx->LookupSymbol(frame).Display().c_str());\n+  }\n+}\n+\n+}  // namespace node"
        },
        {
            "sha": "4d9ce253c0defbee1bbf6644e30f188f5d3e2185",
            "filename": "src/debug_utils.h",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/nodejs/node/blob/8e2d33f15620013de504c1181641aa961906f436/src%2Fdebug_utils.h",
            "raw_url": "https://github.com/nodejs/node/raw/8e2d33f15620013de504c1181641aa961906f436/src%2Fdebug_utils.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fdebug_utils.h?ref=8e2d33f15620013de504c1181641aa961906f436",
            "patch": "@@ -84,6 +84,24 @@ inline void FORCE_INLINE Debug(AsyncWrap* async_wrap,\n   Debug(async_wrap, format.c_str(), std::forward<Args>(args)...);\n }\n \n+// Debug helper for inspecting the currently running `node` executable.\n+class NativeSymbolDebuggingContext {\n+ public:\n+  static std::unique_ptr<NativeSymbolDebuggingContext> New();\n+\n+  class SymbolInfo {\n+   public:\n+    std::string name;\n+    std::string filename;\n+\n+    std::string Display() const;\n+  };\n+\n+  virtual ~NativeSymbolDebuggingContext() {}\n+  virtual SymbolInfo LookupSymbol(void* address) { return { \"\", \"\" }; }\n+  virtual bool IsMapped(void* address) { return false; }\n+  virtual int GetStackTrace(void** frames, int count) { return 0; }\n+};\n \n }  // namespace node\n "
        }
    ],
    "stats": {
        "total": 293,
        "additions": 199,
        "deletions": 94
    }
}