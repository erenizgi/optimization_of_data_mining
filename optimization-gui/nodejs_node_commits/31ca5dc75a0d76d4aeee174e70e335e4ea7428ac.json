{
    "author": "gireeshpunathil",
    "message": "src: promote v8 name spaces with using\n\nthere are several places where v8 artifacts appear with scope resolution\noperator inline with the source. Elevate them for improved readability\nas well as to follow the convention.\n\nPR-URL: https://github.com/nodejs/node/pull/22641\nReviewed-By: MichaÃ«l Zasso <targos@protonmail.com>\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Luigi Pinca <luigipinca@gmail.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "31ca5dc75a0d76d4aeee174e70e335e4ea7428ac",
    "files": [
        {
            "sha": "da9ad93b8d658b741e68b400cd0c3b94171ae689",
            "filename": "src/node.cc",
            "status": "modified",
            "additions": 45,
            "deletions": 35,
            "changes": 80,
            "blob_url": "https://github.com/nodejs/node/blob/31ca5dc75a0d76d4aeee174e70e335e4ea7428ac/src%2Fnode.cc",
            "raw_url": "https://github.com/nodejs/node/raw/31ca5dc75a0d76d4aeee174e70e335e4ea7428ac/src%2Fnode.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode.cc?ref=31ca5dc75a0d76d4aeee174e70e335e4ea7428ac",
            "patch": "@@ -132,11 +132,14 @@ using v8::Array;\n using v8::ArrayBuffer;\n using v8::Boolean;\n using v8::Context;\n+using v8::DEFAULT;\n+using v8::DontEnum;\n using v8::EscapableHandleScope;\n using v8::Exception;\n using v8::Function;\n using v8::FunctionCallbackInfo;\n using v8::HandleScope;\n+using v8::Int32;\n using v8::Integer;\n using v8::Isolate;\n using v8::Just;\n@@ -145,19 +148,27 @@ using v8::Locker;\n using v8::Maybe;\n using v8::MaybeLocal;\n using v8::Message;\n+using v8::MicrotasksPolicy;\n using v8::Name;\n using v8::NamedPropertyHandlerConfiguration;\n+using v8::NewStringType;\n+using v8::None;\n using v8::Nothing;\n using v8::Null;\n using v8::Number;\n using v8::Object;\n using v8::ObjectTemplate;\n using v8::Promise;\n+using v8::PropertyAttribute;\n using v8::PropertyCallbackInfo;\n+using v8::ReadOnly;\n+using v8::Script;\n+using v8::ScriptCompiler;\n using v8::ScriptOrigin;\n using v8::SealHandleScope;\n using v8::SideEffectType;\n using v8::String;\n+using v8::TracingController;\n using v8::TryCatch;\n using v8::Undefined;\n using v8::V8;\n@@ -190,12 +201,12 @@ std::shared_ptr<PerProcessOptions> per_process_opts {\n     new PerProcessOptions() };\n \n static Mutex node_isolate_mutex;\n-static v8::Isolate* node_isolate;\n+static Isolate* node_isolate;\n \n // Ensures that __metadata trace events are only emitted\n // when tracing is enabled.\n class NodeTraceStateObserver :\n-    public v8::TracingController::TraceStateObserver {\n+    public TracingController::TraceStateObserver {\n  public:\n   void OnTraceEnabled() override {\n     char name_buffer[512];\n@@ -278,12 +289,12 @@ class NodeTraceStateObserver :\n     UNREACHABLE();\n   }\n \n-  explicit NodeTraceStateObserver(v8::TracingController* controller) :\n+  explicit NodeTraceStateObserver(TracingController* controller) :\n       controller_(controller) {}\n   ~NodeTraceStateObserver() override {}\n \n  private:\n-  v8::TracingController* controller_;\n+  TracingController* controller_;\n };\n \n static struct {\n@@ -692,20 +703,20 @@ bool ShouldAbortOnUncaughtException(Isolate* isolate) {\n }  // anonymous namespace\n \n \n-void AddPromiseHook(v8::Isolate* isolate, promise_hook_func fn, void* arg) {\n+void AddPromiseHook(Isolate* isolate, promise_hook_func fn, void* arg) {\n   Environment* env = Environment::GetCurrent(isolate);\n   env->AddPromiseHook(fn, arg);\n }\n \n-void AddEnvironmentCleanupHook(v8::Isolate* isolate,\n+void AddEnvironmentCleanupHook(Isolate* isolate,\n                                void (*fun)(void* arg),\n                                void* arg) {\n   Environment* env = Environment::GetCurrent(isolate);\n   env->AddCleanupHook(fun, arg);\n }\n \n \n-void RemoveEnvironmentCleanupHook(v8::Isolate* isolate,\n+void RemoveEnvironmentCleanupHook(Isolate* isolate,\n                                   void (*fun)(void* arg),\n                                   void* arg) {\n   Environment* env = Environment::GetCurrent(isolate);\n@@ -759,7 +770,7 @@ MaybeLocal<Value> MakeCallback(Isolate* isolate,\n                                Local<Value> argv[],\n                                async_context asyncContext) {\n   Local<String> method_string =\n-      String::NewFromUtf8(isolate, method, v8::NewStringType::kNormal)\n+      String::NewFromUtf8(isolate, method, NewStringType::kNormal)\n           .ToLocalChecked();\n   return MakeCallback(isolate, recv, method_string, argc, argv, asyncContext);\n }\n@@ -945,7 +956,7 @@ void AppendExceptionLine(Environment* env,\n   arrow[off + 1] = '\\0';\n \n   Local<String> arrow_str = String::NewFromUtf8(env->isolate(), arrow,\n-      v8::NewStringType::kNormal).ToLocalChecked();\n+      NewStringType::kNormal).ToLocalChecked();\n \n   const bool can_set_arrow = !arrow_str.IsEmpty() && !err_obj.IsEmpty();\n   // If allocating arrow_str failed, print it out. There's not much else to do.\n@@ -1071,8 +1082,8 @@ static MaybeLocal<Value> ExecuteString(Environment* env,\n   try_catch.SetVerbose(false);\n \n   ScriptOrigin origin(filename);\n-  MaybeLocal<v8::Script> script =\n-      v8::Script::Compile(env->context(), source, &origin);\n+  MaybeLocal<Script> script =\n+      Script::Compile(env->context(), source, &origin);\n   if (script.IsEmpty()) {\n     ReportException(env, try_catch);\n     env->Exit(3);\n@@ -1526,7 +1537,7 @@ void FatalException(Isolate* isolate,\n           !code->IsInt32()) {\n         exit(1);\n       }\n-      exit(code.As<v8::Int32>()->Value());\n+      exit(code.As<Int32>()->Value());\n     }\n   }\n }\n@@ -1575,20 +1586,20 @@ static Maybe<bool> ProcessEmitWarningGeneric(Environment* env,\n   // do proper error checking for string creation.\n   if (!String::NewFromUtf8(env->isolate(),\n                            warning,\n-                           v8::NewStringType::kNormal).ToLocal(&args[argc++])) {\n+                           NewStringType::kNormal).ToLocal(&args[argc++])) {\n     return Nothing<bool>();\n   }\n   if (type != nullptr) {\n     if (!String::NewFromOneByte(env->isolate(),\n                                 reinterpret_cast<const uint8_t*>(type),\n-                                v8::NewStringType::kNormal)\n+                                NewStringType::kNormal)\n                                     .ToLocal(&args[argc++])) {\n       return Nothing<bool>();\n     }\n     if (code != nullptr &&\n         !String::NewFromOneByte(env->isolate(),\n                                 reinterpret_cast<const uint8_t*>(code),\n-                                v8::NewStringType::kNormal)\n+                                NewStringType::kNormal)\n                                     .ToLocal(&args[argc++])) {\n       return Nothing<bool>();\n     }\n@@ -1733,7 +1744,7 @@ static void GetLinkedBinding(const FunctionCallbackInfo<Value>& args) {\n   Local<Object> module = Object::New(env->isolate());\n   Local<Object> exports = Object::New(env->isolate());\n   Local<String> exports_prop = String::NewFromUtf8(env->isolate(), \"exports\",\n-      v8::NewStringType::kNormal).ToLocalChecked();\n+      NewStringType::kNormal).ToLocalChecked();\n   module->Set(exports_prop, exports);\n \n   if (mod->nm_context_register_func != nullptr) {\n@@ -1817,16 +1828,15 @@ namespace {\n     obj->DefineOwnProperty(env->context(),                                    \\\n                            OneByteString(env->isolate(), str),                \\\n                            var,                                               \\\n-                           v8::ReadOnly).FromJust();                          \\\n+                           ReadOnly).FromJust();                              \\\n   } while (0)\n \n #define READONLY_DONT_ENUM_PROPERTY(obj, str, var)                            \\\n   do {                                                                        \\\n     obj->DefineOwnProperty(env->context(),                                    \\\n                            OneByteString(env->isolate(), str),                \\\n                            var,                                               \\\n-                           static_cast<v8::PropertyAttribute>(v8::ReadOnly |  \\\n-                                                              v8::DontEnum))  \\\n+                           static_cast<PropertyAttribute>(ReadOnly|DontEnum)) \\\n         .FromJust();                                                          \\\n   } while (0)\n \n@@ -1846,8 +1856,8 @@ void SetupProcessObject(Environment* env,\n       ProcessTitleGetter,\n       env->is_main_thread() ? ProcessTitleSetter : nullptr,\n       env->as_external(),\n-      v8::DEFAULT,\n-      v8::None,\n+      DEFAULT,\n+      None,\n       SideEffectType::kHasNoSideEffect).FromJust());\n \n   // process.version\n@@ -1976,7 +1986,7 @@ void SetupProcessObject(Environment* env,\n   for (size_t i = 0; i < args.size(); ++i) {\n     arguments->Set(env->context(), i,\n         String::NewFromUtf8(env->isolate(), args[i].c_str(),\n-                            v8::NewStringType::kNormal).ToLocalChecked())\n+                            NewStringType::kNormal).ToLocalChecked())\n         .FromJust();\n   }\n   process->Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"argv\"), arguments);\n@@ -1986,7 +1996,7 @@ void SetupProcessObject(Environment* env,\n   for (size_t i = 0; i < exec_args.size(); ++i) {\n     exec_arguments->Set(env->context(), i,\n         String::NewFromUtf8(env->isolate(), exec_args[i].c_str(),\n-                            v8::NewStringType::kNormal).ToLocalChecked())\n+                            NewStringType::kNormal).ToLocalChecked())\n         .FromJust();\n   }\n   process->Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"execArgv\"),\n@@ -2022,7 +2032,7 @@ void SetupProcessObject(Environment* env,\n                       String::NewFromUtf8(\n                           env->isolate(),\n                           env->options()->eval_string.c_str(),\n-                          v8::NewStringType::kNormal).ToLocalChecked());\n+                          NewStringType::kNormal).ToLocalChecked());\n   }\n \n   // -p, --print\n@@ -2048,7 +2058,7 @@ void SetupProcessObject(Environment* env,\n     for (unsigned int i = 0; i < preload_modules.size(); ++i) {\n       Local<String> module = String::NewFromUtf8(env->isolate(),\n                                                  preload_modules[i].c_str(),\n-                                                 v8::NewStringType::kNormal)\n+                                                 NewStringType::kNormal)\n                                  .ToLocalChecked();\n       array->Set(i, module);\n     }\n@@ -2135,11 +2145,11 @@ void SetupProcessObject(Environment* env,\n   if (uv_exepath(exec_path, &exec_path_len) == 0) {\n     exec_path_value = String::NewFromUtf8(env->isolate(),\n                                           exec_path,\n-                                          v8::NewStringType::kInternalized,\n+                                          NewStringType::kInternalized,\n                                           exec_path_len).ToLocalChecked();\n   } else {\n     exec_path_value = String::NewFromUtf8(env->isolate(), args[0].c_str(),\n-        v8::NewStringType::kInternalized).ToLocalChecked();\n+        NewStringType::kInternalized).ToLocalChecked();\n   }\n   process->Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"execPath\"),\n                exec_path_value);\n@@ -2303,15 +2313,15 @@ void LoadEnvironment(Environment* env) {\n   global->Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"global\"), global);\n \n   // Create binding loaders\n-  v8::Local<v8::Function> get_binding_fn =\n+  Local<Function> get_binding_fn =\n       env->NewFunctionTemplate(GetBinding)->GetFunction(env->context())\n           .ToLocalChecked();\n \n-  v8::Local<v8::Function> get_linked_binding_fn =\n+  Local<Function> get_linked_binding_fn =\n       env->NewFunctionTemplate(GetLinkedBinding)->GetFunction(env->context())\n           .ToLocalChecked();\n \n-  v8::Local<v8::Function> get_internal_binding_fn =\n+  Local<Function> get_internal_binding_fn =\n       env->NewFunctionTemplate(GetInternalBinding)->GetFunction(env->context())\n           .ToLocalChecked();\n \n@@ -2843,7 +2853,7 @@ void RunAtExit(Environment* env) {\n }\n \n \n-uv_loop_t* GetCurrentEventLoop(v8::Isolate* isolate) {\n+uv_loop_t* GetCurrentEventLoop(Isolate* isolate) {\n   HandleScope handle_scope(isolate);\n   auto context = isolate->GetCurrentContext();\n   if (context.IsEmpty())\n@@ -2976,7 +2986,7 @@ MultiIsolatePlatform* GetMainThreadMultiIsolatePlatform() {\n \n MultiIsolatePlatform* CreatePlatform(\n     int thread_pool_size,\n-    v8::TracingController* tracing_controller) {\n+    TracingController* tracing_controller) {\n   return new NodePlatform(thread_pool_size, tracing_controller);\n }\n \n@@ -2999,8 +3009,8 @@ Local<Context> NewContext(Isolate* isolate,\n     // Run lib/internal/per_context.js\n     Context::Scope context_scope(context);\n     Local<String> per_context = NodePerContextSource(isolate);\n-    v8::ScriptCompiler::Source per_context_src(per_context, nullptr);\n-    Local<v8::Script> s = v8::ScriptCompiler::Compile(\n+    ScriptCompiler::Source per_context_src(per_context, nullptr);\n+    Local<Script> s = ScriptCompiler::Compile(\n         context,\n         &per_context_src).ToLocalChecked();\n     s->Run(context).ToLocalChecked();\n@@ -3109,7 +3119,7 @@ Isolate* NewIsolate(ArrayBufferAllocator* allocator) {\n \n   isolate->AddMessageListener(OnMessage);\n   isolate->SetAbortOnUncaughtExceptionCallback(ShouldAbortOnUncaughtException);\n-  isolate->SetMicrotasksPolicy(v8::MicrotasksPolicy::kExplicit);\n+  isolate->SetMicrotasksPolicy(MicrotasksPolicy::kExplicit);\n   isolate->SetFatalErrorHandler(OnFatalError);\n   isolate->SetAllowWasmCodeGenerationCallback(AllowWasmCodeGenerationCallback);\n "
        }
    ],
    "stats": {
        "total": 80,
        "additions": 45,
        "deletions": 35
    }
}