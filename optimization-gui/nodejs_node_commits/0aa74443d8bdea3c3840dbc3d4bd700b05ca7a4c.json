{
    "author": "lance",
    "message": "repl: add repl.setupHistory for programmatic repl\n\nAdds a `repl.setupHistory()` instance method so that\nprogrammatic REPLs can also write history to a file.\n\nThis change also refactors all of the history file\nmanagement to `lib/internal/repl/history.js`, cleaning\nup and simplifying `lib/internal/repl.js`.\n\nPR-URL: https://github.com/nodejs/node/pull/25895\nReviewed-By: Daniel Bevenius <daniel.bevenius@gmail.com>",
    "sha": "0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c",
    "files": [
        {
            "sha": "4395193de20326f58e65de5c78af01325b8f1067",
            "filename": "doc/api/repl.md",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c/doc%2Fapi%2Frepl.md",
            "raw_url": "https://github.com/nodejs/node/raw/0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c/doc%2Fapi%2Frepl.md",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/doc%2Fapi%2Frepl.md?ref=0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c",
            "patch": "@@ -448,6 +448,22 @@ deprecated: v9.0.0\n An internal method used to parse and execute `REPLServer` keywords.\n Returns `true` if `keyword` is a valid keyword, otherwise `false`.\n \n+### replServer.setupHistory(historyPath, callback)\n+<!-- YAML\n+added: REPLACEME\n+-->\n+\n+* `historyPath` {string} the path to the history file\n+* `callback` {Function} called when history writes are ready or upon error\n+  * `err` {Error}\n+  * `repl` {repl.REPLServer}\n+\n+Initializes a history log file for the REPL instance. When executing the\n+Node.js binary and using the command line REPL, a history file is initialized\n+by default. However, this is not the case when creating a REPL\n+programmatically. Use this method to initialize a history log file when working\n+with REPL instances programmatically.\n+\n ## repl.start([options])\n <!-- YAML\n added: v0.1.91"
        },
        {
            "sha": "321f4ab29eba5923cadf9758077824d5814fd26c",
            "filename": "lib/internal/repl.js",
            "status": "modified",
            "additions": 2,
            "deletions": 158,
            "changes": 160,
            "blob_url": "https://github.com/nodejs/node/blob/0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c/lib%2Finternal%2Frepl.js",
            "raw_url": "https://github.com/nodejs/node/raw/0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c/lib%2Finternal%2Frepl.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Frepl.js?ref=0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c",
            "patch": "@@ -1,24 +1,10 @@\n 'use strict';\n \n-const { Interface } = require('readline');\n const REPL = require('repl');\n-const path = require('path');\n-const fs = require('fs');\n-const os = require('os');\n-const util = require('util');\n-const debug = util.debuglog('repl');\n+\n module.exports = Object.create(REPL);\n module.exports.createInternalRepl = createRepl;\n \n-// XXX(chrisdickinson): The 15ms debounce value is somewhat arbitrary.\n-// The debounce is to guard against code pasted into the REPL.\n-const kDebounceHistoryMS = 15;\n-\n-function _writeToOutput(repl, message) {\n-  repl._writeToOutput(message);\n-  repl._refreshLine();\n-}\n-\n function createRepl(env, opts, cb) {\n   if (typeof opts === 'function') {\n     cb = opts;\n@@ -55,151 +41,9 @@ function createRepl(env, opts, cb) {\n   if (!Number.isNaN(historySize) && historySize > 0) {\n     opts.historySize = historySize;\n   } else {\n-    // XXX(chrisdickinson): set here to avoid affecting existing applications\n-    // using repl instances.\n     opts.historySize = 1000;\n   }\n \n   const repl = REPL.start(opts);\n-  if (opts.terminal) {\n-    return setupHistory(repl, env.NODE_REPL_HISTORY, cb);\n-  }\n-\n-  repl._historyPrev = _replHistoryMessage;\n-  cb(null, repl);\n-}\n-\n-function setupHistory(repl, historyPath, ready) {\n-  // Empty string disables persistent history\n-  if (typeof historyPath === 'string')\n-    historyPath = historyPath.trim();\n-\n-  if (historyPath === '') {\n-    repl._historyPrev = _replHistoryMessage;\n-    return ready(null, repl);\n-  }\n-\n-  if (!historyPath) {\n-    try {\n-      historyPath = path.join(os.homedir(), '.node_repl_history');\n-    } catch (err) {\n-      _writeToOutput(repl, '\\nError: Could not get the home directory.\\n' +\n-                     'REPL session history will not be persisted.\\n');\n-\n-      debug(err.stack);\n-      repl._historyPrev = _replHistoryMessage;\n-      return ready(null, repl);\n-    }\n-  }\n-\n-  var timer = null;\n-  var writing = false;\n-  var pending = false;\n-  repl.pause();\n-  // History files are conventionally not readable by others:\n-  // https://github.com/nodejs/node/issues/3392\n-  // https://github.com/nodejs/node/pull/3394\n-  fs.open(historyPath, 'a+', 0o0600, oninit);\n-\n-  function oninit(err, hnd) {\n-    if (err) {\n-      // Cannot open history file.\n-      // Don't crash, just don't persist history.\n-      _writeToOutput(repl, '\\nError: Could not open history file.\\n' +\n-                           'REPL session history will not be persisted.\\n');\n-      debug(err.stack);\n-\n-      repl._historyPrev = _replHistoryMessage;\n-      repl.resume();\n-      return ready(null, repl);\n-    }\n-    fs.close(hnd, onclose);\n-  }\n-\n-  function onclose(err) {\n-    if (err) {\n-      return ready(err);\n-    }\n-    fs.readFile(historyPath, 'utf8', onread);\n-  }\n-\n-  function onread(err, data) {\n-    if (err) {\n-      return ready(err);\n-    }\n-\n-    if (data) {\n-      repl.history = data.split(/[\\n\\r]+/, repl.historySize);\n-    } else {\n-      repl.history = [];\n-    }\n-\n-    fs.open(historyPath, 'r+', onhandle);\n-  }\n-\n-  function onhandle(err, hnd) {\n-    if (err) {\n-      return ready(err);\n-    }\n-    fs.ftruncate(hnd, 0, (err) => {\n-      repl._historyHandle = hnd;\n-      repl.on('line', online);\n-\n-      // Reading the file data out erases it\n-      repl.once('flushHistory', function() {\n-        repl.resume();\n-        ready(null, repl);\n-      });\n-      flushHistory();\n-    });\n-  }\n-\n-  // ------ history listeners ------\n-  function online() {\n-    repl._flushing = true;\n-\n-    if (timer) {\n-      clearTimeout(timer);\n-    }\n-\n-    timer = setTimeout(flushHistory, kDebounceHistoryMS);\n-  }\n-\n-  function flushHistory() {\n-    timer = null;\n-    if (writing) {\n-      pending = true;\n-      return;\n-    }\n-    writing = true;\n-    const historyData = repl.history.join(os.EOL);\n-    fs.write(repl._historyHandle, historyData, 0, 'utf8', onwritten);\n-  }\n-\n-  function onwritten(err, data) {\n-    writing = false;\n-    if (pending) {\n-      pending = false;\n-      online();\n-    } else {\n-      repl._flushing = Boolean(timer);\n-      if (!repl._flushing) {\n-        repl.emit('flushHistory');\n-      }\n-    }\n-  }\n-}\n-\n-\n-function _replHistoryMessage() {\n-  if (this.history.length === 0) {\n-    _writeToOutput(\n-      this,\n-      '\\nPersistent history support disabled. ' +\n-        'Set the NODE_REPL_HISTORY environment\\nvariable to ' +\n-        'a valid, user-writable path to enable.\\n'\n-    );\n-  }\n-  this._historyPrev = Interface.prototype._historyPrev;\n-  return this._historyPrev();\n+  repl.setupHistory(opts.terminal ? env.NODE_REPL_HISTORY : '', cb);\n }"
        },
        {
            "sha": "a0ae07441eb91283cb698308e3c06faf272364fa",
            "filename": "lib/internal/repl/history.js",
            "status": "added",
            "additions": 153,
            "deletions": 0,
            "changes": 153,
            "blob_url": "https://github.com/nodejs/node/blob/0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c/lib%2Finternal%2Frepl%2Fhistory.js",
            "raw_url": "https://github.com/nodejs/node/raw/0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c/lib%2Finternal%2Frepl%2Fhistory.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Finternal%2Frepl%2Fhistory.js?ref=0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c",
            "patch": "@@ -0,0 +1,153 @@\n+'use strict';\n+\n+const { Interface } = require('readline');\n+const path = require('path');\n+const fs = require('fs');\n+const os = require('os');\n+const util = require('util');\n+const debug = util.debuglog('repl');\n+\n+// XXX(chrisdickinson): The 15ms debounce value is somewhat arbitrary.\n+// The debounce is to guard against code pasted into the REPL.\n+const kDebounceHistoryMS = 15;\n+\n+module.exports = setupHistory;\n+\n+function _writeToOutput(repl, message) {\n+  repl._writeToOutput(message);\n+  repl._refreshLine();\n+}\n+\n+function setupHistory(repl, historyPath, ready) {\n+  // Empty string disables persistent history\n+  if (typeof historyPath === 'string')\n+    historyPath = historyPath.trim();\n+\n+  if (historyPath === '') {\n+    repl._historyPrev = _replHistoryMessage;\n+    return ready(null, repl);\n+  }\n+\n+  if (!historyPath) {\n+    try {\n+      historyPath = path.join(os.homedir(), '.node_repl_history');\n+    } catch (err) {\n+      _writeToOutput(repl, '\\nError: Could not get the home directory.\\n' +\n+        'REPL session history will not be persisted.\\n');\n+\n+      debug(err.stack);\n+      repl._historyPrev = _replHistoryMessage;\n+      return ready(null, repl);\n+    }\n+  }\n+\n+  var timer = null;\n+  var writing = false;\n+  var pending = false;\n+  repl.pause();\n+  // History files are conventionally not readable by others:\n+  // https://github.com/nodejs/node/issues/3392\n+  // https://github.com/nodejs/node/pull/3394\n+  fs.open(historyPath, 'a+', 0o0600, oninit);\n+\n+  function oninit(err, hnd) {\n+    if (err) {\n+      // Cannot open history file.\n+      // Don't crash, just don't persist history.\n+      _writeToOutput(repl, '\\nError: Could not open history file.\\n' +\n+        'REPL session history will not be persisted.\\n');\n+      debug(err.stack);\n+\n+      repl._historyPrev = _replHistoryMessage;\n+      repl.resume();\n+      return ready(null, repl);\n+    }\n+    fs.close(hnd, onclose);\n+  }\n+\n+  function onclose(err) {\n+    if (err) {\n+      return ready(err);\n+    }\n+    fs.readFile(historyPath, 'utf8', onread);\n+  }\n+\n+  function onread(err, data) {\n+    if (err) {\n+      return ready(err);\n+    }\n+\n+    if (data) {\n+      repl.history = data.split(/[\\n\\r]+/, repl.historySize);\n+    } else {\n+      repl.history = [];\n+    }\n+\n+    fs.open(historyPath, 'r+', onhandle);\n+  }\n+\n+  function onhandle(err, hnd) {\n+    if (err) {\n+      return ready(err);\n+    }\n+    fs.ftruncate(hnd, 0, (err) => {\n+      repl._historyHandle = hnd;\n+      repl.on('line', online);\n+\n+      // Reading the file data out erases it\n+      repl.once('flushHistory', function() {\n+        repl.resume();\n+        ready(null, repl);\n+      });\n+      flushHistory();\n+    });\n+  }\n+\n+  // ------ history listeners ------\n+  function online(line) {\n+    repl._flushing = true;\n+\n+    if (timer) {\n+      clearTimeout(timer);\n+    }\n+\n+    timer = setTimeout(flushHistory, kDebounceHistoryMS);\n+  }\n+\n+  function flushHistory() {\n+    timer = null;\n+    if (writing) {\n+      pending = true;\n+      return;\n+    }\n+    writing = true;\n+    const historyData = repl.history.join(os.EOL);\n+    fs.write(repl._historyHandle, historyData, 0, 'utf8', onwritten);\n+  }\n+\n+  function onwritten(err, data) {\n+    writing = false;\n+    if (pending) {\n+      pending = false;\n+      online();\n+    } else {\n+      repl._flushing = Boolean(timer);\n+      if (!repl._flushing) {\n+        repl.emit('flushHistory');\n+      }\n+    }\n+  }\n+}\n+\n+function _replHistoryMessage() {\n+  if (this.history.length === 0) {\n+    _writeToOutput(\n+      this,\n+      '\\nPersistent history support disabled. ' +\n+      'Set the NODE_REPL_HISTORY environment\\nvariable to ' +\n+      'a valid, user-writable path to enable.\\n'\n+    );\n+  }\n+  this._historyPrev = Interface.prototype._historyPrev;\n+  return this._historyPrev();\n+}"
        },
        {
            "sha": "1f89f43c241488cd7075a62261f58f0d33fe314d",
            "filename": "lib/repl.js",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c/lib%2Frepl.js",
            "raw_url": "https://github.com/nodejs/node/raw/0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c/lib%2Frepl.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/lib%2Frepl.js?ref=0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c",
            "patch": "@@ -82,6 +82,7 @@ const {\n   startSigintWatchdog,\n   stopSigintWatchdog\n } = internalBinding('util');\n+const history = require('internal/repl/history');\n \n // Lazy-loaded.\n let processTopLevelAwait;\n@@ -762,6 +763,10 @@ exports.start = function(prompt,\n   return repl;\n };\n \n+REPLServer.prototype.setupHistory = function setupHistory(historyFile, cb) {\n+  history(this, historyFile, cb);\n+};\n+\n REPLServer.prototype.clearBufferedCommand = function clearBufferedCommand() {\n   this[kBufferedCommandSymbol] = '';\n };"
        },
        {
            "sha": "efafbb7afacb2b2940bd14f01c14b039556f52c4",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c",
            "patch": "@@ -172,6 +172,7 @@\n       'lib/internal/readline.js',\n       'lib/internal/repl.js',\n       'lib/internal/repl/await.js',\n+      'lib/internal/repl/history.js',\n       'lib/internal/repl/recoverable.js',\n       'lib/internal/socket_list.js',\n       'lib/internal/test/binding.js',"
        },
        {
            "sha": "7eda401a7c386b6047e8d601a95c12431d24db18",
            "filename": "test/parallel/test-repl-programmatic-history.js",
            "status": "added",
            "additions": 245,
            "deletions": 0,
            "changes": 245,
            "blob_url": "https://github.com/nodejs/node/blob/0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c/test%2Fparallel%2Ftest-repl-programmatic-history.js",
            "raw_url": "https://github.com/nodejs/node/raw/0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c/test%2Fparallel%2Ftest-repl-programmatic-history.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-repl-programmatic-history.js?ref=0aa74443d8bdea3c3840dbc3d4bd700b05ca7a4c",
            "patch": "@@ -0,0 +1,245 @@\n+'use strict';\n+\n+const common = require('../common');\n+const fixtures = require('../common/fixtures');\n+const stream = require('stream');\n+const REPL = require('repl');\n+const assert = require('assert');\n+const fs = require('fs');\n+const path = require('path');\n+const os = require('os');\n+\n+const tmpdir = require('../common/tmpdir');\n+tmpdir.refresh();\n+\n+// Mock os.homedir()\n+os.homedir = function() {\n+  return tmpdir.path;\n+};\n+\n+// Create an input stream specialized for testing an array of actions\n+class ActionStream extends stream.Stream {\n+  run(data) {\n+    const _iter = data[Symbol.iterator]();\n+    const doAction = () => {\n+      const next = _iter.next();\n+      if (next.done) {\n+        // Close the repl. Note that it must have a clean prompt to do so.\n+        setImmediate(() => {\n+          this.emit('keypress', '', { ctrl: true, name: 'd' });\n+        });\n+        return;\n+      }\n+      const action = next.value;\n+\n+      if (typeof action === 'object') {\n+        this.emit('keypress', '', action);\n+      } else {\n+        this.emit('data', `${action}\\n`);\n+      }\n+      setImmediate(doAction);\n+    };\n+    setImmediate(doAction);\n+  }\n+  resume() {}\n+  pause() {}\n+}\n+ActionStream.prototype.readable = true;\n+\n+\n+// Mock keys\n+const UP = { name: 'up' };\n+const ENTER = { name: 'enter' };\n+const CLEAR = { ctrl: true, name: 'u' };\n+\n+// File paths\n+const historyFixturePath = fixtures.path('.node_repl_history');\n+const historyPath = path.join(tmpdir.path, '.fixture_copy_repl_history');\n+const historyPathFail = fixtures.path('nonexistent_folder', 'filename');\n+const defaultHistoryPath = path.join(tmpdir.path, '.node_repl_history');\n+const emptyHiddenHistoryPath = fixtures.path('.empty-hidden-repl-history-file');\n+const devNullHistoryPath = path.join(tmpdir.path,\n+                                     '.dev-null-repl-history-file');\n+// Common message bits\n+const prompt = '> ';\n+const replDisabled = '\\nPersistent history support disabled. Set the ' +\n+                     'NODE_REPL_HISTORY environment\\nvariable to a valid, ' +\n+                     'user-writable path to enable.\\n';\n+const homedirErr = '\\nError: Could not get the home directory.\\n' +\n+                   'REPL session history will not be persisted.\\n';\n+const replFailedRead = '\\nError: Could not open history file.\\n' +\n+                       'REPL session history will not be persisted.\\n';\n+\n+const tests = [\n+  {\n+    env: { NODE_REPL_HISTORY: '' },\n+    test: [UP],\n+    expected: [prompt, replDisabled, prompt]\n+  },\n+  {\n+    env: { NODE_REPL_HISTORY: ' ' },\n+    test: [UP],\n+    expected: [prompt, replDisabled, prompt]\n+  },\n+  {\n+    env: { NODE_REPL_HISTORY: historyPath },\n+    test: [UP, CLEAR],\n+    expected: [prompt, `${prompt}'you look fabulous today'`, prompt]\n+  },\n+  {\n+    env: {},\n+    test: [UP, '\\'42\\'', ENTER],\n+    expected: [prompt, '\\'', '4', '2', '\\'', '\\'42\\'\\n', prompt, prompt],\n+    clean: false\n+  },\n+  { // Requires the above test case\n+    env: {},\n+    test: [UP, UP, ENTER],\n+    expected: [prompt, `${prompt}'42'`, '\\'42\\'\\n', prompt]\n+  },\n+  {\n+    env: { NODE_REPL_HISTORY: historyPath,\n+           NODE_REPL_HISTORY_SIZE: 1 },\n+    test: [UP, UP, CLEAR],\n+    expected: [prompt, `${prompt}'you look fabulous today'`, prompt]\n+  },\n+  {\n+    env: { NODE_REPL_HISTORY: historyPathFail,\n+           NODE_REPL_HISTORY_SIZE: 1 },\n+    test: [UP],\n+    expected: [prompt, replFailedRead, prompt, replDisabled, prompt]\n+  },\n+  {\n+    before: function before() {\n+      if (common.isWindows) {\n+        const execSync = require('child_process').execSync;\n+        execSync(`ATTRIB +H \"${emptyHiddenHistoryPath}\"`, (err) => {\n+          assert.ifError(err);\n+        });\n+      }\n+    },\n+    env: { NODE_REPL_HISTORY: emptyHiddenHistoryPath },\n+    test: [UP],\n+    expected: [prompt]\n+  },\n+  {\n+    before: function before() {\n+      if (!common.isWindows)\n+        fs.symlinkSync('/dev/null', devNullHistoryPath);\n+    },\n+    env: { NODE_REPL_HISTORY: devNullHistoryPath },\n+    test: [UP],\n+    expected: [prompt]\n+  },\n+  { // Make sure this is always the last test, since we change os.homedir()\n+    before: function before() {\n+      // Mock os.homedir() failure\n+      os.homedir = function() {\n+        throw new Error('os.homedir() failure');\n+      };\n+    },\n+    env: {},\n+    test: [UP],\n+    expected: [prompt, homedirErr, prompt, replDisabled, prompt]\n+  }\n+];\n+const numtests = tests.length;\n+\n+\n+function cleanupTmpFile() {\n+  try {\n+    // Write over the file, clearing any history\n+    fs.writeFileSync(defaultHistoryPath, '');\n+  } catch (err) {\n+    if (err.code === 'ENOENT') return true;\n+    throw err;\n+  }\n+  return true;\n+}\n+\n+// Copy our fixture to the tmp directory\n+fs.createReadStream(historyFixturePath)\n+  .pipe(fs.createWriteStream(historyPath)).on('unpipe', () => runTest());\n+\n+const runTestWrap = common.mustCall(runTest, numtests);\n+\n+function runTest(assertCleaned) {\n+  const opts = tests.shift();\n+  if (!opts) return; // All done\n+\n+  if (assertCleaned) {\n+    try {\n+      assert.strictEqual(fs.readFileSync(defaultHistoryPath, 'utf8'), '');\n+    } catch (e) {\n+      if (e.code !== 'ENOENT') {\n+        console.error(`Failed test # ${numtests - tests.length}`);\n+        throw e;\n+      }\n+    }\n+  }\n+\n+  const test = opts.test;\n+  const expected = opts.expected;\n+  const clean = opts.clean;\n+  const before = opts.before;\n+  const historySize = opts.env.NODE_REPL_HISTORY_SIZE;\n+  const historyFile = opts.env.NODE_REPL_HISTORY;\n+\n+  if (before) before();\n+\n+  const repl = REPL.start({\n+    input: new ActionStream(),\n+    output: new stream.Writable({\n+      write(chunk, _, next) {\n+        const output = chunk.toString();\n+\n+        // Ignore escapes and blank lines\n+        if (output.charCodeAt(0) === 27 || /^[\\r\\n]+$/.test(output))\n+          return next();\n+\n+        try {\n+          assert.strictEqual(output, expected.shift());\n+        } catch (err) {\n+          console.error(`Failed test # ${numtests - tests.length}`);\n+          throw err;\n+        }\n+        next();\n+      }\n+    }),\n+    prompt: prompt,\n+    useColors: false,\n+    terminal: true,\n+    historySize: historySize\n+  });\n+\n+  repl.setupHistory(historyFile, function(err, repl) {\n+    if (err) {\n+      console.error(`Failed test # ${numtests - tests.length}`);\n+      throw err;\n+    }\n+\n+    repl.once('close', () => {\n+      if (repl._flushing) {\n+        repl.once('flushHistory', onClose);\n+        return;\n+      }\n+\n+      onClose();\n+    });\n+\n+    function onClose() {\n+      const cleaned = clean === false ? false : cleanupTmpFile();\n+\n+      try {\n+        // Ensure everything that we expected was output\n+        assert.strictEqual(expected.length, 0);\n+        setImmediate(runTestWrap, cleaned);\n+      } catch (err) {\n+        console.error(`Failed test # ${numtests - tests.length}`);\n+        throw err;\n+      }\n+    }\n+\n+    repl.inputStream.run(test);\n+  });\n+}"
        }
    ],
    "stats": {
        "total": 580,
        "additions": 422,
        "deletions": 158
    }
}