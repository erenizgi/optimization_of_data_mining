{
    "author": "chinhuang007",
    "message": "src: add sync trace to fs\n\nAdd sync trace to fs operations which\nis enabled by the node.fs.sync trace event\ncategory. Also add a general test js file\nto verify all operations.\n\nPR-URL: https://github.com/nodejs/node/pull/19649\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Michael Dawson <michael_dawson@ca.ibm.com>",
    "sha": "09c63460ebda30c7d5e7f40532a311fb2139803a",
    "files": [
        {
            "sha": "28a128b89c342cd0e7835d4beab5e34bb4e9afdf",
            "filename": "src/node_file.cc",
            "status": "modified",
            "additions": 76,
            "deletions": 1,
            "changes": 77,
            "blob_url": "https://github.com/nodejs/node/blob/09c63460ebda30c7d5e7f40532a311fb2139803a/src%2Fnode_file.cc",
            "raw_url": "https://github.com/nodejs/node/raw/09c63460ebda30c7d5e7f40532a311fb2139803a/src%2Fnode_file.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_file.cc?ref=09c63460ebda30c7d5e7f40532a311fb2139803a",
            "patch": "@@ -24,6 +24,7 @@\n #include \"node_internals.h\"\n #include \"node_stat_watcher.h\"\n #include \"node_file.h\"\n+#include \"tracing/trace_event.h\"\n \n #include \"req_wrap-inl.h\"\n #include \"stream_base-inl.h\"\n@@ -75,6 +76,18 @@ using v8::Value;\n #endif\n \n #define GET_OFFSET(a) ((a)->IsNumber() ? (a).As<Integer>()->Value() : -1)\n+#define TRACE_NAME(name) \"fs.sync.\" #name\n+#define GET_TRACE_ENABLED                                                  \\\n+  (*TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED                             \\\n+  (TRACING_CATEGORY_NODE2(fs, sync)) != 0)\n+#define FS_SYNC_TRACE_BEGIN(syscall, ...)                                  \\\n+  if (GET_TRACE_ENABLED)                                                   \\\n+  TRACE_EVENT_BEGIN(TRACING_CATEGORY_NODE2(fs, sync), TRACE_NAME(syscall), \\\n+  ##__VA_ARGS__);\n+#define FS_SYNC_TRACE_END(syscall, ...)                                    \\\n+  if (GET_TRACE_ENABLED)                                                   \\\n+  TRACE_EVENT_END(TRACING_CATEGORY_NODE2(fs, sync), TRACE_NAME(syscall),   \\\n+  ##__VA_ARGS__);\n \n // The FileHandle object wraps a file descriptor and will close it on garbage\n // collection if necessary. If that happens, a process warning will be\n@@ -316,7 +329,7 @@ int FileHandle::ReadStart() {\n \n     // ReadStart() checks whether current_read_ is set to determine whether\n     // a read is in progress. Moving it into a local variable makes sure that\n-    // the ReadStart() call below doesn’t think we’re still actively reading.\n+    // the ReadStart() call below doesn't think we're still actively reading.\n     std::unique_ptr<FileHandleReadWrap> read_wrap =\n         std::move(handle->current_read_);\n \n@@ -683,7 +696,9 @@ void Access(const FunctionCallbackInfo<Value>& args) {\n   } else {  // access(path, mode, undefined, ctx)\n     CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(access);\n     SyncCall(env, args[3], &req_wrap_sync, \"access\", uv_fs_access, *path, mode);\n+    FS_SYNC_TRACE_END(access);\n   }\n }\n \n@@ -704,7 +719,9 @@ void Close(const FunctionCallbackInfo<Value>& args) {\n   } else {  // close(fd, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(close);\n     SyncCall(env, args[2], &req_wrap_sync, \"close\", uv_fs_close, fd);\n+    FS_SYNC_TRACE_END(close);\n   }\n }\n \n@@ -812,7 +829,9 @@ static void Stat(const FunctionCallbackInfo<Value>& args) {\n   } else {  // stat(path, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(stat);\n     int err = SyncCall(env, args[2], &req_wrap_sync, \"stat\", uv_fs_stat, *path);\n+    FS_SYNC_TRACE_END(stat);\n     if (err == 0) {\n       node::FillGlobalStatsArray(env,\n           static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));\n@@ -836,8 +855,10 @@ static void LStat(const FunctionCallbackInfo<Value>& args) {\n   } else {  // lstat(path, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(lstat);\n     int err = SyncCall(env, args[2], &req_wrap_sync, \"lstat\", uv_fs_lstat,\n                        *path);\n+    FS_SYNC_TRACE_END(lstat);\n     if (err == 0) {\n       node::FillGlobalStatsArray(env,\n           static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));\n@@ -861,7 +882,9 @@ static void FStat(const FunctionCallbackInfo<Value>& args) {\n   } else {  // fstat(fd, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(fstat);\n     int err = SyncCall(env, args[2], &req_wrap_sync, \"fstat\", uv_fs_fstat, fd);\n+    FS_SYNC_TRACE_END(fstat);\n     if (err == 0) {\n       node::FillGlobalStatsArray(env,\n           static_cast<const uv_stat_t*>(req_wrap_sync.req.ptr));\n@@ -890,8 +913,10 @@ static void Symlink(const FunctionCallbackInfo<Value>& args) {\n   } else {  // symlink(target, path, flags, undefinec, ctx)\n     CHECK_EQ(argc, 5);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(symlink);\n     SyncCall(env, args[4], &req_wrap_sync, \"symlink\",\n              uv_fs_symlink, *target, *path, flags);\n+    FS_SYNC_TRACE_END(symlink);\n   }\n }\n \n@@ -914,8 +939,10 @@ static void Link(const FunctionCallbackInfo<Value>& args) {\n   } else {  // link(src, dest)\n     CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(link);\n     SyncCall(env, args[3], &req_wrap_sync, \"link\",\n              uv_fs_link, *src, *dest);\n+    FS_SYNC_TRACE_END(link);\n   }\n }\n \n@@ -937,8 +964,10 @@ static void ReadLink(const FunctionCallbackInfo<Value>& args) {\n   } else {\n     CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(readlink);\n     int err = SyncCall(env, args[3], &req_wrap_sync, \"readlink\",\n                        uv_fs_readlink, *path);\n+    FS_SYNC_TRACE_END(readlink);\n     if (err < 0) {\n       return;  // syscall failed, no need to continue, error info is in ctx\n     }\n@@ -978,8 +1007,10 @@ static void Rename(const FunctionCallbackInfo<Value>& args) {\n   } else {\n     CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(rename);\n     SyncCall(env, args[3], &req_wrap_sync, \"rename\", uv_fs_rename,\n              *old_path, *new_path);\n+    FS_SYNC_TRACE_END(rename);\n   }\n }\n \n@@ -1002,8 +1033,10 @@ static void FTruncate(const FunctionCallbackInfo<Value>& args) {\n   } else {\n     CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(ftruncate);\n     SyncCall(env, args[3], &req_wrap_sync, \"ftruncate\", uv_fs_ftruncate, fd,\n              len);\n+    FS_SYNC_TRACE_END(ftruncate);\n   }\n }\n \n@@ -1023,7 +1056,9 @@ static void Fdatasync(const FunctionCallbackInfo<Value>& args) {\n   } else {\n     CHECK_EQ(argc, 3);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(fdatasync);\n     SyncCall(env, args[2], &req_wrap_sync, \"fdatasync\", uv_fs_fdatasync, fd);\n+    FS_SYNC_TRACE_END(fdatasync);\n   }\n }\n \n@@ -1043,7 +1078,9 @@ static void Fsync(const FunctionCallbackInfo<Value>& args) {\n   } else {\n     CHECK_EQ(argc, 3);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(fsync);\n     SyncCall(env, args[2], &req_wrap_sync, \"fsync\", uv_fs_fsync, fd);\n+    FS_SYNC_TRACE_END(fsync);\n   }\n }\n \n@@ -1063,7 +1100,9 @@ static void Unlink(const FunctionCallbackInfo<Value>& args) {\n   } else {\n     CHECK_EQ(argc, 3);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(unlink);\n     SyncCall(env, args[2], &req_wrap_sync, \"unlink\", uv_fs_unlink, *path);\n+    FS_SYNC_TRACE_END(unlink);\n   }\n }\n \n@@ -1083,8 +1122,10 @@ static void RMDir(const FunctionCallbackInfo<Value>& args) {\n   } else {  // rmdir(path, undefined, ctx)\n     CHECK_EQ(argc, 3);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(rmdir);\n     SyncCall(env, args[2], &req_wrap_sync, \"rmdir\",\n              uv_fs_rmdir, *path);\n+    FS_SYNC_TRACE_END(rmdir);\n   }\n }\n \n@@ -1107,8 +1148,10 @@ static void MKDir(const FunctionCallbackInfo<Value>& args) {\n   } else {  // mkdir(path, mode, undefined, ctx)\n     CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(mkdir);\n     SyncCall(env, args[3], &req_wrap_sync, \"mkdir\",\n              uv_fs_mkdir, *path, mode);\n+    FS_SYNC_TRACE_END(mkdir);\n   }\n }\n \n@@ -1130,8 +1173,10 @@ static void RealPath(const FunctionCallbackInfo<Value>& args) {\n   } else {  // realpath(path, encoding, undefined, ctx)\n     CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(realpath);\n     int err = SyncCall(env, args[3], &req_wrap_sync, \"realpath\",\n                        uv_fs_realpath, *path);\n+    FS_SYNC_TRACE_END(realpath);\n     if (err < 0) {\n       return;  // syscall failed, no need to continue, error info is in ctx\n     }\n@@ -1171,8 +1216,10 @@ static void ReadDir(const FunctionCallbackInfo<Value>& args) {\n   } else {  // readdir(path, encoding, undefined, ctx)\n     CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(readdir);\n     int err = SyncCall(env, args[3], &req_wrap_sync, \"scandir\",\n                        uv_fs_scandir, *path, 0 /*flags*/);\n+    FS_SYNC_TRACE_END(readdir);\n     if (err < 0) {\n       return;  // syscall failed, no need to continue, error info is in ctx\n     }\n@@ -1255,8 +1302,10 @@ static void Open(const FunctionCallbackInfo<Value>& args) {\n   } else {  // open(path, flags, mode, undefined, ctx)\n     CHECK_EQ(argc, 5);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(open);\n     int result = SyncCall(env, args[4], &req_wrap_sync, \"open\",\n                           uv_fs_open, *path, flags, mode);\n+    FS_SYNC_TRACE_END(open);\n     args.GetReturnValue().Set(result);\n   }\n }\n@@ -1283,8 +1332,10 @@ static void OpenFileHandle(const FunctionCallbackInfo<Value>& args) {\n   } else {  // openFileHandle(path, flags, mode, undefined, ctx)\n     CHECK_EQ(argc, 5);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(open);\n     int result = SyncCall(env, args[4], &req_wrap_sync, \"open\",\n                           uv_fs_open, *path, flags, mode);\n+    FS_SYNC_TRACE_END(open);\n     if (result < 0) {\n       return;  // syscall failed, no need to continue, error info is in ctx\n     }\n@@ -1317,8 +1368,10 @@ static void CopyFile(const FunctionCallbackInfo<Value>& args) {\n   } else {  // copyFile(src, dest, flags, undefined, ctx)\n     CHECK_EQ(argc, 5);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(copyfile);\n     SyncCall(env, args[4], &req_wrap_sync, \"copyfile\",\n              uv_fs_copyfile, *src, *dest, flags);\n+    FS_SYNC_TRACE_END(copyfile);\n   }\n }\n \n@@ -1368,8 +1421,10 @@ static void WriteBuffer(const FunctionCallbackInfo<Value>& args) {\n   } else {  // write(fd, buffer, off, len, pos, undefined, ctx)\n     CHECK_EQ(argc, 7);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(write);\n     int bytesWritten = SyncCall(env, args[6], &req_wrap_sync, \"write\",\n                                 uv_fs_write, fd, &uvbuf, 1, pos);\n+    FS_SYNC_TRACE_END(write, \"bytesWritten\", bytesWritten);\n     args.GetReturnValue().Set(bytesWritten);\n   }\n }\n@@ -1411,8 +1466,10 @@ static void WriteBuffers(const FunctionCallbackInfo<Value>& args) {\n   } else {  // writeBuffers(fd, chunks, pos, undefined, ctx)\n     CHECK_EQ(argc, 5);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(write);\n     int bytesWritten = SyncCall(env, args[4], &req_wrap_sync, \"write\",\n                                 uv_fs_write, fd, *iovs, iovs.length(), pos);\n+    FS_SYNC_TRACE_END(write, \"bytesWritten\", bytesWritten);\n     args.GetReturnValue().Set(bytesWritten);\n   }\n }\n@@ -1503,8 +1560,10 @@ static void WriteString(const FunctionCallbackInfo<Value>& args) {\n       buf = *stack_buffer;\n     }\n     uv_buf_t uvbuf = uv_buf_init(buf, len);\n+    FS_SYNC_TRACE_BEGIN(write);\n     int bytesWritten = SyncCall(env, args[5], &req_wrap_sync, \"write\",\n                                 uv_fs_write, fd, &uvbuf, 1, pos);\n+    FS_SYNC_TRACE_END(write, \"bytesWritten\", bytesWritten);\n     args.GetReturnValue().Set(bytesWritten);\n   }\n }\n@@ -1556,8 +1615,10 @@ static void Read(const FunctionCallbackInfo<Value>& args) {\n   } else {  // read(fd, buffer, offset, len, pos, undefined, ctx)\n     CHECK_EQ(argc, 7);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(read);\n     const int bytesRead = SyncCall(env, args[6], &req_wrap_sync, \"read\",\n                                    uv_fs_read, fd, &uvbuf, 1, pos);\n+    FS_SYNC_TRACE_END(read, \"bytesRead\", bytesRead);\n     args.GetReturnValue().Set(bytesRead);\n   }\n }\n@@ -1585,8 +1646,10 @@ static void Chmod(const FunctionCallbackInfo<Value>& args) {\n   } else {  // chmod(path, mode, undefined, ctx)\n     CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(chmod);\n     SyncCall(env, args[3], &req_wrap_sync, \"chmod\",\n              uv_fs_chmod, *path, mode);\n+    FS_SYNC_TRACE_END(chmod);\n   }\n }\n \n@@ -1613,8 +1676,10 @@ static void FChmod(const FunctionCallbackInfo<Value>& args) {\n   } else {  // fchmod(fd, mode, undefined, ctx)\n     CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(fchmod);\n     SyncCall(env, args[3], &req_wrap_sync, \"fchmod\",\n              uv_fs_fchmod, fd, mode);\n+    FS_SYNC_TRACE_END(fchmod);\n   }\n }\n \n@@ -1644,8 +1709,10 @@ static void Chown(const FunctionCallbackInfo<Value>& args) {\n   } else {  // chown(path, uid, gid, undefined, ctx)\n     CHECK_EQ(argc, 5);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(chown);\n     SyncCall(env, args[4], &req_wrap_sync, \"chown\",\n              uv_fs_chown, *path, uid, gid);\n+    FS_SYNC_TRACE_END(chown);\n   }\n }\n \n@@ -1675,8 +1742,10 @@ static void FChown(const FunctionCallbackInfo<Value>& args) {\n   } else {  // fchown(fd, uid, gid, undefined, ctx)\n     CHECK_EQ(argc, 5);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(fchown);\n     SyncCall(env, args[4], &req_wrap_sync, \"fchown\",\n              uv_fs_fchown, fd, uid, gid);\n+    FS_SYNC_TRACE_END(fchown);\n   }\n }\n \n@@ -1703,8 +1772,10 @@ static void UTimes(const FunctionCallbackInfo<Value>& args) {\n   } else {  // utimes(path, atime, mtime, undefined, ctx)\n     CHECK_EQ(argc, 5);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(utimes);\n     SyncCall(env, args[4], &req_wrap_sync, \"utime\",\n              uv_fs_utime, *path, atime, mtime);\n+    FS_SYNC_TRACE_END(utimes);\n   }\n }\n \n@@ -1730,8 +1801,10 @@ static void FUTimes(const FunctionCallbackInfo<Value>& args) {\n   } else {  // futimes(fd, atime, mtime, undefined, ctx)\n     CHECK_EQ(argc, 5);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(futimes);\n     SyncCall(env, args[4], &req_wrap_sync, \"futime\",\n              uv_fs_futime, fd, atime, mtime);\n+    FS_SYNC_TRACE_END(futimes);\n   }\n }\n \n@@ -1753,8 +1826,10 @@ static void Mkdtemp(const FunctionCallbackInfo<Value>& args) {\n   } else {  // mkdtemp(tmpl, encoding, undefined, ctx)\n     CHECK_EQ(argc, 4);\n     FSReqWrapSync req_wrap_sync;\n+    FS_SYNC_TRACE_BEGIN(mkdtemp);\n     SyncCall(env, args[3], &req_wrap_sync, \"mkdtemp\",\n              uv_fs_mkdtemp, *tmpl);\n+    FS_SYNC_TRACE_END(mkdtemp);\n     const char* path = static_cast<const char*>(req_wrap_sync.req.path);\n \n     Local<Value> error;"
        },
        {
            "sha": "18dd6ec18b35f9a7ac0e75e1c21b30201c654660",
            "filename": "src/tracing/trace_event_common.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/nodejs/node/blob/09c63460ebda30c7d5e7f40532a311fb2139803a/src%2Ftracing%2Ftrace_event_common.h",
            "raw_url": "https://github.com/nodejs/node/raw/09c63460ebda30c7d5e7f40532a311fb2139803a/src%2Ftracing%2Ftrace_event_common.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Ftracing%2Ftrace_event_common.h?ref=09c63460ebda30c7d5e7f40532a311fb2139803a",
            "patch": "@@ -271,6 +271,9 @@\n // does nothing.\n // - category and name strings must have application lifetime (statics or\n //   literals). They may not include \" chars.\n+#define TRACE_EVENT_BEGIN(category_group, name, ...)                  \\\n+  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \\\n+                           TRACE_EVENT_FLAG_NONE, ##__VA_ARGS__)\n #define TRACE_EVENT_BEGIN0(category_group, name)                          \\\n   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \\\n                            TRACE_EVENT_FLAG_NONE)\n@@ -327,6 +330,9 @@\n // is not enabled, then this does nothing.\n // - category and name strings must have application lifetime (statics or\n //   literals). They may not include \" chars.\n+#define TRACE_EVENT_END(category_group, name, ...)                      \\\n+  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name, \\\n+                           TRACE_EVENT_FLAG_NONE, ##__VA_ARGS__)\n #define TRACE_EVENT_END0(category_group, name)                          \\\n   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name, \\\n                            TRACE_EVENT_FLAG_NONE)"
        },
        {
            "sha": "5bd9b99ba3fedfefe112210485c324276f378e3a",
            "filename": "test/parallel/test-trace-events-fs-sync.js",
            "status": "added",
            "additions": 162,
            "deletions": 0,
            "changes": 162,
            "blob_url": "https://github.com/nodejs/node/blob/09c63460ebda30c7d5e7f40532a311fb2139803a/test%2Fparallel%2Ftest-trace-events-fs-sync.js",
            "raw_url": "https://github.com/nodejs/node/raw/09c63460ebda30c7d5e7f40532a311fb2139803a/test%2Fparallel%2Ftest-trace-events-fs-sync.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-trace-events-fs-sync.js?ref=09c63460ebda30c7d5e7f40532a311fb2139803a",
            "patch": "@@ -0,0 +1,162 @@\n+'use strict';\n+const common = require('../common');\n+const assert = require('assert');\n+const cp = require('child_process');\n+const fs = require('fs');\n+\n+const tests = new Array();\n+const traceFile = 'node_trace.1.log';\n+\n+let gid = 1;\n+let uid = 1;\n+let skipSymlinks = false;\n+\n+// On Windows, creating symlinks requires admin privileges.\n+// We'll check if we have enough privileges.\n+if (common.isWindows) {\n+  try {\n+    const o = cp.execSync('whoami /priv');\n+    if (!o.includes('SeCreateSymbolicLinkPrivilege')) {\n+      skipSymlinks = true;\n+    }\n+  } catch (er) {\n+    // better safe than sorry\n+    skipSymlinks = true;\n+  }\n+} else {\n+  gid = process.getgid();\n+  uid = process.getuid();\n+}\n+\n+tests['fs.sync.access'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                          'fs.accessSync(\"fs.txt\");' +\n+                          'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.chmod'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                         'fs.chmodSync(\"fs.txt\",100);' +\n+                         'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.chown'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                         'fs.chownSync(\"fs.txt\",' + uid + ',' + gid + ');' +\n+                         'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.close'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                         'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.copyfile'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                            'fs.copyFileSync(\"fs.txt\",\"a.txt\");' +\n+                            'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.fchmod'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                          'const fd = fs.openSync(\"fs.txt\", \"r+\");' +\n+                          'fs.fchmodSync(fd,100);' +\n+                          'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.fchown'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                          'const fd = fs.openSync(\"fs.txt\", \"r+\");' +\n+                          'fs.fchownSync(fd,' + uid + ',' + gid + ');' +\n+                          'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.fdatasync'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                             'const fd = fs.openSync(\"fs.txt\", \"r+\");' +\n+                             'fs.fdatasyncSync(fd);' +\n+                             'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.fstat'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                         'fs.readFileSync(\"fs.txt\");' +\n+                         'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.fsync'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                         'const fd = fs.openSync(\"fs.txt\", \"r+\");' +\n+                         'fs.fsyncSync(fd);' +\n+                         'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.ftruncate'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                             'const fd = fs.openSync(\"fs.txt\", \"r+\");' +\n+                             'fs.ftruncateSync(fd, 1);' +\n+                             'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.futimes'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                           'const fd = fs.openSync(\"fs.txt\", \"r+\");' +\n+                           'fs.futimesSync(fd,1,1);' +\n+                           'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.link'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                        'fs.linkSync(\"fs.txt\", \"linkx\");' +\n+                        'fs.unlinkSync(\"linkx\");' +\n+                        'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.lstat'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                         'fs.lstatSync(\"fs.txt\");' +\n+                         'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.mkdir'] = 'fs.mkdirSync(\"fstemp\");' +\n+                         'fs.rmdirSync(\"fstemp\")';\n+tests['fs.sync.mkdtemp'] = 'const fp = fs.mkdtempSync(\"fstest\");' +\n+                           'fs.rmdirSync(fp)';\n+tests['fs.sync.open'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                        'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.read'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                        'fs.readFileSync(\"fs.txt\");' +\n+                        'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.readdir'] = 'fs.readdirSync(\"./\")';\n+tests['fs.sync.realpath'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                            'fs.linkSync(\"fs.txt\", \"linkx\");' +\n+                            'fs.realpathSync.native(\"linkx\");' +\n+                            'fs.unlinkSync(\"linkx\");' +\n+                            'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.rename'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                          'fs.renameSync(\"fs.txt\",\"xyz.txt\"); ' +\n+                          'fs.unlinkSync(\"xyz.txt\")';\n+tests['fs.sync.rmdir'] = 'fs.mkdirSync(\"fstemp\");' +\n+                         'fs.rmdirSync(\"fstemp\")';\n+tests['fs.sync.stat'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                        'fs.statSync(\"fs.txt\");' +\n+                        'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.unlink'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                          'fs.linkSync(\"fs.txt\", \"linkx\");' +\n+                          'fs.unlinkSync(\"linkx\");' +\n+                          'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.utimes'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                          'fs.utimesSync(\"fs.txt\",1,1);' +\n+                          'fs.unlinkSync(\"fs.txt\")';\n+tests['fs.sync.write'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                         'fs.unlinkSync(\"fs.txt\")';\n+\n+// On windows, we need permissions to test symlink and readlink.\n+// We'll only try to run these tests if we have enough privileges.\n+if (!skipSymlinks) {\n+  tests['fs.sync.symlink'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                             'fs.symlinkSync(\"fs.txt\", \"linkx\");' +\n+                             'fs.unlinkSync(\"linkx\");' +\n+                             'fs.unlinkSync(\"fs.txt\")';\n+  tests['fs.sync.readlink'] = 'fs.writeFileSync(\"fs.txt\", \"123\", \"utf8\");' +\n+                              'fs.symlinkSync(\"fs.txt\", \"linkx\");' +\n+                              'fs.readlinkSync(\"linkx\");' +\n+                              'fs.unlinkSync(\"linkx\");' +\n+                              'fs.unlinkSync(\"fs.txt\")';\n+}\n+\n+const tmpdir = require('../common/tmpdir');\n+tmpdir.refresh();\n+process.chdir(tmpdir.path);\n+\n+for (const tr in tests) {\n+  const proc = cp.spawnSync(process.execPath,\n+                            [ '--trace-events-enabled',\n+                              '--trace-event-categories', 'node.fs.sync',\n+                              '-e', tests[tr] ]);\n+  // Some AIX versions don't support futimes or utimes, so skip.\n+  if (common.isAIX && proc.status !== 0 && tr === 'fs.sync.futimes') {\n+    continue;\n+  }\n+  if (common.isAIX && proc.status !== 0 && tr === 'fs.sync.utimes') {\n+    continue;\n+  }\n+\n+  // Make sure the operation is successful.\n+  assert.strictEqual(proc.status, 0, tr + ': ' + proc.stderr);\n+\n+  // Confirm that trace log file is created.\n+  assert(common.fileExists(traceFile));\n+  const data = fs.readFileSync(traceFile);\n+  const traces = JSON.parse(data.toString()).traceEvents;\n+  assert(traces.length > 0);\n+\n+  // C++ fs sync trace events should be generated.\n+  assert(traces.some((trace) => {\n+    if (trace.pid !== proc.pid)\n+      return false;\n+    if (trace.cat !== 'node,node.fs,node.fs.sync')\n+      return false;\n+    if (trace.name !== tr)\n+      return false;\n+    return true;\n+  }));\n+}"
        }
    ],
    "stats": {
        "total": 245,
        "additions": 244,
        "deletions": 1
    }
}