{
    "author": "addaleax",
    "message": "src: allocate Buffer memory using ArrayBuffer allocator\n\nAlways use the right allocator for memory that is turned into\nan `ArrayBuffer` at a later point.\n\nThis enables embedders to use their own `ArrayBuffer::Allocator`s,\nand is inspired by Electronâ€™s electron/node@f61bae3440e. It should\nrender their downstream patch unnecessary.\n\nRefs: https://github.com/electron/node/commit/f61bae3440e1bfcc83bba6ff0785adfb89b4045e\n\nPR-URL: https://github.com/nodejs/node/pull/26207\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>",
    "sha": "84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
    "files": [
        {
            "sha": "aca1842c30b37bf054c438db550476c551554198",
            "filename": "src/node_buffer.cc",
            "status": "modified",
            "additions": 40,
            "deletions": 58,
            "changes": 98,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_buffer.cc",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_buffer.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_buffer.cc?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -54,17 +54,6 @@\n   size_t length = end - start;\n \n namespace node {\n-\n-namespace {\n-\n-inline void* BufferMalloc(size_t length) {\n-  return per_process::cli_options->zero_fill_all_buffers ?\n-             node::UncheckedCalloc(length) :\n-             node::UncheckedMalloc(length);\n-}\n-\n-}  // namespace\n-\n namespace Buffer {\n \n using v8::ArrayBuffer;\n@@ -260,7 +249,7 @@ MaybeLocal<Object> New(Isolate* isolate,\n   char* data = nullptr;\n \n   if (length > 0) {\n-    data = static_cast<char*>(BufferMalloc(length));\n+    data = UncheckedMalloc(length);\n \n     if (data == nullptr) {\n       THROW_ERR_MEMORY_ALLOCATION_FAILED(isolate);\n@@ -278,13 +267,7 @@ MaybeLocal<Object> New(Isolate* isolate,\n     }\n   }\n \n-  Local<Object> buf;\n-  if (New(isolate, data, actual).ToLocal(&buf))\n-    return scope.Escape(buf);\n-\n-  // Object failed to be created. Clean up resources.\n-  free(data);\n-  return Local<Object>();\n+  return scope.EscapeMaybe(New(isolate, data, actual));\n }\n \n \n@@ -311,26 +294,16 @@ MaybeLocal<Object> New(Environment* env, size_t length) {\n     return Local<Object>();\n   }\n \n-  void* data;\n+  AllocatedBuffer ret(env);\n   if (length > 0) {\n-    data = BufferMalloc(length);\n-    if (data == nullptr) {\n+    ret = env->AllocateManaged(length, false);\n+    if (ret.data() == nullptr) {\n       THROW_ERR_MEMORY_ALLOCATION_FAILED(env);\n       return Local<Object>();\n     }\n-  } else {\n-    data = nullptr;\n   }\n \n-  Local<ArrayBuffer> ab =\n-    ArrayBuffer::New(env->isolate(),\n-        data,\n-        length,\n-        ArrayBufferCreationMode::kInternalized);\n-  Local<Object> obj;\n-  if (Buffer::New(env, ab, 0, length).ToLocal(&obj))\n-    return scope.Escape(obj);\n-  return Local<Object>();\n+  return scope.EscapeMaybe(ret.ToBuffer());\n }\n \n \n@@ -357,28 +330,18 @@ MaybeLocal<Object> Copy(Environment* env, const char* data, size_t length) {\n     return Local<Object>();\n   }\n \n-  void* new_data;\n+  AllocatedBuffer ret(env);\n   if (length > 0) {\n     CHECK_NOT_NULL(data);\n-    new_data = node::UncheckedMalloc(length);\n-    if (new_data == nullptr) {\n+    ret = env->AllocateManaged(length, false);\n+    if (ret.data() == nullptr) {\n       THROW_ERR_MEMORY_ALLOCATION_FAILED(env);\n       return Local<Object>();\n     }\n-    memcpy(new_data, data, length);\n-  } else {\n-    new_data = nullptr;\n+    memcpy(ret.data(), data, length);\n   }\n \n-  Local<ArrayBuffer> ab =\n-    ArrayBuffer::New(env->isolate(),\n-        new_data,\n-        length,\n-        ArrayBufferCreationMode::kInternalized);\n-  Local<Object> obj;\n-  if (Buffer::New(env, ab, 0, length).ToLocal(&obj))\n-    return scope.Escape(obj);\n-  return Local<Object>();\n+  return scope.EscapeMaybe(ret.ToBuffer());\n }\n \n \n@@ -425,7 +388,8 @@ MaybeLocal<Object> New(Environment* env,\n   return scope.Escape(ui.ToLocalChecked());\n }\n \n-\n+// Warning: This function needs `data` to be allocated with malloc() and not\n+// necessarily isolate's ArrayBuffer::Allocator.\n MaybeLocal<Object> New(Isolate* isolate, char* data, size_t length) {\n   EscapableHandleScope handle_scope(isolate);\n   Environment* env = Environment::GetCurrent(isolate);\n@@ -435,18 +399,37 @@ MaybeLocal<Object> New(Isolate* isolate, char* data, size_t length) {\n     return MaybeLocal<Object>();\n   }\n   Local<Object> obj;\n-  if (Buffer::New(env, data, length).ToLocal(&obj))\n+  if (Buffer::New(env, data, length, true).ToLocal(&obj))\n     return handle_scope.Escape(obj);\n   return Local<Object>();\n }\n \n-\n-MaybeLocal<Object> New(Environment* env, char* data, size_t length) {\n+// Warning: If this call comes through the public node_buffer.h API,\n+// the contract for this function is that `data` is allocated with malloc()\n+// and not necessarily isolate's ArrayBuffer::Allocator.\n+MaybeLocal<Object> New(Environment* env,\n+                       char* data,\n+                       size_t length,\n+                       bool uses_malloc) {\n   if (length > 0) {\n     CHECK_NOT_NULL(data);\n     CHECK(length <= kMaxLength);\n   }\n \n+  if (uses_malloc) {\n+    if (env->isolate_data()->uses_node_allocator()) {\n+      // We don't know for sure that the allocator is malloc()-based, so we need\n+      // to fall back to the FreeCallback variant.\n+      auto free_callback = [](char* data, void* hint) { free(data); };\n+      return New(env, data, length, free_callback, nullptr);\n+    } else {\n+      // This is malloc()-based, so we can acquire it into our own\n+      // ArrayBufferAllocator.\n+      CHECK_NOT_NULL(env->isolate_data()->node_allocator());\n+      env->isolate_data()->node_allocator()->RegisterPointer(data, length);\n+    }\n+  }\n+\n   Local<ArrayBuffer> ab =\n       ArrayBuffer::New(env->isolate(),\n                        data,\n@@ -1053,15 +1036,13 @@ static void EncodeUtf8String(const FunctionCallbackInfo<Value>& args) {\n \n   Local<String> str = args[0].As<String>();\n   size_t length = str->Utf8Length(isolate);\n-  char* data = node::UncheckedMalloc(length);\n+  AllocatedBuffer buf = env->AllocateManaged(length);\n   str->WriteUtf8(isolate,\n-                 data,\n+                 buf.data(),\n                  -1,  // We are certain that `data` is sufficiently large\n                  nullptr,\n                  String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);\n-  auto array_buf = ArrayBuffer::New(\n-      isolate, data, length, ArrayBufferCreationMode::kInternalized);\n-  auto array = Uint8Array::New(array_buf, 0, length);\n+  auto array = Uint8Array::New(buf.ToArrayBuffer(), 0, length);\n   args.GetReturnValue().Set(array);\n }\n \n@@ -1123,7 +1104,8 @@ void Initialize(Local<Object> target,\n \n   // It can be a nullptr when running inside an isolate where we\n   // do not own the ArrayBuffer allocator.\n-  if (uint32_t* zero_fill_field = env->isolate_data()->zero_fill_field()) {\n+  if (ArrayBufferAllocator* allocator = env->isolate_data()->node_allocator()) {\n+    uint32_t* zero_fill_field = allocator->zero_fill_field();\n     Local<ArrayBuffer> array_buffer = ArrayBuffer::New(\n         env->isolate(), zero_fill_field, sizeof(*zero_fill_field));\n     CHECK(target"
        },
        {
            "sha": "49b9dfe576c0604b87f5a98b45fab37fbd7308b3",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 129,
            "deletions": 154,
            "changes": 283,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -52,15 +52,6 @@ static const int X509_NAME_FLAGS = ASN1_STRFLGS_ESC_CTRL\n                                  | XN_FLAG_FN_SN;\n \n namespace node {\n-namespace Buffer {\n-// OpenSSL uses `unsigned char*` for raw data, make this easier for us.\n-v8::MaybeLocal<v8::Object> New(Environment* env, unsigned char* udata,\n-                               size_t length) {\n-  char* data = reinterpret_cast<char*>(udata);\n-  return Buffer::New(env, data, length);\n-}\n-}  // namespace Buffer\n-\n namespace crypto {\n \n using node::THROW_ERR_TLS_INVALID_PROTOCOL_METHOD;\n@@ -1651,13 +1642,18 @@ static MaybeLocal<Object> ECPointToBuffer(Environment* env,\n     if (error != nullptr) *error = \"Failed to get public key length\";\n     return MaybeLocal<Object>();\n   }\n-  MallocedBuffer<unsigned char> buf(len);\n-  len = EC_POINT_point2oct(group, point, form, buf.data, buf.size, nullptr);\n+  AllocatedBuffer buf = env->AllocateManaged(len);\n+  len = EC_POINT_point2oct(group,\n+                           point,\n+                           form,\n+                           reinterpret_cast<unsigned char*>(buf.data()),\n+                           buf.size(),\n+                           nullptr);\n   if (len == 0) {\n     if (error != nullptr) *error = \"Failed to get public key\";\n     return MaybeLocal<Object>();\n   }\n-  return Buffer::New(env, buf.release(), len);\n+  return buf.ToBuffer();\n }\n \n \n@@ -2036,9 +2032,9 @@ void SSLWrap<Base>::GetFinished(const FunctionCallbackInfo<Value>& args) {\n   if (len == 0)\n     return;\n \n-  char* buf = Malloc(len);\n-  CHECK_EQ(len, SSL_get_finished(w->ssl_.get(), buf, len));\n-  args.GetReturnValue().Set(Buffer::New(env, buf, len).ToLocalChecked());\n+  AllocatedBuffer buf = env->AllocateManaged(len);\n+  CHECK_EQ(len, SSL_get_finished(w->ssl_.get(), buf.data(), len));\n+  args.GetReturnValue().Set(buf.ToBuffer().ToLocalChecked());\n }\n \n \n@@ -2059,9 +2055,9 @@ void SSLWrap<Base>::GetPeerFinished(const FunctionCallbackInfo<Value>& args) {\n   if (len == 0)\n     return;\n \n-  char* buf = Malloc(len);\n-  CHECK_EQ(len, SSL_get_peer_finished(w->ssl_.get(), buf, len));\n-  args.GetReturnValue().Set(Buffer::New(env, buf, len).ToLocalChecked());\n+  AllocatedBuffer buf = env->AllocateManaged(len);\n+  CHECK_EQ(len, SSL_get_peer_finished(w->ssl_.get(), buf.data(), len));\n+  args.GetReturnValue().Set(buf.ToBuffer().ToLocalChecked());\n }\n \n \n@@ -2079,10 +2075,10 @@ void SSLWrap<Base>::GetSession(const FunctionCallbackInfo<Value>& args) {\n   int slen = i2d_SSL_SESSION(sess, nullptr);\n   CHECK_GT(slen, 0);\n \n-  char* sbuf = Malloc(slen);\n-  unsigned char* p = reinterpret_cast<unsigned char*>(sbuf);\n+  AllocatedBuffer sbuf = env->AllocateManaged(slen);\n+  unsigned char* p = reinterpret_cast<unsigned char*>(sbuf.data());\n   i2d_SSL_SESSION(sess, &p);\n-  args.GetReturnValue().Set(Buffer::New(env, sbuf, slen).ToLocalChecked());\n+  args.GetReturnValue().Set(sbuf.ToBuffer().ToLocalChecked());\n }\n \n \n@@ -3963,11 +3959,9 @@ void CipherBase::SetAAD(const FunctionCallbackInfo<Value>& args) {\n   args.GetReturnValue().Set(b);  // Possibly report invalid state failure\n }\n \n-\n CipherBase::UpdateResult CipherBase::Update(const char* data,\n                                             int len,\n-                                            unsigned char** out,\n-                                            int* out_len) {\n+                                            AllocatedBuffer* out) {\n   if (!ctx_)\n     return kErrorState;\n   MarkPopErrorOnReturn mark_pop_error_on_return;\n@@ -3985,27 +3979,27 @@ CipherBase::UpdateResult CipherBase::Update(const char* data,\n     CHECK(MaybePassAuthTagToOpenSSL());\n   }\n \n-  *out_len = 0;\n-  int buff_len = len + EVP_CIPHER_CTX_block_size(ctx_.get());\n+  int buf_len = len + EVP_CIPHER_CTX_block_size(ctx_.get());\n   // For key wrapping algorithms, get output size by calling\n   // EVP_CipherUpdate() with null output.\n   if (kind_ == kCipher && mode == EVP_CIPH_WRAP_MODE &&\n       EVP_CipherUpdate(ctx_.get(),\n                        nullptr,\n-                       &buff_len,\n+                       &buf_len,\n                        reinterpret_cast<const unsigned char*>(data),\n                        len) != 1) {\n     return kErrorState;\n   }\n \n-  *out = Malloc<unsigned char>(buff_len);\n+  *out = env()->AllocateManaged(buf_len);\n   int r = EVP_CipherUpdate(ctx_.get(),\n-                           *out,\n-                           out_len,\n+                           reinterpret_cast<unsigned char*>(out->data()),\n+                           &buf_len,\n                            reinterpret_cast<const unsigned char*>(data),\n                            len);\n \n-  CHECK_LE(*out_len, buff_len);\n+  CHECK_LE(static_cast<size_t>(buf_len), out->size());\n+  out->Resize(buf_len);\n \n   // When in CCM mode, EVP_CipherUpdate will fail if the authentication tag is\n   // invalid. In that case, remember the error and throw in final().\n@@ -4023,37 +4017,33 @@ void CipherBase::Update(const FunctionCallbackInfo<Value>& args) {\n   CipherBase* cipher;\n   ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());\n \n-  unsigned char* out = nullptr;\n+  AllocatedBuffer out;\n   UpdateResult r;\n-  int out_len = 0;\n \n   // Only copy the data if we have to, because it's a string\n   if (args[0]->IsString()) {\n     StringBytes::InlineDecoder decoder;\n     if (!decoder.Decode(env, args[0].As<String>(), args[1], UTF8)\n              .FromMaybe(false))\n       return;\n-    r = cipher->Update(decoder.out(), decoder.size(), &out, &out_len);\n+    r = cipher->Update(decoder.out(), decoder.size(), &out);\n   } else {\n     char* buf = Buffer::Data(args[0]);\n     size_t buflen = Buffer::Length(args[0]);\n-    r = cipher->Update(buf, buflen, &out, &out_len);\n+    r = cipher->Update(buf, buflen, &out);\n   }\n \n   if (r != kSuccess) {\n-    free(out);\n     if (r == kErrorState) {\n       ThrowCryptoError(env, ERR_get_error(),\n                        \"Trying to add data in unsupported state\");\n     }\n     return;\n   }\n \n-  CHECK(out != nullptr || out_len == 0);\n-  Local<Object> buf =\n-      Buffer::New(env, reinterpret_cast<char*>(out), out_len).ToLocalChecked();\n+  CHECK(out.data() != nullptr || out.size() == 0);\n \n-  args.GetReturnValue().Set(buf);\n+  args.GetReturnValue().Set(out.ToBuffer().ToLocalChecked());\n }\n \n \n@@ -4073,14 +4063,13 @@ void CipherBase::SetAutoPadding(const FunctionCallbackInfo<Value>& args) {\n   args.GetReturnValue().Set(b);  // Possibly report invalid state failure\n }\n \n-\n-bool CipherBase::Final(unsigned char** out, int* out_len) {\n+bool CipherBase::Final(AllocatedBuffer* out) {\n   if (!ctx_)\n     return false;\n \n   const int mode = EVP_CIPHER_CTX_mode(ctx_.get());\n \n-  *out = Malloc<unsigned char>(\n+  *out = env()->AllocateManaged(\n       static_cast<size_t>(EVP_CIPHER_CTX_block_size(ctx_.get())));\n \n   if (kind_ == kDecipher && IsSupportedAuthenticatedMode(ctx_.get())) {\n@@ -4092,8 +4081,17 @@ bool CipherBase::Final(unsigned char** out, int* out_len) {\n   bool ok;\n   if (kind_ == kDecipher && mode == EVP_CIPH_CCM_MODE) {\n     ok = !pending_auth_failed_;\n+    *out = AllocatedBuffer(env());  // Empty buffer.\n   } else {\n-    ok = EVP_CipherFinal_ex(ctx_.get(), *out, out_len) == 1;\n+    int out_len = out->size();\n+    ok = EVP_CipherFinal_ex(ctx_.get(),\n+                            reinterpret_cast<unsigned char*>(out->data()),\n+                            &out_len) == 1;\n+\n+    if (out_len >= 0)\n+      out->Resize(out_len);\n+    else\n+      *out = AllocatedBuffer();  // *out will not be used.\n \n     if (ok && kind_ == kCipher && IsAuthenticatedMode()) {\n       // In GCM mode, the authentication tag length can be specified in advance,\n@@ -4122,33 +4120,21 @@ void CipherBase::Final(const FunctionCallbackInfo<Value>& args) {\n   ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());\n   if (cipher->ctx_ == nullptr) return env->ThrowError(\"Unsupported state\");\n \n-  unsigned char* out_value = nullptr;\n-  int out_len = -1;\n+  AllocatedBuffer out;\n \n   // Check IsAuthenticatedMode() first, Final() destroys the EVP_CIPHER_CTX.\n   const bool is_auth_mode = cipher->IsAuthenticatedMode();\n-  bool r = cipher->Final(&out_value, &out_len);\n-\n-  if (out_len <= 0 || !r) {\n-    free(out_value);\n-    out_value = nullptr;\n-    out_len = 0;\n-    if (!r) {\n-      const char* msg = is_auth_mode ?\n-          \"Unsupported state or unable to authenticate data\" :\n-          \"Unsupported state\";\n-\n-      return ThrowCryptoError(env,\n-                              ERR_get_error(),\n-                              msg);\n-    }\n+  bool r = cipher->Final(&out);\n+\n+  if (!r) {\n+    const char* msg = is_auth_mode\n+                          ? \"Unsupported state or unable to authenticate data\"\n+                          : \"Unsupported state\";\n+\n+    return ThrowCryptoError(env, ERR_get_error(), msg);\n   }\n \n-  Local<Object> buf = Buffer::New(\n-      env,\n-      reinterpret_cast<char*>(out_value),\n-      out_len).ToLocalChecked();\n-  args.GetReturnValue().Set(buf);\n+  args.GetReturnValue().Set(out.ToBuffer().ToLocalChecked());\n }\n \n \n@@ -4508,33 +4494,38 @@ void Sign::SignUpdate(const FunctionCallbackInfo<Value>& args) {\n   sign->CheckThrow(err);\n }\n \n-static MallocedBuffer<unsigned char> Node_SignFinal(EVPMDPointer&& mdctx,\n-                                                    const ManagedEVPPKey& pkey,\n-                                                    int padding,\n-                                                    int pss_salt_len) {\n+static AllocatedBuffer Node_SignFinal(Environment* env,\n+                                      EVPMDPointer&& mdctx,\n+                                      const ManagedEVPPKey& pkey,\n+                                      int padding,\n+                                      int pss_salt_len) {\n   unsigned char m[EVP_MAX_MD_SIZE];\n   unsigned int m_len;\n \n   if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))\n-    return MallocedBuffer<unsigned char>();\n+    return AllocatedBuffer();\n \n   int signed_sig_len = EVP_PKEY_size(pkey.get());\n   CHECK_GE(signed_sig_len, 0);\n   size_t sig_len = static_cast<size_t>(signed_sig_len);\n-  MallocedBuffer<unsigned char> sig(sig_len);\n+  AllocatedBuffer sig = env->AllocateManaged(sig_len);\n \n   EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));\n   if (pkctx &&\n       EVP_PKEY_sign_init(pkctx.get()) > 0 &&\n       ApplyRSAOptions(pkey, pkctx.get(), padding, pss_salt_len) &&\n       EVP_PKEY_CTX_set_signature_md(pkctx.get(),\n                                     EVP_MD_CTX_md(mdctx.get())) > 0 &&\n-      EVP_PKEY_sign(pkctx.get(), sig.data, &sig_len, m, m_len) > 0) {\n-    sig.Truncate(sig_len);\n+      EVP_PKEY_sign(pkctx.get(),\n+                    reinterpret_cast<unsigned char*>(sig.data()),\n+                    &sig_len,\n+                    m,\n+                    m_len) > 0) {\n+    sig.Resize(sig_len);\n     return sig;\n   }\n \n-  return MallocedBuffer<unsigned char>();\n+  return AllocatedBuffer();\n }\n \n Sign::SignResult Sign::SignFinal(\n@@ -4573,16 +4564,14 @@ Sign::SignResult Sign::SignFinal(\n   }\n #endif  // NODE_FIPS_MODE\n \n-  MallocedBuffer<unsigned char> buffer =\n-      Node_SignFinal(std::move(mdctx), pkey, padding, salt_len);\n-  Error error = buffer.is_empty() ? kSignPrivateKey : kSignOk;\n+  AllocatedBuffer buffer =\n+      Node_SignFinal(env(), std::move(mdctx), pkey, padding, salt_len);\n+  Error error = buffer.data() == nullptr ? kSignPrivateKey : kSignOk;\n   return SignResult(error, std::move(buffer));\n }\n \n \n void Sign::SignFinal(const FunctionCallbackInfo<Value>& args) {\n-  Environment* env = Environment::GetCurrent(args);\n-\n   Sign* sign;\n   ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());\n \n@@ -4607,13 +4596,7 @@ void Sign::SignFinal(const FunctionCallbackInfo<Value>& args) {\n   if (ret.error != kSignOk)\n     return sign->CheckThrow(ret.error);\n \n-  MallocedBuffer<unsigned char> sig =\n-      std::move(ret.signature);\n-\n-  Local<Object> rc =\n-      Buffer::New(env, reinterpret_cast<char*>(sig.release()), sig.size)\n-      .ToLocalChecked();\n-  args.GetReturnValue().Set(rc);\n+  args.GetReturnValue().Set(ret.signature.ToBuffer().ToLocalChecked());\n }\n \n void Verify::Initialize(Environment* env, Local<Object> target) {\n@@ -4722,16 +4705,15 @@ void Verify::VerifyFinal(const FunctionCallbackInfo<Value>& args) {\n   args.GetReturnValue().Set(verify_result);\n }\n \n-\n template <PublicKeyCipher::Operation operation,\n           PublicKeyCipher::EVP_PKEY_cipher_init_t EVP_PKEY_cipher_init,\n           PublicKeyCipher::EVP_PKEY_cipher_t EVP_PKEY_cipher>\n-bool PublicKeyCipher::Cipher(const ManagedEVPPKey& pkey,\n+bool PublicKeyCipher::Cipher(Environment* env,\n+                             const ManagedEVPPKey& pkey,\n                              int padding,\n                              const unsigned char* data,\n                              int len,\n-                             unsigned char** out,\n-                             size_t* out_len) {\n+                             AllocatedBuffer* out) {\n   EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));\n   if (!ctx)\n     return false;\n@@ -4740,14 +4722,21 @@ bool PublicKeyCipher::Cipher(const ManagedEVPPKey& pkey,\n   if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), padding) <= 0)\n     return false;\n \n-  if (EVP_PKEY_cipher(ctx.get(), nullptr, out_len, data, len) <= 0)\n+  size_t out_len = 0;\n+  if (EVP_PKEY_cipher(ctx.get(), nullptr, &out_len, data, len) <= 0)\n     return false;\n \n-  *out = Malloc<unsigned char>(*out_len);\n+  *out = env->AllocateManaged(out_len);\n \n-  if (EVP_PKEY_cipher(ctx.get(), *out, out_len, data, len) <= 0)\n+  if (EVP_PKEY_cipher(ctx.get(),\n+                      reinterpret_cast<unsigned char*>(out->data()),\n+                      &out_len,\n+                      data,\n+                      len) <= 0) {\n     return false;\n+  }\n \n+  out->Resize(out_len);\n   return true;\n }\n \n@@ -4770,33 +4759,22 @@ void PublicKeyCipher::Cipher(const FunctionCallbackInfo<Value>& args) {\n   uint32_t padding;\n   if (!args[offset + 1]->Uint32Value(env->context()).To(&padding)) return;\n \n-  unsigned char* out_value = nullptr;\n-  size_t out_len = 0;\n+  AllocatedBuffer out;\n \n   ClearErrorOnReturn clear_error_on_return;\n \n   bool r = Cipher<operation, EVP_PKEY_cipher_init, EVP_PKEY_cipher>(\n+      env,\n       pkey,\n       padding,\n       reinterpret_cast<const unsigned char*>(buf),\n       len,\n-      &out_value,\n-      &out_len);\n-\n-  if (out_len == 0 || !r) {\n-    free(out_value);\n-    out_value = nullptr;\n-    out_len = 0;\n-    if (!r) {\n-      return ThrowCryptoError(env,\n-        ERR_get_error());\n-    }\n-  }\n+      &out);\n \n-  Local<Object> vbuf =\n-      Buffer::New(env, reinterpret_cast<char*>(out_value), out_len)\n-      .ToLocalChecked();\n-  args.GetReturnValue().Set(vbuf);\n+  if (!r)\n+    return ThrowCryptoError(env, ERR_get_error());\n+\n+  args.GetReturnValue().Set(out.ToBuffer().ToLocalChecked());\n }\n \n \n@@ -4961,10 +4939,11 @@ void DiffieHellman::GenerateKeys(const FunctionCallbackInfo<Value>& args) {\n   DH_get0_key(diffieHellman->dh_.get(), &pub_key, nullptr);\n   const int size = BN_num_bytes(pub_key);\n   CHECK_GE(size, 0);\n-  char* data = Malloc(size);\n+  AllocatedBuffer data = env->AllocateManaged(size);\n   CHECK_EQ(size,\n-           BN_bn2binpad(pub_key, reinterpret_cast<unsigned char*>(data), size));\n-  args.GetReturnValue().Set(Buffer::New(env, data, size).ToLocalChecked());\n+           BN_bn2binpad(\n+               pub_key, reinterpret_cast<unsigned char*>(data.data()), size));\n+  args.GetReturnValue().Set(data.ToBuffer().ToLocalChecked());\n }\n \n \n@@ -4981,10 +4960,11 @@ void DiffieHellman::GetField(const FunctionCallbackInfo<Value>& args,\n \n   const int size = BN_num_bytes(num);\n   CHECK_GE(size, 0);\n-  char* data = Malloc(size);\n-  CHECK_EQ(size,\n-           BN_bn2binpad(num, reinterpret_cast<unsigned char*>(data), size));\n-  args.GetReturnValue().Set(Buffer::New(env, data, size).ToLocalChecked());\n+  AllocatedBuffer data = env->AllocateManaged(size);\n+  CHECK_EQ(\n+      size,\n+      BN_bn2binpad(num, reinterpret_cast<unsigned char*>(data.data()), size));\n+  args.GetReturnValue().Set(data.ToBuffer().ToLocalChecked());\n }\n \n void DiffieHellman::GetPrime(const FunctionCallbackInfo<Value>& args) {\n@@ -5042,9 +5022,9 @@ void DiffieHellman::ComputeSecret(const FunctionCallbackInfo<Value>& args) {\n       Buffer::Length(args[0]),\n       nullptr));\n \n-  MallocedBuffer<char> data(DH_size(diffieHellman->dh_.get()));\n+  AllocatedBuffer ret = env->AllocateManaged(DH_size(diffieHellman->dh_.get()));\n \n-  int size = DH_compute_key(reinterpret_cast<unsigned char*>(data.data),\n+  int size = DH_compute_key(reinterpret_cast<unsigned char*>(ret.data()),\n                             key.get(),\n                             diffieHellman->dh_.get());\n \n@@ -5079,14 +5059,13 @@ void DiffieHellman::ComputeSecret(const FunctionCallbackInfo<Value>& args) {\n   // DH_compute_key returns number of bytes in a remainder of exponent, which\n   // may have less bytes than a prime number. Therefore add 0-padding to the\n   // allocated buffer.\n-  if (static_cast<size_t>(size) != data.size) {\n-    CHECK_GT(data.size, static_cast<size_t>(size));\n-    memmove(data.data + data.size - size, data.data, size);\n-    memset(data.data, 0, data.size - size);\n+  if (static_cast<size_t>(size) != ret.size()) {\n+    CHECK_GT(ret.size(), static_cast<size_t>(size));\n+    memmove(ret.data() + ret.size() - size, ret.data(), size);\n+    memset(ret.data(), 0, ret.size() - size);\n   }\n \n-  args.GetReturnValue().Set(\n-      Buffer::New(env->isolate(), data.release(), data.size).ToLocalChecked());\n+  args.GetReturnValue().Set(ret.ToBuffer().ToLocalChecked());\n }\n \n void DiffieHellman::SetKey(const FunctionCallbackInfo<Value>& args,\n@@ -5260,15 +5239,14 @@ void ECDH::ComputeSecret(const FunctionCallbackInfo<Value>& args) {\n   // NOTE: field_size is in bits\n   int field_size = EC_GROUP_get_degree(ecdh->group_);\n   size_t out_len = (field_size + 7) / 8;\n-  char* out = node::Malloc(out_len);\n+  AllocatedBuffer out = env->AllocateManaged(out_len);\n \n-  int r = ECDH_compute_key(out, out_len, pub.get(), ecdh->key_.get(), nullptr);\n-  if (!r) {\n-    free(out);\n+  int r = ECDH_compute_key(\n+      out.data(), out_len, pub.get(), ecdh->key_.get(), nullptr);\n+  if (!r)\n     return env->ThrowError(\"Failed to compute ECDH key\");\n-  }\n \n-  Local<Object> buf = Buffer::New(env, out, out_len).ToLocalChecked();\n+  Local<Object> buf = out.ToBuffer().ToLocalChecked();\n   args.GetReturnValue().Set(buf);\n }\n \n@@ -5310,11 +5288,12 @@ void ECDH::GetPrivateKey(const FunctionCallbackInfo<Value>& args) {\n     return env->ThrowError(\"Failed to get ECDH private key\");\n \n   const int size = BN_num_bytes(b);\n-  unsigned char* out = node::Malloc<unsigned char>(size);\n-  CHECK_EQ(size, BN_bn2binpad(b, out, size));\n+  AllocatedBuffer out = env->AllocateManaged(size);\n+  CHECK_EQ(size, BN_bn2binpad(b,\n+                              reinterpret_cast<unsigned char*>(out.data()),\n+                              size));\n \n-  Local<Object> buf =\n-      Buffer::New(env, reinterpret_cast<char*>(out), size).ToLocalChecked();\n+  Local<Object> buf = out.ToBuffer().ToLocalChecked();\n   args.GetReturnValue().Set(buf);\n }\n \n@@ -6066,31 +6045,28 @@ void VerifySpkac(const FunctionCallbackInfo<Value>& args) {\n   args.GetReturnValue().Set(verify_result);\n }\n \n-\n-char* ExportPublicKey(const char* data, int len, size_t* size) {\n-  char* buf = nullptr;\n-\n+AllocatedBuffer ExportPublicKey(Environment* env,\n+                                const char* data,\n+                                int len,\n+                                size_t* size) {\n   BIOPointer bio(BIO_new(BIO_s_mem()));\n-  if (!bio)\n-    return nullptr;\n+  if (!bio) return AllocatedBuffer();\n \n   NetscapeSPKIPointer spki(NETSCAPE_SPKI_b64_decode(data, len));\n-  if (!spki)\n-    return nullptr;\n+  if (!spki) return AllocatedBuffer();\n \n   EVPKeyPointer pkey(NETSCAPE_SPKI_get_pubkey(spki.get()));\n-  if (!pkey)\n-    return nullptr;\n+  if (!pkey) return AllocatedBuffer();\n \n   if (PEM_write_bio_PUBKEY(bio.get(), pkey.get()) <= 0)\n-    return nullptr;\n+    return AllocatedBuffer();\n \n   BUF_MEM* ptr;\n   BIO_get_mem_ptr(bio.get(), &ptr);\n \n   *size = ptr->length;\n-  buf = Malloc(*size);\n-  memcpy(buf, ptr->data, *size);\n+  AllocatedBuffer buf = env->AllocateManaged(*size);\n+  memcpy(buf.data(), ptr->data, *size);\n \n   return buf;\n }\n@@ -6107,12 +6083,11 @@ void ExportPublicKey(const FunctionCallbackInfo<Value>& args) {\n   CHECK_NOT_NULL(data);\n \n   size_t pkey_size;\n-  char* pkey = ExportPublicKey(data, length, &pkey_size);\n-  if (pkey == nullptr)\n+  AllocatedBuffer pkey = ExportPublicKey(env, data, length, &pkey_size);\n+  if (pkey.data() == nullptr)\n     return args.GetReturnValue().SetEmptyString();\n \n-  Local<Value> out = Buffer::New(env, pkey, pkey_size).ToLocalChecked();\n-  args.GetReturnValue().Set(out);\n+  args.GetReturnValue().Set(pkey.ToBuffer().ToLocalChecked());\n }\n \n "
        },
        {
            "sha": "78293e70f1d7943bcde368410a35f2e619a0bfd4",
            "filename": "src/node_crypto.h",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_crypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_crypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.h?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -544,9 +544,8 @@ class CipherBase : public BaseObject {\n   bool InitAuthenticated(const char* cipher_type, int iv_len,\n                          unsigned int auth_tag_len);\n   bool CheckCCMMessageLength(int message_len);\n-  UpdateResult Update(const char* data, int len, unsigned char** out,\n-                      int* out_len);\n-  bool Final(unsigned char** out, int* out_len);\n+  UpdateResult Update(const char* data, int len, AllocatedBuffer* out);\n+  bool Final(AllocatedBuffer* out);\n   bool SetAutoPadding(bool auto_padding);\n \n   bool IsAuthenticatedMode() const;\n@@ -677,11 +676,11 @@ class Sign : public SignBase {\n \n   struct SignResult {\n     Error error;\n-    MallocedBuffer<unsigned char> signature;\n+    AllocatedBuffer signature;\n \n     explicit SignResult(\n         Error err,\n-        MallocedBuffer<unsigned char>&& sig = MallocedBuffer<unsigned char>())\n+        AllocatedBuffer&& sig = AllocatedBuffer())\n       : error(err), signature(std::move(sig)) {}\n   };\n \n@@ -738,12 +737,12 @@ class PublicKeyCipher {\n   template <Operation operation,\n             EVP_PKEY_cipher_init_t EVP_PKEY_cipher_init,\n             EVP_PKEY_cipher_t EVP_PKEY_cipher>\n-  static bool Cipher(const ManagedEVPPKey& pkey,\n+  static bool Cipher(Environment* env,\n+                     const ManagedEVPPKey& pkey,\n                      int padding,\n                      const unsigned char* data,\n                      int len,\n-                     unsigned char** out,\n-                     size_t* out_len);\n+                     AllocatedBuffer* out);\n \n   template <Operation operation,\n             EVP_PKEY_cipher_init_t EVP_PKEY_cipher_init,"
        },
        {
            "sha": "7fc21c9cae1eee669cf403dd4783f1a837cfaac4",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 12,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -12,7 +12,6 @@\n namespace node {\n \n using v8::ArrayBuffer;\n-using v8::ArrayBufferCreationMode;\n using v8::Boolean;\n using v8::Context;\n using v8::Float64Array;\n@@ -1767,32 +1766,36 @@ Http2Stream* Http2Session::SubmitRequest(\n   return stream;\n }\n \n+uv_buf_t Http2Session::OnStreamAlloc(size_t suggested_size) {\n+  return env()->AllocateManaged(suggested_size).release();\n+}\n+\n // Callback used to receive inbound data from the i/o stream\n-void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n+void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) {\n   HandleScope handle_scope(env()->isolate());\n   Context::Scope context_scope(env()->context());\n   Http2Scope h2scope(this);\n   CHECK_NOT_NULL(stream_);\n   Debug(this, \"receiving %d bytes\", nread);\n   CHECK(stream_buf_ab_.IsEmpty());\n+  AllocatedBuffer buf(env(), buf_);\n \n   // Only pass data on if nread > 0\n   if (nread <= 0) {\n-    free(buf.base);\n     if (nread < 0) {\n       PassReadErrorToPreviousListener(nread);\n     }\n     return;\n   }\n \n   // Shrink to the actual amount of used data.\n-  char* base = Realloc(buf.base, nread);\n+  buf.Resize(nread);\n \n-  IncrementCurrentSessionMemory(nread);\n+  IncrementCurrentSessionMemory(buf.size());\n   OnScopeLeave on_scope_leave([&]() {\n     // Once finished handling this write, reset the stream buffer.\n     // The memory has either been free()d or was handed over to V8.\n-    DecrementCurrentSessionMemory(nread);\n+    DecrementCurrentSessionMemory(buf.size());\n     stream_buf_ab_ = Local<ArrayBuffer>();\n     stream_buf_ = uv_buf_init(nullptr, 0);\n   });\n@@ -1803,17 +1806,13 @@ void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n \n   // Remember the current buffer, so that OnDataChunkReceived knows the\n   // offset of a DATA frame's data into the socket read buffer.\n-  stream_buf_ = uv_buf_init(base, nread);\n+  stream_buf_ = uv_buf_init(buf.data(), nread);\n \n   Isolate* isolate = env()->isolate();\n \n   // Create an array buffer for the read data. DATA frames will be emitted\n   // as slices of this array buffer to avoid having to copy memory.\n-  stream_buf_ab_ =\n-      ArrayBuffer::New(isolate,\n-                       base,\n-                       nread,\n-                       ArrayBufferCreationMode::kInternalized);\n+  stream_buf_ab_ = buf.ToArrayBuffer();\n \n   statistics_.data_received += nread;\n   ssize_t ret = Write(&stream_buf_, 1);"
        },
        {
            "sha": "aa953667facccf77d5fc2dd16e5d1051bef545f0",
            "filename": "src/node_http2.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_http2.h",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_http2.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.h?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -783,6 +783,7 @@ class Http2Session : public AsyncWrap, public StreamListener {\n   }\n \n   // Handle reads/writes from the underlying network transport.\n+  uv_buf_t OnStreamAlloc(size_t suggested_size) override;\n   void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;\n   void OnStreamAfterWrite(WriteWrap* w, int status) override;\n "
        },
        {
            "sha": "16c0e77ae853f4b1dd6901f9eb9bbc312d5c00e5",
            "filename": "src/node_http_parser_impl.h",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_http_parser_impl.h",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_http_parser_impl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http_parser_impl.h?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -594,10 +594,9 @@ class Parser : public AsyncWrap, public StreamListener {\n   uv_buf_t OnStreamAlloc(size_t suggested_size) override {\n     // For most types of streams, OnStreamRead will be immediately after\n     // OnStreamAlloc, and will consume all data, so using a static buffer for\n-    // reading is more efficient. For other streams, just use the default\n-    // allocator, which uses Malloc().\n+    // reading is more efficient. For other streams, just use Malloc() directly.\n     if (env()->http_parser_buffer_in_use())\n-      return StreamListener::OnStreamAlloc(suggested_size);\n+      return uv_buf_init(Malloc(suggested_size), suggested_size);\n     env()->set_http_parser_buffer_in_use(true);\n \n     if (env()->http_parser_buffer() == nullptr)"
        },
        {
            "sha": "82cf5713e95bf2bce87d84e1d90b863dffaa0d17",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -146,10 +146,12 @@ v8::MaybeLocal<v8::Object> New(Environment* env,\n                                size_t length,\n                                void (*callback)(char* data, void* hint),\n                                void* hint);\n-// Takes ownership of |data|.  Must allocate |data| with malloc() or realloc()\n-// because ArrayBufferAllocator::Free() deallocates it again with free().\n-// Mixing operator new and free() is undefined behavior so don't do that.\n-v8::MaybeLocal<v8::Object> New(Environment* env, char* data, size_t length);\n+// Takes ownership of |data|.  Must allocate |data| with the current Isolate's\n+// ArrayBuffer::Allocator().\n+v8::MaybeLocal<v8::Object> New(Environment* env,\n+                               char* data,\n+                               size_t length,\n+                               bool uses_malloc);\n \n // Construct a Buffer from a MaybeStackBuffer (and also its subclasses like\n // Utf8Value and TwoByteValue).\n@@ -167,7 +169,7 @@ static v8::MaybeLocal<v8::Object> New(Environment* env,\n   const size_t len_in_bytes = buf->length() * sizeof(buf->out()[0]);\n \n   if (buf->IsAllocated())\n-    ret = New(env, src, len_in_bytes);\n+    ret = New(env, src, len_in_bytes, true);\n   else if (!buf->IsInvalidated())\n     ret = Copy(env, src, len_in_bytes);\n "
        },
        {
            "sha": "34977557c5bfb83b1d645f67f97289f757de9eda",
            "filename": "src/node_messaging.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_messaging.cc",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_messaging.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_messaging.cc?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -144,6 +144,9 @@ MaybeLocal<Value> Message::Deserialize(Environment* env,\n       continue;\n     }\n \n+    env->isolate_data()->node_allocator()->RegisterPointer(\n+        array_buffer_contents_[i].data, array_buffer_contents_[i].size);\n+\n     Local<ArrayBuffer> ab =\n         ArrayBuffer::New(env->isolate(),\n                          array_buffer_contents_[i].release(),\n@@ -367,6 +370,11 @@ Maybe<bool> Message::Serialize(Environment* env,\n     // it inaccessible in this Isolate.\n     ArrayBuffer::Contents contents = ab->Externalize();\n     ab->Neuter();\n+\n+    CHECK(env->isolate_data()->uses_node_allocator());\n+    env->isolate_data()->node_allocator()->UnregisterPointer(\n+        contents.Data(), contents.ByteLength());\n+\n     array_buffer_contents_.push_back(\n         MallocedBuffer<char> { static_cast<char*>(contents.Data()),\n                                contents.ByteLength() });"
        },
        {
            "sha": "df7e1749e52ea8127fa85f896835cbf0cec1a635",
            "filename": "src/node_native_module.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 8,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_native_module.cc",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_native_module.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_native_module.cc?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -11,7 +11,6 @@ namespace native_module {\n \n using v8::Array;\n using v8::ArrayBuffer;\n-using v8::ArrayBufferCreationMode;\n using v8::Context;\n using v8::DEFAULT;\n using v8::EscapableHandleScope;\n@@ -153,13 +152,8 @@ MaybeLocal<Uint8Array> NativeModuleLoader::GetCodeCache(Isolate* isolate,\n \n   cached_data = it->second.get();\n \n-  MallocedBuffer<uint8_t> copied(cached_data->length);\n-  memcpy(copied.data, cached_data->data, cached_data->length);\n-  Local<ArrayBuffer> buf =\n-      ArrayBuffer::New(isolate,\n-                       copied.release(),\n-                       cached_data->length,\n-                       ArrayBufferCreationMode::kInternalized);\n+  Local<ArrayBuffer> buf = ArrayBuffer::New(isolate, cached_data->length);\n+  memcpy(buf->GetContents().Data(), cached_data->data, cached_data->length);\n   return scope.Escape(Uint8Array::New(buf, 0, cached_data->length));\n }\n "
        },
        {
            "sha": "12ed313b033987df2dfcfd87645d6155332b98df",
            "filename": "src/node_serdes.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_serdes.cc",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fnode_serdes.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_serdes.cc?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -200,10 +200,13 @@ void SerializerContext::ReleaseBuffer(const FunctionCallbackInfo<Value>& args) {\n   SerializerContext* ctx;\n   ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());\n \n+  // Note: Both ValueSerializer and this Buffer::New() variant use malloc()\n+  // as the underlying allocator.\n   std::pair<uint8_t*, size_t> ret = ctx->serializer_.Release();\n   auto buf = Buffer::New(ctx->env(),\n                          reinterpret_cast<char*>(ret.first),\n-                         ret.second);\n+                         ret.second,\n+                         true /* uses_malloc */);\n \n   if (!buf.IsEmpty()) {\n     args.GetReturnValue().Set(buf.ToLocalChecked());"
        },
        {
            "sha": "9cff67cd9fecf2b7ae30da0963fa9b9840f715a0",
            "filename": "src/stream_base-inl.h",
            "status": "modified",
            "additions": 3,
            "deletions": 12,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fstream_base-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fstream_base-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base-inl.h?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -419,18 +419,9 @@ inline void ShutdownWrap::OnDone(int status) {\n   Dispose();\n }\n \n-inline void WriteWrap::SetAllocatedStorage(char* data, size_t size) {\n-  CHECK_NULL(storage_);\n-  storage_ = data;\n-  storage_size_ = size;\n-}\n-\n-inline char* WriteWrap::Storage() {\n-  return storage_;\n-}\n-\n-inline size_t WriteWrap::StorageSize() const {\n-  return storage_size_;\n+inline void WriteWrap::SetAllocatedStorage(AllocatedBuffer&& storage) {\n+  CHECK_NULL(storage_.data());\n+  storage_ = std::move(storage);\n }\n \n inline void WriteWrap::OnDone(int status) {"
        },
        {
            "sha": "ebd9beb984eba383c23307ef19c800d26e3c9848",
            "filename": "src/stream_base.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 26,
            "changes": 47,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fstream_base.cc",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fstream_base.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.cc?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -111,9 +111,9 @@ int StreamBase::Writev(const FunctionCallbackInfo<Value>& args) {\n     }\n   }\n \n-  MallocedBuffer<char> storage;\n+  AllocatedBuffer storage;\n   if (storage_size > 0)\n-    storage = MallocedBuffer<char>(storage_size);\n+    storage = env->AllocateManaged(storage_size);\n \n   offset = 0;\n   if (!all_buffers) {\n@@ -129,8 +129,8 @@ int StreamBase::Writev(const FunctionCallbackInfo<Value>& args) {\n \n       // Write string\n       CHECK_LE(offset, storage_size);\n-      char* str_storage = storage.data + offset;\n-      size_t str_size = storage_size - offset;\n+      char* str_storage = storage.data() + offset;\n+      size_t str_size = storage.size() - offset;\n \n       Local<String> string = chunk->ToString(env->context()).ToLocalChecked();\n       enum encoding encoding = ParseEncoding(env->isolate(),\n@@ -149,7 +149,7 @@ int StreamBase::Writev(const FunctionCallbackInfo<Value>& args) {\n   StreamWriteResult res = Write(*bufs, count, nullptr, req_wrap_obj);\n   SetWriteResult(res);\n   if (res.wrap != nullptr && storage_size > 0) {\n-    res.wrap->SetAllocatedStorage(storage.release(), storage_size);\n+    res.wrap->SetAllocatedStorage(std::move(storage));\n   }\n   return res.err;\n }\n@@ -239,26 +239,26 @@ int StreamBase::WriteString(const FunctionCallbackInfo<Value>& args) {\n     CHECK_EQ(count, 1);\n   }\n \n-  MallocedBuffer<char> data;\n+  AllocatedBuffer data;\n \n   if (try_write) {\n     // Copy partial data\n-    data = MallocedBuffer<char>(buf.len);\n-    memcpy(data.data, buf.base, buf.len);\n+    data = env->AllocateManaged(buf.len);\n+    memcpy(data.data(), buf.base, buf.len);\n     data_size = buf.len;\n   } else {\n     // Write it\n-    data = MallocedBuffer<char>(storage_size);\n+    data = env->AllocateManaged(storage_size);\n     data_size = StringBytes::Write(env->isolate(),\n-                                   data.data,\n+                                   data.data(),\n                                    storage_size,\n                                    string,\n                                    enc);\n   }\n \n   CHECK_LE(data_size, storage_size);\n \n-  buf = uv_buf_init(data.data, data_size);\n+  buf = uv_buf_init(data.data(), data_size);\n \n   uv_stream_t* send_handle = nullptr;\n \n@@ -278,7 +278,7 @@ int StreamBase::WriteString(const FunctionCallbackInfo<Value>& args) {\n \n   SetWriteResult(res);\n   if (res.wrap != nullptr) {\n-    res.wrap->SetAllocatedStorage(data.release(), data_size);\n+    res.wrap->SetAllocatedStorage(std::move(data));\n   }\n \n   return res.err;\n@@ -343,35 +343,30 @@ void StreamResource::ClearError() {\n   // No-op\n }\n \n-\n-uv_buf_t StreamListener::OnStreamAlloc(size_t suggested_size) {\n-  return uv_buf_init(Malloc(suggested_size), suggested_size);\n+uv_buf_t EmitToJSStreamListener::OnStreamAlloc(size_t suggested_size) {\n+  CHECK_NOT_NULL(stream_);\n+  Environment* env = static_cast<StreamBase*>(stream_)->stream_env();\n+  return env->AllocateManaged(suggested_size).release();\n }\n \n-\n-void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {\n+void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) {\n   CHECK_NOT_NULL(stream_);\n   StreamBase* stream = static_cast<StreamBase*>(stream_);\n   Environment* env = stream->stream_env();\n   HandleScope handle_scope(env->isolate());\n   Context::Scope context_scope(env->context());\n+  AllocatedBuffer buf(env, buf_);\n \n   if (nread <= 0)  {\n-    free(buf.base);\n     if (nread < 0)\n       stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());\n     return;\n   }\n \n-  CHECK_LE(static_cast<size_t>(nread), buf.len);\n-  char* base = Realloc(buf.base, nread);\n+  CHECK_LE(static_cast<size_t>(nread), buf.size());\n+  buf.Resize(nread);\n \n-  Local<ArrayBuffer> obj = ArrayBuffer::New(\n-      env->isolate(),\n-      base,\n-      nread,\n-      v8::ArrayBufferCreationMode::kInternalized);  // Transfer ownership to V8.\n-  stream->CallJSOnreadMethod(nread, obj);\n+  stream->CallJSOnreadMethod(nread, buf.ToArrayBuffer());\n }\n \n "
        },
        {
            "sha": "33cf62a0c861bae06eda6e087a109666d1532b20",
            "filename": "src/stream_base.h",
            "status": "modified",
            "additions": 4,
            "deletions": 10,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fstream_base.h",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fstream_base.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.h?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -74,24 +74,17 @@ class ShutdownWrap : public StreamReq {\n \n class WriteWrap : public StreamReq {\n  public:\n-  char* Storage();\n-  size_t StorageSize() const;\n-  void SetAllocatedStorage(char* data, size_t size);\n+  void SetAllocatedStorage(AllocatedBuffer&& storage);\n \n   WriteWrap(StreamBase* stream,\n             v8::Local<v8::Object> req_wrap_obj)\n     : StreamReq(stream, req_wrap_obj) { }\n \n-  ~WriteWrap() override {\n-    free(storage_);\n-  }\n-\n   // Call stream()->EmitAfterWrite() and dispose of this request wrap.\n   void OnDone(int status) override;\n \n  private:\n-  char* storage_ = nullptr;\n-  size_t storage_size_ = 0;\n+  AllocatedBuffer storage_;\n };\n \n \n@@ -115,7 +108,7 @@ class StreamListener {\n   // It is not valid to return a zero-length buffer from this method.\n   // It is not guaranteed that the corresponding `OnStreamRead()` call\n   // happens in the same event loop turn as this call.\n-  virtual uv_buf_t OnStreamAlloc(size_t suggested_size);\n+  virtual uv_buf_t OnStreamAlloc(size_t suggested_size) = 0;\n \n   // `OnStreamRead()` is called when data is available on the socket and has\n   // been read into the buffer provided by `OnStreamAlloc()`.\n@@ -181,6 +174,7 @@ class ReportWritesToJSStreamListener : public StreamListener {\n // JS land via the handleâ€™s .ondata method.\n class EmitToJSStreamListener : public ReportWritesToJSStreamListener {\n  public:\n+  uv_buf_t OnStreamAlloc(size_t suggested_size) override;\n   void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;\n };\n "
        },
        {
            "sha": "4c9b447a61c8262fc8f74eb9ab1f39d3dbe7fd9c",
            "filename": "src/stream_pipe.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fstream_pipe.cc",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fstream_pipe.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_pipe.cc?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -114,17 +114,17 @@ uv_buf_t StreamPipe::ReadableListener::OnStreamAlloc(size_t suggested_size) {\n   StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);\n   size_t size = std::min(suggested_size, pipe->wanted_data_);\n   CHECK_GT(size, 0);\n-  return uv_buf_init(Malloc(size), size);\n+  return pipe->env()->AllocateManaged(size).release();\n }\n \n void StreamPipe::ReadableListener::OnStreamRead(ssize_t nread,\n-                                                const uv_buf_t& buf) {\n+                                                const uv_buf_t& buf_) {\n   StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);\n+  AllocatedBuffer buf(pipe->env(), buf_);\n   AsyncScope async_scope(pipe);\n   if (nread < 0) {\n     // EOF or error; stop reading and pass the error to the previous listener\n     // (which might end up in JS).\n-    free(buf.base);\n     pipe->is_eof_ = true;\n     stream()->ReadStop();\n     CHECK_NOT_NULL(previous_listener_);\n@@ -138,19 +138,18 @@ void StreamPipe::ReadableListener::OnStreamRead(ssize_t nread,\n     return;\n   }\n \n-  pipe->ProcessData(nread, buf);\n+  pipe->ProcessData(nread, std::move(buf));\n }\n \n-void StreamPipe::ProcessData(size_t nread, const uv_buf_t& buf) {\n-  uv_buf_t buffer = uv_buf_init(buf.base, nread);\n+void StreamPipe::ProcessData(size_t nread, AllocatedBuffer&& buf) {\n+  uv_buf_t buffer = uv_buf_init(buf.data(), nread);\n   StreamWriteResult res = sink()->Write(&buffer, 1);\n   if (!res.async) {\n-    free(buf.base);\n     writable_listener_.OnStreamAfterWrite(nullptr, res.err);\n   } else {\n     is_writing_ = true;\n     is_reading_ = false;\n-    res.wrap->SetAllocatedStorage(buf.base, buf.len);\n+    res.wrap->SetAllocatedStorage(std::move(buf));\n     if (source() != nullptr)\n       source()->ReadStop();\n   }"
        },
        {
            "sha": "061ad9842e8f6d162a3c79a13ad2e72346168aa9",
            "filename": "src/stream_pipe.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fstream_pipe.h",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fstream_pipe.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_pipe.h?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -41,7 +41,7 @@ class StreamPipe : public AsyncWrap {\n   // `OnStreamWantsWrite()` support.\n   size_t wanted_data_ = 0;\n \n-  void ProcessData(size_t nread, const uv_buf_t& buf);\n+  void ProcessData(size_t nread, AllocatedBuffer&& buf);\n \n   class ReadableListener : public StreamListener {\n    public:"
        },
        {
            "sha": "5682e51478d5e97c2b43503818b7aa5c9f82cbc6",
            "filename": "src/udp_wrap.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 13,
            "changes": 22,
            "blob_url": "https://github.com/nodejs/node/blob/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fudp_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/84e02b178ad14fae0df2a514e8a39bfa50ffdc2d/src%2Fudp_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fudp_wrap.cc?ref=84e02b178ad14fae0df2a514e8a39bfa50ffdc2d",
            "patch": "@@ -462,25 +462,23 @@ void UDPWrap::OnSend(uv_udp_send_t* req, int status) {\n void UDPWrap::OnAlloc(uv_handle_t* handle,\n                       size_t suggested_size,\n                       uv_buf_t* buf) {\n-  buf->base = node::Malloc(suggested_size);\n-  buf->len = suggested_size;\n+  UDPWrap* wrap = static_cast<UDPWrap*>(handle->data);\n+  *buf = wrap->env()->AllocateManaged(suggested_size).release();\n }\n \n-\n void UDPWrap::OnRecv(uv_udp_t* handle,\n                      ssize_t nread,\n-                     const uv_buf_t* buf,\n+                     const uv_buf_t* buf_,\n                      const struct sockaddr* addr,\n                      unsigned int flags) {\n+  UDPWrap* wrap = static_cast<UDPWrap*>(handle->data);\n+  Environment* env = wrap->env();\n+\n+  AllocatedBuffer buf(env, *buf_);\n   if (nread == 0 && addr == nullptr) {\n-    if (buf->base != nullptr)\n-      free(buf->base);\n     return;\n   }\n \n-  UDPWrap* wrap = static_cast<UDPWrap*>(handle->data);\n-  Environment* env = wrap->env();\n-\n   HandleScope handle_scope(env->isolate());\n   Context::Scope context_scope(env->context());\n \n@@ -493,14 +491,12 @@ void UDPWrap::OnRecv(uv_udp_t* handle,\n   };\n \n   if (nread < 0) {\n-    if (buf->base != nullptr)\n-      free(buf->base);\n     wrap->MakeCallback(env->onmessage_string(), arraysize(argv), argv);\n     return;\n   }\n \n-  char* base = node::UncheckedRealloc(buf->base, nread);\n-  argv[2] = Buffer::New(env, base, nread).ToLocalChecked();\n+  buf.Resize(nread);\n+  argv[2] = buf.ToBuffer().ToLocalChecked();\n   argv[3] = AddressToJS(env, addr);\n   wrap->MakeCallback(env->onmessage_string(), arraysize(argv), argv);\n }"
        }
    ],
    "stats": {
        "total": 575,
        "additions": 256,
        "deletions": 319
    }
}