{
    "author": "tniessen",
    "message": "crypto: fix unencrypted DER PKCS8 parsing\n\nThe previously used OpenSSL call only supports encrypted PKCS8,\nthis commit adds support for unencrypted PKCS8.\n\nPR-URL: https://github.com/nodejs/node/pull/26236\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: Sam Roberts <vieuxtech@gmail.com>\nReviewed-By: Ujjwal Sharma <usharma1998@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "8d69fdde1955e0b08bdbe6949090f459995784a7",
    "files": [
        {
            "sha": "98ae216348d250d7a8f4dede018c3fcfc6c00b12",
            "filename": "src/node_crypto.cc",
            "status": "modified",
            "additions": 66,
            "deletions": 39,
            "changes": 105,
            "blob_url": "https://github.com/nodejs/node/blob/8d69fdde1955e0b08bdbe6949090f459995784a7/src%2Fnode_crypto.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8d69fdde1955e0b08bdbe6949090f459995784a7/src%2Fnode_crypto.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.cc?ref=8d69fdde1955e0b08bdbe6949090f459995784a7",
            "patch": "@@ -2848,6 +2848,59 @@ static MaybeLocal<Value> WritePublicKey(Environment* env,\n   return BIOToStringOrBuffer(env, bio.get(), config.format_);\n }\n \n+static bool IsASN1Sequence(const unsigned char* data, size_t size,\n+                           size_t* data_offset, size_t* data_size) {\n+  if (size < 2 || data[0] != 0x30)\n+    return false;\n+\n+  if (data[1] & 0x80) {\n+    // Long form.\n+    size_t n_bytes = data[1] & ~0x80;\n+    if (n_bytes + 2 > size || n_bytes > sizeof(size_t))\n+      return false;\n+    size_t length = 0;\n+    for (size_t i = 0; i < n_bytes; i++)\n+      length = (length << 8) | data[i + 2];\n+    *data_offset = 2 + n_bytes;\n+    *data_size = std::min(size - 2 - n_bytes, length);\n+  } else {\n+    // Short form.\n+    *data_offset = 2;\n+    *data_size = std::min<size_t>(size - 2, data[1]);\n+  }\n+\n+  return true;\n+}\n+\n+static bool IsRSAPrivateKey(const unsigned char* data, size_t size) {\n+  // Both RSAPrivateKey and RSAPublicKey structures start with a SEQUENCE.\n+  size_t offset, len;\n+  if (!IsASN1Sequence(data, size, &offset, &len))\n+    return false;\n+\n+  // An RSAPrivateKey sequence always starts with a single-byte integer whose\n+  // value is either 0 or 1, whereas an RSAPublicKey starts with the modulus\n+  // (which is the product of two primes and therefore at least 4), so we can\n+  // decide the type of the structure based on the first three bytes of the\n+  // sequence.\n+  return len >= 3 &&\n+         data[offset] == 2 &&\n+         data[offset + 1] == 1 &&\n+         !(data[offset + 2] & 0xfe);\n+}\n+\n+static bool IsEncryptedPrivateKeyInfo(const unsigned char* data, size_t size) {\n+  // Both PrivateKeyInfo and EncryptedPrivateKeyInfo start with a SEQUENCE.\n+  size_t offset, len;\n+  if (!IsASN1Sequence(data, size, &offset, &len))\n+    return false;\n+\n+  // A PrivateKeyInfo sequence always starts with an integer whereas an\n+  // EncryptedPrivateKeyInfo starts with an AlgorithmIdentifier.\n+  return len >= 1 &&\n+         data[offset] != 2;\n+}\n+\n static EVPKeyPointer ParsePrivateKey(const PrivateKeyEncodingConfig& config,\n                                      const char* key,\n                                      size_t key_len) {\n@@ -2873,11 +2926,19 @@ static EVPKeyPointer ParsePrivateKey(const PrivateKeyEncodingConfig& config,\n       BIOPointer bio(BIO_new_mem_buf(key, key_len));\n       if (!bio)\n         return pkey;\n-      char* pass = const_cast<char*>(config.passphrase_.get());\n-      pkey.reset(d2i_PKCS8PrivateKey_bio(bio.get(),\n-                                         nullptr,\n-                                         PasswordCallback,\n-                                         pass));\n+\n+      if (IsEncryptedPrivateKeyInfo(\n+              reinterpret_cast<const unsigned char*>(key), key_len)) {\n+        char* pass = const_cast<char*>(config.passphrase_.get());\n+        pkey.reset(d2i_PKCS8PrivateKey_bio(bio.get(),\n+                                           nullptr,\n+                                           PasswordCallback,\n+                                           pass));\n+      } else {\n+        PKCS8Pointer p8inf(d2i_PKCS8_PRIV_KEY_INFO_bio(bio.get(), nullptr));\n+        if (p8inf)\n+          pkey.reset(EVP_PKCS82PKEY(p8inf.get()));\n+      }\n     } else {\n       CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSEC1);\n       const unsigned char* p = reinterpret_cast<const unsigned char*>(key);\n@@ -3093,40 +3154,6 @@ static ManagedEVPPKey GetPrivateKeyFromJs(\n   }\n }\n \n-static bool IsRSAPrivateKey(const unsigned char* data, size_t size) {\n-  // Both RSAPrivateKey and RSAPublicKey structures start with a SEQUENCE.\n-  if (size >= 2 && data[0] == 0x30) {\n-    size_t offset;\n-    if (data[1] & 0x80) {\n-      // Long form.\n-      size_t n_bytes = data[1] & ~0x80;\n-      if (n_bytes + 2 > size || n_bytes > sizeof(size_t))\n-        return false;\n-      size_t i, length = 0;\n-      for (i = 0; i < n_bytes; i++)\n-        length = (length << 8) | data[i + 2];\n-      offset = 2 + n_bytes;\n-      size = std::min(size, length + 2);\n-    } else {\n-      // Short form.\n-      offset = 2;\n-      size = std::min<size_t>(size, data[1] + 2);\n-    }\n-\n-    // An RSAPrivateKey sequence always starts with a single-byte integer whose\n-    // value is either 0 or 1, whereas an RSAPublicKey starts with the modulus\n-    // (which is the product of two primes and therefore at least 4), so we can\n-    // decide the type of the structure based on the first three bytes of the\n-    // sequence.\n-    return size - offset >= 3 &&\n-           data[offset] == 2 &&\n-           data[offset + 1] == 1 &&\n-           !(data[offset + 2] & 0xfe);\n-  }\n-\n-  return false;\n-}\n-\n static ManagedEVPPKey GetPublicOrPrivateKeyFromJs(\n     const FunctionCallbackInfo<Value>& args,\n     unsigned int* offset,"
        },
        {
            "sha": "e9862ff1bc5879e51db0e4bf702b8808658b4f63",
            "filename": "src/node_crypto.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/8d69fdde1955e0b08bdbe6949090f459995784a7/src%2Fnode_crypto.h",
            "raw_url": "https://github.com/nodejs/node/raw/8d69fdde1955e0b08bdbe6949090f459995784a7/src%2Fnode_crypto.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_crypto.h?ref=8d69fdde1955e0b08bdbe6949090f459995784a7",
            "patch": "@@ -77,6 +77,7 @@ using BIOPointer = DeleteFnPtr<BIO, BIO_free_all>;\n using SSLCtxPointer = DeleteFnPtr<SSL_CTX, SSL_CTX_free>;\n using SSLSessionPointer = DeleteFnPtr<SSL_SESSION, SSL_SESSION_free>;\n using SSLPointer = DeleteFnPtr<SSL, SSL_free>;\n+using PKCS8Pointer = DeleteFnPtr<PKCS8_PRIV_KEY_INFO, PKCS8_PRIV_KEY_INFO_free>;\n using EVPKeyPointer = DeleteFnPtr<EVP_PKEY, EVP_PKEY_free>;\n using EVPKeyCtxPointer = DeleteFnPtr<EVP_PKEY_CTX, EVP_PKEY_CTX_free>;\n using EVPMDPointer = DeleteFnPtr<EVP_MD_CTX, EVP_MD_CTX_free>;"
        },
        {
            "sha": "7b3eee570ddf40de25aefdd7cc7159a24681d549",
            "filename": "test/parallel/test-crypto-keygen.js",
            "status": "modified",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/nodejs/node/blob/8d69fdde1955e0b08bdbe6949090f459995784a7/test%2Fparallel%2Ftest-crypto-keygen.js",
            "raw_url": "https://github.com/nodejs/node/raw/8d69fdde1955e0b08bdbe6949090f459995784a7/test%2Fparallel%2Ftest-crypto-keygen.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fparallel%2Ftest-crypto-keygen.js?ref=8d69fdde1955e0b08bdbe6949090f459995784a7",
            "patch": "@@ -174,6 +174,73 @@ const sec1EncExp = (cipher) => getRegExpForPEM('EC PRIVATE KEY', cipher);\n     testEncryptDecrypt(publicKey, key);\n     testSignVerify(publicKey, key);\n   }));\n+\n+  // Now do the same with an encrypted private key, but encoded as DER.\n+  generateKeyPair('rsa', {\n+    publicExponent: 0x10001,\n+    modulusLength: 512,\n+    publicKeyEncoding,\n+    privateKeyEncoding: {\n+      type: 'pkcs8',\n+      format: 'der',\n+      cipher: 'aes-256-cbc',\n+      passphrase: 'secret'\n+    }\n+  }, common.mustCall((err, publicKeyDER, privateKeyDER) => {\n+    assert.ifError(err);\n+\n+    assert(Buffer.isBuffer(publicKeyDER));\n+    assertApproximateSize(publicKeyDER, 74);\n+\n+    assert(Buffer.isBuffer(privateKeyDER));\n+\n+    // Since the private key is encrypted, signing shouldn't work anymore.\n+    const publicKey = { key: publicKeyDER, ...publicKeyEncoding };\n+    assert.throws(() => {\n+      testSignVerify(publicKey, {\n+        key: privateKeyDER,\n+        format: 'der',\n+        type: 'pkcs8'\n+      });\n+    }, /bad decrypt|asn1 encoding routines/);\n+\n+    const privateKey = {\n+      key: privateKeyDER,\n+      format: 'der',\n+      type: 'pkcs8',\n+      passphrase: 'secret'\n+    };\n+    testEncryptDecrypt(publicKey, privateKey);\n+    testSignVerify(publicKey, privateKey);\n+  }));\n+\n+  // Now do the same with an encrypted private key, but encoded as DER.\n+  generateKeyPair('rsa', {\n+    publicExponent: 0x10001,\n+    modulusLength: 512,\n+    publicKeyEncoding,\n+    privateKeyEncoding: {\n+      type: 'pkcs8',\n+      format: 'der'\n+    }\n+  }, common.mustCall((err, publicKeyDER, privateKeyDER) => {\n+    assert.ifError(err);\n+\n+    assert(Buffer.isBuffer(publicKeyDER));\n+    assertApproximateSize(publicKeyDER, 74);\n+\n+    assert(Buffer.isBuffer(privateKeyDER));\n+\n+    const publicKey = { key: publicKeyDER, ...publicKeyEncoding };\n+    const privateKey = {\n+      key: privateKeyDER,\n+      format: 'der',\n+      type: 'pkcs8',\n+      passphrase: 'secret'\n+    };\n+    testEncryptDecrypt(publicKey, privateKey);\n+    testSignVerify(publicKey, privateKey);\n+  }));\n }\n \n {"
        }
    ],
    "stats": {
        "total": 173,
        "additions": 134,
        "deletions": 39
    }
}