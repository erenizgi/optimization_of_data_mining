{
    "author": "psmarshall",
    "message": "deps: backport 4 CPU profiler commits from upstream V8\n\n[cpu-profiler] Add a new profiling mode with a more detailed call tree.\nhttps://chromium.googlesource.com/v8/v8.git/+/ecae80cdb350dde1e654c531b56f5b6c44dc8c77\n\n[cpu-profiler] Reuse free slots in code_entries_\nhttps://chromium.googlesource.com/v8/v8.git/+/3e1126bf15e62c433c4e9cb21316d182f691c63a\n\n[cpu-profiler] Only store deopt inline frames for functions that need it\nhttps://chromium.googlesource.com/v8/v8.git/+/0bfcbdd4726920755e51dab28c18ab93e050819b\n\n[cpu-profiler] Use instruction start as the key for the CodeMap\nhttps://chromium.googlesource.com/v8/v8.git/+/ba752ea4c50713dff1e94f45a79db3ba968a8d66\n\nPR-URL: https://github.com/nodejs/node/pull/22028\nReviewed-By: Ruben Bridgewater <ruben@bridgewater.de>\nReviewed-By: Benedikt Meurer <benedikt.meurer@gmail.com>",
    "sha": "8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
    "files": [
        {
            "sha": "a085594786e46fba42fe89b9ef9453d467720dc3",
            "filename": "common.gypi",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/common.gypi",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/common.gypi",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/common.gypi?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -29,7 +29,7 @@\n \n     # Reset this number to 0 on major V8 upgrades.\n     # Increment by one for each non-official patch applied to deps/v8.\n-    'v8_embedder_string': '-node.22',\n+    'v8_embedder_string': '-node.23',\n \n     # Enable disassembler for `--print-code` v8 options\n     'v8_enable_disassembler': 1,"
        },
        {
            "sha": "af36aa6d2d19d5112917c1bc8289a6a98abeccb1",
            "filename": "deps/v8/include/v8-profiler.h",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Finclude%2Fv8-profiler.h",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Finclude%2Fv8-profiler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Finclude%2Fv8-profiler.h?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -277,6 +277,16 @@ class V8_EXPORT CpuProfile {\n   void Delete();\n };\n \n+enum CpuProfilingMode {\n+  // In the resulting CpuProfile tree, intermediate nodes in a stack trace\n+  // (from the root to a leaf) will have line numbers that point to the start\n+  // line of the function, rather than the line of the callsite of the child.\n+  kLeafNodeLineNumbers,\n+  // In the resulting CpuProfile tree, nodes are separated based on the line\n+  // number of their callsite in their parent.\n+  kCallerLineNumbers,\n+};\n+\n /**\n  * Interface for controlling CPU profiling. Instance of the\n  * profiler can be created using v8::CpuProfiler::New method.\n@@ -320,6 +330,13 @@ class V8_EXPORT CpuProfiler {\n    * |record_samples| parameter controls whether individual samples should\n    * be recorded in addition to the aggregated tree.\n    */\n+  void StartProfiling(Local<String> title, CpuProfilingMode mode,\n+                      bool record_samples = false);\n+  /**\n+   * The same as StartProfiling above, but the CpuProfilingMode defaults to\n+   * kLeafNodeLineNumbers mode, which was the previous default behavior of the\n+   * profiler.\n+   */\n   void StartProfiling(Local<String> title, bool record_samples = false);\n \n   /**"
        },
        {
            "sha": "50e88904afcab12590faee22bb335a029630acaf",
            "filename": "deps/v8/src/api.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fapi.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fapi.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fapi.cc?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -10017,7 +10017,7 @@ const char* CpuProfileNode::GetScriptResourceNameStr() const {\n }\n \n int CpuProfileNode::GetLineNumber() const {\n-  return reinterpret_cast<const i::ProfileNode*>(this)->entry()->line_number();\n+  return reinterpret_cast<const i::ProfileNode*>(this)->line_number();\n }\n \n \n@@ -10155,9 +10155,14 @@ void CpuProfiler::CollectSample() {\n \n void CpuProfiler::StartProfiling(Local<String> title, bool record_samples) {\n   reinterpret_cast<i::CpuProfiler*>(this)->StartProfiling(\n-      *Utils::OpenHandle(*title), record_samples);\n+      *Utils::OpenHandle(*title), record_samples, kLeafNodeLineNumbers);\n }\n \n+void CpuProfiler::StartProfiling(Local<String> title, CpuProfilingMode mode,\n+                                 bool record_samples) {\n+  reinterpret_cast<i::CpuProfiler*>(this)->StartProfiling(\n+      *Utils::OpenHandle(*title), record_samples, mode);\n+}\n \n CpuProfile* CpuProfiler::StopProfiling(Local<String> title) {\n   return reinterpret_cast<CpuProfile*>("
        },
        {
            "sha": "51946289124a8b487277a54fb3b3730f5b4c2a86",
            "filename": "deps/v8/src/code-events.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fcode-events.h",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fcode-events.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fcode-events.h?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -83,7 +83,7 @@ class CodeEventListener {\n   virtual void GetterCallbackEvent(Name* name, Address entry_point) = 0;\n   virtual void SetterCallbackEvent(Name* name, Address entry_point) = 0;\n   virtual void RegExpCodeCreateEvent(AbstractCode* code, String* source) = 0;\n-  virtual void CodeMoveEvent(AbstractCode* from, Address to) = 0;\n+  virtual void CodeMoveEvent(AbstractCode* from, AbstractCode* to) = 0;\n   virtual void SharedFunctionInfoMoveEvent(Address from, Address to) = 0;\n   virtual void CodeMovingGCEvent() = 0;\n   virtual void CodeDisableOptEvent(AbstractCode* code,\n@@ -155,7 +155,7 @@ class CodeEventDispatcher {\n   void RegExpCodeCreateEvent(AbstractCode* code, String* source) {\n     CODE_EVENT_DISPATCH(RegExpCodeCreateEvent(code, source));\n   }\n-  void CodeMoveEvent(AbstractCode* from, Address to) {\n+  void CodeMoveEvent(AbstractCode* from, AbstractCode* to) {\n     CODE_EVENT_DISPATCH(CodeMoveEvent(from, to));\n   }\n   void SharedFunctionInfoMoveEvent(Address from, Address to) {"
        },
        {
            "sha": "e69551f70e40551a488c2a23bdc4c6ecfe9dbcf8",
            "filename": "deps/v8/src/heap/mark-compact.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fheap%2Fmark-compact.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fheap%2Fmark-compact.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fheap%2Fmark-compact.cc?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -1136,7 +1136,7 @@ class ProfilingMigrationObserver final : public MigrationObserver {\n                    int size) final {\n     if (dest == CODE_SPACE || (dest == OLD_SPACE && dst->IsBytecodeArray())) {\n       PROFILE(heap_->isolate(),\n-              CodeMoveEvent(AbstractCode::cast(src), dst->address()));\n+              CodeMoveEvent(AbstractCode::cast(src), AbstractCode::cast(dst)));\n     }\n     heap_->OnMoveEvent(dst, src, size);\n   }"
        },
        {
            "sha": "da9e126879f21a27631abd0ceb3bd64f37505b94",
            "filename": "deps/v8/src/log.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 15,
            "changes": 25,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Flog.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Flog.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Flog.cc?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -270,7 +270,7 @@ class PerfBasicLogger : public CodeEventLogger {\n   PerfBasicLogger();\n   ~PerfBasicLogger() override;\n \n-  void CodeMoveEvent(AbstractCode* from, Address to) override {}\n+  void CodeMoveEvent(AbstractCode* from, AbstractCode* to) override {}\n   void CodeDisableOptEvent(AbstractCode* code,\n                            SharedFunctionInfo* shared) override {}\n \n@@ -492,7 +492,7 @@ class LowLevelLogger : public CodeEventLogger {\n   explicit LowLevelLogger(const char* file_name);\n   ~LowLevelLogger() override;\n \n-  void CodeMoveEvent(AbstractCode* from, Address to) override;\n+  void CodeMoveEvent(AbstractCode* from, AbstractCode* to) override;\n   void CodeDisableOptEvent(AbstractCode* code,\n                            SharedFunctionInfo* shared) override {}\n   void SnapshotPositionEvent(HeapObject* obj, int pos);\n@@ -610,11 +610,10 @@ void LowLevelLogger::LogRecordedBuffer(const wasm::WasmCode* code,\n                 code->instructions().length());\n }\n \n-void LowLevelLogger::CodeMoveEvent(AbstractCode* from, Address to) {\n+void LowLevelLogger::CodeMoveEvent(AbstractCode* from, AbstractCode* to) {\n   CodeMoveStruct event;\n   event.from_address = from->InstructionStart();\n-  size_t header_size = from->InstructionStart() - from->address();\n-  event.to_address = to + header_size;\n+  event.to_address = to->InstructionStart();\n   LogWriteStruct(event);\n }\n \n@@ -636,7 +635,7 @@ class JitLogger : public CodeEventLogger {\n  public:\n   explicit JitLogger(JitCodeEventHandler code_event_handler);\n \n-  void CodeMoveEvent(AbstractCode* from, Address to) override;\n+  void CodeMoveEvent(AbstractCode* from, AbstractCode* to) override;\n   void CodeDisableOptEvent(AbstractCode* code,\n                            SharedFunctionInfo* shared) override {}\n   void AddCodeLinePosInfoEvent(void* jit_handler_data, int pc_offset,\n@@ -694,7 +693,7 @@ void JitLogger::LogRecordedBuffer(const wasm::WasmCode* code, const char* name,\n   code_event_handler_(&event);\n }\n \n-void JitLogger::CodeMoveEvent(AbstractCode* from, Address to) {\n+void JitLogger::CodeMoveEvent(AbstractCode* from, AbstractCode* to) {\n   base::LockGuard<base::Mutex> guard(&logger_mutex_);\n \n   JitCodeEvent event;\n@@ -703,12 +702,7 @@ void JitLogger::CodeMoveEvent(AbstractCode* from, Address to) {\n       from->IsCode() ? JitCodeEvent::JIT_CODE : JitCodeEvent::BYTE_CODE;\n   event.code_start = reinterpret_cast<void*>(from->InstructionStart());\n   event.code_len = from->InstructionSize();\n-\n-  // Calculate the header size.\n-  const size_t header_size = from->InstructionStart() - from->address();\n-\n-  // Calculate the new start address of the instructions.\n-  event.new_code_start = reinterpret_cast<void*>(to + header_size);\n+  event.new_code_start = reinterpret_cast<void*>(to->InstructionStart());\n \n   code_event_handler_(&event);\n }\n@@ -1450,9 +1444,10 @@ void Logger::RegExpCodeCreateEvent(AbstractCode* code, String* source) {\n   msg.WriteToLogFile();\n }\n \n-void Logger::CodeMoveEvent(AbstractCode* from, Address to) {\n+void Logger::CodeMoveEvent(AbstractCode* from, AbstractCode* to) {\n   if (!is_listening_to_code_events()) return;\n-  MoveEventInternal(CodeEventListener::CODE_MOVE_EVENT, from->address(), to);\n+  MoveEventInternal(CodeEventListener::CODE_MOVE_EVENT, from->address(),\n+                    to->address());\n }\n \n namespace {"
        },
        {
            "sha": "35f668855960b2afae6e7bf49b23b54d6fe2180f",
            "filename": "deps/v8/src/log.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Flog.h",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Flog.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Flog.h?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -209,7 +209,7 @@ class Logger : public CodeEventListener {\n   // Emits a code create event for a RegExp.\n   void RegExpCodeCreateEvent(AbstractCode* code, String* source);\n   // Emits a code move event.\n-  void CodeMoveEvent(AbstractCode* from, Address to);\n+  void CodeMoveEvent(AbstractCode* from, AbstractCode* to);\n   // Emits a code line info record event.\n   void CodeLinePosInfoRecordEvent(Address code_start,\n                                   ByteArray* source_position_table);\n@@ -466,7 +466,7 @@ class ExternalCodeEventListener : public CodeEventListener {\n   void GetterCallbackEvent(Name* name, Address entry_point) override {}\n   void SetterCallbackEvent(Name* name, Address entry_point) override {}\n   void SharedFunctionInfoMoveEvent(Address from, Address to) override {}\n-  void CodeMoveEvent(AbstractCode* from, Address to) override {}\n+  void CodeMoveEvent(AbstractCode* from, AbstractCode* to) override {}\n   void CodeDisableOptEvent(AbstractCode* code,\n                            SharedFunctionInfo* shared) override {}\n   void CodeMovingGCEvent() override {}"
        },
        {
            "sha": "dfccb293d186fe12a815e401c1db45b4fdc3a79f",
            "filename": "deps/v8/src/perf-jit.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fperf-jit.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fperf-jit.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fperf-jit.cc?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -419,7 +419,7 @@ void PerfJitLogger::LogWriteUnwindingInfo(Code* code) {\n   LogWriteBytes(padding_bytes, static_cast<int>(padding_size));\n }\n \n-void PerfJitLogger::CodeMoveEvent(AbstractCode* from, Address to) {\n+void PerfJitLogger::CodeMoveEvent(AbstractCode* from, AbstractCode* to) {\n   // We may receive a CodeMove event if a BytecodeArray object moves. Otherwise\n   // code relocation is not supported.\n   CHECK(from->IsBytecodeArray());"
        },
        {
            "sha": "bbcc79dd1c4a65f3eb4de6341235a6cef74de3f4",
            "filename": "deps/v8/src/perf-jit.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fperf-jit.h",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fperf-jit.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fperf-jit.h?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -41,7 +41,7 @@ class PerfJitLogger : public CodeEventLogger {\n   PerfJitLogger();\n   virtual ~PerfJitLogger();\n \n-  void CodeMoveEvent(AbstractCode* from, Address to) override;\n+  void CodeMoveEvent(AbstractCode* from, AbstractCode* to) override;\n   void CodeDisableOptEvent(AbstractCode* code,\n                            SharedFunctionInfo* shared) override {}\n \n@@ -118,7 +118,7 @@ class PerfJitLogger : public CodeEventLogger {\n // PerfJitLogger is only implemented on Linux\n class PerfJitLogger : public CodeEventLogger {\n  public:\n-  void CodeMoveEvent(AbstractCode* from, Address to) override {\n+  void CodeMoveEvent(AbstractCode* from, AbstractCode* to) override {\n     UNIMPLEMENTED();\n   }\n "
        },
        {
            "sha": "d8603c81685ae1b4b36e9f32317bedb0f70d7e27",
            "filename": "deps/v8/src/profiler/cpu-profiler-inl.h",
            "status": "modified",
            "additions": 10,
            "deletions": 6,
            "changes": 16,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fcpu-profiler-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fcpu-profiler-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fprofiler%2Fcpu-profiler-inl.h?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -16,31 +16,35 @@ namespace v8 {\n namespace internal {\n \n void CodeCreateEventRecord::UpdateCodeMap(CodeMap* code_map) {\n-  code_map->AddCode(start, entry, size);\n+  code_map->AddCode(instruction_start, entry, instruction_size);\n }\n \n \n void CodeMoveEventRecord::UpdateCodeMap(CodeMap* code_map) {\n-  code_map->MoveCode(from, to);\n+  code_map->MoveCode(from_instruction_start, to_instruction_start);\n }\n \n \n void CodeDisableOptEventRecord::UpdateCodeMap(CodeMap* code_map) {\n-  CodeEntry* entry = code_map->FindEntry(start);\n+  CodeEntry* entry = code_map->FindEntry(instruction_start);\n   if (entry != nullptr) {\n     entry->set_bailout_reason(bailout_reason);\n   }\n }\n \n \n void CodeDeoptEventRecord::UpdateCodeMap(CodeMap* code_map) {\n-  CodeEntry* entry = code_map->FindEntry(start);\n-  if (entry != nullptr) entry->set_deopt_info(deopt_reason, deopt_id);\n+  CodeEntry* entry = code_map->FindEntry(instruction_start);\n+  if (entry == nullptr) return;\n+  std::vector<CpuProfileDeoptFrame> frames_vector(\n+      deopt_frames, deopt_frames + deopt_frame_count);\n+  entry->set_deopt_info(deopt_reason, deopt_id, std::move(frames_vector));\n+  delete[] deopt_frames;\n }\n \n \n void ReportBuiltinEventRecord::UpdateCodeMap(CodeMap* code_map) {\n-  CodeEntry* entry = code_map->FindEntry(start);\n+  CodeEntry* entry = code_map->FindEntry(instruction_start);\n   if (!entry) {\n     // Code objects for builtins should already have been added to the map but\n     // some of them have been filtered out by CpuProfiler."
        },
        {
            "sha": "79606dc812ebda1b203547377b4b417f338ac394",
            "filename": "deps/v8/src/profiler/cpu-profiler.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fcpu-profiler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fcpu-profiler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fprofiler%2Fcpu-profiler.cc?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -345,20 +345,20 @@ void CpuProfiler::CollectSample() {\n   }\n }\n \n-void CpuProfiler::StartProfiling(const char* title, bool record_samples) {\n-  if (profiles_->StartProfiling(title, record_samples)) {\n+void CpuProfiler::StartProfiling(const char* title, bool record_samples,\n+                                 ProfilingMode mode) {\n+  if (profiles_->StartProfiling(title, record_samples, mode)) {\n     TRACE_EVENT0(\"v8\", \"CpuProfiler::StartProfiling\");\n     StartProcessorIfNotStarted();\n   }\n }\n \n-\n-void CpuProfiler::StartProfiling(String* title, bool record_samples) {\n-  StartProfiling(profiles_->GetName(title), record_samples);\n+void CpuProfiler::StartProfiling(String* title, bool record_samples,\n+                                 ProfilingMode mode) {\n+  StartProfiling(profiles_->GetName(title), record_samples, mode);\n   isolate_->debug()->feature_tracker()->Track(DebugFeatureTracker::kProfiler);\n }\n \n-\n void CpuProfiler::StartProcessorIfNotStarted() {\n   if (processor_) {\n     processor_->AddCurrentStack(isolate_);\n@@ -426,7 +426,7 @@ void CpuProfiler::LogBuiltins() {\n     CodeEventsContainer evt_rec(CodeEventRecord::REPORT_BUILTIN);\n     ReportBuiltinEventRecord* rec = &evt_rec.ReportBuiltinEventRecord_;\n     Builtins::Name id = static_cast<Builtins::Name>(i);\n-    rec->start = builtins->builtin(id)->address();\n+    rec->instruction_start = builtins->builtin(id)->InstructionStart();\n     rec->builtin_id = id;\n     processor_->Enqueue(evt_rec);\n   }"
        },
        {
            "sha": "4e56c7bd7409e3e7084a004379c9bff123be5bda",
            "filename": "deps/v8/src/profiler/cpu-profiler.h",
            "status": "modified",
            "additions": 14,
            "deletions": 9,
            "changes": 23,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fcpu-profiler.h",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fcpu-profiler.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fprofiler%2Fcpu-profiler.h?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -53,26 +53,26 @@ class CodeEventRecord {\n \n class CodeCreateEventRecord : public CodeEventRecord {\n  public:\n-  Address start;\n+  Address instruction_start;\n   CodeEntry* entry;\n-  unsigned size;\n+  unsigned instruction_size;\n \n   INLINE(void UpdateCodeMap(CodeMap* code_map));\n };\n \n \n class CodeMoveEventRecord : public CodeEventRecord {\n  public:\n-  Address from;\n-  Address to;\n+  Address from_instruction_start;\n+  Address to_instruction_start;\n \n   INLINE(void UpdateCodeMap(CodeMap* code_map));\n };\n \n \n class CodeDisableOptEventRecord : public CodeEventRecord {\n  public:\n-  Address start;\n+  Address instruction_start;\n   const char* bailout_reason;\n \n   INLINE(void UpdateCodeMap(CodeMap* code_map));\n@@ -81,19 +81,21 @@ class CodeDisableOptEventRecord : public CodeEventRecord {\n \n class CodeDeoptEventRecord : public CodeEventRecord {\n  public:\n-  Address start;\n+  Address instruction_start;\n   const char* deopt_reason;\n   int deopt_id;\n   Address pc;\n   int fp_to_sp_delta;\n+  CpuProfileDeoptFrame* deopt_frames;\n+  int deopt_frame_count;\n \n   INLINE(void UpdateCodeMap(CodeMap* code_map));\n };\n \n \n class ReportBuiltinEventRecord : public CodeEventRecord {\n  public:\n-  Address start;\n+  Address instruction_start;\n   Builtins::Name builtin_id;\n \n   INLINE(void UpdateCodeMap(CodeMap* code_map));\n@@ -197,10 +199,13 @@ class CpuProfiler : public CodeEventObserver {\n \n   static void CollectSample(Isolate* isolate);\n \n+  typedef v8::CpuProfilingMode ProfilingMode;\n+\n   void set_sampling_interval(base::TimeDelta value);\n   void CollectSample();\n-  void StartProfiling(const char* title, bool record_samples = false);\n-  void StartProfiling(String* title, bool record_samples);\n+  void StartProfiling(const char* title, bool record_samples = false,\n+                      ProfilingMode mode = ProfilingMode::kLeafNodeLineNumbers);\n+  void StartProfiling(String* title, bool record_samples, ProfilingMode mode);\n   CpuProfile* StopProfiling(const char* title);\n   CpuProfile* StopProfiling(String* title);\n   int GetProfilesCount();"
        },
        {
            "sha": "31652ba9f98e83341de9e2b3b9207966d2d3b57a",
            "filename": "deps/v8/src/profiler/profile-generator-inl.h",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofile-generator-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofile-generator-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofile-generator-inl.h?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -33,10 +33,11 @@ inline CodeEntry* ProfileGenerator::FindEntry(Address address) {\n }\n \n ProfileNode::ProfileNode(ProfileTree* tree, CodeEntry* entry,\n-                         ProfileNode* parent)\n+                         ProfileNode* parent, int line_number)\n     : tree_(tree),\n       entry_(entry),\n       self_ticks_(0),\n+      line_number_(line_number),\n       parent_(parent),\n       id_(tree->next_node_id()) {\n   tree_->EnqueueNode(this);"
        },
        {
            "sha": "4273234dd23d86d4f6de4ebe4ad7d78f3ba00d3b",
            "filename": "deps/v8/src/profiler/profile-generator.cc",
            "status": "modified",
            "additions": 141,
            "deletions": 69,
            "changes": 210,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofile-generator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofile-generator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofile-generator.cc?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -131,15 +131,14 @@ const std::vector<std::unique_ptr<CodeEntry>>* CodeEntry::GetInlineStack(\n   return it != rare_data_->inline_locations_.end() ? &it->second : nullptr;\n }\n \n-void CodeEntry::AddDeoptInlinedFrames(\n-    int deopt_id, std::vector<CpuProfileDeoptFrame> inlined_frames) {\n-  EnsureRareData()->deopt_inlined_frames_.insert(\n-      std::make_pair(deopt_id, std::move(inlined_frames)));\n-}\n-\n-bool CodeEntry::HasDeoptInlinedFramesFor(int deopt_id) const {\n-  return rare_data_ && rare_data_->deopt_inlined_frames_.find(deopt_id) !=\n-                           rare_data_->deopt_inlined_frames_.end();\n+void CodeEntry::set_deopt_info(\n+    const char* deopt_reason, int deopt_id,\n+    std::vector<CpuProfileDeoptFrame> inlined_frames) {\n+  DCHECK(!has_deopt_info());\n+  RareData* rare_data = EnsureRareData();\n+  rare_data->deopt_reason_ = deopt_reason;\n+  rare_data->deopt_id_ = deopt_id;\n+  rare_data->deopt_inlined_frames_ = std::move(inlined_frames);\n }\n \n void CodeEntry::FillFunctionInfo(SharedFunctionInfo* shared) {\n@@ -158,12 +157,11 @@ CpuProfileDeoptInfo CodeEntry::GetDeoptInfo() {\n   CpuProfileDeoptInfo info;\n   info.deopt_reason = rare_data_->deopt_reason_;\n   DCHECK_NE(kNoDeoptimizationId, rare_data_->deopt_id_);\n-  if (rare_data_->deopt_inlined_frames_.find(rare_data_->deopt_id_) ==\n-      rare_data_->deopt_inlined_frames_.end()) {\n+  if (rare_data_->deopt_inlined_frames_.empty()) {\n     info.stack.push_back(CpuProfileDeoptFrame(\n         {script_id_, static_cast<size_t>(std::max(0, position()))}));\n   } else {\n-    info.stack = rare_data_->deopt_inlined_frames_[rare_data_->deopt_id_];\n+    info.stack = rare_data_->deopt_inlined_frames_;\n   }\n   return info;\n }\n@@ -180,18 +178,16 @@ void ProfileNode::CollectDeoptInfo(CodeEntry* entry) {\n   entry->clear_deopt_info();\n }\n \n-\n-ProfileNode* ProfileNode::FindChild(CodeEntry* entry) {\n-  auto map_entry = children_.find(entry);\n+ProfileNode* ProfileNode::FindChild(CodeEntry* entry, int line_number) {\n+  auto map_entry = children_.find({entry, line_number});\n   return map_entry != children_.end() ? map_entry->second : nullptr;\n }\n \n-\n-ProfileNode* ProfileNode::FindOrAddChild(CodeEntry* entry) {\n-  auto map_entry = children_.find(entry);\n+ProfileNode* ProfileNode::FindOrAddChild(CodeEntry* entry, int line_number) {\n+  auto map_entry = children_.find({entry, line_number});\n   if (map_entry == children_.end()) {\n-    ProfileNode* node = new ProfileNode(tree_, entry, this);\n-    children_[entry] = node;\n+    ProfileNode* node = new ProfileNode(tree_, entry, this, line_number);\n+    children_[{entry, line_number}] = node;\n     children_list_.push_back(node);\n     return node;\n   } else {\n@@ -234,8 +230,9 @@ bool ProfileNode::GetLineTicks(v8::CpuProfileNode::LineTick* entries,\n \n \n void ProfileNode::Print(int indent) {\n-  base::OS::Print(\"%5u %*s %s %d #%d\", self_ticks_, indent, \"\", entry_->name(),\n-                  entry_->script_id(), id());\n+  int line_number = line_number_ != 0 ? line_number_ : entry_->line_number();\n+  base::OS::Print(\"%5u %*s %s:%d %d #%d\", self_ticks_, indent, \"\",\n+                  entry_->name(), line_number, entry_->script_id(), id());\n   if (entry_->resource_name()[0] != '\\0')\n     base::OS::Print(\" %s:%d\", entry_->resource_name(), entry_->line_number());\n   base::OS::Print(\"\\n\");\n@@ -304,7 +301,33 @@ ProfileNode* ProfileTree::AddPathFromEnd(const std::vector<CodeEntry*>& path,\n   for (auto it = path.rbegin(); it != path.rend(); ++it) {\n     if (*it == nullptr) continue;\n     last_entry = *it;\n-    node = node->FindOrAddChild(*it);\n+    node = node->FindOrAddChild(*it, v8::CpuProfileNode::kNoLineNumberInfo);\n+  }\n+  if (last_entry && last_entry->has_deopt_info()) {\n+    node->CollectDeoptInfo(last_entry);\n+  }\n+  if (update_stats) {\n+    node->IncrementSelfTicks();\n+    if (src_line != v8::CpuProfileNode::kNoLineNumberInfo) {\n+      node->IncrementLineTicks(src_line);\n+    }\n+  }\n+  return node;\n+}\n+\n+ProfileNode* ProfileTree::AddPathFromEnd(const ProfileStackTrace& path,\n+                                         int src_line, bool update_stats,\n+                                         ProfilingMode mode) {\n+  ProfileNode* node = root_;\n+  CodeEntry* last_entry = nullptr;\n+  int parent_line_number = v8::CpuProfileNode::kNoLineNumberInfo;\n+  for (auto it = path.rbegin(); it != path.rend(); ++it) {\n+    if ((*it).code_entry == nullptr) continue;\n+    last_entry = (*it).code_entry;\n+    node = node->FindOrAddChild((*it).code_entry, parent_line_number);\n+    parent_line_number = mode == ProfilingMode::kCallerLineNumbers\n+                             ? (*it).line_number\n+                             : v8::CpuProfileNode::kNoLineNumberInfo;\n   }\n   if (last_entry && last_entry->has_deopt_info()) {\n     node->CollectDeoptInfo(last_entry);\n@@ -363,9 +386,10 @@ void ProfileTree::TraverseDepthFirst(Callback* callback) {\n using v8::tracing::TracedValue;\n \n CpuProfile::CpuProfile(CpuProfiler* profiler, const char* title,\n-                       bool record_samples)\n+                       bool record_samples, ProfilingMode mode)\n     : title_(title),\n       record_samples_(record_samples),\n+      mode_(mode),\n       start_time_(base::TimeTicks::HighResolutionNow()),\n       top_down_(profiler->isolate()),\n       profiler_(profiler),\n@@ -378,14 +402,16 @@ CpuProfile::CpuProfile(CpuProfiler* profiler, const char* title,\n }\n \n void CpuProfile::AddPath(base::TimeTicks timestamp,\n-                         const std::vector<CodeEntry*>& path, int src_line,\n+                         const ProfileStackTrace& path, int src_line,\n                          bool update_stats) {\n   ProfileNode* top_frame_node =\n-      top_down_.AddPathFromEnd(path, src_line, update_stats);\n+      top_down_.AddPathFromEnd(path, src_line, update_stats, mode_);\n+\n   if (record_samples_ && !timestamp.IsNull()) {\n     timestamps_.push_back(timestamp);\n     samples_.push_back(top_frame_node);\n   }\n+\n   const int kSamplesFlushCount = 100;\n   const int kNodesFlushCount = 10;\n   if (samples_.size() - streaming_next_sample_ >= kSamplesFlushCount ||\n@@ -482,13 +508,25 @@ void CpuProfile::Print() {\n }\n \n CodeMap::CodeMap() = default;\n-CodeMap::~CodeMap() = default;\n+\n+CodeMap::~CodeMap() {\n+  // First clean the free list as it's otherwise impossible to tell\n+  // the slot type.\n+  unsigned free_slot = free_list_head_;\n+  while (free_slot != kNoFreeSlot) {\n+    unsigned next_slot = code_entries_[free_slot].next_free_slot;\n+    code_entries_[free_slot].entry = nullptr;\n+    free_slot = next_slot;\n+  }\n+  for (auto slot : code_entries_) delete slot.entry;\n+}\n \n void CodeMap::AddCode(Address addr, CodeEntry* entry, unsigned size) {\n   ClearCodesInRange(addr, addr + size);\n-  code_map_.emplace(\n-      addr, CodeEntryInfo{static_cast<unsigned>(code_entries_.size()), size});\n-  code_entries_.push_back(std::unique_ptr<CodeEntry>(entry));\n+  unsigned index = AddCodeEntry(addr, entry);\n+  code_map_.emplace(addr, CodeEntryMapInfo{index, size});\n+  DCHECK(entry->instruction_start() == kNullAddress ||\n+         addr == entry->instruction_start());\n }\n \n void CodeMap::ClearCodesInRange(Address start, Address end) {\n@@ -499,9 +537,8 @@ void CodeMap::ClearCodesInRange(Address start, Address end) {\n   }\n   auto right = left;\n   for (; right != code_map_.end() && right->first < end; ++right) {\n-    std::unique_ptr<CodeEntry>& entry = code_entries_[right->second.index];\n-    if (!entry->used()) {\n-      entry.reset();\n+    if (!entry(right->second.index)->used()) {\n+      DeleteCodeEntry(right->second.index);\n     }\n   }\n   code_map_.erase(left, right);\n@@ -511,28 +548,51 @@ CodeEntry* CodeMap::FindEntry(Address addr) {\n   auto it = code_map_.upper_bound(addr);\n   if (it == code_map_.begin()) return nullptr;\n   --it;\n-  Address end_address = it->first + it->second.size;\n-  if (addr >= end_address) return nullptr;\n-  CodeEntry* entry = code_entries_[it->second.index].get();\n-  DCHECK(entry);\n-  return entry;\n+  Address start_address = it->first;\n+  Address end_address = start_address + it->second.size;\n+  CodeEntry* ret = addr < end_address ? entry(it->second.index) : nullptr;\n+  if (ret && ret->instruction_start() != kNullAddress) {\n+    DCHECK_EQ(start_address, ret->instruction_start());\n+    DCHECK(addr >= start_address && addr < end_address);\n+  }\n+  return ret;\n }\n \n void CodeMap::MoveCode(Address from, Address to) {\n   if (from == to) return;\n   auto it = code_map_.find(from);\n   if (it == code_map_.end()) return;\n-  CodeEntryInfo info = it->second;\n+  CodeEntryMapInfo info = it->second;\n   code_map_.erase(it);\n   DCHECK(from + info.size <= to || to + info.size <= from);\n   ClearCodesInRange(to, to + info.size);\n   code_map_.emplace(to, info);\n+\n+  CodeEntry* entry = code_entries_[info.index].entry;\n+  entry->set_instruction_start(to);\n+}\n+\n+unsigned CodeMap::AddCodeEntry(Address start, CodeEntry* entry) {\n+  if (free_list_head_ == kNoFreeSlot) {\n+    code_entries_.push_back(CodeEntrySlotInfo{entry});\n+    return static_cast<unsigned>(code_entries_.size()) - 1;\n+  }\n+  unsigned index = free_list_head_;\n+  free_list_head_ = code_entries_[index].next_free_slot;\n+  code_entries_[index].entry = entry;\n+  return index;\n+}\n+\n+void CodeMap::DeleteCodeEntry(unsigned index) {\n+  delete code_entries_[index].entry;\n+  code_entries_[index].next_free_slot = free_list_head_;\n+  free_list_head_ = index;\n }\n \n void CodeMap::Print() {\n   for (const auto& pair : code_map_) {\n     base::OS::Print(\"%p %5d %s\\n\", reinterpret_cast<void*>(pair.first),\n-                    pair.second.size, code_entries_[pair.second.index]->name());\n+                    pair.second.size, entry(pair.second.index)->name());\n   }\n }\n \n@@ -542,7 +602,8 @@ CpuProfilesCollection::CpuProfilesCollection(Isolate* isolate)\n       current_profiles_semaphore_(1) {}\n \n bool CpuProfilesCollection::StartProfiling(const char* title,\n-                                           bool record_samples) {\n+                                           bool record_samples,\n+                                           ProfilingMode mode) {\n   current_profiles_semaphore_.Wait();\n   if (static_cast<int>(current_profiles_.size()) >= kMaxSimultaneousProfiles) {\n     current_profiles_semaphore_.Signal();\n@@ -557,7 +618,7 @@ bool CpuProfilesCollection::StartProfiling(const char* title,\n     }\n   }\n   current_profiles_.emplace_back(\n-      new CpuProfile(profiler_, title, record_samples));\n+      new CpuProfile(profiler_, title, record_samples, mode));\n   current_profiles_semaphore_.Signal();\n   return true;\n }\n@@ -608,8 +669,8 @@ void CpuProfilesCollection::RemoveProfile(CpuProfile* profile) {\n }\n \n void CpuProfilesCollection::AddPathToCurrentProfiles(\n-    base::TimeTicks timestamp, const std::vector<CodeEntry*>& path,\n-    int src_line, bool update_stats) {\n+    base::TimeTicks timestamp, const ProfileStackTrace& path, int src_line,\n+    bool update_stats) {\n   // As starting / stopping profiles is rare relatively to this\n   // method, we don't bother minimizing the duration of lock holding,\n   // e.g. copying contents of the list to a local vector.\n@@ -624,47 +685,52 @@ ProfileGenerator::ProfileGenerator(CpuProfilesCollection* profiles)\n     : profiles_(profiles) {}\n \n void ProfileGenerator::RecordTickSample(const TickSample& sample) {\n-  std::vector<CodeEntry*> entries;\n+  ProfileStackTrace stack_trace;\n   // Conservatively reserve space for stack frames + pc + function + vm-state.\n   // There could in fact be more of them because of inlined entries.\n-  entries.reserve(sample.frames_count + 3);\n+  stack_trace.reserve(sample.frames_count + 3);\n \n   // The ProfileNode knows nothing about all versions of generated code for\n   // the same JS function. The line number information associated with\n   // the latest version of generated code is used to find a source line number\n   // for a JS function. Then, the detected source line is passed to\n   // ProfileNode to increase the tick count for this source line.\n-  int src_line = v8::CpuProfileNode::kNoLineNumberInfo;\n+  const int no_line_info = v8::CpuProfileNode::kNoLineNumberInfo;\n+  int src_line = no_line_info;\n   bool src_line_not_found = true;\n \n   if (sample.pc != nullptr) {\n     if (sample.has_external_callback && sample.state == EXTERNAL) {\n       // Don't use PC when in external callback code, as it can point\n-      // inside callback's code, and we will erroneously report\n+      // inside a callback's code, and we will erroneously report\n       // that a callback calls itself.\n-      entries.push_back(\n-          FindEntry(reinterpret_cast<Address>(sample.external_callback_entry)));\n+      stack_trace.push_back(\n+          {FindEntry(reinterpret_cast<Address>(sample.external_callback_entry)),\n+           no_line_info});\n     } else {\n-      CodeEntry* pc_entry = FindEntry(reinterpret_cast<Address>(sample.pc));\n-      // If there is no pc_entry we're likely in native code.\n-      // Find out, if top of stack was pointing inside a JS function\n-      // meaning that we have encountered a frameless invocation.\n+      Address attributed_pc = reinterpret_cast<Address>(sample.pc);\n+      CodeEntry* pc_entry = FindEntry(attributed_pc);\n+      // If there is no pc_entry, we're likely in native code. Find out if the\n+      // top of the stack (the return address) was pointing inside a JS\n+      // function, meaning that we have encountered a frameless invocation.\n       if (!pc_entry && !sample.has_external_callback) {\n-        pc_entry = FindEntry(reinterpret_cast<Address>(sample.tos));\n+        attributed_pc = reinterpret_cast<Address>(sample.tos);\n+        pc_entry = FindEntry(attributed_pc);\n       }\n       // If pc is in the function code before it set up stack frame or after the\n-      // frame was destroyed SafeStackFrameIterator incorrectly thinks that\n-      // ebp contains return address of the current function and skips caller's\n-      // frame. Check for this case and just skip such samples.\n+      // frame was destroyed, SafeStackFrameIterator incorrectly thinks that\n+      // ebp contains the return address of the current function and skips the\n+      // caller's frame. Check for this case and just skip such samples.\n       if (pc_entry) {\n-        int pc_offset = static_cast<int>(reinterpret_cast<Address>(sample.pc) -\n-                                         pc_entry->instruction_start());\n+        int pc_offset =\n+            static_cast<int>(attributed_pc - pc_entry->instruction_start());\n+        DCHECK_GE(pc_offset, 0);\n         src_line = pc_entry->GetSourceLine(pc_offset);\n         if (src_line == v8::CpuProfileNode::kNoLineNumberInfo) {\n           src_line = pc_entry->line_number();\n         }\n         src_line_not_found = false;\n-        entries.push_back(pc_entry);\n+        stack_trace.push_back({pc_entry, src_line});\n \n         if (pc_entry->builtin_id() == Builtins::kFunctionPrototypeApply ||\n             pc_entry->builtin_id() == Builtins::kFunctionPrototypeCall) {\n@@ -675,7 +741,8 @@ void ProfileGenerator::RecordTickSample(const TickSample& sample) {\n           // former case we don't so we simply replace the frame with\n           // 'unresolved' entry.\n           if (!sample.has_external_callback) {\n-            entries.push_back(CodeEntry::unresolved_entry());\n+            stack_trace.push_back(\n+                {CodeEntry::unresolved_entry(), no_line_info});\n           }\n         }\n       }\n@@ -684,17 +751,21 @@ void ProfileGenerator::RecordTickSample(const TickSample& sample) {\n     for (unsigned i = 0; i < sample.frames_count; ++i) {\n       Address stack_pos = reinterpret_cast<Address>(sample.stack[i]);\n       CodeEntry* entry = FindEntry(stack_pos);\n+      int line_number = no_line_info;\n       if (entry) {\n         // Find out if the entry has an inlining stack associated.\n         int pc_offset =\n             static_cast<int>(stack_pos - entry->instruction_start());\n+        DCHECK_GE(pc_offset, 0);\n         const std::vector<std::unique_ptr<CodeEntry>>* inline_stack =\n             entry->GetInlineStack(pc_offset);\n         if (inline_stack) {\n           std::transform(\n               inline_stack->rbegin(), inline_stack->rend(),\n-              std::back_inserter(entries),\n-              [](const std::unique_ptr<CodeEntry>& ptr) { return ptr.get(); });\n+              std::back_inserter(stack_trace),\n+              [=](const std::unique_ptr<CodeEntry>& ptr) {\n+                return CodeEntryAndLineNumber{ptr.get(), no_line_info};\n+              });\n         }\n         // Skip unresolved frames (e.g. internal frame) and get source line of\n         // the first JS caller.\n@@ -705,26 +776,27 @@ void ProfileGenerator::RecordTickSample(const TickSample& sample) {\n           }\n           src_line_not_found = false;\n         }\n+        line_number = entry->GetSourceLine(pc_offset);\n       }\n-      entries.push_back(entry);\n+      stack_trace.push_back({entry, line_number});\n     }\n   }\n \n   if (FLAG_prof_browser_mode) {\n     bool no_symbolized_entries = true;\n-    for (auto e : entries) {\n-      if (e != nullptr) {\n+    for (auto e : stack_trace) {\n+      if (e.code_entry != nullptr) {\n         no_symbolized_entries = false;\n         break;\n       }\n     }\n     // If no frames were symbolized, put the VM state entry in.\n     if (no_symbolized_entries) {\n-      entries.push_back(EntryForVMState(sample.state));\n+      stack_trace.push_back({EntryForVMState(sample.state), no_line_info});\n     }\n   }\n \n-  profiles_->AddPathToCurrentProfiles(sample.timestamp, entries, src_line,\n+  profiles_->AddPathToCurrentProfiles(sample.timestamp, stack_trace, src_line,\n                                       sample.update_stats);\n }\n "
        },
        {
            "sha": "e575a786481d5160c8fe820e7f3dc0835d934c93",
            "filename": "deps/v8/src/profiler/profile-generator.h",
            "status": "modified",
            "additions": 69,
            "deletions": 28,
            "changes": 97,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofile-generator.h",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofile-generator.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofile-generator.h?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -6,9 +6,11 @@\n #define V8_PROFILER_PROFILE_GENERATOR_H_\n \n #include <deque>\n+#include <limits>\n #include <map>\n #include <memory>\n #include <unordered_map>\n+#include <utility>\n #include <vector>\n \n #include \"include/v8-profiler.h\"\n@@ -72,12 +74,9 @@ class CodeEntry {\n     return rare_data_ ? rare_data_->bailout_reason_ : kEmptyBailoutReason;\n   }\n \n-  void set_deopt_info(const char* deopt_reason, int deopt_id) {\n-    DCHECK(!has_deopt_info());\n-    RareData* rare_data = EnsureRareData();\n-    rare_data->deopt_reason_ = deopt_reason;\n-    rare_data->deopt_id_ = deopt_id;\n-  }\n+  void set_deopt_info(const char* deopt_reason, int deopt_id,\n+                      std::vector<CpuProfileDeoptFrame> inlined_frames);\n+\n   CpuProfileDeoptInfo GetDeoptInfo();\n   bool has_deopt_info() const {\n     return rare_data_ && rare_data_->deopt_id_ != kNoDeoptimizationId;\n@@ -108,10 +107,9 @@ class CodeEntry {\n   const std::vector<std::unique_ptr<CodeEntry>>* GetInlineStack(\n       int pc_offset) const;\n \n-  void AddDeoptInlinedFrames(int deopt_id, std::vector<CpuProfileDeoptFrame>);\n-  bool HasDeoptInlinedFramesFor(int deopt_id) const;\n-\n+  void set_instruction_start(Address start) { instruction_start_ = start; }\n   Address instruction_start() const { return instruction_start_; }\n+\n   CodeEventListener::LogEventsAndTags tag() const {\n     return TagField::decode(bit_field_);\n   }\n@@ -143,8 +141,7 @@ class CodeEntry {\n     int deopt_id_ = kNoDeoptimizationId;\n     std::unordered_map<int, std::vector<std::unique_ptr<CodeEntry>>>\n         inline_locations_;\n-    std::unordered_map<int, std::vector<CpuProfileDeoptFrame>>\n-        deopt_inlined_frames_;\n+    std::vector<CpuProfileDeoptFrame> deopt_inlined_frames_;\n   };\n \n   RareData* EnsureRareData();\n@@ -189,15 +186,24 @@ class CodeEntry {\n   DISALLOW_COPY_AND_ASSIGN(CodeEntry);\n };\n \n+struct CodeEntryAndLineNumber {\n+  CodeEntry* code_entry;\n+  int line_number;\n+};\n+\n+typedef std::vector<CodeEntryAndLineNumber> ProfileStackTrace;\n \n class ProfileTree;\n \n class ProfileNode {\n  public:\n-  inline ProfileNode(ProfileTree* tree, CodeEntry* entry, ProfileNode* parent);\n+  inline ProfileNode(ProfileTree* tree, CodeEntry* entry, ProfileNode* parent,\n+                     int line_number = 0);\n \n-  ProfileNode* FindChild(CodeEntry* entry);\n-  ProfileNode* FindOrAddChild(CodeEntry* entry);\n+  ProfileNode* FindChild(\n+      CodeEntry* entry,\n+      int line_number = v8::CpuProfileNode::kNoLineNumberInfo);\n+  ProfileNode* FindOrAddChild(CodeEntry* entry, int line_number = 0);\n   void IncrementSelfTicks() { ++self_ticks_; }\n   void IncreaseSelfTicks(unsigned amount) { self_ticks_ += amount; }\n   void IncrementLineTicks(int src_line);\n@@ -208,6 +214,10 @@ class ProfileNode {\n   unsigned id() const { return id_; }\n   unsigned function_id() const;\n   ProfileNode* parent() const { return parent_; }\n+  int line_number() const {\n+    return line_number_ != 0 ? line_number_ : entry_->line_number();\n+  }\n+\n   unsigned int GetHitLineCount() const {\n     return static_cast<unsigned int>(line_ticks_.size());\n   }\n@@ -222,20 +232,25 @@ class ProfileNode {\n   void Print(int indent);\n \n  private:\n-  struct CodeEntryEqual {\n-    bool operator()(CodeEntry* entry1, CodeEntry* entry2) const {\n-      return entry1 == entry2 || entry1->IsSameFunctionAs(entry2);\n+  struct Equals {\n+    bool operator()(CodeEntryAndLineNumber lhs,\n+                    CodeEntryAndLineNumber rhs) const {\n+      return lhs.code_entry->IsSameFunctionAs(rhs.code_entry) &&\n+             lhs.line_number == rhs.line_number;\n     }\n   };\n-  struct CodeEntryHash {\n-    std::size_t operator()(CodeEntry* entry) const { return entry->GetHash(); }\n+  struct Hasher {\n+    std::size_t operator()(CodeEntryAndLineNumber pair) const {\n+      return pair.code_entry->GetHash() ^ ComputeIntegerHash(pair.line_number);\n+    }\n   };\n \n   ProfileTree* tree_;\n   CodeEntry* entry_;\n   unsigned self_ticks_;\n-  std::unordered_map<CodeEntry*, ProfileNode*, CodeEntryHash, CodeEntryEqual>\n+  std::unordered_map<CodeEntryAndLineNumber, ProfileNode*, Hasher, Equals>\n       children_;\n+  int line_number_;\n   std::vector<ProfileNode*> children_list_;\n   ProfileNode* parent_;\n   unsigned id_;\n@@ -253,10 +268,17 @@ class ProfileTree {\n   explicit ProfileTree(Isolate* isolate);\n   ~ProfileTree();\n \n+  typedef v8::CpuProfilingMode ProfilingMode;\n+\n   ProfileNode* AddPathFromEnd(\n       const std::vector<CodeEntry*>& path,\n       int src_line = v8::CpuProfileNode::kNoLineNumberInfo,\n       bool update_stats = true);\n+  ProfileNode* AddPathFromEnd(\n+      const ProfileStackTrace& path,\n+      int src_line = v8::CpuProfileNode::kNoLineNumberInfo,\n+      bool update_stats = true,\n+      ProfilingMode mode = ProfilingMode::kLeafNodeLineNumbers);\n   ProfileNode* root() const { return root_; }\n   unsigned next_node_id() { return next_node_id_++; }\n   unsigned GetFunctionId(const ProfileNode* node);\n@@ -293,10 +315,13 @@ class ProfileTree {\n \n class CpuProfile {\n  public:\n-  CpuProfile(CpuProfiler* profiler, const char* title, bool record_samples);\n+  typedef v8::CpuProfilingMode ProfilingMode;\n+\n+  CpuProfile(CpuProfiler* profiler, const char* title, bool record_samples,\n+             ProfilingMode mode);\n \n   // Add pc -> ... -> main() call path to the profile.\n-  void AddPath(base::TimeTicks timestamp, const std::vector<CodeEntry*>& path,\n+  void AddPath(base::TimeTicks timestamp, const ProfileStackTrace& path,\n                int src_line, bool update_stats);\n   void FinishProfile();\n \n@@ -322,6 +347,7 @@ class CpuProfile {\n \n   const char* title_;\n   bool record_samples_;\n+  ProfilingMode mode_;\n   base::TimeTicks start_time_;\n   base::TimeTicks end_time_;\n   std::vector<ProfileNode*> samples_;\n@@ -344,15 +370,27 @@ class CodeMap {\n   void Print();\n \n  private:\n-  struct CodeEntryInfo {\n+  struct CodeEntryMapInfo {\n     unsigned index;\n     unsigned size;\n   };\n \n+  union CodeEntrySlotInfo {\n+    CodeEntry* entry;\n+    unsigned next_free_slot;\n+  };\n+\n+  static constexpr unsigned kNoFreeSlot = std::numeric_limits<unsigned>::max();\n+\n   void ClearCodesInRange(Address start, Address end);\n+  unsigned AddCodeEntry(Address start, CodeEntry*);\n+  void DeleteCodeEntry(unsigned index);\n \n-  std::deque<std::unique_ptr<CodeEntry>> code_entries_;\n-  std::map<Address, CodeEntryInfo> code_map_;\n+  CodeEntry* entry(unsigned index) { return code_entries_[index].entry; }\n+\n+  std::deque<CodeEntrySlotInfo> code_entries_;\n+  std::map<Address, CodeEntryMapInfo> code_map_;\n+  unsigned free_list_head_ = kNoFreeSlot;\n \n   DISALLOW_COPY_AND_ASSIGN(CodeMap);\n };\n@@ -361,8 +399,11 @@ class CpuProfilesCollection {\n  public:\n   explicit CpuProfilesCollection(Isolate* isolate);\n \n+  typedef v8::CpuProfilingMode ProfilingMode;\n+\n   void set_cpu_profiler(CpuProfiler* profiler) { profiler_ = profiler; }\n-  bool StartProfiling(const char* title, bool record_samples);\n+  bool StartProfiling(const char* title, bool record_samples,\n+                      ProfilingMode mode = ProfilingMode::kLeafNodeLineNumbers);\n   CpuProfile* StopProfiling(const char* title);\n   std::vector<std::unique_ptr<CpuProfile>>* profiles() {\n     return &finished_profiles_;\n@@ -373,8 +414,8 @@ class CpuProfilesCollection {\n \n   // Called from profile generator thread.\n   void AddPathToCurrentProfiles(base::TimeTicks timestamp,\n-                                const std::vector<CodeEntry*>& path,\n-                                int src_line, bool update_stats);\n+                                const ProfileStackTrace& path, int src_line,\n+                                bool update_stats);\n \n   // Limits the number of profiles that can be simultaneously collected.\n   static const int kMaxSimultaneousProfiles = 100;"
        },
        {
            "sha": "e3c2c140fb619f2ff2eda110b4d9bd22300d0bda",
            "filename": "deps/v8/src/profiler/profiler-listener.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 40,
            "changes": 88,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofiler-listener.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofiler-listener.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofiler-listener.cc?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -26,37 +26,37 @@ ProfilerListener::~ProfilerListener() = default;\n void ProfilerListener::CallbackEvent(Name* name, Address entry_point) {\n   CodeEventsContainer evt_rec(CodeEventRecord::CODE_CREATION);\n   CodeCreateEventRecord* rec = &evt_rec.CodeCreateEventRecord_;\n-  rec->start = entry_point;\n+  rec->instruction_start = entry_point;\n   rec->entry = NewCodeEntry(CodeEventListener::CALLBACK_TAG, GetName(name));\n-  rec->size = 1;\n+  rec->instruction_size = 1;\n   DispatchCodeEvent(evt_rec);\n }\n \n void ProfilerListener::CodeCreateEvent(CodeEventListener::LogEventsAndTags tag,\n                                        AbstractCode* code, const char* name) {\n   CodeEventsContainer evt_rec(CodeEventRecord::CODE_CREATION);\n   CodeCreateEventRecord* rec = &evt_rec.CodeCreateEventRecord_;\n-  rec->start = code->address();\n+  rec->instruction_start = code->InstructionStart();\n   rec->entry = NewCodeEntry(\n       tag, GetFunctionName(name), CodeEntry::kEmptyResourceName,\n       CpuProfileNode::kNoLineNumberInfo, CpuProfileNode::kNoColumnNumberInfo,\n       nullptr, code->InstructionStart());\n   RecordInliningInfo(rec->entry, code);\n-  rec->size = code->ExecutableSize();\n+  rec->instruction_size = code->InstructionSize();\n   DispatchCodeEvent(evt_rec);\n }\n \n void ProfilerListener::CodeCreateEvent(CodeEventListener::LogEventsAndTags tag,\n                                        AbstractCode* code, Name* name) {\n   CodeEventsContainer evt_rec(CodeEventRecord::CODE_CREATION);\n   CodeCreateEventRecord* rec = &evt_rec.CodeCreateEventRecord_;\n-  rec->start = code->address();\n+  rec->instruction_start = code->InstructionStart();\n   rec->entry = NewCodeEntry(\n       tag, GetFunctionName(name), CodeEntry::kEmptyResourceName,\n       CpuProfileNode::kNoLineNumberInfo, CpuProfileNode::kNoColumnNumberInfo,\n       nullptr, code->InstructionStart());\n   RecordInliningInfo(rec->entry, code);\n-  rec->size = code->ExecutableSize();\n+  rec->instruction_size = code->InstructionSize();\n   DispatchCodeEvent(evt_rec);\n }\n \n@@ -66,15 +66,15 @@ void ProfilerListener::CodeCreateEvent(CodeEventListener::LogEventsAndTags tag,\n                                        Name* script_name) {\n   CodeEventsContainer evt_rec(CodeEventRecord::CODE_CREATION);\n   CodeCreateEventRecord* rec = &evt_rec.CodeCreateEventRecord_;\n-  rec->start = code->address();\n+  rec->instruction_start = code->InstructionStart();\n   rec->entry = NewCodeEntry(tag, GetFunctionName(shared->DebugName()),\n                             GetName(InferScriptName(script_name, shared)),\n                             CpuProfileNode::kNoLineNumberInfo,\n                             CpuProfileNode::kNoColumnNumberInfo, nullptr,\n                             code->InstructionStart());\n   RecordInliningInfo(rec->entry, code);\n   rec->entry->FillFunctionInfo(shared);\n-  rec->size = code->ExecutableSize();\n+  rec->instruction_size = code->InstructionSize();\n   DispatchCodeEvent(evt_rec);\n }\n \n@@ -85,7 +85,7 @@ void ProfilerListener::CodeCreateEvent(CodeEventListener::LogEventsAndTags tag,\n                                        int column) {\n   CodeEventsContainer evt_rec(CodeEventRecord::CODE_CREATION);\n   CodeCreateEventRecord* rec = &evt_rec.CodeCreateEventRecord_;\n-  rec->start = abstract_code->address();\n+  rec->instruction_start = abstract_code->InstructionStart();\n   std::unique_ptr<SourcePositionTable> line_table;\n   if (shared->script()->IsScript()) {\n     Script* script = Script::cast(shared->script());\n@@ -106,9 +106,8 @@ void ProfilerListener::CodeCreateEvent(CodeEventListener::LogEventsAndTags tag,\n                    GetName(InferScriptName(script_name, shared)), line, column,\n                    std::move(line_table), abstract_code->InstructionStart());\n   RecordInliningInfo(rec->entry, abstract_code);\n-  RecordDeoptInlinedFrames(rec->entry, abstract_code);\n   rec->entry->FillFunctionInfo(shared);\n-  rec->size = abstract_code->ExecutableSize();\n+  rec->instruction_size = abstract_code->InstructionSize();\n   DispatchCodeEvent(evt_rec);\n }\n \n@@ -117,7 +116,7 @@ void ProfilerListener::CodeCreateEvent(CodeEventListener::LogEventsAndTags tag,\n                                        wasm::WasmName name) {\n   CodeEventsContainer evt_rec(CodeEventRecord::CODE_CREATION);\n   CodeCreateEventRecord* rec = &evt_rec.CodeCreateEventRecord_;\n-  rec->start = code->instruction_start();\n+  rec->instruction_start = code->instruction_start();\n   // TODO(herhut): Instead of sanitizing here, make sure all wasm functions\n   //               have names.\n   const char* name_ptr =\n@@ -126,23 +125,23 @@ void ProfilerListener::CodeCreateEvent(CodeEventListener::LogEventsAndTags tag,\n                             CpuProfileNode::kNoLineNumberInfo,\n                             CpuProfileNode::kNoColumnNumberInfo, nullptr,\n                             code->instruction_start());\n-  rec->size = code->instructions().length();\n+  rec->instruction_size = code->instructions().length();\n   DispatchCodeEvent(evt_rec);\n }\n \n-void ProfilerListener::CodeMoveEvent(AbstractCode* from, Address to) {\n+void ProfilerListener::CodeMoveEvent(AbstractCode* from, AbstractCode* to) {\n   CodeEventsContainer evt_rec(CodeEventRecord::CODE_MOVE);\n   CodeMoveEventRecord* rec = &evt_rec.CodeMoveEventRecord_;\n-  rec->from = from->address();\n-  rec->to = to;\n+  rec->from_instruction_start = from->InstructionStart();\n+  rec->to_instruction_start = to->InstructionStart();\n   DispatchCodeEvent(evt_rec);\n }\n \n void ProfilerListener::CodeDisableOptEvent(AbstractCode* code,\n                                            SharedFunctionInfo* shared) {\n   CodeEventsContainer evt_rec(CodeEventRecord::CODE_DISABLE_OPT);\n   CodeDisableOptEventRecord* rec = &evt_rec.CodeDisableOptEventRecord_;\n-  rec->start = code->address();\n+  rec->instruction_start = code->InstructionStart();\n   rec->bailout_reason = GetBailoutReason(shared->disable_optimization_reason());\n   DispatchCodeEvent(evt_rec);\n }\n@@ -152,45 +151,48 @@ void ProfilerListener::CodeDeoptEvent(Code* code, DeoptKind kind, Address pc,\n   CodeEventsContainer evt_rec(CodeEventRecord::CODE_DEOPT);\n   CodeDeoptEventRecord* rec = &evt_rec.CodeDeoptEventRecord_;\n   Deoptimizer::DeoptInfo info = Deoptimizer::GetDeoptInfo(code, pc);\n-  rec->start = code->address();\n+  rec->instruction_start = code->InstructionStart();\n   rec->deopt_reason = DeoptimizeReasonToString(info.deopt_reason);\n   rec->deopt_id = info.deopt_id;\n   rec->pc = pc;\n   rec->fp_to_sp_delta = fp_to_sp_delta;\n+\n+  // When a function is deoptimized, we store the deoptimized frame information\n+  // for the use of GetDeoptInfos().\n+  AttachDeoptInlinedFrames(code, rec);\n   DispatchCodeEvent(evt_rec);\n }\n \n void ProfilerListener::GetterCallbackEvent(Name* name, Address entry_point) {\n   CodeEventsContainer evt_rec(CodeEventRecord::CODE_CREATION);\n   CodeCreateEventRecord* rec = &evt_rec.CodeCreateEventRecord_;\n-  rec->start = entry_point;\n+  rec->instruction_start = entry_point;\n   rec->entry =\n       NewCodeEntry(CodeEventListener::CALLBACK_TAG, GetConsName(\"get \", name));\n-  rec->size = 1;\n+  rec->instruction_size = 1;\n   DispatchCodeEvent(evt_rec);\n }\n \n void ProfilerListener::RegExpCodeCreateEvent(AbstractCode* code,\n                                              String* source) {\n   CodeEventsContainer evt_rec(CodeEventRecord::CODE_CREATION);\n   CodeCreateEventRecord* rec = &evt_rec.CodeCreateEventRecord_;\n-  rec->start = code->address();\n+  rec->instruction_start = code->InstructionStart();\n   rec->entry = NewCodeEntry(\n       CodeEventListener::REG_EXP_TAG, GetConsName(\"RegExp: \", source),\n       CodeEntry::kEmptyResourceName, CpuProfileNode::kNoLineNumberInfo,\n-      CpuProfileNode::kNoColumnNumberInfo, nullptr,\n-      code->raw_instruction_start());\n-  rec->size = code->ExecutableSize();\n+      CpuProfileNode::kNoColumnNumberInfo, nullptr, code->InstructionStart());\n+  rec->instruction_size = code->InstructionSize();\n   DispatchCodeEvent(evt_rec);\n }\n \n void ProfilerListener::SetterCallbackEvent(Name* name, Address entry_point) {\n   CodeEventsContainer evt_rec(CodeEventRecord::CODE_CREATION);\n   CodeCreateEventRecord* rec = &evt_rec.CodeCreateEventRecord_;\n-  rec->start = entry_point;\n+  rec->instruction_start = entry_point;\n   rec->entry =\n       NewCodeEntry(CodeEventListener::CALLBACK_TAG, GetConsName(\"set \", name));\n-  rec->size = 1;\n+  rec->instruction_size = 1;\n   DispatchCodeEvent(evt_rec);\n }\n \n@@ -254,16 +256,18 @@ void ProfilerListener::RecordInliningInfo(CodeEntry* entry,\n   }\n }\n \n-void ProfilerListener::RecordDeoptInlinedFrames(CodeEntry* entry,\n-                                                AbstractCode* abstract_code) {\n-  if (abstract_code->kind() != AbstractCode::OPTIMIZED_FUNCTION) return;\n-  Handle<Code> code(abstract_code->GetCode());\n-\n+void ProfilerListener::AttachDeoptInlinedFrames(Code* code,\n+                                                CodeDeoptEventRecord* rec) {\n+  int deopt_id = rec->deopt_id;\n   SourcePosition last_position = SourcePosition::Unknown();\n   int mask = RelocInfo::ModeMask(RelocInfo::DEOPT_ID) |\n              RelocInfo::ModeMask(RelocInfo::DEOPT_SCRIPT_OFFSET) |\n              RelocInfo::ModeMask(RelocInfo::DEOPT_INLINING_ID);\n-  for (RelocIterator it(*code, mask); !it.done(); it.next()) {\n+\n+  rec->deopt_frames = nullptr;\n+  rec->deopt_frame_count = 0;\n+\n+  for (RelocIterator it(code, mask); !it.done(); it.next()) {\n     RelocInfo* info = it.rinfo();\n     if (info->rmode() == RelocInfo::DEOPT_SCRIPT_OFFSET) {\n       int script_offset = static_cast<int>(info->data());\n@@ -274,25 +278,29 @@ void ProfilerListener::RecordDeoptInlinedFrames(CodeEntry* entry,\n       continue;\n     }\n     if (info->rmode() == RelocInfo::DEOPT_ID) {\n-      int deopt_id = static_cast<int>(info->data());\n+      if (deopt_id != static_cast<int>(info->data())) continue;\n       DCHECK(last_position.IsKnown());\n-      std::vector<CpuProfileDeoptFrame> inlined_frames;\n \n       // SourcePosition::InliningStack allocates a handle for the SFI of each\n       // frame. These don't escape this function, but quickly add up. This\n       // scope limits their lifetime.\n       HandleScope scope(isolate_);\n-      for (SourcePositionInfo& pos_info : last_position.InliningStack(code)) {\n+      std::vector<SourcePositionInfo> stack =\n+          last_position.InliningStack(handle(code));\n+      CpuProfileDeoptFrame* deopt_frames =\n+          new CpuProfileDeoptFrame[stack.size()];\n+\n+      int deopt_frame_count = 0;\n+      for (SourcePositionInfo& pos_info : stack) {\n         if (pos_info.position.ScriptOffset() == kNoSourcePosition) continue;\n         if (pos_info.script.is_null()) continue;\n         int script_id = pos_info.script->id();\n         size_t offset = static_cast<size_t>(pos_info.position.ScriptOffset());\n-        inlined_frames.push_back(CpuProfileDeoptFrame({script_id, offset}));\n-      }\n-      if (!inlined_frames.empty() &&\n-          !entry->HasDeoptInlinedFramesFor(deopt_id)) {\n-        entry->AddDeoptInlinedFrames(deopt_id, std::move(inlined_frames));\n+        deopt_frames[deopt_frame_count++] = {script_id, offset};\n       }\n+      rec->deopt_frames = deopt_frames;\n+      rec->deopt_frame_count = deopt_frame_count;\n+      break;\n     }\n   }\n }"
        },
        {
            "sha": "313a6808c45e16702cf5a3adf787d6d37b3a26ce",
            "filename": "deps/v8/src/profiler/profiler-listener.h",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofiler-listener.h",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofiler-listener.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fprofiler%2Fprofiler-listener.h?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -15,6 +15,7 @@ namespace v8 {\n namespace internal {\n \n class CodeEventsContainer;\n+class CodeDeoptEventRecord;\n \n class CodeEventObserver {\n  public:\n@@ -43,7 +44,7 @@ class ProfilerListener : public CodeEventListener {\n                        wasm::WasmName name) override;\n \n   void CodeMovingGCEvent() override {}\n-  void CodeMoveEvent(AbstractCode* from, Address to) override;\n+  void CodeMoveEvent(AbstractCode* from, AbstractCode* to) override;\n   void CodeDisableOptEvent(AbstractCode* code,\n                            SharedFunctionInfo* shared) override;\n   void CodeDeoptEvent(Code* code, DeoptKind kind, Address pc,\n@@ -79,7 +80,7 @@ class ProfilerListener : public CodeEventListener {\n \n  private:\n   void RecordInliningInfo(CodeEntry* entry, AbstractCode* abstract_code);\n-  void RecordDeoptInlinedFrames(CodeEntry* entry, AbstractCode* abstract_code);\n+  void AttachDeoptInlinedFrames(Code* code, CodeDeoptEventRecord* rec);\n   Name* InferScriptName(Name* name, SharedFunctionInfo* info);\n   V8_INLINE void DispatchCodeEvent(const CodeEventsContainer& evt_rec) {\n     observer_->CodeEventHandler(evt_rec);"
        },
        {
            "sha": "f1061a6c2f621243b389ea7ae8db289531db3645",
            "filename": "deps/v8/src/snapshot/serializer.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fsnapshot%2Fserializer.h",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Fsrc%2Fsnapshot%2Fserializer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Fsrc%2Fsnapshot%2Fserializer.h?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -28,8 +28,8 @@ class CodeAddressMap : public CodeEventLogger {\n     isolate_->logger()->RemoveCodeEventListener(this);\n   }\n \n-  void CodeMoveEvent(AbstractCode* from, Address to) override {\n-    address_to_name_map_.Move(from->address(), to);\n+  void CodeMoveEvent(AbstractCode* from, AbstractCode* to) override {\n+    address_to_name_map_.Move(from->address(), to->address());\n   }\n \n   void CodeDisableOptEvent(AbstractCode* code,"
        },
        {
            "sha": "da069e0a26938653530477dcab2dcec6e0483df1",
            "filename": "deps/v8/test/cctest/cctest.status",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Ftest%2Fcctest%2Fcctest.status",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Ftest%2Fcctest%2Fcctest.status",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftest%2Fcctest%2Fcctest.status?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -75,6 +75,7 @@\n   # BUG(5193). The cpu profiler tests are notoriously flaky.\n   'test-profile-generator/RecordStackTraceAtStartProfiling': [SKIP],\n   'test-cpu-profiler/CollectCpuProfile': [SKIP],\n+  'test-cpu-profiler/CollectCpuProfileCallerLineNumbers': [FAIL, PASS],\n   'test-cpu-profiler/CollectCpuProfileSamples': [SKIP],\n   'test-cpu-profiler/CollectDeoptEvents': [SKIP],\n   'test-cpu-profiler/CpuProfileDeepStack': [SKIP],"
        },
        {
            "sha": "f74bdf1ede87f53b4f396bb85f0a792895f8a40a",
            "filename": "deps/v8/test/cctest/test-cpu-profiler.cc",
            "status": "modified",
            "additions": 85,
            "deletions": 13,
            "changes": 98,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Ftest%2Fcctest%2Ftest-cpu-profiler.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Ftest%2Fcctest%2Ftest-cpu-profiler.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftest%2Fcctest%2Ftest-cpu-profiler.cc?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -176,27 +176,29 @@ TEST(CodeEvents) {\n                                     \"comment\");\n   profiler_listener.CodeCreateEvent(i::Logger::BUILTIN_TAG, comment2_code,\n                                     \"comment2\");\n-  profiler_listener.CodeMoveEvent(comment2_code, moved_code->address());\n+  profiler_listener.CodeMoveEvent(comment2_code, moved_code);\n \n   // Enqueue a tick event to enable code events processing.\n-  EnqueueTickSampleEvent(processor, aaa_code->address());\n+  EnqueueTickSampleEvent(processor, aaa_code->InstructionStart());\n \n   isolate->logger()->RemoveCodeEventListener(&profiler_listener);\n   processor->StopSynchronously();\n \n   // Check the state of profile generator.\n-  CodeEntry* aaa = generator->code_map()->FindEntry(aaa_code->address());\n+  CodeEntry* aaa =\n+      generator->code_map()->FindEntry(aaa_code->InstructionStart());\n   CHECK(aaa);\n   CHECK_EQ(0, strcmp(aaa_str, aaa->name()));\n \n   CodeEntry* comment =\n-      generator->code_map()->FindEntry(comment_code->address());\n+      generator->code_map()->FindEntry(comment_code->InstructionStart());\n   CHECK(comment);\n   CHECK_EQ(0, strcmp(\"comment\", comment->name()));\n \n-  CHECK(!generator->code_map()->FindEntry(comment2_code->address()));\n+  CHECK(!generator->code_map()->FindEntry(comment2_code->InstructionStart()));\n \n-  CodeEntry* comment2 = generator->code_map()->FindEntry(moved_code->address());\n+  CodeEntry* comment2 =\n+      generator->code_map()->FindEntry(moved_code->InstructionStart());\n   CHECK(comment2);\n   CHECK_EQ(0, strcmp(\"comment2\", comment2->name()));\n }\n@@ -298,11 +300,11 @@ TEST(Issue1398) {\n   profiler_listener.CodeCreateEvent(i::Logger::BUILTIN_TAG, code, \"bbb\");\n \n   v8::TickSample* sample = processor->StartTickSample();\n-  sample->pc = reinterpret_cast<void*>(code->address());\n+  sample->pc = reinterpret_cast<void*>(code->InstructionStart());\n   sample->tos = nullptr;\n   sample->frames_count = v8::TickSample::kMaxFramesCount;\n   for (unsigned i = 0; i < sample->frames_count; ++i) {\n-    sample->stack[i] = reinterpret_cast<void*>(code->address());\n+    sample->stack[i] = reinterpret_cast<void*>(code->InstructionStart());\n   }\n   processor->FinishTickSample();\n \n@@ -428,11 +430,14 @@ class ProfilerHelper {\n     profiler_->Dispose();\n   }\n \n+  typedef v8::CpuProfilingMode ProfilingMode;\n+\n   v8::CpuProfile* Run(v8::Local<v8::Function> function,\n                       v8::Local<v8::Value> argv[], int argc,\n                       unsigned min_js_samples = 0,\n                       unsigned min_external_samples = 0,\n-                      bool collect_samples = false);\n+                      bool collect_samples = false,\n+                      ProfilingMode mode = ProfilingMode::kLeafNodeLineNumbers);\n \n   v8::CpuProfiler* profiler() { return profiler_; }\n \n@@ -445,11 +450,11 @@ v8::CpuProfile* ProfilerHelper::Run(v8::Local<v8::Function> function,\n                                     v8::Local<v8::Value> argv[], int argc,\n                                     unsigned min_js_samples,\n                                     unsigned min_external_samples,\n-                                    bool collect_samples) {\n+                                    bool collect_samples, ProfilingMode mode) {\n   v8::Local<v8::String> profile_name = v8_str(\"my_profile\");\n \n   profiler_->SetSamplingInterval(100);\n-  profiler_->StartProfiling(profile_name, collect_samples);\n+  profiler_->StartProfiling(profile_name, mode, collect_samples);\n \n   v8::internal::CpuProfiler* iprofiler =\n       reinterpret_cast<v8::internal::CpuProfiler*>(profiler_);\n@@ -509,7 +514,6 @@ static const v8::CpuProfileNode* GetChild(v8::Local<v8::Context> context,\n   return result;\n }\n \n-\n static void CheckSimpleBranch(v8::Local<v8::Context> context,\n                               const v8::CpuProfileNode* node,\n                               const char* names[], int length) {\n@@ -519,7 +523,6 @@ static void CheckSimpleBranch(v8::Local<v8::Context> context,\n   }\n }\n \n-\n static const ProfileNode* GetSimpleBranch(v8::Local<v8::Context> context,\n                                           v8::CpuProfile* profile,\n                                           const char* names[], int length) {\n@@ -530,6 +533,41 @@ static const ProfileNode* GetSimpleBranch(v8::Local<v8::Context> context,\n   return reinterpret_cast<const ProfileNode*>(node);\n }\n \n+struct NameLinePair {\n+  const char* name;\n+  int line_number;\n+};\n+\n+static const v8::CpuProfileNode* FindChild(const v8::CpuProfileNode* node,\n+                                           NameLinePair pair) {\n+  for (int i = 0, count = node->GetChildrenCount(); i < count; ++i) {\n+    const v8::CpuProfileNode* child = node->GetChild(i);\n+    // The name and line number must match, or if the requested line number was\n+    // -1, then match any function of the same name.\n+    if (strcmp(child->GetFunctionNameStr(), pair.name) == 0 &&\n+        (child->GetLineNumber() == pair.line_number ||\n+         pair.line_number == -1)) {\n+      return child;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+static const v8::CpuProfileNode* GetChild(const v8::CpuProfileNode* node,\n+                                          NameLinePair pair) {\n+  const v8::CpuProfileNode* result = FindChild(node, pair);\n+  if (!result) FATAL(\"Failed to GetChild: %s:%d\", pair.name, pair.line_number);\n+  return result;\n+}\n+\n+static void CheckBranch(const v8::CpuProfileNode* node, NameLinePair path[],\n+                        int length) {\n+  for (int i = 0; i < length; i++) {\n+    NameLinePair pair = path[i];\n+    node = GetChild(node, pair);\n+  }\n+}\n+\n static const char* cpu_profiler_test_source =\n     \"%NeverOptimizeFunction(loop);\\n\"\n     \"%NeverOptimizeFunction(delay);\\n\"\n@@ -610,6 +648,40 @@ TEST(CollectCpuProfile) {\n   profile->Delete();\n }\n \n+TEST(CollectCpuProfileCallerLineNumbers) {\n+  i::FLAG_allow_natives_syntax = true;\n+  LocalContext env;\n+  v8::HandleScope scope(env->GetIsolate());\n+\n+  CompileRun(cpu_profiler_test_source);\n+  v8::Local<v8::Function> function = GetFunction(env.local(), \"start\");\n+\n+  int32_t profiling_interval_ms = 200;\n+  v8::Local<v8::Value> args[] = {\n+      v8::Integer::New(env->GetIsolate(), profiling_interval_ms)};\n+  ProfilerHelper helper(env.local());\n+  helper.Run(function, args, arraysize(args), 1000, 0, false,\n+             v8::CpuProfilingMode::kCallerLineNumbers);\n+  v8::CpuProfile* profile =\n+      helper.Run(function, args, arraysize(args), 1000, 0, false,\n+                 v8::CpuProfilingMode::kCallerLineNumbers);\n+\n+  const v8::CpuProfileNode* root = profile->GetTopDownRoot();\n+  const v8::CpuProfileNode* start_node = GetChild(root, {\"start\", 27});\n+  const v8::CpuProfileNode* foo_node = GetChild(start_node, {\"foo\", 30});\n+\n+  NameLinePair bar_branch[] = {{\"bar\", 23}, {\"delay\", 19}, {\"loop\", 18}};\n+  CheckBranch(foo_node, bar_branch, arraysize(bar_branch));\n+  NameLinePair baz_branch[] = {{\"baz\", 25}, {\"delay\", 20}, {\"loop\", 18}};\n+  CheckBranch(foo_node, baz_branch, arraysize(baz_branch));\n+  NameLinePair delay_at22_branch[] = {{\"delay\", 22}, {\"loop\", 18}};\n+  CheckBranch(foo_node, delay_at22_branch, arraysize(delay_at22_branch));\n+  NameLinePair delay_at24_branch[] = {{\"delay\", 24}, {\"loop\", 18}};\n+  CheckBranch(foo_node, delay_at24_branch, arraysize(delay_at24_branch));\n+\n+  profile->Delete();\n+}\n+\n static const char* hot_deopt_no_frame_entry_test_source =\n     \"%NeverOptimizeFunction(foo);\\n\"\n     \"%NeverOptimizeFunction(start);\\n\""
        },
        {
            "sha": "b53bf148e615e45581a653438af77d9d3af93909",
            "filename": "deps/v8/test/cctest/test-profile-generator.cc",
            "status": "modified",
            "additions": 44,
            "deletions": 1,
            "changes": 45,
            "blob_url": "https://github.com/nodejs/node/blob/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Ftest%2Fcctest%2Ftest-profile-generator.cc",
            "raw_url": "https://github.com/nodejs/node/raw/8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8/deps%2Fv8%2Ftest%2Fcctest%2Ftest-profile-generator.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/deps%2Fv8%2Ftest%2Fcctest%2Ftest-profile-generator.cc?ref=8ac662eb4dddde40b0ecfe278ea7fb55b580e4a8",
            "patch": "@@ -64,6 +64,25 @@ TEST(ProfileNodeFindOrAddChild) {\n   CHECK_EQ(childNode3, node->FindOrAddChild(&entry3));\n }\n \n+TEST(ProfileNodeFindOrAddChildWithLineNumber) {\n+  CcTest::InitializeVM();\n+  ProfileTree tree(CcTest::i_isolate());\n+  ProfileNode* root = tree.root();\n+  CodeEntry a(i::CodeEventListener::FUNCTION_TAG, \"a\");\n+  ProfileNode* a_node = root->FindOrAddChild(&a, -1);\n+\n+  // a --(22)--> child1\n+  //   --(23)--> child1\n+\n+  CodeEntry child1(i::CodeEventListener::FUNCTION_TAG, \"child1\");\n+  ProfileNode* child1_node = a_node->FindOrAddChild(&child1, 22);\n+  CHECK(child1_node);\n+  CHECK_EQ(child1_node, a_node->FindOrAddChild(&child1, 22));\n+\n+  ProfileNode* child2_node = a_node->FindOrAddChild(&child1, 23);\n+  CHECK(child2_node);\n+  CHECK_NE(child1_node, child2_node);\n+}\n \n TEST(ProfileNodeFindOrAddChildForSameFunction) {\n   CcTest::InitializeVM();\n@@ -172,6 +191,29 @@ TEST(ProfileTreeAddPathFromEnd) {\n   CHECK_EQ(1u, node4->self_ticks());\n }\n \n+TEST(ProfileTreeAddPathFromEndWithLineNumbers) {\n+  CcTest::InitializeVM();\n+  CodeEntry a(i::CodeEventListener::FUNCTION_TAG, \"a\");\n+  CodeEntry b(i::CodeEventListener::FUNCTION_TAG, \"b\");\n+  CodeEntry c(i::CodeEventListener::FUNCTION_TAG, \"c\");\n+  ProfileTree tree(CcTest::i_isolate());\n+  ProfileTreeTestHelper helper(&tree);\n+\n+  ProfileStackTrace path = {{&c, 5}, {&b, 3}, {&a, 1}};\n+  tree.AddPathFromEnd(path, v8::CpuProfileNode::kNoLineNumberInfo, true,\n+                      v8::CpuProfilingMode::kCallerLineNumbers);\n+\n+  ProfileNode* a_node =\n+      tree.root()->FindChild(&a, v8::CpuProfileNode::kNoLineNumberInfo);\n+  tree.Print();\n+  CHECK(a_node);\n+\n+  ProfileNode* b_node = a_node->FindChild(&b, 1);\n+  CHECK(b_node);\n+\n+  ProfileNode* c_node = b_node->FindChild(&c, 3);\n+  CHECK(c_node);\n+}\n \n TEST(ProfileTreeCalculateTotalTicks) {\n   CcTest::InitializeVM();\n@@ -634,7 +676,8 @@ int GetFunctionLineNumber(CpuProfiler& profiler, LocalContext& env,\n   i::Handle<i::JSFunction> func = i::Handle<i::JSFunction>::cast(\n       v8::Utils::OpenHandle(*v8::Local<v8::Function>::Cast(\n           env->Global()->Get(env.local(), v8_str(name)).ToLocalChecked())));\n-  CodeEntry* func_entry = code_map->FindEntry(func->abstract_code()->address());\n+  CodeEntry* func_entry =\n+      code_map->FindEntry(func->abstract_code()->InstructionStart());\n   if (!func_entry) FATAL(\"%s\", name);\n   return func_entry->line_number();\n }"
        }
    ],
    "stats": {
        "total": 673,
        "additions": 469,
        "deletions": 204
    }
}