{
    "author": "addaleax",
    "message": "src: simplify AliasedBuffer lifetime management\n\nRely on the V8 garbage collector to take care of managing\nthe lifetime of the underlying memory of an `AliasedBuffer`.\n\nPR-URL: https://github.com/nodejs/node/pull/26196\nReviewed-By: Joyee Cheung <joyeec9h3@gmail.com>\nReviewed-By: Minwoo Jung <minwoo@nodesource.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "d1011f6bbfadfa254925014896aa710f02403770",
    "files": [
        {
            "sha": "498bab4d2323a3c5f029082c1131c9b1cc9267b7",
            "filename": "src/aliased_buffer.h",
            "status": "modified",
            "additions": 14,
            "deletions": 29,
            "changes": 43,
            "blob_url": "https://github.com/nodejs/node/blob/d1011f6bbfadfa254925014896aa710f02403770/src%2Faliased_buffer.h",
            "raw_url": "https://github.com/nodejs/node/raw/d1011f6bbfadfa254925014896aa710f02403770/src%2Faliased_buffer.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Faliased_buffer.h?ref=d1011f6bbfadfa254925014896aa710f02403770",
            "patch": "@@ -30,19 +30,17 @@ class AliasedBuffer {\n   AliasedBuffer(v8::Isolate* isolate, const size_t count)\n       : isolate_(isolate),\n         count_(count),\n-        byte_offset_(0),\n-        free_buffer_(true) {\n+        byte_offset_(0) {\n     CHECK_GT(count, 0);\n     const v8::HandleScope handle_scope(isolate_);\n \n-    const size_t size_in_bytes = sizeof(NativeT) * count;\n-\n-    // allocate native buffer\n-    buffer_ = Calloc<NativeT>(count);\n+    const size_t size_in_bytes =\n+        MultiplyWithOverflowCheck(sizeof(NativeT), count);\n \n     // allocate v8 ArrayBuffer\n     v8::Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(\n-        isolate_, buffer_, size_in_bytes);\n+        isolate_, size_in_bytes);\n+    buffer_ = static_cast<NativeT*>(ab->GetContents().Data());\n \n     // allocate v8 TypedArray\n     v8::Local<V8T> js_array = V8T::New(ab, byte_offset_, count);\n@@ -65,16 +63,16 @@ class AliasedBuffer {\n                 v8::Uint8Array>& backing_buffer)\n       : isolate_(isolate),\n         count_(count),\n-        byte_offset_(byte_offset),\n-        free_buffer_(false) {\n+        byte_offset_(byte_offset) {\n     const v8::HandleScope handle_scope(isolate_);\n \n     v8::Local<v8::ArrayBuffer> ab = backing_buffer.GetArrayBuffer();\n \n     // validate that the byte_offset is aligned with sizeof(NativeT)\n     CHECK_EQ(byte_offset & (sizeof(NativeT) - 1), 0);\n     // validate this fits inside the backing buffer\n-    CHECK_LE(sizeof(NativeT) * count,  ab->ByteLength() - byte_offset);\n+    CHECK_LE(MultiplyWithOverflowCheck(sizeof(NativeT), count),\n+             ab->ByteLength() - byte_offset);\n \n     buffer_ = reinterpret_cast<NativeT*>(\n         const_cast<uint8_t*>(backing_buffer.GetNativeBuffer() + byte_offset));\n@@ -87,25 +85,16 @@ class AliasedBuffer {\n       : isolate_(that.isolate_),\n         count_(that.count_),\n         byte_offset_(that.byte_offset_),\n-        buffer_(that.buffer_),\n-        free_buffer_(false) {\n+        buffer_(that.buffer_) {\n     js_array_ = v8::Global<V8T>(that.isolate_, that.GetJSArray());\n   }\n \n-  ~AliasedBuffer() {\n-    if (free_buffer_ && buffer_ != nullptr) {\n-      free(buffer_);\n-    }\n-    js_array_.Reset();\n-  }\n-\n   AliasedBuffer& operator=(AliasedBuffer&& that) noexcept {\n     this->~AliasedBuffer();\n     isolate_ = that.isolate_;\n     count_ = that.count_;\n     byte_offset_ = that.byte_offset_;\n     buffer_ = that.buffer_;\n-    free_buffer_ = that.free_buffer_;\n \n     js_array_.Reset(isolate_, that.js_array_.Get(isolate_));\n \n@@ -231,29 +220,26 @@ class AliasedBuffer {\n   void reserve(size_t new_capacity) {\n     DCHECK_GE(new_capacity, count_);\n     DCHECK_EQ(byte_offset_, 0);\n-    DCHECK(free_buffer_);\n     const v8::HandleScope handle_scope(isolate_);\n \n     const size_t old_size_in_bytes = sizeof(NativeT) * count_;\n     const size_t new_size_in_bytes = sizeof(NativeT) * new_capacity;\n \n+    // allocate v8 new ArrayBuffer\n+    v8::Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(\n+        isolate_, new_size_in_bytes);\n+\n     // allocate new native buffer\n-    NativeT* new_buffer = Calloc<NativeT>(new_capacity);\n+    NativeT* new_buffer = static_cast<NativeT*>(ab->GetContents().Data());\n     // copy old content\n     memcpy(new_buffer, buffer_, old_size_in_bytes);\n \n-    // allocate v8 new ArrayBuffer\n-    v8::Local<v8::ArrayBuffer> ab = v8::ArrayBuffer::New(\n-        isolate_, new_buffer, new_size_in_bytes);\n-\n     // allocate v8 TypedArray\n     v8::Local<V8T> js_array = V8T::New(ab, byte_offset_, new_capacity);\n \n     // move over old v8 TypedArray\n     js_array_ = std::move(v8::Global<V8T>(isolate_, js_array));\n \n-    // Free old buffer and set new values\n-    free(buffer_);\n     buffer_ = new_buffer;\n     count_ = new_capacity;\n   }\n@@ -264,7 +250,6 @@ class AliasedBuffer {\n   size_t byte_offset_;\n   NativeT* buffer_;\n   v8::Global<V8T> js_array_;\n-  bool free_buffer_;\n };\n }  // namespace node\n "
        }
    ],
    "stats": {
        "total": 43,
        "additions": 14,
        "deletions": 29
    }
}