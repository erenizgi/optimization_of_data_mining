{
    "author": "danbev",
    "message": "src: use smart pointers in cares_wrap.cc\n\nPR-URL: https://github.com/nodejs/node/pull/23813\nReviewed-By: Ben Noordhuis <info@bnoordhuis.nl>\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Anna Henningsen <anna@addaleax.net>\nReviewed-By: Refael Ackermann <refack@gmail.com>",
    "sha": "226a41a198af450d6b5d492150276b36b60d5930",
    "files": [
        {
            "sha": "4fcfa12ba8e09599d826527e37857e2999d00af8",
            "filename": "src/cares_wrap.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 18,
            "changes": 40,
            "blob_url": "https://github.com/nodejs/node/blob/226a41a198af450d6b5d492150276b36b60d5930/src%2Fcares_wrap.cc",
            "raw_url": "https://github.com/nodejs/node/raw/226a41a198af450d6b5d492150276b36b60d5930/src%2Fcares_wrap.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fcares_wrap.cc?ref=226a41a198af450d6b5d492150276b36b60d5930",
            "patch": "@@ -1796,22 +1796,25 @@ static void Query(const FunctionCallbackInfo<Value>& args) {\n \n   Local<Object> req_wrap_obj = args[0].As<Object>();\n   Local<String> string = args[1].As<String>();\n-  Wrap* wrap = new Wrap(channel, req_wrap_obj);\n+  auto wrap = std::make_unique<Wrap>(channel, req_wrap_obj);\n \n   node::Utf8Value name(env->isolate(), string);\n   channel->ModifyActivityQueryCount(1);\n   int err = wrap->Send(*name);\n   if (err) {\n     channel->ModifyActivityQueryCount(-1);\n-    delete wrap;\n+  } else {\n+    // Release ownership of the pointer allowing the ownership to be transferred\n+    USE(wrap.release());\n   }\n \n   args.GetReturnValue().Set(err);\n }\n \n \n void AfterGetAddrInfo(uv_getaddrinfo_t* req, int status, struct addrinfo* res) {\n-  GetAddrInfoReqWrap* req_wrap = static_cast<GetAddrInfoReqWrap*>(req->data);\n+  std::unique_ptr<GetAddrInfoReqWrap> req_wrap {\n+      static_cast<GetAddrInfoReqWrap*>(req->data)};\n   Environment* env = req_wrap->env();\n \n   HandleScope handle_scope(env->isolate());\n@@ -1868,21 +1871,20 @@ void AfterGetAddrInfo(uv_getaddrinfo_t* req, int status, struct addrinfo* res) {\n   uv_freeaddrinfo(res);\n \n   TRACE_EVENT_NESTABLE_ASYNC_END2(\n-      TRACING_CATEGORY_NODE2(dns, native), \"lookup\", req_wrap,\n+      TRACING_CATEGORY_NODE2(dns, native), \"lookup\", req_wrap.get(),\n       \"count\", n, \"verbatim\", verbatim);\n \n   // Make the callback into JavaScript\n   req_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);\n-\n-  delete req_wrap;\n }\n \n \n void AfterGetNameInfo(uv_getnameinfo_t* req,\n                       int status,\n                       const char* hostname,\n                       const char* service) {\n-  GetNameInfoReqWrap* req_wrap = static_cast<GetNameInfoReqWrap*>(req->data);\n+  std::unique_ptr<GetNameInfoReqWrap> req_wrap {\n+      static_cast<GetNameInfoReqWrap*>(req->data)};\n   Environment* env = req_wrap->env();\n \n   HandleScope handle_scope(env->isolate());\n@@ -1903,14 +1905,12 @@ void AfterGetNameInfo(uv_getnameinfo_t* req,\n   }\n \n   TRACE_EVENT_NESTABLE_ASYNC_END2(\n-      TRACING_CATEGORY_NODE2(dns, native), \"lookupService\", req_wrap,\n+      TRACING_CATEGORY_NODE2(dns, native), \"lookupService\", req_wrap.get(),\n       \"hostname\", TRACE_STR_COPY(hostname),\n       \"service\", TRACE_STR_COPY(service));\n \n   // Make the callback into JavaScript\n   req_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);\n-\n-  delete req_wrap;\n }\n \n using ParseIPResult = decltype(static_cast<ares_addr_port_node*>(0)->addr);\n@@ -1970,7 +1970,9 @@ void GetAddrInfo(const FunctionCallbackInfo<Value>& args) {\n       CHECK(0 && \"bad address family\");\n   }\n \n-  auto req_wrap = new GetAddrInfoReqWrap(env, req_wrap_obj, args[4]->IsTrue());\n+  auto req_wrap = std::make_unique<GetAddrInfoReqWrap>(env,\n+                                                       req_wrap_obj,\n+                                                       args[4]->IsTrue());\n \n   struct addrinfo hints;\n   memset(&hints, 0, sizeof(struct addrinfo));\n@@ -1979,7 +1981,7 @@ void GetAddrInfo(const FunctionCallbackInfo<Value>& args) {\n   hints.ai_flags = flags;\n \n   TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(\n-      TRACING_CATEGORY_NODE2(dns, native), \"lookup\", req_wrap,\n+      TRACING_CATEGORY_NODE2(dns, native), \"lookup\", req_wrap.get(),\n       \"hostname\", TRACE_STR_COPY(*hostname),\n       \"family\",\n       family == AF_INET ? \"ipv4\" : family == AF_INET6 ? \"ipv6\" : \"unspec\");\n@@ -1989,8 +1991,9 @@ void GetAddrInfo(const FunctionCallbackInfo<Value>& args) {\n                                *hostname,\n                                nullptr,\n                                &hints);\n-  if (err)\n-    delete req_wrap;\n+  if (err == 0)\n+    // Release ownership of the pointer allowing the ownership to be transferred\n+    USE(req_wrap.release());\n \n   args.GetReturnValue().Set(err);\n }\n@@ -2010,18 +2013,19 @@ void GetNameInfo(const FunctionCallbackInfo<Value>& args) {\n   CHECK(uv_ip4_addr(*ip, port, reinterpret_cast<sockaddr_in*>(&addr)) == 0 ||\n         uv_ip6_addr(*ip, port, reinterpret_cast<sockaddr_in6*>(&addr)) == 0);\n \n-  GetNameInfoReqWrap* req_wrap = new GetNameInfoReqWrap(env, req_wrap_obj);\n+  auto req_wrap = std::make_unique<GetNameInfoReqWrap>(env, req_wrap_obj);\n \n   TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(\n-      TRACING_CATEGORY_NODE2(dns, native), \"lookupService\", req_wrap,\n+      TRACING_CATEGORY_NODE2(dns, native), \"lookupService\", req_wrap.get(),\n       \"ip\", TRACE_STR_COPY(*ip), \"port\", port);\n \n   int err = req_wrap->Dispatch(uv_getnameinfo,\n                                AfterGetNameInfo,\n                                reinterpret_cast<struct sockaddr*>(&addr),\n                                NI_NAMEREQD);\n-  if (err)\n-    delete req_wrap;\n+  if (err == 0)\n+    // Release ownership of the pointer allowing the ownership to be transferred\n+    USE(req_wrap.release());\n \n   args.GetReturnValue().Set(err);\n }"
        }
    ],
    "stats": {
        "total": 40,
        "additions": 22,
        "deletions": 18
    }
}