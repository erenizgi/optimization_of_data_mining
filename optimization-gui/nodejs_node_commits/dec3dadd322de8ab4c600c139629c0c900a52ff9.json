{
    "author": "jkunkee",
    "message": "deps: backport ICU fix for ARM64 Windows\n\nICU 63 as ingested by Node.js does not quite support ARM64 Windows\nbecause its OBJ file IMAGE_FILE_MACHINE_TYPE field logic defaults to\nx86 instead of Unknown. This change backports the ICU 64.1 fix for\nthis.\n\nICU Issue: https://unicode-org.atlassian.net/browse/ICU-20382\nICU Commit: unicode-org/icu@11e538b\n\nPR-URL: https://github.com/nodejs/node/pull/26090\nReviewed-By: Steven R Loomis <srloomis@us.ibm.com>\nReviewed-By: Richard Lau <riclau@uk.ibm.com>\nReviewed-By: James M Snell <jasnell@gmail.com>",
    "sha": "dec3dadd322de8ab4c600c139629c0c900a52ff9",
    "files": [
        {
            "sha": "f23995bb2169f6df30026a5a845fe061b6f42b34",
            "filename": "tools/icu/patches/63/source/tools/toolutil/pkg_genc.cpp",
            "status": "added",
            "additions": 1221,
            "deletions": 0,
            "changes": 1221,
            "blob_url": "https://github.com/nodejs/node/blob/dec3dadd322de8ab4c600c139629c0c900a52ff9/tools%2Ficu%2Fpatches%2F63%2Fsource%2Ftools%2Ftoolutil%2Fpkg_genc.cpp",
            "raw_url": "https://github.com/nodejs/node/raw/dec3dadd322de8ab4c600c139629c0c900a52ff9/tools%2Ficu%2Fpatches%2F63%2Fsource%2Ftools%2Ftoolutil%2Fpkg_genc.cpp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/tools%2Ficu%2Fpatches%2F63%2Fsource%2Ftools%2Ftoolutil%2Fpkg_genc.cpp?ref=dec3dadd322de8ab4c600c139629c0c900a52ff9",
            "patch": "@@ -0,0 +1,1221 @@\n+// Â© 2016 and later: Unicode, Inc. and others.\n+// License & terms of use: http://www.unicode.org/copyright.html\n+/******************************************************************************\n+ *   Copyright (C) 2009-2016, International Business Machines\n+ *   Corporation and others.  All Rights Reserved.\n+ *******************************************************************************\n+ */\n+#include \"unicode/utypes.h\"\n+\n+#if U_PLATFORM_HAS_WIN32_API\n+#   define VC_EXTRALEAN\n+#   define WIN32_LEAN_AND_MEAN\n+#   define NOUSER\n+#   define NOSERVICE\n+#   define NOIME\n+#   define NOMCX\n+#include <windows.h>\n+#include <time.h>\n+#   ifdef __GNUC__\n+#       define WINDOWS_WITH_GNUC\n+#   endif\n+#endif\n+\n+#if U_PLATFORM_IS_LINUX_BASED && U_HAVE_ELF_H\n+#   define U_ELF\n+#endif\n+\n+#ifdef U_ELF\n+#   include <elf.h>\n+#   if defined(ELFCLASS64)\n+#       define U_ELF64\n+#   endif\n+    /* Old elf.h headers may not have EM_X86_64, or have EM_X8664 instead. */\n+#   ifndef EM_X86_64\n+#       define EM_X86_64 62\n+#   endif\n+#   define ICU_ENTRY_OFFSET 0\n+#endif\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"unicode/putil.h\"\n+#include \"cmemory.h\"\n+#include \"cstring.h\"\n+#include \"filestrm.h\"\n+#include \"toolutil.h\"\n+#include \"unicode/uclean.h\"\n+#include \"uoptions.h\"\n+#include \"pkg_genc.h\"\n+#include \"filetools.h\"\n+\n+#define MAX_COLUMN ((uint32_t)(0xFFFFFFFFU))\n+\n+#define HEX_0X 0 /*  0x1234 */\n+#define HEX_0H 1 /*  01234h */\n+\n+/* prototypes --------------------------------------------------------------- */\n+static void\n+getOutFilename(const char *inFilename, const char *destdir, char *outFilename, char *entryName, const char *newSuffix, const char *optFilename);\n+\n+static uint32_t\n+write8(FileStream *out, uint8_t byte, uint32_t column);\n+\n+static uint32_t\n+write32(FileStream *out, uint32_t byte, uint32_t column);\n+\n+#if U_PLATFORM == U_PF_OS400\n+static uint32_t\n+write8str(FileStream *out, uint8_t byte, uint32_t column);\n+#endif\n+/* -------------------------------------------------------------------------- */\n+\n+/*\n+Creating Template Files for New Platforms\n+\n+Let the cc compiler help you get started.\n+Compile this program\n+    const unsigned int x[5] = {1, 2, 0xdeadbeef, 0xffffffff, 16};\n+with the -S option to produce assembly output.\n+\n+For example, this will generate array.s:\n+gcc -S array.c\n+\n+This will produce a .s file that may look like this:\n+\n+    .file   \"array.c\"\n+    .version        \"01.01\"\n+gcc2_compiled.:\n+    .globl x\n+    .section        .rodata\n+    .align 4\n+    .type    x,@object\n+    .size    x,20\n+x:\n+    .long   1\n+    .long   2\n+    .long   -559038737\n+    .long   -1\n+    .long   16\n+    .ident  \"GCC: (GNU) 2.96 20000731 (Red Hat Linux 7.1 2.96-85)\"\n+\n+which gives a starting point that will compile, and can be transformed\n+to become the template, generally with some consulting of as docs and\n+some experimentation.\n+\n+If you want ICU to automatically use this assembly, you should\n+specify \"GENCCODE_ASSEMBLY=-a name\" in the specific config/mh-* file,\n+where the name is the compiler or platform that you used in this\n+assemblyHeader data structure.\n+*/\n+static const struct AssemblyType {\n+    const char *name;\n+    const char *header;\n+    const char *beginLine;\n+    const char *footer;\n+    int8_t      hexType; /* HEX_0X or HEX_0h */\n+} assemblyHeader[] = {\n+    /* For gcc assemblers, the meaning of .align changes depending on the */\n+    /* hardware, so we use .balign 16 which always means 16 bytes. */\n+    /* https://sourceware.org/binutils/docs/as/Pseudo-Ops.html */\n+    {\"gcc\",\n+        \".globl %s\\n\"\n+        \"\\t.section .note.GNU-stack,\\\"\\\",%%progbits\\n\"\n+        \"\\t.section .rodata\\n\"\n+        \"\\t.balign 16\\n\"\n+        \"#ifdef U_HIDE_DATA_SYMBOL\\n\"\n+        \"\\t.hidden %s\\n\"\n+        \"#endif\\n\"\n+        \"\\t.type %s,%%object\\n\"\n+        \"%s:\\n\\n\",\n+\n+        \".long \",\".size %s, .-%s\\n\",HEX_0X\n+    },\n+    {\"gcc-darwin\",\n+        /*\"\\t.section __TEXT,__text,regular,pure_instructions\\n\"\n+        \"\\t.section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32\\n\"*/\n+        \".globl _%s\\n\"\n+        \"#ifdef U_HIDE_DATA_SYMBOL\\n\"\n+        \"\\t.private_extern _%s\\n\"\n+        \"#endif\\n\"\n+        \"\\t.data\\n\"\n+        \"\\t.const\\n\"\n+        \"\\t.balign 16\\n\"\n+        \"_%s:\\n\\n\",\n+\n+        \".long \",\"\",HEX_0X\n+    },\n+    {\"gcc-cygwin\",\n+        \".globl _%s\\n\"\n+        \"\\t.section .rodata\\n\"\n+        \"\\t.balign 16\\n\"\n+        \"_%s:\\n\\n\",\n+\n+        \".long \",\"\",HEX_0X\n+    },\n+    {\"gcc-mingw64\",\n+        \".globl %s\\n\"\n+        \"\\t.section .rodata\\n\"\n+        \"\\t.balign 16\\n\"\n+        \"%s:\\n\\n\",\n+\n+        \".long \",\"\",HEX_0X\n+    },\n+/* 16 bytes alignment. */\n+/* http://docs.oracle.com/cd/E19641-01/802-1947/802-1947.pdf */\n+    {\"sun\",\n+        \"\\t.section \\\".rodata\\\"\\n\"\n+        \"\\t.align   16\\n\"\n+        \".globl     %s\\n\"\n+        \"%s:\\n\",\n+\n+        \".word \",\"\",HEX_0X\n+    },\n+/* 16 bytes alignment for sun-x86. */\n+/* http://docs.oracle.com/cd/E19963-01/html/821-1608/eoiyg.html */\n+    {\"sun-x86\",\n+        \"Drodata.rodata:\\n\"\n+        \"\\t.type   Drodata.rodata,@object\\n\"\n+        \"\\t.size   Drodata.rodata,0\\n\"\n+        \"\\t.globl  %s\\n\"\n+        \"\\t.align  16\\n\"\n+        \"%s:\\n\",\n+\n+        \".4byte \",\"\",HEX_0X\n+    },\n+/* 1<<4 bit alignment for aix. */\n+/* http://pic.dhe.ibm.com/infocenter/aix/v6r1/index.jsp?topic=%2Fcom.ibm.aix.aixassem%2Fdoc%2Falangref%2Fidalangref_csect_pseudoop.htm */\n+    {\"xlc\",\n+        \".globl %s{RO}\\n\"\n+        \"\\t.toc\\n\"\n+        \"%s:\\n\"\n+        \"\\t.csect %s{RO}, 4\\n\",\n+\n+        \".long \",\"\",HEX_0X\n+    },\n+    {\"aCC-ia64\",\n+        \"\\t.file   \\\"%s.s\\\"\\n\"\n+        \"\\t.type   %s,@object\\n\"\n+        \"\\t.global %s\\n\"\n+        \"\\t.secalias .abe$0.rodata, \\\".rodata\\\"\\n\"\n+        \"\\t.section .abe$0.rodata = \\\"a\\\", \\\"progbits\\\"\\n\"\n+        \"\\t.align  16\\n\"\n+        \"%s::\\t\",\n+\n+        \"data4 \",\"\",HEX_0X\n+    },\n+    {\"aCC-parisc\",\n+        \"\\t.SPACE  $TEXT$\\n\"\n+        \"\\t.SUBSPA $LIT$\\n\"\n+        \"%s\\n\"\n+        \"\\t.EXPORT %s\\n\"\n+        \"\\t.ALIGN  16\\n\",\n+\n+        \".WORD \",\"\",HEX_0X\n+    },\n+/* align 16 bytes */\n+/*  http://msdn.microsoft.com/en-us/library/dwa9fwef.aspx */\n+    { \"masm\",\n+      \"\\tTITLE %s\\n\"\n+      \"; generated by genccode\\n\"\n+      \".386\\n\"\n+      \".model flat\\n\"\n+      \"\\tPUBLIC _%s\\n\"\n+      \"ICUDATA_%s\\tSEGMENT READONLY PARA PUBLIC FLAT 'DATA'\\n\"\n+      \"\\tALIGN 16\\n\"\n+      \"_%s\\tLABEL DWORD\\n\",\n+      \"\\tDWORD \",\"\\nICUDATA_%s\\tENDS\\n\\tEND\\n\",HEX_0H\n+    }\n+};\n+\n+static int32_t assemblyHeaderIndex = -1;\n+static int32_t hexType = HEX_0X;\n+\n+U_CAPI UBool U_EXPORT2\n+checkAssemblyHeaderName(const char* optAssembly) {\n+    int32_t idx;\n+    assemblyHeaderIndex = -1;\n+    for (idx = 0; idx < UPRV_LENGTHOF(assemblyHeader); idx++) {\n+        if (uprv_strcmp(optAssembly, assemblyHeader[idx].name) == 0) {\n+            assemblyHeaderIndex = idx;\n+            hexType = assemblyHeader[idx].hexType; /* set the hex type */\n+            return TRUE;\n+        }\n+    }\n+\n+    return FALSE;\n+}\n+\n+\n+U_CAPI void U_EXPORT2\n+printAssemblyHeadersToStdErr(void) {\n+    int32_t idx;\n+    fprintf(stderr, \"%s\", assemblyHeader[0].name);\n+    for (idx = 1; idx < UPRV_LENGTHOF(assemblyHeader); idx++) {\n+        fprintf(stderr, \", %s\", assemblyHeader[idx].name);\n+    }\n+    fprintf(stderr,\n+        \")\\n\");\n+}\n+\n+U_CAPI void U_EXPORT2\n+writeAssemblyCode(const char *filename, const char *destdir, const char *optEntryPoint, const char *optFilename, char *outFilePath) {\n+    uint32_t column = MAX_COLUMN;\n+    char entry[64];\n+    uint32_t buffer[1024];\n+    char *bufferStr = (char *)buffer;\n+    FileStream *in, *out;\n+    size_t i, length;\n+\n+    in=T_FileStream_open(filename, \"rb\");\n+    if(in==NULL) {\n+        fprintf(stderr, \"genccode: unable to open input file %s\\n\", filename);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+\n+    getOutFilename(filename, destdir, bufferStr, entry, \".S\", optFilename);\n+    out=T_FileStream_open(bufferStr, \"w\");\n+    if(out==NULL) {\n+        fprintf(stderr, \"genccode: unable to open output file %s\\n\", bufferStr);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+\n+    if (outFilePath != NULL) {\n+        uprv_strcpy(outFilePath, bufferStr);\n+    }\n+\n+#if defined (WINDOWS_WITH_GNUC) && U_PLATFORM != U_PF_CYGWIN\n+    /* Need to fix the file separator character when using MinGW. */\n+    swapFileSepChar(outFilePath, U_FILE_SEP_CHAR, '/');\n+#endif\n+\n+    if(optEntryPoint != NULL) {\n+        uprv_strcpy(entry, optEntryPoint);\n+        uprv_strcat(entry, \"_dat\");\n+    }\n+\n+    /* turn dashes or dots in the entry name into underscores */\n+    length=uprv_strlen(entry);\n+    for(i=0; i<length; ++i) {\n+        if(entry[i]=='-' || entry[i]=='.') {\n+            entry[i]='_';\n+        }\n+    }\n+\n+    sprintf(bufferStr, assemblyHeader[assemblyHeaderIndex].header,\n+        entry, entry, entry, entry,\n+        entry, entry, entry, entry);\n+    T_FileStream_writeLine(out, bufferStr);\n+    T_FileStream_writeLine(out, assemblyHeader[assemblyHeaderIndex].beginLine);\n+\n+    for(;;) {\n+        length=T_FileStream_read(in, buffer, sizeof(buffer));\n+        if(length==0) {\n+            break;\n+        }\n+        if (length != sizeof(buffer)) {\n+            /* pad with extra 0's when at the end of the file */\n+            for(i=0; i < (length % sizeof(uint32_t)); ++i) {\n+                buffer[length+i] = 0;\n+            }\n+        }\n+        for(i=0; i<(length/sizeof(buffer[0])); i++) {\n+            column = write32(out, buffer[i], column);\n+        }\n+    }\n+\n+    T_FileStream_writeLine(out, \"\\n\");\n+\n+    sprintf(bufferStr, assemblyHeader[assemblyHeaderIndex].footer,\n+        entry, entry, entry, entry,\n+        entry, entry, entry, entry);\n+    T_FileStream_writeLine(out, bufferStr);\n+\n+    if(T_FileStream_error(in)) {\n+        fprintf(stderr, \"genccode: file read error while generating from file %s\\n\", filename);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+\n+    if(T_FileStream_error(out)) {\n+        fprintf(stderr, \"genccode: file write error while generating from file %s\\n\", filename);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+\n+    T_FileStream_close(out);\n+    T_FileStream_close(in);\n+}\n+\n+U_CAPI void U_EXPORT2\n+writeCCode(const char *filename, const char *destdir, const char *optName, const char *optFilename, char *outFilePath) {\n+    uint32_t column = MAX_COLUMN;\n+    char buffer[4096], entry[64];\n+    FileStream *in, *out;\n+    size_t i, length;\n+\n+    in=T_FileStream_open(filename, \"rb\");\n+    if(in==NULL) {\n+        fprintf(stderr, \"genccode: unable to open input file %s\\n\", filename);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+\n+    if(optName != NULL) { /* prepend  'icudt28_' */\n+      strcpy(entry, optName);\n+      strcat(entry, \"_\");\n+    } else {\n+      entry[0] = 0;\n+    }\n+\n+    getOutFilename(filename, destdir, buffer, entry+uprv_strlen(entry), \".c\", optFilename);\n+    if (outFilePath != NULL) {\n+        uprv_strcpy(outFilePath, buffer);\n+    }\n+    out=T_FileStream_open(buffer, \"w\");\n+    if(out==NULL) {\n+        fprintf(stderr, \"genccode: unable to open output file %s\\n\", buffer);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+\n+    /* turn dashes or dots in the entry name into underscores */\n+    length=uprv_strlen(entry);\n+    for(i=0; i<length; ++i) {\n+        if(entry[i]=='-' || entry[i]=='.') {\n+            entry[i]='_';\n+        }\n+    }\n+\n+#if U_PLATFORM == U_PF_OS400\n+    /*\n+    TODO: Fix this once the compiler implements this feature. Keep in sync with udatamem.c\n+\n+    This is here because this platform can't currently put\n+    const data into the read-only pages of an object or\n+    shared library (service program). Only strings are allowed in read-only\n+    pages, so we use char * strings to store the data.\n+\n+    In order to prevent the beginning of the data from ever matching the\n+    magic numbers we must still use the initial double.\n+    [grhoten 4/24/2003]\n+    */\n+    sprintf(buffer,\n+        \"#ifndef IN_GENERATED_CCODE\\n\"\n+        \"#define IN_GENERATED_CCODE\\n\"\n+        \"#define U_DISABLE_RENAMING 1\\n\"\n+        \"#include \\\"unicode/umachine.h\\\"\\n\"\n+        \"#endif\\n\"\n+        \"U_CDECL_BEGIN\\n\"\n+        \"const struct {\\n\"\n+        \"    double bogus;\\n\"\n+        \"    const char *bytes; \\n\"\n+        \"} %s={ 0.0, \\n\",\n+        entry);\n+    T_FileStream_writeLine(out, buffer);\n+\n+    for(;;) {\n+        length=T_FileStream_read(in, buffer, sizeof(buffer));\n+        if(length==0) {\n+            break;\n+        }\n+        for(i=0; i<length; ++i) {\n+            column = write8str(out, (uint8_t)buffer[i], column);\n+        }\n+    }\n+\n+    T_FileStream_writeLine(out, \"\\\"\\n};\\nU_CDECL_END\\n\");\n+#else\n+    /* Function renaming shouldn't be done in data */\n+    sprintf(buffer,\n+        \"#ifndef IN_GENERATED_CCODE\\n\"\n+        \"#define IN_GENERATED_CCODE\\n\"\n+        \"#define U_DISABLE_RENAMING 1\\n\"\n+        \"#include \\\"unicode/umachine.h\\\"\\n\"\n+        \"#endif\\n\"\n+        \"U_CDECL_BEGIN\\n\"\n+        \"const struct {\\n\"\n+        \"    double bogus;\\n\"\n+        \"    uint8_t bytes[%ld]; \\n\"\n+        \"} %s={ 0.0, {\\n\",\n+        (long)T_FileStream_size(in), entry);\n+    T_FileStream_writeLine(out, buffer);\n+\n+    for(;;) {\n+        length=T_FileStream_read(in, buffer, sizeof(buffer));\n+        if(length==0) {\n+            break;\n+        }\n+        for(i=0; i<length; ++i) {\n+            column = write8(out, (uint8_t)buffer[i], column);\n+        }\n+    }\n+\n+    T_FileStream_writeLine(out, \"\\n}\\n};\\nU_CDECL_END\\n\");\n+#endif\n+\n+    if(T_FileStream_error(in)) {\n+        fprintf(stderr, \"genccode: file read error while generating from file %s\\n\", filename);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+\n+    if(T_FileStream_error(out)) {\n+        fprintf(stderr, \"genccode: file write error while generating from file %s\\n\", filename);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+\n+    T_FileStream_close(out);\n+    T_FileStream_close(in);\n+}\n+\n+static uint32_t\n+write32(FileStream *out, uint32_t bitField, uint32_t column) {\n+    int32_t i;\n+    char bitFieldStr[64]; /* This is more bits than needed for a 32-bit number */\n+    char *s = bitFieldStr;\n+    uint8_t *ptrIdx = (uint8_t *)&bitField;\n+    static const char hexToStr[16] = {\n+        '0','1','2','3',\n+        '4','5','6','7',\n+        '8','9','A','B',\n+        'C','D','E','F'\n+    };\n+\n+    /* write the value, possibly with comma and newline */\n+    if(column==MAX_COLUMN) {\n+        /* first byte */\n+        column=1;\n+    } else if(column<32) {\n+        *(s++)=',';\n+        ++column;\n+    } else {\n+        *(s++)='\\n';\n+        uprv_strcpy(s, assemblyHeader[assemblyHeaderIndex].beginLine);\n+        s+=uprv_strlen(s);\n+        column=1;\n+    }\n+\n+    if (bitField < 10) {\n+        /* It's a small number. Don't waste the space for 0x */\n+        *(s++)=hexToStr[bitField];\n+    }\n+    else {\n+        int seenNonZero = 0; /* This is used to remove leading zeros */\n+\n+        if(hexType==HEX_0X) {\n+         *(s++)='0';\n+         *(s++)='x';\n+        } else if(hexType==HEX_0H) {\n+         *(s++)='0';\n+        }\n+\n+        /* This creates a 32-bit field */\n+#if U_IS_BIG_ENDIAN\n+        for (i = 0; i < sizeof(uint32_t); i++)\n+#else\n+        for (i = sizeof(uint32_t)-1; i >= 0 ; i--)\n+#endif\n+        {\n+            uint8_t value = ptrIdx[i];\n+            if (value || seenNonZero) {\n+                *(s++)=hexToStr[value>>4];\n+                *(s++)=hexToStr[value&0xF];\n+                seenNonZero = 1;\n+            }\n+        }\n+        if(hexType==HEX_0H) {\n+         *(s++)='h';\n+        }\n+    }\n+\n+    *(s++)=0;\n+    T_FileStream_writeLine(out, bitFieldStr);\n+    return column;\n+}\n+\n+static uint32_t\n+write8(FileStream *out, uint8_t byte, uint32_t column) {\n+    char s[4];\n+    int i=0;\n+\n+    /* convert the byte value to a string */\n+    if(byte>=100) {\n+        s[i++]=(char)('0'+byte/100);\n+        byte%=100;\n+    }\n+    if(i>0 || byte>=10) {\n+        s[i++]=(char)('0'+byte/10);\n+        byte%=10;\n+    }\n+    s[i++]=(char)('0'+byte);\n+    s[i]=0;\n+\n+    /* write the value, possibly with comma and newline */\n+    if(column==MAX_COLUMN) {\n+        /* first byte */\n+        column=1;\n+    } else if(column<16) {\n+        T_FileStream_writeLine(out, \",\");\n+        ++column;\n+    } else {\n+        T_FileStream_writeLine(out, \",\\n\");\n+        column=1;\n+    }\n+    T_FileStream_writeLine(out, s);\n+    return column;\n+}\n+\n+#if U_PLATFORM == U_PF_OS400\n+static uint32_t\n+write8str(FileStream *out, uint8_t byte, uint32_t column) {\n+    char s[8];\n+\n+    if (byte > 7)\n+        sprintf(s, \"\\\\x%X\", byte);\n+    else\n+        sprintf(s, \"\\\\%X\", byte);\n+\n+    /* write the value, possibly with comma and newline */\n+    if(column==MAX_COLUMN) {\n+        /* first byte */\n+        column=1;\n+        T_FileStream_writeLine(out, \"\\\"\");\n+    } else if(column<24) {\n+        ++column;\n+    } else {\n+        T_FileStream_writeLine(out, \"\\\"\\n\\\"\");\n+        column=1;\n+    }\n+    T_FileStream_writeLine(out, s);\n+    return column;\n+}\n+#endif\n+\n+static void\n+getOutFilename(const char *inFilename, const char *destdir, char *outFilename, char *entryName, const char *newSuffix, const char *optFilename) {\n+    const char *basename=findBasename(inFilename), *suffix=uprv_strrchr(basename, '.');\n+\n+    /* copy path */\n+    if(destdir!=NULL && *destdir!=0) {\n+        do {\n+            *outFilename++=*destdir++;\n+        } while(*destdir!=0);\n+        if(*(outFilename-1)!=U_FILE_SEP_CHAR) {\n+            *outFilename++=U_FILE_SEP_CHAR;\n+        }\n+        inFilename=basename;\n+    } else {\n+        while(inFilename<basename) {\n+            *outFilename++=*inFilename++;\n+        }\n+    }\n+\n+    if(suffix==NULL) {\n+        /* the filename does not have a suffix */\n+        uprv_strcpy(entryName, inFilename);\n+        if(optFilename != NULL) {\n+          uprv_strcpy(outFilename, optFilename);\n+        } else {\n+          uprv_strcpy(outFilename, inFilename);\n+        }\n+        uprv_strcat(outFilename, newSuffix);\n+    } else {\n+        char *saveOutFilename = outFilename;\n+        /* copy basename */\n+        while(inFilename<suffix) {\n+            if(*inFilename=='-') {\n+                /* iSeries cannot have '-' in the .o objects. */\n+                *outFilename++=*entryName++='_';\n+                inFilename++;\n+            }\n+            else {\n+                *outFilename++=*entryName++=*inFilename++;\n+            }\n+        }\n+\n+        /* replace '.' by '_' */\n+        *outFilename++=*entryName++='_';\n+        ++inFilename;\n+\n+        /* copy suffix */\n+        while(*inFilename!=0) {\n+            *outFilename++=*entryName++=*inFilename++;\n+        }\n+\n+        *entryName=0;\n+\n+        if(optFilename != NULL) {\n+            uprv_strcpy(saveOutFilename, optFilename);\n+            uprv_strcat(saveOutFilename, newSuffix);\n+        } else {\n+            /* add \".c\" */\n+            uprv_strcpy(outFilename, newSuffix);\n+        }\n+    }\n+}\n+\n+#ifdef CAN_GENERATE_OBJECTS\n+static void\n+getArchitecture(uint16_t *pCPU, uint16_t *pBits, UBool *pIsBigEndian, const char *optMatchArch) {\n+    union {\n+        char        bytes[2048];\n+#ifdef U_ELF\n+        Elf32_Ehdr  header32;\n+        /* Elf32_Ehdr and ELF64_Ehdr are identical for the necessary fields. */\n+#elif U_PLATFORM_HAS_WIN32_API\n+        IMAGE_FILE_HEADER header;\n+#endif\n+    } buffer;\n+\n+    const char *filename;\n+    FileStream *in;\n+    int32_t length;\n+\n+#ifdef U_ELF\n+\n+#elif U_PLATFORM_HAS_WIN32_API\n+    const IMAGE_FILE_HEADER *pHeader;\n+#else\n+#   error \"Unknown platform for CAN_GENERATE_OBJECTS.\"\n+#endif\n+\n+    if(optMatchArch != NULL) {\n+        filename=optMatchArch;\n+    } else {\n+        /* set defaults */\n+#ifdef U_ELF\n+        /* set EM_386 because elf.h does not provide better defaults */\n+        *pCPU=EM_386;\n+        *pBits=32;\n+        *pIsBigEndian=(UBool)(U_IS_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB);\n+#elif U_PLATFORM_HAS_WIN32_API\n+        // Windows always runs in little-endian mode.\n+        *pIsBigEndian = FALSE;\n+\n+        // Note: The various _M_<arch> macros are predefined by the MSVC compiler based\n+        // on the target compilation architecture.\n+        // https://docs.microsoft.com/cpp/preprocessor/predefined-macros\n+\n+        // link.exe will link an IMAGE_FILE_MACHINE_UNKNOWN data-only .obj file\n+        // no matter what architecture it is targeting (though other values are\n+        // required to match). Unfortunately, the variable name decoration/mangling\n+        // is slightly different on x86, which means we can't use the UNKNOWN type\n+        // for all architectures though.\n+#   if defined(_M_IX86)\n+        *pCPU = IMAGE_FILE_MACHINE_I386;\n+#   else\n+        *pCPU = IMAGE_FILE_MACHINE_UNKNOWN;\n+#   endif\n+#   if defined(_M_IA64) || defined(_M_AMD64) || defined (_M_ARM64)\n+        *pBits = 64; // Doesn't seem to be used for anything interesting though?\n+#   elif defined(_M_IX86) || defined(_M_ARM)\n+        *pBits = 32;\n+#   else\n+#      error \"Unknown platform for CAN_GENERATE_OBJECTS.\"\n+#   endif\n+#else\n+#   error \"Unknown platform for CAN_GENERATE_OBJECTS.\"\n+#endif\n+        return;\n+    }\n+\n+    in=T_FileStream_open(filename, \"rb\");\n+    if(in==NULL) {\n+        fprintf(stderr, \"genccode: unable to open match-arch file %s\\n\", filename);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+    length=T_FileStream_read(in, buffer.bytes, sizeof(buffer.bytes));\n+\n+#ifdef U_ELF\n+    if(length<(int32_t)sizeof(Elf32_Ehdr)) {\n+        fprintf(stderr, \"genccode: match-arch file %s is too short\\n\", filename);\n+        exit(U_UNSUPPORTED_ERROR);\n+    }\n+    if(\n+        buffer.header32.e_ident[0]!=ELFMAG0 ||\n+        buffer.header32.e_ident[1]!=ELFMAG1 ||\n+        buffer.header32.e_ident[2]!=ELFMAG2 ||\n+        buffer.header32.e_ident[3]!=ELFMAG3 ||\n+        buffer.header32.e_ident[EI_CLASS]<ELFCLASS32 || buffer.header32.e_ident[EI_CLASS]>ELFCLASS64\n+    ) {\n+        fprintf(stderr, \"genccode: match-arch file %s is not an ELF object file, or not supported\\n\", filename);\n+        exit(U_UNSUPPORTED_ERROR);\n+    }\n+\n+    *pBits= buffer.header32.e_ident[EI_CLASS]==ELFCLASS32 ? 32 : 64; /* only 32 or 64: see check above */\n+#ifdef U_ELF64\n+    if(*pBits!=32 && *pBits!=64) {\n+        fprintf(stderr, \"genccode: currently only supports 32-bit and 64-bit ELF format\\n\");\n+        exit(U_UNSUPPORTED_ERROR);\n+    }\n+#else\n+    if(*pBits!=32) {\n+        fprintf(stderr, \"genccode: built with elf.h missing 64-bit definitions\\n\");\n+        exit(U_UNSUPPORTED_ERROR);\n+    }\n+#endif\n+\n+    *pIsBigEndian=(UBool)(buffer.header32.e_ident[EI_DATA]==ELFDATA2MSB);\n+    if(*pIsBigEndian!=U_IS_BIG_ENDIAN) {\n+        fprintf(stderr, \"genccode: currently only same-endianness ELF formats are supported\\n\");\n+        exit(U_UNSUPPORTED_ERROR);\n+    }\n+    /* TODO: Support byte swapping */\n+\n+    *pCPU=buffer.header32.e_machine;\n+#elif U_PLATFORM_HAS_WIN32_API\n+    if(length<sizeof(IMAGE_FILE_HEADER)) {\n+        fprintf(stderr, \"genccode: match-arch file %s is too short\\n\", filename);\n+        exit(U_UNSUPPORTED_ERROR);\n+    }\n+    /* TODO: Use buffer.header.  Keep aliasing legal.  */\n+    pHeader=(const IMAGE_FILE_HEADER *)buffer.bytes;\n+    *pCPU=pHeader->Machine;\n+    /*\n+     * The number of bits is implicit with the Machine value.\n+     * *pBits is ignored in the calling code, so this need not be precise.\n+     */\n+    *pBits= *pCPU==IMAGE_FILE_MACHINE_I386 ? 32 : 64;\n+    /* Windows always runs on little-endian CPUs. */\n+    *pIsBigEndian=FALSE;\n+#else\n+#   error \"Unknown platform for CAN_GENERATE_OBJECTS.\"\n+#endif\n+\n+    T_FileStream_close(in);\n+}\n+\n+U_CAPI void U_EXPORT2\n+writeObjectCode(const char *filename, const char *destdir, const char *optEntryPoint, const char *optMatchArch, const char *optFilename, char *outFilePath) {\n+    /* common variables */\n+    char buffer[4096], entry[96]={ 0 };\n+    FileStream *in, *out;\n+    const char *newSuffix;\n+    int32_t i, entryLength, length, size, entryOffset=0, entryLengthOffset=0;\n+\n+    uint16_t cpu, bits;\n+    UBool makeBigEndian;\n+\n+    /* platform-specific variables and initialization code */\n+#ifdef U_ELF\n+    /* 32-bit Elf file header */\n+    static Elf32_Ehdr header32={\n+        {\n+            /* e_ident[] */\n+            ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3,\n+            ELFCLASS32,\n+            U_IS_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB,\n+            EV_CURRENT /* EI_VERSION */\n+        },\n+        ET_REL,\n+        EM_386,\n+        EV_CURRENT, /* e_version */\n+        0, /* e_entry */\n+        0, /* e_phoff */\n+        (Elf32_Off)sizeof(Elf32_Ehdr), /* e_shoff */\n+        0, /* e_flags */\n+        (Elf32_Half)sizeof(Elf32_Ehdr), /* eh_size */\n+        0, /* e_phentsize */\n+        0, /* e_phnum */\n+        (Elf32_Half)sizeof(Elf32_Shdr), /* e_shentsize */\n+        5, /* e_shnum */\n+        2 /* e_shstrndx */\n+    };\n+\n+    /* 32-bit Elf section header table */\n+    static Elf32_Shdr sectionHeaders32[5]={\n+        { /* SHN_UNDEF */\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+        },\n+        { /* .symtab */\n+            1, /* sh_name */\n+            SHT_SYMTAB,\n+            0, /* sh_flags */\n+            0, /* sh_addr */\n+            (Elf32_Off)(sizeof(header32)+sizeof(sectionHeaders32)), /* sh_offset */\n+            (Elf32_Word)(2*sizeof(Elf32_Sym)), /* sh_size */\n+            3, /* sh_link=sect hdr index of .strtab */\n+            1, /* sh_info=One greater than the symbol table index of the last\n+                * local symbol (with STB_LOCAL). */\n+            4, /* sh_addralign */\n+            (Elf32_Word)(sizeof(Elf32_Sym)) /* sh_entsize */\n+        },\n+        { /* .shstrtab */\n+            9, /* sh_name */\n+            SHT_STRTAB,\n+            0, /* sh_flags */\n+            0, /* sh_addr */\n+            (Elf32_Off)(sizeof(header32)+sizeof(sectionHeaders32)+2*sizeof(Elf32_Sym)), /* sh_offset */\n+            40, /* sh_size */\n+            0, /* sh_link */\n+            0, /* sh_info */\n+            1, /* sh_addralign */\n+            0 /* sh_entsize */\n+        },\n+        { /* .strtab */\n+            19, /* sh_name */\n+            SHT_STRTAB,\n+            0, /* sh_flags */\n+            0, /* sh_addr */\n+            (Elf32_Off)(sizeof(header32)+sizeof(sectionHeaders32)+2*sizeof(Elf32_Sym)+40), /* sh_offset */\n+            (Elf32_Word)sizeof(entry), /* sh_size */\n+            0, /* sh_link */\n+            0, /* sh_info */\n+            1, /* sh_addralign */\n+            0 /* sh_entsize */\n+        },\n+        { /* .rodata */\n+            27, /* sh_name */\n+            SHT_PROGBITS,\n+            SHF_ALLOC, /* sh_flags */\n+            0, /* sh_addr */\n+            (Elf32_Off)(sizeof(header32)+sizeof(sectionHeaders32)+2*sizeof(Elf32_Sym)+40+sizeof(entry)), /* sh_offset */\n+            0, /* sh_size */\n+            0, /* sh_link */\n+            0, /* sh_info */\n+            16, /* sh_addralign */\n+            0 /* sh_entsize */\n+        }\n+    };\n+\n+    /* symbol table */\n+    static Elf32_Sym symbols32[2]={\n+        { /* STN_UNDEF */\n+            0, 0, 0, 0, 0, 0\n+        },\n+        { /* data entry point */\n+            1, /* st_name */\n+            0, /* st_value */\n+            0, /* st_size */\n+            ELF64_ST_INFO(STB_GLOBAL, STT_OBJECT),\n+            0, /* st_other */\n+            4 /* st_shndx=index of related section table entry */\n+        }\n+    };\n+\n+    /* section header string table, with decimal string offsets */\n+    static const char sectionStrings[40]=\n+        /*  0 */ \"\\0\"\n+        /*  1 */ \".symtab\\0\"\n+        /*  9 */ \".shstrtab\\0\"\n+        /* 19 */ \".strtab\\0\"\n+        /* 27 */ \".rodata\\0\"\n+        /* 35 */ \"\\0\\0\\0\\0\"; /* contains terminating NUL */\n+        /* 40: padded to multiple of 8 bytes */\n+\n+    /*\n+     * Use entry[] for the string table which will contain only the\n+     * entry point name.\n+     * entry[0] must be 0 (NUL)\n+     * The entry point name can be up to 38 characters long (sizeof(entry)-2).\n+     */\n+\n+    /* 16-align .rodata in the .o file, just in case */\n+    static const char padding[16]={ 0 };\n+    int32_t paddingSize;\n+\n+#ifdef U_ELF64\n+    /* 64-bit Elf file header */\n+    static Elf64_Ehdr header64={\n+        {\n+            /* e_ident[] */\n+            ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3,\n+            ELFCLASS64,\n+            U_IS_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB,\n+            EV_CURRENT /* EI_VERSION */\n+        },\n+        ET_REL,\n+        EM_X86_64,\n+        EV_CURRENT, /* e_version */\n+        0, /* e_entry */\n+        0, /* e_phoff */\n+        (Elf64_Off)sizeof(Elf64_Ehdr), /* e_shoff */\n+        0, /* e_flags */\n+        (Elf64_Half)sizeof(Elf64_Ehdr), /* eh_size */\n+        0, /* e_phentsize */\n+        0, /* e_phnum */\n+        (Elf64_Half)sizeof(Elf64_Shdr), /* e_shentsize */\n+        5, /* e_shnum */\n+        2 /* e_shstrndx */\n+    };\n+\n+    /* 64-bit Elf section header table */\n+    static Elf64_Shdr sectionHeaders64[5]={\n+        { /* SHN_UNDEF */\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+        },\n+        { /* .symtab */\n+            1, /* sh_name */\n+            SHT_SYMTAB,\n+            0, /* sh_flags */\n+            0, /* sh_addr */\n+            (Elf64_Off)(sizeof(header64)+sizeof(sectionHeaders64)), /* sh_offset */\n+            (Elf64_Xword)(2*sizeof(Elf64_Sym)), /* sh_size */\n+            3, /* sh_link=sect hdr index of .strtab */\n+            1, /* sh_info=One greater than the symbol table index of the last\n+                * local symbol (with STB_LOCAL). */\n+            4, /* sh_addralign */\n+            (Elf64_Xword)(sizeof(Elf64_Sym)) /* sh_entsize */\n+        },\n+        { /* .shstrtab */\n+            9, /* sh_name */\n+            SHT_STRTAB,\n+            0, /* sh_flags */\n+            0, /* sh_addr */\n+            (Elf64_Off)(sizeof(header64)+sizeof(sectionHeaders64)+2*sizeof(Elf64_Sym)), /* sh_offset */\n+            40, /* sh_size */\n+            0, /* sh_link */\n+            0, /* sh_info */\n+            1, /* sh_addralign */\n+            0 /* sh_entsize */\n+        },\n+        { /* .strtab */\n+            19, /* sh_name */\n+            SHT_STRTAB,\n+            0, /* sh_flags */\n+            0, /* sh_addr */\n+            (Elf64_Off)(sizeof(header64)+sizeof(sectionHeaders64)+2*sizeof(Elf64_Sym)+40), /* sh_offset */\n+            (Elf64_Xword)sizeof(entry), /* sh_size */\n+            0, /* sh_link */\n+            0, /* sh_info */\n+            1, /* sh_addralign */\n+            0 /* sh_entsize */\n+        },\n+        { /* .rodata */\n+            27, /* sh_name */\n+            SHT_PROGBITS,\n+            SHF_ALLOC, /* sh_flags */\n+            0, /* sh_addr */\n+            (Elf64_Off)(sizeof(header64)+sizeof(sectionHeaders64)+2*sizeof(Elf64_Sym)+40+sizeof(entry)), /* sh_offset */\n+            0, /* sh_size */\n+            0, /* sh_link */\n+            0, /* sh_info */\n+            16, /* sh_addralign */\n+            0 /* sh_entsize */\n+        }\n+    };\n+\n+    /*\n+     * 64-bit symbol table\n+     * careful: different order of items compared with Elf32_sym!\n+     */\n+    static Elf64_Sym symbols64[2]={\n+        { /* STN_UNDEF */\n+            0, 0, 0, 0, 0, 0\n+        },\n+        { /* data entry point */\n+            1, /* st_name */\n+            ELF64_ST_INFO(STB_GLOBAL, STT_OBJECT),\n+            0, /* st_other */\n+            4, /* st_shndx=index of related section table entry */\n+            0, /* st_value */\n+            0 /* st_size */\n+        }\n+    };\n+\n+#endif /* U_ELF64 */\n+\n+    /* entry[] have a leading NUL */\n+    entryOffset=1;\n+\n+    /* in the common code, count entryLength from after the NUL */\n+    entryLengthOffset=1;\n+\n+    newSuffix=\".o\";\n+\n+#elif U_PLATFORM_HAS_WIN32_API\n+    struct {\n+        IMAGE_FILE_HEADER fileHeader;\n+        IMAGE_SECTION_HEADER sections[2];\n+        char linkerOptions[100];\n+    } objHeader;\n+    IMAGE_SYMBOL symbols[1];\n+    struct {\n+        DWORD sizeofLongNames;\n+        char longNames[100];\n+    } symbolNames;\n+\n+    /*\n+     * entry sometimes have a leading '_'\n+     * overwritten if entryOffset==0 depending on the target platform\n+     * see check for cpu below\n+     */\n+    entry[0]='_';\n+\n+    newSuffix=\".obj\";\n+#else\n+#   error \"Unknown platform for CAN_GENERATE_OBJECTS.\"\n+#endif\n+\n+    /* deal with options, files and the entry point name */\n+    getArchitecture(&cpu, &bits, &makeBigEndian, optMatchArch);\n+    if (optMatchArch)\n+    {\n+        printf(\"genccode: --match-arch cpu=%hu bits=%hu big-endian=%d\\n\", cpu, bits, makeBigEndian);\n+    }\n+    else\n+    {\n+        printf(\"genccode: using architecture cpu=%hu bits=%hu big-endian=%d\\n\", cpu, bits, makeBigEndian);\n+    }\n+#if U_PLATFORM_HAS_WIN32_API\n+    if(cpu==IMAGE_FILE_MACHINE_I386) {\n+        entryOffset=1;\n+    }\n+#endif\n+\n+    in=T_FileStream_open(filename, \"rb\");\n+    if(in==NULL) {\n+        fprintf(stderr, \"genccode: unable to open input file %s\\n\", filename);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+    size=T_FileStream_size(in);\n+\n+    getOutFilename(filename, destdir, buffer, entry+entryOffset, newSuffix, optFilename);\n+    if (outFilePath != NULL) {\n+        uprv_strcpy(outFilePath, buffer);\n+    }\n+\n+    if(optEntryPoint != NULL) {\n+        uprv_strcpy(entry+entryOffset, optEntryPoint);\n+        uprv_strcat(entry+entryOffset, \"_dat\");\n+    }\n+    /* turn dashes in the entry name into underscores */\n+    entryLength=(int32_t)uprv_strlen(entry+entryLengthOffset);\n+    for(i=0; i<entryLength; ++i) {\n+        if(entry[entryLengthOffset+i]=='-') {\n+            entry[entryLengthOffset+i]='_';\n+        }\n+    }\n+\n+    /* open the output file */\n+    out=T_FileStream_open(buffer, \"wb\");\n+    if(out==NULL) {\n+        fprintf(stderr, \"genccode: unable to open output file %s\\n\", buffer);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+\n+#ifdef U_ELF\n+    if(bits==32) {\n+        header32.e_ident[EI_DATA]= makeBigEndian ? ELFDATA2MSB : ELFDATA2LSB;\n+        header32.e_machine=cpu;\n+\n+        /* 16-align .rodata in the .o file, just in case */\n+        paddingSize=sectionHeaders32[4].sh_offset & 0xf;\n+        if(paddingSize!=0) {\n+                paddingSize=0x10-paddingSize;\n+                sectionHeaders32[4].sh_offset+=paddingSize;\n+        }\n+\n+        sectionHeaders32[4].sh_size=(Elf32_Word)size;\n+\n+        symbols32[1].st_size=(Elf32_Word)size;\n+\n+        /* write .o headers */\n+        T_FileStream_write(out, &header32, (int32_t)sizeof(header32));\n+        T_FileStream_write(out, sectionHeaders32, (int32_t)sizeof(sectionHeaders32));\n+        T_FileStream_write(out, symbols32, (int32_t)sizeof(symbols32));\n+    } else /* bits==64 */ {\n+#ifdef U_ELF64\n+        header64.e_ident[EI_DATA]= makeBigEndian ? ELFDATA2MSB : ELFDATA2LSB;\n+        header64.e_machine=cpu;\n+\n+        /* 16-align .rodata in the .o file, just in case */\n+        paddingSize=sectionHeaders64[4].sh_offset & 0xf;\n+        if(paddingSize!=0) {\n+                paddingSize=0x10-paddingSize;\n+                sectionHeaders64[4].sh_offset+=paddingSize;\n+        }\n+\n+        sectionHeaders64[4].sh_size=(Elf64_Xword)size;\n+\n+        symbols64[1].st_size=(Elf64_Xword)size;\n+\n+        /* write .o headers */\n+        T_FileStream_write(out, &header64, (int32_t)sizeof(header64));\n+        T_FileStream_write(out, sectionHeaders64, (int32_t)sizeof(sectionHeaders64));\n+        T_FileStream_write(out, symbols64, (int32_t)sizeof(symbols64));\n+#endif\n+    }\n+\n+    T_FileStream_write(out, sectionStrings, (int32_t)sizeof(sectionStrings));\n+    T_FileStream_write(out, entry, (int32_t)sizeof(entry));\n+    if(paddingSize!=0) {\n+        T_FileStream_write(out, padding, paddingSize);\n+    }\n+#elif U_PLATFORM_HAS_WIN32_API\n+    /* populate the .obj headers */\n+    uprv_memset(&objHeader, 0, sizeof(objHeader));\n+    uprv_memset(&symbols, 0, sizeof(symbols));\n+    uprv_memset(&symbolNames, 0, sizeof(symbolNames));\n+\n+    /* write the linker export directive */\n+    uprv_strcpy(objHeader.linkerOptions, \"-export:\");\n+    length=8;\n+    uprv_strcpy(objHeader.linkerOptions+length, entry);\n+    length+=entryLength;\n+    uprv_strcpy(objHeader.linkerOptions+length, \",data \");\n+    length+=6;\n+\n+    /* set the file header */\n+    objHeader.fileHeader.Machine=cpu;\n+    objHeader.fileHeader.NumberOfSections=2;\n+    objHeader.fileHeader.TimeDateStamp=(DWORD)time(NULL);\n+    objHeader.fileHeader.PointerToSymbolTable=IMAGE_SIZEOF_FILE_HEADER+2*IMAGE_SIZEOF_SECTION_HEADER+length+size; /* start of symbol table */\n+    objHeader.fileHeader.NumberOfSymbols=1;\n+\n+    /* set the section for the linker options */\n+    uprv_strncpy((char *)objHeader.sections[0].Name, \".drectve\", 8);\n+    objHeader.sections[0].SizeOfRawData=length;\n+    objHeader.sections[0].PointerToRawData=IMAGE_SIZEOF_FILE_HEADER+2*IMAGE_SIZEOF_SECTION_HEADER;\n+    objHeader.sections[0].Characteristics=IMAGE_SCN_LNK_INFO|IMAGE_SCN_LNK_REMOVE|IMAGE_SCN_ALIGN_1BYTES;\n+\n+    /* set the data section */\n+    uprv_strncpy((char *)objHeader.sections[1].Name, \".rdata\", 6);\n+    objHeader.sections[1].SizeOfRawData=size;\n+    objHeader.sections[1].PointerToRawData=IMAGE_SIZEOF_FILE_HEADER+2*IMAGE_SIZEOF_SECTION_HEADER+length;\n+    objHeader.sections[1].Characteristics=IMAGE_SCN_CNT_INITIALIZED_DATA|IMAGE_SCN_ALIGN_16BYTES|IMAGE_SCN_MEM_READ;\n+\n+    /* set the symbol table */\n+    if(entryLength<=8) {\n+        uprv_strncpy((char *)symbols[0].N.ShortName, entry, entryLength);\n+        symbolNames.sizeofLongNames=4;\n+    } else {\n+        symbols[0].N.Name.Short=0;\n+        symbols[0].N.Name.Long=4;\n+        symbolNames.sizeofLongNames=4+entryLength+1;\n+        uprv_strcpy(symbolNames.longNames, entry);\n+    }\n+    symbols[0].SectionNumber=2;\n+    symbols[0].StorageClass=IMAGE_SYM_CLASS_EXTERNAL;\n+\n+    /* write the file header and the linker options section */\n+    T_FileStream_write(out, &objHeader, objHeader.sections[1].PointerToRawData);\n+#else\n+#   error \"Unknown platform for CAN_GENERATE_OBJECTS.\"\n+#endif\n+\n+    /* copy the data file into section 2 */\n+    for(;;) {\n+        length=T_FileStream_read(in, buffer, sizeof(buffer));\n+        if(length==0) {\n+            break;\n+        }\n+        T_FileStream_write(out, buffer, (int32_t)length);\n+    }\n+\n+#if U_PLATFORM_HAS_WIN32_API\n+    /* write the symbol table */\n+    T_FileStream_write(out, symbols, IMAGE_SIZEOF_SYMBOL);\n+    T_FileStream_write(out, &symbolNames, symbolNames.sizeofLongNames);\n+#endif\n+\n+    if(T_FileStream_error(in)) {\n+        fprintf(stderr, \"genccode: file read error while generating from file %s\\n\", filename);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+\n+    if(T_FileStream_error(out)) {\n+        fprintf(stderr, \"genccode: file write error while generating from file %s\\n\", filename);\n+        exit(U_FILE_ACCESS_ERROR);\n+    }\n+\n+    T_FileStream_close(out);\n+    T_FileStream_close(in);\n+}\n+#endif"
        }
    ],
    "stats": {
        "total": 1221,
        "additions": 1221,
        "deletions": 0
    }
}