{
    "author": "addaleax",
    "message": "src: introduce native-layer stream piping\n\nProvide a way to create pipes between native `StreamBase` instances\nthat acts more directly than a `.pipe()` call would.\n\nPR-URL: https://github.com/nodejs/node/pull/18936\nReviewed-By: James M Snell <jasnell@gmail.com>\nReviewed-By: Matteo Collina <matteo.collina@gmail.com>",
    "sha": "67f1d76956a8a5da9875b113371c8786ad579086",
    "files": [
        {
            "sha": "1b047fe9ac52f296706aca86fa89c90d7c93fe57",
            "filename": "node.gyp",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/nodejs/node/blob/67f1d76956a8a5da9875b113371c8786ad579086/node.gyp",
            "raw_url": "https://github.com/nodejs/node/raw/67f1d76956a8a5da9875b113371c8786ad579086/node.gyp",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/node.gyp?ref=67f1d76956a8a5da9875b113371c8786ad579086",
            "patch": "@@ -338,6 +338,7 @@\n         'src/string_decoder.cc',\n         'src/string_search.cc',\n         'src/stream_base.cc',\n+        'src/stream_pipe.cc',\n         'src/stream_wrap.cc',\n         'src/tcp_wrap.cc',\n         'src/timer_wrap.cc',\n@@ -394,6 +395,7 @@\n         'src/string_decoder-inl.h',\n         'src/stream_base.h',\n         'src/stream_base-inl.h',\n+        'src/stream_pipe.h',\n         'src/stream_wrap.h',\n         'src/tracing/agent.h',\n         'src/tracing/node_trace_buffer.h',"
        },
        {
            "sha": "f0689d32f3c69f97b5ae9770919ee27929ce8d43",
            "filename": "src/async_wrap.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fasync_wrap.h",
            "raw_url": "https://github.com/nodejs/node/raw/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fasync_wrap.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fasync_wrap.h?ref=67f1d76956a8a5da9875b113371c8786ad579086",
            "patch": "@@ -58,6 +58,7 @@ namespace node {\n   V(SHUTDOWNWRAP)                                                             \\\n   V(SIGNALWRAP)                                                               \\\n   V(STATWATCHER)                                                              \\\n+  V(STREAMPIPE)                                                               \\\n   V(TCPCONNECTWRAP)                                                           \\\n   V(TCPSERVERWRAP)                                                            \\\n   V(TCPWRAP)                                                                  \\"
        },
        {
            "sha": "4fc6b31ffebd212eee12845e60317638f92801c2",
            "filename": "src/env.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/nodejs/node/blob/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fenv.h",
            "raw_url": "https://github.com/nodejs/node/raw/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fenv.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fenv.h?ref=67f1d76956a8a5da9875b113371c8786ad579086",
            "patch": "@@ -222,6 +222,7 @@ struct PackageConfig {\n   V(onstop_string, \"onstop\")                                                  \\\n   V(onstreamclose_string, \"onstreamclose\")                                    \\\n   V(ontrailers_string, \"ontrailers\")                                          \\\n+  V(onunpipe_string, \"onunpipe\")                                              \\\n   V(onwrite_string, \"onwrite\")                                                \\\n   V(openssl_error_stack, \"opensslErrorStack\")                                 \\\n   V(output_string, \"output\")                                                  \\\n@@ -233,6 +234,8 @@ struct PackageConfig {\n   V(pbkdf2_error_string, \"PBKDF2 Error\")                                      \\\n   V(pid_string, \"pid\")                                                        \\\n   V(pipe_string, \"pipe\")                                                      \\\n+  V(pipe_target_string, \"pipeTarget\")                                         \\\n+  V(pipe_source_string, \"pipeSource\")                                         \\\n   V(port_string, \"port\")                                                      \\\n   V(preference_string, \"preference\")                                          \\\n   V(priority_string, \"priority\")                                              \\\n@@ -255,9 +258,11 @@ struct PackageConfig {\n   V(session_id_string, \"sessionId\")                                           \\\n   V(shell_string, \"shell\")                                                    \\\n   V(signal_string, \"signal\")                                                  \\\n+  V(sink_string, \"sink\")                                                      \\\n   V(size_string, \"size\")                                                      \\\n   V(sni_context_err_string, \"Invalid SNI context\")                            \\\n   V(sni_context_string, \"sni_context\")                                        \\\n+  V(source_string, \"source\")                                                  \\\n   V(stack_string, \"stack\")                                                    \\\n   V(status_string, \"status\")                                                  \\\n   V(stdio_string, \"stdio\")                                                    \\"
        },
        {
            "sha": "d6df93cf3804a704b59fd76f37e160120cdce2db",
            "filename": "src/node_http2.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/nodejs/node/blob/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fnode_http2.cc",
            "raw_url": "https://github.com/nodejs/node/raw/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fnode_http2.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_http2.cc?ref=67f1d76956a8a5da9875b113371c8786ad579086",
            "patch": "@@ -1813,7 +1813,9 @@ inline void Http2Stream::Close(int32_t code) {\n }\n \n int Http2Stream::DoShutdown(ShutdownWrap* req_wrap) {\n-  CHECK(!this->IsDestroyed());\n+  if (IsDestroyed())\n+    return UV_EPIPE;\n+\n   {\n     Http2Scope h2scope(this);\n     flags_ |= NGHTTP2_STREAM_FLAG_SHUT;"
        },
        {
            "sha": "79c2ce553200f343ab76e998531283989724136f",
            "filename": "src/node_internals.h",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fnode_internals.h",
            "raw_url": "https://github.com/nodejs/node/raw/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fnode_internals.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fnode_internals.h?ref=67f1d76956a8a5da9875b113371c8786ad579086",
            "patch": "@@ -120,6 +120,7 @@ struct sockaddr;\n     V(serdes)                                                                 \\\n     V(signal_wrap)                                                            \\\n     V(spawn_sync)                                                             \\\n+    V(stream_pipe)                                                            \\\n     V(stream_wrap)                                                            \\\n     V(string_decoder)                                                         \\\n     V(tcp_wrap)                                                               \\"
        },
        {
            "sha": "7523b3a545355fc7d9930fa503df2d8f9f2700e9",
            "filename": "src/stream_base-inl.h",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/nodejs/node/blob/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fstream_base-inl.h",
            "raw_url": "https://github.com/nodejs/node/raw/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fstream_base-inl.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base-inl.h?ref=67f1d76956a8a5da9875b113371c8786ad579086",
            "patch": "@@ -67,8 +67,14 @@ inline void StreamListener::OnStreamAfterWrite(WriteWrap* w, int status) {\n \n inline StreamResource::~StreamResource() {\n   while (listener_ != nullptr) {\n-    listener_->OnStreamDestroy();\n-    RemoveStreamListener(listener_);\n+    StreamListener* listener = listener_;\n+    listener->OnStreamDestroy();\n+    // Remove the listener if it didn’t remove itself. This makes the logic\n+    // logic in `OnStreamDestroy()` implementations easier, because they\n+    // may call generic cleanup functions which can just remove the\n+    // listener unconditionally.\n+    if (listener == listener_)\n+      RemoveStreamListener(listener_);\n   }\n }\n "
        },
        {
            "sha": "7264824265a579d19e4f10e3bcf8d9c8a768198d",
            "filename": "src/stream_base.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/nodejs/node/blob/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fstream_base.h",
            "raw_url": "https://github.com/nodejs/node/raw/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fstream_base.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_base.h?ref=67f1d76956a8a5da9875b113371c8786ad579086",
            "patch": "@@ -141,6 +141,9 @@ class StreamListener {\n   // This is called immediately before the stream is destroyed.\n   virtual void OnStreamDestroy() {}\n \n+  // The stream this is currently associated with, or nullptr if there is none.\n+  inline StreamResource* stream() { return stream_; }\n+\n  protected:\n   // Pass along a read error to the `StreamListener` instance that was active\n   // before this one. For example, a protocol parser does not care about read"
        },
        {
            "sha": "8f0263cd9ae99b773c840e21cb1fc5978320478a",
            "filename": "src/stream_pipe.cc",
            "status": "added",
            "additions": 266,
            "deletions": 0,
            "changes": 266,
            "blob_url": "https://github.com/nodejs/node/blob/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fstream_pipe.cc",
            "raw_url": "https://github.com/nodejs/node/raw/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fstream_pipe.cc",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_pipe.cc?ref=67f1d76956a8a5da9875b113371c8786ad579086",
            "patch": "@@ -0,0 +1,266 @@\n+#include \"stream_pipe.h\"\n+#include \"stream_base-inl.h\"\n+#include \"node_buffer.h\"\n+#include \"node_internals.h\"\n+\n+using v8::Context;\n+using v8::External;\n+using v8::FunctionCallbackInfo;\n+using v8::FunctionTemplate;\n+using v8::Local;\n+using v8::Object;\n+using v8::Value;\n+\n+namespace node {\n+\n+StreamPipe::StreamPipe(StreamBase* source,\n+                       StreamBase* sink,\n+                       Local<Object> obj)\n+    : AsyncWrap(source->stream_env(), obj, AsyncWrap::PROVIDER_STREAMPIPE) {\n+  MakeWeak(this);\n+\n+  CHECK_NE(sink, nullptr);\n+  CHECK_NE(source, nullptr);\n+\n+  source->PushStreamListener(&readable_listener_);\n+  sink->PushStreamListener(&writable_listener_);\n+\n+  CHECK(sink->HasWantsWrite());\n+\n+  // Set up links between this object and the source/sink objects.\n+  // In particular, this makes sure that they are garbage collected as a group,\n+  // if that applies to the given streams (for example, Http2Streams use\n+  // weak references).\n+  obj->Set(env()->context(), env()->source_string(), source->GetObject())\n+      .FromJust();\n+  source->GetObject()->Set(env()->context(), env()->pipe_target_string(), obj)\n+      .FromJust();\n+  obj->Set(env()->context(), env()->sink_string(), sink->GetObject())\n+      .FromJust();\n+  sink->GetObject()->Set(env()->context(), env()->pipe_source_string(), obj)\n+      .FromJust();\n+}\n+\n+StreamPipe::~StreamPipe() {\n+  CHECK(is_closed_);\n+}\n+\n+StreamBase* StreamPipe::source() {\n+  return static_cast<StreamBase*>(readable_listener_.stream());\n+}\n+\n+StreamBase* StreamPipe::sink() {\n+  return static_cast<StreamBase*>(writable_listener_.stream());\n+}\n+\n+void StreamPipe::Unpipe() {\n+  if (is_closed_)\n+    return;\n+\n+  // Note that we cannot use virtual methods on `source` and `sink` here,\n+  // because this function can be called from their destructors via\n+  // `OnStreamDestroy()`.\n+\n+  is_closed_ = true;\n+  is_reading_ = false;\n+  source()->RemoveStreamListener(&readable_listener_);\n+  sink()->RemoveStreamListener(&writable_listener_);\n+\n+  // Delay the JS-facing part with SetImmediate, because this might be from\n+  // inside the garbage collector, so we can’t run JS here.\n+  HandleScope handle_scope(env()->isolate());\n+  env()->SetImmediate([](Environment* env, void* data) {\n+    StreamPipe* pipe = static_cast<StreamPipe*>(data);\n+\n+    HandleScope handle_scope(env->isolate());\n+    Context::Scope context_scope(env->context());\n+    Local<Object> object = pipe->object();\n+\n+    if (object->Has(env->context(), env->onunpipe_string()).FromJust()) {\n+      pipe->MakeCallback(env->onunpipe_string(), 0, nullptr).ToLocalChecked();\n+    }\n+\n+    // Set all the links established in the constructor to `null`.\n+    Local<Value> null = Null(env->isolate());\n+\n+    Local<Value> source_v;\n+    Local<Value> sink_v;\n+    source_v = object->Get(env->context(), env->source_string())\n+        .ToLocalChecked();\n+    sink_v = object->Get(env->context(), env->sink_string())\n+        .ToLocalChecked();\n+    CHECK(source_v->IsObject());\n+    CHECK(sink_v->IsObject());\n+\n+    object->Set(env->context(), env->source_string(), null).FromJust();\n+    object->Set(env->context(), env->sink_string(), null).FromJust();\n+    source_v.As<Object>()->Set(env->context(),\n+                               env->pipe_target_string(),\n+                               null).FromJust();\n+    sink_v.As<Object>()->Set(env->context(),\n+                             env->pipe_source_string(),\n+                             null).FromJust();\n+  }, static_cast<void*>(this), object());\n+}\n+\n+uv_buf_t StreamPipe::ReadableListener::OnStreamAlloc(size_t suggested_size) {\n+  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);\n+  size_t size = std::min(suggested_size, pipe->wanted_data_);\n+  CHECK_GT(size, 0);\n+  return uv_buf_init(Malloc(size), size);\n+}\n+\n+void StreamPipe::ReadableListener::OnStreamRead(ssize_t nread,\n+                                                const uv_buf_t& buf) {\n+  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);\n+  AsyncScope async_scope(pipe);\n+  if (nread < 0) {\n+    // EOF or error; stop reading and pass the error to the previous listener\n+    // (which might end up in JS).\n+    free(buf.base);\n+    pipe->is_eof_ = true;\n+    stream()->ReadStop();\n+    CHECK_NE(previous_listener_, nullptr);\n+    previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));\n+    // If we’re not writing, close now. Otherwise, we’ll do that in\n+    // `OnStreamAfterWrite()`.\n+    if (!pipe->is_writing_) {\n+      pipe->ShutdownWritable();\n+      pipe->Unpipe();\n+    }\n+    return;\n+  }\n+\n+  pipe->ProcessData(nread, buf);\n+}\n+\n+void StreamPipe::ProcessData(size_t nread, const uv_buf_t& buf) {\n+  uv_buf_t buffer = uv_buf_init(buf.base, nread);\n+  StreamWriteResult res = sink()->Write(&buffer, 1);\n+  if (!res.async) {\n+    free(buf.base);\n+    writable_listener_.OnStreamAfterWrite(nullptr, res.err);\n+  } else {\n+    is_writing_ = true;\n+    is_reading_ = false;\n+    res.wrap->SetAllocatedStorage(buf.base, buf.len);\n+    source()->ReadStop();\n+  }\n+}\n+\n+void StreamPipe::ShutdownWritable() {\n+  sink()->Shutdown();\n+}\n+\n+void StreamPipe::WritableListener::OnStreamAfterWrite(WriteWrap* w,\n+                                                      int status) {\n+  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);\n+  pipe->is_writing_ = false;\n+  if (pipe->is_eof_) {\n+    AsyncScope async_scope(pipe);\n+    pipe->ShutdownWritable();\n+    pipe->Unpipe();\n+    return;\n+  }\n+\n+  if (status != 0) {\n+    CHECK_NE(previous_listener_, nullptr);\n+    StreamListener* prev = previous_listener_;\n+    pipe->Unpipe();\n+    prev->OnStreamAfterWrite(w, status);\n+    return;\n+  }\n+}\n+\n+void StreamPipe::WritableListener::OnStreamAfterShutdown(ShutdownWrap* w,\n+                                                         int status) {\n+  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);\n+  CHECK_NE(previous_listener_, nullptr);\n+  StreamListener* prev = previous_listener_;\n+  pipe->Unpipe();\n+  prev->OnStreamAfterShutdown(w, status);\n+}\n+\n+void StreamPipe::ReadableListener::OnStreamDestroy() {\n+  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);\n+  if (!pipe->is_eof_) {\n+    OnStreamRead(UV_EPIPE, uv_buf_init(nullptr, 0));\n+  }\n+}\n+\n+void StreamPipe::WritableListener::OnStreamDestroy() {\n+  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);\n+  pipe->is_eof_ = true;\n+  pipe->Unpipe();\n+}\n+\n+void StreamPipe::WritableListener::OnStreamWantsWrite(size_t suggested_size) {\n+  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);\n+  pipe->wanted_data_ = suggested_size;\n+  if (pipe->is_reading_ || pipe->is_closed_)\n+    return;\n+  AsyncScope async_scope(pipe);\n+  pipe->is_reading_ = true;\n+  pipe->source()->ReadStart();\n+}\n+\n+uv_buf_t StreamPipe::WritableListener::OnStreamAlloc(size_t suggested_size) {\n+  CHECK_NE(previous_listener_, nullptr);\n+  return previous_listener_->OnStreamAlloc(suggested_size);\n+}\n+\n+void StreamPipe::WritableListener::OnStreamRead(ssize_t nread,\n+                                                const uv_buf_t& buf) {\n+  CHECK_NE(previous_listener_, nullptr);\n+  return previous_listener_->OnStreamRead(nread, buf);\n+}\n+\n+void StreamPipe::New(const FunctionCallbackInfo<Value>& args) {\n+  CHECK(args.IsConstructCall());\n+  CHECK(args[0]->IsExternal());\n+  CHECK(args[1]->IsExternal());\n+  auto source = static_cast<StreamBase*>(args[0].As<External>()->Value());\n+  auto sink = static_cast<StreamBase*>(args[1].As<External>()->Value());\n+\n+  new StreamPipe(source, sink, args.This());\n+}\n+\n+void StreamPipe::Start(const FunctionCallbackInfo<Value>& args) {\n+  StreamPipe* pipe;\n+  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());\n+  pipe->is_closed_ = false;\n+  if (pipe->wanted_data_ > 0)\n+    pipe->writable_listener_.OnStreamWantsWrite(pipe->wanted_data_);\n+}\n+\n+void StreamPipe::Unpipe(const FunctionCallbackInfo<Value>& args) {\n+  StreamPipe* pipe;\n+  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());\n+  pipe->Unpipe();\n+}\n+\n+namespace {\n+\n+void InitializeStreamPipe(Local<Object> target,\n+                          Local<Value> unused,\n+                          Local<Context> context) {\n+  Environment* env = Environment::GetCurrent(context);\n+\n+  // Create FunctionTemplate for FileHandle::CloseReq\n+  Local<FunctionTemplate> pipe = env->NewFunctionTemplate(StreamPipe::New);\n+  Local<String> stream_pipe_string =\n+      FIXED_ONE_BYTE_STRING(env->isolate(), \"StreamPipe\");\n+  env->SetProtoMethod(pipe, \"unpipe\", StreamPipe::Unpipe);\n+  env->SetProtoMethod(pipe, \"start\", StreamPipe::Start);\n+  AsyncWrap::AddWrapMethods(env, pipe);\n+  pipe->SetClassName(stream_pipe_string);\n+  pipe->InstanceTemplate()->SetInternalFieldCount(1);\n+  target->Set(context, stream_pipe_string, pipe->GetFunction()).FromJust();\n+}\n+\n+}  // anonymous namespace\n+\n+}  // namespace node\n+\n+NODE_MODULE_CONTEXT_AWARE_INTERNAL(stream_pipe,\n+                                   node::InitializeStreamPipe)"
        },
        {
            "sha": "98d6dae11be8419813082274ce184a2171d4cb6b",
            "filename": "src/stream_pipe.h",
            "status": "added",
            "additions": 68,
            "deletions": 0,
            "changes": 68,
            "blob_url": "https://github.com/nodejs/node/blob/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fstream_pipe.h",
            "raw_url": "https://github.com/nodejs/node/raw/67f1d76956a8a5da9875b113371c8786ad579086/src%2Fstream_pipe.h",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/src%2Fstream_pipe.h?ref=67f1d76956a8a5da9875b113371c8786ad579086",
            "patch": "@@ -0,0 +1,68 @@\n+#ifndef SRC_STREAM_PIPE_H_\n+#define SRC_STREAM_PIPE_H_\n+\n+#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS\n+\n+#include \"stream_base.h\"\n+\n+namespace node {\n+\n+class StreamPipe : public AsyncWrap {\n+ public:\n+  StreamPipe(StreamBase* source, StreamBase* sink, v8::Local<v8::Object> obj);\n+  ~StreamPipe();\n+\n+  void Unpipe();\n+\n+  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void Start(const v8::FunctionCallbackInfo<v8::Value>& args);\n+  static void Unpipe(const v8::FunctionCallbackInfo<v8::Value>& args);\n+\n+  size_t self_size() const override { return sizeof(*this); }\n+\n+ private:\n+  StreamBase* source();\n+  StreamBase* sink();\n+\n+  void ShutdownWritable();\n+  void FlushToWritable();\n+\n+  bool is_reading_ = false;\n+  bool is_writing_ = false;\n+  bool is_eof_ = false;\n+  bool is_closed_ = true;\n+\n+  // Set a default value so that when we’re coming from Start(), we know\n+  // that we don’t want to read just yet.\n+  // This will likely need to be changed when supporting streams without\n+  // `OnStreamWantsWrite()` support.\n+  size_t wanted_data_ = 0;\n+\n+  void ProcessData(size_t nread, const uv_buf_t& buf);\n+\n+  class ReadableListener : public StreamListener {\n+   public:\n+    uv_buf_t OnStreamAlloc(size_t suggested_size) override;\n+    void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;\n+    void OnStreamDestroy() override;\n+  };\n+\n+  class WritableListener : public StreamListener {\n+   public:\n+    uv_buf_t OnStreamAlloc(size_t suggested_size) override;\n+    void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;\n+    void OnStreamAfterWrite(WriteWrap* w, int status) override;\n+    void OnStreamAfterShutdown(ShutdownWrap* w, int status) override;\n+    void OnStreamWantsWrite(size_t suggested_size) override;\n+    void OnStreamDestroy() override;\n+  };\n+\n+  ReadableListener readable_listener_;\n+  WritableListener writable_listener_;\n+};\n+\n+}  // namespace node\n+\n+#endif\n+\n+#endif  // SRC_STREAM_PIPE_H_"
        },
        {
            "sha": "64c4fd5cd8ab507fe115fef6b8ec63e4c93ff8f3",
            "filename": "test/sequential/test-async-wrap-getasyncid.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/nodejs/node/blob/67f1d76956a8a5da9875b113371c8786ad579086/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "raw_url": "https://github.com/nodejs/node/raw/67f1d76956a8a5da9875b113371c8786ad579086/test%2Fsequential%2Ftest-async-wrap-getasyncid.js",
            "contents_url": "https://api.github.com/repos/nodejs/node/contents/test%2Fsequential%2Ftest-async-wrap-getasyncid.js?ref=67f1d76956a8a5da9875b113371c8786ad579086",
            "patch": "@@ -35,6 +35,7 @@ common.crashOnUnhandledRejection();\n     delete providers.HTTP2STREAM;\n     delete providers.HTTP2PING;\n     delete providers.HTTP2SETTINGS;\n+    delete providers.STREAMPIPE;\n \n     const objKeys = Object.keys(providers);\n     if (objKeys.length > 0)"
        }
    ],
    "stats": {
        "total": 361,
        "additions": 358,
        "deletions": 3
    }
}